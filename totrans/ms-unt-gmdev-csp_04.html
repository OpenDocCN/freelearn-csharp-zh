<html><head></head><body>
<div id="_idContainer021" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-28" class="calibre5"><a id="_idTextAnchor029" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Writing Clean and Modular C# Code for Unity Game Development</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Welcome to </span><a href="B22017_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.4.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.5.1">, where we focus on the importance of clean and modular C# code for Unity game development. </span><span class="kobospan" id="kobo.5.2">In the next pages, you’ll learn practical skills to write clear and efficient code. </span><span class="kobospan" id="kobo.5.3">We’ll cover clean code principles, stress the significance of readability, and introduce industry best practices. </span><span class="kobospan" id="kobo.5.4">You’ll also explore conventions and code structuring for smoother collaboration. </span><span class="kobospan" id="kobo.5.5">Additionally, we’ll delve into refactoring and optimization techniques to enhance your C# code’s performance and scalability. </span><span class="kobospan" id="kobo.5.6">By the end of this chapter, you’ll have the expertise to write, document, refactor, and optimize C# code effectively, laying a solid foundation for successful Unity </span><span><span class="kobospan" id="kobo.6.1">game development.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span><span class="kobospan" id="kobo.8.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Introduction to writing </span><span><span class="kobospan" id="kobo.10.1">clean code</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">C# code conventions </span><span><span class="kobospan" id="kobo.12.1">and readability</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">C# code refactoring and </span><span><span class="kobospan" id="kobo.14.1">optimization techniques</span></span></li>
</ul>
<h1 id="_idParaDest-29" class="calibre5"><a id="_idTextAnchor030" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.15.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">You will need the following to follow along with me in </span><span><span class="kobospan" id="kobo.17.1">this chapter:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.18.1">Unity version 2022.3.13</span></strong><span class="kobospan" id="kobo.19.1">: Download and install Unity version 2022.3.13 or any other version. </span><span class="kobospan" id="kobo.19.2">It is recommended to install the </span><span><span class="kobospan" id="kobo.20.1">2022 version.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.21.1">Primary IDE – Visual Studio 2022</span></strong><span class="kobospan" id="kobo.22.1">: Ensure Visual Studio 2022 is installed for </span><span><span class="kobospan" id="kobo.23.1">optimal learning.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.24.1">GitHub repository for code samples</span></strong><span class="kobospan" id="kobo.25.1">: Access the code samples and project files of this chapter from our GitHub repository: </span><a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.26.1">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002</span></a><span class="kobospan" id="kobo.27.1">. </span><span class="kobospan" id="kobo.27.2">Clone or download the repository to have easy access to the code demonstrated in </span><span><span class="kobospan" id="kobo.28.1">this chapter.</span></span></li>
</ul>
<h1 id="_idParaDest-30" class="calibre5"><a id="_idTextAnchor031" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.29.1">Introduction to writing clean code</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">Clean code </span><a id="_idIndexMarker048" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.31.1">refers to well-organized, readable, and easy-to-understand code. </span><span class="kobospan" id="kobo.31.2">It’s like writing a clear story that anyone can follow without getting lost in confusing jargon or </span><span><span class="kobospan" id="kobo.32.1">messy paragraphs.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.33.1">In software</span><a id="_idIndexMarker049" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.34.1"> development, clean code matters a lot. </span><span class="kobospan" id="kobo.34.2">First, it makes the code easier for everyone in the team to grasp, helping them work together smoothly. </span><span class="kobospan" id="kobo.34.3">Second, it saves time because clean code is simpler to fix when something goes wrong. </span><span class="kobospan" id="kobo.34.4">Lastly, it’s like having a clean room – it just feels better and is easier to manage in the long run. </span><span class="kobospan" id="kobo.34.5">In this list, we highlight the significance of employing </span><span><span class="kobospan" id="kobo.35.1">clean code</span><a id="_idTextAnchor032" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.36.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.37.1">Building AAA games</span></strong><span class="kobospan" id="kobo.38.1">: Have you come across “the power of clean code” on your coding journey? </span><span class="kobospan" id="kobo.38.2">Well, it’s like the secret sauce for cooking up high-quality code, especially when you’re aiming to create top-notch AAA games. </span><span class="kobospan" id="kobo.38.3">Clean code is the key ingredient for building games that stand out in </span><span><span class="kobospan" id="kobo.39.1">the industry.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.40.1">Working with others</span></strong><span class="kobospan" id="kobo.41.1">: In the world of coding, we’re never alone. </span><span class="kobospan" id="kobo.41.2">Whether you’re part of a company with high standards or collaborating on a project, the clean code mentality is your silent companion. </span><span class="kobospan" id="kobo.41.3">You might not realize you’re using it, but with a bit of knowledge, you can rock the industry by making your code clear and understandable for everyone on </span><span><span class="kobospan" id="kobo.42.1">the team.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.43.1">Flexibility in applying clean code</span></strong><span class="kobospan" id="kobo.44.1">: The goal of this chapter isn’t to force you to use all these clean code principles every single time. </span><span class="kobospan" id="kobo.44.2">Sometimes you need to dive into coding first and then tidy up later. </span><span class="kobospan" id="kobo.44.3">These aren’t strict rules; they’re more like tools you can pull out when needed. </span><span class="kobospan" id="kobo.44.4">If a feature is familiar, and you know how to implement it with principles such as SOLID, go for it. </span><span class="kobospan" id="kobo.44.5">But if you’re unsure, start with the basics and refine your code so you gain a clearer picture of </span><span><span class="kobospan" id="kobo.45.1">what’s needed.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.46.1">Every coder’s struggle</span></strong><span class="kobospan" id="kobo.47.1">: Picture this: you’re tired of the endless coding and updates, facing issues as you go. </span><span class="kobospan" id="kobo.47.2">Changing a feature becomes a headache, especially when the code turns into a messy puzzle. </span><span class="kobospan" id="kobo.47.3">Dealing with testers feels like a never-ending loop of modifications. </span><span class="kobospan" id="kobo.47.4">If this sounds familiar, you’re not alone. </span><span class="kobospan" id="kobo.47.5">This chapter is your guide to overcoming the struggles of code maintenance </span><span><span class="kobospan" id="kobo.48.1">and updates.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.49.1">Code that tells a story</span></strong><span class="kobospan" id="kobo.50.1">: Ever written a piece of code and then completely forgotten what it was for? </span><span class="kobospan" id="kobo.50.2">It happens to the best of us. </span><span class="kobospan" id="kobo.50.3">This chapter is here to teach you how to write code that tells a story – a story that’s clear and easy to follow and won’t leave you scratching your </span><span><span class="kobospan" id="kobo.51.1">head later.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.52.1">Modularity and efficiency tips</span></strong><span class="kobospan" id="kobo.53.1">: Get ready for some tips and tricks on how to make your </span><a id="_idIndexMarker050" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.54.1">code modular and efficient. </span><span class="kobospan" id="kobo.54.2">I’ll walk you through general principles and show you how to apply them in real-world scenarios. </span><span class="kobospan" id="kobo.54.3">Plus, we’ll dive into examples – messy code versus clean code – for each clean code principle, giving you a practical understanding of how to implement these ideas in your </span><span><span class="kobospan" id="kobo.55.1">own projects.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.56.1">Clean code is essential for building better software. </span><span class="kobospan" id="kobo.56.2">By understanding its importance, you’ll be better equipped to write code that’s clear, understandable, and effective. </span><span class="kobospan" id="kobo.56.3">In the next section, we will understand the principles of writing </span><span><span class="kobospan" id="kobo.57.1">clean code.</span></span></p>
<h1 id="_idParaDest-31" class="calibre5"><a id="_idTextAnchor033" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.58.1">Principles of writing clean code</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.59.1">In the </span><a id="_idIndexMarker051" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.60.1">world of </span><strong class="bold"><span class="kobospan" id="kobo.61.1">object-oriented programming</span></strong><span class="kobospan" id="kobo.62.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.63.1">OOP</span></strong><span class="kobospan" id="kobo.64.1">), clean</span><a id="_idIndexMarker052" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.65.1"> code thrives on a foundation of five key principles </span><a id="_idIndexMarker053" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.66.1">known as </span><strong class="bold"><span class="kobospan" id="kobo.67.1">SOLID</span></strong><span class="kobospan" id="kobo.68.1">. </span><span class="kobospan" id="kobo.68.2">These principles act as guiding lights, helping us write code that’s not just functional but also </span><span><span class="kobospan" id="kobo.69.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.70.1">Easy to read and understand</span></strong><span class="kobospan" id="kobo.71.1">: Anyone who picks up your code should be able to grasp its purpose and logic without too </span><span><span class="kobospan" id="kobo.72.1">much effort</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.73.1">Maintainable</span></strong><span class="kobospan" id="kobo.74.1">: Modifications and updates should be a breeze, even for someone unfamiliar with the </span><span><span class="kobospan" id="kobo.75.1">code’s history</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.76.1">Extendable and reusable</span></strong><span class="kobospan" id="kobo.77.1">: Building on existing code should be straightforward, promoting code reuse and </span><span><span class="kobospan" id="kobo.78.1">reducing redundancy</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.79.1">Let me tell you a story. </span><span class="kobospan" id="kobo.79.2">Before</span><a id="_idIndexMarker054" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.80.1"> I discovered SOLID principles, I often found myself struggling to figure out how to build features. </span><span class="kobospan" id="kobo.80.2">Reaching the finish line felt like a messy, chaotic journey. </span><span class="kobospan" id="kobo.80.3">Then, SOLID came along and changed everything. </span><span class="kobospan" id="kobo.80.4">It was like a map, helping me organize my thoughts and code into a clear, </span><span><span class="kobospan" id="kobo.81.1">structured path.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.82.1">But SOLID wasn’t just a clean code tool; it empowered me to become a better problem solver. </span><span class="kobospan" id="kobo.82.2">It shifted my mindset from a “try hard” approach to a “create solutions” approach. </span><span class="kobospan" id="kobo.82.3">I went from someone who wrestled with code to someone who crafted </span><span><span class="kobospan" id="kobo.83.1">elegant solutions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.84.1">As software developers, our job is to solve problems. </span><span class="kobospan" id="kobo.84.2">SOLID becomes your secret weapon in this battle. </span><span class="kobospan" id="kobo.84.3">It provides the framework to tackle most challenges </span><span><span class="kobospan" id="kobo.85.1">you’ll encounter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.86.1">However, simply reading about SOLID isn’t enough. </span><span class="kobospan" id="kobo.86.2">True learning comes from applying it yourself. </span><span class="kobospan" id="kobo.86.3">Grab your existing code and dive in! </span><span class="kobospan" id="kobo.86.4">Experiment with incorporating SOLID principles and see how they transform your work. </span><span class="kobospan" id="kobo.86.5">Trust me, the hands-on experience will solidify your understanding and unlock a whole new level of </span><span><span class="kobospan" id="kobo.87.1">development mastery.</span></span></p>
<h2 id="_idParaDest-32" class="calibre7"><a id="_idTextAnchor034" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.88.1">Single Responsibility Principle (SRP)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.89.1">Let’s </span><a id="_idIndexMarker055" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.90.1">discuss the </span><strong class="bold"><span class="kobospan" id="kobo.91.1">Single Responsibility Principle</span></strong><span class="kobospan" id="kobo.92.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.93.1">SRP</span></strong><span class="kobospan" id="kobo.94.1">) in the context of game development. </span><span class="kobospan" id="kobo.94.2">The </span><a id="_idIndexMarker056" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.95.1">SRP suggests that a class should have only one reason to change, meaning it should only have one responsibility. </span><span class="kobospan" id="kobo.95.2">In the gaming world, this translates to ensuring that each component or class is responsible for a single aspect of the game, making the code base more modular </span><span><span class="kobospan" id="kobo.96.1">and maintainable.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.97.1">When we begin coding, it’s common to stuff all the logic into one massive class that takes on many jobs. </span><span class="kobospan" id="kobo.97.2">It gets tricky trying to fix one issue without messing up other things in that class or introducing new logic that ends up making other sections </span><span><span class="kobospan" id="kobo.98.1">act strangely.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.99.1">Let’s start with an example of a player controller script that combines various responsibilities and then refactor it to adhere to </span><span><span class="kobospan" id="kobo.100.1">the SRP.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.101.1">In the following code block, we can see the old </span><strong class="source-inline"><span class="kobospan" id="kobo.102.1">PlayerController</span></strong><span class="kobospan" id="kobo.103.1"> class, which has </span><span><span class="kobospan" id="kobo.104.1">many responsibilities:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.105.1">
public class PlayerController : MonoBehaviour
{
    private Animator playerAnimator;
    private RigidBody rigidBody;
    private void Start()
    {
        playerAnimator = GetComponent&lt;Animator&gt;();
        rigidBody = GetComponent&lt;RigidBody&gt;();
    }
    private void Update()
    {
        // Logic for handling animations
        playerAnimator.SetBool("IsRunning",playerInput.IsRunning());
        // Logic for handling player input
        if (Input.GetKeyDown(KeyCode.Space))
        {
            rigidBody.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
        }
        // Logic for handling player movement
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.106.1">Let’s </span><a id="_idIndexMarker057" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.107.1">break down the big class into smaller classes, each with its own set </span><span><span class="kobospan" id="kobo.108.1">of actions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.109.1">In the following</span><a id="_idIndexMarker058" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.110.1"> code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.111.1">PlayerAnimation</span></strong><span class="kobospan" id="kobo.112.1"> class, which is responsible for handling </span><span><span class="kobospan" id="kobo.113.1">player animations:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.114.1">
public class PlayerAnimation : MonoBehaviour
{
    private Animator animator;
    private void Start()
    {
        animator = GetComponent&lt;Animator&gt;();
    }
    public void UpdateAnimation(bool isRunning)
    {
        animator.SetBool("IsRunning", isRunning);
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.115.1">In the following code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.116.1">PlayerMovement</span></strong><span class="kobospan" id="kobo.117.1"> class, which is responsible for handling player movement, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.118.1">PlayerInput</span></strong><span class="kobospan" id="kobo.119.1"> class, which is responsible for handling </span><span><span class="kobospan" id="kobo.120.1">player input:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.121.1">
public class PlayerMovement : MonoBehaviour
{
    public void Move(float horizontalInput)
    {
        // Logic for moving the player based on input
    }
     public void Jump()
    {
        // Logic for jumping the player based on input
    }
}
public class PlayerInput : MonoBehaviour
{
    public float HorizontalInput()
    {
        return Input.GetAxisRaw("Horizontal");
    }
    public bool IsJumping()
    {
        // Logic for determining if the player is jumping
        return Input.GetKeyDown(KeyCode.Space);
    }
    public bool IsRunning()
    {
        // Logic for determining if the player is running
        return Input.GetKey(KeyCode.LeftShift);
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.122.1">In the following</span><a id="_idIndexMarker059" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.123.1"> code block, we can see</span><a id="_idIndexMarker060" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.124.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.125.1">PlayerController</span></strong><span class="kobospan" id="kobo.126.1"> class acting as the orchestrator, </span><span><span class="kobospan" id="kobo.127.1">delegating responsibilities:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.128.1">
public class PlayerController : MonoBehaviour
{
    private PlayerAnimation playerAnimation;
    private PlayerInput playerInput;
    private PlayerMovement playerMovement;
    private void Start()
    {
        playerAnimation = GetComponent&lt;PlayerAnimation&gt;();
        playerInput = GetComponent&lt;PlayerInput&gt;();
        playerMovement = GetComponent&lt;PlayerMovement&gt;();
    }
    private void Update()
    {
        playerMovement.Move(playerInput.HorizontalInput());
        if (playerAnimation != null)
        {
            playerAnimation.UpdateAnimation(playerInput.IsRunning());
        }
        if (playerInput.IsJumping())
        {
            playerMovement.Jump();
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.129.1">In this </span><a id="_idIndexMarker061" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.130.1">simplified version of the </span><strong class="source-inline"><span class="kobospan" id="kobo.131.1">PlayerController</span></strong><span class="kobospan" id="kobo.132.1"> class, we have separate classes for movement, input handling, and </span><a id="_idIndexMarker062" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.133.1">animations, making </span><strong class="source-inline"><span class="kobospan" id="kobo.134.1">PlayerController</span></strong><span class="kobospan" id="kobo.135.1"> more focused and adhering to the SRP. </span><span class="kobospan" id="kobo.135.2">Each class handles its specific responsibility, enhancing code organization </span><span><span class="kobospan" id="kobo.136.1">and clarity.</span></span></p>
<h2 id="_idParaDest-33" class="calibre7"><a id="_idTextAnchor035" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.137.1">Open-Closed Principle (OCP)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.138.1">Let’s </span><a id="_idIndexMarker063" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.139.1">explore the </span><strong class="bold"><span class="kobospan" id="kobo.140.1">Open-Closed Principle</span></strong><span class="kobospan" id="kobo.141.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.142.1">OCP</span></strong><span class="kobospan" id="kobo.143.1">) in the context of game development. </span><span class="kobospan" id="kobo.143.2">The OCP promotes the idea that a class should be </span><a id="_idIndexMarker064" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.144.1">open for extension while remaining closed for modification. </span><span class="kobospan" id="kobo.144.2">In the context of game development, this implies the ability to introduce new features or functionalities without making changes to the existing code. </span><span class="kobospan" id="kobo.144.3">This principle plays a crucial role in enhancing code flexibility and maintainability, allowing for the seamless addition of new elements to the game without disrupting the </span><span><span class="kobospan" id="kobo.145.1">established framework.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.146.1">An example of the </span><em class="italic"><span class="kobospan" id="kobo.147.1">power-up dilemma</span></em><span class="kobospan" id="kobo.148.1"> is </span><span><span class="kobospan" id="kobo.149.1">as follows.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.150.1">Imagine you have a basic power-up system in your game that grants bonus points. </span><span class="kobospan" id="kobo.150.2">Using the OCP, you can create a base </span><strong class="source-inline"><span class="kobospan" id="kobo.151.1">PowerUp</span></strong><span class="kobospan" id="kobo.152.1"> class with common functionalities such as activation and duration. </span><span class="kobospan" id="kobo.152.2">Then, you can create subclasses for different specific power-ups, such as double jump or </span><span><span class="kobospan" id="kobo.153.1">temporary invincibility.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.154.1">This way, adding a new power-up involves creating a new subclass without modifying the existing code. </span><span class="kobospan" id="kobo.154.2">You’re not stuck with a rigid system – the possibilities </span><span><span class="kobospan" id="kobo.155.1">are endless!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.156.1">OCP allows you to </span><a id="_idIndexMarker065" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.157.1">build games that are flexible, adaptable, and maintainable. </span><span class="kobospan" id="kobo.157.2">It’s like having a well-designed construction set, letting you create and expand your game world </span><span><span class="kobospan" id="kobo.158.1">without limits.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.159.1">In the following </span><a id="_idIndexMarker066" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.160.1">code block, we can see the base </span><strong class="source-inline"><span class="kobospan" id="kobo.161.1">PowerUp</span></strong><span class="kobospan" id="kobo.162.1"> class with </span><span><span class="kobospan" id="kobo.163.1">common functionalities:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.164.1">
public abstract class PowerUp
{
    public abstract void Activate(); // Common activation logic
    public abstract void Deactivate(); // Common deactivation logic
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.165.1">In the following code block, we can see the subclass </span><span><span class="kobospan" id="kobo.166.1">for </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">DoubleJumpPowerUp</span></strong></span><span><span class="kobospan" id="kobo.168.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.169.1">
public class DoubleJumpPowerUp : PowerUp
{
    public override void Activate()
    {
        // Specific activation logic for double jump
    }
    public override void Deactivate()
    {
        // Specific deactivation logic for double jump
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.170.1">In the following code block, we can see the subclass </span><span><span class="kobospan" id="kobo.171.1">for </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.172.1">TemporaryInvincibilityPowerUp</span></strong></span><span><span class="kobospan" id="kobo.173.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.174.1">
public class TemporaryInvincibilityPowerUp : PowerUp
{
    public override void Activate()
    {
        // Specific activation logic for temporary invincibility
    }
    public override void Deactivate()
    {
        // Specific deactivation logic for temporary invincibility
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.175.1">In </span><a id="_idIndexMarker067" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.176.1">the </span><a id="_idIndexMarker068" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.177.1">following code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.178.1">PowerUpManager</span></strong><span class="kobospan" id="kobo.179.1"> class utilizing </span><span><span class="kobospan" id="kobo.180.1">the power-ups:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.181.1">
public class PowerUpManager : MonoBehaviour
{
    private void Start()
    {
        // Example of using the power-up system
        PowerUp doubleJump = new DoubleJumpPowerUp();
        AddPowerUp(doubleJump);
        PowerUp invincibility = new TemporaryInvincibilityPowerUp();
        AddPowerUp(invincibility);
    }
    private void AddPowerUp(PowerUp powerUp)
    {
        powerUp.Activate();
        // Logic for adding power-up to the game
    }
    private void RemovePowerUp(PowerUp powerUp)
    {
        powerUp.Deactivate();
        // Logic for removing power-up from the game
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.182.1">In this </span><a id="_idIndexMarker069" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.183.1">Unity example, the </span><strong class="source-inline"><span class="kobospan" id="kobo.184.1">PowerUp</span></strong><span class="kobospan" id="kobo.185.1"> class is extended with specific power-ups, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">DoubleJumpPowerUp</span></strong><span class="kobospan" id="kobo.187.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.188.1">TemporaryInvincibilityPowerUp</span></strong><span class="kobospan" id="kobo.189.1">. </span><span><span class="kobospan" id="kobo.190.1">The </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.191.1">PowerUp</span></strong></span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">
Manager</span></strong><span class="kobospan" id="kobo.193.1"> class demonstrates how to add and remove power-ups, and each power-up logs a message upon activation and deactivation. </span><span class="kobospan" id="kobo.193.2">This structure allows for the addition of new power-ups without modifying the existing code, following </span><span><span class="kobospan" id="kobo.194.1">the OCP.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.195.1">Now, the</span><a id="_idIndexMarker070" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.196.1"> fun part begins! </span><span class="kobospan" id="kobo.196.2">We can use this system to connect each power-up subclass to its own prefab. </span><span class="kobospan" id="kobo.196.3">When the player grabs a power-up, only the specific power-up associated with that prefab activates. </span><span class="kobospan" id="kobo.196.4">This means adding new power-ups is a breeze – just create a new subclass and its prefab and voilà! </span><span class="kobospan" id="kobo.196.5">You’ve expanded your game’s possibilities without touching the core logic. </span><span class="kobospan" id="kobo.196.6">This principle isn’t just for power-ups, though. </span><span class="kobospan" id="kobo.196.7">You can use it for enemies, items, abilities – the sky’s the limit! </span><span class="kobospan" id="kobo.196.8">So, go forth and build your awesome game with the power of </span><span><span class="kobospan" id="kobo.197.1">the OCP!</span></span></p>
<h2 id="_idParaDest-34" class="calibre7"><a id="_idTextAnchor036" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.198.1">Liskov Substitution Principle (LSP)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.199.1">Let’s </span><a id="_idIndexMarker071" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.200.1">explore the </span><strong class="bold"><span class="kobospan" id="kobo.201.1">Liskov Substitution Principle</span></strong><span class="kobospan" id="kobo.202.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.203.1">LSP</span></strong><span class="kobospan" id="kobo.204.1">) within the realm of game development. </span><span class="kobospan" id="kobo.204.2">The LSP</span><a id="_idIndexMarker072" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.205.1"> maintains that substituting objects of a superclass with objects of a subclass should not disrupt the program’s correctness. </span><span class="kobospan" id="kobo.205.2">In the context of game development, this implies that using derived classes (subclasses) should seamlessly integrate without compromising the expected functionality of the base class. </span><span class="kobospan" id="kobo.205.3">This principle ensures the smooth interchangeability of classes, allowing for flexibility and ease of use in game </span><span><span class="kobospan" id="kobo.206.1">development scenarios.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.207.1"> An example of the </span><em class="italic"><span class="kobospan" id="kobo.208.1">sneaky enemy dilemma</span></em><span class="kobospan" id="kobo.209.1"> is </span><span><span class="kobospan" id="kobo.210.1">as follows.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.211.1">Imagine you have a base class called </span><strong class="source-inline"><span class="kobospan" id="kobo.212.1">Enemy</span></strong><span class="kobospan" id="kobo.213.1"> with basic movement and attack behaviors. </span><span class="kobospan" id="kobo.213.2">You then create two subclasses: </span><strong class="source-inline"><span class="kobospan" id="kobo.214.1">GroundEnemy</span></strong><span class="kobospan" id="kobo.215.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.216.1">FlyingEnemy</span></strong><span class="kobospan" id="kobo.217.1">. </span><span class="kobospan" id="kobo.217.2">The LSP ensures that both subclasses behave as expected enemies, moving and attacking in ways that comply with the </span><strong class="source-inline"><span class="kobospan" id="kobo.218.1">Enemy</span></strong><span class="kobospan" id="kobo.219.1"> base class’s definition. </span><span class="kobospan" id="kobo.219.2">This means that any code designed to work with enemies, such as collision detection or damage calculation, will work seamlessly with both </span><strong class="source-inline"><span class="kobospan" id="kobo.220.1">GroundEnemy</span></strong><span class="kobospan" id="kobo.221.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.222.1">FlyingEnemy</span></strong><span class="kobospan" id="kobo.223.1"> instances. </span><span class="kobospan" id="kobo.223.2">This consistency simplifies development and allows you to focus on creating unique behaviors for each subclass without worrying about breaking </span><span><span class="kobospan" id="kobo.224.1">core functionalities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.225.1">In the following code block, we can see the base class </span><span><span class="kobospan" id="kobo.226.1">for </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.227.1">Enemy</span></strong></span><span><span class="kobospan" id="kobo.228.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.229.1">
public class Enemy : MonoBehaviour
{
    public virtual void Move()
    {// Basic movement logic for all enemies
    }
    public virtual void Attack()
    {// Basic attack logic for all enemies
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.230.1">In the following code block, we can see the subclass </span><span><span class="kobospan" id="kobo.231.1">for </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.232.1">GroundEnemy</span></strong></span><span><span class="kobospan" id="kobo.233.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.234.1">
public class GroundEnemy : Enemy
{
    public override void Move()
    {// Specific movement logic for ground enemies
    }
    public override void Attack()
    {// Specific attack logic for ground enemies
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.235.1">In the </span><a id="_idIndexMarker073" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.236.1">following code block, we can see the </span><a id="_idIndexMarker074" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.237.1">subclass </span><span><span class="kobospan" id="kobo.238.1">for </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.239.1">FlyingEnemy</span></strong></span><span><span class="kobospan" id="kobo.240.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.241.1">
public class FlyingEnemy : Enemy
{
    public override void Move()
    {// Specific movement logic for flying enemies
    }
    public override void Attack()
    {// Specific attack logic for flying enemies
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.242.1">In the following code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.243.1">EnemyManager</span></strong><span class="kobospan" id="kobo.244.1"> class demonstrating </span><span><span class="kobospan" id="kobo.245.1">the LSP:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.246.1">
public class EnemyManager : MonoBehaviour
{
    void Start()
    {
        // Creating instances of GroundEnemy and FlyingEnemy
        Enemy groundEnemy = new GroundEnemy();
        Enemy flyingEnemy = new FlyingEnemy();
        // Using LSP, treating both enemies as base class
        groundEnemy.Move();
        groundEnemy.Attack();
        flyingEnemy.Move();
        flyingEnemy.Attack();
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.247.1">In this </span><a id="_idIndexMarker075" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.248.1">Unity example, the </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">Enemy</span></strong><span class="kobospan" id="kobo.250.1"> class </span><a id="_idIndexMarker076" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.251.1">acts as the base class with basic movement and attack methods. </span><span class="kobospan" id="kobo.251.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.252.1">GroundEnemy</span></strong><span class="kobospan" id="kobo.253.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.254.1">FlyingEnemy</span></strong><span class="kobospan" id="kobo.255.1"> subclasses extend the base class and provide specific implementations for movement and attack. </span><span class="kobospan" id="kobo.255.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">EnemyManager</span></strong><span class="kobospan" id="kobo.257.1"> class demonstrates the LSP by treating instances of both subclasses as instances of the base class, ensuring that code written to work with enemies functions seamlessly with both </span><strong class="source-inline"><span class="kobospan" id="kobo.258.1">GroundEnemy</span></strong><span class="kobospan" id="kobo.259.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">FlyingEnemy</span></strong></span><span><span class="kobospan" id="kobo.261.1"> instances.</span></span></p>
<h2 id="_idParaDest-35" class="calibre7"><a id="_idTextAnchor037" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.262.1">What is the difference between the LSP and OCP?</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.263.1">In game </span><a id="_idIndexMarker077" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.264.1">development, the key difference between the LSP and OCP lies in their focus </span><span><span class="kobospan" id="kobo.265.1">and application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.266.1">The LSP </span><a id="_idIndexMarker078" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.267.1">ensures that derived classes can be seamlessly substituted for their base class without affecting program behavior. </span><span class="kobospan" id="kobo.267.2">In a game, this means different types of enemies (e.g., ground and flying enemies) should be interchangeable without breaking the </span><span><span class="kobospan" id="kobo.268.1">expected functionality.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.269.1">The OCP encourages designing classes that are open for extension but closed for modification. </span><span class="kobospan" id="kobo.269.2">In game development, this allows adding new features (e.g., new types of weapons) without altering existing code, promoting flexibility </span><span><span class="kobospan" id="kobo.270.1">and maintainability.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.271.1">To better illustrate their difference, here’s an example. </span><span class="kobospan" id="kobo.271.2">In a game system, consider a base class for weapons. </span><span class="kobospan" id="kobo.271.3">Adhering to the LSP allows substituting specific weapon types without disrupting expected behaviors, while following the OCP enables extending the system to add new weapons without modifying </span><span><span class="kobospan" id="kobo.272.1">existing code.</span></span></p>
<h2 id="_idParaDest-36" class="calibre7"><a id="_idTextAnchor038" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.273.1">Interface Segregation Principle (ISP)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.274.1">Now, let’s talk about </span><a id="_idIndexMarker079" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.275.1">the </span><strong class="bold"><span class="kobospan" id="kobo.276.1">Interface Segregation Principle</span></strong><span class="kobospan" id="kobo.277.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.278.1">ISP</span></strong><span class="kobospan" id="kobo.279.1">) in the gaming world. </span><span class="kobospan" id="kobo.279.2">The ISP suggests that a class shouldn’t be required to do things it doesn’t need to. </span><span class="kobospan" id="kobo.279.3">Simply put, it encourages creating </span><a id="_idIndexMarker080" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.280.1">small, task-specific interfaces instead of big, general ones. </span><span class="kobospan" id="kobo.280.2">In the context of game development, this means designing interfaces that suit each class’s specific needs. </span><span class="kobospan" id="kobo.280.3">This helps keep things clear, makes the code more focused, and allows for easier upkeep and changes in </span><span><span class="kobospan" id="kobo.281.1">game development.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.282.1">Let’s see an example of the NPC </span><span><span class="kobospan" id="kobo.283.1">interfaces dilemma.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.284.1">Imagine you have NPCs in your game, each with various functionalities, such as wandering, talking, and trading. </span><span class="kobospan" id="kobo.284.2">Applying the ISP ensures that each NPC only needs to implement interfaces relevant to its specific behaviors, avoiding </span><span><span class="kobospan" id="kobo.285.1">unnecessary methods.</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.286.1">Without the ISP</span></em><span class="kobospan" id="kobo.287.1">, in the following code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">INPC</span></strong><span class="kobospan" id="kobo.289.1"> interface, which has general methods for all NPCs, with the </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">FriendlyNPC</span></strong><span class="kobospan" id="kobo.291.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">AggressiveNPC</span></strong><span class="kobospan" id="kobo.293.1"> classes, which </span><span><span class="kobospan" id="kobo.294.1">implement </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.295.1">INPC</span></strong></span><span><span class="kobospan" id="kobo.296.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.297.1">
public interface INPC
{
    void Wander();
    void Talk();
    void Trade();
}
public class FriendlyNPC : INPC
{
    public void Wander() { /* Implementation */ }
    public void Talk() { /* Implementation */ }
    public void Trade() { /* Implementation */ }
}
public class AggressiveNPC : INPC
{
    // Unnecessary implementations for Wander and Trade
    public void Wander() { /* Unnecessary Implementation */ }
    public void Talk() { /* Implementation */ }
    public void Trade() { /* Unnecessary Implementation */ }
}</span></pre> <p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.298.1">With the ISP</span></em><span class="kobospan" id="kobo.299.1">, in the</span><a id="_idIndexMarker081" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.300.1"> following code block, we will separate interfaces based on functionality, with the </span><strong class="source-inline"><span class="kobospan" id="kobo.301.1">FriendlyNPC</span></strong><span class="kobospan" id="kobo.302.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.303.1">AggressiveNPC</span></strong><span class="kobospan" id="kobo.304.1"> classes, which implement </span><a id="_idIndexMarker082" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.305.1">relevant interfaces:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.306.1">
public interface IWanderable
{
    void Wander();
}
public interface ITalkable
{
    void Talk();
}
public interface ITradable
{
    void Trade();
}
public class FriendlyNPC : IWanderable, ITalkable, ITradable
{
    public void Wander() { /* Implementation */ }
    public void Talk() { /* Implementation */ }
    public void Trade() { /* Implementation */ }
}
public class AggressiveNPC : ITalkable
{
    public void Talk() { /* Implementation */ }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.307.1">In this </span><a id="_idIndexMarker083" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.308.1">adapted example, applying the ISP leads to separate interfaces for distinct NPC functionalities. </span><span class="kobospan" id="kobo.308.2">Each NPC type (friendly or aggressive) can</span><a id="_idIndexMarker084" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.309.1"> now implement only the interfaces relevant to its behavior, avoiding the implementation of unnecessary methods. </span><span class="kobospan" id="kobo.309.2">This makes the system more modular and adaptable as different NPC types can adhere to their specific interfaces without being burdened by </span><span><span class="kobospan" id="kobo.310.1">irrelevant methods.</span></span></p>
<h2 id="_idParaDest-37" class="calibre7"><a id="_idTextAnchor039" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.311.1">Dependency Inversion Principle (DIP)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.312.1">Let’s </span><a id="_idIndexMarker085" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.313.1">discuss the </span><strong class="bold"><span class="kobospan" id="kobo.314.1">Dependency Inversion Principle</span></strong><span class="kobospan" id="kobo.315.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.316.1">DIP</span></strong><span class="kobospan" id="kobo.317.1">) in the context of game development. </span><span class="kobospan" id="kobo.317.2">The DIP suggests</span><a id="_idIndexMarker086" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.318.1"> that high-level modules (e.g., game logic) should not depend on low-level modules (e.g., specific implementations), but both should depend on abstractions (e.g., interfaces or abstract classes). </span><span class="kobospan" id="kobo.318.2">Additionally, it promotes that details should depend on abstractions, not the other </span><span><span class="kobospan" id="kobo.319.1">way around.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.320.1">Let us see an example of the weapon </span><span><span class="kobospan" id="kobo.321.1">manager dilemma.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.322.1">Consider a game where the </span><strong class="source-inline"><span class="kobospan" id="kobo.323.1">WeaponManager</span></strong><span class="kobospan" id="kobo.324.1"> is responsible for handling different types of weapons wielded by the player. </span><span class="kobospan" id="kobo.324.2">Without adhering to the DIP, the </span><strong class="source-inline"><span class="kobospan" id="kobo.325.1">WeaponManager</span></strong><span class="kobospan" id="kobo.326.1"> might directly instantiate and manage specific weapon classes, such as pistols and rifles. </span><span class="kobospan" id="kobo.326.2">However, applying the DIP transforms the scenario. </span><span class="kobospan" id="kobo.326.3">Now, the </span><strong class="source-inline"><span class="kobospan" id="kobo.327.1">WeaponManager</span></strong><span class="kobospan" id="kobo.328.1"> relies on an abstraction, say </span><strong class="source-inline"><span class="kobospan" id="kobo.329.1">IWeapon</span></strong><span class="kobospan" id="kobo.330.1">, representing the common functionalities of </span><span><span class="kobospan" id="kobo.331.1">all weapons.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.332.1">In the following code block, we can see the high-level module and also the low-level modules </span><em class="italic"><span class="kobospan" id="kobo.333.1">without </span></em><span><em class="italic"><span class="kobospan" id="kobo.334.1">the DIP</span></em></span><span><span class="kobospan" id="kobo.335.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.336.1">
public class WeaponManager
{
    private Pistol pistol;
    private Rifle rifle;
    public WeaponManager()
    {
        pistol = new Pistol();
        rifle = new Rifle();
    }
    public void UseWeapons()
    {
        pistol.Fire();
        rifle.Fire();
    }
}
public class Pistol
{
    public void Fire() { /* Implementation */ }
}
public class Rifle
{
    public void Fire() { /* Implementation */ }
}</span></pre> <p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.337.1">With the DIP</span></em><span class="kobospan" id="kobo.338.1">, in the </span><a id="_idIndexMarker087" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.339.1">following code block, we can see the high-level module and low-level modules</span><a id="_idIndexMarker088" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.340.1"> implementing </span><span><span class="kobospan" id="kobo.341.1">the abstraction:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.342.1">
public interface IWeapon
{
    void Fire();
}
public class WeaponManager
{
    private readonly List&lt;IWeapon&gt; weapons;
    public WeaponManager(List&lt;IWeapon&gt; weapons)
    {
        this.weapons = weapons;
    }
    public void UseWeapons()
    {
        foreach (var weapon in weapons)
        {
            weapon.Fire();
        }
    }
}
public class Pistol : IWeapon
{
    public void Fire() { /* Implementation */ }
}
public class Rifle : IWeapon
{
    public void Fire() { /* Implementation */ }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.343.1">In this </span><a id="_idIndexMarker089" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.344.1">example, applying the DIP allows </span><strong class="source-inline"><span class="kobospan" id="kobo.345.1">WeaponManager</span></strong><span class="kobospan" id="kobo.346.1"> to depend on the abstraction (</span><strong class="source-inline"><span class="kobospan" id="kobo.347.1">IWeapon</span></strong><span class="kobospan" id="kobo.348.1">), enabling easy extension with new weapon types without modifying the high-level module. </span><span class="kobospan" id="kobo.348.2">This flexibility is crucial in game development, where new features and components may be added over time without disrupting </span><span><span class="kobospan" id="kobo.349.1">existing code.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.350.1">Implementing </span><a id="_idIndexMarker090" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.351.1">the SOLID principles in Unity is instrumental in achieving modular C# code, a crucial aspect of effective software design. </span><span class="kobospan" id="kobo.351.2">Modularity, which involves breaking down a system into self-contained components, is facilitated by the SOLID principles, making the code not only easy to understand, maintain, and test but also adherent to </span><span><span class="kobospan" id="kobo.352.1">the LSP.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.353.1">Modularity’s significance lies in its ability to enhance code organization. </span><span class="kobospan" id="kobo.353.2">Applying the SRP ensures that each module has a single responsibility, fostering a focused and modular code base. </span><span class="kobospan" id="kobo.353.3">The OCP supports extending code without changing existing modules, allowing the seamless addition of new features. </span><span class="kobospan" id="kobo.353.4">The LSP ensures that derived classes can substitute their base classes without affecting program behavior, promoting consistency and predictability in </span><span><span class="kobospan" id="kobo.354.1">Unity code.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.355.1">In Unity development, effective code organization involves using namespaces and classes thoughtfully. </span><span class="kobospan" id="kobo.355.2">The ISP tailors interfaces to specific functionalities, promoting a concise and modular design. </span><strong class="bold"><span class="kobospan" id="kobo.356.1">Dependency Injection</span></strong><span class="kobospan" id="kobo.357.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.358.1">DI</span></strong><span class="kobospan" id="kobo.359.1">), advocated by the DIP, creates loosely </span><a id="_idIndexMarker091" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.360.1">coupled modules, enhancing adaptability. </span><span class="kobospan" id="kobo.360.2">In summary, the SOLID principles, including the LSP, guide the creation of modular and flexible C# code in Unity, ensuring a robust, maintainable, and consistent code base. </span><span class="kobospan" id="kobo.360.3">In the following section, we’ll explore design patterns in game development and learn how to implement them effectively in our </span><span><span class="kobospan" id="kobo.361.1">code base.</span></span></p>
<h1 id="_idParaDest-38" class="calibre5"><a id="_idTextAnchor040" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.362.1">Understanding design patterns in game development</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.363.1">Design patterns are </span><a id="_idIndexMarker092" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.364.1">proven solutions to common problems encountered in software development. </span><span class="kobospan" id="kobo.364.2">In game development, they provide valuable tools for building robust, maintainable, and efficient games. </span><span class="kobospan" id="kobo.364.3">The following section has an overview of design patterns and </span><span><span class="kobospan" id="kobo.365.1">their types.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.366.1">There are many design patterns, each applicable to specific situations. </span><span class="kobospan" id="kobo.366.2">Here are some common types encountered in </span><span><span class="kobospan" id="kobo.367.1">game development.</span></span></p>
<h2 id="_idParaDest-39" class="calibre7"><a id="_idTextAnchor041" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.368.1">Creational patterns</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.369.1">Creational patterns</span><a id="_idIndexMarker093" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.370.1"> are design patterns that provide </span><a id="_idIndexMarker094" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.371.1">structured approaches to object creation, ensuring flexibility and reusability while maintaining a clear separation between object creation and usage code. </span><span class="kobospan" id="kobo.371.2">Here are some of </span><span><span class="kobospan" id="kobo.372.1">these patterns:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.373.1">Singleton</span></strong><span class="kobospan" id="kobo.374.1">: Ensures</span><a id="_idIndexMarker095" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.375.1"> only one instance of a class exists throughout the game. </span><span class="kobospan" id="kobo.375.2">Useful for global objects such as game managers or </span><span><span class="kobospan" id="kobo.376.1">audio players.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.377.1">Factory Method</span></strong><span class="kobospan" id="kobo.378.1">: Creates </span><a id="_idIndexMarker096" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.379.1">objects without specifying the exact class, promoting flexibility and </span><span><span class="kobospan" id="kobo.380.1">code reuse.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.381.1">Object Pool</span></strong><span class="kobospan" id="kobo.382.1">: Pre-allocates </span><a id="_idIndexMarker097" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.383.1">and reuses objects to improve performance, especially for frequently created objects such as projectiles </span><span><span class="kobospan" id="kobo.384.1">or enemies.</span></span></li>
</ul>
<h2 id="_idParaDest-40" class="calibre7"><a id="_idTextAnchor042" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.385.1">Structural patterns</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.386.1">Structural patterns </span><a id="_idIndexMarker098" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.387.1">focus on organizing classes and </span><a id="_idIndexMarker099" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.388.1">objects to form larger structures, enabling better composition and flexibility in managing complex relationships between entities within a system. </span><span class="kobospan" id="kobo.388.2">Here are some of </span><span><span class="kobospan" id="kobo.389.1">these patterns:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.390.1">Flyweight</span></strong><span class="kobospan" id="kobo.391.1">: Makes </span><a id="_idIndexMarker100" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.392.1">incompatible interfaces work together by translating calls between them. </span><span class="kobospan" id="kobo.392.2">Useful for integrating external libraries or </span><span><span class="kobospan" id="kobo.393.1">custom code.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.394.1">Decorator</span></strong><span class="kobospan" id="kobo.395.1">: Adds </span><a id="_idIndexMarker101" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.396.1">functionality to an object dynamically without subclassing it, promoting flexible </span><span><span class="kobospan" id="kobo.397.1">object behavior.</span></span></li>
</ul>
<h2 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor043" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.398.1">Behavioral patterns</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.399.1">Behavioral patterns </span><a id="_idIndexMarker102" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.400.1">address communication and interaction</span><a id="_idIndexMarker103" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.401.1"> between objects in a system, focusing on how objects collaborate and distribute responsibilities to achieve desired behaviors and functionalities. </span><span class="kobospan" id="kobo.401.2">These patterns help manage algorithms, relationships, and responsibilities among objects to promote flexibility and extensibility in software design. </span><span class="kobospan" id="kobo.401.3">Here are some of </span><span><span class="kobospan" id="kobo.402.1">these patterns:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.403.1">Observer</span></strong><span class="kobospan" id="kobo.404.1">: Allows </span><a id="_idIndexMarker104" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.405.1">objects to subscribe to and be notified about changes in other objects, facilitating communication and </span><span><span class="kobospan" id="kobo.406.1">event handling.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.407.1">Strategy</span></strong><span class="kobospan" id="kobo.408.1">: Defines</span><a id="_idIndexMarker105" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.409.1"> a family of algorithms and encapsulates them to allow switching between them at runtime. </span><span class="kobospan" id="kobo.409.2">Useful for handling different player actions or </span><span><span class="kobospan" id="kobo.410.1">enemy behaviors.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.411.1">State</span></strong><span class="kobospan" id="kobo.412.1">: Encapsulates </span><a id="_idIndexMarker106" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.413.1">the behavior of an object based on its internal state, allowing for state-dependent behavior changes. </span><span class="kobospan" id="kobo.413.2">Useful for handling character states such as walking, jumping, </span><span><span class="kobospan" id="kobo.414.1">or attacking.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.415.1">In the next few sections, we are going to talk about one design pattern from </span><span><span class="kobospan" id="kobo.416.1">each type.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.417.1">Singleton design pattern</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.418.1">The</span><a id="_idIndexMarker107" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.419.1"> Singleton pattern ensures that a class </span><a id="_idIndexMarker108" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.420.1">has only one instance and provides a global point of access to that instance throughout the application. </span><span><em class="italic"><span class="kobospan" id="kobo.421.1">Figure 2</span></em></span><em class="italic"><span class="kobospan" id="kobo.422.1">.1</span></em><span class="kobospan" id="kobo.423.1"> illustrates the </span><span><span class="kobospan" id="kobo.424.1">Singleton structure:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer018">
<span class="kobospan" id="kobo.425.1"><img alt="Figure 2.1 – Singleton design pattern structure" src="image/B22017_02_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.426.1">Figure 2.1 – Singleton design pattern structure</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.427.1">In the </span><a id="_idIndexMarker109" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.428.1">following code block, you can see an</span><a id="_idIndexMarker110" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.429.1"> implementation example of Singleton </span><span><span class="kobospan" id="kobo.430.1">in Unity:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.431.1">
public class GameManager : MonoBehaviour
{
    // Static reference to the instance
    private static GameManager _instance;
    // Public property to access the instance
    public static GameManager Instance
    {
        get
        {
            if (_instance == null)
            {
                // If the instance is null, create a new instance
                _instance = new GameObject("GameManager").AddComponent&lt;GameManager&gt;();
            }
            return _instance;
        }
    }
    // Other GameManager properties and methods
    public void StartGame()
    {
        Debug.Log("Game Started!");
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.432.1">In the</span><a id="_idIndexMarker111" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.433.1"> following</span><a id="_idIndexMarker112" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.434.1"> code block, we can see a usage example for the </span><span><span class="kobospan" id="kobo.435.1">Singleton pattern:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.436.1">
public class PlayerController : MonoBehaviour
{
    private void Start()
    {
        // Accessing the GameManager instance
        GameManager.Instance.StartGame();
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.437.1">In this example, </span><strong class="source-inline"><span class="kobospan" id="kobo.438.1">GameManager</span></strong><span class="kobospan" id="kobo.439.1"> is a Singleton responsible for managing the game state. </span><span class="kobospan" id="kobo.439.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.440.1">PlayerController</span></strong><span class="kobospan" id="kobo.441.1"> class accesses the single instance to start the game. </span><span class="kobospan" id="kobo.441.2">While Singletons</span><a id="_idIndexMarker113" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.442.1"> offers global access and lazy initialization benefits, developers should carefully consider the potential drawbacks, especially in </span><span><span class="kobospan" id="kobo.443.1">larger projects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.444.1">The following are some</span><a id="_idIndexMarker114" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.445.1"> of the pros of using the </span><span><span class="kobospan" id="kobo.446.1">Singleton pattern:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.447.1">Global access</span></strong><span class="kobospan" id="kobo.448.1">: Provides a single, globally accessible point to manage and control a specific aspect of the game, such as game state </span><span><span class="kobospan" id="kobo.449.1">or settings</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.450.1">Lazy initialization</span></strong><span class="kobospan" id="kobo.451.1">: The instance is created only when it is first needed, saving resources until </span><span><span class="kobospan" id="kobo.452.1">it’s required</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.453.1">Easy to implement</span></strong><span class="kobospan" id="kobo.454.1">: The Singleton pattern is straightforward to implement and widely recognized, making it easy for developers to understand </span><span><span class="kobospan" id="kobo.455.1">and use</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.456.1">The following</span><a id="_idIndexMarker115" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.457.1"> are some of the cons of using the </span><span><span class="kobospan" id="kobo.458.1">Singleton pattern:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.459.1">Global state</span></strong><span class="kobospan" id="kobo.460.1">: Singletons introduce a global state, and excessive use can lead to tight coupling and a global state that is challenging </span><span><span class="kobospan" id="kobo.461.1">to manage</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.462.1">Potential for misuse</span></strong><span class="kobospan" id="kobo.463.1">: Developers might overuse Singletons, leading to a proliferation of global instances, diminishing the benefits </span><span><span class="kobospan" id="kobo.464.1">of encapsulation</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.465.1">Difficult to test</span></strong><span class="kobospan" id="kobo.466.1">: Testing code that depends on Singletons can be challenging, as the global state may impact the results of </span><span><span class="kobospan" id="kobo.467.1">unit tests</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.468.1">There is a principle, though, that exists to solve the singleton problem, and it’s called </span><span><span class="kobospan" id="kobo.469.1">dependency injection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.470.1">DI is a design pattern that addresses the concerns associated with tight coupling and global state by </span><a id="_idIndexMarker116" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.471.1">providing objects with their dependencies rather than letting them create those dependencies. </span><span class="kobospan" id="kobo.471.2">In Unity, this is often achieved through constructor injection or </span><span><span class="kobospan" id="kobo.472.1">property injection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.473.1">The </span><a id="_idIndexMarker117" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.474.1">following are the benefits </span><span><span class="kobospan" id="kobo.475.1">of DI:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.476.1">Reduced coupling</span></strong><span class="kobospan" id="kobo.477.1">: By injecting dependencies, classes become less dependent on specific implementations, reducing </span><span><span class="kobospan" id="kobo.478.1">tight coupling</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.479.1">Testability</span></strong><span class="kobospan" id="kobo.480.1">: Classes with injected dependencies are often easier to test because you can provide mock or test implementations for </span><span><span class="kobospan" id="kobo.481.1">those dependencies</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.482.1">Flexibility</span></strong><span class="kobospan" id="kobo.483.1">: Different implementations of a dependency can be injected, enabling easy swapping of components without modifying </span><span><span class="kobospan" id="kobo.484.1">existing code</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.485.1">DI can help mitigate some of the issues associated with the Singleton pattern in the </span><span><span class="kobospan" id="kobo.486.1">following ways:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.487.1">Reduced global state</span></strong><span class="kobospan" id="kobo.488.1">: By injecting dependencies, you can avoid creating global singletons, reducing the overall global state in </span><span><span class="kobospan" id="kobo.489.1">your application</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.490.1">Easier testing</span></strong><span class="kobospan" id="kobo.491.1">: Code relying on injected dependencies is generally easier to test because you can replace real implementations with mock objects or </span><span><span class="kobospan" id="kobo.492.1">test-specific instances</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.493.1">Improved modularity</span></strong><span class="kobospan" id="kobo.494.1">: DI encourages a modular design where components are loosely coupled, making it easier to understand and maintain the </span><span><span class="kobospan" id="kobo.495.1">code base</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.496.1">The Singleton design pattern</span><a id="_idIndexMarker118" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.497.1"> provides a single, globally accessible instance of a class, offering convenience but potentially leading to issues such as tight coupling and difficulty in testing. </span><span class="kobospan" id="kobo.497.2">DI addresses these concerns by allowing objects to be provided with their dependencies externally, reducing reliance on a global state. </span><span class="kobospan" id="kobo.497.3">This promotes loose coupling, enhances testability, and improves code maintainability by decoupling components and facilitating the easier management of object </span><span><span class="kobospan" id="kobo.498.1">life cycles.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.499.1">Flyweight design pattern</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.500.1">The </span><a id="_idIndexMarker119" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.501.1">Flyweight pattern in Unity offers a </span><a id="_idIndexMarker120" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.502.1">solution for optimizing memory usage by sharing common data across multiple objects. </span><span class="kobospan" id="kobo.502.2">It allows you to efficiently manage resources by storing shared data externally and referencing it when needed. </span><span><em class="italic"><span class="kobospan" id="kobo.503.1">Figure 2</span></em></span><em class="italic"><span class="kobospan" id="kobo.504.1">.2</span></em><span class="kobospan" id="kobo.505.1"> illustrates </span><span><span class="kobospan" id="kobo.506.1">Flyweight’s structure:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer019">
<span class="kobospan" id="kobo.507.1"><img alt="Figure 2.2 – Flyweight design pattern structure" src="image/B22017_02_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.508.1">Figure 2.2 – Flyweight design pattern structure</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.509.1">In the following code blocks, you’ll see an example scenario where the Flyweight pattern can </span><span><span class="kobospan" id="kobo.510.1">be applied.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.511.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.512.1">IWeapon</span></strong><span class="kobospan" id="kobo.513.1"> interface represents the shared properties and behaviors </span><span><span class="kobospan" id="kobo.514.1">of weapons:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.515.1">
 // Flyweight interface for weapons
public interface IWeapon
{
    void Fire();
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.516.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.517.1">Weapon</span></strong><span class="kobospan" id="kobo.518.1"> class implements the </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">IWeapon</span></strong><span class="kobospan" id="kobo.520.1"> interface and acts as a concrete Flyweight class representing </span><span><span class="kobospan" id="kobo.521.1">individual weapons:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.522.1">
// Concrete flyweight class for shared weapon properties
public class Weapon : IWeapon
{
     private string name;
     private int damage;
     private string sound;
     public Weapon(string name, int damage, string sound)
     {
         this.name = name;
         this.damage = damage;
         this.sound = sound;
     }
     public void Fire()
     {
          Debug.Log($"{name} fired - Damage: {damage} - Sound: {sound}");
     }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.523.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.524.1">WeaponFactory</span></strong><span class="kobospan" id="kobo.525.1"> class </span><a id="_idIndexMarker121" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.526.1">acts as a Flyweight factory, managing</span><a id="_idIndexMarker122" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.527.1"> and reusing flyweight objects based on specific keys (e.g., </span><span><span class="kobospan" id="kobo.528.1">weapon types):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.529.1">
// Flyweight factory class to manage and reuse flyweight objects
public class WeaponFactory
{
    private Dictionary&lt;string, IWeapon&gt; weapons;
    public WeaponFactory()
    {
        weapons = new Dictionary&lt;string, IWeapon&gt;();
    }
    public IWeapon GetWeapon(string key)
    {
        if (!weapons.ContainsKey(key))
        {
            switch (key)
            {
                case "pistol":
                    weapons[key] = new Weapon("Pistol", 30, "Bang!");
                    break;
                case "shotgun":
                    weapons[key] = new Weapon("Shotgun", 50, "Boom!");
                    break;
                case "rifle":
                    weapons[key] = new Weapon("Rifle", 40, "Pew Pew!");
                    break;
                default:
                    throw new ArgumentException("Invalid weapon key");
            }
        }
        return weapons[key];
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.530.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.531.1">GameClient</span></strong><span class="kobospan" id="kobo.532.1"> class </span><a id="_idIndexMarker123" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.533.1">demonstrates </span><a id="_idIndexMarker124" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.534.1">how to use the flyweight objects retrieved from the factory, showcasing the reusability and memory efficiency of the </span><span><span class="kobospan" id="kobo.535.1">Flyweight pattern:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.536.1">
public class GameClient : MonoBehaviour
{
    void Start()
    {
        WeaponFactory weaponFactory = new WeaponFactory();
        // Using flyweight objects
        IWeapon pistol = weaponFactory.GetWeapon("pistol");
        pistol.Fire();
        IWeapon shotgun = weaponFactory.GetWeapon("shotgun");
        shotgun.Fire();
        IWeapon rifle = weaponFactory.GetWeapon("rifle");
        rifle.Fire();
        // Reusing flyweight objects
        IWeapon anotherPistol = weaponFactory.GetWeapon("pistol");
        anotherPistol.Fire();
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.537.1">This </span><a id="_idIndexMarker125" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.538.1">example simulates a game scenario where different types of weapons are represented as flyweight objects, and the factory efficiently manages these shared objects to optimize memory usage and </span><span><span class="kobospan" id="kobo.539.1">improve performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.540.1">The following are </span><a id="_idIndexMarker126" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.541.1">the pros of using the </span><span><span class="kobospan" id="kobo.542.1">Flyweight pattern:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.543.1">Memory optimization</span></strong><span class="kobospan" id="kobo.544.1">: By sharing common data, the pattern reduces memory consumption, especially for large numbers of </span><span><span class="kobospan" id="kobo.545.1">similar objects</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.546.1">Improved performance</span></strong><span class="kobospan" id="kobo.547.1">: Sharing reduces the overhead of creating and managing redundant data, leading to </span><span><span class="kobospan" id="kobo.548.1">better performance</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.549.1">Simplified code</span></strong><span class="kobospan" id="kobo.550.1">: Separating shared and unique data promotes cleaner and more </span><span><span class="kobospan" id="kobo.551.1">maintainable code</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.552.1">The following are the</span><a id="_idIndexMarker127" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.553.1"> cons of using the </span><span><span class="kobospan" id="kobo.554.1">Flyweight pattern:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.555.1">Complexity</span></strong><span class="kobospan" id="kobo.556.1">: Implementing the Flyweight pattern introduces additional complexity, especially when managing shared and </span><span><span class="kobospan" id="kobo.557.1">unique states</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.558.1">Potential overhead</span></strong><span class="kobospan" id="kobo.559.1">: While the pattern improves memory and performance, it may introduce overhead due to managing </span><span><span class="kobospan" id="kobo.560.1">shared resources</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.561.1">Despite these considerations, the Flyweight pattern remains a valuable tool for efficient resource management in Unity projects, particularly in scenarios with many similar objects requiring </span><span><span class="kobospan" id="kobo.562.1">memory optimization.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.563.1">Observer design pattern</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.564.1">The </span><a id="_idIndexMarker128" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.565.1">Observer pattern</span><a id="_idIndexMarker129" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.566.1"> in Unity promotes loose coupling between objects by allowing them to subscribe to events and receive notifications when those events occur. </span><span class="kobospan" id="kobo.566.2">This way, objects can react to changes without needing to know the specific details of the object raising </span><span><span class="kobospan" id="kobo.567.1">the event.</span></span></p>
<p class="calibre3"><span><em class="italic"><span class="kobospan" id="kobo.568.1">Figure 2</span></em></span><em class="italic"><span class="kobospan" id="kobo.569.1">.3</span></em><span class="kobospan" id="kobo.570.1"> illustrates </span><span><span class="kobospan" id="kobo.571.1">Observer’s structure.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer020">
<span class="kobospan" id="kobo.572.1"><img alt="Figure 2.3 – Observer design pattern structure" src="image/B22017_02_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.573.1">Figure 2.3 – Observer design pattern structure</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.574.1">Let’s create a simple example in Unity to demonstrate the implementation of a health system using the </span><span><span class="kobospan" id="kobo.575.1">Observer pattern.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.576.1">In the following code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">IHealthObserver</span></strong><span class="kobospan" id="kobo.578.1"> Observer interface and the </span><strong class="source-inline"><span class="kobospan" id="kobo.579.1">IHealthSubject</span></strong> <span><span class="kobospan" id="kobo.580.1">subject interface:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.581.1">
// Observer interface
public interface IHealthObserver
{
    void OnHealthChanged(int health);
}
// Subject interface
public interface IHealthSubject
{
    event Action&lt;int&gt; OnHealthChanged;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.582.1">In the </span><a id="_idIndexMarker130" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.583.1">following code block, we can see </span><a id="_idIndexMarker131" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.584.1">the </span><strong class="source-inline"><span class="kobospan" id="kobo.585.1">HealthManager</span></strong><span class="kobospan" id="kobo.586.1"> class </span><span><span class="kobospan" id="kobo.587.1">implementing </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.588.1">IHealthSubject</span></strong></span><span><span class="kobospan" id="kobo.589.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.590.1">
public class HealthManager : MonoBehaviour, IHealthSubject
{
    private int currentHealth;
    public int MaxHealth { get; private set; } = 100;
    // Event to notify observers when health changes
    public event Action&lt;int&gt; OnHealthChanged;
    private void Start()
    {
        currentHealth = MaxHealth;
    }
    // Method to damage the character
    public void TakeDamage(int damage)
    {
        currentHealth -= damage;
        currentHealth = Mathf.Clamp(currentHealth, 0, MaxHealth);
        // Notify observers about the health change
        OnHealthChanged?.Invoke(currentHealth);
        // Check for death condition
        if (currentHealth == 0)
        {
            Debug.Log("Character has died!");
            // Additional logic for character death...
</span><span class="kobospan1" id="kobo.590.2">        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.591.1">In </span><a id="_idIndexMarker132" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.592.1">the </span><a id="_idIndexMarker133" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.593.1">following code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.594.1">UIObserver</span></strong><span class="kobospan" id="kobo.595.1"> class </span><span><span class="kobospan" id="kobo.596.1">implementing </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.597.1">IHealthObserver</span></strong></span><span><span class="kobospan" id="kobo.598.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.599.1">
public class UIObserver : MonoBehaviour, IHealthObserver
{
    public void OnHealthChanged(int health)
    {
        // Update UI elements based on the received health value
        Debug.Log($"Health UI Updated: {health}");
        // Additional UI update logic...
</span><span class="kobospan1" id="kobo.599.2">    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.600.1">In the following code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.601.1">GameplayObserver</span></strong><span class="kobospan" id="kobo.602.1"> class implementing </span><span><strong class="source-inline"><span class="kobospan" id="kobo.603.1">IHealthObserver</span></strong></span><span><span class="kobospan" id="kobo.604.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.605.1">
public class GameplayObserver : MonoBehaviour, IHealthObserver
{
    public void OnHealthChanged(int health)
    {
        // Update gameplay mechanics based on the received health value
        Debug.Log($"Gameplay Updated: {health}");
        // Additional gameplay update logic...
</span><span class="kobospan1" id="kobo.605.2">    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.606.1">In the</span><a id="_idIndexMarker134" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.607.1"> following code block, we can see a usage </span><a id="_idIndexMarker135" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.608.1">example for the Observer pattern </span><span><span class="kobospan" id="kobo.609.1">in Unity:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.610.1">
public class GameExample : MonoBehaviour
{
    private void Start()
    {
        HealthManager healthManager = new HealthManager();
        UIObserver uiObserver = new UIObserver();
        GameplayObserver gameplayObserver = new GameplayObserver();
        // Register observers with the HealthManager
        healthManager.OnHealthChanged += uiObserver.OnHealthChanged;
        healthManager.OnHealthChanged += gameplayObserver.OnHealthChanged;
        // Simulate damage to the character
        healthManager.TakeDamage(20);
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.611.1">In this </span><a id="_idIndexMarker136" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.612.1">example, the </span><strong class="source-inline"><span class="kobospan" id="kobo.613.1">HealthManager</span></strong><span class="kobospan" id="kobo.614.1"> class </span><a id="_idIndexMarker137" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.615.1">represents the subject, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.616.1">UIObserver</span></strong><span class="kobospan" id="kobo.617.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.618.1">GameplayObserver</span></strong><span class="kobospan" id="kobo.619.1"> classes represent observers. </span><span class="kobospan" id="kobo.619.2">When the character takes damage, </span><strong class="source-inline"><span class="kobospan" id="kobo.620.1">HealthManager</span></strong><span class="kobospan" id="kobo.621.1"> triggers the </span><strong class="source-inline"><span class="kobospan" id="kobo.622.1">OnHealthChanged</span></strong><span class="kobospan" id="kobo.623.1"> event, notifying all registered observers. </span><span class="kobospan" id="kobo.623.2">Each observer then updates its state based on the received health value, demonstrating the Observer pattern </span><span><span class="kobospan" id="kobo.624.1">in action.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.625.1">The following </span><a id="_idIndexMarker138" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.626.1">are the pros of using the </span><span><span class="kobospan" id="kobo.627.1">Observer pattern:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.628.1">Improved decoupling</span></strong><span class="kobospan" id="kobo.629.1">: Objects are not dependent on each other’s implementation details, promoting loose coupling </span><span><span class="kobospan" id="kobo.630.1">and modularity</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.631.1">Enhanced maintainability</span></strong><span class="kobospan" id="kobo.632.1">: Code becomes easier to understand and modify because event handling is centralized and observers </span><span><span class="kobospan" id="kobo.633.1">are decoupled</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.634.1">Increased flexibility</span></strong><span class="kobospan" id="kobo.635.1">: Allows for the dynamic addition and removal of observers, making the system more adaptable to </span><span><span class="kobospan" id="kobo.636.1">changing requirements</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.637.1">The following are</span><a id="_idIndexMarker139" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.638.1"> the cons of using the </span><span><span class="kobospan" id="kobo.639.1">Observer pattern:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.640.1">Increased complexity</span></strong><span class="kobospan" id="kobo.641.1">: Introduces additional abstraction layers compared to direct communication, which can slightly increase </span><span><span class="kobospan" id="kobo.642.1">code complexity</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.643.1">Performance overhead</span></strong><span class="kobospan" id="kobo.644.1">: Event handling involves method calls and potentially data transfer, which can lead to some </span><span><span class="kobospan" id="kobo.645.1">performance overhead</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.646.1">Overall, the Observer pattern is a powerful tool for facilitating communication between objects and managing dynamic changes in Unity. </span><span class="kobospan" id="kobo.646.2">The benefits of loose coupling and flexibility outweigh the drawbacks in most situations involving </span><span><span class="kobospan" id="kobo.647.1">event-driven behavior.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.648.1">Additionally, here are some other applications of the Observer pattern </span><span><span class="kobospan" id="kobo.649.1">in Unity:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.650.1">Implementing state machines for characters </span><span><span class="kobospan" id="kobo.651.1">and enemies</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.652.1">Updating UI elements based on changes in game state (e.g., score, level, </span><span><span class="kobospan" id="kobo.653.1">and inventory)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.654.1">Triggering animations or sound effects based on specific events in </span><span><span class="kobospan" id="kobo.655.1">the game</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.656.1">Remember, you can find all the examples on GitHub </span><span><span class="kobospan" id="kobo.657.1">for reference.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.658.1">It’s not mandatory </span><a id="_idIndexMarker140" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.659.1">to use these patterns in all your code. </span><span class="kobospan" id="kobo.659.2">They serve as solutions to common problems, but sometimes, implementing patterns might complicate things unnecessarily. </span><span class="kobospan" id="kobo.659.3">The key is to focus on solving the problem at hand first and then look for the best solution. </span><span class="kobospan" id="kobo.659.4">In the following section, we will delve into coding conventions and explore best practices for writing </span><span><span class="kobospan" id="kobo.660.1">clear code.</span></span></p>
<h1 id="_idParaDest-42" class="calibre5"><a id="_idTextAnchor044" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.661.1">Coding conventions and best practices</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.662.1">Maintaining consistent and clear code is essential for effective development and collaboration. </span><span class="kobospan" id="kobo.662.2">Adhering to recognized conventions and best practices enhances code clarity, maintainability, and readability. </span><span class="kobospan" id="kobo.662.3">Here’s a breakdown of key aspects of </span><span><span class="kobospan" id="kobo.663.1">C# coding:</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.664.1">C# naming conventions</span></strong><span class="kobospan" id="kobo.665.1">: Understanding </span><a id="_idIndexMarker141" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.666.1">and implementing C# naming conventions is pivotal for maintaining code consistency and clarity. </span><span class="kobospan" id="kobo.666.2">Let’s delve into </span><a id="_idIndexMarker142" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.667.1">best practices for naming variables, methods, classes, and namespaces to ensure our code is both readable </span><span><span class="kobospan" id="kobo.668.1">and expressive:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.669.1">Variables</span></strong><span class="kobospan" id="kobo.670.1">: Adopt </span><strong class="bold"><span class="kobospan" id="kobo.671.1">camelCase</span></strong><span class="kobospan" id="kobo.672.1"> (e.g., </span><strong class="source-inline1"><span class="kobospan" id="kobo.673.1">playerScore</span></strong><span class="kobospan" id="kobo.674.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.675.1">enemyHealth</span></strong><span class="kobospan" id="kobo.676.1">) and opt for </span><a id="_idIndexMarker143" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.677.1">descriptive</span><a id="_idIndexMarker144" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.678.1"> names conveying the variable’s purpose (e.g., </span><strong class="source-inline1"><span class="kobospan" id="kobo.679.1">currentLevel</span></strong><span class="kobospan" id="kobo.680.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.681.1">isGameOver</span></strong><span class="kobospan" id="kobo.682.1">). </span><span class="kobospan" id="kobo.682.2">Avoid abbreviations unless widely understood (e.g., fps for frames </span><span><span class="kobospan" id="kobo.683.1">per second).</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.684.1">Methods</span></strong><span class="kobospan" id="kobo.685.1">: Utilize </span><strong class="bold"><span class="kobospan" id="kobo.686.1">PascalCase</span></strong><span class="kobospan" id="kobo.687.1"> (e.g., </span><strong class="source-inline1"><span class="kobospan" id="kobo.688.1">StartGame</span></strong><span class="kobospan" id="kobo.689.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.690.1">MovePlayer</span></strong><span class="kobospan" id="kobo.691.1">) and ensure the </span><a id="_idIndexMarker145" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.692.1">method</span><a id="_idIndexMarker146" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.693.1"> name precisely reflects its functionality. </span><span class="kobospan" id="kobo.693.2">Use verbs for action-oriented methods (e.g., </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.694.1">CalculateDamage</span></strong></span><span><span class="kobospan" id="kobo.695.1">, </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.696.1">LoadLevel</span></strong></span><span><span class="kobospan" id="kobo.697.1">).</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.698.1">Classes</span></strong><span class="kobospan" id="kobo.699.1">: Employ</span><a id="_idIndexMarker147" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.700.1"> PascalCase for class names (e.g., </span><strong class="source-inline1"><span class="kobospan" id="kobo.701.1">Player</span></strong><span class="kobospan" id="kobo.702.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.703.1">EnemyController</span></strong><span class="kobospan" id="kobo.704.1">) and avoid generic names such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.705.1">MyClass</span></strong><span class="kobospan" id="kobo.706.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.707.1">NewClass</span></strong><span class="kobospan" id="kobo.708.1">. </span><span class="kobospan" id="kobo.708.2">Choose descriptive names representing the </span><span><span class="kobospan" id="kobo.709.1">class’s purpose.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.710.1">Namespaces</span></strong><span class="kobospan" id="kobo.711.1">: Apply </span><a id="_idIndexMarker148" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.712.1">PascalCase for namespaces (e.g., </span><strong class="source-inline1"><span class="kobospan" id="kobo.713.1">MyGame.Characters</span></strong><span class="kobospan" id="kobo.714.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.715.1">Utility.Math</span></strong><span class="kobospan" id="kobo.716.1">) and organize code into meaningful </span><span><span class="kobospan" id="kobo.717.1">hierarchical namespaces.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.718.1">Meaningful and descriptive names</span></strong><span class="kobospan" id="kobo.719.1">: Crafting meaningful and descriptive names </span><a id="_idIndexMarker149" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.720.1">is fundamental to writing clear and understandable code. </span><span class="kobospan" id="kobo.720.2">Let’s explore guidelines for selecting names that accurately convey the purpose and type of variables, avoiding ambiguity and enhancing </span><span><span class="kobospan" id="kobo.721.1">code readability:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.722.1">Choose names that accurately reflect the </span><span><span class="kobospan" id="kobo.723.1">represented entity.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.724.1">Avoid ambiguous names such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.725.1">temp</span></strong> <span><span class="kobospan" id="kobo.726.1">or </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.727.1">data</span></strong></span><span><span class="kobospan" id="kobo.728.1">.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.729.1">Use prefixes and suffixes to clarify variable types (e.g., </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.730.1">isJumping</span></strong></span><span><span class="kobospan" id="kobo.731.1">, </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.732.1">playerPosition</span></strong></span><span><span class="kobospan" id="kobo.733.1">).</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.734.1">Code formatting</span></strong><span class="kobospan" id="kobo.735.1">: Mastering</span><a id="_idIndexMarker150" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.736.1"> code formatting is a </span><a id="_idIndexMarker151" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.737.1">fundamental aspect of writing clean and organized code. </span><span class="kobospan" id="kobo.737.2">Let’s explore key elements such as indentation, spacing, and comments to enhance readability and structure in your </span><span><span class="kobospan" id="kobo.738.1">programming endeavors:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.739.1">Indentation</span></strong><span class="kobospan" id="kobo.740.1">: Employ </span><a id="_idIndexMarker152" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.741.1">consistent indentation for enhanced readability </span><span><span class="kobospan" id="kobo.742.1">and structure</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.743.1">Spacing</span></strong><span class="kobospan" id="kobo.744.1">: Introduce</span><a id="_idIndexMarker153" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.745.1"> appropriate spacing around operators, keywords, </span><span><span class="kobospan" id="kobo.746.1">and parentheses</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.747.1">Comments</span></strong><span class="kobospan" id="kobo.748.1">: Include</span><a id="_idIndexMarker154" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.749.1"> comments to elucidate complex logic, clarify algorithms, and document </span><span><span class="kobospan" id="kobo.750.1">code functionality</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.751.1">Error handling and exception management</span></strong><span class="kobospan" id="kobo.752.1">: Error handling and exception management </span><a id="_idIndexMarker155" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.753.1">are critical aspects of software development, ensuring robustness and reliability in handling unexpected scenarios. </span><span class="kobospan" id="kobo.753.2">Let’s delve into effective strategies, such as using </span><strong class="source-inline1"><span class="kobospan" id="kobo.754.1">try-catch</span></strong><span class="kobospan" id="kobo.755.1"> blocks and providing meaningful feedback, to manage errors gracefully and enhance </span><span><span class="kobospan" id="kobo.756.1">user experience:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.757.1">Implement robust error handling for graceful management of </span><span><span class="kobospan" id="kobo.758.1">unexpected situations</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.759.1">Use </span><strong class="source-inline1"><span class="kobospan" id="kobo.760.1">try-catch</span></strong><span class="kobospan" id="kobo.761.1"> blocks to capture exceptions and provide meaningful </span><span><span class="kobospan" id="kobo.762.1">user feedback</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.763.1">Avoid ignoring errors to prevent </span><span><span class="kobospan" id="kobo.764.1">unpredictable behavior</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.765.1">Method and class length</span></strong><span class="kobospan" id="kobo.766.1">: When it comes to method and class length, maintaining a </span><a id="_idIndexMarker156" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.767.1">balance between conciseness and clarity is paramount to fostering maintainable code bases. </span><span class="kobospan" id="kobo.767.2">Let’s explore strategies for keeping methods and classes concise while ensuring they remain focused and easy to understand, promoting code readability </span><span><span class="kobospan" id="kobo.768.1">and maintainability:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.769.1">Strive for concise and focused methods </span><span><span class="kobospan" id="kobo.770.1">and classes</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.771.1">Steer clear of “monolithic classes” handling everything, making them challenging to understand </span><span><span class="kobospan" id="kobo.772.1">and maintain</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.773.1">Extract complex functionality into separate methods for clarity </span><span><span class="kobospan" id="kobo.774.1">and reusability</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.775.1">Additional best practices</span></strong><span class="kobospan" id="kobo.776.1">: In pursuit of robust and maintainable code, embracing </span><a id="_idIndexMarker157" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.777.1">additional best practices beyond the fundamentals is essential. </span><span class="kobospan" id="kobo.777.2">Let’s delve </span><span><span class="kobospan" id="kobo.778.1">into strategies:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.779.1">Employ meaningful constants instead of </span><span><span class="kobospan" id="kobo.780.1">magic numbers</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.781.1">Minimize the use of </span><span><span class="kobospan" id="kobo.782.1">global variables</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.783.1">Avoid deeply nested code and </span><span><span class="kobospan" id="kobo.784.1">excessive indentation</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.785.1">Embarking on a journey through essential coding conventions and best practices, we explored fundamental aspects such as C# naming conventions, where clarity and consistency reign supreme. </span><span class="kobospan" id="kobo.785.2">We discussed the nuances of meaningful and descriptive names, mastering the art of code formatting, navigating error handling and exception management, and optimizing method and class length, as well as discovered additional best practices to refine your code base for robustness </span><span><span class="kobospan" id="kobo.786.1">and clarity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.787.1">Let’s explore some refactoring techniques </span><span><span class="kobospan" id="kobo.788.1">with examples.</span></span></p>
<h2 id="_idParaDest-43" class="calibre7"><a id="_idTextAnchor045" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.789.1">Refactoring techniques</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.790.1">Refactoring techniques</span><a id="_idIndexMarker158" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.791.1"> involve breaking down long and complex methods into smaller, focused functions and eliminating duplicated code to adhere to principles such as </span><strong class="bold"><span class="kobospan" id="kobo.792.1">Don’t Repeat Yourself</span></strong><span class="kobospan" id="kobo.793.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.794.1">DRY</span></strong><span class="kobospan" id="kobo.795.1">) and </span><strong class="bold"><span class="kobospan" id="kobo.796.1">Keep It Simple, Stupid</span></strong><span class="kobospan" id="kobo.797.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.798.1">KISS</span></strong><span class="kobospan" id="kobo.799.1">), ultimately resulting in cleaner and more maintainable </span><span><span class="kobospan" id="kobo.800.1">Unity projects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.801.1">Let’s look at a couple of examples of code smells in Unity projects that may indicate a need </span><span><span class="kobospan" id="kobo.802.1">for refactoring.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.803.1">Example 1: Long and complex method</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.804.1">In the</span><a id="_idIndexMarker159" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.805.1"> following code block, we can see that the </span><strong class="source-inline"><span class="kobospan" id="kobo.806.1">PlayerController</span></strong><span class="kobospan" id="kobo.807.1"> class has a </span><span><span class="kobospan" id="kobo.808.1">long method:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.809.1">
public class PlayerController : MonoBehaviour
{
    public void HandlePlayerInput()
    {
        // ... </span><span class="kobospan1" id="kobo.809.2">(code for handling input)
        if (isMoving)
        {
            // ... </span><span class="kobospan1" id="kobo.809.3">(code for player movement)
        }
        if (isShooting)
        {
            // ... </span><span class="kobospan1" id="kobo.809.4">(code for shooting logic)
        }
        // ... </span><span class="kobospan1" id="kobo.809.5">(more complex logic)
        if (isJumping)
        {
            // ... </span><span class="kobospan1" id="kobo.809.6">(code for jumping)
        }
        // ... </span><span class="kobospan1" id="kobo.809.7">(more code)
        if (isDucking)
        {
            // ... </span><span class="kobospan1" id="kobo.809.8">(code for ducking)
        }
        // ... </span><span class="kobospan1" id="kobo.809.9">(more code)
        if (isInteracting)
        {
            // ... </span><span class="kobospan1" id="kobo.809.10">(code for interacting with objects)
        }
        // ... </span><span class="kobospan1" id="kobo.809.11">(even more code)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.810.1">The </span><a id="_idIndexMarker160" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.811.1">code smell here is the </span><strong class="source-inline"><span class="kobospan" id="kobo.812.1">HandlePlayerInput</span></strong><span class="kobospan" id="kobo.813.1"> method is lengthy and handles multiple tasks, making it hard to maintain. </span><span class="kobospan" id="kobo.813.2">Refactor it into smaller, dedicated functions for specific player actions, such as movement, shooting, </span><span><span class="kobospan" id="kobo.814.1">and jumping.</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.815.1">After refactoring</span></em><span class="kobospan" id="kobo.816.1">, in the following code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.817.1">PlayerController</span></strong><span class="kobospan" id="kobo.818.1"> class has methods for each piece of logic instead of a </span><span><span class="kobospan" id="kobo.819.1">large method:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.820.1">
public class PlayerController : MonoBehaviour
{
    public void HandlePlayerInput()
    {
        HandleMovement();
        HandleShooting();
        HandleJumping();
        HandleDucking();
        HandleInteracting();
    }
    private void HandleMovement()
    {
        // ... </span><span class="kobospan1" id="kobo.820.2">(code for player movement)
    }
    private void HandleShooting()
    {
        // ... </span><span class="kobospan1" id="kobo.820.3">(code for shooting logic)
    }
    private void HandleJumping()
    {
        // ... </span><span class="kobospan1" id="kobo.820.4">(code for jumping)
    }
    private void HandleDucking()
    {
        // ... </span><span class="kobospan1" id="kobo.820.5">(code for ducking)
    }
    private void HandleInteracting()
    {
        // ... </span><span class="kobospan1" id="kobo.820.6">(code for interacting with objects)
    }
}</span></pre> <h3 class="calibre9"><span class="kobospan" id="kobo.821.1">Example 2: Duplicated code</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.822.1">In the </span><a id="_idIndexMarker161" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.823.1">following code block, we can see the </span><strong class="source-inline"><span class="kobospan" id="kobo.824.1">EnemyAI</span></strong><span class="kobospan" id="kobo.825.1"> class has </span><span><span class="kobospan" id="kobo.826.1">duplicated logic:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.827.1">
public class EnemyAI : MonoBehaviour
{
    public void AttackPlayer()
    {
        // ... </span><span class="kobospan1" id="kobo.827.2">(code for attacking player)
    }
    public void AttackAlly()
    {
        // ... </span><span class="kobospan1" id="kobo.827.3">(same code for attacking ally)
    }
    public void AttackBoss()
    {
        // ... </span><span class="kobospan1" id="kobo.827.4">(same code for attacking boss)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.828.1">The code smell here is that duplicated code for attacking the player, ally, and boss poses maintenance hurdles. </span><span class="kobospan" id="kobo.828.2">Refactor by crafting a single method for attacking and invoking it with distinct parameters to </span><span><span class="kobospan" id="kobo.829.1">eliminate redundancy.</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.830.1">After refactoring</span></em><span class="kobospan" id="kobo.831.1">, in the following code block, we can see </span><strong class="source-inline"><span class="kobospan" id="kobo.832.1">EnemyAI</span></strong><span class="kobospan" id="kobo.833.1"> has common code </span><span><span class="kobospan" id="kobo.834.1">for attacking:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.835.1">
public class EnemyAI : MonoBehaviour
{
    public void Attack(Entity target)
    {
        // ... </span><span class="kobospan1" id="kobo.835.2">(common code for attacking)
    }
    // Usage examples:
    // enemyAI.Attack(player);
    // enemyAI.Attack(ally);
    // enemyAI.Attack(boss);
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.836.1">These refactoring</span><a id="_idIndexMarker162" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.837.1"> examples adhere to the DRY and KISS principles, resulting in cleaner and more maintainable Unity code. </span><span class="kobospan" id="kobo.837.2">In the next couple of bullet points, we will take a look at the definitions of DRY </span><span><span class="kobospan" id="kobo.838.1">and KISS:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.839.1">DRY principle</span></strong><span class="kobospan" id="kobo.840.1">: The</span><a id="_idIndexMarker163" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.841.1"> DRY principle is a software development concept advocating for the avoidance of code duplication. </span><span class="kobospan" id="kobo.841.2">It emphasizes that each piece of knowledge or logic within a system should have a single, unambiguous representation to reduce redundancy. </span><span class="kobospan" id="kobo.841.3">By following DRY, developers aim to enhance maintainability, reduce the chance of errors, and improve </span><span><span class="kobospan" id="kobo.842.1">code readability.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.843.1">KISS principle</span></strong><span class="kobospan" id="kobo.844.1">: The </span><a id="_idIndexMarker164" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.845.1">KISS principle suggests that simplicity should be a key goal in design and decision-making. </span><span class="kobospan" id="kobo.845.2">It encourages developers to favor straightforward, uncomplicated solutions over complex ones. </span><span class="kobospan" id="kobo.845.3">KISS asserts that simplicity often leads to better understandability, maintainability, and reduced chances of errors. </span><span class="kobospan" id="kobo.845.4">The principle is a reminder to avoid unnecessary complexity when </span><span><span class="kobospan" id="kobo.846.1">solving problems.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.847.1">By identifying and </span><a id="_idIndexMarker165" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.848.1">addressing code smells in Unity projects, we ensure cleaner, more maintainable code. </span><span class="kobospan" id="kobo.848.2">Through examples such as breaking down long methods and eliminating duplicated code, we adhere to principles such as DRY and KISS, resulting in improved code quality </span><span><span class="kobospan" id="kobo.849.1">and readability.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.850.1">Time to demonstrate your knowledge! </span><span class="kobospan" id="kobo.850.2">Give these questions and challenges </span><span><span class="kobospan" id="kobo.851.1">a try.</span></span></p>
<h1 id="_idParaDest-44" class="calibre5"><a id="_idTextAnchor046" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.852.1">Questions</span></h1>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.853.1">What is the primary goal of writing </span><span><span class="kobospan" id="kobo.854.1">clean code?</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.855.1">Implement a singleton pattern for managing game settings such as sound volume, music volume, and screen resolution. </span><span class="kobospan" id="kobo.855.2">Ensure that there is only one instance of the settings manager throughout </span><span><span class="kobospan" id="kobo.856.1">the game.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.857.1">Create a singleton score manager that tracks the player’s score across multiple game levels or scenes. </span><span class="kobospan" id="kobo.857.2">Ensure that the score manager instance persists between </span><span><span class="kobospan" id="kobo.858.1">scene changes.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.859.1">Implement a flyweight pattern using object pooling for bullets in a shooting game. </span><span class="kobospan" id="kobo.859.2">The flyweight should efficiently manage the creation and reuse of bullet objects to minimize memory overhead </span><span><span class="kobospan" id="kobo.860.1">during gameplay.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.861.1">Design a flyweight pattern for rendering a tile-based map in a 2D game. </span><span class="kobospan" id="kobo.861.2">Optimize the rendering process by reusing flyweight tile objects for similar tile types, such as grass, water, </span><span><span class="kobospan" id="kobo.862.1">and rocks.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.863.1">Develop an observer pattern-based event system for handling in-game events such as player deaths, power-up pickups, and level completions. </span><span class="kobospan" id="kobo.863.2">Implement observers for different event types and ensure efficient </span><span><span class="kobospan" id="kobo.864.1">event broadcasting.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.865.1">Create an observer pattern implementation to update UI elements dynamically based on game events. </span><span class="kobospan" id="kobo.865.2">For example, update health bars, score displays, and inventory icons using observers for player health changes, score increments, and </span><span><span class="kobospan" id="kobo.866.1">item pickups.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.867.1">Combine singleton, flyweight, and observer patterns to design a player character system. </span><span class="kobospan" id="kobo.867.2">Use the singleton pattern for player input handling, flyweight for managing player animations efficiently, and observers for handling player state changes (e.g., </span><span><span class="kobospan" id="kobo.868.1">health, inventory).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.869.1">Design a game system (e.g., inventory management, quest tracking) and choose the most suitable design patterns (singleton, flyweight, observer, etc.) to implement various aspects of the system. </span><span class="kobospan" id="kobo.869.2">Justify your design decisions based on SOLID principles </span><span><span class="kobospan" id="kobo.870.1">and scalability.</span></span></li>
</ul>
<h1 id="_idParaDest-45" class="calibre5"><a id="_idTextAnchor047" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.871.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.872.1">To wrap up this chapter, remember that writing neat and well-organized C# code is key for successful Unity game development. </span><span class="kobospan" id="kobo.872.2">The skills you’ve gained, such as naming things sensibly and arranging code logically, will make your game creation journey smoother. </span><span class="kobospan" id="kobo.872.3">Keeping things simple and avoiding repeated code make your work easier to grasp and maintain. </span><span class="kobospan" id="kobo.872.4">Applying these ideas will lead to games with code that just makes sense, making you a more efficient and effective game developer. </span><span class="kobospan" id="kobo.872.5">It’s important to note that the journey toward clean code and best practices is ongoing. </span><span class="kobospan" id="kobo.872.6">You don’t have to apply all the principles in every project, but consistently incorporating them into your coding mindset will enhance your skills </span><span><span class="kobospan" id="kobo.873.1">over time.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.874.1">Now, gear up for the next chapter, where you’ll explore Unity plugins. </span><span class="kobospan" id="kobo.874.2">You will discover how to identify and evaluate various types of plugins, seamlessly integrating them into your projects. </span><span class="kobospan" id="kobo.874.3">This knowledge will empower you to enhance game features, save development time, and implement new mechanics using C#. </span><span class="kobospan" id="kobo.874.4">So, get ready for </span><a href="B22017_03.xhtml#_idTextAnchor049" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.875.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.876.1">, where you’ll broaden your Unity toolkit and elevate your game </span><span><span class="kobospan" id="kobo.877.1">development skills.</span></span></p>
</div>
</body></html>