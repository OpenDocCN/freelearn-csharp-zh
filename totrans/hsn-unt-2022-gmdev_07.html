<html><head></head><body>
  <div><h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-95" class="chapterTitle">Physics Collisions and Health System</h1>
    <p class="normal">As games try to simulate real-world behaviors, one important aspect to simulate is physics, which dictates how objects move and how they collide with each other, such as in the collision of players and walls, or bullets and enemies. Physics can be difficult to control due to the myriad of reactions that can happen after a collision, so we will learn how to properly configure our game to create physics as accurately as we can. This will generate the desired arcade movement feeling but get realistic collisions working—after all, sometimes, real life is not as interesting as video games!</p>
    <p class="normal">In this chapter, we will examine the following collision concepts: </p>
    <ul>
      <li class="bulletList">Configuring physics</li>
      <li class="bulletList">Detecting collisions</li>
      <li class="bulletList">Moving with physics</li>
    </ul>
    <p class="normal">First, we will learn how to properly configure physics, a step needed for the collisions between objects to be detected by our scripts, using new Unity events that we are also going to learn. All of this is needed in order to detect when our bullets touch our enemies and damage them. Then, we are going to discuss the difference between moving with <code class="inlineCode">Transform</code>, as we have done so far, as well as moving with Rigidbody and the pros and cons of each version. This will be used to experiment with different ways of moving our player and let you decide which one you will want to use. Let’s start by discussing physics settings.</p>
    <h1 id="_idParaDest-96" class="heading-1">Configuring physics</h1>
    <p class="normal">Unity’s physics system is prepared to <a id="_idIndexMarker344"/>cover a great range of possible gameplay applications, so properly configuring it is important to get the desired result. </p>
    <p class="normal">In this section, we will examine the following physics settings concepts:</p>
    <ul>
      <li class="bulletList">Setting shapes</li>
      <li class="bulletList">Physics object types</li>
      <li class="bulletList">Filtering collisions</li>
    </ul>
    <p class="normal">We are going to start by learning about the different kinds of colliders that Unity offers, and then learn about different ways to configure those to detect different kinds of physics reactions (<strong class="keyWord">collisions</strong> and <strong class="keyWord">triggers</strong>). Finally, we will discuss how to ignore collisions between specific objects to prevent situations such as the player’s bullets damaging the player.</p>
    <h2 id="_idParaDest-97" class="heading-2">Setting shapes</h2>
    <p class="normal">At the beginning of this book, we<a id="_idIndexMarker345"/> learned that objects usually have two shapes, the visual shape—which is basically the 3D mesh—and the physical one, the collider—the one that the <a id="_idIndexMarker346"/>physics system will use to calculate collisions. Remember that the idea of this is to allow you to have a highly detailed visual model while having a simplified physics shape to increase the performance. </p>
    <p class="normal">Unity has several types of colliders, so here we will recap the common ones, starting with the primitive<a id="_idIndexMarker347"/> types, that is, <strong class="keyWord">Box</strong>, <strong class="keyWord">Sphere</strong>, and <strong class="keyWord">Capsule</strong>. These shapes are the<a id="_idIndexMarker348"/> cheapest ones (in terms of performance) to detect collisions due to <a id="_idIndexMarker349"/>the fact that the collisions between them are done via mathematical formulae, unlike other colliders such as the <strong class="keyWord">Mesh Collider</strong>, which <a id="_idIndexMarker350"/>allows you to use any mesh as the physics body of the object, but with a higher performance cost and some limitations. The idea is that you should use a primitive type to represent your objects or a combination of them, for example, an airplane could be done with two Box colliders, one for the body and the other one for the wings. You can see an example of this in the following screenshot, where you can see a weapons collider made from primitives:</p>
    <figure class="mediaobject"><img src="img/B18585_07_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.1: Compound colliders</p>
    <p class="normal">Anyway, this is not always necessary; if we want the weapon to just fall to the ground, maybe a Box collider covering the entire weapon can be enough, considering those kinds of collisions don’t need to be accurate, thereby increasing performance. Also, some shapes cannot be<a id="_idIndexMarker351"/> represented even with a combination of primitive shapes, such as<a id="_idIndexMarker352"/> ramps or pyramids, where your only solution is to use a Mesh collider, which asks for a 3D mesh to use for collisions, but we won’t use them in this book given their high-performance impact; we will solve all of our physics colliders with primitives.</p>
    <p class="normal">Now, let’s add the necessary colliders to our scene to prepare it to calculate collisions properly. Consider that if you used an Asset Store environment package other than mine, you may already have the scene modules with colliders; I will be showing the work I needed to do in my case, but try to extrapolate the main ideas here to your scene. To add the colliders, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select a wall in the base and check the object and possible child objects for collider components; in my case, I have no colliders. If you detect any Mesh collider, you can leave it if you want, but I would suggest you remove it and replace it with another option in the next step. The idea is to add the collider to it, but the problem I detected here is that, due to the fact my wall is not an instance of a Prefab, I need to add a collider to every wall in the scene. </li>
      <li class="numberedList">One option is to create a Prefab and replace all of the walls with instances of the Prefab (the recommended solution) or to just select all walls in the Hierarchy (by clicking them while pressing <em class="keystroke">Ctrl</em> or <em class="keystroke">Cmd</em> on Mac) and, with them selected, use the <strong class="screenText">Add Component</strong> button to add a collider to all of them. In my case, I will use the <code class="inlineCode">Box Collider</code> component, which will adapt the size of the collider to the mesh. If it doesn’t adapt, you can just change the <strong class="screenText">Size</strong> and <strong class="screenText">Center</strong> properties of the <strong class="screenText">Box Collider</strong> to cover the entire wall:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.2: A Box Collider added to a wall</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Repeat <em class="italic">steps 1</em> and <em class="italic">2</em> for the corners, floor tiles, and any other obstacle that will block player and enemy movement.</li>
    </ol>
    <p class="normal">Now that we have <a id="_idIndexMarker353"/>added the needed colliders to the walls and floor, we can continue with the player and enemy. We will be adding the <strong class="screenText">Capsule Collider</strong> to them, the usual collider to use in movable characters due to the fact that the rounded<a id="_idIndexMarker354"/> bottom will allow the object to smoothly climb ramps. Being horizontally rounded allows the object to easily rotate in corners without getting stuck, along with other conveniences of that shape. You might want to create an enemy Prefab based on one of the characters we downloaded before, so you can add the collider to that Prefab. Our player is a simple GameObject in the scene, so you will need to add the collider to that one, but consider also creating a Prefab for the player for convenience.</p>
    <div><p class="normal">You may be tempted to add several Box colliders to the bones of the character to create a realistic shape of the object, and while we can do that to apply different damage according to the part of the body where the enemies were shot, we are just creating movement colliders; the capsule is enough. In advanced damage systems, both capsule and Bone colliders will coexist, one for the movement and the other for damage detection; but we will simplify this in our game. </p>
    </div>
    <p class="normal">Also, sometimes the <a id="_idIndexMarker355"/>collider won’t adapt well to the visual shape of the object, and in my case, the Capsule <a id="_idIndexMarker356"/>collider didn’t fit the character very well. I needed to fix its shape to match the character by setting its values as shown in the following screenshot: <strong class="screenText">Center</strong> to <code class="inlineCode">0,1,0,</code> <strong class="screenText">Radius</strong> to <code class="inlineCode">0.5</code>, and <strong class="screenText">Height</strong> to <code class="inlineCode">2</code>:</p>
    <figure class="mediaobject"><img src="img/B18585_07_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.3: Character collider</p>
    <p class="normal">The bullet we created with the Sphere already had a Sphere collider, but if you replaced the mesh of the bullet with another one, you might want to change the collider. For now, we don’t need other objects in our game, so now that everything has its proper collider, let’s see how to set the different physics settings to each object to enable proper collision detection.</p>
    <div><p class="normal">If you check the Terrain’s components, you will see that it has its own kind of collider, the <strong class="keyWord">Terrain Collider</strong>. For Terrains, that’s the only collider to use.</p>
    </div>
    <h2 id="_idParaDest-98" class="heading-2">Physics object types</h2>
    <p class="normal">Now that we have added<a id="_idIndexMarker357"/> colliders to every object by making the objects have a presence in the physics simulation, it is time to configure them to have the exact physics behavior we want. We have a myriad of possible combinations of settings, but we will discuss a set of common profiles that cover most situations. Remember, besides colliders, we saw the Rigidbody component at the beginning of this book, which is the one that applies physics to the object. The following profiles are done with a combination of colliders <a id="_idIndexMarker358"/>and Rigidbody settings:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Static Collider</strong>: As the name<a id="_idIndexMarker359"/> suggests, this kind of collider is not supposed to move, aside from some specific exceptions. Most of the environment objects fall into this category, such as walls, floors, obstacles, and the terrain. These kinds of colliders are just colliders with no <code class="inlineCode">Rigidbody</code> component, so they have a presence in the physics simulation but don’t have any physics applied to them; they cannot be moved by other objects’ collisions, they won’t have physics, and they will be fixed in their position no matter what. Take into account that this has nothing to do with the <strong class="screenText">Static</strong> checkbox at the top-right part of the editor; those are for systems we will explore later in several chapters (such as Chapter 12, Lighting Using the Universal Render Pipeline), so you can have a Static Collider with that checkbox unchecked if needed.</li>
      <li class="bulletList"><strong class="keyWord">Physics Collider</strong>: These are <a id="_idIndexMarker360"/>colliders with a <code class="inlineCode">Rigidbody</code> component, like the example of the falling ball we did in the first part of this book. These are fully physics-driven objects that have gravity and can be moved through forces; other objects can push them and they perform every other physics reaction you can expect. You can use this for the player, grenade movement, falling crates, or in all objects in heavily physics-based games such as <em class="italic">The Incredible Machine</em>. </li>
      <li class="bulletList"><strong class="keyWord">Kinematic Collider</strong>: These are colliders that have a <code class="inlineCode">Rigidbody</code> component but have the <strong class="screenText">Is Kinematic</strong> checkbox checked. These don’t have physics reactions to collisions and forces<a id="_idIndexMarker361"/> like <strong class="screenText">Static Colliders</strong>, but they are expected to move, allowing <strong class="screenText">Physics Colliders</strong> to properly handle collisions against them when moving. These can be used in objects that need to move using animations or custom scripting movements such as moving platforms. </li>
      <li class="bulletList"><strong class="keyWord">Trigger Static Collider</strong>: This is a<a id="_idIndexMarker362"/> regular Static Collider but with the <strong class="screenText">Is Trigger</strong> checkbox of the collider checked. The difference is that kinematic and physics objects pass through it but by generating a <code class="inlineCode">Trigger</code> event, an event that can be captured via scripting, which tells us that something is inside the collider. </li>
    </ul>
    <p class="bulletList">This can be used to create buttons or trigger objects, in areas of the game when the player passes through something happening, such as a wave of enemies being spawned, a door being opened, or winning the game in case that area is the goal of the player. Note that regular Static Colliders won’t generate a trigger event when passing through this type<a id="_idIndexMarker363"/> because those aren’t supposed to move.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Trigger Kinematic Collider</strong>: Kinematic Colliders don’t generate collisions, so they will pass through any other object, but they will generate <code class="inlineCode">Trigger</code> events, so we can react via<a id="_idIndexMarker364"/> scripting. This can be used to create moveable power-ups that, when touched, disappear and give us points, or bullets that move with custom scripting movements and no physics, just straight like our bullets, but damage other objects when they touch them.</li>
    </ul>
    <p class="normal">Of course, other profiles can <a id="_idIndexMarker365"/>exist aside from the specified ones to use in some games with specific gameplay requirements, but it’s down to you to experiment with all possible combinations of physics settings to see whether they are useful for your case; the described profiles will cover 99% of cases.</p>
    <p class="normal">To recap the previous scenarios, I leave you with the following table showing the reaction of contact between all of the types of colliders. You will find a row per each profile that can move; remember that static profiles aren’t supposed to move. Each column represents the reaction when they collide with the other types, <code class="inlineCode">Nothing</code> meaning the object will pass through with no effect, <code class="inlineCode">Trigger</code> meaning the object will pass through but raise <code class="inlineCode">Trigger</code> events, and <code class="inlineCode">Collision</code> meaning that the object won’t be able to pass through the object: </p>
    <table id="table001-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell"/>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Static</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Dynamic</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Kinematic</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Trigger Static</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Trigger Kinematic</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Dynamic</p>
          </td>
          <td class="table-cell">
            <p class="normal">Collision</p>
          </td>
          <td class="table-cell">
            <p class="normal">Collision</p>
          </td>
          <td class="table-cell">
            <p class="normal">Collision</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Kinematic</p>
          </td>
          <td class="table-cell">
            <p class="normal">Nothing</p>
          </td>
          <td class="table-cell">
            <p class="normal">Collision</p>
          </td>
          <td class="table-cell">
            <p class="normal">Nothing</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Trigger Kinematic</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Figure 7.4: Collision Reaction Matrix</p>
    <p class="normal">Considering this, let’s start configuring the physics of our scene’s objects.</p>
    <p class="normal">The walls, corners, floor tiles, and obstacles should use the Static Collider profile, so no <code class="inlineCode">Rigidbody</code> component on them, and their colliders will have the <strong class="screenText">Is Trigger</strong> checkbox unchecked:</p>
    <figure class="mediaobject"><img src="img/B18585_07_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.5: Configuration for floor tiles; remember the Static checkbox is for lighting only </p>
    <p class="normal">The player should move and <a id="_idIndexMarker366"/>generate collisions against objects, so we need it to have a <strong class="keyWord">Dynamic</strong> profile. This profile will generate a funny behavior with our current movement script (which I encourage you to test), especially when colliding against walls, so it won’t behave as you expected. We will deal with this later in this chapter:</p>
    <figure class="mediaobject"><img src="img/B18585_07_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.6: Dynamic settings on the player </p>
    <p class="normal">The <code class="inlineCode">Enemy</code> Prefab we suggested you create previously will be using the Kinematic profile because we will be moving this object with Unity’s AI systems later, so we don’t need physics here, and as we want the<a id="_idIndexMarker367"/> player to collide against them, we need a collision reaction there, so there’s no <code class="inlineCode">Trigger</code> here:</p>
    <figure class="mediaobject"><img src="img/B18585_07_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.7: Kinematic setting for the enemy</p>
    <p class="normal">For the <code class="inlineCode">Bullet</code> Prefab, it moves with simplistic movement via scripting (it just moves forward), and not physics. We don’t need collisions; we will code the bullet to destroy itself as soon as it touches <a id="_idIndexMarker368"/>something and will damage the collided object (if possible), so a Kinematic Trigger profile is enough for this one. We will use the <code class="inlineCode">Trigger</code> event to script the contact reactions:</p>
    <figure class="mediaobject"><img src="img/B18585_07_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.8: The Kinematic Trigger setting for our bullet; Is Trigger and Is Kinematic are checked </p>
    <p class="normal">Now that we have properly<a id="_idIndexMarker369"/> configured the objects, let’s check how to filter undesired collisions between certain object types.</p>
    <h2 id="_idParaDest-99" class="heading-2">Filtering collisions</h2>
    <p class="normal">Sometimes we want certain <a id="_idIndexMarker370"/>objects to ignore each other, like the bullets shot by the player, which shouldn’t collide with the player itself. We can always filter that with an <code class="inlineCode">if</code> statement in<a id="_idIndexMarker371"/> the C# script, checking whether the hit object is from the opposite team or whatever filtering logic you want, but by then, it is too late; the physics system wasted resources by checking a collision between objects that were never meant to collide. Here is where the Layer Collision Matrix can help us.</p>
    <p class="normal">The <strong class="keyWord">Layer Collision Matrix</strong> sounds <a id="_idIndexMarker372"/>scary, but it is a simple setting of the physics system that allows us to specify which groups of objects should collide with other groups. For example, the player’s bullets should collide with enemies, and enemy bullets should collide with the player. In this case the enemies’ bullets will pass through enemies, but this is desired in our case. The idea is to create <a id="_idIndexMarker373"/>those groups and put our objects inside them, and in Unity, those groups are called <strong class="keyWord">layers</strong>. We can create layers and set the layer property of the GameObject (the top part of the Inspector) to assign the object to that group or layer. Note that you have a limited number of layers, so try to use them wisely. </p>
    <p class="normal">We can achieve this by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <strong class="screenText">Edit | Project Settings</strong> and, inside it, look for the <strong class="screenText">Tags and Layers</strong> option from the left pane:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.9: The Tags and Layers settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">From the <strong class="screenText">Layers</strong> section, fill the empty spaces to create layers. We will use this for the bullet scenario, so we need four layers: <code class="inlineCode">Player</code>, <code class="inlineCode">Enemy</code>, <code class="inlineCode">PlayerBullet</code>, and <code class="inlineCode">EnemyBullet</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.10: Creating layers</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Select the <code class="inlineCode">Player</code> GameObject in<a id="_idIndexMarker374"/> the Hierarchy and, from the top part of the Inspector, change<a id="_idIndexMarker375"/> the <strong class="screenText">Layer</strong> property to <code class="inlineCode">Player</code>. Also, change the <code class="inlineCode">Enemy</code> Prefab to have the <code class="inlineCode">Enemy</code> layer. A window will show, asking you whether you want to also change the child objects; select <strong class="screenText">Yes</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_10.png" alt=""/> </figure>
    <p class="packt_figref">Figure 7.11: Changing the layers of the player and the enemy Prefab</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In the case of the bullet, we have a problem; we have one Prefab but two layers, and a Prefab can only have one layer. We have two options: changing the layer according to the shooter via scripting, or having two bullet Prefabs with different layers. For simplicity, I will choose the latter, also taking the chance to apply another material to the enemy bullet to make it look different.</li>
      <li class="numberedList">We will be creating a Prefab <strong class="keyWord">Variant</strong> of the player bullet. Remember that a Variant is a Prefab that is based on an original one like class inheritance. When the original Prefab changes, the Variant will change, but the Variant can have differences, which will make it unique. </li>
      <li class="numberedList">Drop a bullet Prefab into<a id="_idIndexMarker376"/> the scene to create an instance.</li>
      <li class="numberedList">Drag the instance again to the <code class="inlineCode">Prefabs</code> folder, this time selecting the <strong class="screenText">Prefab</strong> <strong class="screenText">Variant</strong> option in the window that will appear. </li>
      <li class="numberedList">Rename it <code class="inlineCode">Enemy Bullet</code>. </li>
      <li class="numberedList">Destroy the Prefab instance in the scene.</li>
      <li class="numberedList">Create a second material similar to the player bullet with a different color and put it on the enemy bullet Prefab Variant.</li>
      <li class="numberedList">Select the<a id="_idIndexMarker377"/> enemy bullet Prefab, set its layer to <code class="inlineCode">EnemyBullet</code>, and do the same for the original Prefab (<code class="inlineCode">PlayerBullet</code>). Even if you changed the original Prefab layer, as the Variant modified it, the modified version (or override) will prevail, allowing each Prefab to have its own layer.</li>
    </ol>
    <p class="normal">Now that we have configured the layers, let’s configure the physics system to use them:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <strong class="screenText">Edit | Project Settings</strong> and look for the <strong class="screenText">Physics </strong>settings (not <strong class="screenText">Physics 2D</strong>).</li>
      <li class="numberedList">Scroll down until you see the <strong class="screenText">Layer Collision Matrix</strong>, a half grid of checkboxes. You will notice that each column and row is labeled with the names of the layers, so each checkbox in the cross of a row and column will allow us to specify whether these two should collide. In our case, we configured it as shown in the following screenshot so that player bullets do not hit the player or other player bullets, and enemy bullets do not hit enemies or other enemy bullets:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.12: Making player bullets collide with enemies and enemy bullets with the player</p>
    <p class="normal">It is worth noticing that <a id="_idIndexMarker378"/>sometimes filtering logic won’t be that fixed or predictable, for example, only hit objects that <a id="_idIndexMarker379"/>have a certain amount of life, objects that don’t have an invisibility temporal buff, or conditions that can change during the game and are difficult to generate for all possible layers for all possible groups. So, in these cases, we should rely on manual filtering after the <strong class="screenText">Trigger</strong> or <strong class="screenText">Collision</strong> event.</p>
    <p class="normal">Now that we have filtered collisions, let’s check whether our settings are working properly by reacting to collisions in the next section.</p>
    <h1 id="_idParaDest-100" class="heading-1">Detecting collisions</h1>
    <p class="normal">As you can see, proper physics <a id="_idIndexMarker380"/>settings can be complicated and very important, but now that we have tackled that, let’s do something with those settings by reacting to the contact in different ways and creating a <strong class="keyWord">health system</strong> in the process. </p>
    <p class="normal">In this section, we will examine the following collision concepts:</p>
    <ul>
      <li class="bulletList">Detecting Trigger events</li>
      <li class="bulletList">Modifying the other object</li>
    </ul>
    <p class="normal">First, we are going to explore the different collision and trigger events Unity offers to react to contact between two objects through the Unity collision events. This allows us to execute any reaction code<a id="_idIndexMarker381"/> we want to place, but we are going to explore how to modify the contacted object components using the <code class="inlineCode">GetComponent</code> function.</p>
    <h2 id="_idParaDest-101" class="heading-2">Detecting Trigger events</h2>
    <p class="normal">If objects are properly configured, as previously<a id="_idIndexMarker382"/> discussed, we can get two reactions: collisions or triggers. The<a id="_idIndexMarker383"/> <strong class="keyWord">Collision</strong> reaction has a default effect that blocks the movement of the objects, but we can add custom behavior on top of that using scripting; but with a <strong class="keyWord">Trigger</strong>, unless we add custom behavior, it won’t produce any noticeable effect. Either way, we can script reactions to both possible scenarios such as adding a score, reducing health, and losing the game. To do so, we can use the suite<a id="_idIndexMarker384"/> of <strong class="keyWord">Physics events</strong>.</p>
    <p class="normal">These events are split into two<a id="_idIndexMarker385"/> groups, <strong class="keyWord">Collision events</strong> and <strong class="keyWord">Trigger events</strong>, so according to your object <a id="_idIndexMarker386"/>setting, you will need to pick the proper group. Both groups have three main events, <strong class="keyWord">Enter</strong>, <strong class="keyWord">Stay</strong>, and <strong class="keyWord">Exit</strong>, telling us when a collision or trigger began (<em class="italic">Enter</em>), whether they are still happening or are still in contact (<em class="italic">Stay</em>), and when they stopped contacting (<em class="italic">Exit</em>). For example, we can script a behavior such as playing a sound when two objects first make contact in the Enter event, such as a friction sound, and stop it when the contact ends, in the Exit event.</p>
    <p class="normal">Let’s test this by creating our first contact behavior: the bullet being destroyed when coming into contact with something. Remember that the bullets are configured to be triggers, so they will generate <code class="inlineCode">Trigger</code> events on contact with anything. You can do this with the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create and add a script called <code class="inlineCode">ContactDestroyer</code> on the <strong class="screenText">Player Bullet</strong> Prefab; as the <strong class="screenText">Enemy Bullet</strong> Prefab is a Variant of it, it will also have the same script.</li>
      <li class="numberedList">To detect when a trigger happens, such as with <strong class="screenText">Start</strong> and <strong class="screenText">Update</strong>, create an event function named <code class="inlineCode">OnTriggerEnter</code>.</li>
      <li class="numberedList">Inside the event, use the <code class="inlineCode">Destroy(gameObject);</code> line to make the bullet destroy itself when touching something:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.13: Auto-destroying on contact with something</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Save the script and shoot the bullets against the walls to see how they disappear instead of passing through them. Here we don’t have a collision, but a trigger that destroys the bullet on contact. So, this way, we are sure that the bullet will never pass through anything, but we are still not using physics movement.</li>
    </ol>
    <p class="normal">For now, we won’t need the other Collision events, but if you need them, they will work similarly; just create a function called <code class="inlineCode">OnCollisionEnter</code> instead. </p>
    <p class="normal">Now, let’s explore another version of the<a id="_idIndexMarker387"/> same function. It not only tells us that we hit something but also what we came into contact with. We will use this to make our <strong class="screenText">Contact Destroyer</strong> also destroy the other object. To do this, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Replace the <code class="inlineCode">OnTriggerEnter</code> method signature with the one in the following screenshot. This one receives a parameter of the <code class="inlineCode">Collider</code> type, indicating the exact collider that hit us: </li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.14: Version of the trigger event that tells us which object we collided with</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">We can access the GameObject of that collider using the <code class="inlineCode">gameObject</code> property. We can use this to destroy the other one as well, as shown in the following screenshot. If we just use the <code class="inlineCode">Destroy</code> function by passing the <code class="inlineCode">other</code> variable, it will only destroy the <code class="inlineCode">Collider</code> component:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.15: Destroying both objects</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Save and test the script. You will notice that the bullet will destroy everything it touches. Remember to verify that your enemy has a Capsule collider for the bullet to detect collisions against it.</li>
    </ol>
    <p class="normal">The equivalent version in Visual Scripting would be like the following figure:</p>
    <figure class="mediaobject"><img src="img/B18585_07_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.16: Destroying both objects with Visual Scripting</p>
    <p class="normal">As you can see, we <a id="_idIndexMarker388"/>created an <strong class="screenText">On Trigger Enter</strong> node and chained it to two <strong class="screenText">Destroy</strong> nodes. To specify which object each <strong class="screenText">Destroy</strong> node will destroy, we used the <strong class="screenText">Component: Get GameObject</strong> node twice. The right one was created with no node connected to its left input pin, which means it will return the GameObject that is currently executing this script (hence, the <strong class="screenText">This</strong> label in the node left pin), in this case, the bullet. For the second one we needed to connect the <strong class="screenText">Collider</strong> output pin at the right of the <strong class="screenText">OnTriggerEnter</strong> node to the <strong class="screenText">Get GameObject</strong> node; this way we specify we want to obtain the GameObject that contains the collider our bullet collided with. </p>
    <p class="normal">Now, in our game we don’t <a id="_idIndexMarker389"/>want the bullet to destroy everything on contact; instead, we will make the enemies and the player have a life amount; the bullets will reduce that life amount until it reaches 0, so let’s check how to do that.</p>
    <h2 id="_idParaDest-102" class="heading-2">Modifying the other object</h2>
    <p class="normal">For the bullet to damage the collided object, we will need to access a <code class="inlineCode">Life</code> component to change its amount, so we will need to <a id="_idIndexMarker390"/>create this <code class="inlineCode">Life</code> component to hold a float field with the amount of life. Every object with this component will be considered a damageable object. To access the <code class="inlineCode">Life</code> component from our bullet scripts we will need the <code class="inlineCode">GetComponent</code> function to help us.</p>
    <p class="normal">If you have a reference to a GameObject or component, you can use <code class="inlineCode">GetComponent</code> to access a specific component if the object contains it (if not, it will return <code class="inlineCode">null</code>). Let’s see how to use that function to make the bullet lower the amount of life of the other object:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create and add a <code class="inlineCode">Life</code> component with a <code class="inlineCode">public float</code> field called <code class="inlineCode">amount</code> to both the player and enemy Prefabs. Remember to set the value <code class="inlineCode">100</code> (or whatever life amount you want to give them) in the <strong class="screenText">Amount</strong> field for both in the Inspector:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.17: The Life component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Remove the <code class="inlineCode">ContactDestroyer</code> component from the player bullet, which will also remove it from the <strong class="screenText">Enemy Bullet Variant</strong>.</li>
      <li class="numberedList">Add a new script called <code class="inlineCode">ContactDamager</code> to both the enemy and player.</li>
      <li class="numberedList">Add an <code class="inlineCode">OnTriggerEnter</code> event that receives the <code class="inlineCode">other</code> collider as a parameter and just add the <code class="inlineCode">Destroy</code> function call that auto-destroys itself, not the one<a id="_idIndexMarker391"/> that destroys the other object; our script won’t be responsible for destroying it, just reducing its life.</li>
      <li class="numberedList">Add a float field called <code class="inlineCode">damage</code>, so we can configure the amount of damage to inflict on the other object. Remember to save the file and set a value before continuing.</li>
      <li class="numberedList">Use <code class="inlineCode">GetComponent</code> on the reference to the other collider to get a reference to its <code class="inlineCode">Life</code> component and save it in a variable:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.18: Accessing the collided object’s Life component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Before reducing the life of the object, we must check that the <code class="inlineCode">Life</code> reference isn’t <code class="inlineCode">null</code>, which would happen if the other object doesn’t have the <code class="inlineCode">Life</code> component, as in the case of walls and obstacles. The idea is that the bullet will destroy itself when anything collides with it and reduce the life of the other object if it is a damageable object that contains the <code class="inlineCode">Life</code> component.</li>
    </ol>
    <p class="normal">In the following screenshot, you will find the full script:</p>
    <figure class="mediaobject"><img src="img/B18585_07_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.19: Reducing the life of the collided object</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Place an enemy in the scene and set its speed to <code class="inlineCode">0</code> to prevent it from moving.</li>
      <li class="numberedList">Select it in the Hierarchy before hitting <strong class="screenText">Play</strong> and start shooting at it. </li>
    </ol>
    <p class="normal">You can see how the life value reduces in the Inspector. You can also press the <em class="keystroke">Esc</em> key to regain control of the mouse and select the object while in <strong class="screenText">Play</strong> mode to see the life field change during the runtime in the editor.</p>
    <p class="normal">Now, you will notice that life is <a id="_idIndexMarker392"/>decreasing, but it will become negative; we want the object to destroy itself when life is below 0 instead. We can do this in two ways: one is to add an <code class="inlineCode">Update</code> to the <code class="inlineCode">Life</code> component, which will check all of the frames to see whether life is below 0, destroying itself when that happens. The second way is by encapsulating the life field and checking that inside the setter to prevent all frames from being checked. I would prefer the second way, but we will implement the first one to make our scripts as simple as possible for beginners. </p>
    <p class="normal">To do this, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add <code class="inlineCode">Update</code> to the <code class="inlineCode">Life</code> component.</li>
      <li class="numberedList">Add <code class="inlineCode">If</code> to check whether the amount field is below or equals <code class="inlineCode">0</code>.</li>
      <li class="numberedList">Add <code class="inlineCode">Destroy</code> in case the <code class="inlineCode">if</code> condition is <code class="inlineCode">true</code>.</li>
      <li class="numberedList">The full <code class="inlineCode">Life</code> script will look like the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.20: The Life component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Save and see how the<a id="_idIndexMarker393"/> object is destroyed once <code class="inlineCode">Life</code> becomes <code class="inlineCode">0</code>. </li>
    </ol>
    <p class="normal">The Visual Scripting version for the <code class="inlineCode">Life</code> component would look like this:</p>
    <figure class="mediaobject"><img src="img/B18585_07_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.21: The Life component in Visual Scripting</p>
    <p class="normal">The script is pretty straightforward—we check if our <code class="inlineCode">Life</code> variable is less than 0 and then destroy ourselves as we did<a id="_idIndexMarker394"/> previously. Now, let’s check the <strong class="keyWord">Damager</strong> script:</p>
    <figure class="mediaobject"><img src="img/B18585_07_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.22: The Damager component in Visual Scripting</p>
    <p class="normal">This version is a little bit different from our C# counterpart. At first glance it looks the same: we use <strong class="screenText">Get Variable</strong> as before to read the life, then we use the <strong class="screenText">Subtract</strong> node to subtract <strong class="screenText">damage</strong> from <strong class="screenText">life</strong>, and the result of that calculation becomes the new value of <strong class="screenText">life</strong>, with the <strong class="screenText">Set Variable</strong> node used to alter the current value of that variable.</p>
    <p class="normal">The first difference we can see here is the absence of any <code class="inlineCode">GetComponent</code> node. In C# we used that instruction to get the <code class="inlineCode">Life</code> component on the collided object in order to read and alter its <strong class="screenText">amount</strong> variable, reducing the remaining life. But as in Visual Scripting our node graphs don’t have variables, so we don’t need to access the component to read them. Instead, knowing that the enemy has a <code class="inlineCode">Life</code> variable in its <strong class="screenText">Variables</strong> component, we use the <strong class="screenText">Get Variable</strong> node, connecting it to the collider we hit (the <strong class="screenText">Collider</strong> output pin of <strong class="screenText">On Trigger Enter</strong>), so essentially we are reading the value of the <code class="inlineCode">Life</code> variable of the collided object.</p>
    <p class="normal">The same goes for changing its value: we use the <strong class="screenText">Set Value</strong> node, connecting it to the collider, specifying we want to alter the value of the <code class="inlineCode">Life</code> variable of the collider object, not ours (as bullets, we even don’t have a <code class="inlineCode">Life</code> variable). Note that this can raise an error if the collided object doesn’t have the <code class="inlineCode">Life</code> variable, and that is why we added the <strong class="screenText">Object Has Variable</strong> node, which checks if the object has a variable called <code class="inlineCode">Life</code>. If it doesn’t, we just do nothing, which is useful when we collide with walls or other non-destructible objects. Finally, we make the <strong class="screenText">Damager</strong> (the bullet in this case) auto-destroy itself.</p>
    <p class="normal">Optionally, you can<a id="_idIndexMarker395"/> instantiate an object when this happens such as a sound, a particle, or maybe a power-up. I will leave this as a challenge for you. By using a similar script, you can make a life power-up that increases the life value or a speed power-up that accesses the <code class="inlineCode">PlayerMovement</code> script and increases the <strong class="screenText">Speed</strong> field; from now on, use your imagination to create exciting behaviors using this.</p>
    <p class="normal">Now that we have explored how to detect collisions and react to them, let’s explore how to fix the player falling when hitting a wall.</p>
    <h1 id="_idParaDest-103" class="heading-1">Moving with physics</h1>
    <p class="normal">So far, the player, the only object<a id="_idIndexMarker396"/> that moves with the <strong class="keyWord">Dynamic Collider Profile</strong> and the one that will move with physics, is actually moving through custom scripting using the Transform API. Every dynamic object should instead move using the Rigidbody API functions in a way the physics system understands better. As such, here we will explore how to move objects, this time through the Rigidbody component.</p>
    <p class="normal">In this section, we will examine the following physics movement concepts:</p>
    <ul>
      <li class="bulletList">Applying forces</li>
      <li class="bulletList">Tweaking physics</li>
    </ul>
    <p class="normal">We will start by seeing how to move objects the correct physical way, through forces, and we will apply this concept to the movement of our player. Then, we will explore why real physics is not always fun, and how we can tweak the physics properties of our objects to have a more responsive and appealing behavior.</p>
    <h2 id="_idParaDest-104" class="heading-2">Applying forces</h2>
    <p class="normal">The physically accurate way of moving an object is through forces, which affect the object’s velocity. To apply force, we need to access <code class="inlineCode">Rigidbody</code> instead of <code class="inlineCode">Transform</code> and use the <code class="inlineCode">AddForce</code> and <code class="inlineCode">AddTorque</code> functions to move and rotate respectively. These are functions where you<a id="_idIndexMarker397"/> can specify the amount of force to apply to each axis of position and rotation. This method of movement will have full physics reactions; the forces will accumulate on the velocity to start moving and will suffer drag effects that will make the speed slowly decrease, and the most important aspect here is that they will collide against walls, blocking the object’s way.</p>
    <p class="normal">To get this kind of movement, we can do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a <code class="inlineCode">Rigidbody</code> field in the <code class="inlineCode">PlayerMovement</code> script, but this time, make it <code class="inlineCode">private</code>, meaning, do not write the <code class="inlineCode">public</code> keyword in the field, which will make it disappear in the editor; we will get the reference another way:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.23: The private Rigidbody reference field</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Note that we named this variable <code class="inlineCode">rb</code> just to prevent our scripts from being too wide, making the screenshots of the code in the book too small. It’s recommended to call the variable properly in your scripts—in this case, it would be named <code class="inlineCode">rigidbody</code>.</li>
      <li class="numberedList">Using <code class="inlineCode">GetComponent</code> in the <code class="inlineCode">Start</code> event function, get our Rigidbody and save it in the field. We will use this field to cache the result of the <code class="inlineCode">GetComponent</code> function; calling that function every frame to access the Rigidbody is not performant. Also, you can notice here that the <code class="inlineCode">GetComponent</code> function can be used to retrieve not only components from other objects (like the collision example) but also your own:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.24: Caching the Rigidbody reference for future usage</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Replace the <code class="inlineCode">transform.Translate</code> calls with <code class="inlineCode">rb.AddRelativeForce</code>. This will call the add force functions of the Rigidbody, specifically the relative ones, which will consider the current rotation of the object. For example, if you specify a force<a id="_idIndexMarker398"/> in the <em class="italic">z</em>-axis (the third parameter), the object will apply its force along with its forward vector.</li>
      <li class="numberedList">Replace the <code class="inlineCode">transform.Rotate</code> calls with <code class="inlineCode">rb.AddRelativeTorque</code>, which will apply rotation forces:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.25: Using the Rigidbody forces API</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Check that the player GameObject capsule collider is not intersecting with the floor, but just a little bit over it. If the player is intersecting, the movement won’t work properly. If this is the case, move it upward.</li>
    </ol>
    <p class="normal">In the Visual Scripting version, the change is the same; replace the <strong class="screenText">Transform </strong>and <strong class="screenText">Rotate</strong> nodes with <strong class="screenText">Add Relative Force </strong>and <strong class="screenText">Add Relative Torque</strong> nodes. An example of <strong class="screenText">Add Relative Force</strong> would be the<a id="_idIndexMarker399"/> following one:</p>
    <figure class="mediaobject"><img src="img/B18585_07_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.26: Using the Rigidbody forces API</p>
    <p class="normal">And for rotation like this:</p>
    <figure class="mediaobject"><img src="img/B18585_07_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.27: Using the Rigidbody torque API</p>
    <p class="normal">You can see that we don’t need to use <strong class="screenText">GetComponent</strong> nodes here either, given that just using the <strong class="screenText">Add Relative Force</strong> or <strong class="screenText">Torque</strong> nodes makes Visual Scripting understand that we want to apply those actions on our own Rigidbody component (explaining again the <strong class="screenText">This</strong> label). If in any other case we need to call those functions on a Rigidbody other than ours, we would need the <strong class="screenText">GetComponent</strong> node there, but let’s explore that later.</p>
    <p class="normal">Now, if you save and test the results, you will probably find the player falling and that’s because now we are using real physics, which contains floor friction, and due to the force being applied at <a id="_idIndexMarker400"/>the center of gravity, it will make the object fall. Remember that, in terms of physics, you are a capsule; you don’t have legs to move, and here is where standard physics is not suitable for our game. The solution is to tweak physics to emulate the kind of behavior we need.</p>
    <h2 id="_idParaDest-105" class="heading-2">Tweaking physics</h2>
    <p class="normal">To make our player<a id="_idIndexMarker401"/> move like in a regular platformer game, we will need to freeze certain axes to prevent the object from falling. Remove the friction to the ground and increase the air friction (drag) to make the player reduce its speed automatically when releasing the keys. </p>
    <p class="normal">To do this, follow these steps: </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In the <code class="inlineCode">Rigidbody</code> component, look at the <strong class="screenText">Constraints</strong> section at the bottom and check the <strong class="screenText">X</strong> and <strong class="screenText">Z</strong> axes of the <strong class="screenText">Freeze Rotation</strong> property:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.28: Freezing rotation axes</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">This will prevent the object from falling sideways but will allow the object to rotate horizontally. You might also freeze the <em class="italic">y</em>-axis of the <strong class="screenText">Freeze Position</strong> property if you don’t want the player to jump, preventing some undesired vertical movement on collisions.</li>
      <li class="numberedList">You will probably need to change the speed values because you changed from a meters-per-second value to newtons-per-second, the expected value of the <strong class="screenText">Add Force</strong> and <strong class="screenText">Add Torque</strong> functions. Using 1,000 in speed and 160 in rotation speed was enough for me.</li>
      <li class="numberedList">Now, you will probably notice that the speed will increase a lot over time, as will the rotation. Remember that you are using forces, which affects your velocity. When you stop applying forces, the velocity is preserved, and that’s why the player kill keeps rotating even if you are not moving the mouse. The fix to this is to increase the <strong class="screenText">Drag</strong> and <strong class="screenText">Angular Drag</strong>, which emulates air friction, and will reduce the movement and rotation respectively when no force is applied. Experiment with values that you see suitable; in my case, I used <code class="inlineCode">2</code><code class="inlineCode"><a id="_idIndexMarker402"/></code> for <strong class="screenText">Drag</strong> and <code class="inlineCode">10</code> for <strong class="screenText">Angular Drag</strong>, needing to increase <strong class="screenText">Rotation Speed</strong> to <code class="inlineCode">150</code> to compensate for the drag increase:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.29: Setting air friction for rotation and movement</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Now, if you move while touching the wall, instead of sliding, like in most games, your Player will stick to the obstacles due to contact friction. We can remove this by creating a <code class="inlineCode">Physics Material</code>, an asset that can be assigned to the colliders to control how they react in those scenarios. </li>
      <li class="numberedList">Start creating one by clicking on the <strong class="screenText">+</strong> button from the <strong class="screenText">Project</strong> window and selecting <strong class="screenText">Physics Material</strong> (not the 2D version). Call it <code class="inlineCode">Player</code> and remember to put it in a folder for those kinds of assets.</li>
      <li class="numberedList">Select it and set <strong class="screenText">Static Friction</strong> and <strong class="screenText">Dynamic Friction</strong> to <code class="inlineCode">0</code>, and <strong class="screenText">Friction Combine</strong> to <code class="inlineCode">Minimum</code>, which will make the <strong class="screenText">Physics</strong> system pick the minimum friction of the two colliding objects, which is always the minimum—in our case, zero:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.30: Creating a physics material</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Select the player and drag this asset to the <strong class="screenText">Material</strong> property of the <strong class="screenText">Capsule Collider</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_07_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.31: Setting the physics material of the player</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">If you play the<a id="_idIndexMarker403"/> game now, you may notice that the player will move faster than before because now we don’t have any kind of friction on the floor, so you may need to reduce the movement force. </li>
    </ol>
    <p class="normal">As you can see, we needed to bend the physics rules to allow a responsive player movement. You can get more responsiveness by increasing drags and forces, so the speeds are applied faster and reduced faster, but that depends, again, on the experience you want your game to have. </p>
    <p class="normal">Some games want an immediate response with no velocity interpolation, going from 0 to full speed and vice versa from one frame to the other, and in these cases, you can override the velocity and rotation vectors of the player directly at your will or even use other systems instead of physics, such as the <code class="inlineCode">Character Controller</code> component, which have special physics for platformer characters; but let’s keep things simple for now.</p>
    <h1 id="_idParaDest-106" class="heading-1">Summary</h1>
    <p class="normal">Every game has physics in some way or another, for movement, collision detection, or both. In this chapter, we learned how to use the physics system for both, being aware of proper settings to make the system work properly, reacting to collisions to generate gameplay systems, and moving the player in such a way that it collides with obstacles, keeping its physically inaccurate movement. We used these concepts to create our player and bullet movement and make our bullets damage the enemies, but we can reuse the knowledge to create a myriad of other possible gameplay requirements, so I suggest you play a little bit with the physics concepts seen here; you can discover a lot of interesting use cases.</p>
    <p class="normal">In the next chapter, we will be discussing how to program the visual aspects of the game, such as effects, and make the UI react to the input.</p>
  </div>
</body></html>