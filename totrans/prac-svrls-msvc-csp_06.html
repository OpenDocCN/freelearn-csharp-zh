<html><head></head><body>
<div><h1 class="chapterNumber"><a id="_idTextAnchor141"/>6</h1>
<h1 class="chapterTitle" id="_idParaDest-105"><a id="_idTextAnchor142"/>IoT Functions in Practice</h1>
<p class="normal">The implementation of the Internet of Things certainly is changing the way we interact with the world. Although we have a lot of solutions delivered, IoT is still challenging to deliver, especially if you want to focus on a scalable solution.</p>
<p class="normal">The idea of this chapter is to present Event Grid, Event Hubs, and IoT Hub triggers that will be good options to start a microservice connected to devices. Besides that, we will discuss how to enable IoT using Azure.</p>
<p class="normal">This chapter will help you to create an IoT environment using Azure. Besides that, it will guide you on connecting this environment through Azure IoT Function triggers. To finish, it will present the car-sharing example case for IoT. Let’s check how to do it.</p>
<h1 class="heading-1" id="_idParaDest-106"><a id="_idTextAnchor143"/>Technical requirements</h1>
<p class="normal">This chapter requires Visual Studio 2022 free <em class="italic">community edition </em>or Visual Studio Code. You will also need an Azure account to create the sample environment. You can find the sample code for this chapter at <a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</a>.</p>
<h1 class="heading-1" id="_idParaDest-107"><a id="_idTextAnchor144"/>Enabling IoT in Azure</h1>
<p class="normal">When we think about IoT, one of the greatest worries is the scalability of the solution. Considering that we are designing a solution to facilitate connection with a great number of devices, the best way to enable IoT in Azure is by using IoT Hub. IoT Hub creates a great environment for connecting, monitoring, and managing your IoT devices, offering a Platform as a Service (PaaS) solution that will make<a id="_idIndexMarker323"/> you focus on the application you are working on.</p>
<p class="normal">There are two tiers of pricing for IoT Hub in Azure and the Free Edition of it. The Free Edition enables up to 8,000 messages of 0.5KB a day and it has the same features we have in the Standard tier. If you go for the Basic or Standard tiers, this can be increased to up to 3 billion messages of 4KB a day! The standard tier also offers device management, cloud-to-device messaging, and IoT Edge. Besides that, the Standard tier has a layer of security managed by Defender, called Defender for IoT. This<a id="_idIndexMarker324"/> information gives us an idea of how scalable the platform is.</p>
<p class="normal">For our purposes in this book and to help you understand the following examples, we suggest that you create a free tier IoT Hub component. The next topics will discuss how to get messages from this IoT Hub so you can create a microservice based on it.</p>
<p class="normal">The process of doing so is quite simple. You must go to <strong class="keyWord">Create Resource</strong> in Azure and type IoT Hub in Azure Marketplace.</p>
<figure class="mediaobject"><img alt="Figure 6.1: Creating an IoT Hub using Azure Marketplace" src="img/B31916_06_01.png"/></figure>
<p class="packt_figref">Figure 6.1: Creating an IoT Hub using Azure Marketplace</p>
<p class="normal">For <strong class="keyWord">Free Tier</strong>, you only<a id="_idIndexMarker325"/> need to fill in the information related to the <strong class="keyWord">Basics</strong> tab, so after this, you can move on to the <strong class="keyWord">Review + create</strong> tab.</p>
<figure class="mediaobject"><img alt="Figure 6.2: Azure IoT Hub Free Tier setup" src="img/B31916_06_02.png"/></figure>
<p class="packt_figref">Figure 6.2: Azure IoT Hub Free Tier setup</p>
<p class="normal">As soon as the resource is <a id="_idIndexMarker326"/>created, you will be able to create devices in the Azure IoT Hub <strong class="keyWord">Device management</strong> area.</p>
<figure class="mediaobject"><img alt="Figure 6.3: Azure IoT Hub Device management" src="img/B31916_06_03.png"/></figure>
<p class="packt_figref">Figure 6.3: Azure IoT Hub Device management</p>
<p class="normal">First, the device will only need <strong class="keyWord">Device ID</strong> information, which represents the uniqueness of the device that will be handled.</p>
<figure class="mediaobject"><img alt="Figure 6.4: Creating a device in IoT Hub" src="img/B31916_06_04.png"/></figure>
<p class="packt_figref">Figure 6.4: Creating a device in IoT Hub</p>
<p class="normal">IoT Hub also provides the possibility to connect devices on the edge, by using IoT Edge devices. This is not the focus of this book, but <a id="_idIndexMarker327"/>you will find information about it in the <em class="italic">Further reading</em> section. For the book’s purpose, devices created in Azure are good to go.</p>
<p class="normal">Considering we have the devices created, we need to understand how to simulate them. The code below shows how we can do it using the .NET <code class="inlineCode">Microsoft.Azure.Devices.Client</code> library:</p>
<pre class="programlisting code"><code class="hljs-code">// &lt;summary&gt;
// Simulates a device by creating a DeviceClient and sending a message.
// &lt;/summary&gt;
// &lt;param name=”connectionString”&gt;The connection string of the //device.&lt;/param&gt;
// &lt;param name=”message”&gt;The message to be sent by the device.&lt;/param&gt;
private static async Task SimulateDeviceAsync(string connectionString, string message)
{
  var deviceClient = DeviceClient.CreateFromConnectionString(
 connectionString, TransportType.Mqtt);
  await SendMessageAsync(deviceClient, message);
}
// &lt;summary&gt;
// Sends a message to the IoT hub using the provided DeviceClient.
// &lt;/summary&gt;
// &lt;param name=”deviceClient”&gt;The DeviceClient used to send the //message.&lt;/param&gt;
/// &lt;param name=”message”&gt;The message to be sent.&lt;/param&gt;
private static async Task SendMessageAsync(DeviceClient deviceClient, string message)
{
  var messageBytes = Encoding.UTF8.GetBytes(message);
  var iotMessage = new Message(messageBytes);
  await deviceClient.SendEventAsync(iotMessage);
}
</code></pre>
<p class="normal">The connectionString argument in the method above is specific to each IoT device. You can get it using the Azure portal, but it is <a id="_idIndexMarker328"/>great to mention that there is a very useful tool for Azure IoT Hub called <strong class="keyWord">Azure IoT Explorer</strong>.</p>
<p class="normal">With Azure IoT Explorer, we<a id="_idIndexMarker329"/> can manage devices connected to IoT Hub in a graphical tool that facilitates diagnosing and testing. For instance, to get the <strong class="keyWord">connection string</strong> of a specific device, you can check the <strong class="keyWord">Device identity</strong> information available.</p>
<figure class="mediaobject"><img alt="Figure 6.5: Getting device connection string" src="img/B31916_06_05.png"/></figure>
<p class="packt_figref">Figure 6.5: Getting device connection string</p>
<p class="normal">Now that we have understood how to simulate devices, let’s learn how to receive data from these devices using Azure <a id="_idIndexMarker330"/>Functions.</p>
<h1 class="heading-1" id="_idParaDest-108"><a id="_idTextAnchor145"/>Connecting IoT Hub with Azure Functions</h1>
<p class="normal">By default, IoT Hub offers a built-in service that delivers device-to-cloud messages to a compatible EventHubs <a id="_idIndexMarker331"/>endpoint at messages/events. This <a id="_idIndexMarker332"/>means that you can easily connect IoT Hub device messages to an Event Hubs trigger function:</p>
<pre class="programlisting code"><code class="hljs-code">[Function(nameof(IoTFunction))]
public void Run([EventHubTrigger(“messages/events”, Connection = “EventHubConnection”)] EventData[] events)
{
foreach (EventData @event in events)
  {
    _logger.LogInformation(“Event Body: {body}”, @event.EventBody);
  }
}
</code></pre>
<p class="normal">This option is certainly very useful since you can develop a solution very fast where you connect different devices using IoT Hub and Azure Functions. So, this can be considered the simplest way to directly integrate message processing.</p>
<p class="normal">In the code above, we are just defining the default endpoint messages/events and defining the variable that will give us the connection string for the Event Hub. The EventHubConnection variable can be found in <strong class="keyWord">Built-in endpoints</strong> in IoT Hub. There will be only shared access policies that enable us to receive data from devices (<strong class="keyWord">ServiceConnect</strong> permissions). It is recommended that you share the policy with the least access, considering the purpose of this connection is just reading the information.</p>
<figure class="mediaobject"><img alt="Figure 6.6: Obtaining Event Hubs connection string to receive data from IoT Hub" src="img/B31916_06_06.png"/></figure>
<p class="packt_figref">Figure 6.6: Obtaining Event Hubs connection string to receive data from IoT Hub</p>
<p class="normal">It is also worth noting that these messages can be retained for a maximum of seven days, according to the tier you have <a id="_idIndexMarker333"/>selected in Azure IoT Hub.</p>
<p class="normal">Although the built-in option is very <a id="_idIndexMarker334"/>easy and fast to implement, you may want to apply different IoT scenarios where other alternatives can be applied. There are several ways to trigger data coming from devices using <strong class="keyWord">Events</strong> in Azure IoT Hub, as we can see in the following screenshot.</p>
<figure class="mediaobject"><img alt="Figure 6.7: Azure IoT Hub Events alternatives to receive data from devices" src="img/B31916_06_07.png"/></figure>
<p class="packt_figref">Figure 6.7: Azure IoT Hub Events alternatives to receive data from devices</p>
<p class="normal">Each approach certainly will give<a id="_idIndexMarker335"/> you the versatility to implement event driven and scalable solutions. Besides that, you<a id="_idIndexMarker336"/> need to analyze exactly the data you are going to send from devices to the cloud to define the best alternative. It is worth noting that only IoT Hub triggers aims at direct integration between IoT Hub and Azure Functions. The other triggers are visible under the <strong class="keyWord">Events</strong> blade.</p>
<table class="table-container" id="table001-1">
<thead>
<tr>
<th class="table-head">
<p class="normal"><strong class="keyWord">Approach</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">When to use</strong></p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="table-cell">
<p class="normal">IoT Hub Trigger</p>
</td>
<td class="table-cell">
<p class="normal">Simplest, direct integration for message processing.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Event Grid Trigger</p>
</td>
<td class="table-cell">
<p class="normal">Best for event-driven systems and scalable architecture.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Service Bus Trigger</p>
</td>
<td class="table-cell">
<p class="normal">When you need intermediate buffering or message priority handling.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Blob Storage Trigger</p>
</td>
<td class="table-cell">
<p class="normal">When you want to store and process telemetry data as files.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">HTTP Trigger (Direct)</p>
</td>
<td class="table-cell">
<p class="normal">When you need fine-grained control over function invocation.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Logic Apps</p>
</td>
<td class="table-cell">
<p class="normal">For no-code/low-code integration with IoT Hub and Functions.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Stream Analytics Output</p>
</td>
<td class="table-cell">
<p class="normal">When you need to perform real-time analytics before invoking the function.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Queue Trigger</p>
</td>
<td class="table-cell">
<p class="normal">For lightweight, simple queue-based message processing.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">We have already <a id="_idIndexMarker337"/>covered how to implement some of these alternatives in the <a id="_idIndexMarker338"/>last three chapters, so we will not explore them again.</p>
<h1 class="heading-1" id="_idParaDest-109"><a id="_idTextAnchor146"/>Car-sharing IoT example</h1>
<p class="normal">The car-sharing example that we are covering in the book enables interaction between car-seeking and car-holding users. But let’s <a id="_idIndexMarker339"/>suppose we have the possibility to deliver a special plan for car-holders who apply for a specific IoT device from the platform we are designing. Another option would be to integrate the car-sharing app in the central car cockpit. In this scenario, users could track the location, speed, and status of the available vehicles. It would also be possible to monitor vehicle health parameters such as battery life, tire pressure, and fuel levels.</p>
<p class="normal">In the alternatives presented before, a new vehicle-tracking microservice could be implemented and its data would probably be shared with the existing <strong class="keyWord">Routes-Listing </strong>and <strong class="keyWord">Routes-Planner</strong> microservices. For the first one, it would be possible to provide up-to-date information on car availability and estimated arrival times. For the planner, it would facilitate the decision of the best car to suggest a new hide.</p>
<p class="normal">But considering the scenario above, which would be a great architectural approach? In <a href="Chapter_7.xhtml#_idTextAnchor151"><em class="italic">Chapter 7</em></a>, <em class="italic">Microservices in Practice</em>, we will present the RabbitMQ message broker, which will be very useful for this scenario, and the complete example of Routes-Planner microservices. The diagram below shows how the IoT solution and the Vehicle-Tracking microservice will be connected to the main solution.</p>
<p class="normal">Azure IoT Hub is the component responsible for managing multiple cars (devices) and it will send tracking data received<a id="_idIndexMarker340"/> from each car to the Vehicle-Tracking microservice using Azure Event Hubs messages. This microservice will be responsible for processing vehicle health parameters, as presented above, and this information will be stored in the Cosmos DB database, considering the volume of data received. To finish, it will publish only the data needed for the RoutesPlanning microservice using a RabbitMQ principal bus.</p>
<figure class="mediaobject"><img alt="Figure 6.8: IoT solution connected to a microservice solution" src="img/B31916_06_08.png"/></figure>
<p class="packt_figref">Figure 6.8: IoT solution connected to a microservice solution</p>
<p class="normal">The tracking data that is sent from the car could have a structure like the one below. It is also great to mention that, if you are<a id="_idIndexMarker341"/> running .NET from a device to the cloud, this structure can be reused if you work in a class library dedicated to defining SharedMessages:</p>
<pre class="programlisting code"><code class="hljs-code">using SharedMessages.BasicTypes;
using System;
namespace SharedMessages.VehicleTracking
{
  public class VehicleTrackingMessage : TimedMessage
  {
    public Guid VehicleId { get; set; }
    public GeoLocalizationMessage? Location { get; set; }
    public double Speed { get; set; }
    public double CarStatus { get; set; }
    public double BatteryLevel { get; set; }
    public double FuelLevel { get; set; }
    public double TirePressure { get; set; }   
  }
}
</code></pre>
<p class="normal">It is worth noting that the Location property is defined by another shared class, called GeoLocalizationMessage:</p>
<pre class="programlisting code"><code class="hljs-code">using System;
using System.Collections.Generic;
using System.Text;
namespace SharedMessages.BasicTypes
{
  public class GeoLocalizationMessage
  {
    public double Latitude { get; set; }
    public double Longitude { get; set; }
  }
}
</code></pre>
<p class="normal">Considering this <a id="_idIndexMarker342"/>scenario, the following code is an emulation of a car collecting data and sending data using IoT Hub as the front door:</p>
<pre class="programlisting code"><code class="hljs-code">using System.Text;
using System.Text.Json;
using Microsoft.Azure.Devices.Client;
using SharedMessages.BasicTypes;
using SharedMessages.VehicleTracking;
// &lt;summary&gt;
// The main class for the Car Simulator program.
// &lt;/summary&gt;
class Program
{
  // &lt;summary&gt;
// The connection string for the car device.
// &lt;/summary&gt;
  private static string carConnectionString = “[device connection string]”;
  // &lt;summary&gt;
// The main entry point for the program.
// &lt;/summary&gt;
static async Task Main()
  {
    while (true)
    {
      // Create a new vehicle tracking message with random data
VehicleTrackingMessage vehicleTrackingMessage = new
        VehicleTrackingMessage
      {
        VehicleId = Guid.NewGuid(),
        Location = new GeoLocalizationMessage
        {
          Latitude = 47.6426,
          Longitude = -122.1301
        },
        Speed = 60 + DateTime.Now.Second,
        CarStatus = 1,
        BatteryLevel = 100 - DateTime.Now.Second,
        FuelLevel = 100,
        TirePressure = 32
      };
      // Simulate sending the device message
await SimulateDeviceAsync(carConnectionString,
 vehicleTrackingMessage);
      Console.WriteLine(“Vehicle tracking sent!”);
      await Task.Delay(new Random().Next(10000, 20000));
    }
  }
  // &lt;summary&gt;
// Simulates sending a device message to the IoT hub.
// &lt;/summary&gt;
// &lt;param name=”connectionString”&gt;The connection string for the  
  //device.&lt;/param&gt;
// &lt;param name=”message”&gt;The vehicle tracking message to send.&lt;/param&gt;
  private static async Task SimulateDeviceAsync(string connectionString,
                                        VehicleTrackingMessage message)
  {
    var deviceClient = DeviceClient.CreateFromConnectionString(
 connectionString, TransportType.Mqtt);
    string jsonMessage = JsonSerializer.Serialize(message);
    await SendMessageAsync(deviceClient, jsonMessage);
  }
  // &lt;summary&gt;
// Sends a message to the IoT hub.
// &lt;/summary&gt;
// &lt;param name=”deviceClient”&gt;The device client to use for sending the  
  //message.&lt;/param&gt;
// &lt;param name=”message”&gt;The message to send.&lt;/param&gt;
  private static async Task SendMessageAsync(DeviceClient deviceClient, 
      string message)
  {
    var messageBytes = Encoding.UTF8.GetBytes(message);
    var iotMessage = new Message(messageBytes);
    await deviceClient.SendEventAsync(iotMessage);
  }
}
</code></pre>
<p class="normal">It is worth noting that we are just creating data here with random information. However, the process itself exactly represents the output of data from a device to the cloud.</p>
<div><p class="normal">Depending on the <a id="_idIndexMarker343"/>device you have, you may need to change the protocol used with Azure IoT Hub. You may check https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-protocols for more information.</p>
</div>
<p class="normal">On the other hand, the following code represents the function that will process the vehicle tracking message, storing its data in Cosmos DB and, at the same time, alerting all the microservices via RabbitMQ that there is a new message from a car, so other microservices, like RoutesPlanning, can make use of it to run their business rules:</p>
<pre class="programlisting code"><code class="hljs-code">using System;
using System.Text.Json;
using Azure.Messaging.EventHubs;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;
using SharedMessages.VehicleTracking;
namespace VehicleTrackingFunction
{
  // &lt;summary&gt;
// Azure Function to process vehicle tracking messages from Event Hub.
// &lt;/summary&gt;
  public class VehicleTracking
  {
    private readonly ILogger&lt;VehicleTracking&gt; _logger;
    // &lt;summary&gt;
// Initializes a new instance of the &lt;see cref=”VehicleTracking”/&gt;
    //class.
// &lt;/summary&gt;
// &lt;param name=”logger”&gt;The logger instance.&lt;/param&gt;
    public VehicleTracking(ILogger&lt;VehicleTracking&gt; logger)
    {
      _logger = logger;
    }
    // &lt;summary&gt;
// Function triggered by Event Hub messages.
// &lt;/summary&gt;
// &lt;param name=”events”&gt;Array of EventData received from Event
    //Hub.&lt;/param&gt;
    [Function(nameof(VehicleTracking))]
    public async Task Run([EventHubTrigger(“messages/events”,
      Connection = “CarSharingIoTEventHub”)] EventData[] events)
    {
      foreach (EventData @event in events)
      {
        var jsonString = @event.EventBody.ToString();
        if (!string.IsNullOrEmpty(jsonString))
        {
          VehicleTrackingMessage? vehicleTrackingMessage = JsonSerializer.Deserialize&lt;VehicleTrackingMessage&gt;(jsonString);
          if (vehicleTrackingMessage != null)
          {
            await SaveDataToDatabase(vehicleTrackingMessage);
            await AlertDataToRabbitMQ(vehicleTrackingMessage);
          }
        }
      }
    }
    // &lt;summary&gt;
// Sends vehicle tracking data to RabbitMQ.
// &lt;/summary&gt;
// &lt;param name=”vehicleTrackingMessage”&gt;The vehicle tracking
    //message.&lt;/param&gt;
    private async Task AlertDataToRabbitMQ(
      VehicleTrackingMessage vehicleTrackingMessage)
    {
      // Implementation for alerting data to RabbitMQ
Console.WriteLine($”Vehicle tracking data alerted to RabbitMQ: ID =
 {vehicleTrackingMessage.VehicleId};
        Speed = {vehicleTrackingMessage.Speed}”);
    }
    // &lt;summary&gt;
// Saves vehicle tracking data to CosmosDB database.
// &lt;/summary&gt;
// &lt;param name=”vehicleTrackingMessage”&gt;The vehicle tracking
    //message.&lt;/param&gt;
    private async Task SaveDataToDatabase(VehicleTrackingMessage 
      vehicleTrackingMessage)
    {
      // Implementation for saving data to the database CosmosDB
Console.WriteLine($”Vehicle tracking data saved to database: ID =
 {vehicleTrackingMessage.VehicleId};
        Speed = {vehicleTrackingMessage.Speed}”);
    }
  }
}
</code></pre>
<p class="normal">Some great things about this approach justify why microservices are a good way to work with big products. First, the implementation of the IoT solution is totally decoupled from the implementation of the rest of the application, which enables developers to define the technology used and the deployment pipeline. Second, the usage of the information provided by the IoT solution is optional<a id="_idIndexMarker344"/> and can be spread to each microservice that is required. Besides that, one point of attention is the contract defined in the Shared Messages. You must be careful not to create an incompatibility between the systems. A good approach to avoid this is to version the message content.</p>
<h1 class="heading-1" id="_idParaDest-110"><a id="_idTextAnchor147"/>Summary</h1>
<p class="normal">This chapter discussed how Internet of Things solutions can be handled in Azure, especially with the help of Azure IoT Hub and Azure Functions. It also presented an extension of the car-sharing example using an IoT service, which demonstrates how useful microservices architecture can be.</p>
<p class="normal">Microservices offer several strategic advantages in the development of large-scale applications, especially when it comes to implementing IoT solutions. By decoupling the IoT solution from the rest of the application, developers have the flexibility to choose the appropriate technologies and pipelines for deployment independently. This modular approach not only enhances scalability and maintainability but also allows different teams to work on various parts of the application without interference.</p>
<p class="normal">Another significant benefit of microservices is their optional and distributed usage of information. The data provided by the IoT solution can be utilized by any microservice that requires it, ensuring efficient data handling and processing. However, it is crucial to maintain compatibility across different systems by carefully managing contracts. Versioning message content is an effective strategy to avoid incompatibility issues, ensuring smooth communication between microservices. In the next chapter, we will start discussing the usage of microservices in practice with more emphasis.</p>
<h1 class="heading-1" id="_idParaDest-111"><a id="_idTextAnchor148"/>Questions</h1>
<ol>
<li class="numberedList" value="1">What is the purpose of reading device-to-cloud messages from the built-in endpoint in IoT applications?</li>
</ol>
<p class="normal-one">The built-in endpoint in IoT Hub allows you to read device-to-cloud messages easily and directly, making it ideal for quick integration between devices and backend applications. It simplifies the process of connecting IoT devices to services like Azure Functions using standard Event Hub-compatible endpoints.</p>
<p class="normal-one">This approach is useful for scenarios where rapid prototyping or lightweight integration is needed, as it requires minimal configuration and supports scalable, event-driven solutions.</p>
<ol>
<li class="numberedList" value="2">How can you read device-to-cloud messages from the built-in endpoint?</li>
</ol>
<p class="normal-one">To read messages from the built-in endpoint, you can create an Azure function using an Event Hub trigger and point it to the default messages/events endpoint of IoT Hub. The connection string with read permissions (typically from the service policy) is used to access the messages.</p>
<p class="normal-one">This method enables a fast and straightforward implementation of serverless message processing, allowing the Azure Function to automatically execute whenever a device sends data to IoT Hub.</p>
<ol>
<li class="numberedList" value="3">What are the advantages of using the Azure IoT explorer for managing IoT devices?</li>
</ol>
<p class="normal-one">The Azure IoT explorer is a graphical tool that simplifies device management in IoT Hub. It allows you to register new devices, view connection strings, send test messages, and monitor device status without writing any code.</p>
<p class="normal-one">This tool is especially helpful during the development and testing phases, as it accelerates diagnostics and gives developers a user-friendly interface to interact with and configure IoT devices.</p>
<ol>
<li class="numberedList" value="4">How does Queue Trigger facilitate lightweight, simple queue-based message processing?</li>
</ol>
<p class="normal-one">Queue triggers enable Azure Functions to respond to messages placed in Azure Storage Queues. This pattern provides a lightweight and decoupled way to process tasks asynchronously, making it easy to implement background job handling or message workflows.</p>
<p class="normal-one">It is particularly effective in scenarios where simplicity, scalability, and fault tolerance are desired without the need for complex messaging infrastructure.</p>
<ol>
<li class="numberedList" value="5">What are the key differences between IoT Hub and Event Hubs?</li>
</ol>
<p class="normal-one">IoT Hub is specifically designed for secure and scalable communication with IoT devices, offering device management, bidirectional messaging, and integration with IoT Edge. Event Hubs, on the other hand, is a high-throughput, general-purpose event ingestion service mainly used for telemetry and logging.</p>
<p class="normal-one">While both support massive data ingestion, IoT Hub provides device-centric features like twin properties, direct methods, and security credentials per device, whereas Event Hubs focuses on data streaming and integration into analytics pipelines.</p>
<ol>
<li class="numberedList" value="6">What are the benefits of decoupling the IoT solution from the rest of the application?</li>
</ol>
<p class="normal-one">Decoupling the IoT solution allows independent development, scaling, and deployment of the device communication layer. Each microservice can process only the data it needs, leading to better performance, flexibility, and maintainability.</p>
<p class="normal-one">Additionally, this separation enables teams to adopt different technologies or deployment strategies as needed, while keeping the core application architecture clean and modular.</p>
<ol>
<li class="numberedList" value="7">How can versioning message content help prevent incompatibility issues in shared messages?</li>
</ol>
<p class="normal-one">Versioning message content ensures that changes to data structures don’t break functionality in microservices that consume these messages. Each service can process the version it understands, allowing smooth evolution of the system.</p>
<p class="normal-one">By maintaining compatibility across versions, developers can update and deploy components independently without risking integration failures or data misinterpretation between services.</p>
<ol>
<li class="numberedList" value="8">What role does the pipeline of deployment play in the implementation of microservices in IoT solutions?</li>
</ol>
<p class="normal-one">A well-defined deployment pipeline allows each microservice, including those related to IoT, to be built, tested, and deployed independently. This supports continuous integration and delivery, reducing time to market and minimizing risks during updates.</p>
<p class="normal-one">For IoT scenarios, where data ingestion and processing are critical, automated pipelines ensure reliability, version control, and traceability across the distributed system—enhancing overall application robustness.</p>
<h1 class="heading-1" id="_idParaDest-112"><a id="_idTextAnchor149"/>Further reading</h1>
<ul>
<li class="bulletList">Azurite: <a href="https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite">https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite</a></li>
<li class="bulletList">Microsoft Azure Storage Explorer: <a href="https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer">https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer</a></li>
<li class="bulletList">Azure IoT Edge Documentation: <a href="https://learn.microsoft.com/en-us/azure/iot-edge">https://learn.microsoft.com/en-us/azure/iot-edge</a></li>
<li class="bulletList">Read device-to-cloud messages from the built-in endpoint: <a href="https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-messages-read-builtin">https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-messages-read-builtin</a></li>
<li class="bulletList">Azure IoT explorer: <a href="https://learn.microsoft.com/en-us/azure/iot/howto-use-iot-explorer">https://learn.microsoft.com/en-us/azure/iot/howto-use-iot-explorer</a></li>
<li class="bulletList">Comparison between IoT Hub and Event Hubs: <a href="https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-compare-event-hubs">https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-compare-event-hubs</a></li>
<li class="bulletList">Azure Functions Event Triggers: https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-event-iot</li>
<li class="bulletList">Azure Functions IoT Triggers: https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-event-iot-trigger</li>
<li class="bulletList">Azure Stream Analytics: https://azure.microsoft.com/en-us/products/stream-analytics/</li>
</ul>
<h1 class="heading-1" id="_idParaDest-113"><a id="_idTextAnchor150"/>Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/PSMCSharp">https://packt.link/PSMCSharp</a></p>
<p class="normal"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="img/B31916_Discord-QR-Code.png"/></p>
</div>
</body></html>