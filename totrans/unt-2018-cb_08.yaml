- en: Lights and Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Directional Light with a cookie Texture to simulate a cloudy day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and applying a cookie Texture to a spotlight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a custom reflection map to a scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a laser aim with a projector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the laser aim with a line renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an environment with Procedural Skybox and Directional Light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflecting surrounding objects with reflection probes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using material emission to bake light from a glowing lamp onto scene objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting a scene with lightmaps and light probes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you're trying to make a better-looking game or you want to add interesting
    features, lights and effects can boost your project and help you deliver a higher
    quality product. Modern game engines, including Unity, use complex mathematics
    and physical modelling of how light from light sources interacts with objects
    in a **Scene**.
  prefs: []
  type: TYPE_NORMAL
- en: For visually realistic virtual game **Scenes**, the game engine must model sources
    of light, how light falls directly from those sources onto surfaces, and also
    how light then indirectly bounces from those surfaces to other objects in the
    scene, and again onto other objects and so on. For rich, complex **Scenes** containing
    many objects and light sources, it would be impossible to calculate everything
    from scratch every frame, so pre-computation needs to take place to model these
    light source and surface interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the creative ways of using lights and effects,
    and also take a look at some of Unity's key **Lighting** features, such as Procedural
    Skyboxes, Reflection emissive **Materials**, Probes, Light Probes, custom Reflection
    Sources, and **Global Illumination** (**GI**).
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways of creating light sources in Unity. Here's a quick overview
    of the most common methods.
  prefs: []
  type: TYPE_NORMAL
- en: Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lights are placed into the scene as GameObjects, featuring a Light component.
    They can function in Realtime, Baked, or Mixed modes. Among the other properties,
    they can have their Range, Color, Intensity, and Shadow Type set by the user.
    There are four types of lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directional Light**: This is normally used to simulate the sunlight'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spot Light**: This works like a cone-shaped spot light'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point Light**: This is a bulb-like, omnidirectional light'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Area Light**: This baked-only light type is emitted in all directions from
    a rectangle-shaped entity, allowing for a smooth, realistic shading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates different types of lights, with their
    scene panel icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cf7e68d-aa83-492f-a1a8-423f8e583a2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Environment lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity's Environment Lighting is often achieved through the combination of a
    Skybox **Material** and sunlight defined by the scene's **Directional Light**.
    Such a combination creates an ambient light that is integrated into the scene's
    environment, and which can be set as real-time or baked into **Lightmaps**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ambient lighting doesn''t come from any locational source, as it exists evenly
    throughout the scene. Ambient light can be used to influence the overall brightness
    of a scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af27aa4e-7612-4a3d-b7ae-06b79a62fe02.png)'
  prefs: []
  type: TYPE_IMG
- en: Emissive materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When applied to static objects, materials featuring the Emission colors or
    maps will cast light over surfaces nearby, in both **Real-Time** and **Baked**
    modes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e935fb04-6498-4e0d-9853-ae197c5df3ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Projector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As its name suggests, a Projector can be used to simulate projected lights
    and shadows, basically by projecting a material and its **Texture** map onto the
    other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75b02737-7317-418c-924b-a50ed54ed431.png)'
  prefs: []
  type: TYPE_IMG
- en: Lightmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lightmaps are basically **Texture** maps generated from the **Scene's** lighting
    information and applied to the scene's static objects in order to avoid the use
    of processing-intensive **Real-Time** lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-computation of lighting in a **Scene** is known as Lightmap *Baking. Static* –
    immovable – parts of the scene (lights and other objects) can have their lighting
    "baked" (pre-computed), before the game is run. Then, during **Run-Time**, game
    performance is improved, since the pre-calculated Lightmaps can be used rather
    than having to re-calculate each frame at **Run-Time** (although this does require
    more memory to store the pre-computations).
  prefs: []
  type: TYPE_NORMAL
- en: Unity offers two lightmappers, Enlighten, and more recently the Progressive
    lightmapper. Enlighten can work well for Precomputed real-time Global Illumination
    (ambient lighting). The Progressive lightmapper is recommended for Baked Lightmaps.
  prefs: []
  type: TYPE_NORMAL
- en: Light probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Light Probes are a way of sampling the **Scene's** illumination at specific
    points in order to have it applied onto dynamic objects without the use of **Real-Time**
    lighting. *Moving* (dynamic) objects can use Light Probes so that their lighting
    changes in relation to where the baked light sources are located in the **Scene**.
  prefs: []
  type: TYPE_NORMAL
- en: The Lighting settings window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Lighting window, (menu: Window | Rendering | Lighting Settings), is the
    hub for setting and adjusting the scene''s illumination features, such as Lightmaps,
    Global Illumination, Fog, and much more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a6dba89-0bc9-4b8a-ac62-cc7f2b5f3d22.png)'
  prefs: []
  type: TYPE_IMG
- en: The Light Explorer panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with Lights and Lighting, a useful tool in Unity is the Lighting
    Explorer panel, which allows editing and viewing the properties of all of the
    lights in the current scene. The Lighting Explorer panel lists all Lights in a
    single panel, making it easy to work with each individually, or change the settings
    of several at the same time. It can be a great time-saving tool when working with
    scenes involving lots of Light Game Objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the Light Explorer panel, choose the following menu: Window | Rendering
    | Light Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ac03c9f-1459-45f7-8197-ae1fdc54c015.png)'
  prefs: []
  type: TYPE_IMG
- en: Cucoloris cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lights can have a cookie **Texture** applied. Cookies are **Textures** used
    to cast shadows or silhouettes in a **Scene**. They are produced by using the
    cookie Texture as a mask between the light source and the surfaces being rendered.
    Their name, and usage, comes from the use of physical devices called cucoloris
    (nicknamed cookies) used in theatre and movie production, to give the shadow effects
    implying environments such as moving clouds, the bars of a prison window, or the
    sunlight broken up by a jungle leaf canopy.
  prefs: []
  type: TYPE_NORMAL
- en: Color space (Gamma and Linear)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity now offers a choice of two Color spaces: Gamma (the default) and Linear.
    You can select your desired Color Space via the following menu: Edit | Project
    Settings | Player. While Linear space has significant advantages, it isn''t supported
    by all hardware (especially mobile systems), so which you choose will depend on
    which platform you are deploying for.'
  prefs: []
  type: TYPE_NORMAL
- en: Further resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter aims to present you with some of Unity''s lighting features, and
    offer a few tricks with lights and effects. As you work through the recipes in
    this chapter, you may wish to learn more about this chapter''s topics from some
    of these sources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity lighting manual entry: [https://docs.unity3d.com/Manual/Lighting.html](https://docs.unity3d.com/Manual/Lighting.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity''s **Global Illumination** (**GI**) pages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/GIIntro.html](https://docs.unity3d.com/Manual/GIIntro.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Manual/GlobalIllumination.html](http://docs.unity3d.com/Manual/GlobalIllumination.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity''s information about cookie **Textures** can be found at their manual
    page: [https://docs.unity3d.com/Manual/Cookies.html](https://docs.unity3d.com/Manual/Cookies.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another source about Unity and cookie **Textures** is the *CgProgramming WikiBook*
    for Unity: [https://en.wikibooks.org/wiki/Cg_Programming/Unity/Cookies](https://en.wikibooks.org/wiki/Cg_Programming/Unity/Cookies)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity manual about choosing a color space: [https://unity3d.com/learn/tutorials/topics/graphics/choosing-color-space](https://unity3d.com/learn/tutorials/topics/graphics/choosing-color-space)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity manual about the Lighting Explorer panel: [https://docs.unity3d.com/Manual/LightingExplorer.html](https://docs.unity3d.com/Manual/LightingExplorer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About Linear and Gamma lighting workflows: [https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html](https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LMHPoly article on 7 tips for better Unity Lighting: [https://lmhpoly.com/7-tips-for-better-lighting-in-unity/](https://lmhpoly.com/7-tips-for-better-lighting-in-unity/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directional Light with cookie Texture to simulate a cloudy day
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As can be seen in many first-person shooters and survival horror games, lights
    and shadows can add a great deal of realism to a **Scene**, helping to create
    the right atmosphere for the game immensely. In this recipe, we will create a
    cloudy outdoor environment using cookie **Textures**. Cookie **Textures** work
    as masks for lights. It functions by adjusting the intensity of the light projection
    to the cookie texture's alpha channel. This allows for a silhouette effect (just
    think of the bat signal) or, as in this particular case, subtle variations that
    give a filtered quality to the lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't have access to an image editor, or prefer to skip the **Texture**
    map elaboration in order to focus on the implementation, we have provided the
    prepared cookie image file cloudCookie.tga, inside the `07_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simulate a cloudy outdoor environment, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your image editor, create a new 512 x 512 pixel image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using black as the foreground color and white as the background color, apply
    the Clouds filter – in Photoshop, choose the following menu: Filter | Render |
    Clouds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d798ed3-09b7-469e-944d-e3b5734a00b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Learning about the Alpha channel is useful, but you could get the same result
    without it. Skip steps 3 to 7, save your image as cloudCookie.png and, when changing
    texture type in step 9, leave Alpha from Greyscale checked.
  prefs: []
  type: TYPE_NORMAL
- en: Select your entire image and copy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Channels window (in Photoshop, this can be done choosing the following
    menu: Window | Channels.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There should be three channels: Red, Green, and Blue. Create a new channel.
    This will be the Alpha channel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Channels window, select the Alpha 1 channel and paste your image into
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/091ede6b-80fd-4f7f-adf1-a43d80bfedd7.png)'
  prefs: []
  type: TYPE_IMG
- en: Save your image file as cloudCookie.PSD or TGA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import your image file to Unity and select it in the **Project** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Inspector**, change its Texture Type to Cookie and its Light Type
    to Directional. Then, click on Apply, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08ab0e68-3598-4d9d-8b16-8cab91722c8f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add a light to our scene. Since we want to simulate sunlight, the best
    option is to create a **Directional Light**. Choose the Hierarchy menu: Create
    | Light | Directional Light.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need a surface to actually see the lighting effect. You can either
    add a 3D plane to your scene (menu: GameObject | 3D Object | Plane), or create
    a 3D Terrain (menu: GameObject | 3D Object | Terrain).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector, reset the light's Transform Position to (`0, 0, 0`) and its
    Rotation to (`90, 0, 0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Cookie field, select the cloudCookie texture that you imported earlier.
    Change the Cookie Size field to 15, or a value that you feel is more appropriate
    for the **Scene''s** dimensions. Set the Shadow Type as No Shadows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6dfecb4f-03ad-4dcc-b58b-53a72a383e52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new C# script class named ShadowMover, and add an instance object
    as a component to the **Directional Light**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Select the Directional Light. In the Inspector, change the parameters Wind Speed
    X and Wind Speed Z to different values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your scene. The shadows will now be moving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The script class offers two public values for the X- and Z- speeds of movement
    (simulating wind).
  prefs: []
  type: TYPE_NORMAL
- en: When the scene starts, first, the initial position of the Directional Light
    is stored. Then, the size of the cookie is read from the sibling Light component,
    and used to calculate maximum X and Z values. Finally, a Vector3 is created, for
    the amount to move our light by in seconds, based on the X and Z window speeds
    (Y is zero, since we don't need to move the Directional Light in the Y axis).
  prefs: []
  type: TYPE_NORMAL
- en: The `WrapValue(...)` method is defined, which returns a value. If the positive
    value of the first parameter exceeds the second parameter (the limit), then the
    third parameter (the initial value) is returned. Otherwise, the value of the first
    parameter is returned. This allows is to ensure that if a value (for example,
    our X or Z coordinate) goes beyond a limit, we can "wrap" it back to its start
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method is executed in each frame. The next position for the light
    is calculated (current position plus the current frame's proportion of the wind
    speed per second vector). The X and Z values of this new position are set using
    our `WrapValue(...)` method, so we know that their limit values are not exceeded.
    Finally, the position of the light is set to this new position, `Vector3`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we are not enabling shadows is because the light angle for the X
    axis must be 90 degrees (or there will be a noticeable gap when the light resets
    to the original position). If you want dynamic shadows in your scene, please add
    a second **Directional Light**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and applying a cookie texture to a spotlight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookie Textures can work well with Unity **Spotlight**s to simulate shadows
    coming from projectors, windows, and so on. An example of this would be for the
    bars of a prison window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create and apply a cookie **Texture** suitable to use
    with Unity **Spotlights**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1e123b2-093a-4a82-8397-0653e9e437d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't have access to an image editor, or prefer to skip the **Texture**
    map elaboration in order to focus on the implementation, we have provided the
    prepared cookie image file called spotCookie.tif inside the `07_02` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create and apply a cookie texture to a spotlight, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your image editor, create a new 512 x 512 greyscale pixel image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the border is completely black by setting the brush tool color
    to black and drawing around the four edges of the image. Then, draw some criss-crossed
    lines. Save your image, naming it spotCookie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a45d26bf-879e-4eaa-aede-eba662c5a63d.png)'
  prefs: []
  type: TYPE_IMG
- en: Import your image file to Unity and select it in the Project panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Inspector, change its Texture Type to Cookie and its Light Type to
    Spotlight, and set the Alpha Source to From Grayscale. Then, click on Apply, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/944c9df7-c815-45f6-ab0b-051b460b5062.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a scene containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A flat 3D Terrain or Plane as our ground
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A 3D Cube or Plane, stretched to act as a wall
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two or three other 3D objects in front of the wall
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Position the **Main Camera** to be showing the 3D objects in front of the "wall".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add a Spotlight to the scene by choosing the following menu: Create |
    Light | Spotlight.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Orient the Spotlight to be pointing in the direction of the **Main Camera** 
    – you'll probably have to rotate the Y value by 180 degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Shadow Type to No Shadows, and drag your spotCookie **Texture** from the
    Project panel into the Cookie slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your Scene. You should now see the spotlight casting shadows as if a light
    had been shone through a grid of planks of wood or metal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a greyscale Texture for use with Unity Spotlights – that's completely
    black around the edges – so that light does not "bleed" around the edge of our
    Spotlight emission. The black lines in the Texture are used by Unity to create
    shadows in the light emitted from the Spotligh, creating the effect that there
    are some straight beams of wood or metal through which the Spotlight is being
    shone.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about creating Spotlight cookies in Unity at the Unity tutorial
    page: [http://docs.unity3d.com/Manual/HOWTO-LightCookie.html](http://docs.unity3d.com/Manual/HOWTO-LightCookie.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom Reflection map to a scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity''s Standard Shader gets its reflection from the scene''s Reflection Source,
    as configured in the scene section of the Lighting window. The level of reflectiveness
    for each Material is defined by its Metallic value or Specular value, depending
    on which Shader is being used. This approach can be a real time-saver, allowing
    you to quickly assign the same reflection map to every object in the scene. It
    also helps keep the overall look of the scene coherent and cohesive. In this recipe,
    we will learn how to take advantage of the Reflection Source feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10c82279-c87a-4a62-a0d6-d9cbcc483828.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will prepare a Reflection Cubemap, which is basically the
    environment to be projected as a reflection onto the material. It can be made
    from either six or, as shown in this recipe, a single image file.
  prefs: []
  type: TYPE_NORMAL
- en: To help us with this recipe, we have provided a Unity package (batteryPrefab.unitypackage),
    containing a prefab made of a 3D object and a basic Material (using a TIFF as
    a Diffuse map), and also a JPG file to be used as the reflection map. All of these
    files are inside the `07_03` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add Reflectiveness and Specularity to a material, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the batteryPrefab.unitypackage package into a new project. Then, select
    the battery_prefab object from the Assets folder, in the **Project** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Inspector, expand the **Material** component and observe the asset
    preview window. Thanks to the Specular map, the material already features a reflective
    look. However, it looks as if it is reflecting the scene''s default Skybox, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb7e8060-e994-4381-a5f5-09fb4a21f8e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Import the CustomReflection.jpg image file. Ensure that this asset is selected
    in the Project panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Inspector for its Import Settings, set the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Texture Type**: Default'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Texture Shape**: Cube'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping**: Latitude-Longitude Layout (Cylindrical)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convolution Type**: None'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fixup Edge Seams**: Checked'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filter Mode**: Trilinear'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, click on the Apply button, as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/77e0476b-b1f9-434e-b874-07a5da933ff7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s replace the scene''s Skybox with our newly created Cubemap as the Reflection
    map for our scene (menu: Window | Rendering | Lighting Settings).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Scene** section and use the drop-down menu to change the Reflection
    Source to Custom. Finally, assign the newly created CustomReflection texture as
    the Cubemap, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3f86985-e065-4875-9955-64ecdf9782db.png)'
  prefs: []
  type: TYPE_IMG
- en: Check out the new reflections on the battery_prefab object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The material's specular map provides a reflective look, including the intensity
    and smoothness of the reflection. However, the image you see in the refection
    itself is given by the Cubemap that we created.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection Cubemaps can be achieved in many ways and have different mapping
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cylindrical mapping that we applied was well-suited for the photograph that
    we used. However, depending on how the reflection image is generated, a Cubic-
    or Spheremap-based mapping can be more appropriate. Also, note that the Fixup
    Edge Seams option will try to make the image seamless.
  prefs: []
  type: TYPE_NORMAL
- en: Sharp reflections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that the reflection is somewhat blurry compared to the
    original image; this is because we have ticked the Glossy Reflections box. To
    get a sharper-looking reflection, deselect this option; in this case, you can
    also leave the Filter Mode option as default (Bilinear).
  prefs: []
  type: TYPE_NORMAL
- en: Maximum size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At 512 x 512 pixels, our reflection map will probably run fine on lower-end
    machines. However, if the quality of the reflection map is not very important
    in your game's context, and the original image dimensions are big (say, 4,096
    x 4,096), you might want to change the texture's Max Size from the Import Settings menu
    to a lower number.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a laser aim with a projector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although using UI elements, such as a cross-hair, is a valid way to allow players
    to aim, replacing (or combining) it with a projected laser dot might be a more
    interesting approach. In this recipe, we will use a light projector to implement
    this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c056206-f8fc-4668-92e3-9449290e9aca.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help us with this recipe, in the `07_04` folder, we've provided a Unity package
    (laserAssets.unitypackage) containing a sample scene featuring a character holding
    a laser pointer, and also a texture map named LineTexture.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a laser dot aim with a Projector, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll be importing the Projectors components from the **Unity Standard Assets**.
    If you didn't install the **Standard Assets** when you installed Unity, go the
    the **Asset Store** and install the free **Standard Assets** now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `laserAssets.unitypackage` into a new project. Then, open the scene named
    basic_scene_MsLaser. This is a basic scene, featuring a player character in a
    maze, with standard arrow keys or WASD movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the **Projectors** contents from the Effects Unity Standard Assets package
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1b104465-fe16-4357-bf92-835121da42c0.png)'
  prefs: []
  type: TYPE_IMG
- en: From the **Inspector**, locate the ProjectorLight shader (inside the Assets
    | Standard Assets | Effects | Projectors | Shaders folder). Duplicate the file
    and name the new copy as ProjectorLaser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open ProjectorLaser. From the first line of the code, change Shader `"Projector/Light"`
    to Shader `"Projector/Laser"`. Then, locate `Blend DstColor One` and change it
    to `Blend One One`. Save and close the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2b81dbb7-7f13-44a0-89ee-4983dc962b0b.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason for editing the shader for the laser was to make it stronger by changing
    its blend type to Additive. Shader programming is a complex subject, which is
    beyond the scope of this book. However, if you want to learn more about it, check
    out Unity's documentation on the subject, which is available at [http://docs.unity3d.com/Manual/SL-Reference.html](http://docs.unity3d.com/Manual/SL-Reference.html),
    and also the book called *Unity Shaders and Effects Cookbook*, published by Packt.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new material called m_laser. In the Inspector, change its Shader to
    Projector/Laser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the Falloff Texture in the **Project** panel (inside Effects | Projectors
    | Textures).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open it in your image editor and, except for the first and last columns column
    of pixels, which should be black, paint everything white. Save the changed image
    file as Falloff_laser and go back to Unity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/975973c3-39ff-43e4-8bb6-78b4e70dce8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the m_laser asset in the **Project** panel. In the Inspector, set the
    Main Color to red (RGB: 255, 0, 0). Then, from the texture slots, drag **Texture**
    Light into the Cookie slot, and **Texture** Falloff_laser into the Falloff slot
    (these **Textures** are inside your imported folder, Effects | Projectors | Textures):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1c593dac-3b31-443f-8def-b81718501e15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the **Hierarchy**, find and select the pointerPrefab object (MsLaser |
    mixamorig:Hips | mixamorig:Spine | mixamorig:Spine1 | mixamorig:Spine2 | mixamorig:RightShoulder
    | mixamorig:RightArm | mixamorig:RightForeArm | mixamorig:RightHand | pointerPrefab).
    Then, create a new child GameObject (menu: Create | Create Empty Child). Rename
    this new child laserProjector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b5fd3c3e-d3cc-45b6-9685-a3c913efd00b.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the laserProjector object. Then, from the **Inspector**, click the Add
    Component button and navigate to Effects | Projector. Then, from the new Projector
    component, set the Orthographic option as true and set Orthographic Size as `0.1`.
    Finally, select m_laser from the Material slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene. You will be able to see the laser aim dot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, the size of the aim dot has been exaggerated. Should you need
    a more realistic thickness for your laser pointer, change the Orthographic Size
    of the **Projector** component to something smaller, like 0.025.
  prefs: []
  type: TYPE_NORMAL
- en: The laser aim effect was achieved by using a Projector. A Projector can be used
    to simulate light, shadows, and more, and is a component that projects a Material
    (and its Texture) onto other game objects. By attaching a projector to the laserPointer
    object, we have ensured that it will face the right direction at all times. To
    get the desired, vibrant look, we edited the projector Material's Shader code,
    making it brighter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some ways to enhance this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the range of the laser with Raycast hit to limit the far clip plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our laser target should highlight the first object it hits – it shouldn''t
    go through all of the objects ahead of it. The project''s far clip plane defined
    the distance at which the projector stops. We can use a simple script to fire
    a Raycast, and use the distance to the first object it hits as a guide for setting
    this far clip plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the Raycast hits an object, we set the **Projector** far clip plane to that
    distance, plus a little margin if 0.5 Unity units (for example, it might be a
    curved surface).
  prefs: []
  type: TYPE_NORMAL
- en: 'We scripted a way to prevent projections from going through objects, by setting
    its far clip plane on approximately the same level of the first object that is
    receiving the projection. The line of code that is responsible for this action
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Learn more about projectors from the Unity manual page: [https://docs.unity3d.com/Manual/class-Projector.html](https://docs.unity3d.com/Manual/class-Projector.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the laser aim with a Line Renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s improve the previous recipe by displaying a laser beam from the character''s
    laser gun to the projected laser target. We''ll implement the laser beam through
    scripting a Line Renderer, which is being redrawn each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12ea8a77-6e6f-4674-a686-7eb991393261.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe ­is based on the previous one, so make a copy of that project and
    work with its copy. You'll also need a **Texture** for the beam color; one is
    provided in the `07_05` folder called beam.psd.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enhance the laser aim with a Line Renderer, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Our Line Renderer will need a **Material** to work with. Create a new Material
    named m_beam.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector**, set the Shader of the m_beam to Particles/Additive. Also,
    set its Tint Color to red (**RGB**: `255;0;0`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the beam image file. Then, set it as the Particle **Texture** for the
    m_beam, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e1d367f2-f940-403c-a420-42bee06ca636.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new C# script class named LaserBeam, and add an instance object as
    a component to the Game Object''s Laser Projector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Select the LaserProjector Game Object. From the Inspector, find the Laser Beam
    (Script) component and drag the m_beam Material from the Project panel into the
    Beam Material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the scene. The red laser beam should be shining in a line from the laser
    gun to the first object hit by the beam.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The laser aim effect was achieved by using a dynamic Line Renderer, which created
    and updated each frame through code.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the width of the laser beam has been exaggerated. Should you
    need a more realistic thickness for your beam, change the Line Width field of
    the Laser Beam (Script) component to 0.05\. Also, remember to make the beam more
    opaque by setting the Regular Color of the Laser Beam component brighter. You'll
    probably want to match the size of the laser aim Projector, too, so set the Orthographic
    Size of the **Projector** component to something smaller, such as 0.025.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the Line Renderer, we have opted to create it dynamically, via code,
    instead of manually adding the component to the game object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some ways to enhance this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the beam color when the Fire key is held down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s always good to provide the player with audio or visual feedback when
    they do something. So, when the player presses the *Fire* button (for example,
    the mouse button) let''s change the color of the beam. Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new public variable for the fire beam color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new method to set up changing a color (using a Sine wave value):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add statements at the end of the `Update()` method to detect when the Fire
    button is pressed/released to trigger a color change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Setting up an environment with Procedural Skybox and Directional Light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the traditional six-sided and Cubemap Skyboxes, Unity also features
    a third type of skybox: the Procedural Skybox. Easy to create and set up, the
    Procedural Skybox can be used in conjunction with a Directional Light to provide
    Environment Lighting in your scene. In this recipe, we will learn about the different
    parameters of the Procedural Skybox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ce3efd7-fb5a-4ba9-a8a6-839ab2563b02.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up Environment Lighting using the Procedural Skybox and **Directional
    Light**, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **Scene** inside a Unity project. Observe that a new scene already
    includes two objects: the Main Camera and a Directional Light.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the scene, create a 3D Plane named Plane-ground; positioned at (0, 0, 0)
    and scaled to (`20, 20, 20`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some 3D Cubes to your scene, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db1ab526-ed1f-4ee3-8a1a-74d7626c56af.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a new **Material** asset file named m_skybox. In the Inspector, change
    the Shader from Standard to Skybox/Procedural.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Lighting window (Window | Rendering | Lighting Settings), and access
    the scene section. In the Environment Lighting subsection, populate the Skybox
    slot with the m_skybox Material, and the Sun slot with the scene's default Directional
    Light. Ensure that the real-time Global Illumination option is checked (from real-time
    Lighting), and that the Environment Ambient Mode is set to real-time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Project** panel, select m_skybox. Then, from the Inspector, set
    the Sun Size as 0.05 and the Atmosphere Thickness as 1.4\. Experiment by changing
    the Sky Tint color to RGB: 148; 128; 128, and the Ground color to a value that
    resembles the scene cube floor''s color (such as RGB: 202; 202; 202). If you feel
    that the scene is too bright, try bringing the Exposure level down to 0.85, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bbebd520-8302-4a77-a6bb-b01c3a73b3d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the Directional Light and change its Rotation to 5, 170, 0\. Also ensure
    that its Light Mode setting is real-time (not baked or Mixed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene  – it should resemble a dawning environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ultimately, the appearance of Unity''s native Procedural Skyboxes depends on
    the five parameters that make them up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sun size: The size of the bright yellow sun that is drawn onto the Skybox is
    located according to the Directional Light''s Rotation on the X and Y axes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Atmosphere Thickness: This simulates how dense the atmosphere is for this Skybox.
    Lower values (less than 1.0) are good for simulating the outer space settings.
    Moderate values (around 1.0) are suitable for earth-based environments. Values
    that are slightly above 1.0 can be useful when simulating air pollution and other
    dramatic settings. Exaggerated values (for example, more than 2.0) can help to
    illustrate extreme conditions or even alien settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sky Tint: This is the color that is used to tint the Skybox. It is useful for
    fine-tuning or creating stylized environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ground: This is the color of the ground. It can really affect the Global Illumination
    of the scene. So, choose a value that is close to the level''s terrain and/or
    geometry (or a neutral one).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exposure: This determines the amount of light that gets in the Skybox. The
    higher levels simulate overexposure, while the lower values simulate underexposure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that the Skybox appearance will respond to the scene's
    Directional Light, playing the role of the sun. In this case, rotating the light
    around its X axis can create dawn and sunset scenarios, whereas rotating it around
    its Y axis will change the position of the sun, changing the cardinal points of
    the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Also, regarding the Environment Lighting, note that although we have used the
    Skybox as the Ambient Source, we could have chosen a Gradient or a single color
    instead, in which case the scene's illumination wouldn't be attached to the Skybox's
    appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, also regarding the Environment Lighting, please note that we have set
    the Ambient GI to real-time. The reason for this was to allow the real-time changes
    in the GI, promoted by the rotating Directional Light. In case we didn't need
    these changes at runtime, we could have chosen the baked alternative.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some ways to enhance this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and rising the sun through scripted rotation of Directional Light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make things even more interesting by using code to change the rotation
    of the Directional Light. This will give a dynamic rising/setting sun effect as
    our scene runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ceate a new C# script class named RotateLight, and add an instance object as
    a component to the Directional Light Game Object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you run the scene, you will see the sun rising/setting and the lighting
    colors changing accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sun flare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add a sun flare effect to our scene.
  prefs: []
  type: TYPE_NORMAL
- en: For this step, you will need to import Unity's Standard Assets Effects package,
    which you should have installed when you installed Unity, but you can also add
    it to an individual project via the Unity Asset Store.
  prefs: []
  type: TYPE_NORMAL
- en: Import the Light Flares contents from the Effects Unity Standard Assets package
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Directional Light. In the Inspector, for the Light component, populate
    the Flare slot with the sun flare (from the project panel, the Effects | Light
    Flares | Flares folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the scene section of the Lighting window, find the Other Settings subsection.
    Then, set Flare Fade Speed to 1 and Flare Strength to 0.46, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/977297a5-2005-4b84-a05b-e6021e33e58e.png)'
  prefs: []
  type: TYPE_IMG
- en: Play the scene. A sun flare effect should have been applied to the scene's lighting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reflecting surrounding objects with Reflection Probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want your scene's environment to be reflected by Game Objects by featuring
    reflective Materials (such as the ones with high Metallic or Specular levels),
    then you can achieve such an effect by using Reflection Probes. They allow for
    real-time, baked, or even Custom reflections through the use of Cubemaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'real-time reflections can be expensive in terms of processing; in which case,
    you should favor baked reflections, unless it''s really necessary to display dynamic
    objects being reflected (mirror-like objects, for instance). Still, there are
    some ways real-time reflections can be optimized. In this recipe, we will test
    three different configurations for reflection probes:'
  prefs: []
  type: TYPE_NORMAL
- en: real-time reflections (constantly updated)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: real-time reflections (updated on-demand via scripting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: baked reflections (from the editor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we have prepared a basic scene, featuring three sets of reflective
    objects: one is constantly moving, one is static, and one moves whenever it is
    interacted with. The `reflectionProbes.unitypackage` package that is containing
    the scene can be found inside the `07_07` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reflect the surrounding objects using the Reflection Probes, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the Unity package `reflectionProbes.unitypackage`. Then, open the scene
    named reflective_objects. This is a basic scene featuring three sets of reflective
    objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the Quality setting for the project has enabled real-time Reflection
    Probes. Do this by choosing menu: Edit | Project Settings | Quality, and ensuring
    that the real-time Reflection Probes option is checked for the quality setting
    you wish to use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the scene. Observe that one of the systems is dynamic, one is static, and
    one rotates randomly, whenever a key is pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let''s create a constantly updated real-time Reflection Probe for the scene
    (menu: Create | Light | Reflection Probe). Name it ReflectionProbe-real-time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make ReflectionProbe-real-time a child of the Game Object System 1 real-time
    | MainSphere. Then, in the Inspector, set its Transform Position to (0, 0, 0):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3b50102-891d-44f1-875d-145f4d30f154.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Inspector, find the Reflection Probe component. Set the Type as real-time,
    Refresh Mode as Every Frame, and Time Slicing as No time slicing, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c4253593-b2c5-44f6-8e20-c2af70874c7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Play the scene. The reflections on System 1 real-time will now be updated in
    real-time. Stop the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe that the only object displaying the real-time reflections is System
    1 real-time | MainSphere. The reason for this is the size of the box of the Reflection
    Probe. From the Reflection Probe component, change its size to (25, 10, 25). Note
    that the small red spheres are now affected as well. However, it is important
    to note that all objects display the same reflection. Since our Reflection Probe''s
    origin is placed at the same location as the MainSphere, all reflective objects
    will display reflections from that point of view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f3446e6a-e0d9-41b8-99e0-bc5164cb79b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to eliminate the reflection from the reflective objects within
    the Reflection Probe, such as the small red spheres, select the objects and, from
    the Mesh Renderer component, set Reflection Probes as Off, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ebb2c12a-221a-4f57-83c0-ae8ae69c33ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Add a new Reflection Probe to the scene. This time, name it ReflectionProbe-onDemand
    and make it a child of the System 2 On Demand | MainSphere GameObject. Then, in
    the Inspector, change its transform position to (0,0,0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, go to the Reflection Probe component. Set Type as real-time, Refresh Mode
    as Via scripting, and Time Slicing as Individual faces, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8920f18b-65a6-4d85-a52d-b83fb1ca4e72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new C# script class named UpdateProbe, and add an instance object
    as a component to GameObject ReflectionProbe-onDemand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, find the script class named RandomRotation, which is attached to the System
    2 On Demand | Spheres object, and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Save the script and test your scene. Observe how the Reflection Probe is updated
    whenever a key is pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the scene. Add a third Reflection Probe to the scene. Name it ReflectionProbe-custom
    and make it a child of the System 3 On Custom | MainSphere GameObject. Then, from
    the Inspector, change its Transform Position to (0,0,0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the Reflection Probe component. Set Type as Custom and click on the Bake
    button, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6743b6f1-ab65-40a9-b4fd-1fd00639c0f7.png)'
  prefs: []
  type: TYPE_IMG
- en: A Save File dialog window will show up. Save the file as ReflectionProbe-custom-reflectionHDR.exr.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe that the reflection map does not include the reflection of red spheres
    on it. To change this, you have two options: set the System 3 On Custom | Spheres
    GameObject (and all its children) as Reflection Probe Static, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/598c9a68-f0ae-4fb3-8ebc-769daec38cfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Or check the Dynamic Objects option Reflection Probe component of the ReflectionProbe-custom
    GameObject. Note that with this option, you will also see a reflection of the
    other two large spheres and their belt of red spheres in the reflection on the
    MainSphere of System 3 Custom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select GameObject ReflectionProbe-custom, and click the Bake button again. You
    should now see the reflection of red spheres on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want your reflection Cubemap to be dynamically baked while you edit
    your scene, you can set the Reflection Probe Type to baked, open the Lighting
    window (menu: Window | Rendering | Lighting Settings), access the scene section,
    and check the Auto Generate option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec69e6fb-7c18-4432-ba07-5768ab822e07.png)'
  prefs: []
  type: TYPE_IMG
- en: This mode won't include dynamic objects in the reflection, so be sure to set
    System 3 Custom | Spheres and System 3 Custom | MainSphere as Reflection Probe
    Static.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Reflection Probes element acts like omnidirectional cameras that render
    Cubemaps and applies them onto the objects within their constraints. When creating
    Reflection Probes, it''s important to be aware of how the different types work:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-time Reflection Probes**: **Cubemaps** are updated at runtime. The real-time
    Reflection Probes have three different Refresh Modes: On Awake (Cubemap is baked
    once, right before the scene starts); Every frame (Cubemap is constantly updated);
    Via scripting (Cubemap is updated whenever the RenderProbe function is used). Since
    Cubemaps feature six sides, the Reflection Probes features Time Slicing, so each
    side can be updated independently. There are three different types of Time Slicing:
    All Faces at Once (renders all faces at once and calculates mipmaps over 6 frames.
    It updates the probe in 9 frames); Individual Faces (each face is rendered over
    a number of frames. It updates the probe in 14 frames. The results can be a bit
    inaccurate, but it is the least expensive solution in terms of frame rate impact);
    No Time Slicing (the Probe is rendered and mipmaps are calculated in one frame.
    It provides high accuracy, but it also the most expensive in terms of frame rate).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'baked: Cubemaps are baked when editing the screen. Cubemaps can be either manually
    or automatically updated, depending on whether the Auto Generation option is checked
    (it can be found at the Scene section of the Lighting Settings window).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom: The Custom Reflection Probes can be either manually baked from the
    scene (and even include Dynamic objects), or created from a premade Cubemap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of additional settings that can be tweaked, such as Importance,
    Intensity, Box Projection, Resolution, HDR (Hight Dynamic Range), and so on. For
    a complete view on each of these settings, we strongly recommend that you read
    Unity's documentation on the subject, which is available at [http://docs.unity3d.com/Manual/class-ReflectionProbe.html](http://docs.unity3d.com/Manual/class-ReflectionProbe.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using Material Emission to bake light from a glowing lamp onto scene objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as Lights, other objects can also emit light if their Materials have
    Emmision properties (such as a Texture, and/or tint color). In this recipe we''ll
    create a lamp that glows green via its Emission Texture. The lamp and other 3D
    objects in the scene will be baked in order to create a pre-computed Lightmap
    for the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72bc19b6-ed07-4243-8c82-8c248898838e.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have provided a 3D lamp model (lamp), as well as a green
    Texture (lamp_emission) in the `lamp.unitypackage` Unity package in the `07_08`
    folder .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a glowing lamp using Material Emission, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D Project. You should start with a basic **scene** containing
    a Main Camera and a Directional Light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the Unity package `lamp.unitypackage` containing the 3D lamp model (lamp),
    as well as a green Texture (lamp_emission).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the 3D model asset lamp selected in the Project panel, in the Inspector,
    check its Generate Lightmap UVs option, and click on the Apply button to confirm
    the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9f09f3a-3ac6-475a-9b55-eb1c5a3aefb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project panel, select Material m_lamp. Check the Emission option, and
    then assign Texture lamp_emission to its Emission Color property. Set the Global
    Illumination drop-down menu to baked. This will make the lamp object emit a green
    light that will be baked into the Lightmap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/25a9c5cc-44c6-4b12-8fcd-87ce395edfe9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, for **Material** m_lamp, click the HDR color box, and increase the intensity
    of this light emitting Material to 1 or 2 (this is a value you may wish to play
    with and "tweak" in order to get your desired settings for a scene):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3625d0fc-d38f-481b-a77e-ccc329e3a0e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Add some 3D GameObjects to create a simple 3D scene containing a 3D Plane (the
    ground) and three 3D cubes. Position and scale the 3D cubes so that there is large
    one at the back of the 3D Plane, a medium sized one in the middle, and a small
    one in the front.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, drag an instance of the 3D lamp model from the Project panel into the
    scene, placing it near the front-most 3D cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f30a7637-0f32-4ad2-b990-d92d2f0b533c.png)'
  prefs: []
  type: TYPE_IMG
- en: You may need to adjust the Main Camera position and rotation so that you can
    see the lamp and the three 3D cubes sitting on the 3D Plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Baked lighting only works for static objects, so, with the exception of the
    Main Camera, select everything in the Hierarchy and check the Static option at
    the top-right of the Inspector panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0dffc329-6fdc-4607-a0c6-19a9bddc41a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, select the Directional Light in the Hierarchy and change its Light Mode
    drop-down menu property to baked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/558568d7-d39a-461a-bb3f-867941a07e66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now assign the **Directional Light** as an Environmental Lighting Sun
    source. Open the Lighting Settings window (choose menu: Window | Rendering | Lighting
    Settings), and drag the **Directional Light** from the **Hierarchy** into the
    Sun slot for the scene Environment properties. Also, set the Environment Lighting
    Ambient Mode drop-down menu to baked. In the Debug Settings, uncheck Auto Generate
    and click the Generate Lighting button to "bake" the Ambient light and green lamp
    emission light into the Scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7d55fc5d-37d4-4cc4-992f-d8b15ae8ccb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a few seconds (depending on the speed of your computer and the complexity
    of the scene), you''ll see a progess bar of the Lightmap baking process at the
    bottom-right of the Unity Editor application window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8aae3ffc-2d07-4b23-a377-60ce4cd5b95a.png)'
  prefs: []
  type: TYPE_IMG
- en: Play your **Scene**. You should see how the **Scene** objects are lit both by
    the Directional Light, and by the green Texture emitted from the lamp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the rotation of the Directional Light, and try setting its Light Intensity
    and Indirect Multiplier to 0.5\. Also, play with the HDR intensity of the Material
    m_lamp, and re-bake the Lightmap to make the lamp emission more emphasized (and
    the **Directional Light** play a lessor role).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have added an emissive **Material** to a GameObject (the lamp), and baked
    a Lightmap based on the static objects in the **Scene** (which include the lamp,
    the **Directional Light**, and the 3D Plane and cubes). The environment's Global
    Illumination ambient lighting is sourced from the Directional Light settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lightmaps are basically Texture maps including scene lights/shadows, global
    illumination, indirect illumination, and objects featuring the Emissive Materials.
    They can be generated automatically or on demand by Unity''s lighting engine.
    However, there are some points that you should pay attention to, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set all the non-moving objects and lights to be baked as Static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the game lights as Baked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the scene's Ambient GI as Baked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the Global Illumination option of the emissive materials as baked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate Light UVs for all 3D meshes (specially the imported ones)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either build the Lightmaps manually from the Lighting Settings window, or check
    the Auto Generate option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting a simple scene with Lightmaps and Light Probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lightmaps are a great alternative to real-time lighting, as they can provide
    the desired look to an environment without being processor-intensive. There is
    one downside, though – since there is no way of baking Lightmaps onto the dynamic
    objects, the lighting of the important elements of the game (such as player characters
    themselves) can look artificial, failing to match the intensity of the surrounding
    area. The solution? Light Probes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Light Probes work by sampling the light intensity over the location that they
    are placed at. Dynamic objects, once Light Probe-enabled, will be lit according
    to the interpolation of the nearest probes around them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e09c847-75d9-42bc-859a-3f5c5f281e9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared a basic Unity package (rollerballLevel.unitypackage),
    including a game environment containing emissive lamps (from the previous recipe!),
    and Game Objects, making a suitable level for a RollerBall game. The Game Objects
    are static, and the Directional Light and Emissive Material are set to baked,
    so the scene has been set up as a baked Lightmapped scene.
  prefs: []
  type: TYPE_NORMAL
- en: The rollerBallLevel.unitypackage package, containing the scene, can be found
    inside the `07_09` folder. You'll also find the two PNG images you need to create
    the RollerBall Material (RollerBallAlbedo.png and RollerBallSpecularGloss.png).
  prefs: []
  type: TYPE_NORMAL
- en: The geometry for this scene was created using ProBuilder, an extension developed
    by ProCore, which is now free as part of Unity 2018\. ProBuilder is a fantastic
    level design tool that speeds up the design process considerably for both simple
    and complex level design. You can learn more at [http://www.procore3d.com](http://www.procore3d.com) and [https://blogs.unity3d.com/2018/02/15/probuilder-joins-unity-offering-integrated-in-editor-advanced-level-design/](https://blogs.unity3d.com/2018/02/15/probuilder-joins-unity-offering-integrated-in-editor-advanced-level-design/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reflect the surrounding objects using the Reflection Probes, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import rollerBallLevel.unitypackage into a new project. Then, open the scene
    named scene0_level_baked. The scene features a basic environment, with a Directional
    Light and some green emissive lamps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import Standard Assets into your project. We need three packages, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cameras
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Characters (we need the RollerBall, so you can uncheck FirstPersonCharacter
    and ThirdPersonCharacter when importing)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Effects (we just need the Projectors assets, so you can uncheck all other folders
    apart from that one when importing)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag the RollerBall prefab from the **Project** panel (Standard Assets | Characters
    | RollerBall | Prefabs) into the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the FreeLookCameraRig prefab from the **Project** panel (Standard Assets
    | Cameras | Prefabs) into the scene. If this does not automatically target the
    RollerBall character, then drag the RollerBall Game Object from the **Hierarchy**
    into the Free Look Cam (Script) Target slot in the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's add a little color to our RollerBall by creating and applying a new **Material**
    for this GameObject. Create a new Material m_rollerballColor with a Specular setup.
    Set the Albedo Texture to RollerBallAlbedo and its tint to 127/127/127\. Set the
    Specular Texture to RollerBallSpecularGloss.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Game Object RollerBall in the **Hierarchy**. Apply the m_rollerballColor **Material**
    to the RollerBall Game Object. This should now be a two-colored ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to ensure that the RollerBall GameObject will be dynamically affected
    by Light Probes, so with Game Object RollerBall still selected in the Hierarchy,
    for the Mesh Renderer component for the Light Probes option, choose the Blend
    Probes option from the drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d3b17fbc-c1d1-409a-b690-745e2db1ad2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to create the Light Probes for the scene. Choose the Hierarchy
    menu: Create | Light | Light Probe Group. This will give you a basic group of
    eight Light Probes, arranged in pairs to form a cubic volume.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to note that even if you are working on a level that is flat,
    you shouldn't place all your probes on the same level, as Light Probe Groups will
    form a volume in order for the interpolation to be calculated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate the manipulation of the probes, type **Probe** into the search
    field of the Hierarchy panel. This will isolate the newly created Light Probe
    Group, making it the only editable object on the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d1cc991c-8776-40d9-ba91-193396c50b6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Change your viewport layout to 4 Split by choosing Window | Layouts | 4 Split.
    Then, set viewports as Top, Front, Right, and Persp. Optionally, change Top, Front,
    and Right views to Wireframe mode. Finally, make sure that they are set to Orthographic
    view, as shown in the following screenshot. This will make it easier for you to
    position the Light Probes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d470e30f-9659-4ce5-9704-84340d157293.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Position the initial Light Probes at the corners of the top room of the level.
    To move the Probes around, simply click and drag them, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/333f2e3e-1ed4-47a6-a342-6d0b3eb9a8f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the four probes to the left side of the tunnel''s entrance. Then, duplicate
    them (use the *Ctrl/Cmd + D* keys). Finally, drag the new probes slightly to the
    right, to a point that they are no longer over the shadow that is projected by
    the wall, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ed9c4e6-67cb-4df5-b159-c45bb722c52f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Repeat the last step, this time duplicating the probes next to the tunnel''s
    entrance and bringing them inward toward the group. To delete the selected probes,
    either use the respective button on the Light Probe Group component, or use the
    *Ctrl/Cmd + Backspace* keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7704c28b-874e-4a22-b873-f34c77a2fc43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Duplicate and reposition the four probes that are nearest to the tunnel, repeating
    the operation five times and conforming each duplicate set to the shadow projected
    by the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8beb8aca-bcf0-4409-9a45-5b45aa6295dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the Add Probe button to place the three probes over well-lit areas of the
    scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/beaef73f-b81e-416b-967f-005384f857ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, add Light Probes within the shadow that is projected by the L-shaped wall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6093f2df-5778-4305-9047-51375d48c138.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the Rollerball is able to jump, place the higher probes even higher so
    that they will sample the lighting above the shadowed areas of the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6805e6ad-fca4-41f2-9abd-9cd5f466332a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Placing too many Light Probes on a scene might be memory intensive. Try optimizing
    the Light Probes Group by removing the probes from the regions that the player
    won''t have access to. Also, avoid overcrowding the regions of continuous lighting
    conditions by removing the probes that are too close to others in the same lighting
    condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bc5888fa-5610-42cc-a2db-84aed4342886.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To check out which Light Probes are influencing the Rollerball at any place,
    move the Rollerball Game Object around the scene. A polyhedron will indicate which
    probes are being interpolated at that position, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/99f89ca1-7468-4067-a51c-29e931c04614.png)'
  prefs: []
  type: TYPE_IMG
- en: From the bottom of the Lighting Settings window, click on the Generate Lighting
    button and wait for the Lightmaps to be baked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test the scene. The Rollerball will be lit according to the Light Probes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f115318f-ebc8-4883-ae64-8b64b081a35d.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep adding probes until the level is completely covered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Light Probes work by sampling the scene's illumination at the point that they're
    placed at. A dynamic object that has Use Light Probes enabled has its lighting
    determined by the interpolation between the lighting values of the four Light
    Probes, defining a volume around it (or, in case there are no probes suited to
    define a volume around the dynamic object, a triangulation between the nearest
    probes is used).
  prefs: []
  type: TYPE_NORMAL
- en: More information on this subject can be found in the Unity's documentation at [http://docs.unity3d.com/Manual/LightProbes.html](http://docs.unity3d.com/Manual/LightProbes.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case you can spare some processing power, you can exchange the use of Light
    probes for a Mixed light.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the Light Probe Group from your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Directional Light** and, from the Light component, change Baking
    to Mixed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set Shadow Type as Soft Shadows and Strength as 0.5, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9e3fd18f-9612-4bfc-8122-87001918ac49.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, click on the Generate Lighting button and wait for the Lightmaps to
    be baked. The **Real-Time** light/shadows will be cast into/from the dynamic objects,
    such as Rollerball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
