- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Your First Minimal API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The convenience of the .NET ecosystem could not be more evident by the steps
    you took in the last chapter. Minimal APIs in .NET live up to their name by having
    not only minimal logic and dependencies but also minimal setup requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Just by creating your first project, you have technically already created your
    first minimal API. It’s functional out of the box, with a **GET** endpoint that
    returns a response.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, there is more to minimal APIs than what we saw in the **Hello World**
    example. There are different HTTP request methods, varying endpoints, and more
    advanced response generation to consider as part of a straightforward API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Project structure and organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining endpoints and routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the employee management API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have gained experience in defining endpoints
    for handling HTTP requests. You’ll also be able to implement basic HTTP request
    handling and response generation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the directions in this chapter, you’ll need to have the following
    installed on your Windows, macOS, or Linux machine:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET 9.0 **Software Development** **Kit** ( **SDK** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio or Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# Extension for Visual Studio Code (if you are using Visual Studio Code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you followed the setup guidance in [*Chapter 1*](B20968_01.xhtml#_idTextAnchor014)
    , then you are ready to follow the directions in this chapter. However, if you
    still need to configure the preceding tools, then please follow the [*Chapter
    1*](B20968_01.xhtml#_idTextAnchor014) setup instructions under the *Installing
    required tools and dependencies* section. The code for this chapter is available
    in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET
    -9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9) .'
  prefs: []
  type: TYPE_NORMAL
- en: Project structure and organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rules around how a project is structured and organized are not exactly rigid,
    but it is important to ensure that you are organizing your projects in a cohesive
    and accessible manner. With minimal APIs in general, we are aiming for simplicity.
    Project structure and organization in minimal APIs specifically are no different.
    Therefore, it may not come as a shock that the project structure for minimal APIs
    outlined in the following examples will be extremely basic.
  prefs: []
  type: TYPE_NORMAL
- en: In the following three subsections, we look at the elements needed to simplify
    our project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Endpoints** are the *open doors* to your API. Each endpoint sits within an
    area of your domain (e.g., employees or inventory) and is responsible for specific
    actions within that domain, such as adding, updating, or removing an inventory
    item.'
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET **Controller** -based projects, you would usually distribute endpoints
    for each area of the domain into logical groups called **Controllers** . Each
    **Controller** is a class containing endpoints that are relevant to that **Controller’s**
    domain area.
  prefs: []
  type: TYPE_NORMAL
- en: However, in minimal APIs, it is normal for endpoints to simply be defined in
    the app’s entry-point, within **Program.cs** .
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like in **Model-View-Controller** ( **MVC** ) projects, a model in minimal
    APIs can be used to encapsulate domain objects. Models are usually created as
    their own classes. In the upcoming examples, which demonstrate API endpoint mappings,
    I will be creating logic for an API that manages employees. Therefore, I will
    use a model in the form of an **Employee** class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a class to represent domain objects brings many benefits, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns** : Models encapsulate the data for the application,
    separating it from the business logic, which will be found within the API layer
    in our case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability** : Model objects can be reused by business logic across the
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loose coupling** : Thanks to the separation of concerns between data and
    business logic, changes to the API need not affect the structure of the data inadvertently.
    This is particularly important in common cases where models mirror a database
    table’s structure through an ORM such as Entity Framework or Dapper (See [*Chapter
    8*](B20968_08.xhtml#_idTextAnchor132) ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staying organized
  prefs: []
  type: TYPE_NORMAL
- en: While minimal API project structures can afford to stay very simple, it’s still
    important to keep them organized. It is good practice to keep all models in a
    dedicated **Models** folder and all endpoints in their own **Endpoints** folder.
  prefs: []
  type: TYPE_NORMAL
- en: For the final piece in the project structure puzzle, we have routes.
  prefs: []
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If endpoints are the open door into the API, **routes** are the address of each
    door. By creating a route, you are defining the URLs that your API will respond
    to, and which piece of logic will be executed as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Routes can be standalone or contain parameters that will be passed through to
    the resulting API logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the endpoint on the following pages, you will see routes defined in the form
    of strings, indicating the text that should be appended onto the application’s
    base URL to access specific endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if our application is hosted at **getInventoryItem** , the full
    URL for that endpoint would become [https://adventureworks.com/getInventoryItem](https://adventureworks.com/getInventoryItem)
    .
  prefs: []
  type: TYPE_NORMAL
- en: We can, however, make our routes more generic. **getInventoryItem** is certainly
    clear, but it is better practice to, where possible, send different kinds of requests
    to a generic route, with different logic firing depending on the HTTP method in
    use.
  prefs: []
  type: TYPE_NORMAL
- en: For example, instead of naming our route **getinventoryitem** , we could apply
    the generic name **inventoryitems** to as many HTTP methods as is relevant. This
    means that a **GET** request (we will learn about these methods in the next section)
    to this route will get an inventory item, but a **POST** to the same route will
    create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is deemed to be a best practice for naming routes, for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency** : Since having a generic endpoint has become an API convention,
    it allows your API to conform to an agreed standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intuitiveness** : Most developers consuming an API will work to the same
    standard. This means that they will be more quickly able to pick up your API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RESTful principles** : Allowing the HTTP method to identify the function
    of an endpoint rather than the route allows us to conform to RESTful principles,
    which encourage good use of **CREATE, READ, UPDATE, DELETE** ( **CRUD** ) operations,
    idempotency (during multiple identical requests, the server’s state is never changed,
    and it returns the same results for the same request each time), and the need
    for full coverage of the standard HTTP methods ( **GET** , **POST** , **PUT**
    , **PATCH** , **DELETE** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast to the list, if you have API endpoints that support an HTTP method
    in a very bespoke use case, you can still create routes that are more specific.
    However, the customary practice is to use the generic route naming convention
    that we outlined.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding routes is critical to minimal API development in addition to most
    API fram eworks. Let’s turn our attention to the way in which routes and their
    endpoints are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Defining endpoints and routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other RESTful API framework, minimal API endpoints are accessed using
    different HTTP methods. Depending on the HTTP method used to contact the API endpoint,
    a different result will be produced, or an action will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we will look at some examples of endpoints being mapped
    with different HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: GET methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An HTTP **GET** method is a request for information. On successful retrieval,
    the API endpoint returns a **200 OK** status code, along with the requested data.
  prefs: []
  type: TYPE_NORMAL
- en: The example shows a **GET** endpoint mapped to the **"/employees"** route. It
    gets the employee ID contained within the URL and uses this to find the relevant
    employee data before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if this API were hosted at constoso.com, a **GET** call to [contoso.com/employees/24](https://contoso.com/employees/24)
    would retrieve the employee whose ID is **24** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at **POST** methods now.
  prefs: []
  type: TYPE_NORMAL
- en: POST methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An HTTP **POST** method is a request to create something. On successful execution,
    the API endpoint usually returns a **201 Created** status code (this is best practice,
    although some APIs return the standard **200 OK** code), along with any relevant
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows a **POST** method mapped to the **"/employees"**
    endpoint. It expects to receive an employee payload in JSON format. The endpoint
    then converts the payload into an object of the **Employee** type, before calling
    some other back-end code to create an **Employee** , using this object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If everything worked as expected, the endpoint returns a **201 Created** status
    code, along with the **Employee** **Created** message.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if this API were hosted at **constoso.com** , a **POST** call
    would execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Up next, we look at **PUT** methods.
  prefs: []
  type: TYPE_NORMAL
- en: PUT methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An HTTP **PUT** method is a request to update something. It’s important to remember
    that **PUT** updates a resource in a particular way compared to the **PATCH**
    method, which has its own way of updating.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUT** methods require a payload that represents the entire resource being
    updated. So, in the case of our **Employee** API, if you were to use a **PUT**
    endpoint to update an existing employee, the API endpoint would expect a full
    **Employee** object to be sent in the request. It would then find the existing
    employee and replace it with the one sent in the request.'
  prefs: []
  type: TYPE_NORMAL
- en: On successful execution, the API endpoint returns the standard **200 OK** status
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The example shows a **PUT** method mapped to the **"/employees"** route. It
    expects to receive an employee payload in JSON format. Like in the preceding **POST**
    example, the endpoint converts this JSON payload into an object of the **Employee**
    type, before finding the original employee and calling a method to replace it
    with the updated one
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if this API was hosted at constoso.com, a **PUT** call would execute
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: PATCH methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like a **PUT** method, an HTTP **PATCH** method is also a request to update
    something. However, the way it does its update is different. Instead of requiring
    a payload containing a representation of the entire object, a **PATCH** method
    only requires that the individual values that need to be changed are sent as part
    of the request. The API can then take care of updating the relevant properties
    on the existing object.
  prefs: []
  type: TYPE_NORMAL
- en: On successful execution, the API endpoint usually returns the standard **200
    OK** status code.
  prefs: []
  type: TYPE_NORMAL
- en: The example shows a **PATCH** method mapped to the **"/updateEmployeeName"**
    route. It expects to receive an **Employee** object like **POST** and **PUT**
    . However, it is only interested in the **Name** and **Id** properties. This means
    that as long as a JSON payload is sent and it contains these properties, it will
    work. Using these properties, the code fetches the right object of the **Employee**
    type based on the given Id. It then updates the name property on the retrieved
    employee only, without overwriting the whole object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if this API was hosted at constoso.com, a **P** **ATCH** call
    would execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The final method we will look at is **DELETE** .
  prefs: []
  type: TYPE_NORMAL
- en: DELETE method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **DELETE** method is self-explanatory in terms of what it does. Sending an
    ID for a resource as a parameter in the same way we did for the **GET** endpoint,
    the API can locate that specific resource and then remove it.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, on success, a **DELETE** method will usually return the standard
    **200 OK** status code, but it may instead return **204 No Content** , which is
    also fine.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows a **DELETE** method mapped to the **"/employees"**
    route. The endpoint will use the **Id** parameter to find the corresponding object
    of the **Employee** type as the target for deletion. After removing the **Employee**
    object, it returns a **204 No Content** status code to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this API was hosted at constoso.com, a **DELETE** call to [https://contoso.com/employees](https://contoso.com/employees)
    would execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you feel you’ve understood the different HTTP methods available to our
    API, turn to the next section to start building a basic minimal API based on a
    simple, real-world use case.
  prefs: []
  type: TYPE_NORMAL
- en: Building the employee management API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered an overview of routing and endpoints, along with the
    ways in which they support the various HTTP methods, let’s start building a new
    minimal API project, with the use case of employee management.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal in this section will be to create a repository of employees on which
    our API can operate. The API will then be able to get, create, update, and delete
    employees.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the next few steps to create the employee management API.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t followed the steps in [*Chapter 1*](B20968_01.xhtml#_idTextAnchor014)
    to create your ASP.NET project in Visual Studio or Visual Studio Code, follow
    them first, and then continue with the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may already have this in your project, but if not, ensure that it is present
    at the top of **Program.cs** . This will build the **WebApplication** instance
    that hosts the minimal API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The two lines in the previous step are enough to build the **WebApplication**
    instance, but it still needs to be started. Add this line to the bottom of your
    class to start the instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you have a runnable app, but no endpoints. Before we define those endpoints,
    we need some data to work with. We’ll come back to **Program.cs** to define the
    endpoints shortly. But before that, let’s create a model of the **Employee** type:'
  prefs: []
  type: TYPE_NORMAL
- en: In the folder structure of the project, create a new folder called **Models**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the new folder, create a new class called **Employee** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create these properties in the **Employee** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This model can be used to represent an **Employee** resource, on which the API
    can perform various CRUD operations. Ordinarily, we would keep this data in a
    database, such as SQL, but for now, we’re going to keep it simple and store the
    employees in a collection. To do this, the collection needs to be situated somewhere
    in which it can be accessed by the endpoints we’re about to create.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top level of the project, (the same level as **Program.cs** ), create
    a new class called **EmployeeManager** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want this class to be available at any time, without the need to instantiate
    it, so make it a static class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a private **List** of the **Employee** type at the top of the class. Your
    class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have an easily accessible class that can store the employees. As the
    collection is private, we can now add a set of methods that can be publicly exposed
    to the endpoints to perform operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re about to create logic for the CRUD actions to be performed on each **Employee**
    in the collection. As part of this, it will be necessary to look up each employee
    object in the list. Let’s add a private function that will find this for us, for
    reuse on each CRUD operation. With the private function added, the class now looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update the class so that it contains the CRUD methods and functions
    shown in this code sni ppet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The **EmployeeManager** class will now enable our API endpoints to perform specific
    CRUD actions on employees in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the first endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first endpoint to add will be the **GET** endpoint for retrieving a specific
    **Employee** object by its ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following **GET** endpoint in **Program.cs** right above the final
    **app.Run()** line you added earlier in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code starts by referencing the **WebApplication** instance known as **app**
    , calling the **MapGet** method. There are equivalent mapping methods in **WebApplication**
    named based on the type of HTTP method. Examples include **MapPut** , **MapPost**
    , and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter expected on the mapping method will be the route you wish
    to listen to. In this case, we are mapping to the **"/employees/{id}"** route,
    which uses a routing parame ter (more on this in [*Chapter 4*](B20968_04.xhtml#_idTextAnchor081)
    ) to capture an employee ID.
  prefs: []
  type: TYPE_NORMAL
- en: This is then followed by a second parameter in the form of a lambda expression,
    which uses the passed-in ID to execute the intended logic. At this point, the
    code calls the **Create()** function defined in the **EmployeeManager** class
    before finally returning the result to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the remaining endpoints to **Program.cs** below the **GET** endpoint we
    just created and above the **app.Run()** method. **Program.cs** should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that all of the subsequent endpoints you’ve mapped follow a similar
    pattern to the first **GET** endpoint you added. Each of them specifies the HTTP
    method type that is being used, followed by the route, then by any parameters.
    There is then a body that executes relevant logic before a result is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the code should compile. (If it does not, check that everything
    has been typed in correctly.) So, run the application (click the play button in
    Visual Studio or use the **dotnet run** terminal command in Visual Studio Code)
    and make some test requests to each of the created endpoints. The **POST** , **PUT**
    , and **PATCH** endpoints expect an **Employee** object as a parameter, so ensure
    that you have sent JSON that mirrors the structure of the **Employee** model.
    Look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Having created an endpoint, it is time we test it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your endpoint using OpenAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET 9 introduces OpenAPI integration, meaning that you can simply install a
    package and change the configuration of your API in **Program.cs** to generate
    a JSON representation of your API and its endpoints. This is useful because you
    can import it into API tools such as Postman, from which you can then easily test
    your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to test in this manner, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the **Microsoft.AspNetCore.OpenApi** package via NuGet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update **Program.cs** so that it uses OpenApi:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the API and navigate to the **openAPI/v1.json** route. This will provide
    you with a representation of your API schema, which can be imported into API clients
    such as Postman for testing.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the chapter, you’ve now mapped endpoints with varying HTTP
    methods, provided them with routes and parameters, created models, and added logic
    to be executed. The goal of the endpoint is to return a response to the client.
    We now need to handle the requests by returning a response.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET provides a handy helper object for sending responses back to clients,
    called **IResult** .
  prefs: []
  type: TYPE_NORMAL
- en: An **IResult** contains properties that can be used to represent standard HTTP
    responses for many different scenarios. For example, we could use IResult to return
    a specific status code, return JSON data, or even trigger **ASP.NET Identity**
    provider functionality such as challenges and sign-in/out.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new IResult easily using ASP.NET’s **Results** factory class.
    In the preceding examples, you will have seen references to this factory class,
    where the API has returned status codes by calling **Results.OK()** and **Results.Created()**
    , to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these simple HTTP status code methods have optional parameters that
    allow you to return strongly typed objects as JSON. For example, while you can
    simply return a **200** result by omitting any parameters in **Results.OK()**
    , you can also pass an object argument, and it will be sent back to the client.
    This was done in our Employee API endpoints for the **GET** endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The ability to pass strongly typed .NET objects such as **Employee** back to
    the client in a helper method is one of the most powerful aspects of minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’ll be more detailed examples of handling HTTP requests in [*Chapter 4*](B20968_04.xhtml#_idTextAnchor081)
    . For now, here are some examples of how **Results** can be used to return common
    HTTP responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After exploring **Results** , let’s take a look at one of its alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Typed Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative to using **Results** to return specific HTTP status codes is
    **TypedResults** , which is similar to **Results** but where the example responses
    using **Results** return an **IResult** each time, **TypedResults** returns a
    strongly typed object representing the status code.
  prefs: []
  type: TYPE_NORMAL
- en: '**TypedResults** implements a factory returning the appropriate strongly typed
    object that implements **IResult** for the specified status (e.g., returning **OK<string>**
    for a **200** **OK** result).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use **TypedResults** in virtually the same way you use **Results**
    . Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'NET 9 also introduces support for **500 INTERNAL SERVER ERROR** responses in
    **TypedResults** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should now have a decent understanding of how to handle HTTP
    requests, returning the relevant HTTP status codes and strongly typed objects
    back to the client. Let us sum up everything we have covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered most of the introductory aspects of creating simple
    minimal APIs, and you created your first minimal API project.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to define endpoints, and how they act as doors into the API,
    each of them sitting on their respective routes. Using the example of the **Employee**
    API, you gained insight into how to structure your project, splitting endpoints
    and data to achieve the benefits of loose coupling and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: You explored the concept of models as data structures that describe the domain
    objects in use by the API, and you built a simple CRUD system for manipulating
    data during requests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you gained a basic understanding of how to handle HTTP requests in
    a minimal API, using ASP.NET helper logic to compose and return responses to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with your foundational knowledge, turn to the next chapter, where we will
    explore the anatomy of a minimal API. We’ll delve deeper and more scientifically
    into the key components that make up minimal APIs, and you’ll be introduced to
    some of the various architectural and design patterns that can be adopted to fully
    realise their potential.
  prefs: []
  type: TYPE_NORMAL
