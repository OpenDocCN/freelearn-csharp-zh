- en: Working with the Middleware Pipeline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与中间件管道一起工作
- en: 'The previous chapter provided an overview of ASP.NET Core projects. We looked
    at how to create an ASP.NET Core project and how to deal with the files and the
    structure involved. Also, we learned some of the basic concepts behind the MVC
    stack and ASP.NET Core. Now, let''s explore the concept of middleware in depth.
    Middleware is an essential part of the ASP.NET Core platform: it helps us to deal
    with incoming requests and outgoing responses. Most of all, these types of components
    can be used to monitor performances and implement cross-cutting functionalities.
    The chapter starts with an introduction to the middleware concept. It goes on
    to show how to implement custom middleware and it ends with an overview of the
    built-in middleware of ASP.NET Core.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章提供了 ASP.NET Core 项目的概述。我们了解了如何创建 ASP.NET Core 项目以及如何处理相关的文件和结构。我们还学习了 MVC
    堆栈和 ASP.NET Core 背后的某些基本概念。现在，让我们深入探讨中间件的概念。中间件是 ASP.NET Core 平台的重要组成部分：它帮助我们处理进入的请求和发出的响应。最重要的是，这些类型的组件可以用来监控性能和实现横切功能。本章从中间件概念的介绍开始。接着展示如何实现自定义中间件，并以
    ASP.NET Core 内置中间件的概述结束。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Introducing middleware and dealing with its different aspects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍中间件及其不同方面
- en: Concrete use cases for middleware in an ASP.NET Core project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 项目中中间件的具体用例
- en: An overview of the built-in middleware of ASP.NET Core
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 内置中间件的概述
- en: Implementing custom middleware
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义中间件
- en: Introducing middleware
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍中间件
- en: As the name suggests, middleware is a component placed between our application
    and incoming requests. Incoming requests hit the middleware's pipeline before
    they can reach the effective logic implemented in our application. As a result,
    middleware are considered one of the essential concepts of ASP.NET Core because
    it is the first layer in front of our application, and it is usually associated
    with cross-cutting concepts such as *logging*, *error handling*, *authentication*,
    and *validation.* It can also perform advanced tasks such as *conditional service
    initialization,* based on a request.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，中间件是放置在我们应用程序和进入请求之间的组件。进入请求在到达我们应用程序中实现的有效逻辑之前会击中中间件的管道。因此，中间件被认为是 ASP.NET
    Core 的基本概念之一，因为它是我们应用程序前面的第一层，通常与*日志记录*、*错误处理*、*身份验证*和*验证*等横切概念相关联。它还可以根据请求执行诸如*条件服务初始化*等高级任务。
- en: 'In general, middleware can:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，中间件可以：
- en: Handle, process, and modify incoming *HTTP requests*
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理、处理和修改进入的*HTTP 请求*
- en: Handle, process, and change outgoing *HTTP responses*
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理、处理和更改发出的*HTTP 响应*
- en: Interrupt the middleware pipeline by returning an *early response*
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过返回*早期响应*来中断中间件管道
- en: 'Furthermore, the whole ASP.NET Core stack is composed of middleware. Middleware
    is also compliant with some essential concepts of *clean code*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，整个 ASP.NET Core 堆栈由中间件组成。中间件也符合一些*清洁代码*的基本概念：
- en: 'Each middleware focuses on a single purpose: taking a request and enhancing
    it. It is advisable to implement new middleware for each goal, to be compliant
    with the *single responsibility principle*.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个中间件专注于单一目的：接收一个请求并增强它。建议为每个目标实现新的中间件，以符合*单一职责原则*。
- en: Middleware also uses the concept of *chaining.* It takes an incoming request
    and passes it through the next piece of middleware. Therefore, every piece of
    middleware enhances the request and it decides whether to interrupt or continue
    the middleware pipeline.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件还使用了*链式*的概念。它接收一个进入的请求，并将其传递给下一个中间件。因此，每个中间件都会增强请求，并决定是否中断或继续中间件管道。
- en: 'As previously mentioned, middleware can *short-circuit* the pipeline, which
    means that it can block our requests and skip the rest of the pipeline. This *short-circuit*
    concept should not be underestimated as it is an excellent way to *increase the
    performance* of our service. Furthermore, the request will not hit our controllers
    if there is something wrong or if the user is not authorized to proceed. Moreover,
    the middleware pipeline is usually associated with a schema that looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，中间件可以*短路*管道，这意味着它可以阻止我们的请求并跳过管道的其余部分。这个*短路*概念不应被低估，因为它是我们服务*提高性能*的绝佳方式。此外，如果出现问题或用户没有权限继续操作，请求将不会击中我们的控制器。此外，中间件管道通常与如下所示的架构相关联：
- en: '![](img/ecf5ed76-d153-4a5b-95e1-0870d11ec63a.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecf5ed76-d153-4a5b-95e1-0870d11ec63a.png)'
- en: A single piece of middleware can act, and perform logic, on the *request* but
    also the *response.* Besides, it is essential to understand that the order of
    middleware counts—indeed, we declare the order when we bind it to our pipeline.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单个中间件可以在**请求**上执行操作并执行逻辑，也可以在**响应**上执行。此外，理解中间件顺序的重要性至关重要——实际上，当我们将其绑定到管道时，我们声明了顺序。
- en: The middleware pipeline in practice
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际中的中间件管道
- en: 'We have looked at some theory behind the middleware pipeline and how it can
    be useful in terms of short-circuiting and the single responsibility principle.
    Now let''s contextualize that in ASP.NET Core. In the previous chapter, we looked
    at the default Web API template provided by .NET Core. Let''s proceed by replacing
    the content of the `Startup` class with the following snippet of code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了中间件管道背后的理论以及它在短路和单一责任原则方面的有用性。现在让我们在ASP.NET Core中具体化这一点。在前一章中，我们研究了.NET
    Core提供的默认Web API模板。让我们通过用以下代码片段替换`Startup`类的内容来继续：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can run this project by executing the following CLI command in the `SampleAPI`
    folder:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`SampleAPI`文件夹中执行以下CLI命令来运行此项目：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The aforementioned command starts our application using the `http://localhost:5000`
    address. We can invoke it using our browser:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用`http://localhost:5000`地址启动我们的应用程序。我们可以使用浏览器调用它：
- en: '![](img/68e623dc-705d-4dc5-a2b1-a89fd8ce1baf.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68e623dc-705d-4dc5-a2b1-a89fd8ce1baf.png)'
- en: As you can see, running Hello, World! using a middleware strategy is simple.
    It requires implementing the `Configure` method, which is the method whereby middleware
    is usually defined. `app.Run` executes a delegate method, which is the representation
    of our middleware. In our case, it takes the `HttpContext` of the request and
    writes content inside the response of the context.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用中间件策略运行“Hello, World!”很简单。它需要实现`Configure`方法，这是中间件通常被定义的方法。`app.Run`执行一个委托方法，这是我们的中间件的表示。在我们的例子中，它接受请求的`HttpContext`并在上下文的响应中写入内容。
- en: 'It is essential to understand how the ASP.NET Core framework implements the
    `Run` method. Let''s have a closer look at the implementation of the `Run` method
    by checking the code in the `Microsoft.AspNetCore.Builder` namespace:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理解ASP.NET Core框架如何实现`Run`方法至关重要。让我们通过检查`Microsoft.AspNetCore.Builder`命名空间中的代码来更仔细地看看`Run`方法的实现：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code gives us more details about what we are doing. We notice
    that the `RequestDelegate` handler cannot be `null`, and if we go deep into the
    stack we can see that our delegate will be added *at the end of the pipeline*
    by using the `app.Use` extension method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码提供了我们正在执行操作的更多细节。我们注意到`RequestDelegate`处理器不能为`null`，如果我们深入到调用栈中，我们可以看到我们的委托将通过`app.Use`扩展方法被添加到**管道的末尾**。
- en: It is essential to understand that the order of middleware counts. The order
    of the middleware pipeline is implicitly defined in the `Configure` method of
    the `Startup` class. Furthermore, *MVC middleware* is usually the last one hit
    by requests; on the other hand, authorization *middleware* is generally placed
    before other middleware to guarantee the correct security level (putting authorization
    *middleware* after *MVC middleware* may damage our service and make it unsafe)*.*
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理解中间件顺序的重要性。中间件管道的顺序在`Startup`类的`Configure`方法中隐式定义。此外，**MVC中间件**通常是被请求击中的最后一个；另一方面，**授权中间件**通常被放置在其他中间件之前，以确保正确的安全级别（将授权**中间件**放在**MVC中间件**之后可能会损害我们的服务并使其不安全）*.*
- en: HttpContext in ASP.NET Core
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core中的HttpContext
- en: 'In the previous example, we saw how to create middleware using the `app.Run`
    extension method. A key concept involved in that implementation is the `HttpContext`
    type, which is the unique entry point for obtaining all information about HTTP
    properties; it is usually related to the incoming request. The `HttpContext` attribute
    exposes methods and properties to get information from the request and update
    information in the response. The response and request information are represented
    by the following attributes: `HttpContext.Response` and `HttpContext.Request`.
    For example, in the previous case, we used the `WriteAsync` method, which wrote
    the `Hello World!` string in response to the current `HttpContext`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了如何使用 `app.Run` 扩展方法创建中间件。该实现中涉及的一个关键概念是 `HttpContext` 类型，它是获取所有
    HTTP 属性信息的唯一入口点；它通常与传入的请求相关。`HttpContext` 属性公开了从请求中获取信息和在响应中更新信息的方法和属性。响应和请求信息由以下属性表示：`HttpContext.Response`
    和 `HttpContext.Request`。例如，在上一个案例中，我们使用了 `WriteAsync` 方法，该方法将 `Hello World!` 字符串写入到当前的
    `HttpContext` 响应中。
- en: Dependency injection is a core part of ASP.NET Core. `HttpContext` has all references
    to services instantiated in the current request. To be specific, it provides a
    `RequestServices` property, which refers to the service container. We will explore
    dependency injection in more detail in the next chapter. Declaring a piece of
    *inline* middleware using the `app.Run` method is not the only way to define new
    middleware. Furthermore, in the following sub-section, we will see how to build
    middleware logic using a *class-based* approach.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是 ASP.NET Core 的核心部分。`HttpContext` 包含了当前请求中实例化的所有服务的引用。具体来说，它提供了一个 `RequestServices`
    属性，该属性指向服务容器。我们将在下一章中更详细地探讨依赖注入。使用 `app.Run` 方法声明一段 *内联* 中间件不是定义新中间件的唯一方式。此外，在下面的子节中，我们将看到如何使用
    *基于类的* 方法构建中间件逻辑。
- en: Class-based middleware
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于类的中间件
- en: 'Middleware can also be implemented by using a *class-based* approach*.* This
    kind of approach increases the r*eusability*, *testability*, and *maintainability*
    of middleware. A *class-based* approach involves the definition of a new type,
    for example. Let''s have a look at class-based middleware:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件也可以通过使用 *基于类的* 方法来实现。这种方法增加了中间件的 *可重用性*、*可测试性* 和 *可维护性*。基于类的方法涉及定义一个新的类型，例如。让我们看看基于类的中间件：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s examine some key points in this class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察这个类的一些关键点：
- en: '`RequestDelegate` represents the reference to the next element in the pipeline.
    This could be a delegate or other class-based middleware.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestDelegate` 代表对管道中下一个元素的引用。这可能是委托或其他基于类的中间件。'
- en: '`InvokeAsync` is the core part of our middleware*.* This contains the implementation
    of the middleware and calls the `_next` element in our pipeline. At this point,
    our implementation must choose between continuing the pipeline or only returning
    a result to the client. For example, in the case of a *not authorized* message,
    the middleware will interrupt the pipeline.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvokeAsync` 是我们中间件的核心部分。这包含了中间件的实现并调用管道中的 `_next` 元素。在这个点上，我们的实现必须在继续管道或仅向客户端返回结果之间做出选择。例如，在
    *未授权* 消息的情况下，中间件将中断管道。'
- en: 'After defining our middleware class, we need to add it to our pipeline. An
    excellent way to do this is to establish a new extension method as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义我们的中间件类之后，我们需要将其添加到我们的管道中。一种很好的方法是创建一个新的扩展方法，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After this, we can add our middleware to the pipeline in our `Startup` class
    by executing the extension method previously defined:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以在 `Startup` 类中通过执行之前定义的扩展方法将我们的中间件添加到管道中：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding implementation provides a way to encapsulate the logic of the
    middleware in the `SampleMiddleware` class. This approach is preferred for various
    reasons. First of all, the middleware class and the logic can be verified and
    tested using unit tests. Secondly, in an enterprise environment, it can be useful
    to create dedicated library projects containing common middleware used by the
    web services and to distribute them through the company's NuGet repository. Finally,
    the class-based approach provides a clear way to highlight middleware dependencies
    using constructor injection. We will look at this topic in more depth in [Chapter
    4](54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml), *Dependency Injection*. Now that
    we have seen how to declare and add middleware to the ASP.NET Core pipeline, it
    is necessary to cover the conditional initialization of middleware in slightly
    more depth.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现提供了一种将中间件的逻辑封装在`SampleMiddleware`类中的方法。出于各种原因，这种方法是首选的。首先，中间件类和逻辑可以通过单元测试进行验证和测试。其次，在企业环境中，创建包含由Web服务使用的常见中间件的专用库项目，并通过公司的NuGet仓库进行分发可能很有用。最后，基于类的方法提供了使用构造函数注入突出显示中间件依赖关系的一种清晰方式。我们将在[第4章](54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml)，*依赖注入*中更深入地探讨这个主题。现在我们已经看到了如何在ASP.NET
    Core管道中声明和添加中间件，有必要更深入地讨论中间件的条件初始化。
- en: Conditional pipeline
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件管道
- en: ASP.NET Core provides some useful operators that let us put conditional initialization
    logic inside the middleware pipeline. Those kinds of operators may assist in providing
    additional performance benefits to our services and applications. Let's have a
    look at some of these operators.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了一些有用的操作符，允许我们将条件初始化逻辑放入中间件管道中。这些类型的操作符可能有助于为我们的服务和应用程序提供额外的性能优势。让我们看看这些操作符的一些例子。
- en: 'The `IApplicationBuilder Map (this IApplicationBuilder app, PathString pathMatch,
    Action<IApplicationBuilder> configuration)` extension method helps us to initialize
    our middleware by mapping a URI path; for example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`IApplicationBuilder Map (this IApplicationBuilder app, PathString pathMatch,
    Action<IApplicationBuilder> configuration)`扩展方法帮助我们通过映射URI路径来初始化我们的中间件；例如：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, `SampleMiddleware` will only be added to our pipeline if it is
    called as a URI with the specified path. Notice that the `Map` operator can also
    be nested inside others: this approach provides a more advanced approach to conditional
    initialization.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有当`SampleMiddleware`作为一个具有指定路径的URI被调用时，它才会被添加到我们的管道中。请注意，`Map`操作符也可以嵌套在其他操作符内部：这种方法提供了一种更高级的初始化条件的方法。
- en: 'Another useful operator is `MapWhen`, which only initializes the middleware
    provided as a parameter if the *predicate* function returns `true`; for example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的操作符是`MapWhen`，它只有在*谓词*函数返回`true`时才会初始化提供的中间件；例如：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, if the request is HTTPS, we will initialize the `SampleMiddleware`
    class. Conditional middleware initialization can be really useful when we need
    to act on a specific type of request. It usually becomes necessary when we need
    to force the execution of some logic on HTTP request types, such as when a specific
    header is present in the request, or a specific protocol is used.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果请求是HTTPS，我们将初始化`SampleMiddleware`类。当需要针对特定类型的请求采取行动时，条件中间件初始化可能非常有用。通常，当需要在HTTP请求类型上强制执行某些逻辑时，例如请求中存在特定头或使用特定协议时，这通常成为必要。
- en: In conclusion, *class-based* middleware is really useful when we need to implement
    custom logic in the middleware pipeline, and conditional initialization provides
    a cleaner way to initialize our set of middleware. In ASP.NET Core, middleware
    is a first-class citizen of the base logic of the framework; therefore, the next
    section covers some use cases and some middleware that comes out of the box with
    ASP.NET Core.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，*基于类的*中间件在需要在中间件管道中实现自定义逻辑时非常有用，条件初始化提供了一种更干净的方式来初始化我们的中间件集合。在ASP.NET Core中，中间件是框架基本逻辑的一等公民；因此，下一节将涵盖一些用例和一些与ASP.NET
    Core一起提供的中间件。
- en: Understanding built-in middleware
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内置中间件
- en: So, what are the use cases for middleware? As discussed earlier, they are usually
    related to cross-cutting concerns such as *logging*, *authentication,* and *exception
    handling*. ASP.NET Core itself provides some *built-in middleware* that represents
    a standard way to solve problems*:*
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，中间件有哪些用例呢？如前所述，它们通常与跨切面关注点相关，例如*日志记录*、*身份验证*和*异常处理*。ASP.NET Core本身提供了一些*内置中间件*，它们代表了解决问题的标准方式：*
- en: '`UseStaticFiles()`: Provides a way to deal with static files and assets inside
    your application. When the client asks for a static resource, this middleware
    filters the request and returns the requested file without hitting the rest of
    the pipeline.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseStaticFiles()`: 提供了一种处理应用程序内部静态文件和资源的方法。当客户端请求静态资源时，此中间件会过滤请求并返回请求的文件，而无需触及管道的其余部分。'
- en: '`AddResponseCaching()`: Helps developers to configure the caching system of
    the application. This middleware also adds all HTTP-compliant information related
    to the cache.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddResponseCaching()`: 帮助开发者配置应用程序的缓存系统。此中间件还添加了所有与缓存相关的HTTP兼容信息。'
- en: '`UseHttpsRedirection()`: This new, built-in piece of ASP.NET Core 2.1 middleware
    provides a way to force HTTPS redirection.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseHttpsRedirection()`: 这个新的内置ASP.NET Core 2.1中间件提供了一种强制HTTPS重定向的方法。'
- en: '`UseDeveloperExceptionPage()`: This shows a detailed error page (the new YSOD)
    in the case of exceptions*.* This is usually conditionally initialized, depending
    on the environment.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseDeveloperExceptionPage()`: 在发生异常的情况下，此功能会显示详细的错误页面（新的YSOD）。这通常根据环境条件进行初始化。'
- en: 'These are some built-in pieces of middleware provided by ASP.NET Core. As you
    can see, all middleware provides cross-cutting functionalities for your application.
    What''s important here is that the order of middleware initialization reflects
    the order of our pipeline; for example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是ASP.NET Core提供的内置中间件的一部分。正如你所见，所有中间件都为你的应用程序提供了跨切面功能。这里重要的是中间件初始化的顺序反映了我们的管道顺序；例如：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the `UseStaticFiles` middleware will never receive requests for
    static files because the MVC middleware handles them first. A general rule is
    to place `UseHttpsRedirection()` as the last middleware in the pipeline; otherwise,
    other middleware will not intercept requests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`UseStaticFiles`中间件将不会收到静态文件的请求，因为MVC中间件首先处理它们。一个一般规则是将`UseHttpsRedirection()`作为管道中的最后一个中间件；否则，其他中间件将不会拦截请求。
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Middleware is a useful tool for developers dealing with cross-cutting concerns.
    This is because it intercepts and enhances every *incoming request* and *outgoing
    response, and it can increase performance with early-return requests.* Concepts
    from logging to authentication should be handled by using middleware. The topics
    covered in the chapter provided you with the necessary knowledge to understand
    the middleware-first approach taken by the ASP.NET Core framework. Furthermore,
    the chapter also gave an overview of the built-in middleware of ASP.NET Core,
    and it described how to create custom middleware.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是处理跨切面问题的开发者有用的工具。这是因为它拦截并增强每个*进入请求*和*输出响应*，并且可以通过早期返回请求来提高性能。从日志记录到身份验证的概念都应通过使用中间件来处理。本章涵盖的主题为你理解ASP.NET
    Core框架采用的中间件优先方法提供了必要的知识。此外，本章还概述了ASP.NET Core的内置中间件，并描述了如何创建自定义中间件。
- en: 'In the next chapter, we will explore another core topic for increasing the
    maintainability and testability of our code: *dependency injection*. ASP.NET Core
    provides out-of-the-box dependency injection, and we will also explore how to
    solve dependencies and how to deal with different life cycle types.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个核心主题，即提高我们代码的可维护性和可测试性：*依赖注入*。ASP.NET Core提供了开箱即用的依赖注入，我们还将探讨如何解决依赖关系以及如何处理不同生命周期类型。
