["```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Linq;\n    using System.Threading;\n    using System.Threading.Tasks;\n    ```", "```cs\n    var data = Enumerable.Range(0, 100);\n    var numbers = new BlockingCollection<int>(100);\n    ```", "```cs\n    // A simple blocking producer \n    Task.Factory.StartNew( ()=>\n    {\n        foreach (var item in data)\n        {\n            numbers.Add(item);\n            Console.WriteLine(\"Adding:{0} Item Count={1}\", item, numbers.Count);\n        }\n        numbers.CompleteAdding();\n    });\n    ```", "```cs\n    // A simple blocking consumer.\n    Task.Factory.StartNew(() =>\n    {\n            int item = -1;\n            while (!numbers.IsCompleted)\n            {\n                try\n                {\n                    item = numbers.Take();\n                }\n                catch (InvalidOperationException)\n                {\n                    Console.WriteLine(\"Nothing to take\");\n                    break;\n                }\n                Console.WriteLine(\"Taking:{0} \", item);\n                // wait for a bit\n                 Thread.SpinWait(1000);\n        }\n\n        Console.WriteLine(\"\\rNo more items to take.\");\n    });\n\n    Console.ReadLine();\n    ```", "```cs\nforeach (var item in data)\n{\n    numbers.Add(item);\n    Console.WriteLine(\"Adding:{0} Item Count={1}\", item, numbers.Count);\n}\nnumbers.CompleteAdding();\n```", "```cs\nTask.Factory.StartNew(() =>\n{\n    while (!numbers.IsCompleted)\n    {\n        try\n        {\n            item = numbers.Take();\n        }\n        catch (InvalidOperationException)\n        {\n            Console.WriteLine(\"Nothing to take\");\n            break;\n        }\n    ...\n    }\nConsole.WriteLine(\"\\rNo more items to take.\");\n});\n```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Linq;\n    using System.Threading;\n    using System.Threading.Tasks;\n    ```", "```cs\n    var data = Enumerable.Range(0, 100);\n    var numbers = new BlockingCollection<int>(100);\n    ```", "```cs\n    // A simple blocking producer \n    Task.Factory.StartNew( ()=>\n    {\n        foreach (var item in data)\n        {\n            numbers.Add(item);\n            Console.WriteLine(\"Adding:{0} Item Count={1}\", item, numbers.Count);\n        }\n        numbers.CompleteAdding();\n    });\n    ```", "```cs\n    Task.Factory.StartNew(() =>\n    {\n        foreach (var item in numbers.GetConsumingEnumerable())\n        {                        \n            Console.Write(\"\\nConsuming item: {0}\", item);                       \n        }                    \n    });\n    Console.ReadLine();\n    ```", "```cs\nTask.Factory.StartNew(() =>\n{\n    while (!numbers.IsCompleted)\n    {\n        try\n        {\n            item = numbers.Take();\n        }\n        catch (InvalidOperationException)\n        {\n            Console.WriteLine(\"Nothing to take\");\n            break;\n        }\n    ...\n    }\nConsole.WriteLine(\"\\rNo more items to take.\");\n});\n```", "```cs\nTask.Factory.StartNew(() =>\n{\n    foreach (var item in result.GetConsumingEnumerable())\n    {                        \n        Console.Write(\"\\nConsuming item: {0}\", item);                       \n    }                    \n});\nConsole.ReadLine();\n```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Linq;\n    using System.Threading;\n    using System.Threading.Tasks;\n    ```", "```cs\n    var data = Enumerable.Range(0, 100);\n    ConcurrentStack<int> stack = new ConcurrentStack<int>();\n    ```", "```cs\n    // producer \n    Task.Factory.StartNew(() =>\n    {\n        foreach (var item in data)\n        {\n            stack.Push(item);\n            Console.WriteLine(\"Pushing item onto stack:{0} Item Count={1}\", \n          item, stack.Count);\n        }\n    });\n    ```", "```cs\n    //consumer\n    Task.Factory.StartNew(() =>\n    {\n        Thread.SpinWait(1000000);\n        while (!stack.IsEmpty)\n        {\n            int result = 0;\n            stack.TryPop(out result);\n            Console.WriteLine(\"Popping item from stack:{0} Item Count={1}\", \n          result, stack.Count);\n        }\n    });\n    Console.ReadLine();\n    ```", "```cs\nforeach (var item in data)\n{\n    stack.Push(item);\n    Console.WriteLine(\"Pushing item onto stack:{0} Item Count={1}\", \n    item, stack.Count);\n}\n```", "```cs\nwhile (!stack.IsEmpty)\n{\n    int result = 0;\n    stack.TryPop(out result);\n    Console.WriteLine(\"Popping item from stack:{0} Item Count={1}\", \n    result, stack.Count);\n}\n```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading.Tasks;\n    ```", "```cs\n    var dictionary = new ConcurrentDictionary<string, int>();\n    dictionary[\"A\"] = 1;\n    dictionary[\"B\"] = 2;\n    dictionary[\"C\"] = 3;\n    dictionary[\"D\"] = 4;\n    dictionary[\"E\"] = 5;\n    dictionary[\"F\"] = 6;\n    dictionary[\"G\"] = 7;\n    dictionary[\"H\"] = 8;\n    dictionary[\"I\"] = 9;\n    dictionary[\"J\"] = 10;\n    dictionary[\"K\"] = 11;\n    dictionary[\"L\"] = 12;\n    dictionary[\"M\"] = 13;\n    dictionary[\"N\"] = 14;\n    dictionary[\"O\"] = 15;\n    ```", "```cs\n    // update dictionary on a separate thread\n    Task.Factory.StartNew(() =>\n    {\n        foreach (var pair in dictionary)\n        {\n            var newValue = pair.Value + 1;\n            dictionary.TryUpdate(pair.Key,newValue,pair.Value);\n            Console.WriteLine(\"Updated key: {0} value:{1}\", pair.Key, newValue);\n        }   \n    });\n    ```", "```cs\n    Task.Factory.StartNew(() =>\n    {\n        foreach (var pair in dictionary)\n        {\n            Console.WriteLine(\"Reading key: {0} value:{1}\",pair.Key,pair.Value);\n        }\n    });            \n\n    Console.ReadLine();\n    ```", "```cs\nforeach (var pair in dictionary)\n    {\n        var newValue = pair.Value + 1;\n        dictionary.TryUpdate(pair.Key,newValue,pair.Value);\n        Console.WriteLine(\"Updated key: {0} value:{1}\", pair.Key, newValue);\n    }\n```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Linq;\n    using System.Threading;\n    using System.Threading.Tasks;\n    ```", "```cs\n    var data = Enumerable.Range(0, 100);\n    var numbers = new BlockingCollection<int>(100);\n    var tokenSource = new CancellationTokenSource();\n    var token = tokenSource.Token;\n    ```", "```cs\n    Task.Factory.StartNew(() =>\n    {\n        foreach (var item in data)\n        {\n        try\n        {\n          numbers.TryAdd(item,5,token);\n          Console.WriteLine(\"Adding:{0} Item Count={1}\", \n            item, numbers.Count);\n        }\n        catch(OperationCanceledException)\n        {\n          Console.WriteLine(\"Adding operation has been cancelled\");\n          numbers.CompleteAdding();\n          break;\n        }\n        }\n        numbers.CompleteAdding();\n    },token);\n    ```", "```cs\n    // A simple blocking consumer.\n    Task.Factory.StartNew(() =>\n    {\n\n      while (!numbers.IsCompleted)\n      {\n        try\n        {\n          numbers.TryTake(out item,5,token);\n        }\n        catch (OperationCanceledException)\n        {\n          Console.WriteLine(\"Take operation has been cancelled\");\n          break;\n        }\n        Console.WriteLine(\"Taking:{0} \", item);\n        // wait for a bit\n        Thread.SpinWait(10000);\n      }\n      Console.WriteLine(\"\\rNo more items to take.\");\n    },token);\n    ```", "```cs\n    Thread.SpinWait(2000000);\n    tokenSource.Cancel();\n    Console.ReadLine();\n    ```", "```cs\nforeach (var item in data)\n{\n  try\n  {\n    numbers.TryAdd(item,5,token);\n    Console.WriteLine(\"Adding:{0} Item Count={1}\", \n              item, numbers.Count);\n  }\n  catch(OperationCanceledException)\n  {\n    Console.WriteLine(\"Adding operation has been cancelled\");\n    numbers.CompleteAdding();\n    break;\n  }\n}\n```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading.Tasks;\n    ```", "```cs\n    private static double CalcSumRoot(int root)\n    {\n      double result = 0;\n      for (int i = 1; i < 10000000; i++)\n      {\n        result += Math.Exp(Math.Log(i) / root);\n      }\n      return result;\n    }\n    ```", "```cs\n    private static void DisplayResults(BlockingCollection<double> results)\n    {\n      foreach (var item in results.GetConsumingEnumerable())\n      {\n        Console.Write(\"\\nConsuming item: {0}\", item);\n      }\n    }\n    ```", "```cs\n    var results = new BlockingCollection<double>();\n    var tasks = new List<Task>();\n    var consume1 = Task.Factory.StartNew(() => DisplayResults(results));\n    var consume2 = Task.Factory.StartNew(() => DisplayResults(results));\n    ```", "```cs\n    for (int item = 1; item < 25; item++)\n    {\n      var value = item;\n      var compute = Task.Factory.StartNew(() =>\n      {\n        var calcResult = CalcSumRoot(value);\n        Console.Write(\"\\nProducing item: {0}\", calcResult);\n        results.TryAdd(calcResult);\n      });\n      tasks.Add(compute);\n    }\n    ```", "```cs\n    Task.Factory.ContinueWhenAll(tasks.ToArray(),\n    result =>\n    {\n      results.CompleteAdding();\n      Console.Write(\"\\nCompleted adding.\");\n    });\n\n    Console.ReadLine();\n    ```", "```cs\nTask.Factory.ContinueWhenAll(tasks.ToArray(),\nresult =>\n{\n  results.CompleteAdding();\n  Console.Write(\"\\nCompleted adding.\");\n});\n\nConsole.ReadLine();\n```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    ```", "```cs\n    public class ConcurrentObjectPool<T>\n    {\n    }\n    ```", "```cs\n    private ConcurrentStack<T> _objects;\n    private Func<T> _objectInitializer;\n    ```", "```cs\n    public ConcurrentObjectPool(Func<T> objectInitializer)\n    {\n      _objects = new ConcurrentStack<T>();\n      _objectInitializer = objectInitializer;\n    }\n    ```", "```cs\n    public T GetObject()\n    {\n      T item;\n      if (_objects.TryPop(out item)) return item;\n      return _objectInitializer();\n    }\n    ```", "```cs\n    public void PutObject(T item)\n    {\n      _objects.Push(item);\n    }\n    ```", "```cs\n    using System;\n    using System.Text;\n    using System.Threading.Tasks;\n    ```", "```cs\n    var pool = new ConcurrentObjectPool<StringBuilder>(()=>\n      new StringBuilder(\"Pooled Object created by objectInitializer\"));\n    ```", "```cs\n    var task1 = Task.Factory.StartNew(() =>\n    {\n      for (var index = 0; index < 10; index++)\n      {\n        StringBuilder newObject = new StringBuilder(string.Concat(\"Pooled object\", \n              index.ToString()));\n        Console.WriteLine(\"Putting pooled object: {0}\", index.ToString());\n        pool.PutObject(newObject);\n      }\n    });\n    ```", "```cs\n    task1.ContinueWith((antecedent)=>\n    {\n      for (var index = 0; index < 10; index++)\n      {\n        var pooledObject = pool.GetObject();\n        Console.WriteLine(\"First Task: {0}\", pooledObject.ToString());                    \n      }\n    });\n\n    task1.ContinueWith((antecedent) =>\n    {\n      for (var index = 0; index < 10; index++)\n      {\n        var pooledObject = pool.GetObject();\n        Console.WriteLine(\"Second Tasks: {0}\", pooledObject.ToString());\n      }\n    });\n    ```", "```cs\n ()=>new StringBuilder(\"Pooled Object created by objectInitializer\")\n```", "```cs\npublic T GetObject()\n{\n  T item;\n  if (_objects.TryPop(out item)) return item;\n  return _objectInitializer();\n}\n```", "```cs\n    using System.Collections.Concurrent;\n    using System.Collections.Generic;\n    using System.Collections;\n    using System;\n    using System.Threading;\n    ```", "```cs\n    public enum QueuePriorityLevel\n    {\n      High = 0,\n      Medium = 1,\n      Low = 2\n    }\n    ```", "```cs\n    public class PriorityQueue<PriorityLevel, TValue>: \n      IProducerConsumerCollection<KeyValuePair<QueuePriorityLevel, TValue>>\n    {\n\n    }\n    ```", "```cs\n    private ConcurrentQueue<KeyValuePair<QueuePriorityLevel, TValue>> _lowPriotityQueue = null;\n    private ConcurrentQueue<KeyValuePair<QueuePriorityLevel, TValue>> _mediumPriotityQueue = null;\n    private ConcurrentQueue<KeyValuePair<QueuePriorityLevel, TValue>> _highPriotityQueue = null;\n    private ConcurrentQueue<KeyValuePair<QueuePriorityLevel, TValue>>[] _queues = null;\n    private int _count = 0;\n    ```", "```cs\n    public PriorityQueue()\n    {\n      _lowPriotityQueue = new ConcurrentQueue<KeyValuePair<QueuePriorityLevel,TValue>>();\n      _mediumPriotityQueue = new ConcurrentQueue<KeyValuePair<QueuePriorityLevel,TValue>>();\n      _highPriotityQueue = new ConcurrentQueue<KeyValuePair<QueuePriorityLevel,TValue>>();\n      _queues = new ConcurrentQueue<KeyValuePair<QueuePriorityLevel, TValue>>[3]\n      {\n        _lowPriotityQueue,\n        _mediumPriotityQueue,\n        _highPriotityQueue\n      };\n    }\n    ```", "```cs\n    public void CopyTo(KeyValuePair<QueuePriorityLevel, TValue>[] array, int index)\n    {\n      if (array == null) throw new ArgumentNullException();\n\n      KeyValuePair<QueuePriorityLevel, TValue>[] temp = this.ToArray();\n      for (int i = 0; i < array.Length && i < temp.Length; i++)\n        array[i] = temp[i];\n    }\n    ```", "```cs\n    public KeyValuePair<QueuePriorityLevel, TValue>[] ToArray()\n    {\n      KeyValuePair<QueuePriorityLevel, TValue>[] result;\n\n      lock (_queues)\n      {\n        result = new KeyValuePair<QueuePriorityLevel, TValue>[this.Count];\n        int index = 0;\n        foreach (var q in _queues)\n        {\n          if (q.Count > 0)\n          {\n            q.CopyTo(result, index);\n            index += q.Count;\n          }\n        }\n        return result;\n      }\n    }\n    ```", "```cs\n    public bool TryAdd(KeyValuePair<QueuePriorityLevel, TValue> item)\n    {\n      int priority = (int) item.Key;\n      _queues[priority].Enqueue(item);\n      Interlocked.Increment(ref _count);\n      return true;\n    }\n    ```", "```cs\n    public bool TryTake(out KeyValuePair<QueuePriorityLevel, TValue> item)\n    {\n      bool success = false;\n\n      for (int i = 0; i <= 2; i++)\n      {\n        lock (_queues)\n        {\n          success = _queues[i].TryDequeue(out item);\n          if (success)\n          {\n            Interlocked.Decrement(ref _count);\n            return true;\n          }\n        }\n      }\n\n      item = new KeyValuePair<QueuePriorityLevel, TValue>(0, default(TValue));\n      return false;\n    }\n    ```", "```cs\n    public IEnumerator<KeyValuePair<QueuePriorityLevel, TValue>> GetEnumerator()\n    {\n      for (int i = 0; i <= 2; i++)\n      {\n        foreach (var item in _queues[i])\n          yield return item;\n      }\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n      return GetEnumerator();\n    }\n    ```", "```cs\n    public int Count\n    {\n      get { return _count; }\n    }\n    ```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Collections.Generic;\n    using System.Threading;\n    using System.Threading.Tasks;\n    ```", "```cs\n    var queue = new PriorityQueue<QueuePriorityLevel, int>();\n    var bc = new BlockingCollection<KeyValuePair<QueuePriorityLevel, int>>(queue);\n    var tasks = new List<Task>();\n    ```", "```cs\n    var producer = Task.Factory.StartNew(() =>\n    {\n      Random r = new Random();\n      int itemsToAdd = 50;\n      int count = 0;\n      for (int i = 0; i < itemsToAdd; i++ )\n      {\n        Thread.SpinWait(10000);\n        // Generate random priority level\n        QueuePriorityLevel[] values = (QueuePriorityLevel[])Enum.GetValues(typeof(QueuePriorityLevel));\n        var priority = values[new Random().Next(0, values.Length)];                    \n        var item = new KeyValuePair<QueuePriorityLevel, int>(priority, count++);\n        bc.Add(item);\n        Console.WriteLine(\"added priority {0}, data={1}\", priority, item.Value);\n      }\n      Console.WriteLine(\"Producer is finished.\");\n     }).ContinueWith( (antecedent)=>\n       {\n         bc.CompleteAdding();\n       });\n    ```", "```cs\n    Thread.SpinWait(100000);\n    ```", "```cs\n    var consumer = Task.Factory.StartNew(() =>\n    {\n      while (!bc.IsCompleted )\n      {\n         KeyValuePair<QueuePriorityLevel, int> item = new KeyValuePair<QueuePriorityLevel, int>();\n        bool success = false;\n        success = bc.TryTake(out item);\n        if (success)\n        {\n        Console.WriteLine(\"removed Priority = {0} data = {1} Collection Count= {2}\", item.Key, item.Value, bc.Count);\n        }\n        else\n          Console.WriteLine(\"No items remaining. count = {0}\", bc.Count);\n      }\n      Console.WriteLine(\"Exited consumer loop\");\n    });\n    ```", "```cs\n    tasks.Add(producer);\n    tasks.Add(consumer);\n\n    try\n    {\n      Task.WaitAll(tasks.ToArray());\n    }\n\n    catch (AggregateException ae)\n    {\n      foreach (var v in ae.InnerExceptions)\n        Console.WriteLine(v.Message);\n    }\n\n    Console.ReadLine();\n    ```", "```cs\npublic class PriorityQueue<PriorityLevel, TValue>: \n    IProducerConsumerCollection<KeyValuePair<QueuePriorityLevel, TValue>>\n{\n  private ConcurrentQueue<KeyValuePair<QueuePriorityLevel, TValue>> _lowPriotityQueue = null;\n  private ConcurrentQueue<KeyValuePair<QueuePriorityLevel, TValue>> _mediumPriotityQueue = null;\n  private ConcurrentQueue<KeyValuePair<QueuePriorityLevel, TValue>> _highPriotityQueue = null;\n  private ConcurrentQueue<KeyValuePair<QueuePriorityLevel, TValue>>[] _queues = null;\n  private int _count = 0;\t\n  ...  \n}\n```", "```cs\npublic bool TryAdd(KeyValuePair<QueuePriorityLevel, TValue> item)\n{\n  int priority = (int) item.Key;\n  _queues[priority].Enqueue(item);\n  Interlocked.Increment(ref _count);\n  return true;\n}\n```", "```cs\npublic bool TryTake(out KeyValuePair<QueuePriorityLevel, TValue> item)\n{\n  bool success = false;\n\n  for (int i = 0; i <= 2; i++)\n  {\n    lock (_queues)\n    {\n      success = _queues[i].TryDequeue(out item);\n      if (success)\n      {\n        Interlocked.Decrement(ref _count);\n        return true;\n      }\n    }\n  }\n}\n```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Threading.Tasks;\n    ```", "```cs\n    static void CreateRange(BlockingCollection<int> result)\n    {\n      try\n      {\n        for (int i = 1; i < 10; i++)\n        {\n          result.Add(i);\n          Console.WriteLine(\"Create Range {0}\", i);\n        }\n      }\n      finally\n      {\n        result.CompleteAdding();\n      }\n    }\n    ```", "```cs\n    static void SquareTheRange(BlockingCollection<int> source, BlockingCollection<int> result)\n    {\n      try\n      {\n        foreach (var value in source.GetConsumingEnumerable())\n        {\n          result.Add((int)(value * value));\n        }\n      }\n      finally\n      {\n        result.CompleteAdding();\n      }\n    }\n    ```", "```cs\n    {\n      foreach (var value in input.GetConsumingEnumerable())\n      {\n        Console.WriteLine(\"The result is {0}\", value);\n      }\n    }\n    ```", "```cs\n    var bufferA = new BlockingCollection<int>(10);\n    var bufferB = new BlockingCollection<int>(10);\n    ```", "```cs\n    var createStage = Task.Factory.StartNew(() => \n      {\n        CreateRange(bufferA);\n      },TaskCreationOptions.LongRunning);\n    var squareStage = Task.Factory.StartNew(() => \n      {\n        SquareTheRange(bufferA, bufferB);\n      },TaskCreationOptions.LongRunning );\n\n    var displayStage = Task.Factory.StartNew(() => \n      {\n        DisplayResults(bufferB);\n      },TaskCreationOptions.LongRunning);\n    ```", "```cs\n    Task.WaitAll(createStage, squareStage, displayStage);\n    Console.ReadLine();\n    ```"]