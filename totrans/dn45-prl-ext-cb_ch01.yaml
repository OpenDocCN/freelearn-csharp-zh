- en: Chapter 1. Getting Started with Task Parallel Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 使用任务并行库入门
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a task
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务
- en: Waiting for tasks to finish
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待任务完成
- en: Returning results from a task
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任务返回结果
- en: Passing data to a task
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向任务传递数据
- en: Creating a child task
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建子任务
- en: Lazy task execution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒任务执行
- en: Handling task exceptions using try/catch block
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用try/catch块处理任务异常
- en: Handling task exceptions with AggregateException.Handle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AggregateException.Handle处理任务异常
- en: Cancelling a task
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消任务
- en: Cancelling one of many tasks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消多个任务中的一个
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: At the beginning of the personal computer era, there was no concept of multiple
    threads offered by an operating system. Typically, operating system code and application
    code ran on a single thread of execution. The problem with this was that if a
    single application misbehaved, or simply took a long time to execute, the whole
    machine would stall, and often had to be rebooted.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在个人计算机时代的初期，操作系统并没有提供多线程的概念。通常，操作系统代码和应用程序代码都在单个执行线程上运行。这个问题在于，如果单个应用程序行为不当，或者简单地执行时间过长，整个机器就会停滞，并且通常需要重新启动。
- en: As the development of the Windows operating systems progressed, Microsoft realized
    that they needed to improve this situation. In the Windows NT kernel, each application
    runs in its own process. A process is a collection of resources in which a virtual
    address space is allocated for each application. The advent of these processes
    ensured that code and data being used by one application could not be accessed
    and corrupted by another application, thus improving the reliability of the system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Windows操作系统的不断发展，微软意识到他们需要改善这种情况。在Windows NT内核中，每个应用程序都在自己的进程中运行。进程是一组资源，为每个应用程序分配一个虚拟地址空间。这些进程的出现确保了被一个应用程序使用的代码和数据不能被另一个应用程序访问和损坏，从而提高了系统的可靠性。
- en: Each process in Windows was also given its own thread. A thread is an operating
    system construct that functions like a virtual CPU. At any given moment, one of
    these threads is allowed to run on the physical CPU for a slice of time. When
    the time for a thread to run expires, it is swapped off of the CPU for another
    thread. Therefore, if a single thread enters an infinite loop, it can't monopolize
    all of the CPU time on the system. At the end of its time slice, it will be switched
    out for another thread.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Windows中的每个进程也都有自己的线程。线程是操作系统的一个构造，其功能类似于虚拟CPU。在任何给定时刻，这些线程中的一个可以在物理CPU上运行一段时间。当一个线程的运行时间结束时，它会被切换出CPU，以便另一个线程运行。因此，如果单个线程进入无限循环，它不能垄断系统上的所有CPU时间。在其时间片结束时，它将被切换到另一个线程。
- en: Over the years, computers with multiple processors began to appear. These multiple
    processor machines were able to execute multiple threads at once. It became possible
    for an application to spawn new threads to run a compute-bound process asynchronously,
    thus gaining a performance improvement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，多处理器的计算机开始出现。这些多处理器机器能够同时执行多个线程。这使得应用程序能够异步地生成新线程来运行计算密集型进程，从而获得性能提升。
- en: Over the past few years, the trend in processor development has shifted from
    making processors faster and faster, to making processors with multiple CPU cores
    on a single physical processor chip. Individuals who purchase these new machines
    expect their investment to pay off in terms of applications which are able to
    run efficiently across the available processor cores. Maximizing the utilization
    of the computing resources provided by the next generation of multi-core processors
    requires a change in the way the code is written.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，处理器发展的趋势已经从制造越来越快的处理器，转变为在单个物理处理器芯片上制造具有多个CPU核心的处理器。购买这些新机器的个人期望他们的投资能够通过能够高效运行在可用处理器核心上的应用程序来实现回报。最大化下一代多核处理器提供的计算资源利用率需要改变编写代码的方式。
- en: The .NET framework has supported writing multi-threaded applications from the
    beginning, but the complexity of doing so has remained just out of reach for many
    .NET developers. To fully take the advantage of multi-threading, you needed to
    know quite a bit about how Windows works under the hood. For starters, you had
    to create and manage your own threads, which can be a demanding task as the number
    of threads in an application grows, and can often be the source of hard-to-find
    bugs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架从一开始就支持编写多线程应用程序，但实现这一点的复杂性对于许多 .NET 开发者来说仍然遥不可及。要充分利用多线程，你需要相当了解 Windows
    内部的工作原理。首先，你必须创建和管理自己的线程，随着应用程序中线程数量的增加，这可能是一项繁重的任务，并且往往是难以发现的错误来源。
- en: Finally, help has arrived. Starting in .NET 4.0, Microsoft introduced the .NET
    Parallel Extensions, which gave us a new runtime, new class library types (the
    **Task Parallel Library** (**TPL**)), and new diagnostic tools to help with the
    inherent complexities of parallel programming.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，帮助终于来了。从 .NET 4.0 开始，Microsoft 引入了 .NET 并行扩展，为我们提供了一个新的运行时、新的类库类型（**任务并行库**（**TPL**））以及新的诊断工具，以帮助解决并行编程固有的复杂性。
- en: The TPL isn't just a collection of new types. It's a completely new way of thinking
    about parallel programming. No longer do we need to think in terms of threads.
    With the TPL, we can now think in terms of `task`. With this new task-based model,
    we just need to figure out the pieces of our application that can execute concurrently,
    and convert those pieces into tasks. The runtime will take care of managing and
    creating all of the underlying threads that actually do the work. The `System.Threading.Task`
    class in itself is just a wrapper for passing a delegate, which is a data structure
    that refers to a `static` method or to a class instance, and an instance method
    of that class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 不仅仅是一系列新类型。它是一种全新的并行编程思考方式。我们不再需要从线程的角度思考。使用 TPL，我们现在可以以 `task` 为单位思考。在这个新的基于任务的模型中，我们只需要确定应用程序中可以并发执行的部分，并将这些部分转换为任务。运行时将负责管理和创建所有实际执行工作的底层线程。`System.Threading.Task`
    类本身只是一个传递委托的包装器，委托是一种数据结构，它引用一个 `static` 方法或类实例及其该类的一个实例方法。
- en: A TPL `task` still uses the classic thread pool internally, but the heavy lifting
    of spinning up new threads to carry out the `tasks` and determining the optimum
    number of threads required to take full advantage of the hardware, is all done
    by the runtime.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 的 `task` 仍然在内部使用经典的线程池，但启动新线程以执行 `tasks` 和确定充分利用硬件所需的最佳线程数量等繁重工作都由运行时处理。
- en: In this chapter, we will take a look at the basics of creating a parallel `task`.
    You will learn how to pass data into a `Task` using the `Task` state object, returning
    data from a `Task`, cancelling the `Task`, and handling exceptions within a `Task`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨创建并行 `task` 的基础知识。你将学习如何使用 `Task` 状态对象将数据传递给 `Task`，从 `Task` 返回数据，取消
    `Task`，以及在 `Task` 内部处理异常。
- en: Creating a task
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务
- en: '`Tasks` are an abstraction in the .NET framework to represent asynchronous
    units of work. In some ways, a task resembles the creation of a classic .NET thread,
    but provides a higher level of abstraction, which makes your code easier to write
    and read.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tasks` 是 .NET 框架中的一种抽象，用于表示异步工作单元。在某种程度上，任务类似于经典 .NET 线程的创建，但提供了更高层次的抽象，这使得你的代码更容易编写和阅读。'
- en: We will look at the three basic ways to create and run a new task.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨创建和运行新任务的三种基本方法。
- en: 'The `Parallel.Invoke()` method: This method provides an easy way to run any
    number of concurrent statements'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke()` 方法：此方法提供了一种简单的方式来运行任意数量的并发语句'
- en: 'The `Task.Start()` method: This method starts a task and schedules it for execution
    with `TaskScheduler`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Start()` 方法：此方法启动一个任务，并使用 `TaskScheduler` 对其进行执行调度'
- en: 'The `Task.Factory.StartNew()` method: This method creates and starts a task
    using `Task.Factory`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew()` 方法：此方法使用 `Task.Factory` 创建并启动一个任务'
- en: In this recipe, we will create a new task using each of these three methods.
    To give our tasks something to do, we will be using `WebClient` to read the text
    of three classic books. We will then split the words of each book into a string
    array, and display a count of the words in each book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用这三种方法中的每一种来创建一个新的任务。为了使我们的任务有所作为，我们将使用 `WebClient` 来读取三本经典书籍的文本。然后我们将每本书的单词拆分到一个字符串数组中，并显示每本书中的单词计数。
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Ok, let's start building a `Console` application that demonstrates the various
    ways to create a parallel task.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始构建一个 `Console` 应用程序，演示创建并行任务的多种方式。
- en: Launch Visual Studio 2012.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2012。
- en: Start a new project using the C# **Console Application** project template, and
    assign `SimpleTasks` as the **Solution name** as shown in the following screenshot:![How
    to do it…](img/0225OT_01_01.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 C# **控制台应用程序** 项目模板创建一个新的项目，并将 `SimpleTasks` 作为 **解决方案名称**，如图所示：![如何操作…](img/0225OT_01_01.jpg)
- en: 'Add the following `using` statements at the top of your `Program` class:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的顶部添加以下 `using` 语句：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 书籍的账户中下载你购买的所有示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以将文件直接通过电子邮件发送给你。
- en: 'First, let''s create a task using `Parallel.Invoke`. Add the following code
    to the `Main` method of the `Program` class:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用 `Parallel.Invoke` 创建一个任务。将以下代码添加到 `Program` 类的 `Main` 方法中：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let''s start `task` using the `Start` method of the `Task` object. Add
    the following code to the `Main` method of the `Program` class just below the
    code for the previous step:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `Task` 对象的 `Start` 方法启动 `task`。将以下代码添加到 `Program` 类的 `Main` 方法中，位于上一步代码的下方：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, let''s create `task` using `Task.Factory.StartNew`. Add the following
    code to the `Main` method of the `Program` class:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用 `Task.Factory.StartNew` 创建 `task`。将以下代码添加到 `Program` 类的 `Main` 方法中：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot. Note that the exact order of the text you
    see may vary as `tasks` run asynchronously:![How to do it…](img/0225OT_01_02.jpg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到类似于以下截图的输出。请注意，你看到的文本的确切顺序可能会因 `tasks`
    的异步运行而有所不同：![如何操作…](img/0225OT_01_02.jpg)
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `Parallel.Invoke` method can implicitly create and run any number of statements
    concurrently by passing an action delegate for each delegate of work to be done.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke` 方法可以通过为要执行的工作的每个委托传递一个动作委托来隐式创建和运行任意数量的语句并发执行。'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is worth noting however, that the number of `tasks` actually created by `Parallel.Invoke`
    may or may not be equal to the number of delegates passed in, especially if there
    are a large number of delegates.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，`Parallel.Invoke` 实际创建的 `tasks` 的数量可能与传入的委托数量相等或不相等，特别是如果有大量委托。
- en: Using `Task.Start()` or `Task.Factory.StartNew()` creates new tasks explicitly.
    The new `tasks` will be allocated threads by the `ThreadPool` class, which handles
    the actual creation of the threads the `tasks` use for carrying out their work.
    As developers, we are shielded from all of this thread creation work, because
    it is done for us by the `Task` object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Task.Start()` 或 `Task.Factory.StartNew()` 可以显式创建新任务。新的 `tasks` 将由 `ThreadPool`
    类分配线程，该类负责创建 `tasks` 用于执行其工作的实际线程。作为开发者，我们被屏蔽了所有这些线程创建的工作，因为这一切都是由 `Task` 对象为我们完成的。
- en: When you create a task, you are really just creating a wrapper around a delegate
    of work to be performed. The delegate can be a named delegate and anonymous method,
    or a lambda expression.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个任务时，你实际上只是在要执行的工作的委托周围创建了一个包装器。这个委托可以是一个命名的委托、匿名方法或 lambda 表达式。
- en: So, which of these methods of creating `task` is the best? `Task.Factory.StartNew`
    is usually the preferred method, because it is more efficient in terms of the
    synchronization costs. Some amount of synchronization cost is incurred when using
    `Thread.Start`, because it is necessary to ensure that another thread is not simultaneously
    calling start on the same `Task` object. When using `Task.Factory.StartNew`, we
    know that the task has already been scheduled by the time `task` reference is
    handed back to our code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，创建 `task` 的这些方法中哪一个是最好的？`Task.Factory.StartNew` 通常被认为是首选方法，因为它在同步成本方面更高效。使用
    `Thread.Start` 时会消耗一些同步成本，因为必须确保没有其他线程同时调用同一 `Task` 对象的启动。当使用 `Task.Factory.StartNew`
    时，我们知道任务已经在 `task` 引用返回到我们的代码之前被调度了。
- en: Note also that you can't call `Start()` on a task that has already run and completed.
    If you need the tasks to do the work again, you need to create new `task` with
    the same delegate of work.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你无法在已经运行并完成的任务上调用`Start()`。如果你需要任务再次执行工作，你需要创建具有相同工作代理的新`task`。
- en: For the remainder of this book, we will primarily be using `Task.Factory.StartNew`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将主要使用`Task.Factory.StartNew`。
- en: Waiting for tasks to finish
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待任务完成
- en: 'When developing a parallel application, you will often have situations where
    a task must be completed before the main thread can continue processing. The Task
    Parallel Library includes several methods that allow you to wait for one or more
    parallel `tasks` to complete. This recipe will cover two such methods: `Task.Wait()`
    and `Task.WaitAll()`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发并行应用程序时，你经常会遇到必须先完成任务，主线程才能继续处理的情况。任务并行库包括几个方法，允许你等待一个或多个并行`task`完成。这个菜谱将涵盖两种这样的方法：`Task.Wait()`和`Task.WaitAll()`。
- en: In this recipe we will be creating three tasks, all of which read in the text
    classic books and produce a `word count`. After we create the first task, we will
    wait for it to complete using `Task.Wait()`, before starting the second and third
    task. We will then wait for both the second and third tasks to complete using
    `Task.WaitAll()` before writing a message to the console.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建三个任务，所有这些任务都是读取经典书籍的文本并生成`单词计数`。在创建第一个任务后，我们将使用`Task.Wait()`等待它完成，然后再开始第二个和第三个任务。然后，我们将使用`Task.WaitAll()`等待第二个和第三个任务完成，然后再向控制台发送消息。
- en: How to do it…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's create a `Console` application that demonstrates how to wait for `task`
    completion.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`Console`应用程序，演示如何等待`task`完成。
- en: Launch Visual Studio 2012.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount` as the **Solution name**.![How to do it…](img/0225OT_01_03.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C# **控制台应用程序**项目模板启动一个新项目，并将`WordCount`作为**解决方案名称**。![如何做…](img/0225OT_01_03.jpg)
- en: 'Add the following `using` statements at the top of your `Program` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Program`类的顶部添加以下`using`语句：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `Main` method of the `Program` class, add a character array containing
    the basic punctuation marks. We will use this array in `string.Split()` to eliminate
    punctuation marks. Also add a string `constant` for the `user-agent` header of
    the `WebClient`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类的`Main`方法中，添加一个包含基本标点符号的字符数组。我们将使用这个数组在`string.Split()`中消除标点符号。还要添加一个名为`constant`的字符串，用于`WebClient`的`user-agent`头。
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OK, now let''s create our first task. This task will use `WebClient` to read
    the *Origin of Species* by Darwin, and get its word count. Enter the following
    code in the `Main` method of the `Program` class just below the previous statement:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在让我们创建我们的第一个任务。这个任务将使用`WebClient`读取达尔文的《物种起源》，并获取其单词计数。在`Program`类的`Main`方法中，在上一条语句下方输入以下代码：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, just below the previous task, write the following statements to wait on
    the task, and write a message to the `Console` application:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在上一任务下方，写下以下语句以等待任务，并向`Console`应用程序发送消息：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Below the previous statement, enter the code to create the second and third
    tasks. These tasks are very similar to the first task.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一条语句下方，输入创建第二个和第三个任务的代码。这些任务与第一个任务非常相似。
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, let's use `Task.WaitAll()` to wait for the second and third task to
    complete, then prompt the user to exit the program. `Task.WaitAll()` takes an
    array of `task` as its parameter, and can be used to wait for any number of tasks
    to complete.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用`Task.WaitAll()`等待第二个和第三个任务完成，然后提示用户退出程序。`Task.WaitAll()`接受一个`task`数组作为其参数，可以用来等待任意数量的任务完成。
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot. Note that the exact order of the last few
    lines of text may still vary depending on the execution order of the second and
    third tasks.![How to do it…](img/0225OT_01_04.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该看到类似于以下截图的输出。注意，最后几行文本的确切顺序可能仍然取决于第二个和第三个任务的执行顺序。![如何做…](img/0225OT_01_04.jpg)
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Although `Task.Wait()` and `Task.WaitAll()` are fairly self-explanatory, both
    have several overloads that offer different functionalities.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Task.Wait()`和`Task.WaitAll()`相当直观，但它们都有几个重载，提供了不同的功能。
- en: '`Task.Wait()` can take either an `Int32` or `TimeSpan` parameter to specify
    a specific period of time to wait. It can also accept a `CancellationToken` token
    parameter for cancellation, which will be covered later in the chapter.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Wait()` 可以接受一个 `Int32` 或 `TimeSpan` 参数来指定等待的特定时间段。它还可以接受一个用于取消的 `CancellationToken`
    令牌参数，这将在本章后面进行介绍。'
- en: '`Task.WaitAll()` always takes an array of `Task` as its first parameter, and
    has a second parameter which can be an `Int32` or `TimeSpan` as in `Task.Wait`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.WaitAll()` 总是将其第一个参数作为 `Task` 数组，并且有一个第二个参数，可以是 `Int32` 或 `TimeSpan`，就像
    `Task.Wait` 一样。'
- en: Another useful method not shown in the recipe is `Task.WaitAny()`. `WaitAny`
    is very similar to `WaitAll`, except that it waits for only one `Task` in the
    array of `Task` to complete. The first `Task` of `Task` array to finish, completes
    the wait condition, and execution of the main thread is allowed to move forward.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中未显示的另一个有用的方法是 `Task.WaitAny()`。`WaitAny` 与 `WaitAll` 非常相似，但它只等待数组中的 `Task`
    之一完成。`Task` 数组中第一个完成的 `Task` 将完成等待条件，并允许主线程的执行继续前进。
- en: It is important to note that when you call one of the `Wait` methods, the runtime
    will check to see if the task you are waiting on has started executing. If `task`
    has started executing, then the thread that called `Wait` will block until `task`
    has finished executing. However, if `task` has not started running, then the runtime
    may execute the task using the thread that calls `Wait`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当你调用 `Wait` 方法之一时，运行时会检查你等待的任务是否已经开始执行。如果 `task` 已经开始执行，则调用 `Wait` 的线程将阻塞，直到
    `task` 执行完成。然而，如果 `task` 尚未开始运行，则运行时可能会使用调用 `Wait` 的线程来执行任务。
- en: 'The various overloads and behaviors of `Task.Wait`, `Task.WaitAll`, and `Task.WaitAny`
    are shown in the following table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Wait`、`Task.WaitAll` 和 `Task.WaitAny` 的各种重载和行为如下表所示：'
- en: '| `Wait()` | Waits for the task to complete execution. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `Wait()` | 等待任务完成执行。 |'
- en: '| `Wait(CancellationToken)` | Waits for the task to complete execution or `CancellationToken`
    to be set. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Wait(CancellationToken)` | 等待任务完成执行或设置 `CancellationToken`。 |'
- en: '| `Wait(Int32)` | Waits for task to complete or number of milliseconds to pass.
    A value of `-1` waits indefinitely. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `Wait(Int32)` | 等待任务完成或经过指定毫秒数。值为 `-1` 表示无限期等待。 |'
- en: '| `Wait(TimeSpan)` | Waits for the task to complete execution or specified
    timespan to pass. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `Wait(TimeSpan)` | 等待任务完成执行或指定的时长过去。 |'
- en: '| `Wait(Int32, CancellationToken)` | Waits for task to complete, number of
    milliseconds to pass, or `CancellationToken` to be set. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `Wait(Int32, CancellationToken)` | 等待任务完成，经过指定毫秒数或设置 `CancellationToken`。
    |'
- en: '| `WaitAll(Task[])` | Waits for all of the tasks in array to complete execution.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAll(Task[])` | 等待数组中的所有任务完成执行。 |'
- en: '| `WaitAll(Task[], Int32)` | Waits for all of the tasks in the array to complete
    execution or number of milliseconds to pass. A value of `-1` waits indefinitely.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAll(Task[], Int32)` | 等待数组中的所有任务完成执行或经过指定毫秒数。值为 `-1` 表示无限期等待。 |'
- en: '| `WaitAll(Task[], CancellationToken)` | Waits for all of the tasks in array
    to complete execution or for a `CancellationToken` to be set. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAll(Task[], CancellationToken)` | 等待数组中的所有任务完成执行或设置 `CancellationToken`。
    |'
- en: '| `WaitAll(Task[], TimeSpan)` | Waits for all of the tasks in array to complete
    execution or specified timespan to pass. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAll(Task[], TimeSpan)` | 等待数组中的所有任务完成执行或指定的时长过去。 |'
- en: '| `WaitAll(Task[], Int32, CancellationToken)` | Waits for all of the tasks
    in array to complete execution, number of milliseconds to pass, or `CancellationToken`
    to be set. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAll(Task[], Int32, CancellationToken)` | 等待数组中的所有任务完成执行，经过指定毫秒数或设置 `CancellationToken`。
    |'
- en: '| `WaitAny(Task[])` | Waits for any of the tasks in the array to complete execution.
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAny(Task[])` | 等待数组中的任何任务完成执行。 |'
- en: '| `WaitAny(Task[], Int32)` | Waits for any of the tasks in array to complete
    execution or number of milliseconds to pass. A value of `-1` waits indefinitely.
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAny(Task[], Int32)` | 等待数组中的任何任务完成执行或经过指定毫秒数。值为 `-1` 表示无限期等待。 |'
- en: '| `WaitAny(Task[], CancellationToken)` | Waits for any of the tasks in array
    to complete execution or for a `CancellationToken` to be set. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAny(Task[], CancellationToken)` | 等待数组中的任何任务完成执行或设置 `CancellationToken`。
    |'
- en: '| `WaitAny(Task[], TimeSpan)` | Waits for any of the tasks in array to complete
    execution or specified timespan to pass. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAny(Task[], TimeSpan)` | 等待数组中的任何任务完成执行或指定的时长过去。 |'
- en: '| `WaitAny(Task[], Int32, CancellationToken)` | Waits for any of the tasks
    in array to complete execution, number of milliseconds to pass, or `CancellationToken`
    to be set. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAny(Task[], Int32, CancellationToken)` | 等待数组中的任何任务完成执行，等待的毫秒数，或 `CancellationToken`
    被设置。|'
- en: Returning results from a task
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从任务返回结果
- en: So far, our tasks have not returned any values. However, it is often necessary
    to return a result from a task so it can be used in another part of our application.
    This functionality is provided by the `Result` property of `Task<TResult`>.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的任务还没有返回任何值。然而，通常需要从任务中返回一个结果，以便它可以在我们应用程序的另一个部分中使用。这个功能由 `Task<TResult>`
    的 `Result` 属性提供。
- en: In this recipe, we will be creating a solution similar with tasks similar to
    the previous solution, but each of our three tasks return a result which can then
    be used to display the word count to the user.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个类似于上一个解决方案的解决方案，但我们的三个任务中的每一个都会返回一个结果，然后可以使用这个结果向用户显示单词计数。
- en: How to do it…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's go to Visual Studio and see how we can return result values from our tasks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去 Visual Studio 看看我们如何从我们的任务中返回结果值。
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount2` as the **Solution name**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 C# **控制台应用程序** 项目模板创建一个新的项目，并将 `WordCount2` 作为 **解决方案名称**。
- en: 'Add the following `using` statements are at the top of your `Program` class:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `Program` 类顶部添加以下 `using` 语句：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `Main` method of the `Program` class, add a character array containing
    the basic punctuation marks. We will use this array in `string.Split()` to eliminate
    punctuation marks. Also add a string constant for the `WebClient` `user-agent`
    header.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的 `Main` 方法中，添加一个包含基本标点符号的字符数组。我们将使用此数组在 `string.Split()` 中消除标点符号。还要添加一个用于
    `WebClient` `user-agent` 标头的字符串常量。
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Start by creating three tasks of type `Task<int>` named `task1`, `task2`, and
    `task3`. Your tasks should look as shown in the following code snippet:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建三个类型为 `Task<int>` 的任务，分别命名为 `task1`、`task2` 和 `task3`。您的任务应如下所示：
- en: '[PRE13]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Immediately below your tasks, add `Console.Writeline()` statements that use
    `Task.Result` to display the results to the user. The remainder of the `Main`
    method should now look as shown in the following code snippet:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的任务下方立即添加使用 `Task.Result` 来向用户显示结果的 `Console.WriteLine()` 语句。现在 `Main` 方法其余部分应如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following:![How to do it…](img/0225OT_01_05.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。您应该看到如下类似的输出：![如何做到这一点…](img/0225OT_01_05.jpg)
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Task<TResult>` subclasses the standard `Task` class and provides the additional
    feature of the ability to return a value. This is done by switching from providing
    an `Action` delegate to providing a `Func<TResult>` delegate.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task<TResult>` 是 `Task` 标准类的子类，并提供了能够返回值的附加功能。这是通过从提供 `Action` 委托切换到提供 `Func<TResult>`
    委托来实现的。'
- en: It is worth noting that calling the `Task.Result` accessor will ensure that
    the asynchronous operation is complete before returning, so this is another method
    of waiting for a task to complete. Once the result of `Task` is available, it
    will be stored and returned immediately on later calls to the `Result` accessor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，调用 `Task.Result` 访问器将确保在返回之前异步操作已完成，因此这是等待任务完成的另一种方法。一旦 `Task` 的结果可用，它将在后续对
    `Result` 访问器的调用中立即存储和返回。
- en: Passing data to a task
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向任务传递数据
- en: You can supply the data used by `task` by passing an instance of `System.Action<object>`
    and an object representing the data to be used by the action.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递一个 `System.Action<object>` 的实例以及一个表示将要由操作使用的对象的数据来提供 `task` 所使用的数据。
- en: In this recipe, we will be revisiting our WordCount example, but this time we
    will be parameterizing the data the tasks will act upon.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重新审视我们的 WordCount 示例，但这次我们将对任务将要操作的数据进行参数化。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The ability to pass data into a task allows us to create a single task that
    can operate on multiple pieces of input data. Let''s create a `Console` application
    so we can see how this works:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据传递到任务的能力使我们能够创建一个可以操作多个输入数据的单个任务。让我们创建一个 `Console` 应用程序，以便我们可以看到它是如何工作的：
- en: Start a new project using the C# **Console Application** project template and
    assign `WordCount3`as the **Solution name**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 C# **控制台应用程序** 项目模板创建一个新的项目，并将 `WordCount3` 作为 **解决方案名称**。
- en: 'Add the following `using` statements at the top of your `Program` class:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `Program` 类顶部添加以下 `using` 语句：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `Main` method of the `Program` class, add a character array containing
    the basic punctuation marks. We will use this array in `string.Split()` to eliminate
    punctuation marks. Also add a constant string for the `WebClients` user-agent
    task.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的 `Main` 方法中，添加一个包含基本标点符号的字符数组。我们将使用此数组在 `string.Split()` 中消除标点符号。还要添加一个用于
    `WebClients` 用户代理任务的常量字符串。
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For this recipe, let''s create a `new Dictionary` instance that can hold our
    book titles and URLs. Immediately after the previous statement, add the following
    code to create and initialize the `dictionary`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，让我们创建一个可以保存我们的书名和 URL 的 `new Dictionary` 实例。在上一条语句之后立即添加以下代码来创建和初始化 `dictionary`：
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time we will be creating anonymous tasks in a loop. We still would like
    to wait for the tasks to complete before prompting the user to exit the program.
    We need a collection to hold our tasks, so we can pass them to `Task.WaitAll()`
    and wait for completion. Below the previous statement, create a `List<Task>` to
    hold our tasks.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们将在循环中创建匿名任务。我们仍然希望在提示用户退出程序之前等待任务完成。我们需要一个集合来保存我们的任务，以便我们可以将它们传递给 `Task.WaitAll()`
    并等待完成。在上一条语句下方创建一个 `List<Task>` 来保存我们的任务。
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we want to create a `for` loop to loop through `KeyValuePairs` in the
    dictionary. Let's put the `for` loop below the previous statement.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建一个 `for` 循环来遍历字典中的 `KeyValuePairs`。让我们在上一条语句下方放置 `for` 循环。
- en: '[PRE19]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Inside the body of your `for` loop, put the definition of `task`, and add it
    to your task list as follows. Note the `KeyValuePair` being passed into `task`
    is in the form of an object. In the delegate body, we cast this object back to
    a `KeyValuePair`. Other than that, task is pretty much the same.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `for` 循环体内，放置 `task` 的定义，并将其按照以下方式添加到任务列表中。注意传递给 `task` 的 `KeyValuePair`
    是以对象的形式。在委托体中，我们将此对象转换回 `KeyValuePair`。除此之外，`task` 几乎相同。
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After the `for` loop, let''s finish things up by waiting on the tasks to complete
    using `Task.WaitAll()` and prompting the user to exit. The last few lines should
    be as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `for` 循环之后，让我们通过使用 `Task.WaitAll()` 等待任务完成并提示用户退出来完成事情。最后几行应该是这样的：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_01_06.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到以下截图所示的输出：![如何做…](img/0225OT_01_06.jpg)
- en: How it works…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: By passing data to `Task` using the state feature, we now have a very powerful
    model for task creation, because we can create many tasks at once, each having
    the same code statements in the body and passing in the data that `Task` operates
    on. It also makes our code much more concise and readable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用状态功能将数据传递给 `Task`，我们现在有一个非常强大的任务创建模型，因为我们可以一次创建许多任务，每个任务在主体中都有相同的代码语句，并传递
    `Task` 操作的数据。这也使我们的代码更加简洁和易于阅读。
- en: 'In our application we need to pass two items of data into the `task`: a book
    title and the URL of the book, so we created `dictionary`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们需要将两个数据项传递给 `task`：一本书的标题和书的 URL，因此我们创建了 `dictionary`。
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We would also want to wait on all of these tasks to complete before we prompt
    the user to exit, so we need to create a collection that can be converted to an
    array of tasks to hold our `Task` objects. In this case, we made a list of tasks.
    In the body of our look that creates the tasks, we will add the tasks to the list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望等待所有这些任务完成后再提示用户退出，因此我们需要创建一个可以转换为任务数组以保存我们的 `Task` 对象的集合。在这种情况下，我们创建了一个任务列表。在创建任务的循环体内，我们将任务添加到列表中。
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In our loop, we will pass in each of `KeyValuePairs` in `dictionary` as an object,
    using the `Task(Action<Object>, Object)` constructor. This syntax is just a bit
    odd because you actually refer to the `state` object twice.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的循环中，我们将使用 `Task(Action<Object>, Object)` 构造函数将 `dictionary` 中的每个 `KeyValuePairs`
    作为对象传递。这种语法有点奇怪，因为你实际上两次引用了 `state` 对象。
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The key takeaway here is that the only way to pass data to a `Task` constructor
    is using `Action<Object>`. To use the members of a specific type, you must convert
    or explicitly cast the data back to the desired type in the body of the `Task`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键要点是，向 `Task` 构造函数传递数据的唯一方法是使用 `Action<Object>`。要使用特定类型的成员，必须在 `Task` 的主体中将数据转换或显式地转换回所需类型。
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a child task
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建子任务
- en: Code that is running a task can create another task with the `TaskCreationOptions.AttachedToParent
    set`. In this case, the new task becomes a child of the original or parent task.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行任务的代码可以使用 `TaskCreationOptions.AttachedToParent` 设置创建另一个任务。在这种情况下，新任务成为原始或父任务的子任务。
- en: In this recipe, we will be using a simplified version of the WordCount solution
    that uses a parent task to get the text of one book into a string array, and then
    spins up a child task to print the results.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用简化版的 WordCount 解决方案，该方案使用父任务将一本书的文本放入字符串数组中，然后启动一个子任务来打印结果。
- en: How to do it…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's return to our WordCount solution, so we can see how to create a child
    task and attach it to a parent.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 WordCount 解决方案，这样我们就可以看到如何创建子任务并将其附加到父任务上。
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount4` as the **Solution name**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 C# **控制台应用程序** 项目模板开始一个新的项目，并将 **解决方案名称** 设置为 `WordCount4`。
- en: 'Add the following `using` statements at the top of your `Program` class:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的顶部添加以下 `using` 语句：
- en: '[PRE26]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the `Main` method of the `Program` class, add a character array containing
    the basic punctuation marks. We will use this array in `string.Split()` to eliminate
    punctuation marks. Also, add a constant string for the `WebClient` `user-agent`
    header.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的 `Main` 方法中，添加一个包含基本标点符号的字符数组。我们将使用这个数组在 `string.Split()` 中消除标点符号。同时，添加一个常量字符串用于
    `WebClient` 的 `user-agent` 头部。
- en: '[PRE27]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, let's create the basic structure of our parent task. This is very similar
    to the other tasks we have created so far, and takes no parameters, and returns
    no values.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建父任务的基本结构。这与我们迄今为止创建的其他任务非常相似，它不接收任何参数，也不返回任何值。
- en: '[PRE28]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, right after the comment in the parent task, let's create a child task
    to print the results and set the `AttachedToParent` option.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在父任务的注释之后，让我们创建一个子任务来打印结果并设置 `AttachedToParent` 选项。
- en: '[PRE29]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, just below the close of the parent task, let''s wait for the parent
    task to complete, and prompt the user to exit the application with the following
    code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在父任务的关闭代码下方，让我们等待父任务完成，并使用以下代码提示用户退出应用程序：
- en: '[PRE30]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That's pretty much it. In Visual Studio 2012, press *F5* to run the project.
    You should see output as shown in the following screenshot:![How to do it…](img/0225OT_01_07.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这基本上就是全部内容。在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到以下截图所示的输出：![如何做到这一点…](img/0225OT_01_07.jpg)
- en: How it works…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using `TaskCreationOptions.AttachedToParent` expresses structured parallelism.
    The parent task will wait for the child task to finish, so at the end of our program,
    all we have to do is wait for the parent task.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TaskCreationOptions.AttachedToParent` 表达结构化并行性。父任务将等待子任务完成，因此在我们程序的末尾，我们只需要等待父任务。
- en: The nested child task, itself, is just an ordinary `task` created in the delegate
    of another `task`. A parent task may create any number of child tasks, limited
    only by system resources.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的子任务本身只是在另一个 `task` 的委托中创建的普通 `task`。父任务可以创建任意数量的子任务，仅受系统资源的限制。
- en: You can also create a nested task without using `TaskCreationOptions.AttachedToParent`.
    The only real difference is that the nested tasks created without this option
    are essentially independent from the outer task. A task created with the `TaskCreationOptions.AttachedToParent`
    option set is very closely synchronized with the parent.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以不使用 `TaskCreationOptions.AttachedToParent` 创建嵌套任务。唯一的真正区别是，没有此选项创建的嵌套任务基本上与外部任务独立。使用
    `TaskCreationOptions.AttachedToParent` 选项创建的任务与父任务非常紧密地同步。
- en: The outer task could also use the `DenyChildAttach` option to prevent other
    tasks from attaching as child tasks. However, the same outer task could still
    create an independent nested task.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 外部任务也可以使用 `DenyChildAttach` 选项来防止其他任务作为子任务附加。然而，相同的父任务仍然可以创建一个独立的嵌套任务。
- en: Lazy task execution
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒任务执行
- en: Lazy initialization of an object means that object creation is deferred until
    the object is actually used by your program. If you have a parallel task that
    you want to execute only when the value returned from the task is actually needed,
    you can combine lazy task execution with the `Task.Factory.StartNew` method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的懒初始化意味着对象创建被延迟到对象实际上被程序使用时。如果您有一个只想在任务返回的值实际需要时才执行的任务，您可以将懒任务执行与 `Task.Factory.StartNew`
    方法结合使用。
- en: In this recipe, we will return to our, by now familiar WordCount solution, to
    show you how to execute a parallel task and compute a word count for our book,
    only when we display the result to the console.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将回到我们熟悉的 WordCount 解决方案，向您展示如何执行并行任务并计算书籍的单词数，仅在我们在控制台显示结果时。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's create a console application that demonstrates how we can defer task creation
    until the result of the task is needed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个控制台应用程序，演示我们如何将任务创建推迟到需要任务结果时。
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount5` as the **Solution name**.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C# **控制台应用程序**项目模板创建一个新的项目，并将`WordCount5`作为**解决方案名称**。
- en: Add the following `using` statements at the top of your `Program` class.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Program`类的顶部添加以下`using`语句。
- en: '[PRE31]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first step is to declare `System.Threading.Task<int>` for lazy initialization.
    In the `Main` method of your `Program` class, put a `Lazy` declaration as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是声明`System.Threading.Task<int>`进行懒初始化。在你的`Program`类的`Main`方法中，放置以下`Lazy`声明：
- en: '[PRE32]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the `Lazy` initialization declaration, place the code to create to task.
    The entire statement should now look as the following code snippet:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Lazy`初始化声明中，放置创建任务的代码。整个语句现在应该看起来像以下代码片段：
- en: '[PRE33]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we just need to write the result to the `Console`. Just add the following
    code to the end of your program:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要将结果写入`Console`。只需将以下代码添加到你的程序末尾：
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: All done. In Visual Studio 2012, press *F5* to run the project. You should see
    the output as shown in the following screenshot:![How to do it…](img/0225OT_01_08.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成了。在Visual Studio 2012中，按*F5*运行项目。你应该会看到以下截图所示的输出：![如何做…](img/0225OT_01_08.jpg)
- en: How it works…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`System.Lazy<T>` creates a thread safe Lazy initialization of an object. Lazy
    initialization is primarily used to improve performance and avoid computational
    overhead until necessary. You can pass a delegate (remember that System Threading
    Task is just a wrapper around a delegate) to the `System.Lazy` constructor, and
    as we have done in this recipe, you can use a lambda expression to specify a `factory`
    method for object creation. This keeps all of the initialization code in one place.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Lazy<T>`创建了一个线程安全的对象懒初始化。懒初始化主要用于提高性能和避免不必要的计算开销。你可以将一个委托（记住，System
    Threading Task只是委托的一个包装）传递给`System.Lazy`构造函数，就像我们在本菜谱中所做的那样，你可以使用lambda表达式来指定对象创建的`factory`方法。这可以将所有初始化代码放在一个地方。'
- en: '`Lazy` initialization occurs the first time the `System.Lazy<T>.Value` property
    is accessed.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lazy`初始化发生在第一次访问`System.Lazy<T>.Value`属性时。'
- en: Handling task exceptions using try/catch block
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用try/catch块处理任务异常
- en: Let's face it; sometimes things just go wrong with our code. Even with the simplified
    parallel programming model provided by the TPL, we still need to be able to handle
    our exceptions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实；有时候我们的代码会出现问题。即使有了TPL提供的简化并行编程模型，我们仍然需要能够处理我们的异常。
- en: 'Tasks use `System.AggregateException` to consolidate multiple failures into
    a single exception object. In this recipe, we will take a look at the simplest
    way to handle `System.AggregateException` in our `tasks`: the `try`/`catch` blocks.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 任务使用`System.AggregateException`将多个失败合并成一个异常对象。在本菜谱中，我们将看看在`tasks`中处理`System.AggregateException`的最简单方法：`try`/`catch`块。
- en: The try-catch statement consists of a try block followed by one of more catch
    blocks, which specify handlers for different exceptions. The try block contains
    the guarded code that may cause the exception.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: try-catch语句由一个try块后跟一个或多个catch块组成，这些catch块指定了不同异常的处理程序。try块包含可能导致异常的保护代码。
- en: Getting ready…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: For this recipe we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime exception is thrown, and intercepts
    the exception before it gets to our handler.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要关闭Visual Studio 2012的异常助手。异常助手会在抛出运行时异常时出现，并在它到达我们的处理器之前拦截异常。
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭异常助手，请转到**调试**菜单并选择**异常**。
- en: Uncheck the **user-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    ready…](img/0225OT_01_09.jpg)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中**公共语言运行时异常**旁边的**用户未处理的**复选框。![准备中…](img/0225OT_01_09.jpg)
- en: How to do it…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's return to our WordCount solution so we can see how to handle an `AggregateException`
    thrown by a parallel task.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到WordCount解决方案，以便我们可以看到如何处理由并行任务抛出的`AggregateException`。
- en: Start a new project using the C# **Console Application** project template and
    assign `WordCount6` as the **Solution name**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C# **控制台应用程序**项目模板创建一个新的项目，并将`WordCount6`作为**解决方案名称**。
- en: 'Add the following `using` statements are at the top of your `Program` class:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Program`类的顶部添加以下`using`语句：
- en: '[PRE35]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For this recipe, we will just need a single task. The task will be very similar
    to our other word count tasks, but in this one we will simulate a problem with
    the `System.Net.WebClient` by creating and throwing a `System.Net.WebException`.
    In the `Main` method of your `Program` class, create `System.Task` that looks
    as the following `Task`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们只需要一个任务。这个任务将非常类似于我们的其他单词计数任务，但在这个任务中，我们将通过创建和抛出`System.Net.WebException`来模拟`System.Net.WebClient`的问题。在你的`Program`类的`Main`方法中，创建一个如下所示的`System.Task`：
- en: '[PRE36]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Just below the `Task`, let's put in our `try`/`catch` blocks as shown in the
    following code snippet. In the `catch` block, we will want to specifically catch
    `System.AggregateException`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Task`下方，让我们按照以下代码片段所示添加我们的`try`/`catch`块。在`catch`块中，我们将想要特别捕获`System.AggregateException`。
- en: '[PRE37]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now let's implement the body of our `try` block. The body of the `try` block
    should be as shown in the following code snippet. There are a couple of subtle
    but important concepts in here that will be explained later in the chapter.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现`try`块的主体。`try`块的主体应如下所示。这里有几个微妙但重要的概念将在本章后面解释。
- en: '[PRE38]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, let''s implement the body of our `catch` block. It should look as shown
    in the following code snippet:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们实现`catch`块的主体。它应该如下所示：
- en: '[PRE39]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After the `catch` block, let's finish up by prompting the user to exit, and
    waiting on the user to hit *Enter*.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`catch`块之后，让我们通过提示用户退出并等待用户按下*Enter*来完成。
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_01_10.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到如下截图所示的输出：![如何做…](img/0225OT_01_10.jpg)
- en: How it works…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: All of this stuff has been pretty self-explanatory so far, but handling exceptions
    in task involves a couple of subtleties that need to be pointed out.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有这些内容都相当直观，但在任务中处理异常涉及一些需要指出的微妙之处。
- en: The task itself is pretty straightforward. Other than throwing the `System.Net.WebException`,
    there is nothing out of the ordinary here.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 任务本身相当直接。除了抛出`System.Net.WebException`之外，这里没有其他不寻常的地方。
- en: Let's take a closer look at the try/catch blocks. The first statement in the
    `try` block `System.Threading.Task.Wait()` to wait on task completion. However,
    there is another purpose here. Unhandled exceptions thrown inside a `task` are
    swallowed by the runtime and wrapped up in `System.AggregateException`. It is
    your job to handle this.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`try`/`catch`块。`try`块中的第一个语句`System.Threading.Task.Wait()`是用来等待任务完成的。然而，这里还有一个目的。在`task`内部抛出的未处理异常会被运行时吞没，并包装在`System.AggregateException`中。这是你的工作。
- en: The TPL also has the concept of `AggregateException` being observed. If `AggregateException`
    is raised by your task, it will only be handled if it is currently being observed.
    This is very important to understand. If you never take an action that causes
    the exceptions to be observed, you are going to have a problem. When the `Task`
    object is garbage collected, the `Finalize` method of the `task` will see that
    the `task` had unobserved exceptions, and it will throw`System.AggregateException`.
    You will not be able to catch an exception thrown by the finalizer thread and
    your process will be terminated.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: TPL还有一个观察`AggregateException`的概念。如果你的任务引发了`AggregateException`，它只有在当前正在被观察时才会被处理。这一点非常重要。如果你从未采取任何导致异常被观察的动作，你将遇到问题。当`Task`对象被垃圾回收时，`task`的`Finalize`方法会看到`task`有未观察到的异常，并抛出`System.AggregateException`。你将无法捕获由终结线程抛出的异常，并且你的进程将被终止。
- en: 'So how to you observe an `AggregateException`, you ask? The `Systm.Threading.Task`
    class has a few methods and properties call triggers that cause `System.AggregateException`
    to be observed. A few of these are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何观察`AggregateException`呢？`System.Threading.Tasks.Task`类有几个方法和属性称为触发器，它们会导致`System.AggregateException`被观察。以下是一些这样的触发器：
- en: Task.Wait
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Task.Wait
- en: Task.WaitAny
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Task.WaitAny
- en: Task.WaitAll
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Task.WaitAll
- en: Task.Result
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Task.Result
- en: Using any of these `trigger` methods indicates to the runtime that you are interested
    in observing any `System.AggregateException` that occurs. If you do not use one
    of the `trigger` methods on the `Task` class, the TPL will not raise any `AggregateException`,
    and an unhandled exception will occur.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些`trigger`方法中的任何一个都表示你希望运行时观察任何发生的`System.AggregateException`。如果你不在`Task`类上使用任何一个`trigger`方法，TPL将不会引发任何`AggregateException`，并且将发生未处理的异常。
- en: Now, let's take a look at the `catch` block. `System.AggregateException` can
    wrap many individual exception objects. In our `catch` block, we need to loop
    through `AggregateException.InnerExceptions` to take a look at all of the individual
    exceptions that occurred in a task.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `catch` 块。`System.AggregateException` 可以包装多个单独的异常对象。在我们的 `catch` 块中，我们需要遍历
    `AggregateException.InnerExceptions` 来查看任务中发生的所有单个异常。
- en: It is important to note that there is really no way to correlate an exception
    from the `AggregateExcetion.InnerExceptions` collection back to the particular
    `task` that threw an exception. All you really know is that some operation threw
    an `Exception`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，实际上并没有办法将来自 `AggregateExcetion.InnerExceptions` 集合的异常关联回抛出异常的特定 `task`。您真正知道的是某些操作抛出了一个
    `Exception`。
- en: '`System.AggregateException` overrides the `GetBaseException` method of exception,
    and returns the innermost exception, which is the initial cause of the problem.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.AggregateException` 覆盖了异常的 `GetBaseException` 方法，并返回最内层的异常，即问题的初始原因。'
- en: Handling task exceptions with AggregateException.Handle
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AggregateException.Handle 处理任务异常
- en: In this recipe, we will look at another way to handle `System.AggregateException`,
    by using the `AggregateException.Handle` method. The `Handler` method invokes
    a handler function for each exception wrapped in `AggregateException`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将探讨另一种处理 `System.AggregateException` 的方法，即使用 `AggregateException.Handle`
    方法。`Handler` 方法为 `AggregateException` 中包装的每个异常调用处理器函数。
- en: Getting ready…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime exception is thrown and intercepts
    the exception before it gets to our handler.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要关闭 Visual Studio 2012 的异常助手。异常助手会在抛出运行时异常时出现，并在它到达我们的处理器之前拦截异常。
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭异常助手，请转到 **Debug** 菜单并选择 **Exceptions**。
- en: Uncheck the **user-unhandled** checkbox next to **Common Language Runtime Exceptions**.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选 **Common Language Runtime Exceptions** 旁边的 **user-unhandled** 复选框。
- en: How to do it…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's take a look at how we can use `AggregateException.Handle` to provide an
    alternate method to handling exceptions in a parallel application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `AggregateException.Handle` 来提供一个在并行应用程序中处理异常的替代方法。
- en: For this recipe, we will return to our **WordCount6** project, and modify it
    to handle our exceptions in a different way. Start Visual Studio 2012 and open
    the **WordCount6** project.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将回到我们的 **WordCount6** 项目，并修改它以以不同的方式处理异常。启动 Visual Studio 2012 并打开
    **WordCount6** 项目。
- en: 'The first step is to define our handler function that will be invoked when
    we call `AggregateException.Handle`. Following the `Main` method of your `Program`
    class, add a new `private static handler` method that returns a bool. It should
    look as the following code snippet:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是定义我们的处理器函数，该函数将在我们调用 `AggregateException.Handle` 时被调用。在您的 `Program` 类的 `Main`
    方法之后，添加一个新的 `private static handler` 方法，它返回一个布尔值。它应该看起来像以下代码片段：
- en: '[PRE41]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The only other step here is to replace the body of your `catch` block with
    a call to `System.AggregateException.Handle`, passing in the `HandleWebExceptions`
    predicate. The updated `try`/`catch` block should look as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的另一个步骤是将您的 `catch` 块的主体替换为对 `System.AggregateException.Handle` 的调用，传递 `HandleWebExceptions`
    谓词。更新的 `try`/`catch` 块应如下所示：
- en: '[PRE42]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Those are the only modifications necessary. In Visual Studio 2012, press *F5*
    to run the project. You should see output as shown in the following screenshot:![How
    to do it…](img/0225OT_01_11.jpg)
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些就是所需的唯一修改。在 Visual Studio 2012 中，按 *F5* 运行项目。您应该看到以下截图所示的输出：![如何操作…](img/0225OT_01_11.jpg)
- en: How it works…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`AggregateException.Handle()` takes a predicate that you supply, and the predicate
    will be invoked once for every exception wrapped in `System.AggregateException`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`AggregateException.Handle()` 接收一个您提供的谓词，并且该谓词将为 `System.AggregateException`
    中包装的每个异常调用一次。'
- en: The predicate itself just needs to contain the logic to handle the various exception
    types that you expect, and to return true or false to indicate whether the exception
    was handled.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词本身只需要包含处理您期望的各种异常类型的逻辑，并返回 true 或 false 以指示是否处理了异常。
- en: If any of the exceptions went unhandled, they will be wrapped in a new `System.AggregateException`
    and thrown.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何异常未被处理，它们将被包装在一个新的 `System.AggregateException` 中并抛出。
- en: Cancelling a task
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消任务
- en: Up to this point, we have focused on creating, running, and handling exceptions
    in `tasks`. Now we will begin to take a look at using `System.Threading.CancellationTokenSource`
    and `System.Threading.CancellationToken` to cancel `tasks`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于创建、运行和处理`tasks`中的异常。现在，我们将开始探讨使用`System.Threading.CancellationTokenSource`和`System.Threading.CancellationToken`来取消`tasks`。
- en: This recipe will show how to cancel a single task.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示如何取消单个任务。
- en: How to do it…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's create a console application that shows how to cancel a parallel task.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个控制台应用程序，展示如何取消并行任务。
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount7` as the **Solution name**.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C# **控制台应用程序**项目模板创建一个新的项目，并将`WordCount7`作为**解决方案名称**。
- en: 'Add the following `using` statements at the top of your `Program` class:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Program`类的顶部添加以下`using`语句：
- en: '[PRE43]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s start by creating `CancellationTokenSource` and getting our `CancellationToken`.
    In the `Main` method of your `Program` class, add the following statements:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建`CancellationTokenSource`并获取我们的`CancellationToken`开始。在你的`Program`类的`Main`方法中，添加以下语句：
- en: '[PRE44]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we need to create our `Task` and pass `CancellationToken` into the constructor.
    Right after the previous line, put in the following `Task` definition:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们的`Task`并将`CancellationToken`传递给构造函数。在上一行之后，添加以下`Task`定义：
- en: '[PRE45]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the body of our `Task`, we need to check the `IsCancellationRequested` property
    of `CancellationToken`. If it has been, we dispose of our resource and throw `OperationCancelledException`.
    If not, we do our usual work. Enter the following code into the body of `Task`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Task`的主体中，我们需要检查`CancellationToken`的`IsCancellationRequested`属性。如果已经取消，我们销毁我们的资源并抛出`OperationCancelledException`。如果没有，我们执行我们通常的工作。将以下代码输入到`Task`的主体中：
- en: '[PRE46]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Right after the task, put in the following lines to write the cancellation status
    to the `Console`, and then call the `Cancel` method of `TokenSource`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务完成后，将以下行添加到将取消状态写入`控制台`，然后调用`TokenSource`的`Cancel`方法。
- en: '[PRE47]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following are the last statements put in a condition to check whether the
    task has been cancelled or faulted before we try to write out the results:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在尝试写入结果之前，以下最后几行被放入一个条件中，以检查任务是否已被取消或出现故障：
- en: '[PRE48]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Lastly, we'll finish up by prompting the user to exit and waiting for the input.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将通过提示用户退出并等待输入来完成。
- en: '[PRE49]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_01_12.jpg)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到以下截图所示的输出：![如何操作…](img/0225OT_01_12.jpg)
- en: How it works…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The basic idea of cancelling `task` is that we create `CancellationTokenSource`,
    obtain `CancellationToken` from it, and then pass `CancellationToken` onto the
    `Task` constructor. Once we have done that, we can call the `Cancel` method on
    the `CancellationTokenSource` to cancel the task.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 取消`task`的基本思想是，我们创建`CancellationTokenSource`，从它那里获取`CancellationToken`，然后将`CancellationToken`传递给`Task`构造函数。一旦我们这样做，我们就可以在`CancellationTokenSource`上调用`Cancel`方法来取消任务。
- en: That's all easy enough. However, inside `task` we have a couple of options on
    how to handle the cancellation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很简单。然而，在`task`内部，我们有一些处理取消的选项。
- en: If your task has resources that need to be cleaned up (such as the `WebClient`),
    you need to check the cancellation tokens `IsCancellationRequested` property,
    then dispose of the resources, and throw a new `OperationCancelledException`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的任务有需要清理的资源（例如`WebClient`），你需要检查取消令牌的`IsCancellationRequested`属性，然后销毁资源，并抛出一个新的`OperationCancelledException`。
- en: The other option, if your task doesn't use resources which need to be explicitly
    cleaned up, is to use the token `ThrowIsCancellationRequested()`, which will ensure
    the task transitions to a status of cancelled in a single statement.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是，如果你的任务不使用需要显式清理的资源，可以使用`ThrowIsCancellationRequested()`令牌，这将确保任务在单个语句中转换为已取消状态。
- en: If you need to execute `task` and prevent it from being cancelled, you can obtain
    a special `CancellationToken` that is not associated with any `CancellationTokenSource`
    from the static `CancellationToken.None` property, and pass this token to `Task`.
    Since there is no associated `CancellationTokenSource`, it is not possible to
    call `Cancel` for this token, and any code that is checking the `CancellationToken.IsCancellationRequested`
    property will always get back a false.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要执行 `task` 并防止它被取消，您可以从静态属性 `CancellationToken.None` 获取一个不与任何 `CancellationTokenSource`
    关联的特殊 `CancellationToken`，并将此令牌传递给 `Task`。由于没有关联的 `CancellationTokenSource`，因此无法为此令牌调用
    `Cancel`，并且任何检查 `CancellationToken.IsCancellationRequested` 属性的代码都将始终返回 `false`。
- en: There's more…
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can register one or more methods to be called when `CancellationTokenSource`
    is cancelled, by registering a `callback` method with the `CancellationToken.Register`
    method. You just need to pass `Action<Object>`, and optionally, a state value
    will be passed to `callback` and a `Boolean`, indicating whether to invoke the
    delegate using `SynchronizationContext` of the calling thread to the `Register`
    method. Passing in a value of false means the thread that calls `Cancel` will
    invoke the registered methods synchronously. If you pass true, the callbacks will
    be sent to `SynchronizationContext`, which determines which thread will invoke
    the callbacks.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `CancellationToken.Register` 方法注册一个 `callback` 方法来注册一个或多个在 `CancellationTokenSource`
    被取消时调用的方法。您只需传递 `Action<Object>`，并且可选地，一个状态值将被传递给 `callback`，以及一个 `Boolean`，指示是否使用调用线程的
    `SynchronizationContext` 调用 `Register` 方法。传递 `false` 的值意味着调用 `Cancel` 的线程将同步调用已注册的方法。如果您传递
    `true`，回调将被发送到 `SynchronizationContext`，它将确定哪个线程将调用回调。
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `Register` method of `CancellationToken` returns a `CancellationTokenRegistration`
    object. To remove a registered callback from `CancellationTokenSource`, so it
    doesn't get invoked, call the `Dispose` method of the `CancellationTokenRegistration`
    object.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationToken` 的 `Register` 方法返回一个 `CancellationTokenRegistration` 对象。要从
    `CancellationTokenSource` 中移除已注册的回调，以便它不会被调用，请调用 `CancellationTokenRegistration`
    对象的 `Dispose` 方法。'
- en: You can also create `CancellationTokenSource` by linking other `CancellationTokenSource`
    objects together. The new composite `CancellationTokenSource` will be cancelled,
    if any of the linked `CancellationTokenSource` objects are cancelled.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过将其他 `CancellationTokenSource` 对象链接在一起来创建 `CancellationTokenSource`。如果任何链接的
    `CancellationTokenSource` 对象被取消，新的复合 `CancellationTokenSource` 将会被取消。
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Cancelling one of many tasks
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消众多任务之一
- en: Now that we have seen how to cancel a task, let's take a look at how we can
    use `CancellationToken` to cancel multiple tasks with a single call to `CancellationTokenSource.Cancel()`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何取消一个任务，让我们看看我们如何可以使用 `CancellationToken` 通过对 `CancellationTokenSource.Cancel()`
    的单次调用来取消多个任务。
- en: How to do it…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Now let's return to our WordCount example and create a `Console` application
    that provides for the cancellation of multiple tasks with single `CancellationToken`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的 WordCount 示例，创建一个 `Console` 应用程序，该程序允许通过单个 `CancellationToken` 取消多个任务。
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount8` as the **Solution name**.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 C# **控制台应用程序** 项目模板启动一个新的项目，并将 `WordCount8` 作为 **解决方案名称**。
- en: 'Add the following `using` statements at the top of your `Program` class:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `Program` 类顶部添加以下 `using` 语句：
- en: '[PRE52]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, let's create a `helper` method to display errors and cancellation status.
    Since we have multiple tasks, it's better to have this logic all in one place.
    Following the `Main` method of your `Program` class, create a `static` method
    call `HandleExceptions` which will display the errors and task status to the user.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 `helper` 方法来显示错误和取消状态。由于我们有多个任务，最好将此逻辑放在一个地方。在您的 `Program` 类的 `Main`
    方法之后创建一个 `static` 方法 `HandleExceptions`，它将向用户显示错误和任务状态。
- en: '[PRE53]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next, at the top of the `Main` method, create `CancellationTokenSource` and
    get our `CancellationToken`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `Main` 方法的顶部创建 `CancellationTokenSource` 并获取我们的 `CancellationToken`。
- en: '[PRE54]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we need to create our tasks and our array of `delimiters`. The tasks are
    the same as in the recipe for cancelling a single task. The key here is that we
    are passing the same `CancellationToken` in for all three tasks.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的任务和我们的 `delimiters` 数组。任务与取消单个任务的配方中的任务相同。关键是我们在所有三个任务中传递了相同的 `CancellationToken`。
- en: '[PRE55]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'OK, let''s finish up by calling `CancellationTokenSource.Cancel()` , checking
    the results, and catching the exceptions. The remainder of the `Main` method should
    look as the following code snippet:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们通过调用 `CancellationTokenSource.Cancel()`、检查结果和捕获异常来完成。`Main` 方法的其余部分应如下代码片段所示：
- en: '[PRE56]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_01_13.jpg)
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到如下截图所示的输出：![如何操作…](img/0225OT_01_13.jpg)
- en: How it works…
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Functionally, cancelling multiple tasks is the same as cancelling a single task.
    In fact, the Parallel Extensions team has put a lot of work into making cancellation
    of various parallel structures very similar, as you will see as we go through
    the book.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，取消多个任务与取消单个任务相同。实际上，并行扩展团队已经投入了大量工作，使得取消各种并行结构非常相似，正如我们在阅读本书时会看到的那样。
- en: 'All that is necessary to cancel multiple tasks is to create `CancellationToken`,
    then pass that token into all of the tasks you wish to cancel as shown in the
    following code snippet:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 取消多个任务所必需的只是创建一个 `CancellationToken`，然后将该令牌传递到所有你希望取消的任务中，如下代码片段所示：
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
