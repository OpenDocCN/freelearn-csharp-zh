<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Adding Depth – Cinder 3D Basics</h1></div></div></div><p>This chapter will introduce you to the basic 3D aspects and practical methods as well as the 3D primitives that can be drawn with Cinder. We will start by making a transition from 2D coordinate system to 3D, and continue with basic problems and solutions that we are going to face in the 3D graphics programming world from now on. We will also add basic animation during the walkthrough to demonstrate the basic approach of adding movement to the otherwise static objects.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Introducing the 3D space</h1></div></div></div><p>To use Cinder with <a class="indexterm" id="id249"/>3D we need to understand a bit about 3D computer graphics. First thing that we need to know is that 3D graphics are created in a three-dimensional space that exists somewhere in the computer and is transformed into a two-dimensional image that can be displayed on our computer screens afterwards.</p><p>Usually there is a projection<a class="indexterm" id="id250"/> (frustrum) that has different properties which are similar to the properties of cameras we have in the real world. <strong>Frustrum</strong> <a class="indexterm" id="id251"/>takes care of rendering all the 3D objects that are visible in frustrum. It is responsible for creating the 2D image that we see on the screen.</p><div><img alt="Introducing the 3D space" src="img/9564_08_01.jpg"/></div><p>As you can see in the preceding figure, all objects inside the frustrum are being rendered on the screen. Objects<a class="indexterm" id="id252"/> outside the view frustrum are being ignored.</p><p>OpenGL<a class="indexterm" id="id253"/> (that is being used for drawing in Cinder) relies on the so called rendering pipeline to map the 3D coordinates of the objects to the 2D screen coordinates. Three kind of matrices are used for this process: the model, view, and projection matrices. The model matrix maps the 3D object's local coordinates to the world (or global) space, the view matrix maps it to the camera space, and finally the projection matrix takes care of the mapping to the 2D screen space. Older versions of OpenGL combine the model and view matrices into one—the <a class="indexterm" id="id254"/>
<strong>modelview</strong> matrix.</p><p>In the previous chapters we used 2D coordinates (x and y coordinate axes) to place different kinds of objects and graphics on the screen. Now we will take advantage of the third dimension—the z axis.</p><p>The coordinate system in Cinder starts from the top-left corner of the screen. Any object placed there has the coordinates 0, 0, 0 (these are values of x, y, and z respectively). The x axis extends to the right, y to the bottom, but z extends towards the viewer (us), as shown in the following figure:</p><div><img alt="Introducing the 3D space" src="img/9564_08_02.jpg"/></div><p>As you can see in the preceding figure, the coordinate system in Cinder is a bit different from the one in <a class="indexterm" id="id255"/>OpenGL. The built-in OpenGL drawing functions in Cinder takes care of the mapping.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Drawing in 3D</h1></div></div></div><p>Let's try to draw something by<a class="indexterm" id="id256"/> taking into account that there is a third dimension.</p><p>Create another <a class="indexterm" id="id257"/>project by using <strong>TinderBox</strong>
<a class="indexterm" id="id258"/> and name it <code class="literal">Basic3D</code>. Open the project file (<code class="literal">xcode/Basic3D.xcodeproj</code> on Mac or <code class="literal">vc10\Basic3D.sln</code> on Windows). Open <code class="literal">Basic3DApp.cpp</code> in the editor and navigate to the <code class="literal">draw()</code> method<a class="indexterm" id="id259"/> implementation.</p><p>Just after the <code class="literal">gl::clear()</code> method<a class="indexterm" id="id260"/> add the following line to draw a cube:</p><div><pre class="programlisting">gl::drawCube( Vec3f(0,0,0), Vec3f(100,100,100) );</pre></div><p>The first parameter defines the position of the center of the cube, the second defines its size. Note that we use the <code class="literal">Vec3f()</code> variables to define position and size within three (x, y and z) dimensions.</p><p>Compile and run the project. This will draw a solid cube at the top-left corner of the screen. We are able to see just one quarter of it because the center of the cube is the reference point. Let's move it to the center of the screen by transforming the previous line as follows:</p><div><pre class="programlisting">gl::drawCube(
        Vec3f(getWindowWidth()/2,getWindowHeight()/2,0),
        Vec3f(100,100,100) );</pre></div><p>Now we are <a class="indexterm" id="id261"/>positioning<a class="indexterm" id="id262"/> the cube in the middle of the screen no matter what the window's width or height is, because we pass half of the window's width (<code class="literal">getWindowWidth()/2</code>) and half of the window's height (<code class="literal">getWindowHeight()/2</code>) as values for the x and y coordinates of the cube's location. Compile and run the project to see the result. Play around with the size parameters to understand the logic behind it.</p><p>We may want to rotate the cube a bit. There is a built-in <code class="literal">rotate()</code> function<a class="indexterm" id="id263"/> that we can use. One of the things that we have to remember, though, is that we have to use it before drawing the object. So <a class="indexterm" id="id264"/>add the following line before <code class="literal">gl::drawCube()</code>:</p><div><pre class="programlisting">gl::rotate( Vec3f(0,1,0) );</pre></div><p>Compile and run the project. You should see a strange rotation animation around the y axis. The problem here is that the <code class="literal">rotate()</code> function rotates the whole 3D world of our application including the object in it and it does so by taking into account the scene coordinates. As the center of the 3D world (the place where all axes cross and are zero) is in the top-left corner, all rotation is happening around this point.</p><div><img alt="Drawing in 3D" src="img/9564_08_03.jpg"/></div><p>To change that we have to use the <code class="literal">translate()</code> function. It is used to move the scene (or canvas) before we <code class="literal">rotate()</code> or<a class="indexterm" id="id265"/> <code class="literal">drawCube()</code>. To make our cube rotate around the center of the screen, we have to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Use the <code class="literal">translate()</code> function<a class="indexterm" id="id266"/> to translate the 3D world to the center of the screen.</li><li class="listitem">Use the <code class="literal">rotate()</code>function<a class="indexterm" id="id267"/> to rotate the 3D world.</li><li class="listitem">Draw the object (<code class="literal">drawCube()</code>).</li><li class="listitem">Use the <code class="literal">translate()</code>function to translate the scene back.</li></ol></div><p>We <a class="indexterm" id="id268"/>have <a class="indexterm" id="id269"/>to use the <code class="literal">translate()</code> function <a class="indexterm" id="id270"/>to translate the scene back to the location, because each time we call <code class="literal">translate()</code> values are added instead of being replaced. In code it should look similar to the following:</p><div><pre class="programlisting">gl::translate( Vec3f(getWindowWidth()/2,getWindowHeight()/2,0) );
gl::rotate( Vec3f::yAxis()*1 );
gl::drawCube( Vec3f::zero(), Vec3f(100,100,100) );
gl::translate( Vec3f(-getWindowWidth()/2,-getWindowHeight()/2,0) );</pre></div><p>So now we get a smooth rotation of the cube around the y axis. The rotation angle around y axis is increased in each frame by 1 degree as we pass the <code class="literal">Vec3f::yAxis()*1</code> value to the<a class="indexterm" id="id271"/> <code class="literal">rotate()</code> function. Experiment with the rotation values to understand this a bit more.</p><p>What if we want the cube to be in a constant rotated position? We have to remember that the <code class="literal">rotate()</code> function works similar to the translate function. It adds values to the rotation of the scene instead of replacing them. Instead of rotating the object back, we will use the<a class="indexterm" id="id272"/> <code class="literal">pushMatrices()</code> and<a class="indexterm" id="id273"/> <code class="literal">popMatrices()</code> functions.</p><p>Rotation and translation are transformations. Every time you call <code class="literal">translate()</code> or <code class="literal">rotate()</code>, you are modifying the modelview matrix. If something is done, it is sometimes not so easy to undo it. Every time you transform something, changes are being made based on all previous transformations in the current state.</p><p>So what is this state? Each state contains a copy of the current transformation matrices. By calling <code class="literal">pushModelView()</code> we <a class="indexterm" id="id274"/>enter a fresh state by making a copy of the current modelview matrix and storing it into the stack. We will make some crazy transformations now without worrying about how we will undo them. To go back, we call <code class="literal">popModelView()</code> that pops (or deletes) the current modelview matrix from the stack, and returns us to the state with the previous modelview matrix.</p><p>So let's try this out by adding the<a class="indexterm" id="id275"/> following code after the <code class="literal">gl::clear()</code> call:</p><div><pre class="programlisting">gl::pushModelView();
gl::translate( Vec3f(getWindowWidth()/2,getWindowHeight()/2,0) );
gl::rotate( Vec3f(35,20,0) );
gl::drawCube( Vec3f::zero(), Vec3f(100,100,100) );
gl::popModelView();</pre></div><p>Compile <a class="indexterm" id="id276"/>and run our program now, you should see something similar to the following screenshot:</p><div><img alt="Drawing in 3D" src="img/9564_08_04.jpg"/></div><p>As we can see, before <a class="indexterm" id="id277"/>doing anything, we create a copy of the current <a class="indexterm" id="id278"/>state with <code class="literal">pushModelView()</code>. Then we do the same as before, translate our scene to the middle of the screen, rotate it (this time <code class="literal">35</code> degrees around x axis and <code class="literal">20</code> degrees around y axis), and finally draw the cube! To reset the stage to the state it was before, we have to use just one<a class="indexterm" id="id279"/> line of code, <code class="literal">popModelView()</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Understanding nested states</h1></div></div></div><p>It is possible to create nested states by<a class="indexterm" id="id280"/> using the previously discussed functions. By using two <code class="literal">pushModelView()</code> calls in a row, we are storing two different states. By calling one <code class="literal">popModelView()</code> afterwards, we pop just the last pushed modelview matrix.</p><p>Let's change our <code class="literal">draw()</code> method<a class="indexterm" id="id281"/> implementation to the following:</p><div><pre class="programlisting">void Basic3DApp::draw() {
   gl::clear( Color( 0, 0, 0 ) );
   
   // make a copy of the current modelview matrix
   <strong>gl::pushModelView();</strong>
   
   // translate the origin of the world to the center of the screen
   gl::translate( Vec3f(getWindowWidth()/2,getWindowHeight()/2,0) );

   // draw a ring of cubes
   int i; // iterator
   int numCubes = 10; // number of cubes in the ring
   for ( i=0; i &lt; numCubes; i++ )
   {
           // make another copy of the current modelview matrix
           <strong>gl::pushModelView();</strong>
              
          // rotate the world around z axis
          gl::rotate( Vec3f::zAxis() * (360.f / numCubes * i) );
          
          // draw a relatively small cube
          // 200 pixels to the right from the center of the world
          gl::drawCube( Vec3f(200,0,0), Vec3f(25,25,25) );

          // return to the previous state
<strong>          gl::popModelView();</strong>
   }

   // rotate the world around the origin
   gl::rotate( Vec3f(35,20,0) );
   	// draw a bigger cube in the center of the world
   gl::drawCube( Vec3f::zero(), Vec3f(100,100,100) );
   	// return to the initial state
   <strong>gl::popModelView();</strong>
}</pre></div><p>Note the <a class="indexterm" id="id282"/>use of <code class="literal">gl::pushModelView()</code> and <code class="literal">gl::popModelView()</code>. Compile and run the project, you should see a ring of smaller cubes surrounding the one we saw earlier.</p><p>Now try to move the <code class="literal">gl::rotate()</code> call before the <code class="literal">for</code> loop and after the <code class="literal">gl::translate()</code> call. Compile and run the project. You should see a bit of a different image than the one you saw earlier:</p><div><img alt="Understanding nested states" src="img/9564_08_05.jpg"/></div><p>This is a simple<a class="indexterm" id="id283"/> demonstration of nested states. Try to experiment in the way we just did, by adding extra transformations and changing their order. Furthermore, OpenGL is not limited to just two levels of nested states. You could try to add orbiting objects around each of the small squares by adding more <code class="literal">pushModelView()</code> and <code class="literal">popModelView()</code> functions inside another <code class="literal">for</code> loop, for example.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Handling depth sorting</h1></div></div></div><p>Let's take a look at the <a class="indexterm" id="id284"/>3D primitive drawing functions that are built into Cinder. There are not a lot of them but as Cinder is meant to be a bit more low level than other similar tools, you should continue to learn some OpenGL afterwards to get the most out of Cinder and drawing in 3D space.</p><p>Let's start with changing the single colored cube into something more colorful and adding some constant rotation to it as it was before. To do that, we will have to replace the <code class="literal">drawCube()</code> function <a class="indexterm" id="id285"/>call with<a class="indexterm" id="id286"/> <code class="literal">drawColorCube()</code>:</p><div><pre class="programlisting">gl::drawColorCube( Vec3f::zero(), Vec3f(100,100,100) );</pre></div><p>When you run and compile the application, you will see that the cube is drawn somehow strange. This is the effect of inappropriate depth sorting. A 3D model consists of vertices that are placed at different depths in the current projection. These vertices form faces that also have different depth information that is taken into account when transforming them into pixels at different depths. If these vertices are not sorted and drawn in appropriate order according to their depth information, we get an image where the faces and objects behind in the back of the scene are drawn in front and the opposite. To avoid this, we have to enable the depth read feature of the OpenGL. Add <a class="indexterm" id="id287"/>these lines of code in the <code class="literal">setup()</code> method implementation:</p><div><pre class="programlisting">gl::enableDepthRead();</pre></div><p>After you compile and run the project, the cube should look just fine:</p><div><img alt="Handling depth sorting" src="img/9564_08_06.jpg"/></div><p>With that done, let's add some rotation animation. To do this we will need to declare some variables that will take care of storing the rotation variables. Then we will need to assign initial values to them in the<a class="indexterm" id="id288"/> <code class="literal">setup()</code> method, change them in the<a class="indexterm" id="id289"/> <code class="literal">update()</code> method, and finally draw in the <code class="literal">draw()</code> method implementation. Let's start with declaring the variables. Add these lines just after the <code class="literal">setup()</code>, <code class="literal">update()</code>, and <code class="literal">draw()</code> method<a class="indexterm" id="id290"/> declarations:</p><div><pre class="programlisting">Vec3f currentRotation;
Vec3f rotationIncrement;</pre></div><p>Instead of using one <code class="literal">float</code> variable for the current and increment rotation angle around each axis we are using the <code class="literal">Vec3f</code> datatype to be able to store the rotation values in one variable.</p><p>We have to assign the initial values to these variables now. Go to the <code class="literal">setup()</code> method implementation and add the following lines:</p><div><pre class="programlisting">currentRotation = Vec3f( 0, 0, 0 );
rotationIncrement = Vec3f( 1.1f, 1.2f, 1.3f );</pre></div><p>With that done, go to the <code class="literal">update()</code> method implementation and add the following line:</p><div><pre class="programlisting">currentRotation += rotationIncrement;</pre></div><p>This will increment the rotation around all the three axis on each frame.</p><p>Finally we have to<a class="indexterm" id="id291"/> make use of the <code class="literal">currentRotation</code> variable while drawing. Change the parameter of the <code class="literal">gl::rotate()</code> function before the <code class="literal">gl::drawColorCube()</code> call to <code class="literal">currentRotation</code> as follows:</p><div><pre class="programlisting">…
// rotate the world around the origin
gl::rotate( <strong>currentRotation</strong> );

// draw a bigger cube in the center
gl::drawColorCube( Vec3f::zero(), Vec3f(100,100,100) );</pre></div><p>Now the rotation values will be increased and updated on each frame. Compile and run the project to see for yourself! You should get a nice rotation animation. Try to do the same with the location and size of the cube for better understanding of how this works.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Exploring other Cinder 3D primitives</h1></div></div></div><p>Now let's try out the different<a class="indexterm" id="id292"/> 3D primitives that Cinder supplies it's own functions for. We just tried to draw a different kind of cube, so let's continue with something equally classic, a sphere. Replace the <code class="literal">gl::drawColorCube()</code> function<a class="indexterm" id="id293"/> call with the following line:</p><div><pre class="programlisting">gl::drawSphere( Vec3f::zero(), 100 );</pre></div><p>The first parameter of this function defines the center of the sphere and the second defines the radius. There is a third (optional) parameter <code class="literal">int</code> that controls the number of segments the sphere is made of. The default value is 12, but you might want to change it to a higher value to increase the smoothness of the sphere.</p><p>Compile and run the project. You should see an image similar to the following screenshot:</p><div><img alt="Exploring other Cinder 3D primitives" src="img/9564_08_07.jpg"/></div><p>The problem <a class="indexterm" id="id294"/>here is that it does not look quite 3D. As you might have already guessed, the problem is that there is no light. To add light to the scene, add the following lines in the <code class="literal">setup()</code> method<a class="indexterm" id="id295"/> implementation:</p><div><pre class="programlisting">glEnable( GL_LIGHTING );
glEnable( GL_LIGHT0 );</pre></div><p>These are OpenGL functions that are responsible for turning the light on. The first one enables light as such, the second is turning on the first light or <code class="literal">GL_LIGHT0</code>. There are ways of positioning and changing it's parameters, but we won't dig into this as it is outside the scope of this book.</p><p>Compile and run the project to see the sphere with lights turned on. You should get a result that is similar to the following screenshot:</p><div><img alt="Exploring other Cinder 3D primitives" src="img/9564_08_08.jpg"/></div><p>Let's try to <a class="indexterm" id="id296"/>draw something else instead of a sphere. How about a cylinder? Replace the <code class="literal">drawSphere()</code> function<a class="indexterm" id="id297"/> call with the following line:</p><div><pre class="programlisting">gl::drawCylinder(50, 50, 100);</pre></div><p>This will draw an open-ended cylinder on the screen. The first parameter defines the width of the cylinder base, the second parameter defines the width of the cylinder top. The third parameter defines the cylinder height.</p><p>After we compile and run the application, you will notice that the cylinder is not rotating around it's center like the cube or sphere we drew before. That is because of the way it is drawn – from the bottom up instead of both – up and down. To change that, we can draw another cylinder, with a negative height or change the <code class="literal">translate()</code> values. For the sake of simplicity, let's draw another cylinder. Replace the cylinder drawing code to this:</p><div><pre class="programlisting">gl::drawCylinder(50, 50, 50);
gl::drawCylinder(50, 50, -50);</pre></div><p>We can see the same cylinder but now it rotates around its center. Another thing that we might want to add are the closed ends of the cylinder. We have to use 2D shapes again to accomplish this task. Add the following lines of code directly after the <code class="literal">drawCylinder()</code> function<a class="indexterm" id="id298"/> calls:</p><div><pre class="programlisting">gl::rotate( Vec3f(-90,0,0) );
gl::translate( Vec3f(0,0,50) );
gl::drawSolidCircle(Vec2f(0,0), 50, 12);
gl::translate( Vec3f(0,0,-50) );
gl::rotate( Vec3f(180,0,0) );
gl::translate( Vec3f(0,0,50) );</pre></div><p>gl::drawSolidCircle(Vec2f(0,0), 50, 12); Not too easy, right? There <a class="indexterm" id="id299"/>is no <code class="literal">drawSolidCircle()</code> function<a class="indexterm" id="id300"/> that would draw a circle based on 3D coordinates yet, but this is a kind of shorthand anyway so we don't have to write pure OpenGL. What these lines of code do is that they move the scene or canvas in appropriate position and rotation relative to the already drawn cylinder to draw the top and the bottom of it.</p><p>Let's change the code a bit, so we see another thing that is possible with the <code class="literal">drawCylinder()</code> function<a class="indexterm" id="id301"/> that is drawing a cone or even a pyramid:</p><div><pre class="programlisting">gl::drawCylinder(50, <strong>0</strong>, 50, <strong>4</strong>);
gl::drawCylinder(50, <strong>0</strong>, -50, <strong>4</strong>);</pre></div><p>Delete or comment out the <code class="literal">drawSolidCircle()</code> part and change the top values of the <code class="literal">drawCylinder()</code> functions to <code class="literal">0</code> and add a fourth value (and set it to <code class="literal">4</code> or more if you want to draw a cone) that represents the slice count of the cylinder.</p><p>After compiling and running the application, a pyramid is not quite what we see. Let's call it a diamond to describe the shape more correctly. In the following screenshot you can see an image strip with the <code class="literal">gl::drawCylinder()</code> adjustments we just did:</p><div><img alt="Exploring other Cinder 3D primitives" src="img/9564_08_09.jpg"/></div><p>Another basic shape worth introducing is the torus. Cinder has a built-in function for drawing this and this is how the function looks:</p><div><pre class="programlisting">gl::drawTorus(100, 20);</pre></div><p>Add the preceding line of code after the cylinder drawing function calls. The first parameter defines the outer radius (the circle responsible for the base shape of the torus), the second defines the inner radius or the radius if the circle that is used for creating the volume of the torus.</p><p>To make things look even more straightedged, let's add the third and fourth parameter that are responsible for the longitude and latitude segment count of the torus:</p><div><pre class="programlisting">gl::drawTorus(100, 20, <strong>8</strong>, <strong>8</strong>);</pre></div><p>If we compile and run <a class="indexterm" id="id302"/>the application now, we should see an image similar to one of these:</p><div><img alt="Exploring other Cinder 3D primitives" src="img/9564_08_10.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Summary</h1></div></div></div><p>To sum up, in this chapter we introduced ourselves with the very basic 3D stuff that can be done with Cinder. We understood a bit about the concept of 3D space as well as how to draw and animate objects in this space. We learned to switch on the lightning and construct more complex shapes out of primitives.</p><p>There is more, but to get the real graphics power out of Cinder, you have to learn some more of OpenGL and the <strong>OpenGL Shading Language</strong> (<strong>GLSL</strong>).</p><p>In the next chapter, we will talk less about graphics but more about what is possible with Cinder in terms of audio.</p></div></body></html>