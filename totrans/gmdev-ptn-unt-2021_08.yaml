- en: Managing Game Events with the Event Bus
  prefs: []
  type: TYPE_NORMAL
- en: The Event Bus acts as a central hub that manages a specific list of global events
    that objects can choose to subscribe to or publish. It's the most straightforward
    pattern related to event managing that I have in my toolbox. It reduces the process
    of assigning the role of subscriber or publisher to an object into a single line
    of code. As you can imagine, this can be beneficial when you need results quickly.
    But like most simple solutions, it has some drawbacks and limitations, which we
    will explore further on.
  prefs: []
  type: TYPE_NORMAL
- en: In the code example presented in this chapter, we will use the Event Bus to
    broadcast specific race events to components that need to listen for changes in
    the overall state of the race. But it's essential to keep in mind; I'm proposing
    using the Event Bus as a solution for managing global race events because of its
    simplicity and not its scalability. So it might not be the best solution in all
    cases, but it is one of the most straightforward patterns to implement, as we
    will see in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Event Bus pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of a Race Event Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter includes simplified skeleton code examples for the sake of brevity
    and clarity. If you wish to review a complete implementation of the pattern in
    the context of an actual game project, open the `FPP` folder in the GitHub project.
    You can find the link under the *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will also be using the following specific Unity engine API features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Static`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnityEvents`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnityActions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with these concepts, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml), *A
    Short Primer to Programming in Unity*.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter06](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/2U7wrCM](https://bit.ly/2U7wrCM).'
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself having problems understanding the mechanism behind delegates,
    keep in mind that they are similar to function pointers in C/C++. In simple terms,
    a delegate points to a method. And delegates are often used to implement event
    handlers and callbacks. An action is a type of delegate that you can use with
    a method that has a void return type.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Event Bus pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an event is raised by an object (publisher), it sends out a signal that
    other objects (subscribers) can receive. The signal is in the form of a notification
    that can indicate the occurrence of an action. In an event system, an object broadcasts
    an event. Only those objects that subscribe to it will be notified and choose
    how to handle it. So, we can imagine it as having a sudden burst of a radio signal
    that only those with antennas tuned to a specific frequency can detect.
  prefs: []
  type: TYPE_NORMAL
- en: The Event Bus pattern is a close cousin of the Messaging system and Publish-Subscribe
    patterns, the latter being the more accurate name for what the Event Bus does.
    The keyword in the title of this pattern is the term *bus*. In simple computing
    terms, a bus is a connection between components. In the context of this chapter,
    the components will be objects that can be publishers or listeners of events.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the Event Bus is a way to connect objects through events by using a publish-subscribe
    model. It's possible to accomplish a similar model with a pattern such as the
    Observer and native C# events. However, those alternatives have some drawbacks.
    For example, in a typical implementation of the Observer pattern, a tight coupling
    might occur, as observers (listeners) and subjects (publishers) might become dependent
    and aware of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the Event Bus, at least in the way we will implement it in Unity, abstracts
    and simplifies the relations between publishers and subscribers, so they are entirely
    unaware of one another. Another advantage is that it reduces the process of assigning
    the role of publisher or subscriber to a single line of code. Therefore, the Event
    Bus is a valuable pattern to learn and have in your back pocket. As you can see
    in the following diagram, it does act as a middleman between publishers and subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/272dfd72-4bd9-4a96-a736-c192239f3c9a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Diagram of the Event Bus pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the diagram, there are three main ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Publishers**: These objects can publish specific types of events declared
    by the Event Bus to subscribers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Bus**: This object is responsible for coordinating the transmission
    of events between publishers and subscribers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscribers**: These objects register themselves as subscribers of specific
    events through the Event Bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and drawbacks of the Event Bus pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **benefits** of the Event Bus pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoupling**: The main benefit of using an event system is that it decouples
    your objects. Objects can communicate through events instead of directly referencing
    each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: The Event Bus offers simplicity by abstracting the mechanism
    of publishing or subscribing to an event from its clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **drawbacks** of the Event Bus pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: Under the hood of any event system, there''s a low-level mechanism
    that manages messaging between objects. And so there might be a slight performance
    cost when using an event system, but depending on your target platform, it could
    be minuscule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global**: In this chapter, we implement the Event Bus with static methods
    and properties to make it easier to access from anywhere in our code. There is
    always a risk when using globally accessible variables and states as they can
    make debugging and unit testing more difficult. However, this is a very contextual
    drawback and not an absolute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UnityEvents can actually accept up to four generic-type arguments. This can
    make it possible to pass event-specific data to subscribers. Review the following
    Unity API documentation section for more details: [https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Events.UnityEvent.html](https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Events.UnityEvent.html)[.](https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html)
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Event Bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I have used the Event Bus in the past for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rapid prototyping**: I use the Event Bus pattern often when rapidly prototyping
    new game mechanics or features. With this pattern, I can easily have components
    that trigger each other''s behaviors with events while keeping them decoupled.
    This pattern permits us to add and remove objects as subscribers or publishers
    with a single line of code, which is always helpful when you want to prototype
    something quickly and easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production code**: I use the Event Bus in production code if I can''t find
    a justifiable reason to implement a more sophisticated approach to managing game
    events. It''s a pattern that does the job well if you don''t need to handle complex
    event types or structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I would avoid using a globally accessible Event Bus like the one presented in
    this chapter to manage events that don't have a "global scope." For instance,
    if I have a UI component in the HUD that displays a damage alert when the player
    collides with an obstacle, it would be inefficient to publish a collision event
    through the Event Bus as it's a localized interaction between the bike and an
    object on the track. Instead, I would use something like an Observer pattern because,
    in that scenario, I only need one UI component to observe a specific change in
    the state of an object, in this case, the bike. As a rule of thumb, every time
    you have to implement a system that uses events, go through the list of known
    patterns, choose one suitable for your use case, but don't always fall back to
    the easiest one, which, in my opinion, is the Event Bus.
  prefs: []
  type: TYPE_NORMAL
- en: Managing global race events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project we are working on is a racing game, and most races are structured
    in stages. The following is a shortlist of typical racing stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Countdown**: At this stage, the bike is stopped behind the start line while
    a countdown timer is running down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Race start**: Once the clock hits zero, the green light signal is turned
    on, and the bike moves forward on the track.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Race finish**: The moment the player crosses the finish line, the race is
    over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In between the start and finish of the race, certain events can be triggered
    that could change the current state of the race:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Race pause**: The player could pause the game while still racing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Race quit**: The player could quit the race at any time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Race stop**: The race could stop suddenly if the player is involved in a
    fatal crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So we want to broadcast a notification that signals the occurrence of each stage
    of the race and any other important event in between that will change the overall
    state of the race. This approach will permit us to trigger specific behaviors
    of components that need to behave in certain ways depending on the current context
    of the race.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are some components that will get updated depending on a
    specific state of the race:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HUD**: The race status indicator will change depending on the context of
    the race **HUD** (**heads-up display**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RaceTimer**: The race timer will only start at the start of the race and
    stops when the player crosses the finish line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BikeController**: The bike controller releases the brakes of the bike once
    the race starts. This mechanism prevents the player from launching onto the track
    before the green light.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InputRecorder**: At the start of the race, the input replay system will start
    recording the player''s inputs so that they can be replayed later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these components have specific behaviors that have to be triggered at particular
    stages of the race. So we will use the Event Bus to implement these global race
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Race Event Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement the Race Event Bus in two easy steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to expose the specific race event types that we support,
    which we will do with the following enum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that the preceding enum values represent specific events
    outlining the stages of a race, from start to finish. So we are restricting ourselves
    to handling events with just a global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part is the core component of the pattern, the actual game event bus
    class, which we will call `RaceEventBus`, to be more domain-specific in the naming
    convention of our classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The key ingredient of our class is the `Events` dictionary. This acts as a ledger
    in which we maintain a list of relations between event types and subscribers.
    By keeping it `private` and `readonly`, we are ensuring that it can't be overwritten
    by another object directly.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a client must call the `Subscribe()` public static method to add
    itself as a subscriber of a specific event type. The `Subscribe()` method takes
    two parameters; the first is the race event type, and the second one is the callback
    function. Because `UnityAction` is a delegate type, it provides us with a way
    to pass a method as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, when a client object calls the `Publish()` method, the registered callback
    methods of all the subscribers of a specific race event type will get called at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The `Unsubscribe()` method is self-explanatory as it permits objects to remove
    themselves as subscribers of a specific event type. Thus, their callback methods
    will not be called by the Event Bus when an object publishes an event.
  prefs: []
  type: TYPE_NORMAL
- en: If this still looks abstract, it will be made clear as we implement client classes
    in the next section and see how we can use the Event Bus to trigger behaviors
    of objects at specific moments in the proper sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Race Event Bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the core elements of the pattern in place, we can write some
    code to test our `RaceEventBus` class. For reasons of brevity, I have removed
    all the behavior code in each client class to focus on the use of the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For starters, we are going to write a countdown timer that subscribes to the
    `COUNTDOWN` race event type. Once the `COUNTDOWN` event is published, it will
    trigger a 3-second countdown to the start of the race. And at the exact moment
    the count reaches its end, it will publish the `START` event to signal the beginning
    of the race:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The most significant lines of code in the preceding class are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every time the `CountdownTimer` object is enabled, the `Subscribe()` method
    is called. And when the opposite happens, and it gets disabled, it unsubscribes
    itself. We are doing this to ensure that the object is listening to an event when
    it's active or doesn't get called by `RaceEventBus` when disabled or destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: The `Subscribe()` method takes two arguments – the event type, and a callback
    function. This means that the `StartTimer()` method of `CountdownTimer` will be
    called by `RaceEventBus` every time the `COUNTDOWN` event is published.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we will implement a skeleton of the `BikeController` class to test
    out the `START` and `STOP` events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, we are going to write an `HUDController` class. This doesn''t do
    much except display a button to stop the race once it starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the sequence of events, we need to attach the following client class
    to a GameObject in an empty Unity scene. With this, we will be able to trigger
    the countdown timer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example might seem overly simplified, but its purpose is to showcase
    how we can trigger individual object behaviors in a specific sequence with events
    while keeping them decoupled. None of the objects communicate with one another
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Their only common point of reference is `RaceEventBus`. Therefore, we could
    easily add more subscribers and publishers; for instance, we could have a `TrackController`
    object listen for the `RESTART` event to know when to reset the race track. And
    thus, we can now sequence the triggering of behaviors of core components with
    events, each presenting a particular stage of the race.
  prefs: []
  type: TYPE_NORMAL
- en: Action is a delegate that points to a method that accepts one or more arguments
    but returns no value. For instance, you should use Action when your delegate points
    to a method that returns void. UnityAction behaves like Actions in native C#,
    except UnityActions was designed to be used with UnityEvents.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Event Bus implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using the Event Bus, we can trigger behaviors while keeping core components
    decoupled. It's straightforward for us to add or remove objects as subscribers
    or publishers. We also defined a specific list of global events that represent
    every stage of a race. Therefore, we can now start sequencing and triggering behaviors
    of core components, from the start to the end of a race, and anything in between.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review some alternative solutions to the Event
    Bus, with each solution offering a different approach that might be a better solution
    depending on context.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing some alternative solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Event systems and patterns are a vast topic, and it''s a subject matter we
    can''t cover in depth in this book. Therefore, we have prepared a shortlist of
    patterns to consider when implementing an event system or mechanism, but keep
    in mind that there''s a lot more out there, and we encourage you as a reader to
    continue exploring the topic beyond the limited scope of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observer**: An oldie but goodie pattern in which an object (subject) maintains
    a list of objects (observers) and notifies them of an internal state change. It''s
    a pattern to consider when you need to establish a one-to-many relationship between
    a group of entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Queue**: This pattern permits us to store events generated by publishers
    in a queue and forward them to their subscribers at a convenient time. This approach
    decouples the temporal relationship between publishers and subscribers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ScriptableObjects**: It''s possible to create an event system with ScriptableObjects
    in Unity. The key benefit of this approach is that it makes it easier to author
    new custom game events. If you need to build a scalable and customizable event
    system, this might be the way to go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are asking yourself why we are not showcasing more advanced event systems
    in this book, including those implemented with ScriptableObjects, the answer is
    that the core intent of this book is to introduce readers to design patterns,
    not overwhelm them with complexity. We offer a first-step introduction to core
    concepts, but encourage readers to seek more advanced material as they progress.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the Event Bus, a simple pattern that simplifies
    the process of publishing and subscribing to events in Unity. It's a tool that
    helps during rapid prototyping or when you have a defined list of global events
    to manage. However, it has its limits of use, and it's always wise to explore
    other options before committing to using a globally accessible event bus.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will implement a system that will allow us to replay
    player inputs. Many racing games have replay and rewind features, and with the
    Command pattern, we will attempt to build one from scratch.
  prefs: []
  type: TYPE_NORMAL
