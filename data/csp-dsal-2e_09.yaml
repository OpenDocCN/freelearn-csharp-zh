- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: See in Action
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看看实际应用
- en: As you already know, algorithms are almost everywhere, and there are many types
    and classifications. They are supported by numerous data structures and some of
    them you learned while reading the previous chapters. After some theoretical parts,
    it is high time to keep on practicing, based on interesting examples. They are
    chosen from various types of algorithms, summarizing many subjects that you have
    got to know.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，算法几乎无处不在，并且有众多类型和分类。它们由众多数据结构支持，其中一些你在阅读前几章时已经学过。在理论部分之后，现在是时候基于有趣的例子继续实践了。这些例子来自各种类型的算法，总结了你已经了解的许多主题。
- en: First, you will see how to calculate a given number from the **Fibonacci series**
    in a few variants that differ significantly in performance results, so you will
    get to know how you can optimize your code. Sometimes, even small changes can
    lead to huge performance improvements. Then, you will learn how to apply the greedy
    approach to solve the **minimum coin change** problem, as well as how to benefit
    from the divide-and-conquer algorithm to find the **closest pair of points** located
    on the two-dimensional surface. You will also see a beautiful **fractal** and
    the code that designs such graphics. The following examples will be related to
    applications of back-tracking with recursion to solve puzzles, namely **rat in
    a maze** and **Sudoku**. Coming closer to the end of the chapter, you will see
    how to apply a genetic algorithm to **guess a title** of this book, based on the
    rules of Darwinian theory of evolution and natural selection. The last example
    will be a brute-force algorithm for **guessing a** **secret password**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将看到如何通过几种在性能结果上有显著差异的变体来计算斐波那契数列中的给定数，这样你将了解如何优化你的代码。有时，即使是微小的变化也能带来巨大的性能提升。然后，你将学习如何应用贪婪算法来解决**最小硬币找零**问题，以及如何利用分而治之算法来找到位于二维表面上的**最近点对**。你还将看到一个美丽的**分形**以及设计此类图形的代码。以下例子将涉及使用递归回溯法解决谜题的应用，即**迷宫中的老鼠**和**数独**。随着章节接近尾声，你将看到如何根据达尔文的进化论和自然选择规则，应用遗传算法来**猜测这本书的标题**。最后一个例子将是用于**猜测****密码**的暴力算法。
- en: As you can see, there are a lot of interesting examples just ahead of you, so
    be ready to write quite a lot of code and solve these tasks together. Let’s start!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前方有许多有趣的例子，所以准备好写很多代码并一起解决这些任务吧！让我们开始！
- en: 'In this chapter, you will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将涵盖以下主题：
- en: The Fibonacci series
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斐波那契数列
- en: Minimum coin change
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小硬币找零
- en: The closest pair of points
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近点对
- en: Fractal generation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分形生成
- en: Rat in a maze
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迷宫中的老鼠
- en: A Sudoku puzzle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数独谜题
- en: A title guess
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题猜测
- en: A password guess
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码猜测
- en: The Fibonacci series
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斐波那契数列
- en: 'As the first example, let’s take a look at calculating a given number from
    the **Fibonacci series**, using the following **recursive** function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，让我们看看如何使用以下**递归**函数计算斐波那契数列中的给定数：
- en: '![Figure 9.1 – A formula for calculating a number from the Fibonacci series](img/B18069_09_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 计算斐波那契数列中一个数的公式](img/B18069_09_1.jpg)'
- en: Figure 9.1 – A formula for calculating a number from the Fibonacci series
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 计算斐波那契数列中一个数的公式
- en: 'Its interpretation is very simple:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其解释非常简单：
- en: '*F(0)* is equal to 0'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F(0)* 等于 0'
- en: '*F(1)* is equal to 1'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F(1)* 等于 1'
- en: '*F(n)* is a sum of *F(n-1)* and *F(n-2)*, which means that this number is a
    sum of the two preceding ones'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F(n)* 是 *F(n-1)* 和 *F(n-2)* 的和，这意味着这个数是前两个数的和'
- en: As an example, *F(2)* is equal to the sum of *F(0)* and *F(1)*. Thus, it is
    equal to 1, while *F(3)* is equal to 2\. It is worth mentioning that there are
    two base cases, namely for *n* equal to 0 and 1\. For both of them, there is a
    specific value defined, namely 0 and 1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*F(2)* 等于 *F(0)* 和 *F(1)* 的和。因此，它等于1，而 *F(3)* 等于2。值得注意的是，有两个基本案例，即当 *n* 等于0和1时。对于这两个，都有一个特定的值定义，即0和1。
- en: 'The **recursive** implementation in the C# language is shown as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言中的**递归**实现如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you see, the `Fibonacci` method calls itself twice with different values
    of parameters, namely smaller by 1 and 2 than the `n` parameter passed to the
    method. If you call the method passing `25,` you will receive 75025 as a result,
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Fibonacci`方法以不同的参数值调用自身两次，即比传递给方法的`n`参数小1和2。如果你传递`25`给这个方法，你将得到75025作为结果，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Keep in mind that the presented recursive version for calculating a value of
    the Fibonacci function is very inefficient and will be very slow for larger input
    numbers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所提供的斐波那契函数值的递归版本非常低效，对于较大的输入数字将会非常慢。
- en: 'You can significantly improve its performance using **dynamic programming**,
    either with top-down or bottom-up approaches. First, let’s use the **top-down
    approach** with **memoization** to **cache the calculated results** for subproblems:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**动态规划**来显著提高其性能，无论是自顶向下还是自底向上的方法。首先，让我们使用带有**记忆化**的**自顶向下方法**来**缓存子问题的计算结果**：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You use the `Dictionary` class as a cache, where keys are values of `n` passed
    to the `Fibonacci` method and values are the calculated results, namely `Fibonacci(n)`.
    Within the method, you add the check on whether the cache contains a key equal
    to `n`. If so, you do not perform further operations and simply return the value
    from the cache. If the cache does not have such a key yet, you use the same approach
    as in the case of the recursive version and add the calculated result to the cache
    just before returning the result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用`Dictionary`类作为缓存，其中键是传递给`Fibonacci`方法的`n`的值，值是计算结果，即`Fibonacci(n)`。在方法内部，您检查缓存是否包含等于`n`的键。如果是这样，您就不执行进一步的操作，而是简单地从缓存中返回值。如果缓存还没有这样的键，您就使用与递归版本相同的方法，并在返回结果之前将计算结果添加到缓存中。
- en: Is it worth introducing such changes? Let’s see some numbers regarding execution
    time for the 50th number from the Fibonacci series. In the basic recursive version,
    it took more than 88 seconds on my machine. Introducing the top-down approach
    caused the same result received in... less than 1 millisecond. This solution is
    almost 100,000 times faster!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 引入这样的改变值得吗？让我们看看关于斐波那契数列第50个数的执行时间的几个数字。在基本的递归版本中，在我的机器上需要超过88秒。引入自顶向下方法导致的结果与...不到1毫秒的结果相同。这个解决方案几乎快了100,000倍！
- en: 'Now you know that dynamic programming can make a huge difference, let’s take
    a look at the **bottom-up approach** for the Fibonacci number calculation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道动态规划可以带来巨大的差异，让我们看看斐波那契数计算的**自底向上方法**：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, a bigger modification is introduced because you replace recursion with
    iteration. However, the code is very simple, as it consists of only one `for`
    loop that iterates from 2 until the given number and calculates the sum of the
    two preceding values. Of course, there are separate `if` conditions for the 0
    and 1 values of the `n` parameter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，引入了更大的修改，因为您用迭代代替了递归。然而，代码非常简单，因为它只包含一个从2迭代到给定数字的`for`循环，并计算前两个值的和。当然，对于`n`参数的0和1值，有单独的`if`条件。
- en: And what about the performance in this case? Let’s compare calculating the 5,000th
    number from the Fibonacci series using both the top-down and bottom-down approaches.
    The top-down approach requires about 2 milliseconds, while the bottom-up still
    takes less than 1 millisecond on my laptop. Keep in mind that we are now talking
    about the 5,000th number from the Fibonacci series, and previously, the tests
    were made for only the 50th number. Incredible performance boost, isn’t it?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在这种情况下性能如何？让我们比较使用自顶向下和自底向上方法计算斐波那契数列的第5,000个数。自顶向下方法大约需要2毫秒，而自底向上在我的笔记本电脑上仍然不到1毫秒。记住，我们现在讨论的是斐波那契数列的第5,000个数，而之前的测试只是针对第50个数。性能提升令人难以置信，不是吗？
- en: Results can differ
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能会有所不同
- en: The performance results are obtained on my computer and are calculated in a
    very simple way, even without repeating them several times. Of course, such results
    can be different in other circumstances, such as while using your machine. However,
    it is crucial to present some trend, not a precise result in milliseconds. This
    performance testing aims to show you a huge difference between a basic recursive
    version and any of the optimized versions with dynamic programming.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 性能结果是在我的电脑上获得的，并且以非常简单的方式计算，甚至不需要重复多次。当然，在其他情况下，例如在使用您的机器时，这些结果可能会有所不同。然而，展示一些趋势，而不是精确的毫秒级结果至关重要。这种性能测试旨在向您展示基本递归版本和任何具有动态规划的优化版本之间的巨大差异。
- en: After the first example, let’s proceed to solving the minimum coin change problem.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子之后，让我们继续解决最小硬币兑换问题。
- en: Minimum coin change
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小硬币兑换
- en: The second example shown in this chapter presents a **greedy algorithm** to
    solve the **minimum coin change** problem, for finding the minimum number of coins
    to receive the amount specified as the input.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的第二个例子是一个 **贪婪算法**，用于解决 **最小硬币找零** 问题，即找到获取指定输入金额所需的最少硬币数量。
- en: "![Figure 9.2 – \uFEFFIllustration of denominations in the case of the euro\
    \ currency](img/B18069_09_2.jpg)"
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 欧元货币面额的示意图](img/B18069_09_2.jpg)'
- en: Figure 9.2 – Illustration of denominations in the case of the euro currency
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 欧元货币面额的示意图
- en: For example, for the coin system consisting of 1, 2, 5, 10, 20, 50, 100, 200,
    and 500 denominations, if you want to get a value of 158, you need to pick 5 coins,
    namely 100, 50, 5, 2, and 1\. The greedy approach is very simple because you just
    **pick the largest possible denomination not greater than the remaining amount**.
    You perform this operation until the remaining amount is equal to 0\. As you see,
    the algorithm does not care about the overall solution and tries to choose the
    best solution at each step.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于由1、2、5、10、20、50、100、200和500面额组成的硬币系统，如果你想获取158的金额，你需要选择5枚硬币，即100、50、5、2和1。贪婪算法非常简单，因为你只需
    **选择不大于剩余金额的最大面额**。你执行此操作，直到剩余金额等于0。正如你所见，该算法不考虑整体解决方案，而是试图在每一步选择最佳解决方案。
- en: 'The C#-based implementation is shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了基于C#的实现：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The most important role is performed by the `GetCoins` method, which takes one
    input, namely the amount to get. It returns a list of chosen coins. For example,
    if you call this method passing 158, you will see 100, 50, 5, 2, and 1 in the
    console.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是 `GetCoins` 方法所扮演的角色，它接受一个输入，即要获取的金额。它返回所选硬币的列表。例如，如果你调用此方法并传入158，你将在控制台看到100、50、5、2和1。
- en: That’s a quick example! Now, let’s proceed to something a bit more complex.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速示例！现在，让我们继续探讨一些更复杂的内容。
- en: Closest pair of points
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最近点对
- en: Another example is an algorithm to **find the closest pair of points** located
    on the two-dimensional surface. It is an interesting algorithmic problem that
    can be solved using the **divide-and-conquer** paradigm.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是寻找位于二维表面上的 **最近点对** 的算法。这是一个有趣的算法问题，可以使用 **分而治之** 的范式来解决。
- en: 'Each point is represented by *x* and *y* coordinates, with values starting
    from (**0**, **0**) in the top-left corner of the surface. To find the closest
    pair of points, you first sort all points according to the *x* coordinate, as
    shown in the following diagrams, marked from **A** to **N**:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个点由 *x* 和 *y* 坐标表示，值从表面的左上角（**0**, **0**）开始。为了找到最近的点对，你首先根据 *x* 坐标对所有点进行排序，如下面的图所示，标记为
    **A** 到 **N**：
- en: '![Figure 9.3 – Diagrams of the algorithm to find the closest pair of points](img/B18069_09_3.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 寻找最近点对算法的示意图](img/B18069_09_3.jpg)'
- en: Figure 9.3 – Diagrams of the algorithm to find the closest pair of points
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 寻找最近点对算法的示意图
- en: Then, you divide the surface into two halves. You can do this by calculating
    half of the points count, namely 7 in our example, and taking the first 7 points
    as the left half and the next 7 points as the right half.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将表面分成两半。你可以通过计算点数的一半来实现这一点，在我们的例子中是7，然后取前7个点作为左半部分，接下来的7个点作为右半部分。
- en: Here is a task for **recursion**, so you recursively find the closest points
    in both halves and store data as *r*l (points **D** and **E**) and *r*r (points
    **I** and **K**). You choose the closer pair by comparing such distances and store
    the result as *r*, namely points **D** and **E** in our case.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于 **递归** 的任务，所以你递归地找到两半中的最近点，并将数据存储为 *r*l（点 **D** 和 **E**）和 *r*r（点 **I**
    和 **K**）。你通过比较这些距离来选择较近的点对，并将结果存储为 *r*，即在我们的例子中是点 **D** 和 **E**。
- en: That’s not all – you also need to check the distance between points from the
    left and the right half, as presented in the preceding diagram, on the right.
    To do so, you get an array with data of all points that are closer to the middle
    point (in respect to the *x* coordinate only) than the *r* distance of the already
    found pair of points (**D** and **E** in our example). Then, you find the closest
    pair of points in this array (**G** and **H** in the example). Let’s name the
    result *s*. To complete the task, choose which pair, from *r* (**D** and **E**)
    and *s* (**G** and **H**), is closer. Then, just return the result (**D** and
    **E** in our case).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那不是全部——你还需要检查左半部分和右半部分点之间的距离，如图所示，在右侧。为此，你得到一个包含所有点的数据的数组，这些点相对于中间点（仅就x坐标而言）比已找到的点对（**D**和**E**在我们的例子中）的*r*距离更近。然后，你在这个数组中找到最近的点对（例子中的**G**和**H**）。让我们称这个结果为*s*。为了完成任务，选择*r*（**D**和**E**）和*s*（**G**和**H**）中哪个更近。然后，只需返回结果（在我们的情况下是**D**和**E**）。
- en: 'The most important part of the code is shown as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码最重要的部分如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, there is the base condition that terminates execution when the array
    of points is empty or contains only one element. Then, you check whether the number
    of points in the array is less than or equal to 3\. If so, you choose the closest
    pair of points in the collection just by checking all possible variants. Otherwise,
    you choose an index of the middle point and call the method recursively for the
    left and right halves. Then, you get points from both halves that are close enough
    to the middle point, taking only *x* coordinates into account. Next, you calculate
    the distance between all points in the `strip` array to get the closest pair from
    it. Finally, you just return the closer pair of points.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个基本条件，当点数组为空或只包含一个元素时终止执行。然后，你检查数组中点的数量是否小于或等于3。如果是这样，你只需通过检查所有可能的变体来选择集合中的最近点对。否则，你选择中间点的索引，并递归地对左右两半部分调用该方法。然后，你从两半部分获取足够接近中间点的点，只考虑*x*坐标。接下来，你计算`strip`数组中所有点之间的距离，以从其中获取最近的点对。最后，你只需返回最近的点对。
- en: 'As you see, the main part of the algorithm is pretty simple to implement and
    understand. So, let’s talk about the rest, starting with the `Point` definition:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，算法的主要部分实现和理解都非常简单。那么，让我们谈谈其余的部分，从`Point`定义开始：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Result` record is presented here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`记录如下所示：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Result Closest(Point[] points)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Result Closest(Point[] points)
- en: '{'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Result result = new(points[0], points[0], double.MaxValue);
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Result result = new(points[0], points[0], double.MaxValue);
- en: for (int i = 0; i < points.Length; i++)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < points.Length; i++)
- en: '{'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int j = i + 1; j < points.Length; j++)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: for (int j = i + 1; j < points.Length; j++)
- en: '{'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: double distance = points[i].GetDistanceTo(points[j]);
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: double distance = points[i].GetDistanceTo(points[j]);
- en: if (distance < result.Distance)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: if (distance < result.Distance)
- en: '{'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: result = new(points[i], points[j], distance);
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: result = new(points[i], points[j], distance);
- en: '}'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return result;
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: return result;
- en: '}'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Result Closer(Result r1, Result r2) =>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Result Closer(Result r1, Result r2) =>
- en: 'r1.Distance < r2.Distance ? r1 : r2;'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'r1.Distance < r2.Distance ? r1 : r2;'
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: List<Point> points =
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: List<Point> points =
- en: '['
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: new Point(6, 45),   // A
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(6, 45),   // A
- en: new Point(12, 8),   // B
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(12, 8),   // B
- en: new Point(14, 31),  // C
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(14, 31),  // C
- en: new Point(24, 18),  // D
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(24, 18),  // D
- en: new Point(32, 26),  // E
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(32, 26),  // E
- en: new Point(40, 41),  // F
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(40, 41),  // F
- en: new Point(44, 6),   // G
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(44, 6),   // G
- en: new Point(57, 20),  // H
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(57, 20),  // H
- en: new Point(60, 35),  // I
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(60, 35),  // I
- en: new Point(72, 9),   // J
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(72, 9),   // J
- en: new Point(73, 41),  // K
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(73, 41),  // K
- en: new Point(85, 25),  // L
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(85, 25),  // L
- en: new Point(92, 8),   // M
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(92, 8),   // M
- en: new Point(93, 43)   // N
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: new Point(93, 43)   // N
- en: '];'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '];'
- en: points.Sort((a, b) => a.X.CompareTo(b.X));
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: points.Sort((a, b) => a.X.CompareTo(b.X));
- en: Result? closestPair = FindClosestPair(points.ToArray());
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Result? closestPair = FindClosestPair(points.ToArray());
- en: if (closestPair != null)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: if (closestPair != null)
- en: '{'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine(
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(
- en: '"Closest pair: ({0}, {1}) and ({2}, {3})'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '"Closest pair: ({0}, {1}) and ({2}, {3})'
- en: 'with distance: {4:F2}",'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'with distance: {4:F2}",'
- en: closestPair.P1.X,
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: closestPair.P1.X,
- en: closestPair.P1.Y,
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: closestPair.P1.Y,
- en: closestPair.P2.X,
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: closestPair.P2.X,
- en: closestPair.P2.Y,
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: closestPair.P2.Y,
- en: closestPair.Distance);
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: closestPair.Distance);
- en: '}'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Closest pair: (24, 18) and (32, 26) with distance: 11.31'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'Closest pair: (24, 18) and (32, 26) with distance: 11.31'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: void AddLine(int level, float x, float y,
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: void AddLine(int level, float x, float y,
- en: float length, float angle)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: float length, float angle)
- en: '{'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (level < 0) { return; }
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: if (level < 0) { return; }
- en: float endX = x + (float)(length * Math.Cos(angle));
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: float endX = x + (float)(length * Math.Cos(angle));
- en: float endY = y + (float)(length * Math.Sin(angle));
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: float endY = y + (float)(length * Math.Sin(angle));
- en: lines.Add(new(x, y, endX, endY));
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: lines.Add(new(x, y, endX, endY));
- en: AddLine(level - 1, endX, endY, length * 0.8f,
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: AddLine(level - 1, endX, endY, length * 0.8f,
- en: angle + (float)Math.PI * 0.3f);
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: angle + (float)Math.PI * 0.3f);
- en: AddLine(level - 1, endX, endY, length * 0.6f,
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: AddLine(level - 1, endX, endY, length * 0.6f,
- en: angle + (float)Math.PI * 1.7f);
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: angle + (float)Math.PI * 1.7f);
- en: '}'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: record Line(float X1, float Y1, float X2, float Y2)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: record Line(float X1, float Y1, float X2, float Y2)
- en: '{'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public float GetLength() =>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: public float GetLength() =>
- en: (float)Math.Sqrt(Math.Pow(X1 - X2, 2)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (float)Math.Sqrt(Math.Pow(X1 - X2, 2)
- en: + Math.Pow(Y1 - Y2, 2));
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: + Math.Pow(Y1 - Y2, 2));
- en: '}'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: using System.Drawing;
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: using System.Drawing;
- en: using System.Drawing.Drawing2D;
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: using System.Drawing.Drawing2D;
- en: const int maxSize = 1000;
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: const int maxSize = 1000;
- en: List<Line> lines = [];
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: List<Line> lines = [];
- en: maxSize). Then, you prepare an empty list for the lines. In the last line, you
    call the AddLine method. You indicate that 14 levels of pattern will be added.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: maxSize)。然后，你准备一个空的线条列表。在最后一行，你调用 AddLine 方法。你指定将添加 14 级的图案。
- en: The required NuGet package
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的 NuGet 包
- en: As you use elements from the `System.Drawing` and `System.Drawing.Drawing2D`
    namespaces, it is necessary to install an additional NuGet package, namely `System.Drawing.Common`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用了 `System.Drawing` 和 `System.Drawing.Drawing2D` 命名空间中的元素，因此需要安装一个额外的 NuGet
    包，即 `System.Drawing.Common`。
- en: 'As soon as you have the collection of lines, you can calculate the minimum
    and maximum *x* and *y* coordinates, as well as the target *width* and *height*,
    as presented here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了线条集合，你可以计算最小和最大的 *x* 和 *y* 坐标，以及目标 *宽度* 和 *高度*，如下所示：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The remaining part of code is related to printing the fractal on the bitmap:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的剩余部分与在位图中打印分形有关：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Within the presented code, you create a new instance of the `Bitmap` class with
    the specified size, as well as prepare the `Graphics` object to draw on this bitmap.
    Then, you paint the whole bitmap with a white color, set anti-aliasing, and specify
    a black pen for drawing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示的代码中，你创建了一个具有指定大小的 `Bitmap` 类的新实例，并准备了 `Graphics` 对象来绘制此位图。然后，你用白色绘制整个位图，设置抗锯齿，并指定黑色笔进行绘制。
- en: The preceding piece of code involves the `foreach` loop. Within it, you calculate
    a line width, as well as the start and end coordinates. The last line in the loop
    simply draws the line. Finally, you save the prepared bitmap in the working directory
    in the file, whose name is created based on the current time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段涉及 `foreach` 循环。在循环中，你计算线条宽度以及起始和结束坐标。循环中的最后一行简单地绘制线条。最后，你将准备好的位图保存到工作目录中的文件，其名称基于当前时间创建。
- en: Do you see warnings?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到警告了吗？
- en: The prepared code shows some warnings in the IDE. They inform you about the
    availability of graphics-related features only on the Windows platform. You can
    hide such warnings by adding the line `#pragma warning disable CA1416` just before
    the preceding code, as well as adding the line `#pragma warning restore CA1416`
    just at the end. What’s more, if you want to also draw graphics on other platforms,
    you can use other available NuGet packages, such as `SkiaSharp`. I strongly encourage
    you to create this example with `SkiaSharp` as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 准备的代码在 IDE 中显示了一些警告。它们仅通知你图形相关功能仅在 Windows 平台上可用。你可以在前面的代码之前添加一行 `#pragma warning
    disable CA1416` 来隐藏此类警告，以及添加一行 `#pragma warning restore CA1416` 来在代码末尾恢复。此外，如果你想在其他平台上绘制图形，可以使用其他可用的
    NuGet 包，例如 `SkiaSharp`。我强烈建议你使用 `SkiaSharp` 创建此示例。
- en: 'That’s all! You can now adjust various parameters to paint beautiful fractals,
    even better than presented in the preceding figure. Some of the other results
    are shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！你现在可以调整各种参数来绘制美丽的分形，甚至比前面图中的更好。其他一些结果如下所示：
- en: '![Figure 9.5 – Exemplary fractals generated using the recursive function](img/B18069_09_5.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 使用递归函数生成的示例分形](img/B18069_09_5.jpg)'
- en: Figure 9.5 – Exemplary fractals generated using the recursive function
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 使用递归函数生成的示例分形
- en: Where can you find more information?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以找到更多信息？
- en: You can find a lot of content about fractals in the internet. However, an approach
    similar to presented here, is described at [http://www.csharphelper.com/howtos/howto_curly_tree.html](http://www.csharphelper.com/howtos/howto_curly_tree.html).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在互联网上找到很多关于分形的内容。然而，与这里展示的类似的方法，可以在 [http://www.csharphelper.com/howtos/howto_curly_tree.html](http://www.csharphelper.com/howtos/howto_curly_tree.html)
    中找到描述。
- en: As soon as you are satisfied with the design of your fractal, let’s move to
    the next section, where you will solve the *rat in a* *maze* puzzle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对分形的设计满意，让我们进入下一节，在那里你将解决 *迷宫中的老鼠* 智力题。
- en: Rat in a maze
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫中的老鼠
- en: 'Let’s continue our adventure with examples by solving the **rat in a maze**
    problem with a **back-tracking algorithm**. The diagram is shown as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过解决**老鼠在迷宫中**的问题，使用**回溯算法**继续我们的冒险。图示如下：
- en: "![Figure 9.6 – \uFEFFIllustration of the \uFEFFrat in a \uFEFFmaze example](img/B18069_09_6.jpg)"
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 老鼠在迷宫示例的示意图](img/B18069_09_6.jpg)'
- en: Figure 9.6 – Illustration of the rat in a maze example
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 老鼠在迷宫示例的示意图
- en: Let’s imagine that a rat is located in the top-left field on the board, which
    is marked as **(0, 0)** in the preceding figure, and we need to find a path to
    the exit, which is located in the bottom-right field and is marked as **(7, 7)**.
    Of course, some blocks are disabled (shown in gray) and the rat cannot go through
    them. To reach the target, the rat can go up, down, left, or right only using
    the available blocks.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象老鼠位于板上的左上角字段，在先前的图中标记为**（0，0）**，我们需要找到通往出口的路径，出口位于右下角，标记为**（7，7）**。当然，一些方块是禁用的（以灰色显示），老鼠不能通过它们。为了到达目标，老鼠只能通过可用的方块向上、下、左或右移动。
- en: You can solve this problem using the **recursion** to check possible paths leading
    the rat from the entry to the exit. If the currently calculated path does not
    reach the exit, you **backtrack** and try other variants.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**递归**来检查可能的路径，这些路径将老鼠从入口引导到出口。如果当前计算的路径没有到达出口，你将**回溯**并尝试其他变体。
- en: 'The main part of the implementation is the `Go` method, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的主要部分是`Go`方法，如下所示：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The method takes two parameters, namely `row` and `column`. It also uses three
    additional variables. The first is named `maze` and is a two-dimensional array
    representing the maze with available (filled with `true` values) and unavailable
    (`false`) fields for the rat. The second, namely `size`, stores the size of the
    maze, namely the number of rows, which is also equal to the number of columns.
    Another variable (`solution`) is similar to `maze`, but it stores the data of
    the currently checked path. The fields forming the solution are filled with `true`
    values, while others are filled with `false`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数，即`row`和`column`。它还使用三个额外的变量。第一个名为`maze`，它是一个二维数组，表示迷宫，其中包含老鼠可用的（用`true`值填充）和不可用的（用`false`值填充）字段。第二个，即`size`，存储迷宫的大小，即行数，这也等于列数。另一个变量（`solution`）与`maze`类似，但它存储当前检查路径的数据。形成解决方案的字段用`true`值填充，而其他字段用`false`值填充。
- en: At the beginning of the method, you check whether the rat already reached the
    exit. If so, you mark the final field as a part of the solution and return a value
    indicating that the rat completed its task and exited the maze. Otherwise, you
    check whether the rat is still within the maze and not on any unavailable field.
    If all of these conditions are met, you check whether this field is already a
    part of the path, and if so, you inform that this solution is incorrect.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法开始时，你检查老鼠是否已经到达出口。如果是这样，你将最终字段标记为解决方案的一部分，并返回一个值表示老鼠完成了其任务并走出了迷宫。否则，你检查老鼠是否仍然在迷宫内且不在任何不可用的字段上。如果所有这些条件都满足，你检查该字段是否已经是路径的一部分，如果是，你通知这种解决方案是错误的。
- en: If the rat is within the maze and on an available field that has not already
    been visited, you mark this field as a part of the solution and try to go down,
    right, up, and left by calling the `Go` method recursively. If none of these moves
    reaches the target (of course, also after the next steps), you indicate that the
    current field is not a part of the solution, which represents **back-tracking**.
    Then, you return a value indicating that the target has not been reached.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果老鼠在迷宫内且位于尚未访问的可用的字段上，你将此字段标记为解决方案的一部分，并尝试通过调用递归的`Go`方法向下、右、上和左移动。如果这些移动中的任何一个都没有达到目标（当然，在下一步之后），你将当前字段标记为不是解决方案的一部分，这代表**回溯**。然后，你返回一个值表示目标尚未到达。
- en: 'Next, take a look at the code that calls the `Go` method for the first time:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看看调用`Go`方法的第一次代码：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: void Print()
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: void Print()
- en: '{'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int row = 0; row < size; row++)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: for (int row = 0; row < size; row++)
- en: '{'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int col = 0; col < size; col++)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: for (int col = 0; col < size; col++)
- en: '{'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.Write(solution[row, col] ? "x" : "-");'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'Console.Write(solution[row, col] ? "x" : "-");'
- en: '}'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Console.WriteLine();
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine();
- en: '}'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: x-------
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: x-------
- en: x-------
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: x-------
- en: xx------
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: xx------
- en: -x------
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: -x------
- en: -xx-----
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: -xx-----
- en: --x-----
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: --x-----
- en: --xxxxxx
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: --xxxxxx
- en: '-------x'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '-------x'
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: bool Solve()
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: bool Solve()
- en: '{'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: (int row, int col) = GetEmpty();
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: (int row, int col) = GetEmpty();
- en: if (row < 0 && col < 0) { return true; }
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: if (row < 0 && col < 0) { return true; }
- en: for (int i = 1; i <= 9; i++)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 1; i <= 9; i++)
- en: '{'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (IsCorrect(row, col, i))
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: if (IsCorrect(row, col, i))
- en: '{'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: board[row, col] = i;
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: board[row, col] = i;
- en: if (Solve()) { return true; }
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: if (Solve()) { return true; }
- en: else { board[row, col] = 0; }
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: else { board[row, col] = 0; }
- en: '}'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return false;
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: return false;
- en: '}'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: (int, int) GetEmpty()
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: (int, int) GetEmpty()
- en: '{'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int r = 0; r < 9; r++)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: for (int r = 0; r < 9; r++)
- en: '{'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int c = 0; c < 9; c++)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: for (int c = 0; c < 9; c++)
- en: '{'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (board[r, c] == 0) { return (r, c); }
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: if (board[r, c] == 0) { return (r, c); }
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return (-1, -1);
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: return (-1, -1);
- en: '}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: bool IsCorrect(int row, int col, int num)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: bool IsCorrect(int row, int col, int num)
- en: '{'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int i = 0; i < 9; i++)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < 9; i++)
- en: '{'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (board[row, i] == num) { return false; }
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: if (board[row, i] == num) { return false; }
- en: if (board[i, col] == num) { return false; }
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: if (board[i, col] == num) { return false; }
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int rs = row - row % 3;
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: int rs = row - row % 3;
- en: int cs = col - col % 3;
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: int cs = col - col % 3;
- en: for (int r = rs; r < rs + 3; r++)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: for (int r = rs; r < rs + 3; r++)
- en: '{'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int c = cs; c < cs + 3; c++)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: for (int c = cs; c < cs + 3; c++)
- en: '{'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (board[r, c] == num) { return false; }
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: if (board[r, c] == num) { return false; }
- en: '}'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return true;
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: return true;
- en: '}'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE22]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: int[,] board = new int[,]
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: int[,] board = new int[,]
- en: '{'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '{ 0, 5, 0, 4, 0, 1, 0, 0, 6 },'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 0, 5, 0, 4, 0, 1, 0, 0, 6 },'
- en: '{ 1, 0, 0, 9, 5, 0, 8, 0, 0 },'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 1, 0, 0, 9, 5, 0, 8, 0, 0 },'
- en: '{ 9, 0, 4, 0, 6, 0, 0, 0, 1 },'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 9, 0, 4, 0, 6, 0, 0, 0, 1 },'
- en: '{ 6, 2, 0, 0, 0, 5, 3, 0, 4 },'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 6, 2, 0, 0, 0, 5, 3, 0, 4 },'
- en: '{ 0, 9, 0, 0, 7, 0, 2, 0, 5 },'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 0, 9, 0, 0, 7, 0, 2, 0, 5 },'
- en: '{ 5, 0, 7, 0, 0, 0, 0, 8, 9 },'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 5, 0, 7, 0, 0, 0, 0, 8, 9 },'
- en: '{ 8, 0, 0, 5, 1, 9, 0, 0, 2 },'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 8, 0, 0, 5, 1, 9, 0, 0, 2 },'
- en: '{ 2, 3, 0, 0, 0, 6, 5, 0, 8 },'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 2, 3, 0, 0, 0, 6, 5, 0, 8 },'
- en: '{ 4, 1, 0, 2, 0, 8, 6, 0, 0 }'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 4, 1, 0, 2, 0, 8, 6, 0, 0 }'
- en: '};'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'Print method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 打印方法：
- en: '[PRE23]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result is shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, a back-tracking algorithm can be successfully applied to solve
    both rat in a maze and Sudoku puzzles. You can achieve this goal with short and
    clear code that is also easy to understand. So, after these examples, let’s move
    on to the next section where you will see an interesting application of a genetic
    algorithm.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，回溯算法可以成功应用于解决迷宫中的老鼠和数独问题。您可以通过简短、清晰且易于理解的代码实现这一目标。因此，在这些示例之后，让我们继续到下一节，在那里您将看到遗传算法的一个有趣应用。
- en: Title guess
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 标题猜测
- en: It is high time to change a type of applied algorithm to a **heuristic** one,
    which has many applications and also subtypes. Here, we focus only on **genetic
    algorithms**, which are **adaptive heuristic search algorithms**. They are related
    to the Darwinian theory of evolution and natural selection. According to it, individuals
    in a population compete, and the **population evolves to create next generations
    that are better suited to survive**. The genetic algorithms operate on strings
    that evolve to receive possibly the highest value of **fitness**, complying with
    the **rule of survival** and **passing on the genes of the fittest parents**,
    also based on a **randomized data exchange**. The algorithm ends its operation
    when a suitable value of fitness is reached or when the maximum number of generations
    is reached.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将应用算法的类型从一种**启发式**算法转变为一种，这种算法有众多应用和子类型。在这里，我们只关注**遗传算法**，它们是**自适应启发式搜索算法**。它们与达尔文的进化论和自然选择理论相关。根据这一理论，种群中的个体相互竞争，种群会进化以产生更适合生存的下一代。遗传算法在字符串上操作，这些字符串会进化以接收可能的最大**适应度**值，遵守**生存规则**，并基于**随机数据交换**传递最适应父母的基因。算法在达到合适的适应度值或达到最大代数时结束操作。
- en: Where can you find more information?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在哪里找到更多信息？
- en: You can find a lot of content about genetic algorithms in the internet, such
    as in the article published at [https://link.springer.com/article/10.1007/s11042-020-10139-6](https://link.springer.com/article/10.1007/s11042-020-10139-6).
    The simple approach to a genetic algorithm, which is shown in this chapter, is
    based on the solution presented at [https://www.geeksforgeeks.org/genetic-algorithms/](https://www.geeksforgeeks.org/genetic-algorithms/).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在互联网上找到大量关于遗传算法的内容，例如在[https://link.springer.com/article/10.1007/s11042-020-10139-6](https://link.springer.com/article/10.1007/s11042-020-10139-6)上发表的文章。本章中展示的遗传算法的简单方法基于[https://www.geeksforgeeks.org/genetic-algorithms/](https://www.geeksforgeeks.org/genetic-algorithms/)上提出的解决方案。
- en: 'Let''s take a look at an example of a genetic algorithm application to guess
    the title of this book. The first part of the code is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个遗传算法应用的例子，用于猜测这本书的标题。代码的第一部分如下：
- en: '[PRE25]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, you create an initial population, with 1,000 individuals. Each individual
    has a random chromosome, represented by a random string whose length is equal
    to the target string, which is a title of the book. Let’s go further:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个初始种群，包含1,000个个体。每个个体都有一个随机的染色体，表示为一个长度等于目标字符串的随机字符串，即书名。让我们进一步了解：
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The most interesting part is located in the infinite `while` loop. Here, you
    sort the population from the best fitted to survive – that is, by fitness in decreasing
    order. To explain it in detail, fitness is equal to 0 when no chars in the chromosome
    string match the following chars in the target string. In turn, fitness is equal
    to 33 (i.e., the number of chars in the book title), when the chromosome string
    is equal to the target string. For this reason, if the first element from the
    population (namely the fittest) has a fitness equal to the target string length,
    it means that the solution is found, so you just print it and exit the loop.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分位于无限`while`循环中。在这里，你按照适应度从高到低的顺序对种群进行排序，即生存能力最强的个体排在前面。为了详细解释，当染色体字符串中没有字符与目标字符串中的字符匹配时，适应度等于0。反过来，当染色体字符串与目标字符串相等时，适应度等于33（即书名中字符的数量）。因此，如果种群中的第一个元素（即最适应的个体）的适应度等于目标字符串的长度，这意味着找到了解决方案，所以你只需打印出来并退出循环。
- en: Otherwise, you clear the list with data of a new generation and add 200 best-fitted
    individuals to it. This means that **20% of the best-fitted individuals are moved
    automatically to the next generation**. For the remaining 800 places in the new
    generation, you perform **crossover** and **randomly choose parents, from 40%
    of the best-fitted individuals, to generate new individuals**. Then, you replace
    the current population with the new generation and proceed to the next iteration.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你清除新的一代的数据列表，并添加200个适应度最高的个体到其中。这意味着**20%的适应度最高的个体会自动进入下一代**。对于新的一代中剩余的800个位置，你执行**交叉**并**随机选择父母**，从40%的适应度最高的个体中，生成新的个体。然后，你用新的一代替换当前种群，并继续下一轮迭代。
- en: 'It’s worth mentioning the `Individual` record, the code for which is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是`Individual`记录，其代码如下：
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Individual Mate(Individual p1, Individual p2)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Individual Mate(Individual p1, Individual p2)
- en: '{'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string child = string.Empty;
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: string child = string.Empty;
- en: for (int i = 0; i < Target.Length; i++)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < Target.Length; i++)
- en: '{'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: float r = random.Next(101) / 100.0f;
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: float r = random.Next(101) / 100.0f;
- en: if (r < 0.45f) { child += p1.Chromosome[i]; }
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: if (r < 0.45f) { child += p1.Chromosome[i]; }
- en: else if (r < 0.9f) { child += p2.Chromosome[i]; }
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: else if (r < 0.9f) { child += p2.Chromosome[i]; }
- en: else { child += GetRandomGene(); }
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: else { child += GetRandomGene(); }
- en: '}'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return new Individual(child, GetFitness(child));
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: return new Individual(child, GetFitness(child));
- en: '}'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: char GetRandomGene() => Genes[random.Next(Genes.Length)];
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: char GetRandomGene() => Genes[random.Next(Genes.Length)];
- en: string GetRandomChromosome()
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: string GetRandomChromosome()
- en: '{'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string chromosome = string.Empty;
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: string chromosome = string.Empty;
- en: for (int i = 0; i < Target.Length; i++)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < Target.Length; i++)
- en: '{'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: chromosome += GetRandomGene();
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: chromosome += GetRandomGene();
- en: '}'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return chromosome;
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: return chromosome;
- en: '}'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: int GetFitness(string chromosome)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: int GetFitness(string chromosome)
- en: '{'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int fitness = 0;
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: int fitness = 0;
- en: for (int i = 0; i < Target.Length; i++)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < Target.Length; i++)
- en: '{'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (chromosome[i] == Target[i]) { fitness++; }
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: if (chromosome[i] == Target[i]) { fitness++; }
- en: '}'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return fitness;
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: return fitness;
- en: '}'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE30]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: void Print() => Console.WriteLine(
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: void Print() => Console.WriteLine(
- en: '$"Generation {generationNo:D2}:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: $"第{generationNo:D2}代：
- en: '{population[0].Chromosome} / {population[0].Fitness}");'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '{population[0].Chromosome} / {population[0].Fitness}");'
- en: '[PRE31]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Generation 00: UvWvvtycVTYAsJYxXZpanLkj#rDrmDIEI / 4'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第00代：UvWvvtycVTYAsJYxXZpanLkj#rDrmDIEI / 4
- en: 'Generation 01: sXDGuQQDPnbjpRvWZs evqRNlg#yiwIPL / 5'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 第01代：sXDGuQQDPnbjpRvWZs evqRNlg#yiwIPL / 5
- en: 'Generation 02: j#TvvtmKToXuTjxBegpaCLkmNsornzg R / 7'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 第02代：j#TvvtmKToXuTjxBegpaCLkmNsornzg R / 7
- en: 'Generation 03: fZCUBIT QrnuzwuWTskTOf bezodQwhmM / 8'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第03代：fZCUBIT QrnuzwuWTskTOf bezodQwhmM / 8
- en: 'Generation 04: CyDwafZZpinLziuPgs yID AevGrGf bs / 9'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第04代：CyDwafZZpinLziuPgs yID AevGrGf bs / 9
- en: 'Generation 05: C# ZaBawSWwLoturSXOcIq wLeSgQOhme / 12 (...)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 第05代：C# ZaBawSWwLoturSXOcIq wLeSgQOhme / 12 (...)
- en: 'Generation 10:  Sboats ttrDcterus Mnt jmvGrifhms / 17 (...)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第10代：Sboats ttrDcterus Mnt jmvGrifhms / 17 (...)
- en: 'Generation 15: C kData ltrCkteres entbAagorZthmD / 21 (...)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第15代：C kData ltrCkteres entbAagorZthmD / 21 (...)
- en: 'Generation 20: C#VDatahStrdcturessanU Al#orithmd / 26 (...)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第20代：C#VDatahStrdcturessanU Al#orithmd / 26 (...)
- en: 'Generation 25: CZ Data StrunturOs awd Algorithms / 29 (...)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 第25代：CZ Data StrunturOs awd Algorithms / 29 (...)
- en: 'Generation 30: C# Data Structures Qjd Algorithms / 31 (...)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 第30代：C# Data Structures Qjd Algorithms / 31 (...)
- en: 'Generation 35: C# Data Structures and Algorothms / 32 (...)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第35代：C# Data Structures and Algorothms / 32 (...)
- en: 'Generation 37: C# Data Structures and Algorithms / 33'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 第37代：C# 数据结构和算法 / 33
- en: '[PRE32]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: using System.Diagnostics;
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: using System.Diagnostics;
- en: using System.Text;
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 System.Text;
- en: const string secretPassword = "csharp";
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: const string secretPassword = "csharp";
- en: int charsCount = 0;
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: int charsCount = 0;
- en: char[] chars = new char[36];
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: char[] chars = new char[36];
- en: for (char c = 'a'; c <= 'z'; c++)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: for (char c = 'a'; c <= 'z'; c++)
- en: '{'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: chars[charsCount++] = c;
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: chars[charsCount++] = c;
- en: '}'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: for (char c = '0'; c <= '9'; c++)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: for (char c = '0'; c <= '9'; c++)
- en: '{'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: chars[charsCount++] = c;
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: chars[charsCount++] = c;
- en: '}'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE33]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: for (int length = 2; length <= 8; length++)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: for (int length = 2; length <= 8; length++)
- en: '{'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Stopwatch sw = Stopwatch.StartNew();
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Stopwatch sw = Stopwatch.StartNew();
- en: int[] indices = new int[length];
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: int[] indices = new int[length];
- en: for (int i = 0; i < length; i++) { indices[i] = 0; }
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < length; i++) { indices[i] = 0; }
- en: bool isCompleted = false;
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: bool isCompleted = false;
- en: StringBuilder builder = new();
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: StringBuilder builder = new();
- en: long count = 0;
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: long count = 0;
- en: while (!isCompleted)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: while (!isCompleted)
- en: '{'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: builder.Clear();
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Clear();
- en: for (int i = 0; i < length; i++)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < length; i++)
- en: '{'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: builder.Append(chars[indices[i]]);
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Append(chars[indices[i]]);
- en: '}'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: string guess = builder.ToString();
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: string guess = builder.ToString();
- en: if (guess == secretPassword)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: if (guess == secretPassword)
- en: '{'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Found.");
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("找到。");
- en: '}'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: count++;
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: count++;
- en: if (count % 10000000 == 0)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: if (count % 10000000 == 0)
- en: '{'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine($" > Checked: {count}.");'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'Console.WriteLine($" > 已检查: {count}.");'
- en: '}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: indices[length - 1]++;
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: indices[length - 1]++;
- en: if (indices[length - 1] >= charsCount)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: if (indices[length - 1] >= charsCount)
- en: '{'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for (int i = length - 1; i >= 0; i--)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = length - 1; i >= 0; i--)
- en: '{'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: indices[i] = 0;
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: indices[i] = 0;
- en: indices[i - 1]++;
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: indices[i - 1]++;
- en: if (indices[i - 1] < charsCount) { break; }
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: if (indices[i - 1] < charsCount) { break; }
- en: if (i - 1 == 0 && indices[0] >= charsCount)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: if (i - 1 == 0 && indices[0] >= charsCount)
- en: '{'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: isCompleted = true;
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: isCompleted = true;
- en: break;
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: sw.Stop();
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: sw.Stop();
- en: int seconds = (int)sw.ElapsedMilliseconds / 1000;
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: int seconds = (int)sw.ElapsedMilliseconds / 1000;
- en: Console.ForegroundColor = ConsoleColor.White;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ForegroundColor = ConsoleColor.White;
- en: 'Console.WriteLine($"{length} chars: {seconds}s");'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'Console.WriteLine($"{length} 个字符: {seconds}s");'
- en: Console.ResetColor();
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Console.ResetColor();
- en: '}'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE34]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
