- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object Relational Mapping with Entity Framework Core and Dapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used direct connections to SQL and NoSQL databases
    to create and retrieve data, a staple of most APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, a large segment of APIs based on .NET favor the use of **Object
    Relation Mapping** ( **ORM** ) to converse with databases over the direct connection
    method. This is because ORMs offer another layer of abstraction over the underlying
    data, promoting SOLID design principles while being conducive to scalability and
    easy long-term maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore two of the mainstream ORM frameworks
    – Entity Framework Core and Dapper. With these two technologies, we will be able
    to map the entities in our database and manage them as if the data was contained
    within the classes that make up our minimal API project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ORMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Dapper in minimal API projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing CRUD operations with Dapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Entity Framework in minimal API projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing CRUD operations with Entity Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following software to be installed on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 or Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft SQL Server 2022 Developer Edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft SQL Server Management Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need to create a database in SQL Server ( **MyCompany** ). The SQL
    to create the required **Employees** table was provided in the previous chapter,
    but I will also include it in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ORMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ORMs were first introduced in the 1990s to address the mismatch between the
    way data is modeled in relational databases such as SQL and **Object-Oriented
    Programming** ( **OOP** ) languages, often referred to as the **Impedance Mismatch**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Data in a *relational database* is laid out in a series of tables, each with
    a number of columns defining the property of each record, which in turn is represented
    by a row in the table. The relationships between entities in a relational database
    are represented by *foreign keys* and *join* operations that occur during a query.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, data in an *OOP language* is represented as objects that have fields,
    properties, and operational logic such as methods and functions that can act on
    the data. Relationships between objects in OOP are more abstract, represented
    by pointer references and concepts such as inheritance and polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: An ORM bridges the gap between these two paradigms by providing a means of mapping
    the data, which allows us to work with database records as if they were objects.
    This provides a layer of abstraction that simplifies the complexities of SQL,
    making it easier to perform **Create** , **Read** , **Update** , **Delete** (
    **CRUD** ) operations.
  prefs: []
  type: TYPE_NORMAL
- en: There are many, widely used ORMs on offer for various OOP languages and frameworks.
    The first widely used ORM was **TopLink** . Developed in 1994, it was designed
    to provide mapping for Java applications, influencing many of the ORM technologies
    we take for granted today, such as the two we will be exploring in this chapter
    – Dapper and Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: ORMs are a significant accelerator to any project, but particularly to minimal
    API projects. They reduce boilerplate code in ASP.NET because they can be easily
    installed as a package, and configuration can be achieved centrally, with queries
    and commands requiring less ceremony than direct SQL connections that use classes
    such as **SqlConnection** and **SqlCommand** .
  prefs: []
  type: TYPE_NORMAL
- en: One of the most powerful aspects of ORMs is the ability for them to manage the
    schema of the underlying database. Objects can be of course mapped from an existing
    database, but ORMs provide the ability to manage the database structure in the
    same way classes are configured in code.. This makes schema management really
    simple and more efficient because developers would be altering class structures
    anyway. It prevents *double keying* , taking advantage of the work that has already
    been done in code to automate the dependent changes in the database.
  prefs: []
  type: TYPE_NORMAL
- en: If you read the previous chapter, you’ll remember that we created a database
    called **MyCompany** to use as an example for connecting directly from our API.
    We will continue to use this database, but instead, we will map the objects within
    it using ORMs. Let’s first do this using the ORM, Dapper.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Dapper in minimal API projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’m starting with Dapper because it is an ORM that is often referred to as a
    *Micro-ORM* when compared to Entity Framework. The reason for this is that it
    does away with a lot of ORM features such as result caching, change tracking,
    lazy loading, and database migrations. Instead, Dapper focuses on simplicity and
    performance. Being a more lightweight solution means that it could be preferable
    to Entity Framework, depending on the needs of your minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper is a good starting point for learning ORMs because it still uses SQL
    queries, making it the perfect middle-ground between the direct connection method
    shown in the previous chapter and the more verbose ORM feature set provided by
    Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Database migrations and Dapper
  prefs: []
  type: TYPE_NORMAL
- en: The last differentiating feature (database migrations) is an important one because
    it relates to the ability to change the schema of a database. We will talk about
    migrations later in the chapter when we explore Entity Framework, but for now,
    know that database migrations change the database schema from our code, and Dapper
    does not support this via migrations. However, you can still change the table
    schema by sending SQL commands through Dapper. This is outside of the scope of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper works with many database providers, including SQL Server, Oracle, SQLite,
    MySQL, and PostgreSQL. It uses ADO.NET, meaning that it will work with any database
    platform that has a provider using ADO.NET. Because we are using the database
    we created in the previous chapter, we will be connecting to a SQL Server database.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a new (empty) ASP.NET project in Visual Studio so that we have
    a clean slate to work on.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created the project, navigate to **Program.cs** , which should
    have the template **Hello** **World** example.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we need a database to connect to. If you followed along with
    the previous chapter, you will have installed a SQL Server instance and created
    a database called **MyCompany** . If you haven’t done this already, install SQL
    Server and create the database within SQL Server Management Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a database, if you don’t yet have the **Employees** table, you
    can use the following SQL to create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Dapper uses providers to facilitate the connection to the target database platform.
    For SQL Server, the required providers are the same as for direct connections
    to SQL Server from C#: **Microsoft.Data.SqlClient** .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install **Microsoft.Data.SqlClient** , either from the **NuGet** package manager
    GUI or in the Package Manager Console by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While we’re installing **NuGet** packages, we also need to install the **Dapper**
    package. You can do this in the package manager console by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We could technically start writing queries now, directly within our minimal
    API endpoints, but for consistency and good practice, we should create a new service
    specifically for Dapper and register it for dependency injection. Create a class
    called **DapperService** . As we did in the previous chapter for **SQLService**
    and **MongoDbService** , we will register this class as a singleton in **Program.cs**
    . Ensure you register the service before **app.Run();** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have now configured the project to use Dapper on a SQL Server database using
    dependency injection with the relevant provider, and we have created a database
    to work with, meaning that we can proceed with performing our first CRUD operations
    from our minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: Performing CRUD operations with Dapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s work our way through each of the aspects of CRUD in Dapper with some examples.
    First of all, let’s create an employee.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Employee record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we will create an endpoint that creates an employee. That means we’ll
    be using the **POST** method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to **Program.cs** and map a POST endpoint to the **employees** route. It
    should accept an **Employee** as a parameter, and it should inject **DapperService**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we can create a method within **DapperService** that handles the creation
    of the employee in the database (this is where we get to use Dapper).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **DapperService.cs** and create a method called **AddEmployee** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like the direct connection examples from the previous chapter, Dapper uses **SqlConnection**
    to connect to a SQL Server. Inside the scope of that connection, you need to write
    the appropriate query for the action you want to take. Because we’re creating
    an **employee** , we will be adding a new record to the database and so we will
    write an **INSERT** statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make a **using** statement to hold the connection to the database (remember,
    **using** statements allow the connection to be automatically disposed of) and
    add the connection string to your database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow this up by defining a string that represents the **INSERT** statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the **INSERT** statement must contain all the relevant columns and
    values as parameters for those columns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will use Dapper to commit the database transaction against the instantiated
    **SqlConnection** . We can use **ExecuteAsync()** , a Dapper extension method
    that will execute the statement while mapping the properties from the **Employee**
    object that we passed into this the **AddEmployee()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have a method on **DapperService** that can receive an **Employee**
    parameter and commit it to the database via Dapper, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All that remains now is to call this method in the **POST** endpoint we started
    writing in **Program.cs** , before returning an **HTTP 201 CREATED** status code
    to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s taken care of the *Create* part of CRUD.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and referencing connection strings
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, I demonstrated how you can follow best practices by
    storing connection strings in a configuration file and then referencing them via
    **IConfiguration.**
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t already done so, please refer to this in the previous chapter
    so that you can implement it for Dapper and Entity Framework usage.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the *Read* part now.
  prefs: []
  type: TYPE_NORMAL
- en: Reading an Employee record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Read* part will entail having a **GET** endpoint on top of a **SELECT**
    query on the database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a **GET** endpoint to **Program.cs** , mapped to the **Employees**
    route. It should have a route parameter called **id** that is passed through the
    body of the lambda expression inside the endpoint, and it should inject **DapperService**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’re going to take the same approach we took in the last example by
    making a new function in **DapperService** , but this time, instead of inserting,
    it will run a **SELECT** query to get the employee for the specified **id** ,
    before returning it to the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**QuerySingleAsync<Employee>()** is where the Dapper code comes in. Like before,
    this is a Dapper extension method that allows us to execute a SQL query, with
    the expectation that one record will be returned, that record being an employee.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice the parameters being sent in. We passed the SQL query, but then we passed
    a new instance of an object array. This is the value for the **@employeeId** parameter
    that we declared in the SQL query. Dapper expects us to pass our parameter values
    in as an array of objects so that their values can be mapped to the relevant parameters
    in the query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also called a specific extension method – **QuerySingleAsync()** . The reason
    for this is obvious – we only want one record. If you want more, there are functions
    such as **Query()** that will return an **IEnumerable** containing many records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we once again simply call the function in **DapperService** from the
    endpoint, returning the result to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let’s look at how we can *update* an employee record.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an Employee record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re two letters into CRUD now. Let’s take a look now at **Update** by taking
    the same approach – creating a **PUT** endpoint and connecting it to **DapperService:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a function that performs the update against the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the code we’ve added to update the record in **DapperService** is
    similar to the code we added to create a record. The main difference is the SQL
    string. Otherwise, we’re still passing in an **Employee** object and mapping its
    properties to the record in the database via Dapper.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an Employee record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we’ve reached the final section of CRUD – **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll follow the same principle we’ve applied in all the operations up to this
    point, but this time I’m going to start by adding the functionality to **DapperService**
    for deleting a record by ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add an endpoint to use the service for record deletion, returning
    a **NO CONTENT** result to the client on success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’ve covered enough of Dapper that you should now be able to use it to perform
    basic simple CRUD operations on SQL databases through this powerful yet lightweight
    (micro) ORM. You could also try swapping out the SQL provider for one that supports
    another database, such as MySQL or PostgreSQL, to improve your experience of using
    Dapper to manage data in SQL for incoming requests on your minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper has its place, but Entity Framework is a more feature-rich alternative
    that is used for not only transacting data but also to manage the SQL database
    structure from code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how we can build the same functionality we’ve explored
    in the section, using Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Entity Framework in minimal API projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, we need to use Microsoft’s Entity Framework packages to configure the
    connection, referred to hereafter as the **context** . This wording already creates
    a layer of abstraction from the database as we start to consider our data as members
    of this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the following packages via the package manager console
    in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that all the libraries required to interact with SQL Server through
    Entity Framework are in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will **scaffold** the existing **MyCompany** database, again from
    the package manager console, using the connection string for the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Scaffolding** means that Entity Framework looks at the schema of the database
    and maps the tables to objects in your code. The result is a **DbContext** , which
    wraps all of the different entities in the context. A series of models will also
    be created that are classes representing each of the entities. These are placed
    in the folder specified by the **OutputDir** switch used by the console command.'
  prefs: []
  type: TYPE_NORMAL
- en: Because I stated that I want the context to be called **MyCompanyContext** ,
    a new class called **MyCompanyContext** has been generated in the **Models** folder.
  prefs: []
  type: TYPE_NORMAL
- en: In this class, you can see that a **DbSet<Employee>** called **Employees** has
    been added. A **DbSet** represents all the current records in a given database
    table. This is a collection representing each of the records in **Employees**
    , and by adding to, retrieving from, updating, or removing from this collection,
    we can indirectly change the corresponding SQL table. Let’s look at the generated
    code to further understand what is happening here.
  prefs: []
  type: TYPE_NORMAL
- en: '**MyCompanyContext** is a class derived from **DbContext** . It represents
    the data source in use and provides a means of interacting with this source at
    a higher level of abstraction. When the class is instantiated, **DbContextOptions**
    is injected into it, which is then passed to the base **DbContext** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Entity Framework then generates the code required to build the context, mapping
    business objects to tables in the database, allowing a model to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Entity Framework is instructed in this example to use SQL Server with the specified
    connection string to model the entities based on the database schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Before we start looking at communicating with the database through Entity Framework
    from the API endpoints, we have another piece of configuration to explore.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand how **migrations** are used by Entity Framework
    to change the database schema. A migration is a set of instructions to follow
    to make specific changes to a database. Whether to add a column to a table, add
    a new table, or remove a column, it can usually be done via a migration.
  prefs: []
  type: TYPE_NORMAL
- en: Migrations keep Entity Framework as the single source of truth for your data
    by outlining how a database’s structural change should be managed, in addition
    to data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore migrations by making a change to our **Employees** table. We’re
    going to add a **Title** column to the table. First, open the **Employee** model
    that was generated in the **Models** folder and add **Title** as a **string**
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then, we head back to the package manager console to input a command to add
    the migration. This command asks Entity Framework to look for any changes to any
    of the **DbSet** objects in the **DbContext** . It will then generate C# code
    that will eventually run SQL on the database to commit the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **Add-Migration** command in the package manager console, followed
    by a string that gives the migration a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Migration names
  prefs: []
  type: TYPE_NORMAL
- en: When naming a migration, it is good practice to provide a summary of the changes
    these migrations make – for example, **changed_datatype_of_salary_column_to_decimal**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Entity Framework will then build the project and add a new class for the migration
    in the **Migrations** folder, creating the folder if it does not yet exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the migration specifies that a column is to be added called
    **Title** .
  prefs: []
  type: TYPE_NORMAL
- en: 'To commit this to the database, we can write another simple command in the
    package manager console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If all went as expected, you’ll see that the **Employees** table in the database
    has a **Title** column.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the basics of its configuration, let’s update the endpoints
    in **Program.cs** to use Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Performing CRUD operations with Entity Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a new dependency in the form of the **DbContext** . We should register
    it within the **Main** method in **Program.cs** for use during a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we did in the previous examples using Dapper, we will create a new service
    for managing CRUD operations for **Employee** objects. This time, we will be more
    specific with the naming, and call it **EmployeeService** .
  prefs: []
  type: TYPE_NORMAL
- en: 'In **EmployeeService** , start by adding a constructor, to which we can pass
    the registered context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define all the functions that will be needed for CRUD operations using
    **MyCompanyContext** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll create a customer exception called **EmployeeNotFoundException**
    , which can we throw in the event a requested employee is not present in the data
    source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In each of these new functions within **EmployeeService** , we are interacting
    with the database via the **Employees** collection sitting within **MyCompanyContext**
    . We are then committing the changes we have made to this collection to the database
    using **SaveChangesAsync();** .
  prefs: []
  type: TYPE_NORMAL
- en: Take note of the reusability of one of the functions, **GetEmployeeById** .
    In most CRUD operations, we need to be able to target the affected **Employee**
    object, and we can reuse this function for this. To guard against the potential
    of an employee not being found in the collection, there is a custom exception
    that can be thrown. This is useful for the API endpoint because it means it can
    cater its response to a specific exception if it occurs, in this case, returning
    a **404 NOT FOUND** status code if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve established that in Entity Framework, interacting with a database table
    means interacting with a collection in C#. This is apparent in **EmployeeService**
    , where LINQ queries are used in place of the SQL queries that would have been
    used in a direct SQL connection or a micro-ORM such as Dapper.
  prefs: []
  type: TYPE_NORMAL
- en: With the establishment of **EmployeeService** , the API endpoints in **Program.cs**
    can be altered to use Entity Framework rather than the previously used Dapper.
    But to what extent do they need to be changed?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this is – not very much at all, thanks to the abstraction we’ve
    created in the form of **EmployeeService** . We’ve used an injected dependency
    to manage the database interaction, with the functions within having the same
    name or **signature** as each other, meaning that we can just swap out the injected
    **DapperService** for the new **EmployeeService** that uses Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to **Program.cs** and register **EmployeeService** for dependency
    injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Double-click the parameter that currently passes in **DapperService** to any
    of the mapped endpoints. In Visual Studio, you can rename this object **EmployeeService**
    by holding *Ctrl* and pressing the *R* key twice.
  prefs: []
  type: TYPE_NORMAL
- en: After renaming, all other occurrences will also be updated. You shouldn’t have
    any errors as long as the functions called by each endpoint have the same signature
    regardless of whether you’re using **DapperService** or **EmployeeService** .
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the **POST** endpoint for creating an **employee**
    after it has been updated to use **EmployeeService** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This was a rather whirlwind introduction to Entity Framework, which has a great
    deal more in the way of features. However, the main focus is on a minimal API’s
    interaction with databases in an abstracted manner, and this example is enough
    to get you started on your ORM journey.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review the things we’ve learned about Dapper and Entity Framework in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced the use of Dapper and Entity Framework to provide
    an abstraction layer between minimal API endpoints and relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: We opened with an introduction to ORMs, defining their role in simplifying database
    interactions in minimal APIs, before providing an overview of the various features
    available for interaction with data sources.
  prefs: []
  type: TYPE_NORMAL
- en: We then stepped through the configuration of Dapper, adding the relevant libraries
    and providing a dedicated **DapperService** that could be used on minimal API
    endpoints with dependency injection. Once we had configured Dapper, we created
    the SQL queries in **DapperService** and linked the endpoints to the service to
    provide an end-to-end link between API and database via Dapper.
  prefs: []
  type: TYPE_NORMAL
- en: Having established CRUD operations on the database with Dapper, we contrasted
    this by configuring Entity Framework, and then performed the equivalent setup
    of a service for completing CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the original **DapperService** was swapped out for the new **EmployeeService**
    using Entity Framework, demonstrating the versatility of injecting an abstraction
    as a dependency for data management.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no doubt that integrating data sources via ORMs is a significant aspect
    of building a minimal API. When managing data, depending on the way the data is
    requested, the potential for bottlenecks in performance can be significant. We
    will explore this concept and ways that these bottlenecks can be mitigated in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 - Optimal Minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build high-performing, scalable APIs, it’s essential to fine-tune your system’s
    performance and take advantage of advanced programming techniques. This part covers
    how to identify bottlenecks, employ asynchronous programming, and implement caching
    strategies to improve efficiency and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B20968_10.xhtml#_idTextAnchor154) , *Profiling and Identifying
    Bottlenecks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B20968_11.xhtml#_idTextAnchor165) , *Utilizing Asynchronous
    Programming for Scalability*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B20968_12.xhtml#_idTextAnchor174) , *Caching Strategies for
    Enhanced Performance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
