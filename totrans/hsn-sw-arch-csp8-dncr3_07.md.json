["```cs\nSet-ExecutionPolicy -ExecutionPolicy Unrestricted -Force -Scope CurrentUser\n```", "```cs\nvar myPolicy = Policy\n  .Handle<HttpRequestException>()\n  .Or<OperationCanceledException>()\n  .Retry(3);\n....\n....\nmyPolicy.Execute(()=>{\n    //your code here\n});\n```", "```cs\nvar erPolicy= Policy\n    ...\n    //Exceptions to handle here\n    .WaitAndRetry(6, \n        retryAttempt => TimeSpan.FromSeconds(Math.Pow(2,\n            retryAttempt)));\n```", "```cs\nvar cbPolicy=Policy\n    .Handle<SomeExceptionType>()\n    .CircuitBreaker(6, TimeSpan.FromMinutes(1));\n```", "```cs\nPolicy\n  .Bulkhead(10, 15)\n```", "```cs\nvar combinedPolicy = Policy\n  .Wrap(erPolicy, cbPolicy);\n```", "```cs\nvar myHost=new HostBuilder()\n    //Several chained calls\n    //defining Host configuration\n    .Build();\n```", "```cs\nhost.Start();\n```", "```cs\nawait host.RunAsync(cancelationToken)\n```", "```cs\nvar myHost = new HostBuilder()\n    .ConfigureServices((hostContext, services) =>\n    {\n        services.Configure<HostOptions>(option =>\n        {\n            option.ShutdownTimeout = System.TimeSpan.FromSeconds(10);\n        });\n        ....\n        ....\n        //further configuration\n    })\n    .Build();\n```", "```cs\nservices.AddHostedService<MyHostedService>();\n```", "```cs\nusing Microsoft.Extensions.DependencyInjection;\n```", "```cs\npublic class MyHostedService: BackgroundService \n{\n    private applicationLifetime;\n    public MyHostedService(IApplicationLifetime applicationLifetime)\n    {\n        this.applicationLifetime=applicationLifetime;\n    }\n    protected Task ExecuteAsync(CancellationToken token) \n    {\n        ...\n        applicationLifetime.StopApplication();\n        ...\n    }\n}\n```", "```cs\nservices.AddTransient<MyResource>();\nservices.AddTransient<IResourceInterface, MyResource>();\nservices.AddSingleton<MyResource>();\nservices.AddSingleton<IResourceInterface, MyResource>();\n```", "```cs\n.UseContentRoot(\"c:\\\\<deault path>\")\n```", "```cs\n.ConfigureLogging((hostContext, configLogging) =>\n    {\n        configLogging.AddConsole();\n        configLogging.AddDebug();\n    })\n```", "```cs\n.ConfigureHostConfiguration(configHost =>\n    {\n        configHost.AddJsonFile(\"settings.json\", optional: true);\n        configHost.AddEnvironmentVariables(prefix: \"PREFIX_\");\n        configHost.AddCommandLine(args);\n    })\n```", "```cs\nFROM microsoft/dotnet:x.x-aspnetcore-runtime AS base\nWORKDIR /app\nEXPOSE 80\nEXPOSE 443\n```", "```cs\nFROM microsoft/dotnet:x.x-sdk AS build\nWORKDIR /src\nCOPY MvcDockerTest/MvcDockerTest.csproj MvcDockerTest/\nRUN dotnet restore MvcDockerTest/MvcDockerTest.csproj\nCOPY . .\nWORKDIR /src/MvcDockerTest\nRUN dotnet build MvcDockerTest.csproj -c Release -o /app\n\nFROM build AS publish\nRUN dotnet publish MvcDockerTest.csproj -c Release -o /app\n```", "```cs\nFROM base AS final\nWORKDIR /app\nCOPY --from=publish /app .\nENTRYPOINT [\"dotnet\", \"MvcDockerTest.dll\"]\n```", "```cs\nversion: '3.4'\n\nservices:\n  mvcdockertest:\n    image: ${DOCKER_REGISTRY-}mvcdockertest\n    build:\n      context: .\n      dockerfile: MvcDockerTest/Dockerfile\n\n  mvcdockertest1:\n    image: ${DOCKER_REGISTRY-}mvcdockertest1\n    build:\n      context: .\n      dockerfile: MvcDockerTest1/Dockerfile\n```", "```cs\nversion: '3.4'\n\nservices:\n  mvcdockertest:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=https://+:443;http://+:80\n      - ASPNETCORE_HTTPS_PORT=44355\n    ports:\n      - \"3150:80\"\n      - \"44355:443\"\n    volumes:\n      - ${APPDATA}/Asp.NET/Https:/root/.aspnet/https:ro\n      - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro\n  mvcdockertest1:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=https://+:443;http://+:80\n      - ASPNETCORE_HTTPS_PORT=44317\n    ports:\n      - \"3172:80\"\n      - \"44317:443\"\n    volumes:\n      - ${APPDATA}/Asp.NET/Https:/root/.aspnet/https:ro\n      - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro\n```", "```cs\nsql.data:\n  image: mssql-server-linux:latest\nenvironment:\n- SA_PASSWORD=Pass@word\n- ACCEPT_EULA=Y\nports:\n- \"5433:1433\"\n```", "```cs\ndocker-compose -f docker-compose.yml -f docker-compose-staging.override.yml\n```", "```cs\ndocker-compose -f docker-compose.yml -f docker-compose.test.staging.yml down\n```", "```cs\nprotected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\n\nprotected override async Task RunAsync(CancellationToken cancellationToken)\n```", "```cs\ndocker pull other.registry.io/samples/myimage \n```", "```cs\ndocker pull other.registry.io/samples/myimage:version1.0 \n```", "```cs\ndocker images\n```", "```cs\ndocker login myregistry.azurecr.io\n```", "```cs\ndocker tag myimage myregistry.azurecr.io/testpath/myimage\n```", "```cs\ndocker push myregistry.azurecr.io/testpath/myimage\n```", "```cs\ndocker rmi myregistry.azurecr.io/testpath/myimage\n```", "```cs\n<ClusterConnectionParameters \n    ConnectionEndpoint=\"<cluster name>.<location \n    code>.cloudapp.azure.com:19000\"\n    X509Credential=\"true\"\n    ServerCertThumbprint=\"<server certificate thumbprint>\"\n    FindType=\"FindByThumbprint\"\n    FindValue=\"<client certificate thumbprint>\"\n    StoreLocation=\"CurrentUser\"\n    StoreName=\"My\" />\n```", "```cs\naz aks get-credentials --resource-group <resource group> --name <cluster name>\n```", "```cs\nkubectl apply -f myClusterConfiguration.yaml\n```", "```cs\nkubectl get service MyDeployment --watch\n```", "```cs\naz aks delete --resource-group <resource group> --name <cluster name> --no-wait\n```", "```cs\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: MyDeployment\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: MyApplication\n  template:\n    ...\n    ...\n```", "```cs\ntemplate:\n    metadata:\n      labels:\n        app: MyApplication\n    spec:\n      containers:\n      - name: MyContainerName\n        image: myregistry.azurecr.io/testpath/myimage\n        resources:\n          requests:\n            cpu: 100m\n            memory: 128Mi\n          limits:\n            cpu: 250m\n            memory: 256Mi\n        ports:\n        - containerPort: 80\n        - name: http\n        env:\n        - name: MyEnvironmetVariable\n          value: \"MyEnvironmetVariable\"\n```", "```cs\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: MyApplication-service\nspec:\n  ports:\n  - port: 8080\n    targetPort: 80\n    protocol: TCP\n    name: http\n  selector:\n    app: MyApplication\n```", "```cs\napiVersion: v1\nkind: Namespace  \nmetadata:   \n    name: my-namespace   \n    labels:     \n        name: my-namespace\n```", "```cs\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<Settings  \n\n          > \n  <!-- This is used by the StateManager's replicator. -->\n  <Section Name=\"ReplicatorConfig\">\n    <Parameter Name=\"ReplicatorEndpoint\" Value=\"ReplicatorEndpoint\" />\n  </Section>\n  <!-- This is used for securing StateManager's replication traffic. -->\n  <Section Name=\"ReplicatorSecurityConfig\" />\n\n  <!-- Below the new Section to add -->\n\n  <Section Name=\"Timing\">\n    <Parameter Name=\"MessageMaxDelaySeconds\" Value=\"\" />\n  </Section>\n</Settings>\n```", "```cs\n<Endpoint Name=\"<endpoint name>\" PathSuffix=\"<the path of the endpoint URI>\" Protocol=\"<a protcolo like Tcp, http, https, etc.>\" Port=\"the exposed port\" Type=\"<Internal or Input>\"/>\n```", "```cs\n<Parameter Name=\"<parameter name>\" DefaultValue=\"<parameter definition>\" />\n```", "```cs\n<UniformInt64Partition PartitionCount=\"[LogStore_PartitionCount]\" LowKey=\"0\" HighKey=\"1000\" />\n```", "```cs\n<Parameter Name=\"LogStore_MinReplicaSetSize\" DefaultValue=\"1\" />\n<Parameter Name=\"LogStore_PartitionCount\" DefaultValue=\"2\" />\n<Parameter Name=\"LogStore_TargetReplicaSetSize\" DefaultValue=\"1\" />\n```", "```cs\n<Service Name=LogStore ServicePackageActivationMode=\"ExclusiveProcess\">\n    <StatefulService ServiceTypeName=\"LogStoreType\" \n    TargetReplicaSetSize=\n    \"[LogStore_TargetReplicaSetSize]\" \n    MinReplicaSetSize=\"[LogStore_MinReplicaSetSize]\">\n        <UniformInt64Partition PartitionCount=\"\n        [LogStore_PartitionCount]\" \n        LowKey=\"0\" HighKey=\"1000\" />\n    </StatefulService>\n</Service>\n```", "```cs\n<ClusterConnectionParameters \n    ConnectionEndpoint=\"<cluster name>.<location \n    code>.cloudapp.azure.com:19000\"\n    X509Credential=\"true\"\n    ServerCertThumbprint=\"<server certificate thumbprint>\"\n    FindType=\"FindByThumbprint\"\n    FindValue=\"<client certificate thumbprint>\"\n    StoreLocation=\"CurrentUser\"\n    StoreName=\"My\" />\n```", "```cs\nusing System;\nusing System.Runtime.Serialization;\n\nnamespace IdempotencyTools\n{\n    [DataContract]\n    public class IdempotentMessage<T>\n    {\n        [DataMember]\n        public T Value { get; protected set; }\n        [DataMember]\n        public DateTimeOffset Time { get; protected set; }\n        [DataMember]\n        public Guid Id { get; protected set; }\n\n        public IdempotentMessage(T originalMessage)\n        {\n            Value = originalMessage;\n            Time = DateTimeOffset.Now;\n            Id = Guid.NewGuid();\n        }\n    }\n}\n```", "```cs\npublic class IdempotencyFilter\n{\n    protected IReliableDictionary<Guid, DateTimeOffset> dictionary;\n    protected int maxDelaySeconds;\n    protected DateTimeOffset lastClear;\n    protected IReliableStateManager sm;\n    protected IdempotencyFilter() { }\n    public static async Task<IdempotencyFilter> NewIdempotencyFilter(\n        string name, \n        int maxDelaySeconds, \n        IReliableStateManager sm)\n    {\n        var result = new IdempotencyFilter();\n        result.dictionary = await \n            sm.GetOrAddAsync<IReliableDictionary<Guid, DateTimeOffset>> \n            (name);\n        result.maxDelaySeconds = maxDelaySeconds;\n        result.lastClear = DateTimeOffset.Now;\n        result.sm = sm;\n        return result;\n    }\n...\n...\n```", "```cs\npublic async Task<T> NewMessage<T>(IdempotentMessage<T> message)\n{\n    DateTimeOffset now = DateTimeOffset.Now;\n    if ((now - lastClear).TotalSeconds > 1.5 * maxDelaySeconds)\n    {\n        await Clear();\n    }\n    if ((now - message.Time).TotalSeconds > maxDelaySeconds)\n        return default(T);\n    using (ITransaction tx = this.sm.CreateTransaction())\n    {\n        ...\n        ...\n    }\n }\n```", "```cs\nusing (ITransaction tx = this.sm.CreateTransaction())\n{\n    var result = await dictionary.TryGetValueAsync(tx, \n    message.Id);\n    if (result.HasValue)\n    {\n        tx.Abort();\n        return default(T);\n    }\n    else\n    {\n        await dictionary.TryAddAsync(tx, message.Id, message.Time);\n        await tx.CommitAsync();\n        return message.Value;\n    }\n}\n```", "```cs\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Threading.Tasks;\nusing IdempotencyTools;\nusing Microsoft.ServiceFabric.Services.Remoting;\n\nnamespace Interactions\n{\n    public interface ILogStore: IService\n    {\n        Task<bool> LogPurchase(IdempotentMessage<PurchaseInfo> \n        idempotentMessage);\n    }\n}\n```", "```cs\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.Serialization;\nusing System.Text;\n\nnamespace Interactions\n{\n    [DataContract]\n    public class PurchaseInfo\n    {\n        [DataMember]\n        public string Location { get; set; }\n        [DataMember]\n        public decimal Cost { get; set; }\n        [DataMember]\n        public DateTimeOffset Time { get; set; }\n    }\n}\n```", "```cs\ninternal sealed class LogStore : StatefulService, ILogStore\n...\n... private IReliableQueue<IdempotentMessage<PurchaseInfo>> LogQueue = null;\npublic async Task<bool> \n    LogPurchase(IdempotentMessage<PurchaseInfo> idempotentMessage)\n{\n    if (LogQueue == null) return false;\n    using (ITransaction tx = this.StateManager.CreateTransaction())\n    {\n        await LogQueue.EnqueueAsync(tx, idempotentMessage);\n        await tx.CommitAsync();\n        return true;\n    }\n}\n```", "```cs\nprotected override IEnumerable<ServiceReplicaListener> \n    CreateServiceReplicaListeners()\n{\n    return this.CreateServiceRemotingReplicaListeners<LogStore>();\n}\n```", "```cs\nreturn new ServiceReplicaListener[]\n{\n    new ServiceReplicaListener(context => \n    new MyCustomHttpListener(context, \"<endpoint name>\"),             \n    \"CustomWriteUpdateListener\", true),\n\n    new ServiceReplicaListener(serviceContext =>\n    new KestrelCommunicationListener(serviceContext, \"<endpoint name>\" \n    (url, listener) =>\n        {\n           ...\n        })\n        \"HttpReadOnlyListener\",\n    true)\n};\n```", "```cs\nnew ServiceReplicaListener(serviceContext =>\nnew KestrelCommunicationListener(serviceContext, \"<endpoint name>\" (url, listener) =>\n{\n    return new WebHostBuilder()\n    .UseKestrel()\n    .ConfigureServices(\n        services => services\n        .AddSingleton<StatefulServiceContext>(serviceContext)\n        .AddSingleton<IReliableStateManager>(this.StateManager))\n\n    .UseContentRoot(Directory.GetCurrentDirectory())\n    .UseStartup<Startup>()\n    .UseServiceFabricIntegration(listener, \n\n    ServiceFabricIntegrationOptions.UseUniqueServiceUrl)\n    .UseUrls(url)\n    .Build();\n})\n\"HttpReadOnlyListener\",\ntrue)\n```", "```cs\npublic async Task<string> OpenAsync(CancellationToken cancellationToken)\n{\n    EndpointResourceDescription serviceEndpoint = serviceContext\n    .CodePackageActivationContext.GetEndpoint(\"ServiceEndpoint\");\n    //create service URI that depend on current Ip \n    (FabricRuntime.GetNodeContext().IPAddressOrFQDN)\n    //partition id (serviceContext.PartitionId)\n    //and replica id (serviceContext.ReplicaOrInstanceId)\n    //open the listener\n    return <computedURISchema>;\n}\n```", "```cs\nnamespace LogStore\n{\n    public class RunningTotal\n    {\n        public DateTime Day { get; set; }\n        public decimal Count { get; set; }\n\n        public RunningTotal \n                Update(DateTimeOffset time, decimal value)\n        {\n            ...\n        }\n    }\n}\n```", "```cs\npublic RunningTotal Update(DateTimeOffset time, decimal value)\n        {\n            var normalizedTime = time.ToUniversalTime();\n            var newDay = new DateTime(normalizedTime.Year, \n                    normalizedTime.Month, normalizedTime.Day);\n           ... \n           ...\n        }\n```", "```cs\npublic RunningTotal Update(DateTimeOffset time, decimal value)\n{\n    ...\n    ...\n    var result = newDay > Day && Day != DateTime.MinValue ? \n    new RunningTotal\n    {\n        Day=Day,\n        Count=Count\n    } \n    : null;\n    if(newDay > Day) Day = newDay;\n    if (result != null) Count = value;\n    else Count += value;\n    return result;\n}\n```", "```cs\nnamespace LogStore\n{\n    public class ComputeStatistics : BackgroundService\n    {\n        IReliableQueue<IdempotentMessage<PurchaseInfo>> queue;\n        IReliableStateManager stateManager;\n        ConfigurationPackage configurationPackage;\n        public ComputeStatistics(\n            IReliableQueue<IdempotentMessage<PurchaseInfo>> queue,\n            IReliableStateManager stateManager,\n            ConfigurationPackage configurationPackage)\n        {\n            this.queue = queue;\n            this.stateManager = stateManager;\n            this.configurationPackage = configurationPackage;\n        }\n```", "```cs\nprotected async override Task ExecuteAsync(CancellationToken stoppingToken)\n{\n    bool queueEmpty = false;\n    var delayString=configurationPackage.Settings.Sections[\"Timing\"]\n        .Parameters[\"MessageMaxDelaySeconds\"].Value;\n    var delay = int.Parse(delayString);\n    var filter = await IdempotencyFilter.NewIdempotencyFilter(\n        \"logMessages\", delay, stateManager);\n    var store = await\n        stateManager.GetOrAddAsync<IReliableDictionary<string, RunningTotal>>(\"partialCount\");\n....\n...\n```", "```cs\n<ServiceManifestImport>\n    <ServiceManifestRef ServiceManifestName=\"LogStorePkg\" ServiceManifestVersion=\"1.0.0\" />\n    <!--code to add start -->\n    <ConfigOverrides>\n      <ConfigOverride Name=\"Config\">\n        <Settings>\n          <Section Name=\"Timing\">\n            <Parameter Name=\"MessageMaxDelaySeconds\" Value=\"[MessageMaxDelaySeconds]\" />\n          </Section>\n        </Settings>\n      </ConfigOverride>\n    </ConfigOverrides>\n    <!--code to add end-->\n</ServiceManifestImport>\n```", "```cs\nwhile (!stoppingToken.IsCancellationRequested)\n    {\n        while (!queueEmpty && !stoppingToken.IsCancellationRequested)\n        {\n            RunningTotal total = null;\n            using (ITransaction tx = stateManager.CreateTransaction())\n            {\n                ...\n                ... \n                ...\n            }\n        }\n        await Task.Delay(100, stoppingToken);\n        queueEmpty = false;\n    }\n} \n```", "```cs\nawait Task.Delay(100, stoppingToken);\nqueueEmpty = false;\n```", "```cs\nRunningTotal total = null;\nusing (ITransaction tx = stateManager.CreateTransaction())\n{\n    var result = await queue.TryDequeueAsync(tx);\n    if (!result.HasValue) queueEmpty = true;\n    else\n    {\n        var item = await filter.NewMessage<PurchaseInfo>(result.Value);\n        if(item != null)\n        {\n            var counter = await store.TryGetValueAsync(tx, \n            item.Location);\n            //counter update\n            ...\n        }\n        ...\n        ...\n    }\n}\n```", "```cs\n    //counter update    \n    var newCounter = counter.HasValue ? \n    new RunningTotal\n    {\n        Count=counter.Value.Count,\n        Day= counter.Value.Day\n    }\n    : new RunningTotal();\n    total = newCounter.Update(item.Time, item.Cost);\n    if (counter.HasValue)\n        await store.TryUpdateAsync(tx, item.Location, \n        newCounter, counter.Value);\n    else\n        await store.TryAddAsync(tx, item.Location, newCounter);\n```", "```cs\nif(item != null)\n{\n  ...\n  ...\n}\nawait tx.CommitAsync();\nif(total != null)\n{\n    await SendTotal(total, item.Location);\n}\n```", "```cs\nprotected async Task SendTotal(RunningTotal total, string location)\n{\n   //Empty, actual application would send data to a service \n   //that exposes daily statistics through a public Http endpoint         \n}\n```", "```cs\nprotected override async Task RunAsync(CancellationToken cancellationToken)\n{\n    // TODO: Replace the following sample code with your own logic \n    // or remove this RunAsync override if it's not needed in your service.\n    cancellationToken.ThrowIfCancellationRequested();\n    LogQueue = await \n        this.StateManager\n        .GetOrAddAsync<IReliableQueue\n        <IdempotentMessage<PurchaseInfo>>>(\"logQueue\");\n    var configurationPackage = Context\n        .CodePackageActivationContext\n        .GetConfigurationPackageObject(\"Config\");\n    ...\n    ...\n```", "```cs\nvar host = new HostBuilder()\n    .ConfigureServices((hostContext, services) =>\n    {\n        services.AddSingleton(this.StateManager);\n        services.AddSingleton(this.LogQueue);\n        services.AddSingleton(configurationPackage);\n        services.AddHostedService<ComputeStatistics>();\n    })\n    .Build();\nawait host.RunAsync(cancellationToken);\n```", "```cs\n<Parameter Name=\"FakeSource_InstanceCount\" DefaultValue=\"2\" />\n```", "```cs\nstring[] locations = new string[] { \"Florence\", \"London\", \"New York\", \"Paris\" };\n\nprotected override async Task RunAsync(CancellationToken cancellationToken)\n{\n    Random random = new Random();\n    while (true)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n\n        PurchaseInfo message = new PurchaseInfo\n        {\n            Time = DateTimeOffset.Now,\n            Location= locations[random.Next(0, locations.Length)],\n            Cost= 200m*random.Next(1, 4)\n        };\n        //Send message to counting microservices \n        ...\n        ...\n\n        await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);\n    }\n}\n```", "```cs\n//Send message to counting microservices \nvar partition = new ServicePartitionKey(Math.Abs(message.Location.GetHashCode()) % 1000);\nvar client = ServiceProxy.Create<ILogStore>(\n    new Uri(\"fabric:/PurchaseLogging/LogStore\"), partition);\ntry\n{\n    while (!await client.LogPurchase(new  \n    IdempotentMessage<PurchaseInfo>(message)))\n    {\n        await Task.Delay(TimeSpan.FromMilliseconds(100),   \n        cancellationToken);\n    }\n}\ncatch\n{\n\n}\n```", "```cs\nServicePartitionResolver resolver = ServicePartitionResolver.GetDefault();\n\nResolvedServicePartition partition =     \nawait resolver.ResolveAsync(new Uri(\"fabric:/MyApp/MyService\"), \n    new ServicePartitionKey(.....), cancellationToken);\n//look for a primary service only endpoint\nvar finalURI= partition.Endpoints.First(p => \n    p.Role == ServiceEndpointRole.StatefulPrimary).Addreess;\n\n```", "```cs\ntotal = newCounter.Update(item.Time, item.Cost);\nif (counter.HasValue)...//put breakpoint on this line\n```"]