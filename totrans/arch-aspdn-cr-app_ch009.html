<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>8 Dependency Injection</title>
<link href="../styles/stylesheet1.css" rel="stylesheet" type="text/css"/>
<link href="../styles/stylesheet2.css" rel="stylesheet" type="text/css"/>
<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>
<section class="level1 pkt" data-number="9" id="dependency-injection">
<h1 data-number="9"><span class="koboSpan" id="kobo.1.1" xmlns="http://www.w3.org/1999/xhtml">8 Dependency Injection</span></h1>
<section class="level2" data-number="9.1" id="before-you-begin-join-our-book-community-on-discord-7">
<h2 data-number="9.1"><span class="koboSpan" id="kobo.2.1" xmlns="http://www.w3.org/1999/xhtml">Before you begin: Join our book community on Discord</span></h2>
<p><span class="koboSpan" id="kobo.3.1" xmlns="http://www.w3.org/1999/xhtml">Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</span></p>
<p><a href="https://packt.link/EarlyAccess"><span class="koboSpan" id="kobo.4.1" xmlns="http://www.w3.org/1999/xhtml">https://packt.link/EarlyAccess</span></a></p>
<p><span class="koboSpan" id="kobo.5.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Qr code Description automatically generated" src="../media/file39.png" style="width:10em"/></span></p>
<p><span class="koboSpan" id="kobo.6.1" xmlns="http://www.w3.org/1999/xhtml">This chapter explores the ASP.NET Core </span><strong><span class="koboSpan" id="kobo.7.1" xmlns="http://www.w3.org/1999/xhtml">Dependency Injection</span></strong><span class="koboSpan" id="kobo.8.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.9.1" xmlns="http://www.w3.org/1999/xhtml">DI</span></strong><span class="koboSpan" id="kobo.10.1" xmlns="http://www.w3.org/1999/xhtml">) system, how to leverage it efficiently, and its limits and capabilities.We learn to compose objects using DI and delve into the Inversion of Control (IoC) principle. </span><span class="koboSpan" id="kobo.10.2" xmlns="http://www.w3.org/1999/xhtml">As we traverse the landscape of the built-in DI container, we explore its features and potential uses.Beyond practical examples, we lay down the conceptual foundation of Dependency Injection to understand its purpose, its benefits, and the problems it solves and to lay down the ground for the rest of the book as we rely heavily on DI.We then return to the first three Gang of Four (GoF) design patterns we encountered, but this time, through the lens of Dependency Injection. </span><span class="koboSpan" id="kobo.10.3" xmlns="http://www.w3.org/1999/xhtml">By refactoring these patterns using DI, we gain a more holistic understanding of how this powerful design tool influences the structure and flexibility of our software.Dependency Injection is a cornerstone in your path toward mastering modern application design and its transformative role in developing efficient, adaptable, testable, and maintainable software.In this chapter, we cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1" xmlns="http://www.w3.org/1999/xhtml">What is dependency injection?</span></li>
<li><span class="koboSpan" id="kobo.12.1" xmlns="http://www.w3.org/1999/xhtml">Revisiting the Strategy pattern</span></li>
<li><span class="koboSpan" id="kobo.13.1" xmlns="http://www.w3.org/1999/xhtml">Understanding guard clauses</span></li>
<li><span class="koboSpan" id="kobo.14.1" xmlns="http://www.w3.org/1999/xhtml">Revisiting the Singleton pattern</span></li>
<li><span class="koboSpan" id="kobo.15.1" xmlns="http://www.w3.org/1999/xhtml">Understanding the Service Locator pattern</span></li>
<li><span class="koboSpan" id="kobo.16.1" xmlns="http://www.w3.org/1999/xhtml">Revisiting the Factory pattern</span></li>
</ul>
</section>
<section class="level2" data-number="9.2" id="what-is-dependency-injection">
<h2 data-number="9.2"><span class="koboSpan" id="kobo.17.1" xmlns="http://www.w3.org/1999/xhtml">What is dependency injection?</span></h2>
<p><span class="koboSpan" id="kobo.18.1" xmlns="http://www.w3.org/1999/xhtml">DI is a way to apply the </span><strong><span class="koboSpan" id="kobo.19.1" xmlns="http://www.w3.org/1999/xhtml">Inversion of Control</span></strong><span class="koboSpan" id="kobo.20.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.21.1" xmlns="http://www.w3.org/1999/xhtml">IoC</span></strong><span class="koboSpan" id="kobo.22.1" xmlns="http://www.w3.org/1999/xhtml">) principle. </span><span class="koboSpan" id="kobo.22.2" xmlns="http://www.w3.org/1999/xhtml">IoC is a broader version of the dependency inversion principle (the </span><em><span class="koboSpan" id="kobo.23.1" xmlns="http://www.w3.org/1999/xhtml">D</span></em><span class="koboSpan" id="kobo.24.1" xmlns="http://www.w3.org/1999/xhtml"> in SOLID).The idea behind DI is to move the creation of dependencies from the objects themselves to the </span><strong><span class="koboSpan" id="kobo.25.1" xmlns="http://www.w3.org/1999/xhtml">composition root</span></strong><span class="koboSpan" id="kobo.26.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.26.2" xmlns="http://www.w3.org/1999/xhtml">That way, we can delegate the management of dependencies to an </span><strong><span class="koboSpan" id="kobo.27.1" xmlns="http://www.w3.org/1999/xhtml">IoC container</span></strong><span class="koboSpan" id="kobo.28.1" xmlns="http://www.w3.org/1999/xhtml">, which does the heavy lifting.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.29.1" xmlns="http://www.w3.org/1999/xhtml">An IoC container and a </span><strong><span class="koboSpan" id="kobo.30.1" xmlns="http://www.w3.org/1999/xhtml">DI container</span></strong><span class="koboSpan" id="kobo.31.1" xmlns="http://www.w3.org/1999/xhtml"> are the same thing—they’re just different words people use. </span><span class="koboSpan" id="kobo.31.2" xmlns="http://www.w3.org/1999/xhtml">I use both interchangeably in real life, but I stick to IoC container in the book because it seems more accurate than DI container.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.32.1" xmlns="http://www.w3.org/1999/xhtml">IoC is the concept (the principle), while DI is a way of inverting the flow of control (applying IoC). </span><span class="koboSpan" id="kobo.32.2" xmlns="http://www.w3.org/1999/xhtml">For example, you apply the IoC principle (inverting the flow) by injecting dependencies at runtime (doing DI) using a container. </span><span class="koboSpan" id="kobo.32.3" xmlns="http://www.w3.org/1999/xhtml">Feel free to use any or both.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.33.1" xmlns="http://www.w3.org/1999/xhtml">Next, we define the composition root.</span></p>
<section class="level3" data-number="9.2.1" id="the-composition-root">
<h3 data-number="9.2.1"><span class="koboSpan" id="kobo.34.1" xmlns="http://www.w3.org/1999/xhtml">The composition root</span></h3>
<p><span class="koboSpan" id="kobo.35.1" xmlns="http://www.w3.org/1999/xhtml">A critical concept behind DI is the composition root. </span><span class="koboSpan" id="kobo.35.2" xmlns="http://www.w3.org/1999/xhtml">The composition root is where we tell the container about our dependencies and their expected lifetime: where we compose our dependency trees. </span><span class="koboSpan" id="kobo.35.3" xmlns="http://www.w3.org/1999/xhtml">The composition root should be as close to the program's starting point as possible, so from ASP.NET Core 6 onward, the composition root is in the </span><code><span class="koboSpan" id="kobo.36.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.37.1" xmlns="http://www.w3.org/1999/xhtml"> file. </span><span class="koboSpan" id="kobo.37.2" xmlns="http://www.w3.org/1999/xhtml">In the previous versions, it was in the </span><code><span class="koboSpan" id="kobo.38.1" xmlns="http://www.w3.org/1999/xhtml">Program</span></code><span class="koboSpan" id="kobo.39.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.40.1" xmlns="http://www.w3.org/1999/xhtml">Startup</span></code><span class="koboSpan" id="kobo.41.1" xmlns="http://www.w3.org/1999/xhtml"> classes.Next, we explore how to leverage DI to create highly adaptable systems.</span></p>
</section>
<section class="level3" data-number="9.2.2" id="striving-for-adaptability">
<h3 data-number="9.2.2"><span class="koboSpan" id="kobo.42.1" xmlns="http://www.w3.org/1999/xhtml">Striving for adaptability</span></h3>
<p><span class="koboSpan" id="kobo.43.1" xmlns="http://www.w3.org/1999/xhtml">To achieve a high degree of flexibility with DI, we can apply the following formula, driven by the SOLID principles:Object </span><code><span class="koboSpan" id="kobo.44.1" xmlns="http://www.w3.org/1999/xhtml">A</span></code><span class="koboSpan" id="kobo.45.1" xmlns="http://www.w3.org/1999/xhtml"> should not know about object </span><code><span class="koboSpan" id="kobo.46.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.47.1" xmlns="http://www.w3.org/1999/xhtml"> that it is using. </span><span class="koboSpan" id="kobo.47.2" xmlns="http://www.w3.org/1999/xhtml">Instead, </span><code><span class="koboSpan" id="kobo.48.1" xmlns="http://www.w3.org/1999/xhtml">A</span></code><span class="koboSpan" id="kobo.49.1" xmlns="http://www.w3.org/1999/xhtml"> should use an interface, </span><code><span class="koboSpan" id="kobo.50.1" xmlns="http://www.w3.org/1999/xhtml">I</span></code><span class="koboSpan" id="kobo.51.1" xmlns="http://www.w3.org/1999/xhtml">, implemented by </span><code><span class="koboSpan" id="kobo.52.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.53.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><code><span class="koboSpan" id="kobo.54.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.55.1" xmlns="http://www.w3.org/1999/xhtml"> should be resolved and injected at runtime.Let’s decompose this:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.56.1" xmlns="http://www.w3.org/1999/xhtml">Object </span><code><span class="koboSpan" id="kobo.57.1" xmlns="http://www.w3.org/1999/xhtml">A</span></code><span class="koboSpan" id="kobo.58.1" xmlns="http://www.w3.org/1999/xhtml"> should depend on interface </span><code><span class="koboSpan" id="kobo.59.1" xmlns="http://www.w3.org/1999/xhtml">I</span></code><span class="koboSpan" id="kobo.60.1" xmlns="http://www.w3.org/1999/xhtml"> instead of concrete type </span><code><span class="koboSpan" id="kobo.61.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.62.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.63.1" xmlns="http://www.w3.org/1999/xhtml">Instance </span><code><span class="koboSpan" id="kobo.64.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.65.1" xmlns="http://www.w3.org/1999/xhtml">, injected into </span><code><span class="koboSpan" id="kobo.66.1" xmlns="http://www.w3.org/1999/xhtml">A</span></code><span class="koboSpan" id="kobo.67.1" xmlns="http://www.w3.org/1999/xhtml">, should be resolved by the IoC container at runtime.</span></li>
<li><code><span class="koboSpan" id="kobo.68.1" xmlns="http://www.w3.org/1999/xhtml">A</span></code><span class="koboSpan" id="kobo.69.1" xmlns="http://www.w3.org/1999/xhtml"> should not be aware of the existence of </span><code><span class="koboSpan" id="kobo.70.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.71.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><code><span class="koboSpan" id="kobo.72.1" xmlns="http://www.w3.org/1999/xhtml">A</span></code><span class="koboSpan" id="kobo.73.1" xmlns="http://www.w3.org/1999/xhtml"> should not control the lifetime of </span><code><span class="koboSpan" id="kobo.74.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.75.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.76.1" xmlns="http://www.w3.org/1999/xhtml">We can also inject objects directly without passing by an interface. </span><span class="koboSpan" id="kobo.76.2" xmlns="http://www.w3.org/1999/xhtml">It all depends on what we inject, in what context, and our requirements. </span><span class="koboSpan" id="kobo.76.3" xmlns="http://www.w3.org/1999/xhtml">We tackle many use cases throughout the book to help you understand DI.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.77.1" xmlns="http://www.w3.org/1999/xhtml">Next, we translate this equation into an analogy that helps explain the reasons to use a container.</span></p>
</section>
<section class="level3" data-number="9.2.3" id="understanding-the-use-of-the-ioc-container">
<h3 data-number="9.2.3"><span class="koboSpan" id="kobo.78.1" xmlns="http://www.w3.org/1999/xhtml">Understanding the use of the IoC container</span></h3>
<p><span class="koboSpan" id="kobo.79.1" xmlns="http://www.w3.org/1999/xhtml">To better understand the use of the IoC container and to create an image around the previous adaptability concept, let’s start with a LEGO® analogy where IoC is the equivalent of drawing a plan to build a LEGO®castle:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.80.1" xmlns="http://www.w3.org/1999/xhtml">We draw the plan</span></li>
<li><span class="koboSpan" id="kobo.81.1" xmlns="http://www.w3.org/1999/xhtml">We gather the blocks</span></li>
<li><span class="koboSpan" id="kobo.82.1" xmlns="http://www.w3.org/1999/xhtml">We press the start button on a hypothetical robot builder</span></li>
<li><span class="koboSpan" id="kobo.83.1" xmlns="http://www.w3.org/1999/xhtml">The robot assembles the blocks by following our plan</span></li>
<li><span class="koboSpan" id="kobo.84.1" xmlns="http://www.w3.org/1999/xhtml">The castle is complete</span></li>
</ol>
<p><span class="koboSpan" id="kobo.85.1" xmlns="http://www.w3.org/1999/xhtml">By following this logic, we can create a new 4x4 block with a unicorn painted on its side (concrete type), update the plan (composition root), and then press the restart button to rebuild the castle with that new block inserted into it, replacing the old one without affecting the structural integrity of the castle (program). </span><span class="koboSpan" id="kobo.85.2" xmlns="http://www.w3.org/1999/xhtml">As long as we respect the 4x4 block contract (interface), everything is updatable without impacting the rest of the castle, leading to great flexibility.Following that idea, if we need to manage every single LEGO® block one by one, it would quickly become incredibly complex! </span><span class="koboSpan" id="kobo.85.3" xmlns="http://www.w3.org/1999/xhtml">Therefore, managing all dependencies by hand in a project would be super tedious and error-prone, even in the smallest program. </span><span class="koboSpan" id="kobo.85.4" xmlns="http://www.w3.org/1999/xhtml">This situation is where an IoC container (the hypothetical robot builder) comes into play.</span></p>
</section>
<section class="level3" data-number="9.2.4" id="the-role-of-an-ioc-container">
<h3 data-number="9.2.4"><span class="koboSpan" id="kobo.86.1" xmlns="http://www.w3.org/1999/xhtml">The role of an IoC container</span></h3>
<p><span class="koboSpan" id="kobo.87.1" xmlns="http://www.w3.org/1999/xhtml">An IoC container manages objects for us. </span><span class="koboSpan" id="kobo.87.2" xmlns="http://www.w3.org/1999/xhtml">We configure it, and then, when we ask for a service, the container resolves and injects it. </span><span class="koboSpan" id="kobo.87.3" xmlns="http://www.w3.org/1999/xhtml">On top of that, the container manages the lifetime of dependencies, leaving our classes to do only one thing, the job we designed them to do. </span><span class="koboSpan" id="kobo.87.4" xmlns="http://www.w3.org/1999/xhtml">No more need to think about their dependencies!The bottom line is that an IoC container is a DI framework that does the auto-wiring for us. </span><span class="koboSpan" id="kobo.87.5" xmlns="http://www.w3.org/1999/xhtml">We can conceptualize Dependency Injection as follows:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.88.1" xmlns="http://www.w3.org/1999/xhtml">The </span><em><span class="koboSpan" id="kobo.89.1" xmlns="http://www.w3.org/1999/xhtml">consumer</span></em><span class="koboSpan" id="kobo.90.1" xmlns="http://www.w3.org/1999/xhtml"> of a dependency states its needs about one or more dependencies (contracts).</span></li>
<li><span class="koboSpan" id="kobo.91.1" xmlns="http://www.w3.org/1999/xhtml">The IoC container injects that dependency (implementation) upon creating the </span><em><span class="koboSpan" id="kobo.92.1" xmlns="http://www.w3.org/1999/xhtml">consumer</span></em><span class="koboSpan" id="kobo.93.1" xmlns="http://www.w3.org/1999/xhtml">, fulfilling its needs at runtime.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.94.1" xmlns="http://www.w3.org/1999/xhtml">Next, we explore an code smell that applying Dependency Injection helps us avoid.</span></p>
</section>
<section class="level3" data-number="9.2.5" id="code-smell-control-freak-1">
<h3 data-number="9.2.5"><span class="koboSpan" id="kobo.95.1" xmlns="http://www.w3.org/1999/xhtml">Code smell – Control Freak</span></h3>
<p><span class="koboSpan" id="kobo.96.1" xmlns="http://www.w3.org/1999/xhtml">Control freak is a code smell and even an anti-pattern that forbids us from using the </span><code><span class="koboSpan" id="kobo.97.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.98.1" xmlns="http://www.w3.org/1999/xhtml"> keyword. </span><span class="koboSpan" id="kobo.98.2" xmlns="http://www.w3.org/1999/xhtml">Yes, using the </span><code><span class="koboSpan" id="kobo.99.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.100.1" xmlns="http://www.w3.org/1999/xhtml"> keyword is the code smell! </span><span class="koboSpan" id="kobo.100.2" xmlns="http://www.w3.org/1999/xhtml">The following code is wrong and can’t leverage DI:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.101.1" xmlns="http://www.w3.org/1999/xhtml">namespace CompositionRoot.ControlFreak;
public class Consumer
{
    public void Do()
    {
        var dependency = new Dependency();
        dependency.Operation();
    }
}
public class Dependency
{
    public void Operation()
        =&gt; throw new NotImplementedException();
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.102.1" xmlns="http://www.w3.org/1999/xhtml">The highlighted line shows the anti-pattern in action. </span><span class="koboSpan" id="kobo.102.2" xmlns="http://www.w3.org/1999/xhtml">To enable the Consumer class to use dependency injection, we could update it like the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.103.1" xmlns="http://www.w3.org/1999/xhtml">public class Consumer
{
    private readonly Dependency _dependency;
    public DIEnabledConsumer(Dependency dependency)
    {
        _dependency = dependency;
    }
    public void Do()
    {
        _dependency.Operation();
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.104.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code removes the new keyword and is now open for modification. </span><span class="koboSpan" id="kobo.104.2" xmlns="http://www.w3.org/1999/xhtml">The highlighted lines represent the constructor injection pattern we explore subsequently in this chapter.Nevertheless, do not ban the </span><code><span class="koboSpan" id="kobo.105.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.106.1" xmlns="http://www.w3.org/1999/xhtml"> keyword just yet. </span><span class="koboSpan" id="kobo.106.2" xmlns="http://www.w3.org/1999/xhtml">Instead, every time you use it, ask yourself whether the object you instantiated using the </span><code><span class="koboSpan" id="kobo.107.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.108.1" xmlns="http://www.w3.org/1999/xhtml"> keyword is a dependency that could be managed by the container and injected instead.To help with that, I borrowed two terms from Mark Seemann’s book </span><em><span class="koboSpan" id="kobo.109.1" xmlns="http://www.w3.org/1999/xhtml">Dependency Injection in .NET</span></em><span class="koboSpan" id="kobo.110.1" xmlns="http://www.w3.org/1999/xhtml">; the name </span><em><span class="koboSpan" id="kobo.111.1" xmlns="http://www.w3.org/1999/xhtml">Control Freak</span></em><span class="koboSpan" id="kobo.112.1" xmlns="http://www.w3.org/1999/xhtml"> also comes from that book. </span><span class="koboSpan" id="kobo.112.2" xmlns="http://www.w3.org/1999/xhtml">He describes the following two categories of dependencies:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.113.1" xmlns="http://www.w3.org/1999/xhtml">Stable dependencies</span></li>
<li><span class="koboSpan" id="kobo.114.1" xmlns="http://www.w3.org/1999/xhtml">Volatile dependencies</span></li>
</ul>
<p><span class="koboSpan" id="kobo.115.1" xmlns="http://www.w3.org/1999/xhtml">Next is my take on defining them.</span></p>
<section class="level4" data-number="9.2.5.1" id="stable-dependencies">
<h4 data-number="9.2.5.1"><span class="koboSpan" id="kobo.116.1" xmlns="http://www.w3.org/1999/xhtml">Stable dependencies</span></h4>
<p><strong><span class="koboSpan" id="kobo.117.1" xmlns="http://www.w3.org/1999/xhtml">Stable dependencies</span></strong><span class="koboSpan" id="kobo.118.1" xmlns="http://www.w3.org/1999/xhtml"> should not break our application when a new version is released. </span><span class="koboSpan" id="kobo.118.2" xmlns="http://www.w3.org/1999/xhtml">They should use deterministic algorithms (input </span><code><span class="koboSpan" id="kobo.119.1" xmlns="http://www.w3.org/1999/xhtml">X</span></code><span class="koboSpan" id="kobo.120.1" xmlns="http://www.w3.org/1999/xhtml"> should always produce output </span><code><span class="koboSpan" id="kobo.121.1" xmlns="http://www.w3.org/1999/xhtml">Y</span></code><span class="koboSpan" id="kobo.122.1" xmlns="http://www.w3.org/1999/xhtml">), and you should not expect to change them with something else in the future.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.123.1" xmlns="http://www.w3.org/1999/xhtml">Most data structures devoided of behaviors, like Data Transfer Objects (DTOs), fall into this category. </span><span class="koboSpan" id="kobo.123.2" xmlns="http://www.w3.org/1999/xhtml">You can also consider the .NET BCL as stable dependencies.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.124.1" xmlns="http://www.w3.org/1999/xhtml">We can still instantiate objects using the </span><code><span class="koboSpan" id="kobo.125.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.126.1" xmlns="http://www.w3.org/1999/xhtml"> keyword when they fall into this category because the dependencies are stable and unlikely to break anything if they change.Next, we look at their counterpart.</span></p>
</section>
<section class="level4" data-number="9.2.5.2" id="volatile-dependencies">
<h4 data-number="9.2.5.2"><span class="koboSpan" id="kobo.127.1" xmlns="http://www.w3.org/1999/xhtml">Volatile dependencies</span></h4>
<p><strong><span class="koboSpan" id="kobo.128.1" xmlns="http://www.w3.org/1999/xhtml">Volatile dependencies</span></strong><span class="koboSpan" id="kobo.129.1" xmlns="http://www.w3.org/1999/xhtml"> can change at runtime, like extendable elements with contextual behaviors. </span><span class="koboSpan" id="kobo.129.2" xmlns="http://www.w3.org/1999/xhtml">They may also be likely to change for various reasons like new features development.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.130.1" xmlns="http://www.w3.org/1999/xhtml">Most classes we create, such as data access and business logic code, are volatile dependencies.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.131.1" xmlns="http://www.w3.org/1999/xhtml">The primary way to break the tight coupling between classes is to rely on interfaces and DI and no longer instantiate those volatile dependencies using the </span><code><span class="koboSpan" id="kobo.132.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.133.1" xmlns="http://www.w3.org/1999/xhtml"> keyword. </span><span class="koboSpan" id="kobo.133.2" xmlns="http://www.w3.org/1999/xhtml">Volatile dependencies are why dependency injection is key to building flexible, testable, and maintainable software.</span></p>
</section>
<section class="level4" data-number="9.2.5.3" id="conclusion-11">
<h4 data-number="9.2.5.3"><span class="koboSpan" id="kobo.134.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h4>
<p><span class="koboSpan" id="kobo.135.1" xmlns="http://www.w3.org/1999/xhtml">To conclude this interlude: don’t be a control freak anymore; those days are behind you!</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.136.1" xmlns="http://www.w3.org/1999/xhtml">When in doubt, inject the dependency instead of using the </span><code><span class="koboSpan" id="kobo.137.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.138.1" xmlns="http://www.w3.org/1999/xhtml"> keyword.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.139.1" xmlns="http://www.w3.org/1999/xhtml">Next, we explore the available lifetimes we can attribute to our volatile dependencies.</span></p>
</section>
</section>
<section class="level3" data-number="9.2.6" id="object-lifetime">
<h3 data-number="9.2.6"><span class="koboSpan" id="kobo.140.1" xmlns="http://www.w3.org/1999/xhtml">Object lifetime</span></h3>
<p><span class="koboSpan" id="kobo.141.1" xmlns="http://www.w3.org/1999/xhtml">Now that we understand we should no longer use the </span><code><span class="koboSpan" id="kobo.142.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.143.1" xmlns="http://www.w3.org/1999/xhtml"> keyword, we need a way to create those classes. </span><span class="koboSpan" id="kobo.143.2" xmlns="http://www.w3.org/1999/xhtml">From now on, the IoC container will play that role and manage object instantiation and their lifetime for us.</span></p>
<section class="level4" data-number="9.2.6.1" id="whats-an-objects-lifetime">
<h4 data-number="9.2.6.1"><span class="koboSpan" id="kobo.144.1" xmlns="http://www.w3.org/1999/xhtml">What’s an object's lifetime?</span></h4>
<p><span class="koboSpan" id="kobo.145.1" xmlns="http://www.w3.org/1999/xhtml">When we create an instance manually, using the </span><code><span class="koboSpan" id="kobo.146.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.147.1" xmlns="http://www.w3.org/1999/xhtml"> keyword, we create a hold on that object; we know when we create it and when its life ends. </span><span class="koboSpan" id="kobo.147.2" xmlns="http://www.w3.org/1999/xhtml">That’s the lifetime of the object.Of course, using the </span><code><span class="koboSpan" id="kobo.148.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.149.1" xmlns="http://www.w3.org/1999/xhtml"> keyword leaves no chance to control these objects from the outside, enhance them, intercept them, or swap them for another implementation—as covered in the preceding </span><em><span class="koboSpan" id="kobo.150.1" xmlns="http://www.w3.org/1999/xhtml">Code smell – Control Freak</span></em><span class="koboSpan" id="kobo.151.1" xmlns="http://www.w3.org/1999/xhtml"> section.</span></p>
</section>
<section class="level4" data-number="9.2.6.2" id="net-object-lifetime">
<h4 data-number="9.2.6.2"><span class="koboSpan" id="kobo.152.1" xmlns="http://www.w3.org/1999/xhtml">.NET object lifetime</span></h4>
<p><span class="koboSpan" id="kobo.153.1" xmlns="http://www.w3.org/1999/xhtml">With dependency injection, we need to forget about controlling objects and start to think about using dependencies, or more explicitly, depending on their interfaces. </span><span class="koboSpan" id="kobo.153.2" xmlns="http://www.w3.org/1999/xhtml">In ASP.NET Core, there are three possible lifetimes to choose from:</span></p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong><span class="koboSpan" id="kobo.154.1" xmlns="http://www.w3.org/1999/xhtml">Lifetime</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.155.1" xmlns="http://www.w3.org/1999/xhtml">Description</span></strong></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.156.1" xmlns="http://www.w3.org/1999/xhtml">Transient</span></td>
<td><span class="koboSpan" id="kobo.157.1" xmlns="http://www.w3.org/1999/xhtml">The container creates a new instance every time.</span></td>
</tr>
<tr class="odd">
<td><span class="koboSpan" id="kobo.158.1" xmlns="http://www.w3.org/1999/xhtml">Scoped</span></td>
<td><p><span class="koboSpan" id="kobo.159.1" xmlns="http://www.w3.org/1999/xhtml">The container creates an instance per HTTP request and reuses it.</span></p>
<p><span class="koboSpan" id="kobo.160.1" xmlns="http://www.w3.org/1999/xhtml">In some rare cases, we can also create custom scopes.</span></p></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.161.1" xmlns="http://www.w3.org/1999/xhtml">Singleton</span></td>
<td><span class="koboSpan" id="kobo.162.1" xmlns="http://www.w3.org/1999/xhtml">The container creates a single instance of that dependency and always reuses that unique object.</span></td>
</tr>
</tbody>
</table><span class="koboSpan" id="kobo.163.1" xmlns="http://www.w3.org/1999/xhtml">
Table 8.1: objects lifetime description
</span><p><span class="koboSpan" id="kobo.164.1" xmlns="http://www.w3.org/1999/xhtml">We can now manage our volatile dependencies using one of those three scopes. </span><span class="koboSpan" id="kobo.164.2" xmlns="http://www.w3.org/1999/xhtml">Here are some questions to help you choose:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.165.1" xmlns="http://www.w3.org/1999/xhtml">Do I need a single instance of my dependency? </span><span class="koboSpan" id="kobo.165.2" xmlns="http://www.w3.org/1999/xhtml">Yes? </span><span class="koboSpan" id="kobo.165.3" xmlns="http://www.w3.org/1999/xhtml">Use the </span><strong><span class="koboSpan" id="kobo.166.1" xmlns="http://www.w3.org/1999/xhtml">singleton</span></strong><span class="koboSpan" id="kobo.167.1" xmlns="http://www.w3.org/1999/xhtml"> lifetime.</span></li>
<li><span class="koboSpan" id="kobo.168.1" xmlns="http://www.w3.org/1999/xhtml">Do I need a single instance of my dependency shared over an HTTP request? </span><span class="koboSpan" id="kobo.168.2" xmlns="http://www.w3.org/1999/xhtml">Yes? </span><span class="koboSpan" id="kobo.168.3" xmlns="http://www.w3.org/1999/xhtml">Use the </span><strong><span class="koboSpan" id="kobo.169.1" xmlns="http://www.w3.org/1999/xhtml">scoped</span></strong><span class="koboSpan" id="kobo.170.1" xmlns="http://www.w3.org/1999/xhtml"> lifetime.</span></li>
<li><span class="koboSpan" id="kobo.171.1" xmlns="http://www.w3.org/1999/xhtml">Do I need a new instance of my dependency every time? </span><span class="koboSpan" id="kobo.171.2" xmlns="http://www.w3.org/1999/xhtml">Yes? </span><span class="koboSpan" id="kobo.171.3" xmlns="http://www.w3.org/1999/xhtml">Use the </span><strong><span class="koboSpan" id="kobo.172.1" xmlns="http://www.w3.org/1999/xhtml">transient</span></strong><span class="koboSpan" id="kobo.173.1" xmlns="http://www.w3.org/1999/xhtml"> lifetime.</span></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.174.1" xmlns="http://www.w3.org/1999/xhtml">A general approach to object lifetime is to design the components to be </span><em><span class="koboSpan" id="kobo.175.1" xmlns="http://www.w3.org/1999/xhtml">singletons</span></em><span class="koboSpan" id="kobo.176.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.176.2" xmlns="http://www.w3.org/1999/xhtml">When impossible, we go for </span><em><span class="koboSpan" id="kobo.177.1" xmlns="http://www.w3.org/1999/xhtml">scoped</span></em><span class="koboSpan" id="kobo.178.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.178.2" xmlns="http://www.w3.org/1999/xhtml">When </span><em><span class="koboSpan" id="kobo.179.1" xmlns="http://www.w3.org/1999/xhtml">scoped</span></em><span class="koboSpan" id="kobo.180.1" xmlns="http://www.w3.org/1999/xhtml"> is also impossible, go for </span><em><span class="koboSpan" id="kobo.181.1" xmlns="http://www.w3.org/1999/xhtml">transient</span></em><span class="koboSpan" id="kobo.182.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.182.2" xmlns="http://www.w3.org/1999/xhtml">This way, we maximize instance reuse, lower the overhead of creating objects, lower the memory cost of keeping those objects in memory, and lower the amount of garbage collection needed to remove unused instances.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.183.1" xmlns="http://www.w3.org/1999/xhtml">For example, we can pick </span><em><span class="koboSpan" id="kobo.184.1" xmlns="http://www.w3.org/1999/xhtml">singleton</span></em><span class="koboSpan" id="kobo.185.1" xmlns="http://www.w3.org/1999/xhtml"> mindlessly for stateless objects, which are the easiest to maintain and less likely to break.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.186.1" xmlns="http://www.w3.org/1999/xhtml">For stateful objects, where multiple consumers use the same instance, we must ensure the object is thread-safe if the lifetime is </span><em><span class="koboSpan" id="kobo.187.1" xmlns="http://www.w3.org/1999/xhtml">singleton</span></em><span class="koboSpan" id="kobo.188.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><em><span class="koboSpan" id="kobo.189.1" xmlns="http://www.w3.org/1999/xhtml">scoped</span></em><span class="koboSpan" id="kobo.190.1" xmlns="http://www.w3.org/1999/xhtml"> because multiple consumers could try to access it simultaneously.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.191.1" xmlns="http://www.w3.org/1999/xhtml">One essential aspect to consider when choosing a lifetime is the consumers of stateful objects. </span><span class="koboSpan" id="kobo.191.2" xmlns="http://www.w3.org/1999/xhtml">For example, if we load data related to the current user, we must ensure that data do not leak to other users. </span><span class="koboSpan" id="kobo.191.3" xmlns="http://www.w3.org/1999/xhtml">To do so, we can define the lifetime of that object to </span><em><span class="koboSpan" id="kobo.192.1" xmlns="http://www.w3.org/1999/xhtml">scoped</span></em><span class="koboSpan" id="kobo.193.1" xmlns="http://www.w3.org/1999/xhtml">, which is limited to a single HTTP request. </span><span class="koboSpan" id="kobo.193.2" xmlns="http://www.w3.org/1999/xhtml">If we don’t want to reuse that state between multiple consumers, we can choose a </span><em><span class="koboSpan" id="kobo.194.1" xmlns="http://www.w3.org/1999/xhtml">transient</span></em><span class="koboSpan" id="kobo.195.1" xmlns="http://www.w3.org/1999/xhtml"> lifetime to ensure every consumer gets their own instance.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.196.1" xmlns="http://www.w3.org/1999/xhtml">How does that translate into code? </span><span class="koboSpan" id="kobo.196.2" xmlns="http://www.w3.org/1999/xhtml">.NET offers multiple extension methods to help us configure the lifetimes of our objects, like </span><code><span class="koboSpan" id="kobo.197.1" xmlns="http://www.w3.org/1999/xhtml">AddTransient</span></code><span class="koboSpan" id="kobo.198.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.199.1" xmlns="http://www.w3.org/1999/xhtml">AddScoped</span></code><span class="koboSpan" id="kobo.200.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><code><span class="koboSpan" id="kobo.201.1" xmlns="http://www.w3.org/1999/xhtml">AddSingleton</span></code><span class="koboSpan" id="kobo.202.1" xmlns="http://www.w3.org/1999/xhtml">, which explicitly state their lifetimes.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.203.1" xmlns="http://www.w3.org/1999/xhtml">We use the built-in container throughout the book with many of its registration methods, so you should grow familiar with it very quickly. </span><span class="koboSpan" id="kobo.203.2" xmlns="http://www.w3.org/1999/xhtml">It has good discoverability, so you can explore the possibilities using IntelliSense while writing code or reading the documentation.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.204.1" xmlns="http://www.w3.org/1999/xhtml">Next, we use those methods and explore how to register dependencies with the container.</span></p>
</section>
</section>
<section class="level3" data-number="9.2.7" id="registering-our-dependencies">
<h3 data-number="9.2.7"><span class="koboSpan" id="kobo.205.1" xmlns="http://www.w3.org/1999/xhtml">Registering our dependencies</span></h3>
<p><span class="koboSpan" id="kobo.206.1" xmlns="http://www.w3.org/1999/xhtml">In ASP.NET Core, we register our dependencies in the </span><code><span class="koboSpan" id="kobo.207.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.208.1" xmlns="http://www.w3.org/1999/xhtml"> file, which represents the composition root. </span><span class="koboSpan" id="kobo.208.2" xmlns="http://www.w3.org/1999/xhtml">Since the minimal hosting model, the </span><code><span class="koboSpan" id="kobo.209.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationBuilder</span></code><span class="koboSpan" id="kobo.210.1" xmlns="http://www.w3.org/1999/xhtml"> exposes the </span><code><span class="koboSpan" id="kobo.211.1" xmlns="http://www.w3.org/1999/xhtml">Services</span></code><span class="koboSpan" id="kobo.212.1" xmlns="http://www.w3.org/1999/xhtml"> property we use to add our dependencies to the container. </span><span class="koboSpan" id="kobo.212.2" xmlns="http://www.w3.org/1999/xhtml">Afterward, .NET creates the container when it builds the </span><code><span class="koboSpan" id="kobo.213.1" xmlns="http://www.w3.org/1999/xhtml">WebApplication</span></code><span class="koboSpan" id="kobo.214.1" xmlns="http://www.w3.org/1999/xhtml"> instance.Next is a minimal </span><code><span class="koboSpan" id="kobo.215.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.216.1" xmlns="http://www.w3.org/1999/xhtml"> file depicting this concept:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.217.1" xmlns="http://www.w3.org/1999/xhtml">var builder = WebApplication.CreateBuilder(args);
// Register dependencies
var app = builder.Build();
// The IoC container is now available
app.Run();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.218.1" xmlns="http://www.w3.org/1999/xhtml">Then, we use the </span><code><span class="koboSpan" id="kobo.219.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services</span></code><span class="koboSpan" id="kobo.220.1" xmlns="http://www.w3.org/1999/xhtml"> property to register our dependencies in that </span><code><span class="koboSpan" id="kobo.221.1" xmlns="http://www.w3.org/1999/xhtml">IServiceCollection</span></code><span class="koboSpan" id="kobo.222.1" xmlns="http://www.w3.org/1999/xhtml"> implementation. </span><span class="koboSpan" id="kobo.222.2" xmlns="http://www.w3.org/1999/xhtml">Here’s an example of registering some dependencies:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.223.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddSingleton&lt;Dependency1&gt;();
builder.Services.AddSingleton&lt;Dependency2&gt;();
builder.Services.AddSingleton&lt;Dependency3&gt;();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.224.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code registers the dependencies using the singleton lifetime, so we get the same instance each time we request one.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.225.1" xmlns="http://www.w3.org/1999/xhtml">Remember to compose the program in the composition root. </span><span class="koboSpan" id="kobo.225.2" xmlns="http://www.w3.org/1999/xhtml">That removes the need for those pesky </span><code><span class="koboSpan" id="kobo.226.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.227.1" xmlns="http://www.w3.org/1999/xhtml"> keywords spread around your code base and all the tight coupling that come with them. </span><span class="koboSpan" id="kobo.227.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, it centralizes the application’s composition into that location, creating the plan to assemble the LEGO® blocks.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.228.1" xmlns="http://www.w3.org/1999/xhtml">As you may be thinking right now, that can lead to a lot of registration statements in a single location, and you are correct; maintaining such a composition root would be a challenge in almost any application. </span><span class="koboSpan" id="kobo.228.2" xmlns="http://www.w3.org/1999/xhtml">To address this concern, we introduce an elegant way to encapsulate the registration code next, ensuring it remains manageable.</span></p>
</section>
<section class="level3" data-number="9.2.8" id="registering-your-features-elegantly">
<h3 data-number="9.2.8"><span class="koboSpan" id="kobo.229.1" xmlns="http://www.w3.org/1999/xhtml">Registering your features elegantly</span></h3>
<p><span class="koboSpan" id="kobo.230.1" xmlns="http://www.w3.org/1999/xhtml">As we've just discovered, while we should register dependencies in the composition root, we can also arrange our registration code in a structured manner. </span><span class="koboSpan" id="kobo.230.2" xmlns="http://www.w3.org/1999/xhtml">For example, we can break down our application's composition into several methods or classes and invoke them from our composition root. </span><span class="koboSpan" id="kobo.230.3" xmlns="http://www.w3.org/1999/xhtml">Another strategy could be to use an auto-discovery system to automate the registration of certain services.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.231.1" xmlns="http://www.w3.org/1999/xhtml">The critical part is to centralize the program composition in one place.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.232.1" xmlns="http://www.w3.org/1999/xhtml">A common pattern in ASP.NET Core is having special methods like </span><code><span class="koboSpan" id="kobo.233.1" xmlns="http://www.w3.org/1999/xhtml">Add[Feature name]</span></code><span class="koboSpan" id="kobo.234.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.234.2" xmlns="http://www.w3.org/1999/xhtml">These methods register their dependencies, letting us add a group of dependencies with just one method call. </span><span class="koboSpan" id="kobo.234.3" xmlns="http://www.w3.org/1999/xhtml">This pattern is convenient for breaking down program composition into smaller, easier-to-handle parts, like individual features. </span><span class="koboSpan" id="kobo.234.4" xmlns="http://www.w3.org/1999/xhtml">This also makes the composition root more readable.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.235.1" xmlns="http://www.w3.org/1999/xhtml">A feature is the correct size as long as it stays cohesive. </span><span class="koboSpan" id="kobo.235.2" xmlns="http://www.w3.org/1999/xhtml">If your feature becomes too big, does too many things, or starts to share dependencies with other features, it may be time for a redesign before losing control over it. </span><span class="koboSpan" id="kobo.235.3" xmlns="http://www.w3.org/1999/xhtml">That’s usually a good indicator of undesired coupling.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.236.1" xmlns="http://www.w3.org/1999/xhtml">To implement this pattern, we use extension methods, making it trivial. </span><span class="koboSpan" id="kobo.236.2" xmlns="http://www.w3.org/1999/xhtml">Here’s a guide:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.237.1" xmlns="http://www.w3.org/1999/xhtml">Create a static class named </span><code><span class="koboSpan" id="kobo.238.1" xmlns="http://www.w3.org/1999/xhtml">[subject]Extensions</span></code><span class="koboSpan" id="kobo.239.1" xmlns="http://www.w3.org/1999/xhtml"> in the </span><code><span class="koboSpan" id="kobo.240.1" xmlns="http://www.w3.org/1999/xhtml">Microsoft.Extensions.DependencyInjection</span></code><span class="koboSpan" id="kobo.241.1" xmlns="http://www.w3.org/1999/xhtml"> namespace.</span></li>
<li><span class="koboSpan" id="kobo.242.1" xmlns="http://www.w3.org/1999/xhtml">Create an extension method that returns the </span><code><span class="koboSpan" id="kobo.243.1" xmlns="http://www.w3.org/1999/xhtml">IServiceCollection</span></code><span class="koboSpan" id="kobo.244.1" xmlns="http://www.w3.org/1999/xhtml"> interface, which allows method calls to be chained.</span></li>
</ol>
<blockquote>
<p><span class="koboSpan" id="kobo.245.1" xmlns="http://www.w3.org/1999/xhtml">According to Microsoft's recommendation, we should create the class in the same namespace as the element we extend. </span><span class="koboSpan" id="kobo.245.2" xmlns="http://www.w3.org/1999/xhtml">In our case, the </span><code><span class="koboSpan" id="kobo.246.1" xmlns="http://www.w3.org/1999/xhtml">IServiceCollection</span></code><span class="koboSpan" id="kobo.247.1" xmlns="http://www.w3.org/1999/xhtml"> interface lives in the </span><code><span class="koboSpan" id="kobo.248.1" xmlns="http://www.w3.org/1999/xhtml">Microsoft.Extensions.DependencyInjection</span></code><span class="koboSpan" id="kobo.249.1" xmlns="http://www.w3.org/1999/xhtml"> namespace.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.250.1" xmlns="http://www.w3.org/1999/xhtml">Of course, this is not mandatory, and we can adapt this process to our needs. </span><span class="koboSpan" id="kobo.250.2" xmlns="http://www.w3.org/1999/xhtml">For example, we can define the class in another namespace if we want consumers to add a </span><code><span class="koboSpan" id="kobo.251.1" xmlns="http://www.w3.org/1999/xhtml">using</span></code><span class="koboSpan" id="kobo.252.1" xmlns="http://www.w3.org/1999/xhtml"> statement implicitly. </span><span class="koboSpan" id="kobo.252.2" xmlns="http://www.w3.org/1999/xhtml">We can also return something else when the registration process can continue beyond that first method, like a builder interface.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.253.1" xmlns="http://www.w3.org/1999/xhtml">Builder interfaces are used to configure more complex features, like ASP.NET Core MVC. </span><span class="koboSpan" id="kobo.253.2" xmlns="http://www.w3.org/1999/xhtml">For example, the </span><code><span class="koboSpan" id="kobo.254.1" xmlns="http://www.w3.org/1999/xhtml">AddControllers</span></code><span class="koboSpan" id="kobo.255.1" xmlns="http://www.w3.org/1999/xhtml"> extension method returns an </span><code><span class="koboSpan" id="kobo.256.1" xmlns="http://www.w3.org/1999/xhtml">IMvcBuilder</span></code><span class="koboSpan" id="kobo.257.1" xmlns="http://www.w3.org/1999/xhtml"> interface that contains a </span><code><span class="koboSpan" id="kobo.258.1" xmlns="http://www.w3.org/1999/xhtml">PartManager</span></code><span class="koboSpan" id="kobo.259.1" xmlns="http://www.w3.org/1999/xhtml"> property. </span><span class="koboSpan" id="kobo.259.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, some extension methods target the </span><code><span class="koboSpan" id="kobo.260.1" xmlns="http://www.w3.org/1999/xhtml">IMvcBuilder</span></code><span class="koboSpan" id="kobo.261.1" xmlns="http://www.w3.org/1999/xhtml"> interface, allowing further configuration of the feature by requiring its registration first; that is, you can’t configure </span><code><span class="koboSpan" id="kobo.262.1" xmlns="http://www.w3.org/1999/xhtml">IMvcBuilder</span></code><span class="koboSpan" id="kobo.263.1" xmlns="http://www.w3.org/1999/xhtml"> before calling </span><code><span class="koboSpan" id="kobo.264.1" xmlns="http://www.w3.org/1999/xhtml">AddControllers</span></code><span class="koboSpan" id="kobo.265.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.265.2" xmlns="http://www.w3.org/1999/xhtml">You can also design your features to leverage that pattern when needed.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.266.1" xmlns="http://www.w3.org/1999/xhtml">Let’s explore a demo.</span></p>
<section class="level4" data-number="9.2.8.1" id="project-registering-the-demo-feature">
<h4 data-number="9.2.8.1"><span class="koboSpan" id="kobo.267.1" xmlns="http://www.w3.org/1999/xhtml">Project – Registering the Demo Feature</span></h4>
<p><span class="koboSpan" id="kobo.268.1" xmlns="http://www.w3.org/1999/xhtml">Let’s explore registering the dependencies of the Demo Feature. </span><span class="koboSpan" id="kobo.268.2" xmlns="http://www.w3.org/1999/xhtml">That feature contains the following code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.269.1" xmlns="http://www.w3.org/1999/xhtml">namespace CompositionRoot.DemoFeature;
public class MyFeature
{
    private readonly IMyFeatureDependency _myFeatureDependency;
    public MyFeature(IMyFeatureDependency myFeatureDependency)
    {
        _myFeatureDependency = myFeatureDependency;
    }
    public void Operation()
    {
        // use _myFeatureDependency
    }
}
public interface IMyFeatureDependency { }
public class MyFeatureDependency : IMyFeatureDependency { }</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.270.1" xmlns="http://www.w3.org/1999/xhtml">As we can see, there is nothing complex but two empty classes and an interface. </span><span class="koboSpan" id="kobo.270.2" xmlns="http://www.w3.org/1999/xhtml">Remember that we are exploring the registration of dependencies, not what to do with them or what they can do—yet.Now, we want the container to serve an instance of the </span><code><span class="koboSpan" id="kobo.271.1" xmlns="http://www.w3.org/1999/xhtml">MyFeatureDependency</span></code><span class="koboSpan" id="kobo.272.1" xmlns="http://www.w3.org/1999/xhtml"> class when a dependency requests the </span><code><span class="koboSpan" id="kobo.273.1" xmlns="http://www.w3.org/1999/xhtml">IMyFeatureDependency</span></code><span class="koboSpan" id="kobo.274.1" xmlns="http://www.w3.org/1999/xhtml"> interface as the </span><code><span class="koboSpan" id="kobo.275.1" xmlns="http://www.w3.org/1999/xhtml">MyFeature</span></code><span class="koboSpan" id="kobo.276.1" xmlns="http://www.w3.org/1999/xhtml"> class does. </span><span class="koboSpan" id="kobo.276.2" xmlns="http://www.w3.org/1999/xhtml">We want a singleton lifetime.To achieve this, in the </span><code><span class="koboSpan" id="kobo.277.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.278.1" xmlns="http://www.w3.org/1999/xhtml"> file, we can write the following code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.279.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddSingleton&lt;MyFeature&gt;();
builder.Services.AddSingleton&lt;IMyFeatureDependency, MyFeatureDependency&gt;();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.280.1" xmlns="http://www.w3.org/1999/xhtml">We can also chain the two method calls instead:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.281.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services
    .AddSingleton&lt;MyFeature&gt;()
    .AddSingleton&lt;IMyFeatureDependency, MyFeatureDependency&gt;()
;</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.282.1" xmlns="http://www.w3.org/1999/xhtml">However, this is not yet elegant. </span><span class="koboSpan" id="kobo.282.2" xmlns="http://www.w3.org/1999/xhtml">What we want to achieve is this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.283.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddDemoFeature();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.284.1" xmlns="http://www.w3.org/1999/xhtml">To build that registration method, we can write the following extension method:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.285.1" xmlns="http://www.w3.org/1999/xhtml">using CompositionRoot.DemoFeature;
namespace Microsoft.Extensions.DependencyInjection;
public static class DemoFeatureExtensions
{
    public static IServiceCollection AddDemoFeature(this IServiceCollection services)
    {
        return services
            .AddSingleton&lt;MyFeature&gt;()
            .AddSingleton&lt;IMyFeatureDependency, MyFeatureDependency&gt;()
        ;
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.286.1" xmlns="http://www.w3.org/1999/xhtml">As highlighted, the registration is the same but uses the </span><code><span class="koboSpan" id="kobo.287.1" xmlns="http://www.w3.org/1999/xhtml">services</span></code><span class="koboSpan" id="kobo.288.1" xmlns="http://www.w3.org/1999/xhtml"> parameter, which is the extended type, instead of the </span><code><span class="koboSpan" id="kobo.289.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services</span></code><span class="koboSpan" id="kobo.290.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><code><span class="koboSpan" id="kobo.291.1" xmlns="http://www.w3.org/1999/xhtml">builder</span></code><span class="koboSpan" id="kobo.292.1" xmlns="http://www.w3.org/1999/xhtml"> does not exist in that class, yet the </span><code><span class="koboSpan" id="kobo.293.1" xmlns="http://www.w3.org/1999/xhtml">services</span></code><span class="koboSpan" id="kobo.294.1" xmlns="http://www.w3.org/1999/xhtml"> parameter is the same object as the </span><code><span class="koboSpan" id="kobo.295.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services</span></code><span class="koboSpan" id="kobo.296.1" xmlns="http://www.w3.org/1999/xhtml"> property).If you are unfamiliar with extension methods, they come in handy for extending existing classes, like we just did. </span><span class="koboSpan" id="kobo.296.2" xmlns="http://www.w3.org/1999/xhtml">Besides having a static method inside a static class, the </span><code><span class="koboSpan" id="kobo.297.1" xmlns="http://www.w3.org/1999/xhtml">this</span></code><span class="koboSpan" id="kobo.298.1" xmlns="http://www.w3.org/1999/xhtml"> keyword next to the first parameter determines whether it is an extension method.For example, we can build sophisticated libraries that are easy to use with a set of extension methods. </span><span class="koboSpan" id="kobo.298.2" xmlns="http://www.w3.org/1999/xhtml">Think </span><code><span class="koboSpan" id="kobo.299.1" xmlns="http://www.w3.org/1999/xhtml">System.Linq</span></code><span class="koboSpan" id="kobo.300.1" xmlns="http://www.w3.org/1999/xhtml"> for such a system.Now that we learned the basics of dependency injection, there is one last thing to cover before revisiting the Strategy design pattern.</span></p>
</section>
</section>
<section class="level3" data-number="9.2.9" id="using-external-ioc-containers">
<h3 data-number="9.2.9"><span class="koboSpan" id="kobo.301.1" xmlns="http://www.w3.org/1999/xhtml">Using external IoC containers</span></h3>
<p><span class="koboSpan" id="kobo.302.1" xmlns="http://www.w3.org/1999/xhtml">ASP.NET Core provides an extensible built-in IoC container out of the box. </span><span class="koboSpan" id="kobo.302.2" xmlns="http://www.w3.org/1999/xhtml">It is not the most powerful IoC container because it lacks some advanced features, but it does the job for most applications.Rest assured; we can change it to another one if need be. </span><span class="koboSpan" id="kobo.302.3" xmlns="http://www.w3.org/1999/xhtml">You might also want to do that if you are used to another IoC container and want to stick to it.Here’s the strategy I recommend:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.303.1" xmlns="http://www.w3.org/1999/xhtml">Use the built-in container, as per Microsoft's recommendation.</span></li>
<li><span class="koboSpan" id="kobo.304.1" xmlns="http://www.w3.org/1999/xhtml">When you can’t achieve something with it, look at your design and see if you can redesign your feature to work with the built-in container and simplify your design.</span></li>
<li><span class="koboSpan" id="kobo.305.1" xmlns="http://www.w3.org/1999/xhtml">If it is impossible to achieve your goal, see if extending the default container using an existing library or coding the feature yourself is possible.</span></li>
<li><span class="koboSpan" id="kobo.306.1" xmlns="http://www.w3.org/1999/xhtml">If it is still impossible, explore swapping it for another IoC container.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.307.1" xmlns="http://www.w3.org/1999/xhtml">Assuming the container supports it, it is super simple to swap. </span><span class="koboSpan" id="kobo.307.2" xmlns="http://www.w3.org/1999/xhtml">The third-party container must implement the </span><code><span class="koboSpan" id="kobo.308.1" xmlns="http://www.w3.org/1999/xhtml">IServiceProviderFactory&lt;TContainerBuilder&gt;</span></code><span class="koboSpan" id="kobo.309.1" xmlns="http://www.w3.org/1999/xhtml"> interface. </span><span class="koboSpan" id="kobo.309.2" xmlns="http://www.w3.org/1999/xhtml">Then, in the </span><code><span class="koboSpan" id="kobo.310.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.311.1" xmlns="http://www.w3.org/1999/xhtml"> file, we must register that factory using the </span><code><span class="koboSpan" id="kobo.312.1" xmlns="http://www.w3.org/1999/xhtml">UseServiceProviderFactory&lt;TContainerBuilder&gt;</span></code><span class="koboSpan" id="kobo.313.1" xmlns="http://www.w3.org/1999/xhtml"> method like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.314.1" xmlns="http://www.w3.org/1999/xhtml">var builder = WebApplication.CreateBuilder(args);
builder.Host.UseServiceProviderFactory&lt;ContainerBuilder&gt;(new ContainerBuilderFactory());</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.315.1" xmlns="http://www.w3.org/1999/xhtml">In this case, the </span><code><span class="koboSpan" id="kobo.316.1" xmlns="http://www.w3.org/1999/xhtml">ContainerBuilder</span></code><span class="koboSpan" id="kobo.317.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.318.1" xmlns="http://www.w3.org/1999/xhtml">ContainerBuilderFactory</span></code><span class="koboSpan" id="kobo.319.1" xmlns="http://www.w3.org/1999/xhtml"> classes are just wrappers around ASP.NET Core, but your third-party container of choice should provide you with those types. </span><span class="koboSpan" id="kobo.319.2" xmlns="http://www.w3.org/1999/xhtml">I suggest you visit their documentation to know more.Once that factory is registered, we can configure the container using the </span><code><span class="koboSpan" id="kobo.320.1" xmlns="http://www.w3.org/1999/xhtml">ConfigureContainer&lt;TContainerBuilder&gt;</span></code><span class="koboSpan" id="kobo.321.1" xmlns="http://www.w3.org/1999/xhtml"> method and register our dependencies as usual, like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.322.1" xmlns="http://www.w3.org/1999/xhtml">builder.Host.ConfigureContainer&lt;ContainerBuilder&gt;((context, builder) =&gt;
{
    builder.Services.AddSingleton&lt;Dependency1&gt;();
    builder.Services.AddSingleton&lt;Dependency2&gt;();
    builder.Services.AddSingleton&lt;Dependency3&gt;();
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.323.1" xmlns="http://www.w3.org/1999/xhtml">That’s the only difference; the rest of the </span><code><span class="koboSpan" id="kobo.324.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.325.1" xmlns="http://www.w3.org/1999/xhtml"> file remains the same.As I sense you don’t feel like implementing your own IoC container, multiple third-party integrations already exist. </span><span class="koboSpan" id="kobo.325.2" xmlns="http://www.w3.org/1999/xhtml">Here is a non-exhaustive list taken from the official documentation:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.326.1" xmlns="http://www.w3.org/1999/xhtml">Autofac</span></li>
<li><span class="koboSpan" id="kobo.327.1" xmlns="http://www.w3.org/1999/xhtml">DryIoc</span></li>
<li><span class="koboSpan" id="kobo.328.1" xmlns="http://www.w3.org/1999/xhtml">Grace</span></li>
<li><span class="koboSpan" id="kobo.329.1" xmlns="http://www.w3.org/1999/xhtml">LightInject</span></li>
<li><span class="koboSpan" id="kobo.330.1" xmlns="http://www.w3.org/1999/xhtml">Lamar</span></li>
<li><span class="koboSpan" id="kobo.331.1" xmlns="http://www.w3.org/1999/xhtml">Stashbox</span></li>
<li><span class="koboSpan" id="kobo.332.1" xmlns="http://www.w3.org/1999/xhtml">Simple Injector</span></li>
</ul>
<p><span class="koboSpan" id="kobo.333.1" xmlns="http://www.w3.org/1999/xhtml">On top of replacing the container entirely, some libraries extend the default container and add functionalities to it. </span><span class="koboSpan" id="kobo.333.2" xmlns="http://www.w3.org/1999/xhtml">We explore this option in </span><em><span class="koboSpan" id="kobo.334.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 11</span></em><span class="koboSpan" id="kobo.335.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.336.1" xmlns="http://www.w3.org/1999/xhtml">Structural Patterns</span></em><span class="koboSpan" id="kobo.337.1" xmlns="http://www.w3.org/1999/xhtml">.Now that we have covered most of the theory, we revisit the Strategy pattern as the primary tool to compose our applications and add flexibility to our systems.</span></p>
</section>
</section>
<section class="level2" data-number="9.3" id="revisiting-the-strategy-pattern">
<h2 data-number="9.3"><span class="koboSpan" id="kobo.338.1" xmlns="http://www.w3.org/1999/xhtml">Revisiting the Strategy pattern</span></h2>
<p><span class="koboSpan" id="kobo.339.1" xmlns="http://www.w3.org/1999/xhtml">In this section, we leverage the Strategy pattern to compose complex object trees and use DI to dynamically create those instances without using the </span><code><span class="koboSpan" id="kobo.340.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.341.1" xmlns="http://www.w3.org/1999/xhtml"> keyword, moving away from being control freaks and toward writing DI-ready code.The Strategy pattern is a behavioral design pattern we can use to compose object trees at runtime, allowing extra flexibility and control over objects’ behavior. </span><span class="koboSpan" id="kobo.341.2" xmlns="http://www.w3.org/1999/xhtml">Composing our objects using the Strategy pattern makes our classes smaller, easier to test and maintain, and puts us on the SOLID path.From now on, we want to compose objects and lower the amount of inheritance to a minimum. </span><span class="koboSpan" id="kobo.341.3" xmlns="http://www.w3.org/1999/xhtml">We call that principle </span><strong><span class="koboSpan" id="kobo.342.1" xmlns="http://www.w3.org/1999/xhtml">composition over inheritance</span></strong><span class="koboSpan" id="kobo.343.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.343.2" xmlns="http://www.w3.org/1999/xhtml">The goal is to inject dependencies (composition) into the current class instead of depending on base class features (inheritance). </span><span class="koboSpan" id="kobo.343.3" xmlns="http://www.w3.org/1999/xhtml">Additionally, this approach enables us to pull out behaviors and place them in separate classes, adhering to the Single Responsibility Principle (SRP) and Interface Segregation Principle (ISP). </span><span class="koboSpan" id="kobo.343.4" xmlns="http://www.w3.org/1999/xhtml">We can reuse these behaviors in one or more different classes through their interface, embodying the Dependency Inversion Principle (DIP). </span><span class="koboSpan" id="kobo.343.5" xmlns="http://www.w3.org/1999/xhtml">This strategy promotes code reuse and composition.The following list covers the most popular ways of injecting dependencies into objects, allowing us to control their behaviors from the outside by composing our objects:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.344.1" xmlns="http://www.w3.org/1999/xhtml">Constructor injection</span></li>
<li><span class="koboSpan" id="kobo.345.1" xmlns="http://www.w3.org/1999/xhtml">Property injection</span></li>
<li><span class="koboSpan" id="kobo.346.1" xmlns="http://www.w3.org/1999/xhtml">Method injection</span></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.347.1" xmlns="http://www.w3.org/1999/xhtml">We can also get dependencies directly from the container. </span><span class="koboSpan" id="kobo.347.2" xmlns="http://www.w3.org/1999/xhtml">This is known as the Service Locator (anti-)pattern. </span><span class="koboSpan" id="kobo.347.3" xmlns="http://www.w3.org/1999/xhtml">We explore the Service Locator pattern later in this chapter.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.348.1" xmlns="http://www.w3.org/1999/xhtml">Let’s look at some theory and then jump into the code to see DI in action.</span></p>
<section class="level3" data-number="9.3.1" id="constructor-injection">
<h3 data-number="9.3.1"><span class="koboSpan" id="kobo.349.1" xmlns="http://www.w3.org/1999/xhtml">Constructor injection</span></h3>
<p><strong><span class="koboSpan" id="kobo.350.1" xmlns="http://www.w3.org/1999/xhtml">Constructor injection</span></strong><span class="koboSpan" id="kobo.351.1" xmlns="http://www.w3.org/1999/xhtml"> consists of injecting dependencies into the constructor as parameters. </span><span class="koboSpan" id="kobo.351.2" xmlns="http://www.w3.org/1999/xhtml">This is the most popular and preferred technique by far. </span><span class="koboSpan" id="kobo.351.3" xmlns="http://www.w3.org/1999/xhtml">Constructor injection is useful for injecting required dependencies; you can add null checks to ensure that, also known as the guard clause (see the </span><em><span class="koboSpan" id="kobo.352.1" xmlns="http://www.w3.org/1999/xhtml">Adding a guard clause</span></em><span class="koboSpan" id="kobo.353.1" xmlns="http://www.w3.org/1999/xhtml"> section).</span></p>
</section>
<section class="level3" data-number="9.3.2" id="property-injection">
<h3 data-number="9.3.2"><span class="koboSpan" id="kobo.354.1" xmlns="http://www.w3.org/1999/xhtml">Property injection</span></h3>
<p><span class="koboSpan" id="kobo.355.1" xmlns="http://www.w3.org/1999/xhtml">The built-in IoC container does not support </span><strong><span class="koboSpan" id="kobo.356.1" xmlns="http://www.w3.org/1999/xhtml">property injection</span></strong><span class="koboSpan" id="kobo.357.1" xmlns="http://www.w3.org/1999/xhtml"> out of the box. </span><span class="koboSpan" id="kobo.357.2" xmlns="http://www.w3.org/1999/xhtml">The concept is to inject </span><strong><span class="koboSpan" id="kobo.358.1" xmlns="http://www.w3.org/1999/xhtml">optional dependencies</span></strong><span class="koboSpan" id="kobo.359.1" xmlns="http://www.w3.org/1999/xhtml"> into properties. </span><span class="koboSpan" id="kobo.359.2" xmlns="http://www.w3.org/1999/xhtml">Most of the time, you want to avoid doing this because property injection leads to optional dependencies, leading to nullable properties, more null checks, and often avoidable code complexity. </span><span class="koboSpan" id="kobo.359.3" xmlns="http://www.w3.org/1999/xhtml">So when we think about it, it is good that ASP.NET Core left this one out of the built-in container.You can usually remove the property injection requirements by reworking your design, leading to a better design. </span><span class="koboSpan" id="kobo.359.4" xmlns="http://www.w3.org/1999/xhtml">If you cannot avoid using property injection, use a third-party container or find a way to build the dependency tree yourself (maybe leveraging one of the Factory patterns).Nevertheless, from a high-level view, the container would do something like this:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.360.1" xmlns="http://www.w3.org/1999/xhtml">Create a new instance of the class and inject all required dependencies into the constructor.</span></li>
<li><span class="koboSpan" id="kobo.361.1" xmlns="http://www.w3.org/1999/xhtml">Find extension points by scanning properties (this could be attributes, contextual bindings, or something else).</span></li>
<li><span class="koboSpan" id="kobo.362.1" xmlns="http://www.w3.org/1999/xhtml">For each extension point, inject (set) a dependency, leaving unconfigured properties untouched, hence its definition of an optional dependency.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.363.1" xmlns="http://www.w3.org/1999/xhtml">There are a couple of exceptions to the previous statement regarding the lack of support:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.364.1" xmlns="http://www.w3.org/1999/xhtml">Razor components (Blazor) support property injection using the </span><code><span class="koboSpan" id="kobo.365.1" xmlns="http://www.w3.org/1999/xhtml">[Inject]</span></code><span class="koboSpan" id="kobo.366.1" xmlns="http://www.w3.org/1999/xhtml"> attribute.</span></li>
<li><span class="koboSpan" id="kobo.367.1" xmlns="http://www.w3.org/1999/xhtml">Razor contains the </span><code><span class="koboSpan" id="kobo.368.1" xmlns="http://www.w3.org/1999/xhtml">@inject</span></code><span class="koboSpan" id="kobo.369.1" xmlns="http://www.w3.org/1999/xhtml"> directive, which generates a property to hold a dependency (ASP.NET Core manages to inject it).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.370.1" xmlns="http://www.w3.org/1999/xhtml">We can’t call that property injection per se because they are not optional but required, and the </span><code><span class="koboSpan" id="kobo.371.1" xmlns="http://www.w3.org/1999/xhtml">@inject</span></code><span class="koboSpan" id="kobo.372.1" xmlns="http://www.w3.org/1999/xhtml"> directive is more about generating code than doing DI. </span><span class="koboSpan" id="kobo.372.2" xmlns="http://www.w3.org/1999/xhtml">They are more about an internal workaround than “real” property injection. </span><span class="koboSpan" id="kobo.372.3" xmlns="http://www.w3.org/1999/xhtml">That is as close as .NET gets from property injection.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.373.1" xmlns="http://www.w3.org/1999/xhtml">I recommend aiming for constructor injection instead. </span><span class="koboSpan" id="kobo.373.2" xmlns="http://www.w3.org/1999/xhtml">Not having property injection should not cause you any problems. </span><span class="koboSpan" id="kobo.373.3" xmlns="http://www.w3.org/1999/xhtml">Often, our need for property injection stems from less-than-optimal design choices, whether from our design strategies or a framework we're utilizing.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.374.1" xmlns="http://www.w3.org/1999/xhtml">Next, we look at method injection.</span></p>
</section>
<section class="level3" data-number="9.3.3" id="method-injection">
<h3 data-number="9.3.3"><span class="koboSpan" id="kobo.375.1" xmlns="http://www.w3.org/1999/xhtml">Method injection</span></h3>
<p><span class="koboSpan" id="kobo.376.1" xmlns="http://www.w3.org/1999/xhtml">ASP.NET Core supports method injection only at a few locations, such as in a controller’s actions (methods), the </span><code><span class="koboSpan" id="kobo.377.1" xmlns="http://www.w3.org/1999/xhtml">Startup</span></code><span class="koboSpan" id="kobo.378.1" xmlns="http://www.w3.org/1999/xhtml"> class (if you are using the pre-.NET 6 hosting model), and the middleware’s </span><code><span class="koboSpan" id="kobo.379.1" xmlns="http://www.w3.org/1999/xhtml">Invoke</span></code><span class="koboSpan" id="kobo.380.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.381.1" xmlns="http://www.w3.org/1999/xhtml">InvokeAsync</span></code><span class="koboSpan" id="kobo.382.1" xmlns="http://www.w3.org/1999/xhtml"> methods. </span><span class="koboSpan" id="kobo.382.2" xmlns="http://www.w3.org/1999/xhtml">We cannot liberally use method injection in our classes without some work on our part.Method injection is also used to inject </span><strong><span class="koboSpan" id="kobo.383.1" xmlns="http://www.w3.org/1999/xhtml">optional dependencies</span></strong><span class="koboSpan" id="kobo.384.1" xmlns="http://www.w3.org/1999/xhtml"> into classes. </span><span class="koboSpan" id="kobo.384.2" xmlns="http://www.w3.org/1999/xhtml">We can also validate those at runtime using null checks or any other required logic.</span></p>
<blockquote>
<p><strong><span class="koboSpan" id="kobo.385.1" xmlns="http://www.w3.org/1999/xhtml">I recommend aiming for constructor injection whenever you can</span></strong><span class="koboSpan" id="kobo.386.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.386.2" xmlns="http://www.w3.org/1999/xhtml">We should only resort to method injection when it's our sole option or when it brings added value to our design.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.387.1" xmlns="http://www.w3.org/1999/xhtml">For example, in a controller, injecting a transient service in the only action that needs it instead of using constructor injection could save a lot of useless object instantiation and, by doing so, increase performance (less instantiation and less garbage collection). </span><span class="koboSpan" id="kobo.387.2" xmlns="http://www.w3.org/1999/xhtml">This can also lower the number of class-level dependencies a single class has.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.388.1" xmlns="http://www.w3.org/1999/xhtml">Manually injecting a dependency in a method as an argument is valid. </span><span class="koboSpan" id="kobo.388.2" xmlns="http://www.w3.org/1999/xhtml">Here’s an example, starting with the classes:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.389.1" xmlns="http://www.w3.org/1999/xhtml">namespace CompositionRoot.ManualMethodInjection;
public class Subject
{
    public int Operation(Context context)
    {
        // ...
        </span><span class="koboSpan" id="kobo.389.2" xmlns="http://www.w3.org/1999/xhtml">return context.Number;
    }
}
public class Context
{
    public required int Number { get; init; }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.390.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code represents the </span><code><span class="koboSpan" id="kobo.391.1" xmlns="http://www.w3.org/1999/xhtml">Subject</span></code><span class="koboSpan" id="kobo.392.1" xmlns="http://www.w3.org/1999/xhtml"> class that consumes an instance of the </span><code><span class="koboSpan" id="kobo.393.1" xmlns="http://www.w3.org/1999/xhtml">Context</span></code><span class="koboSpan" id="kobo.394.1" xmlns="http://www.w3.org/1999/xhtml"> from its </span><code><span class="koboSpan" id="kobo.395.1" xmlns="http://www.w3.org/1999/xhtml">Operation</span></code><span class="koboSpan" id="kobo.396.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.396.2" xmlns="http://www.w3.org/1999/xhtml">It then returns the value of its </span><code><span class="koboSpan" id="kobo.397.1" xmlns="http://www.w3.org/1999/xhtml">Number</span></code><span class="koboSpan" id="kobo.398.1" xmlns="http://www.w3.org/1999/xhtml"> property.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.399.1" xmlns="http://www.w3.org/1999/xhtml">This example follows a similar pattern to injecting an </span><code><span class="koboSpan" id="kobo.400.1" xmlns="http://www.w3.org/1999/xhtml">HttpContext</span></code><span class="koboSpan" id="kobo.401.1" xmlns="http://www.w3.org/1999/xhtml"> into an endpoint delegate. </span><span class="koboSpan" id="kobo.401.2" xmlns="http://www.w3.org/1999/xhtml">In that case, the </span><code><span class="koboSpan" id="kobo.402.1" xmlns="http://www.w3.org/1999/xhtml">HttpContext</span></code><span class="koboSpan" id="kobo.403.1" xmlns="http://www.w3.org/1999/xhtml"> represents the current HTTP request. </span><span class="koboSpan" id="kobo.403.2" xmlns="http://www.w3.org/1999/xhtml">In our case, the </span><code><span class="koboSpan" id="kobo.404.1" xmlns="http://www.w3.org/1999/xhtml">Context</span></code><span class="koboSpan" id="kobo.405.1" xmlns="http://www.w3.org/1999/xhtml"> contains only an arbitrary number we use in the consuming code next.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.406.1" xmlns="http://www.w3.org/1999/xhtml">To test that our code does as it should, we can write the following test:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.407.1" xmlns="http://www.w3.org/1999/xhtml">[Fact]
public void Should_return_the_value_of_the_Context_Number_property()
{
    // Arrange
    var subject = new Subject();
    var context = new Context { Number = 44 };
    // Act
    var result = subject.Operation(context);
    // Assert
    Assert.Equal(44, result);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.408.1" xmlns="http://www.w3.org/1999/xhtml">When we run the test, it works. </span><span class="koboSpan" id="kobo.408.2" xmlns="http://www.w3.org/1999/xhtml">We successfully injected the </span><code><span class="koboSpan" id="kobo.409.1" xmlns="http://www.w3.org/1999/xhtml">context</span></code><span class="koboSpan" id="kobo.410.1" xmlns="http://www.w3.org/1999/xhtml"> into the </span><code><span class="koboSpan" id="kobo.411.1" xmlns="http://www.w3.org/1999/xhtml">subject</span></code><span class="koboSpan" id="kobo.412.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.412.2" xmlns="http://www.w3.org/1999/xhtml">Now to simulate a more complex system, let’s have a look at a theory that does the same more dynamically:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.413.1" xmlns="http://www.w3.org/1999/xhtml">[Theory]
[MemberData(nameof(GetData))]
public void Showcase_manual_method_injection(
    Subject subject, Context context, int expectedNumber)
{
    // Manually injecting the context into the
    // Operation method of the subject.
    </span><span class="koboSpan" id="kobo.413.2" xmlns="http://www.w3.org/1999/xhtml">var number = subject.Operation(context);
    // Validate that we got the specified context.
    </span><span class="koboSpan" id="kobo.413.3" xmlns="http://www.w3.org/1999/xhtml">Assert.Equal(expectedNumber, number);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.414.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code showcases the same concept, but xUnit injects the dependencies into the method, which is closer to what would happen in a real program. </span><span class="koboSpan" id="kobo.414.2" xmlns="http://www.w3.org/1999/xhtml">Remember, we want to remove the </span><code><span class="koboSpan" id="kobo.415.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.416.1" xmlns="http://www.w3.org/1999/xhtml"> keywords from our life!</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.417.1" xmlns="http://www.w3.org/1999/xhtml">The rest of the implementation is not important. </span><span class="koboSpan" id="kobo.417.2" xmlns="http://www.w3.org/1999/xhtml">I only pieced the simulation together to showcase this scenario. </span><span class="koboSpan" id="kobo.417.3" xmlns="http://www.w3.org/1999/xhtml">One interesting detail is that the </span><code><span class="koboSpan" id="kobo.418.1" xmlns="http://www.w3.org/1999/xhtml">Subject</span></code><span class="koboSpan" id="kobo.419.1" xmlns="http://www.w3.org/1999/xhtml"> is always the same (singleton) while the </span><code><span class="koboSpan" id="kobo.420.1" xmlns="http://www.w3.org/1999/xhtml">Context</span></code><span class="koboSpan" id="kobo.421.1" xmlns="http://www.w3.org/1999/xhtml"> is always different (transient), leading to a different outcome every time (</span><code><span class="koboSpan" id="kobo.422.1" xmlns="http://www.w3.org/1999/xhtml">Context { Number = 0 }</span></code><span class="koboSpan" id="kobo.423.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.424.1" xmlns="http://www.w3.org/1999/xhtml">Context { Number = 1 }</span></code><span class="koboSpan" id="kobo.425.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><code><span class="koboSpan" id="kobo.426.1" xmlns="http://www.w3.org/1999/xhtml">Context { Number = 2 }</span></code><span class="koboSpan" id="kobo.427.1" xmlns="http://www.w3.org/1999/xhtml">).</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.428.1" xmlns="http://www.w3.org/1999/xhtml">Having explored how to inject dependencies, we are ready to roll up our sleeves and dive into hands-on coding.</span></p>
</section>
<section class="level3" data-number="9.3.4" id="project-strategy-1">
<h3 data-number="9.3.4"><span class="koboSpan" id="kobo.429.1" xmlns="http://www.w3.org/1999/xhtml">Project – Strategy</span></h3>
<p><span class="koboSpan" id="kobo.430.1" xmlns="http://www.w3.org/1999/xhtml">In the Strategy project, we delve into various methods of injecting dependencies, transitioning from the Control Freak approach to a SOLID one. </span><span class="koboSpan" id="kobo.430.2" xmlns="http://www.w3.org/1999/xhtml">Through this exploration, we evaluate the advantages and drawbacks of each technique.The project takes the form of a travel agency's location API, initially returning only hardcoded cities. </span><span class="koboSpan" id="kobo.430.3" xmlns="http://www.w3.org/1999/xhtml">We've implemented the same endpoint five times across different controllers to facilitate comparison and trace the progression. </span><span class="koboSpan" id="kobo.430.4" xmlns="http://www.w3.org/1999/xhtml">Each controller comes in pair except for one. </span><span class="koboSpan" id="kobo.430.5" xmlns="http://www.w3.org/1999/xhtml">The pairs comprise a base controller that uses an in-memory service (dev) and an updated controller that simulates a SQL database (production). </span><span class="koboSpan" id="kobo.430.6" xmlns="http://www.w3.org/1999/xhtml">Here’s the breakdown of each controller:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.431.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.432.1" xmlns="http://www.w3.org/1999/xhtml">ControlFreakLocationsController</span></code><span class="koboSpan" id="kobo.433.1" xmlns="http://www.w3.org/1999/xhtml"> instantiates the </span><code><span class="koboSpan" id="kobo.434.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.435.1" xmlns="http://www.w3.org/1999/xhtml"> class using the </span><code><span class="koboSpan" id="kobo.436.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.437.1" xmlns="http://www.w3.org/1999/xhtml"> keyword.</span></li>
<li><span class="koboSpan" id="kobo.438.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.439.1" xmlns="http://www.w3.org/1999/xhtml">ControlFreakUpdatedLocationsController</span></code><span class="koboSpan" id="kobo.440.1" xmlns="http://www.w3.org/1999/xhtml"> instantiates the </span><code><span class="koboSpan" id="kobo.441.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService</span></code><span class="koboSpan" id="kobo.442.1" xmlns="http://www.w3.org/1999/xhtml"> class and its dependency using the </span><code><span class="koboSpan" id="kobo.443.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.444.1" xmlns="http://www.w3.org/1999/xhtml"> keyword.</span></li>
<li><span class="koboSpan" id="kobo.445.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.446.1" xmlns="http://www.w3.org/1999/xhtml">InjectImplementationLocationsController</span></code><span class="koboSpan" id="kobo.447.1" xmlns="http://www.w3.org/1999/xhtml"> leverages constructor injection to get an instance of the </span><code><span class="koboSpan" id="kobo.448.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.449.1" xmlns="http://www.w3.org/1999/xhtml"> class from the container.</span></li>
<li><span class="koboSpan" id="kobo.450.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.451.1" xmlns="http://www.w3.org/1999/xhtml">InjectImplementationUpdatedLocationsController</span></code><span class="koboSpan" id="kobo.452.1" xmlns="http://www.w3.org/1999/xhtml"> leverages constructor injection to get an instance of the </span><code><span class="koboSpan" id="kobo.453.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService </span></code><span class="koboSpan" id="kobo.454.1" xmlns="http://www.w3.org/1999/xhtml">class from the container.</span></li>
<li><span class="koboSpan" id="kobo.455.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.456.1" xmlns="http://www.w3.org/1999/xhtml">InjectAbstractionLocationsController</span></code><span class="koboSpan" id="kobo.457.1" xmlns="http://www.w3.org/1999/xhtml"> leverages dependency injection and interfaces to let its consumers change its behavior at runtime.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.458.1" xmlns="http://www.w3.org/1999/xhtml">The controllers share the same building blocks; let’s start there.</span></p>
<section class="level4" data-number="9.3.4.1" id="shared-building-blocks">
<h4 data-number="9.3.4.1"><span class="koboSpan" id="kobo.459.1" xmlns="http://www.w3.org/1999/xhtml">Shared building blocks</span></h4>
<p><span class="koboSpan" id="kobo.460.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.461.1" xmlns="http://www.w3.org/1999/xhtml">Location</span></code><span class="koboSpan" id="kobo.462.1" xmlns="http://www.w3.org/1999/xhtml"> data structure is the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.463.1" xmlns="http://www.w3.org/1999/xhtml">namespace Strategy.Models;
public record class Location(int Id, string Name, string CountryCode);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.464.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.465.1" xmlns="http://www.w3.org/1999/xhtml">LocationSummary</span></code><span class="koboSpan" id="kobo.466.1" xmlns="http://www.w3.org/1999/xhtml"> DTO returned by the controller is the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.467.1" xmlns="http://www.w3.org/1999/xhtml">namespace Strategy.Controllers;
public record class LocationSummary(int Id, string Name);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.468.1" xmlns="http://www.w3.org/1999/xhtml">The service interface is the following and has only one method that returns one or more </span><code><span class="koboSpan" id="kobo.469.1" xmlns="http://www.w3.org/1999/xhtml">Location</span></code><span class="koboSpan" id="kobo.470.1" xmlns="http://www.w3.org/1999/xhtml"> objects:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.471.1" xmlns="http://www.w3.org/1999/xhtml">using Strategy.Models;
namespace Strategy.Services;
public interface ILocationService
{
    Task&lt;IEnumerable&lt;Location&gt;&gt; FetchAllAsync(CancellationToken cancellationToken);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.472.1" xmlns="http://www.w3.org/1999/xhtml">The two implementations of this interface are an in-memory version to use when developing and a SQL version to use when deploying (let’s call this production to keep it simple).The in-memory service returns a predefined list of cities:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.473.1" xmlns="http://www.w3.org/1999/xhtml">using Strategy.Models;
namespace Strategy.Services;
public class InMemoryLocationService : ILocationService
{
    public async Task&lt;IEnumerable&lt;Location&gt;&gt; FetchAllAsync(CancellationToken cancellationToken)
    {
        await Task.Delay(Random.Shared.Next(1, 100), cancellationToken);
        return new Location[] {
            new Location(1, "Paris", "FR"),
            new Location(2, "New York City", "US"),
            new Location(3, "Tokyo", "JP"),
            new Location(4, "Rome", "IT"),
            new Location(5, "Sydney", "AU"),
            new Location(6, "Cape Town", "ZA"),
            new Location(7, "Istanbul", "TR"),
            new Location(8, "Bangkok", "TH"),
            new Location(9, "Rio de Janeiro", "BR"),
            new Location(10, "Toronto", "CA"),
        };
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.474.1" xmlns="http://www.w3.org/1999/xhtml">The SQL implementation uses an </span><code><span class="koboSpan" id="kobo.475.1" xmlns="http://www.w3.org/1999/xhtml">IDatabase</span></code><span class="koboSpan" id="kobo.476.1" xmlns="http://www.w3.org/1999/xhtml"> interface to access the data:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.477.1" xmlns="http://www.w3.org/1999/xhtml">using Strategy.Data;
using Strategy.Models;
namespace Strategy.Services;
public class SqlLocationService : ILocationService
{
    private readonly IDatabase _database;
    public SqlLocationService(IDatabase database) {
        _database = database;
    }
    public Task&lt;IEnumerable&lt;Location&gt;&gt; FetchAllAsync(CancellationToken cancellationToken) {
        return _database.ReadManyAsync&lt;Location&gt;(
            "SELECT * FROM Location",
            cancellationToken
        );
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.478.1" xmlns="http://www.w3.org/1999/xhtml">That database access interface is simply the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.479.1" xmlns="http://www.w3.org/1999/xhtml">namespace Strategy.Data;
public interface IDatabase
{
    Task&lt;IEnumerable&lt;T&gt;&gt; ReadManyAsync&lt;T&gt;(string sql, CancellationToken cancellationToken);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.480.1" xmlns="http://www.w3.org/1999/xhtml">In the project itself, the </span><code><span class="koboSpan" id="kobo.481.1" xmlns="http://www.w3.org/1999/xhtml">IDatabase</span></code><span class="koboSpan" id="kobo.482.1" xmlns="http://www.w3.org/1999/xhtml"> interface has only the </span><code><span class="koboSpan" id="kobo.483.1" xmlns="http://www.w3.org/1999/xhtml">NotImplementedDatabase</span></code><span class="koboSpan" id="kobo.484.1" xmlns="http://www.w3.org/1999/xhtml"> implementation, which throws a </span><code><span class="koboSpan" id="kobo.485.1" xmlns="http://www.w3.org/1999/xhtml">NotImplementedException</span></code><span class="koboSpan" id="kobo.486.1" xmlns="http://www.w3.org/1999/xhtml"> when its </span><code><span class="koboSpan" id="kobo.487.1" xmlns="http://www.w3.org/1999/xhtml">ReadManyAsync</span></code><span class="koboSpan" id="kobo.488.1" xmlns="http://www.w3.org/1999/xhtml"> method is called:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.489.1" xmlns="http://www.w3.org/1999/xhtml">namespace Strategy.Data;
public class NotImplementedDatabase : IDatabase
{
    public Task&lt;IEnumerable&lt;T&gt;&gt; ReadManyAsync&lt;T&gt;(string sql, CancellationToken cancellationToken)
        =&gt; throw new NotImplementedException();
}</span></code></pre>
</div>
<blockquote>
<p><span class="koboSpan" id="kobo.490.1" xmlns="http://www.w3.org/1999/xhtml">Since the goal is not learning database access, I mocked that part in a test case in a xUnit test using the controller and the </span><code><span class="koboSpan" id="kobo.491.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService</span></code><span class="koboSpan" id="kobo.492.1" xmlns="http://www.w3.org/1999/xhtml"> class.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.493.1" xmlns="http://www.w3.org/1999/xhtml">With those shared pieces, we can start with the first two controllers.</span></p>
</section>
<section class="level4" data-number="9.3.4.2" id="control-freak-controllers">
<h4 data-number="9.3.4.2"><span class="koboSpan" id="kobo.494.1" xmlns="http://www.w3.org/1999/xhtml">Control Freak controllers</span></h4>
<p><span class="koboSpan" id="kobo.495.1" xmlns="http://www.w3.org/1999/xhtml">This first version of the code showcases the lack of flexibility that creating dependencies using the </span><code><span class="koboSpan" id="kobo.496.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.497.1" xmlns="http://www.w3.org/1999/xhtml"> keyword brings when the time to update the application arises. </span><span class="koboSpan" id="kobo.497.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the initial controller that leverages an in-memory collection:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.498.1" xmlns="http://www.w3.org/1999/xhtml">using Microsoft.AspNetCore.Mvc;
using Strategy.Services;
namespace Strategy.Controllers;
[Route("travel/[controller]")]
[ApiController]
public class ControlFreakLocationsController : ControllerBase
{
    [HttpGet]
    public async Task&lt;IEnumerable&lt;LocationSummary&gt;&gt; GetAsync(CancellationToken cancellationToken)
    {
        var locationService = new InMemoryLocationService();
        var locations = await locationService
            .FetchAllAsync(cancellationToken);
        return locations
            .Select(l =&gt; new LocationSummary(l.Id, l.Name));
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.499.1" xmlns="http://www.w3.org/1999/xhtml">Executing this code works and returns the </span><code><span class="koboSpan" id="kobo.500.1" xmlns="http://www.w3.org/1999/xhtml">LocationSummary</span></code><span class="koboSpan" id="kobo.501.1" xmlns="http://www.w3.org/1999/xhtml"> equivalent of the </span><code><span class="koboSpan" id="kobo.502.1" xmlns="http://www.w3.org/1999/xhtml">Location</span></code><span class="koboSpan" id="kobo.503.1" xmlns="http://www.w3.org/1999/xhtml"> objects returned by the </span><code><span class="koboSpan" id="kobo.504.1" xmlns="http://www.w3.org/1999/xhtml">FetchAllAsync</span></code><span class="koboSpan" id="kobo.505.1" xmlns="http://www.w3.org/1999/xhtml"> method of the </span><code><span class="koboSpan" id="kobo.506.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.507.1" xmlns="http://www.w3.org/1999/xhtml"> class. </span><span class="koboSpan" id="kobo.507.2" xmlns="http://www.w3.org/1999/xhtml">However, changing the </span><code><span class="koboSpan" id="kobo.508.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.509.1" xmlns="http://www.w3.org/1999/xhtml"> to a </span><code><span class="koboSpan" id="kobo.510.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService</span></code><span class="koboSpan" id="kobo.511.1" xmlns="http://www.w3.org/1999/xhtml"> is impossible without changing the code like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.512.1" xmlns="http://www.w3.org/1999/xhtml">public class ControlFreakUpdatedLocationsController : ControllerBase
{
    [HttpGet]
    public async Task&lt;IEnumerable&lt;LocationSummary&gt;&gt; GetAsync(CancellationToken cancellationToken)
    {
        var database = new NotImplementedDatabase();
        var locationService = new SqlLocationService(database);
        var locations = await locationService.FetchAllAsync(cancellationToken);
        return locations.Select(l =&gt; new LocationSummary(l.Id, l.Name));
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.513.1" xmlns="http://www.w3.org/1999/xhtml">The changes are highlighted in the two code blocks. </span><span class="koboSpan" id="kobo.513.2" xmlns="http://www.w3.org/1999/xhtml">We could also create an if statement to load one or the other conditionally, but exporting this to a whole system makes a lot of duplication.</span><strong><span class="koboSpan" id="kobo.514.1" xmlns="http://www.w3.org/1999/xhtml">Advantages:</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.515.1" xmlns="http://www.w3.org/1999/xhtml">It is easy to understand the code and what objects the controller uses.</span></li>
</ul>
<p><strong><span class="koboSpan" id="kobo.516.1" xmlns="http://www.w3.org/1999/xhtml">Disadvantages:</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.517.1" xmlns="http://www.w3.org/1999/xhtml">The controller is tightly coupled with its dependencies, leading to a lack of flexibility.</span></li>
<li><span class="koboSpan" id="kobo.518.1" xmlns="http://www.w3.org/1999/xhtml">Going from </span><code><span class="koboSpan" id="kobo.519.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.520.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.521.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService</span></code><span class="koboSpan" id="kobo.522.1" xmlns="http://www.w3.org/1999/xhtml"> requires updating the code.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.523.1" xmlns="http://www.w3.org/1999/xhtml">Let’s improve on that design next with the next controller pair.</span></p>
</section>
<section class="level4" data-number="9.3.4.3" id="injecting-an-implementation-in-the-controllers">
<h4 data-number="9.3.4.3"><span class="koboSpan" id="kobo.524.1" xmlns="http://www.w3.org/1999/xhtml">Injecting an implementation in the controllers</span></h4>
<p><span class="koboSpan" id="kobo.525.1" xmlns="http://www.w3.org/1999/xhtml">This second version of the codebase improves flexibility by leveraging dependency injection. </span><span class="koboSpan" id="kobo.525.2" xmlns="http://www.w3.org/1999/xhtml">In the following controller, we inject the </span><code><span class="koboSpan" id="kobo.526.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.527.1" xmlns="http://www.w3.org/1999/xhtml"> class in its constructor:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.528.1" xmlns="http://www.w3.org/1999/xhtml">using Microsoft.AspNetCore.Mvc;
using Strategy.Services;
namespace Strategy.Controllers;
[Route("travel/[controller]")]
[ApiController]
public class InjectImplementationLocationsController : ControllerBase
{
    private readonly InMemoryLocationService _locationService;
    public InjectImplementationLocationsController(
        InMemoryLocationService locationService)
    {
        _locationService = locationService;
    }
    [HttpGet]
    public async Task&lt;IEnumerable&lt;LocationSummary&gt;&gt; GetAsync(CancellationToken cancellationToken)
    {
        var locations = await _locationService.FetchAllAsync(cancellationToken);
        return locations.Select(l =&gt; new LocationSummary(l.Id, l.Name));
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.529.1" xmlns="http://www.w3.org/1999/xhtml">Assuming the </span><strong><span class="koboSpan" id="kobo.530.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></strong><span class="koboSpan" id="kobo.531.1" xmlns="http://www.w3.org/1999/xhtml"> class is registered with the container, running this code would yield the same result as the Control Freak version and return the in-memory cities.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.532.1" xmlns="http://www.w3.org/1999/xhtml">To register a class with the container, we can do the following:</span></p>
</blockquote>
<pre><code><span class="koboSpan" id="kobo.533.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddSingleton&lt;InMemoryLocationService&gt;();</span></code></pre>
<p><span class="koboSpan" id="kobo.534.1" xmlns="http://www.w3.org/1999/xhtml">Unfortunately, to change that service for the </span><code><span class="koboSpan" id="kobo.535.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService</span></code><span class="koboSpan" id="kobo.536.1" xmlns="http://www.w3.org/1999/xhtml">, we need to change the code again. </span><span class="koboSpan" id="kobo.536.2" xmlns="http://www.w3.org/1999/xhtml">This time, however, we must only change the constructor injection code like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.537.1" xmlns="http://www.w3.org/1999/xhtml">public class InjectImplementationUpdatedLocationsController : ControllerBase
{
    private readonly SqlLocationService _locationService;
    public InjectImplementationUpdatedLocationsController(SqlLocationService locationService)
    {
        _locationService = locationService;
    }
    // ...
</span><span class="koboSpan" id="kobo.537.2" xmlns="http://www.w3.org/1999/xhtml">}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.538.1" xmlns="http://www.w3.org/1999/xhtml">This is yet another not ideal outcome.</span><strong><span class="koboSpan" id="kobo.539.1" xmlns="http://www.w3.org/1999/xhtml">Advantages:</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.540.1" xmlns="http://www.w3.org/1999/xhtml">It is easy to understand the code and what objects the controller uses.</span></li>
<li><span class="koboSpan" id="kobo.541.1" xmlns="http://www.w3.org/1999/xhtml">Using constructor injection allows changing the dependency in one place, and all the methods get it (assuming we have more than one method).</span></li>
<li><span class="koboSpan" id="kobo.542.1" xmlns="http://www.w3.org/1999/xhtml">We can inject subclasses without changing the code.</span></li>
</ul>
<p><strong><span class="koboSpan" id="kobo.543.1" xmlns="http://www.w3.org/1999/xhtml">Disadvantages:</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.544.1" xmlns="http://www.w3.org/1999/xhtml">The controller is tightly coupled with its dependencies, leading to a lack of flexibility.</span></li>
<li><span class="koboSpan" id="kobo.545.1" xmlns="http://www.w3.org/1999/xhtml">Going from </span><code><span class="koboSpan" id="kobo.546.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.547.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.548.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService</span></code><span class="koboSpan" id="kobo.549.1" xmlns="http://www.w3.org/1999/xhtml"> requires updating the code.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.550.1" xmlns="http://www.w3.org/1999/xhtml">We are getting there but still have a last step to make that controller flexible.</span></p>
</section>
<section class="level4" data-number="9.3.4.4" id="injecting-an-abstraction-in-the-controller">
<h4 data-number="9.3.4.4"><span class="koboSpan" id="kobo.551.1" xmlns="http://www.w3.org/1999/xhtml">Injecting an abstraction in the controller</span></h4>
<p><span class="koboSpan" id="kobo.552.1" xmlns="http://www.w3.org/1999/xhtml">In this last controller, we leverage the SOLID principles, constructor injection, and, inherently, the Strategy pattern to build a controller that we can change from the outside. </span><span class="koboSpan" id="kobo.552.2" xmlns="http://www.w3.org/1999/xhtml">All we have to do to make the code flexible is inject the interface instead of its implementation, like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.553.1" xmlns="http://www.w3.org/1999/xhtml">using Microsoft.AspNetCore.Mvc;
using Strategy.Services;
namespace Strategy.Controllers;
[Route("travel/[controller]")]
[ApiController]
public class InjectAbstractionLocationsController : ControllerBase
{
    private readonly ILocationService _locationService;
    public InjectAbstractionLocationsController(ILocationService locationService)
    {
        _locationService = locationService;
    }
    [HttpGet]
    public async Task&lt;IEnumerable&lt;LocationSummary&gt;&gt; GetAsync(CancellationToken cancellationToken)
    {
        var locations = await _locationService.FetchAllAsync(cancellationToken);
        return locations.Select(l =&gt; new LocationSummary(l.Id, l.Name));
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.554.1" xmlns="http://www.w3.org/1999/xhtml">The highlighted lines showcase the changes. </span><span class="koboSpan" id="kobo.554.2" xmlns="http://www.w3.org/1999/xhtml">Injecting the </span><code><span class="koboSpan" id="kobo.555.1" xmlns="http://www.w3.org/1999/xhtml">ILocationService</span></code><span class="koboSpan" id="kobo.556.1" xmlns="http://www.w3.org/1999/xhtml"> interface lets us control if we inject an instance of the </span><code><span class="koboSpan" id="kobo.557.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.558.1" xmlns="http://www.w3.org/1999/xhtml"> class, the </span><code><span class="koboSpan" id="kobo.559.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService</span></code><span class="koboSpan" id="kobo.560.1" xmlns="http://www.w3.org/1999/xhtml"> class, or any other implementation we’d like.This is the most flexible possibility we can get.</span><strong><span class="koboSpan" id="kobo.561.1" xmlns="http://www.w3.org/1999/xhtml">Advantages:</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.562.1" xmlns="http://www.w3.org/1999/xhtml">Using constructor injection allows changing the dependency in one place, and all the methods get it (assuming we have more than one method).</span></li>
<li><span class="koboSpan" id="kobo.563.1" xmlns="http://www.w3.org/1999/xhtml">Injecting the </span><code><span class="koboSpan" id="kobo.564.1" xmlns="http://www.w3.org/1999/xhtml">ILocationService</span></code><span class="koboSpan" id="kobo.565.1" xmlns="http://www.w3.org/1999/xhtml"> interface allows us to inject any of its implementations without changing the code.</span></li>
<li><span class="koboSpan" id="kobo.566.1" xmlns="http://www.w3.org/1999/xhtml">Because of the </span><code><span class="koboSpan" id="kobo.567.1" xmlns="http://www.w3.org/1999/xhtml">ILocationService</span></code><span class="koboSpan" id="kobo.568.1" xmlns="http://www.w3.org/1999/xhtml"> interface, the controller is loosely coupled with its dependencies.</span></li>
</ul>
<p><strong><span class="koboSpan" id="kobo.569.1" xmlns="http://www.w3.org/1999/xhtml">Disadvantages:</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.570.1" xmlns="http://www.w3.org/1999/xhtml">Understanding what objects the controller uses is harder since the dependencies are resolved at runtime. </span><span class="koboSpan" id="kobo.570.2" xmlns="http://www.w3.org/1999/xhtml">However, this forces us to program against an interface instead (a good thing).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.571.1" xmlns="http://www.w3.org/1999/xhtml">Let’s have a look at this flexibility in action.</span></p>
</section>
<section class="level4" data-number="9.3.4.5" id="constructing-the-injectabstractionlocationscontroller">
<h4 data-number="9.3.4.5"><span class="koboSpan" id="kobo.572.1" xmlns="http://www.w3.org/1999/xhtml">Constructing the InjectAbstractionLocationsController</span></h4>
<p><span class="koboSpan" id="kobo.573.1" xmlns="http://www.w3.org/1999/xhtml">I created a few xUnit tests to explore the possibilities, making it easy to create classes manually.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.574.1" xmlns="http://www.w3.org/1999/xhtml">I used Moq to mock implementations. </span><span class="koboSpan" id="kobo.574.2" xmlns="http://www.w3.org/1999/xhtml">If you are unfamiliar with Moq and want to learn more, I left a link in the </span><em><span class="koboSpan" id="kobo.575.1" xmlns="http://www.w3.org/1999/xhtml">Further Reading</span></em><span class="koboSpan" id="kobo.576.1" xmlns="http://www.w3.org/1999/xhtml"> section.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.577.1" xmlns="http://www.w3.org/1999/xhtml">Two of the tests refers to the following member, a static </span><code><span class="koboSpan" id="kobo.578.1" xmlns="http://www.w3.org/1999/xhtml">Location</span></code><span class="koboSpan" id="kobo.579.1" xmlns="http://www.w3.org/1999/xhtml"> object:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.580.1" xmlns="http://www.w3.org/1999/xhtml">public static Location ExpectedLocation { get; }
    = new Location(11, "Montréal", "CA");</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.581.1" xmlns="http://www.w3.org/1999/xhtml">The test cases are not to assess the correctness of our code but to explore how easy it is to compose the controller differently. </span><span class="koboSpan" id="kobo.581.2" xmlns="http://www.w3.org/1999/xhtml">Let’s explore the first test case.</span></p>
<section class="level5" data-number="9.3.4.5.1" id="mock_the_idatabase">
<h5 data-number="9.3.4.5.1"><span class="koboSpan" id="kobo.582.1" xmlns="http://www.w3.org/1999/xhtml">Mock_the_IDatabase</span></h5>
<p><span class="koboSpan" id="kobo.583.1" xmlns="http://www.w3.org/1999/xhtml">The first is an integration test that injects an instance of the </span><code><span class="koboSpan" id="kobo.584.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService</span></code><span class="koboSpan" id="kobo.585.1" xmlns="http://www.w3.org/1999/xhtml"> class into the controller and mocks the database. </span><span class="koboSpan" id="kobo.585.2" xmlns="http://www.w3.org/1999/xhtml">The fake database returns a collection of one item. </span><span class="koboSpan" id="kobo.585.3" xmlns="http://www.w3.org/1999/xhtml">That item is the </span><code><span class="koboSpan" id="kobo.586.1" xmlns="http://www.w3.org/1999/xhtml">Location</span></code><span class="koboSpan" id="kobo.587.1" xmlns="http://www.w3.org/1999/xhtml"> instance referenced by the </span><code><span class="koboSpan" id="kobo.588.1" xmlns="http://www.w3.org/1999/xhtml">ExpectedLocation</span></code><span class="koboSpan" id="kobo.589.1" xmlns="http://www.w3.org/1999/xhtml"> property. </span><span class="koboSpan" id="kobo.589.2" xmlns="http://www.w3.org/1999/xhtml">Here’s that code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.590.1" xmlns="http://www.w3.org/1999/xhtml">var databaseMock = new Mock&lt;IDatabase&gt;();
databaseMock.Setup(x =&gt; x.ReadManyAsync&lt;Location&gt;(It.IsAny&lt;string&gt;(), It.IsAny&lt;CancellationToken&gt;()))
    .ReturnsAsync(() =&gt; new Location[] { ExpectedLocation })
;
var sqlLocationService = new SqlLocationService(
    databaseMock.Object);
var sqlController = new InjectAbstractionLocationsController(
    sqlLocationService);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.591.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code shows how we can control the dependency we inject into the classes because of how the </span><code><span class="koboSpan" id="kobo.592.1" xmlns="http://www.w3.org/1999/xhtml">InjectAbstractionLocationsController</span></code><span class="koboSpan" id="kobo.593.1" xmlns="http://www.w3.org/1999/xhtml"> was designed. </span><span class="koboSpan" id="kobo.593.2" xmlns="http://www.w3.org/1999/xhtml">We can’t say the same about the four other controller versions.Next, we call the GetAsync method to verify that everything works as expected:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.594.1" xmlns="http://www.w3.org/1999/xhtml">var result = await sqlController.GetAsync(CancellationToken.None);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.595.1" xmlns="http://www.w3.org/1999/xhtml">Finally, let’s verify we received that collection of one object:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.596.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Collection(result,
    location =&gt;
    {
        Assert.Equal(ExpectedLocation.Id, location.Id);
        Assert.Equal(ExpectedLocation.Name, location.Name);
    }
);</span></code></pre>
</div>
<blockquote>
<p><span class="koboSpan" id="kobo.597.1" xmlns="http://www.w3.org/1999/xhtml">Optionally, or instead, we could validate the service called the database mock, like this:</span></p>
</blockquote>
<pre><code><span class="koboSpan" id="kobo.598.1" xmlns="http://www.w3.org/1999/xhtml">databaseMock.Verify(x =&gt; x
    .ReadManyAsync&lt;Location&gt;(
        It.IsAny&lt;string&gt;(),
        It.IsAny&lt;CancellationToken&gt;()
    ),
    Times.Once()
);</span></code></pre>
<blockquote>
<p><span class="koboSpan" id="kobo.599.1" xmlns="http://www.w3.org/1999/xhtml">There are a lot of useful features in the Moq library.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.600.1" xmlns="http://www.w3.org/1999/xhtml">Validating that the code was correct is not important for this example. </span><span class="koboSpan" id="kobo.600.2" xmlns="http://www.w3.org/1999/xhtml">The key is to understand the composition of the controller, which the following diagram represents:</span></p>
<figure>
<span class="koboSpan" id="kobo.601.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 8.1: Composition of the controller in a test that mocks the IDatabase interface" src="../media/file40.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.602.1" xmlns="http://www.w3.org/1999/xhtml">Figure 8.1: Composition of the controller in a test that mocks the IDatabase interface</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.603.1" xmlns="http://www.w3.org/1999/xhtml">As we can see from the diagram, the classes depend on interfaces, and we inject implementations when building them. </span><span class="koboSpan" id="kobo.603.2" xmlns="http://www.w3.org/1999/xhtml">The next two tests are simpler than this, only depending on the </span><code><span class="koboSpan" id="kobo.604.1" xmlns="http://www.w3.org/1999/xhtml">ILocationService</span></code><span class="koboSpan" id="kobo.605.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.605.2" xmlns="http://www.w3.org/1999/xhtml">Let’s explore the second one.</span></p>
</section>
<section class="level5" data-number="9.3.4.5.2" id="use_the_inmemorylocationservice">
<h5 data-number="9.3.4.5.2"><span class="koboSpan" id="kobo.606.1" xmlns="http://www.w3.org/1999/xhtml">Use_the_InMemoryLocationService</span></h5>
<p><span class="koboSpan" id="kobo.607.1" xmlns="http://www.w3.org/1999/xhtml">Next, we use the in-memory location service to compose the controller like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.608.1" xmlns="http://www.w3.org/1999/xhtml">var inMemoryLocationService = new InMemoryLocationService();
var devController = new InjectAbstractionLocationsController(
    inMemoryLocationService);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.609.1" xmlns="http://www.w3.org/1999/xhtml">As we can see from the preceding code, we injected a different service into the controller, changing its behavior. </span><span class="koboSpan" id="kobo.609.2" xmlns="http://www.w3.org/1999/xhtml">This time, after calling the </span><code><span class="koboSpan" id="kobo.610.1" xmlns="http://www.w3.org/1999/xhtml">GetAsync</span></code><span class="koboSpan" id="kobo.611.1" xmlns="http://www.w3.org/1999/xhtml"> method, the controller returned the ten </span><code><span class="koboSpan" id="kobo.612.1" xmlns="http://www.w3.org/1999/xhtml">Location</span></code><span class="koboSpan" id="kobo.613.1" xmlns="http://www.w3.org/1999/xhtml"> objects from the </span><code><span class="koboSpan" id="kobo.614.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.615.1" xmlns="http://www.w3.org/1999/xhtml">.The visual representation of our object tree is as follows:</span></p>
<figure>
<span class="koboSpan" id="kobo.616.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 8.2: Composition of the controller in a test that injects an InMemoryLocationService instance." src="../media/file41.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.617.1" xmlns="http://www.w3.org/1999/xhtml">Figure 8.2: Composition of the controller in a test that injects an InMemoryLocationService instance.</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.618.1" xmlns="http://www.w3.org/1999/xhtml">It is harder to write assertions for the preceding test because we inject an instance of the </span><code><span class="koboSpan" id="kobo.619.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.620.1" xmlns="http://www.w3.org/1999/xhtml"> class, which ties the result to its implementation. </span><span class="koboSpan" id="kobo.620.2" xmlns="http://www.w3.org/1999/xhtml">For this reason, we won’t look at that code here. </span><span class="koboSpan" id="kobo.620.3" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, we succeeded at composing the controller differently. </span><span class="koboSpan" id="kobo.620.4" xmlns="http://www.w3.org/1999/xhtml">Let’s have a look at the last test case.</span></p>
</section>
<section class="level5" data-number="9.3.4.5.3" id="mock_the_ilocationservice">
<h5 data-number="9.3.4.5.3"><span class="koboSpan" id="kobo.621.1" xmlns="http://www.w3.org/1999/xhtml">Mock_the_ILocationService</span></h5>
<p><span class="koboSpan" id="kobo.622.1" xmlns="http://www.w3.org/1999/xhtml">The last unit test mocks the ILocationService directly. </span><span class="koboSpan" id="kobo.622.2" xmlns="http://www.w3.org/1999/xhtml">The mock service returns a collection of one item. </span><span class="koboSpan" id="kobo.622.3" xmlns="http://www.w3.org/1999/xhtml">That item is the </span><code><span class="koboSpan" id="kobo.623.1" xmlns="http://www.w3.org/1999/xhtml">Location</span></code><span class="koboSpan" id="kobo.624.1" xmlns="http://www.w3.org/1999/xhtml"> instance referenced by the </span><code><span class="koboSpan" id="kobo.625.1" xmlns="http://www.w3.org/1999/xhtml">ExpectedLocation</span></code><span class="koboSpan" id="kobo.626.1" xmlns="http://www.w3.org/1999/xhtml"> property. </span><span class="koboSpan" id="kobo.626.2" xmlns="http://www.w3.org/1999/xhtml">Here’s that code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.627.1" xmlns="http://www.w3.org/1999/xhtml">var locationServiceMock = new Mock&lt;ILocationService&gt;();
locationServiceMock.Setup(x =&gt; x.FetchAllAsync(It.IsAny&lt;CancellationToken&gt;())).ReturnsAsync(() =&gt; new Location[] { ExpectedLocation });
var testController = new InjectAbstractionLocationsController(
    locationServiceMock.Object);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.628.1" xmlns="http://www.w3.org/1999/xhtml">When executing the </span><code><span class="koboSpan" id="kobo.629.1" xmlns="http://www.w3.org/1999/xhtml">GetAsync</span></code><span class="koboSpan" id="kobo.630.1" xmlns="http://www.w3.org/1999/xhtml"> method, we get the same result as in the first test case: a collection of a single test </span><code><span class="koboSpan" id="kobo.631.1" xmlns="http://www.w3.org/1999/xhtml">Location</span></code><span class="koboSpan" id="kobo.632.1" xmlns="http://www.w3.org/1999/xhtml"> object. </span><span class="koboSpan" id="kobo.632.2" xmlns="http://www.w3.org/1999/xhtml">We can assert the correctness of the method by comparing values like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.633.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Collection(result,
    location =&gt;
    {
        Assert.Equal(ExpectedLocation.Id, location.Id);
        Assert.Equal(ExpectedLocation.Name, location.Name);
    }
);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.634.1" xmlns="http://www.w3.org/1999/xhtml">We can also leverage Moq to verify that the controller called the </span><code><span class="koboSpan" id="kobo.635.1" xmlns="http://www.w3.org/1999/xhtml">FetchAllAsync</span></code><span class="koboSpan" id="kobo.636.1" xmlns="http://www.w3.org/1999/xhtml"> method using the following code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.637.1" xmlns="http://www.w3.org/1999/xhtml">locationServiceMock.Verify(x =&gt; x
    .FetchAllAsync(It.IsAny&lt;CancellationToken&gt;()),
    Times.Once()
);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.638.1" xmlns="http://www.w3.org/1999/xhtml">The object tree of is very similar to the previous diagram but we faked the service implementation, making this a real unit test:</span></p>
<figure>
<span class="koboSpan" id="kobo.639.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 8.3: Composition of the controller in a test that mocks the ILocationService interface." src="../media/file42.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.640.1" xmlns="http://www.w3.org/1999/xhtml">Figure 8.3: Composition of the controller in a test that mocks the ILocationService interface.</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.641.1" xmlns="http://www.w3.org/1999/xhtml">As we explored in this project, with the right design and dependency injection, we can easily compose different object trees using the same building blocks. </span><span class="koboSpan" id="kobo.641.2" xmlns="http://www.w3.org/1999/xhtml">However, with a bad design, it is hard to impossible to do so without altering the code.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.642.1" xmlns="http://www.w3.org/1999/xhtml">As you may have noticed, we used the </span><code><span class="koboSpan" id="kobo.643.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.644.1" xmlns="http://www.w3.org/1999/xhtml"> keyword in the controller to instantiate the DTO. </span><span class="koboSpan" id="kobo.644.2" xmlns="http://www.w3.org/1999/xhtml">DTOs are stable dependencies. </span><span class="koboSpan" id="kobo.644.3" xmlns="http://www.w3.org/1999/xhtml">We also explore object mappers in </span><em><span class="koboSpan" id="kobo.645.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 15</span></em><span class="koboSpan" id="kobo.646.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.647.1" xmlns="http://www.w3.org/1999/xhtml">Object mappers, Aggregate Services, and Façade</span></em><span class="koboSpan" id="kobo.648.1" xmlns="http://www.w3.org/1999/xhtml">, which is a way to encapsulate the logic of copying an object into another.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.649.1" xmlns="http://www.w3.org/1999/xhtml">Let’s conclude before our next subject.</span></p>
</section>
</section>
</section>
<section class="level3" data-number="9.3.5" id="conclusion-12">
<h3 data-number="9.3.5"><span class="koboSpan" id="kobo.650.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.651.1" xmlns="http://www.w3.org/1999/xhtml">In this section, we saw that the strategy pattern went from a simple behavioral GoF pattern to the cornerstone of dependency injection. </span><span class="koboSpan" id="kobo.651.2" xmlns="http://www.w3.org/1999/xhtml">We explored different ways of injecting dependencies with a strong focus on constructor injection.Constructor injection is the most commonly used approach as it injects required dependencies, which we want the most. </span><span class="koboSpan" id="kobo.651.3" xmlns="http://www.w3.org/1999/xhtml">Method injection allows injecting algorithms, shared states, or contexts in a method that could not otherwise access that information. </span><span class="koboSpan" id="kobo.651.4" xmlns="http://www.w3.org/1999/xhtml">We can use property injection to inject optional dependencies, which should rarely happen.You can see optional dependencies as code smells because if the class has an optional role to play, it also has a primary role resulting in dual responsibilities. </span><span class="koboSpan" id="kobo.651.5" xmlns="http://www.w3.org/1999/xhtml">Moreover, if a role is optional, it could be better to move it to another class or rethink the system's design in that specific area.To practice what you just learned, you could connect the code sample to a real database, an Azure Table, Redis, a JSON file, or any other data source—tip: code classes that implement the </span><code><span class="koboSpan" id="kobo.652.1" xmlns="http://www.w3.org/1999/xhtml">ILocationService</span></code><span class="koboSpan" id="kobo.653.1" xmlns="http://www.w3.org/1999/xhtml"> interface.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.654.1" xmlns="http://www.w3.org/1999/xhtml">As we covered, we can inject classes into other classes directly. </span><span class="koboSpan" id="kobo.654.2" xmlns="http://www.w3.org/1999/xhtml">There is nothing wrong with that. </span><span class="koboSpan" id="kobo.654.3" xmlns="http://www.w3.org/1999/xhtml">However, I suggest injecting interfaces as your initial approach until you are confident that you have mastered the different architectural principles and patterns covered in this book.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.655.1" xmlns="http://www.w3.org/1999/xhtml">Next, we explore guard clauses.</span></p>
</section>
</section>
<section class="level2" data-number="9.4" id="understanding-guard-clauses">
<h2 data-number="9.4"><span class="koboSpan" id="kobo.656.1" xmlns="http://www.w3.org/1999/xhtml">Understanding guard clauses</span></h2>
<p><span class="koboSpan" id="kobo.657.1" xmlns="http://www.w3.org/1999/xhtml">A guard clause represents a condition the code must meet before executing a method. </span><span class="koboSpan" id="kobo.657.2" xmlns="http://www.w3.org/1999/xhtml">Essentially, it's a type of code that "guards" against continuing the execution of the method if certain conditions aren't met.In most cases, guard clauses are implemented at the beginning of a method to throw an exception early when the conditions necessary for the method's execution are not satisfied. </span><span class="koboSpan" id="kobo.657.3" xmlns="http://www.w3.org/1999/xhtml">Throwing an exception allows callers to catch the error without the need to implement a more complex communication mechanism.We already stated that we use constructor injection to inject the required dependencies reliably. </span><span class="koboSpan" id="kobo.657.4" xmlns="http://www.w3.org/1999/xhtml">However, nothing fully guarantees us that the dependencies are not </span><code><span class="koboSpan" id="kobo.658.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.659.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.659.2" xmlns="http://www.w3.org/1999/xhtml">Ensuring a dependency is not </span><code><span class="koboSpan" id="kobo.660.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.661.1" xmlns="http://www.w3.org/1999/xhtml"> is one of the most common guard clauses, which is trivial to implement. </span><span class="koboSpan" id="kobo.661.2" xmlns="http://www.w3.org/1999/xhtml">For example, we could check for nulls in the controller by replacing the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.662.1" xmlns="http://www.w3.org/1999/xhtml">_locationService = locationService;</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.663.1" xmlns="http://www.w3.org/1999/xhtml">With the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.664.1" xmlns="http://www.w3.org/1999/xhtml">_locationService = locationService ?? </span><span class="koboSpan" id="kobo.664.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(locationService));</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.665.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code uses a </span><code><span class="koboSpan" id="kobo.666.1" xmlns="http://www.w3.org/1999/xhtml">throw</span></code><span class="koboSpan" id="kobo.667.1" xmlns="http://www.w3.org/1999/xhtml"> expression from C# 7 (See </span><em><span class="koboSpan" id="kobo.668.1" xmlns="http://www.w3.org/1999/xhtml">Appendix A</span></em><span class="koboSpan" id="kobo.669.1" xmlns="http://www.w3.org/1999/xhtml"> for more information). </span><span class="koboSpan" id="kobo.669.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.670.1" xmlns="http://www.w3.org/1999/xhtml">ArgumentNullException</span></code><span class="koboSpan" id="kobo.671.1" xmlns="http://www.w3.org/1999/xhtml"> type makes it evident that the </span><code><span class="koboSpan" id="kobo.672.1" xmlns="http://www.w3.org/1999/xhtml">locationService</span></code><span class="koboSpan" id="kobo.673.1" xmlns="http://www.w3.org/1999/xhtml"> parameter is </span><code><span class="koboSpan" id="kobo.674.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.675.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.675.2" xmlns="http://www.w3.org/1999/xhtml">So if the </span><code><span class="koboSpan" id="kobo.676.1" xmlns="http://www.w3.org/1999/xhtml">locationService</span></code><span class="koboSpan" id="kobo.677.1" xmlns="http://www.w3.org/1999/xhtml"> parameter is </span><code><span class="koboSpan" id="kobo.678.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.679.1" xmlns="http://www.w3.org/1999/xhtml">, an </span><code><span class="koboSpan" id="kobo.680.1" xmlns="http://www.w3.org/1999/xhtml">ArgumentNullException</span></code><span class="koboSpan" id="kobo.681.1" xmlns="http://www.w3.org/1999/xhtml"> is thrown; otherwise, the </span><code><span class="koboSpan" id="kobo.682.1" xmlns="http://www.w3.org/1999/xhtml">locationService</span></code><span class="koboSpan" id="kobo.683.1" xmlns="http://www.w3.org/1999/xhtml"> parameter is assigned to the </span><code><span class="koboSpan" id="kobo.684.1" xmlns="http://www.w3.org/1999/xhtml">_locationService</span></code><span class="koboSpan" id="kobo.685.1" xmlns="http://www.w3.org/1999/xhtml"> member.Of course, with the introduction of the nullable reference types (see </span><em><span class="koboSpan" id="kobo.686.1" xmlns="http://www.w3.org/1999/xhtml">Appendix A</span></em><span class="koboSpan" id="kobo.687.1" xmlns="http://www.w3.org/1999/xhtml">), receiving a </span><code><span class="koboSpan" id="kobo.688.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.689.1" xmlns="http://www.w3.org/1999/xhtml"> argument is less likely yet still possible.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.690.1" xmlns="http://www.w3.org/1999/xhtml">A built-in container will automatically throw an exception if it can’t fulfill all dependencies during the instantiation of a class (such as a controller). </span><span class="koboSpan" id="kobo.690.2" xmlns="http://www.w3.org/1999/xhtml">That does not mean that all third-party containers act the same.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.691.1" xmlns="http://www.w3.org/1999/xhtml">Moreover, that does not protect you from passing </span><code><span class="koboSpan" id="kobo.692.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.693.1" xmlns="http://www.w3.org/1999/xhtml"> to a class you manually instantiates, nor that a method will not receive a </span><code><span class="koboSpan" id="kobo.694.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.695.1" xmlns="http://www.w3.org/1999/xhtml"> value. </span><span class="koboSpan" id="kobo.695.2" xmlns="http://www.w3.org/1999/xhtml">I recommend adding guards even since they are less mandatory now. </span><span class="koboSpan" id="kobo.695.3" xmlns="http://www.w3.org/1999/xhtml">The tooling can handle most of the work for us, leading to only a minor time overhead.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.696.1" xmlns="http://www.w3.org/1999/xhtml">Furthermore, suppose you are writing code consumed by other projects, like a library. </span><span class="koboSpan" id="kobo.696.2" xmlns="http://www.w3.org/1999/xhtml">In that case, adding guards is more important since nothing guarantees that the consumers of that code have nullable reference type checks enabled.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.697.1" xmlns="http://www.w3.org/1999/xhtml">When we need to validate a parameter and don't need an assignment, like with most parameters of a constructor, we can use the following helper, and the BCL handles the check for us:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.698.1" xmlns="http://www.w3.org/1999/xhtml">ArgumentNullException.ThrowIfNull(locationService);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.699.1" xmlns="http://www.w3.org/1999/xhtml">When we need to validate a string and want to ensure it is not empty, we can use the following instead:ArgumentException.ThrowIfNullOrEmpty(name);Of course, we can always revert to </span><code><span class="koboSpan" id="kobo.700.1" xmlns="http://www.w3.org/1999/xhtml">if</span></code><span class="koboSpan" id="kobo.701.1" xmlns="http://www.w3.org/1999/xhtml"> statements to validate parameters. </span><span class="koboSpan" id="kobo.701.2" xmlns="http://www.w3.org/1999/xhtml">When doing so, we must ensure we throw relevant exceptions. </span><span class="koboSpan" id="kobo.701.3" xmlns="http://www.w3.org/1999/xhtml">If no pertinent exceptions exist, we can create one. </span><span class="koboSpan" id="kobo.701.4" xmlns="http://www.w3.org/1999/xhtml">Creating custom exceptions is a great way to write manageable applications.Next, we revisit an (anti-)pattern while exploring the singleton lifetime replacing it.</span></p>
</section>
<section class="level2" data-number="9.5" id="revisiting-the-singleton-pattern">
<h2 data-number="9.5"><span class="koboSpan" id="kobo.702.1" xmlns="http://www.w3.org/1999/xhtml">Revisiting the Singleton pattern</span></h2>
<p><span class="koboSpan" id="kobo.703.1" xmlns="http://www.w3.org/1999/xhtml">The Singleton pattern is obsolete, goes against the SOLID principles, and we replace it with a lifetime, as we’ve already seen. </span><span class="koboSpan" id="kobo.703.2" xmlns="http://www.w3.org/1999/xhtml">This section explores that lifetime and recreates the good old application state, which is nothing more than a singleton-scoped dictionary.We explore two examples: one about the application state, in case you were wondering where that feature disappeared to. </span><span class="koboSpan" id="kobo.703.3" xmlns="http://www.w3.org/1999/xhtml">Then, the Wishlist project also uses the singleton lifetime to provide an application-level feature. </span><span class="koboSpan" id="kobo.703.4" xmlns="http://www.w3.org/1999/xhtml">There are also a few unit tests to play with testability and to allow safe refactoring.</span></p>
<section class="level3" data-number="9.5.1" id="project-application-state">
<h3 data-number="9.5.1"><span class="koboSpan" id="kobo.704.1" xmlns="http://www.w3.org/1999/xhtml">Project – Application state</span></h3>
<p><span class="koboSpan" id="kobo.705.1" xmlns="http://www.w3.org/1999/xhtml">You might remember the application state if you programmed ASP.NET using .NET Framework or the “good” old classic ASP with VBScript. </span><span class="koboSpan" id="kobo.705.2" xmlns="http://www.w3.org/1999/xhtml">If you don’t, the application state was a key/value dictionary that allowed you to store data globally in your application, shared between all sessions and requests. </span><span class="koboSpan" id="kobo.705.3" xmlns="http://www.w3.org/1999/xhtml">That is one of the things that ASP always had and other languages, such as PHP, did not (or do not easily allow).For example, I remember designing a generic reusable typed shopping cart system with classic ASP/VBScript. </span><span class="koboSpan" id="kobo.705.4" xmlns="http://www.w3.org/1999/xhtml">VBScript was not a strongly typed language and had limited object-oriented capabilities. </span><span class="koboSpan" id="kobo.705.5" xmlns="http://www.w3.org/1999/xhtml">The shopping cart fields and types were defined at the application level (once per application), and then each user had their own “instance” containing the products in their “private shopping cart” (created once per session).In ASP.NET Core, there is no more </span><code><span class="koboSpan" id="kobo.706.1" xmlns="http://www.w3.org/1999/xhtml">Application</span></code><span class="koboSpan" id="kobo.707.1" xmlns="http://www.w3.org/1999/xhtml"> dictionary. </span><span class="koboSpan" id="kobo.707.2" xmlns="http://www.w3.org/1999/xhtml">To achieve the same goal, you could use a static class or static members, which is not the best approach; remember that global objects (</span><code><span class="koboSpan" id="kobo.708.1" xmlns="http://www.w3.org/1999/xhtml">static</span></code><span class="koboSpan" id="kobo.709.1" xmlns="http://www.w3.org/1999/xhtml">) make your application harder to test and less flexible. </span><span class="koboSpan" id="kobo.709.2" xmlns="http://www.w3.org/1999/xhtml">We could also use the Singleton pattern or create an ambient context, allowing us to create an application-level instance of an object. </span><span class="koboSpan" id="kobo.709.3" xmlns="http://www.w3.org/1999/xhtml">We could even mix that with a factory to create end-user shopping carts, but we won’t; these are not the best solution either. </span><span class="koboSpan" id="kobo.709.4" xmlns="http://www.w3.org/1999/xhtml">Another way could be to use one of the ASP.NET Core caching mechanisms, memory cache, or distributed cache, but this is a stretch.We could also save everything in a database to persist the shopping cart between visits, but that is not related to the application state and requires more work, potentially a user account, so we will not do that either.We could save the shopping cart on the client-side using cookies, local storage, or any other modern mechanism to save data on the user’s computer. </span><span class="koboSpan" id="kobo.709.5" xmlns="http://www.w3.org/1999/xhtml">However, we’d get even further from the application state than using a database.For most cases requiring an application state-like feature, the best approach would be to create a standard class and an interface and then register the binding with a singleton lifetime in the container. </span><span class="koboSpan" id="kobo.709.6" xmlns="http://www.w3.org/1999/xhtml">Finally, you inject it into the component that needs it, using constructor injection. </span><span class="koboSpan" id="kobo.709.7" xmlns="http://www.w3.org/1999/xhtml">Doing so allows the mocking of dependencies and changing the implementations without touching the code but the composition root.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.710.1" xmlns="http://www.w3.org/1999/xhtml">Sometimes, the best solution is not the technically complex ones or design pattern-oriented; the best solution is often the simplest. </span><span class="koboSpan" id="kobo.710.2" xmlns="http://www.w3.org/1999/xhtml">Less code means less maintenance and fewer tests, resulting in a simpler application.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.711.1" xmlns="http://www.w3.org/1999/xhtml">Let’s implement a small program that simulates the application state. </span><span class="koboSpan" id="kobo.711.2" xmlns="http://www.w3.org/1999/xhtml">The API is a single interface with two implementations. </span><span class="koboSpan" id="kobo.711.3" xmlns="http://www.w3.org/1999/xhtml">The program also exposes part of the API over HTTP, allowing users to get or set a value associated with the specified key. </span><span class="koboSpan" id="kobo.711.4" xmlns="http://www.w3.org/1999/xhtml">We use the singleton lifetime to ensure the data is shared between all requests.The interface looks like the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.712.1" xmlns="http://www.w3.org/1999/xhtml">public interface IApplicationState
{
    TItem? </span><span class="koboSpan" id="kobo.712.2" xmlns="http://www.w3.org/1999/xhtml">Get&lt;TItem&gt;(string key);
    bool Has&lt;TItem&gt;(string key);
    void Set&lt;TItem&gt;(string key, TItem value) where TItem : notnull;
} </span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.713.1" xmlns="http://www.w3.org/1999/xhtml">We can get the value associated with a key, associate a value with a key (set), and validate whether a key exists.The </span><code><span class="koboSpan" id="kobo.714.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.715.1" xmlns="http://www.w3.org/1999/xhtml"> file contains the code responsible for handling HTTP requests. </span><span class="koboSpan" id="kobo.715.2" xmlns="http://www.w3.org/1999/xhtml">We can swap the implementations by commenting or uncommenting the first line of the </span><code><span class="koboSpan" id="kobo.716.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.717.1" xmlns="http://www.w3.org/1999/xhtml"> file, which is </span><code><span class="koboSpan" id="kobo.718.1" xmlns="http://www.w3.org/1999/xhtml">#define USE_MEMORY_CACHE</span></code><span class="koboSpan" id="kobo.719.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.719.2" xmlns="http://www.w3.org/1999/xhtml">That changes the dependency registration, as highlighted in the following code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.720.1" xmlns="http://www.w3.org/1999/xhtml">var builder = WebApplication.CreateBuilder(args);
#if USE_MEMORY_CACHE
        builder.Services.AddMemoryCache();
        builder.Services.AddSingleton&lt;IApplicationState, ApplicationMemoryCache&gt;();
#else
        builder.Services.AddSingleton&lt;IApplicationState,
ApplicationDictionary&gt;();
#endif
var app = builder.Build();
app.MapGet("/", (IApplicationState myAppState, string key) =&gt;
{
    var value = myAppState.Get&lt;string&gt;(key);
    return $"{key} = {value ?? </span><span class="koboSpan" id="kobo.720.2" xmlns="http://www.w3.org/1999/xhtml">"null"}";
});
app.MapPost("/", (IApplicationState myAppState, SetAppState dto) =&gt;
{
    myAppState.Set(dto.Key, dto.Value);
    return $"{dto.Key} = {dto.Value}";
});
app.Run();
public record class SetAppState(string Key, string Value);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.721.1" xmlns="http://www.w3.org/1999/xhtml">Let’s now explore the first implementation.</span></p>
<section class="level4" data-number="9.5.1.1" id="first-implementation">
<h4 data-number="9.5.1.1"><span class="koboSpan" id="kobo.722.1" xmlns="http://www.w3.org/1999/xhtml">First implementation</span></h4>
<p><span class="koboSpan" id="kobo.723.1" xmlns="http://www.w3.org/1999/xhtml">The first implementation uses the memory cache system, and I thought it would be educational to show that to you. </span><span class="koboSpan" id="kobo.723.2" xmlns="http://www.w3.org/1999/xhtml">Caching data in memory is something you might need to do sooner rather than later. </span><span class="koboSpan" id="kobo.723.3" xmlns="http://www.w3.org/1999/xhtml">However, we are hiding the cache system behind our implementation, which is also educational.Here is the </span><code><span class="koboSpan" id="kobo.724.1" xmlns="http://www.w3.org/1999/xhtml">ApplicationMemoryCache</span></code><span class="koboSpan" id="kobo.725.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.726.1" xmlns="http://www.w3.org/1999/xhtml">public class ApplicationMemoryCache : IApplicationState
{
    private readonly IMemoryCache _memoryCache;
    public ApplicationMemoryCache(IMemoryCache memoryCache)
    {
        _memoryCache = memoryCache ?? </span><span class="koboSpan" id="kobo.726.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(memoryCache));
    }
    public TItem Get&lt;TItem&gt;(string key)
    {
        return _memoryCache.Get&lt;TItem&gt;(key);
    }
    public bool Has&lt;TItem&gt;(string key)
    {
        return _memoryCache.TryGetValue&lt;TItem&gt;(key, out _);
    }
    public void Set&lt;TItem&gt;(string key, TItem value)
    {
        _memoryCache.Set(key, value);
    }
}</span></code></pre>
</div>
<blockquote>
<p><strong><span class="koboSpan" id="kobo.727.1" xmlns="http://www.w3.org/1999/xhtml">Note</span></strong></p>
<blockquote>
<p><span class="koboSpan" id="kobo.728.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.729.1" xmlns="http://www.w3.org/1999/xhtml">ApplicationMemoryCache</span></code><span class="koboSpan" id="kobo.730.1" xmlns="http://www.w3.org/1999/xhtml"> class is a thin wrapper over </span><code><span class="koboSpan" id="kobo.731.1" xmlns="http://www.w3.org/1999/xhtml">IMemoryCache</span></code><span class="koboSpan" id="kobo.732.1" xmlns="http://www.w3.org/1999/xhtml">, hiding the implementation details. </span><span class="koboSpan" id="kobo.732.2" xmlns="http://www.w3.org/1999/xhtml">Such a wrapper is similar to the Façade and Adapter patterns we explore in </span><em><span class="koboSpan" id="kobo.733.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 11</span></em><span class="koboSpan" id="kobo.734.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.735.1" xmlns="http://www.w3.org/1999/xhtml">Structural Patterns</span></em><span class="koboSpan" id="kobo.736.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.737.1" xmlns="http://www.w3.org/1999/xhtml">This simple class and two lines in our composition root make it an application-wide key-value store; done already! </span><span class="koboSpan" id="kobo.737.2" xmlns="http://www.w3.org/1999/xhtml">Let’s now explore the second implementation.</span></p>
</section>
<section class="level4" data-number="9.5.1.2" id="second-implementation">
<h4 data-number="9.5.1.2"><span class="koboSpan" id="kobo.738.1" xmlns="http://www.w3.org/1999/xhtml">Second implementation</span></h4>
<p><span class="koboSpan" id="kobo.739.1" xmlns="http://www.w3.org/1999/xhtml">The second implementation uses </span><code><span class="koboSpan" id="kobo.740.1" xmlns="http://www.w3.org/1999/xhtml">ConcurrentDictionary&lt;string, object&gt;</span></code><span class="koboSpan" id="kobo.741.1" xmlns="http://www.w3.org/1999/xhtml"> to store the application state data and ensure thread safety, as multiple users could use the application state simultaneously. </span><span class="koboSpan" id="kobo.741.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.742.1" xmlns="http://www.w3.org/1999/xhtml">ApplicationDictionary</span></code><span class="koboSpan" id="kobo.743.1" xmlns="http://www.w3.org/1999/xhtml"> class is almost as simple as </span><code><span class="koboSpan" id="kobo.744.1" xmlns="http://www.w3.org/1999/xhtml">ApplicationMemoryCache</span></code><span class="koboSpan" id="kobo.745.1" xmlns="http://www.w3.org/1999/xhtml">:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.746.1" xmlns="http://www.w3.org/1999/xhtml">using System.Collections.Concurrent;
namespace ApplicationState;
public class ApplicationDictionary : IApplicationState
{
    private readonly ConcurrentDictionary&lt;string, object&gt; _memoryCache = new();
    public TItem? </span><span class="koboSpan" id="kobo.746.2" xmlns="http://www.w3.org/1999/xhtml">Get&lt;TItem&gt;(string key)
    {
        return _memoryCache.TryGetValue(key, out var item)
            ? </span><span class="koboSpan" id="kobo.746.3" xmlns="http://www.w3.org/1999/xhtml">(TItem)item
            : default;
    }
    public bool Has&lt;TItem&gt;(string key)
    {
        return _memoryCache.TryGetValue(key, out var item) &amp;&amp; item is TItem;
    }
    public void Set&lt;TItem&gt;(string key, TItem value)
        where TItem : notnull
    {
        _memoryCache.AddOrUpdate(key, value, (k, v) =&gt; value);
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.747.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code leverages the </span><code><span class="koboSpan" id="kobo.748.1" xmlns="http://www.w3.org/1999/xhtml">TryGetValue</span></code><span class="koboSpan" id="kobo.749.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.750.1" xmlns="http://www.w3.org/1999/xhtml">AddOrUpdate</span></code><span class="koboSpan" id="kobo.751.1" xmlns="http://www.w3.org/1999/xhtml"> methods to ensure thread safety while keeping the logic to a minimum and ensuring we avoid coding mistakes.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.752.1" xmlns="http://www.w3.org/1999/xhtml">Can you spot the flaw that might cause some problems in this design? </span><span class="koboSpan" id="kobo.752.2" xmlns="http://www.w3.org/1999/xhtml">See the solution at the end of the project section.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.753.1" xmlns="http://www.w3.org/1999/xhtml">Let’s explore how to use the implementations.</span></p>
</section>
<section class="level4" data-number="9.5.1.3" id="using-the-implementations">
<h4 data-number="9.5.1.3"><span class="koboSpan" id="kobo.754.1" xmlns="http://www.w3.org/1999/xhtml">Using the implementations</span></h4>
<p><span class="koboSpan" id="kobo.755.1" xmlns="http://www.w3.org/1999/xhtml">We can now use any of the two implementations without impacting the rest of the program. </span><span class="koboSpan" id="kobo.755.2" xmlns="http://www.w3.org/1999/xhtml">That demonstrates the strength of DI when it comes to dependency management. </span><span class="koboSpan" id="kobo.755.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, we control the lifetime of the dependencies from the composition root.If we were to use the </span><code><span class="koboSpan" id="kobo.756.1" xmlns="http://www.w3.org/1999/xhtml">IApplicationState</span></code><span class="koboSpan" id="kobo.757.1" xmlns="http://www.w3.org/1999/xhtml"> interface in another class, say </span><code><span class="koboSpan" id="kobo.758.1" xmlns="http://www.w3.org/1999/xhtml">SomeConsumer</span></code><span class="koboSpan" id="kobo.759.1" xmlns="http://www.w3.org/1999/xhtml">, its usage could look similar to the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.760.1" xmlns="http://www.w3.org/1999/xhtml">namespace ApplicationState;
public class SomeConsumer
{
    private readonly IApplicationState _myApplicationWideService;
    public SomeConsumer(IapplicationState myApplicationWideService)
    {
        _myApplicationWideService = myApplicationWideService ?? </span><span class="koboSpan" id="kobo.760.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(myApplicationWideService));
    }
    public void Execute()
    {
        if (_myApplicationWideService.Has&lt;string&gt;("some-key"))
        {
            var someValue = _myApplicationWideService.Get&lt;string&gt;("some-key");
            // Do something with someValue
        }
        // Do something else like:
        _myApplicationWideService.Set("some-key", "some-value");
        // More logic here
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.761.1" xmlns="http://www.w3.org/1999/xhtml">In that code, </span><code><span class="koboSpan" id="kobo.762.1" xmlns="http://www.w3.org/1999/xhtml">SomeConsumer</span></code><span class="koboSpan" id="kobo.763.1" xmlns="http://www.w3.org/1999/xhtml"> depends only on the </span><code><span class="koboSpan" id="kobo.764.1" xmlns="http://www.w3.org/1999/xhtml">IApplicationState</span></code><span class="koboSpan" id="kobo.765.1" xmlns="http://www.w3.org/1999/xhtml"> interface, not </span><code><span class="koboSpan" id="kobo.766.1" xmlns="http://www.w3.org/1999/xhtml">ApplicationDictionary</span></code><span class="koboSpan" id="kobo.767.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.768.1" xmlns="http://www.w3.org/1999/xhtml">ApplicationMemoryCache</span></code><span class="koboSpan" id="kobo.769.1" xmlns="http://www.w3.org/1999/xhtml">, and even less on </span><code><span class="koboSpan" id="kobo.770.1" xmlns="http://www.w3.org/1999/xhtml">IMemoryCache</span></code><span class="koboSpan" id="kobo.771.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.772.1" xmlns="http://www.w3.org/1999/xhtml">ConcurrentDictionary&lt;string, object&gt;</span></code><span class="koboSpan" id="kobo.773.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.773.2" xmlns="http://www.w3.org/1999/xhtml">Using DI allows us to hide the implementation by inverting the flow of dependencies. </span><span class="koboSpan" id="kobo.773.3" xmlns="http://www.w3.org/1999/xhtml">It also breaks direct coupling between concrete implementations. </span><span class="koboSpan" id="kobo.773.4" xmlns="http://www.w3.org/1999/xhtml">This approach also promotes programming against interfaces, as recommended by the Dependency Inversion Principle (DIP), and facilitates the creation of open-closed classes, in accordance with the Open/Closed Principle (OCP).Here is a diagram illustrating our application state system, making it visually easier to notice how it breaks coupling:</span></p>
<figure>
<span class="koboSpan" id="kobo.774.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 8.2: DI-oriented diagram representing the application state system" src="../media/file43.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.775.1" xmlns="http://www.w3.org/1999/xhtml">Figure 8.2: DI-oriented diagram representing the application state system</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.776.1" xmlns="http://www.w3.org/1999/xhtml">From this sample, let’s remember that the singleton lifetime allows us to reuse objects between requests and share them application-wide. </span><span class="koboSpan" id="kobo.776.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, hiding implementation details behind interfaces can improve the flexibility of our design.It is important to note that the singleton scope is only valid in a single process, so you can’t rely purely on in-memory mechanisms for larger applications that span multiple servers. </span><span class="koboSpan" id="kobo.776.3" xmlns="http://www.w3.org/1999/xhtml">We could use the </span><code><span class="koboSpan" id="kobo.777.1" xmlns="http://www.w3.org/1999/xhtml">IDistributedCache</span></code><span class="koboSpan" id="kobo.778.1" xmlns="http://www.w3.org/1999/xhtml"> interface to circumvent this limitation and persist our application state system to a persistent caching tool, like Redis.</span></p>
<blockquote>
<p><strong><span class="koboSpan" id="kobo.779.1" xmlns="http://www.w3.org/1999/xhtml">The flaw</span></strong><span class="koboSpan" id="kobo.780.1" xmlns="http://www.w3.org/1999/xhtml">: If we look closely at the </span><code><span class="koboSpan" id="kobo.781.1" xmlns="http://www.w3.org/1999/xhtml">Has&lt;TItem&gt;</span></code><span class="koboSpan" id="kobo.782.1" xmlns="http://www.w3.org/1999/xhtml"> method, it returns true only when an entry is present for the specified key AND has the right type. </span><span class="koboSpan" id="kobo.782.2" xmlns="http://www.w3.org/1999/xhtml">So we could override an entry of a different type without knowing it exists.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.783.1" xmlns="http://www.w3.org/1999/xhtml">For example, </span><code><span class="koboSpan" id="kobo.784.1" xmlns="http://www.w3.org/1999/xhtml">ConsumerA</span></code><span class="koboSpan" id="kobo.785.1" xmlns="http://www.w3.org/1999/xhtml"> sets an item of type </span><code><span class="koboSpan" id="kobo.786.1" xmlns="http://www.w3.org/1999/xhtml">A</span></code><span class="koboSpan" id="kobo.787.1" xmlns="http://www.w3.org/1999/xhtml"> for the key </span><code><span class="koboSpan" id="kobo.788.1" xmlns="http://www.w3.org/1999/xhtml">K</span></code><span class="koboSpan" id="kobo.789.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.789.2" xmlns="http://www.w3.org/1999/xhtml">Elsewhere in the code, </span><code><span class="koboSpan" id="kobo.790.1" xmlns="http://www.w3.org/1999/xhtml">ConsumerB</span></code><span class="koboSpan" id="kobo.791.1" xmlns="http://www.w3.org/1999/xhtml"> looks to see if an item of type </span><code><span class="koboSpan" id="kobo.792.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.793.1" xmlns="http://www.w3.org/1999/xhtml"> exists for the key </span><code><span class="koboSpan" id="kobo.794.1" xmlns="http://www.w3.org/1999/xhtml">K</span></code><span class="koboSpan" id="kobo.795.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.795.2" xmlns="http://www.w3.org/1999/xhtml">The method returns </span><code><span class="koboSpan" id="kobo.796.1" xmlns="http://www.w3.org/1999/xhtml">false</span></code><span class="koboSpan" id="kobo.797.1" xmlns="http://www.w3.org/1999/xhtml"> because it’s a different type. </span><code><span class="koboSpan" id="kobo.798.1" xmlns="http://www.w3.org/1999/xhtml">ConsumerB</span></code><span class="koboSpan" id="kobo.799.1" xmlns="http://www.w3.org/1999/xhtml"> overrides the value of the </span><code><span class="koboSpan" id="kobo.800.1" xmlns="http://www.w3.org/1999/xhtml">K</span></code><span class="koboSpan" id="kobo.801.1" xmlns="http://www.w3.org/1999/xhtml"> with an object of type </span><code><span class="koboSpan" id="kobo.802.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.803.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.803.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the code representing this:</span></p>
</blockquote>
</blockquote>
<pre><code><span class="koboSpan" id="kobo.804.1" xmlns="http://www.w3.org/1999/xhtml">// Arrange
var sp = new ServiceCollection()
    .AddSingleton&lt;IApplicationState, ApplicationDictionary&gt;()
    .BuildServiceProvider()
;
// Step 1: Consumer A sets a string
var consumerA = sp.GetRequiredService&lt;IApplicationState&gt;();
consumerA.Set("K", "A");
Assert.True(consumerA.Has&lt;string&gt;("K")); // true
// Step 2: Consumer B overrides the value with an int
var consumerB = sp.GetRequiredService&lt;IApplicationState&gt;();
if (!consumerB.Has&lt;int&gt;("K")) // Oops, key K exists but it's of type string, not int
{
    consumerB.Set("K", 123);
}
Assert.True(consumerB.Has&lt;int&gt;("K")); // true
// Consumer A is broken!
</span><span class="koboSpan" id="kobo.804.2" xmlns="http://www.w3.org/1999/xhtml">Assert.False(consumerA.Has&lt;string&gt;("K")); // false</span></code></pre>
<blockquote>
<p><span class="koboSpan" id="kobo.805.1" xmlns="http://www.w3.org/1999/xhtml">Improving the design to support such a scenario could be a good practice exercise. </span><span class="koboSpan" id="kobo.805.2" xmlns="http://www.w3.org/1999/xhtml">You could, for example, remove the </span><code><span class="koboSpan" id="kobo.806.1" xmlns="http://www.w3.org/1999/xhtml">TItem</span></code><span class="koboSpan" id="kobo.807.1" xmlns="http://www.w3.org/1999/xhtml"> type from the </span><code><span class="koboSpan" id="kobo.808.1" xmlns="http://www.w3.org/1999/xhtml">Has</span></code><span class="koboSpan" id="kobo.809.1" xmlns="http://www.w3.org/1999/xhtml"> method or, even better, allow storing multiple items under the same key, as long as their types are different.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.810.1" xmlns="http://www.w3.org/1999/xhtml">Let’s now explore the next project.</span></p>
</section>
</section>
<section class="level3" data-number="9.5.2" id="project-wishlist">
<h3 data-number="9.5.2"><span class="koboSpan" id="kobo.811.1" xmlns="http://www.w3.org/1999/xhtml">Project – Wishlist</span></h3>
<p><span class="koboSpan" id="kobo.812.1" xmlns="http://www.w3.org/1999/xhtml">Let’s get into another sample to illustrate using the singleton lifetime and DI. </span><span class="koboSpan" id="kobo.812.2" xmlns="http://www.w3.org/1999/xhtml">Seeing DI in action should help understand it and then leverage it to create SOLID software.</span><strong><span class="koboSpan" id="kobo.813.1" xmlns="http://www.w3.org/1999/xhtml">Context</span></strong><span class="koboSpan" id="kobo.814.1" xmlns="http://www.w3.org/1999/xhtml">: The application is a site-wide wishlist where users can add items. </span><span class="koboSpan" id="kobo.814.2" xmlns="http://www.w3.org/1999/xhtml">Items expire every 30 seconds. </span><span class="koboSpan" id="kobo.814.3" xmlns="http://www.w3.org/1999/xhtml">When a user adds an existing item, the system must increment the count and reset the item’s expiration time. </span><span class="koboSpan" id="kobo.814.4" xmlns="http://www.w3.org/1999/xhtml">That way, popular items stay on the list longer, making it to the top. </span><span class="koboSpan" id="kobo.814.5" xmlns="http://www.w3.org/1999/xhtml">When displayed, the system must sort the items by count (highest count first).</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.815.1" xmlns="http://www.w3.org/1999/xhtml">An expiration time of 30 seconds is very fast, but I’m sure you don’t want to wait days before an item expires when running the app. </span><span class="koboSpan" id="kobo.815.2" xmlns="http://www.w3.org/1999/xhtml">It is a test config.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.816.1" xmlns="http://www.w3.org/1999/xhtml">The program is a tiny web API that exposes two endpoints:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.817.1" xmlns="http://www.w3.org/1999/xhtml">Add an item to the wishlist (</span><code><span class="koboSpan" id="kobo.818.1" xmlns="http://www.w3.org/1999/xhtml">POST</span></code><span class="koboSpan" id="kobo.819.1" xmlns="http://www.w3.org/1999/xhtml">).</span></li>
<li><span class="koboSpan" id="kobo.820.1" xmlns="http://www.w3.org/1999/xhtml">Read the wishlist (</span><code><span class="koboSpan" id="kobo.821.1" xmlns="http://www.w3.org/1999/xhtml">GET</span></code><span class="koboSpan" id="kobo.822.1" xmlns="http://www.w3.org/1999/xhtml">).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.823.1" xmlns="http://www.w3.org/1999/xhtml">The wishlist interface looks like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.824.1" xmlns="http://www.w3.org/1999/xhtml">public interface IWishList
{
    Task&lt;WishListItem&gt; AddOrRefreshAsync(string itemName);
    Task&lt;IEnumerable&lt;WishListItem&gt;&gt; AllAsync();
}
public record class WishListItem(string Name, int Count, DateTimeOffset Expiration);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.825.1" xmlns="http://www.w3.org/1999/xhtml">The two operations are there, and by making them async (returning a </span><code><span class="koboSpan" id="kobo.826.1" xmlns="http://www.w3.org/1999/xhtml">Task&lt;T&gt;</span></code><span class="koboSpan" id="kobo.827.1" xmlns="http://www.w3.org/1999/xhtml">), we could implement another version that relies on a remote system, such as a database, instead of an in-memory store. </span><span class="koboSpan" id="kobo.827.2" xmlns="http://www.w3.org/1999/xhtml">Then, the </span><code><span class="koboSpan" id="kobo.828.1" xmlns="http://www.w3.org/1999/xhtml">WishListItem</span></code><span class="koboSpan" id="kobo.829.1" xmlns="http://www.w3.org/1999/xhtml"> record class is part of the </span><code><span class="koboSpan" id="kobo.830.1" xmlns="http://www.w3.org/1999/xhtml">IWishList</span></code><span class="koboSpan" id="kobo.831.1" xmlns="http://www.w3.org/1999/xhtml"> contract; it is the model. </span><span class="koboSpan" id="kobo.831.2" xmlns="http://www.w3.org/1999/xhtml">To keep it simple, the wishlist only stores the names of items.</span></p>
<blockquote>
<p><strong><span class="koboSpan" id="kobo.832.1" xmlns="http://www.w3.org/1999/xhtml">Note</span></strong></p>
<blockquote>
<p><span class="koboSpan" id="kobo.833.1" xmlns="http://www.w3.org/1999/xhtml">Trying to foresee the future is not usually a good idea, but designing APIs to be awaitable is generally a safe bet. </span><span class="koboSpan" id="kobo.833.2" xmlns="http://www.w3.org/1999/xhtml">Other than this, I’d recommend you stick to the simplest code that satisfies the program's needs (KISS). </span><span class="koboSpan" id="kobo.833.3" xmlns="http://www.w3.org/1999/xhtml">When you try to solve problems that do not exist yet, you usually end up coding a lot of useless stuff, leading to additional unnecessary maintenance and testing time.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.834.1" xmlns="http://www.w3.org/1999/xhtml">In the composition root, we must serve the </span><code><span class="koboSpan" id="kobo.835.1" xmlns="http://www.w3.org/1999/xhtml">IWishList</span></code><span class="koboSpan" id="kobo.836.1" xmlns="http://www.w3.org/1999/xhtml"> implementation instance in a singleton scope (highlighted) so all requests share the same instance. </span><span class="koboSpan" id="kobo.836.2" xmlns="http://www.w3.org/1999/xhtml">Let’s start with the first half of the </span><code><span class="koboSpan" id="kobo.837.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.838.1" xmlns="http://www.w3.org/1999/xhtml"> file:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.839.1" xmlns="http://www.w3.org/1999/xhtml">var builder = WebApplication.CreateBuilder(args);
builder.Services
    .ConfigureOptions&lt;InMemoryWishListOptions&gt;()
    .AddTransient&lt;IValidateOptions&lt;InMemoryWishListOptions&gt;, InMemoryWishListOptions&gt;()
    .AddSingleton(serviceProvider =&gt; serviceProvider.GetRequiredService&lt;IOptions&lt;InMemoryWishListOptions&gt;&gt;().Value)
    // The singleton registration
    .AddSingleton&lt;IWishList, InMemoryWishList&gt;() 
;</span></code></pre>
</div>
<blockquote>
<p><span class="koboSpan" id="kobo.840.1" xmlns="http://www.w3.org/1999/xhtml">If you are wondering where </span><code><span class="koboSpan" id="kobo.841.1" xmlns="http://www.w3.org/1999/xhtml">IConfigureOptions</span></code><span class="koboSpan" id="kobo.842.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.843.1" xmlns="http://www.w3.org/1999/xhtml">IValidateOptions</span></code><span class="koboSpan" id="kobo.844.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><code><span class="koboSpan" id="kobo.845.1" xmlns="http://www.w3.org/1999/xhtml">IOptions</span></code><span class="koboSpan" id="kobo.846.1" xmlns="http://www.w3.org/1999/xhtml"> come from, we cover the ASP.NET Core Options pattern in </span><em><span class="koboSpan" id="kobo.847.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 9</span></em><span class="koboSpan" id="kobo.848.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.849.1" xmlns="http://www.w3.org/1999/xhtml">Options, Settings, and Configuration</span></em><span class="koboSpan" id="kobo.850.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.851.1" xmlns="http://www.w3.org/1999/xhtml">Let’s now look at the second half of the </span><code><span class="koboSpan" id="kobo.852.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.853.1" xmlns="http://www.w3.org/1999/xhtml"> file that contains the minimal API code to handle the HTTP requests:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.854.1" xmlns="http://www.w3.org/1999/xhtml">var app = builder.Build();
app.MapGet("/", async (IWishList wishList) =&gt; 
    await wishList.AllAsync());
app.MapPost("/", async (IWishList wishList, CreateItem? </span><span class="koboSpan" id="kobo.854.2" xmlns="http://www.w3.org/1999/xhtml">newItem) =&gt;
{
    if (newItem?.Name == null)
    {
        return Results.BadRequest();
    }
    var item = await wishList.AddOrRefreshAsync(newItem.Name);
    return Results.Created("/", item);
});
app.Run();
public record class CreateItem(string? </span><span class="koboSpan" id="kobo.854.3" xmlns="http://www.w3.org/1999/xhtml">Name);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.855.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.856.1" xmlns="http://www.w3.org/1999/xhtml">GET</span></code><span class="koboSpan" id="kobo.857.1" xmlns="http://www.w3.org/1999/xhtml"> endpoint delegates the logic to the injected </span><code><span class="koboSpan" id="kobo.858.1" xmlns="http://www.w3.org/1999/xhtml">IWishList</span></code><span class="koboSpan" id="kobo.859.1" xmlns="http://www.w3.org/1999/xhtml"> implementation and returns the result, while the </span><code><span class="koboSpan" id="kobo.860.1" xmlns="http://www.w3.org/1999/xhtml">POST</span></code><span class="koboSpan" id="kobo.861.1" xmlns="http://www.w3.org/1999/xhtml"> endpoint validates the </span><code><span class="koboSpan" id="kobo.862.1" xmlns="http://www.w3.org/1999/xhtml">CreateItem</span></code><span class="koboSpan" id="kobo.863.1" xmlns="http://www.w3.org/1999/xhtml"> DTO before delegating the logic to the wishlist.To help us implement the </span><code><span class="koboSpan" id="kobo.864.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryWishList</span></code><span class="koboSpan" id="kobo.865.1" xmlns="http://www.w3.org/1999/xhtml"> class, we started by writing some tests to back our specifications up. </span><span class="koboSpan" id="kobo.865.2" xmlns="http://www.w3.org/1999/xhtml">Since static members are hard to configure in tests (remember globals?), I borrowed a concept from the ASP.NET Core memory cache and created an </span><code><span class="koboSpan" id="kobo.866.1" xmlns="http://www.w3.org/1999/xhtml">ISystemClock</span></code><span class="koboSpan" id="kobo.867.1" xmlns="http://www.w3.org/1999/xhtml"> interface that abstracts away the static call to </span><code><span class="koboSpan" id="kobo.868.1" xmlns="http://www.w3.org/1999/xhtml">DateTimeOffset.UtcNow</span></code><span class="koboSpan" id="kobo.869.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.870.1" xmlns="http://www.w3.org/1999/xhtml">DateTime.UtcNow</span></code><span class="koboSpan" id="kobo.871.1" xmlns="http://www.w3.org/1999/xhtml">.This way, we can program the value of </span><code><span class="koboSpan" id="kobo.872.1" xmlns="http://www.w3.org/1999/xhtml">UtcNow</span></code><span class="koboSpan" id="kobo.873.1" xmlns="http://www.w3.org/1999/xhtml"> in our tests to create expired items. </span><span class="koboSpan" id="kobo.873.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the clock interface and implementation:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.874.1" xmlns="http://www.w3.org/1999/xhtml">namespace Wishlist.Internal;
public interface ISystemClock
{
    DateTimeOffset UtcNow { get; }
}
public class SystemClock : ISystemClock
{
    public DateTimeOffset UtcNow =&gt; DateTimeOffset.UtcNow;
}</span></code></pre>
</div>
<blockquote>
<p><span class="koboSpan" id="kobo.875.1" xmlns="http://www.w3.org/1999/xhtml">.NET 8 adds a new </span><code><span class="koboSpan" id="kobo.876.1" xmlns="http://www.w3.org/1999/xhtml">TimeProvider</span></code><span class="koboSpan" id="kobo.877.1" xmlns="http://www.w3.org/1999/xhtml"> class to the </span><code><span class="koboSpan" id="kobo.878.1" xmlns="http://www.w3.org/1999/xhtml">System</span></code><span class="koboSpan" id="kobo.879.1" xmlns="http://www.w3.org/1999/xhtml"> namespace, which does not help us much here. </span><span class="koboSpan" id="kobo.879.2" xmlns="http://www.w3.org/1999/xhtml">However, if we want to leverage that API, we could update the SystemClock to the following:</span></p>
</blockquote>
<pre><code><span class="koboSpan" id="kobo.880.1" xmlns="http://www.w3.org/1999/xhtml">public class CustomClock : ISystemClock
{
    private readonly TimeProvider _timeProvider;
    public CustomClock(TimeProvider timeProvider)
    {
        _timeProvider = timeProvider ?? </span><span class="koboSpan" id="kobo.880.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(timeProvider));
    }
    public DateTimeOffset UtcNow =&gt; _timeProvider.GetUtcNow();
}</span></code></pre>
<blockquote>
<p><span class="koboSpan" id="kobo.881.1" xmlns="http://www.w3.org/1999/xhtml">That code leverages the new API, but we’ll stick to our simple implementation instead.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.882.1" xmlns="http://www.w3.org/1999/xhtml">Let’s look at the outline of the unit tests next because the whole code would take pages and be of low value:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.883.1" xmlns="http://www.w3.org/1999/xhtml">namespace Wishlist;
public class InMemoryWishListTest
{
    // Constructor and private fields omitted
    public class AddOrRefreshAsync : InMemoryWishListTest
    {
        [Fact]
        public async Task Should_create_new_item();
        [Fact]
        public async Task Should_increment_Count_of_an_existing_item();
        [Fact]
        public async Task Should_set_the_new_Expiration_date_of_an_existing_item();
        [Fact]
        public async Task Should_set_the_Count_of_expired_items_to_1();
        [Fact]
        public async Task Should_remove_expired_items();
    }
    public class AllAsync : InMemoryWishListTest
    {
        [Fact]
        public async Task Should_return_items_ordered_by_Count_Descending();
        [Fact]
        public async Task Should_not_return_expired_items();
    }
    // Private helper methods omitted
}</span></code></pre>
</div>
<blockquote>
<p><span class="koboSpan" id="kobo.884.1" xmlns="http://www.w3.org/1999/xhtml">The full source code is on GitHub: </span><a href="https://adpg.link/ywy8"><span class="koboSpan" id="kobo.885.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/ywy8</span></a><span class="koboSpan" id="kobo.886.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.887.1" xmlns="http://www.w3.org/1999/xhtml">In the test class, we can mock the </span><code><span class="koboSpan" id="kobo.888.1" xmlns="http://www.w3.org/1999/xhtml">ISystemClock</span></code><span class="koboSpan" id="kobo.889.1" xmlns="http://www.w3.org/1999/xhtml"> interface and program it to obtain the desired results based on each test case. </span><span class="koboSpan" id="kobo.889.2" xmlns="http://www.w3.org/1999/xhtml">We can also program some helper methods to make it easier to read the tests. </span><span class="koboSpan" id="kobo.889.3" xmlns="http://www.w3.org/1999/xhtml">Those helpers use tuples to return multiple values (see </span><em><span class="koboSpan" id="kobo.890.1" xmlns="http://www.w3.org/1999/xhtml">Appendix A</span></em><span class="koboSpan" id="kobo.891.1" xmlns="http://www.w3.org/1999/xhtml"> for more information on language features). </span><span class="koboSpan" id="kobo.891.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the mock field:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.892.1" xmlns="http://www.w3.org/1999/xhtml">private readonly Mock&lt;ISystemClock&gt; _systemClockMock = new();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.893.1" xmlns="http://www.w3.org/1999/xhtml">Here’s an example of such a helper method setting the clock to the present time and the </span><code><span class="koboSpan" id="kobo.894.1" xmlns="http://www.w3.org/1999/xhtml">ExpectedExpiryTime</span></code><span class="koboSpan" id="kobo.895.1" xmlns="http://www.w3.org/1999/xhtml"> to a later time (</span><code><span class="koboSpan" id="kobo.896.1" xmlns="http://www.w3.org/1999/xhtml">UtcNow + ExpirationInSeconds</span></code><span class="koboSpan" id="kobo.897.1" xmlns="http://www.w3.org/1999/xhtml"> later):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.898.1" xmlns="http://www.w3.org/1999/xhtml">private (DateTimeOffset UtcNow, DateTimeOffset ExpectedExpiryTime) SetUtcNow()
{
    var utcNow = DateTimeOffset.UtcNow;
    _systemClockMock.Setup(x =&gt; x.UtcNow).Returns(utcNow);
    var expectedExpiryTime = utcNow.AddSeconds(_options.ExpirationInSeconds);
    return (utcNow, expectedExpiryTime);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.899.1" xmlns="http://www.w3.org/1999/xhtml">Here is an example of another helper method setting the clock and the </span><code><span class="koboSpan" id="kobo.900.1" xmlns="http://www.w3.org/1999/xhtml">ExpectedExpiryTime</span></code><span class="koboSpan" id="kobo.901.1" xmlns="http://www.w3.org/1999/xhtml"> to the past (two-time </span><code><span class="koboSpan" id="kobo.902.1" xmlns="http://www.w3.org/1999/xhtml">ExpirationInSeconds</span></code><span class="koboSpan" id="kobo.903.1" xmlns="http://www.w3.org/1999/xhtml"> for the clock and once </span><code><span class="koboSpan" id="kobo.904.1" xmlns="http://www.w3.org/1999/xhtml">ExpirationInSeconds</span></code><span class="koboSpan" id="kobo.905.1" xmlns="http://www.w3.org/1999/xhtml"> for the </span><code><span class="koboSpan" id="kobo.906.1" xmlns="http://www.w3.org/1999/xhtml">ExpectedExpiryTime</span></code><span class="koboSpan" id="kobo.907.1" xmlns="http://www.w3.org/1999/xhtml">):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.908.1" xmlns="http://www.w3.org/1999/xhtml">private (DateTimeOffset UtcNow, DateTimeOffset ExpectedExpiryTime) SetUtcNowToExpired()
{
    var delay = -(_options.ExpirationInSeconds * 2);
    var utcNow = DateTimeOffset.UtcNow.AddSeconds(delay);
    _systemClockMock.Setup(x =&gt; x.UtcNow).Returns(utcNow);
    var expectedExpiryTime = utcNow.AddSeconds(_options.ExpirationInSeconds);
    return (utcNow, expectedExpiryTime);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.909.1" xmlns="http://www.w3.org/1999/xhtml">We now have five tests covering the </span><code><span class="koboSpan" id="kobo.910.1" xmlns="http://www.w3.org/1999/xhtml">AddOrRefreshAsync</span></code><span class="koboSpan" id="kobo.911.1" xmlns="http://www.w3.org/1999/xhtml"> method and two covering the </span><code><span class="koboSpan" id="kobo.912.1" xmlns="http://www.w3.org/1999/xhtml">AllAsync</span></code><span class="koboSpan" id="kobo.913.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.913.2" xmlns="http://www.w3.org/1999/xhtml">Now that we have those failing tests, here is the implementation of the </span><code><span class="koboSpan" id="kobo.914.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryWishList</span></code><span class="koboSpan" id="kobo.915.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.916.1" xmlns="http://www.w3.org/1999/xhtml">namespace Wishlist;
public class InMemoryWishList : IWishList
{
    private readonly InMemoryWishListOptions _options;
    private readonly ConcurrentDictionary&lt;string, InternalItem&gt; _items = new();
    public InMemoryWishList(InMemoryWishListOptions options)
    {
        _options = options ?? </span><span class="koboSpan" id="kobo.916.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(options));
    }
    public Task&lt;WishListItem&gt; AddOrRefreshAsync(string itemName)
    {
        var expirationTime = _options.SystemClock.UtcNow.AddSeconds(_options.ExpirationInSeconds);
        _items
            .Where(x =&gt; x.Value.Expiration &lt; _options.SystemClock.UtcNow)
            .Select(x =&gt; x.Key)
            .ToList()
            .ForEach(key =&gt; _items.Remove(key, out _))
        ;
        var item = _items.AddOrUpdate(
            itemName,
            new InternalItem(Count: 1, Expiration: expirationTime),
            (string key, InternalItem item) =&gt; item with {
                Count = item.Count + 1,
                Expiration = expirationTime
            }            
        );
        var wishlistItem = new WishListItem(
            Name: itemName,
            Count: item.Count,
            Expiration: item.Expiration
        );
        return Task.FromResult(wishlistItem);
    }
    public Task&lt;IEnumerable&lt;WishListItem&gt;&gt; AllAsync()
    {
        var items = _items
            .Where(x =&gt; x.Value.Expiration &gt;= _options.SystemClock.UtcNow)
            .Select(x =&gt; new WishListItem(
                Name: x.Key,
                Count: x.Value.Count,
                Expiration: x.Value.Expiration
            ))
            .OrderByDescending(x =&gt; x.Count)
            .AsEnumerable()
        ;
        return Task.FromResult(items);
    }
    private record class InternalItem(int Count, DateTimeOffset Expiration);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.917.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.918.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryWishList</span></code><span class="koboSpan" id="kobo.919.1" xmlns="http://www.w3.org/1999/xhtml"> class uses </span><code><span class="koboSpan" id="kobo.920.1" xmlns="http://www.w3.org/1999/xhtml">ConcurrentDictionary&lt;string, InternalItem&gt;</span></code><span class="koboSpan" id="kobo.921.1" xmlns="http://www.w3.org/1999/xhtml"> internally to store the items and make the wishlist thread-safe. </span><span class="koboSpan" id="kobo.921.2" xmlns="http://www.w3.org/1999/xhtml">It also uses a </span><code><span class="koboSpan" id="kobo.922.1" xmlns="http://www.w3.org/1999/xhtml">with</span></code><span class="koboSpan" id="kobo.923.1" xmlns="http://www.w3.org/1999/xhtml"> expression to manipulate and copy the </span><code><span class="koboSpan" id="kobo.924.1" xmlns="http://www.w3.org/1999/xhtml">InternalItem</span></code><span class="koboSpan" id="kobo.925.1" xmlns="http://www.w3.org/1999/xhtml"> record class.The </span><code><span class="koboSpan" id="kobo.926.1" xmlns="http://www.w3.org/1999/xhtml">AllAsync</span></code><span class="koboSpan" id="kobo.927.1" xmlns="http://www.w3.org/1999/xhtml"> method filters out expired items, while the </span><code><span class="koboSpan" id="kobo.928.1" xmlns="http://www.w3.org/1999/xhtml">AddOrRefreshAsync</span></code><span class="koboSpan" id="kobo.929.1" xmlns="http://www.w3.org/1999/xhtml"> method removes expired items. </span><span class="koboSpan" id="kobo.929.2" xmlns="http://www.w3.org/1999/xhtml">This might not be the most advanced logic ever, but that does the trick.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.930.1" xmlns="http://www.w3.org/1999/xhtml">You might have noticed that the code is not the most elegant of all, and I left it this way on purpose. </span><span class="koboSpan" id="kobo.930.2" xmlns="http://www.w3.org/1999/xhtml">While using the test suite, I invite you to refactor the methods of the </span><code><span class="koboSpan" id="kobo.931.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryWishList</span></code><span class="koboSpan" id="kobo.932.1" xmlns="http://www.w3.org/1999/xhtml"> class to be more readable.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.933.1" xmlns="http://www.w3.org/1999/xhtml">I took a few minutes to refactor it myself and saved it as </span><code><span class="koboSpan" id="kobo.934.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryWishListRefactored</span></code><span class="koboSpan" id="kobo.935.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.935.2" xmlns="http://www.w3.org/1999/xhtml">You can also uncomment the first line of </span><code><span class="koboSpan" id="kobo.936.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryWishListTest.cs</span></code><span class="koboSpan" id="kobo.937.1" xmlns="http://www.w3.org/1999/xhtml"> to test that class instead of the main one. </span><span class="koboSpan" id="kobo.937.2" xmlns="http://www.w3.org/1999/xhtml">My refactoring is a way to make the code cleaner, to give you ideas. </span><span class="koboSpan" id="kobo.937.3" xmlns="http://www.w3.org/1999/xhtml">It is not the only way, nor the best way, to write that class (the “best way” being subjective).</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.938.1" xmlns="http://www.w3.org/1999/xhtml">Lastly, optimizing for readability and performance are often very different things.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.939.1" xmlns="http://www.w3.org/1999/xhtml">Back to DI, the line that makes the wishlist shared between users is in the composition root we explored earlier. </span><span class="koboSpan" id="kobo.939.2" xmlns="http://www.w3.org/1999/xhtml">As a reference, here it is:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.940.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddSingleton&lt;IWishList, InMemoryWishList&gt;();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.941.1" xmlns="http://www.w3.org/1999/xhtml">Yes, only that line makes all the difference between creating multiple instances and a single shared instance. </span><span class="koboSpan" id="kobo.941.2" xmlns="http://www.w3.org/1999/xhtml">Setting the lifetime to Singleton allows you to open multiple browsers and share the wishlist.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.942.1" xmlns="http://www.w3.org/1999/xhtml">To </span><code><span class="koboSpan" id="kobo.943.1" xmlns="http://www.w3.org/1999/xhtml">POST</span></code><span class="koboSpan" id="kobo.944.1" xmlns="http://www.w3.org/1999/xhtml"> to the API, I recommend using the </span><code><span class="koboSpan" id="kobo.945.1" xmlns="http://www.w3.org/1999/xhtml">Wishlist.http</span></code><span class="koboSpan" id="kobo.946.1" xmlns="http://www.w3.org/1999/xhtml"> file in the project or the Postman collection (</span><a href="https://adpg.link/postman6"><span class="koboSpan" id="kobo.947.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/postman6</span></a><span class="koboSpan" id="kobo.948.1" xmlns="http://www.w3.org/1999/xhtml">) that comes with the book. </span><span class="koboSpan" id="kobo.948.2" xmlns="http://www.w3.org/1999/xhtml">The collection already contains multiple requests you can execute in batches or individually. </span><span class="koboSpan" id="kobo.948.3" xmlns="http://www.w3.org/1999/xhtml">You can also use the Swagger UI that I added to the project.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.949.1" xmlns="http://www.w3.org/1999/xhtml">That’s it! </span><span class="koboSpan" id="kobo.949.2" xmlns="http://www.w3.org/1999/xhtml">All that code to demo what a single line of code in the composition root can do, and we have a working program, as tiny as it may be.</span></p>
</section>
<section class="level3" data-number="9.5.3" id="conclusion-13">
<h3 data-number="9.5.3"><span class="koboSpan" id="kobo.950.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.951.1" xmlns="http://www.w3.org/1999/xhtml">This section explored replacing the classic Singleton pattern with a standard instantiable class registered with a singleton lifetime. </span><span class="koboSpan" id="kobo.951.2" xmlns="http://www.w3.org/1999/xhtml">We looked at the old application state, learned that it was no more, and implemented two versions of it. </span><span class="koboSpan" id="kobo.951.3" xmlns="http://www.w3.org/1999/xhtml">We no longer need that, but it was a good way of learning about singletons.We then implemented a wishlist system as a second example. </span><span class="koboSpan" id="kobo.951.4" xmlns="http://www.w3.org/1999/xhtml">We concluded that the whole thing was working due to and managed by a single line of the composition root: the call to the </span><code><span class="koboSpan" id="kobo.952.1" xmlns="http://www.w3.org/1999/xhtml">AddSingleton</span></code><span class="koboSpan" id="kobo.953.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.953.2" xmlns="http://www.w3.org/1999/xhtml">Changing that line could drastically change the system's behavior, making it unusable.From now on, you can see the Singleton pattern as an anti-pattern in .NET, and unless you find strong reasons to implement it, you should stick to normal classes and DI instead. </span><span class="koboSpan" id="kobo.953.3" xmlns="http://www.w3.org/1999/xhtml">Doing this moves the creation responsibility from the singleton class to the composition root, which is the composition root’s responsibility, leaving the class only one responsibility.Next, we explore the Service Locator anti-pattern/code smell.</span></p>
</section>
</section>
<section class="level2" data-number="9.6" id="understanding-the-service-locator-pattern">
<h2 data-number="9.6"><span class="koboSpan" id="kobo.954.1" xmlns="http://www.w3.org/1999/xhtml">Understanding the Service Locator pattern</span></h2>
<p><span class="koboSpan" id="kobo.955.1" xmlns="http://www.w3.org/1999/xhtml">Service Locator is an anti-pattern that reverts the IoC principle to its Control Freak roots. </span><span class="koboSpan" id="kobo.955.2" xmlns="http://www.w3.org/1999/xhtml">The only difference is using the IoC container to build the dependency tree instead of the </span><code><span class="koboSpan" id="kobo.956.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.957.1" xmlns="http://www.w3.org/1999/xhtml"> keyword.There is some use of this pattern in ASP.NET, and we may argue that there are some reasons for using the Service Locator pattern, but it should happen rarely or never in most applications. </span><span class="koboSpan" id="kobo.957.2" xmlns="http://www.w3.org/1999/xhtml">For that reason, let’s call the Service Locator pattern a </span><strong><span class="koboSpan" id="kobo.958.1" xmlns="http://www.w3.org/1999/xhtml">code smell</span></strong><span class="koboSpan" id="kobo.959.1" xmlns="http://www.w3.org/1999/xhtml"> instead of an </span><strong><span class="koboSpan" id="kobo.960.1" xmlns="http://www.w3.org/1999/xhtml">anti-pattern</span></strong><span class="koboSpan" id="kobo.961.1" xmlns="http://www.w3.org/1999/xhtml">.My strong recommendation is </span><em><span class="koboSpan" id="kobo.962.1" xmlns="http://www.w3.org/1999/xhtml">don’t use the Service Locator pattern</span></em><span class="koboSpan" id="kobo.963.1" xmlns="http://www.w3.org/1999/xhtml"> unless you know you are not creating hidden coupling or have no other option. </span><span class="koboSpan" id="kobo.963.2" xmlns="http://www.w3.org/1999/xhtml">As a rule of thumb, you want to avoid injecting an </span><code><span class="koboSpan" id="kobo.964.1" xmlns="http://www.w3.org/1999/xhtml">IServiceProvider</span></code><span class="koboSpan" id="kobo.965.1" xmlns="http://www.w3.org/1999/xhtml"> in your application’s codebase. </span><span class="koboSpan" id="kobo.965.2" xmlns="http://www.w3.org/1999/xhtml">Doing so reverts to the classic flow of control and defeats the purpose of dependency injection.A good use of Service Locator could be to migrate a legacy system that is too big to rewrite. </span><span class="koboSpan" id="kobo.965.3" xmlns="http://www.w3.org/1999/xhtml">So you could build the new code using DI and update the legacy code using the Service Locator pattern, allowing both systems to live together or migrate one into the other, depending on your goal. </span><span class="koboSpan" id="kobo.965.4" xmlns="http://www.w3.org/1999/xhtml">Fetching dependencies dynamically is another potential use of the Service Locator pattern; we explore this in </span><em><span class="koboSpan" id="kobo.966.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 15</span></em><span class="koboSpan" id="kobo.967.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.968.1" xmlns="http://www.w3.org/1999/xhtml">Object Mappers, Aggregate Services, and Façade</span></em><span class="koboSpan" id="kobo.969.1" xmlns="http://www.w3.org/1999/xhtml">.Without further ado, let’s jump into some more code.</span></p>
<section class="level3" data-number="9.6.1" id="project-servicelocator">
<h3 data-number="9.6.1"><span class="koboSpan" id="kobo.970.1" xmlns="http://www.w3.org/1999/xhtml">Project – ServiceLocator</span></h3>
<p><span class="koboSpan" id="kobo.971.1" xmlns="http://www.w3.org/1999/xhtml">The best way to avoid something is to know about it, so let’s see how to implement the Service Locator pattern using </span><code><span class="koboSpan" id="kobo.972.1" xmlns="http://www.w3.org/1999/xhtml">IServiceProvider</span></code><span class="koboSpan" id="kobo.973.1" xmlns="http://www.w3.org/1999/xhtml"> to find a dependency.The service we want to use is an implementation of </span><code><span class="koboSpan" id="kobo.974.1" xmlns="http://www.w3.org/1999/xhtml">IMyService</span></code><span class="koboSpan" id="kobo.975.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.975.2" xmlns="http://www.w3.org/1999/xhtml">Let’s start with the interface:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.976.1" xmlns="http://www.w3.org/1999/xhtml">namespace ServiceLocator;
public interface IMyService : IDisposable
{
    void Execute();
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.977.1" xmlns="http://www.w3.org/1999/xhtml">The interface inherits from the </span><code><span class="koboSpan" id="kobo.978.1" xmlns="http://www.w3.org/1999/xhtml">IDisposable</span></code><span class="koboSpan" id="kobo.979.1" xmlns="http://www.w3.org/1999/xhtml"> interface and contains a single </span><code><span class="koboSpan" id="kobo.980.1" xmlns="http://www.w3.org/1999/xhtml">Execute</span></code><span class="koboSpan" id="kobo.981.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.981.2" xmlns="http://www.w3.org/1999/xhtml">Here is the implementation, which does nothing more than throw an exception if the instance has been disposed of (we’ll leverage this later):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.982.1" xmlns="http://www.w3.org/1999/xhtml">namespace ServiceLocator;
public class MyServiceImplementation : IMyService
{
    private bool _isDisposed = false;
    public void Dispose() =&gt; _isDisposed = true;
    public void Execute()
    {
        if (_isDisposed)
        {
            throw new NullReferenceException("Some dependencies have been disposed.");
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.983.1" xmlns="http://www.w3.org/1999/xhtml">Then, let’s add a controller that implements the Service Locator pattern:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.984.1" xmlns="http://www.w3.org/1999/xhtml">namespace ServiceLocator;
public class MyController : ControllerBase
{
    private readonly IServiceProvider _serviceProvider;
    public MyController(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider ?? </span><span class="koboSpan" id="kobo.984.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(serviceProvider));
    }
    [Route("/service-locator")]
    public IActionResult Get()
    {
        using var myService = _serviceProvider
            .GetRequiredService&lt;IMyService&gt;();
        myService.Execute();
        return Ok("Success!");
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.985.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding code, instead of injecting </span><code><span class="koboSpan" id="kobo.986.1" xmlns="http://www.w3.org/1999/xhtml">IMyService</span></code><span class="koboSpan" id="kobo.987.1" xmlns="http://www.w3.org/1999/xhtml"> into the constructor, we are injecting </span><code><span class="koboSpan" id="kobo.988.1" xmlns="http://www.w3.org/1999/xhtml">IServiceProvider</span></code><span class="koboSpan" id="kobo.989.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.989.2" xmlns="http://www.w3.org/1999/xhtml">Then, we use it (highlighted line) to locate the </span><code><span class="koboSpan" id="kobo.990.1" xmlns="http://www.w3.org/1999/xhtml">IMyService</span></code><span class="koboSpan" id="kobo.991.1" xmlns="http://www.w3.org/1999/xhtml"> instance. </span><span class="koboSpan" id="kobo.991.2" xmlns="http://www.w3.org/1999/xhtml">Doing so shifts the responsibility for creating the object from the container to the consumer (</span><code><span class="koboSpan" id="kobo.992.1" xmlns="http://www.w3.org/1999/xhtml">MyController</span></code><span class="koboSpan" id="kobo.993.1" xmlns="http://www.w3.org/1999/xhtml">, in this case). </span><code><span class="koboSpan" id="kobo.994.1" xmlns="http://www.w3.org/1999/xhtml">MyController</span></code><span class="koboSpan" id="kobo.995.1" xmlns="http://www.w3.org/1999/xhtml"> should not be aware of </span><code><span class="koboSpan" id="kobo.996.1" xmlns="http://www.w3.org/1999/xhtml">IServiceProvider</span></code><span class="koboSpan" id="kobo.997.1" xmlns="http://www.w3.org/1999/xhtml"> and should let the container do its job without interference.What could go wrong? </span><span class="koboSpan" id="kobo.997.2" xmlns="http://www.w3.org/1999/xhtml">If we run the application and navigate to </span><code><span class="koboSpan" id="kobo.998.1" xmlns="http://www.w3.org/1999/xhtml">/service-locator</span></code><span class="koboSpan" id="kobo.999.1" xmlns="http://www.w3.org/1999/xhtml">, everything works as expected. </span><span class="koboSpan" id="kobo.999.2" xmlns="http://www.w3.org/1999/xhtml">However, if we reload the page, we get an error thrown by the </span><code><span class="koboSpan" id="kobo.1000.1" xmlns="http://www.w3.org/1999/xhtml">Execute()</span></code><span class="koboSpan" id="kobo.1001.1" xmlns="http://www.w3.org/1999/xhtml"> method because we called </span><code><span class="koboSpan" id="kobo.1002.1" xmlns="http://www.w3.org/1999/xhtml">Dispose()</span></code><span class="koboSpan" id="kobo.1003.1" xmlns="http://www.w3.org/1999/xhtml"> during the previous request. </span><code><span class="koboSpan" id="kobo.1004.1" xmlns="http://www.w3.org/1999/xhtml">MyController</span></code><span class="koboSpan" id="kobo.1005.1" xmlns="http://www.w3.org/1999/xhtml"> should not control its injected dependencies, which is the point that I am trying to emphasize here: leave the container to control the lifetime of dependencies rather than trying to be a control freak. </span><span class="koboSpan" id="kobo.1005.2" xmlns="http://www.w3.org/1999/xhtml">Using the Service Locator pattern opens pathways toward those wrong behaviors, which will likely cause more harm than good in the long run.Moreover, even though the ASP.NET Core container does not natively support this, we lose the ability to inject dependencies contextually when using the Service Locator pattern because the consumer controls its dependencies. </span><span class="koboSpan" id="kobo.1005.3" xmlns="http://www.w3.org/1999/xhtml">What do I mean by contextually? </span><span class="koboSpan" id="kobo.1005.4" xmlns="http://www.w3.org/1999/xhtml">Let’s assume we have two classes, </span><code><span class="koboSpan" id="kobo.1006.1" xmlns="http://www.w3.org/1999/xhtml">A</span></code><span class="koboSpan" id="kobo.1007.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.1008.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.1009.1" xmlns="http://www.w3.org/1999/xhtml">, implementing interface </span><code><span class="koboSpan" id="kobo.1010.1" xmlns="http://www.w3.org/1999/xhtml">I</span></code><span class="koboSpan" id="kobo.1011.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.1011.2" xmlns="http://www.w3.org/1999/xhtml">We could inject an instance of </span><code><span class="koboSpan" id="kobo.1012.1" xmlns="http://www.w3.org/1999/xhtml">A</span></code><span class="koboSpan" id="kobo.1013.1" xmlns="http://www.w3.org/1999/xhtml"> into </span><code><span class="koboSpan" id="kobo.1014.1" xmlns="http://www.w3.org/1999/xhtml">Consumer1</span></code><span class="koboSpan" id="kobo.1015.1" xmlns="http://www.w3.org/1999/xhtml"> but an instance of </span><code><span class="koboSpan" id="kobo.1016.1" xmlns="http://www.w3.org/1999/xhtml">B</span></code><span class="koboSpan" id="kobo.1017.1" xmlns="http://www.w3.org/1999/xhtml"> into </span><code><span class="koboSpan" id="kobo.1018.1" xmlns="http://www.w3.org/1999/xhtml">Consumer2</span></code><span class="koboSpan" id="kobo.1019.1" xmlns="http://www.w3.org/1999/xhtml">.Before exploring ways to fix this, here is the </span><code><span class="koboSpan" id="kobo.1020.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.1021.1" xmlns="http://www.w3.org/1999/xhtml"> code that powers this program:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.1022.1" xmlns="http://www.w3.org/1999/xhtml">var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddSingleton&lt;IMyService, MyServiceImplementation&gt;()
    .AddControllers()
;
var app = builder.Build();
app.MapControllers();
app.Run();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.1023.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code enables controller support and registers our service.To fix the controller, we must either remove the using statement or even better: move away from the Service Locator pattern and inject our dependencies instead. </span><span class="koboSpan" id="kobo.1023.2" xmlns="http://www.w3.org/1999/xhtml">Of course, you are reading a dependency injection chapter, so I picked moving away from the Service Locator pattern. </span><span class="koboSpan" id="kobo.1023.3" xmlns="http://www.w3.org/1999/xhtml">Here's what we are about to tackle:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1024.1" xmlns="http://www.w3.org/1999/xhtml">Method injection</span></li>
<li><span class="koboSpan" id="kobo.1025.1" xmlns="http://www.w3.org/1999/xhtml">Constructor injection</span></li>
<li><span class="koboSpan" id="kobo.1026.1" xmlns="http://www.w3.org/1999/xhtml">Minimal API</span></li>
</ul>
<p><span class="koboSpan" id="kobo.1027.1" xmlns="http://www.w3.org/1999/xhtml">Let’s start with method injection.</span></p>
<section class="level4" data-number="9.6.1.1" id="implementing-method-injection">
<h4 data-number="9.6.1.1"><span class="koboSpan" id="kobo.1028.1" xmlns="http://www.w3.org/1999/xhtml">Implementing method injection</span></h4>
<p><span class="koboSpan" id="kobo.1029.1" xmlns="http://www.w3.org/1999/xhtml">The following controller uses </span><em><span class="koboSpan" id="kobo.1030.1" xmlns="http://www.w3.org/1999/xhtml">method injection</span></em><span class="koboSpan" id="kobo.1031.1" xmlns="http://www.w3.org/1999/xhtml"> instead of the Service Locator pattern. </span><span class="koboSpan" id="kobo.1031.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the code that demonstrates this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.1032.1" xmlns="http://www.w3.org/1999/xhtml">public class MethodInjectionController : ControllerBase
{
    [Route("/method-injection")]
    public IActionResult GetUsingMethodInjection([FromServices] IMyService myService)
    {
        ArgumentNullException.ThrowIfNull(myService, nameof(myService));
        myService.Execute();
        return Ok("Success!");
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.1033.1" xmlns="http://www.w3.org/1999/xhtml">Let’s analyze the code:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1034.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.1035.1" xmlns="http://www.w3.org/1999/xhtml">FromServicesAttribute</span></code><span class="koboSpan" id="kobo.1036.1" xmlns="http://www.w3.org/1999/xhtml"> class tells the model binder about method injection.</span></li>
<li><span class="koboSpan" id="kobo.1037.1" xmlns="http://www.w3.org/1999/xhtml">We added a guard clause to protect us from </span><code><span class="koboSpan" id="kobo.1038.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.1039.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.1040.1" xmlns="http://www.w3.org/1999/xhtml">Finally, we kept the original code except for the </span><code><span class="koboSpan" id="kobo.1041.1" xmlns="http://www.w3.org/1999/xhtml">using</span></code><span class="koboSpan" id="kobo.1042.1" xmlns="http://www.w3.org/1999/xhtml"> statement.</span></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.1043.1" xmlns="http://www.w3.org/1999/xhtml">Method injection like this is convenient when a controller has multiple actions but only one uses the service.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1044.1" xmlns="http://www.w3.org/1999/xhtml">Let’s reexplore constructor injection.</span></p>
</section>
<section class="level4" data-number="9.6.1.2" id="implementing-constructor-injection">
<h4 data-number="9.6.1.2"><span class="koboSpan" id="kobo.1045.1" xmlns="http://www.w3.org/1999/xhtml">Implementing constructor injection</span></h4>
<p><span class="koboSpan" id="kobo.1046.1" xmlns="http://www.w3.org/1999/xhtml">At this point, you should be familiar with constructor injection. </span><span class="koboSpan" id="kobo.1046.2" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, next is the controller's code after migrating the Service Locator pattern to constructor injection:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.1047.1" xmlns="http://www.w3.org/1999/xhtml">namespace ServiceLocator;
public class ConstructorInjectionController : ControllerBase
{
    private readonly IMyService _myService;
    public ConstructorInjectionController(IMyService myService)
    {
        _myService = myService ?? </span><span class="koboSpan" id="kobo.1047.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(myService));
    }
    [Route("/constructor-injection")]
    public IActionResult GetUsingConstructorInjection()
    {
        _myService.Execute();
        return Ok("Success!");
    }
} </span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.1048.1" xmlns="http://www.w3.org/1999/xhtml">When using constructor injection, we ensure that </span><code><span class="koboSpan" id="kobo.1049.1" xmlns="http://www.w3.org/1999/xhtml">IMyService</span></code><span class="koboSpan" id="kobo.1050.1" xmlns="http://www.w3.org/1999/xhtml"> is not </span><code><span class="koboSpan" id="kobo.1051.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.1052.1" xmlns="http://www.w3.org/1999/xhtml"> upon class instantiation. </span><span class="koboSpan" id="kobo.1052.2" xmlns="http://www.w3.org/1999/xhtml">Since it is a class member, it is even less tempting to call its </span><code><span class="koboSpan" id="kobo.1053.1" xmlns="http://www.w3.org/1999/xhtml">Dispose()</span></code><span class="koboSpan" id="kobo.1054.1" xmlns="http://www.w3.org/1999/xhtml"> method in an action method, leaving that responsibility to the container (as it should be).Let’s analyze the code before moving to the next possibility:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1055.1" xmlns="http://www.w3.org/1999/xhtml">We implemented the strategy pattern with constructor injection.</span></li>
<li><span class="koboSpan" id="kobo.1056.1" xmlns="http://www.w3.org/1999/xhtml">We added a guard clause to ensure no </span><code><span class="koboSpan" id="kobo.1057.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.1058.1" xmlns="http://www.w3.org/1999/xhtml"> value could get in at runtime.</span></li>
<li><span class="koboSpan" id="kobo.1059.1" xmlns="http://www.w3.org/1999/xhtml">We simplified the action to the bare minimum.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.1060.1" xmlns="http://www.w3.org/1999/xhtml">Both techniques are an acceptable replacement for the Service Locator pattern.</span></p>
</section>
<section class="level4" data-number="9.6.1.3" id="implementing-a-minimal-api">
<h4 data-number="9.6.1.3"><span class="koboSpan" id="kobo.1061.1" xmlns="http://www.w3.org/1999/xhtml">Implementing a minimal API</span></h4>
<p><span class="koboSpan" id="kobo.1062.1" xmlns="http://www.w3.org/1999/xhtml">Of course, we can do the same with a minimal API. </span><span class="koboSpan" id="kobo.1062.2" xmlns="http://www.w3.org/1999/xhtml">Here is the code of that endpoint:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.1063.1" xmlns="http://www.w3.org/1999/xhtml">app.MapGet("/minimal-api", (IMyService myService) =&gt;
{
    myService.Execute();
    return "Success!";
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.1064.1" xmlns="http://www.w3.org/1999/xhtml">That code does the same as the method injection sample without the guard clause that I omitted because no external consumer will likely inject nulls into it: the endpoint is a delegate passed directly to the </span><code><span class="koboSpan" id="kobo.1065.1" xmlns="http://www.w3.org/1999/xhtml">MapGet</span></code><span class="koboSpan" id="kobo.1066.1" xmlns="http://www.w3.org/1999/xhtml"> method.Refactoring out the Service Locator pattern is often as trivial as this.</span></p>
</section>
</section>
<section class="level3" data-number="9.6.2" id="conclusion-14">
<h3 data-number="9.6.2"><span class="koboSpan" id="kobo.1067.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.1068.1" xmlns="http://www.w3.org/1999/xhtml">Most of the time, by following the Service Locator anti-pattern, we only hide that we are taking control of objects instead of decoupling our components. </span><span class="koboSpan" id="kobo.1068.2" xmlns="http://www.w3.org/1999/xhtml">The code sample demonstrated a problem when disposing of an object, which could also happen using constructor injection. </span><span class="koboSpan" id="kobo.1068.3" xmlns="http://www.w3.org/1999/xhtml">However, when thinking about it, it is more tempting to dispose of an object that we create than one we inject.Moreover, the service locator takes control away from the container and moves it into the consumer, against the </span><strong><span class="koboSpan" id="kobo.1069.1" xmlns="http://www.w3.org/1999/xhtml">Open-Closed Principle</span></strong><span class="koboSpan" id="kobo.1070.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.1070.2" xmlns="http://www.w3.org/1999/xhtml">You should be able to update the consumer by updating the composition root’s bindings.In the case of the sample code, we could change the binding, and it would work. </span><span class="koboSpan" id="kobo.1070.3" xmlns="http://www.w3.org/1999/xhtml">In a more advanced case, binding two implementations to the same interface would be tough when contextual injection is required.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1071.1" xmlns="http://www.w3.org/1999/xhtml">The IoC container is responsible for weaving the program’s thread, connecting its pieces together where each independent piece should be as clueless as possible about the others.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1072.1" xmlns="http://www.w3.org/1999/xhtml">On top of that, the Service Locator pattern complicates testing. </span><span class="koboSpan" id="kobo.1072.2" xmlns="http://www.w3.org/1999/xhtml">When unit testing your class, you must mock a container that returns a mocked service instead of mocking only the service.One place where I can see its usage justified is in the composition root, where bindings are defined, and sometimes, especially when using the built-in container, we can’t avoid it to compensate for the lack of advanced features. </span><span class="koboSpan" id="kobo.1072.3" xmlns="http://www.w3.org/1999/xhtml">Another good place would be a library that adds functionalities to the container. </span><span class="koboSpan" id="kobo.1072.4" xmlns="http://www.w3.org/1999/xhtml">Other than that, try to stay away!</span></p>
<blockquote>
<p><strong><span class="koboSpan" id="kobo.1073.1" xmlns="http://www.w3.org/1999/xhtml">Beware</span></strong></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1074.1" xmlns="http://www.w3.org/1999/xhtml">Moving the service locator elsewhere does not make it disappear; it only moves it around, like any dependency. </span><span class="koboSpan" id="kobo.1074.2" xmlns="http://www.w3.org/1999/xhtml">However, moving it to the composition root can improve the maintainability of that code and remove the tight coupling.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.1075.1" xmlns="http://www.w3.org/1999/xhtml">Next, we revisit our third and final pattern of this chapter.</span></p>
</section>
</section>
<section class="level2" data-number="9.7" id="revisiting-the-factory-pattern">
<h2 data-number="9.7"><span class="koboSpan" id="kobo.1076.1" xmlns="http://www.w3.org/1999/xhtml">Revisiting the Factory pattern</span></h2>
<p><span class="koboSpan" id="kobo.1077.1" xmlns="http://www.w3.org/1999/xhtml">A factory creates other objects; it is like a literal real-world factory. </span><span class="koboSpan" id="kobo.1077.2" xmlns="http://www.w3.org/1999/xhtml">We explored in the previous chapter how to leverage the Abstract Factory pattern to create families of objects. </span><span class="koboSpan" id="kobo.1077.3" xmlns="http://www.w3.org/1999/xhtml">A factory can be as simple as an interface with one or more </span><code><span class="koboSpan" id="kobo.1078.1" xmlns="http://www.w3.org/1999/xhtml">Create[Object]</span></code><span class="koboSpan" id="kobo.1079.1" xmlns="http://www.w3.org/1999/xhtml"> methods or, even more, a simple delegate. </span><span class="koboSpan" id="kobo.1079.2" xmlns="http://www.w3.org/1999/xhtml">We explore a DI-oriented simple factory in this section. </span><span class="koboSpan" id="kobo.1079.3" xmlns="http://www.w3.org/1999/xhtml">We are building on top of the Strategy pattern example.In that example, we coded two classes implementing the </span><code><span class="koboSpan" id="kobo.1080.1" xmlns="http://www.w3.org/1999/xhtml">ILocationService</span></code><span class="koboSpan" id="kobo.1081.1" xmlns="http://www.w3.org/1999/xhtml"> interface. </span><span class="koboSpan" id="kobo.1081.2" xmlns="http://www.w3.org/1999/xhtml">The composition root used the </span><code><span class="koboSpan" id="kobo.1082.1" xmlns="http://www.w3.org/1999/xhtml">#define</span></code><span class="koboSpan" id="kobo.1083.1" xmlns="http://www.w3.org/1999/xhtml"> preprocessor directive to tell the compiler what bindings to compile. </span><span class="koboSpan" id="kobo.1083.2" xmlns="http://www.w3.org/1999/xhtml">In this version, we want to choose the implementation at runtime.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1084.1" xmlns="http://www.w3.org/1999/xhtml">Not compiling the code we don’t need is good for many reasons, including security (lowering the attack surface). </span><span class="koboSpan" id="kobo.1084.2" xmlns="http://www.w3.org/1999/xhtml">In this case, we are simply using an alternative strategy useful for many scenarios.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1085.1" xmlns="http://www.w3.org/1999/xhtml">To achieve our new goal, we can extract the construction logic of the </span><code><span class="koboSpan" id="kobo.1086.1" xmlns="http://www.w3.org/1999/xhtml">ILocationService</span></code><span class="koboSpan" id="kobo.1087.1" xmlns="http://www.w3.org/1999/xhtml"> interface into a factory.</span></p>
<section class="level3" data-number="9.7.1" id="project-factory">
<h3 data-number="9.7.1"><span class="koboSpan" id="kobo.1088.1" xmlns="http://www.w3.org/1999/xhtml">Project – Factory</span></h3>
<p><span class="koboSpan" id="kobo.1089.1" xmlns="http://www.w3.org/1999/xhtml">In the project, a copy from the Strategy project, we start by renaming the </span><code><span class="koboSpan" id="kobo.1090.1" xmlns="http://www.w3.org/1999/xhtml">InjectAbstractionLocationsController</span></code><span class="koboSpan" id="kobo.1091.1" xmlns="http://www.w3.org/1999/xhtml"> class to </span><code><span class="koboSpan" id="kobo.1092.1" xmlns="http://www.w3.org/1999/xhtml">LocationsController</span></code><span class="koboSpan" id="kobo.1093.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.1093.2" xmlns="http://www.w3.org/1999/xhtml">We can then delete the other controllers.Now, we want to change the </span><code><span class="koboSpan" id="kobo.1094.1" xmlns="http://www.w3.org/1999/xhtml">ILocationService</span></code><span class="koboSpan" id="kobo.1095.1" xmlns="http://www.w3.org/1999/xhtml"> bindings to reflect the following logic:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1096.1" xmlns="http://www.w3.org/1999/xhtml">When developing the application, we use the </span><code><span class="koboSpan" id="kobo.1097.1" xmlns="http://www.w3.org/1999/xhtml">InMemoryLocationService</span></code><span class="koboSpan" id="kobo.1098.1" xmlns="http://www.w3.org/1999/xhtml"> class.</span></li>
<li><span class="koboSpan" id="kobo.1099.1" xmlns="http://www.w3.org/1999/xhtml">When deploying to any environment, we must use the </span><code><span class="koboSpan" id="kobo.1100.1" xmlns="http://www.w3.org/1999/xhtml">SqlLocationService</span></code><span class="koboSpan" id="kobo.1101.1" xmlns="http://www.w3.org/1999/xhtml"> class.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.1102.1" xmlns="http://www.w3.org/1999/xhtml">To achieve this, we use the </span><code><span class="koboSpan" id="kobo.1103.1" xmlns="http://www.w3.org/1999/xhtml">Environment</span></code><span class="koboSpan" id="kobo.1104.1" xmlns="http://www.w3.org/1999/xhtml"> property of the </span><code><span class="koboSpan" id="kobo.1105.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationBuilder</span></code><span class="koboSpan" id="kobo.1106.1" xmlns="http://www.w3.org/1999/xhtml"> object. </span><span class="koboSpan" id="kobo.1106.2" xmlns="http://www.w3.org/1999/xhtml">That property of type </span><code><span class="koboSpan" id="kobo.1107.1" xmlns="http://www.w3.org/1999/xhtml">IWebHostEnvironment</span></code><span class="koboSpan" id="kobo.1108.1" xmlns="http://www.w3.org/1999/xhtml"> contains some useful properties like the </span><code><span class="koboSpan" id="kobo.1109.1" xmlns="http://www.w3.org/1999/xhtml">EnvironmentName</span></code><span class="koboSpan" id="kobo.1110.1" xmlns="http://www.w3.org/1999/xhtml">, and .NET adds extension methods, like the </span><code><span class="koboSpan" id="kobo.1111.1" xmlns="http://www.w3.org/1999/xhtml">IsDevelopment</span></code><span class="koboSpan" id="kobo.1112.1" xmlns="http://www.w3.org/1999/xhtml"> method that returns true when the </span><code><span class="koboSpan" id="kobo.1113.1" xmlns="http://www.w3.org/1999/xhtml">EnvironmentName</span></code><span class="koboSpan" id="kobo.1114.1" xmlns="http://www.w3.org/1999/xhtml"> equals </span><code><span class="koboSpan" id="kobo.1115.1" xmlns="http://www.w3.org/1999/xhtml">Development</span></code><span class="koboSpan" id="kobo.1116.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.1116.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the </span><code><span class="koboSpan" id="kobo.1117.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.1118.1" xmlns="http://www.w3.org/1999/xhtml"> file code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.1119.1" xmlns="http://www.w3.org/1999/xhtml">using Factory.Data;
using Factory.Services;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
builder.Services.AddSingleton&lt;ILocationService&gt;(sp =&gt;
{
    if (builder.Environment.IsDevelopment())
    {
        return new InMemoryLocationService();
    }
    return new SqlLocationService(new NotImplementedDatabase());
});
var app = builder.Build();
app.MapControllers();
app.Run();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.1120.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code is fairly straightforward; it registers a delegate to act as a factory, which builds the appropriate service based on the ASP.NET Core </span><code><span class="koboSpan" id="kobo.1121.1" xmlns="http://www.w3.org/1999/xhtml">Environment</span></code><span class="koboSpan" id="kobo.1122.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1123.1" xmlns="http://www.w3.org/1999/xhtml">We are using the </span><code><span class="koboSpan" id="kobo.1124.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.1125.1" xmlns="http://www.w3.org/1999/xhtml"> keyword here, but is this wrong? </span><span class="koboSpan" id="kobo.1125.2" xmlns="http://www.w3.org/1999/xhtml">The composition root is where we should create or configure elements, so instantiating objects there is correct, as it is to use the Service Locator pattern. </span><span class="koboSpan" id="kobo.1125.3" xmlns="http://www.w3.org/1999/xhtml">It is best to avoid the </span><code><span class="koboSpan" id="kobo.1126.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.1127.1" xmlns="http://www.w3.org/1999/xhtml"> keyword and the Service Locator pattern whenever possible, but using the default container makes it harder than with a full-featured third-party one. </span><span class="koboSpan" id="kobo.1127.2" xmlns="http://www.w3.org/1999/xhtml">Nevertheless, we can avoid doing that in many cases, and even if we must use the </span><code><span class="koboSpan" id="kobo.1128.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.1129.1" xmlns="http://www.w3.org/1999/xhtml"> keyword and the Service Locator pattern, we often don’t need a third-party container.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1130.1" xmlns="http://www.w3.org/1999/xhtml">When we run the program, the right instance is injected into the controller based on the logic we added to the factory. </span><span class="koboSpan" id="kobo.1130.2" xmlns="http://www.w3.org/1999/xhtml">The flow is similar to the following:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.1131.1" xmlns="http://www.w3.org/1999/xhtml">The application starts.</span></li>
<li><span class="koboSpan" id="kobo.1132.1" xmlns="http://www.w3.org/1999/xhtml">A client sends an HTTP request to the controller (</span><code><span class="koboSpan" id="kobo.1133.1" xmlns="http://www.w3.org/1999/xhtml">GET /travel/locations</span></code><span class="koboSpan" id="kobo.1134.1" xmlns="http://www.w3.org/1999/xhtml">).</span></li>
<li><span class="koboSpan" id="kobo.1135.1" xmlns="http://www.w3.org/1999/xhtml">ASP.NET Core creates the controller and leverages the IoC container to inject the </span><code><span class="koboSpan" id="kobo.1136.1" xmlns="http://www.w3.org/1999/xhtml">ILocationService</span></code><span class="koboSpan" id="kobo.1137.1" xmlns="http://www.w3.org/1999/xhtml"> dependency.</span></li>
<li><span class="koboSpan" id="kobo.1138.1" xmlns="http://www.w3.org/1999/xhtml">Our factory creates the correct instance based on the current environment.</span></li>
<li><span class="koboSpan" id="kobo.1139.1" xmlns="http://www.w3.org/1999/xhtml">The action method runs, and the client receives the response.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.1140.1" xmlns="http://www.w3.org/1999/xhtml">We could also create a factory class and an interface, as explored in the previous chapter. </span><span class="koboSpan" id="kobo.1140.2" xmlns="http://www.w3.org/1999/xhtml">However, in this case, it would likely just create noise.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1141.1" xmlns="http://www.w3.org/1999/xhtml">An essential thing to remember is that </span><em><span class="koboSpan" id="kobo.1142.1" xmlns="http://www.w3.org/1999/xhtml">moving code around your codebase does not make that code, logic, dependencies, or coupling disappear</span></em><span class="koboSpan" id="kobo.1143.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.1143.2" xmlns="http://www.w3.org/1999/xhtml">Coding a factory doesn’t make all your design issues disappear. </span><span class="koboSpan" id="kobo.1143.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, adding more complexity adds a cost to your project, so factory or not, each time you try to break tight coupling or remove a dependency, ensure that you are not just moving the responsibility elsewhere or overengineering your solution.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1144.1" xmlns="http://www.w3.org/1999/xhtml">Of course, to keep our composition root clean, we could create an extension method that does the registration, like an </span><code><span class="koboSpan" id="kobo.1145.1" xmlns="http://www.w3.org/1999/xhtml">AddLocationService</span></code><span class="koboSpan" id="kobo.1146.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.1146.2" xmlns="http://www.w3.org/1999/xhtml">I’ll leave you to try this one out, find other ways to improve the project, or even improve one of your own projects.The possibilities are almost endless when you think about the Factory patterns. </span><span class="koboSpan" id="kobo.1146.3" xmlns="http://www.w3.org/1999/xhtml">Now that you’ve seen a few in action, you may find other uses for a factory when injecting some classes with complex instantiation logic into other objects.</span></p>
</section>
</section>
<section class="level2" data-number="9.8" id="summary-7">
<h2 data-number="9.8"><span class="koboSpan" id="kobo.1147.1" xmlns="http://www.w3.org/1999/xhtml">Summary</span></h2>
<p><span class="koboSpan" id="kobo.1148.1" xmlns="http://www.w3.org/1999/xhtml">This chapter delved into Dependency Injection, understanding its crucial role in crafting adaptable systems. </span><span class="koboSpan" id="kobo.1148.2" xmlns="http://www.w3.org/1999/xhtml">We learned how DI applies the Inversion of Control principle, shifting dependency creation from the objects to the composition root. </span><span class="koboSpan" id="kobo.1148.3" xmlns="http://www.w3.org/1999/xhtml">We explored the IoC container's role in object management, service resolution and injection, and dependency lifetime management. </span><span class="koboSpan" id="kobo.1148.4" xmlns="http://www.w3.org/1999/xhtml">We tackled the Control Freak anti-pattern, advocating for dependency injection over using the </span><code><span class="koboSpan" id="kobo.1149.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.1150.1" xmlns="http://www.w3.org/1999/xhtml"> keyword.We revisited the Strategy pattern and explored how to use it with Dependency Injection to compose complex object trees. </span><span class="koboSpan" id="kobo.1150.2" xmlns="http://www.w3.org/1999/xhtml">We learned about the principle of composition over inheritance, which encourages us to inject dependencies into the classes instead of relying on base class features and inheritance. </span><span class="koboSpan" id="kobo.1150.3" xmlns="http://www.w3.org/1999/xhtml">We explored different ways of injecting dependencies into objects, including constructor injection, property injection, and method injection.We learned that a guard clause is a condition that must be met before a method is executed, often used to prevent null dependencies. </span><span class="koboSpan" id="kobo.1150.4" xmlns="http://www.w3.org/1999/xhtml">We explored how to implement guard clauses. </span><span class="koboSpan" id="kobo.1150.5" xmlns="http://www.w3.org/1999/xhtml">We also discussed the importance of adding guard clauses, as nullable reference type checks offer no guarantee at runtime.We revisited the Singleton pattern and how to replace it with a lifetime. </span><span class="koboSpan" id="kobo.1150.6" xmlns="http://www.w3.org/1999/xhtml">We explored two examples utilizing the singleton lifetime to provide application-level features.We delved into the Service Locator pattern, often considered an anti-pattern, as it can create hidden coupling and revert the Inversion of Control principle. </span><span class="koboSpan" id="kobo.1150.7" xmlns="http://www.w3.org/1999/xhtml">We learned that avoiding using the Service Locator pattern is generally best. </span><span class="koboSpan" id="kobo.1150.8" xmlns="http://www.w3.org/1999/xhtml">We explored how to implement the Service Locator pattern and discussed the potential issues that could arise. </span><span class="koboSpan" id="kobo.1150.9" xmlns="http://www.w3.org/1999/xhtml">We revisited the Factory pattern and learned how to build a simple, DI-oriented factory that replaces the object creation logic of the IoC container.</span><strong><span class="koboSpan" id="kobo.1151.1" xmlns="http://www.w3.org/1999/xhtml">Here are the key takeaways from this substantial chapter</span></strong><span class="koboSpan" id="kobo.1152.1" xmlns="http://www.w3.org/1999/xhtml">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1153.1" xmlns="http://www.w3.org/1999/xhtml">Dependency Injection is a technique applying the Inversion of Control principle for effective dependency management and lifetime control.</span></li>
<li><span class="koboSpan" id="kobo.1154.1" xmlns="http://www.w3.org/1999/xhtml">An IoC container resolves and manages dependencies, offering varying control over object behavior.</span></li>
<li><span class="koboSpan" id="kobo.1155.1" xmlns="http://www.w3.org/1999/xhtml">We can categorize dependencies into stable and volatile, the latter justifying DI.</span></li>
<li><span class="koboSpan" id="kobo.1156.1" xmlns="http://www.w3.org/1999/xhtml">The lifetime of a service is Transient, Scoped, or Singleton.</span></li>
<li><span class="koboSpan" id="kobo.1157.1" xmlns="http://www.w3.org/1999/xhtml">Dependency injection allows us to avoid the Control Freak anti-pattern and stop creating objects with the </span><code><span class="koboSpan" id="kobo.1158.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.1159.1" xmlns="http://www.w3.org/1999/xhtml"> keyword, improving flexibility and testability.</span></li>
<li><span class="koboSpan" id="kobo.1160.1" xmlns="http://www.w3.org/1999/xhtml">The Service Locator pattern often creates hidden coupling and should be avoided but in the composition root.</span></li>
<li><span class="koboSpan" id="kobo.1161.1" xmlns="http://www.w3.org/1999/xhtml">The composition root is where we register our service bindings with the IoC container; in the </span><code><span class="koboSpan" id="kobo.1162.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.1163.1" xmlns="http://www.w3.org/1999/xhtml"> file.</span></li>
<li><span class="koboSpan" id="kobo.1164.1" xmlns="http://www.w3.org/1999/xhtml">Composing objects using the Strategy pattern alongside constructor injection facilitates handling complex object trees, emphasizing the principle of composition over inheritance.</span></li>
<li><span class="koboSpan" id="kobo.1165.1" xmlns="http://www.w3.org/1999/xhtml">On top of constructor injection, there’s also method injection and property injection, which are less supported. </span><span class="koboSpan" id="kobo.1165.2" xmlns="http://www.w3.org/1999/xhtml">It is best to prioritize constructor injection over the others.</span></li>
<li><span class="koboSpan" id="kobo.1166.1" xmlns="http://www.w3.org/1999/xhtml">Guard clauses safeguard method execution from unmet conditions.</span></li>
<li><span class="koboSpan" id="kobo.1167.1" xmlns="http://www.w3.org/1999/xhtml">It is better to avoid the Singleton pattern in favor of binding a class and an interface with a singleton lifetime in the container.</span></li>
<li><span class="koboSpan" id="kobo.1168.1" xmlns="http://www.w3.org/1999/xhtml">The Factory pattern is ideal for creating objects with complex instantiation logic.</span></li>
<li><span class="koboSpan" id="kobo.1169.1" xmlns="http://www.w3.org/1999/xhtml">Moving code around doesn't eliminate dependencies or coupling; it's important not to overengineer solutions.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.1170.1" xmlns="http://www.w3.org/1999/xhtml">In subsequent sections, we explore tools that add functionalities to the default built-in container. </span><span class="koboSpan" id="kobo.1170.2" xmlns="http://www.w3.org/1999/xhtml">Meanwhile, we explore options, settings, and configurations in the next chapter. </span><span class="koboSpan" id="kobo.1170.3" xmlns="http://www.w3.org/1999/xhtml">These ASP.NET Core patterns aim to make our lives easier when managing such common problems.</span></p>
</section>
<section class="level2" data-number="9.9" id="questions-7">
<h2 data-number="9.9"><span class="koboSpan" id="kobo.1171.1" xmlns="http://www.w3.org/1999/xhtml">Questions</span></h2>
<p><span class="koboSpan" id="kobo.1172.1" xmlns="http://www.w3.org/1999/xhtml">Let’s take a look at a few practice questions:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.1173.1" xmlns="http://www.w3.org/1999/xhtml">What are the three DI lifetimes that we can assign to objects in ASP.NET Core?</span></li>
<li><span class="koboSpan" id="kobo.1174.1" xmlns="http://www.w3.org/1999/xhtml">What is the composition root for?</span></li>
<li><span class="koboSpan" id="kobo.1175.1" xmlns="http://www.w3.org/1999/xhtml">Is it true that we should avoid the </span><code><span class="koboSpan" id="kobo.1176.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.1177.1" xmlns="http://www.w3.org/1999/xhtml"> keyword when instantiating volatile dependencies?</span></li>
<li><span class="koboSpan" id="kobo.1178.1" xmlns="http://www.w3.org/1999/xhtml">What is the pattern that we revisited in this chapter that helps compose objects to eliminate inheritance?</span></li>
<li><span class="koboSpan" id="kobo.1179.1" xmlns="http://www.w3.org/1999/xhtml">Is the Service Locator pattern a design pattern, a code smell, or an anti-pattern?</span></li>
<li><span class="koboSpan" id="kobo.1180.1" xmlns="http://www.w3.org/1999/xhtml">What is the principle of composition over inheritance?</span></li>
</ol>
</section>
<section class="level2" data-number="9.10" id="further-reading-6">
<h2 data-number="9.10"><span class="koboSpan" id="kobo.1181.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></h2>
<p><span class="koboSpan" id="kobo.1182.1" xmlns="http://www.w3.org/1999/xhtml">Here are some links to build upon what we have learned in the chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1183.1" xmlns="http://www.w3.org/1999/xhtml">Moq: </span><a href="https://adpg.link/XZv8"><span class="koboSpan" id="kobo.1184.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/XZv8</span></a></li>
<li><span class="koboSpan" id="kobo.1185.1" xmlns="http://www.w3.org/1999/xhtml">If you need more options, such as contextual injections, you can check out an open-source library I built. </span><span class="koboSpan" id="kobo.1185.2" xmlns="http://www.w3.org/1999/xhtml">It adds support for new scenarios: </span><a href="https://adpg.link/S3aT"><span class="koboSpan" id="kobo.1186.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/S3aT</span></a></li>
<li><span class="koboSpan" id="kobo.1187.1" xmlns="http://www.w3.org/1999/xhtml">Official documentation, Default service container replacement: </span><a href="https://adpg.link/5ZoG"><span class="koboSpan" id="kobo.1188.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/5ZoG</span></a></li>
</ul>
</section>
<section class="level2" data-number="9.11" id="answers-4">
<h2 data-number="9.11"><span class="koboSpan" id="kobo.1189.1" xmlns="http://www.w3.org/1999/xhtml">Answers</span></h2>
<ol>
<li><span class="koboSpan" id="kobo.1190.1" xmlns="http://www.w3.org/1999/xhtml">Transient, Scoped, Singleton.</span></li>
<li><span class="koboSpan" id="kobo.1191.1" xmlns="http://www.w3.org/1999/xhtml">The composition root holds the code that describes how to compose the program’s object graph—the types bindings.</span></li>
<li><span class="koboSpan" id="kobo.1192.1" xmlns="http://www.w3.org/1999/xhtml">Yes, it is true. </span><span class="koboSpan" id="kobo.1192.2" xmlns="http://www.w3.org/1999/xhtml">Volatile dependencies should be injected instead of instantiated.</span></li>
<li><span class="koboSpan" id="kobo.1193.1" xmlns="http://www.w3.org/1999/xhtml">The Strategy pattern.</span></li>
<li><span class="koboSpan" id="kobo.1194.1" xmlns="http://www.w3.org/1999/xhtml">The Service Locator pattern is all three. </span><span class="koboSpan" id="kobo.1194.2" xmlns="http://www.w3.org/1999/xhtml">It is a design pattern used by DI libraries internally but becomes a code smell in application code. </span><span class="koboSpan" id="kobo.1194.3" xmlns="http://www.w3.org/1999/xhtml">If misused, it is an anti-pattern with the same drawbacks as using the </span><code><span class="koboSpan" id="kobo.1195.1" xmlns="http://www.w3.org/1999/xhtml">new</span></code><span class="koboSpan" id="kobo.1196.1" xmlns="http://www.w3.org/1999/xhtml"> keyword directly.</span></li>
<li><span class="koboSpan" id="kobo.1197.1" xmlns="http://www.w3.org/1999/xhtml">The principle of composition over inheritance encourages us to inject dependencies into classes and use them instead of relying on base class features and inheritance. </span><span class="koboSpan" id="kobo.1197.2" xmlns="http://www.w3.org/1999/xhtml">This approach promotes flexibility and code reuse. </span><span class="koboSpan" id="kobo.1197.3" xmlns="http://www.w3.org/1999/xhtml">It also negates the need for the LSP.</span></li>
</ol>
</section>
</section>
</body>
</html>
