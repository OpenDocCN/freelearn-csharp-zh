<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-117"><a id="_idTextAnchor147" class="pcalibre pcalibre1 calibre6"/>8</h1>
<h1 id="_idParaDest-118" class="calibre5"><a id="_idTextAnchor148" class="pcalibre pcalibre1 calibre6"/>The Event System and Programming for UI</h1>
<p class="calibre3">One of the key features of the Unity UI system is the ability to easily program how the UI elements receive interactions from the player<a id="_idIndexMarker320" class="pcalibre pcalibre1 calibre6"/> via events. The <strong class="bold">Event System</strong> is a robust system that allows you to create and manage events.</p>
<p class="calibre3">Once you learn how to take advantage of the Event System, you will be able to create interactable UI as well as UI that responds to events in your game.</p>
<p class="calibre3">In this chapter, we will discuss the following topics:</p>
<ul class="calibre16">
<li class="calibre14">How to access UI elements and their properties via code</li>
<li class="calibre14">What the Event System is and how to work with it</li>
<li class="calibre14">How to customize input axes with the Input Manager</li>
<li class="calibre14">What an Input Module is, and which ones are provided by Unity</li>
<li class="calibre14">How to use the Event Trigger component to receive events on UI objects</li>
<li class="calibre14">What Raycasters are and what types of Raycasters are provided by Unity</li>
<li class="calibre14">How to show and hide pop-up Panels using keyboard inputs</li>
<li class="calibre14">How to pause the game</li>
<li class="calibre14">How to create a drag and drop inventory system</li>
<li class="calibre14">How to use mouse or multi-touch input to pan and zoom the camera</li>
</ul>
<h1 id="_idParaDest-119" class="calibre5"><a id="_idTextAnchor149" class="pcalibre pcalibre1 calibre6"/>Technical requirements</h1>
<p class="calibre3">You can find the relevant codes and asset files of this chapter here: <a href="https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008" class="pcalibre pcalibre1 calibre6">https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008</a></p>
<h1 id="_idParaDest-120" class="calibre5"><a id="_idTextAnchor151" class="pcalibre pcalibre1 calibre6"/>Accessing UI elements in code</h1>
<p class="calibre3">All the UI elements <a id="_idIndexMarker321" class="pcalibre pcalibre1 calibre6"/>can be accessed and manipulated in code like other GameObjects. To access a UI element in code, you must include the <code>UnityEngine.UI</code> namespace and the correct variable type. Let’s look at the <code>UnityEngine.UI</code> namespace.<a id="_idTextAnchor152" class="pcalibre pcalibre1 calibre6"/></p>
<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor153" class="pcalibre pcalibre1 calibre6"/>UnityEngine.UI namespace</h2>
<p class="calibre3">A <code>using</code> keyword.</p>
<p class="calibre3">By default, all new C# scripts include the <code>System.Collections</code>, <code>System.Collections.Generic</code> and <code>UnityEngine</code> namespaces. To access the properties of UI elements via code, you must first use the <code>UnityEngine.UI</code> namespace.</p>
<p class="calibre3">Therefore, at the top of your C# script, you will need to include the following line to signify that you want to use the <code>UnityEngine.UI</code> namespace:</p>
<pre class="source-code">
using UnityEngine.UI;</pre> <p class="calibre3">Without using the namespace, any variable type related to UI elements will be colored red in your code editor, and you will be given a compiler error. Once you include the namespace, the variable type will change to the blue-colored text, signifying that it is an available variable type, and the compiler error will disappe<a id="_idTextAnchor154" class="pcalibre pcalibre1 calibre6"/>ar.</p>
<h2 id="_idParaDest-122" class="calibre7"><a id="_idTextAnchor155" class="pcalibre pcalibre1 calibre6"/>UI variable types</h2>
<p class="calibre3">Each variable type is a <a id="_idIndexMarker324" class="pcalibre pcalibre1 calibre6"/>class within the <code>UnityEngine.UI</code> namespace. Therefore, each of these variable types, in turn, has its own set of variables and functions that can be accessed. We’ll discuss each variable type more thoroughly in future sections and chapters, but for now, let’s just look at the standard template for accessing a property of a UI element in code.</p>
<p class="calibre3">You can find within the source files a Unity package named <code>Chapter 08</code><code>.unitypackage</code>. Importing it will bring in a scene named <code>Chapter8.unity</code> and various code files. Import the items from the package and open the scene. In the <code>Chapter8</code> scene, you will see a UI Image named <code>UI Variables Example</code>. It does not have a sprite assigned to it and appears as a white square. The following script, <code>AddSprite.cs</code>, is attached <a id="_idIndexMarker325" class="pcalibre pcalibre1 calibre6"/>to the UI Image:</p>
<pre class="source-code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
<strong class="bold">using UnityEngine.UI;</strong>
public class AddSprite : MonoBehaviour {
     <strong class="bold">Image theImage;</strong>
     public Sprite theSprite;
     void Awake(){
          <strong class="bold">theImage = GetComponent&lt;Image&gt;();</strong>
     }
     void Start () {
          <strong class="bold">theImage.sprite = theSprite;</strong>
          <strong class="bold">theImage.preserveAspect = true;</strong>
     }
}</pre> <p class="calibre3">The UI-specific pieces of code are highlighted in the preceding code. Note that the <code>UnityEngine.UI</code> namespace is included at the top of the class.</p>
<p class="calibre3">There are two public variables defined in the class: <code>theImage</code>, which is an <code>Image</code> type, and <code>theSprite</code>, which is a <code>Sprite</code> type. The <code>theImage</code> variable is referencing the UI Image in the scene and the <code>theSprite</code> variable is referencing the sprite that will become the source image of the UI Image.</p>
<p class="calibre3">The <code>Image</code> variable type is within the <code>UnityEngine.UI</code> namespace and represents UI Image GameObject. The <code>Sprite</code> variable type is not a UI element and is included in the <code>UnityEngine</code> namespace.</p>
<p class="calibre3">Within the <code>Start()</code> function, the properties of the <code>Image</code> component on <code>theImage</code> are referenced by typing a period and then the property after the variable name. You can access<a id="_idIndexMarker326" class="pcalibre pcalibre1 calibre6"/> any property that appears in a UI element’s corresponding component in this way. You can also access properties that are not listed in the component this way.</p>
<p class="calibre3">The <code>AddSprite</code> script attached to <code>UI Variables Example (Image)</code> appears in the inspector, as shown in the following screenshot:</p>
<div><div><img alt="Figure 8.1: The AddSprite script and its properties" src="img/B18327_08_01.jpg" class="calibre182"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1: The AddSprite script and its properties</p>
<p class="calibre3">Now, when the scene is played, the sprite will change from a blank white square to an image of a banana with its aspect ratio preserved.</p>
<p class="calibre3">Let’s explore the Event System, which will allow us to interact with ou<a id="_idTextAnchor156" class="pcalibre pcalibre1 calibre6"/>r UI.</p>
<h1 id="_idParaDest-123" class="calibre5"><a id="_idTextAnchor157" class="pcalibre pcalibre1 calibre6"/>The Event System</h1>
<p class="calibre3">In <a href="B18327_06.xhtml#_idTextAnchor085" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 6</em></a>, we<a id="_idIndexMarker327" class="pcalibre pcalibre1 calibre6"/> learned that when the first Canvas is added to a scene, a GameObject named <code>EventSystem</code> is automatically added to the Hierarchy. The Event System allows you to easily receive player interactions and send those interactions to objects in your scene through events. Note that I said, <em class="italic">objects in your scene</em> and not <em class="italic">UI objects</em>. The Event System allows you to send events to non-UI items, too!</p>
<p class="calibre3">Before we proceed, I’d like to note my use of <code>EventSystem</code> (one word) and Event System (two words), because I will be switching back and forth between the two. I want you to know that I am doing it deliberately and am not just randomly deciding that sometimes I hate the spacebar.</p>
<p class="calibre3">I will use <code>EventSystem</code> (one word) to reference the actual GameObject that appears in the Hierarchy of your scene and Event System (two words) to reference the system that handles events.</p>
<p class="calibre3">The Event System <a id="_idIndexMarker328" class="pcalibre pcalibre1 calibre6"/>does quite a few things for you other than just sending events to objects. It also keeps track of the currently selected GameObject, the Input Modules, and Raycasting.</p>
<p class="calibre3">The EventSystem GameObject initializes, by default, with three components: the <strong class="bold">Transform</strong>, <strong class="bold">Event System</strong> Manager, and <strong class="bold">Standalone Input Module</strong>, as shown in the following screenshot:</p>
<div><div><img alt="Figure 8.2: The EventSystem GameObject and its components" src="img/B18327_08_02.jpg" class="calibre183"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2: The EventSystem GameObject and its components</p>
<p class="calibre3">Since <code>EventSystem</code> is a GameObject, it physically exists within the scene (even though it has no renderable <a id="_idIndexMarker329" class="pcalibre pcalibre1 calibre6"/>component making it visible) and therefore has a <strong class="bold">Transform</strong> component like all other GameObjects. You should be familiar with the <strong class="bold">Transform</strong> component by now, so we won’t discuss it further. However, the other two components do merit further discussion. Let’s look at the <strong class="bold">Event System</strong> component more closely now. We’ll also discuss the <strong class="bold">Standalone Input Module</strong> component in the <em class="italic">Input Modules</em> section of this chapter.</p>
<p class="calibre3">You cannot have more than that one <code>EventSystem</code> GameObject in your scene. If you try to add a new one in the scene via <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <strong class="bold">Event System</strong>, a new one will not be added, and the one currently in the scene will be selected for you.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you manage to add a second <strong class="source-inline1">EventSystem</strong> to your scene (by perhaps using <em class="italic">Ctrl</em> + <em class="italic">D</em> to duplicate the existing one), you will see a warning message on your <strong class="bold">Console</strong>.</p>
<p class="callout">If you have more than one <strong class="source-inline1">EventSystem</strong> GameObject in your scene, only the first one added will actually do anything. Any additional <strong class="source-inline1">EventSystems</strong> will be non-functional.</p>
<p class="calibre3">Let’s look at the <strong class="bold">Event System</strong> Manage<a id="_idTextAnchor158" class="pcalibre pcalibre1 calibre6"/>r next.</p>
<h2 id="_idParaDest-124" class="calibre7"><a id="_idTextAnchor159" class="pcalibre pcalibre1 calibre6"/>Event System Manager</h2>
<p class="calibre3"><strong class="bold">Event System </strong>Manager<a id="_idIndexMarker330" class="pcalibre pcalibre1 calibre6"/> is the component that actually does all the tracking and managing of the various <strong class="bold">Event </strong><strong class="bold">System</strong> elements.</p>
<p class="calibre3">If you want to work with the <code>EventSystem</code> GameObject will not be automatically created for you. You can add an <strong class="bold">Event System</strong> Manager to a GameObject by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Event System</strong> on the object’s Inspector. Let’s talk about the properties under the <strong class="bold">Event </strong><strong class="bold">System</strong> M<a id="_idTextAnchor160" class="pcalibre pcalibre1 calibre6"/>anager.</p>
<h3 class="calibre9">First Selected</h3>
<p class="calibre3">You know <a id="_idIndexMarker331" class="pcalibre pcalibre1 calibre6"/>when you start up a game and the <strong class="bold">Start Game</strong> button is highlighted for you so that hitting <em class="italic">Enter</em> will start the game without you having to use your mouse? That’s what the <strong class="bold">First Selected</strong> property does for you. It selects a UI element in the scene for you<a id="_idIndexMarker332" class="pcalibre pcalibre1 calibre6"/> automatically when it starts up.</p>
<p class="calibre3">You can drag and drop any intractable UI element into this slot to make it the first selected UI item in your scene. This is particularly helpful for games that do not use a mouse or touchscreen but rely solely on a gamepad, joystick, or<a id="_idTextAnchor161" class="pcalibre pcalibre1 calibre6"/> keyboard.</p>
<h3 class="calibre9">Send Navigation Events</h3>
<p class="calibre3">The <strong class="bold">Send Navigation Events</strong> property can be toggled on and off. When this property is enabled, you<a id="_idIndexMarker333" class="pcalibre pcalibre1 calibre6"/> can navigate between UI elements via a gamepad, joystick, or keyboard. The following navigation events can be used:</p>
<ul class="calibre16">
<li class="calibre14"><strong class="bold">Move</strong>: You can select the various UI elements via arrow keys on the keyboard or the control stick on a gamepad (or whichever keys/buttons you have designated as the movement keys). Movement will start at the UI item designated <strong class="bold">First Selected</strong>. We will discuss how to specify the order in which UI items are selected using movement in <a href="B18327_10.xhtml#_idTextAnchor236" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 10</em></a>.</li>
<li class="calibre14"><strong class="bold">Submit</strong>: Commit to the UI item selected.</li>
<li class="calibre14"><strong class="bold">Cancel</strong>: Cancel the<a id="_idTextAnchor162" class="pcalibre pcalibre1 calibre6"/> selection.</li>
</ul>
<h3 class="calibre9">Drag Threshold</h3>
<p class="calibre3">The <strong class="bold">Drag Threshold</strong> property represents the number of pixels a UI object can be moved <a id="_idIndexMarker334" class="pcalibre pcalibre1 calibre6"/>before it is considered being <em class="italic">dragged</em>. People don’t have perfectly steady hands, so when they are trying to click or tap a UI item, their mouse or finger may move slightly. This <strong class="bold">Drag Threshold</strong> allows the player to move their input slightly (or a lot if you make this number high) before the item they are selecting is <em class="italic">dragged</em> rather t<a id="_idTextAnchor163" class="pcalibre pcalibre1 calibre6"/>han <em class="italic">clicked</em>.</p>
<h1 id="_idParaDest-125" class="calibre5"><a id="_idTextAnchor164" class="pcalibre pcalibre1 calibre6"/>Input Manager</h1>
<p class="calibre3">Before <a id="_idIndexMarker335" class="pcalibre pcalibre1 calibre6"/>we discuss the next component of the <strong class="bold">Event System</strong> Manager, I want to discuss the Input Manager. The Input Manager is where you define the axes in your game by assigning them to the buttons on your mouse, keyboard, or joystick (gamepad). This also allows you to use the axis name when coding to easily reference all inputs that you want to perform in an action.</p>
<p class="callout-heading">Note</p>
<p class="callout">Remember, as we discussed in <a href="B18327_05.xhtml#_idTextAnchor072" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 5</em></a>, there are actually two systems that will allow you to handle input in your game: the Input Manager and the new Input System. This chapter will focus on the Input Manager. We will discuss the new Input System in a future chapter.</p>
<p class="calibre3">To open the <strong class="bold">Input Manager</strong>, select <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Input Manager</strong>.</p>
<p class="calibre3">If you<a id="_idIndexMarker336" class="pcalibre pcalibre1 calibre6"/> select the arrow next to <strong class="bold">Axes</strong>, you will see the default list of axes:</p>
<div><div><img alt="Figure 8.3: The Input Manager and all its pre-defined axes" src="img/B18327_08_03.jpg" class="calibre184"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.3: The Input Manager and all its pre-defined axes</p>
<p class="calibre3">There are 30 total axes by default. Changing the number next to <strong class="bold">Size</strong> will give you more or less axes. Expanding the individual axes will reveal the following:</p>
<div><div><img alt="Figure 8.4: The first Horizontal input axis" src="img/B18327_08_04.jpg" class="calibre185"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.4: The first Horizontal input axis</p>
<p class="calibre3">The word <a id="_idIndexMarker337" class="pcalibre pcalibre1 calibre6"/>entered in the <strong class="bold">Name</strong> slot is what will appear next to the expandable arrow. In the preceding screenshot, all the keys that allow for horizontal movement have been defined.</p>
<p class="calibre3">Note that the left and right arrows, along with the <em class="italic">A</em> and <em class="italic">D</em> keys of a keyboard, are defaulted to the <strong class="bold">Horizontal</strong> movement.</p>
<p class="calibre3">There is also a second <strong class="bold">Horizontal</strong> axis further down the list. It is configured to work with a joystick or a gamepad.</p>
<div><div><img alt="Figure 8.5: The second Horizontal input axis" src="img/B18327_08_05.jpg" class="calibre186"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.5: The second Horizontal input axis</p>
<p class="calibre3">As there<a id="_idIndexMarker338" class="pcalibre pcalibre1 calibre6"/> are two <code>"</code><code>Horizontal"</code> label.</p>
<p class="callout-heading">Note</p>
<p class="callout">To view a list of <a id="_idIndexMarker339" class="pcalibre pcalibre1 calibre6"/>the keywords for each keyboard key as well as a description for each of the properties of an axis input, visit <a href="https://docs.unity3d.com/Manual/class-InputManager.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/Manual/class-InputManager.xhtml</a>.</p>
<p class="calibre3">This will allow you to reference all these buttons and joysticks together as a group. This is much simpler than having to write code that gets each of the individual keyboard keys along the individual joysticks.</p>
<p class="calibre3">You can delete any of these 30 default axes you want by right-clicking on them and selecting <strong class="bold">Delete </strong><strong class="bold">Array Element</strong>.</p>
<p class="calibre3">However, be careful when you delete them. You need at least one <strong class="bold">Submit</strong> axis and one <strong class="bold">Cancel</strong> axis to be able to use the <strong class="bold">Standalone Input Manager</strong> (unless you change the <strong class="bold">Submit Button</strong> and <strong class="bold">Cancel Button</strong> in the <strong class="bold">Standalone Input Manager</strong>). For more information, refer to the <em class="italic">Standalone Input Manager</em> section of this chapter.</p>
<p class="calibre3">Now that we have explored the Input Manager, we can review the various input functions for buttons an<a id="_idTextAnchor165" class="pcalibre pcalibre1 calibre6"/>d key presses.</p>
<h1 id="_idParaDest-126" class="calibre5"><a id="_idTextAnchor166" class="pcalibre pcalibre1 calibre6"/>Input functions for buttons and key presses</h1>
<p class="calibre3">There <a id="_idIndexMarker340" class="pcalibre pcalibre1 calibre6"/>are quite a few ways to access key and button presses via code. How you do this depends on whether you have the key specified as an axis in the <strong class="bold">Input Manager</strong> and whether you want the key to register once or continuously. I’ll discuss a few in this text, but you can find a full list of the functions at <a href="https://docs.unity3d.com/ScriptReference/Input.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/ScriptReference/Input.xhtml</a>.</p>
<p class="calibre3">A script named <code>KeyPresses.cs</code> is attached to the <code>Main Camera</code> in the <code>Chapter8</code> example scene we were reviewing earlier in this chapter. The <code>KeyPresses.cs</code> script contains all the code demonstrated in this section if you’d like to play around wi<a id="_idTextAnchor167" class="pcalibre pcalibre1 calibre6"/>th key presses.</p>
<h2 id="_idParaDest-127" class="calibre7"><a id="_idTextAnchor168" class="pcalibre pcalibre1 calibre6"/>GetButton</h2>
<p class="calibre3">If you <a id="_idIndexMarker341" class="pcalibre pcalibre1 calibre6"/>have a button defined as an axis in the <code>GetButton()</code>, <code>GetButtonDown()</code>, and <code>GetButtonUp()</code> to determine when a button has been pressed.</p>
<p class="calibre3"><code>GetButton()</code> returns <code>true</code> while the button is being held, <code>GetButtonDown()</code> returns <code>true</code> only once, on the frame that the button is initially pressed, and <code>GetButtonUp()</code> returns <code>true</code> only once, on the frame that the button is released.</p>
<p class="calibre3">Within each of the functions, you place the axis name from the <code>Update()</code> function of a script so that they can be triggered at any time.</p>
<p class="calibre3">So, for example, if you wanted to check whether the <em class="italic">Enter</em> key is being pressed, since it is assigned to a <strong class="bold">Positive Button</strong> for the <strong class="bold">Submit</strong> axis, you can write the following code to trigger when the <em class="italic">Enter</em> key is pressed down:</p>
<pre class="source-code">
void Update () {
     if (Input.GetButtonDown("Submit")){
          Debug.Log("You pressed a submit key/button!");
     }
}</pre> <p class="calibre3">Keep in mind <a id="_idIndexMarker343" class="pcalibre pcalibre1 calibre6"/>that this will not just trigger with the <em class="italic">Enter</em> key, as the <strong class="bold">Submit</strong> axis has a few keys<a id="_idIndexMarker344" class="pcalibre pcalibre1 calibre6"/> assigned to the <strong class="bold">Positive Button</strong> and <strong class="bold">Alt </strong><strong class="bold">Positive Button</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">It’s important to note that if you play the <strong class="source-inline1">Chapter8</strong> scene and want to watch these button and key presses fire the console log messages, you must first click within the <strong class="bold">Game View</strong> so that the inputs will re<a id="_idTextAnchor169" class="pcalibre pcalibre1 calibre6"/>gister in the game.</p>
<h2 id="_idParaDest-128" class="calibre7"><a id="_idTextAnchor170" class="pcalibre pcalibre1 calibre6"/>GetAxis</h2>
<p class="calibre3">If you’re <a id="_idIndexMarker345" class="pcalibre pcalibre1 calibre6"/>looking for a function that will trigger continuously <a id="_idIndexMarker346" class="pcalibre pcalibre1 calibre6"/>without any breaks between firing, you want to use <code>GetAxis()</code> rather than <code>GetButton()</code>. <code>GetButton()</code> is good for buttons you want to hold down but want a slight pause between events firing (think of holding down a fire button, and the gun shoots bullets with breaks in between them). <code>GetAxis()</code> works better for events involving movement because of this continuous frame-rate independent execution.</p>
<p class="calibre3"><code>GetAxis()</code> works a bit differently, as it returns a <code>float</code> value rather than a <code>bool</code>, such as <code>GetButton()</code>. It is also best suited within an <code>Update()</code> function. So, for example, you can check whether the horizontal movement is occurring as follows:</p>
<pre class="source-code">
void Update () {
     float horizontalValue = Input.GetAxis("Horizontal");
     if (horizontalValue != 0){
          Debug.Log("You're holding down a horizontal button!");
     }
}</pre> <h2 id="_idParaDest-129" class="calibre7"><a id="_idTextAnchor171" class="pcalibre pcalibre1 calibre6"/>GetKey</h2>
<p class="calibre3">If you want to<a id="_idIndexMarker347" class="pcalibre pcalibre1 calibre6"/> get a keyboard key press that is not assigned <a id="_idIndexMarker348" class="pcalibre pcalibre1 calibre6"/>to an axis, you can use <code>GetKey()</code>, <code>GetKeyDown()</code>, or <code>GetKeyUp()</code> to reference keyboard keys via their <code>KeyCode</code>.</p>
<p class="calibre3">The <code>GetKey()</code> functions work pretty similar to the <code>GetButton()</code> functions. <code>GetKey()</code> returns <code>true</code> while the key is being held down; <code>GetKeyDown()</code> returns <code>true</code> only once, on the frame that the key is initially pressed; and <code>GetKeyUp()</code> returns <code>true</code> only once, on the frame that the key is released.</p>
<p class="calibre3">Each key has its own <code>KeyCode</code> that needs to be referenced in the parentheses of the <code>GetKey()</code> functions. You can find a list of all the keyboard <code>KeyCode</code> values at <a href="https://docs.unity3d.com/ScriptReference/KeyCode.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/ScriptReference/KeyCode.xhtml</a>.</p>
<p class="calibre3">So, for example, if you wanted to check whether the <em class="italic">8</em> key from the alphanumeric keyboard is being pressed, you could write the following code to trigger when the <em class="italic">8</em> key is pressed down:</p>
<pre class="source-code">
void Update () {
     if (Input.GetKeyDown(KeyCode.Alpha8)){
          Debug.Log("You pressed the 8 key for some reason!");
     }
}</pre> <h2 id="_idParaDest-130" class="calibre7"><a id="_idTextAnchor172" class="pcalibre pcalibre1 calibre6"/>GetMouseButton</h2>
<p class="calibre3">Just as<a id="_idIndexMarker349" class="pcalibre pcalibre1 calibre6"/> with <code>GetButton()</code> and <code>GetKey()</code>, there are<a id="_idIndexMarker350" class="pcalibre pcalibre1 calibre6"/> three functions for checking when a mouse button has been pressed: <code>GetMouseButton()</code>, <code>GetMouseButtonDown()</code>, and <code>GetMouseButtonUp()</code>. They return <code>true</code> in the same way that the <code>GetButton()</code> and <code>GetKey()</code> functions do.</p>
<p class="calibre3">You’d place these functions within the <code>Update()</code> function as well. Within the parentheses, you check to see which button is being pressed; <code>0</code> represents a left-click, <code>1</code> represents a right-click, and <code>2</code> represents a middle-click.</p>
<p class="calibre3">So, for example, if <a id="_idIndexMarker351" class="pcalibre pcalibre1 calibre6"/>you wanted to check that the middle mouse button was clicked, you could write the following code to trigger when the middle mouse button is pressed down:</p>
<pre class="source-code">
void Update () {
     if (Input.GetMouseButtonDown(2)){
          Debug.Log("You pressed the middle mouse button!");
     }
}</pre> <p class="calibre3">Now that <a id="_idIndexMarker352" class="pcalibre pcalibre1 calibre6"/>we’ve reviewed the input function for buttons and key presses, let’s review the Input Modules.</p>
<h1 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor173" class="pcalibre pcalibre1 calibre6"/>Input Modules</h1>
<p class="calibre3">Input Modules <a id="_idIndexMarker353" class="pcalibre pcalibre1 calibre6"/>describe how the Event System will handle the inputs to the game via the mouse, keyboard, touchscreen, gamepad, and so on. You can think of them as the bridge between the hardware and events.</p>
<p class="calibre3">There are three input modules provided by Unity:</p>
<ul class="calibre16">
<li class="calibre14">Standalone Input Module</li>
<li class="calibre14">Base Input Module</li>
<li class="calibre14">Pointer Input Module</li>
</ul>
<p class="calibre3">To utilize these input modules, you attach them as components to your <code>EventSystem</code> GameObject.</p>
<p class="calibre3">You are not restricted to using these three input modules and can create your own, so if you have an input device that is not covered by one of those three, you’d create your own input module script and then attach it to the Event System.</p>
<p class="calibre3">There is another input module called Touch Input Module, which used to be necessary for touchscreen inputs. However, this module has been deprecated and its functionality is now lumped<a id="_idIndexMarker354" class="pcalibre pcalibre1 calibre6"/> into the Standalone Input Module. Since this input module has been deprecated, it will not be discussed in this text.</p>
<p class="calibre3">Let’s look at the three input module<a id="_idTextAnchor174" class="pcalibre pcalibre1 calibre6"/>s provided by Unity in depth.</p>
<h2 id="_idParaDest-132" class="calibre7"><a id="_idTextAnchor175" class="pcalibre pcalibre1 calibre6"/>Standalone Input Module</h2>
<p class="calibre3">The <strong class="bold">Standalone Input Module</strong> is a pretty robust input module that will work with most of <a id="_idIndexMarker355" class="pcalibre pcalibre1 calibre6"/>your<a id="_idIndexMarker356" class="pcalibre pcalibre1 calibre6"/> input devices. It works with a mouse, keyboard, touchscreen, and gamepad.</p>
<p class="calibre3">The <code>EventSystem</code> GameObject when it is created. However, you can attach the <strong class="bold">Standalone Input Module</strong> as a component using <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Standalone Input Module</strong> on the object’s <strong class="bold">Inspector</strong>. You could do this if you wanted to add a second one, previously deleted it, and want to re-attach it, or want to add the <strong class="bold">Standalone Input Module</strong> to another GameObject.</p>
<div><div><img alt="Figure 8.6: The Standalone Input Module component" src="img/B18327_08_06.jpg" class="calibre187"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.6: The Standalone Input Module component</p>
<p class="calibre3">You’ll see that the first four properties of the <strong class="bold">Standalone Input Module</strong> are <strong class="bold">Horizontal Axis</strong>, <strong class="bold">Vertical Axis</strong>, <strong class="bold">Submit Button</strong>, and <strong class="bold">Cancel Button</strong>. These properties are the reason I wanted to discuss the Input Manager before discussing the Input Modules. The default properties assigned to these slots are <strong class="bold">Horizontal</strong>, <strong class="bold">Vertical</strong>, <strong class="bold">Submit</strong>, and <strong class="bold">Cancel</strong>. These assignments are referencing the axes assignments from the Input Manager.</p>
<p class="calibre3">The <code>10</code>. This <a id="_idIndexMarker357" class="pcalibre pcalibre1 calibre6"/>means<a id="_idIndexMarker358" class="pcalibre pcalibre1 calibre6"/> that there will be a tenth of a second delay after an input action before the next input action is registered. The <strong class="bold">Repeat Delay</strong> property is the amount of time, in seconds, before <strong class="bold">Input Actions Per </strong><strong class="bold">Second</strong> occurs.</p>
<p class="calibre3">Setting the <strong class="bold">Force Module Active</strong> property to true will make this <strong class="bold">Standalone Input </strong><strong class="bold">Module</strong> active.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more about the Standalone Input Module at the following locations:</p>
<p class="callout"><a href="mailto:https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml</a></p>
<p class="callout"><a href="https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSystems.StandaloneInputModule.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSystems.StandaloneInputModule.xhtml</a></p>
<h2 id="_idParaDest-133" class="calibre7"><a id="_idTextAnchor177" class="pcalibre pcalibre1 calibre6"/>BaseInputModule/PointerInputModule</h2>
<p class="calibre3">The <code>BaseInputModule</code> and <code>PointerInputModule</code> are modules that are only accessible via code.</p>
<p class="calibre3">If you <a id="_idIndexMarker359" class="pcalibre pcalibre1 calibre6"/>need to<a id="_idIndexMarker360" class="pcalibre pcalibre1 calibre6"/> create your<a id="_idIndexMarker361" class="pcalibre pcalibre1 calibre6"/> own Input Module, you will create it by <a id="_idIndexMarker362" class="pcalibre pcalibre1 calibre6"/>extending from the <code>BaseInputModule</code>. You can view a full list of the variables, functions, and messages that can be utilized by extending the <code>BaseInputModule</code> at <a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml</a>.</p>
<p class="calibre3">The <code>PointerInputModule</code> is a <code>BaseInputModule</code> that is used by the Standalone Input Module described earlier. It can also be used to write custom Input Modules. You can view a full list of the variables, functions, and messages that can be utilized by extending the <code>PointerInputModule</code> at <a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml</a>.</p>
<p class="calibre3">Now, let’s look at how we can access multi-touch inpu<a id="_idTextAnchor178" class="pcalibre pcalibre1 calibre6"/>t on mobile and touchscreen devices.</p>
<h1 id="_idParaDest-134" class="calibre5"><a id="_idTextAnchor179" class="pcalibre pcalibre1 calibre6"/>Input for multi-touch</h1>
<p class="calibre3">Accessing <a id="_idIndexMarker363" class="pcalibre pcalibre1 calibre6"/>multi-touch is pretty easy. You access touches with <code>Input.GetTouch(index)</code>, where the index represents the index of the touch, with the first touch occurring at index <code>0</code>. From there, you can access information pretty much in the same way <a id="_idIndexMarker364" class="pcalibre pcalibre1 calibre6"/>as accessing information about a mouse. You can also find out how many total touches are occurring with <code>Input.touchCount</code>. See the <em class="italic">Examples</em> section of this chapter for an example of how to access multi-touch input.</p>
<p class="calibre3">Mobile devices also have accelerometers and gyroscopes providing input to the device. Let’s look at how you can access those inputs.</p>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor180" class="pcalibre pcalibre1 calibre6"/>Input for accelerometer and gyroscope</h1>
<p class="calibre3">You can access <a id="_idIndexMarker365" class="pcalibre pcalibre1 calibre6"/>data from the device’s accelerometer using the <code>Vector3 Input.acceleration</code> property. The coordinates of <code>Input.acceleration</code> line up with the scene based on the rotation of the device, as shown:</p>
<div><div><img alt="Figure 8.7: The world axes based on screen rotation" src="img/B18327_08_07.jpg" class="calibre188"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.7: The world axes based on screen rotation</p>
<p class="calibre3">Simple examples <a id="_idIndexMarker366" class="pcalibre pcalibre1 calibre6"/>of this involve moving an object around a scene when the device is moved, using something like the following within an <code>Update()</code> function on the object:</p>
<pre class="source-code">
transform.Translate(Input.acceleration.x, 0, -Input.acceleration.y);</pre> <p class="calibre3">The gyroscope uses more complicated mathematics to get a more precise movement of the screen using the <code>Gyroscope</code> class. Remember, the gyroscope is not supported on many devices, so it’s best to use the accelerometer when possible.</p>
<p class="callout-heading">Note</p>
<p class="callout">An example of how to use the gyroscope on an iOS device can be found here: <a href="https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml</a>.</p>
<p class="calibre3">Now that we’ve reviewed the various input modules, let’s review Event Triggers.</p>
<h1 id="_idParaDest-136" class="calibre5"><a id="_idTextAnchor181" class="pcalibre pcalibre1 calibre6"/>Event Trigger</h1>
<p class="calibre3">The <code>onClick</code> event. However, if you’d like to add an event to an object that either isn’t already set up to receive events or you want it to receive different events, you can attach an <strong class="bold">Event Trigger</strong> component to the GameObject.</p>
<p class="calibre3">You can attach an <strong class="bold">Event Trigger</strong> component by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Event Trigger</strong>.</p>
<p class="calibre3">One caveat of using the <strong class="bold">Event Trigger</strong> component is that the object it is attached to receives all the events, not just the ones you added. So, even if you don’t tell the object what to do with the specified event, it will receive that event and acknowledge that the event occurred—it just won’t do anything in response. This can slow the performance of your game. If you are worried about performance, you will want to write your own script that attaches only the events you want to use to your component. The next section, <em class="italic">Event Inputs</em>, discusses how to achieve this.</p>
<p class="calibre3">If you use an <strong class="bold">Event Trigger</strong> component on an object other than a UI element, the object must also have a collider component, and you must include a raycaster on the camera within the scene.</p>
<p class="calibre3">Which collider and raycaster you use depends on whether you are working in 2D or 3D.</p>
<p class="calibre3">If you are working in 2D, you can add a 2D collider to the object with <strong class="bold">Add Component</strong> | <strong class="bold">Physics 2D</strong> and then select the appropriate 2D collider from within the object’s <strong class="bold">Inspector</strong>. You can then add a raycaster to the camera by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Physics 2D Raycaster</strong> from within the camera’s <strong class="bold">Inspector</strong>.</p>
<p class="calibre3">If you are working in 3D, you can add a 3D collider to the object with <strong class="bold">Add Component</strong> | <strong class="bold">Physics</strong> and then select the appropriate 3D collider from within the object’s <strong class="bold">Inspector</strong>. You can then add a raycaster to the camera by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Physics Raycaster</strong> from within the camera’s <strong class="bold">Inspector</strong>.</p>
<p class="calibre3">Let’s look at the various event t<a id="_idTextAnchor182" class="pcalibre pcalibre1 calibre6"/>ypes that the Event Trigger can receive.</p>
<h2 id="_idParaDest-137" class="calibre7"><a id="_idTextAnchor183" class="pcalibre pcalibre1 calibre6"/>Event types</h2>
<p class="calibre3">You can tell the <a id="_idIndexMarker368" class="pcalibre pcalibre1 calibre6"/>object which type of input event you want to receive by selecting <strong class="bold">Add New </strong><strong class="bold">Event Type</strong>.</p>
<p class="calibre3">Many of<a id="_idIndexMarker369" class="pcalibre pcalibre1 calibre6"/> these events are tied to the bounding region of the object. The bounding region of a UI object is represented by the area of the Rect Transform. For a non-UI object, the bounding reg<a id="_idTextAnchor184" class="pcalibre pcalibre1 calibre6"/>ion is represented by a 2D or 3D collider.</p>
<h3 class="calibre9">Pointer events</h3>
<p class="calibre3">Pointer events<a id="_idIndexMarker370" class="pcalibre pcalibre1 calibre6"/> can be called by the pointer in a <strong class="bold">Standalone Input Module</strong>. Remember that a pointer is not exclusively a mouse. The pointer in a <strong class="bold">Standalone Input Module</strong> can be a mouse, finger touch, or a reticle tied to gamepad movement.</p>
<p class="calibre3">Two of the event types are related to the position of the pointer in relation to the object’s bounding box region. The <strong class="bold">PointerEnter</strong> event is called when the pointer enters the bounding box of the object and <strong class="bold">PointerExit</strong> is called when the pointer exits the bound box area.</p>
<p class="calibre3">There are three events related to clicking on the object. The <strong class="bold">PointerDown</strong> event is called when the pointer is pressed down within the bounding region of the object, and <strong class="bold">PointerUp</strong> is called when the pointer is released within the bounding region of the object. It’s important to note that with <strong class="bold">PointerUp</strong>, the pointer can be pressed outside of the object, held down, and then released inside the object for the <strong class="bold">PointerUp</strong> event to trigger. The <strong class="bold">PointerClick</strong> event is called when the pointer is pressed and then release<a id="_idTextAnchor185" class="pcalibre pcalibre1 calibre6"/>d within the bounding region of the object.</p>
<h3 class="calibre9">Drag and Drop events</h3>
<p class="calibre3">When working <a id="_idIndexMarker371" class="pcalibre pcalibre1 calibre6"/>with the various drag and drop events, it’s important to differentiate between the object being dragged and the object on which the dragged object is dropped.</p>
<p class="calibre3">The <strong class="bold">InitializePotentialDrag</strong> event is called whenever a drag object is found, but before an object is actually being dragged.</p>
<p class="calibre3">The <strong class="bold">Drag</strong> event is called on the object being dragged when it is being dragged. A <strong class="bold">Drag</strong> event occurs when a pointer is pressed within the bounding box of an object and then moved without releasing. It’s ended by releasing the pointer. The <strong class="bold">BeginDrag</strong> event is called from the object being dragged when its drag begins, and the <strong class="bold">EndDrag</strong> event is called when its drag ends.</p>
<p class="calibre3">The <strong class="bold">Drop</strong> event<a id="_idIndexMarker372" class="pcalibre pcalibre1 calibre6"/> is different from the <strong class="bold">EndDrag</strong> event. The <strong class="bold">EndDrag</strong> event is called on the object that was just being dragged. The <strong class="bold">Drop</strong> event is called by the object on which the dragged object was dropped. Therefore, the <strong class="bold">Drop</strong> event is called by the object touching the dragged object when the dragged object stops dragging. So, if you were making a drag and drop menu, you’d add the <strong class="bold">Drag</strong> event to the objects you want to drag and the <strong class="bold">Drop</strong> <a id="_idTextAnchor186" class="pcalibre pcalibre1 calibre6"/>event to the slots they will be dropped into.</p>
<h3 class="calibre9">Selection events</h3>
<p class="calibre3">The <strong class="bold">Select</strong> event is <a id="_idIndexMarker373" class="pcalibre pcalibre1 calibre6"/>called when the object is considered the selected object and <strong class="bold">Deselect</strong> is called when the object is no longer considered selected. Each of these events only fires once—the moment the object is considered selected or deselected. If you want an event that will trigger continuously while the object is selected, you can use the <strong class="bold">UpdateSelected</strong> event. T<a id="_idTextAnchor187" class="pcalibre pcalibre1 calibre6"/>he <strong class="bold">UpdateSelected</strong> event is called every frame.</p>
<h3 class="calibre9">Other events</h3>
<p class="calibre3">Other events <a id="_idIndexMarker374" class="pcalibre pcalibre1 calibre6"/>are called based on assignments in the Input Manager. Remember that you can assign buttons, keys, and such to axes that define movement, submit, and cancel. Let’s talk about a few of these events.</p>
<p class="calibre3">The <strong class="bold">Scroll</strong> event is called when the mouse wheel scrolls and the <strong class="bold">Move</strong> event is called when a movement happens. When the button assigned to the <strong class="bold">Submit</strong> axis is pressed, the <strong class="bold">Submit</strong> event is called and when the button assigned to the <strong class="bold">Canc<a id="_idTextAnchor188" class="pcalibre pcalibre1 calibre6"/>el</strong> axis is pressed, the <strong class="bold">Cancel</strong> event is called.</p>
<h2 id="_idParaDest-138" class="calibre7"><a id="_idTextAnchor189" class="pcalibre pcalibre1 calibre6"/>Adding an action to the event</h2>
<p class="calibre3">Once you have actually<a id="_idIndexMarker375" class="pcalibre pcalibre1 calibre6"/> selected an event type, you must specify what will happen when that event type triggers. The following screenshot shows the results of selecting <strong class="bold">Pointer Enter</strong> as an event type:</p>
<div><div><img alt="Figure 8.8: The Event Trigger component" src="img/B18327_08_08.jpg" class="calibre189"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.8: The Event Trigger component</p>
<p class="calibre3">The<a id="_idIndexMarker376" class="pcalibre pcalibre1 calibre6"/> preceding screenshot shows that an event type of <strong class="bold">Pointer Enter</strong> has been selected, but what happens when the pointer enters the object’s bounding area is yet to be defined. To define what happens when the event triggers, you must select the <strong class="bold">+</strong> sign at the bottom-right corner of the event’s box. You can add multiple actions when the event triggers by selecting the <strong class="bold">+</strong> sign multiple times.</p>
<p class="calibre3">Once an event type has been added to the <strong class="bold">Event Trigger</strong> component, it cannot be added a second time and will be grayed out in the <strong class="bold">Add New Event </strong><strong class="bold">Type</strong> list.</p>
<p class="calibre3">To remove an event type from the <strong class="bold">Event Trigger</strong> component, select the <strong class="bold">–</strong> sign at the top-right corner of the event type’s box.</p>
<p class="calibre3">Once the plus sign is selected, the event type should look as follows:</p>
<div><div><img alt="Figure 8.9: The Event Trigger component with a Pointer Enter event" src="img/B18327_08_09.jpg" class="calibre190"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.9: The Event Trigger component with a Pointer Enter event</p>
<p class="calibre3">The first setting on this event is a dropdown menu with the <strong class="bold">Runtime Only</strong> (by default), <strong class="bold">Editor and Runtime</strong>, and <strong class="bold">Off</strong> options. This is where we specify when the event can be triggered. Setting this to <strong class="bold">Off</strong> will make the event never trigger. Setting this to <strong class="bold">Runtime Only</strong> will have the event trigger when the game is being played. Setting this to <strong class="bold">Editor and Runtime</strong> will make events trigger when the game is being played, but it also accepts the triggers in the Editor when the game is not in play mode. Most of the time, <strong class="bold">Runtime Only</strong> is sufficient for what you will be doing and hence it is the default.</p>
<p class="calibre3">Below that <a id="_idIndexMarker377" class="pcalibre pcalibre1 calibre6"/>dropdown menu is a slot with <strong class="bold">None (Object)</strong> in it. You are to drag from the Hierarchy whichever item the function you want to run is attached to into this slot. Once that is assigned, a list of all the available components and scripts attached to that object will display in the second dropdown menu. You can drag and drop the object the <strong class="bold">Event Trigger</strong> is attached to in this slot and are not restricted to only using other objects.</p>
<p class="calibre3">The following screenshot shows an <code>Image</code> GameObject with an <code>foodSpriteSheet_1</code> sprite when the pointer enters its <strong class="bold">Rect Transform</strong>.</p>
<div><div><img alt="Figure 8.10: The Event Trigger component with a Pointer Enter event that swaps a sprite" src="img/B18327_08_10.jpg" class="calibre191"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.10: The Event Trigger component with a Pointer Enter event that swaps a sprite</p>
<p class="calibre3">To see this <code>Chapter8</code> scene. Hover your mouse over the image. It will initially look like a potion bottle but will change to a triangle when your mouse hovers over it.</p>
<p class="calibre3">You can also run functions within scripts attached to objects. For example, the next screenshot shows the same image but now with a <code>Main Camera</code> has a script attached to it called <code>HelloWorld.cs</code> with a function called <code>HeyThere()</code>.</p>
<div><div><img alt="Figure 8.11: The Event Trigger component with Pointer Click event that triggers a method" src="img/B18327_08_11.jpg" class="calibre192"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.11: The Event Trigger component with Pointer Click event that triggers a method</p>
<p class="calibre3">The <code>HeyThere()</code> function<a id="_idIndexMarker378" class="pcalibre pcalibre1 calibre6"/> simply prints <code>Hello world! This is main camera speaking!</code> in the <strong class="bold">Console</strong> whenever the image to the right is clicked.</p>
<p class="calibre3">To run a function from the <strong class="bold">Event Trigger</strong> component, it must be public, have a return type of void, and have no more than one parameter.</p>
<p class="calibre3">Now, let’s review how we can write code that performs similarly to the Event Tri<a id="_idTextAnchor190" class="pcalibre pcalibre1 calibre6"/>gger component through the use of event inputs.</p>
<h1 id="_idParaDest-139" class="calibre5"><a id="_idTextAnchor191" class="pcalibre pcalibre1 calibre6"/>Event inputs</h1>
<p class="calibre3">As stated in the <em class="italic">Event Trigger</em> section, you may not want to use an <strong class="bold">Event Trigger</strong> component because the <strong class="bold">Event Trigger</strong> component causes the object on which it is attached<a id="_idIndexMarker379" class="pcalibre pcalibre1 calibre6"/> to receive all the events listed in the <em class="italic">Event Trigger</em> section. So, if you are worried about performance issues, you will want an alternate way to receive events on an object.</p>
<p class="calibre3">All event types that were available to add in the <em class="italic">Event Trigger</em> section can also be added to an object via code without using the <strong class="bold">Event Trigger</strong> component. To use an event without the <strong class="bold">Event Trigger</strong> component, you must derive your script from the appropriate interface and know the type of event data class that the event uses.</p>
<p class="calibre3">An <strong class="bold">interface</strong> is a<a id="_idIndexMarker380" class="pcalibre pcalibre1 calibre6"/> template that defines all the required functionality that a class can implement. So, by using an interface, you can then use any of the methods or functions that have been defined within that interface. I’ll show you some examples of how to do this, but first, let’s look at the available events and their required interfaces.</p>
<p class="calibre3">There are three classes that the event data can be derived from, which are <code>PointerEventData</code>, <code>AxisEventData</code>, and <code>BaseEventData</code>:</p>
<ul class="calibre16">
<li class="calibre14"><code>PointerEventData</code> is the class that contains events associated with the pointer</li>
<li class="calibre14"> <code>AxisEventData</code> contains events associated with the keyboard and gamepad</li>
<li class="calibre14"><code>BaseEventData</code> contains events that are used by all event types</li>
</ul>
<p class="calibre3">There is a<a id="_idIndexMarker381" class="pcalibre pcalibre1 calibre6"/> fourth event data class, <code>AbstractEventData</code>. It is the class from which the other three inherit.</p>
<p class="calibre3">The list of events available for a <code>StandaloneInputModule</code> along with their required interfaces and event data class are provided in the following chart. The events are listed in the same order they are listed within the Event Trigger component for continuity purposes:</p>
<table class="no-table-style" id="table001-2">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<thead class="calibre193">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Event</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Interface</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Event </strong><strong class="bold">Data Type</strong></p>
</td>
</tr>
</thead>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnPointerEnter</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IPointerEnterHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnPointerExit</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IPointerExitHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnPointerDown</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IPointerDownHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnPointerUp</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IPointerUpHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnPointerClick</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IPointerClickHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnDrag</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IdragHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnDrop</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IdropHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnScroll</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IscrollHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnUpdateSelected</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IUpdateSelectedHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>BaseEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnSelect</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IselectHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>BaseEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnDeselect</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IdeselectHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>BaseEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnMove</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IMoveHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>AxisEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnInitializePotentialDrag</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IInitializePotentialDragHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnBeginDrag</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IbeginDragHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnEndDrag</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>IEndDragHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>PointerEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnSubmit</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>ISubmitHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>BaseEventData</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>OnCancel</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>ICancelHandler</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>BaseEventData</code></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 8.1: Interfaces and event data types for the various events</p>
<p class="calibre3">To write a<a id="_idIndexMarker382" class="pcalibre pcalibre1 calibre6"/> class with one of these events, you will use the following template:</p>
<pre class="source-code">
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
public class ClassName : MonoBehaviour, <strong class="bold">InterfaceName</strong>{
     public void <strong class="bold">EventName</strong>(<strong class="bold">EventDataTypeName</strong> eventData){
          //what happens after event triggers
     }
}</pre> <p class="calibre3">The items highlighted in the preceding code will be replaced by the items within the preceding table.</p>
<p class="calibre3">For example, if you wanted to implement an <code>OnPointerEnter</code> event, the code would look as follows after the highlighted code has been replaced with an appropriate event, interface, and event data type:</p>
<pre class="source-code">
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
public class ClassName : MonoBehaviour, <strong class="bold">IPointerEnterHandler</strong>
     public void <strong class="bold">OnePointerEnter</strong>(<strong class="bold">PointerEventData</strong> eventData){
         //what happens after the event triggers
     }
}</pre> <p class="calibre3">You must<a id="_idIndexMarker383" class="pcalibre pcalibre1 calibre6"/> include the <code>UnityEngine.EventSystems</code> namespace to write code with event data. The <code>UnityEngine.UI</code> namespace is optional and is only required if you will also be writing your events for UI objects.</p>
<p class="calibre3">Now that we’ve reviewed various ways to send and receive events, let’s look at raycasters<a id="_idTextAnchor192" class="pcalibre pcalibre1 calibre6"/>.</p>
<h1 id="_idParaDest-140" class="calibre5"><a id="_idTextAnchor193" class="pcalibre pcalibre1 calibre6"/>Raycasters</h1>
<p class="calibre3">Remember that <a id="_idIndexMarker384" class="pcalibre pcalibre1 calibre6"/>the Event System keeps track of raycasting along with all the other<a id="_idIndexMarker385" class="pcalibre pcalibre1 calibre6"/> things we have discussed. Raycasting is used to determine which UI elements are being interacted with by projecting a ray from the user’s pointer into the scene. This ray is considered to originate at the camera’s plane and then proceed forward through the scene. Whatever this ray hits receives an interaction. You can have the ray continue through the first UI element it hits or stop at the first UI element it hits. To get a ray to stop at the first UI element it hits, the object must block raycasting. This will stop items behind it from being interacted with. Next, we’ll discuss the types of raycaster<a id="_idTextAnchor194" class="pcalibre pcalibre1 calibre6"/>s.</p>
<h2 id="_idParaDest-141" class="calibre7"><a id="_idTextAnchor195" class="pcalibre pcalibre1 calibre6"/>Graphic Raycaster</h2>
<p class="calibre3">When a<a id="_idIndexMarker386" class="pcalibre pcalibre1 calibre6"/> Canvas is added to the scene, it is automatically <a id="_idIndexMarker387" class="pcalibre pcalibre1 calibre6"/>given a <strong class="bold">Graphic </strong><strong class="bold">Raycaster</strong> component.</p>
<p class="calibre3">This is the raycasting system that will allow you to interact with all UI objects that are children of that Canvas. It has three properties: <strong class="bold">Ignore Reversed Graphics</strong>, <strong class="bold">Blocking Objects</strong>, and <strong class="bold">Blocking Mask</strong>.</p>
<p class="calibre3">The <strong class="bold">Ignore Reversed Graphics</strong> toggle determines whether or not graphical objects within the Canvas can be interacted with if they are facing backward (in relation to the raycaster). The <strong class="bold">Blocking Objects</strong> and <strong class="bold">Blocking Mask</strong> properties allow you to assign the types <a id="_idIndexMarker388" class="pcalibre pcalibre1 calibre6"/>of <a id="_idIndexMarker389" class="pcalibre pcalibre1 calibre6"/>objects that are in front of the Canvas (between the camera and the Canvas) that can block raycasting to the <a id="_idTextAnchor196" class="pcalibre pcalibre1 calibre6"/>Canvas.</p>
<h2 id="_idParaDest-142" class="calibre7"><a id="_idTextAnchor197" class="pcalibre pcalibre1 calibre6"/>Other Raycasters</h2>
<p class="calibre3">As stated earlier, if <a id="_idIndexMarker390" class="pcalibre pcalibre1 calibre6"/>you want to use the Event System with a <a id="_idIndexMarker391" class="pcalibre pcalibre1 calibre6"/>non-UI object, you must attach a Raycaster component to a camera within the scene. You can add either a <strong class="bold">Physics 2D Raycaster</strong> or a <strong class="bold">Physics Raycaster</strong> (or both) to your camera based on whether you are using 2D or 3D.</p>
<p class="calibre3">From within the camera’s inspector, you can add the <strong class="bold">Physics 2D Raycaster</strong> by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Physics 2D Raycaster</strong> and the <strong class="bold">Physics Raycaster</strong> by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Physics Raycaster</strong>.</p>
<p class="calibre3">The two components appear as follows:</p>
<div><div><img alt="Figure 8.12: The two types of Physics Raycasters" src="img/B18327_08_12.jpg" class="calibre194"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.12: The two types of Physics Raycasters</p>
<p class="calibre3">The <strong class="bold">Event Mask</strong> property determines which types of objects can receive raycasting.</p>
<p class="calibre3">If you attempt to add either of these components to a non-camera GameObject, a <strong class="bold">Camera</strong> component will automatically be attached to the GameObject as well.</p>
<p class="calibre3">Now that we’ve reviewed the various systems that we can use to program interactions for our UI, let’s look at some e<a id="_idTextAnchor198" class="pcalibre pcalibre1 calibre6"/>xamples.</p>
<h1 id="_idParaDest-143" class="calibre5"><a id="_idTextAnchor199" class="pcalibre pcalibre1 calibre6"/>Examples</h1>
<p class="calibre3">We will continue to work on the UI we have been building for the last two chapters. To help organize the project, duplicate the <code>Chapter7</code> scene that you created in the last chapter; it will automatically be named <code>Chapter8</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you did not work through the examples for <a href="B18327_06.xhtml#_idTextAnchor085" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 6</em></a>, and <a href="B18327_07.xhtml#_idTextAnchor106" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 7</em></a>, but would like to work through the examples in this chapter, you can import the package labeled <strong class="source-inline1">Chapter 08</strong><strong class="source-inline1"> – Examples 1 - Start</strong>. You can also view the completed examples in the <strong class="source-inline1">Chapter 08</strong><strong class="source-inline1"> – Examples 1 – </strong><strong class="source-inline1">End</strong> <a id="_idTextAnchor200" class="pcalibre pcalibre1 calibre6"/>package.</p>
<h2 id="_idParaDest-144" class="calibre7"><a id="_idTextAnchor201" class="pcalibre pcalibre1 calibre6"/>Showing and hiding pop-up menus with keypress</h2>
<p class="calibre3">So far, we have made<a id="_idIndexMarker392" class="pcalibre pcalibre1 calibre6"/> two Panels that we plan on turning into popups: the <code>Pause Panel</code> from <a href="B18327_06.xhtml#_idTextAnchor085" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 6</em></a>, and the <code>Inventory Panel</code> from <a href="B18327_07.xhtml#_idTextAnchor106" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 7</em></a>. Right now, they are both visible in the scene (even though <code>Pause Panel</code> is hidden behind the <code>Inventory Panel</code>). We want them to pop up when we press <em class="italic">P</em> and <em class="italic">I</em> on the<a id="_idIndexMarker393" class="pcalibre pcalibre1 calibre6"/> keyboard. For demonstration purposes, we’ll access the keyboard keys differently for each Panel.</p>
<p class="calibre3">Remember that both of these Panels have Canvas Group components on them. These components will allow us to easily access the Panels’ alpha, intractable, and blocks raycasts p<a id="_idTextAnchor202" class="pcalibre pcalibre1 calibre6"/>roperties.</p>
<h3 class="calibre9">Using KeyCode with the Inventory Panel</h3>
<p class="calibre3">Let’s<a id="_idIndexMarker394" class="pcalibre pcalibre1 calibre6"/> begin with the <code>Inventory Panel</code>. We want <a id="_idIndexMarker395" class="pcalibre pcalibre1 calibre6"/>the Panel to pop up and close when the <em class="italic">I</em> key is pressed on the keyboard. To make the <code>Inventory Panel</code> appear and disappear with the <em class="italic">I</em> key, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">Create a new C# script in the <code>Assets/Scripts</code> folder by right-clicking within the <strong class="bold">Project</strong> view of the folder and selecting <strong class="bold">Create</strong> | <strong class="bold">C# Script</strong> from the pop-up Panel.</li>
<li class="calibre14">Name the script <code>ShowHidePanels.cs</code>, and then double-click on it to open.</li>
<li class="calibre14">Now, let’s use a <code>public CanvasGroup</code> variable called <code>inventoryPanel</code> to represent <a id="_idIndexMarker396" class="pcalibre pcalibre1 calibre6"/>the Panel. We use a <code>CanvasGroup</code> variable type to reference the Panel since<a id="_idIndexMarker397" class="pcalibre pcalibre1 calibre6"/> we want to access the properties of the <code>ShowHidePanels</code> script to include the following highlighted line of code:<pre class="source-code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class ShowHidePanels : MonoBehaviour {
    <strong class="bold">public CanvasGroup inventoryPanel;</strong>
}</pre><p class="calibre3">The <code>CanvasGroup</code> variable type, even though it is used with UI elements, is not in the <code>UnityEngine.UI</code> namespace, but the <code>UnityEngine</code> namespace, so we do not need to include the <code>UnityEngine.UI</code> namespace in our script at the moment.</p></li> <li class="calibre14">Let’s create another variable that will keep track of whether or not the <code>Inventory Panel</code> is visible. Add the following code to the next line of the script to initialize the variable:<pre class="source-code">
bool inventoryUp = false;</pre></li> <li class="calibre14">We will be toggling the Panels on and off by adjusting their <code>alpha</code>, <code>interactable</code>, and <code>blocksRaycasts</code> properties. When the Panel is hidden, it should also not accept interactions or block raycasts. So, let’s create a method that we can call to perform the toggle. Add the following namespace to your script:<pre class="source-code">
using System;</pre><p class="calibre3">Add the following method to your script:</p><pre class="source-code">public void TogglePanel(CanvasGroup Panel, bool show)
{
    Panel.alpha = Convert.ToInt32(show);
    Panel.interactable = show;
    Panel.blocksRaycasts = show;
}</pre><p class="calibre3">As you can see, the<a id="_idIndexMarker398" class="pcalibre pcalibre1 calibre6"/> method has two parameters. The first parameter is a <code>CanvasGroup</code> called <code>Panel</code> and the second parameter is a Boolean called <code>show</code>. It will set the <code>alpha</code> property to <code>0</code> when <code>show</code> is <code>false</code> and <code>1</code> when <code>show</code> is <code>true</code>. It will also set the <code>interactable</code> and <code>blocksRaycasts</code> properties to <code>false</code> when <code>show</code> is <code>false</code> and <code>true</code> when <code>show</code> is <code>true</code>.</p></li> <li class="calibre14">We<a id="_idIndexMarker399" class="pcalibre pcalibre1 calibre6"/> want <code>Inventory Panel</code> to be hidden when the scene starts playing. So, update the <code>Start()</code> function to include the following code:<pre class="source-code">
void Start () {
    TogglePanel(inventoryPanel, inventoryUp);
}</pre></li> <li class="calibre14">Now, we need to write code that triggers whenever the <em class="italic">I</em> key on the keyboard is pressed down. We will use the <code>Input.GetKeyDown()</code> function in a way that the function is called the moment the key is pressed down. We will also use <code>KeyCode.I</code> to reference the <em class="italic">I</em> key on the keyboard. Add the following code to your <code>Update</code> function to check whether the <em class="italic">I</em> key is pressed down:<pre class="source-code">
void Update () {
    //inventory Panel
    if(Input.GetKeyDown(KeyCode.I)){
    }
}</pre></li> <li class="calibre14">We want this <a id="_idIndexMarker400" class="pcalibre pcalibre1 calibre6"/>key to disable and enable the Panel, so we will change the value of <code>inventoryUp</code> to whatever the opposite <a id="_idIndexMarker401" class="pcalibre pcalibre1 calibre6"/>of its current value is. That is, if it is <code>true</code>, we will set it to <code>false</code>, if it is <code>false</code>, we will set it to <code>true</code>. Then, we will call the <code>TogglePanel()</code> method.<p class="calibre3">Add the following highlighted code to your <code>Update()</code> function:</p><pre class="source-code">
void Update()
{
    // Inventory Panel
    if (Input.GetKeyDown(KeyCode.I))
    {
        inventoryUp = !inventoryUp;
        TogglePanel(inventoryPanel, inventoryUp);
    }
}</pre></li> <li class="calibre14">Now, for this code to work, we need to attach it to a GameObject within our scene. It really doesn’t matter what GameObject we attach it to, since we used a public variable to access our <code>Inventory Panel</code>, we can assign that via the Inspector. However, since we are planning on using this script to affect both Panels, I want to add it to <code>Main Camera</code>. Drag and drop the <code>ShowHidePanels</code> script into the <code>Main Camera</code>. You should now see the following as a component on your <code>Main Camera</code>:</li>
</ol>
<div><div><img alt="Figure 8.13: The ShowHidePanel.cs script component" src="img/B18327_08_13.jpg" class="calibre195"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.13: The ShowHidePanel.cs script component</p>
<ol class="calibre13">
<li value="10" class="calibre14">Now, we need to assign the <code>Inventory Panel</code> GameObject to the slot labeled <strong class="bold">Inventory Panel</strong>. Drag and drop the <strong class="bold">Inventory Panel</strong> from the Hierarchy into this slot:</li>
</ol>
<div><div><img alt="Figure 8.14: Adding the Inventory Panel ShowHidePanel.cs script component" src="img/B18327_08_14.jpg" class="calibre196"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.14: Adding the Inventory Panel ShowHidePanel.cs script component</p>
<ol class="calibre13">
<li value="11" class="calibre14">Play the<a id="_idIndexMarker402" class="pcalibre pcalibre1 calibre6"/> game to ensure that the code is working<a id="_idIndexMarker403" class="pcalibre pcalibre1 calibre6"/> correctly. You should see the inventory Panel start out invisible and then turn on and off as you press the <em class="italic">I</em> key on the keyboard.</li>
</ol>
<p class="calibre3">Now that we’ve completed the work needed to show and hide the <code>Inventory Panel</code>, we can move on to<a id="_idTextAnchor203" class="pcalibre pcalibre1 calibre6"/> the <code>Pause Panel</code>.</p>
<h3 class="calibre9">Using Input Manager with the Pause Panel</h3>
<p class="calibre3">Now, let’s do<a id="_idIndexMarker404" class="pcalibre pcalibre1 calibre6"/> the same thing for the <code>Pause Panel</code>. We’ll do this slightly differently than the <code>Inventory Panel</code>. To make <a id="_idIndexMarker405" class="pcalibre pcalibre1 calibre6"/>sure that you can see how to access a key with the Input Manager, we’ll use the Input Manager instead of a <code>KeyCode</code>. We also need to actually pause the game.</p>
<p class="calibre3">To display the <code>Pause Panel</code> using the <em class="italic">P</em> key and pause the game, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">First, we need to set up the Input Manager to include a <code>Pause</code> axis. Open the Input Manager with <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Input Manager</strong> and expand the axes by selecting the arrow next to the word <strong class="bold">Axes</strong>.</li>
<li class="calibre14">By default, your project has 30 axes. You can replace one of these with the new <code>Pause</code> axis if you aren’t planning on using them, but we might as well just go ahead and make a new one. Definitely don’t delete the <code>31</code>. This will duplicate the last axis in the list, <strong class="bold">Debug Horizontal</strong>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 8.15: The Input Manager with an extra axis" src="img/B18327_08_15.jpg" class="calibre197"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.15: The Input Manager with an extra axis</p>
<ol class="calibre13">
<li value="3" class="calibre14">Change the<a id="_idIndexMarker407" class="pcalibre pcalibre1 calibre6"/> second <code>Debug Horizontal</code> axis to a <code>Pause</code> axis by changing the <code>Pause</code>, the <code>p</code>, and changing the rest of the properties to the following:</li>
</ol>
<div><div><img alt="Figure 8.16: The Pause axis added to the Input Manager" src="img/B18327_08_16.jpg" class="calibre198"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.16: The Pause axis added to the Input Manager</p>
<ol class="calibre13">
<li value="4" class="calibre14">Now that <a id="_idIndexMarker408" class="pcalibre pcalibre1 calibre6"/>we have our <code>Pause</code> axis set up, we can start writing our code. Let’s define some variables to use with the <code>Pause Panel</code> similar to the way we defined variables for <code>Inventory Panel</code>. Add the following variable definitions at the top of your class under your previous variable definitions:<pre class="source-code">
public CanvasGroup pausePanel;bool pauseUp = false;</pre></li> <li class="calibre14">Add the <a id="_idIndexMarker409" class="pcalibre pcalibre1 calibre6"/>following to the <code>Start()</code> function and make the <code>Pause Panel</code> invisible at start:<pre class="source-code">
TogglePanel(pausePanel, pauseUp);</pre></li> <li class="calibre14">Since we added the <code>Pause</code> axis to our Input Manager, we can use <code>Input.GetButtonDown()</code> instead of <code>Input.GetKeyDown()</code>, like we did with <code>Inventory Panel</code>. We want to use <code>GetButtonDown()</code> rather than <code>GetAxis()</code> because we want a function that will return <code>true</code> once, not continuously. If it returned continuously (using <code>GetAxis()</code>), the Panel would flicker in and out while the <em class="italic">P</em> key was being pressed. Add the following code at the end of your <code>Update()</code> function. Note that it’s very similar to the code we used for Inventory Panel:<pre class="source-code">
// pause Panel
if(Input.GetButtonDown("Pause")){
     pauseUp = !pauseUp;
     TogglePanel(pausePanel, pauseUp);
}</pre></li> <li class="calibre14">Now <a id="_idIndexMarker410" class="pcalibre pcalibre1 calibre6"/>that we’ve added new public variables to our script, it should be showing up in the <code>Main Camera</code>. Drag and drop the <code>Pause Panel</code> from the Hierarchy to the <strong class="bold">Pause </strong><strong class="bold">Panel</strong> slot.</li>
</ol>
<div><div><img alt="Figure 8.17: The ShowHidePanel.cs script component with the Pause Panel added" src="img/B18327_08_17.jpg" class="calibre199"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.17: The ShowHidePanel.cs script component with the Pause Panel added</p>
<ol class="calibre13">
<li value="8" class="calibre14">Now, play the game and watch the <code>Pause Panel</code> become visible and invisible when you<a id="_idIndexMarker411" class="pcalibre pcalibre1 calibre6"/> press the <em class="italic">P</em> key on the keyboard.</li>
</ol>
<p class="calibre3">Next, we’ll learn <a id="_idTextAnchor204" class="pcalibre pcalibre1 calibre6"/>about pausing the game.</p>
<h2 id="_idParaDest-145" class="calibre7"><a id="_idTextAnchor205" class="pcalibre pcalibre1 calibre6"/>Pausing the game</h2>
<p class="calibre3">The <a id="_idIndexMarker412" class="pcalibre pcalibre1 calibre6"/>game doesn’t actually pause right now. If we had animations or events running in the scene, they would continue to run even with the <code>Pause Panel</code> up. A really easy way to pause a game is to manipulate the time scale of the game. If the time scale is set to <code>1</code>, time will run as it normally does. If the time scale is set to <code>0</code>, the time within the game will pause.</p>
<p class="calibre3">Also, our current setup doesn’t quite work as a pause menu would be expected to. <code>Inventory Panel</code> and <code>Pause Panel</code> can be displayed at the same time. If <code>Inventory Panel</code> is up, the <code>Pause Panel</code> is covered up by it since it is rendering behind it. Also, the <code>Inventory Panel</code> can be activated when the game is <em class="italic">paused</em>.</p>
<p class="calibre3">We’ll need to<a id="_idIndexMarker413" class="pcalibre pcalibre1 calibre6"/> pause the time scale of our game, change the order that our Panels render, and disable functionality when the game is paused to have a <code>Pause Panel</code> that functions properly. To create a properly functioning <code>Pause Panel</code>, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">Add the following to the <code>Update()</code> function to the <code>ShowHidePanels</code> script to pause the time in the game:<pre class="source-code">
// pause Panel
if(Input.GetButtonDown("Pause")){
     pauseUp = !pauseUp;
     TogglePanel(pausePanel, pauseUp);
     <strong class="bold">Time.timeScale = Convert.ToInt32(pauseUp);</strong>
}</pre></li> <li class="calibre14">Now, let’s deal with the fact that <code>Pause Panel</code> is behind the <code>Inventory Panel</code>. This is an easy fix. Simply change their order in the Hierarchy by dragging the <code>Pause Panel</code> below the <code>Inventory Panel</code>. The items that are listed lower in the Hierarchy render on top of the ones listed above it within the scene. Now, the <code>Pause Panel</code> will be above the <code>Inventory Panel</code> in the scene:</li>
</ol>
<div><div><img alt="Figure 8.18: The children of the Popup Canvas" src="img/B18327_08_18.jpg" class="calibre200"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.18: The children of the Popup Canvas</p>
<ol class="calibre13">
<li value="3" class="calibre14">The only thing left to do is to disable the ability of the <code>Inventory Panel</code> to appear and disappear if the <code>Pause Panel</code> is up. Adjust the <code>if</code> statement that checks for the <em class="italic">I</em> key being pressed to also check whether <code>pauseUp</code> is false, like so:<pre class="source-code">
if(Input.GetKeyDown(KeyCode.I) <code>Inventory Panel</code> cannot be activated or deactivated. If the <code>Inventory Panel</code> is activated when the <code>Pause Panel</code> is already up, it cannot be deactivated until after the game is unpaused.</li>
</ol>
<p class="calibre3">It’s important to<a id="_idIndexMarker414" class="pcalibre pcalibre1 calibre6"/> remember that when you have a <code>Pause Panel</code>, other events need to be turned off. Setting the timescale to <code>0</code> does not stop the ability for other events to occur; it only really stops animations and any clocks you may have displayed that use the time scale. So, we will need to ensure that any other event we program is turned off<a id="_idTextAnchor206" class="pcalibre pcalibre1 calibre6"/> when the game is paused.</p>
<h2 id="_idParaDest-146" class="calibre7"><a id="_idTextAnchor207" class="pcalibre pcalibre1 calibre6"/>Dragging and dropping inventory items</h2>
<p class="calibre3">We have an <code>Inventory Panel</code> that can be displayed and hidden and a HUD inventory. I <a id="_idIndexMarker415" class="pcalibre pcalibre1 calibre6"/>want to be able to drag objects from my larger <code>Inventory Panel</code> to my smaller HUD inventory called <code>Bottom Right Panel</code> that we created in the previous chapter.</p>
<p class="calibre3">To make things a little easier for ourselves, let’s disable the <code>ShowHidePanels</code> script that we added to the <code>Main Camera</code> earlier in this chapter. You can do this by deselecting the checkbox next to the script’s component on the <code>Main Camera</code>:</p>
<div><div><img alt="Figure 8.19: Disabling the ShowHidePanel.cs script component" src="img/B18327_08_19.jpg" class="calibre201"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.19: Disabling the ShowHidePanel.cs script component</p>
<p class="calibre3">Let’s also disable <code>Pause Panel</code> so that it will not be in our way. Do this by deselecting the checkbox next to the name of the <code>Pause Panel</code> in its Inspector.</p>
<p class="calibre3">Now, our Panel will stay visible, making it easier for us to debug the code we’re about to write.</p>
<p class="calibre3">There are <a id="_idIndexMarker416" class="pcalibre pcalibre1 calibre6"/>quite a few different ways to make a drag and drop mechanic. To ensure that this chapter provides an example of how to use the <code>Inventory Panel</code> and <code>Bottom Right Panel</code>, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">Create a new C# script in the <code>Assets/Scripts</code> folder called <code>DragAndDrop.cs</code> and open it.</li>
<li class="calibre14">We will be referencing UI elements in this script, so add the <code>UnityEngine.UI</code> namespace to the top of the script with this:<pre class="source-code">
using UnityEngine.UI;</pre></li> <li class="calibre14">We only need to add two variables to this script: one will represent the GameObject being dragged, and the other represents the Canvas that the items will be dragged on. Add the following public variables to the top of the class:<pre class="source-code">
public GameObject dragItem;¶public Canvas dragCanvas;</pre></li> <li class="calibre14">Before we write any more code, let’s go back to the Editor and do a bit more prep work. Drag the <code>DragAndDrop.cs</code> script to the <code>Main Camera</code> to attach it as a component:
<div><div><img alt="Figure 8.20: The components of the Main Camera" src="img/B18327_08_20.jpg" class="calibre202"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.20: The components of the Main Camera</p>
<p class="calibre3">I’ve chosen to create a script that attaches to the <code>Main Camera</code> rather than the individual inventory items to reduce the need to duplicate this script.</p></li></ol>
<ol class="calibre13">
<li value="5" class="calibre14">Now, create<a id="_idIndexMarker417" class="pcalibre pcalibre1 calibre6"/> a new UI Canvas by selecting <code>Drag Canvas</code>.</li>
<li class="calibre14">Select <code>HUD Canvas</code> and copy its <strong class="bold">Canvas Scalar</strong> component by selecting the settings three dots (aka “the kabob”) in its top-right corner and selecting <strong class="bold">Copy</strong> <strong class="bold">Component</strong>.</li>
<li class="calibre14">Reselect <code>Drag Canvas</code> and paste the copied <strong class="bold">Canvas Scaler</strong> properties to its <strong class="bold">Canvas Scalar</strong> component by selecting the three dots in its top-right corner and selecting <strong class="bold">Paste </strong><strong class="bold">Component Values</strong>.<p class="calibre3">Once that is done, it should have the following values:</p></li>
</ol>
<div><div><img alt="Figure 8.21: The Canvas Scaler component on the Drag Canvas" src="img/B18327_08_21.jpg" class="calibre203"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.21: The Canvas Scaler component on the Drag Canvas</p>
<ol class="calibre13">
<li value="8" class="calibre14">Set the <code>Drag Canvas</code>’ Canvas component to <code>1</code>. This will<a id="_idIndexMarker418" class="pcalibre pcalibre1 calibre6"/> cause anything that is on the <code>Drag Canvas</code> to render in front of all other Canvases since the other Canvases have a <code>0</code>:</li>
</ol>
<div><div><img alt="Figure 8.22: Updating the Sort Order on the Drag Canvas’ Canvas component" src="img/B18327_08_22.jpg" class="calibre204"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.22: Updating the Sort Order on the Drag Canvas’ Canvas component</p>
<ol class="calibre13">
<li value="9" class="calibre14">Drag and drop the <code>Drag Canvas</code> from the Hierarchy into the <code>DragAndDrop</code> script component on the <code>Main Camera</code>:</li>
</ol>
<div><div><img alt="Figure 8.23: The Drag and Drop component" src="img/B18327_08_23.jpg" class="calibre205"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.23: The Drag and Drop component</p>
<ol class="calibre13">
<li value="10" class="calibre14">Reopen the <code>DragAndDrop</code> script. Create a new function called <code>StartDrag()</code>, as follows:<pre class="source-code">
public void StartDrag(GameObject selectedObject){
    dragItem = Instantiate(selectedObject, Input.mousePosition, selectedObject.transform.rotation) as GameObject;
    dragItem.transform.SetParent(dragCanvas.transform);
    dragIt<a id="_idTextAnchor208" class="pcalibre pcalibre1 calibre6"/>em.GetComponent&lt;Image&gt;().SetNativeSize();
    dragItem.transform.localScale = 1.1f * dragItem.transform.localScale;
}</pre><p class="calibre3">This function<a id="_idIndexMarker419" class="pcalibre pcalibre1 calibre6"/> will be called when a drag begins. It accepts a GameObject as a parameter and then creates a new instance of it at the position of the mouse. It then moves it so that it is a child of <code>dragCanvas</code>. Lastly, it sets the size of the sprite on the Image component to native size. This resets the scale of the Image’s Rect Transform to its sprite’s original pixel size. (Refer to <a href="B18327_12.xhtml#_idTextAnchor328" class="pcalibre pcalibre1 calibre6"><em class="italic">Chapter 12</em></a> for more on <strong class="bold">Set Native Size</strong>). The last line makes the image 10% bigger than its native size.</p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">After we hook up our <strong class="source-inline1">BeginDrag</strong> and <strong class="source-inline1">Drag</strong> events, if you comment out the line of code that sets the size to native, you›ll see that the Image does not actually render in the scene, because its scale is «wacky» from the original GameObject being within a <strong class="bold">Layout Group</strong>.</p>
<ol class="calibre13">
<li value="11" class="calibre14">Now, create a new function called <code>Drag()</code>, as follows:<pre class="source-code">
public void Drag(){
     dragItem.transform.position = Input.mousePosition;
}</pre><p class="calibre3">This function will be called when an object is being dragged. While the object is dragged, it will keep position with the mouse.</p></li> <li class="calibre14">Return to the<a id="_idIndexMarker420" class="pcalibre pcalibre1 calibre6"/> Editor. We will just hook the events to the first object in the <code>Inventory Panel</code> for now. Select the first <code>Food</code> image in the <code>Inventory Panel</code>:</li>
</ol>
<div><div><img alt="Figure 8.24: Selecting the Food GameObject" src="img/B18327_08_24.jpg" class="calibre206"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.24: Selecting the Food GameObject</p>
<ol class="calibre13">
<li value="13" class="calibre14">Add a new Event Trigger component to the <code>Food</code> Image by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Event Trigger</strong> within its <strong class="bold">Inspector</strong>:</li>
</ol>
<div><div><img alt="Figure 8.25: The Food GameObject with the Event Trigger component" src="img/B18327_08_25.jpg" class="calibre207"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.25: The Food GameObject with the Event Trigger component</p>
<ol class="calibre13">
<li value="14" class="calibre14">Now, add a <strong class="bold">Begin Drag</strong> event<a id="_idIndexMarker421" class="pcalibre pcalibre1 calibre6"/> type and a <strong class="bold">Drag</strong> event type to the <strong class="bold">Event Trigger</strong> list by selecting <strong class="bold">Add New Event Type</strong> | <strong class="bold">BeginDrag</strong> and <strong class="bold">Add New Event Type</strong> | <strong class="bold">Drag</strong>:</li>
</ol>
<div><div><img alt="Figure 8.26: The Event Trigger component with two events" src="img/B18327_08_26.jpg" class="calibre208"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.26: The Event Trigger component with two events</p>
<ol class="calibre13">
<li value="15" class="calibre14">Now, we<a id="_idIndexMarker422" class="pcalibre pcalibre1 calibre6"/> will add an action to the <strong class="bold">Begin Drag</strong> list by selecting the plus sign at the bottom-right corner of the <strong class="bold">Begin </strong><strong class="bold">Drag</strong> area:</li>
</ol>
<div><div><img alt="Figure 8.27: Adding a Begin Drag event" src="img/B18327_08_27.jpg" class="calibre209"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.27: Adding a Begin Drag event</p>
<ol class="calibre13">
<li value="16" class="calibre14">Drag the <code>Main Camera</code> into the object slot:</li>
</ol>
<div><div><img alt="Figure 8.28: Updating the Begin Drag event with the camera" src="img/B18327_08_28.jpg" class="calibre210"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.28: Updating the Begin Drag event with the camera</p>
<ol class="calibre13">
<li value="17" class="calibre14">The function dropdown list is now intractable. Expand the function dropdown list to see the<a id="_idIndexMarker423" class="pcalibre pcalibre1 calibre6"/> list of functions, components, and such attached to the <code>Main Camera</code>. Find the <strong class="bold">DragAndDrop</strong> script and then the <strong class="bold">StartDrag (</strong><strong class="bold">GameObject)</strong> function:
<div><div><img alt="Figure 8.29: Adding the StartDrag method" src="img/B18327_08_29.jpg" class="calibre211"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.29: Adding the StartDrag method</p>
<p class="calibre3">Once you have done so, you should see the following:</p>
<div><div><img alt="Figure 8.30: Adding the StartDrag method" src="img/B18327_08_30.jpg" class="calibre212"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.30: Adding the StartDrag method</p></li>
</ol>
<ol class="calibre13">
<li value="18" class="calibre14">Now, we<a id="_idIndexMarker424" class="pcalibre pcalibre1 calibre6"/> need to assign the GameObject parameter. Drag and drop the <code>Food</code> Image that this <strong class="bold">Event Trigger</strong> component is attached to into the parameter slot.</li>
</ol>
<div><div><img alt="Figure 8.31: Updating the StartDrag method" src="img/B18327_08_31.jpg" class="calibre213"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.31: Updating the StartDrag method</p>
<ol class="calibre13">
<li value="19" class="calibre14">Now, set up the <strong class="bold">Drag</strong> event list similarly so that it looks like this:</li>
</ol>
<div><div><img alt="Figure 8.32: Adding the Drag method" src="img/B18327_08_32.jpg" class="calibre214"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.32: Adding the Drag method</p>
<ol class="calibre13">
<li value="20" class="calibre14">If you play the game, you should now be able to drag the orange in the first slot out of its slot.
<div><div><img alt="Figure 8.33: Dragging the orange from the inventory" src="img/B18327_08_33.jpg" class="calibre215"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.33: Dragging the orange from the inventory</p>
<p class="calibre3">You’ll see, in<a id="_idIndexMarker425" class="pcalibre pcalibre1 calibre6"/> the Hierarchy, there is a new GameObject called <code>Food(Clone)</code> that is a child of the <code>Drag Canvas</code>. This is the orange that gets created when you begin dragging.</p>
<div><div><img alt="Figure 8.34: The item being dragged in the Drag Canvas" src="img/B18327_08_34.jpg" class="calibre216"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.34: The item being dragged in the Drag Canvas</p>
<p class="calibre3">At this point, you can actually make as many of these clones as you want. In a moment, however, we will make it so that there is only one clone in the <code>Drag Canvas</code> at a time.</p></li>
</ol>
<ol class="calibre13">
<li value="21" class="calibre14">Go back to the <code>DragAndDrop</code> script and create a new function called <code>StopDrag()</code>, as follows:<pre class="source-code">
public void StopDrag(){
     Destroy(dragItem);
}</pre><p class="calibre3">This code will destroy the <code>Food(Clone)</code> GameObject once it is no longer being dragged.</p></li> <li class="calibre14">Go back to the<a id="_idIndexMarker426" class="pcalibre pcalibre1 calibre6"/> Editor and reselect the <code>Food</code> Image in <code>Inventory Panel</code>. Give its <code>EndDrag</code> event type by selecting <code>Drag()</code> function from the <code>DragAndDrop</code> script to this event since that was the last selected function:</li>
</ol>
<div><div><img alt="Figure 8.35: The End Drag event with the Drag method" src="img/B18327_08_35.jpg" class="calibre217"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.35: The End Drag event with the Drag method</p>
<ol class="calibre13">
<li value="23" class="calibre14">Replace the <code>Drag()</code> function in the function dropdown with the <code>StopDrag()</code> function:</li>
</ol>
<div><div><img alt="Figure 8.36: The End Drag event with the StopDrag method" src="img/B18327_08_36.jpg" class="calibre218"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.36: The End Drag event with the StopDrag method</p>
<ol class="calibre13">
<li value="24" class="calibre14">Play the game, and you will see that the orange can now be dragged out of its slot, and when you release the mouse, it is destroyed. This stops you from being able to drag a bunch of oranges from this slot.</li>
<li class="calibre14">Go back to the <code>DragAndDrop</code> script and create a new function called <code>Drop()</code>, as shown in the following:<pre class="source-code">
public void Drop(Image dropSlot){
     GameObject droppedItem = dragCanvas.transform.GetChild(0).gameObject;
     dropSlot.sprite = droppedItem.GetComponent&lt;Image&gt;().sprite;
}</pre><p class="calibre3">This<a id="_idIndexMarker427" class="pcalibre pcalibre1 calibre6"/> function accepts an <code>Image</code> as a parameter. This Image will be the Image component of the slot that will receive a drop. The first line of the function finds the first child of the <code>dragCanvas</code> (at position <code>0</code>) and then assigns its Image’s sprite to the sprite of the <code>dropSlot</code>. Since we have set up the <code>StopDrag()</code> function to destroy the object being dragged once it stops dragging, we don’t have to worry about there being more than one child of the <code>Drag Canvas </code>GameObject, making this the easiest way to find the object being dragged.</p></li> <li class="calibre14">Go back to the Editor and select the second <code>Food</code> Image in the <code>Bottom </code><code>Right Panel</code>:
<div><div><img alt="Figure 8.37: Selecting the correct Food item" src="img/B18327_08_37.jpg" class="calibre219"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.37: Selecting the correct Food item</p>
<p class="calibre3">We’re using the second <code>Food</code> Image, rather than the first, because the first already has an orange in it, and it will be hard to tell that our script worked in that slot.</p></li>
</ol>
<ol class="calibre13">
<li value="27" class="calibre14">Add a new <code>Food</code> Image by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Event Trigger</strong> within its Inspector.</li>
<li class="calibre14">Add a <code>Drop</code> event type to the <strong class="bold">Event Trigger</strong> component by selecting <strong class="bold">Add New Event Type</strong> | <strong class="bold">Drop</strong>:</li>
</ol>
<div><div><img alt="Figure 8.38: The Drop event" src="img/B18327_08_38.jpg" class="calibre220"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.38: The Drop event</p>
<ol class="calibre13">
<li value="29" class="calibre14">Add a new <a id="_idIndexMarker428" class="pcalibre pcalibre1 calibre6"/>action to the list with the <strong class="bold">+</strong> sign.</li>
<li class="calibre14">Drag <code>Main Camera</code> to the object slot and select the <code>Drop()</code> function from the <code>DragAndDrop</code> script:</li>
</ol>
<div><div><img alt="Figure 8.39: The Drop event with its method populated" src="img/B18327_08_39.jpg" class="calibre221"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.39: The Drop event with its method populated</p>
<ol class="calibre13">
<li value="31" class="calibre14">Now, drag the <code>Food</code> Image that this <strong class="bold">Event Trigger</strong> component is attached to into the parameter slot:</li>
</ol>
<div><div><img alt="Figure 8.40: The Drop event with the correct parameter" src="img/B18327_08_40.jpg" class="calibre222"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.40: The Drop event with the correct parameter</p>
<ol class="calibre13">
<li value="32" class="calibre14">Play the game and when you drag the orange into the slot over the banana, the <code>Drop()</code> function doesn’t appear to trigger. This is because the orange being dragged is blocking the raycasting from reaching the banana, so the banana never thinks anything is dropped on it. This is an easy fix. Add the following line of code to the end of the <code>StartDrag()</code> function in the <code>DragAndDrop</code> script so that the raycast won’t be blocked by the orange anymore:<pre class="source-code">
dragItem.GetComponent&lt;Image&gt;().raycastTarget = false;</pre></li> <li class="calibre14">Play the<a id="_idIndexMarker429" class="pcalibre pcalibre1 calibre6"/> game, and you should now be able to drag the orange from the first slot of the <code>Inventory Panel</code> to the second slot of <code>Bottom </code><code>Right Panel</code>.</li>
<li class="calibre14">The functionality of drag and drop is now complete; we just need to add the functionality to the other slots. Let’s add the drag events to the other <code>Inventory Panel</code> items first.<p class="calibre3">Copy the <code>Food</code> Item in the <code>Inventory Panel</code> that we hook the events up to, using the three dots in the component’s top-right corner.</p></li>
<li class="calibre14">Select all the other <code>Food</code> Images in the <code>Inventory Panel</code> by clicking on them while holding <em class="italic">Ctrl</em>.</li>
<li class="calibre14">Now, with all eight <code>Food</code> Images still selected, click on the three dots on the <code>Food</code> Images should now have the <strong class="bold">Event Trigger</strong> component with all the appropriate events.</li>
<li class="calibre14">We’re not done with these other inventory items yet. We need to select each one and drag it into the parameter of the <code>BeginDrag</code> event type for its component. Otherwise, each of these other eight <code>Food</code> items will drag out oranges instead of the appropriate <code>Food</code> item, because the original orange is assigned to that slot. Do so now.</li>
<li class="calibre14">Before continuing, play the game and ensure that each inventory item in <code>Inventory Panel</code> drags out the appropriate image.</li>
<li class="calibre14">Now, we will copy the drop events from the second <code>Food</code> Image image in the <code>Bottom Right Panel</code> to all the other <code>Food</code> Images within the Panel. Copy the <code>Food</code> Image in the <code>Bottom </code><code>Right Panel</code>.</li>
<li class="calibre14">Select<a id="_idIndexMarker430" class="pcalibre pcalibre1 calibre6"/> the other four <code>Food</code> Images in the <code>Bottom Right Panel</code> while holding down <em class="italic">Ctrl</em>.</li>
<li class="calibre14">With each of the <code>Food</code> Images shown in the preceding screenshot still selected, paste the component as new in the Inspector.</li>
<li class="calibre14">Now, select each of the new <code>Food</code> Images and assign each to the parameter slot within their <strong class="bold">Event </strong><strong class="bold">Trigger</strong> component.</li>
<li class="calibre14">Play the game and ensure that the correct image slot is changed when a food item is dropped into it.</li>
<li class="calibre14">Now that the drag and drop code is done, re-enable the <code>ShowHidePanels</code> script on the <code>Main Camera</code> and re-enable the <code>Pause Panel</code>.</li>
</ol>
<p class="calibre3">That’s it for the drag and drop code. Currently, the <code>Pause Panel</code> blocks the raycast on the items within the <code>Inventory Panel</code>, so you don’t have to worry about disabling these events when the game is paused. However, if you end up changing the layout, you will want to do so by checking whether the <code>pauseUp</code> variable in <code>ShowHidePanels</code> is <code>false</code> before performing the tasks.</p>
<p class="calibre3">If you want to allow the objects to go back and forth (drag from both Panels and drop in both Panels), all you have to do is copy the appropriate component to the opposite Panels!</p>
<p class="calibre3">You might also want to make the repeated UI elements prefabs so that you can save yourself some time during development or instantiate them programmatically.</p>
<p class="calibre3">There are so many more examples I would love to cover in this chapter, but I can’t make this chapter take up the entire page count of the book! You’ll see more examples of how to use the Event System in the upcoming chapters, so don’t worry; this isn’t the last code example you will see<a id="_idTextAnchor209" class="pcalibre pcalibre1 calibre6"/>.</p>
<h2 id="_idParaDest-147" class="calibre7"><a id="_idTextAnchor210" class="pcalibre pcalibre1 calibre6"/>Pan and zoom with mouse and multi-touch input</h2>
<p class="calibre3">The last <a id="_idIndexMarker431" class="pcalibre pcalibre1 calibre6"/>example I want to cover in this chapter is how to pan the camera with a two-finger touch and pinch to zoom. We will also implement a left-click pan and scroll wheel zoom so that you can easily test it on your computer (when you don’t have multi-touch input). The following image shows what we will be implementing.</p>
<div><div><img alt="Figure 8.41: Demonstration of the pan and zoom code working" src="img/B18327_08_41.jpg" class="calibre223"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.41: Demonstration of the pan and zoom code working</p>
<p class="calibre3">To implement a pan and zoom on the camera, complete the following steps:</p>
<ol class="calibre13">
<li class="calibre14">So that I can actually see the effects of the pan and zoom, I want to populate some items in the scene. Let’s start by creating a prefab that we will place multiple times in the background. Create a <code>Prefabs</code> folder in your project by right-clicking on the <code>Assets</code> folder and selecting <code>Prefabs</code>.</li>
<li class="calibre14">Drag a sprite to the scene. I chose the first gem in the <code>foodSpriteSheet</code> called <code>foodSpriteSheet_1</code>.</li>
<li class="calibre14">Ensure that the <strong class="bold">Transform</strong> component of the sprite is positioned at the origin. If it is not, select the three dots in the top-right corner of the component and then select <strong class="bold">Reset</strong>.</li>
<li class="calibre14">Rename the sprite <code>Tile</code>.</li>
<li class="calibre14">Now, drag the sprite from the Hierarchy into your <code>Prefabs</code> folder. This will create a prefab called <code>Tile</code>.</li>
<li class="calibre14">We no longer need the prefab in the scene so go ahead and delete it.</li>
<li class="calibre14">Create an empty GameObject by selecting <strong class="bold">+</strong> | <strong class="bold">Create Empty</strong> in the Hierarchy. We will use this to hold the code that instantiates our tiles.</li>
<li class="calibre14">Rename<a id="_idIndexMarker432" class="pcalibre pcalibre1 calibre6"/> this empty GameObject to <code>Tile Maker</code>.</li>
<li class="calibre14">In the book’s source files, you will find three scripts called <code>Tile.cs</code>, <code>TileMaker.cs</code>, and <code>CameraHandle.cs</code>. Import them into the <code>Scripts</code> folder of your project.</li>
<li class="calibre14">Attach the <code>Tile.cs</code> script to the <code>Tile</code> prefab. This script will be used to make any instantiated <code>Tile</code> prefab have a random sprite.</li>
<li class="calibre14">Since the <code>Tile.cs</code> script is not really essential to the example, I won’t review the code, but I will point out that the <code>possibleSprites</code> list contains all the sprites that the tile can change to. Add all the sprites that look like gems to this list. You should see something like the following</li>
</ol>
<div><div><img alt="Figure 8.42: The possible sprites for the tile" src="img/B18327_08_42.jpg" class="calibre224"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.42: The possible sprites for the tile</p>
<ol class="calibre13">
<li value="12" class="calibre14">Now <a id="_idIndexMarker433" class="pcalibre pcalibre1 calibre6"/>attach the <code>TileMaker.cs</code> script to the <code>Tile </code><code>Maker</code> GameObject.</li>
<li class="calibre14">Drag the <code>Tile</code> prefab into the <strong class="bold">Tile Prefab</strong> slot and set the other values as follows:
<div><div><img alt="Figure 8.43: The TileMaker.cs script component" src="img/B18327_08_43.jpg" class="calibre225"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.43: The TileMaker.cs script component</p>
<p class="calibre3">This will make a total of <code>500</code> tiles instantiate in <code>25</code> columns and <code>20</code> rows.</p></li>
</ol>
<ol class="calibre13">
<li value="14" class="calibre14">Play the game and you should see a bunch of random gems appear in your scene.</li>
</ol>
<div><div><img alt="Figure 8.44: The gems in the scene" src="img/B18327_08_44.jpg" class="calibre226"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.44: The gems in the scene</p>
<ol class="calibre13">
<li value="15" class="calibre14">Now, let’s <a id="_idIndexMarker434" class="pcalibre pcalibre1 calibre6"/>hook up the pan and zoom script. Attach the <code>CameraHandler.cs</code> script to the <code>Main Camera</code>.</li>
<li class="calibre14">Before we review the code, let’s add the correct variables to the component. Adjust the values to the following:
<div><div><img alt="Figure 8.45: The CameraHandler.cs script component" src="img/B18327_08_45.jpg" class="calibre227"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.45: The CameraHandler.cs script component</p>
<p class="calibre3">The<a id="_idIndexMarker435" class="pcalibre pcalibre1 calibre6"/> various properties add bounds to how far the camera can pan, how much it can zoom, and how quickly it pans and zooms.</p></li>
</ol>
<ol class="calibre13">
<li value="17" class="calibre14">Now, let’s review the code. The code handles pan and zoom in two ways: one is with mouse input and the other with touch input. You’ll see that it also has special conditions for when a touch device is being played remotely via the Unity Editor.<p class="calibre3">A large portion of this code is vector math, and I will leave that for you to review on your own. The parts of this code I want to focus on are the parts relative to this chapter, specifically the parts involving <code>Input</code> and <code>Touch</code>. First, let’s look at the <code>HandleMouse()</code> method. I’ve highlighted the relevant parts:</p><pre class="source-code">
void HandleMouse() {
     if (<strong class="bold">Input.GetMouseButtonDown(0)</strong>) {
          lastPanPosition = <strong class="bold">Input.mousePosition</strong>;
     } else if (<strong class="bold">Input.GetMouseButton(0)</strong>) {
          PanCamera(Input.mousePosition);
     }
     float scroll = <strong class="bold">Input.GetAxis("Mouse ScrollWheel")</strong>;
     ZoomCamera(scroll, zoomSpeedMouse);
}</pre><p class="calibre3">Notice<a id="_idIndexMarker436" class="pcalibre pcalibre1 calibre6"/> that it uses <code>Input.GetMouseButtonDown(0)</code> to see if the left mouse button is currently held down, <code>Input.GetMouseButton(0)</code> to see if the mouse button has been clicked, and <code>Input.mousePosition</code> to find where the mouse is located.</p></li> <li class="calibre14">Now, let’s look at how input is handled with touch in the <code>HandleTouch()</code> method. First, it looks to see how many fingers are touching the screen with the following <code>switch</code> statement:<pre class="source-code">
switch(<code>Input.touchCount</code> returns how many <em class="italic">fingers</em> are currently touching the screen.</p></li> <li class="calibre14">When a single finger is touching the screen, the camera can pan. It first must get the position of the finger. It does so with the following code:<pre class="source-code">
<strong class="bold">Touch touch = Input.GetTouch(0);</strong>
if (<strong class="bold">touch.phase == TouchPhase.Began</strong>) {
     lastPanPosition = <strong class="bold">touch.position;</strong>
     panFingerId = <strong class="bold">touch.fingerId;</strong>
} else if (<strong class="bold">touch.fingerId</strong> == panFingerId &amp;&amp; <strong class="bold">touch.phase == TouchPhase.Moved</strong>) {
     PanCamera(<strong class="bold">touch.position</strong>);
}</pre><p class="calibre3">Once again, I have highlighted the relevant code.</p></li> <li class="calibre14">When <a id="_idIndexMarker437" class="pcalibre pcalibre1 calibre6"/>two fingers are touching the screen, it will get the position of the fingers with the following:<pre class="source-code">
Vector2[] newPositions = new Vector2[]{<code>Vector2</code> array. It then uses some fancy vector math to see whether the fingers are getting closer to each other or further away from each other, creating a pinch-to-zoom effect.</p></li> <li class="calibre14">The next piece of code that I want to focus on is the following line within the <code>PanCamera()</code> method:<pre class="source-code">
Vector3 offset = theCamera.<code>DragCamera()</code> and <code>StopCameraDrag()</code> methods, so it will know when to get the inputs. We’ll do this with Event Triggers on the <code>Background Canvas</code>. Add an <code>Background Canvas</code> with the following events:</li>
</ol>
<div><div><img alt="Figure 8.46: The Event Trigger on the Background Canvas" src="img/B18327_08_46.jpg" class="calibre228"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.46: The Event Trigger on the Background Canvas</p>
<ol class="calibre13">
<li value="23" class="calibre14">Now<a id="_idIndexMarker438" class="pcalibre pcalibre1 calibre6"/> that you’ve reviewed the code, play the game again to see the pan and zoom functions in action. If you can, I recommend also plugging a mobile device into your computer and running the game via Unity Remote. You can view information about how to use Unity Remote here: <a href="https://docs.unity3d.com/Manual/UnityRemote5.xhtml" class="pcalibre pcalibre1 calibre6">https://docs.unity3d.com/Manual/UnityRemote5.xhtml</a>.</li>
<li class="calibre14">We don’t want the game to pan and zoom when it’s paused and the inventory Panel is up! So, let’s update the <code>ShowHidePanels.cs</code> script to call the <code>TurnOffPanAndZoom()</code> and <code>TurnOnPanAndZoom()</code> methods, which toggle the <code>canPan</code> and <code>canZoom</code> Boolean variables.<p class="calibre3">Add the following variable to the <code>ShowHidePanels.cs</code> class:</p><pre class="source-code">
CameraHandler cameraHandler;</pre></li> <li class="calibre14">Now, we need to initialize the <code>cameraHandler</code> variable. Add an <code>Awake()</code> method with the following code:<pre class="source-code">
void Awake() {¶    cameraHandler = GetComponent&lt;CameraHandler&gt;();¶}</pre></li> <li class="calibre14">Now, add the following to the <code>TogglePanel()</code> method. This will call the <code>TurnOffPanAndZoom()</code> method whenever the game is paused or showing the inventory and call <code>TurnOnPanAndZoom()</code> whenever neither of the Panels is visible:<pre class="source-code">
if (inventoryUp || pauseUp)
{
    cameraHandler.TurnOffPanAndZoom();
}
else
{
    cameraHandler.TurnOnPanAndZoom();
}</pre></li> </ol>
<p class="calibre3">You should <a id="_idIndexMarker439" class="pcalibre pcalibre1 calibre6"/>now have a fully functional pan and zoom that are disabled when menus are visible!</p>
<p class="calibre3">This is almost the exact code I used in my game Barkeology, which you can find on the iOS app store: <a href="https://apps.apple.com/kn/app/barkeology/id1500348850" class="pcalibre pcalibre1 calibre6">https://apps.apple.com/kn/app/barkeology/id1500348850</a> So, if you do not have the ability to test your code on your mobile device, but would like to see it in action, you can view it there.</p>
<p class="calibre3">While this marks the end of the chapter, we will continue to work in the Event System throughout this text, so you will see plenty more examples.</p>
<h1 id="_idParaDest-148" class="calibre5"><a id="_idTextAnchor211" class="pcalibre pcalibre1 calibre6"/>Summary</h1>
<p class="calibre3">Now that we know how to utilize the Event System and program for UI elements, we can start making interactive and visual UI elements. We can also create UI that has its various properties change when events occur.</p>
<p class="calibre3">We covered a lot in this chapter! We discussed how to access the properties of UI elements and how to work with the Event System. We also discussed how to use the Input Module. Now, you can create UI that responds to user inputs as well as UI that responds to events within your game.</p>
<p class="calibre3"> In the next chapter, we will look at the other input system provided by Unity: the New Input System (yeah, that’s its actual name).</p>
</div>
</div></body></html>