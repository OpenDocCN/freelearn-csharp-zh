- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Applying a Microservice Architecture to Your Enterprise Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务架构应用于您的企业应用
- en: This chapter is dedicated to describing highly scalable architectures based
    on small modules called microservices. The microservice architecture allows for
    fine-grained scaling operations where every single module can be scaled as required
    without affecting the remainder of the system. Moreover, they allow for better
    **Continuous Integration/Continuous Deployment** (**CI/CD**) by permitting every
    system subpart to evolve and be deployed independently of the others.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于描述基于称为微服务的小模块的高度可扩展架构。微服务架构允许进行细粒度的扩展操作，其中每个单独的模块都可以按需扩展，而不会影响系统的其余部分。此外，它们通过允许每个系统子部分独立于其他部分进行演变和部署，从而提供了更好的**持续集成/持续部署**（**CI/CD**）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are microservices?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: When do microservices help?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么情况下微服务有帮助？
- en: How does .NET deal with microservices?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET如何处理微服务？
- en: Which tools are needed to manage microservices?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理微服务需要哪些工具？
- en: By the end of this chapter, you will have learned how to implement a single
    microservice in .NET. *Chapter 20*, *Kubernetes*, also explains how to deploy,
    debug, and manage a whole microservices-based application. *Chapter 14*, *Implementing
    Microservices with .NET*, and *Chapter 18*, *Implementing Frontend Microservices
    with ASP.NET Core,* are step-by-step guides to the practical implementation of
    microservices with .NET.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何在.NET中实现单个微服务。“第20章，Kubernetes”也解释了如何部署、调试和管理基于微服务的整个应用。“第14章，使用.NET实现微服务”和“第18章，使用ASP.NET
    Core实现前端微服务”是使用.NET实现微服务的实际应用的逐步指南。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)找到。
- en: 'In this chapter, you will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要以下内容：
- en: Visual Studio 2022 free Community Edition or better with all the database tools
    installed.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了所有数据库工具的Visual Studio 2022免费社区版或更高版本。
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create
    one.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的Azure账户。在第一章“理解软件架构的重要性”中的“创建Azure账户”部分解释了如何创建一个。
- en: '**Docker Desktop for Windows** if you want to debug Docker containerized microservices
    in Visual Studio ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想在Visual Studio中调试Docker容器化的微服务，请使用**Windows Docker桌面版**（[https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)）。
- en: In turn, **Docker Desktop for Windows** requires at least Windows 10 with either
    **Windows Subsystem for Linux** (**WSL**) or **Windows Containers** installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**Windows Docker桌面版**至少需要安装了**Windows子系统（WSL**）或**Windows容器**的Windows 10。
- en: '**WSL** enables Docker containers to run on a Linux virtual machine and can
    be installed as follows (see also [https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install)):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**WSL**允许Docker容器在Linux虚拟机上运行，可以按照以下方式安装（也请参阅[https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install)）：'
- en: Type `powershell` in the Windows 10/11 search bar.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows 10/11的搜索栏中输入`powershell`。
- en: When **Windows PowerShell** is proposed as a search result, click on **Run as
    an administrator**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**Windows PowerShell**作为搜索结果出现时，点击**以管理员身份运行**。
- en: In the Windows PowerShell administrative console that appears, run the command
    `wsl --install`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的Windows PowerShell管理控制台中，运行命令`wsl --install`。
- en: '**Windows Containers** enable Docker containers to run directly on Windows,
    but they require at least the Windows Professional edition. They can be installed
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows容器**允许Docker容器直接在Windows上运行，但至少需要Windows专业版。它们可以按照以下方式安装：'
- en: Type `Windows features` in the Windows 10/11 search bar.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows 10/11的搜索栏中输入`Windows功能`。
- en: The search results will propose running the panel to enable/disable Windows
    features.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索结果将建议运行面板以启用/禁用Windows功能。
- en: Click on it, and in the window that opens, select **Containers**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击它，在打开的窗口中，选择**容器**。
- en: What are microservices?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: Microservices are essentially small, independent units that make up a larger
    software application, each with its specific role and functionality. Splitting
    a software application into independent microservices allows each module that
    makes up a solution to be scaled independently from the others to achieve the
    maximum throughput with minimal cost. In fact, scaling whole systems instead of
    their current bottlenecks inevitably results in a remarkable waste of resources,
    so fine-grained control of subsystem scaling has a considerable impact on the
    system’s overall cost.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务本质上是由小而独立的单元组成的大型软件应用程序，每个单元都有其特定的角色和功能。将软件应用程序拆分为独立的微服务允许构成解决方案的每个模块独立于其他模块进行扩展，以实现最大吞吐量并最小化成本。实际上，对整个系统而不是其当前瓶颈进行扩展不可避免地会导致资源的显著浪费，因此对子系统扩展的精细控制对系统的整体成本有相当大的影响。
- en: However, microservices are more than scalable components – they are software
    building blocks that can be developed, maintained, and deployed independently
    of each other. Splitting development and maintenance among modules that can be
    independently developed, maintained, and deployed improves the overall system’s
    CI/CD cycle (CI/CD was described in detail in *Chapter 8*, *Understanding DevOps
    Principles and CI/CD*).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，微服务不仅仅是可扩展的组件——它们是可以独立开发、维护和部署的软件构建块。将开发和维护分配给可以独立开发、维护和部署的模块可以提高整体系统的CI/CD周期（CI/CD在*第8章*，*理解DevOps原则和CI/CD*中进行了详细描述）。
- en: 'The CI/CD improvement is due to microservice *independence* because it enables
    the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD的改进归因于微服务的**独立性**，因为它能够实现以下功能：
- en: Scaling and distributing microservices on different types of hardware.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同类型的硬件上扩展和分发微服务。
- en: Since each microservice is deployed independently from the others, there can’t
    be binary compatibility or database structure compatibility constraints. Therefore,
    there is no need to align the versions of the different microservices that compose
    the system. This means that each of them can evolve as needed without being constrained
    by the others.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个微服务都是独立于其他微服务部署的，因此不存在二进制兼容性或数据库结构兼容性约束。因此，没有必要对组成系统的不同微服务的版本进行对齐。这意味着它们中的每一个都可以根据需要发展，而不会受到其他微服务的限制。
- en: However, attention must be paid to the choice of communication protocols and
    messages and to their versions, which must be supported by all involved microservices.
    Protocols that are widely supported and that facilitate backward compatibility
    with previous versions of messages should be preferred.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，必须注意通信协议和消息的选择及其版本，这些版本必须由所有参与的微服务支持。应优先考虑广泛支持且便于与旧版本消息向后兼容的协议。
- en: Assigning their development to completely separate smaller teams, thus simplifying
    job organization and reducing all the inevitable coordination inefficiencies that
    arise when handling large teams.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其开发分配给完全独立的较小团队，从而简化工作组织并减少处理大型团队时出现的所有不可避免的协调低效率。
- en: Implementing each microservice with more adequate technologies and in a more
    adequate environment since each microservice is an independent deployment unit.
    This means choosing tools that best fit your requirements and an environment that
    minimizes development efforts and/or maximizes performance.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更合适的技术和更合适的环境来实现每个微服务，因为每个微服务都是一个独立的部署单元。这意味着选择最适合您需求的工具和最小化开发努力/或最大化性能的环境。
- en: Since each microservice can be implemented with different technologies, programming
    languages, tools, and operating systems, enterprises can use all available human
    resources by matching environments with developers’ competencies. For instance,
    all available Java and .NET developers can cooperate in the same application,
    thus exploiting all available resources.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个微服务都可以使用不同的技术、编程语言、工具和操作系统来实现，企业可以通过将环境与开发者的能力相匹配来利用所有可用的人力资源。例如，所有可用的Java和.NET开发者可以合作在同一应用程序中，从而利用所有可用资源。
- en: Legacy subsystems can be embedded in independent microservices, thus enabling
    them to cooperate with newer subsystems. This way, companies may reduce the time
    to market new system versions. Moreover, in this way, legacy systems can evolve
    slowly toward more modern systems with an acceptable impact on costs and the organization.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将遗留子系统嵌入到独立的微服务中，从而使其能够与较新的子系统合作。这样，公司可以缩短推出新系统版本的时间。此外，通过这种方式，遗留系统可以缓慢地向更现代的系统发展，对成本和组织的影响是可以接受的。
- en: The next subsection explains how the concept of microservices was conceived.
    Then, we will continue this introductory section by exploring basic microservice
    design principles and analyzing why microservices are often designed as Docker
    containers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将解释微服务概念是如何产生的。然后，我们将通过探讨基本微服务设计原则和分析为什么微服务通常被设计为Docker容器来继续本介绍性章节。
- en: Microservices and the evolution of the concept of modules
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务和模块概念的演变
- en: 'For a better understanding of the advantages of microservices, as well as their
    design techniques, we must keep the two-fold nature of software modularity and
    software modules in mind:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解微服务的优势以及它们的设计技术，我们必须牢记软件模块化和软件模块的双重性质：
- en: '**Code modularity** refers to code organization that makes it easy for us to
    modify a chunk of code without affecting the remainder of the application. It
    is usually enforced with object-oriented design, where modules can be identified
    with classes.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码模块化**指的是一种代码组织方式，使我们能够轻松修改代码块而不会影响应用程序的其余部分。它通常通过面向对象设计来实现，其中模块可以通过类来识别。'
- en: '**Deployment modularity** depends on what your deployment units are and which
    properties they have. The simplest deployment units are executable files and libraries.
    Thus, for instance, **dynamic link libraries** (**DLLs**) are, for sure, more
    modular than static libraries since they must not be linked with the main executable
    before being deployed.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署模块化**取决于你的部署单元是什么以及它们具有哪些属性。最简单的部署单元是可执行文件和库。因此，例如，**动态链接库**（**DLLs**）肯定比静态库更模块化，因为它们在部署之前不需要与主可执行文件链接。'
- en: While the fundamental concepts of code modularity have reached stasis, the concept
    of deployment modularity is still evolving, and microservices are currently state-of-the-art
    along this evolution path.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码模块化的基本概念已经达到稳定状态，但部署模块化的概念仍在不断发展，微服务目前在这一发展路径上处于最前沿。
- en: As a short review of the main milestones on the path that led to microservices,
    we can say that, first, monolithic executables were broken into static libraries.
    Later on, DLLs replaced static libraries.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对通向微服务之路上的主要里程碑的简要回顾，我们可以这样说，首先，单体可执行文件被分解为静态库。后来，DLLs取代了静态库。
- en: A great change took place when .NET (and other analogous frameworks, such as
    Java) improved the modularity of executables and libraries. In fact, with .NET,
    they can be deployed on different hardware and different operating systems since
    they are deployed in an intermediary language that is compiled when the library
    is executed for the first time. Moreover, they overcome some versioning issues
    of previous DLLs since any executable can bring with it a DLL with a version that
    differs from the version of the same DLL that is installed on the operating system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当.NET（以及其他类似框架，如Java）改进了可执行文件和库的模块化时，发生了巨大的变化。实际上，由于.NET是在库第一次执行时编译的中间语言中部署的，因此它们可以在不同的硬件和不同的操作系统上部署。此外，它们克服了先前DLLs的一些版本问题，因为任何可执行文件都可以携带一个与操作系统上安装的相同DLL版本不同的DLL。
- en: 'However, .NET can’t accept two referenced DLLs – let’s say, *A* and *B* – using
    two different versions of a common dependency – let’s say, *C*. For instance,
    suppose there is a newer version of *A* with many new features we would like to
    use that, in turn, relies on a newer version of *C* that is not supported by *B*.
    In this situation, we should renounce the newer version of *A* because of the
    incompatibility of *C* with *B*. This difficulty has led to two important changes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，.NET不能接受使用不同版本的共同依赖项（例如，*C*）的两个引用DLLs – 假设，*A*和*B*。例如，假设有一个带有许多新功能的新版本*A*，我们希望使用它，它反过来又依赖于一个不支持*B*的新版本*C*。在这种情况下，我们应该放弃*A*的新版本，因为*C*与*B*的不兼容性。这种困难导致了两个重要的变化：
- en: 'Packages: The development world moved from using single DLLs and/or single
    files as deployment units to using packages composed of both DLLs and metadata
    as deployment units. Packages are handled by *package management systems* such
    as NuGet and npm, which use package metadata to automatically check version compatibility
    with the help of semantic versioning.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包：开发世界从使用单个DLLs和/或单个文件作为部署单元转变为使用由DLLs和元数据组成的包作为部署单元。包由*包管理系统*（如NuGet和npm）处理，这些系统使用包元数据通过语义版本化自动检查版本兼容性。
- en: '**Service-Oriented Architecture** (**SOA**): Deployment units started being
    implemented as SOAP-based web services and later transition to REST web services.
    This solves the version compatibility problem since each web service runs in a
    different process and can use the most adequate version of each library with no
    risk of causing incompatibilities with other web services. Moreover, the interface
    that is exposed by each web service is platform-agnostic; that is, web services
    can connect with applications using any framework and run on any operating system
    since web service protocols are based on universally accepted standards. SOAs
    and protocols will be discussed in more detail in *Chapter 15*, *Applying Service-Oriented
    Architectures with .NET.*'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向服务架构**（**SOA**）：部署单元最初以基于SOAP的Web服务实现，后来过渡到RESTful Web服务。这解决了版本兼容性问题，因为每个Web服务都在不同的进程中运行，并且可以使用每个库的最合适版本，而不会与其他Web服务造成不兼容的风险。此外，每个Web服务暴露的接口是平台无关的；也就是说，Web服务可以使用任何框架与应用程序连接，并在任何操作系统上运行，因为Web服务协议基于普遍接受的标准。SOA和协议将在第15章《使用.NET应用面向服务架构》中更详细地讨论。'
- en: Microservices are an evolution of SOA and add more features and more constraints
    that improve the scalability and the modularity of services to improve the overall
    CI/CD cycle. It’s sometimes said that microservices are SOA done well. Moreover,
    as we will see in the next section, microservices are strictly tied with the DDD
    methodology described in *Chapter 7*, *Understanding the Different Domains in
    Software Solutions*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是SOA（面向服务架构）的演进，它增加了更多特性和约束，从而提高了服务的可扩展性和模块化，进而优化了整体的CI/CD（持续集成/持续部署）周期。有时人们会说，微服务是做得好的SOA。此外，正如我们将在下一节中看到的，微服务与第7章中描述的DDD（领域驱动设计）方法紧密相连，即《理解软件解决方案中的不同领域》。
- en: To sum things up, the microservice architecture is an SOA that maximizes independence
    and fine-grained scaling. Now that we’ve clarified all the advantages of microservice
    independence and fine-grained scaling, as well as the very nature of independence,
    we are in a position to look at microservice design principles.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，微服务架构是一种最大化独立性和细粒度扩展的SOA。现在我们已经阐明了微服务独立性和细粒度扩展的所有优势，以及独立的本质，我们现在可以查看微服务设计原则。
- en: Microservice design principles
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务设计原则
- en: In this section, you will learn about the microservices’ basic design principles.
    These principles are the basis for designing each microservice’s code and architecture,
    and for designing the whole application architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解微服务的基本设计原则。这些原则是设计每个微服务的代码和架构，以及设计整个应用程序架构的基础。
- en: Let’s start with principles that arise from the independence constraint. We
    will discuss them each in a separate subsection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从由独立性约束产生的原则开始。我们将分别在每个子节中讨论它们。
- en: The independence of design choices
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计选择的独立性
- en: 'A fundamental design principle is the *independence of design choices*, which
    can be stated as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的设计原则是“设计选择的独立性”，可以表述如下：
- en: The design of each microservice must not depend on the design choices that were
    made in the implementation of other microservices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务的设计不应依赖于其他微服务实现中做出的设计选择。
- en: This principle enables the full independence of each microservice CI/CD cycle
    and leaves us with more technological choices on how to implement each microservice.
    This way, we can choose the best available technology to implement each microservice.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则使得每个微服务的CI/CD周期完全独立，并为我们提供了更多关于如何实现每个微服务的科技选择。这样，我们可以选择最佳的技术来实现每个微服务。
- en: Another consequence of this principle is that different microservices can’t
    connect to the same shared storage (database or filesystem) since sharing the
    same storage also means sharing all the design choices that determine the structure
    of the storage subsystem (database table design, database engine, and so on).
    Thus, either a microservice has its own data storage, or it has no storage at
    all and communicates with other microservices that take care of handling storage.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则的另一个后果是，不同的微服务不能连接到相同的共享存储（数据库或文件系统），因为共享相同的存储也意味着共享所有决定存储子系统（数据库表设计、数据库引擎等）结构的设计选择。因此，要么微服务有自己的数据存储，要么它根本不存储任何数据，并与负责处理存储的其他微服务进行通信。
- en: Dedicated data storage can be implemented either by physically including the
    database service within the boundary of the microservice or with an external database
    that the microservice has exclusive access to. Both are acceptable design choices.
    However, external databases are usually adopted because, for performance reasons,
    database engines are better run on dedicated hardware and with OS and hardware
    features that are optimized for their storage functionalities.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 专用数据存储可以通过在微服务边界内物理包含数据库服务或使用微服务具有独家访问权限的外部数据库来实现。这两种设计选择都是可接受的。然而，通常采用外部数据库，因为出于性能原因，数据库引擎在专用硬件上以及具有针对其存储功能优化的操作系统和硬件特性上运行得更好。
- en: Usually, the *independence of design choices* is interpreted in a lighter form
    by distinguishing between logical and physical microservices. More specifically,
    logical microservices are the result of splitting the application into logical
    independent modules. If the application is designed with a **domain-driven design**
    (**DDD**) methodology, logical microservices correspond to DDD-bounded contexts,
    which we discussed in detail in *Chapter 7*, *Understanding the Different Domains
    in Software Solutions*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*设计选择的独立性*通过区分逻辑和物理微服务以较轻的形式被解释。更具体地说，逻辑微服务是将应用程序拆分为逻辑独立模块的结果。如果应用程序使用**领域驱动设计**（**DDD**）方法设计，则逻辑微服务对应于DDD边界上下文，我们在第7章“理解软件解决方案中的不同领域”中详细讨论了这一点。
- en: In turn, each logical microservice may be split into various physical microservices
    that use the same data storage but that are load-balanced independently to achieve
    a better load balance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，每个逻辑微服务可能被拆分为各种物理微服务，这些微服务使用相同的数据存储，但独立负载均衡以实现更好的负载均衡。
- en: 'For instance, in the book case study, travel payments are handled by the Payments
    Bounded Context described in the Understanding the domains of the WWTravelClub
    application section of *Chapter 21*, *Case Study*, which gives rise to a unique
    logical microservice. However, its practical implementation requires two main
    submodules:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在案例研究中，旅行支付由第21章“案例研究”中“理解WWTravelClub应用程序的领域”部分中描述的支付边界上下文处理，这产生了一个独特的逻辑微服务。然而，其实际实现需要两个主要子模块：
- en: A customer credit card verification and authorization module, which takes care
    of all credit card verifications
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个客户信用卡验证和授权模块，负责处理所有信用卡验证
- en: A user credits management module, which handles credits that the user already
    purchased, card information already loaded in the platform, and new credit card
    info loading
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户信用管理模块，处理用户已经购买的信用、平台中已经加载的卡信息以及新的信用卡信息加载
- en: Since the process of credit card verification and authorization might be very
    time-consuming, it is convenient to implement the two submodules above as independent
    physical microservices, so they can be load-balanced separately.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于信用卡验证和授权的过程可能非常耗时，因此将上述两个子模块作为独立的物理微服务实现是方便的，这样它们就可以分别进行负载均衡。
- en: Independence from the deployment environment
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立于部署环境
- en: During load-balancing, microservices can be moved from very busy hardware nodes
    to more idle nodes. However, dependencies of each microservice on other software/files
    of the destination hardware nodes constrain the possible destination nodes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在负载均衡过程中，微服务可以从非常繁忙的硬件节点移动到更空闲的节点。然而，每个微服务对目标硬件节点上其他软件/文件的依赖性限制了可能的节点。
- en: Therefore, the more we reduce microservice dependencies, the more we have the
    freedom to move them from busy nodes to idle nodes, achieve a better load balance,
    and exploit the available hardware nodes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们减少微服务依赖项越多，我们就越有自由将它们从繁忙的节点移动到空闲的节点，实现更好的负载均衡，并利用可用的硬件节点。
- en: This is the reason microservices are often containerized and use Docker. Containers
    will be discussed in more detail in the *Containers and Docker* subsection of
    this chapter, but basically, containerization is a technique that allows each
    microservice to bring its dependencies with it so that it can run anywhere. However,
    this is not a must because, in some applications, one might verify that all dependencies
    requirements of all microservices can be easily satisfied by all available nodes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微服务通常被容器化并使用Docker的原因。容器将在本章的“容器和Docker”小节中更详细地讨论，但基本上，容器化是一种技术，允许每个微服务携带其依赖项，以便它可以在任何地方运行。然而，这并不是必须的，因为在某些应用程序中，可能验证所有微服务的所有依赖项要求都可以很容易地由所有可用的节点满足。
- en: As we explore how microservices operate within their containerized environments,
    another key architectural principle comes into play – the concept of loose coupling.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索微服务在其容器化环境中的操作时，另一个关键架构原则开始发挥作用——松耦合的概念。
- en: Loose coupling
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 松耦合
- en: Each microservice must be loosely coupled with all the other microservices.
    This principle has a two-fold nature. On the one hand, this means that, according
    to object-oriented programming principles, the interface that’s exposed by each
    microservice must not be too specific but as general as possible. However, it
    also means that communications among microservices must be minimized in order
    to reduce communication costs since microservices don’t share the same address
    space and run on different hardware nodes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都必须与其他所有微服务松散耦合。这个原则有两个方面。一方面，这意味着根据面向对象编程原则，每个微服务暴露的接口不应过于具体，而应尽可能通用。然而，这也意味着微服务之间的通信必须最小化，以降低通信成本，因为微服务不共享相同的地址空间，并且运行在不同的硬件节点上。
- en: For instance, suppose we are implementing a distributed web video game with
    a microservice architecture. Each microservice might take care of different functionalities,
    like collisions, visibility, user input handling, and so on. Some modules, like
    the collision and visibility modules, must know the whole game state, such as
    places where the user avatars are, the state of each avatar, and also the state
    of each reactive object that is in the game (such as obstacles, bullets shot by
    avatars, and so on). Therefore, either all the modules with a hard dependency
    on the whole game state are collapsed into a unique microservice or we must find
    an efficient way to share the overall game state between them with just a few
    message exchanges.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在使用微服务架构实现一个分布式网络视频游戏。每个微服务可能负责不同的功能，如碰撞、可见性、用户输入处理等。一些模块，如碰撞和可见性模块，必须知道整个游戏状态，例如用户头像的位置、每个头像的状态，以及游戏中每个反应对象的状态（例如障碍物、由头像射出的子弹等）。因此，要么所有对整个游戏状态有硬依赖的模块都合并成一个唯一的微服务，要么我们必须找到一种高效的方法，通过仅几次消息交换在它们之间共享整个游戏状态。
- en: Both options have advantages and disadvantages and are actually adopted by real-world
    video games. Fewer messages might cause temporary incongruences, but melting too
    many modules into a unique microservice might impact the overall game performance
    so that the game might appear too “slow” to the users.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选择都有优点和缺点，并且实际上被现实世界的视频游戏所采用。较少的消息可能会引起暂时的不一致，但将太多模块合并成一个唯一的微服务可能会影响整体游戏性能，使得游戏对用户来说可能显得“太慢”。
- en: 'This concept of minimal inter-service communication naturally leads us to another
    consideration: the avoidance of chained requests/responses in a microservice architecture'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最小化服务间通信的概念自然引导我们考虑另一个方面：在微服务架构中避免链式请求/响应。
- en: No chained requests/responses
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无链式请求/响应
- en: When a request reaches a microservice, it must not cause a recursive chain of
    nested requests/responses to other microservices since a similar chain would result
    in an unacceptable response time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个请求到达微服务时，它不能导致对其他微服务的嵌套请求/响应链，因为类似的链会导致无法接受的反应时间。
- en: For instance, suppose that microservice A issues a request to microservice B
    and then waits for B to answer, and B does the same with C, and C does the same
    with D, and so on. As a result, A remains blocked waiting for its answer for the
    whole time the request propagates first to B, then to C, and then to D, and then
    the answer propagates back from D to C, then from C to B, and finally reaches
    A. That is, four request propagation times sum to the other four answer propagation
    times to get the overall A wait time. This way, the time a user waits to get an
    answer from the application might easily become unacceptable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设微服务A向微服务B发起请求并等待B的回答，然后B再对C做同样的事情，C再对D做同样的事情，以此类推。结果，A在整个请求首先传播到B，然后到C，再到D的过程中都处于阻塞状态，等待其回答。然后，回答从D传播回C，再从C传播回B，最后到达A。也就是说，四个请求传播时间总和等于其他四个回答传播时间，得到A的整体等待时间。这样，用户等待从应用程序获得回答的时间可能会很容易变得无法接受。
- en: Chained requests/responses can be avoided if the private data models of all
    the microservices synchronize with push events each time they change. In other
    words, as soon as the data that is handled by a microservice changes, those changes
    are sent to all the microservices that may need them to serve their requests.
    This way, each microservice has all the data it needs to serve all its incoming
    requests in its private data storage, with no need to ask other microservices
    for the data that it lacks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有微服务的私有数据模型在每次变化时都与推送事件同步，则可以避免链式请求/响应。换句话说，一旦微服务处理的数据发生变化，这些变化就会发送到所有可能需要它们的微服务，以便它们可以服务其请求。这样，每个微服务都可以在其私有数据存储中拥有它服务所有传入请求所需的所有数据，无需请求其他微服务提供它所缺少的数据。
- en: '*Figure 11.1* shows how updates are sent to all interested microservices as
    soon as they are produced and how each microservice combines all received updates
    in a local database. This way, each query microservice has all the data it needs
    to answer queries in its local database.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.1*显示了更新是如何在一旦产生就发送到所有感兴趣的微服务的，以及每个微服务是如何在本地数据库中组合所有接收到的更新的。这样，每个查询微服务都有它需要在其本地数据库中回答查询的所有数据。'
- en: '![Diagram  Description automatically generated](img/B19820_11_01.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19820_11_01.png)'
- en: 'Figure 11.1: Push events'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：推送事件
- en: In conclusion, every microservice must contain all the data it needs to serve
    incoming requests and ensure fast responses. To keep their data models up to date
    and ready for incoming requests, microservices must communicate their data changes
    as soon as they take place. These data changes should be communicated through
    asynchronous messages since synchronous nested messages cause unacceptable performance
    because they block all the threads involved in the call tree until a result is
    returned.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，每个微服务必须包含它服务传入请求所需的所有数据，并确保快速响应。为了保持其数据模型最新并准备好处理传入请求，微服务必须在数据变化发生时立即通知其数据变化。这些数据变化应通过异步消息进行通信，因为同步嵌套消息会导致不可接受的性能，因为它们会阻塞调用树中所有涉及的线程，直到返回结果。
- en: It is worth pointing out that the *independence of design choices* principle
    is substantially the bounded context principle of DDD, which we discussed in detail
    in *Chapter 7*, *Understanding the Different Domains in Software Solutions*. In
    this chapter, we have seen that, often, a full DDD approach is useful for the
    *update* subsystem of each microservice.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，*设计选择独立性*原则实质上是DDD的边界上下文原则，我们在第7章“理解软件解决方案中的不同领域”中详细讨论了这一点。在本章中，我们看到了，通常，完整的DDD方法对每个微服务的*更新*子系统是有用的。
- en: It’s not trivial that, in general, all systems that have been developed according
    to the bounded context principle are better implemented with a microservice architecture.
    In fact, once a system has been decomposed into several completely independent
    and loosely coupled parts, it is very likely that these different parts will need
    to be scaled independently because of different traffic and different resource
    requirements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，所有根据边界上下文原则开发的系统都更适合使用微服务架构来实现，这并非易事。事实上，一旦一个系统被分解为几个完全独立且松散耦合的部分，由于不同的流量和不同的资源需求，这些不同的部分很可能需要独立扩展。
- en: At the preceding constraints, we must also add some best practices for building
    a reusable SOA. More details on these best practices will be given in *Chapter
    15*, *Applying Service-Oriented Architectures with .NET*, but nowadays, most SOA
    best practices are automatically enforced by tools and frameworks that are used
    to implement web services.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述约束条件下，我们还必须添加一些构建可重用SOA的最佳实践。关于这些最佳实践的更多细节将在第15章“使用.NET应用服务导向架构”中给出，但如今，大多数SOA最佳实践都由用于实现Web服务的工具和框架自动执行。
- en: 'Fine-grained scaling is a key aspect of microservices architecture, involving
    several critical software and infrastructure requirements:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 精细粒度扩展是微服务架构的关键方面，涉及多个关键的软件和基础设施要求：
- en: First of all, microservices must be small enough to isolate well-defined functionalities.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，微服务必须足够小，以便隔离定义良好的功能。
- en: We also need a complex infrastructure that takes care of automatically instantiating
    microservices and allocating instances on various hardware computational resources,
    commonly called **nodes**.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要一个复杂的基础设施，负责自动实例化微服务和在不同硬件计算资源上分配实例，通常称为**节点**。
- en: The same infrastructure must take care of scaling microservices and load-balancing
    them on the available nodes.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的基础设施必须负责扩展微服务并在可用节点上对它们进行负载均衡。
- en: These kinds of structures will be introduced in the *Which tools are needed
    to manage microservices?* section of this chapter, and discussed in detail in
    *Chapter 20*, *Kubernetes*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构将在本章的*需要哪些工具来管理微服务？*部分中介绍，并在第20章*Kubernetes*中详细讨论。
- en: Moreover, fine-grained scaling of distributed microservices that communicate
    through asynchronous communication requires each microservice to be resilient.
    In fact, communication that’s directed to a specific microservice instance may
    fail due to a hardware fault or for the simple reason that the target instance
    was killed or moved to another node during a load-balancing operation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于通过异步通信进行通信的分布式微服务的细粒度扩展，需要每个微服务都具有弹性。实际上，指向特定微服务实例的通信可能会因为硬件故障或简单的原因（例如，在负载均衡操作期间目标实例被杀死或移动到另一个节点）而失败。
- en: Temporary failures can be overcome with exponential retries. This is where we
    retry the same operation after each failure with a delay that increases exponentially
    until a maximum number of attempts is reached. For instance, first, we would retry
    after 10 milliseconds, and if this retry operation results in a failure, a new
    attempt is made after 20 milliseconds, then after 40 milliseconds, and so on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指数重试克服临时故障。这就是在每个失败之后，我们都会以指数级增加的延迟重试相同的操作，直到达到最大尝试次数。例如，首先，我们会在10毫秒后重试，如果这次重试操作导致失败，那么会在20毫秒后进行新的尝试，然后是40毫秒，以此类推。
- en: 'On the other hand, long-term failures often cause an explosion of retry operations
    that may saturate all system resources in a way that is similar to a denial-of-service
    attack. Therefore, usually, exponential retries are used together with a *circuit
    break strategy*: after a given number of failures, a long-term failure is assumed,
    and access to the resource is prevented for a given time by returning an immediate
    failure without attempting the communication operation.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，长期失败往往会导致重试操作的爆炸性增长，这可能会以类似于拒绝服务攻击的方式耗尽所有系统资源。因此，通常，指数重试会与*熔断策略*一起使用：在给定数量的失败之后，假设发生了长期失败，并通过立即返回失败而不尝试通信操作来防止在给定时间内访问资源。
- en: 'It is also fundamental that the congestion of some subsystems, due to either
    failure or a request peak, does not propagate to other system parts in order to
    prevent overall system congestion. *Bulkhead isolation* prevents congestion propagation
    in the following ways:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，由于故障或请求峰值导致的某些子系统的拥塞不应传播到其他系统部分，以防止整体系统拥塞。*隔离舱隔离*通过以下方式防止拥塞传播：
- en: Only a maximum number of similar simultaneous outbound requests are allowed;
    let’s say, 10\. This is similar to putting an upper bound on thread creation.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许有最大数量的类似同时出站请求；比如说，10个。这类似于对线程创建设置上限。
- en: Requests exceeding the previous bound are queued.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超过先前界限的请求将被排队。
- en: If the maximum queue length is reached, any further requests result in exceptions
    being thrown to abort them.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果达到最大队列长度，任何进一步的请求都会引发异常以终止它们。
- en: The practical .NET implementation of exponential retries, circuit break, and
    bulkhead isolation is described in the *Resilient task execution subsection* of
    this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*弹性任务执行子节*中描述了指数重试、熔断和隔离舱隔离的.NET实际实现。
- en: Retry policies may make it so that the same message is received and processed
    several times because the sender has received no confirmation that the message
    has been received, or simply because it has timed out the operation while the
    receiver actually received the message. The only possible solution to this problem
    is designing all messages so that they’re idempotent – that is, designing messages
    in such a way that processing the same message several times has the same effect
    as processing it once.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重试策略可能会导致相同的消息被接收和处理多次，因为发送者没有收到消息已被接收的确认，或者简单地因为操作超时而接收者实际上已经接收了消息。解决这个问题的唯一可能方法是设计所有消息，使它们是幂等的——也就是说，以这种方式设计消息，即多次处理相同的消息与处理一次的效果相同。
- en: Updating a database table field to a value, for instance, is an idempotent operation
    since repeating it once or twice has exactly the same effect. However, incrementing
    a decimal field is not an idempotent operation. Microservice designers should
    make an effort to design the overall application with as many idempotent messages
    as possible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库表字段更新为某个值，例如，这是一个幂等操作，因为重复一次或两次会产生完全相同的效果。然而，增加一个十进制字段并不是幂等操作。微服务设计者应该努力设计尽可能多的幂等消息的整体应用程序。
- en: An idempotent message is also a message that, if processed twice, doesn’t cause
    malfunctions. For instance, a message that modifies the price of travel is idempotent
    because if we process it another time, we just set again the price to the same
    price as before. However, a message whose purpose is to add a new travel booking
    is not idempotent since if we process it twice, we add two travel bookings instead
    of one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等消息也是一种消息，如果处理两次，不会引起故障。例如，修改旅行价格的消息是幂等的，因为我们再次处理它时，只是将价格设置回之前的价格。然而，旨在添加新的旅行预订的消息不是幂等的，因为我们处理两次时，会添加两个旅行预订而不是一个。
- en: 'The remaining non-idempotent messages must be transformed into idempotent in
    the following way or with other similar techniques:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的非幂等消息必须以下述方式或使用其他类似技术转换为幂等：
- en: Attach both a time and some identifier that uniquely identifies each message.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个消息附加时间和一些唯一标识符，以唯一标识每个消息。
- en: Store all the messages that have been received in a dictionary that’s been indexed
    by the unique identifier attached to the message mentioned in the previous point.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有已接收的消息存储在一个字典中，该字典按前一点提到的消息的唯一标识符进行索引。
- en: Reject old messages.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拒绝旧消息。
- en: When a message that may be a duplicate is received, verify whether it’s contained
    in the dictionary. If it is, then it has already been processed, so reject it.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当收到可能重复的消息时，验证它是否包含在字典中。如果是，那么它已经被处理，因此拒绝它。
- en: Since old messages are rejected, they can be periodically removed from the dictionary
    to prevent it from growing exponentially.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于拒绝旧消息，它们可以定期从字典中删除，以防止其指数级增长。
- en: In *Chapter 14*, *Implementing Microservices with .NET*, we will use this technique
    in practice and discuss communication and coordination problems in more detail.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第14章*，*使用.NET实现微服务*中，我们将实际应用这项技术，并更详细地讨论通信和协调问题。
- en: It is worth pointing out that some message brokers, such as Azure Service Bus,
    offer facilities for implementing the technique described previously. However,
    the receiver must always be able to recognize duplicate messages since, due to
    time-outs in the reception of acknowledgments, messages might be resent. Azure
    Service Bus is discussed in the *.NET communication facilities* subsection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，一些消息代理，如Azure Service Bus，提供了实现之前描述的技术的基础设施。然而，接收者必须始终能够识别重复消息，因为由于确认接收的超时，消息可能会被重新发送。Azure
    Service Bus在*.NET通信设施*小节中讨论。
- en: In the next subsection, we will talk about microservice containerization based
    on Docker.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将讨论基于Docker的微服务容器化。
- en: Containers and Docker
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和Docker
- en: We’ve already discussed the advantages of having microservices that don’t depend
    on the environment where they run; microservices can be moved from busy nodes
    to idle nodes without constraints, thus achieving a better load balance and, consequently,
    better usage of the available hardware.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了拥有不依赖于其运行环境的微服务的优势；微服务可以在繁忙的节点和空闲节点之间移动，不受限制，从而实现更好的负载均衡，进而更好地利用可用硬件。
- en: However, if we need to mix legacy software with newer modules, the ability to
    mix several development stacks in order to use the best stack for each module
    implementation, and so on, we are faced with the problem that the various microservices
    have different hardware/software prerequisites. In these cases, the independence
    of each microservice from the hosting environment can be restored by deploying
    each microservice with all its dependencies on a private virtual machine.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们需要将遗留软件与较新的模块混合，为了使用每个模块实现的最佳堆栈，我们需要混合几个开发堆栈，等等，我们面临的问题是各种微服务有不同的硬件/软件先决条件。在这些情况下，可以通过在每个私有虚拟机上部署每个微服务及其所有依赖项来恢复每个微服务对其托管环境的独立性。
- en: However, starting a virtual machine with its private copy of the operating system
    takes a lot of time, and microservices must be started and stopped quickly to
    reduce load-balancing and fault recovery costs. In fact, new microservices may
    be started either to replace faulty ones or because they were moved from one hardware
    node to another to perform load-balancing. Moreover, adding a whole copy of the
    operating system to each microservice instance would be an excessive overhead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，启动带有其私有操作系统副本的虚拟机需要花费大量时间，而微服务必须快速启动和停止以减少负载均衡和故障恢复成本。实际上，新的微服务可能被启动是为了替换故障的微服务，或者因为它们从一个硬件节点移动到另一个节点以执行负载均衡。此外，将整个操作系统的副本添加到每个微服务实例中将会造成过度的开销。
- en: 'Luckily, microservices can rely on a lighter form of technology: containers.
    Containers provide a lightweight, efficient form of virtualization. Unlike traditional
    virtual machines that virtualize an entire machine, including the operating system,
    containers virtualize at the OS filesystem level, sitting on top of the host OS
    kernel. They use the operating system of the hosting machine (kernel, DLLs, and
    drivers) and use the OS’s native features to isolate processes and resources,
    creating an isolated environment for the images they run.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，微服务可以依赖一种更轻量级的技术：容器。容器提供了一种轻量级、高效的虚拟化形式。与传统虚拟机不同，虚拟机虚拟化整个机器，包括操作系统，而容器在操作系统文件系统级别进行虚拟化，位于宿主操作系统内核之上。它们使用宿主机的操作系统（内核、DLLs和驱动程序）并使用操作系统的原生功能来隔离进程和资源，为它们运行的镜像创建一个隔离的环境。
- en: As a consequence, containers are tied to a specific OS, but they don’t suffer
    the overhead of copying and starting a whole OS in each container instance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器与特定的操作系统相关联，但它们不会遭受在每个容器实例中复制和启动整个操作系统的开销。
- en: On each host machine, containers are handled by a runtime that takes care of
    creating them from *images* and creating an isolated environment for each of them.
    The most popular container image format is Docker, which is a *de facto* standard
    for container images.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在每台主机上，容器由一个运行时处理，负责从*镜像*创建它们并为每个容器创建一个隔离的环境。最受欢迎的容器镜像格式是Docker，它是容器镜像的*事实标准*。
- en: Images contain files needed to create each container and specify which container
    resources, such as communication ports, to expose outside of the container. However,
    they need not explicitly contain all involved files since they can be layered.
    This way, each image is built by adding new files and configuration information
    on top of another existing image that is referenced from inside the newly defined
    image.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像包含创建每个容器所需的文件，并指定哪些容器资源，如通信端口，需要暴露在容器外部。然而，它们不需要显式包含所有相关文件，因为它们可以是分层的。这样，每个镜像都是通过在另一个现有镜像之上添加新文件和配置信息来构建的，该现有镜像是从新定义的镜像内部引用的。
- en: For instance, if you want to deploy a .NET application as a Docker image, it
    is enough to just add your software and files to your Docker image and then reference
    an already existing .NET Docker image.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想将.NET应用程序作为Docker镜像部署，只需将你的软件和文件添加到你的Docker镜像中，然后引用一个已经存在的.NET Docker镜像即可。
- en: 'To allow for easy image referencing, images are grouped into registries that
    may be either public or private. They are similar to NuGet or npm registries.
    Docker offers a public registry ([https://hub.docker.com/_/registry](https://hub.docker.com/_/registry))
    where you can find most of the public images you may need to reference in your
    own images. However, each company can define private registries. For instance,
    Microsoft offers Azure Container Registry, where you can define your private container
    registry service: [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/).
    There, you can also find most of the .NET-related images you might need to reference
    in your code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于引用镜像，镜像被分组到注册表中，这些注册表可以是公共的或私有的。它们类似于NuGet或npm注册表。Docker提供了一个公共注册表([https://hub.docker.com/_/registry](https://hub.docker.com/_/registry))，在那里你可以找到大多数你可能需要在自己的镜像中引用的公共镜像。然而，每个公司都可以定义私有注册表。例如，微软提供了Azure
    Container Registry，在那里你可以定义你的私有容器注册表服务：[https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)。在那里，你还可以找到大多数你可能需要在代码中引用的.NET相关镜像。
- en: Before instantiating each container, the Docker runtime must solve all the recursive
    references. This cumbersome job is not performed each time a new container is
    created since the Docker runtime has a cache where it stores the fully assembled
    images that correspond to each input image and that it has already processed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化每个容器之前，Docker运行时必须解决所有递归引用。由于Docker运行时有一个缓存，其中存储了与每个输入镜像相对应的完整组装的镜像，并且已经处理过，因此这项繁琐的工作不是每次创建新容器时都执行。
- en: 'Since each application is usually composed of several modules to be run in
    different containers, a tool called **Docker Compose** also allows `.yml` files,
    known as **composition files**, that specify the following information:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个应用程序通常由多个模块组成，这些模块需要在不同的容器中运行，因此一个名为**Docker Compose**的工具还允许使用称为**组合文件**的`.yml`文件，这些文件指定以下信息：
- en: Which images to deploy.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署哪些镜像。
- en: How the internal resources that are exposed by each image must be mapped to
    the physical resources of the host machine. For instance, how communication ports
    that are exposed by Docker images must be mapped to the ports of the physical
    machine.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个镜像暴露的内部资源必须映射到宿主机的物理资源。例如，Docker镜像暴露的通信端口必须映射到物理机的端口。
- en: We will analyze Docker images and `.yml` files in the *How does .NET deal with
    microservices?* section of this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的*“.NET如何处理微服务？”*部分中分析Docker镜像和`.yml`文件。
- en: The Docker runtime handles images and containers on a single machine, but usually,
    containerized microservices are deployed and load-balanced on clusters that are
    composed of several machines. Clusters are handled by pieces of software called
    **orchestrators**. Orchestrators will be introduced in the *Which tools are needed
    to manage microservices?* section of this chapter, and described in detail in
    *Chapter 20,* *Kubernetes*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Docker运行时在单台机器上处理镜像和容器，但通常，容器化的微服务是在由多台机器组成的集群上部署和负载均衡的。集群由称为**编排器**的软件组件来处理。编排器将在本章的*“需要哪些工具来管理微服务？”*部分中介绍，并在第20章*“Kubernetes”*中详细描述。
- en: Now that we understand what microservices are, what problems they can solve,
    and their basic design principles, we are ready to analyze when and how to use
    them in our system architecture. The next section analyzes when we should use
    them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了微服务是什么，它们可以解决哪些问题，以及它们的基本设计原则，我们准备分析在系统架构中何时以及如何使用它们。下一节将分析我们应该何时使用它们。
- en: When do microservices help?
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务何时有帮助？
- en: 'The answer to this question requires us to understand the roles microservices
    play in modern software architectures. We will look at this in the following two
    subsections:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案需要我们理解微服务在现代软件架构中扮演的角色。我们将在以下两个子节中探讨这一点：
- en: Layered architectures and microservices
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次架构和微服务
- en: When is it worth considering microservice architectures?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么情况下考虑微服务架构是有价值的？
- en: Let’s start with a detailed look at layered architectures and microservices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对层次架构和微服务的详细分析开始。
- en: Layered architectures and microservices
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次架构和微服务
- en: As discussed in *Chapter 7, Understanding the Different Domains in Software
    Solutions*, enterprise systems are usually organized in logical independent layers.
    The outermost layer is the one that interacts with the user and is called the
    presentation layer (in the onion architecture, the outermost layer also contains
    drivers and test suites), while the last layer (the innermost layer in the onion
    architecture) takes care of application permanent data handling and is called
    the data layer (the domain layer in the onion architecture). Requests originate
    in the presentation layer and pass through all the layers until they reach the
    data layer (and then come back, traversing all the layers in reverse until they
    reach the outermost layer again).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第7章*“理解软件解决方案中的不同领域”*中讨论的那样，企业系统通常组织在逻辑独立的层中。最外层是与用户交互的层，称为表示层（在洋葱架构中，最外层还包含驱动程序和测试套件），而最内层（洋葱架构中的最内层）负责处理应用程序的永久数据，称为数据层（洋葱架构中的领域层）。请求起源于表示层，穿过所有层直到达到数据层（然后返回，反向穿越所有层直到再次达到最外层）。
- en: In the case of classical layered architecture (the onion architecture is quite
    different, as discussed in *Chapter 7*, *Understanding the Different Domains in
    Software Solutions*), each layer takes data from the previous layer, processes
    it, and passes it to the next layer. Then, it receives the results from its next
    layer and sends them back to its previous layer. Also, thrown exceptions can’t
    jump layers – each layer must take care of intercepting all the exceptions and
    either *solve them* somehow or transform them into other exceptions that are expressed
    in the language of its previous layer. The layered architecture ensures the complete
    independence of the functionalities of each layer from the functionalities of
    all the other layers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典分层架构的情况下（洋葱架构与第7章*理解软件解决方案中的不同领域*中讨论的有所不同），每一层从前一层数据，处理它，并将其传递到下一层。然后，它从下一层接收结果并将其发送回前一层。此外，抛出的异常不能跨越层——每一层都必须负责拦截所有异常，或者以某种方式*解决*它们，或者将它们转换成以前一层的语言表达的其他异常。分层架构确保了每一层的功能完全独立于所有其他层的功能。
- en: For instance, we can change the **Object-Relational Mapping** (**ORM**) software
    that interfaces the database without affecting all the layers that are above the
    data layer (ORM software is discussed in *Chapter 13*, *Interacting with Data
    in C# – Entity Framework Core*). In the same way, we can completely change the
    user interface (that is, the presentation layer) without affecting the remainder
    of the system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以更改**对象关系映射**（**ORM**）软件，该软件作为数据库的接口，而不会影响数据层之上的所有层（ORM软件在*第13章*，*使用C#与数据交互
    – Entity Framework Core*中讨论）。同样，我们可以完全更改用户界面（即表示层），而不会影响系统的其余部分。
- en: Moreover, each layer implements a different kind of system specification. The
    data layer takes care of what the system *must remember*, the presentation layer
    takes care of the system-user interaction protocol, and all the layers that are
    in the middle implement the domain rules, which specify how data must be processed
    (for instance, how an employee paycheck must be computed). Typically, the data
    and presentation layers are separated by just one domain rule layer, called the
    business or application layer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每一层实现不同类型的系统规范。数据层负责系统*必须记住*的内容，表示层负责系统与用户交互的协议，而中间的所有层实现领域规则，这些规则指定了数据必须如何处理（例如，如何计算员工的工资）。通常，数据和表示层仅由一个领域规则层隔开，称为业务层或应用层。
- en: '![Diagram  Description automatically generated](img/B19820_11_02.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19820_11_02.png)'
- en: 'Figure 11.2: Layers of classic architectures'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：经典架构的层
- en: 'Each layer *speaks* a different language: the data layer speaks the language
    of relation among entities, the business layer speaks the language of domain experts,
    and the presentation layer speaks the language of users. So, when data and exceptions
    pass from one layer to another, they must be translated into the language of the
    destination layer.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层*说*着不同的语言：数据层说着实体之间关系的语言，业务层说着领域专家的语言，表示层说着用户的语言。因此，当数据和异常从一个层传递到另一个层时，它们必须被翻译成目标层的语言。
- en: That being said, how do microservices fit into a layered architecture? Are they
    adequate for the functionalities of all the layers or just some layers? Can a
    single microservice span several layers?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，微服务如何适应分层架构？它们是否适合所有层的功能，或者只是某些层的功能？单个微服务能否跨越多个层？
- en: 'The last question is the easiest to answer: yes! In fact, we’ve already stated
    that microservices should store the data they need within their logical boundaries.
    Therefore, there are microservices that span the business and data layers, for
    sure.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题最容易回答：是的！事实上，我们之前已经提到，微服务应该在其逻辑边界内存储它们所需的数据。因此，确实存在跨越业务和数据层的微服务。
- en: However, since we said that each logical microservice can be implemented with
    several physical microservices for pure load-balancing reasons, one microservice
    might take care of encapsulating data used by another microservice that might
    remain confined in the data layer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们提到每个逻辑微服务可以由几个物理微服务实现，纯粹是为了负载均衡的原因，一个微服务可能负责封装另一个微服务使用的、可能仍然局限于数据层的数据。
- en: 'Moreover, we said also that while each microservice must have its exclusive
    storage, it can use also external storage engines. This is shown in the diagram
    below:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提到，虽然每个微服务都必须有自己的专用存储，但它也可以使用外部存储引擎。下面的图示展示了这一点：
- en: '![](img/B19820_11_03.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_11_03.png)'
- en: 'Figure 11.3: External or internal storage'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：外部或内部存储
- en: It is worth pointing out that the storage engine itself can be implemented as
    a set of physical microservices that are associated with no logical microservice
    since they may be considered part of the infrastructure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，存储引擎本身可以作为一个物理微服务集实现，这些微服务与任何逻辑微服务无关，因为它们可能被认为是基础设施的一部分。
- en: This is the case, for instance, for storage engines based on the distributed
    Redis in-memory cache, where we use microservice facilities offered by the infrastructure
    to implement scalable one-master/many-read-only replicas, or sophisticated many-master/many-read-only
    replicas distributed in memory storage. Redis and Redis Cloud services are described
    in the *Redis* section *of* *Chapter 12*, *Choosing Your Data Storage in the Cloud*,
    while many-master/many-read-only replicas architectures are described in *Chapter
    20*, *Kubernetes*. The diagram below shows how microservice-based many-master/many-read-only
    replicas storage engines work.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况适用于基于分布式Redis内存缓存的存储引擎，其中我们利用基础设施提供的微服务设施来实现可扩展的单主/多只读副本，或者复杂的多主/多只读副本，这些副本在内存存储中分布。Redis和Redis
    Cloud服务在*第12章*的*选择云中的数据存储*部分中描述，而多主/多只读副本架构在*第20章*的*Kubernetes*中描述。下面的图示展示了基于微服务的多主/多只读副本存储引擎的工作原理。
- en: '![](img/B19820_11_04.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_11_04.png)'
- en: 'Figure 11.4: Many-master/many-read-only replicas storage engine'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：多主/多只读副本存储引擎
- en: Each master has its associated read-only replicas. Storage updates can be passed
    just to masters that replicate their data to all their associated read-only replicas.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主节点都与其关联的只读副本相关联。存储更新只需传递给那些将数据复制到所有关联的只读副本的主节点。
- en: Each master takes care of a portion of the storage space, for instance, all
    products whose name starts with “A,” and so on. In this way, the load is balanced
    between all masters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主节点负责存储空间的一部分，例如，所有以“A”开头的所有产品，等等。这样，负载在所有主节点之间得到平衡。
- en: Thus, we may have business layer microservices, data layer microservices, and
    microservices that span both layers. So, what about the presentation layer?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能有业务层微服务、数据层微服务和跨越这两层的微服务。那么，展示层呢？
- en: The presentation layer
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展示层
- en: This layer can also fit into a microservice architecture if it is implemented
    on the server side – that is, if the whole graphic that interacts with the user
    is built on the server side and not in the user client machine (mobile device,
    desktop, etc.).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它在服务器端实现，这一层也可以适应微服务架构——也就是说，如果与用户交互的整个图形都是在服务器端构建的，而不是在用户客户端机器（移动设备、桌面等）上。
- en: When there are microservices that interact directly with the user, we speak
    of server-side implementation of the presentation layer since the HTML and/or
    all elements of the user interface are created by the frontend, which sends the
    response to the user.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当有直接与用户交互的微服务时，我们称之为展示层的服务器端实现，因为HTML和/或用户界面的所有元素都是由前端创建的，前端将响应发送给用户。
- en: These kinds of microservices are called frontend microservices, while microservices
    that do back-office work without interacting with the user are called worker microservices.
    The diagram below summarizes the frontend/worker organization.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这类微服务被称为前端微服务，而那些不与用户交互执行后台工作的微服务被称为工作微服务。下面的图示总结了前端/工作组织结构。
- en: '![](img/B19820_11_05.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_11_05.png)'
- en: 'Figure 11.5: Frontend and worker microservices'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：前端和工作微服务
- en: When, instead, the HTML and/or all elements of the user interface are generated
    on the user machine, we speak of client-side implementation of the presentation
    layer. The so-called single-page applications and mobile applications run the
    presentation layer on the client machine and interact with the application through
    communication interfaces exposed by dedicated microservices. These dedicated microservices
    are completely analogous to the frontend microservices depicted in *Figure 11.5*
    and are called *API gateways,* to underline their role of exposing a public API
    for connecting client devices with the whole microservices infrastructure. Also,
    API gateways interact with worker microservices in a way that is completely analogous
    to frontend microservices.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTML 和/或用户界面的所有元素在用户机器上生成时，我们称之为表示层的客户端实现。所谓的单页应用程序和移动应用程序在客户端机器上运行表示层，并通过由专用微服务公开的通信接口与应用程序交互。这些专用微服务与
    *图 11.5* 中描述的前端微服务完全类似，被称为 *API 网关*，以强调它们公开公共 API 以连接客户端设备与整个微服务基础设施的作用。此外，API
    网关与工作微服务的交互方式与前端微服务完全类似。
- en: 'Single-page applications and mobile/desktop client applications are discussed
    in *Chapter 19*, *Client Frameworks: Blazor*.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序和移动/桌面客户端应用程序在 *第 19 章*，*客户端框架：Blazor* 中讨论。
- en: In a microservice architecture, when the presentation layer is a website, it
    can be implemented with a set of several microservices. However, if it requires
    heavy web servers and/or heavy frameworks, containerizing them may not be convenient.
    This decision must also consider the loss of performance that happens when containerizing
    the web server and the possible need for hardware firewalls between the web server
    and the remainder of the system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，当表示层是一个网站时，它可以由一组多个微服务实现。然而，如果它需要重型网络服务器和/或重型框架，容器化它们可能不方便。这个决定还必须考虑容器化网络服务器时可能发生的性能损失以及在网络服务器和系统其余部分之间可能需要硬件防火墙的可能性。
- en: ASP.NET Core is a lightweight framework that runs on the Kestrel web server,
    so it can be containerized efficiently and used as is in the worker microservices.
    The usage of ASP:NET Core in the implementation of worker microservices is described
    in great detail in *Chapter 14*, *Implementing Microservices with .NET*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 是一个轻量级框架，它在 Kestrel 网络服务器上运行，因此可以高效地容器化，并直接用于工作微服务。在 *第 14 章*，*使用
    .NET 实现微服务* 中详细描述了在实现工作微服务中使用 ASP.NET Core 的方法。
- en: Instead, frontend and/or high-traffic websites have more compelling security
    and load-balancing requirements that can be satisfied just with fully-featured
    web servers. Accordingly, architectures based on microservices usually offer specialized
    components that take care of interfacing with the outside world. For instance,
    in *Chapter 20*, *Kubernetes*, we will see that in microservices-dedicated infrastructures
    like **Kubernetes** clusters, this role is played by so-called **ingresses**.
    These are fully-featured web servers interfaced with the microservices infrastructure.
    Thanks to the integration with the microservices infrastructure, the whole web
    server traffic is automatically routed to the interested microservices. More details
    on this will be given in *Chapter 20*, *Kubernetes*. The diagram below shows the
    role of Ingresses.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，前端和/或高流量网站有更紧迫的安全性和负载均衡需求，这些需求可以通过功能齐全的网络服务器得到满足。因此，基于微服务的架构通常提供专门组件来处理与外部世界的接口。例如，在
    *第 20 章*，*Kubernetes* 中，我们将看到在像 **Kubernetes** 集群这样的微服务专用基础设施中，这个角色由所谓的 **入口**
    扮演。这些是与微服务基础设施接口的完整功能网络服务器。由于与微服务基础设施的集成，整个网络服务器流量自动路由到感兴趣的微服务。更多细节将在 *第 20 章*，*Kubernetes*
    中给出。下面的图表显示了入口的作用。
- en: '![](img/B19820_11_06.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_11_06.png)'
- en: 'Figure 11.6: Ingresses based on load-balanced web servers'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：基于负载均衡网络服务器的入口
- en: Monolithic websites can be easily broken into load-balanced smaller subsites
    without microservice-specific technologies, but a microservice architecture can
    bring all the advantages of microservices into the construction of a single HTML
    page. More specifically, different microservices may take care of different areas
    of each HTML page. Microservices that cooperate in the construction of the HTML
    of application pages, and, in general, in the construction of any kind of user
    interface, are named micro-frontends.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 单体网站可以很容易地分解成负载均衡的小型子站点，而不需要特定的微服务技术，但微服务架构可以将微服务的所有优势带入单个HTML页面的构建中。更具体地说，不同的微服务可能负责每个HTML页面的不同区域。在构建应用页面HTML以及通常在构建任何类型的用户界面时协作的微服务被称为微前端。
- en: When the HTML is created on the server side, the various micro-frontends create
    HTML chunks that are combined either on the server side or directly in the browser.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当HTML在服务器端创建时，各种微前端创建HTML代码块，这些代码块可以在服务器端或直接在浏览器中组合。
- en: When, instead, the HTML is created directly on the client, each micro-frontend
    provides a different chunk of code to the client. These code chunks are run on
    the client machine, and each of them takes care of different pages/page areas.
    We will speak more of this kind of micro-frontend in *Chapter 18*, *Implementing
    Frontend Microservices with ASP.NET Core*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果HTML直接在客户端创建，每个微前端都会向客户端提供不同的代码块。这些代码块在客户端机器上运行，每个都负责不同的页面/页面区域。我们将在*第18章*，*使用ASP.NET
    Core实现前端微服务*中更多地讨论这种类型的微前端。
- en: Now that we’ve clarified which parts of a system can benefit from the adoption
    of microservices, we are ready to state the rules when it comes to deciding how
    they’re adopted.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经明确了系统哪些部分可以从采用微服务中受益，我们准备好陈述在决定如何采用它们时的规则。
- en: When is it worth considering microservice architectures?
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在什么情况下值得考虑使用微服务架构？
- en: 'Microservices can improve the implementation of both the business and data
    layers, but their adoption has some costs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以提高业务和数据层的实现，但它们的采用有一些成本：
- en: Allocating instances to nodes and scaling them has a cost in terms of cloud
    fees or internal infrastructures and licenses.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实例分配到节点并对其进行扩展在云费用或内部基础设施和许可证方面会产生成本。
- en: Splitting a unique process into smaller communication processes increases communication
    costs and hardware needs, especially if the microservices are containerized.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个独特的流程拆分成更小的通信流程会增加通信成本和硬件需求，尤其是如果微服务是容器化的。
- en: Designing and testing software for a microservice requires more time and increases
    engineering costs, both in time and complexity. In particular, making microservices
    resilient and ensuring that they adequately handle all possible failures, as well
    as verifying these features with integration tests, can increase the development
    time by more than one order of magnitude (that is, about 10 times).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务设计和测试软件需要更多时间，并增加工程成本，包括时间和复杂性。特别是，使微服务具有弹性并确保它们能够适当地处理所有可能的故障，以及通过集成测试验证这些功能，可以将开发时间增加一个数量级以上（即大约10倍）。
- en: So, when are microservices worth the cost of using them? Are there functionalities
    that must be implemented as microservices?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，微服务何时值得使用它们的成本？是否有必须作为微服务实现的函数？
- en: A rough answer to the second question is yes when the application is big enough
    in terms of traffic and/or software complexity. In fact, as an application grows
    in complexity and its traffic increases, it’s recommended that we pay the costs
    associated with scaling it since this allows for more scaling optimization and
    better handling when it comes to the development team. The costs we pay for these
    would soon exceed the cost of microservice adoption.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题的粗略回答是：当应用在流量和/或软件复杂性方面足够大时。实际上，随着应用复杂性的增加和流量的增加，我们建议我们承担与扩展它相关的成本，因为这允许进行更多的扩展优化，并且在开发团队方面有更好的处理。我们为此付出的代价很快就会超过采用微服务的成本。
- en: Thus, if fine-grained scaling makes sense for our application, and if we can
    estimate the savings that fine-grained scaling and development give us, we can
    easily compute an overall application throughput limit that makes the adoption
    of microservices convenient.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果细粒度扩展对我们应用来说是有意义的，并且如果我们可以估计细粒度扩展和开发带来的节省，我们就可以轻松计算出整体应用吞吐量限制，这使得采用微服务变得方便。
- en: Microservice costs can also be justified by an increase in the market value
    of our products/services. Since the microservice architecture allows us to implement
    each microservice with a technology that has been optimized for its use, the quality
    that’s added to our software may justify all or part of the microservice costs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务成本也可以通过我们产品/服务的市场价值增加来证明。由于微服务架构允许我们使用针对其使用进行优化的技术来实现每个微服务，因此我们软件中增加的质量可能可以证明所有或部分微服务成本是合理的。
- en: However, scaling and technology optimizations are not the only parameters to
    consider. Sometimes, we are forced to adopt a microservice architecture without
    being able to perform a detailed cost analysis.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，扩展和技术优化并不是唯一需要考虑的参数。有时，我们被迫采用微服务架构，而无法进行详细的成本分析。
- en: If the size of the team that takes care of the CI/CD of the overall system grows
    too much, the organization and coordination of this big team cause difficulties
    and inefficiencies. In this type of situation, it is desirable to move to an architecture
    that breaks the whole CI/CD cycle into independent parts that can be taken care
    of by smaller teams.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果负责整个系统CI/CD的团队规模变得过大，这个大团队的组织和协调将导致困难和低效率。在这种情况下，转向一种将整个CI/CD周期分解为独立部分，这些部分可以由更小的团队来处理的架构是可取的。
- en: Moreover, since these development costs are only justified by a high volume
    of requests, we probably have high traffic being processed by independent modules
    that have been developed by different teams. Therefore, scaling optimizations
    and the need to reduce interaction between development teams make the adoption
    of a microservice architecture very convenient.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这些开发成本只有在高请求量的情况下才是合理的，我们可能正在处理由不同团队开发的独立模块的高流量。因此，进行扩展优化和减少开发团队之间的交互需求使得采用微服务架构变得非常方便。
- en: From this, we may conclude that if the system and the development team grow
    too much, it is necessary to split the development team into smaller teams, each
    working on an efficient bounded context subsystem. It is very likely that, in
    a similar situation, a microservice architecture is the only possible option.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，如果我们系统和开发团队规模变得过大，有必要将开发团队拆分成更小的团队，每个团队负责一个高效的边界上下文子系统。在类似的情况下，微服务架构可能是唯一可行的选择。
- en: Another situation that forces the adoption of a microservice architecture is
    the integration of newer subparts with legacy subsystems based on different technologies,
    as containerized microservices are the only way to implement an efficient interaction
    between the legacy system and the new subparts in order to gradually replace the
    legacy subparts with newer ones. Similarly, if our team is composed of developers
    with experience in different development stacks, an architecture based on containerized
    microservices may become a *must*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 迫使采用微服务架构的另一种情况是将基于不同技术的较新子部分与旧子系统集成，因为容器化微服务是实现旧系统与新子部分之间有效交互的唯一方式，以便逐步用较新的子部分替换旧子部分。同样，如果我们的团队由具有不同开发栈经验的开发者组成，基于容器化微服务的架构可能成为一项*必需*。
- en: In the next section, we will analyze the building blocks and tools that are
    available for the implementation of .NET-based microservices.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分析可用于实现基于.NET的微服务的构建块和工具。
- en: How does .NET deal with microservices?
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET是如何处理微服务的？
- en: The new .NET, which evolved from .NET Core, was conceived as a multi-platform
    framework that was light and fast enough to implement efficient microservices.
    In particular, ASP.NET Core is the ideal tool for implementing text REST and binary
    gRPC APIs to communicate with a microservice since it can run efficiently with
    lightweight web servers such as Kestrel and is itself light and modular.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 新的.NET，它是由.NET Core演变而来的，被构想为一个轻量级且快速的跨平台框架，足以实现高效的微服务。特别是，ASP.NET Core是实现与微服务通信的文本REST和二进制gRPC
    API的理想工具，因为它可以与轻量级Web服务器如Kestrel高效运行，并且它本身也是轻量级和模块化的。
- en: The whole .NET stack evolved with microservices as a strategic deployment platform
    in mind and has facilities and packages for building efficient and light HTTP
    and gRPC communication to ensure service resiliency and to handle long-running
    tasks. The following subsections describe some of the different tools or solutions
    that we can use to implement a .NET-based microservice architecture.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 .NET 堆栈是在以微服务作为战略部署平台的前提下演进的，并提供了构建高效且轻量级的 HTTP 和 gRPC 通信的设施和包，以确保服务的弹性并处理长时间运行的任务。以下小节将描述一些我们可以用来实现基于
    .NET 的微服务架构的不同工具或解决方案。
- en: .NET communication facilities
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 通信设施
- en: Microservices need two kinds of communication channels.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务需要两种类型的通信通道。
- en: The first communication channel receives external requests, either directly
    or through an API gateway. HTTP is the usual protocol for external communication
    due to available web service standards and tools. .NET’s main HTTP/gRPC communication
    facility is ASP.NET Core since it’s a lightweight HTTP/gRPC framework, which makes
    it ideal for implementing web APIs in small microservices. We will describe ASP.NET
    REST API apps in detail in *Chapter 15*, *Applying Service-Oriented Architectures
    with .NET*, and we will describe gRPC services in *Chapter 14*, *Implementing
    Microservices with .NET*. .NET also offers an efficient and modular HTTP client
    solution that is able to pool and reuse heavy connection objects. Also, the `HttpClient`
    class will be described in more detail in *Chapter 15*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个通信通道接收外部请求，无论是直接还是通过 API 网关。由于可用的 Web 服务标准和工具，HTTP 是外部通信的常用协议。.NET 的主要 HTTP/gRPC
    通信设施是 ASP.NET Core，因为它是一个轻量级的 HTTP/gRPC 框架，这使得它非常适合在小型微服务中实现 Web API。我们将在*第 15
    章*，*使用 .NET 应用服务导向架构*中详细描述 ASP.NET REST API 应用，我们将在*第 14 章*，*使用 .NET 实现微服务*中描述
    gRPC 服务。.NET 还提供了一种高效且模块化的 HTTP 客户端解决方案，能够池化和重用重连接对象。此外，`HttpClient` 类将在*第 15
    章*中更详细地描述。
- en: The second channel is a different type of communication channel to push updates
    to other microservices. In fact, we have already mentioned that intra-microservice
    communication cannot be triggered by an ongoing request since a complex tree of
    blocking calls to other microservices would increase request latency to an unacceptable
    level. As a consequence, updates must not be requested immediately before they’re
    used and should be pushed whenever state changes take place. Ideally, this kind
    of communication should be asynchronous to achieve acceptable performance. In
    fact, synchronous calls would block the sender while they are waiting for the
    result, thus increasing the idle time of each microservice. However, synchronous
    communication that just puts the request in a processing queue and then returns
    confirmation of the successful communication instead of the final result is acceptable
    if communication is fast enough (low communication latency and high bandwidth).
    A publisher/subscriber communication would be preferable since, in this case,
    the sender and receiver don’t need to know each other, thus increasing the microservices’
    independence. In fact, all the receivers that are interested in a certain type
    of communication merely need to register to receive a specific *event*, while
    senders just need to publish those events. All the wiring is performed by a service
    that takes care of queuing events and dispatching them to all the subscribers.
    The publisher/subscriber pattern was described in *Chapter 6*, *Design Patterns
    and .NET 8 Implementation*, along with other useful patterns.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个通道是一种不同的通信通道，用于向其他微服务推送更新。实际上，我们之前已经提到，由于对其他微服务的复杂阻塞调用树会增加请求延迟到不可接受的水平，因此不能通过正在进行的请求来触发微服务内部的通信。因此，在它们被使用之前不应立即请求更新，而应该在状态发生变化时推送。理想情况下，这种通信应该是异步的，以实现可接受的性能。实际上，同步调用会在等待结果时阻塞发送方，从而增加每个微服务的空闲时间。然而，如果通信足够快（低通信延迟和高带宽），仅将请求放入处理队列并返回成功通信的确认而不是最终结果的同步通信是可以接受的。发布/订阅通信会更受欢迎，因为在这种情况下，发送方和接收方不需要相互了解，从而增加了微服务的独立性。实际上，所有对某种特定通信类型感兴趣的接收者只需注册以接收特定的*事件*，而发送方只需发布这些事件。所有连接的配置都是由一个负责排队事件并将它们分发给所有订阅者的服务来完成的。发布/订阅模式在*第
    6 章*，*设计模式和 .NET 8 实现*中进行了描述，以及其他有用的模式。
- en: While .NET doesn’t directly offer tools that may help in asynchronous communication
    or client/server tools that implement publisher/subscriber communication, Azure
    offers a similar service with *Azure Service Bus* ([https://docs.microsoft.com/en-us/azure/service-bus-messaging/](https://docs.microsoft.com/en-us/azure/service-bus-messaging/)).
    Azure Service Bus handles both queued asynchronous communication through Azure
    Service Bus *queues* and publisher/subscriber communication through Azure Service
    Bus *topics*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 .NET 没有直接提供可能有助于异步通信的工具，或者实现发布/订阅通信的客户端/服务器工具，但 Azure 提供了一个类似的服务，即 *Azure
    服务总线* ([https://docs.microsoft.com/en-us/azure/service-bus-messaging/](https://docs.microsoft.com/en-us/azure/service-bus-messaging/))。Azure
    服务总线通过 Azure 服务总线 *队列* 处理排队异步通信，并通过 Azure 服务总线 *主题* 处理发布/订阅通信。
- en: Once you’ve configured the Azure Service Bus on the Azure portal, you can connect
    to it in order to send messages/events and receive messages/events through a client
    contained in `Microsoft.Azure.ServiceBus` NuGet package.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在 Azure 门户上配置了 Azure 服务总线，你就可以通过包含在 `Microsoft.Azure.ServiceBus` NuGet 包中的客户端连接到它，以便发送消息/事件并通过接收消息/事件。
- en: 'Azure Service Bus has two types of communication: queue-based and topic-based.
    In queue-based communication, each message that’s placed in the queue by a sender
    is removed from the queue by the first receiver that pulls it from the queue.
    Topic-based communication, on the other hand, is an implementation of the publisher/subscriber
    pattern. Each topic has several subscriptions, and a different copy of each message
    sent to a topic can be pulled from each topic subscription.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 服务总线有两种通信类型：基于队列和基于主题。在基于队列的通信中，发送者放入队列的每条消息都由第一个从队列中拉取它的接收者从队列中移除。另一方面，基于主题的通信是发布/订阅模式的实现。每个主题都有多个订阅，并且可以从中每个主题订阅中拉取发送到主题的每条消息的不同副本。
- en: 'The design flow is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 设计流程如下：
- en: Define an Azure Service Bus private namespace.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 Azure 服务总线私有命名空间。
- en: Get the root connection strings that were created by the Azure portal and/or
    define new connection strings with fewer privileges.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由 Azure 门户创建的根连接字符串，或定义具有较少权限的新连接字符串。
- en: Define queues and/or topics where the sender will send their messages in binary
    format.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义队列和/或主题，发送者将用二进制格式发送他们的消息。
- en: For each topic, define names for all the required subscriptions.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个主题，定义所有必需的订阅名称。
- en: In the case of queue-based communication, the sender sends messages to a queue,
    and the receivers pull messages from the same queue. Each message is delivered
    to one receiver. That is, once a receiver gains access to the queue, it reads
    and removes one or more messages.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于队列的通信情况下，发送者将消息发送到队列，接收者从同一个队列中拉取消息。每条消息都交付给一个接收者。也就是说，一旦接收者获得对队列的访问权限，它就会读取并移除一条或几条消息。
- en: In the case of topic-based communication, each sender sends messages to a topic
    while each receiver pulls messages from its private subscription associated with
    that topic.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于主题的通信情况下，每个发送者将消息发送到主题，而每个接收者从与其相关联的主题的私有订阅中拉取消息。
- en: There are also other commercial and free open-source alternatives to Azure Service
    Bus, such as NServiceBus ([https://particular.net/nservicebus](https://particular.net/nservicebus)),
    MassTransit ([https://masstransit-project.com/](https://masstransit-project.com/)),
    and Brighter ([https://www.goparamore.io/](https://www.goparamore.io/)). They
    enhance existing brokers (like Azure Service Bus itself) with higher-level functionalities.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有其他商业和免费的开放源代码替代方案，如 NServiceBus ([https://particular.net/nservicebus](https://particular.net/nservicebus))、MassTransit
    ([https://masstransit-project.com/](https://masstransit-project.com/)) 和 Brighter
    ([https://www.goparamore.io/](https://www.goparamore.io/))。它们通过高级功能增强了现有的代理（如
    Azure 服务总线本身）。
- en: 'There is also a completely independent option that can be used on on-premises
    platforms: RabbitMQ. It is free and open source and can be installed locally,
    on a virtual machine, or in a Docker container. Then, you can connect with it
    through the client contained in the `RabbitMQ.Client` NuGet package.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个完全独立的选项，可以在本地平台使用：RabbitMQ。它是免费和开源的，可以安装在本地、虚拟机或 Docker 容器中。然后，你可以通过包含在
    `RabbitMQ.Client` NuGet 包中的客户端连接到它。
- en: The functionalities of RabbitMQ are similar to the ones offered by Azure Service
    Bus, but you have to take care of more implementation details, like serialization,
    reliable messages, and error handling, while Azure Service Bus takes care of all
    the low-level operations and offers you a simpler interface. However, there are
    clients that build a more powerful abstraction on top of RabbitMQ, like, for instance,
    EasyNetQ. The publisher/subscriber-based communication pattern used by both Azure
    Service Bus and RabbitMQ was described in *Chapter 6*, *Design Patterns and .NET
    8 Implementation*. RabbitMQ will be described in more detail in *Chapter 14*,
    *Implementing Microservices with .NET*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ的功能与Azure Service Bus提供的功能类似，但您必须注意更多的实现细节，如序列化、可靠消息和错误处理，而Azure Service
    Bus则负责所有底层操作并提供一个更简单的接口。然而，有一些客户端在RabbitMQ之上构建了更强大的抽象，例如EasyNetQ。Azure Service
    Bus和RabbitMQ使用的基于发布/订阅的通信模式在*第6章*，*设计模式和.NET 8实现*中进行了描述。RabbitMQ将在*第14章*，*使用.NET实现微服务*中更详细地介绍。
- en: Resilient task execution
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性任务执行
- en: Resilient communication and, in general, resilient task execution can be implemented
    easily with the help of a .NET library called Polly, whose project is a member
    of the .NET Foundation. Polly is available through the `Polly` NuGet package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为Polly的.NET库可以轻松实现弹性通信和弹性任务执行，该库的项目是.NET基金会的成员。Polly可以通过`Polly` NuGet包获得。
- en: 'In Polly, you define policies and then execute tasks in the context of those
    policies, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Polly中，您定义策略，然后在策略的上下文中执行任务，如下所示：
- en: '[PRE0]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first part of each policy specifies the exceptions that must be handled.
    Then, you specify what to do when one of those exceptions is captured. In the
    preceding code, the `Execute` method is retried up to three times if a failure
    is reported either by an `HttpRequestException` exception or by an `OperationCanceledException`
    exception.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每项政策的第一个部分指定了必须处理的异常。然后，您指定在捕获到这些异常之一时应该执行的操作。在上面的代码中，如果报告失败是由`HttpRequestException`异常或`OperationCanceledException`异常引起的，则`Execute`方法会重试最多三次。
- en: 'The following is the implementation of an exponential retry policy:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现指数重试策略的示例：
- en: '[PRE1]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first argument of `WaitAndRetryAsync` specifies that a maximum of six retries
    is performed in the event of failure. The lambda function passed as the second
    argument specifies how much time to wait before the next attempt. In this specific
    example, this time grows exponentially with the number of attempts by a power
    of 2 (2 seconds for the first retry, 4 seconds for the second retry, and so on).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitAndRetryAsync`的第一个参数指定在失败事件中最多执行六次重试。作为第二个参数传递的lambda函数指定在下次尝试之前等待的时间。在这个特定的例子中，这个时间随着尝试次数的指数增长，以2的幂次（第一次重试为2秒，第二次重试为4秒，依此类推）。'
- en: 'The following is a simple circuit breaker policy:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的断路器策略：
- en: '[PRE2]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After six failures, the task can’t be executed for one minute since an exception
    is returned.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在六次失败后，由于返回了异常，任务将无法执行一分钟。
- en: 'The following is the implementation of the Bulkhead Isolation policy (see the
    *Microservices design principles* section for more information):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现隔离舱隔离策略（有关更多信息，请参阅*微服务设计原则*部分）：
- en: '[PRE3]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A maximum of 10 parallel executions is allowed in the `Execute` method. Further
    tasks are inserted in an execution queue. This has a limit of 15 tasks. If the
    queue limit is exceeded, an exception is thrown.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Execute`方法允许最多10个并行执行。进一步的任务将插入到执行队列中。这个队列的容量为15个任务。如果队列限制被超过，则会抛出异常。'
- en: For the Bulkhead Isolation policy to work properly and, in general, for every
    strategy to work properly, task executions must be triggered through the same
    policy instance; otherwise, Polly is unable to count how many executions of a
    specific task are active.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使隔离舱隔离策略正常工作，以及在一般情况下，为了使每个策略正常工作，必须通过相同的策略实例触发任务执行；否则，Polly无法计算特定任务的活动执行次数。
- en: 'Policies can be combined with the `Wrap` method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Wrap`方法组合策略：
- en: '[PRE4]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Polly offers several more options, such as generic methods for tasks that return
    a specific type, timeout policies, task result caching, the ability to define
    custom policies, and so on. It is also possible to configure Polly as part of
    an `HttpClient` definition in the dependency injection section of any ASP.NET
    Core and .NET application. This way, it is quite immediate to define resilient
    clients.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Polly还提供了一些其他选项，例如针对返回特定类型的任务的通用方法、超时策略、任务结果缓存、定义自定义策略的能力等等。此外，还可以将Polly配置为任何ASP.NET
    Core和.NET应用程序依赖注入部分中的`HttpClient`定义的一部分。这样，定义健壮的客户端就变得相当直接了。
- en: 'Polly’s official documentation can be found in its GitHub repository here:
    [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Polly的官方文档可以在其GitHub仓库中找到：[https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)。
- en: The practical usage of Polly is explained in the *A worker microservice with
    ASP.NET Core* section of *Chapter 21*, *Case Study*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Polly的实际用法在*第21章*的*案例研究*部分*具有ASP.NET Core的Worker微服务*中解释。
- en: The resilience and robustness provided by tools like Polly are crucial components
    of microservice architecture, particularly when managing complex tasks and processes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 工具如Polly提供的弹性和健壮性是微服务架构的关键组成部分，尤其是在管理复杂任务和流程时。
- en: 'This brings us to another fundamental aspect of microservices: the implementation
    of generic hosts.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们来到了微服务的另一个基本方面：通用宿主的实现。
- en: Using generic hosts
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用通用宿主
- en: Each microservice may need to run several independent threads, with each performing
    a different operation on requests received. Such threads need several resources,
    such as database connections, communication channels, specialized modules that
    perform complex operations, and so on. Moreover, all processing threads must be
    adequately initialized when the microservice is started and gracefully stopped
    when the microservice is stopped as a consequence of either load-balancing or
    errors.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务可能需要运行多个独立的线程，每个线程对收到的请求执行不同的操作。这些线程需要多种资源，例如数据库连接、通信通道、执行复杂操作的专业模块等等。此外，所有处理线程必须在微服务启动时得到适当的初始化，并在微服务由于负载均衡或错误而停止时优雅地停止。
- en: All of these needs led the .NET team to conceive and implement *hosted services*
    and *hosts*. A host creates an adequate environment for running several tasks,
    known as **hosted services**, and provides them with resources, common settings,
    and a graceful start/stop.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些需求促使.NET团队构思并实现了*托管服务*和*宿主*。宿主为运行多个任务（称为**托管服务**）提供了一个适当的环境，并为它们提供资源、通用设置以及优雅的启动/停止。
- en: The concept of a web host was initially conceived to implement the ASP.NET Core
    web framework, but, with effect from .NET Core 2.1, the host concept was extended
    to all .NET applications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 网络宿主的概念最初是为了实现ASP.NET Core网络框架而构思的，但从.NET Core 2.1版本开始，宿主概念被扩展到了所有.NET应用程序。
- en: At the time of writing this book, a `Host` is automatically created for you
    in any ASP.NET Core, Blazor, and Worker Service project. The simplest way to test
    .NET Host features is to select a **Service -> Worker Service** project.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，任何ASP.NET Core、Blazor和Worker Service项目都会自动为您创建一个`Host`。测试.NET Host功能的简单方法是在项目中选择**服务
    -> 工作服务**项目。
- en: '![](img/B19820_11_07.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_11_07.png)'
- en: 'Figure 11.7: Creating a Worker Service project in Visual Studio'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：在Visual Studio中创建Worker Service项目
- en: All features related to the concept of a `Host` are contained in the `Microsoft.Extensions.Hosting`
    NuGet package.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Host`概念相关的所有功能都包含在`Microsoft.Extensions.Hosting` NuGet包中。
- en: '`Program.cs` contains some skeleton code for configuring the host with a fluent
    interface, starting with the `CreateDefaultBuilder` method of the `Host` class.
    The final step of this configuration is calling the `Build` method, which assembles
    the actual host with all the configuration information we provided:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program.cs`包含一些使用流畅接口配置宿主的框架代码，从`Host`类的`CreateDefaultBuilder`方法开始。此配置的最终步骤是调用`Build`方法，该方法将所有我们提供的配置信息组装成实际的宿主：'
- en: '[PRE5]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Host configuration includes defining the common resources, defining the default
    folder for files, loading the configuration parameters from several sources (JSON
    files, environment variables, and any arguments that are passed to the application),
    and declaring all the hosted services.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 宿主配置包括定义通用资源、定义文件的默认文件夹、从多个来源（JSON文件、环境变量以及传递给应用程序的任何参数）加载配置参数，以及声明所有托管服务。
- en: It is worth pointing out that ASP.NET Core and Blazor projects use methods that
    perform pre-configuration of the `Host`, including several of the tasks listed
    previously.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，ASP.NET Core 和 Blazor 项目使用的方法包括对 `Host` 的预配置，其中包括之前列出的几个任务。
- en: 'Then, the host is started, which causes all the hosted services to be started:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动宿主，这将导致所有托管服务启动：
- en: '[PRE6]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The program remains blocked on the preceding instruction until the host is shut
    down. The host is automatically shut down when the operating system kills the
    process. However, the host can also be shut down manually either by one of the
    hosted services or externally by calling `await host.StopAsync(timeout)`. Here,
    `timeout` is a time span defining the maximum time to wait for the hosted services
    to stop gracefully. After this time, all the hosted services are aborted if they
    haven’t been terminated. We will explain how a hosted service can shut down the
    host later on in this subsection.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会阻塞在先前的指令上，直到宿主关闭。当操作系统终止进程时，宿主会自动关闭。然而，宿主也可以通过托管服务之一或通过外部调用 `await host.StopAsync(timeout)`
    来手动关闭。在这里，`timeout` 是一个定义等待托管服务优雅停止的最大时间的时间跨度。在此之后，如果托管服务尚未终止，则所有托管服务都将被中止。我们将在本小节稍后解释托管服务如何关闭宿主。
- en: 'When the thread contains a `host.RunAsync` is launched from within another
    thread instead of `Program.cs`. The fact that the host thread is being shut down
    can be signaled by a `cancellationToken` passed to `RunAsync`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程包含 `host.RunAsync` 并从另一个线程而不是 `Program.cs` 中启动时，可以通过传递给 `RunAsync` 的 `cancellationToken`
    来表示宿主线程正在关闭：
- en: '[PRE7]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This way of shutting down is triggered as soon as the `cancellationToken` enters
    a canceled state by another thread.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当另一个线程通过 `cancellationToken` 进入取消状态时，这种关闭方式立即被触发。
- en: 'By default, the host has a 5-second timeout for shutting down; that is, it
    waits 5 seconds before exiting once a shutdown has been requested. This time can
    be changed within the `ConfigureServices` method, which is used to declare *hosted
    services* and other resources:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，宿主有 5 秒的关闭超时；也就是说，一旦请求关闭，它将等待 5 秒后才退出。这个时间可以在 `ConfigureServices` 方法中更改，该方法用于声明
    *托管服务* 和其他资源：
- en: '[PRE8]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, increasing the host timeout doesn’t increase the orchestrator timeout,
    so if the host waits too long, the whole microservice is killed by the orchestrator.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，增加宿主超时不会增加协调器超时，所以如果宿主等待时间过长，整个微服务将被协调器杀死。
- en: If no cancellation token is explicitly passed to `Run` or `RunAsync`, a cancellation
    token is automatically generated and is automatically signaled when the operating
    system informs the application it is going to kill it. This cancellation token
    is passed to all hosted services to give them the opportunity to stop gracefully.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确传递取消令牌给 `Run` 或 `RunAsync`，则会自动生成一个取消令牌，并且当操作系统通知应用程序它将要杀死它时，该取消令牌会自动被触发。这个取消令牌被传递给所有托管服务，以给它们提供优雅停止的机会。
- en: Hosted services are implementations of the `IHostedService` interface, whose
    only methods are `StartAsync(cancellationToken)` and `StopAsync(cancellationToken)`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 托管服务是 `IHostedService` 接口的实现，它只包含 `StartAsync(cancellationToken)` 和 `StopAsync(cancellationToken)`
    这两个方法。
- en: Both methods are passed a `cancellationToken`. The `cancellationToken` in the
    `StartAsync` method signals that a shutdown was requested. The `StartAsync` method
    periodically checks this `cancellationToken` while performing all operations needed
    to start the host, and if it is signaled, the host start process is aborted. On
    the other hand, the `cancellationToken` in the `StopAsync` method signals that
    the shutdown timeout expired.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都传递了一个 `cancellationToken`。`StartAsync` 方法中的 `cancellationToken` 表示请求关闭。`StartAsync`
    方法在执行启动宿主所需的所有操作时，会定期检查这个 `cancellationToken`，如果它被触发，则宿主启动过程将被终止。另一方面，`StopAsync`
    方法中的 `cancellationToken` 表示关闭超时已过期。
- en: 'Hosted services can be declared in the same `ConfigureServices` method that’s
    used to define host options, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 托管服务可以在用于定义宿主选项的相同 `ConfigureServices` 方法中声明，如下所示：
- en: '[PRE9]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Most declarations inside `ConfigureServices` require the addition of the following
    namespace:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureServices` 内部的大多数声明都需要添加以下命名空间：'
- en: '[PRE10]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usually, the `IHostedService` interface isn’t implemented directly but can be
    inherited from the `BackgroundService` abstract class, which exposes the easier-to-implement
    `ExecuteAsync(CancellationToken)` method, which is where we can place the whole
    logic of the service. A shutdown is signaled by passing `cancellationToken` as
    an argument, which is easier to handle. We will look in more detail at an implementation
    of `IHostedService` in *Chapter 14*, *Implementing Microservices with .NET*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`IHostedService`接口不是直接实现的，但可以继承自`BackgroundService`抽象类，该类公开了更容易实现的`ExecuteAsync(CancellationToken)`方法，我们可以在其中放置服务的全部逻辑。通过传递`cancellationToken`作为参数来发出关闭信号，这更容易处理。我们将在*第14章*，*使用.NET实现微服务*中更详细地查看`IHostedService`的实现。
- en: 'To allow a hosted service to shut down the whole host, we need to declare an
    `IApplicationLifetime` interface as its constructor parameter:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许托管服务关闭整个宿主，我们需要将其构造函数参数声明为`IApplicationLifetime`接口：
- en: '[PRE11]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the hosted service is created, it is automatically passed an implementation
    of `IHostApplicationLifetime`, whose `StopApplication` method will trigger the
    host shutdown. This implementation is handled automatically, but we can also declare
    custom resources whose instances will be automatically passed to all the host
    service constructors that declare them as parameters. Therefore, say we define
    a constructor like this one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当托管服务被创建时，它会自动传递一个`IHostApplicationLifetime`的实现，其`StopApplication`方法将触发宿主关闭。这种实现是自动处理的，但我们可以声明自定义资源，其实例将被自动传递到所有声明它们为参数的宿主服务构造函数。因此，假设我们定义了一个这样的构造函数：
- en: '[PRE12]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are several ways to define the resources needed by the preceding constructor:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 定义前面构造函数所需资源的方法有几种：
- en: '[PRE13]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we use `AddTransient`, a different instance is created and passed to all
    the constructors that require an instance of that type. On the other hand, with
    `AddSingleton`, a unique instance is created and passed to all the constructors
    that require the declared type. The overload with two generic types allows you
    to pass an interface and a type that implements that interface. This way, a constructor
    requires the interface and is decoupled from the specific implementation of that
    interface.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`AddTransient`时，会创建一个不同的实例并将其传递到所有需要该类型实例的构造函数。另一方面，使用`AddSingleton`时，会创建一个唯一的实例并将其传递到所有需要声明类型的构造函数。具有两个泛型类型重载的版本允许你传递一个接口及其实现该接口的类型。这样，构造函数需要接口，并且与该接口的具体实现解耦。
- en: If resource constructors contain parameters, they will be automatically instantiated
    with the types declared in `ConfigureServices` in a recursive fashion. This pattern
    of interaction, called **dependency injection** (**DI**), has already been discussed
    in detail in *Chapter 6*, *Design Patterns and .NET 8 Implementation*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源构造函数包含参数，它们将自动以递归方式使用在`ConfigureServices`中声明的类型进行实例化。这种交互模式称为**依赖注入**（**DI**），已经在*第6章*，*设计模式和.NET
    8实现*中详细讨论过。
- en: '`IHostBuilder` also has a method we can use to define the default folder –
    that is, the folder used to resolve all relative paths mentioned in all .NET methods:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`IHostBuilder`还有一个我们可以用来定义默认文件夹的方法——即用于解析所有.NET方法中提到的所有相对路径的文件夹：'
- en: '[PRE14]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It also has methods that we can use to add logging targets:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了我们可以用来添加日志目标的方法：
- en: '[PRE15]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous example shows a console-based logging source, but we can also
    log in to Azure targets with adequate providers. The *Further reading* section
    contains links to some Azure logging providers that can work with microservices
    that have been deployed in Azure. Once you’ve configured logging, you can enable
    your hosted services and log custom messages by adding an `ILogger<T>` parameter
    in their constructors. `ILogger<T>` has methods for logging messages with several
    severity levels: Trace, Debug (lowest), Information, Warning, Error, Critical,
    and None (highest). In turn, the application configuration specifies the minimum
    severity level needed to actually output log messages. All messages that pass
    the severity filter are simultaneously sent to all configured targets.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了基于控制台的日志源，但我们也可以使用足够的提供者将日志记录到Azure目标。*进一步阅读*部分包含了一些可以与已部署在Azure中的微服务一起工作的Azure日志提供者的链接。一旦你配置了日志，你就可以通过在它们的构造函数中添加一个`ILogger<T>`参数来启用你的托管服务并记录自定义消息。`ILogger<T>`有用于以多个严重级别记录消息的方法：跟踪（Trace）、调试（最低）、信息、警告、错误、关键和空（最高）。反过来，应用程序配置指定了实际输出日志消息所需的最低严重级别。所有通过严重性过滤器的消息都会同时发送到所有配置的目标。
- en: The only purpose of the type `T` is to classify the message through its full
    name.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `T` 的唯一目的是通过其全名来分类消息。
- en: The developer can specify the minimum severity level in a configuration file.
    We may have different severity levels for each type of `T`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在配置文件中指定最小严重性级别。对于 `T` 的每种类型，我们可能有不同的严重性级别。
- en: 'For instance:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE16]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the above configuration file, the default severity level is “`Information`”,
    but all types whose name starts with “`Microsoft.AspNetCore`” have a “`Warning`”
    severity level.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置文件中，默认严重性级别是“`Information`”，但所有名称以“`Microsoft.AspNetCore`”开头的类型都具有“`Warning`”严重性级别。
- en: 'Finally, `IHostBuilder` has methods we can use to read configuration parameters
    from various sources:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`IHostBuilder` 有我们可以用来从各种来源读取配置参数的方法：
- en: '[PRE17]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The way parameters defined in configuration streams can be used from inside
    the application will be explained in more detail in *Chapter 17*, *Presenting
    ASP.NET Core*, which is dedicated to ASP.NET.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将在 *第 17 章*，*展示 ASP.NET Core* 中更详细地解释如何在应用程序内部使用配置流中定义的参数，该章节专门介绍 ASP.NET。
- en: As we transition from the specificities of ASP.NET Core to the broader realm
    of application deployment and environment setup, an important tool comes into
    play – Visual Studio Docker support.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 ASP.NET Core 的具体性过渡到更广泛的应用程序部署和环境设置领域时，一个重要的工具就派上用场了——Visual Studio Docker
    支持。
- en: Visual Studio support for Docker
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio 对 Docker 的支持
- en: Visual Studio offers support for creating, debugging, and deploying Docker images.
    Docker deployment requires us to install *Docker Desktop for Windows* on our development
    machine so that we can run Docker images.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 提供了创建、调试和部署 Docker 镜像的支持。Docker 部署需要我们在开发机上安装 *Docker Desktop
    for Windows*，这样我们才能运行 Docker 镜像。
- en: The download link can be found in the *Technical requirements* section at the
    beginning of this chapter. Before we start any development activity, we must ensure
    it is installed and running (you should see a Docker icon in the window notification
    bar when the Docker runtime is running).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下载链接可以在本章开头的 *Technical requirements* 部分找到。在我们开始任何开发活动之前，我们必须确保它已安装并正在运行（当 Docker
    运行时正在运行时，你应该在窗口通知栏中看到 Docker 图标）。
- en: 'Docker support will be described with a simple ASP.NET Core MVC project. Let’s
    create one. To do so, follow these steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用一个简单的 ASP.NET Core MVC 项目来描述 Docker 支持。让我们创建一个。为此，请按照以下步骤操作：
- en: Name the project `MvcDockerTest`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `MvcDockerTest`。
- en: For simplicity, disable authentication if it is not already disabled.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，如果尚未禁用，请禁用身份验证。
- en: You are given the option to add Docker support when you create the project,
    but please don’t check the **Docker support** checkbox. You can test how Docker
    support can be added to any project after it has been created.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你创建项目时，你会得到添加 Docker 支持的选项，但请不要勾选 **Docker support** 复选框。项目创建后，你可以测试如何将 Docker
    支持添加到任何项目中。
- en: Once you have your ASP.NET MVC application scaffolded and running, right-click
    on its project icon in **Solution Explorer**, select **Add**, and then select
    **Container Orchestrator Support | Docker Compose**. If you installed both **WSL**
    and **Windows Containers**, a dialog for choosing between **Linux** and **Windows**
    will appear. Otherwise, **Linux**will be automatically chosen if you installed
    just **WSL**, and **Windows** if you installed just **Windows Containers**.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的 ASP.NET MVC 应用程序已经搭建并运行，在 **Solution Explorer** 中右键单击其项目图标，选择 **Add**，然后选择
    **Container Orchestrator Support | Docker Compose**。如果你安装了 **WSL** 和 **Windows
    Containers**，将出现一个选择 **Linux** 和 **Windows** 的对话框。如果没有安装 **WSL** 和 **Windows Containers**，则如果只安装了
    **WSL**，将自动选择 **Linux**；如果只安装了 **Windows Containers**，则选择 **Windows**。
- en: If you installed **WSL****,** please select **Linux**, since it is the default
    used by the Docker server when WSL is available.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你安装了 **WSL**，请选择 **Linux**，因为当 WSL 可用时，它是 Docker 服务器默认使用的。
- en: The advantage of enabling Docker Compose instead of just Docker is that you
    can manually configure how the image is run on the development machine, as well
    as how Docker image ports are mapped to external ports by editing the Docker Compose
    files that are added to the solution.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Docker Compose 而不是仅启用 Docker 的优点是，你可以手动配置如何在开发机上运行镜像，以及如何通过编辑添加到解决方案中的 Docker
    Compose 文件将 Docker 镜像端口映射到外部端口。
- en: If your Docker runtime has been installed properly and is running, you should
    be able to run the Docker image from Visual Studio. Please try it!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Docker 运行时已经正确安装并正在运行，你应该能够从 Visual Studio 运行 Docker 镜像。请尝试一下！
- en: Now that we have explored how to configure and run Docker images, let’s delve
    deeper into the structure and composition of these images. Understanding the Docker
    file created by Visual Studio is key to grasping how it orchestrates the creation
    and management of these images.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何配置和运行Docker镜像，让我们更深入地了解这些镜像的结构和组成。理解由Visual Studio创建的Docker文件是掌握它如何编排这些镜像的创建和管理的关键。
- en: Analyzing the Docker file
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析Docker文件
- en: 'Let’s analyze the Docker file that was created by Visual Studio. It is a sequence
    of image creation steps. Each step enriches an existing image with something else
    with the help of the `From` instruction, which is a reference to an already existing
    image. The following is the first step:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析由Visual Studio创建的Docker文件。它是一系列创建镜像的步骤。每个步骤都通过`From`指令（它是对已存在镜像的引用）的帮助，在现有镜像上添加一些其他内容。以下是第一步：
- en: '[PRE18]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first step uses the `mcr.microsoft.com/dotnet/aspnet:x.x` ASP.NET (Core)
    runtime that was published by Microsoft in the Docker public repository (where
    `x.x` is the ASP.NET (Core) version that was selected in your project).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步使用了由Microsoft在Docker公共仓库中发布的`mcr.microsoft.com/dotnet/aspnet:x.x` ASP.NET
    (Core)运行时版本（其中`x.x`是在项目中选择的ASP.NET (Core)版本）。
- en: 'The `WORKDIR` command creates the directory that follows the command within
    the image that is going to be created. The two `EXPOSE` commands declare which
    ports will be exposed outside the image and mapped to ports of the actual hosting
    machine. Mapped ports are decided in the deployment stage either as command-line
    arguments of a Docker command or within a Docker Compose file. In our case, there
    are two ports: one for HTTP (80) and another for HTTPS (443).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`命令在即将创建的镜像中创建一个目录。两个`EXPOSE`命令声明了哪些端口将暴露在镜像外部并映射到实际托管机的端口。映射的端口在部署阶段决定，要么作为Docker命令的命令行参数，要么在Docker
    Compose文件中。在我们的例子中，有两个端口：一个用于HTTP（80），另一个用于HTTPS（443）。'
- en: This intermediate image is cached by Docker, which doesn’t need to recompute
    since it doesn’t depend on the code we write but only on the selected version
    of the ASP.NET (Core) runtime.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间镜像被Docker缓存，因为它不需要重新计算，因为它不依赖于我们编写的代码，而只依赖于所选的ASP.NET (Core)运行时版本。
- en: 'The second step produces a different image that will not be used to deploy.
    Instead, it will be used to create application-specific files that will be deployed:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步生成一个不同的镜像，它不会用于部署。相反，它将用于创建将部署的应用程序特定的文件：
- en: '[PRE19]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This step starts from the ASP.NET SDK image, which contains parts we don’t need
    to add for deployment; these are needed to process the project code. The new `src`
    directory is created in the `build` image and made the current image directory.
    Then, the project file is copied into `/src/MvcDockerTest`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤从ASP.NET SDK镜像开始，其中包含我们不添加到部署中的部分；这些部分是处理项目代码所需的。在`build`镜像中创建了一个新的`src`目录，并将其设置为当前镜像目录。然后，项目文件被复制到`/src/MvcDockerTest`。
- en: The `RUN` command executes an operating system command on the image. In this
    case, it calls the `dotnet` runtime, asking it to restore the NuGet packages that
    were referenced by the previously copied project file.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`命令在镜像上执行操作系统命令。在这种情况下，它调用`dotnet`运行时，请求它恢复之前复制的项目文件中引用的NuGet包。'
- en: Then, the `COPY..` command copies the whole project file tree into the `src`
    image directory. Finally, the project directory is made the current directory,
    and the `dotnet` runtime is asked to build the project in release mode and copy
    all the output files into the new `/app/build` directory. Finally, the `dotnet
    publish` task is executed in a new image called `publish`, outputting the published
    binaries into `/app/publish`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`COPY..`命令将整个项目文件树复制到`src`镜像目录。最后，将项目目录设置为当前目录，并请求`dotnet`运行时以发布模式构建项目，并将所有输出文件复制到新的`/app/build`目录。最后，在名为`publish`的新镜像中执行`dotnet
    publish`任务，将发布的二进制文件输出到`/app/publish`。
- en: 'The final step starts from the image that we created in the first step, which
    contains the ASP.NET (Core) runtime and adds all the files that were published
    in the previous step:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步从第一步中创建的镜像开始，该镜像包含ASP.NET (Core)运行时，并添加了上一步中发布的所有文件：
- en: '[PRE20]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ENTRYPOINT` command specifies the operating system command that’s needed
    to execute the image. It accepts an array of strings. In our case, it accepts
    the `dotnet` command and its first command-line argument – that is, the DLL we
    need to execute. With that out of the way, let’s now publish our little project!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 命令指定执行镜像所需的操作系统命令。它接受一个字符串数组。在我们的例子中，它接受 `dotnet` 命令及其第一个命令行参数——即我们需要执行的
    DLL。处理完这些之后，现在让我们发布我们的这个小项目！'
- en: Publishing the project
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布项目
- en: 'If we right-click on our project and click **Publish**, we are presented with
    several options:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们右键单击我们的项目并点击 **发布**，我们会看到几个选项：
- en: Publish the image to an existing or new web app (automatically created by Visual
    Studio)
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将镜像发布到现有的或新的 Web 应用程序（由 Visual Studio 自动创建）
- en: Publish to one of several Docker registries, including a private registry in
    Azure Container Registry that, if it doesn’t already exist, can be created from
    within Visual Studio
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到多个 Docker 仓库之一，包括 Azure 容器注册表中的私有仓库，如果它还不存在，可以在 Visual Studio 中创建
- en: Docker Compose support allows you to run and publish a multi-container application
    and add further images, such as a containerized database that is available everywhere.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 支持允许您运行和发布一个多容器应用程序，并添加更多图像，例如一个可在任何地方使用的容器化数据库。
- en: 'The following Docker Compose file instructs the Docker server to run two containerized
    ASP.NET applications:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Docker Compose 文件指示 Docker 服务器运行两个容器化的 ASP.NET 应用程序：
- en: '[PRE21]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can add another ASP:NET Core MVC application to our previous docker-compose
    file by just adding another ASP:NET Core MVC application named MvcDockerTest 1
    to the solution and by enabling docker-compose on it. However, you must pay attention
    to the fact that the newly created project folder is placed inside the same solution
    folder as MvcDockerTest.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将另一个名为 MvcDockerTest 1 的 ASP.NET Core MVC 应用程序添加到解决方案中，并启用其上的 docker-compose
    来将另一个 ASP.NET Core MVC 应用程序添加到我们之前的 docker-compose 文件中。然而，您必须注意，新创建的项目文件夹被放置在与
    MvcDockerTest 相同的解决方案文件夹中。
- en: 'The preceding code references existing Docker files. Any environment-dependent
    information is placed in the `docker-compose.override.yml` file, which is merged
    with the `docker-compose.yml` file when the application is launched from Visual
    Studio:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码引用了现有的 Docker 文件。任何依赖于环境的信息都放置在 `docker-compose.override.yml` 文件中，当应用程序从
    Visual Studio 启动时，该文件将与 `docker-compose.yml` 文件合并：
- en: '[PRE22]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For each image, the file specifies some environment variables (which will be
    defined in the image when the application is launched), the port mappings, and
    some host files.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个镜像，文件指定了一些环境变量（这些变量将在应用程序启动时在镜像中定义），端口映射和一些主机文件。
- en: The files in the host are directly mapped into the images. Each declaration
    contains the path in the host, how the path is mapped in the image, and the desired
    access rights. In our case, `volumes` are used to map the machine key used for
    all encryption needs of the application and the self-signed HTTPS certificate
    that’s used by Visual Studio.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 主机中的文件直接映射到镜像中。每个声明包含主机中的路径，路径如何在镜像中映射，以及所需的访问权限。在我们的例子中，使用 `volumes` 将用于应用程序所有加密需求的应用程序机器密钥和
    Visual Studio 使用的自签名 HTTPS 证书映射。
- en: 'When you launch the application in Visual Studio, just the browser window opens
    and shows the **MvcDockerTest** application. However, both applications are launched,
    so you just need to discover which port **MvcDockerTest1** is running on and open
    another browser window. You can discover the port by clicking on **MvcDockerTest1**
    in the Containers tab in Visual Studio and looking at its HTTPS **Host Port**
    (**60072**), as shown in the figure below:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Visual Studio 中启动应用程序时，只会打开浏览器窗口并显示 **MvcDockerTest** 应用程序。然而，两个应用程序都被启动了，所以您只需要发现
    **MvcDockerTest1** 在哪个端口上运行，并打开另一个浏览器窗口。您可以通过在 Visual Studio 的容器选项卡中点击 **MvcDockerTest1**
    并查看其 HTTPS **主机端口**（**60072**）来发现端口，如图下所示：
- en: '![](img/B19820_11_08.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_11_08.png)'
- en: 'Figure 11.8: Discovering the MvcDockerTest1 host port'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：发现 MvcDockerTest1 主机端口
- en: 'Now, suppose we want to add a containerized SQL Server instance. We would need
    something like the following instructions split between `docker-compose.yml` and
    `docker-compose.override.yml`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要添加一个容器化的 SQL Server 实例。我们需要像以下这样的指令，这些指令分布在 `docker-compose.yml` 和
    `docker-compose.override.yml` 之间：
- en: '[PRE23]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, the preceding code specifies the properties of the SQL Server container,
    as well as the SQL Server configuration and installation parameters. More specifically,
    the preceding code contains the following information:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，前面的代码指定了 SQL Server 容器的属性，以及 SQL Server 配置和安装参数。更具体地说，前面的代码包含以下信息：
- en: '`sql.data` is the name that’s given to the container.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.data` 是分配给容器的名称。'
- en: '`image` specifies where to take the image from. In our case, the image is contained
    in a public Docker registry.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image` 指定了从哪里获取镜像。在我们的例子中，镜像包含在公共 Docker 仓库中。'
- en: '`environment` specifies the environment variables that are needed by SQL Server
    – that is, the administrator password, the acceptance of a SQL Server license,
    and the SQL Server edition.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment` 指定了 SQL Server 所需的环境变量——即管理员密码、接受 SQL Server 许可证以及 SQL Server
    版本。'
- en: As usual, `ports` specify the port mappings.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如同往常，`ports` 指定端口映射。
- en: '`docker-compose.override.yml` is used to run the images from within Visual
    Studio.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose.override.yml` 用于在 Visual Studio 内运行镜像。'
- en: 'If you need to specify parameters for either the production environment or
    the testing environment, you can add further `docker-compose-xxx.override.yml`
    files, such as `docker-compose-staging.override.yml` and `docker-compose-production.override.yml`,
    and then launch them manually in the target environment with something like the
    following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为生产环境或测试环境指定参数，你可以添加额外的 `docker-compose-xxx.override.yml` 文件，例如 `docker-compose-staging.override.yml`
    和 `docker-compose-production.override.yml`，然后在目标环境中手动启动它们，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, you can destroy all the containers with the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下代码销毁所有容器：
- en: '[PRE25]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While `docker-compose` has a limited capability when it comes to handling node
    clusters, it is mainly used in testing and development environments. For production
    environments, more sophisticated tools, called orchestrators, are needed. A de
    facto standard for the production environment is Kubernetes, which will be analyzed
    in detail in *Chapter 20*, *Kubernetes*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `docker-compose` 在处理节点集群方面功能有限，但它主要用于测试和开发环境。对于生产环境，需要更复杂的工具，称为编排器。生产环境的事实标准是
    Kubernetes，它将在第 20 章“Kubernetes”中详细分析。
- en: Azure and Visual Studio support for microservice orchestration
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 和 Visual Studio 对微服务编排的支持
- en: Visual Studio has extensions for debugging a single microservice while it communicates
    with other microservices deployed in Kubernetes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 提供了用于调试单个微服务的扩展，同时它与其他在 Kubernetes 中部署的微服务进行通信。
- en: Also available are tools for testing and debugging several communicating microservices
    in the development machine and for deploying them automatically on Azure Kubernetes
    Service with just minimal configuration information.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有用于在开发机器上测试和调试多个通信微服务以及仅用最小配置信息自动将它们部署到 Azure Kubernetes Service 的工具。
- en: All Visual Studio tools for Kubernetes and the whole process of developing for
    Kubernetes with Visual Studio will be described in the practical example in *Chapter
    22*, *Developing .NET Microservices for Kubernetes*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 所有针对 Kubernetes 的 Visual Studio 工具以及使用 Visual Studio 开发 Kubernetes 的整个过程将在第
    22 章“为 Kubernetes 开发 .NET 微服务”中的实际示例中描述。
- en: Moving on from Visual Studio’s features for Kubernetes, let’s dive into the
    key tools offered, in general, by all microservices orchestrators like Kubernetes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Visual Studio 的 Kubernetes 功能讲起，让我们深入了解所有像 Kubernetes 这样的微服务编排器通常提供的关键工具。
- en: Which tools are needed to manage microservices?
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理微服务需要哪些工具？
- en: 'Effectively handling microservices in your CI/CD cycles requires both a private
    Docker image registry and a state-of-the-art microservice orchestrator that’s
    capable of doing the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI/CD 循环中有效地处理微服务需要私有 Docker 镜像仓库和先进的微服务编排器，后者能够执行以下操作：
- en: Allocating and load-balancing microservices on available hardware nodes
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可用的硬件节点上分配和负载均衡微服务
- en: Monitoring the health state of services and replacing faulty services if hardware/software
    failures occur
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控服务的健康状态，并在硬件/软件故障发生时替换故障服务
- en: Logging and presenting analytics
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和展示分析结果
- en: Allowing the designer to dynamically change requirements such as hardware nodes
    allocated to a cluster, the number of service instances, and so on
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许设计者动态更改需求，例如分配给集群的硬件节点、服务实例数量等
- en: The following subsection describes the Azure facilities we can use to store
    Docker images. The microservices orchestrators available in Azure are described
    in a dedicated chapter – namely, *Chapter 20*, *Kubernetes*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了我们可以使用的Azure设施来存储Docker镜像。Azure中可用的微服务编排器在专门的章节中描述——即*第20章*，*Kubernetes*。
- en: Having learned about the essential functionalities offered by microservices
    orchestration, let’s now turn our attention to how Azure facilitates these processes,
    starting with the setup of a private Docker registry.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了微服务编排提供的基本功能之后，现在让我们将注意力转向Azure如何简化这些过程，从设置私有Docker注册表开始。
- en: Defining your private Docker registry in Azure
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Azure中定义您的私有Docker注册表
- en: Defining your private Docker registry in Azure is easy. Just type `Container
    registries` into the Azure search bar and select **Container registries**. On
    the page that appears, click on the **Create** button.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中定义您的私有Docker注册表很容易。只需在Azure搜索栏中输入`Container registries`并选择**Container
    registries**。在出现的页面上，点击**创建**按钮。
- en: 'The following form will appear:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 将出现以下表单：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_11_09.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19820_11_09.png)'
- en: 'Figure 11.9: Creating an Azure private Docker registry'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：创建Azure私有Docker注册表
- en: 'The name you select is used to compose the overall registry URI: `<name>.azurecr.io`.
    As usual, you can specify the subscription, resource group, and location. The
    **SKU** dropdown lets you choose from various levels of offerings that differ
    in terms of performance, available memory, and a few other auxiliary features.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的名称用于组成整体注册表URI：`<name>.azurecr.io`。通常，您可以指定订阅、资源组和位置。**SKU**下拉菜单允许您从具有不同性能、可用内存和其他一些辅助功能的各个级别中选择。
- en: 'Whenever you mention image names in Docker commands or in a Visual Studio publish
    form, you must prefix them with the registry URI: `<name>.azurecr.io/<my imagename>`.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker命令或Visual Studio发布表单中提及镜像名称时，您必须使用注册表URI作为前缀：`<name>.azurecr.io/<my imagename>`。
- en: If images are created with Visual Studio, then they can be published by following
    the instructions that appear once you publish the project. Otherwise, you must
    use Docker commands to push them into your registry.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Visual Studio创建镜像，则可以按照发布项目时出现的说明进行发布。否则，您必须使用Docker命令将它们推送到您的注册表。
- en: 'The easiest way to use Docker commands that interact with the Azure registry
    is by installing the Azure CLI on your computer. Download the installer from [https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows)
    and execute it. Once the Azure CLI has been installed, you can use the `az` command
    from Windows Command Prompt or PowerShell. In order to connect with your Azure
    account, you must execute the following `login` command:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与Azure注册表交互的Docker命令的最简单方法是安装Azure CLI到您的计算机上。从[https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows)下载安装程序并执行它。一旦Azure
    CLI已安装，您就可以从Windows命令提示符或PowerShell中使用`az`命令。为了连接到您的Azure账户，您必须执行以下`login`命令：
- en: '[PRE26]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command should start your default browser and should drive you through
    the manual login procedure.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应启动您的默认浏览器，并引导您完成手动登录过程。
- en: 'Once logged in to your Azure account, you can log in to your private registry
    by typing the following command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录到您的Azure账户，您可以通过输入以下命令登录到您的私有注册表：
- en: '[PRE27]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let’s say you have a Docker image in another registry. As a first step,
    let’s pull the image on your local computer:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您在另一个注册表中有一个Docker镜像。作为第一步，让我们在本地计算机上拉取该镜像：
- en: '[PRE28]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If there are several versions of the preceding image, the latest will be pulled
    since no version was specified. The version of the image can be specified as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的镜像有多个版本，由于没有指定版本，将拉取最新版本。可以按以下方式指定镜像版本：
- en: '[PRE29]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using the following command, you should see `myimage` within the list of local
    images:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令，您应该在本地镜像列表中看到`myimage`：
- en: '[PRE30]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, tag the image with the path you want to assign in the Azure registry:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用您想要分配到Azure注册表的路径标记镜像：
- en: '[PRE31]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Both the name and destination tag may have versions (`:<version name>`).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 名称和目标标签都可能包含版本（`:<版本名称>`）。
- en: 'Finally, push it to your registry with the following command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下命令将其推送到您的注册表：
- en: '[PRE32]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, you can specify a version; otherwise, the latest version is pushed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以指定一个版本；否则，将推送最新版本。
- en: 'By doing this, you can remove the image from your local computer using the
    following command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令，您可以从本地计算机中删除镜像：
- en: '[PRE33]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described what microservices are and how they have evolved
    from the concept of a module. Then, we talked about the advantages of microservices
    and when it is worth using them, as well as general criteria for their design.
    We also explained what Docker containers are and analyzed the strong connection
    between containers and microservice architectures.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了微服务是什么以及它们是如何从模块的概念演变而来的。然后，我们讨论了微服务的优势以及何时值得使用它们，以及它们设计的一般标准。我们还解释了
    Docker 容器是什么，并分析了容器与微服务架构之间的紧密联系。
- en: Then, we took on a more practical implementation by describing all the tools
    that are available in .NET so that we can implement microservice-based architectures.
    We also described infrastructures that are needed by microservices and how Azure
    offers both container registries and container orchestrators.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过描述 .NET 中可用的所有工具来实施更实际的实现，这样我们就可以实现基于微服务的架构。我们还描述了微服务所需的架构以及 Azure 如何提供容器注册中心和容器编排器。
- en: This chapter was just a general introduction to microservices. Further chapters
    will discuss most of the subjects introduced here in more detail while showing
    practical implementation techniques and code examples.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只是对微服务的一般介绍。接下来的章节将更详细地讨论这里介绍的大多数主题，同时展示实际的实现技术和代码示例。
- en: This ends the first part of the book dedicated to fundamentals. The next chapter,
    *Choosing Your Data Storage in the Cloud*, starts the second part of the book,
    which is dedicated to specific technologies.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书关于基础的第一部分到此结束。下一章，*在云中选择您的数据存储*，开始本书的第二部分，该部分专注于特定技术。
- en: Questions
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the two-fold nature of the module concept?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块概念的双重性质是什么？
- en: Is scaling optimization the only advantage of microservices? If not, list some
    further advantages.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务的优势仅仅是扩展优化吗？如果不是，请列出一些其他优势。
- en: What is Polly?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Polly？
- en: What Docker support is offered by Visual Studio?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 提供了哪些 Docker 支持？
- en: What is an orchestrator, and what orchestrators are available on Azure?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是编排器，Azure 上有哪些可用的编排器？
- en: Why is publisher/subscriber-based communication so important in microservices?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么基于发布者/订阅者的通信在微服务中如此重要？
- en: What is RabbitMQ?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 RabbitMQ？
- en: Why are idempotent messages so important?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么幂等消息如此重要？
- en: Further reading
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are links to the official documentation for Azure Service Bus,
    RabbitMQ, and other event bus technologies:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接是 Azure 服务总线、RabbitMQ 和其他事件总线技术的官方文档：
- en: '**Azure Service Bus**: [https://docs.microsoft.com/en-us/azure/service-bus-messaging/](https://docs.microsoft.com/en-us/azure/service-bus-messaging/)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 服务总线**：[https://docs.microsoft.com/en-us/azure/service-bus-messaging/](https://docs.microsoft.com/en-us/azure/service-bus-messaging/)'
- en: '**NServiceBus**: [https://particular.net/nservicebus](https://particular.net/nservicebus)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NServiceBus**：[https://particular.net/nservicebus](https://particular.net/nservicebus)'
- en: '**MassTransit**: [https://masstransit-project.com/](https://masstransit-project.com/)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MassTransit**：[https://masstransit-project.com/](https://masstransit-project.com/)'
- en: '**Brighter**: [https://www.goparamore.io/](https://www.goparamore.io/)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Brighter**：[https://www.goparamore.io/](https://www.goparamore.io/)'
- en: '**RabbitMQ**: [https://www.rabbitmq.com/getstarted.html](https://www.rabbitmq.com/getstarted.html)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RabbitMQ**：[https://www.rabbitmq.com/getstarted.html](https://www.rabbitmq.com/getstarted.html)'
- en: '**EasyNetQ**: [https://easynetq.com/](https://easynetq.com/)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EasyNetQ**：[https://easynetq.com/](https://easynetq.com/)'
- en: 'The following are also links for Polly and Docker:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下也是 Polly 和 Docker 的链接：
- en: 'The documentation for Polly, a tool for reliable communication/tasks, can be
    found here: [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠通信/任务的工具 Polly 的文档可以在这里找到：[https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)
- en: 'More information on Docker can be found on Docker’s official website: [https://docs.docker.com/](https://docs.docker.com/)'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 Docker 的信息可以在 Docker 的官方网站上找到：[https://docs.docker.com/](https://docs.docker.com/)
- en: Learn more on Discord
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里您可以分享反馈、向作者提问以及了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
