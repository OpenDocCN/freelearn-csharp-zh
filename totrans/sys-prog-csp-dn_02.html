<html><head></head><body>
		<div id="_idContainer015">
			<h1 class="chapter-number" id="_idParaDest-43"><a id="_idTextAnchor042"/>2</h1>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>The One Where Speed Matters</h1>
			<p><em class="italic">Writing </em><span class="No-Break"><em class="italic">for performance</em></span></p>
			<p>Most users agree that applications can never be fast enough. Anytime you talk to people about what annoys them in a piece of software, performance, or lack thereof, it is the one thing that gets to the top of <span class="No-Break">the list.</span></p>
			<p>And that makes sense: we are all busy, and we certainly don’t want to spend time waiting for a piece of machinery to catch up with us. It has to be the other <span class="No-Break">way around!</span></p>
			<p>But if you think about it, you’ll realize it is a miracle that computers can do anything at all within a reasonable time. If you think you’re busy, just look at everything computers need to do! You can do the <span class="No-Break">following experiment:</span></p>
			<ol>
				<li>Reboot <span class="No-Break">your computer.</span></li>
				<li><span class="No-Break">Log in.</span></li>
				<li>Start (if you’re using Windows) Task Manager (hint: use the <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <span class="No-Break"><em class="italic">Esc</em></span><span class="No-Break"> combination).</span></li>
				<li>Look at how much stuff is going on in the section <span class="No-Break">background processes.</span></li>
			</ol>
			<p>All of those processes are examples of system programming. They are all there to help the system do its job or to help the user-facing software get things done. And there are a lot of them. These processes all take up a bit of CPU time, a bit of networking, and some memory. Most are dormant and just waiting for something interesting to happen, but they are still there. They take away resources from the <span class="No-Break">user-facing software.</span></p>
			<p>I guess it is pretty clear that system software needs to be as small and as fast as possible so that there are enough resources left for the rest of the system – that is, the part the user cares about. The next chapter deals with making it small (or as memory-efficient <span class="No-Break">as possible).</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics</span></p>
			<ul>
				<li>Why does <span class="No-Break">speed matter?</span></li>
				<li>What is the <strong class="bold">Common Type </strong><span class="No-Break"><strong class="bold">System</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CTS</strong></span><span class="No-Break">)?</span></li>
				<li>What is the difference between value types and <span class="No-Break">reference types?</span></li>
				<li>What has boxing got to do with performance, and what is <span class="No-Break">it anyway?</span></li>
				<li>How to choose the right data structures and algorithms to be as fast <span class="No-Break">as possible</span></li>
				<li>How do strings work and how can we make <span class="No-Break">them faster?</span></li>
				<li>What is unsafe code and how can we deal with <span class="No-Break">it safely?</span></li>
				<li>Some compiler flags that help speed <span class="No-Break">things up</span></li>
			</ul>
			<p>To summarize, this chapter will show you how to make your systems as fast as possible. So, buckle up; we are about to <span class="No-Break">go fast!</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Technical requirements</h1>
			<p>You will find all the code in this chapter in the following <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter02"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter02</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Setting up the stage</h1>
			<p>So far, we’ve established that we need as much performance as possible to allow the other systems <a id="_idIndexMarker115"/>to do their things. But there are other reasons you might want to optimize <span class="No-Break">your code:</span></p>
			<ul>
				<li><span class="No-Break">Accessibility</span></li>
				<li><span class="No-Break">Hosting costs</span></li>
				<li><span class="No-Break">Planned obsolescence</span></li>
				<li><span class="No-Break">Energy usage</span></li>
			</ul>
			<p>Let’s examine these one <span class="No-Break">by one.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Accessibility</h2>
			<p>Whenever<a id="_idIndexMarker116"/> I mention accessibility to software developers, they usually think about making software useable for people with physical challenges. I like to think a bit broader. Not everybody can afford the latest and fastest hardware. Many people need to make do with older, slower machines. Suppose your code slows that already sluggish machine down. In that case, you might be responsible for these people not being able to use the <span class="No-Break">device anymore.</span></p>
			<p>Other people use shared devices. Often found in institutions, more than one person uses these devices, and everybody adds their software. If your software slows the machine down, it <span class="No-Break">affects everybody.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Hosting costs</h2>
			<p>More <a id="_idIndexMarker117"/>software these days runs in the cloud, in which case you have to pay per usage. If your software requires a lot of horsepower to run, it might increase costs. When added up, every bit of performance loss impacts the monthly cloud <span class="No-Break">provider bill.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Planned obsolescence</h2>
			<p>Machines<a id="_idIndexMarker118"/> have a fiscal lifetime and an economic lifetime. These lifetimes determine when the company decides to replace the device. The fiscal lifetime is easy to calculate: when the organization buys a machine, the accountants tell you in how many years the value is too low to keep it around. They take the purchase price, calculate the depreciation for each year, and make notes of that in their spreadsheets. I’m oversimplifying things here, but I’m not <span class="No-Break">an accountant.</span></p>
			<p>The economic lifetime is harder to calculate. This lifetime is usually when a machine becomes so unusable that it is no longer worth upgrading or investing in. A computer that becomes too slow to be used should be replaced, even if the fiscal lifetime <span class="No-Break">hasn’t expired.</span></p>
			<p>Your software could lead to that happening. If your performance is too low, the organization could write off the machine earlier than desired. And that leads to much e-waste: perfectly good computers get replaced simply because the software was <span class="No-Break">written less-than-perfectly.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Energy usage</h2>
			<p>Using<a id="_idIndexMarker119"/> more CPU power means using more electrical power. You might think it might not be such a big difference, but in the end, all those machines use a lot of energy worldwide. Writing your code as efficiently as possible saves power usage and helps the environment. It’s as simple <span class="No-Break">as that.</span></p>
			<p>Performance can be gained in a lot of places, even in pieces of your code where you deal with the humble integer. Let’s <span class="No-Break">discuss that!</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Which integer is the fastest?</h1>
			<p>Choosing the<a id="_idIndexMarker120"/> right type of integer to use can have an impact on the performance of your system. I wouldn’t worry too much about this: the CLR is pretty good at optimizing your code, and<a id="_idIndexMarker121"/> the <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>) compiler also applies many optimizations. Let’s consider an example. Imagine that we have a <strong class="source-inline">for</strong> loop that iterates over a piece of code. If we have less than 255 iterations, we might be tempted to use a byte. After all, a byte is just 1 byte. If you use an integer, it will be 4 bytes. That is more memory and probably takes longer to <span class="No-Break">process, right?</span></p>
			<p><span class="No-Break">Wrong!</span></p>
			<p>Don’t try to outsmart the compiler. It knows the system a lot better than <span class="No-Break">you do.</span></p>
			<p>Let me <span class="No-Break">show you.</span></p>
			<p>We have the following four lines of <span class="No-Break">C# code:</span></p>
			<pre class="source-code">
var a = byte.MaxValue;
var b = UInt16.MaxValue;
var c = UInt32.MaxValue;
var d = UInt64.MaxValue;</pre>			<p>We set four variables to some values. The following table describes the specifics of <span class="No-Break">each type:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">C# Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Short Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Description</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">MaxValue (Hexadecimal)</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">System.Byte</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">byte</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">A byte</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0xFF</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">System.UInt16</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">ushort</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Unsigned <span class="No-Break">16-bit integer</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0xFFFF</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">System.UInt32</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">uint</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Unsigned <span class="No-Break">32-bit integer</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0xFFFFFFFF</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">System.UInt64</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">ulong</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Unsigned <span class="No-Break">64-bit integer</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0xFFFFFFFFFFFFFFFF</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1: Numeric types with their maximum values</p>
			<p>Let’s examine what<a id="_idIndexMarker122"/> the compiler makes out of it. If you want to see this for yourself, create a new C# console program in Visual Studio (using .NET 7 or .NET 8), use top-level statements, and copy those four lines. Then, set a breakpoint on the first line and run it. As soon as you hit the breakpoint, press <em class="italic">Ctrl</em> + <em class="italic">K</em>, <em class="italic">G</em>. Doing that opens <span class="No-Break">the disassembler.</span></p>
			<p>You’ll get something like this (I’ve cut some of the code that isn’t that useful to <span class="No-Break">us here):</span></p>
			<pre class="source-code">
01: # var a = byte.MaxValue;
02: 00007FFF956076EE  mov         dword ptr [rbp+3Ch],0FFh
03: # var b = UInt16.MaxValue;
04: 00007FFF956076F5  mov         dword ptr [rbp+38h],0FFFFh
05: # var c = UInt32.MaxValue;
06: 00007FFF956076FC  mov         dword ptr
[rbp+34h],0FFFFFFFFh
07: # var d = UInt64.MaxValue;
08: 00007FFF95607703  mov         eax,0FFFFFFFFh
09: 00007FFF95607708  cdqe
10: 00007FFF9560770A  mov         qword ptr [rbp+28h],rax</pre>			<p>I know I promised we wouldn’t be doing assembly programming, but you need to know what’s happening if you want your code to run as fast as possible. Let me talk you <span class="No-Break">through it.</span></p>
			<p>Lines 1, 3, 5, and 7 are comment lines that show the C# code that resulted in <span class="No-Break">this assembly.</span></p>
			<p>On line 2, we<a id="_idIndexMarker123"/> can see the code the CPU handles when we want it to set the value to a variable. The actual command is MOV, which means move. It then takes two parameters. The first is the target of the MOV, and the second is the value. There are several types of MOV commands; this particular one moves a DWORD. In Win32, DWORD stands for Double Word, which we know as an unsigned 32-bit integer. We are moving the hardcoded value, <strong class="source-inline">0FFh</strong> (255 in decimal), to <strong class="source-inline">[rbp+3Ch]</strong>. In case you’re wondering, <strong class="source-inline">rbp</strong> is the stack pointer. So, we’re moving our value, <strong class="source-inline">0xFF</strong>, to position 3C on <span class="No-Break">our stack.</span></p>
			<p>Great. We should know that value types go on the stack instead of the heap. Don’t worry if you didn’t realize that. The next chapter is all about memory. For now, just accept that we have two types of memory: a small but fast stack and a slow but huge heap. This byte goes to <span class="No-Break">the stack.</span></p>
			<p>Line 4 moves <strong class="source-inline">0xFFFF</strong> to <strong class="source-inline">[rbp+38h]</strong>. Again, we are moving a <span class="No-Break"><strong class="source-inline">DWORD</strong></span><span class="No-Break"> here.</span></p>
			<p>Line 6 does more or less the same: we move <strong class="source-inline">0xFFFFFFFF</strong> to the stack. Again, it is <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">DWORD</strong></span><span class="No-Break">.</span></p>
			<p>When compiled, a byte, a <strong class="source-inline">UInt16</strong>, and a <strong class="source-inline">UInt32</strong> are considered a <strong class="source-inline">DWORD</strong>. There is no difference between them. If you look at the assembly code, there’s no way of knowing what type the C# intended to use. That means there is no difference in performance here when using an 8-bit byte or a 32-bit unsigned integer. And in case you’re wondering, the signed 32-bit integer looks the same, with the difference that <strong class="source-inline">Int32.MaxValue</strong> is half the value of <strong class="source-inline">UInt32.MaValue</strong>. However, the compiled code is <span class="No-Break">the same.</span></p>
			<p>Look at the code to copy the 64-bit integer to the stack. That works quite differently. On line 8, we move <strong class="source-inline">0xFFFFFFFF</strong> to a register (a register is a special piece of memory inside the CPU that holds temporary variables). Then, we call CDQE. That copies whatever is in the EAX register (which can hold 32 bits) into the <strong class="source-inline">RAX</strong> register, which can hold 64 bits. Then, on line 10, it copies the first 32 bits of the contents to <span class="No-Break">the stack.</span></p>
			<p>As you can see, setting a variable to <strong class="source-inline">Int64.MaxValue</strong> involves a lot more work than the other three variants. It is considerably slower: the CPU has to do a <span class="No-Break">lot more.</span></p>
			<p>However – and<a id="_idIndexMarker124"/> this is important – this might not always be the case. This is what happens on my modern, beefy 64-bit Windows 11 machine. Things might be completely different on a low-powered Raspberry PI running Linux on an ARM processor. And that is one of the challenges of system programming: you must know how types behave to have the highest <span class="No-Break">possible performance.</span></p>
			<p>I think it’s time to discuss <span class="No-Break">the CTS.</span></p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>The CTS</h1>
			<p>The CTS is a set <a id="_idIndexMarker125"/>of rules describing the types that are used in a .NET program. That’s it. Nothing binary is going on; it is just a set of rules – a standard that compilers, languages, and the runtime must <span class="No-Break">adhere to.</span></p>
			<p>There are several different languages available on .NET Framework. Microsoft has C#, VB.Net, and F#. They also offer J#, a Java variant running on the CLR. You can also write .NET programs in C or C++. Other vendors also provide languages and tools you can choose from. Think of IronPython or Delphi.NET, <span class="No-Break">for instance.</span></p>
			<p>All these languages must stick to the rules. The compiler must emit IL code (again, IL looks like assembly but isn’t). The JIT compiler then takes the IL to create machine code the CPU can understand <span class="No-Break">and run.</span></p>
			<p>There is a subset of the rules in the CTS that are called the <strong class="bold">Common Language Specification</strong> (<strong class="bold">CLS</strong>). These <a id="_idIndexMarker126"/>are the rules you, as a language designer, must follow to ensure your code and components can be used by other languages. However, you can choose not to follow those rules. That means other languages cannot easily use your code. That usually isn’t a big problem, but it might be something to be aware of when you’re designing a new .NET language. For instance, the CLS says the publicly available types cannot be unsigned integers. You will get a warning if you write code with a Uint16 as a public property and mark your code with the <strong class="source-inline">[assembly: </strong><span class="No-Break"><strong class="source-inline">CLSCompliant(true)]</strong></span><span class="No-Break"> attribute.</span></p>
			<p>Our aim here is not to design languages, so we aren’t going to dive deeper <span class="No-Break">into this.</span></p>
			<p>All types used in .NET languages must adhere to the CTS rules. This book is not about learning to program in .NET. Still, knowing about the inner workings is crucial if you’re a system programmer. We will cover just the highlights of the <span class="No-Break">CTS here.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Value types and reference types</h2>
			<p>Later in this chapter, I’ll discuss value and reference types<a id="_idIndexMarker127"/> in a lot <a id="_idIndexMarker128"/>more detail. Here, I will simply say that value types hold their values directly. In contrast, reference types are pointers that point to a value somewhere else <span class="No-Break">in memory.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Classes and structs</h2>
			<p>.NET-based languages are supposed to be object-oriented. From this, it follows that the languages should support classes. These classes also have to have <span class="No-Break">specific characteristics.</span></p>
			<p><strong class="bold">Classes</strong> should <a id="_idIndexMarker129"/>have visibility. They can be public, internal, protected, or private. We all know what those <span class="No-Break">classifiers mean.</span></p>
			<p>Classes have methods, properties, fields, delegates, and so on. These items can be private, protected, or public. You probably already know all of this; I don’t have to explain what this <span class="No-Break">all is.</span></p>
			<p>However, a lot of developers struggle<a id="_idIndexMarker130"/> with <strong class="bold">structs</strong>. To the casual observer, they are more or less the same. And yes, they are indeed similar. They can both have methods, properties, fields, and so on. They can both implement interfaces. And they can both have <span class="No-Break">static members.</span></p>
			<p>The differences between classes and structs are more interesting. First, a class instance lives on the heap, and you will get a pointer that you store in the stack. However, a struct lives on <span class="No-Break">the stack.</span></p>
			<p>Since the variable that “holds” the class is the pointer to the heap memory where the data is stored, that variable can be null. In that case, it points to nothing; it is just a placeholder for a future instance of <span class="No-Break">that class.</span></p>
			<p>A struct cannot be null. There is an edge case: nullable types such as <strong class="source-inline">MyStruct?</strong> can be null, but that is the whole point of nullable types. Structs cannot inherit from each other. They can implement interfaces, though, just like classes can. That also means you cannot have an “abstract” or “sealed” struct. Those two modifiers are meant for classes that must be inherited. Since we cannot inherit from structs, this doesn’t <span class="No-Break">make sense.</span></p>
			<p>Looking at this, you might think that a class is a better choice: there are only a few downsides and a lot of upsides in using them over structs. And you’re not wrong. But structs have one significant advantage over classes: they are initialized on the stack, not the heap. And as I said previously, the stack is way faster than the heap. Since we aim for maximum performance, structs are used much more in our applications than <span class="No-Break">in others.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Floating-point numbers</h2>
			<p>We<a id="_idIndexMarker131"/> already saw that it doesn’t matter what kind of integer you use for most cases. UInt64, Int64, UInt128, and Int128 are generally slower than the other types, so only use them when you have thought it through and decided you <span class="No-Break">need them.</span></p>
			<p>Things are a bit different for floating-point numbers, however. We have three floating-point types in the CLS and, thus, in C#. Please look at the following table to see which ones <span class="No-Break">they are:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">C# Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">float</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">System.Single</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>32-bit <span class="No-Break">single-precision floating-point</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">double</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">System.Double</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>64-bit <span class="No-Break">double-precision floating-point</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">decimal</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">System.Decimal</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The 128-bit decimal type is more precise but has a smaller range than <span class="No-Break">a double</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.2: Floating-point types</p>
			<p>Which type you choose depends on your scenarios. You must select a decimal over a float if you need more precision. That would be obvious. But things are slightly more complicated if you don’t need the 128-bit precision a decimal <span class="No-Break">gives you.</span></p>
			<p>On a 64-bit machine, the double (<strong class="source-inline">System.Double</strong>) is the fastest floating-point number. The CPU can understand this natively, so no conversions are needed. Performance-wise, this is your best choice. However, a float (<strong class="source-inline">System.Single</strong>) is more memory efficient. However, this is only true on a 64-bit machine. If you’re targeting other platforms, the results might be different. For instance, if you want to run your code on an ARM-based device such as a Raspberry Pi, you will find that the CPU is optimized for the float type. So, you would be better off using a single-precision variety if you care about performance. Again, if your use case needs a higher precision, please use one of the other types. They are here for a reason, <span class="No-Break">after all.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Where types live – the difference between value types and reference types</h1>
			<p>Types in the CTS <a id="_idIndexMarker132"/>can be either a value type or a reference type. It is essential to know the difference between these two options. Value types operate on the stack, while reference types live on the heap. Stuff residing on the stack is usually much faster than what happens on <span class="No-Break">the heap.</span></p>
			<p>From this, you would think using value types on the stack is the best way to get your desired sweet performance. Unfortunately, that is not how things work. The reference types are there for a reason, and they can give you significant performance improvements if <span class="No-Break">used correctly!</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>The stack and the heap</h2>
			<p>Before discussing <a id="_idIndexMarker133"/>the difference between value types and reference types, we need to quickly look at the difference between the stack and the heap. I have already mentioned that the stack is faster than the heap but smaller. This is true, but there’s a bit more <span class="No-Break">to this.</span></p>
			<p>The following table shows the differences between the two types <span class="No-Break">of memory:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Feature</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Stack</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Heap</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Allocation/Deallocation</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Fast, <span class="No-Break">compile time</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Slow, runtime</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Lifespan</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Limited <span class="No-Break">to scope</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Beyond scope</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Size Limitation</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Smaller, fixed-size</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Larger, <span class="No-Break">dynamic size</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Data Types</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Value <span class="No-Break">types (usually)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Reference types</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Behavior</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Deterministic</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Non-deterministic</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Fragmentation</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Possible</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Thread</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Thread-specific</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Shared <span class="No-Break">between threads</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.3: Differences between stack and heap memory</p>
			<p>The memory <a id="_idIndexMarker134"/>allocation for stack variables is done at compile time, and the memory is pushed on and popped off the stack. This makes allocation and deallocation extremely fast. For heap variables, the memory is allocated dynamically <span class="No-Break">at runtime.</span></p>
			<p>However, the lifespan of variables on the stack is limited to the function’s scope or the block of code. Once your code no longer needs that variable, such as because you reached the end of a <strong class="source-inline">for</strong> loop, the memory for this variable is automatically freed. For the heap, it is up to you or the garbage collector to get rid of the memory when <span class="No-Break">it’s unnecessary.</span></p>
			<p>The stack is smaller, and you are much more likely to run out of stack memory than heap memory. Heap memory can be huge, especially compared to <span class="No-Break">stack memory.</span></p>
			<p>If you’re wondering how big that stack is, the answer is, “It depends.” You can even specify it yourself. Since the stack is tied to a thread, you can set the stack size when working with <span class="No-Break">new threads:</span></p>
			<pre class="source-code">
// Create a new thread with a stack size of 1 MB
var thread = new Thread(new ThreadStart(ThreadMethod), 1024 * 1024);
thread.Start();</pre>			<p>Here, we created a new thread and gave it a <strong class="source-inline">1 MB</strong> stack. It’s easy to determine this! If you want to limit the amount of memory a thread uses, you can estimate how much you need and allocate it <span class="No-Break">that way.</span></p>
			<p>On a side note, most developers know of <a href="https://StackOverflow.com">https://StackOverflow.com</a>. Strangely enough, I have met many developers who have no idea where that name <span class="No-Break">comes from.</span></p>
			<p>When you create a thread with a given stack size but try to use more memory than available, you get a <strong class="source-inline">StackOverflowException</strong> error. That is where that name <span class="No-Break">comes from.</span></p>
			<p>Let me show you. Oh – and don’t use this in production code. This sample is just for <span class="No-Break">illustrative purposes:</span></p>
			<pre class="source-code">
try
{
    Recur();
}
catch (StackOverflowException e)
{
    Console.WriteLine($"Oh oh.. {e.Message}");
}
return;
static void Recur()
{
    Recur();
}</pre>			<p>The <a id="_idIndexMarker135"/>preceding code calls a recursive function that does one thing: it calls itself. When you call a function or a method, the system stores the address to return to when the function ends. The system stores this return address on the stack. After all, this is short-lived and needs to be fast. You want to continue with your regular flow after the <span class="No-Break">function call.</span></p>
			<p>But this code does nothing except call a function repeatedly and never returns from it. Thus, the return address gets added to the stack thousands of times until the memory runs out, and you get that famous <span class="No-Break"><strong class="source-inline">StackOverflowException</strong></span><span class="No-Break"> error.</span></p>
			<p>If you want to experiment with this, run the preceding code in a separate thread and give it different stack sizes. Doing this will give you an idea of how significant an impact having the correct stack <span class="No-Break">size has.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Boxing and unboxing</h1>
			<p>So far, things <a id="_idIndexMarker136"/>look pretty straightforward. Value types live in the stack; reference types live on the heap. An integer is a value type; thus, you have it on the stack. A class you define<a id="_idIndexMarker137"/> is on the heap since that is a reference type. If you want your class to be faster, you can turn it into a struct and have it available quicker since it goes on the stack. You might be thinking this is easy, but you’d be wrong. Things can be a lot more complicated <span class="No-Break">than that.</span></p>
			<p>Let’s look at our good friend, the integer. An integer is a whole number, so it has no decimal point. As we saw earlier, we have a couple of variations of the integer. We have the 16-bit, the 32-bit, the 64-bit, and even a 128-bit version. And we have them in signed and unsigned versions. We even have a byte: this is technically not an integer, but since it compiles to a DWORD, we can have it in the same category. An integer is a value type, so it lives on the stack. However, if you look at <em class="italic">Table 2.1</em>, you’ll see that the official name of an integer is <strong class="source-inline">System.Int32</strong>. I don’t know about you, but that looks like a class or a <span class="No-Break">struct name.</span></p>
			<p>A struct still lives on the stack, but it is less performant than you might expect compared to a simple integer. Luckily, the compiler helps us with this. As we saw earlier, the compiler turns our integers into DWORDs, so there is no performance penalty. But sometimes, things work differently. So, we need to talk about boxing <span class="No-Break">and unboxing.</span></p>
			<p>C# is a genuine object-oriented language. That means everything is an object, and all descend from a base class. At the top level, one base class is the ancestor of all other classes. That is <strong class="source-inline">System.Object</strong>. Our integer is no different: the <strong class="source-inline">System.Int32</strong> struct derives from the <strong class="source-inline">System.ValueType</strong> class, which, in turn, is a descendant of <strong class="source-inline">System.Object</strong>. So, we still follow the rules of object orientation. Still, there seems to be a mix of classes and structs here. Don’t worry; these are semantics, and the compiler deals with them <span class="No-Break">when needed.</span></p>
			<p>“Dealing with” sometimes means that the runtime converts value types into reference types or vice versa. That is what we call boxing <span class="No-Break">and unboxing.</span></p>
			<p>Boxing happens when the system converts a value type into a reference type. Converting a reference type into a value type is known as unboxing. Think of it as putting our value type in a box, in the shape of a class, or getting it out again if you go the <span class="No-Break">other way:</span></p>
			<pre class="source-code">
int i = 42;
object o = i; // Boxing
int j = (int)o; // Unboxing</pre>			<p>The first line declares <a id="_idIndexMarker138"/>a simple 32-bit integer, and we give it a value. We saw this<a id="_idIndexMarker139"/> previously; this is a relatively simple and fast instruction. In assembly, we move a hardcoded value into a DWORD position on <span class="No-Break">the stack.</span></p>
			<p>We want to make a copy of it, but this time, we use an object instead of an integer. Since <strong class="source-inline">System.Int32</strong> is derived from <strong class="source-inline">System.Object</strong> (with <strong class="source-inline">System.ValueType</strong> in between), you wouldn’t expect this to be that much work. In the end, we still have an integer. But things are more complicated. Again, let’s have a look at the assembly code. To be clear, you don’t need to know assembly, but it is easier to understand how to get the most performance if you know what happens under <span class="No-Break">the hood.</span></p>
			<p>Here, <strong class="source-inline">object o = i</strong> translates to quite a lot <span class="No-Break">of code:</span></p>
			<pre class="source-code">
1: object o = i; // Boxing
2: 00007FF9625E76F1  mov         rcx,7FF96254E8D0h
3: 00007FF9625E76FB  call        CORINFO_HELP_NEWSFAST (07FF9C20D0960h)
4: 00007FF9625E7700  mov         qword ptr [rbp+20h],rax
5: 00007FF9625E7704  mov         rdx,qword ptr [rbp+20h]
6: 00007FF9625E7708  mov         ecx,dword ptr [rbp+3Ch]
7: 00007FF9625E770B  mov         dword ptr [rdx+8],ecx
8: 00007FF9625E770E  mov         rdx,qword ptr [rbp+20h]
9: 00007FF9625E7712  mov         qword ptr [rbp+30h],rdx</pre>			<p>I won’t explain everything that’s happening here, but there are a lot of moving parts here. Line 3, however, is the important one: <strong class="source-inline">CORINFO_HELP_NEWSFAST</strong> is a method in the CLR that allocates memory on the heap. Yes, the heap. Not the stack. This is what we call a very expensive operation: it takes a relatively long amount of time. After that, much copying occurs, all of which <span class="No-Break">takes time.</span></p>
			<p>Compare this with copying that integer variable to another integer without going <span class="No-Break">through boxing:</span></p>
			<pre class="source-code">
1: int j = i;
2: 00007FF9625B7716  mov         eax,dword ptr [rbp+3Ch]
3: 00007FF9625B7719  mov         dword ptr [rbp+2Ch],eax</pre>			<p>This <a id="_idIndexMarker140"/>assembly code takes the value of what’s in the <strong class="source-inline">i</strong> variable (in the <strong class="source-inline">[rbp+0x3C]</strong> memory location) and moves it to the eax register. Then, it transfers that register to <strong class="source-inline">[rbp+0x2C]</strong>, where the new variable, <span class="No-Break"><strong class="source-inline">j</strong></span><span class="No-Break">, is.</span></p>
			<p>This was just<a id="_idIndexMarker141"/> two quick move calls, from the stack to the register (blazingly fast) and from the register back to the stack. That hardly <span class="No-Break">takes time.</span></p>
			<p>Going from the heap to the stack seems to be quicker since less coding is going on. Here, <strong class="source-inline">int j = (int)o</strong> leads to unboxing. The assembly for that code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
1: int j = (int)o; // Unboxing
2: 00007FF9625F7726  mov         rdx,qword ptr [rbp+30h]
3: 00007FF9625F772A  mov         rcx,7FF96255E8D0h
4: 00007FF9625F7734  call        qword ptr [CLRStub[MethodDescPrestub]@00007FF9625EB8D0 (07FF9625EB8D0h)]
5: 00007FF9625F773A  mov         eax,dword ptr [rax]
6: 00007FF9625F773C  mov         dword ptr [rbp+2Ch],eax</pre>			<p>This assembly code doesn’t have that very expensive call to allocate memory. This makes sense: the stack doesn’t require this. The stack has a fixed amount of memory, so you can use it if needed. If you run out of it, you get the <strong class="source-inline">StackOverflow</strong> exception we looked at earlier. The rest is just moving data about. There’s still much more code here than what we saw when we copied two integers. Still, it doesn’t look that bad, <span class="No-Break">does it?</span></p>
			<p>Don’t be fooled: if we decide to use the <strong class="source-inline">j</strong> variable from now and not use <strong class="source-inline">o</strong> anymore, it can be removed from the heap. The garbage collector takes care of that, so you don’t have to worry about it. But the garbage collector also comes with a lot of performance loss. The garbage collector is the topic of another chapter but be assured it can be a huge performance drain. This isn’t obvious from this bit of code. There are hidden <span class="No-Break">costs involved.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Hidden boxing and unboxing</h2>
			<p>Copying a <a id="_idIndexMarker142"/>value type, such as an integer, to a reference type leads to boxing. If you can avoid that, you should do so. But sometimes, boxing and unboxing happen when<a id="_idIndexMarker143"/> you don’t expect it. Look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
internal void DoSomething()
{
    int i = 42;
    DoSomethingElse(i);
}
internal void DoSomethingElse(object o)
{
    Console.WriteLine(o.ToString());
}</pre>			<p>Here, we declare an integer, <strong class="source-inline">i</strong>, in <strong class="source-inline">DoSomething()</strong>. Then, we call <strong class="source-inline">DoSomethingElse()</strong> with that integer. The original author of <strong class="source-inline">DoSomethingElse </strong>was trying to write the code so it could be reused. So, they decided to accept <strong class="source-inline">System.Object</strong> as a parameter. Since everything is, in the end, derived from that, this seems like a good idea. But it isn’t. Here, <strong class="source-inline">i</strong> will be boxed before being passed to <strong class="source-inline">DoSomethingElse</strong>, along with the performance penalty that happens <span class="No-Break">when boxing.</span></p>
			<p>It would be better if the developer wrote the method <span class="No-Break">like this:</span></p>
			<pre class="source-code">
internal void DoSomething()
{
    int i = 42;
    DoSomethingElse(i);
}
internal void DoSomethingElse&lt;T&gt;(T o)
{
    Console.WriteLine(o.ToString());
}</pre>			<p>Here, instead <a id="_idIndexMarker144"/>of accepting an object, we take a generic type. Since we pass it as an integer, the compiler understands that this is a value type and doesn’t convert it into <a id="_idIndexMarker145"/>an object. No boxing is happening here. This code is a lot faster than the <span class="No-Break">previous version.</span></p>
			<p>How about this line <span class="No-Break">of code?</span></p>
			<pre class="source-code">
int i = 42;
string message = "Hello Integer " + i;</pre>			<p>It looks pretty simple. But again, boxing is happening here. Before string concatenation can happen, the <strong class="source-inline">i</strong> variable is first boxed to the <span class="No-Break">reference type.</span></p>
			<p>The next one is nice <span class="No-Break">as well:</span></p>
			<pre class="source-code">
var list = new ArrayList();
list.Add(i); // boxing!
int j = (int)list[0]; // unboxing!</pre>			<p>Value types are part of reference types that usually live on the heap. So, they need to be boxed. Getting the values back will then lead <span class="No-Break">to unboxing.</span></p>
			<p>Moving value types to reference types leads to this behavior. Take a look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
IComparable i = 42;</pre>			<p>This is safe, right? We aren’t converting; we’re just declaring that we are interested in part of the integer that belongs to the <strong class="source-inline">IComparable</strong> interface. The <strong class="source-inline">System.Int32</strong> struct implements a lot of interfaces, and this happens to be one of them. Still, it is a struct, so all should <span class="No-Break">be good.</span></p>
			<p>Let’s have a quick look at the associated assembly for that simple line of <span class="No-Break">C# code:</span></p>
			<pre class="source-code">
1: IComparable i = 42;
2: 00007FF9625E76F1  mov         rcx,7FF96254E8D0h
3: 00007FF9625E76FB  call        CORINFO_HELP_NEWSFAST (07FF9C20D0960h)
4: 00007FF9625E7700  mov         qword ptr [rbp+20h],rax
5: 00007FF9625E7704  mov         rax,qword ptr [rbp+20h]
6: 00007FF9625E7708  mov         dword ptr [rax+8],2Ah
7: 00007FF9625E770F  mov         rax,qword ptr [rbp+20h]
8: 00007FF9625E7713  mov         qword ptr [rbp+30h],rax</pre>			<p>You <a id="_idIndexMarker146"/>should recognize this by now, especially the call to <strong class="source-inline">CORINFO_HELP_NEWSFAST</strong>. This is boxing in action. The same happens when using the <strong class="source-inline">IEquatable&lt;int&gt; = 42</strong> line. Although we now use a generic, we still <span class="No-Break">get boxing.</span></p>
			<p>Let’s look at one more example. This one is a <span class="No-Break">bit silly:</span></p>
			<pre class="source-code">
object myString = "some string";
var stuff = true ? 42 : myString;</pre>			<p>Here, we <a id="_idIndexMarker147"/>have a string that we appoint to an object, <strong class="source-inline">myString</strong> (that is not the silly part). Then, we assign something to <strong class="source-inline">stuff</strong>, depending on <strong class="source-inline">true</strong> being true (which it always is; this is the silly part). If <strong class="source-inline">true</strong> is true, we assign <strong class="source-inline">42</strong> to stuff. If not, we copy <strong class="source-inline">myString</strong> to <strong class="source-inline">var</strong>. At first glance, you might expect <strong class="source-inline">stuff</strong> to be of the <strong class="source-inline">int</strong> type since <strong class="source-inline">true</strong> is always true. But that is not how a static-typed language works. It needs to know what type <strong class="source-inline">stuff</strong> is at compile time. The conditional operator, <strong class="source-inline">? :</strong>, expects both sides to be equivalent types. Thus, it decides that one part is an object and can cast the integer literal to an object. Therefore, it boxes that <strong class="source-inline">42</strong> into an object instance, and <strong class="source-inline">stuff</strong> here is another object instance. And there you have it: <span class="No-Break">more boxing.</span></p>
			<p>Boxing and unboxing allow you to mix and match value and reference types. It would be tough to write reusable code otherwise. But be aware of this, and be mindful of the costs associated with boxing and unboxing. It happens in places you might not be aware of. And that results in <span class="No-Break">less-than-stellar performance.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Choosing the right data structures and algorithms</h1>
			<p>Object orientation <a id="_idIndexMarker148"/>is all about having the data and the operations on that data together in a cohesive and loosely coupled structure. That is what classes and structs do: they combine the two. This way, you can define your data structures in a way that makes sense concerning the <span class="No-Break">system’s functionality.</span></p>
			<p>But when speaking<a id="_idIndexMarker149"/> about performance, other factors come into play. Having static classes is usually a code smell that you must avoid. However, they’re fast. You don’t need to instantiate something, resulting in that costly call to allocate heap <a id="_idIndexMarker150"/>memory. And that memory doesn’t need to be cleaned by the garbage <span class="No-Break">collector later.</span></p>
			<p>Of course, if you have member variables for that class, you might as well instantiate it. Ultimately, all that happens is that those variables end up on the heap (with a little bit of housekeeping). The methods themselves are part of your application code and are <span class="No-Break">stored differently.</span></p>
			<p>The BCL also has many classes and data structures you can use to store data. Some of them are better suited for high performance than others. Which one you choose depends on your use case, but I think writing a bit more code is worth it if that means you can use a more <span class="No-Break">efficient class.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Arrays, Lists, and LinkedLists</h2>
			<p><strong class="bold">Arrays</strong>, <strong class="bold">Lists</strong>, and <strong class="bold">LinkedLists</strong> are all structures you can use to store data sequentially. That<a id="_idIndexMarker151"/> data is stored in the heap as well. Yes, you read that correctly. Look at the following two lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
int i = 42;
int[] r = { 42 };</pre>			<p>The first line is a simple assignment. The system copies the hard-coded value of <strong class="source-inline">42</strong> (0x2A in hex) to a DWORD and stores it on the stack. The second line creates a new array, allocates memory for that on the heap, initializes the array, and then copies <strong class="source-inline">42</strong> into the <span class="No-Break">first position.</span></p>
			<p>Read that again and try to see if you can guess if there’s any boxing <span class="No-Break">going on.</span></p>
			<p>You might expect that there is, but there’s no boxing here. The array holds a pointer to a place in the heap that contains individual DWORD values. It knows how long each value is (32 bits, to be precise), so it can move the values directly without changing anything. Also, no unboxing occurs when taking an element from the array and storing it in a local variable. The system copies the DWORD value and leaves it <span class="No-Break">at that.</span></p>
			<p>A list is the same as an array. Internally, the data is stored in an array. However, a list offers the option to resize it dynamically. Next to that, it has some nice methods such as <strong class="source-inline">Add()</strong>, <strong class="source-inline">Remove()</strong>, and <strong class="source-inline">IndexOf()</strong> that can be very helpful. But nothing comes for free: the methods take time to perform, and dynamic reallocation is very expensive in terms of performance. You must judge if you need those extra methods and dynamic reallocation. If you do, use a list. If you can go without, use <span class="No-Break">an array.</span></p>
			<p>There is an<a id="_idIndexMarker152"/> in-between solution: you can use <strong class="source-inline">List&lt;T&gt;</strong> and initialize it with an appropriate size. After all, you must do the same for an array: you need to know how big it is. Doing that causes the <strong class="source-inline">List</strong> class to initialize the array it uses internally to that exact size, and no reallocations happen – unless, of course, you find out you need more room. But that’s great; you don’t run out of memory. Yes, you get the performance penalty in that case, but that’s okay. If you pre-initialize the <strong class="source-inline">List</strong> class, the performance is almost identical to the pure, <span class="No-Break">basic array.</span></p>
			<p>The <strong class="source-inline">LinkedList</strong> class has some nice features. It is a double-linked list of items, which means each item is accompanied by a pointer to the next and the previous object. This means more data is needed to store things: we cannot just store the items themselves, but the system must also add those pointers. This results in slower behavior: those pointers must also be calculated and copied. So, you might think <strong class="source-inline">LinkedList</strong> is wrong when <span class="No-Break">considering performance.</span></p>
			<p>However, <strong class="source-inline">LinkedList</strong> might<a id="_idIndexMarker153"/> be a great choice if your use case requires insertions and removals. Inserting an item simply means storing the object and adjusting some pointers. In an array or list, inserting would mean moving everything up one place in the internal array when you want something to sit in <span class="No-Break">the middle.</span></p>
			<p>Again, use your judgment. If you can, use arrays (or pre-initialized lists), go for the uninitialized list, and only then look <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">LinkedLists</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Stacks and queues</h2>
			<p><strong class="bold">Stacks</strong> and <strong class="bold">queues</strong> look <a id="_idIndexMarker154"/>very similar. They are more or less similar performance-wise, with one big<a id="_idIndexMarker155"/> difference: a stack is fast if you need to access the latest added items, whereas a queue is very fast when you need quick access to the items in the order they were entered. In other words, a stack is <a id="_idIndexMarker156"/>optimized for <strong class="bold">last in, first out</strong> (<strong class="bold">LIFO</strong>) scenarios, while a queue <a id="_idIndexMarker157"/>is better in <strong class="bold">first in, first out</strong> (<span class="No-Break"><strong class="bold">FIFO</strong></span><span class="No-Break">) scenarios.</span></p>
			<p>However, your code runs faster if you can think of a way to use a stack instead of a queue. A stack is slightly more efficient than a queue in handling its work, at least enough to make it worth rewriting <span class="No-Break">your code.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>HashSets and lists</h2>
			<p>A <strong class="bold">HashSet</strong> and<a id="_idIndexMarker158"/> a list are different types with different behaviors, but there are cases when you might want to swap your list for a <strong class="source-inline">HashSet</strong>. A <strong class="source-inline">HashSet</strong> can be efficient when you’re adding, removing, or looking <span class="No-Break">up items.</span></p>
			<p>A <strong class="source-inline">HashSet</strong> has one significant advantage over a list concerning performance: a HashSet has a constant-time average complexity for add, delete, and search operations. A list, however, has a linear-time search complexity. In everyday English, a HashSet always takes the same time to look up items, no matter how many elements it contains. A list needs more search time when more items are added <span class="No-Break">to it.</span></p>
			<p>But beware: a constant time means the time doesn’t change. This doesn’t imply a <strong class="source-inline">HashSet</strong> is faster! Quite the contrary: a <strong class="source-inline">HashSet</strong> can be pretty slow. And that makes sense: before an item is added to the <strong class="source-inline">HashSet</strong>, it needs to calculate the unique hash for that item. That hash is the key that’s used to store the object’s position. And then, it has to check if an object with that hash has already <span class="No-Break">been added.</span></p>
			<p>Of course, once this has been done, looking up an item is very quick: it needs to have the hash, and then it can find it easily. Also, when you have one of these two collections and need to add an item, the HashSet is faster than the list in <span class="No-Break">many cases.</span></p>
			<p>As with most of these cases, look at your requirements and try to do a couple of benchmark tests to see what you can <span class="No-Break">use best.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>SortedList, SortedDictionary, and Dictionary</h2>
			<p><strong class="bold">SortedList</strong>, <strong class="bold">SortedDictionary</strong>, and <strong class="bold">Dictionary</strong> all store their data as key-value pairs. You need<a id="_idIndexMarker159"/> something to identify the item and store the key separately from the object. This <a id="_idIndexMarker160"/>way of working looks<a id="_idIndexMarker161"/> like working with the <strong class="source-inline">HashSet</strong>, but the big difference is that you can retrieve the items by its key in a <strong class="source-inline">Dictionary</strong>. You can retrieve the data in the <strong class="source-inline">HashSet</strong>, but you must use a <strong class="source-inline">foreach</strong> statement to get them all or a <strong class="source-inline">Linq</strong> statement such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Where()</strong></span><span class="No-Break">.</span></p>
			<p>The keys in the <strong class="source-inline">SortedLis</strong>t, <strong class="source-inline">SortedDictionary</strong>, and <strong class="source-inline">Dictionary</strong> must be unique. If your use case allows for that, these collections can do wonders, but only if you choose the right one. The following table compares these three types in terms of <span class="No-Break">their performance:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Property</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Dictionary</strong></span><strong class="bold">
&lt;</strong><span class="No-Break"><strong class="bold">TKey, TValue&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">SortedList</strong></span><strong class="bold">
&lt;</strong><span class="No-Break"><strong class="bold">TKey, TValue&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">SortedDictionary &lt;TKey,TValue&gt;</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Underlying <span class="No-Break">data structure</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Hash table.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Array for keys, array for values. Keys <span class="No-Break">are sorted.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Balanced binary <span class="No-Break">search tree.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Ordering</span></p>
						</td>
						<td class="No-Table-Style">
							<p>No ordering <span class="No-Break">of elements.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Elements are sorted <span class="No-Break">by key.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Elements are sorted <span class="No-Break">by key.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Insertion</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(1</em>) average <span class="No-Break">time complexity.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(n</em>) time complexity since it might need to shift elements to <span class="No-Break">maintain order.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(log n)</em> <span class="No-Break">time complexity.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Deletion</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(1)</em> average <span class="No-Break">time complexity.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(n)</em> time complexity, for the same reason <span class="No-Break">as insertion.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(log n)</em> <span class="No-Break">time complexity.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Lookup</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(1)</em> average <span class="No-Break">time complexity.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(log n)</em> <span class="No-Break">time complexity.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">O(log n)</em> <span class="No-Break">time complexity.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Memory</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Generally less memory efficient than SortedList, but better <span class="No-Break">than SortedDictionary.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>More memory efficient than SortedDictionary since it uses arrays for <span class="No-Break">the keys.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Generally <span class="No-Break">less memory-efficient.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Use-case</span></p>
						</td>
						<td class="No-Table-Style">
							<p>When you don’t want ordering but want fast insertions, deletions, <span class="No-Break">and lookups.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>When you have a relatively small dataset that you want to keep sorted and you will be doing lots <span class="No-Break">of lookups.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>When you have a larger dataset that you want to keep sorted, and you need faster insertions and deletions than <span class="No-Break">SortedList offers.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.4: Key-based collections</p>
			<p>Again, check your requirements and benchmarks to see what works best <span class="No-Break">for you.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Dictionary or last of tuples/objects</h2>
			<p>A <strong class="bold">List&lt;Tuple&gt;</strong> and a <strong class="bold">Dictionary</strong> are different things, but with some rewrites, you could use both to achieve <span class="No-Break">your goal.</span></p>
			<p>The lookup<a id="_idIndexMarker162"/> speed in<a id="_idIndexMarker163"/> the <strong class="source-inline">Dictionary</strong> is very fast. Since you look for the key instead of the actual item, you can achieve a much better performance than with the list, where you have to iterate through the whole list to find what you need. Also, insertion and deletion are fast and constant when using <span class="No-Break">a Dictionary.</span></p>
			<p>However, with a <strong class="source-inline">Dictionary</strong>, the keys need to be unique. With a list, this is not necessary. Again, with some rewrites, you might be able to use a <strong class="source-inline">Dictionary</strong> instead of a list and benefit from some highly-needed <span class="No-Break">performance gains.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>For versus ForEach</h2>
			<p><strong class="bold">ForEach</strong> is amazing. It helps us write our code so much faster. However, it can also slow down <span class="No-Break">our code.</span></p>
			<p><strong class="source-inline">ForEach</strong> is <a id="_idIndexMarker164"/>so helpful that the people who built the compiler added all sorts of optimizations. ForEach does lots of work: it gets the enumerator and then enumerates through the collection using methods such as <strong class="source-inline">MoveNext()</strong>. They all take time, and you would think that it is much slower than using a <strong class="source-inline">for</strong> loop. However, these optimizations make the difference negligible when using For or ForEach on an array <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">List&lt;T&gt;</strong></span><span class="No-Break">.</span></p>
			<p>But suppose you use your own collection where you have implemented <strong class="source-inline">IEnumerable&lt;T&gt;</strong> and <strong class="source-inline">IEnumerator&lt;T&gt;</strong>. In that case, chances are the C# team did not optimize for that in the compiler. That might result in a slower loop than a regular <span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break"> loop.</span></p>
			<p>As always, benchmark whether using the much more readable ForEach is better than a regular <span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break"> loop.</span></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Strings</h1>
			<p>In the old<a id="_idIndexMarker165"/> days, strings used to be simple. You identified the length needed to store a sentence, allocated memory, and copied each character’s ASCII values in a single row. Then, you put a 0 (zero) at the end, and you were done. Easy. But then you realized you needed something more dynamic as you were unsure how long the string would be. So, you wrote code to change the buffer required to store it. You also realized that you needed to have some operations on those characters. For instance, you might have wanted to know how long the string was and not have to count the characters every time, or maybe you wanted to convert all characters into uppercase. So, you wrote code for that as well. At that point, you had some data in the form of characters (with the zero at the end) and some methods on that data. That is the definition of a class, so in C++, you write a <span class="No-Break"><strong class="source-inline">String</strong></span><span class="No-Break"> class.</span></p>
			<p>Things got even more complicated when you realized that other cultures used other characters. Luckily, others also realized this, so<a id="_idIndexMarker166"/> they created the <strong class="bold">Unicode standard</strong>. But now, instead of storing a single byte per character, you must store a Unicode character. And that can be anything from 8 bits (in UTF-8) to 4 bytes. Then, you learned that although a single character can take 32 bits, that is technically incorrect: that applies to code points. A code point usually <em class="italic">is</em> the character, but sometimes, it isn’t. In those situations, the character you want to display has multiple code points in the string. That’s when most people <span class="No-Break">give up.</span></p>
			<p>The good news is that you no longer have to worry about that since we have the <strong class="source-inline">System.String</strong> class in .NET. It takes care of all of those details, and they look deceivingly simple. Assigning a sentence to an instance of that <strong class="source-inline">String</strong> class is as simple as the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
string someMessage = "Hello, World!";
string theSameEmoji = "\U0001F600";
string someEmoji = "😀";</pre>			<p>The first line assigns <strong class="source-inline">"Hello, World!"</strong> to the <strong class="source-inline">someMessage</strong> variable. When we do this, the compiler generates all the code necessary to create an instance of the <strong class="source-inline">System.String</strong> class and initializes it with the <span class="No-Break">correct text.</span></p>
			<p>The following two lines contain the same Unicode characters: a friendly smiley. The first uses the Unicode character, while the second uses the actual character. Yes, this is <span class="No-Break">valid C#!</span></p>
			<p>Strings <a id="_idIndexMarker167"/>are reference types, so they live on the heap. We learned that the heap is slower than the stack earlier, but we have no choice in this case. The pointer is copied when we copy a reference type to a new variable. This means we have two variables pointing to the same data structure. This also happens when we copy a string: a new pointer is made and points to that class’s <span class="No-Break">same instance.</span></p>
			<p>Strings are immutable. You cannot change the contents of a string. If you do that, the CLR creates a new string, and the old one is ready to be garbage collected. Again, this might lead to unwanted <span class="No-Break">performance issues.</span></p>
			<p>There are some other things we must consider when talking about string performance. Let’s go <span class="No-Break">through them.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Use StringBuilder for concatenation</h2>
			<p>When<a id="_idIndexMarker168"/> talking about string performance, this one gets the most attention. And for good reason: this simple “trick” can help get your application faster. The idea is that when you’re in a loop, do not concatenate strings. Create a <strong class="source-inline">StringBuilder</strong> object and use that. The difference in performance is enormous. And that makes sense: changing a string is impossible, so each time you add to one, a new one is created, the content is copied with the added string on top of it, and the old one <span class="No-Break">is discarded.</span></p>
			<p>Use <strong class="source-inline">StringBuilders</strong> in loops. You can go ahead and just <span class="No-Break">do it.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Interning strings</h2>
			<p>Strings are<a id="_idIndexMarker169"/> interned. If you have a string in your code and the actual text is known at compile time, any other string with the same content will point to the same class. Have a look at <span class="No-Break">this code:</span></p>
			<pre class="source-code">
string str1 = "Hello Systems Programmers";
string str2 = "Hello Systems Programmers";
// Reference equality test
if (Object.ReferenceEquals(str1, str2))
    Console.WriteLine("Both strings point to the same         memory location.");
else
    Console.WriteLine("Strings do not point to the same         memory location.");</pre>			<p>When <a id="_idIndexMarker170"/>you run this code, you will get a message stating that both strings point to the same <span class="No-Break">memory location.</span></p>
			<p>But if you read the contents of both strings from the console, use <strong class="source-inline">Console.ReadLine()</strong>. If you enter the same string twice, they will not be interned. This is because interning happens at <span class="No-Break">compile time.</span></p>
			<p>You could call <strong class="source-inline">String.Intern</strong> yourself. This checks to see if the string you wish to intern is already there, and if so, it makes it point to that instead of having its own copy. This could save a lot of memory, but it has a performance penalty. So, use <span class="No-Break">it wisely.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Use String.Concat or String.Join</h2>
			<p>I said that <a id="_idIndexMarker171"/>you should use <strong class="source-inline">StringBuilder</strong> when joining strings in a loop. But creating a <strong class="source-inline">StringBuilder</strong> object is a bit overkill if you’re outside a loop and only want to add to a string once. In that case, you should use <strong class="source-inline">String.Concat</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">String.Join</strong></span><span class="No-Break">.</span></p>
			<p>Just to be<a id="_idIndexMarker172"/> clear here: if you are looping, use <strong class="source-inline">StringBuilder</strong>. The <strong class="source-inline">StringBuilder</strong> object is the fastest way to concatenate strings. But creating an instance of a <strong class="source-inline">StringBuilder</strong> class takes time (it is a class, thus on the heap). If you only want to add one or two strings to an existing one, <strong class="source-inline">String.Concat</strong> is faster overall than having a <span class="No-Break"><strong class="source-inline">StringBuilder</strong></span><span class="No-Break"> object.</span></p>
			<p>That looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var startString = "Welcome to System ";
var longString = startString.Concat("Programmers!");</pre>			<p>The <strong class="source-inline">String.Join</strong> object is another good way to build up strings. You can use this one when you want to combine a collection of items into one string. The list of items can be anything <a id="_idIndexMarker173"/>since the <a id="_idIndexMarker174"/>CLR calls <strong class="source-inline">ToString()</strong> on them. Here, <strong class="source-inline">ToString()</strong> needs to make sense; otherwise, you’ll get a long list of <span class="No-Break">class names.</span></p>
			<p>It looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
string[] myElements = {"C#", "VB.Net", "F#", "Delphi.Net"};
string result = string.Join(",", myElements);</pre>			<p>Printing <strong class="source-inline">result</strong> will show <strong class="source-inline">C#,VB.Net,F#,Delphi.Net</strong> on <span class="No-Break">your screen.</span></p>
			<p>Be careful what you use as the list of elements. If those are <strong class="source-inline">ValueTypes</strong>, a lot of boxing happens. That negates our performance gain when using the suitable <span class="No-Break">string methods.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Comparison</h2>
			<p>Chances<a id="_idIndexMarker175"/> are that you have to compare strings in your code. There are several ways to improve your performance when doing that. For instance, taking into account a culture takes a lot longer compared to not doing that. If you don’t need a culture-specific check, you should specify that. The same goes for the casing: if you don’t care about the casing when comparing, please don’t use one of the comparisons that take care <span class="No-Break">of that.</span></p>
			<p>There are several ways to compare strings. The most obvious one is the <span class="No-Break">equality operator:</span></p>
			<pre class="source-code">
string a = "my string";
string b = "my string";
var areTheyEqual = a == b; // true</pre>			<p>In this case, there’s no comparison at all. Since the compiler interns the strings, the pointers point to the same data. The equality checks for that and <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>You could also do it <span class="No-Break">like this:</span></p>
			<pre class="source-code">
string a = "my string";
string b = "my string";
var areTheyEqual = a.Equals(b); // true</pre>			<p>This code <a id="_idIndexMarker176"/>does the same thing, with the same caveat concerning the interning. Here, <strong class="source-inline">operator == calls Equals()</strong>, so it shouldn’t be surprising that the results are the same, with the <span class="No-Break">same performance.</span></p>
			<p>Now, look at <span class="No-Break">this code:</span></p>
			<pre class="source-code">
string a = "my string";
string b = "my string";
var areTheyEqual = a.Equals(b,
StringComparison.InvariantCultureIgnoreCase); // true</pre>			<p>This way of comparing is significantly slower than the previous examples. The CLR now has to compare the strings in all their different appearances: in all sorts of cultures and <span class="No-Break">all casings.</span></p>
			<p>This way works brilliantly if you need it, but if you don’t, please omit <span class="No-Break">the options!</span></p>
			<p>I see many people writing this sort <span class="No-Break">of code:</span></p>
			<pre class="source-code">
string a = "my string";
string b = "my string";
var areTheyEqual = a.ToUpper() == b.ToUpper(); // true</pre>			<p>This way of comparing is the worst way of doing this. Calling <strong class="source-inline">ToUpper()</strong> doesn’t convert a string into all uppercase. Instead, it creates a new string with all uppercase characters. Again, strings are immutable, so the runtime creates a new one whenever you change something. Here, we are doing that twice so that we can <span class="No-Break">compare them.</span></p>
			<p>Using <strong class="source-inline">StringComparison.IgnoreCase</strong> is about five times as fast compared to calling <strong class="source-inline">ToUpper()</strong> (or <strong class="source-inline">ToLower()</strong> for <span class="No-Break">that matter).</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Preallocating StringBuilder</h2>
			<p>One final tip: knowing the length of the resulting string when using <strong class="source-inline">StringBuilder</strong> helps <a id="_idIndexMarker177"/>tremendously if you tell that class about that. Preallocating helps optimize the code and reduces many allocations, resulting in <span class="No-Break">better performance.</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Writing unsafe code</h1>
			<p>A word of <a id="_idIndexMarker178"/>warning before we start talking about unsafe code. There is a reason it is called “unsafe.” You could be in for much trouble when you leave <span class="No-Break">safe code.</span></p>
			<p>The CLR checks many things for you when you run your code. For instance, it ensures type safety and ensures you are not playing around with spaces in memory that are not yours to <span class="No-Break">play with.</span></p>
			<p>In the “old” days, when using C++ or C in Windows development, this was the primary source of program crashes. Developers made a slight mistake in their pointer arithmetic and ended up reading or writing memory they had no access to. The operating system immediately killed your process, and you got that dreaded <strong class="source-inline">AccessViolationException</strong> error. This is the ultimate slap on the wrist: the operating system telling you to stay out of someone else’s memory. Sometimes, it would be worse: the operating system might not have caught it, and you messed up the operating system or another program. That could lead to even worse situations: the whole machine <span class="No-Break">could crash.</span></p>
			<p>The safe environment of the CLR in .NET has practically removed that completely. The CLR governs everything you do and ensures you stay in the areas where you are allowed <span class="No-Break">to stay.</span></p>
			<p>You’ve probably realized that this is nice, but checking what’s happening always has a performance hit. Nothing comes for free. We give up some performance in exchange for a <span class="No-Break">stable system.</span></p>
			<p>If you want that performance back, you could tell the CLR to stay out of your way. The CLR will obey and hand over the reins to you. Again, you are on your own and responsible for not messing things up. But things run a bit <span class="No-Break">faster now!</span></p>
			<p>Let’s consider <span class="No-Break">an example.</span></p>
			<p>An array is a pointer to a consecutive list of items. So, <strong class="source-inline">int[1000]</strong> is just a pointer to a long list of a thousand integers, all nicely <span class="No-Break">lined up.</span></p>
			<p>You can access these items in the list by giving the array the index of the item you want. First, the CLR checks if the array has been initialized and not pointing to some weird random place in memory. Then, it checks if your index falls in the range that the CLR allocated for the array. If that checks out, it gets and returns the item for <span class="No-Break">you. Nice.</span></p>
			<p>The following code example iterates through the array and adds up all <span class="No-Break">the values:</span></p>
			<pre class="source-code">
long sum = 0;
for (int i = 0; i &lt; array.Length; ++i)
{
    sum += array[i];
}</pre>			<p>This piece <a id="_idIndexMarker179"/>of code works nicely, but it can be faster. All those checks take time, and we might decide we don’t need them. We tell the CLR to take a break and leave it all <span class="No-Break">to us!</span></p>
			<p>The following snippet shows how to <span class="No-Break">do this:</span></p>
			<pre class="source-code">
unsafe
{
    long sum = 0;
    fixed (int* pArray = array)
    {
        int* pEnd = pArray + array.Length;
        for (int* p = pArray; p &lt; pEnd; p++)
        {
            sum += *p;
        }
    }
}</pre>			<p>We declare the block we want to optimize with the <strong class="source-inline">unsafe</strong> keyword. Everything in that block is now no <span class="No-Break">longer checked.</span></p>
			<p>Then, we retrieve the pointer to the array. We mark it as <strong class="source-inline">fixed</strong>. This keyword means the garbage collector doesn’t move the array until we are done with it. It would be disastrous if the garbage collector moved the array to another place in memory when we accessed it. The <strong class="source-inline">fixed</strong> keyword <span class="No-Break">prevents that.</span></p>
			<p>Then, we get the pointer to the end of the array in memory so that we know when to end. In the <strong class="source-inline">for</strong> loop, we get the pointer to the elements, read the data at that memory position, and add the <span class="No-Break"><strong class="source-inline">sum</strong></span><span class="No-Break"> variable.</span></p>
			<p>This piece <a id="_idIndexMarker180"/>of code works fine. It is also faster than the safe version. But just for fun, mess around a bit with the pointers. Instead of letting it end at the end of the array, let it end at that position plus <strong class="source-inline">0xFFFF</strong>. Now, there is no way to tell what’s going to happen. It might continue reading past the end of the array, getting all those byes and adding them to <strong class="source-inline">sum</strong>. That would mean you are getting the wrong result. It is more likely that you get the <strong class="source-inline">AccessViolationException</strong> error, followed by your program <span class="No-Break">being terminated.</span></p>
			<p>We use unsafe code to improve performance, such as in the preceding example, but also when we need to interact with native libraries written in C/C++. But if you can avoid it without sacrificing performance too much, <span class="No-Break">please do.</span></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Compiler optimizations</h1>
			<p>I have said it <a id="_idIndexMarker181"/>before and will repeat it here: don’t try to outsmart the compiler. The C# compiler is a fantastic piece of software that can do tricks we can’t even think of. But sometimes, we can help the compiler make choices that affect performance in a <span class="No-Break">good way.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Aggressive optimization</h2>
			<p>Look at the<a id="_idIndexMarker182"/> <span class="No-Break">following method:</span></p>
			<pre class="source-code">
private int AddUp(int a, int b)
{
    return a + b;
}</pre>			<p>I am sure you agree that this is not an exciting method. Calling this, however, does take a lot of time: the calling method has to store the return address, move all parameters (the integer values, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>) to the right place, jump to the method, retrieve the parameters, do the actual work, store the return value in the right place, retrieve the return address, jump to that return address, and assign the result to the variable in the <span class="No-Break">calling method.</span></p>
			<p>The compiler <a id="_idIndexMarker183"/>knows this. So, in this particular case, it will probably optimize it and “inline” it. But if you think the compiler doesn’t know about this, you can instruct it to take a closer look at the code and be a bit more aggressive about it. You do that <span class="No-Break">like so:</span></p>
			<pre class="source-code">
[MethodImpl(MethodImplOptions.AggressiveOptimization)]
private int AddUp(int a, int b)
{
    return a + b;
}</pre>			<p>This tells the compiler to be aggressive when optimizing the code. This is a hint to the compiler: there is no guarantee it will do what you ask. But in this case, it will probably honor your request (again, it would likely have done it already) and inline <span class="No-Break">the method.</span></p>
			<p>Inlining means it takes the method’s body and injects it into the calling method directly. So, instead of all this copying and moving I described previously, it will now execute the code inline, as if it is part of the <span class="No-Break">original method.</span></p>
			<p>This is way faster, of course. It also means your original method gets bigger: it now contains that extra bit of code, as do all the other methods that use this <strong class="source-inline">AddUp()</strong> method. It gets copied all over <span class="No-Break">the place.</span></p>
			<p>It is a matter of choice: more performance over less efficient <span class="No-Break">memory usage.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>The optimize flag</h2>
			<p>The compiler can<a id="_idIndexMarker184"/> optimize your code. But it doesn’t always do that. You can<a id="_idIndexMarker185"/> add the <strong class="source-inline">optimize</strong> flag to the compiler to <span class="No-Break">force optimization.</span></p>
			<p>There are several ways to do that. First, you can add it to the command line if you use that to build <span class="No-Break">your code:</span></p>
			<pre class="console">
dotnet build -c Release -property:Optimize=true</pre>			<p>Alternatively, you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">MSBuild</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
msbuild /p:Configuration=Release /p:Optimize=true</pre>			<p>They both achieve the <span class="No-Break">same result.</span></p>
			<p>You could also <a id="_idIndexMarker186"/>set it as an option in your <strong class="source-inline">CSProj</strong> file. The best way to do that is to add it to the <span class="No-Break">project properties:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer014">
					<img alt="Figure 2.1: The project properties showing the Optimize code option" src="image/B20924_03_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: The project properties showing the Optimize code option</p>
			<p>As you can see, you can set <strong class="bold">Optimize code</strong> for <strong class="bold">Debug</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Release</strong></span><span class="No-Break">.</span></p>
			<p>This will add or change the following setting to your <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">csproj</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
  &lt;Optimize&gt;True&lt;/Optimize&gt;
&lt;/PropertyGroup&gt;</pre>			<p>It’s good to know that by default, programs compiled in the <strong class="bold">Debug</strong> configuration have optimizations turned off. In contrast, programs compiled in the <strong class="bold">Release</strong> configuration have it <span class="No-Break">turned on.</span></p>
			<p>When debugging, you are better off using non-optimized code. When releasing, the <span class="No-Break">opposite applies.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Next steps</h1>
			<p>Performance – that was what this chapter was all about. We learned why it is crucial, especially for system programming, to write software that is as fast and efficient <span class="No-Break">as possible.</span></p>
			<p>First, we looked at the BCL and the CLR and saw how the different data types can affect performance, but also that things don’t always behave <span class="No-Break">as expected.</span></p>
			<p>Then, we examined the types in the CTS and identified which types give us the best-performing systems and what to avoid. We spent quite some time in the <strong class="source-inline">Strings</strong> class. We also learned how to rewrite our code so that it uses the best tools this class gives us to make it <span class="No-Break">behave faster.</span></p>
			<p>After, we dove into the dark underworld of unsafe types and saw that they could give us even more performance but with the downside of the possibility of crashing our application, or even our system, in the most <span class="No-Break">spectacular way.</span></p>
			<p>Finally, we looked at ways to help the compiler make our systems even faster. Here, we learned that the compiler is smart enough to make those changes. It’s worth repeating that you shouldn’t try to outsmart the system. You really should only use the unsafe code and compiler tricks if benchmarking shows that you have an issue. Otherwise, leave those two alone. However, they are good tricks to understand if you do <span class="No-Break">need them.</span></p>
			<p>However, better performance often leads to less efficient memory usage. It is a trade-off. Sometimes, it is better to have a more memory-efficient system than it is to have a fast system. Sometimes, you have to mix and match. In the next chapter, we’ll consider memory and cover these aspects in <span class="No-Break">greater detail.</span></p>
		</div>
	</body></html>