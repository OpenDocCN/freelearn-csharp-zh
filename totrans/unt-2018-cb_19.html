<html><head></head><body>
        

                            
                    <h1 class="header-title">Automated Testing</h1>
                
            
            
                
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Generating and running a default test script class</li>
<li>Performing a simple unit test</li>
<li>Parameterizing tests with a data provider method</li>
<li>Unit testing a simple health script class</li>
<li>Creating and executing a unit test in PlayMode</li>
<li>PlayMode testing a door animation</li>
<li>PlayMode and unit testing a player health bar with events, logging, and exceptions</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>For a very simple computer program, we can write code, then run it, entering a variety of valid and invalid data, and see whether the program behaves as we expect it to. This is known as a code-then-test approach. However, this approach has several significant weaknesses:</p>
<ul>
<li>Each time we change the code, as well as running new tests relating to the code we are improving, we have to run all the old tests to ensure that no unexpected modified behaviors have been introduced (in other words, our new code has not <strong>broken</strong> another part of our program)</li>
<li>Running tests manually is time consuming</li>
<li>We are relying on a human to rerun the test each time, and this test may be run using different data, or some data may be omitted, or different team members may take a different approach to running tests</li>
</ul>
<p>Therefore, even for simple programs (and most are not simple), some kind of fast, automated testing system makes a lot of sense.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>There is an approach to software development called <strong>Test-Driven Development</strong> (<strong>TDD</strong>), whereby code is <strong>only</strong> written until all tests pass. So, if we want to add or improve the behavior of our game program, we must specify what we want in terms of tests, and then the programmers write code to pass the tests. This avoids a situation whereby programmers write code and features that are not needed, or spend time over-optimizing things that would have been fine, and so on. It means that the game development team directs its work toward agreed goals understood by all, since they have been specified as tests.</p>
<p>The following diagram illustrates basic TDD in that we only write code until all tests pass. Then it's time to write more tests:</p>
<div><img src="img/c9ca918d-641c-4ed7-adae-842e174b6676.png"/></div>
<p>Another way that TDD is often summarized is as red-green-refactor:</p>
<ul>
<li><strong>red:</strong> We write code that fails the test (in other words, for the new feature/improved behavior we wish to add to our system)</li>
<li><strong>green:</strong> We write code that passes the new test (and all the existing ones)</li>
<li><strong>refactor:</strong> We (may) choose to improve the code (and ensure that the improved code passes all the tests)</li>
</ul>
<p>Two kinds of software test are the following:</p>
<ul>
<li><strong>Unit tests</strong></li>
<li><strong>Integration tests</strong></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Unit tests</h1>
                
            
            
                
<p>A <strong>Unit Test</strong> tests a "unit" of code, which can be a single method, but which may include some other computer work being executed between the method being tested and the end result(s) being checked.</p>
<div><em>"A unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work. If the assumptions on the end result turn out to be wrong, the unit test has failed</em>."<br/>
                               —Roy Oshergrove (p. 5, <em>The Art of Unit Testing</em> (Second edition).</div>
<p>Unit tests should be as follows:</p>
<ul>
<li>automated (runnable at the "push of a button")</li>
<li>fast</li>
<li>easy to implement</li>
<li>easy to read</li>
<li>executed in isolation (tests should be independent from one another)</li>
<li>assessed as either having being passed or failed</li>
<li>relevant tomorrow</li>
<li>consistent (the same results each time!)</li>
<li>able to easily pinpoint what was at fault for each test that fails</li>
</ul>
<p>Most computer languages have an xUnit unit testing system available, for example:</p>
<ul>
<li>C#: NUnit</li>
<li>Java: JUnit</li>
<li>PHP: PHPUnit</li>
</ul>
<p>Unity offers an easy way to write and execute NUnit tests in its editor (and at the command line).</p>
<p>Typically, each unit test will be written in three sections, a sequence of:</p>
<ul>
<li><strong>Arrange</strong>: Set any initial values needed (sometimes, we are just giving a value to a variable in order to improve code readability)</li>
<li><strong>Act</strong>: Invoke some code (and, if appropriate, store the results)</li>
<li><strong>Assert</strong>: Make assertions for what should be true about the code invoked (and any stored results)</li>
</ul>
<p>Observe that the naming of a unit test method (by convention) is quite verbose—it is made up of lots of words that describe what it does. For example, you might have a unit test method named <kbd>TestHealthNotGoAboveOne()</kbd>. The idea is that if a test fails, the name of the test should give a programmer a very good idea of what behavior is being tested and, therefore, how to quickly establish whether the test is correct and, if so, where to look in your program code for what was being tested. Another part of the convention of naming unit tests is that numerals are not used—ust words—so we write "one", "two", and so on, in the name of the test method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integration tests (PlayMode tests in Unity)</h1>
                
            
            
                
<p>An <strong>Integration Test</strong> involves checking the behavior of interacting software components, for example, ones that use real time, or a real filesystem, or that communicate with the web or other applications running on the computer. Integration tests are usually not as fast as unit tests, and may not produce consistent results (since the components may interact in different ways at different times).</p>
<p>Both <strong>Unit</strong> and <strong>Integration Test</strong> are important, but they are different and should be treated differently.</p>
<p>Unity offers <strong>Play Mode</strong> testing, allowing integration testing as Unity scenes execute with testing code in them.</p>
<p>Places where you can learn more about Unity Testing include the following:</p>
<ul>
<li>Unity Test Runner and PlayMode documentation pages:
<ul>
<li><a href="https://docs.unity3d.com/Manual/testing-editortestsrunner.html">https://docs.unity3d.com/Manual/testing-editortestsrunner.html</a></li>
<li><a href="https://docs.unity3d.com/Manual/PlaymodeTestFramework.html">https://docs.unity3d.com/Manual/PlaymodeTestFramework.html</a></li>
</ul>
</li>
<li>A website for the book "The Art of Unit Testing" (and lots of other learning resources associated with testing): <a href="http://artofunittesting.com/">http://artofunittesting.com/</a></li>
<li>A great dual article tutorial about Unity testing by Tomek Paszek of Unity (talking about the old Unity test tools, but most of the content is still very relevant): <a href="https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/">https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/</a></li>
<li>YouTube, where you can learn lots about Unity testing (and other topics) from Infalliblecode: <a href="https://www.youtube.com/infalliblecode">https://www.youtube.com/infalliblecode</a></li>
<li>CodeProject.com's introduction to TDD and NUnit: <a href="https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD">https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating a default test script class</h1>
                
            
            
                
<p>Unity can create a default C# test script for you, thereby enabling you to quickly start creating and executing tests on your project:</p>
<div><img src="img/ae577c7a-a58a-4000-9eda-6f93e1110c47.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To generate a default test script class, follow these steps:</p>
<ol>
<li>In the Project panel, create a folder called Editor</li>
<li>Display the Test Runner panel by choosing the following menu: Window | General | Test Runner</li>
<li>Ensure that the EditMode button is selected in the Test Runner panel</li>
<li>Ensure that your new Editor folder is selected in the Project panel</li>
<li>In the Test Runner panel, click the Create Test Script in the current folder button</li>
<li>You should now have a new C# script added to your Editor folder</li>
<li>To run the tests in your script class, click the Run All button in the Test Running panel</li>
<li>You should now see all green ticks (check marks) in the panel</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Unity checks that you have a folder named Editor selected in the Project panel, and then creates a C# NewTestScript script class for you containing the following:</p>
<pre>    using UnityEngine;<br/>     using UnityEngine.TestTools;<br/>     using NUnit.Framework;<br/>     using System.Collections;<br/> <br/>     public class NewTestScript {<br/>         [Test]<br/>         public void NewTestScriptSimplePasses() {<br/>             // Use the Assert class to test conditions.<br/>         }<br/> <br/>         // A UnityTest behaves like a coroutine in PlayMode<br/>         // and allows you to yield null to skip a frame in EditMode<br/>         [UnityTest]<br/>         public IEnumerator NewTestScriptWithEnumeratorPasses() {<br/>             // Use the Assert class to test conditions.<br/>             // yield to skip a frame<br/>             yield return null;<br/>         }<br/>     } </pre>
<p>In the Test Runner panel, you should see the script class and its two methods listed. Note that the first line in the Test Runner panel is the Unity project name, the second line will say <kbd>Assembly-CSharp-Editor.dll</kbd>, followed by your script class name, and then each of the test methods:</p>
<div><img src="img/f7fcf6a3-c7ad-4c50-849a-b3f16d5e0203.png"/></div>
<p>There are three symbols to indicate the status of each test/class:</p>
<ul>
<li><strong>Empty circle</strong>: Test not executed since the script class was last changed</li>
<li><strong>Green tick</strong> (check mark): The test was passed successfully</li>
<li><strong>Red cross</strong>: The test was failed</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some details that you won't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Create a default test script from the Project panel's Create menu</h1>
                
            
            
                
<p>Another way of creating a default Unit Test script is as follows:</p>
<ul>
<li>From the Project panel, chose the following menu: Create | Testing | C# Test Script</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Edit mode minimum skeleton unit test script</h1>
                
            
            
                
<p>Be aware that if you are only going to use this script class for testing in EditMode, you can delete the second method and some of the using statements as follows, so as to give you a minimal skeleton to work from:</p>
<pre>    using NUnit.Framework;<br/> <br/>     public class UnitTestSkeleton<br/>     {<br/>         [Test]<br/>         public void NewTestScriptSimplePasses()<br/>         {<br/>             // write your assertion(s) here<br/>         }<br/>     } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">A simple unit test</h1>
                
            
            
                
<p>In the same way as printing "hello world" is most programmers first program statement, asserting that 1 + 1 = 2 is perhaps the most common first test executed for those learning unit testing. That's what we'll create in this recipe:</p>
<div><img src="img/d6ba1b96-51a1-42fc-9439-6619d61ecd02.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create and execute a simple unit test, follow these steps:</p>
<ol>
<li>In the Project panel, create a folder called Editor.</li>
<li>Inside your Editor folder, create a new C# <kbd>SimpleTester.cs</kbd> script class containing the following:</li>
</ol>
<pre>    using NUnit.Framework;<br/> <br/>     class SimpleTester<br/>     {<br/>         [Test]<br/>         public void TestOnePlusOneEqualsTwo()<br/>         {<br/>             // Arrange<br/>             int n1 = 1;<br/>             int n2 = 1;<br/>             int expectedResult = 2;<br/> <br/>             // Act<br/>             int result = n1 + n2;<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/>     } </pre>
<ol start="3">
<li>Display the Test Runner panel by choosing the following menu: Window | General | Test Runner.</li>
<li>Ensure that the <kbd>EditMode</kbd> button is selected in the Test Runner panel.</li>
<li>Click Run All.</li>
<li>You should see the results of your Unit Test being executed – if the test was concluded successfully, it should have a green 'tick' next to it.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You have declared that the <kbd>TestOnePlusOneEqualsTwo()</kbd> method in the C# <kbd>SimpleTester.cs</kbd> script class is a test method. When executing this test method, the Unity Test Runner executes each statement in sequence, so variables <kbd>n1</kbd>, <kbd>n2</kbd>, and <kbd>expectedResult</kbd> are set, then the calculation of 1 + 1 is stored in the variable result, and finally (the most important bit), we make an assertion of what should be true after executing that code. Our assertion states that the value of the <kbd>expectedResult</kbd> variable should be equal to the value of the variable result.</p>
<p>If the assertion is true, the test is passed, otherwise it is failed. Generally, as programmers, we expect our code to pass, so we inspect each fail very carefully, first to see whether we have an obvious error, then perhaps to check whether the test itself is correct (especially if it's a new test), and then to begin to debug and understand why our code behaved in such a way that it did not yield the anticipated result.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some details that you won't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shorter tests with values in the assertion</h1>
                
            
            
                
<p>For simple calculations, some programmers prefer to write less test code by putting the values directly into the assertion. So, as shown below, our 1 + 1 = 2 test could be expressed in a single assertion, where the expected value of 2, and the expression 1 + 1, are entered directly into an <kbd>AreEqual(...)</kbd> method invocation:</p>
<pre>    using NUnit.Framework;<br/> <br/>     class SimpleTester<br/>     {<br/>         [Test]<br/>         public void TestOnePlusOneEqualsTwo()<br/>         {<br/>             // Assert<br/>             Assert.AreEqual(2, 1 + 1);<br/>         }<br/>     } </pre>
<p>However, if you are new to testing, you may prefer the previous approach, whereby the preparation, code execution, and storage of results, and the assertion of properties about those results, are structured clearly in a sequence of <strong>Arrange/Act/Assert</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Expected value followed by the actual value</h1>
                
            
            
                
<p>When comparing values with assertions, it is customary for the expected (correct) value to be given first, followed by the actual value:</p>
<pre>    Assert.AreEqual( &lt;expectedValue&gt;, &lt;actualValue&gt; ); </pre>
<p>While it makes no difference to the true or false nature of equality, and so on, it can make a difference to messages when tests fail with some testing frameworks (for example, "got 2 but expected 3" has a very different meaning to "got 3 but expected 2"). Hence, the following assertion would output a message that would be confusing, since 2 was our expected result:</p>
<p> </p>
<pre>    public void TestTwoEqualsThreeShouldFail() {<br/>         // Arrange<br/>         int expectedResult = 2;<br/> <br/>         // Act<br/>         int result = 1 + 2; // 3 !!!<br/> <br/>         // Assert<br/>         Assert.AreEqual(result, expectedResult);<br/>     } </pre>
<p>Refer to the following screenshot:</p>
<div><img src="img/69dd1664-2b61-4de9-b131-5c3bf8b392de.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Parameterizing tests with a data provider method</h1>
                
            
            
                
<p>If we are testing our code using a range of test data, then sometimes there is little difference between each test apart from the the values. Rather than duplicating our Arrange/Act/Assert statements, we can re-use a single method, and the Unity Test Runner will loop through a collection of test data, running the test method for each set of test data. The special method that provides multiple sets of test data to a test method is known as a DataProvider, and we'll create one in this recipe:</p>
<div><img src="img/23878553-e5bf-44f1-9f9d-fb3714659e72.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To parameterize tests with a data provider method, follow these steps:</p>
<ol>
<li>In the Project panel, create a folder called Editor.</li>
<li>Inside your Editor folder, create a new C# <kbd>DataProviderTester.cs</kbd> script class containing the following:</li>
</ol>
<pre>    using NUnit.Framework;<br/> <br/>     class DataProviderTester<br/>     {<br/>         [Test, TestCaseSource("AdditionProvider")]<br/>         public void TestAdd(int num1, int num2, int expectedResult)<br/>         {<br/>             // Arrange<br/>             // (not needed - since values coming as arguments)<br/> <br/>             // Act<br/>             int result = num1 + num2;<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/> <br/>         // the data provider<br/>         static object[] AdditionProvider =<br/>         {<br/>             new object[] { 0, 0, 0 },<br/>             new object[] { 1, 0, 1 },<br/>             new object[] { 0, 1, 1 },<br/>             new object[] { 1, 1, 2 }<br/>         };<br/>     } </pre>
<ol start="3">
<li>Display the Test Runner panel by choosing the following menu: Window | General | Test Runner.</li>
<li>Ensure that the EditMode button is selected in the Test Runner panel.</li>
<li>Click Run All.</li>
<li>You should see the results of your Unit Test being executed. You should see four sets of results for the <kbd>TestAdd(...)</kbd> test method, one for each of the datasets provided by the <kbd>AdditionProvider</kbd> method.</li>
</ol>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We have indicated that the <kbd>TestAdd(...)</kbd> method is a test method with a compiler attribute [Test]. However, in this case, we have added additional information to state that the data source for this method is the <kbd>AdditionProvider</kbd> method.</p>
<p>This means that the Unity Test Runner will retrieve the data objects from the additional provider, and create multiple tests for the <kbd>TestAdd(...)</kbd> method, one for each set of data from the <kbd>AdditionProvider()</kbd> method.</p>
<p>In the Test Runner panel, we can see a line for each of these tests:</p>
<pre>    TestAdd(0,0,0)<br/>     TestAdd(1,0,1)<br/>     TestAdd(0,1,1)<br/>     TestAdd(1,1,2) </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Unit testing a simple health script class</h1>
                
            
            
                
<p>Let's create something that might be used in a game, and that can easily be unit tested. Classes that do <strong>not</strong> subclass from Monobehavior are much easier to unit test, since instance objects can be created using the keyword new. If the class is carefully designed with private data and public methods with clearly declared dependencies as parameters, it becomes easy to write a set of tests to make us confident that objects of this class will behave as expected in terms of default values, as well as valid and invalid data.</p>
<p>In this recipe, we will create a health script class, and a set of tests for this class. This kind of class can be reused for both the health of human players, and also Artificial Intelligence (AI)-controlled enemies in a game:</p>
<div><img src="img/1db24c0c-d5e6-4c17-a24c-153834a86a78.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To unit test a health script class, follow these steps:</p>
<ol>
<li>In the Project panel, create a _Scripts folder.</li>
<li>Inside your <kbd>_Scripts</kbd> folder, create a new C# <kbd>Health.cs</kbd> script class containing the following:</li>
</ol>
<pre>    using UnityEngine;<br/>     using System.Collections;<br/> <br/>     public class Health<br/>     {<br/>         private float health = 1;<br/> <br/>         public float GetHealth()<br/>         {<br/>             return health;<br/>         }<br/> <br/>         public bool AddHealth(float heathPlus)<br/>         {<br/>             if(heathPlus &gt; 0){<br/>                 health += heathPlus;<br/>                 return true;<br/>             } else {<br/>                 return false;<br/>             }<br/>         }<br/> <br/>         public bool KillCharacter()<br/>         {<br/>             health = 0;<br/>             return true;<br/>         }<br/>     } </pre>
<ol start="3">
<li>Inside your _Scripts folder, create a new folder named Editor.</li>
<li>Inside your Editor folder, create a new C# <kbd>TestHealth.cs</kbd> script class containing the following:</li>
</ol>
<pre style="padding-left: 60px">using NUnit.Framework;<br/><br/>class TestHealth {<br/>   [Test]<br/>   public void TestReturnsOneWhenCreated()   {<br/>      // Arrange<br/>      Health h = new Health ();<br/>      float expectedResult = 1;<br/><br/>      // Act<br/>      float result = h.GetHealth ();<br/><br/>      // Assert<br/>      Assert.AreEqual (expectedResult, result);<br/>   }     <br/><br/>    [Test]<br/>    public void TestPointTwoAfterAddPointOneTwiceAfterKill()    {<br/>        // Arrange<br/>        Health h = new Health();<br/>        float healthToAdd = 0.1f;<br/>        float expectedResult = 0.2f;<br/><br/>        // Act<br/>        h.KillCharacter();<br/>        h.AddHealth(healthToAdd);<br/>        h.AddHealth(healthToAdd);<br/>        float result = h.GetHealth();<br/><br/><br/>        // Assert<br/>        Assert.AreEqual(expectedResult, result);<br/>    }<br/><br/>    [Test]<br/>    public void TestNoChangeAndReturnsFalseWhenAddNegativeValue()     {<br/>        // Arrange<br/>        Health h = new Health();<br/>        float healthToAdd = -1;<br/>        bool expectedResultBool = false;<br/>        float expectedResultFloat = 1;<br/><br/>        // Act<br/>        bool resultBool = h.AddHealth(healthToAdd);<br/>        float resultFloat = h.GetHealth();<br/><br/>        // Assert<br/>        Assert.AreEqual(expectedResultBool, resultBool);<br/>        Assert.AreEqual(expectedResultFloat, resultFloat);<br/>    }<br/><br/>    [Test]<br/>    public void TestReturnsZeroWhenKilled()    {<br/>        // Arrange<br/>        Health h = new Health();<br/>        float expectedResult = 0;<br/><br/>        // Act<br/>        h.KillCharacter();<br/>        float result = h.GetHealth();<br/><br/>        // Assert<br/>        Assert.AreEqual(expectedResult, result);<br/>    }<br/><br/><br/>    [Test]<br/>    public void TestHealthNotGoAboveOne()    {<br/>        // Arrange<br/>        Health h = new Health();<br/>        float expectedResult = 1;<br/><br/>        // Act<br/>        h.AddHealth(0.1f);<br/>        h.AddHealth(0.5f);<br/>        h.AddHealth(1);<br/>        h.AddHealth(5);<br/>        float result = h.GetHealth();<br/><br/>        // Assert<br/>        Assert.AreEqual(expectedResult, result);<br/>    }<br/>}</pre>
<ol start="5">
<li>Display the Test Runner panel by choosing the following menu: Window | Debug | Test Runner.</li>
<li>Ensure that the EditMode button is selected in the Test Runner panel.</li>
<li>Click Run All.</li>
<li>You should see the results of your unit tests being executed.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Each of the C# script-classes is described below.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Script-class Health.cs</h1>
                
            
            
                
<p>This script class has one private property; as it is private, it can only be changed by methods. Its initial value is 1.0, in other words, 100% health:</p>
<ul>
<li><kbd>health</kbd> (float): The valid range is from 0 (dead!) to 1.0 (100% health)</li>
</ul>
<p>There are 3 public methods:</p>
<ul>
<li><kbd>GetHealth()</kbd>: This returns the current value of the health float number (which should be between 0 and 1.0)</li>
<li><kbd>AddHealth(float)</kbd>: This takes as input a float (the amount to add to the health), and returns a Boolean true/false, as to whether the value was valid. Note the logic of this method is that it accepts values of 0 or more (and will return true), but it will ensure that the value of health is never more than 1</li>
<li><kbd>KillCharacter()</kbd>: This method sets health to zero, and returns true, since it is always successful in this action</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Script-class TestHealth.cs</h1>
                
            
            
                
<p>This script class has five methods:</p>
<ul>
<li><kbd>TestReturnsOneWhenCreated()</kbd>: This tests that the initial value of health is 1, when a new Health object is created.</li>
<li><kbd>TestPointTwoAfterAddPointOneTwiceAfterKill()</kbd>: This tests that after a kill (health set to zero), and then adding 0.1 on two occasions, the health should be 0.2.</li>
<li><kbd>TestReturnsZeroWhenKilled()</kbd>: This tests that the health value is set to zero immediately after the <kbd>KillCharacter()</kbd> method has been called.</li>
<li><kbd>TestNoChangeAndReturnsFalseWhenAddNegativeValue()</kbd>: This tests that attempting to add a negative value to health should return false and that the value of health should not have changed. This method is an example of a test with more than one assertion (but both are related to the actions.</li>
<li><kbd>TestHealthNotGoAboveOne()</kbd>: This test verifies that even when lots of values are added to health, totaling more than 1.0, the value returned from <kbd>GetHealth()</kbd> is one.</li>
</ul>
<p>Hopefully, all the tests pass when you run them, giving some confidence that the logic implementation in the <kbd>Health.cs</kbd> script class does behave as intended.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating and executing a unit test in Play mode</h1>
                
            
            
                
<p>It's a good idea to write as much of the logic for a game as isolated, non-Monobehavior classes, that are easy to unit test in Edit mode. However, some of the logic in a game relates to things that happen when the game is running. Examples include physics, collisions, and timing-based events. We test these parts of our games in Play Mode.</p>
<p>In this recipe, we'll create one very simple Play Mode test, to check that physics affects a RigidBody (based on an example from the Unity documentation):</p>
<div><img src="img/7d7fe717-66e1-4c2b-bbdb-6b312ea5e15f.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create and execute a unit test in <strong>Play</strong> mode, follow these steps:</p>
<ol>
<li>Display the Test Runner panel by choosing the following menu: Window | General | Test Runner</li>
<li>Enable PlayMode tests for all assemblies. Do this by displaying the drop-down menu in the top-right corner of the Test Runner panel, and then selecting Enable playmode tests for all assemblies (click OK to any message concerned with restarting the editor):</li>
</ol>
<div><img src="img/6abcb454-93c1-4ec8-be54-22864a5f354f.png"/></div>
<ol start="3">
<li>Now, restart the Unity Editor (just close the application and then reopen it with your project).</li>
</ol>
<p>It is very important that you restart the Unity Editor application after enabling PlayMode. If you fail to do this, then you may not be able to locate your PlayMode test script classes where they can see (and refer to) your Monobehavior classes.</p>
<ol start="4">
<li>Ensure that the PlayMode button is selected in the Test Runner panel.</li>
<li>In the Test Runner panel, click the Create PlayMode Test Assembly Folder button. A new folder, named Tests, should have been created.</li>
<li>In the Project panel, open the <kbd>Tests</kbd> folder. It should contain an assembly definition file Tests.asmdef.</li>
<li>In the Test Runner panel, click the Create Test Script in the current folder button – you may wish to rename this script from the default name, <kbd>NewTestScript</kbd>.</li>
<li>Edit your new test script, replacing the content with the following:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/>     using UnityEngine.TestTools;<br/>     using NUnit.Framework;<br/>     using System.Collections;<br/> <br/>     public class NewTestScript<br/>     {<br/>         [UnityTest]<br/>         public IEnumerator GameObject_WithRigidBody_WillBeAffectedByPhysics()<br/>         {<br/>             // Arrange<br/>             var go = new GameObject();<br/>             go.AddComponent&lt;Rigidbody&gt;();<br/>             var originalPosition = go.transform.position.y;<br/> <br/>             // Act<br/>             yield return new WaitForFixedUpdate();<br/> <br/>             // Assert<br/>             Assert.AreNotEqual(originalPosition, go.transform.position.y);<br/>         }<br/>     } </pre>
<ol start="9">
<li>Click Run All.</li>
<li>In the Hierarchy, you'll see that a temporary scene is created (named something along the lines of InitTestScene6623462364), and that a GameObject named Code Based Test Runner is created.</li>
<li>In the Game panel, you will briefly see the message Display 1 No Cameras Rendering.</li>
<li>You should see the results of your unit test being executed – if the test is concluded successfully, it should have a green tick next to it.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Methods marked with the <kbd>[UnityTest]</kbd> attribute are run as coroutines. A coroutine has the ability to pause execution (when it meets a yield statement) and return control to Unity, but then to continue where it left off when called again (for example, the next frame, second, or whatever). The yield statement indicates the statement after which, and for how long, execution of the method is to be paused. Examples of different types of yield include:</p>
<ul>
<li>Waiting until until the next frame: <kbd>null</kbd></li>
<li>Waiting for a given length of time: <kbd>WaitForSeconds(&lt;seconds&gt;)</kbd></li>
<li>Waiting until the next fixed-update time period (physics is not applied each frame (since the framerate varies), but after a fixed period of time): <kbd>WaitForFixedUpdate()</kbd></li>
</ul>
<p>Method <kbd>GameObject_WithRigidBody_WillBeAffectedByPhysics()</kbd> creates a new GameObject and attaches to it a RigidBody. It also stores the original Y position. The yield statement makes the PlayMode Test Runner wait until physics has begun at the next fixed update period. Finally, an assertion is made that the original Y position is not equal to the new Y position (after the physics fixed update). Since the defaults for a RigidBody are that gravity will be applied, this is a good test that physics is being applied to the new object (in other words, it should have started falling down once physics had been applied).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">PlayMode testing a door animation</h1>
                
            
            
                
<p>Having learned the basics of PlayMode testing in the previous recipe, now let's test something non-trivial that we might find in a game. In this recipe, we'll create a PlayMode test to ensure that a door opening animation plays when the player's sphere object enters a collider.</p>
<p>A scene has been provided with the player's sphere initialized to roll toward a red door. When the sphere hits the collider (<kbd>OnTriggerEnter</kbd> event), some code sets the door's Animator Controller Opening variable to true, which transitions the door from its closed state to its open state, as can be seen in the following screenshot:</p>
<div><img src="img/27a33dc2-b393-4ed7-aa36-9cb6807b6c2b.png"/></div>
<p>Thanks should go to the creator of the ground texture; it was designed by Starline, and published at <a href="http://Freepik.com">Freepik.com</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, a Unity Package has been provided <kbd>(doorScene.unitypackage)</kbd> in the <kbd>19_06</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To PlayMode test a door animation, follow these steps:</p>
<ol>
<li>Create a new Unity project, and delete the default folder Scenes.</li>
<li>Import the Unity package provided (doorScene.unitypackage).</li>
<li>Add the following scenes – doorScene and menuScene – to the project Build (the sequence doesn't matter).</li>
<li>Ensure that the scene currently open is menuScene.</li>
<li>Display the Test Runner panel by choosing the following menu: Window | General | Test Runner</li>
<li>Enable playmode tests for all assemblies. Do this by displaying the drop-down menu in the top-right corner of the Test Runner panel, and selecting Enable playmode tests for all assemblies (click OK to any message concerned with restarting the editor).</li>
<li>Now restart the Unity Editor (just close the application and then reopen it with your project).</li>
<li>Ensure that the PlayMode button is selected in the Test Runner panel.</li>
<li>In the Project panel, select the top-level folder Assets.</li>
<li>In the Test Runner panel, click the "Create PlayMode Test Assembly Folder" button. A new folder, named Tests, should have been created.</li>
<li>In the Project panel, open the <kbd>Tests</kbd> folder. It should contain an assembly definition file <kbd>Tests.asmdef</kbd>.</li>
<li>In the Test Runner panel, click the "Create Test Script in the current folder" button. Rename this script class <kbd>DoorTest</kbd>.</li>
<li>Edit the <kbd>DoorTest.cs</kbd> script class, replacing the content with the following:</li>
</ol>
<pre style="padding-left: 60px">    using System.Collections;<br/>     using NUnit.Framework;<br/>     using UnityEngine;<br/>     using UnityEngine.SceneManagement;<br/>     using UnityEngine.TestTools;<br/> <br/>     public class DoorTest<br/>     {<br/>         const int BASE_LAYER = 0;<br/>         private string initialScenePath;<br/>         private Animator doorAnimator;<br/>         private Scene tempTestScene;<br/> <br/>         // name of scene being tested by this class<br/>         private string sceneToTest = "doorScene";<br/> <br/>         [SetUp]<br/>         public void Setup()<br/>         {<br/>             // setup - load the scene<br/>             tempTestScene = SceneManager.GetActiveScene();<br/>         }<br/>     } </pre>
<ol start="14">
<li>Add the following test method to <kbd>DoorTest.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    [UnityTest]<br/>     public IEnumerator TestDoorAnimationStateStartsClosed()<br/>     {<br/>         // load scene to be tested<br/>         yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>         SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/>         // Arrange<br/>         doorAnimator = GameObject.FindWithTag("Door").GetComponent&lt;Animator&gt;();<br/>         string expectedDoorAnimationState = "DoorClosed";<br/> <br/>         // immediate next frame<br/>         yield return null;<br/> <br/>         // Act<br/>         AnimatorClipInfo[] currentClipInfo = doorAnimator.GetCurrentAnimatorClipInfo(BASE_LAYER);<br/>         string doorAnimationState = currentClipInfo[0].clip.name;<br/> <br/>         // Assert<br/>         Assert.AreEqual(expectedDoorAnimationState, doorAnimationState);<br/> <br/>         // teardown - reload original temp test scene<br/>         SceneManager.SetActiveScene(tempTestScene);<br/>         yield return SceneManager.UnloadSceneAsync(sceneToTest);<br/>     } </pre>
<ol start="15">
<li>Add the following test method to <kbd>DoorTest.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    [UnityTest]<br/>     public IEnumerator TestIsOpeningStartsFalse()<br/>     {<br/>         // load scene to be tested<br/>         yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>         SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/>         // Arrange<br/>         doorAnimator = GameObject.FindWithTag("Door").GetComponent&lt;Animator&gt;();<br/> <br/>         // immediate next frame<br/>         yield return null;<br/> <br/>         // Act<br/>         bool isOpening = doorAnimator.GetBool("Opening");<br/> <br/>         // Assert<br/>         Assert.IsFalse(isOpening);<br/> <br/>         // teardown - reload original temp test scene<br/>         SceneManager.SetActiveScene(tempTestScene);<br/>         yield return SceneManager.UnloadSceneAsync(sceneToTest);<br/>     } </pre>
<ol start="16">
<li>Add the following test method to <kbd>DoorTest.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    [UnityTest]<br/>     public IEnumerator TestDoorAnimationStateOpenAfterAFewSeconds()<br/>     {<br/>         // load scene to be tested<br/>         yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>         SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/>         // wait a few seconds<br/>         int secondsToWait = 3;<br/>         yield return new WaitForSeconds(secondsToWait);<br/> <br/>         // Arrange<br/>         doorAnimator = GameObject.FindWithTag("Door").GetComponent&lt;Animator&gt;();<br/>         string expectedDoorAnimationState = "DoorOpen";<br/> <br/> <br/>         // Act<br/>         AnimatorClipInfo[] currentClipInfo = doorAnimator.GetCurrentAnimatorClipInfo(BASE_LAYER);<br/>         string doorAnimationState = currentClipInfo[0].clip.name;<br/>         bool isOpening = doorAnimator.GetBool("Opening");<br/> <br/>         // Assert<br/>         Assert.AreEqual(expectedDoorAnimationState, doorAnimationState);<br/>         Assert.IsTrue(isOpening);<br/> <br/>         // teardown - reload original temp test scene<br/>         SceneManager.SetActiveScene(tempTestScene);<br/>         yield return SceneManager.UnloadSceneAsync(sceneToTest);<br/>     } </pre>
<ol start="17">
<li>Click Run All.</li>
<li>As the tests run, you will see first in the Hierarchy, Game and Scene panels that a temporary scene is created, then the doorScene running, with the sphere rolling toward the red door.</li>
<li>You should see the results of your unit test being executed – if all tests are concluded successfully, there should be green ticks (check marks) next to each test.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You added two scenes to the build, so they can be selected in our scripts using the SceneManager during PlayMode testing.</p>
<p>We opened the menuScene so that we can clearly see when Unity runs different scenes during our PlayMode testing – and we'll see the menu scene reopened after testing takes place.</p>
<p>There is a <kbd>SetUp()</kbd> method that is executed before each test. SetUp and TearDown methods are very useful for preparing things before each test, and resetting things back to how they were before the test took place. Unfortunately, aspects such as loading our door scene before running each test, and then reloading the menu after each test, involve waiting until the scene load process has completed. We can't place yield statements in our <kbd>SetUp()</kbd> and <kbd>TearDown()</kbd> methods, so you'll see each test has repeated scene loading at the beginning and end of each test:</p>
<pre>// load scene to be tested<br/> yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>     SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/> // Arrange-Act-Assert goes here<br/> <br/> // teardown - reload original temp test scene<br/> SceneManager.SetActiveScene(tempTestScene);<br/> yield return SceneManager.UnloadSceneAsync(sceneToTest); </pre>
<p>For each test, we wait, either for a single frame (yield <kbd>null</kbd>), or for a few seconds (yield <kbd>return new WaitForSeconds(...)</kbd>). This ensures that all objects have been created and physics is started before our test starts running. The first two tests check the initial conditions, in other words, that the door begins in the DoorClosed animation state, and that the Animation Controller's <kbd>isOpening</kbd> variable is false.</p>
<p>The final test waits for a few seconds (which is enough time for the sphere to roll up to the door and trigger the opening animation), and tests that the door is entering/has entered the DoorOpen animation state, and that the Animation Controller's <kbd>isOpening</kbd> variable is true.</p>
<p>As can be seen, there is quite a bit more to PlayMode testing than Unit Testing, but it means that we have a way to test actual GameObject interactions when features such as timers and physics are running. As this recipe demonstrates, we can also load our own scenes for PlayMode testing, be they special scenes created just to test interactions, or actual scenes that are to be included in our final game build.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">PlayMode and Unit Testing a player health bar with events, logging, and exceptions</h1>
                
            
            
                
<p>In this recipe, we combine many different kinds of tests on a feature of many games – a visual health bar representing the player's numeric health value (in this case, a float number from 0.0 - 1.0). Although far from comprehensively testing all aspects of the health bar, this recipe gives a good sample of how we can go about testing many different parts of a game using the Unity Testing tools.</p>
<p>A Unity Package is provided that contains the following:</p>
<ul>
<li><kbd>Player.cs</kbd>: a player script class, managing values for player health, and using delegates-and-events to publish health changes to any listening <strong>View</strong> classes</li>
<li>Two <strong>View</strong> classes that register to listen for player health change events:
<ul>
<li><kbd>HealthBarDisplay.cs</kbd>: this updates the fillAmount for a UI image for each new player health value received</li>
<li><kbd>HealthChangeLogger.cs</kbd>: this prints messages about the new player health value received to the Debug.Log file</li>
</ul>
</li>
<li><kbd>PlayerManager.cs</kbd>: a manager script, which initializes player and HealthChangeLogger objects, and also allows the user to change the health of the player by pressing the Up and Down arrow keys (simulating healing/damage during a game)</li>
<li>A scene that has 2 UI images – one is a health bar outline (red heart and a black outline), the second is the filler image – showing dark blue to light blue to green, for weak to strong health values)</li>
</ul>
<p>This recipe allows several different kinds of testing to be demonstrated:</p>
<ul>
<li>PlayMode testing, to check that the actual <kbd>fillAmount</kbd> of the UI image displayed matches the 0.0 ... 1.0 range of the player's health</li>
<li>Unit Testing, to check that player health starts with the correct default value, and correctly increases and decreases after calls to the <kbd>AddHealth(...)</kbd> and <kbd>ReduceHealth(...)</kbd> methods</li>
<li>Unit testing, to check that health change events are published by the player object</li>
<li>Unit testing, to check that expected messages are logged in the <kbd>Debug.Log</kbd></li>
<li>Unit testing, to check that argument out-of-range exceptions are thrown if negative values are passed to the player's <kbd>AddHealth(...)</kbd> or <kbd>ReduceHealth(...)</kbd> methods. This is demonstrated in the following screenshot: </li>
</ul>
<div><img src="img/f66aebf7-313f-4a0a-88bd-41d1a7b04dae.png"/></div>
<p>Thanks to Pixel Art Maker for the health bar image: <a href="http://pixelartmaker.com/art/49e2498a414f221">http://pixelartmaker.com/art/49e2498a414f221</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, a Unity Package has been provided (<kbd>healthBarScene.unitypackage</kbd>) in the <kbd>19_07</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To PlayMode and Unit Test a player health bar, follow these steps:</p>
<ol>
<li>Create a new Unity project, create a new empty scene, and delete the default folder Scenes.</li>
<li>Import the Unity package provided (<kbd>healthBarScene.unitypackage</kbd>).</li>
<li>Open the HealthBarScene scene.</li>
<li>Add HealthBarScene to the project Build (menu: File | Build Settings ...).</li>
<li>Display the Test Runner panel by choosing the following menu: Window | General | Test Runner.</li>
<li>Enable PlayMode tests for all assemblies. Do this by displaying the drop-down menu in the top-right corner of the Test Runner panel, and selecting Enable playmode tests for all assemblies (click OK to any message concerned with restarting the editor).</li>
<li>Now restart the Unity Editor (just close the application and then reopen it with your project).</li>
<li>Ensure that the PlayMode button is selected in the Test Runner panel.</li>
<li>In the Project panel, select the top-level folder Assets.</li>
<li>In the Test Runner panel, click the "Create PlayMode Test Assembly Folder" button. A new folder, named Tests, should have been created.</li>
<li>Ensure that the Assets folder is selected in the Project panel. Create a new folder named PlayModeTests (this should now appear in the Assets folder).</li>
<li>Ensure that the PlayModeTests folder is selected in the Project panel. In the Test Runner panel, click the "Create Test Script in the current folder" button. Rename this script class <kbd>HealthBarPlayModeTests</kbd>.</li>
<li>Edit the <kbd>HealthBarPlayModeTests.cs</kbd> script class, replacing the content with the following:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/>     using UnityEngine.TestTools;<br/>     using NUnit.Framework;<br/>     using System.Collections;<br/>     using UnityEngine.SceneManagement;<br/> <br/> <br/>     [TestFixture]<br/>     public class HealthBarPlayModeTests<br/>     {<br/>         private Scene tempTestScene;<br/> <br/>         // name of scene being tested by this class<br/>         private string sceneToTest = "HealthBar";<br/> <br/>         [SetUp]<br/>         public void Setup()<br/>         {<br/>             // setup - load the scene<br/>             tempTestScene = SceneManager.GetActiveScene();<br/>         }<br/>     } </pre>
<ol start="14">
<li>Add the following test in <kbd>HealthBarPlayModeTests.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">   [UnityTest]<br/>     public IEnumerator TestHealthBarImageMatchesPlayerHealth()<br/>     {<br/>         // load scene to be tested<br/>         yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>         SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/>         // wait for one frame<br/>         yield return null;<br/> <br/>         // Arrange<br/>         Image healthBarFiller = GameObject.Find("image-health-bar-filler").GetComponent&lt;Image&gt;();<br/>         PlayerManager playerManager = GameObject.FindWithTag("PlayerManager").GetComponent&lt;PlayerManager&gt;();<br/>         float expectedResult = 0.9f;<br/> <br/>         // Act<br/>         playerManager.ReduceHealth();<br/> <br/>         // Assert<br/>         Assert.AreEqual(expectedResult, healthBarFiller.fillAmount);<br/> <br/>         // teardown - reload original temp test scene<br/>         SceneManager.SetActiveScene(tempTestScene);<br/>         yield return SceneManager.UnloadSceneAsync(sceneToTest);<br/>     } </pre>
<ol start="15">
<li>Click Run All.</li>
<li>As the tests run, you will see first in the Hierarchy, Game and Scene panels that a temporary scene is created, then the HealthBarScene running, with the visual health bar.</li>
<li>You should see the results of your PlayMode Test being executed – if the test is concluded successfully, there should be a green tick (check mark).</li>
<li>Ensure that the Assets folder is selected in the Project panel. Create a new folder named Editor (this should now appear in the Assets folder).</li>
<li>Ensure that the Editor folder is selected in the Project panel. In the Test Runner panel, click the "Create Test Script in the current folder" button. Rename this script class <kbd>EditModeUnitTests</kbd>.</li>
<li>Edit the <kbd>EditModeUnitTests.cs</kbd> script class, replacing the content with the following:</li>
</ol>
<pre style="padding-left: 60px">    using System;<br/>     using UnityEngine.TestTools;<br/>     using NUnit.Framework;<br/>     using UnityEngine;<br/> <br/>     public class EditModeUnitTests<br/>     {<br/> <br/>         // inner unit test classes go here<br/> <br/>     } </pre>
<ol start="21">
<li>Add the following class and basic tests inside the <kbd>EditModeUnitTests</kbd> class in <kbd>EditModeUnitTests.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestCorrectValues<br/>     {<br/>         [Test]<br/>         public void DefaultHealthOne()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             float expectedResult = 1;<br/> <br/>             // Act<br/>             float result = player.GetHealth();<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/> <br/>         [Test]<br/>         public void HealthCorrectAfterReducedByPointOne()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             float expectedResult = 0.9f;<br/> <br/>             // Act<br/>             player.ReduceHealth(0.1f);<br/>             float result = player.GetHealth();<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/> <br/>         [Test]<br/>         public void HealthCorrectAfterReducedByHalf()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             float expectedResult = 0.5f;<br/> <br/>             // Act<br/>             player.ReduceHealth(0.5f);<br/>             float result = player.GetHealth();<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/>     } </pre>
<ol start="22">
<li>Add the following class and limit test inside the <kbd>EditModeUnitTests</kbd> class in <kbd>EditModeUnitTests.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestLimitNotExceeded<br/>     {<br/>         [Test]<br/>         public void HealthNotExceedMaximumOfOne()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             float expectedResult = 1;<br/> <br/>             // Act<br/>             player.AddHealth(1);<br/>             player.AddHealth(1);<br/>             player.AddHealth(0.5f);<br/>             player.AddHealth(0.1f);<br/>             float result = player.GetHealth();<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/>     } </pre>
<ol start="23">
<li>Add the following class and event tests inside the <kbd>EditModeUnitTests</kbd> class in <kbd>EditModeUnitTests.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestEvents<br/>     {<br/>         [Test]<br/>         public void CheckEventFiredWhenAddHealth()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             bool eventFired = false;<br/> <br/>             Player.OnHealthChange += delegate<br/>             {<br/>                 eventFired = true;<br/>             };<br/> <br/>             // Act<br/>             player.AddHealth(0.1f);<br/> <br/>             // Assert<br/>             Assert.IsTrue(eventFired);<br/>         }<br/> <br/>         [Test]<br/>         public void CheckEventFiredWhenReduceHealth()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             bool eventFired = false;<br/> <br/>             Player.OnHealthChange += delegate<br/>             {<br/>                 eventFired = true;<br/>             };<br/> <br/>             // Act<br/>             player.ReduceHealth(0.1f);<br/> <br/>             // Assert<br/>             Assert.IsTrue(eventFired);<br/>         }<br/>     } </pre>
<ol start="24">
<li>Add the following class and exception tests inside the <kbd>EditModeUnitTests</kbd> class in <kbd>EditModeUnitTests.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestExceptions<br/>     {<br/>         [Test]<br/>         public void Throws_Exception_When_Add_Health_Passed_Less_Than_Zero()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/> <br/>             // Act<br/> <br/>             // Assert<br/>             Assert.Throws&lt;ArgumentOutOfRangeException&gt;(<br/>                 delegate<br/>                 {<br/>                     player.AddHealth(-1);<br/>                 }<br/>             );<br/>         }<br/> <br/>         [Test]<br/>         public void Throws_Exception_When_Reduce_Health_Passed_Less_Than_Zero()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/> <br/>             // Act<br/> <br/>             // Assert<br/>             Assert.Throws&lt;ArgumentOutOfRangeException&gt;(<br/>                 () =&gt; player.ReduceHealth(-1)<br/>             );<br/>         }<br/>   } </pre>
<ol start="25">
<li>Add the following class and logging tests inside the <kbd>EditModeUnitTests</kbd> class in <kbd>EditModeUnitTests.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestLogging<br/>     {<br/>         [Test]<br/>         public void Throws_Exception_When_Add_Health_Passed_Less_Than_Zero()<br/>         {<br/>             Debug.unityLogger.logEnabled = true;<br/> <br/>             // Arrange<br/>             Player player = new Player();<br/>             HealthChangeLogger healthChangeLogger = new HealthChangeLogger();<br/>             string expectedResult = "health = 0.9";<br/> <br/>             // Act<br/>             player.ReduceHealth(0.1f);<br/> <br/>             // Assert<br/>             LogAssert.Expect(LogType.Log, expectedResult);<br/>         }<br/>     } </pre>
<p>You can see that the inner classes allow grouping of the unit tests visually in the Test Runner panel</p>
<div><img src="img/640546ed-4ddc-44c9-9a49-5638af8a756c.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's take a look at how it works in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">PlayMode testing</h1>
                
            
            
                
<p>The PlayMode test <kbd>TestHealthBarImageMatchesPlayerHealth()</kbd> loads the <kbd>HealthBar</kbd> scene, gets a reference to the instance-object of PlayerManager, which is a component of the GameObject tagged PlayerManager, and invokes the <kbd>ReduceHealth()</kbd> method. This method reduces the player's health by 0.1, so from its starting value of 1.0, it becomes 0.9.</p>
<p>The PlayerManager GameObject also has as a component an instance object of the C# <kbd>HealthBarDisplay</kbd> script class. This object registers to listen to published events from the player class. It also has a public UI Image variable that has been linked to the UI Image of the health bar filler image in the scene.</p>
<p>When the player's health is reduced to 0.9, it publishes the <kbd>OnChangeHealth(0.9)</kbd> event. This event is received by the <kbd>HealthBarDisplay</kbd> object instance, which then sets the fillAmount property of the linked health bar filler image in the scene.</p>
<p>The <kbd>TestHealthBarImageMatchesPlayerHealth(</kbd>) PlayMode test gets a reference to the object instance named image-health-bar-filler, storing this reference in the <kbd>healthBarFiller</kbd> variable. The test assertion made is that the expectedResult value of 0.9 matches that actual fillAmount property of the UI Image in the scene:</p>
<pre>Assert.AreEqual(expectedResult, healthBarFiller.fillAmount); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Unit tests</h1>
                
            
            
                
<p>There are several unit tests, grouped by placing them inside their own classes, inside the <kbd>EditModeUnitTests</kbd> script class.</p>
<ul>
<li><kbd>TestCorrectValues</kbd> class:
<ul>
<li><kbd>DefaultHealthOne()</kbd>: this tests that the default (initial value) of the player's health is 1</li>
<li><kbd>HealthCorrectAfterReducedByPointOne()</kbd>: this tests that when the player's health is reduced by 0.1, it becomes 0.9</li>
<li><kbd>HealthCorrectAfterReducedByHalf()</kbd>: this tests that when the player's health is reduced by 0.5 it becomes 0.5</li>
</ul>
</li>
<li>class <kbd>TestLimitNotExceeded</kbd>:
<ul>
<li><kbd>HealthNotExceedMaximumOfOne()</kbd>: this tests that the value of the player's health does not exceed 1, even after attempts to add 1, 0.5, and 0.1 to its initial value of 1</li>
</ul>
</li>
<li>class <kbd>TestEvents</kbd>:
<ul>
<li><kbd>CheckEventFiredWhenAddHealth()</kbd>: this tests that an OnChangeHealth() event is published when the player's health is increased</li>
<li><kbd>CheckEventFiredWhenReduceHealth()</kbd>: this tests that an OnChangeHealth() event is published when the player's health is decreased</li>
</ul>
</li>
<li>class <kbd>TestLogging</kbd>:
<ul>
<li><kbd>CorrectDebugLogMessageAfterHealthReduced()</kbd>: this tests that a Debug.Log message is correctly logged after the player's heath is reduced by 0.1 to 0.9</li>
</ul>
</li>
<li>class <kbd>TestExceptions</kbd>:
<ul>
<li><kbd>Throws_Exception_When_Add_Health_Passed_Less_Than_Zero()</kbd>: this tests that an ArgumentOutOfRangeException is thrown when a negative value is passed to the AddHealth(...) player method </li>
<li><kbd>Throws_Exception_When_Reduce_Health_Passed_Less_Than_Zero()</kbd>: this tests that an ArgumentOutOfRangeException is thrown when a negative value is passed to the ReduceHealth(...) player method</li>
</ul>
</li>
</ul>
<p>These two tests illustrate one convention of naming tests that adds an underscore _ character between each word in the method name in order to improve readability.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>Learn more about the LogAssert Unity Script reference in the Unity documentation:</p>
<ul>
<li><a href="https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html">https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html</a></li>
</ul>
<p>The method for unit testing C# events is adapted from a post on philosophicalgeek.com:</p>
<ul>
<li><a href="http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/">http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/</a></li>
</ul>
<p>The delegate-event publishing of health change events in this health bar feature is an example of the Publisher-Subscriber design pattern. Learn more about design patterns and their implementations for Unity games in <kbd>Chapter 17</kbd>, Extra Features and Design Patterns.</p>


            

            
        
    </body></html>