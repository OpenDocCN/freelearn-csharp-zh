- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The New Input System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity’s `Update()` method to determine if a device received an input. This usually
    results in multiple if-else branches within your `Update()` method that control
    what happens for each input received.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The Input System divorces the handling of individual input devices from code
    by using an event-based programming methodology. Instead of having to create reference
    to each of your input devices within your code, you create code that reacts to
    specific actions. The Input System then controls which Interaction from which
    Input devices trigger these actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This separation of input handling and code allows you to make more customizable
    controls, more easily handle different Input Devices, and more easily handle controls
    from different consoles that have extremely different control schemes. Additionally,
    the modularity of the Input System allows you to easily copy your control schemes
    to other projects, since the information is all stored on an asset.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is meant to be an introduction to the Input System and will give
    you an overview of the key concepts so that you can start using the Input System
    within your projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will discuss the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: How to install the Input System
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences in polling vs subscribing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic elements involved with the Input System
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write code that uses the Input System’s to control your game
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to convert a project that uses the old Input System (the Input Manager)
    to one that uses the new Input System
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two different ways to connect your Input System to your code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we begin looking at how to work with the Input System, it needs to be
    imported into your project. Let’s look at how to do that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the asset files and codes of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2020](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2020)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Input System
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Input System is no longer in preview and is officially part of Unity. However,
    it does not come pre-packaged in unity and must be installed. You can install
    the Input System into your Project via the Package Manager, by completing the
    following steps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Select **Unity Registry** from the dropdown menu.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.1: Changing the Package filter in the Package Manager](img/Figure_20.01_B18327.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.1: Changing the Package filter in the Package Manager'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Search for the **Input System** in the list and select **Install**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.2: Finding the Input System in the Package Manger](img/Figure_20.02_B18327.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.2: Finding the Input System in the Package Manger'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: You will see the following pop up which you must agree to in order to proceed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.3: A Warning about changing input systems](img/Figure_20.03_B18327.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.3: A Warning about changing input systems'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The warning is indicating that any code you wrote using the old Input System
    will no longer function. This is a destructive action and may break your game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you create a new project to explore the Input System as installing
    it may be destructive to your project. It will cause all code written using the
    Input Manager to cease functioning. Don’t install it in a pre-existing project
    until you are comfortable doing so.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Once you reopen your project, you may want to return to the Package Manager
    and install the various Samples provided by Unity with the Package. I recommend
    you install the Simple Demo and UI vs Game Input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a new Input System, it does use a new methodology to access inputs
    than the old Input System. Let’s first discuss the differences in these methodologies
    before we begin looking at the various elements of the Input System.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Polling vs subscribing
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the Input Manager in [*Chapter 8*](B18327_08.xhtml#_idTextAnchor147)
    and up until recently, it was the only way to track inputs from devices in a Unity-built
    game. When using the Input Manager, you assign specific Axes to different input
    actions. You then write a C# script that constantly checks to see if that action
    is performed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.4: C# script watching for specific inputs defined by the Input
    Manager](img/Figure_20.04_B18327.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.4: C# script watching for specific inputs defined by the Input Manager'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, your code would look something like the following pseudocode:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This technique of requesting information at a regular interval, is called **polling**.
    You can use the polling pattern for accessing information from the Input System
    in a similar way that you could with the Input Manager. However, to make your
    code more modular, most of your code when using the Input System will use a **publisher-subscriber**
    (**pub-sub**) pattern.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following analogy: you really enjoy content from a specific YouTube
    content creator. You check their channel every day to see if they have released
    new content. However, you find this cumbersome and instead decide to subscribe
    to their channel. Now the YouTube channel will alert you whenever new content
    is posted, saving you the work. Imagine how much work you save yourself from if
    you had hundreds of YouTube channels you wanted to be updated on by subscribing
    to their channels instead of constantly checking in on them.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Let’s tie the analogy to coding. Instead of your C# script having to constantly
    check in on the various inputs in the `Update()` method, you can instead **subscribe**
    to specific events defined by the **Input System**. In more technical speak, you
    will write event subscriber methods that listen for specific events raised by
    the Input System.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.5: C# script listening for specific events defined by the New Input
    System](img/Figure_20.05_B18327.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.5: C# script listening for specific events defined by the New Input
    System'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when using the New Input System, your code may look something like the
    following pseudocode:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Input System will determine which events to call based on inputs you specify
    and your code will subscribe to those events, performing the appropriate functions
    whenever those events happen.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you tell the Input System which events to call based on which input?
    And what types of events can it call from those inputs? You do this through the
    use of Actions, Interactions, and Input Binding. Let’s explore these concepts
    now.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Input System elements
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Input Manager, you list various Axes and define what buttons can trigger
    these axes. In the Input System, you define a set of **Actions** and describe
    what **Interactions** the various **Controls** of the **Input Device** can trigger
    those Actions through **Input Bindings**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could create the Input Binding that binds the Space Bar on
    a keyboard to a jump Action through a pressed Interaction, where the Input device
    would be the keyboard and the Controls would be all the keys on the keyboard.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.6: An example of an Input Binding](img/Figure_20.06_B18327.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.6: An example of an Input Binding'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: You can create these sets of **Actions** within what is known as an **Action
    Map**. Action Maps contain a list of Actions. The Actions contain the information
    about the Input Bindings. The general idea is to create Action Maps that contain
    groups of actions based on their purpose for example all character control Actions
    may go in one Action Map and all UI Actions may go in a separate one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: You can view your Action Maps, Actions, Bindings, and Interactions in the Action
    Editor. For example, here is the `Player` and `UI`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.7: The Action Editor](img/Figure_20.07_B18327.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.7: The Action Editor'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Within the `Player` Action Map, you can see the `Jump` Action, with the `Space
    [Keyboard]` Binding, and the `Press` Interaction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'To start creating your Actions and Action Maps, right click within an `Assets`
    folder and select `Inputs` within your `Assets` folder. When you do so, you should
    get something that looks like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.8: An Action Asset’s Inspector and icon representation](img/Figure_20.08_B18327.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.8: An Action Asset’s Inspector and icon representation'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: You can either double click on the asset you just created or select **Edit asset**
    from its Inspector to view the Action Editor. The Action Editor will contain your
    list of Action Maps and Actions while displaying each of the Action’s properties.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.9: The Action Editor of a newly created Action Asset](img/Figure_20.09_B18327.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.9: The Action Editor of a newly created Action Asset'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the **+** sign in the **Action Maps** section will create a new Action
    Map.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: A new Action Map will automatically come with a **New action**, which you can
    rename.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.10: An Action Map with its New action](img/Figure_20.10_B18327.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.10: An Action Map with its New action'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Selecting **<No Binding>** will allow you to create an Input Binding.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: I will cover an example of how to select Binding and Interactions in the Examples
    section at the end of this chapter, but for now, let’s look at how you can hook
    these Actions to your code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Actions to code
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways to work with the Input System’s Actions in your code.
    In this section, I will give a general overview of the most important topics that
    should allow you to get started working with the Input System.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect your Actions to your code, you will need to import the `InputSystem`
    with the following statement:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two ways in which I will discuss connecting Actions to your Code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Referencing the Action Asset
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `PlayerInput` component
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about alternate ways you can connect Actions to your code,
    see the following Unity documentation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflows.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflows.xhtml)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'You can reference the Action Asset creating a variable of type `InputActionsAsset`
    like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can then assign the value of `actions` in the Inspector.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'And to reference the specific Action within a `InputActionAsset`, you could
    create a variable of type `InputAction`, like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You could then assign it by finding the specific Action Map and Action within
    the Action Asset, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you find the reference to the Action Asset, you will need to enable and
    disable the appropriate Action Maps. For Example, if you had an Action Map named
    `Player`, you could do the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you have a reference to the `InputActionAsset`, you can have your methods
    subscribe to the various callbacks of the Action. Each Action has the following
    callbacks that you can subscribe to:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`Performed`: The Action’s Interaction is complete'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Started`: The Action’s Interaction has started'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Waiting`: The Action is enabled and waiting for an Input to cause trigger
    an Interaction'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Canceled`: The Action’s Interaction has been canceled'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled`: The Action cannot receive any input as it is disabled'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, for example, you could subscribe to an Action named `Jump` on an Action
    Map named `Player` that is triggered by a button press with something like the
    following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you wish to poll the Actions rather than subscribe to the callback events,
    you use the `ReadValue<TValue>()` method like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you’re not a big fan of writing code, you can instead use the `PlayerInput`
    component. The `PlayerInput` component will allow you to specify which methods
    in your C# scripts are called by the various Actions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.11: The default Player Input component](img/Figure_20.11_B18327.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.11: The default Player Input component'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Using this method vs directly referencing the Actions in your code is mostly
    up to preference. It takes less code, but it takes more Inspector work. As a programmer
    by trade, I personally prefer the method that references the Actions in code.
    I find it easier to debug, more customizable, and quicker to edit when there are
    multiple objects using Actions. However, when I am working on a project that has
    designers making changes in the Inspector, who don’t want to work in code, using
    the `PlayerInput` component is a good solution as it allows them to do things
    without me. You can also use a combination and it’s all based on your needs and
    preferences.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the various ways you can access Actions with your code,
    see the following documentation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflow-ActionsAsset.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflow-ActionsAsset.xhtml)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a general idea of how the Unity Input System works, let’s look
    at some examples of how to work with it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the basics of getting started with the Input System,
    let’s look at some examples of how to implement it. We’ll look at one very basic
    example of a character controller. We’ll start with an example that uses the old
    Input Manager and then adjust it to use the Input System.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: This is a super basic character controller. It is simplified to make the process
    of converting it to the Input System easier to understand.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The example we will use is just a cat that jumps and moves around.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.12: The character controller example using the old Input System](img/Figure_20.12_B18327.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.12: The character controller example using the old Input System'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you begin these examples, complete the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D Unity Project.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `Chapter 20` `– Example 1 - Start` Package provided by the book’s
    source code using `Chapter 20` `– Example 1` to get a feel of how the cat moves
    around. It’s nothing fancy or particularly impressive, but the cat will jump with
    the space bar and move back and forth with the arrow keys and *A*- *D* keys.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `InputManagerBasicCharacterController.cs` class and review the code.
    The key section of code is the `Update()` method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice the use of `Input.GetAxis("Horizontal")` and `Input.GetButtonDown` **("Jump")**
    . These are defined within the Input Manager which you can find in **Edit** |
    **Project Settings** | **Input Manager**.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you’ve played the game. Install the Input System Package and restart
    when requested. See the *Installing the Input System* section for steps.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you try to play the game now, you will see the following error in your console.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is because when we installed the Input System, the project stopped accepting
    inputs that use `UnityEngine.Input`. The cat will no longer move in response to
    our key presses.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok, now that we have our project started and set up, we can convert that code
    to something that can be used by the Input System! Let’s start by setting up our
    Actions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic character controller Actions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start adjusting our code, we first have to set up our Action Map and
    Actions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up your basic character controller Actions, complete the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Inputs` within your `Assets` folder.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click within the folder and select **Create** | **Input Actions**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new Action Asset to `CatActions`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click `CatActions.inputActions` to open the Action Editor.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Auto-Save** box so that any changes you make will automatically
    save.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.13: Selecting Auto-Save](img/Figure_20.13_B18327.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.13: Selecting Auto-Save'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add an Action Map that will hold all the Actions for our character.
    Create a new Action Map by selecting the plus sign and then naming the Action
    Map `Player`. You should now see the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.14: The Player Action Map](img/Figure_20.14_B18327.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.14: The Player Action Map'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the `Jump` action by renaming `New action` to `Jump`. You can do
    so by double-clicking on the words **New action**. Notice that the **Action Type**
    is set to **Button**. This means the Jump Action will be triggered by button-like
    inputs.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.15: The Jump Action’s properties](img/Figure_20.15_B18327.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.15: The Jump Action’s properties'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Click on the arrow next to the `Jump` Action to view all of its bindings. You
    should see **<****No Binding>.**
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.16: The Jump Action’s bindings](img/Figure_20.16_B18327.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.16: The Jump Action’s bindings'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Click on `Space`, then select **Space [Keyboard]**. This will bind the spacebar
    on the keyboard to this Action. Notice it automatically names the binding for
    you.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let’s tell this binding what Interaction it can accept. Select the plus
    sign next to **Interactions** and select **Press** from the dropdown. Your Player
    Action Map should now look as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.17: The Press Interaction on the Space [Keyboard] binding](img/Figure_20.17_B18327.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.17: The Press Interaction on the Space [Keyboard] binding'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to add the Action that will be bound to the keys that were previously
    referenced by `"Horizontal"` in the Input Manager. Select the plus sign next to
    `Move`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Action Type** to **Value** and its **Control Type** to **Vector2**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to add the key bindings. Select the plus sign next to the `Move`
    Action and you’ll notice, since we set `Move` as a different Action Type than
    `Jump`, it has different **Binding Options**. Select **Add Up\Down\Left\Right
    Composite**. You should now see the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.18: The 2D vector bindings](img/Figure_20.18_B18327.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.18: The 2D vector bindings'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Delete the **Up** and **Down** Bindings as well as the one marked **<No Binding>**,
    because we do not need them. You can do this by right-clicking on them and selecting
    **Delete**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Left Arrow` in the **Path** to find **Left** **Arrow [Keyboard]**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `Right Arrow` in the **Path** to find **Right Arrow [Keyboard]**. You
    should now have the following Actions and Bindings.![Figure 20.19: The Left and
    Right Bindings](img/Figure_20.19_B18327.jpg)'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 20.19: The Left and Right Bindings'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have now bound our arrow keys to the move action.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need to bind the *A* and *D* keys. Duplicate the **Left: Left Arrow
    [Keyboard]** and **Right: Right Arrow [Keyboard]** bindings by right clicking
    them and selecting **Duplicate**.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the duplicate `a keyboard` into the **Path** to find **A [Keyboard]**.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the duplicate `d keyboard` into the **Path** to find **D [Keyboard]**.
    You should now see the following Actions and Bindings:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.20: All the necessary Actions and Bindings](img/Figure_20.20._B18327.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.20: All the necessary Actions and Bindings'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’re done hooking up our Actions, we can start using them with our
    code! I’ll show you two ways to do this: with the `PlayerInput` Component and
    by referencing the Action in our script.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic character controller with the PlayerInput Component
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Switching our code to use Actions and the `PlayerInput` component, requires
    a bit of code adjustment and some Inspector work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Actions with the `PlayerInput` Component, complete the following steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: To preserve the previous example, I am going to duplicate the scene and call
    it `Chapter 20` `– Example 2`; duplicate the `InputManagerBasicCharacterController.cs`
    script; and rename the duplicate to `PlayerInputBasicCharacterController.cs.`
    If you’d rather just work in the same scene with the same script, you can skip
    this step. However, if you do want to do this, make sure to also change the name
    of the script in the class definition and add the script as a component to the
    `Cat` in your new scene.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by adjusting the script. We’ll be removing the code within the `Update()`
    method that checks for the Input Axes and instead use public methods that can
    be hooked up in the Inspector. Comment out all the code within the `Update()`
    method. Don’t delete it, b/c we’ll cut and paste some of it to other methods later.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following statement to the top of your script:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new method called `OnJump()`. This will be the method that is called
    when the `Jump` Action is triggered. It should look as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We want our `OnJump()` method to perform similarly to the following statement
    we have commented out in our `Update()` method.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Cut and paste it into the `OnJump()` method.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remove `&& Input.GetButtonDown("Jump")` from the `if` statement. Your `OnJump()`
    method should now appear as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let’s hook this method up in the Inspector. Select your `Cat` from the
    Hierarchy and add the `PlayerInput` Component. Your Cat’s Inspector should have
    the following components:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.21: Some of the components on Cat](img/Figure_20.21._B18327.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.21: Some of the components on Cat'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s add our Actions to the `CatActions` from the Project folder into
    the **Actions** slot. Your component should now look as follows:![Figure 20.22:
    Assigning CatActions to the PlayerInput component](img/Figure_20.22._B18327.jpg)'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 20.22: Assigning CatActions to the PlayerInput component'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice it already found our **Player** Action Map and added it as the **Default
    Map**. If we had more Action Maps, there would be others in the dropdown we could
    choose from.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the **Behavior** dropdown, select **Invoke Unity Events**. This will add
    an **Events** setting that can be expanded to reveal a list of **Player** Events.
    Expanding **Player** will show the two Actions we have defined within the Player
    Map along with some other useful Actions.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.23: The Various Player Action Events](img/Figure_20.23._B18327.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.23: The Various Player Action Events'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'We can hook up our `OnJump()` method to the `Cat` into the Object slot, and
    then selecting **PlayerInputBasicCharacterController** | **OnJump**. Your **Jump**
    Event should now appear as follows:![Figure 20.24: The Player Jump Event calling
    our OnJump method](img/Figure_20.24._B18327.jpg)'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 20.24: The Player Jump Event calling our OnJump method'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Play the game and you should see the cat jump when you press the spacebar.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let’s hook up the Move Action. Return to your code and create the following
    method:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following variable declaration to your code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we got the `movement` variable from the Input Axis, we used the following
    line:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will get the value of the Move Action whenever the `OnMove()` method is
    called.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Return to your `Update()` method and uncomment the remaining code. Your `Update()`
    method should appear as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Delete the following line that uses the old Input System.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Edit the remaining line to use the `moveVector` instead of the movement float.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Remove the `movement` float variable declaration since we no longer need it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return to your Inspector and add the `OnMove()` method to the `Cat` into the
    Object slot, and then selecting **PlayerInputBasicCharacterController** | **OnMove**.
    Your Move Event should now appear as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.25: The Player Move Event calling our OnMove method](img/Figure_20.25._B18327.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.25: The Player Move Event calling our OnMove method'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Play the game and your cat should now be able to move and jump!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I’m not a fan of using the `PlayerInput` component. Since I am a
    programmer by trade, I prefer to spend most of my time in my code editor rather
    than the Unity Editor. I find debugging code that is hooked up in the inspector
    difficult to debug. When I do use this functionality, I try to make life easier
    for my future self (or my other programming coworkers) by adding comments to the
    code that states what components call what methods. This can make debugging and
    understanding the way the code works a little easier. Using a code editor like
    Jetbrains Rider can relieve some of this stress, as it will indicate where code
    is hooked up in the Inspector, but it does not always show all necessary information
    and you can’t count on your coworkers also having the Rider IDE. If you have a
    similar preference, I will show you in the next example how to do this in a code-centric
    way.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic character controller by referencing Actions in your code
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To redo our previous example so that it references the Actions in code, complete
    the following steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: To preserve the previous example, I am going to duplicate the scene and call
    it `Chapter 20` `– Example 3`; duplicate the `PlayerInputBasicCharacterController.cs`
    script; and rename the duplicate to `ActionReferenceBasicCharacterController.cs`.
    If you’d rather just work in the same scene with the same script, you can skip
    this step. However, if you do want to do this, make sure to also change the name
    of the script in the class definition and add the script as a component to the
    `Cat` in your new scene.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `Cat`’s Inspector. Notice if you try to play the game now, the cat
    will not move or jump, since we removed the component that tied the inputs to
    our code.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ActionReferenceBasicCharacterController.cs` script.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment out the `OnMove()` method. We will not be calling this via an Event
    in the Inspector, so we do not need the method. However, we will write code similar
    to it, so I’ll comment it out for now so I can copy and paste it into the correct
    place later.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing we need to do is get a reference to the Action Asset that holds
    all of our Actions. Create the following variable declaration:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can go ahead and hook this up in the Inspector by dragging the `CatActions`
    asset into the **Actions** slot.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the script. Add an empty `OnEnable()` method and `OnDisable()` method
    to your script. We’ll add some code to them momentarily.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I prefer to put the `OnEnable()` method right under the `Awake()` method since
    it executes after it and the `OnDisable()` method at the bottom of the script
    since it will execute after all of our other methods.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we are referencing our Actions via code, we will need to enable and disable
    our Action Map. Add the following boldened lines of code to your `OnEnable()`
    and `OnDisable()` methods.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now let’s hook up our Jump Action. We will accomplish this by subscribing to
    the Jump Action’s `performed` event. Add the following code to your `OnEnable()`
    method.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们连接我们的跳跃动作。我们将通过订阅跳跃动作的`performed`事件来完成此操作。将以下代码添加到你的`OnEnable()`方法中。
- en: '[PRE23]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This should be enough to get the `OnJump()` method we already wrote working
    with your Action Map. Play the game and you can now see the cat jump when you
    press the space bar.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该足以让之前编写的`OnJump()`方法与你的动作映射一起工作。玩游戏，你现在可以在按下空格键时看到猫跳跃。
- en: 'While not entirely necessary for this example, I prefer to make a habit of
    always unsubscribing from any events I subscribe to in `OnDisable()`. Making a
    habit of doing it will save me from problems in the future when it is necessary.
    So, add the following line of code to the top of your `OneDisable()` method:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然在这个例子中并非完全必要，但我更喜欢养成在`OnDisable()`中总是取消订阅任何已订阅事件的习惯。养成这个习惯将使我未来在需要时避免问题。因此，将以下代码行添加到你的`OneDisable()`方法顶部：
- en: '[PRE24]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let’s hook up our Move Action. To do this, we can create a reference to
    the `InputAction` that represents the Move Action to make it easily accessible
    via code. Add the following variable declaration to the top of your code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们连接我们的移动动作。为此，我们可以创建一个表示移动动作的`InputAction`的引用，以便通过代码轻松访问。将以下变量声明添加到你的代码顶部：
- en: '[PRE25]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now let’s initialize it. Add the following line of code to your `OnEnable()`
    method.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们初始化它。将以下代码行添加到你的`OnEnable()`方法中。
- en: '[PRE26]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Instead of subscribing to the Move Action, we’ll poll it in our `Update()` method.
    Cut and paste the following code from within your commented out `OnMove()` method
    to the top of your `Update()` method. You can delete the `OnMove()` method now.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是订阅移动动作，而是在`Update()`方法中轮询它。将以下代码从你的注释掉的`OnMove()`方法中剪切并粘贴到`Update()`方法顶部。你现在可以删除`OnMove()`方法了。
- en: '[PRE27]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will get an error on the `context` variable. It was a parameter for the
    `OnMove()` method and does not exist within the `Update()` method. Instead of
    reading the value of `context`, we will read the value of `playerMoveAction`.
    Replace `context` with `playerMoveAction` so that your `Update()` method appears
    as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在`context`变量上遇到错误。它是`OnMove()`方法的参数，在`Update()`方法中不存在。我们不再读取`context`的值，而是读取`playerMoveAction`的值。将`context`替换为`playerMoveAction`，以便你的`Update()`方法如下所示：
- en: '[PRE28]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And that should be sufficient to get our cat moving with Actions and without
    the `PlayerInput` component. Play the game and watch the cat move around and jump
    when you press the appropriate keys.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样应该足以让我们的猫通过动作移动，而不需要`PlayerInput`组件。玩游戏，观察猫在按下适当的键时移动和跳跃。
- en: I know that setting our specific project up to use the Input System rather than
    using the Input Manager was a lot more work and may not seem worth it. And for
    this tiny example, that is probably true. However, if we wanted to create a cross
    platform version of this project that accepted inputs from multiple types of devices,
    adding new Bindings to an Action within an Action Map is significantly less work
    than adding in a new line of code for each possible input configuration we want
    to work with.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道将我们的特定项目设置为使用输入系统而不是使用输入管理器要花费更多的工作，可能看起来不值得。对于这个微小的例子，这可能确实如此。然而，如果我们想要创建一个跨平台版本的项目，该版本可以接受来自多种类型设备的输入，那么在动作映射中为动作添加新的绑定比为每个我们想要处理的可能输入配置添加新的一行代码要简单得多。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to use the New Input System to collect input
    for your game. This allows us to make an easily customizable input system that
    can make controlling our game via various input devices significantly easier in
    the long run. It may take a bit if set work to set up, but it can save you a lot
    of effort in the long run.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用新的输入系统来收集游戏输入。这使我们能够创建一个易于定制的输入系统，可以从长远来看显著简化通过各种输入设备控制游戏。虽然设置起来可能需要一些工作，但它可以节省你大量的精力。
- en: And so, we come to an end of the book! I have no more User Interface knowledge
    to impart to you.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们来到了本书的结尾！我再也没有更多用户界面知识可以传授给你们了。
