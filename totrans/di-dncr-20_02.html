<html><head></head><body>
        

                            
                    <h1 class="header-title">Dependency Injection and IoC Containers</h1>
                
            
            
                
<p>This chapter is intended to cover the Dependency Inversion principle in more depth. This means coverage of how it is used in already popular frameworks with different languages, like C#, or JavaScript. We will see what are its main advantages and caveats are, together with a brief analysis of why it is gaining momentum and consensus among developers all over the world.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>In all, we'll talk about the concepts and implementation of software artifacts like Factories and Service Locators, and how they relate to Dependency Injection. Factories and Service Locators--concepts, implementations, and how they relate to Dependency Injection</li>
<li>We'll also cover how IoC containers implement this concept, and what the main points that these IoC containers have in common are, beyond the language they're implemented in</li>
<li>Then, we'll go through a brief introduction to Object Composition, Object Lifetime, and the different types of injection, ending with some commentaries about those cases in which Dependency Injection is not the best choice</li>
<li>We will end up with some demos about popular IoC containers in use today for .NET Framework and a brief introduction to how DI is used in JavaScript frameworks, like AngularJS</li>
</ul>
<p>We'll cover the following topics in this chapter:</p>
<ul>
<li>Factories and Service Locators--Concepts, Implementations, and how they relate to Dependency Injection</li>
<li>IoC containers</li>
<li>Demos about popular IoC containers in use today for .NET Framework</li>
<li>Introduction to Object Composition, Object Lifetime, and the different types of injection</li>
<li>Brief introduction to how DI is used in JavaScript frameworks, like AngularJS</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Dependency Principle in more detail</h1>
                
            
            
                
<p>But, before all that, let's remember that we postponed a more detailed explanation of the principle for this chapter. In <a href="d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml" target="_blank">Chapter 1</a>, <em>The SOLID Principles of Software Design</em>, we discussed the five SOLID principles in general, so it's time to go deeper into the Dependency Principle. Actually, it's not that difficult. It only requires to properly understand the two basic points, which Robert Martin highlights, and express the idea by means of some source code. Recall:</p>
<p>"High-level modules should not depend on low-level modules. Both should depend on abstractions.<br/>
Abstractions should not depend upon details. Details should depend upon abstractions."</p>
<p>Remember, also, that we explained the intuitive notion of high-level and low-level classes, depending on their functionality for the application. For this respect, you can think of an app as if it was an organization hierarchy, with its different levels which depend on their role in the company.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Let's look at an example</h1>
                
            
            
                
<p>So, let's see an example that violates the dependency principle, propose a solution, and see how that solution might take several flavors depending on the application's needs (or even the programmer's tastes, in many situations).</p>
<p>We're going to use a basic .NET app to settle the initial scenario. It's just a classic console application that reads a file with a movie's information from a specific directory, and presents the content in the console.</p>
<p>We'll start with a file called <kbd>MovieDB.xml</kbd> (in the XML format and stored in the app's data subdirectory) with a data structure like the following:</p>
<pre>    &lt;Movie&gt;
      &lt;ID&gt;1&lt;/ID&gt;
      &lt;Title&gt;Jurassic Park&lt;/Title&gt;
      &lt;OscarNominations&gt;3&lt;/OscarNominations&gt;
      &lt;OscarWins&gt;3&lt;/OscarWins&gt;
    &lt;/Movie&gt; </pre>
<p>So, we can use LINQ to XML to easily read data from that file and iterate over the results to present a list of movie titles in the console. As a good practice, we'll define a class (the model) that represents the data to be read.</p>
<p>Consequently, we'll have the following:</p>
<pre>    public class Movie
    {
      public string ID { get; set; }
      public string Title { get; set; }
      public string OscarNominations { get; set; }
      public string OscarWins { get; set; }
    } </pre>
<p>Remember that you can use the Edit menu in Visual Studio and select Paste Special to get the options Paste XML as classes and Paste JSON as classes, which will build a new class in the open editor page and insert a definition according to the data pasted, with the class name <kbd>Rootobject</kbd>.</p>
<p>A first approach to the problem might end up with the following code (notice I'm using here the initial and simplest approach to have, both, a model to deal with, and the functionality required):</p>
<pre>    class Program
    {
      static string url = @"Data";
      static XDocument films = XDocument.Load(url + "MoviesDB.xml");
      static List&lt;Movie&gt; movies = new List&lt;Movie&gt;();
      static void Main(string[] args)
      {
        var movieCollection =
            (from f in films.Descendants("Movie")
        select new Movie
        {
          ID = f.Element("Title").Value,
          Title = f.Element("Title").Value,
          OscarNominations = f.Element("OscarNominations").Value,
             OscarWins = f.Element("OscarWins").Value
        }).ToList();
        Console.WriteLine("Movie Titles");
        Console.WriteLine("------------");
        foreach (var movie in movieCollection.Take(10))
        Console.WriteLine(movie.Title);
        Console.ReadLine();
      }
    } </pre>
<p>As you see, we end up with a <kbd>List&lt;Movie&gt;</kbd> collection, and iterate over it, presenting the first ten results of the <kbd>Title</kbd> field in the console (see the following screenshot):</p>
<div><img height="241" width="395" src="img/0927f89d-2d97-4ce5-ba01-c4dd5b0fec53.png"/></div>
<p>Obviously, that's fine for a single use, but not for extended purposes. Since the <kbd>Program</kbd> class has several responsibilities, it should be decoupled accordingly. So, we can think of a <kbd>MovieReader</kbd> class which takes care of reading data and apply the first SOLID principle (separation of concerns).</p>
<p>The new <kbd>MovieReader</kbd> class could look like this:</p>
<pre>    public class XMLMovieReader
    {
      static string url = @"Data";
      static XDocument films = XDocument.Load(url + "MoviesDB.xml");
      static List&lt;Movie&gt; movies = new List&lt;Movie&gt;();
      public List&lt;Movie&gt; ReadMovies()
      {
        var movieCollection =
           (from f in films.Descendants("Movie")
        select new Movie
        {
          ID = f.Element("Title").Value,
          Title = f.Element("Title").Value,
          OscarNominations = f.Element("OscarNominations").Value,
          OscarWins = f.Element("OscarWins").Value
        }).ToList();
        return movieCollection;
      }
    } </pre>
<p>So, we just moved the declarations required to access data to the new class and wrapped the reading functionality around a method <kbd>ReadMovies</kbd>, which reads and returns the required data.</p>
<p>Our <kbd>Main</kbd> entry point is now much simpler. Consider the following code snippet:</p>
<pre>    static void Main(string[] args)
    {
      XMLMovieReader mr = new XMLMovieReader();
      var movieCollection = mr.ReadMovies();
      Console.WriteLine("Movie Titles");
      Console.WriteLine("------------");
      foreach (var movie in movieCollection.Take(10))
      Console.WriteLine(movie.Title);
      Console.ReadLine();
    }</pre>
<p>That's fine, but still, our <kbd>Program</kbd> class depends on the <kbd>XMLMovieReader</kbd>. What happens if we (or somebody else) needs to read data in another format, like JSON, for example?</p>
<p>This is where Dependency Injection comes in. It would be much better than if our <kbd>Program</kbd> class could depend on an abstraction, not on a concrete class. It could be an abstract class, or it could be an interface.</p>
<p>This implies another class in charge of deciding which concrete implementation has to be served, depending on the file format. In this manner, it could also be possible to add further methods of reading data (like accessing a web service or database) without changing the already working code.</p>
<p>So we could have another specialized reader called <kbd>JSONMovieReader</kbd> with this implementation:</p>
<pre>    public class JSONMovieReader
    {
      static string file = @"Data\MoviesDB.json";
      static List&lt;Movie&gt; movies = new List&lt;Movie&gt;();
      static string cadMovies;
      public List&lt;Movie&gt; ReadMovies(string file)
      {
        var moviesText = File.ReadAllText(file);
        return JsonConvert.DeserializeObject&lt;List&lt;Movie&gt;&gt;(moviesText);
      }
    } </pre>
<p>So, we just have to implement the appropriate class depending on the format we use. Besides that, given that both files include exactly the same data, we would obtain identical results in both cases (I omitted the output for that reason).</p>
<p>Now, we should create an interface that defines the common operation that all readers will have in common; the <kbd>ReadMovies()</kbd> method.</p>
<pre>    interface IMovieReader
    {
      List&lt;Movie&gt; ReadMovies();
    } </pre>
<p>This interface is the contract that both classes (and other possible candidates) implement, so, we just have to change both declarations to explicitly indicate that they indeed implement the <kbd>IMovieReader</kbd> interface. In this way, the final definitions will be:</p>
<pre>    public class XMLMovieReader : IMovieReader
    ...
    public class JSONMovieReader : IMovieReader
    ... </pre>
<p>And the last step consists of the creation of the new class in charge of deciding which reader has to be used (the <kbd>ReaderFactory</kbd>, in this demo):</p>
<pre>    public class ReaderFactory
    {
      public IMovieReader _IMovieReader { get; set; }
      public ReaderFactory(string fileType)
      {
        switch (fileType)
        {
          case "XML":
          _IMovieReader = new XMLMovieReader();
          break;
          case "JSON":
          _IMovieReader = new JSONMovieReader();
          break;
          default:
          break;
        }
      }
    }  </pre>
<p>Notice that the constructor of <kbd>ReaderFactory</kbd> decides which type of reader is assigned to the <kbd>_IMovieReader</kbd> property. This could easily grow as needed. Our <kbd>Program</kbd> class has a new definition but it is an extensible one, and we can add as many reading methods as required with few or no changes:</p>
<pre>    class Program3
    {
     static IMovieReader _IMovieReader;
     static void Main(string[] args)
      {
       Console.SetWindowSize(60, 15);
       Console.WriteLine("Please, select the file type to read (1)<br/>         XML, (2) JSON: ");
       var ans = Console.ReadLine();
       var fileType = (ans == "1") ? "XML" : "JSON";
       _IMovieReader = new ReaderFactory(fileType)._IMovieReader;
       var typeSelected = _IMovieReader.GetType().Name;
       var movieCollection = _IMovieReader.ReadMovies();
       Console.WriteLine($"Movie Titles ({typeSelected})");
       Console.WriteLine("------------");
       foreach (var movie in movieCollection.Take(10))
       Console.WriteLine(movie.Title);
       Console.ReadLine();
      }
    }</pre>
<p>In this case, we offer an option to choose the file format, and, depending on the user's choice, the <kbd>IMovieReader</kbd> returned deals with the peculiarities of the format (you can think as well in other formats, such as Excel spreadsheets, pure text formats, comma-delimited files, databases, web services, and so on).</p>
<p>The Class Diagram that Visual Studio generates from this architecture adopts the following aspect (just right-click on the name of the class--<kbd>Program3</kbd>, in this demo, and select View Class Diagram), to obtain a graphic structure like the following:</p>
<div><img height="285" width="552" src="img/da9281ae-feb7-42e8-9130-b5d2960e0c2d.png"/></div>
<p>In summary, the <kbd>IMovieReader</kbd> interface is the contract that both classes agree upon. As long as any other class implements this interface, we'll be able to extend the potential data access mechanisms with new ways, as mentioned above.</p>
<p>An important part of this implementation is the fact that, from the user interface, we access to a read-only property, <kbd>_IMovieReader</kbd> inside the <kbd>ReaderFactory</kbd> class. In that fashion, we avoid further changes in the property, once assigned a value. Finally, we get the <kbd>Name</kbd> property of the resulting type of <kbd>_IMovieReader</kbd>, to include it in the final output.</p>
<p>The list is like the previous one, only this time the user can select the type of format (XML or JSON):</p>
<div><img height="322" width="535" src="img/7572144e-243a-453f-9e91-4c45e0d87480.png"/></div>
<p>At first sight, you might think that we have to write more code when using the DI approach, but, this only happens when we're dealing with simple demos, like in this case.</p>
<p>In real applications, with thousands or tenths of thousands of lines of code, the amount of required code usually diminishes and it greatly facilitates other aspects of the lifecycle, like maintainability, testability, extensibility, parallel development, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Aspects of Dependency Injection</h1>
                
            
            
                
<p>However, before going on with the distinct aspects of Dependency Injection, it is advisable to recall some of the basic concepts that have a deep influence in the way this principle takes form, and that we should consider before its implementation. Concretely, there are three main points to evaluate--Object Composition, Object Lifetime, and Interception.</p>
<p>Since these three topics are crucial in software development in general (not just when talking about DI), we will go back to them in <a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank">Chapter 6</a>, <em>Object Lifetime</em>, <a href="d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml" target="_blank">Chapter 7</a>, <em>Interception</em>, and <a href="795befd2-857f-40d2-ba05-cb2921168bcc.xhtml" target="_blank">Chapter 8</a>, <em>Patterns - Dependency Injection</em>, but let's include now this light introduction to serving as a basic reminder of what is to come.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object Composition</h1>
                
            
            
                
<p>One of the important notions behind Dependency Injection and other SOLID patterns is Object Composition, which, as Wikipedia (<a href="https://en.wikipedia.org/wiki/Object_composition">https://en.wikipedia.org/wiki/Object_composition</a>) reminds, "<em>is a way to combine simple objects or data types into more complex ones. Compositions are a critical building block of many basic data structures, including the tagged union, the linked list, and the binary tree, as well as the object used in object-oriented programming."</em></p>
<p>It puts a quite a clear example; types can often be divided into composite and non-composite types, and composition can be regarded as a relationship between types: an object of a composite type (for example, a car) <em>has an</em> object of a simpler type (for example, a wheel).</p>
<p>As you know, these relations have been at the heart of OOP, since the very beginning. It also has to do with Aggregation and should not be confused with inheritance.</p>
<p>Actually, there is a well-known principle of the OOP called <em>Composition over Inheritance</em>, which states that "<em>classes should achieve polymorphic behavior and code reuse by their composition (by containing instances of other classes that implement the desired functionality) rather than inheritance from a base or parent class."</em></p>
<p>Thus, the recommendation is to favor object composition over class inheritance:</p>
<div><img height="137" width="335" src="img/1b34dfae-13e8-45a6-8560-ee849353b0d6.png"/></div>
<p>(Image courtesy: <a href="https://atomicobject.com/resources/oo-programming/object-oriented-aggregation">https://atomicobject.com/resources/oo-programming/object-oriented-aggregation</a>)</p>
<p>The previous schema shows the difference between both approaches: composition and aggregation. The individual elements used to compose a car are part of the car. The object could not perform its tasks without them.</p>
<p>In the second case, passengers could come and go (or even, now, since driverless cars don't require any), but they can eventually be managed by the car's instance.</p>
<p>Keep in mind that Wikipedia (<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">https://en.wikipedia.org/wiki/Composition_over_inheritance</a>) remarks that--"<em>Classes implementing the identified interfaces are built and added to business domain classes as needed. Thus, system behaviors are realized without inheritance. In fact, business domain classes may all be base classes without any inheritance at all. Alternative implementation of system behaviors is accomplished by providing another class that implements the desired behavior interface. Any business domain class that contains a reference to the interface can easily support any implementation of that interface and the choice can even be delayed until</em> <em>run time."</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object Lifetime</h1>
                
            
            
                
<p>In the previous demo, we've seen a way to get rid of a classes' dependencies by means of abstractions, and the possibilities that we have later on to change those abstractions as needed, along with the application's lifecycle.</p>
<p>But, besides this fundamental ability, this practice allows us to determine abstractions' life: when they are born (instantiated) and when they go out of scope (and leave the Garbage Collector in charge of the task of finishing the useful life).</p>
<p>You know, when an object is not referenced by any other object it automatically becomes eligible for destruction, liberating its associated memory.</p>
<p>The way the GC works is not trivial (although transparent to the user) and quite a few things should be considered, especially the way in which object generations are processed and the memory recovered, even in the Simplified Model (see the following image):</p>
<div><img height="288" width="366" src="img/c1bfa354-214e-45de-8d0c-bf93a03090ad.png"/></div>
<p>(Image courtesy: <a href="https://msdn.microsoft.com/en-us/library/ms973837.aspx">https://msdn.microsoft.com/en-us/library/ms973837.aspx</a>)</p>
<p>A little about Garbage Collection from Wikipedia (<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>)--"<em>In computer science, garbage collection (GC) is a form of automatic memory management. The garbage collector, or just collector, attempts to reclaim garbage</em> <em>or memory occupied by objects that are no longer in use by the program. Garbage collection was invented by John McCarthy around 1959 to simplify manual memory management in Lisp</em>."</p>
<p>Bear in mind that problems might arise when two objects share an instance of the same interface, or when a new scenario shows up when we inject two distinct instances to different clients.</p>
<p>The way those objects are managed in memory also depends on our code to a large extent. Therefore, we will explain those intricacies in <a href="d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml" target="_blank">Chapter 7</a>, <em>Interception</em>, so you can have a detailed picture of this behavior and the implications it might have in your code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interception</h1>
                
            
            
                
<p>We can consider Interception as an application of the Decorator design pattern. For some authors, Interception is the process of pre-filtering a given call, in a way that we can include (or exclude) certain information from its standard (original) behavior.</p>
<p>In the case of the IMovieReader implementation, the creation of a valid object capable of reading movies is redirected to the <kbd>ReaderFactory</kbd>, instead of the previous call to a concrete constructor. This is possible because abstractions allow us to defer instantiation and decide what to create depending on arguments, a system's configuration, configuration files, and so on.</p>
<p>Another typical usage of interception relates to Instrumentation: distinct aspects of the application that go beyond application domains, like logging, auditing, validation and many others.</p>
<p>Finally, we can find interception when we capture the default behavior of system components using the so-called sub-classing technique, which allows for interleaving system calls and, effectively, change the system's behavior, substituting it for our own.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ways to implement DI</h1>
                
            
            
                
<p>In this case, Dependency Injection is implemented by means of a constructor, which is the preferred way of today's implementation for many of the popular IoC containers we can find for the .NET Framework (and even, for other frameworks, like Angular).</p>
<p>However, there are other two classical paths for DI implementation: via properties (also called setter injection) or methods.</p>
<p>In the Property Injection flavor, we're dealing with a scenario in which it makes sense to allow the user to change the dependency once the program is running. For instance, imagine that you start with a concrete implementation, and later on, the client or some program's condition, require change.</p>
<p>There are situations in which that change doesn't require -strictly speaking- a new instance of the class, so it would not be coherent to create it just to change a given value. It's much better to keep the level of independence that DI promotes, but allow the client of the dependency to change that value once used.</p>
<p>To achieve this goal we must create a writable property (not a read-only one, like we did before). But, there's a danger. We have to avoid null values. We can do this easily by creating a default value, something very easy and concise to implement using C# latest techniques, as we'll see in a demo. So, a change of a dependency's value is the key to determining if we have to use properties in the injection.</p>
<p>In Method Injection, the code block that requires the dependency is usually a parameter of some method, and the purpose of the dependency's argument is to provide a context, which determines how the method should behave.</p>
<p>So, we can say that the scenario is scope-dependent. When the scope of the dependency is somehow local, as it happens when it is only being used in one concrete method (it does not affect the whole class), it's a good practice to limit the presence of the dependency exclusively to the method that it is going to use it.</p>
<p>Let's see a couple of samples about these two ways of implementing DI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Property Injection in action</h1>
                
            
            
                
<p>Let's imagine something very simple for this demo. The code presents an initial configuration of color values for the current console, together with a message indicating those values. We offer the user the ability to change themes, to avoid unreadable combinations.</p>
<p>We reduce these combinations to light and dark, besides the initial one, which is black/white. We could define a very simple <kbd>ConsoleDisplayFactory</kbd> class with two default values that are assigned in its instantiation:</p>
<pre>    public class ConsoleDisplayFactory
    {
     // Both properties asume a default (initial) configuration
     public ConsoleColor ForeColor { get; set; } = ConsoleColor.White;
     public ConsoleColor BackColor { get; set; } = ConsoleColor.Black;
     public ConsoleDisplayFactory ConfigureConsole (string theme)
     {
       switch (theme)
       {
         case "light":
         BackColor = ConsoleColor.Yellow;
         ForeColor = ConsoleColor.DarkBlue;
         break;
         case "dark":
         BackColor = ConsoleColor.DarkBlue;
         ForeColor = ConsoleColor.Yellow;
         break;
         default:
         break;
       }
       return this;
     }
    }</pre>
<p>With this definition, every time we create an instance, both properties (<kbd>ForeColor</kbd> and <kbd>BackColor</kbd>) are assigned the default theme configuration. Our <kbd>Program</kbd> class will depend on <kbd>ConsoleDisplayFactory</kbd>, but we make sure that both values hold a consistent color configuration.</p>
<p>Now, our main entry point, located in <kbd>Program4</kbd>, would look like the following code:</p>
<pre>    class Program4
    {
      static ConsoleDisplayFactory cdf = new ConsoleDisplayFactory();
      static void Main(string[] args)
      {
        // Initial config
        cdf.ConfigureConsole("default");
        Console.BackgroundColor = cdf.BackColor;
        Console.ForegroundColor = cdf.ForeColor;
        Console.WriteLine("Console Information");
        Console.WriteLine("-------------------");
        Console.WriteLine("Initial configuration: \n");
        Console.WriteLine($"Back Color: { cdf.BackColor}");
        Console.WriteLine($"Fore Color: { cdf.ForeColor }");
        // User's config
        Console.WriteLine("New theme ('light', 'dark',<br/>            'Enter'=&gt;default):");
        var newTheme = Console.ReadLine();
        cdf.ConfigureConsole(newTheme);
        Console.BackgroundColor = cdf.BackColor;
        Console.ForegroundColor = cdf.ForeColor;
        Console.WriteLine("New configuration: \n");
        Console.WriteLine($"Back Color: { cdf.BackColor}");
        Console.WriteLine($"Fore Color: { cdf.ForeColor }");
        Console.ReadLine();<br/>      }      
    }</pre>
<p>Observe changes to console configuration that are performed via the <kbd>ConsoleDisplayFactory</kbd> instance, which is a property of the <kbd>Program4</kbd> class. For this initial version of the demo, we have opted for a method (which serves as a setter) that takes care of the values assigned.</p>
<p>Another approach could be to code the <kbd>ForeColor</kbd> and <kbd>BackColor</kbd> properties of the <kbd>ConsoleDisplayFactory</kbd> class in a way that the setters of each property would take care of assigning the suitable changes for each theme.</p>
<p>Though pretty simple, this code shows the idea behind Property Injection. We don't need the whole class to be re-instantiated, so we allow the client to change the required properties, but taking care that the results are injected according to business rules.</p>
<p>The fact that we use an injector method or program the setters directly will always depend on the architecture of the code and your necessities.</p>
<p>(We omit the output since it is quite trivial in this case).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Method Injection in practice</h1>
                
            
            
                
<p>As we previously mentioned, the key here is that the injected resource makes sense inside a method of the client class. There are two main reasons for this, which are the following:</p>
<ul>
<li>The injected parameter affects the way the method behaves and it can change along its life-runtime (in distinct method calls)</li>
<li>The injected parameter's functionality affects the method's block of code and nothing else. Therefore, there's no need to create a class-scope dependency when it is only used inside that block</li>
</ul>
<p>This scenario shows up when we are coding a method that has some functionality that is dynamic in nature (an HTTP context, access to a directory that contains files that might change during the execution, Web Sockets, and so on.).</p>
<p>It is well-known that the .NET Framework already implements this feature in some classes belonging to a variety of namespaces. For example, in the <strong>Base Class Libraries</strong> (<strong>BCL</strong>), the <kbd>System.ComponentModel</kbd> namespace allows using the <kbd>TypeConverter</kbd> class which is especially useful in contexts where WPF is involved, to allow conversions between pure CLR types and XAML types or other business logic types.</p>
<p>Some of this classes' methods use an instance of <kbd>ITypeDescriptorContext</kbd> that carries information about the context in which the execution takes place.</p>
<p>But there's a simpler and much more common scenario in which this is happening all the time: the structure of the .NET's event system, and I think that understanding the way it works is very useful to realize how we can find implementations of this pattern in every-day situations, and how this is being used since the very beginning.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">.NET event architecture as Model Injection</h1>
                
            
            
                
<p>Let's think of the event model for a second: in practice, method A calls method B and passes some arguments (two, by default). When you program a Click, <kbd>SelectedItemChanged</kbd>, of <kbd>FormClosing</kbd> event in classic (and modern) .NET, a communication process takes place.</p>
<p>The process involves a method responsible for calling (the sender) and the callee (the receiver). This can be represented with the classic scheme of any other communication process that we all know from the first books of Information Theory:</p>
<div><img height="206" width="318" src="img/0a08780c-c39b-4f75-87d0-4dc2a64d6876.png"/></div>
<p>Aggregation is a simple collection, like a bag of marbles, while composition implies internal/functional dependencies, like the hinges on a box. Cars aggregate passengers; they get in and out without breaking the car's functionality but the tires are components; remove one and the car no longer functions correctly.<br/>
<br/>
If you don't know these concepts (Composition and Aggregation), PACKT has excellent books to start with that, like <em>Learning Object-Oriented Programming</em> by Gaston C. Hillar (<a href="https://www.packtpub.com/application-development/learning-object-oriented-programming">https://www.packtpub.com/application-development/learning-object-oriented-programming</a>).</p>
<p>There is a correspondence between the two schemes in the four elements implied:</p>
<ul>
<li>Issuer (sender): It is the method that makes the call</li>
<li>Receiver: It is another class (or the same) responding in another method</li>
<li>Channel: It is the environment, replaced by a managed environment in .NET</li>
<li>Message: The set of values passed to the receiver (the EventArgs in .NET)</li>
</ul>
<p>Let's think of a Windows app in which the user interface generates events, as, for example, when we use a button to close the window. The piece of code that represents such a scenario is expressed with some code like this:</p>
<pre>    private void btnClose_Click(object sender, EventArgs e)
    {
      this.Close();
    } </pre>
<div><img height="185" width="381" src="img/324631da-adcb-4d77-80f8-0e36b697c692.png"/></div>
<p>Who launches the execution of this code? Well, the Button object, when we program the click event includes the following code in the designer's section of the <kbd>Form</kbd> class:</p>
<pre>    this.btnClose.Click += new System.EventHandler(this.btnClose_Click);</pre>
<p>This creates a delegate of type <kbd>EventHandler</kbd> (the default one) which is going to be in charge of calling the destination method, every time the user clicks on it. To avoid possible problems, that event is just a class with some characteristics:</p>
<ul>
<li>Its signature is the same as the method to be called. In this manner, possible casting problems are avoided since there is no need for type conversions.</li>
<li>The delegate checks for the presence and availability of the <kbd>btnClose_Click</kbd> method before the call, so it guarantees there are no pointer-to-null problems.</li>
</ul>
<p>Given that casting and pointers-to-nowhere were the two of the main causes of the infamous BSODs (Blue Screens of Death), the implantation of this architecture was something crucial from the very beginning of .NET.</p>
<p>However, there is something else here that implies Method Injection, if you analyze the code and, even in those cases, like in the next demo, when the delegate is not the default.</p>
<p>To really appreciate this point, let's program the <kbd>FormClosing</kbd> event that will be launched whenever the user clicks the Close button or tries to close the window in any of the other available ways: <em>Alt</em> + <em>F4</em>, the window's x button, or the window's menu:</p>
<div><img src="img/1b7a2985-0940-4f35-8ffe-c240ca1ab426.png"/></div>
<p>As you can see, this time the second argument of the <kbd>FormClosing</kbd> event is not the default, but an instance of an object that inherits from <kbd>EventArgs</kbd>, and encloses extra information providing the context, that we were talking about.</p>
<p>Actually, that object holds two properties: <kbd>Cancel</kbd> (which is assignable and forces a stop in the exit procedure), and <kbd>CloseReason</kbd>, a read-only property that indicates which mechanism really launched the closing process.</p>
<p>So, we're not programming or instantiating this parameter: it is given to us via injection, every time we define an event procedure. And that internal injection system is responsible for providing the information relevant to the execution context. This is a clear sample of method injection.</p>
<p>If you peek into the definition of the <kbd>FormClosingEventArgs</kbd> parameter, you will see that it is, indeed, another class that inherits from <kbd>CancelEventArgs</kbd> (which, in turn, inherits from EventArgs):</p>
<pre>    public class FormClosingEventArgs : CancelEventArgs
    {
     //
     // Summary:
     // Initializes a new instance of the <br/>            System.Windows.Forms.FormClosingEventArgs class.
     //
     // Parameters:
     // closeReason:
     // A System.Windows.Forms.CloseReason value that represents <br/>         the reason why the form
     // is being closed.
     //
     // cancel:
     // true to cancel the event; otherwise, false.
     public FormClosingEventArgs(CloseReason closeReason, bool cancel);

     //
     // Summary:
     // Gets a value that indicates why the form is being closed.
     //
     // Returns:
     // One of the System.Windows.Forms.CloseReason enumerated values.
     public CloseReason CloseReason { get; }
   }  </pre>
<p>It's interesting to note that <kbd>ClosingEventArgs</kbd> also belongs to the namespace <kbd>System.ComponentModel</kbd> that we mentioned previously.</p>
<p>So, even when we're doing something as simple as closing a window, we're implicitly using method injection, that is at the heart of the .NET Framework.</p>
<p>This architecture can be extended by the user in many ways, even using techniques like event chaining when we need to concatenate processes that depend on the user's choice and that are usually generated via events, for example.</p>
<p>A typical case for even chaining is when a user's selection from a combo (Like Select a Country), generates code that fills up another combo, let's say Select a City. You first have to select the country if you want the cities combo to be filled with the cities belonging to a given country.</p>
<p>One such case could be when the closing process of a window (something like the preceding code shown) requires an extra user intervention. For instance, imagine that you have to ask the user if he/she wants to save the audits (or perform any other action) but only in the case that a previous question is affirmative, like confirming that the user wants to exit the application (which might, in turn, depend on other conditions, like the <kbd>CloseReason</kbd> expressed in the previous code of the FormClosing event.</p>
<p>One possible approach would be to create a generic event on our own, that could be launched if the requested conditions apply. Let's say that only if <kbd>ClosingReason</kbd> is <kbd>CloseReason.UserClosing</kbd>, we should ask the user to confirm application exit and, in case the answer is positive, ask him again if he/she wants to save the information.</p>
<p>We could write the following:</p>
<pre>    private void frmMethodInjection_FormClosing(object sender,<br/>       FormClosingEventArgs e)
    {
      if(e.CloseReason == CloseReason.UserClosing)
      {
        var res = MessageBox.Show("Confirm application exit?", "Notice",
        MessageBoxButtons.YesNo, MessageBoxIcon.Question);
        if (res == DialogResult.Yes)
        FormClosingExtended?.Invoke(this, DateTime.Now.ToLongTimeString());
        else e.Cancel = true;
      }
    }
    public event EventHandler&lt;string&gt; FormClosingExtended; </pre>
<p>So, we're invoking the event <kbd>FormClosingExtended</kbd> only when the if block evaluates to true. But, using the new generic event handler we can pass login information to another event that jumps from there to a distinct event procedure:</p>
<pre>    private void FrmMethodInjection_FormClosingExtended(object<br/>       sender, string e)
    {
      var ans = MessageBox.Show($"Save Closing time: ({e})?","Notice",
      MessageBoxButtons.YesNo,MessageBoxIcon.Question);
      if (ans == DialogResult.Yes)
      {
         File.WriteAllText("ClosingTime.txt", e);
      }  
    } </pre>
<p>This event procedure receives data in the e argument and also asks the user if he/she wants to save it as audit information. In this manner, we don't have to concatenate two <kbd>MessageBox</kbd> calls and the code is clearly separated.</p>
<p>Besides that, since the e argument could be a generic event handler of any kind, the type of information passed as the event argument, could also be of any kind, of any complexity level. For instance, it could be an object with its own methods suitable for validation purposes, security checking, etc.</p>
<p>The only thing missing in the code is to define the event handlers for each of the events implied in the process, which we can do inside the <kbd>MethodInjection</kbd> constructor:</p>
<pre>    public frmMethodInjection()
    {
      InitializeComponent();
      this.FormClosing += frmMethodInjection_FormClosing;
      FormClosingExtended += FrmMethodInjection_FormClosingExtended;
    }</pre>
<p>So, in terms of DI, we're using the internal injection engine inside .NET Framework in two different ways:</p>
<ul>
<li>In the first case, to obtain information passed to us by the framework in relation to the cause that provoked that event to happen (<kbd>ClosingReason</kbd>).</li>
<li>In the second, because we have implemented our own event, that is executed in concatenation to the previous one and receives the required information expecting the user's approval.</li>
</ul>
<p>Note that, in case that no business logic argument is required for the second event handler, we could have registered it also for the FormClosing event, since events are multicast in .NET</p>


            

            
        
    

        

                            
                    <h1 class="header-title">DI containers</h1>
                
            
            
                
<p>In everyday practice, a good part of the plumbing to have DI working is not done via manual coding, but using something called DI Containers (also called IoC Containers). The previous demo using the .NET Framework event's system implies the existence of some DI Container.</p>
<p>Basically, a DI Container is a software library that facilitates the use of Dependency Injection and its based methodologies, like object composition, lifetime management, and so on. This is quite convenient for the programmer, who doesn't have to worry about the details of creation, destruction, etc.</p>
<p>Many people have some confusion with DI and IoC. You can refer to this website to clear out any confusions: <a href="http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection">http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection.</a></p>
<p>In many cases, DI Containers enforce several good practices, like avoiding duplication of instances, by supplying singleton instances of the required component, like it happens in AngularJS since the initial versions.</p>
<p>In .NET, as we have mentioned, IoC is present in several scenarios, and the following image shows some of the main components that use this technique:</p>
<div><img height="270" width="443" src="img/da9d1376-b23a-441a-b0ee-5602c2c34a19.png"/></div>
<p>(Image courtesy: <a href="https://hotproton.com/category/dependency-injection/">https://hotproton.com/category/dependency-injection/</a>)</p>
<p>As you can see in the graphic, .NET (even in the previous versions), holds several components that provide Inversion of Control (IoC), either linked to Events and Delegates, as we've seen in previous demos, or as Service Locators, or DI Injection mechanisms.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service locators</h1>
                
            
            
                
<p>Basically, a service locator is just a design pattern that instructs the implementer on how to construct DI containers capable of obtaining a service with a strong abstraction layer.</p>
<p>There's a condition that all service locators require: services have to be registered, so they can be later found and served at the code's request.</p>
<p>Wikipedia (<a href="http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection">http://www.itgo.me/a/8238364259424879474/inversion-of-control-vs-dependency-injection</a>) summarizes the advantages of Service Locators in three main points:</p>
<ul>
<li>
<p>The service locator can act as a simple run-time linker. This allows code to be added at run-time without re-compiling the application, and in some cases without having to even restart it.</p>
</li>
<li>
<p>Applications can optimize themselves at run-time by selectively adding and removing items from the service locator. For example, an application can detect that it has a better library for reading JPG images available than the default one, and alter the registry accordingly.</p>
</li>
<li>
<p>Large sections of a library or application can be completely separated. The only link between them becomes the registry.</p>
</li>
</ul>
<p>In general, we can say the application of the Dependency Inversion principle leads to the construction of IoC containers and they reflect in concrete DI techniques and Service Locators. (See the following diagram):</p>
<div><img height="274" width="398" src="img/ae91c95e-f636-47b9-9073-e76f66fcfa59.png"/></div>
<p>(Image courtesy: <a href="http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/">http://www.dotnettricks.com/learn/dependencyinjection/understanding-inversion-of-control-dependency-injection-and-service-locator/</a>)</p>
<p>Of course, these advantages don't go without their counterparts. Possible problems include the registry acting like a black box for the rest of the application, uniqueness, security vulnerabilities, hiding class dependencies, adding some testing difficulties, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">DI Containers for .NET</h1>
                
            
            
                
<p>Besides the internal functionality related to DI inside .NET, it is very common to use external containers that provide extra or extended functionality to programmers, and, being .NET--a very popular programming framework, many have proliferated in recent years.</p>
<p>So, our criteria here will be showing the basic implementation of those that seem to have a greater acceptance in the community, like Unity, Castle Windsor, StructureMap, and Autofac.</p>
<p>Actually, the number of choices available has kept growing in the last few years, and some of them are pretty popular as well, like Ninject, Simple Injector, Dynamo, LinFu, Spring.NET, Hiro, and so on, so our choice, in this case, was mainly driven by the level of implementation in the community, their ease of use, their API's consistency, and the performance tests in the latest versions. Since I don't want to pronounce myself about any of those tests, you can take a look at different benchmarks available on the web, and you'll probably come to the same or similar conclusion as I did.</p>
<p>These DI Containers (and others) share a few things in common: they all require a previous configuration, and they have the ability to resolve the required dependencies at runtime. The following schema shows an approach to this idea:</p>
<div><img height="130" width="332" src="img/06bfc163-a1c4-4682-82a1-e65663472e37.png"/></div>
<p>In practice, this means we will instantiate and configure a container object, and later on, we'll ask the container to resolve the required dependencies in one or more locations within our code.</p>
<p>Besides that, in most of the cases, components are resolved from the same instance that we initially instantiate.</p>
<p>A common (and very simple) context for our demos:</p>
<p>Since complications will show up themselves when coding real-life applications, I've chosen a very, very, simple starting point, that can serve us as a common scenario to solve the DI problems it presents. It's based on our previous idea of the <kbd>MovieReader</kbd> but let's say in this case that we don't even read anything from disk (only display a message in the console), to focus on the code's architecture and not on the details of its implementation.</p>
<p>The demo proposes the existence of two classes in charge of reading some books' information from the disk, and they both share a common interface <kbd>IBookReader</kbd>, which implements a unique method <kbd>ReadBooks()</kbd>. These three elements comprise the Data Access Layer:</p>
<pre>     // Data Access Layer
     public interface IBookReader
     {
       void ReadBooks();
     }
     public class XMLBookReader : IBookReader
     {
       public void ReadBooks()
       {
         Console.WriteLine("Books read in XML Format");
       }
     }
     public class JSONBookReader : IBookReader
     {
       public void ReadBooks()
       {
         Console.WriteLine("Books read in JSON Format");
       }
     }</pre>
<p>Pretty simple, right? Now, we build another succinct Business Layer, made up of a class called <kbd>BookManager</kbd>, whose only purpose is to perform business logic, so it exposes a public constructor that receives an instance of one of the two possible readers, and implements a call to the <kbd>ReadBooks</kbd> method, that in turn, will refer to the reading method that corresponds to each case:</p>
<pre>    public class BookManager
    {
      public IBookReader bookReader;
      public BookManager(IBookReader reader)
      {
        bookReader = reader;
      }
      public void ReadBooks()
      {
        bookReader.ReadBooks();
      }
    }</pre>
<p>Finally, in the user interface, that in this case is the <kbd>Console</kbd>, we ask the user to decide the reading mechanism and call the corresponding version of the <kbd>BookManager</kbd>, so we can call the <kbd>ReadBooks</kbd> method:</p>
<pre>    static void Main(string[] args)
    {
      UnityContainer uc = new UnityContainer();
      BookManager bm;
      Console.WriteLine("Please, select reading type (XML, JSON)");
      var ans = Console.ReadLine();
      if (ans.ToLower() == "xml")
      {
         bm = new BookManager(new XMLBookReader());
      }
      else { bm = new BookManager(new JSONBookReader()); }
        bm.ReadBooks();
      Console.ReadLine();
    }</pre>
<p>Up to this point, it's a very simple code, already using some dependency inversion, but still stuck to the creation of the type of reader in the user interface. That's exactly what we obtain when we use an external creation mechanism that takes care of this work for us.</p>
<p>Let's see now how we can change this using the distinct DI Containers mentioned previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Unity Container</h1>
                
            
            
                
<p>The Unity container has been in place for quite a few years now. Somehow, it was the official Microsoft external container and has been linked to the <em>Patterns &amp; Practices</em> initiative for many years.</p>
<p class="mce-root">Please note that Unity is not an official Microsoft product or does not belong to the Patterns &amp; Practices team anymore. The project has been redirected to other people (Pablo Cibraro and Pedro Wood), as Immo Landwerth published in .NET Blog in 2015 (<a href="https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/">https://blogs.msdn.microsoft.com/dotnet/2015/08/21/the-future-of-unity/</a>), commenting: "<em>Dependency injection containers for .NET have continued to mature and evolve significantly. In addition, open source components are now more accepted. The need for having an "official" container from Microsoft is no longer as widespread as it once was.</em>"</p>
<p>That said, Unity is still a very common feature in thousands of projects, and it has reached version 4.01, which you can install inside any project using the <kbd>NuGet Package Manager</kbd> available from the contextual menu of the <kbd>Solution Explorer,</kbd> or the <kbd>Project</kbd> menu as well, either in V. Studio 2017 or other versions.</p>
<p>Once installed, you'll see that it really references two different libraries: Unity 4.01 and the CommonServiceLocator 1.30 library, as you can see in the following screenshot:</p>
<div><img src="img/e4df937a-fc0a-47b4-b4d9-00d687b67d88.png"/></div>
<p>Once installed, you'll see four new references to DLL's in the Solution's Explorer: three of them belong to Unity and the fourth one to <kbd>CommonServiceLocator</kbd>:</p>
<div><img height="260" width="386" src="img/f14847a3-8bd7-45c7-a3cd-d7c267bc37c3.png"/></div>
<p>Inside the <kbd>Microsoft.Practices.Unity.Configuration</kbd> library, you have utilities that allow writing the configuration required in an XML file, so that it serves as the initial settlement for the DI Container. Classes in that namespace will allow you to read and configure a given execution context based on that XML.</p>
<p>On the other side, the <kbd>Microsoft.Practices.Unity.RegistrationByConvention</kbd> library is intended to provide a programmable way of configuration to register multiple types with the container automatically by using a set of rules and conventions, as the official documentation defines (<a href="https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx">https://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx</a>).</p>
<p>Now, if we just want to register those classes belonging to our Business Layer and Data Access Layer, the most evident way to include all elements in our business model and have our data ready, would be something like this:</p>
<pre>    static void Main(string[] args)
    {
      UnityContainer uc = new UnityContainer();
      uc.RegisterType&lt;BookManager&gt;();
      uc.RegisterType&lt;IBookReader, XMLBookReader&gt;();
      uc.RegisterType&lt;IBookReader, JSONBookReader&gt;();
      BookManager bm = uc.Resolve&lt;BookManager&gt;();
      bm.ReadBooks();
      Console.ReadLine();
   }</pre>
<p>Notice, however, that we're defining <kbd>BookManager</kbd> together with <kbd>XMLBookReader</kbd> and <kbd>JSONBookReader</kbd>. This means that if we run the code, we get an instance of the last registered class (<kbd>JSONBookReader</kbd>), which becomes the default option. The reason is that we're not naming these registrations, so they're assigned unnamed identifiers.</p>
<p>You can test the demo inside <kbd>Chapter02_02.Unity</kbd> namespace and insert breakpoints to prove it.</p>
<p>To reproduce the initial situation in which the user selects the format, we need to register distinct aliases for registered types, so they can be resolved at runtime, passing the concrete version that we need.</p>
<p>Besides that, notice that Unity plays the role that was previously playing the <kbd>BookManager</kbd> class. So in this case, we don't need the <kbd>BookManager</kbd> class anymore:</p>
<pre>    static void Main(string[] args)
    {
      Console.WriteLine("Please, select reading type (XML, JSON)");
      // we asume a predefault value
      var format = (Console.ReadLine() != "xml") ? "json" : "xml";
      UnityContainer uc = new UnityContainer();
      uc.RegisterType&lt;IBookReader, XMLBookReader&gt;("xml");
      uc.RegisterType&lt;IBookReader, JSONBookReader&gt;("json");
      IBookReader ibr = uc.Resolve&lt;IBookReader&gt;(format);
      ibr.ReadBooks();
      Console.ReadLine();
    }</pre>
<p>Now, Unity resolves the dependency with the parameter we pass to the <kbd>Resolve()</kbd> method, as we can see it by setting a breakpoint in this line, or simply, watching the output.</p>
<p>The <kbd>UnityContainer</kbd> class admits alternative registration mechanisms. For example, we could use a new business layer class entirely dedicated to Unity registration, with the following code (notice that we should reference <kbd>Microsoft.Practices.Unity</kbd> in the <kbd>using</kbd> section of our code):</p>
<pre>    public class UnityRegistration
    {
      public void Register()
      {
        using (var container = new UnityContainer())
        {
          container.RegisterTypes(
          AllClasses.FromLoadedAssemblies(),
          WithMappings.FromAllInterfaces,
          WithName.Default,
          WithLifetime.ContainerControlled);
        }
      }
    }</pre>
<p>In this manner, all classes from the loaded assemblies are registered for Unity, all mappings (or correspondences) are defined between the existing interfaces and their implementing classes, their default names are used and their lifetime is assigned to be managed by the container, so it's the container itself which decides at runtime when to leave object's instances to the Garbage Collector.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Castle Windsor</h1>
                
            
            
                
<p>One of the winners in benchmarks and usability tests, Castle Windsor has been around for quite some time, and now rallies all activities around its dedicated GitHub project site at <a href="https://github.com/castleproject/Windsor">https://github.com/castleproject/Windsor.</a></p>
<p>The community around this project is very active and, at the time of writing these lines, has more than 500 stars and 265 forks, and they were preparing to release version 3.4. Of course, you can download it and install it separately, or use <kbd>NuGet</kbd> and have it installed for your project in the usual manner:</p>
<div><img height="323" width="331" src="img/c227ceb1-14f2-4b9c-9a8f-425c8c373af2.png"/></div>
<p>The process of installation really installs two components: Castle.Core 3.3 and Castle.Windsor 3.4. Both work together, although they include several namespaces to cover many of the possible programming situations in which we might need dependency injection (and other features).</p>
<p>Castle Windsor's API set is very rich in possibilities and the documentation in the official site lets you start quickly with some samples (see <a href="https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md">https://github.com/castleproject/Windsor/blob/master/docs/basic-tutorial.md</a>).</p>
<p>For our demo, we only have to reference those namespaces required to initialize the <kbd>WindsorContainer</kbd> class and proceed with the registration:</p>
<pre>    using Castle.Windsor;
    using Castle.MicroKernel.Registration; </pre>
<p>The first one allows the creation of a new <kbd>WindsorContainer</kbd> class, while the other defines the required classes for registration. The whole process is similar to the one we saw previously with Unity:</p>
<pre>    static void Main(string[] args)
    {
      Console.WriteLine("Please, select reading type (XML, JSON)");
      // we asume a predefault value
      var format = (Console.ReadLine() != "xml") ? "json" : "xml";
      var container = new WindsorContainer();
      container.Register(Component.For&lt;IBookReader&gt;().<br/>         ImplementedBy&lt;XMLBookReader&gt;().Named("xml"));
      container.Register(Component.For&lt;IBookReader&gt;().<br/>           ImplementedBy&lt;JSONBookReader&gt;().Named("json"));
      IBookReader ibr = container.Resolve&lt;IBookReader&gt;(format);
      ibr.ReadBooks();
      Console.ReadLine();
      // clean up, application exits
      container.Dispose();
    }</pre>
<p>Notice how the Component class includes static, generic methods to allow definitions of any interface (<kbd>IBookReader</kbd>, here), and you can concatenate successive calls to indicate which class implements what interface and what name that we want to assign to each registration, so it can be solved at runtime later on.</p>
<p>Once the registration is completed, the way to resolve it in a concrete implementation accepts a format that is identical to the one we used with Unity.</p>
<p>The code just runs exactly the same as in the previous demo.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using StructureMap</h1>
                
            
            
                
<p>The official site for this DI container defines precisely the differences and spirit behind this implementation:</p>
<p><kbd>StructureMap</kbd> is the oldest, continuously used IoC/DI container for .NET dating back to its first public release and production usage all the way back in June 2004 on .NET 1.1. The current 4. release represents 12+ years of lessons learned in the StructureMap and greater .NET community--while also wiping away a lot of legacy design decisions that no longer make sense today.</p>
<p>So, we're dealing with a veteran here, and that means stability, together with a wide presence in internet forums and coder's sites, like <kbd>StackOverflow</kbd>.</p>
<p class="mce-root">The philosophy that lies behind usage and configuration is quite similar to the other two we've already seen, but it offers several ways to configure the application. As the official documentation states to this respect: "<em>from release 3.0 onwards, StructureMap provides a streamlined fluent interface called the Registry DSL to configure a StructureMap Container with both explicit registrations and conventional auto-registrations.StructureMap no longer supports XML configuration or MEF-style attribute configuration -- but there is some facility for rolling your own attribute-based configuration support.</em>"</p>
<p>The main difference is that it recommends a configuration approach via lambda expressions, but still with similar mechanisms, as you can see in the following code used to create and configure the Container object in the same operation:</p>
<pre>    var container1 = new Container(c =&gt;
    {
      c.For&lt;IFoo&gt;().Use&lt;Foo&gt;();
      c.For&lt;IBar&gt;().Use&lt;Bar&gt;();
    });</pre>
<p>The other main choice relies on creating a <kbd>Registry</kbd> object and then configuring the container based on it. Something like the following:</p>
<pre>    public class FooBarRegistry : Registry
    {
      public FooBarRegistry()
      {
        For&lt;IFoo&gt;().Use&lt;Foo&gt;();
        For&lt;IBar&gt;().Use&lt;Bar&gt;();
      }
    }
    var container1 = new Container(new FooBarRegistry()); </pre>
<p>All this depends on the architecture and complexity of the application to build. For our demo purposes, we will first reference the library (this time there is only one namespace), via NuGet, that presents this installation option:</p>
<div><img height="425" width="462" src="img/10aa6b00-9d5f-4a77-a005-05e3df34616a.png"/></div>
<p>And, for a basic configuration and usage, we only need to reference the basic <kbd>StructureMap</kbd> namespace:</p>
<pre>     using StructureMap;</pre>
<p>The source code equivalent to the previous demos would be (with identical results in execution):</p>
<pre>    static void Main(string[] args)
    {
      Console.WriteLine("Please, select reading type (XML, JSON)");
      // we asume a predefault value
      var format = (Console.ReadLine() != "xml") ? "json" : "xml";
      var container = new Container();

      // container configuration
      container = new Container(x =&gt; {
      x.For&lt;IBookReader&gt;().Add&lt;XMLBookReader&gt;().Named("xml");
      x.For&lt;IBookReader&gt;().Add&lt;JSONBookReader&gt;().Named("json");
    });
      var ibr = container.GetInstance&lt;IBookReader&gt;(format);
      ibr.ReadBooks();
      Console.ReadLine();
      // clean up, application exits
      container.Dispose();
    }</pre>
<p>Notice how the container is configured by passing a lambda expression to the newly created instance of Container and, within the body expression, we use the following pattern:</p>
<pre>container  For &lt;Interface&gt;  Add(Class)  Named("alias")</pre>
<p>The preceding pattern allows us to express as many registrations as we want in a single operation.</p>
<p>There's only a slight variation in the way the <kbd>IBookReader</kbd> instance is obtained because it doesn't use the resolve paradigm. In turn, we can find several methods of resolving instances, as shown in the following screenshot:</p>
<div><img height="164" width="305" src="img/ad0131e3-88bb-425f-a68b-a9e50357654d.png"/></div>
<p>Of course, execution is the same as in the other cases and there is nothing really relevant in the output, which you can find in the source code for <kbd>Chapter02_02.StructureMap</kbd> demo.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Autofac</h1>
                
            
            
                
<p>We'll finish this short visit over .NET containers examining the basics of AutoFac, another DI Container well known in the community, and that claims to be up-to-date with versions that cover .NET Core, ASP.NET Core, Universal Windows Apps, and .NET Framework 4.5.1 and later versions. It also allows support for WCF-based applications.</p>
<p>It has its own dedicated site (<a href="https://autofac.org/">https://autofac.org/</a>) which serves as the starting point, although it is also referenced via <kbd>NuGet</kbd> packages. Besides this, you will find references to several libraries, some specialized, in this page or NuGet.org at <a href="https://www.nuget.org/packages/Autofac/">https://www.nuget.org/packages/Autofac/.</a></p>
<p>If you decide to keep on using <kbd>NuGet</kbd> from Visual Studio, you should find the following reference, once you search for Autofac in the NuGet package editor:</p>
<div><img height="438" width="385" src="img/a4622db5-fe37-4b33-a89d-fc3cf4d6d10c.png"/></div>
<p>The standard architecture is similar to the other three we've already seen, with minor differences. For example, the container here is named <kbd>ContainerBuilder</kbd>.</p>
<p>After its instantiation, we have to configure the required types and interfaces and, finally, we should call to the <kbd>Build()</kbd> method of the <kbd>ContainerBuilder</kbd> to have everything ready.</p>
<p>Although we might use an approach similar to the other demos, in this case, we decided to inject only the version chosen by the user. This can be easily accomplished with the following code:</p>
<pre>    static void Main(string[] args)
    {
      Console.WriteLine("Please, select reading type<br/>         (XML, JSON)");
      // we asume a predefault value
      var builder = new ContainerBuilder();
      if (Console.ReadLine() != "json")
      {
        builder.RegisterType&lt;XMLBookReader&gt;().As&lt;IBookReader&gt;();
      }
      else
      {
        builder.RegisterType&lt;JSONBookReader&gt;().As&lt;IBookReader&gt;();
      }
      var container = builder.Build();
      var ibr = container.Resolve&lt;IBookReader&gt;();
      ibr.ReadBooks();
      Console.ReadLine();
    }</pre>
<p>In short, we have many options regarding IoC containers, and many choices about the way to configure them, but all of them provide us with similar functionality: we can abstract dependencies that are resolved at a later time.</p>
<p>Of course, in this and other cases we could opt for other forms of configuration, like using XML or JSON files and also use more complex configuration classes to support all possible situations that our application requires.</p>
<p>Although this is only an introduction to IoC containers, if you are interested in these APIs, you will see that it is possible to handle the three aspects discussed at the beginning: Object Composition, Object Lifetime, and Interception.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency Injection in other frameworks</h1>
                
            
            
                
<p>.NET or Java are not the only programming environments in which we can find Dependency Injection containers. Many of the most popular JavaScript frameworks also support DI from its inception. This is the case for AngularJS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">DI in Angular</h1>
                
            
            
                
<p>AngularJS (1.x) and Angular (2.x, 4.x, etc) are perhaps the most popular frameworks for JavaScript applications in use today. They are pretty different in their programming model and general purpose, so I will distinguish them both:</p>
<div><img height="180" width="180" src="img/c9990bd7-3496-422d-91c2-305e39ce312b.png"/></div>
<p>Angular frameworks are the result of a Google teamwork lead by Misko Hevery, Igor Minar, and Brad Green, which initially appeared in 2010. The project has bifurcated into two distinct branches: AngularJS 1.x for small/medium projects and Angular 2 (or just Angular) which is intended to cover the needs of big/complex projects and uses TypeScript as the programming language due to its strongly typed nature.</p>
<p>In December 2016, they announced the adoption of a semantic versioning approach, together with a continuous delivery roadmap that will publish a new version every six months, very careful of breaking changes. The latest version is Angular 4, which appeared in March 2017, and is totally backward compatible with Angular 2.</p>
<p>Both projects are also maintained by Google and, despite their different programming models and language, they share a few things in common: They promote the <strong>Single Page Application</strong> (<strong>SPA</strong>) model, and they use a <strong>Model-view-controller</strong> (<strong>MVC</strong>) architecture to provide a suitable separation of responsibilities from the first moment.</p>
<p>AngularJS presents itself as a bunch of libraries so the user can choose only the ones needed for a given purpose, achieving that way a better granularity. All libraries are available via GitHub, NuGet, NPM, Bower, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Our first demo</h1>
                
            
            
                
<p>Let's get down to work with our first demo, and, from this initial approach, we will test how AngularJS provides an excellent, integrated dependency injection system, that facilitates programmers' work to a large extent.</p>
<p>By the way, we can use any IDE to work with Angular, since the three languages implied (two in case we don't care about the visual aspects provided by CSS) are just HTML and JavaScript.</p>
<p>However, I'll keep on using Visual Studio, which has a very good support for Angular programming and provides native Intellisense on Angular directives, and a pretty good debugging experience.</p>
<p>So, let's start a new project or a new website (we don't need any compiled libraries). We can choose an Empty Project in the ASP.NET section. This creates a project with only a <kbd>web.config</kbd> file in case we need to configure the <strong>Internet Information Server</strong> (<strong>IIS</strong>).</p>
<p>Inside the project, we'll create a new HTML file, and once the project is saved we can add the Angular libraries in the usual manner, via the <kbd>NuGet Package Manager</kbd>. We should see that AngularJS is now in versions 1.6.x or higher (we should select Angular.Core for this demo, which is the basic module).</p>
<p>Once we accept the installation, we'll see a new <kbd>Scripts</kbd> folder containing the development (<kbd>angular.js</kbd>) and deployment (<kbd>angular.min.js</kbd>) versions of Angular 1.6, plus a Mock library for testing purposes.</p>
<p>We just have to include the development library and create the minimum required plumbing to see Angular in action--just by including the library, some objects and services are loaded into memory and ready to go.</p>
<p>Especially, there is a <kbd>$injector</kbd> object that will take care of retrieving object instances, instantiate types, load modules and invoke methods.</p>
<p>Also, Angular creates an initial, basic model which serves as the root model for the application ($rootScope), and expects that the user marks an HTML element as the scope of the app. We'll do that in the <kbd>&lt;body&gt; tag</kbd>, name it <kbd>app</kbd>, and define a module with the same name, with the following syntax:</p>
<pre>    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
     &lt;meta charset="utf-8" /&gt;
     &lt;title&gt;Dependency Injection Demo&lt;/title&gt;
     &lt;script src="img/angular.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body ng-app="app"&gt;
     &lt;h1&gt;Dependency Injection Demo&lt;/h1&gt;
     &lt;h3&gt;Current time: {{ time }}&lt;/h3&gt;
     &lt;script&gt;
       var app = angular.module("app", []);
     &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;</pre>
<p>Notice we use an Angular-specific attribute (<kbd>ng-app</kbd>) to mark the scope of our application. These attributes are called directives in Angular and they allow us to modify the DOM to suit our needs (All predefined directives start with <kbd>ng-</kbd>).</p>
<p>Now, we want our page to show the local time when it loads in the browser. The angular mode to do this is to select a target area of the DOM and assign a controller to that area. We can do that including the <kbd>ng-controller</kbd> directive inside the corresponding tag.</p>
<p>As you can see in the code, next to the page's title we've included a <kbd>&lt;h3&gt;</kbd> tag to hold that information, and inside that tag's text, a message, followed by <kbd>{{ time }}</kbd>.</p>
<p>The double brackets syntax is one of the possible binding mechanisms that Angular uses to link data inside the model with the active view, and it's called <strong>moustache syntax</strong>. Thus, we modify the tag in this way:</p>
<pre>    &lt;h3 ng-controller="TimeController"&gt;Current time: <br/>       {{ time }}&lt;/h3&gt;</pre>
<p>Now we have a <kbd>ng-controller</kbd> directive named <kbd>TimeController</kbd>, that we need to define inside the script. Controllers are defined by calling the app's main module, that we previously created, and passing a function as the second argument that will be in charge of the logic linked to that controller.</p>
<p>And, here, we finally get to the Dependency Injection mechanism of AngularJS. This function should have access to the specific model created by Angular to hold the information managed by the controller. We do that via the <kbd>$scope</kbd> object.</p>
<p>Every controller has its own $scope (it's like a sub-model), which allows read/write operations in memory and permits binding between the moustache expressions in the DOM and data stored in that model.</p>
<p>So, how does the user code access to that (or any other) service? Via DI, of course. The final code is surprisingly simple:</p>
<pre>    &lt;body ng-app="app"&gt;
    &lt;h1&gt;Demo Dependency Injection&lt;/h1&gt;
    &lt;h3 ng-controller="TimeController"&gt;Current time: <br/>       {{ time }}&lt;/h3&gt;
    &lt;script&gt;
      var app = angular.module("app", []);
      app.controller("TimeController", function ($scope) {
      $scope.time = new Date().toLocaleTimeString();
     });
    &lt;/script&gt;
    &lt;/body&gt;</pre>
<p>As you see, the controller's definition receives a string to identify the controller's name, and an anonymous function, to hold the functionality linked to that controller.</p>
<p>And, in that function, we just declared the $scope object: the Angular's injection system takes care of the rest. In the next line of code, we can use that object, with a total guarantee of its existence. Even further, Angular provides services and objects of this type using a Singleton approach, so there's no other $scope at the same time.</p>
<p>Of course, the output is as expected, and every time we reload the page, the current time is updated:</p>
<div><img height="86" width="266" src="img/bee9dac8-f393-4913-ae28-2b7d0891382c.png"/></div>
<p>This philosophy is extended to any AngularJS object or service and even to those services that the user might want to create.</p>
<p>In Angular (modern versions), the architecture is similar, only that it uses TypeScript and the preferred way for DI is the constructor-injection model we saw in other demos, given that TypeScript is a totally object-oriented language.</p>
<p>In <a href="48b807a5-dcd8-479d-b71b-670d93f20cc8.xhtml" target="_blank">Chapter 10</a>, <em>Dependency Injection in Other JavaScipt Frameworks</em>, we'll cover Dependency Injection in JavaScript (ES6, or ES 2015, to be precise), TypeScript and Angular 2, so you can have a wider sight of today's implementations of DI in modern web frameworks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have focused on the principles and advantages of Dependency Injection, and how to implement it in C# starting from a very simple application and modifying it to achieve decoupling of classes.</p>
<p>Once we saw the foundations of DI, we've covered briefly three programming aspects that influence the way these techniques are applied: Object Composition, Object Lifetime, and Interception, as a first approach that we'll cover in more detail in further chapters.</p>
<p>And, finally, we've seen how some popular IoC containers implement these concepts, together with a brief introduction to its use in other frameworks, like AngularJS.</p>
<p>In <a href="087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml" target="_blank">Chapter 3</a>, <em>Introducing Dependency Injection in .NET Core 2.0</em>, we will begin the study of the most interesting features about Dependency Injection included in .NET Core.</p>


            

            
        
    </body></html>