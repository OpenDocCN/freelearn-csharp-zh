<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Using PLINQ</h1></div></div></div><p>In this chapter, we will review different parallel programming paradigms, such as task and data parallelism, and cover the basics of data parallelism and parallel LINQ queries. You will learn the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <code class="literal">Parallel</code> class</li><li class="listitem" style="list-style-type: disc">Parallelizing a LINQ query</li><li class="listitem" style="list-style-type: disc">Tweaking the parameters of a PLINQ query</li><li class="listitem" style="list-style-type: disc">Handling exceptions in a PLINQ query</li><li class="listitem" style="list-style-type: disc">Managing data partitioning in a PLINQ query</li><li class="listitem" style="list-style-type: disc">Creating a custom aggregator for a PLINQ query</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Introduction</h1></div></div></div><p>In .NET Framework, there is a subset of libraries that is called Parallel Framework, often referred to as <strong>Parallel Framework Extensions</strong> (<strong>PFX</strong>), which was the name of the very first version of these<a id="id288" class="indexterm"/> libraries. Parallel Framework was released with .NET Framework 4.0 and consists of three major parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Task Parallel Library (TPL)</li><li class="listitem" style="list-style-type: disc">Concurrent collections</li><li class="listitem" style="list-style-type: disc">Parallel LINQ or PLINQ</li></ul></div><p>Until now, you have learned how to run several tasks in parallel and synchronize them with one another. In fact, we partitioned our program into a set of tasks and had different threads running different tasks. This<a id="id289" class="indexterm"/> approach is called <strong>task parallelism</strong>, and you have only been learning about task parallelism so far.</p><p>Imagine that we have a program that performs some heavy calculations over a big set of data. The easiest way to parallelize this program is to partition this set of data into smaller chunks, run the calculations needed over these chunks of data in parallel, and then aggregate the results of these<a id="id290" class="indexterm"/> calculations. This programming model is called <strong>data parallelism</strong>.</p><p>Task parallelism has the lowest abstraction level. We define a program as a combination of tasks, explicitly defining how they are combined. A program composed in this way could be very complex and detailed. Parallel operations are defined in different places in this program, and as it grows, the program becomes harder to understand and maintain. This way of making the program parallel is<a id="id291" class="indexterm"/> called <strong>unstructured parallelism</strong>. It is the price we have to pay if we have complex parallelization logic.</p><p>However, when we have simpler program logic, we can try to offload more parallelization details to the PFX libraries and the C# compiler. For example, we could say, "I would like to run those three methods in parallel, and I do not care how exactly this parallelization happens; let the .NET infrastructure decide the details". This raises the abstraction level as we do not have to provide a detailed description of how exactly we are parallelizing this. This approach<a id="id292" class="indexterm"/> is referred to as <strong>structured parallelism</strong> since the parallelization is usually a sort of declaration and each case of parallelization is defined in exactly one place in the program.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>There could be an impression that unstructured parallelism is bad practice and structured parallelism should be always used instead. I would like to emphasize that this is not true. Structured parallelism is indeed more maintainable, and preferred when possible, but it is a much less universal approach. In general, there are many situations when we simply are not able to use it, and it is perfectly OK to use TPL task parallelism in an unstructured manner.</p></div></div><p>TPL has a <code class="literal">Parallel</code> class, which provides APIs for structured parallelism. This is still a part of TPL, but we will review it in this chapter because it is a perfect example of transition from a lower abstraction level to a higher one. When we use the <code class="literal">Parallel</code> class APIs, we do not need to provide the details of how we partition our work. However, we still need to explicitly define how we make one single result from partitioned results.</p><p>PLINQ has the highest abstraction level. It automatically partitions data in to chunks and decides whether we really need to parallelize the query or whether it will be more effective to use usual sequential query processing. Then, the PLINQ infrastructure takes care of combining the partitioned results. There are many options that programmers may tweak to optimize the query and achieve the best possible performance and result.</p><p>In this chapter, we will cover the <code class="literal">Parallel</code> class API usage and many different PLINQ options, such as making a LINQ query parallel, setting up an execution mode and tweaking the parallelism degree of a PLINQ query, dealing with a query item order, and handling PLINQ exceptions. You will also learn how to manage data partitioning for PLINQ queries.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Using the Parallel class</h1></div></div></div><p>This recipe<a id="id293" class="indexterm"/> shows you how to use the <code class="literal">Parallel</code> class APIs. You will learn how to invoke methods in parallel, how to perform parallel loops, and tweak parallelization mechanics.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec161"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe1</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec162"/>How to do it...</h2></div></div></div><p>To invoke methods in parallel, perform parallel loops, and tweak parallelization mechanics using the <code class="literal">Parallel</code> class, perform the given steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static string EmulateProcessing(string taskName)
{
  Sleep(TimeSpan.FromMilliseconds(
    new Random(DateTime.Now.Millisecond).Next(250, 350)));
  WriteLine($"{taskName} task was processed on a " +
                  $"thread id {CurrentThread.ManagedThreadId}");
  return taskName;
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">Parallel.Invoke(
  () =&gt; EmulateProcessing("Task1"),
  () =&gt; EmulateProcessing("Task2"),
  () =&gt; EmulateProcessing("Task3")
);

var cts = new CancellationTokenSource();

var result = Parallel.ForEach(
  Enumerable.Range(1, 30),
  new ParallelOptions
  {
    CancellationToken = cts.Token,
    MaxDegreeOfParallelism = Environment.ProcessorCount,
    TaskScheduler = TaskScheduler.Default
  },
  (i, state) =&gt;
  {
    WriteLine(i);
    if (i == 20)
    {
      state.Break();
      WriteLine($"Loop is stopped: {state.IsStopped}");
    }
  });

WriteLine("---");
WriteLine($"IsCompleted: {result.IsCompleted}");
WriteLine($"Lowest break iteration: {result.LowestBreakIteration}");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec163"/>How it works...</h2></div></div></div><p>This program <a id="id294" class="indexterm"/>demonstrates different features of the <code class="literal">Parallel</code> class. The <code class="literal">Invoke</code> method allows us to run several actions in parallel without much trouble as compared to defining tasks in TPL. The <code class="literal">Invoke</code> method blocks the other thread until all actions are complete, which is quite a common and convenient scenario.</p><p>The next feature is parallel loops, which are defined with the <code class="literal">For</code> and <code class="literal">ForEach</code> methods. We will look closely at <code class="literal">ForEach</code> since it is very similar to <code class="literal">For</code>. With the <code class="literal">ForEach</code> parallel loop, you can process any <code class="literal">IEnumerable</code> collection in parallel by applying an action delegate to each collection item. We are able to provide several options, customizing parallelization behavior, and get a result that shows whether the loop completed successfully.</p><p>To tweak our parallel loop, we provide an instance of the <code class="literal">ParallelOptions</code> class to the <code class="literal">ForEach</code> method. This allows us to cancel the loop with <code class="literal">CancellationToken</code>, restrict the maximum parallelism degree (how many maximum operations can be run in parallel), and provide a custom <code class="literal">TaskScheduler</code> class to schedule action tasks with it. Actions can accept an additional <code class="literal">ParallelLoopState</code> parameter, which is useful for breaking the loop or for checking what happens with the loop at this moment.</p><p>There are two ways of stopping the parallel loop with this state. We could use either the <code class="literal">Break</code> or <code class="literal">Stop</code> methods. The <code class="literal">Stop</code> method tells the loop to stop processing any more work and sets the <code class="literal">IsStopped</code> property of the parallel loop state to <code class="literal">true</code>. The <code class="literal">Break</code> method stops the<a id="id295" class="indexterm"/> iterations after it, but the initial ones will continue to work. In that case, the <code class="literal">LowestBreakIteration</code> property of the loop result will contain the number of lowest loop iteration where the <code class="literal">Break</code> method was called.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Parallelizing a LINQ query</h1></div></div></div><p>This recipe will <a id="id296" class="indexterm"/>describe how to use PLINQ to make a query parallel and how to go back from a parallel query to sequential processing.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec164"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe2</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec165"/>How to do it...</h2></div></div></div><p>To use PLINQ in order to make a query parallel and to go back from a parallel query to sequential processing, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static void PrintInfo(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(150));
  WriteLine($"{typeName} type was printed on a thread " +
          $"id {CurrentThread.ManagedThreadId}");
}

static string EmulateProcessing(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(150));
  WriteLine($"{typeName} type was processed on a thread " +
          $"id {CurrentThread.ManagedThreadId}");
  return typeName;
}

static IEnumerable&lt;string&gt; GetTypes()
{
  return from assembly in AppDomain.CurrentDomain.GetAssemblies()
          from type in assembly.GetExportedTypes()
          where type.Name.StartsWith("Web")
          select type.Name;

}</pre></div></li><li class="listitem">Add the<a id="id297" class="indexterm"/> following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">var sw = new Stopwatch();
sw.Start();
var query = from t in GetTypes()
  select EmulateProcessing(t);

foreach (string typeName in query)
{
  PrintInfo(typeName);
}
sw.Stop();
WriteLine("---");
WriteLine("Sequential LINQ query.");
WriteLine($"Time elapsed: {sw.Elapsed}");
WriteLine("Press ENTER to continue....");
ReadLine();
Clear();
sw.Reset();

sw.Start();
var parallelQuery = from t in GetTypes().AsParallel()
        select EmulateProcessing(t);

foreach (var typeName in parallelQuery)
{
  PrintInfo(typeName);
}
sw.Stop();
WriteLine("---");
WriteLine("Parallel LINQ query. The results are being merged on a single thread");
WriteLine($"Time elapsed: {sw.Elapsed}");
WriteLine("Press ENTER to continue....");
ReadLine();
Clear();
sw.Reset();

sw.Start();
parallelQuery = from t in GetTypes().AsParallel()
        select EmulateProcessing(t);

parallelQuery.ForAll(PrintInfo);

sw.Stop();
WriteLine("---");
WriteLine("Parallel LINQ query. The results are being processed in parallel");
WriteLine($"Time elapsed: {sw.Elapsed}");
WriteLine("Press ENTER to continue....");
ReadLine();
Clear();
sw.Reset();

sw.Start();
query = from t in GetTypes().AsParallel().AsSequential()
    select EmulateProcessing(t);

foreach (string typeName in query)
{
  PrintInfo(typeName);
}

sw.Stop();
WriteLine("---");
WriteLine("Parallel LINQ query, transformed into sequential.");
WriteLine($"Time elapsed: {sw.Elapsed}");
WriteLine("Press ENTER to continue....");
ReadLine();
Clear();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec166"/>How it works...</h2></div></div></div><p>When the program runs, we create a LINQ query that uses the reflection API to get all types whose names start with <em>Web</em> from the assemblies loaded in the current application domain. We emulate delays for processing each item and for printing it with the <code class="literal">EmulateProcessing</code> and <code class="literal">PrintInfo</code> methods. We also use the <code class="literal">Stopwatch</code> class to measure each query's execution time.</p><p>First, we run a <a id="id298" class="indexterm"/>usual sequential LINQ query. There is no parallelization here, so everything runs on the current thread. The second version of the query uses the <code class="literal">ParallelEnumerable</code> class explicitly. <code class="literal">ParallelEnumerable</code> contains the PLINQ logic implementation and is organized as a number of extension methods to the <code class="literal">IEnumerable</code> collection's functionality. Normally, we do not use this class explicitly; we are using it here to illustrate how PLINQ actually works. The second version runs <code class="literal">EmulateProcessing</code> in parallel; however, by default, the results are merged on a single thread, so the query execution time should be a couple of seconds less than the first version.</p><p>The third version shows how to use the <code class="literal">AsParallel</code> method to run the LINQ query in parallel in a declarative manner. We do not care about implementation details here but just state that we want to run this in parallel. However, the key difference in this version is that we use the <code class="literal">ForAll</code> method to print out the query results. It runs the action to all items in the query on the same thread they were processed in, skipping the results-merging step. It allows us to run <code class="literal">PrintInfo</code> in parallel as well, and this version runs even faster than the previous one.</p><p>The last sample shows how to turn a PLINQ query back to sequential with the <code class="literal">AsSequential</code> method. We can see that this query runs exactly like the first one.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Tweaking the parameters of a PLINQ query</h1></div></div></div><p>This recipe<a id="id299" class="indexterm"/> shows how we can manage parallel processing <a id="id300" class="indexterm"/>options using a PLINQ query and what these options could affect during a query's execution.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec167"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe3</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec168"/>How to do it...</h2></div></div></div><p>To understand how to manage parallel processing options using a PLINQ query and their effects, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the<a id="id301" class="indexterm"/> following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static string EmulateProcessing(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(
    new Random(DateTime.Now.Millisecond).Next(250,350)));
  WriteLine($"{typeName} type was processed on a thread " +
    $"id {CurrentThread.ManagedThreadId}");
  return typeName;
}

static IEnumerable&lt;string&gt; GetTypes()
{
  return from assembly in AppDomain.CurrentDomain.GetAssemblies()
    from type in assembly.GetExportedTypes()
    where type.Name.StartsWith("Web")
    orderby type.Name.Length
    select type.Name;
}</pre></div></li><li class="listitem">Add the <a id="id302" class="indexterm"/>following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">var parallelQuery = from t in GetTypes().AsParallel()
        select EmulateProcessing(t);

var cts = new CancellationTokenSource();
cts.CancelAfter(TimeSpan.FromSeconds(3));

try
{
  parallelQuery
    .WithDegreeOfParallelism(Environment.ProcessorCount)
    .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
    .WithMergeOptions(ParallelMergeOptions.Default)
    .WithCancellation(cts.Token)
    .ForAll(WriteLine);
}
catch (OperationCanceledException)
{
  WriteLine("---");
  WriteLine("Operation has been canceled!");
}

WriteLine("---");
WriteLine("Unordered PLINQ query execution");
var unorderedQuery = from i in ParallelEnumerable.Range(1, 30)
       select i;

foreach (var i in unorderedQuery)
{
  WriteLine(i);
}

WriteLine("---");
WriteLine("Ordered PLINQ query execution");
var orderedQuery = from i in ParallelEnumerable.Range(1, 30).AsOrdered()
     select i;

foreach (var i in orderedQuery)
{
  WriteLine(i);
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec169"/>How it works...</h2></div></div></div><p>The program<a id="id303" class="indexterm"/> demonstrates different useful PLINQ<a id="id304" class="indexterm"/> options that programmers can use. We start with creating a PLINQ query, and then we create another query providing PLINQ tweaking.</p><p>Let's start with cancelation first. To be able to cancel a PLINQ query, there is a <code class="literal">WithCancellation</code> method that accepts a cancelation token object. Here, we signal the cancelation token after 3 seconds, which leads to <code class="literal">OperationCanceledException</code> in the query and cancelation of the rest of the work.</p><p>Then, we are able to specify a parallelism degree for the query. It is the exact number of parallel partitions that will be used to execute the query. In the first recipe, we used the <code class="literal">Parallel.ForEach</code> loop, which has the maximum parallelism degree option. It is different because it specifies a maximum partitions value, but there could be fewer partitions if the infrastructure decides that it is better to use less parallelism to save resources and achieve optimal performance.</p><p>Another interesting<a id="id305" class="indexterm"/> option is overriding the query execution mode with the <a id="id306" class="indexterm"/>
<code class="literal">WithExecutionMode</code> method. The PLINQ infrastructure can process some queries in sequential mode if it decides that parallelizing the query will only add more overhead and it actually will run slower. Using <code class="literal">WithExecutionMode</code>, we can force the query to run in parallel.</p><p>To tune up query<a id="id307" class="indexterm"/> result processing, we have the <code class="literal">WithMergeOptions</code> method. The<a id="id308" class="indexterm"/> default mode is used to buffer a number of results selected by the PLINQ infrastructure before returning them from the query. If the query takes a significant amount of time, it is more reasonable to turn off result buffering to get the results as soon as possible.</p><p>The last option is the <a id="id309" class="indexterm"/>
<code class="literal">AsOrdered</code> method. It is possible that when we use parallel execution, the item order in the collection is not preserved. Later items in the collection could be processed before earlier ones. To prevent this, we need to call <code class="literal">AsOrdered</code> on a parallel query to explicitly tell the PLINQ infrastructure that we intend to preserve the item order for processing.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Handling exceptions in a PLINQ query</h1></div></div></div><p>This recipe will <a id="id310" class="indexterm"/>describe how to handle exceptions in a PLINQ query.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec170"/>Getting ready</h2></div></div></div><p>To work through this<a id="id311" class="indexterm"/> recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe4</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec171"/>How to do it...</h2></div></div></div><p>To understand how to handle exceptions in a PLINQ query, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using static System.Console;</pre></div></li><li class="listitem">Add the<a id="id312" class="indexterm"/> following code snippet inside the<a id="id313" class="indexterm"/> <code class="literal">Main</code> method:<div><pre class="programlisting">IEnumerable&lt;int&gt; numbers = Enumerable.Range(-5, 10);

var query = from number in numbers
    select 100 / number;

try
{
  foreach(var n in query)
    WriteLine(n);
}
catch (DivideByZeroException)
{
  WriteLine("Divided by zero!");
}

WriteLine("---");
WriteLine("Sequential LINQ query processing");
WriteLine();

var parallelQuery = from number in numbers.AsParallel()
        select 100 / number;

try
{
  parallelQuery.ForAll(WriteLine);
}
catch (DivideByZeroException)
{
  WriteLine("Divided by zero - usual exception handler!");
}
catch (AggregateException e)
{
  e.Flatten().Handle(ex =&gt;
  {
    if (ex is DivideByZeroException)
    {
      WriteLine("Divided by zero - aggregate exception handler!");
      return true;
    }
          
    return false;
  });
}

WriteLine("---");
WriteLine("Parallel LINQ query processing and results merging");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec172"/>How it works...</h2></div></div></div><p>First, we run a usual LINQ query over a range of numbers from -5 to 4. When we divide by 0, we get <code class="literal">DivideByZeroException</code>, and we handle it as usual in a <code class="literal">try/catch</code> block.</p><p>However, when <a id="id314" class="indexterm"/>we use <code class="literal">AsParallel</code>, we get <code class="literal">AggregateException</code> instead because we are now running in parallel, leveraging the task infrastructure behind the scenes. <code class="literal">AggregateException</code> will contain all the exceptions that<a id="id315" class="indexterm"/> occurred while running the PLINQ query. To handle the inner <code class="literal">DivideByZeroException</code> class, we use the <code class="literal">Flatten</code> and <code class="literal">Handle</code> methods, which were explained in the <em>Handling exceptions in asynchronous operations</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Using C# 6.0">Chapter 5</a>, <em>Using C# 6.0</em>.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>It is very easy to forget that when we handle aggregate exceptions, having more than one inner exception inside is a very common situation. If you forget to handle all of them, the exception will bubble up and the application will stop working.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Managing data partitioning in a PLINQ query</h1></div></div></div><p>This recipe <a id="id316" class="indexterm"/>shows you how to create a very basic <a id="id317" class="indexterm"/>custom partitioning strategy to parallelize a LINQ query in a specific way.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec173"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe5</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec174"/>How to do it...</h2></div></div></div><p>To learn how to <a id="id318" class="indexterm"/>create a very basic custom partitioning <a id="id319" class="indexterm"/>strategy to parallelize a LINQ query, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static void PrintInfo(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(150));
  WriteLine($"{typeName} type was printed on a thread " +
$"id {CurrentThread.ManagedThreadId}");
}

static string EmulateProcessing(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(150));
  WriteLine($"{typeName} type was processed on a thread " +
  $"id { CurrentThread.ManagedThreadId}. Has " +
  $"{(typeName.Length % 2 == 0 ? "even" : "odd")} length.");

  return typeName;
}

static IEnumerable&lt;string&gt; GetTypes()
{
  var types = AppDomain.CurrentDomain
    .GetAssemblies()
    .SelectMany(a =&gt; a.GetExportedTypes());

  return from type in types
    where type.Name.StartsWith("Web")
    select type.Name;
}

public class StringPartitioner : Partitioner&lt;string&gt;
{
  private readonly IEnumerable&lt;string&gt; _data;

  public StringPartitioner(IEnumerable&lt;string&gt; data)
  {
    _data = data;
  }

  public override bool SupportsDynamicPartitions =&gt; false;

  public override IList&lt;IEnumerator&lt;string&gt;&gt;GetPartitions(
int partitionCount)
  {
    var result = new List&lt;IEnumerator&lt;string&gt;&gt;(
partitionCount);

    for (int i = 1; i &lt;= partitionCount; i++)
    {
      result.Add(CreateEnumerator(i, partitionCount));
    }

    return result;
  }

  IEnumerator&lt;string&gt; CreateEnumerator(int partitionNumber, int partitionCount)
  {
    int evenPartitions = partitionCount / 2;
    bool isEven = partitionNumber % 2 == 0;
    int step = isEven ? evenPartitions : 
partitionCount - evenPartitions;

    int startIndex = partitionNumber / 2 +
    partitionNumber % 2;

    var q = _data
      .Where(v =&gt; !(v.Length % 2 == 0 ^ isEven)
|| partitionCount == 1)
      .Skip(startIndex - 1);

    return q
      .Where((x, i) =&gt; i % step == 0)
      .GetEnumerator();

  }
}</pre></div></li><li class="listitem">Add the<a id="id320" class="indexterm"/> following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">var timer = Stopwatch.StartNew();
var partitioner = new StringPartitioner(GetTypes());
var parallelQuery = from t in partitioner.AsParallel()
//      .WithDegreeOfParallelism(1)
      select EmulateProcessing(t);

parallelQuery.ForAll(PrintInfo);
int count = parallelQuery.Count();
timer.Stop();
WriteLine(" ----------------------- ");
WriteLine($"Total items processed: {count}");
WriteLine($"Time elapsesd: {timer.Elapsed}");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec175"/>How it works...</h2></div></div></div><p>To illustrate that we are able to choose custom partitioning strategies for the PLINQ query, we created a very simple partitioner that processes strings of odd and even lengths in parallel. To<a id="id321" class="indexterm"/> achieve this, we derive our custom <code class="literal">StringPartitioner</code> class from a standard base class <code class="literal">Partitioner&lt;T&gt;</code> using <code class="literal">string</code> as a type parameter.</p><p>We declare that we only support static partitioning by overriding the <code class="literal">SupportsDynamicPartitions</code> property and setting it to <code class="literal">false</code>. This means that we predefine our partitioning strategy. This is an easy way to partition the initial collection but could be inefficient depending on what data we have inside the collection. For example, in our case, if we had many strings with odd lengths and only one string with even length, one of the threads would have finished early and would not have helped to process odd-length strings. On the other hand, dynamic partitioning means that we partition the initial collection on the fly, balancing the work load between the worker threads.</p><p>Then, we implement the <code class="literal">GetPartitions</code> method, where we define the following logic: if there is only one partition, we simply process everything on it. However, if we have more than one partition, then we process strings with odd length on odd partitions and even-length strings on even-numbered partitions.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Please note that we need to create as many partitions as is stated in the <code class="literal">partitionCount</code> parameter, or else we will get the <code class="literal">Partitioner returned a wrong number of partitions</code> error.</p></div></div><p>Finally, we create an<a id="id322" class="indexterm"/> instance of our partitioner and perform a PLINQ query with it. We can see that different threads process the odd-length and <a id="id323" class="indexterm"/>even-length strings. Also, we can experiment with uncommenting the <code class="literal">WithDegreeOfParallelism</code> method and changing its parameter value. In the case of <code class="literal">1</code>, there will be a sequential work items processing, and when increasing the value, we can see that more work gets done in parallel.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Creating a custom aggregator for a PLINQ query</h1></div></div></div><p>This recipe<a id="id324" class="indexterm"/> shows you how to create a custom aggregation<a id="id325" class="indexterm"/> function for a PLINQ query.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec176"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe6</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec177"/>How to do it...</h2></div></div></div><p>To understand the workings of a custom aggregation function for a PLINQ query, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the<a id="id326" class="indexterm"/> following code snippet <a id="id327" class="indexterm"/>below the <code class="literal">Main</code> method:<div><pre class="programlisting">static ConcurrentDictionary&lt;char, int&gt; AccumulateLettersInformation(
    ConcurrentDictionary&lt;char, int&gt; taskTotal , string item)
{
  foreach (var c in item)
  {
    if (taskTotal.ContainsKey(c))
    {
      taskTotal[c] = taskTotal[c] + 1;
    }
    else
    {
      taskTotal[c] = 1;
    }
  }
  WriteLine($"{item} type was aggregated on a thread " +
          $"id {CurrentThread.ManagedThreadId}");
  return taskTotal;
}

static ConcurrentDictionary&lt;char, int&gt; MergeAccumulators(
    ConcurrentDictionary&lt;char, int&gt; total, ConcurrentDictionary&lt;char, int&gt; taskTotal)
{
  foreach (var key in taskTotal.Keys)
  {
    if (total.ContainsKey(key))
    {
      total[key] = total[key] + taskTotal[key];
    }
    else
    {
      total[key] = taskTotal[key];
    }
  }
  WriteLine("---");
  WriteLine($"Total aggregate value was calculated on a thread " +
          $"id {CurrentThread.ManagedThreadId}");
  return total;
}

static IEnumerable&lt;string&gt; GetTypes()
{
  var types = AppDomain.CurrentDomain
    .GetAssemblies()
    .SelectMany(a =&gt; a.GetExportedTypes());

  return from type in types
         where type.Name.StartsWith("Web")
         select type.Name;
}</pre></div></li><li class="listitem">Add the<a id="id328" class="indexterm"/> following code snippet inside<a id="id329" class="indexterm"/> the <code class="literal">Main</code> method:<div><pre class="programlisting">var parallelQuery = from t in GetTypes().AsParallel()
                    select t;

var parallelAggregator = parallelQuery.Aggregate(
  () =&gt; new ConcurrentDictionary&lt;char, int&gt;(),
  (taskTotal, item) =&gt; AccumulateLettersInformation(taskTotal, item), 
  (total, taskTotal) =&gt; MergeAccumulators(total, taskTotal),
  total =&gt; total);

WriteLine();
WriteLine("There were the following letters in type names:");
var orderedKeys = from k in parallelAggregator.Keys
          orderby parallelAggregator[k] descending
          select k;

foreach (var c in orderedKeys)
{
  WriteLine($"Letter '{c}' ---- {parallelAggregator[c]} times");
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec178"/>How it works...</h2></div></div></div><p>Here, we implement custom aggregation mechanics that are able to work with the PLINQ queries. To implement this, we have to understand that since a query is being processed in parallel by several tasks simultaneously, we need to provide mechanics to aggregate each task's result in parallel and then combine those aggregated values into one single result value.</p><p>In this recipe, we wrote an aggregating function that counts letters in a PLINQ query, which returns the <code class="literal">IEnumerable&lt;string&gt;</code> collection. It counts all the letters in each collection item. To illustrate the parallel aggregation process, we print out information about which thread processes each part of the aggregation.</p><p>We aggregate the<a id="id330" class="indexterm"/> PLINQ query results using the <code class="literal">Aggregate</code> extension method defined in the <code class="literal">ParallelEnumerable</code> class. It accepts four parameters, each of which is a function that performs different parts of the aggregation process. The first one is a factory that constructs the empty initial value of the aggregator. It is also called the seed value.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Note that the first value provided to the <code class="literal">Aggregate</code> method is actually not an initial seed value for the aggregator function but a factory method that constructs this initial seed value. If you provide just an instance, it will be used in all partitions that run in parallel, which will lead to an incorrect result.</p></div></div><p>The second<a id="id331" class="indexterm"/> function aggregates each collection item into the partition aggregation object. We implement this function with the <code class="literal">AccumulateLettersInformation</code> method. It iterates the string and counts the letters inside it. Here, the aggregation objects are different for each query partition running in parallel, which is why we called them <code class="literal">taskTotal</code>.</p><p>The third function is a higher level aggregation function that takes an aggregator object from a partition and merges it into a global aggregator object. We implement it with the <code class="literal">MergeAccumulators</code> method. The last function is a selector function that specifies what exact data we need from the global aggregator object.</p><p>Finally, we print out the aggregation result, ordering it by the letters used most often in the collection items.</p></div></div></body></html>