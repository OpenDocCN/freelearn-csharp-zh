<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer022">
<h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor072"/>Chapter 4</em>: User Interface Responsiveness and Threading</h1>
<p>One of the main reasons to introduce threading concepts to a project is the desire to keep an application responsive to user input. Accessing data through services, a database, or the filesystem can introduce delays, and the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) should remain responsive. The real-world examples in this chapter will provide valuable options for ensuring UI responsiveness in your .NET client applications.</p>
<p>In this chapter, we will do the following:</p>
<ul>
<li>Leveraging background threads</li>
<li>Using the thread pool</li>
<li>Updating the UI thread without exceptions</li>
</ul>
<p>By the end of this chapter, you will understand how to take advantage of parallelism and concurrency to keep your client applications responsive and performant.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows users:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later</li>
<li>.NET 6</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04</a>.</p>
<p>Let’s get started by discussing how background threads can be used to perform non-critical tasks without impacting UI performance.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Leveraging background threads</h1>
<p>In <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, we learned how to create background threads and discussed some of their uses. Background threads have a lower priority than the primary <a id="_idIndexMarker193"/>thread of the process and other thread pool threads. In addition, active background threads will not prevent the user or the system from terminating the application.</p>
<p>This means that background threads are perfect for tasks such as the following:</p>
<ul>
<li>Writing log and analytics data</li>
<li>Monitoring network or filesystem resources</li>
<li>Reading data into the application</li>
</ul>
<p>Do not use background threads for critical application operations such as the following:</p>
<ul>
<li>Saving application state</li>
<li>Performing database transactions</li>
<li>Application data processing</li>
</ul>
<p>A good rule to follow when deciding whether some work can be processed by a background thread is to ask yourself whether abruptly interrupting the work to close the application would risk the data integrity of the system. So, how do you know whether you are creating a background or foreground thread?</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Which threads are background threads?</h2>
<p>We have learned that a thread<a id="_idIndexMarker194"/> can be explicitly created as a background thread by setting its <strong class="source-inline">IsBackground</strong> property to <strong class="source-inline">true</strong>. All other threads created by calling a <strong class="source-inline">Thread</strong> constructor are foreground threads by default. The application’s primary (or main) thread is a foreground thread. All <strong class="source-inline">ThreadPool</strong> threads are background threads. This includes all asynchronous operations started by the <strong class="bold">Task Parallel Library</strong> (<strong class="bold">TPL</strong>).</p>
<p>So, if all task-based operations such as <strong class="source-inline">async</strong> methods are executing on background threads, should you avoid using them for saving important application data? Will .NET allow your application to close while these <strong class="source-inline">async</strong> / <strong class="source-inline">await</strong> operations are in process? If there is a foreground thread awaiting an <strong class="source-inline">async</strong> operation, the application will not terminate until the <a id="_idIndexMarker195"/>operation is complete. If you do not use <strong class="source-inline">await</strong>, or you start an operation on the thread pool with <strong class="source-inline">Task.Run</strong>, it is possible for the application to terminate normally before the actions have finished.</p>
<p>The great thing about using <strong class="source-inline">await</strong> with your <strong class="source-inline">async</strong> methods is the flexibility you gain in controlling the flow of execution while keeping the UI responsive. Let’s discuss <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> in client applications and create an example of a <strong class="bold">Windows Presentation Foundation</strong> (<strong class="bold">WPF</strong>) application that loads data from multiple sources.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Using async, await, tasks, and WhenAll</h2>
<p>Using <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> in your code is the <a id="_idIndexMarker196"/>easiest way to introduce some background<a id="_idIndexMarker197"/> work using <strong class="source-inline">ThreadPool</strong>. An asynchronous method must be decorated with the <strong class="source-inline">async</strong> keyword and will return a <strong class="source-inline">System.Threading.Tasks.Task</strong> type instead of a <strong class="source-inline">void</strong> return. </p>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="source-inline">Async</strong> methods return <strong class="source-inline">Task</strong> so the calling <a id="_idIndexMarker198"/>method can await the result of the method. If you were to create an <strong class="source-inline">async</strong> method with a <strong class="source-inline">void</strong> return type, it could not be awaited, and the calling code would continue processing subsequent code before the <strong class="source-inline">async</strong> method had completed. It is important to note that only event handlers should be declared as <strong class="source-inline">async</strong> with a <strong class="source-inline">void</strong> return type.</p>
<p>If the method returns <strong class="source-inline">string</strong>, then the <strong class="source-inline">async</strong> equivalent will return a <strong class="source-inline">Task&lt;string&gt;</strong> generic type. Let’s look at examples of each:</p>
<pre class="source-code">private async Task ProcessDataAsync()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    // Process data here</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private async Task&lt;string&gt; GetStringDataAsync()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    string stringData;</pre>
<pre class="source-code">    // Build string here</pre>
<pre class="source-code">    ...</pre>
<pre class="source-code">    return stringData;</pre>
<pre class="source-code">}</pre>
<p>When you call an <strong class="source-inline">async</strong> method, there are<a id="_idIndexMarker199"/> two common patterns to follow. </p>
<ul>
<li>First, you can await the call and set the return type to a variable of the type returned inside the method:<p class="source-code">await ProcessDataAsync();</p><p class="source-code">string data = await GetStringDataAsync();</p></li>
<li>The second option is to use <strong class="source-inline">Task</strong> variables when invoking the methods and await them later:<p class="source-code">Task dataTask = ProcessDataAsync();</p><p class="source-code">Task&lt;string&gt; stringDataTask = GetStringDataAsync();</p><p class="source-code">DoSomeOtherSynchronousWork();</p><p class="source-code">string data = await stringDataTask;</p><p class="source-code">await dataTask;</p></li>
</ul>
<p>Using this second method, the application can execute some synchronous work while the two <strong class="source-inline">async</strong> methods continue to run on background threads. Once the synchronous work is complete, the application will await the two <strong class="source-inline">async</strong> methods.</p>
<p>Let’s put our <strong class="source-inline">async</strong> knowledge to work in a more realistic sample project. In this example, we will create a new Windows client application <a id="_idIndexMarker200"/>with <strong class="bold">WPF</strong> that loads data from two <strong class="source-inline">async</strong> methods. We will simulate slow service calls to fetch the data in these methods by injecting non-blocking delays with <strong class="source-inline">Task.Delay</strong>. Each method will take several seconds to return its data, but the UI will remain responsive to user input:</p>
<ol>
<li>Start by creating a new WPF project in Visual Studio. Name the project <strong class="source-inline">AwaitWithWpf</strong>.</li>
<li>Add two new classes to the project named <strong class="source-inline">Order</strong> and <strong class="source-inline">MainViewModel</strong>. Your solution should now look something like this:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Figure 4.1 – The AwaitWithWpf solution in Visual Studio " height="324" src="image/Figure_4.1_B18552.jpg" width="913"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The AwaitWithWpf solution in Visual Studio</p>
<ol>
<li value="3">Next, open <strong class="bold">NuGet Package Manager</strong>, search for <strong class="source-inline">MVVM Toolkit</strong> on the <strong class="bold">Browse</strong> tab, and add the latest stable <a id="_idIndexMarker201"/>version of the <strong class="source-inline">Microsoft.Toolkit.Mvvm</strong> package to your project:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer019">
<img alt="Figure 4.2 – Adding the Microsoft.Toolkit.Mvvm package to the project " height="114" src="image/Figure_4.2_B18552.jpg" width="1341"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Adding the Microsoft.Toolkit.Mvvm package to the project</p>
<p>We will be using <a id="_idIndexMarker202"/>the <strong class="bold">MVVM Toolkit</strong> to add <strong class="bold">Model-View-ViewModel (MVVM)</strong> functionality to our <strong class="source-inline">MainViewModel</strong> class.</p>
<p class="callout-heading">Note</p>
<p class="callout">The MVVM Toolkit is an open source MVVM library that is part of the <strong class="bold">Windows Community Toolkit</strong> maintained by Microsoft. If you are unfamiliar with the MVVM pattern or the <a id="_idIndexMarker203"/>MVVM Toolkit, you can read <a id="_idIndexMarker204"/>more about them on Microsoft Docs: <a href="https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction">https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction</a>.</p>
<ol>
<li value="4">Now, open the <strong class="source-inline">Order</strong> class and add the following implementation:<p class="source-code">public class Order</p><p class="source-code">{</p><p class="source-code">    public int OrderId { get; set; }</p><p class="source-code">    public string? CustomerName { get; set; }</p><p class="source-code">    public bool IsArchived { get; set; }</p><p class="source-code">}</p></li>
</ol>
<p>This will provide a few properties to display for each order when the order list is populated on <strong class="source-inline">MainWindow</strong>.</p>
<ol>
<li value="5">Now we will start to <a id="_idIndexMarker205"/>build the <strong class="source-inline">MainViewModel</strong> implementation. The first step is to add a list of orders to bind to the UI and a command to execute when we want to load the orders:<p class="source-code">public class MainViewModel : ObservableObject</p><p class="source-code">{</p><p class="source-code">    private ObservableCollection&lt;Order&gt; _orders = </p><p class="source-code">        new();</p><p class="source-code">    public MainViewModel()</p><p class="source-code">    {</p><p class="source-code">        LoadOrderDataCommand = new AsyncRelayCommand</p><p class="source-code">            (LoadOrderDataAsync);</p><p class="source-code">    }</p><p class="source-code">    public ICommand LoadOrderDataCommand { get; set; }</p><p class="source-code">    public ObservableCollection&lt;Order&gt; Orders</p><p class="source-code">    {</p><p class="source-code">        get { return _orders; }</p><p class="source-code">        set</p><p class="source-code">        {</p><p class="source-code">            SetProperty(ref _orders, value);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    private async Task LoadOrderDataAsync()</p><p class="source-code">    {</p><p class="source-code">        // TODO – Add code to load orders</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Let’s review a few of the properties of the <strong class="source-inline">MainViewModel</strong> class before moving on to the next step:</p>
<ul>
<li>The <strong class="source-inline">MainViewModel</strong> class inherits from the <strong class="source-inline">ObservableObject</strong> type provided by the MVVM Toolkit. </li>
<li>This base class implements the <strong class="source-inline">INotifyPropertyChanged</strong> interface, which is used by WPF data <a id="_idIndexMarker206"/>binding to notify the UI when data-bound property values change.</li>
<li>The <strong class="source-inline">Orders</strong> property will provide the list of orders to the UI through WPF data binding. Calling <strong class="source-inline">SetProperty</strong> on the <strong class="source-inline">ObservableObject</strong> base sets the value of the <strong class="source-inline">_orders</strong> backing variable and triggers a property change notification.</li>
<li>The <strong class="source-inline">LoadOrderDataCommand</strong> property will be executed by a button on <strong class="source-inline">MainWindow</strong>. In the constructor, the property is being initialized as a new <strong class="source-inline">AsyncRelayCommand</strong> that calls <strong class="source-inline">LoadOrderDataAsync</strong> when the command is invoked by the UI.</li>
</ul>
<ol>
<li value="6">Don’t forget to add the necessary <strong class="source-inline">using</strong> statements to the class:<p class="source-code">using Microsoft.Toolkit.Mvvm.ComponentModel;</p><p class="source-code">using Microsoft.Toolkit.Mvvm.Input;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Collections.ObjectModel;</p><p class="source-code">using System.Threading.Tasks;</p><p class="source-code">using System.Windows.Input;</p></li>
<li>Next, let’s create two <strong class="source-inline">async</strong> methods to load order data. One will create current orders and the<a id="_idIndexMarker207"/> other will create a list of archived orders. These are differentiated by the <strong class="source-inline">IsArchived</strong> property on the <strong class="source-inline">Order</strong> class. Each method uses <strong class="source-inline">Task.Delay</strong> to simulate a service call across a slow internet or network connection:<p class="source-code">private async Task&lt;List&lt;Order&gt;&gt; GetCurrentOrders</p><p class="source-code">    Async()</p><p class="source-code">{</p><p class="source-code">    var orders = new List&lt;Order&gt;();</p><p class="source-code">    await Task.Delay(4000);</p><p class="source-code">    orders.Add(new Order { OrderId = 55, CustomerName </p><p class="source-code">        = "Tony", IsArchived = false });</p><p class="source-code">    orders.Add(new Order { OrderId = 56, CustomerName </p><p class="source-code">        = "Peggy", IsArchived = false });</p><p class="source-code">    orders.Add(new Order { OrderId = 60, CustomerName </p><p class="source-code">        = "Carol", IsArchived = false });</p><p class="source-code">    orders.Add(new Order { OrderId = 62, CustomerName </p><p class="source-code">        = "Bruce", IsArchived = false });</p><p class="source-code">    return orders;</p><p class="source-code">}</p><p class="source-code">private async Task&lt;List&lt;Order&gt;&gt; GetArchivedOrders</p><p class="source-code">    Async()</p><p class="source-code">{</p><p class="source-code">    var orders = new List&lt;Order&gt;();</p><p class="source-code">    await Task.Delay(5000);</p><p class="source-code">    orders.Add(new Order { OrderId = 3, CustomerName = </p><p class="source-code">        "Howard", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 18, CustomerName </p><p class="source-code">        = "Steve", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 19, CustomerName </p><p class="source-code">        = "Peter", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 21, CustomerName </p><p class="source-code">        = "Mary", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 25, CustomerName </p><p class="source-code">        = "Gwen", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 34, CustomerName </p><p class="source-code">        = "Harry", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 36, CustomerName </p><p class="source-code">        = "Bob", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 49, CustomerName </p><p class="source-code">        = "Bob", IsArchived = true });</p><p class="source-code">    return orders;</p><p class="source-code">}</p></li>
<li>Now we need to create a synchronous <strong class="source-inline">ProcessOrders</strong> method that combines the two lists of <a id="_idIndexMarker208"/>orders and updates the <strong class="source-inline">Orders</strong> property with the full dataset:<p class="source-code">private void ProcessOrders(List&lt;Order&gt; currentOrders, </p><p class="source-code">    List&lt;Order&gt; archivedOrders)</p><p class="source-code">{</p><p class="source-code">    List&lt;Order&gt; allOrders = new(currentOrders);</p><p class="source-code">    allOrders.AddRange(archivedOrders);</p><p class="source-code">    Orders = new ObservableCollection&lt;Order&gt;</p><p class="source-code">        (allOrders);</p><p class="source-code">}</p></li>
<li>The final step in building the <strong class="source-inline">MainViewModel</strong> class is the most important. Add the following <a id="_idIndexMarker209"/>implementation to the <strong class="source-inline">LoadOrderDataAsync</strong> method:<p class="source-code">private async Task LoadOrderDataAsync()</p><p class="source-code">{</p><p class="source-code">    Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = </p><p class="source-code">        GetCurrentOrdersAsync();</p><p class="source-code">    Task&lt;List&lt;Order&gt;&gt; archivedOrdersTask = </p><p class="source-code">        GetArchivedOrdersAsync();</p><p class="source-code">    List&lt;Order&gt;[] results = await Task.WhenAll(new </p><p class="source-code">        Task&lt;List&lt;Order&gt;&gt;[] {</p><p class="source-code">        currentOrdersTask, archivedOrdersTask</p><p class="source-code">    }).ConfigureAwait(false);</p><p class="source-code">    ProcessOrders(results[0], results[1]);</p><p class="source-code">}</p></li>
</ol>
<p>This method calls <strong class="source-inline">GetCurrentOrdersAsync</strong> and <strong class="source-inline">GetArchivedOrdersAsync</strong> and captures each in a <strong class="source-inline">Task&lt;List&lt;Order&gt;&gt;</strong> variable. You could simply await each call and store the returned orders in <strong class="source-inline">List&lt;Order&gt;</strong> variables. However, that would mean the second method would not start executing until the first one completed. By awaiting <strong class="source-inline">Task.WhenAll</strong> instead, the <a id="_idIndexMarker210"/>methods can execute in parallel on background threads.</p>
<p>If your methods all return<a id="_idIndexMarker211"/> the same data type, you can capture the results of <strong class="source-inline">Task.WhenAll</strong> in an array of the return type. In our case, we are receiving the two lists of orders in an array of <strong class="source-inline">List&lt;Order&gt;</strong> and passing the two array values to <strong class="source-inline">ProcessOrders</strong>.</p>
<ol>
<li value="10">Now, let’s move on to the <strong class="source-inline">MainWindow.xaml.cs</strong> code-behind file. Add the following code to set <strong class="source-inline">DataContext</strong> of <strong class="source-inline">MainWindow</strong> in the constructor after the call to <strong class="source-inline">InitializeComponent</strong>:<p class="source-code">public MainWindow()</p><p class="source-code">{</p><p class="source-code">    InitializeComponent();</p><p class="source-code"><strong class="bold">    var vm = new MainViewModel();</strong></p><p class="source-code"><strong class="bold">    DataContext = vm;</strong></p><p class="source-code">}</p></li>
</ol>
<p><strong class="source-inline">DataContext</strong> is the source for all <strong class="source-inline">Binding</strong> references in the XAML for <strong class="source-inline">MainWindow</strong>. We will create the XAML for our UI in the next step.</p>
<ol>
<li value="11">The last file to update is <strong class="source-inline">MainWindow.xaml</strong>. Open the XAML file and start by adding two rows to <strong class="source-inline">Grid</strong>. The first row will contain another <strong class="source-inline">Grid</strong> containing <strong class="source-inline">Button</strong> and <strong class="source-inline">TextBox</strong>. The second row will contain <strong class="source-inline">ListView</strong> to display the list of orders. We’ll create a template for the orders in a moment:<p class="source-code">&lt;Grid&gt;</p><p class="source-code">    &lt;Grid.RowDefinitions&gt;</p><p class="source-code">        &lt;RowDefinition Height="Auto"/&gt;</p><p class="source-code">        &lt;RowDefinition Height="*"/&gt;</p><p class="source-code">    &lt;/Grid.RowDefinitions&gt;</p><p class="source-code">    &lt;Grid Grid.Row="0" Margin="4"&gt;</p><p class="source-code">        &lt;Grid.ColumnDefinitions&gt;</p><p class="source-code">            &lt;ColumnDefinition Width="Auto"/&gt;</p><p class="source-code">            &lt;ColumnDefinition Width="*"/&gt;</p><p class="source-code">        &lt;/Grid.ColumnDefinitions&gt;</p><p class="source-code">        &lt;Button Content="Load Data" Grid.Column="0" </p><p class="source-code">            Margin="2" Width="200"</p><p class="source-code"><strong class="bold">        Command="{Binding Path=LoadOrderData</strong></p><p class="source-code"><strong class="bold">            Command}"</strong>/&gt;</p><p class="source-code">        &lt;TextBox Grid.Column="1" Margin="2"/&gt;</p><p class="source-code">    &lt;/Grid&gt;</p><p class="source-code">    &lt;ListView Grid.Row="1" <strong class="bold">ItemsSource="{Binding </strong></p><p class="source-code"><strong class="bold">        Path=Orders}"</strong> Margin="4"&gt;</p><p class="source-code">    &lt;/ListView&gt;</p><p class="source-code">&lt;/Grid&gt;</p></li>
</ol>
<p>I have highlighted the two <a id="_idIndexMarker212"/>data binding instances in the XAML markup. The <strong class="source-inline">Command</strong> of <strong class="source-inline">Button</strong> is bound to the <strong class="source-inline">LoadOrderDataCommand</strong> property, and <strong class="source-inline">ItemsSource</strong> of <strong class="source-inline">ListView</strong> is bound to the <strong class="source-inline">Orders</strong> property. Setting <strong class="source-inline">ItemsSource</strong> will make the properties of the <strong class="source-inline">Order</strong> class available to the members of <strong class="source-inline">ListView.ItemTemplate</strong>.</p>
<ol>
<li value="12">Let’s add <strong class="source-inline">ItemTemplate</strong> to <strong class="source-inline">ListView</strong> next. Defining <strong class="source-inline">DataTemplate</strong> within <strong class="source-inline">ItemTemplate</strong> defines<a id="_idIndexMarker213"/> the structure of each item within <strong class="source-inline">ListView</strong>:<p class="source-code">&lt;ListView Grid.Row="1" ItemsSource="{Binding </p><p class="source-code">    Path=Orders}" Margin="4"&gt;</p><p class="source-code">    &lt;ListView.ItemTemplate&gt;</p><p class="source-code">        &lt;DataTemplate&gt;</p><p class="source-code">            &lt;StackPanel Margin="2"&gt;</p><p class="source-code">                &lt;StackPanel Orientation="Horizontal"&gt;</p><p class="source-code">                    &lt;TextBlock Text="Order Id:"</p><p class="source-code">                               Margin="2,2,0,2"</p><p class="source-code">                               Width="100"/&gt;</p><p class="source-code">                    &lt;TextBox IsReadOnly="True"</p><p class="source-code">                           Width="200"</p><p class="source-code">                           Text="{Binding </p><p class="source-code">                           Path=OrderId}" Margin="2"/&gt;</p><p class="source-code">                &lt;/StackPanel&gt;</p><p class="source-code">                &lt;StackPanel Orientation="Horizontal"&gt;</p><p class="source-code">                    &lt;TextBlock Text="Customer:"</p><p class="source-code">                               Margin="2,2,0,2"</p><p class="source-code">                               Width="100"/&gt;</p><p class="source-code">                    &lt;TextBox IsReadOnly="True"</p><p class="source-code">                             Width="200"</p><p class="source-code">                             Text="{Binding </p><p class="source-code">                             Path=CustomerName}" </p><p class="source-code">                             Margin="2"/&gt;</p><p class="source-code">                &lt;/StackPanel&gt;</p><p class="source-code">                &lt;StackPanel Orientation="Horizontal"&gt;</p><p class="source-code">                    &lt;TextBlock Text="Archived:"</p><p class="source-code">                               Margin="2,2,0,2"</p><p class="source-code">                               Width="100"/&gt;</p><p class="source-code">                    &lt;TextBox IsReadOnly="True"</p><p class="source-code">                             Width="200"</p><p class="source-code">                             Text="{Binding </p><p class="source-code">                             Path=IsArchived}"</p><p class="source-code">                              Margin="2"/&gt;</p><p class="source-code">                &lt;/StackPanel&gt;</p><p class="source-code">            &lt;/StackPanel&gt;</p><p class="source-code">        &lt;/DataTemplate&gt;</p><p class="source-code">    &lt;/ListView.ItemTemplate&gt;</p><p class="source-code">&lt;/ListView&gt;</p></li>
</ol>
<p>Each <strong class="source-inline">Order</strong> instance will render as a <strong class="source-inline">StackPanel</strong> containing three horizontally aligned <strong class="source-inline">StackPanel</strong> elements, displaying labels and values for the <strong class="source-inline">OrderId</strong>, <strong class="source-inline">CustomerName</strong>, and <strong class="source-inline">IsArchived</strong> data-bound properties.</p>
<ol>
<li value="13">We’re ready to run the <a id="_idIndexMarker214"/>application and see how things work. After the program starts, click the <strong class="bold">Load Data</strong> button. It will take about 5 seconds to load the data to <strong class="source-inline">ListView</strong>. While you wait, try typing some text into the box to the right of the <strong class="bold">Load Data</strong> button. You can see that<a id="_idIndexMarker215"/> the UI remains responsive to user input thanks to <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> and the <strong class="source-inline">Task.WhenAll</strong> method. Once the data has finished loading, you should see a list of twelve orders in the scrollable list:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer020">
<img alt="Figure 4.2 – Viewing a list of orders in the AsyncWithWpf application " height="714" src="image/Figure_4.3_B18552.jpg" width="1262"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Viewing a list of orders in the AsyncWithWpf application</p>
<p>In a real production application, the implementations of the two <strong class="source-inline">async</strong> methods would be replaced by service calls to fetch data from a database or web services. Regardless of how long it takes to return and <a id="_idIndexMarker216"/>populate the data, other parts of the UI will remain responsive to user input. One change you would want to make is adding an indicator to the UI to inform the user that data is being loaded. You should also disable the <strong class="bold">Load Data</strong> button while the data load process is active to prevent multiple calls to <strong class="source-inline">LoadOrderDataAsync</strong>.</p>
<p>The example illustrates the benefits of using <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> in a Windows application. These <strong class="source-inline">async</strong> calls are using <strong class="source-inline">ThreadPool</strong> within the TPL. Let’s look at some other ways to leverage <strong class="source-inline">ThreadPool</strong> in a Windows application.</p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Using the thread pool</h1>
<p>There are other ways to use <strong class="source-inline">ThreadPool</strong> threads in a .NET application. Let’s discuss a situation where you want to accomplish the<a id="_idIndexMarker217"/> same result that was achieved with <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> in the previous example, but the methods to fetch the order data are not marked as <strong class="source-inline">async</strong>. One option is to update the methods to be <strong class="source-inline">async</strong>. If that code is not within your control to change, you have some other options available.</p>
<p>The <strong class="source-inline">ThreadPool</strong> class has a method called <strong class="source-inline">QueueUserWorkItem</strong>. This method accepts a method to call and queues it for execution on the thread pool. We could use it with our project like this:</p>
<pre class="source-code">ThreadPool.QueueUserWorkItem(GetCurrentOrders);</pre>
<p>There are a few problems with using this method. The primary issue is that there is no return value to get the list of orders from the method call. You could work around this issue with some wrapper methods that update a shared thread-safe collection such as the <strong class="source-inline">BlockingCollection</strong>. That isn’t a great design, and there is a better option.</p>
<p>The <strong class="source-inline">QueueUserWorkItem</strong> method was<a id="_idIndexMarker218"/> more commonly used before the introduction of the TPL. In today’s task-based world, you can use <strong class="source-inline">Task.Run</strong> to execute a synchronous method as <strong class="source-inline">async</strong>. Let’s update our WPF project to use <strong class="source-inline">Task.Run</strong>:</p>
<ol>
<li value="1">The only file that needs to be modified to use <strong class="source-inline">Task.Run</strong> is <strong class="source-inline">MainViewModel</strong>. Start by updating <strong class="source-inline">GetCurrentOrdersAsync</strong> and <strong class="source-inline">GetArchivedOrdersAsync</strong> to no longer be <strong class="source-inline">async</strong> methods. They should also be renamed as <strong class="source-inline">GetCurrentOrders</strong> and <strong class="source-inline">GetArchivedOrders</strong> so consumers are aware that they are not <strong class="source-inline">async</strong> methods:<p class="source-code"><strong class="bold">private List&lt;Order&gt; GetCurrentOrders()</strong></p><p class="source-code">{</p><p class="source-code">    var orders = new List&lt;Order&gt;();</p><p class="source-code">    <strong class="bold">Thread.Sleep(4000);</strong></p><p class="source-code">    orders.Add(new Order { OrderId = 55, CustomerName </p><p class="source-code">        = "Tony", IsArchived = false });</p><p class="source-code">    orders.Add(new Order { OrderId = 56, CustomerName </p><p class="source-code">        = "Peggy", IsArchived = false });</p><p class="source-code">    orders.Add(new Order { OrderId = 60, CustomerName </p><p class="source-code">        = "Carol", IsArchived = false });</p><p class="source-code">    orders.Add(new Order { OrderId = 62, CustomerName </p><p class="source-code">        = "Bruce", IsArchived = false });</p><p class="source-code">    return orders;</p><p class="source-code">}</p><p class="source-code"><strong class="bold">private List&lt;Order&gt; GetArchivedOrders()</strong></p><p class="source-code">{</p><p class="source-code">    var orders = new List&lt;Order&gt;();</p><p class="source-code">    <strong class="bold">Thread.Sleep(5000);</strong></p><p class="source-code">    orders.Add(new Order { OrderId = 3, CustomerName = </p><p class="source-code">        "Howard", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 18, CustomerName </p><p class="source-code">        = "Steve", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 19, CustomerName </p><p class="source-code">        = "Peter", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 21, CustomerName </p><p class="source-code">        = "Mary", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 25, CustomerName </p><p class="source-code">        = "Gwen", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 34, CustomerName </p><p class="source-code">        = "Harry", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 36, CustomerName </p><p class="source-code">        = "Bob", IsArchived = true });</p><p class="source-code">    orders.Add(new Order { OrderId = 49, CustomerName </p><p class="source-code">        = "Bob", IsArchived = true });</p><p class="source-code">    return orders;</p><p class="source-code">}</p></li>
</ol>
<p>The changes are minimal, and I have highlighted them in the preceding source code. The <strong class="source-inline">async</strong> modifier has been removed from the method declarations, the methods have been renamed and they no longer return tasks, and <strong class="source-inline">Task.Delay</strong> in each <a id="_idIndexMarker219"/>method has been updated to <strong class="source-inline">Thread.Sleep</strong>.</p>
<ol>
<li value="2">Next, we will update the <strong class="source-inline">LoadOrderDataAsync</strong> method to call the synchronous methods with <strong class="source-inline">Task.Run</strong>:<p class="source-code">private async Task LoadOrderDataAsync()</p><p class="source-code">{</p><p class="source-code">    Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = </p><p class="source-code">        <strong class="bold">Task.Run(GetCurrentOrders)</strong>;</p><p class="source-code">    Task&lt;List&lt;Order&gt;&gt; archivedOrdersTask = </p><p class="source-code">        <strong class="bold">Task.Run(GetArchivedOrders)</strong>;</p><p class="source-code">    List&lt;Order&gt;[] results = await Task.WhenAll(new </p><p class="source-code">        Task&lt;List&lt;Order&gt;&gt;[] {</p><p class="source-code">        currentOrdersTask, archivedOrdersTask</p><p class="source-code">    }).ConfigureAwait(false);</p><p class="source-code">    ProcessOrders(results[0], results[1]);</p><p class="source-code">}</p></li>
</ol>
<p>No other changes are necessary. <strong class="source-inline">Task.Run</strong> will return the same <strong class="source-inline">Task&lt;List&lt;Order&gt;&gt;</strong> type, which can still be used with <strong class="source-inline">Task.WhenAll</strong> to wait for their completion.</p>
<ol>
<li value="3">Run the program, and it should work exactly as it did before. The UI remains responsive while the order data is loading.</li>
</ol>
<p>This is an excellent way to start incorporating <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> into existing code, but always use caution when adding threading to your applications. In this application, the two methods being called do not access any shared data. So, there was no need to think about thread safety. If these methods were updating a private collection of orders, you would need to introduce a locking mechanism or use a thread-safe collection for the orders.</p>
<p>Before we move on to a discussion of the UI thread, there is one other <strong class="source-inline">Task</strong> method to discuss. The <strong class="source-inline">Task.Factory.StartNew</strong> method is similar in use to <strong class="source-inline">Task.Run</strong>. In fact, you can use them in the <a id="_idIndexMarker220"/>same way. This code uses <strong class="source-inline">Task.Run</strong> to get a <strong class="source-inline">Task</strong> with the current orders:</p>
<pre class="source-code">Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = Task.Run</pre>
<pre class="source-code">     (GetCurrentOrders);</pre>
<p>This code does the same thing with <strong class="source-inline">Task.Factory.StartNew</strong>:</p>
<pre class="source-code">Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = Task.Factory.StartNew</pre>
<pre class="source-code">     (GetCurrentOrders);</pre>
<p>In this case, you should use <strong class="source-inline">Task.Run</strong>. It is a newer method and is simply a shortcut meant to simplify the most common use cases. The <strong class="source-inline">Task.Factory.StartNew</strong> method has some additional overloads for specific uses. This example uses <strong class="source-inline">StartNew</strong> to call <strong class="source-inline">GetCurrentOrders</strong> with some optional parameters:</p>
<pre class="source-code">Task&lt;List&lt;Order&gt;&gt; currentOrdersTask = </pre>
<pre class="source-code">    Task.Factory.StartNew(GetCurrentOrders, </pre>
<pre class="source-code">    CancellationToken.None, </pre>
<pre class="source-code">    <strong class="bold">TaskCreationOptions.AttachedToParent</strong>, </pre>
<pre class="source-code">    TaskScheduler.Default);</pre>
<p>The interesting option we have provided here is <strong class="source-inline">TaskCreationOptions.AttachedToParent</strong>. What this does is it links the task completion of the calling method to that of the child, <strong class="source-inline">GetCurrentOrders</strong>. The default behavior is for their completions to be unlinked. For a complete list of available overloads and their uses, you can review Microsoft Docs here: <a href="https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew">https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout"><em class="italic">Stephen Toub</em> of the .NET team has a blog post where he discusses <strong class="source-inline">Task.Run</strong> versus <strong class="source-inline">Task.Factory.StartNew</strong> and why you might want to choose each option. You can read his post on the <em class="italic">.NET Parallel Programming</em> blog here: <a href="https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/">https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/</a>.</p>
<p>Now, let’s move on to discuss<a id="_idIndexMarker221"/> when you will need to write code to explicitly update the UI thread from a background thread.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Updating the UI thread without exceptions</h1>
<p>When working with managed threading in .NET applications, there are many pitfalls that developers must learn to avoid. One<a id="_idIndexMarker222"/> of the common mistakes developers make is writing code that updates a UI control in a Windows application from a non-UI thread. This kind of error will not be detected by the compiler. Developers will receive a runtime error indicating that a control created on the main thread cannot be modified on another thread.</p>
<p>So, how do you avoid these runtime errors? The best way to avoid them is by not updating UI controls from background threads at all. WPF helps avoid the problem with the MVVM pattern and data binding. Binding updates are automatically marshaled to the UI thread by .NET. You can safely update properties in your <strong class="source-inline">ViewModel</strong> classes from a background thread without causing errors at runtime.</p>
<p>If you are updating UI controls directly in your code, either in a WinForms application or in the code-behind file of a WPF control, you can use an <strong class="source-inline">Invoke</strong> call to <em class="italic">push</em> the execution to the main thread. The implementation is slightly different between WinForms and WPF. Let’s start with a WPF example. If you have a method performing some work on a background thread, and it needs to update the <strong class="source-inline">Text</strong> property of a <strong class="source-inline">TextBox</strong> on a WPF window, you could wrap the code in an action:</p>
<pre class="source-code">Application.Current.Dispatcher.Invoke(new Action(() =&gt; { </pre>
<pre class="source-code">    usernameTextBox.Text = "John Doe";</pre>
<pre class="source-code">}));</pre>
<p><strong class="source-inline">Dispatcher.Invoke</strong> will push the execution to the main thread. Keep in mind that if the main thread is busy with other work, your background thread will wait here for this action to complete. If your background worker wants to fire and forget this action, you can use <strong class="source-inline">Dispatcher.BeginInvoke</strong> instead.</p>
<p>Let’s assume we want to update <strong class="source-inline">usernameTextBox</strong>, but this time, we are working with a WinForms project. The same invocation can be accomplished by using <strong class="source-inline">Form</strong> or <strong class="source-inline">UserControl</strong> executing the code. This<a id="_idIndexMarker223"/> example is a WinForms application with two buttons. Clicking one button will call the <strong class="source-inline">UpdateUsername</strong> method. The other button will call <strong class="source-inline">Task.Run(UpdateUsername)</strong>, putting it on a background thread. To determine whether <strong class="source-inline">Invoke</strong> is needed to access the main thread, you check the Boolean <strong class="source-inline">InvokeRequired</strong> read-only property. It may not be required if the thread pool chose to run <strong class="source-inline">Task</strong> on the main thread:</p>
<pre class="source-code">public partial class Form1 : Form</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    public Form1()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        InitializeComponent();</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private void btnRunInBackground_Click(object sender, </pre>
<pre class="source-code">        EventArgs e)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        Task.Run(UpdateUsername);</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private void btnRunOnMainThread_Click(object sender, </pre>
<pre class="source-code">        EventArgs e)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        UpdateUsername();</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private void UpdateUsername()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        var updateAction = new Action(() =&gt;</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            usernameTextBox.Text = "John Doe";</pre>
<pre class="source-code">        });</pre>
<pre class="source-code">        if (<strong class="bold">this.InvokeRequired</strong>)</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            this.Invoke(updateAction);</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">        else</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            updateAction();</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>The <strong class="source-inline">usernameTextBox</strong> will display<a id="_idIndexMarker224"/> the name <strong class="bold">John Doe</strong> successfully regardless of which button is clicked:</p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<img alt="Figure 4.3 – Updating a control on a WinForms form " height="510" src="image/Figure_4.4_B18552.jpg" width="1173"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Updating a control on a WinForms form</p>
<p>Like WPF, WinForms has a <strong class="source-inline">BeginInvoke</strong> method if the background code does not need to wait for the main thread update to complete. <strong class="source-inline">BeginInvoke</strong> can also accept an <strong class="source-inline">EndInvoke</strong> delegate that<a id="_idIndexMarker225"/> will receive a callback when the main thread invocation has completed.</p>
<p>This section provided a great start on using .NET managed threading in your Windows client applications. Let’s finish up with a summary of what we learned in this chapter.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Summary</h1>
<p>In this chapter, we learned some useful techniques for improving client application performance. We started by exploring some different uses of <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> in the ViewModel of a WPF application. In that project, we saw that awaiting <strong class="source-inline">Task.WhenAll</strong> does not block the main thread, which keeps the UI responsive to user input. We discussed how <strong class="source-inline">Task.Run</strong> and <strong class="source-inline">Task.Factory.StartNew</strong> can be used to call synchronous code from asynchronous code, making it easier to introduce managed threading to existing applications. We finished up the chapter by learning some techniques to update the UI thread from other threads without causing exceptions at runtime.</p>
<p>You should be feeling more comfortable using <strong class="source-inline">async</strong>, <strong class="source-inline">await</strong>, and the TPL in your code after reading this chapter. Try taking what you have learned here and start adding some <strong class="source-inline">async</strong> code to your own client applications. For additional reading on <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>, you can check out this C# article on Microsoft Docs: <a href="https://docs.microsoft.com/dotnet/csharp/async">https://docs.microsoft.com/dotnet/csharp/async</a>.</p>
<p>In the next chapter, we will dive even deeper into using <strong class="source-inline">async</strong>, <strong class="source-inline">await</strong>, and the TPL. We will take some of the concepts from this chapter and expand on them while introducing some best practices.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Questions</h1>
<ol>
<li value="1">What type should every <strong class="source-inline">async</strong> method return?</li>
<li>Which method can be used to await multiple tasks?</li>
<li>Which method to start a new task accepts <strong class="source-inline">TaskDispatcher</strong> as one of the parameters?</li>
<li>When calling an <strong class="source-inline">async</strong> method, what type of thread will execute the task?</li>
<li>What method should be used in a WPF application when updating a user control from a background thread?</li>
<li>Which method should be used on a WinForms control to execute an action on the main thread but not wait for the method to complete?</li>
<li>In WinForms, how can you check whether calling <strong class="source-inline">Invoke</strong> is necessary?</li>
</ol>
</div>
</div>
</body></html>