- en: What to Know Before Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始之前需要了解的内容
- en: You're off to a pretty good start. By now, you should be starting to feel comfortable
    with the basic concepts behind Test-Driven Development. You know the basic premise
    behind TDD and how to write a unit test in C# and JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经取得了相当不错的进展。到现在为止，你应该开始对测试驱动开发背后的基本概念感到舒适。你知道TDD的基本前提以及如何在C#和JavaScript中编写单元测试。
- en: 'In this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: We'll cover more of the practices behind TDD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将介绍更多TDD背后的实践
- en: Specific advice will be given on how to avoid pitfalls along the way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将提供具体的建议，以避免在过程中遇到陷阱
- en: We'll explain the importance of defining and testing boundaries, abstracting
    away third-party code (including the .NET Framework)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将解释定义和测试边界的重要性，以及抽象第三方代码（包括.NET框架）
- en: We'll begin to introduce more advanced concepts, such as spies, mocks, and fakes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将开始介绍更高级的概念，例如间谍、模拟和伪造
- en: First, let's cover some issues you may run into while trying to test an existing
    application. Hopefully, this will help you avoid problems in your next green-field
    application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下在尝试测试现有应用程序时可能会遇到的一些问题。希望这能帮助你避免在下一个绿色田野应用程序中遇到问题。
- en: Untestable code
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无法测试的代码
- en: There are a variety of telltale signs that an application, class, or method
    will be difficult, or even impossible, to test. Sure, there are ways around some
    of the following examples but it's usually best to just avoid workarounds and
    programmatic acrobatics. Simple is usually best, and your future self and/or future
    maintainers will thank you for keeping things simple.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多明显的迹象表明一个应用程序、类或方法将难以测试，甚至可能根本无法测试。当然，有一些方法可以绕过以下一些例子，但通常最好是避免这些解决方案和程序性杂技。简单通常是最好的，你的未来自己和/或未来的维护者会感谢你保持事物的简单性。
- en: Dependency Injection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: If you're creating instances of external resources within your constructors
    or inside methods instead of having them passed in, it will be very difficult
    to write tests to cover these classes and methods. Generally, in today's modern
    applications, Dependency Injection frameworks are used to create and provide the
    external dependencies to a class. Many choose to define an *interface* as the
    contract for the dependency, providing a more flexible method for testing and
    the coupling to external resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在构造函数或方法内部创建外部资源实例，而不是将它们传递进来，将非常难以编写测试来覆盖这些类和方法。通常，在当今的现代应用程序中，依赖注入框架用于创建和提供外部依赖项给一个类。许多人选择定义一个*接口*作为依赖项的契约，提供一种更灵活的测试方法，并减少对外部资源的耦合。
- en: Static
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态
- en: You may have a need to access static third-party classes or methods. Instead
    of accessing static resources directly, it would be better to access these through
    an *interface*. In the example of `DateTime` in C#, `Now` is a static property,
    which prevents you from being able to control the `DateTime` value used by the
    class or method being tested. This makes it more difficult to verify your test
    cases and ensure your program's logic is behaving correctly, based on specific
    dates or times.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要访问静态第三方类或方法。而不是直接访问静态资源，最好通过*接口*来访问这些资源。以C#中的`DateTime`为例，`Now`是一个静态属性，这阻止了你控制被测试的类或方法使用的`DateTime`值。这使得验证测试用例和确保程序逻辑根据特定日期或时间正确行为变得更加困难。
- en: Singleton
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: '*Singletons* are the essence of the shared state. In order to ensure your tests
    run in an isolated environment, it would be best to avoid them. If a *singleton*
    is required (for example, `Logging`, `Data Context`, and so on), most Dependency
    Injection frameworks allow for the substitution of a non-singleton class as a
    single instance, which gives the functionality and flexibility of effectively
    having a singleton. For production code, this allows you to control the scope
    of the singleton instance.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*单例*是共享状态的本质。为了确保你的测试在隔离环境中运行，最好避免使用它们。如果需要*单例*（例如，`Logging`、`Data Context`等），大多数依赖注入框架允许用非单例类替换单例实例，从而提供单例的功能和灵活性。对于生产代码，这允许你控制单例实例的作用域。'
- en: Global state
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局状态
- en: It has long been understood that global state within an application will wreak
    havoc on a system and cause unexpected behavior that is difficult to trace. Changing
    the code in one place will possibly have far-reaching side-effects on the rest
    of your system. For testability, this often means much more effort in setup and
    slower test execution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很早就已经明白，应用程序中的全局状态会对系统造成破坏，并导致难以追踪的意外行为。在一个地方更改代码可能会对系统的其余部分产生深远的影响。为了可测试性，这通常意味着在设置上需要更多的努力，并且测试执行会变慢。
- en: Abstracting third-party software
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象第三方软件
- en: As your application grows, you'll likely introduce external dependencies. Assuredly,
    the developers of these systems, applications, and libraries have thoroughly tested
    their offerings. You should focus your attention on testing your application,
    not on testing third-party code. Your application should be robust enough to handle
    edge cases, and you'll want to account for expected and unexpected behavior. You'll
    want to abstract away the details of the third-party code and test for expected
    (and unexpected) results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序增长，你可能会引入外部依赖。当然，这些系统、应用程序和库的开发者已经彻底测试了他们的产品。你应该专注于测试你的应用程序，而不是测试第三方代码。你的应用程序应该足够健壮，能够处理边缘情况，并且你需要考虑到预期和非预期的行为。你希望抽象掉第三方代码的细节，并测试预期的（以及意外的）结果。
- en: So, what is *third-party code*? Anything you didn't write. That includes the
    .NET Framework itself. One way to achieve the abstraction of third-party code
    is with the use of test doubles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是**第三方代码**？任何你未编写的代码。这包括.NET框架本身。实现第三方代码抽象的一种方法是通过使用测试替身。
- en: Test doubles
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试替身
- en: Test doubles are functions and classes that aid in the testing process by allowing
    you to either verify functionality or bypass a dependency that would otherwise
    be difficult to test. Test doubles are used at all levels to isolate the code
    being tested. Many times, the need for a test double drives the architecture of
    the code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身是函数和类，通过允许你验证功能或绕过难以测试的依赖项来帮助测试过程。测试替身被用于所有级别以隔离正在测试的代码。很多时候，对测试替身的需求推动了代码的架构。
- en: The `DateTime` object in C# is an example of when this is the case. `System.DateTime`
    is part of the .NET Framework, and normally you wouldn’t think that you would
    abstract this in your code. The instinct of most developers is to simply reference
    it in a *using statement* and then access `DateTime.Now` directly within their
    code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`DateTime`对象就是一个这样的例子。`System.DateTime`是.NET框架的一部分，通常你不会认为你需要在代码中抽象这部分。大多数开发者的本能是在一个*using语句*中简单地引用它，然后在他们的代码中直接访问`DateTime.Now`。
- en: A test that can't be repeated is a bad test.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无法重复的测试是一个糟糕的测试。
- en: This is usually difficult to test. If we were to try to test a method using
    `DateTime.Now`, we would be unable to prevent `DateTime.Now` default functionality.
    `DateTime.Now` returns the current date and time stored in a `DateTime` object.
    Not having the ability to manipulate the return of this object causes our tests
    to be unpredictable and unrepeatable. A test that can't be repeated is a bad test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常很难测试。如果我们尝试使用`DateTime.Now`测试一个方法，我们将无法阻止`DateTime.Now`的默认功能。`DateTime.Now`返回存储在`DateTime`对象中的当前日期和时间。无法操纵此对象的返回值会导致我们的测试变得不可预测和不可重复。一个无法重复的测试是一个糟糕的测试。
- en: Many developers already understand the need for predictability. You may have
    heard the phrase, *If it can't be reproduced, it's not a bug* or a similar sentiment.
    This is because, in order to verify that we have fixed a bug, we must be able
    to predictably repeat the error. This way, once the steps to reproduce it no longer
    produce the bug, we can confidently say that the bug is fixed. At least we can
    for that series of steps.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者已经理解了可预测性的必要性。你可能听说过这样的话，“如果无法重现，就不是bug”或类似的观点。这是因为，为了验证我们已修复了一个bug，我们必须能够可预测地重复该错误。这样，一旦重现错误的步骤不再产生bug，我们就可以自信地说bug已经被修复。至少对于那一系列步骤是这样的。
- en: Testing is no different from bug fixing; it follows all the same steps. We just
    know exactly what caused the bug; the code hasn't been written yet, or the refactoring
    we just attempted failed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试与修复bug没有不同；它遵循所有相同的步骤。我们只是确切知道是什么导致了bug；代码尚未编写，或者我们刚刚尝试的重构失败了。
- en: Creating test doubles can get a little involved at times. For this reason, frameworks
    to support the creation of these test doubles have been created for nearly every
    language that has a testing framework. The frameworks are generally referred to
    as mocking frameworks or libraries. In C#, the predominant framework currently
    in use is *Moq*, pronounced *mock*. Similarly, in JavaScript, the most referenced
    mocking library seems to be *Sinon*, pronounced *sign on*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试替身有时可能会变得有些复杂。因此，为了支持这些测试替身创建，几乎为每种拥有测试框架的语言都创建了框架。这些框架通常被称为模拟框架或库。在C#中，目前最广泛使用的框架是*Moq*，发音为*mock*。同样，在JavaScript中，最常引用的模拟库似乎是*Sinon*，发音为*sign
    on*。
- en: Mocking frameworks
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟框架
- en: Mocking frameworks are a great utility to alleviate some of the pressure of
    testing in a large project. They are especially useful when trying to wrap tests
    around a legacy system. A legacy system, in this case, is defined as an application
    that does not already have tests around it. This definition is from Michael Feather's
    book, *Working Effectively with Legacy Code*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟框架是缓解大型项目中测试压力的绝佳工具。当尝试围绕遗留系统编写测试时，它们尤其有用。在这个例子中，遗留系统被定义为尚未围绕它编写测试的应用程序。这个定义来自Michael
    Feather的书籍《*与遗留代码有效工作*》。
- en: Use caution while learning Test-Driven Development and using mocking frameworks.
    Mocking frameworks provide a very attractive alternative to carefully considering
    your code. It is possible to write a complete set of tests that, in the end, only
    really test the mocking framework.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习测试驱动开发和使用模拟框架时，请谨慎行事。模拟框架提供了一个非常有吸引力的替代方案，可以让你不必仔细考虑你的代码。你可能会编写一套完整的测试，最终却只真正测试了模拟框架。
- en: Many mocking frameworks are overpowered in this respect. In C#, a classification
    of mocking frameworks exists that allows you to replace external code. This external
    code includes `DateTime.Now` and any other class that you don’t control. In JavaScript,
    this is called monkey patching, and every framework allows you to do it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模拟框架在这方面功能过于强大。在C#中，存在一种模拟框架的分类，允许你替换外部代码。这些外部代码包括`DateTime.Now`和任何其他你无法控制的类。在JavaScript中，这被称为monkey
    patching，每个框架都允许你这样做。
- en: What's the harm, you ask? One of the benefits of TDD is that it encourages smart
    architectural choices. When you have the power to override the functionality of
    the third-party code, you no longer have the need to abstract in order to test.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你问，这有什么害处吗？TDD（测试驱动开发）的一个好处是它鼓励做出明智的架构选择。当你有权力覆盖第三方代码的功能时，你就不再需要为了测试而进行抽象。
- en: Why is that a problem? Abstraction of the third-party is necessary if we want
    to keep the code flexible and if we want to follow the SOLID principles.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么那是个问题呢？如果我们想要保持代码的灵活性，并且想要遵循SOLID原则，那么对第三方代码的抽象是必要的。
- en: The SOLID principles
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: 'The SOLID principles are a collection of concepts originally put together by
    Robert C. Martin, aka "Uncle Bob." Usually advertised as *Object-Oriented Principles*,
    you should think of them as just plain good architectural choices. The SOLID principles
    consist of five principles: the Single Responsibility Principle, the Open/Closed
    principle, the Liskov Substitution principle, the Interface Segregation Principle,
    and the Dependency Inversion Principle.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是一组最初由Robert C. Martin（即“Uncle Bob”）组合起来的概念。通常被宣传为*面向对象原则*，你应该把它们看作是纯粹的好的架构选择。SOLID原则包括五个原则：单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则。
- en: The original articles on the SOLID principles are available at [http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SOLID原则的原始文章可在[http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)找到。
- en: The Single Responsibility Principle
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: In Uncle Bob's article, the **Single Responsibility Principle** (**SRP**) is
    defined as, "A class should have only one reason to change."
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Uncle Bob的文章中，**单一职责原则（SRP**）被定义为：“一个类应该只有一个改变的理由。”
- en: What does this mean? That is the tough part; there are many approaches to understanding
    the meaning. One way to look at it is that the class should only support one business
    user. Another is that, within the application, the class should only be used with
    a limited or specific scope. Another is that the class should have a limited range
    of functionality. These are all correct, and yet insufficient. One way to ensure
    you are following it is to use what we will refer to as the "Rule of Three to
    Five."
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？这是困难的部分；有很多人理解其含义的方法。一种看法是，类应该只支持一个业务用户。另一种看法是，在应用程序内部，类应该只在有限的或特定的范围内使用。还有一种看法是，类应该具有有限的功能范围。这些都是正确的，但还不够充分。确保你遵守这一原则的一种方法是我们将要提到的“三到五规则”。
- en: If we're discussing requirements, for example, when a requirement has between
    three to five acceptance criteria, then it is most likely appropriately sized
    for its level of detail. Similarly, if we are discussing a method or function,
    then three to five lines of code is probably appropriately sized.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在讨论需求，例如，当一个需求有三个到五个验收标准时，那么它很可能在细节程度上是适当规模的。同样，如果我们正在讨论一个方法或函数，那么三到五行代码可能也是适当规模的。
- en: The Rule of Three to Five is a generic way to know that you are honoring the
    SRP. The rule states, "Less than three is good. Between three and five is fine.
    Above five is strongly consider refactoring." It's not quite as elegant as many
    other laws, principles, and rules, but the rule of three to five is easy to follow.
    This rule is just a guideline and should not be used as an ultimatum. You should
    try to apply this rule to just about everything in software development. You have
    already seen it in action in this book. This rule was used to determine the scope
    of the requirements in [Chapter 1](part0021.html#K0RQ0-d186949d2da74f5c95dd1712efae1195),
    *Why TDD is Important*, and in all the code samples that have been included so
    far.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 三到五规则是一种通用的方式来了解你是否在遵守SRP。该规则表述为：“少于三个是好的。三个到五个是不错的。超过五个则强烈考虑重构。”它并不像许多其他法律、原则和规则那样优雅，但三到五规则很容易遵循。这个规则只是一个指导方针，不应被视为最终命令。你应该尝试将这个规则应用到软件开发中的几乎所有事情上。你已经在本书中看到了它的应用。这个规则被用来确定[第1章](part0021.html#K0RQ0-d186949d2da74f5c95dd1712efae1195)，“为什么TDD很重要”中需求的范围，以及到目前为止所包含的所有代码示例。
- en: If you use the Rule of Three to Five, it nearly guarantees that you are following
    SRP, and it keeps your code, file structure, and requirements small and maintainable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用三到五规则，几乎可以保证你正在遵循单一职责原则（SRP），并且它使你的代码、文件结构和需求保持小而易于维护。
- en: The Open/Closed principle
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: The Open/Closed principle states, "Software entities (classes, modules, functions,
    and so on) should be open for extension, but closed for modification." The second
    of the SOLID principles doesn't sound like it is saying much, but it has a large
    impact.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 开放/封闭原则表述为：“软件实体（类、模块、函数等）应该对扩展开放，但对修改封闭。”SOLID原则中的第二个听起来似乎并没有说很多，但它有着巨大的影响。
- en: There are many ways to honor this principle. You or your development team could
    put into place a rule that only allows for new development. That is, any existing
    functionality cannot be updated or changed, only replaced by new methods or classes.
    When we get to creating dividing lines in the code, you could use those dividing
    lines to create a place for this functionality swap to take place.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方式来遵守这一原则。你可以或你的开发团队可以制定一个规则，只允许新的开发。也就是说，现有的功能不能被更新或改变，只能通过新的方法或类来替换。当我们到达创建代码分隔线的时候，你可以使用这些分隔线来创建一个进行功能交换的地方。
- en: The Open/Closed principle also enables continuous integration and deployment.
    This is because, if your application never breaks a contract it has with the user,
    itself, or a third party, then it can always be deployed without fear of causing
    a production issue.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 开放/封闭原则还使持续集成和部署成为可能。这是因为，如果你的应用程序从未违反与用户、自身或第三方之间的合同，那么它总是可以部署而不用担心引起生产问题。
- en: The Liskov Substitution principle
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则
- en: 'The Liskov Substitution principle may be difficult to understand at first due
    to its somewhat complex and mathematical definition. From Barbara Liskov''s *Data
    Abstraction and Hierarchy* [[https://pdfs.semanticscholar.org/36be/babeb72287ad9490e1ebab84e7225ad6a9e5.pdf](https://pdfs.semanticscholar.org/36be/babeb72287ad9490e1ebab84e7225ad6a9e5.pdf)],
    the principle is stated as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Liskov 替换原则可能由于其复杂和数学定义而难以理解。从 Barbara Liskov 的 *数据抽象和层次结构* [[https://pdfs.semanticscholar.org/36be/babeb72287ad9490e1ebab84e7225ad6a9e5.pdf](https://pdfs.semanticscholar.org/36be/babeb72287ad9490e1ebab84e7225ad6a9e5.pdf)]
    中，该原则被表述如下：
- en: '*What is wanted here is something like the following substitution property.
    If for each object o1 of type S there is an object o2 of type T, such that for
    all programs P defined in terms of T, the behavior of P is unchanged when o1 is
    substituted for o2, then S is a subtype of T.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里所需要的是类似以下替换属性。如果对于类型S的每个对象o1，都存在一个类型T的对象o2，使得对于所有以T定义的程序P，当用o1替换o2时，P的行为保持不变，那么S是T的子类型。*'
- en: Uncle Bob has simplified this definition to be, *Functions that use pointers
    or references to base classes must be able to use objects of derived classes without
    knowing it.* Looking at this principle, it seems like it would just be inheritance.
    Except, it's not just inheritance. This principle implies that not only does the
    object replacing the other have to implement the same interface or contract as
    the original, it must also adhere to the same expectations as the original.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Uncle Bob 将这个定义简化为，*使用基类指针或引用的函数必须能够在不知道的情况下使用派生类的对象。* 看这个原则，它似乎只是继承。但是，它不仅仅是继承。这个原则意味着替换其他对象的那个对象不仅必须实现与原始对象相同的接口或合同，还必须遵守与原始对象相同的期望。
- en: The classic example of a violation of this principle is the use of a square
    class in the place of a rectangle class. A typical rectangle class would need
    to have both length and width properties. In mathematics, a square is just a special
    type of rectangle. So, many would assume that creating a square class with length
    and width would be an acceptable swap for the rectangle class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 违反此原则的经典例子是在矩形类的地方使用正方形类。一个典型的矩形类需要具有长度和宽度属性。在数学上，正方形只是矩形的一种特殊类型。因此，许多人会认为创建具有长度和宽度的正方形类可以接受地替换矩形类。
- en: The problem here is that a square requires that both length and width have the
    same value. So, when you change either one on the square class, the class will
    update the other to have the same value. This is a problem because the application
    using the object doesn't expect this behavior. Therefore, the application must
    be aware of the possibility of the length or width changing without notice.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，正方形要求长度和宽度具有相同的值。因此，当你更改正方形类中的任何一个时，该类将更新另一个以具有相同的值。这是一个问题，因为使用该对象的应用程序并不期望这种行为。因此，应用程序必须意识到长度或宽度可能在没有通知的情况下更改的可能性。
- en: A failure to meet the expectations of the application is known as a refused
    bequest. A refused bequest can cause inconsistent behavior in an application and,
    at the very least, requires more code to compensate for the mismatch.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无法满足应用程序的期望被称为拒绝遗赠。拒绝遗赠可能导致应用程序行为不一致，并且至少需要更多的代码来补偿不匹配。
- en: The Interface Segregation principle
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The Interface Segregation principle is about keeping to the contract of interaction
    presented by your class small. More than small, the contract presented by your
    class should have a single responsibility.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则是关于保持你的类小而简洁的交互合同。更具体地说，你的类所呈现的合同应该只有一个责任。
- en: Sometimes, having a class with a small single responsibility contract is difficult
    or not desired. In those instances, the class should implement multiple contracts
    instead of creating a combined contract. We want multiple contracts to reduce
    the number of far-reaching dependencies.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，拥有一个具有小而单一责任合同的类可能很困难或不是所希望的。在这些情况下，类应该实现多个合同，而不是创建一个组合合同。我们希望多个合同可以减少远距离依赖的数量。
- en: Every time a base class or interface is modified, the child classes must also
    be modified. At the very least, the child classes must now be recompiled. By limiting
    the scope of a contract, we can reduce the impact of changing that contract and
    improve the overall system architecture.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每次修改基类或接口时，子类也必须进行修改。至少，子类现在必须重新编译。通过限制合同的范围，我们可以减少更改该合同的影响，并改善整体系统架构。
- en: The Dependency Inversion principle
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: Inversion of dependencies is important for several reasons, among which are
    that inverted dependencies increase flexibility, decrease fragility, and help
    the code to be potentially reused.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项倒置之所以重要，有几个原因，其中之一是倒置的依赖项增加了灵活性，减少了易碎性，并有助于代码的潜在重用。
- en: Inversion of dependencies allows for a plugin type architecture. By defining
    a contract of interaction, a module can determine how it wants to interact with
    dependencies. Then the dependencies depend on that contract.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项倒置允许插件式架构。通过定义交互合同，一个模块可以确定它想要如何与依赖项交互。然后依赖项依赖于该合同。
- en: Because the top-level module has no outgoing dependencies, it can be deployed
    independently. Deploying a piece of an application independently almost never
    happens, but having an independently deployable library has the tremendous benefit
    of not needing to be recompiled when a dependency changes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为顶层模块没有外部依赖，它可以独立部署。独立部署应用程序的一部分几乎从未发生过，但拥有一个可以独立部署的库在依赖项更改时不需要重新编译具有巨大的好处。
- en: In normal development, the dependencies fluctuate a lot more than the higher-level
    modules. This fluctuation causes the need to recompile. When your application
    dependencies flow downward, a dependency recompile also triggers a recompile of
    the dependent library. So, in effect, changing a utility helper class in a tiny,
    but common, library will trigger a recompile of your entire application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常开发中，依赖项的波动比高级模块要多得多。这种波动导致需要重新编译。当你的应用程序依赖项向下流动时，依赖项的重新编译也会触发依赖库的重新编译。因此，实际上，改变一个微小但常见的库中的实用辅助类将触发整个应用程序的重新编译。
- en: If you are inverting your dependencies, however, a change like this will only
    trigger a recompile of the utility helper library and the application library.
    It will not trigger a recompile of every library between.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在倒置依赖项，这样的变化只会触发实用辅助库和应用程序库的重新编译。它不会触发介于两者之间的每个库的重新编译。
- en: That does it for the SOLID principles. Please keep them in mind if you choose
    to use a mocking framework. Make sure you don't allow the mocking framework to
    trick you into building a rigid, fragile, immobile system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是SOLID原则的全部内容。如果你选择使用模拟框架，请记住它们。确保你不允许模拟框架诱使你构建一个僵化、易碎、不可移动的系统。
- en: Timely greeting
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 及时的问候
- en: 'Expanding on the classic *Hello World* example, what if you wanted to change
    your greeting based on the time of day? An example is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展经典的*Hello World*示例时，如果你想要根据一天中的时间改变你的问候语怎么办？以下是一个示例：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You might think to yourself, This is simple; I can just write a quick method
    to return the proper message. Of course, you would be right. This is a pretty
    easy task. You might come up with something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这很简单；我只需编写一个快速的方法来返回适当的消息。当然，你会是对的。这是一个相当容易的任务。你可能会想出像这样的一些东西：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember, back in [Chapter 1](part0021.html#K0RQ0-d186949d2da74f5c95dd1712efae1195),
    *Why TDD is Important*, we discussed the Three laws of TDD. The all-important
    first law states that you aren't allowed to write a single line of production
    code without a failing test.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在[第1章](part0021.html#K0RQ0-d186949d2da74f5c95dd1712efae1195)，“为什么TDD很重要”中，我们讨论了TDD的三个定律。至关重要的第一个定律指出，你不允许在没有失败的测试的情况下编写任何生产代码。
- en: Fragile tests
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易碎的测试
- en: '"But, this is such a simple method," you might say. What if you encountered
    a bug? What if you wanted to write some tests for this method after the fact?
    Would you have to run your test suite at a specific time of day to ensure a passing
    test? Would you have to alter your tests based on the time of day that you ran
    them?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: “但是，这是一个如此简单的方法，”你可能会说。如果你遇到了一个错误怎么办？如果你想在事后为这个方法编写一些测试怎么办？你是否需要在一个特定的时间运行你的测试套件以确保测试通过？你是否需要根据你运行测试的时间改变你的测试？
- en: False positives and false failures
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假阳性和假阴性
- en: 'If we left the code in our *Message* example as-is and wrote a test to cover
    the method, it might look something like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像在*消息*示例中那样直接留下代码，并编写一个测试来覆盖该方法，它可能看起来像这样：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Can you spot the problem with this test? There's nothing inherently wrong with
    the test, per se. The problem is that the production code will return a different
    message, based on the time of day. This means that if you ran the test in the
    afternoon, it would pass. If you ran the test in the morning, it would fail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现这个测试的问题吗？测试本身并没有固有的错误。问题是生产代码将根据一天中的时间返回不同的消息。这意味着如果你在下午运行测试，它会通过。如果你在早上运行测试，它会失败。
- en: Abstract DateTime
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象 DateTime
- en: '`DateTime` is part of the .NET Framework, and therefore, it should be abstracted
    away from our system. Typically, we want our system to depend on interfaces, allowing
    us to substitute implementations at runtime.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime` 是 .NET Framework 的一部分，因此，它应该从我们的系统中抽象出来。通常，我们希望我们的系统依赖于接口，这样我们就可以在运行时替换实现。'
- en: 'Following is an example of `ITimeManager`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 `ITimeManager` 的示例：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For testing purposes, you might end up with an implementation of `ITimeManager`
    that looks like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，你可能会得到一个看起来像这样的 `ITimeManager` 实现：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This allows us to set the value for `Now` so that we can supply a known value
    to our test methods. Now, let''s revisit our tests:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们设置 `Now` 的值，以便我们可以向测试方法提供已知值。现在，让我们回顾我们的测试：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our production code would end up looking something like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生产代码最终可能看起来像这样：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Test double types
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Test double 类型
- en: Test doubles come in many varieties. Those varieties can generally be grouped
    as dummies, stubs, spies, mocks, and fakes. Coming up, we will discuss the different
    types and provide examples in C# and in JavaScript for each.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身有很多种类。这些种类通常可以分为 dummies、stubs、spies、mocks 和 fakes。接下来，我们将讨论不同类型，并为每种类型提供
    C# 和 JavaScript 的示例。
- en: Dummies
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dummies
- en: Dummies are the simplest form of test double. A dummy has no appreciable functionality.
    We don't actually expect the `dummy` class or method to be used in the result
    of the class or method we are testing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Dummies 是测试替身中最简单的一种形式。Dummies 没有可感知的功能。我们实际上并不期望在测试的类或方法的结果中使用 `dummy` 类或方法。
- en: Dummies are most often used when the class you are testing has a dependency
    that the method or function you are testing does not use.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Dummies 通常在测试的类具有依赖关系，而你正在测试的方法或函数没有使用该依赖关系时使用。
- en: You create a dummy by creating a new copy or instance of a class or method and
    then doing absolutely nothing in the body of the code. Void methods will be empty
    and methods or functions expecting a return value will either throw when called
    or return the simplest form of that return value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个类或方法的新副本或实例来创建一个 dummies，然后在代码体中做任何事情。Void 方法将是空的，而期望返回值的函数或方法在调用时将抛出异常或返回该返回值的简单形式。
- en: Dummy logger
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dummy logger
- en: A *Logging* service is a perfect example of something that can be replaced with
    a dummy. While you are testing specific methods it is unlikely (and not recommended)
    to also test logging functionality.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*Logging* 服务是一个完美的例子，可以用 dummies 替换。当你正在测试特定方法时，不太可能（也不推荐）同时测试日志功能。'
- en: Example in C#
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 示例
- en: The following is an example of a `DummyLogger` in C#. You'll note that when `Log`
    is called nothing happens.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 C# 中的 `DummyLogger` 示例。你会注意到当调用 `Log` 时，没有任何操作发生。
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example in JavaScript
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 示例
- en: The following is an example of a `DummyLogger` in JavaScript. You'll note that
    when `info`, `warn`, `error`, and `success` are called nothing happens.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 JavaScript 中的 `DummyLogger` 示例。你会注意到当调用 `info`、`warn`、`error` 和 `success`
    时，没有任何操作发生。
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Stubs
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stubs
- en: Stubs are the next level up from dummies. A Stub test double will provide the
    same response regardless of the parameters passed into it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Stubs 是比 Dummies 高一级的测试替身。Stub 测试替身将提供与传入的参数无关的相同响应。
- en: Stubs are used when you want to test different paths of execution in your code.
    One instance is an error that must be thrown under a particular condition.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要测试代码中的不同执行路径时，会使用 Stubs。一个例子是在特定条件下必须抛出的错误。
- en: Stubs are created by creating a copy or override of the class or method that
    needs to return the stub value and then setting it to return the needed value.
    Remember, stubs don't evaluate parameters, so you need to just return the desired
    value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Stubs 是通过创建需要返回 stub 值的类或方法的副本或覆盖，然后将其设置为返回所需值来创建的。记住，stubs 不评估参数，所以你只需要返回所需的值。
- en: Example in C#
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 示例
- en: The following is an example of a `StubSpeakerContactServiceError` in C#. You'll
    note that, when `MessageSpeaker` is called then a new `UnableToContactSpeakerException`
    error is thrown.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个C#中的`StubSpeakerContactServiceError`的示例。你会注意到，当调用`MessageSpeaker`时，会抛出一个新的`UnableToContactSpeakerException`错误。
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example in JavaScript
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript示例
- en: The following is an example of a `stubSpeakerReducer` in JavaScript. You'll
    note that regardless of the action passed in, a new `*UNABLE_TO_RETRIEVE_SPEAKERS*`
    error is pushed to the error array in the state.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个JavaScript中`stubSpeakerReducer`的示例。你会注意到，无论传递什么操作，都会在状态中的错误数组中推送一个新的`*UNABLE_TO_RETRIEVE_SPEAKERS*`错误。
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Spies
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间谍（Spies）
- en: Spies are the next evolution in test doubles. A spy returns a value similar
    to a stub but has an extremely important and helpful difference. Spies can report
    back on the information related to the function call.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍（Spies）是测试替身（test doubles）的下一进化阶段。间谍返回一个类似于存根（stub）的值，但它有一个极其重要且有用的区别。间谍可以报告与函数调用相关的信息。
- en: Spies are most often used when you want to verify that a function was called
    with specific parameters. This is most useful at third-party boundaries in your
    application. For instance, it is important to know whether your application is
    correctly configuring a database connection using the credentials supplied by
    some configuration service. Also, in some cases, it is difficult to measure the
    side-effects of the method or function being tested. In those cases, you can use
    a spy to just make sure you are calling the method or function in the first place.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要验证一个函数是否以特定参数被调用时，间谍（Spies）通常被使用。这在你的应用程序的第三方边界处非常有用。例如，了解你的应用程序是否正确配置了数据库连接，使用了某些配置服务提供的凭据，这一点很重要。在某些情况下，测量被测试的方法或函数的副作用可能很困难。在这些情况下，你可以使用间谍来确保你首先调用了该方法或函数。
- en: Spies are created by starting with a stub and adding the functionality to determine
    whether a function has been called, how many times a function is called, or reporting
    what values were passed into that function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍（Spies）是通过从存根（stub）开始，并添加确定函数是否被调用、函数被调用的次数，或者报告传递给该函数的值的函数来创建的。
- en: Example in C#
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#示例
- en: The following is an example of a `SpySpeakerContactService` in C#. The `SpySpeakerContactService` allows
    you to determine if the service has been called and how many times it might have
    been called.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个C#中的`SpySpeakerContactService`的示例。`SpySpeakerContactService`允许你确定服务是否被调用，以及它可能被调用多少次。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example in JavaScript
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript示例
- en: The following is an example of a `spySpeakerReducer` in JavaScript. The `spySpeakerReducer`
    allows you to determine how many times it might have been called.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个JavaScript中`spySpeakerReducer`的示例。`spySpeakerReducer`允许你确定它可能被调用多少次。
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Mocks
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟（Mocks）
- en: Mocks are essentially programmable spies. Mocks are useful when you want to
    use the same test double in multiple tests. Mocks have the ability to return whatever
    values you set them to return. It is important to note that mocks are still not
    doing any logic. They return the value that is specified and do not check the
    parameters passed to the function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟（Mocks）基本上是可编程的间谍。当你想要在多个测试中使用相同的测试替身时，模拟（Mocks）非常有用。模拟能够返回你设置的任何值。需要注意的是，模拟仍然没有执行任何逻辑。它们返回指定的值，并不检查传递给函数的参数。
- en: Mocks are used in all the situations where dummies, stubs, and spies are used.
    Mocks are a heavier implementation of a test double, which is why you may not
    want to use them all the time. Mocks get less reuse than the previous test doubles
    because a mock's data must be set for each test, whereas a dummy, stub, or spy
    has a set return value that does not need to be configured. Setting up the test
    data that gets returned is often more difficult than simply creating a whole stub
    or spy class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟（Mocks）用于所有使用存根（dummies）、存根（stubs）和间谍（spies）的情况。模拟是测试替身的一个更重的实现，这也是为什么你可能不想总是使用它们的原因。与之前的测试替身相比，模拟的重用性较低，因为模拟的数据必须为每个测试设置，而存根、存根或间谍有一个固定的返回值，不需要配置。设置返回的测试数据通常比创建整个存根或间谍类更困难。
- en: Mocks are created by making a copy of a class or method and creating a property
    that can be set as the return value for a method; then, in the method being mocked,
    the property value is returned. Once created, before each test, the mock's return
    value must be set.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟（Mocks）是通过复制一个类或方法并创建一个可以设置为方法返回值的属性来创建的；然后，在正在模拟的方法中，返回该属性值。一旦创建，在每次测试之前，必须设置模拟的返回值。
- en: Example in C#
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#示例
- en: The following is an example of a `MockDateTimeService` in C#. The `MockDateTimeService`
    allows you to set the `DateTime` to be returned by the service in order to reliably
    test how other parts of the system might behave based on specific `DateTime`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个C#中的`MockDateTimeService`示例。`MockDateTimeService`允许您设置服务返回的`DateTime`，以便可靠地测试系统其他部分基于特定`DateTime`可能的行为。
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Example in JavaScript
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript示例
- en: The following is an example of a `MockDateTimeService` in JavaScript. Much like
    the `MockDateTimeService` in C#, this allows you to set the `DateTime` to be returned
    by the service in order to reliably test how other parts of the system might behave
    based on specific `DateTimes`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个JavaScript中的`MockDateTimeService`示例。与C#中的`MockDateTimeService`类似，这允许您设置服务返回的`DateTime`，以便可靠地测试系统其他部分基于特定`DateTimes`可能的行为。
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Fakes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: Fakes are the last and most powerful type of test double. A fake is a class
    that attempts to behave as if it weren't a test double. While a fake will not
    connect with a database, it will attempt to behave just like it is connecting
    to a database. A fake will not use the system clock, but it will attempt to have
    an internal clock that behaves as close to the system clock as possible.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是最后也是最强大的测试双胞胎类型。模拟是一个试图表现得像它不是一个测试双胞胎的类。虽然模拟不会连接到数据库，但它会尝试表现得就像它正在连接到数据库一样。模拟不会使用系统时钟，但它会尝试拥有一个尽可能接近系统时钟的内部时钟。
- en: Fakes either add extra testing functionality or prevent external interference
    from third-party libraries and systems. Most applications are connected to some
    data source. A fake repository can be created that uses its own in-memory data
    source but otherwise behaves just like a normal data connection.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟要么添加额外的测试功能，要么防止第三方库和系统的外部干扰。大多数应用程序都连接到某些数据源。可以创建一个使用其自己的内存数据源的模拟仓库，但除此之外，它的行为就像一个正常的数据连接。
- en: Fakes are created by generating a whole new class or method and then writing
    enough functionality to be indistinguishable from the production class or method.
    The only important distinction for a fake versus a production class or method
    is that the fake does not make external connections and likely has the ability
    for the tester to control the underlying data set.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是通过生成一个全新的类或方法，然后编写足够的功能以使其与生产类或方法不可区分来创建的。对于模拟与生产类或方法之间的唯一重要区别是，模拟不进行外部连接，并且可能允许测试人员控制底层数据集。
- en: Example in C#
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#示例
- en: The following is an example of a `FakeRepository` and associated *interfaces*.
    The `FakeRepository` is a fake implementation of a generic repository.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`FakeRepository`及其相关*接口*的示例。`FakeRepository`是一个泛型仓库的模拟实现。
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Example in JavaScript
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript示例
- en: The following is an example of a `FakeDataContext` in JavaScript.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个JavaScript中的`FakeDataContext`示例。
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: N-Tiered example
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: N层示例
- en: Now, turn your attention back to the API controller in [Chapter 2](part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195),
    *Setting Up the .NET Test Environment*. Hard-coded data being returned directly
    from the controller does not make for a solid foundation on which to build an
    application. Most modern .NET applications of any size are written in some sort
    of N-tiered architecture. You'll want to separate your business logic from your
    presentation, in this instance, the presentation in the API endpoint.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将您的注意力转回到[第2章](part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195)中的API控制器，“设置.NET测试环境”。直接从控制器返回硬编码的数据并不能为构建应用程序提供一个坚实的基础。大多数现代的任何规模的.NET应用程序都是用某种N层架构编写的。您会希望将您的业务逻辑与您的表示层分离，在这个例子中，就是API端点的表示层。
- en: We'll introduce an *interface* for a speaker service in preparation for using
    Dependency Injection to provide the concrete implementation to the controller,
    then verify that the proper method in the new service is being called. You'll
    need to rearrange some tests in order to remove the business logic from the controller.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引入一个演讲服务的*接口*，为使用依赖注入向控制器提供具体实现做准备，然后验证新服务中的正确方法是否被调用。您可能需要重新排列一些测试，以从控制器中移除业务逻辑。
- en: Presentation layer
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示层
- en: 'To get started, add a new test to verify that the controller accepts an *interface*
    of `ISpeakerService`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，添加一个新的测试来验证控制器是否接受`ISpeakerService`的*接口*：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, make your test pass by creating a constructor in the `SpeakerController`
    to accept the `ISpeakerService` interface, introducing a field variable and a
    constructor in your `speaker controller` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在`SpeakerController`中创建一个接受`ISpeakerService`接口的构造函数，引入一个字段变量和构造函数到你的`speaker
    controller`类中，来使测试通过：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Your test project should now fail to compile. This is because in our previous
    example from [Chapter 2](part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195),
    *Setting up the .NET Test Environment*, we''re defining the controller instance
    in the constructor of the test class. Modify the constructor to create an instance
    of `TestSpeakerService`, which implements the `ISpeakerService` interface, and
    pass this to the `SpeakerController`. Feel free to create the `TestSpeakerService`
    in your test class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试项目现在应该无法编译。这是因为在我们之前的例子中，从[第2章](part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195)，*设置.NET测试环境*，我们在测试类的构造函数中定义了控制器实例。修改构造函数以创建一个实现`ISpeakerService`接口的`TestSpeakerService`实例，并将其传递给`SpeakerController`。你可以在测试类中自由创建`TestSpeakerService`：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, you'll want to verify that the `Search` method of the `SpeakerService`
    is called from the controller. But, how do you do that? One way is to use a mocking
    framework called *Moq*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将想要验证`SpeakerService`的`Search`方法是否被控制器调用。但是，如何做到这一点呢？一种方法是通过一个名为*Moq*的模拟框架。
- en: Moq
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moq
- en: To add *Moq* to your unit test project, right-click on your test project and
    choose Manage NuGet Packages. Browse for *Moq,* and choose to install the latest
    stable version. We won't delve too deeply into *Moq*, but we will show how mocking
    frameworks help facilitate testing the boundaries of your application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要将*Moq*添加到你的单元测试项目中，右键单击你的测试项目，选择管理NuGet包。搜索*Moq*，并选择安装最新稳定版本。我们不会深入探讨*Moq*，但我们会展示模拟框架如何帮助促进对应用程序边界的测试。
- en: 'Add a test to verify that the `Search` method of the `SpeakerService` is called
    once from the `Search` action result of the controller:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个测试来验证`SpeakerService`的`Search`方法是否从控制器的`Search`动作结果中调用一次：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to make the test pass, you will also be required to do a little more
    setup in the constructor of the `test` class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，你还需要在`test`类的构造函数中进行一些额外的设置：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Be sure to modify the *interface* so that the application will compile:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确保修改*接口*，以便应用程序可以编译：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, make your test pass by ensuring the `Search` method of the `SpeakerService`
    is called from the `Search` action result of the controller. If you haven''t done
    so already, create a `field` variable for `_speakerService` that is assigned in
    the constructor by the `speakerService` parameter:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过确保从控制器的`Search`动作结果中调用`SpeakerService`的`Search`方法来使测试通过。如果你还没有这样做，创建一个名为`_speakerService`的`field`变量，并在构造函数中通过`speakerService`参数进行赋值：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, add a test to validate that the `searchString` supplied to the `Search`
    action result of the controller is the `searchString` being passed to the `Search`
    method of the `SpeakerService`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个测试来验证控制器`Search`动作结果提供的`searchString`与传递给`SpeakerService`的`Search`方法的`searchString`是否相同：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And make the test pass by supplying `searchString` to the `Search` method on
    the `_speakerService`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`_speakerService`的`Search`方法提供`searchString`来使测试通过：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, ensure that the results of the `Search` method from the `SpeakerService`
    are what is being returned by the action result:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，确保`SpeakerService`的`Search`方法的结果是动作结果返回的内容：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Remember, the results returned by the `Search` method of the `SpeakerService`
    are being defined by the `Mock`. You''ll need to extract a `field` in order to
    test that the results being returned by the *action result* are the same as those
    being defined for our `Mock`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`SpeakerService`的`Search`方法返回的结果是由`Mock`定义的。你需要提取一个`field`来测试返回给*动作结果*的结果与为我们的`Mock`定义的结果是否相同：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's still the problem of the hard-coded data. Don't forget to remove unnecessary
    and unneeded code while you're making your test pass. Remember *red, green, refactor*.
    This applies to your production code as well as your tests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然存在硬编码数据的问题。在使测试通过的同时，别忘了删除不必要的代码。记住*红、绿、重构*。这同样适用于你的生产代码以及测试代码。
- en: 'You may encounter some failing tests once you remove the hard-coded data. For
    now, skip these tests, as we''ll be moving this logic to another part of the application.
    Now it''s time to create a `SpeakerService`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在你删除硬编码数据后，可能会遇到一些失败的测试。目前，跳过这些测试，因为我们将会将这个逻辑移动到应用程序的另一个部分。现在，是时候创建一个`SpeakerService`了：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Business layer
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务层
- en: 'You might want to start thinking about how to organize your tests effectively.
    As your application grows, and the number of test files increases, you may find
    it more and more cumbersome to navigate your solution. One answer  might be to
    create individual folders per class under test and a single file per public method
    within the class folder. This might look something like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要开始考虑如何有效地组织你的测试。随着你的应用程序的增长，测试文件的数量增加，你可能会发现导航你的解决方案变得越来越繁琐。一个可能的解决方案是为每个待测试的类创建单独的文件夹，并在类文件夹中为每个公共方法创建一个单独的文件。这可能会看起来像这样：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You don't necessarily need to tackle this now, but it wouldn't hurt to have
    a plan for the future. Applications tend to grow quite quickly, and before you
    know it you will have thirteen projects within your solution. You may choose to
    go ahead and create a `Services` project with a `ServicesTest` project at this
    time, to separate your business layer and associated tests from your presentation
    layer and its tests. That will be left as an exercise for the reader.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不一定需要处理这个问题，但为未来制定一个计划不会有害。应用程序往往会迅速增长，在你意识到之前，你可能会在你的解决方案中拥有十三个项目。你现在可以选择创建一个`Services`项目，并在此同时创建一个`ServicesTest`项目，以将业务层及其相关测试与表示层及其测试分开。这将被留给读者作为练习。
- en: 'Now, create a new test class for the `SpeakerService`. Here is where you''ll
    be creating all of your test methods for `Search` in the `SpeakerService`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为`SpeakerService`创建一个新的测试类。这里是你将在`SpeakerService`中创建所有`Search`测试方法的地方：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once you make this test pass, create a few new tests to confirm the `Search`
    method exists and that it returns a collection of speakers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个测试通过，创建一些新的测试来确认`Search`方法存在并且返回一个演讲者集合：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, test that the `SpeakerService` implements the `ISpeakerService` interface:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，测试`SpeakerService`是否实现了`ISpeakerService`接口：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Your `SpeakerService` should now look something like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`SpeakerService`现在可能看起来像这样：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remember, take slow and methodical steps. You are not allowed to write a line
    of production code without writing a failing test, and you're not to write more
    production code than is sufficient to make the tests pass.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要慢而有序地进行。你不允许在不编写失败的测试的情况下编写任何生产代码，而且你不应该编写比使测试通过所必需的更多的生产代码。
- en: 'Now, begin to move the s*kipped* tests from the `controller test` file to the
    `Speaker Service Search Test` file. Start with `GivenExactMatchThenOneSpeakerInCollection`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始将`s*kipped*`测试从`controller test`文件移动到`Speaker Service Search Test`文件。从`GivenExactMatchThenOneSpeakerInCollection`开始：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make this test pass, then move on to `GivenCaseInsensitveMatchThenSpeakerInCollection`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让这个测试通过，然后继续到`GivenCaseInsensitveMatchThenSpeakerInCollection`：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And finally, `GivenNoMatchThenEmptyCollection` and `Given3MatchThenCollectionWith3Speakers`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GivenNoMatchThenEmptyCollection`和`Given3MatchThenCollectionWith3Speakers`：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you get more comfortable with the practice and gain more experience with
    TDD, you may find it helpful to list the tests which you want to implement. This
    could be simply jotting them down on a piece of paper, or stubbing out some skipped
    or ignored tests in your IDE.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对这个实践越来越熟悉，并且对TDD有更多的经验，你可能发现列出你想要实现的所有测试是有帮助的。这可以简单地是在一张纸上写下它们，或者在你的IDE中为跳过的或忽略的测试创建一些存根。
- en: 'If done correctly, your code should look something like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果做得正确，你的代码应该看起来像这样：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We’ve now moved the hard-coded data out of our controller and into our business
    layer in the `SpeakerService`. You may think that a lot of effort was expended
    simply to move the problem into a new file! While this is true to an extent, this
    actually puts us in a better place for future development. The "logic", such as
    it is, has been moved into a class that can be reused by other parts of the application,
    and by potential new interfaces (think native and/or mobile applications) that
    would not have access to our original controller.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将硬编码的数据从我们的控制器移到了`SpeakerService`的业务层。你可能认为我们付出了很多努力，仅仅是为了将问题移到一个新的文件！虽然这在一定程度上是正确的，但这实际上使我们处于更好的位置，以便于未来的开发。所谓的“逻辑”已经被移动到一个可以被应用程序的其他部分以及潜在的新接口（例如原生和/或移动应用程序）重用的类中，而这些接口无法访问我们的原始控制器。
- en: We'll continue with this example in future chapters. We will *finally* rid ourselves
    of hard-coded data and implement a data access layer using the Entity framework.
    All of this can be accomplished with Test-Driven Development.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的章节中继续这个例子。我们最终将摆脱硬编码的数据，并使用Entity框架实现数据访问层。所有这些都可以通过测试驱动开发来完成。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some pitfalls that will hinder TDD, such as dependence
    on third-party libraries, direct instantiation of classes, and fragile tests.
    We also discussed ways to avoid or work around those issues. We introduced and
    discussed each of the SOLID principles. We also discussed the different types
    of test double and when each type is appropriate. Lastly, we gave a short example
    of an N-tiered application and how it could be tested.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些会阻碍TDD的陷阱，例如对第三方库的依赖、直接实例化类以及脆弱的测试。我们还讨论了避免或解决这些问题的方法。我们介绍了并讨论了每个SOLID原则。我们还讨论了不同类型的测试替身以及何时使用每种类型。最后，我们给出了一个N层应用的简短示例以及如何对其进行测试。
- en: In [Chapter 5](part0183.html#5EGMU0-d186949d2da74f5c95dd1712efae1195), *Tabula
    Rasa – Approaching an Application with TDD in Mind*, we'll explore how to approach
    and application with a TDD in mind, turning theory into practice, and how better
    to grow an application through tests.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0183.html#5EGMU0-d186949d2da74f5c95dd1712efae1195)，“Tabula Rasa –
    Approaching an Application with TDD in Mind”，我们将探讨如何带着TDD（测试驱动开发）的思路去接近一个应用程序，将理论转化为实践，以及如何通过测试更好地发展应用程序。
