- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now You Know Some Patterns, What Next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the course of writing this book, I asked a few friends, colleagues, and
    at least one of my many archenemies for input. Invariably, they would ask about
    a pattern they had studied in school or used on a project wondering why it wasn’t
    included in this wonderful tome. The short answer to their question: the goal
    of the book is to focus on patterns that you can add quickly to your coding arsenal.
    Patterns that have a quick return on your investment of time and money.'
  prefs: []
  type: TYPE_NORMAL
- en: Many of the patterns I chose to omit are very similar to the ones I included
    in this book. The patterns that made the cut were strictly my own preferences.
    These patterns have proven the most useful to me during my 25 years of experience
    as a celebrated and award-winning software engineer using C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The GoF patterns we didn’t cover will be discussed very briefly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns outside of **object-oriented programming** (**OOP**). There are patterns
    that are not applicable to OOP—for example, patterns designed to describe database
    or network structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create your own patterns. The GoF book documents a format for creating
    your own patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that I am only using diagrams. There is no code for this chapter.
    Likewise, there aren’t any technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns we didn’t discuss
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I didn’t cover all 23 patterns in the GoF book. I only covered about half. A
    number of factors went into deciding what to include and what to leave for a tacit
    discussion in this chapter. Some of the patterns are more troublesome than they
    are worth. The **Memento pattern** solves a problem that can easily be solved
    with a few .NET features. Some patterns were not included because they are very
    similar to another pattern we covered. Some are patterns you are never likely
    to need. The **Interpreter pattern** is only useful if you are inventing a new
    programming language. This is rarely done anymore owing to the popularity of **domain-specific
    languages** (**DSLs**). Tools exist for the construction of DSLs that preclude
    the need for the Interpreter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the patterns from the original GoF book we didn’t cover in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of Responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template Method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll discuss each of these patterns at a high level in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making copies of objects can be tricky but if your object is flat, with no composition
    and just a few fields, it’s no problem at all. However, making a deep copy of
    a complicated object that was built using composition and inheritance—and it’s
    got a few layers of each—is harder. *Deep copying* refers to making an exact copy
    of an object from the highest level to the lowest level. The first step is to
    instantiate a new object from the same class. Then, you need to copy the values
    from all the properties and fields into the new object. You can only do this if
    every field or property in the object you want to copy is `public`. This includes
    all the objects used to compose the object you’re copying. Even if you manage
    to do this, the copy you create is subsequently of the dependent class used to
    make the copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at it another way. You’re beginning a project with the *Transylvanian
    Historical Society*. Your job is to copy, brick by brick, a castle owned by one
    Vlad von Dracula. The castle’s copy will be a museum in another town. There’s
    a catch: the castle’s drawbridge is up and you’re not allowed inside.'
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t hard to make a copy of the outside parts of the castle you can see,
    but it is impossible to duplicate the interior—especially that creepy crypt in
    the basement. That is, unless you had inside help. A man named Renfield offers
    his help. He has full knowledge of the castle’s interior because he never leaves
    its walls. If you can get Renfield to help you from the inside, making a copy
    of the castle isn’t going to be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype is a Creational pattern that enables you to copy an object brick by
    brick. It works by delegating the copy job to the object itself. In short, it’s
    an inside job. The copy operation itself is called **cloning**. An object capable
    of cloning itself is called a prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The Prototype pattern is used when you want to be able to make
    deep copies of an object. ](img/B18605_Figure_8.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The Prototype pattern is used when you want to be able to make
    deep copies of an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the Prototype pattern diagram by the numbers displayed on it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Prototype` interface defines the method that will perform the cloning operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ConcretePrototype` implements the Prototype interface and provides the
    implementation of the `Clone` method. If your object structure is complicated,
    this method is positioned to be able to see everything inside the object where
    it lives. This method might be refactored so that its name is *Renfield*. He’s
    the guy inside the castle who can help you clone it. The `Clone` method likewise
    can provide you with details needed to copy the object without losing any blood.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Prototype pattern can be very useful if you need a bunch of classes copied
    from a small set of objects defined by concrete subclasses. Think back to our
    bicycle factory. Let’s say there are half a dozen bicycle configurations that
    are very popular. Let’s further presume that Phoebe’s robots need a new instance
    of the `bicycle` object in order to manufacture a physical bicycle. In this case,
    a `bicycle` object is instantiated, the bicycle is manufactured, and the object
    is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: It would make sense in these circumstances to make a collection of “master copies”
    of the popular bicycle models and configurations. These masters could be cloned
    instead of the software needing to run an expensive builder method to generate
    a new bicycle conforming to a commonly ordered configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I keep two sets of wrenches in the back of my Jeep. One set is a common 3/8”
    mechanical ratchet set. One time I was driving home through Oklahoma from vacation
    in the Ozark mountain range. We had opted to take a scenic route by driving the
    back roads through a forested area of the state. We were cruising along, and I
    ran over a board in the middle of the road. It was unavoidable. I immediately
    switched my car’s display to the tires, and over the course of a few miles, I
    could see the pressure in one tire gradually decreasing. I had a nail in one of
    my tires. I pulled over at the first opportunity and found some level ground so
    that I could safely jack my car and change the tire.
  prefs: []
  type: TYPE_NORMAL
- en: My wife and two girls were with me. We had to take all the luggage out of the
    car to get to the jack. If you’ve ever tried to change a tire with factory-supplied
    tools, then you understand I was hot, frustrated, and stuck on the side of the
    road. A pickup truck pulled up behind us, and the driver, wearing a cowboy hat,
    jeans, and a t-shirt, offered to help us out. I could see an array of expensive
    power tools in the back of his truck. I accepted his offer. We loosened the tire’s
    lug nuts with his power wrench, and in minutes, we were back on the road. I vowed
    the first thing I’d do when I got home was to get me the same kit he had.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minute I brought my new power wrench home, I wanted to use it on more than
    just changing a tire. After all, flat tires don’t happen all the time. I wanted
    to use it with my other ratchet set. Unfortunately, the 3/8” sockets from my other
    set don’t work with the ½” power tool. If you’re not familiar with these tools,
    check out the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2:  My power impact wrench can only use the socket wrench sockets
    if I use an adapter. ](img/B18605_Figure_8.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2:  My power impact wrench can only use the socket wrench sockets if
    I use an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: The power wrench is like a normal wrench, except that the drive square is bigger
    on the power tool. The drive square is the part of the tool where you attach the
    sockets, which have a square hole in them. There’s no way a 3/8” socket can fit
    onto a ½” drive square. That is, it didn’t fit until I found an adapter. An adapter
    lets me use one interface—such as a 3/8” socket—with a different interface, such
    as the drive square of a ½” power socket tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Adapter pattern does the same thing for your classes. An adapter implementation
    allows two classes with different interfaces to be used together. If my wrench
    problem were expressed in **Unified Modeling Language** (**UML**), it might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: A class structure following the Adapter pattern is used to allow
    a class following one interface to work seamlessly with a different interface.
    ](img/B18605_Figure_8.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: A class structure following the Adapter pattern is used to allow
    a class following one interface to work seamlessly with a different interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break this down, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The power wrench is the client and we need a way to attach the smaller 3/8”
    sockets to the ½” drive square. To do this, we need an adapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The adapter should be described with an interface to prevent tight coupling.
    This interface calls for an `AttachSocket` method, which is implemented in the
    concrete adapter class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The concrete adapter class implements the interface and contains a method that
    accepts something from the client that can be adapted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ThreeEighthsInchSocket` class represents the incompatible interface you’d
    like to connect to your client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In short, the adapter implements the client interface—`ISocketWrenchAdapter`
    in this example. It also wraps the class with which we are interfacing—in this
    case, `ThreeEighthsInchSocket`. The adapter receives the drive square from the
    power tool when it calls the `AttachSocket` method in the adapter class. The internals
    of this method perform the logical operations needed to convert that input into
    something the adaptee can use. In software parlance, the client would be making
    a call to the adapter class. The method called would provide conversion logic
    that converts what was passed into the method so as to be compatible with the
    adaptee.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a very useful pattern when you need to leverage third-party or legacy
    with new work.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever had a thought that keeps you awake at night? Or maybe you have
    a thought that wakes you up? You’re sound asleep and then you awake with a jolt.
    Your half-slumbering brain just figured out what’s wrong with line 37.
  prefs: []
  type: TYPE_NORMAL
- en: Late one night in a fit of heuristic frenzy, Kitty wonders what would happen
    if one day, demand for Bumble Bikes exploded. What if the small company was inundated
    with thousands of orders? The robotic manufacturing system Phoebe built instantiates
    a bicycle object each time it builds a bicycle. Each bicycle object takes up space
    in the server’s **random-access memory** (**RAM**). Kitty decides to try a simulation
    using a development server. After a few load tests, she determines she can load
    1,000 instances of a bicycle object complete with the bridged painter system.
    Once the object count goes above 1,000 concurrent objects, the server starts to
    slow down. Once she reaches 2,000 objects in memory, the system nearly grinds
    to a halt and is unusable.
  prefs: []
  type: TYPE_NORMAL
- en: One obvious solution to this problem is to order more RAM for the server. Of
    course, this makes it a hardware problem. We are software developers. Maybe there
    is a way to solve this problem by strictly using software patterns. Maybe a small
    adjustment will prevent us from having to ask the pointy-haired boss for several
    thousand dollars in upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: The Flyweight pattern is used to move some of the shared elements of each object’s
    state into one shared object. Sometimes, you can shift a large amount of data
    out of memory and into one shared object. You see this anywhere you have a high
    object count. For example, if you use C# with Unity to develop game software,
    your game might have hundreds, or even thousands, of enemies. Maybe you’re leveraging
    a homemade particle system with thousands of shiny moving particles, or maybe
    you’re doing a factory simulation where thousands of bicycles are being manufactured
    by a small cadre of robots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: The Flyweight pattern entails shifting duplicated state variables
    into a separate object that can be shared to reduce memory footprint.  ](img/B18605_Figure_8.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: The Flyweight pattern entails shifting duplicated state variables
    into a separate object that can be shared to reduce memory footprint.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break it down by the numbers in the diagram, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have a `Bicycle` class with all its parts. For our simulation, we’re
    just going to make road bikes. The ordering system lets customers customize the
    bicycle frame with a special paint job, or pick from one of the standard colors.
    The seat can also be swapped out for one of several models. However, the rest
    of the properties offer no customization options. They will be the same for every
    road bike we build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, watch what happens if we shift the parts of the state that don’t vary into
    a separate class. Here, our `Bicycle` class only contains those properties that
    might be different between each bicycle we make.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The elements of state that are common for all objects are called the extrinsic
    state and are represented in the `BicycleFlyweightCommonState` class. It’s a bit
    of a mouthful, but I wanted to be sure you recognized which part was the flyweight.
    We can make one instance of this class and share it with all 1 million of the
    `Bicycle` classes in Phoebe’s simulation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s say the `Bicycle` class weighs in at 16 **kilobytes** (**KB**) of memory
    usage upon instantiation. If Phoebe wants to generate 1 million of them, that’s
    going to consume 16 **gigabytes** (**GB**) of memory. Once we shift the repeated
    state to the flyweight object, we chop out 14 KB for one object. Since we only
    instantiate it once, the memory footprint comprises only the intrinsic state.
    We instantiate 1 million bicycle objects at 2 KB, or total consumption is 2 GB
    plus the negligible 14 KB for a single instance of the extrinsic state in the
    flyweight class. That’s a nearly 8X reduction! I don’t know about you, but I would
    strut for a week if I could reduce my software’s memory footprint by 8X just by
    rearranging some classes!
  prefs: []
  type: TYPE_NORMAL
- en: Chain of Responsibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The success of Bumble Bikes isn’t owed entirely to Kitty’s designs nor Phoebe’s
    brilliant robotics. Bumble Bikes also has a focus on quality and **quality assurance**
    (**QA**) is completely automated. A system of cameras does a series of inspections
    using **artificial intelligence** (**AI**) via OpenCV. The inspection begins with
    the frame, then moves to the handlebars, the drivetrain components, the brakes,
    the wheels, the tires, and finally the seat. The logic used by the AI to perform
    the inspection is not contained in a single method. That would violate the **single-responsibility
    principle** (**SRP**). Instead, each inspection’s logic is encapsulated within
    a separate method for each inspection. The inspection happens sequentially, beginning
    with the frame. If any of the inspections fail, the bicycle is flagged as a defect
    and set aside for remediation performed by a human bicycle mechanic.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an overview of the QA checks in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Sequential quality assurance checks on a bicycle are one example
    of Chain of Responsibility.  ](img/B18605_Figure_8.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Sequential quality assurance checks on a bicycle are one example
    of Chain of Responsibility.'
  prefs: []
  type: TYPE_NORMAL
- en: This sequentially ordered set of inspections uses the Chain of Responsibility
    pattern. If any of the inspections fail, the remainder of the inspections is not
    run. This is how Toyota makes cars. If a defect is found on the assembly line,
    everything stops until the problem is corrected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern itself takes on the form seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: The Chain of Responsibility pattern is used anytime you need
    a stateful sequence of events.  ](img/B18605_Figure_8.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: The Chain of Responsibility pattern is used anytime you need a
    stateful sequence of events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break it down, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An interface, usually called `IHandler`, defines two methods. The `Handle` method
    defines the method signature for the implementation of the inspection logic. The
    `Next` method allows us to move to the next inspection, assuming the current step
    passes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An abstract handler class defines the next handler, which is a common property
    among the concrete classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The concrete classes inherit from `Handler` and implement their inspection logic
    with the `Handle` method, which overrides the base class method. Similarly, the
    `Next` method overrides the base and is used to pass the torch on to the next
    runner or, in our case, pass the current inspection and move to the next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flowchart logic has been around since the Turing machine. It should come as
    no surprise there is a pattern to encapsulate this universal concept.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One day, Kitty and Phoebe get a call from Dr. Eloise Swanson. Dr. Swanson has
    started a new business called *U.S. Robots and Mechanical Men*. Her company’s
    newest product is a high-end **software development kit** (**SDK**) for robotic
    control. Dr. Swanson had studied Phoebe’s designs while in graduate school at
    the **Massachusetts Institute of Technology** (**MIT**) and thought Bumble Bikes
    would make a good partner for beta testing.
  prefs: []
  type: TYPE_NORMAL
- en: The SDK was very effective and easy to use. However, it wasn’t a drop-in replacement
    for the software Kitty and Phoebe had written. First, there’s no way an SDK can
    fully replace custom-tailored software for any business. The second problem was
    bloat because the SDK was designed to work with any robotic system. A great deal
    of code was used to account for every possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Kitty and Phoebe found that the SDK was a good fit to control their painting
    robots. However, it was only needed when a custom paint job was ordered that had
    never done before. Once a paint job was performed, it was cataloged and the color
    formula could be reused. The SDK from *U.S. Robots* made much shorter work of
    the paint jobs, at the cost of slow initialization and a large memory footprint.
    If the girls were to couple their code to the SDK, which of course they wouldn’t,
    all their work would be slowed down by an expensive initialization process they
    would rarely use.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to lazy load the SDK objects only when they are needed. The
    P roxy pattern allows you to define and use a placeholder for an object. The proxy
    could then load the big, slow SDK classes only when they were needed. The rest
    of the production process would remain unhampered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the structure of the Proxy pattern in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: The Proxy pattern can substitute a simple object for a more complicated
    one until the complicated one is actually needed.  ](img/B18605_Figure_8.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: The Proxy pattern can substitute a simple object for a more complicated
    one until the complicated one is actually needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Breaking it down will help us understand further, so we’ll do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: We have this SDK from a third-party vendor. We know tightly coupling to a third-party
    vendor’s SDK is a bad idea in the first place. In this case, the SDK has a method
    we want to use, but its containing class has a big, slow constructor, and the
    object is rarely used. We need a way to lazily load this object only when it is
    needed while also preventing a tight coupling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create an interface to prevent tight coupling. Our client software can require
    the interface, and any changes in the future are fine as long as we can keep the
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create a wrapper that holds the SDK instance. The wrapper holds an
    instance of `BigSlowButVeryUsefulPaintService`, which might take several minutes
    to instantiate. That’s a long time, considering we only need one method. Our wrapper
    instantiates `BigSlowButVeryUsefulPaintService`, then calls the expensive `InitializeSystem`
    method only when it is really needed. Since we bore the instantiation cost, we
    can store the instance in a private property and use it again if the need arises.
    That might sound like a singleton, but singletons ensure only one instance is
    ever created. Here, we are just reusing what we have already made, which isn’t
    quite the same thing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, usese the Proxy pattern anytime you need a placeholder for a third-party,
    legacy, or overly expensive object. This will to prevent tight coupling and defer
    expensive operations that might happen on instantiation for when they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Interpreter pattern is one you will likely never need. This pattern is used
    when you have a custom language you need to interpret that can be expressed using
    **abstract syntax trees** (**ASTs**). With the rise in popularity of **domain-specific
    languages** (**DSLs**), entire toolkits, such as JetBrains Meta Programming System
    and Visual Studio Enterprise’s Modeling SDK, make creating a custom language interpreter
    a relatively simple project.
  prefs: []
  type: TYPE_NORMAL
- en: Since DSLs are well beyond the scope of a book on patterns, I will list a reference
    to the DSL tools I’ve mentioned here in the *Further reading* section at the end
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It isn’t difficult to imagine a future for Bumble Bikes where their automated
    manufacturing system might expand and become more complex. Right now, we have
    the Builder pattern controlling the robotics that build bicycles and wheelchairs.
    There are two physical factories, and each factory specializes in just a few products.
    All that could change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: I worked for an aircraft manufacturer on a joint venture with another aircraft
    manufacturer. Our company made the powerplant (engine) and assembled the final
    aircraft. The partner company built the body of the aircraft. Other partner companies
    supplied avionics, which are the electronic flight-control systems present in
    modern aircraft. Another company still manufactures military components that I’m
    not allowed to talk about.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if Bumble Bikes had a slew of manufacturing operations like that. Even
    if they were all collocated in one plant, the level of signal communications between
    all the different robotic manufacturing systems could become very chaotic. If
    each system were to communicate with all the other systems directly, we’d very
    quickly find ourselves in trouble.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever created a large web application using HTML and JavaScript, you
    have run into a similar problem. You have dozens of different pieces of code modifying
    the **Document Object Model** (**DOM**) in response to potentially hundreds of
    signals emanating from user interactions, timers, **Representational State Transfer**
    (**REST**) **application programming interface** (**API**) calls, third-party
    SDKs such as jQuery, and third-party advertising sites injecting code into your
    site for monetization. When a system such as this reaches critical mass in terms
    of signal complexity, it becomes slow and nearly impossible to debug and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider one more example: a natural disaster such as a hurricane or
    tornado. What if all the **first responders** (**FRs**) were able to contact each
    other directly? Every firefighter could radio every policeman, who could radio
    every **emergency medical service** (**EMS**) unit. The EMS responders could talk
    directly to triage nurses and Red Cross volunteers. All this happens on one big
    open communication channel. What are your odds of surviving a disaster in this
    environment? Open direct communications can sometimes be a good thing, but I think
    we all realize it doesn’t scale. Now, imagine hundreds of objects in a piece of
    software that all have direct access to all the other objects on the stack. You
    see the problem, right?'
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s needed in all these circumstances is some form of dispatcher: a central
    hub for communications. The Mediator pattern embodies this role. A mediator acts
    as a central hub for all communications and routes requests to the objects that
    need them in a controlled manner. Let’s examine the diagram shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: The Mediator pattern involves a single centralized object that
    directs calls between objects. ](img/B18605_Figure_8.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: The Mediator pattern involves a single centralized object that
    directs calls between objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the numbers in the diagram, it works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a base class for the colleague objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have a bunch of colleague objects that need a centralized way to communicate.
    Here, I just have four, which is probably no cause to run to the Mediator pattern.
    But imagine 400 objects all communicating directly with each other! Like I said
    before, direct communications don’t scale!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make an interface called `IMediator`, which sounds cool when you say it out
    loud. This, as usual, prevents tight coupling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now for the good part. A central object based on the `IMediator` interface contains
    instances of all the objects and has defined communications channels between them
    in the form of methods that I called `ReactWithX`, where X is the number corresponding
    with the object sending the signal. `ReactWith1` calls an appropriate method on
    `Colleague1`, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This pattern is designed to simplify the communications process, but it usually
    results in a very large object with lots of internalized component instances and
    methods for communicating. You have to weigh the complexity of the `Mediator`
    class against the benefits of the centralization it offers. On the one hand, as
    a developer, it’s nice to have one class where you can drop a breakpoint in your
    IDE. Like a lion scoping out the local watering hole, eventually, all message
    traffic passes through this one class, making it simpler to find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: On the downside, the class itself can become unwieldy.
  prefs: []
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever saved a game or used undo in your favorite editor? If so, then
    you’ve likely interacted with the Memento pattern. The best analogy for a memento
    is a cool but outdated technology. When I was in grade school, the hottest camera
    was called a Polaroid. Most cameras back then involved a roll of film. You would
    shoot your pictures on the camera, then take the film to a drug store to be developed.
    It took about a week to get your pictures back. However, with a Polaroid, you
    could take your pictures, which were ejected from the camera and self-developed
    within a few minutes. The development process seemed to go a little faster if
    you shook the picture, which gave rise to a popular song lyric, and accompanying
    dance move, “Shake it like a Polaroid picture”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back then, we called these pictures *snapshots*. This term is used today in
    conjunction with the Memento pattern. A snapshot, like a Polaroid picture, is
    a representation of an event or place at a particular point in time. So it is
    with software as well: a snapshot represents the state of an object at a point
    in time. Like a photo, a software snapshot can be saved as a memento—something
    to remind you of that one time when your object was in that state.'
  prefs: []
  type: TYPE_NORMAL
- en: Text editors such as your IDE or Microsoft Word are constantly tracking the
    state of your documents and saving mementos as you type. When you hit *Ctrl*/*Command
    + Z* on your keyboard, you can go back sequentially to earlier and earlier mementos.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this seems easy. All you’d need to do is create a `List<>`
    object to hold, say, the last 100 state changes your user has made. Maybe you
    store a memento every 30 seconds or so. That’s easy. It’s that easy only if every
    object in your state and every object used in inheritance and composition has
    100% public properties. If the entire state is public, you wouldn’t need a pattern
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real impediment here is the same one we encountered with the Prototype
    pattern earlier. We were trying to copy Count Dracula’s castle, but we weren’t
    allowed inside the front gate. Making a shallow copy of the outside of the castle
    is straightforward, to make a full copy of the whole castle requires an inside
    actor. This is equally true in the Memento pattern. In the memento’s case, the
    inside actor is a nested class. The nested class has access to the outer class’s
    state and can store our suggested `List<>` object containing our undo history.
    Let’s look at the diagram shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9: The Memento pattern. ](img/B18605_Figure_8.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: The Memento pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the most familiar example is a text editor, I used that for the diagram.
    Let’s review the numbered parts of the diagram, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This class represents the `DocumentEditor` class, which is our client. The memento
    pattern calls this the originator since this is where the stored state comes from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the editor needs to save an undo state—or, for that matter, a file—it
    can use the `Memento` class for storage. Note that all the internals are private.
    The `Memento` class is nested inside the originator; it is defined *inside* the
    `DocumentEditor` class as a nested class. Besides being locked down, you should
    consider `Memento` classes immutable: once you create them, you should never change
    them. The private properties are set via the constructor and subsequently never
    modified. This means when you implement, there should not be any setter accessor
    methods for these properties.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There isn’t a standard way to draw internal classes in UML, so I put the `Caretaker`
    class outside the dashed box as a visual clue that there’s something different
    about this class. Remember, `Memento` is inside the `DocumentEditor`, and not
    via composition. The `Caretaker` class, in turn, contains the `DocumentEditor`
    object inside the `Originator` field. The `Caretaker` class, then is responsible
    for creating and restoring mementos, as well as the undo history.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Memento pattern can be difficult to get right, and you might go a long way
    in your career without needing it. Even if you land a job at a company that makes
    a document editor, chances are you’ll be using one of the many excellent third-party
    **user interface** (**UI**) controls, such as those from Telerik, that have already
    implemented this for you.
  prefs: []
  type: TYPE_NORMAL
- en: The other point worth mentioning is that you can achieve a nearly identical
    effect using C#’s serialization libraries. Usually, saving the application state
    also entails persistence. Good editors let you undo the last 100 changes. Great
    editors let you do that between editing sessions. You can turn off your laptop,
    fly across the world, boot back up, and your undo history is still available because
    it’s serialized (saved) to a file somewhere on your hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Framework gives us a slew of serialization options, including `System.Runtime.Serialization`,
    `System.Runtime.Serialization.Json`, and `System.Text.Json.Serialization`. Each
    contains a set of classes designed to make serializing your objects to files fairly
    trivial. However, you’ll still have problems with private properties. Thankfully,
    Microsoft has supplied us with the `DataContractSerializer` class that helps you
    get around this limitation without resorting to an intricate class structure or
    worrying about the memento’s immutability.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ll confess looking back at the last eight chapters, I probably should have
    covered this pattern. You’ll use it, especially if you work in game development
    with Unity 3D. If you’re not familiar with this tool kit, it’s essentially a game
    engine capable of creating AAA games for consoles, PC, Mac, mobile, and the web.
    I taught game development with Unity for many years at a local college and so
    I have a soft spot for it, despite never having worked as a professional game
    developer. The Unity 3D game engine uses a finite state machine to control the
    animation of your game characters. It uses a visual editor to define the states
    and the animation to use when the game character’s state changes.
  prefs: []
  type: TYPE_NORMAL
- en: The State pattern entails changing an object’s behavior based on changes to
    its internal state. An object’s state is conceptually just the values of all its
    properties at a point in time. If you make a game where you run around the countryside
    fighting zombies, you might define your zombies with different behaviors. Most
    of the time, they’re just shambling around randomly looking for fresh BRAINS!
  prefs: []
  type: TYPE_NORMAL
- en: When something with a brain comes into view, the zombie’s behavior changes.
    It shambles towards the brain-toting organism while hissing “BRAINS!” over and
    over. Once the zombie is within arm’s reach, its behavior changes again. The zombie
    attacks!
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one object with three behaviors, all controlled by the internal state.
    When we put the behaviors and states together, we form what’s called a finite-state
    machine. It is finite because zombies have a finite number of behaviors. In this
    case, the number is 3\. The finite state machine can be diagrammed as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: A finite state machine representing zombie behavior in a video
    game.  ](img/B18605_Figure_8.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: A finite state machine representing zombie behavior in a video
    game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This state diagram shows the transitions between the different states. The
    zombie can’t randomly attack a victim that is too far away. It has to see the
    victim and close the distance first. A diagram of the pattern appears here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: The State pattern.  ](img/B18605_Figure_8.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: The State pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break it down, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IState` interface defines the behaviors that are possible. Our zombie can
    patrol, close distance to a visible victim, and attack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Context` class holds a reference to an object implementing the `IState`
    interface, which is used to communicate with concrete state objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Concrete state objects contain state-specific methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The context object can be used to change the state by swapping concrete state
    objects held in the private state property. This means the context can enforce
    any logic for state transitions.
  prefs: []
  type: TYPE_NORMAL
- en: I didn’t include the State pattern earlier because it is very similar to the
    Strategy pattern covered in [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089). Kitty
    and Phoebe used the Strategy pattern to create a navigation system for bicycles.
    The behavior of the system changed depending on what type of terrain the user
    requested.
  prefs: []
  type: TYPE_NORMAL
- en: Template Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Template Method pattern is very similar to the Strategy pattern, which we
    covered in [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089). This is a behavioral
    pattern that allows you to define the structure of an algorithm but defer the
    implementation to subclasses that override the actual logic but not the structure.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089), Phoebe designed a navigational
    computer for bicycles. It used the Strategy pattern to compute navigational routes
    depending on whether the rider wanted a route via paved roads, unpaved gravel
    roads, or extreme terrain. We could have done the same thing with the Template
    Method pattern, which is why I didn’t feel the need to cover both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13: The Template pattern.  ](img/B18605_Figure_8.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: The Template pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the numbered parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The abstract template class defines the structure of a class that forms an algorithm.
    The steps to the algorithm are defined as abstract and can be overridden by a
    concrete implementation in a child class. The steps, however, are called in a
    method within the template class. In my example, I called it `ExecuteTemplate()`,
    which is not overridden. `ExecuteTemplate()` calls the steps in order, and this
    never changes. The template defines overrideable logic, but the structure is consistent
    each time the template is used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the concrete classes that override the algorithm steps. Note the `AlgoImplementationA`
    class overrides all the steps in the parent class. The `AlgoImplementationB` class
    just overrides a few.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This pattern allows you to make very flexible algorithm implementations using
    nothing more than common household inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Visitor pattern is another Behavioral pattern designed to help you “bolt
    on” new behaviors to existing objects. Its motivations are focused on SOLID principles
    (head back to [*Chapter 2*](B18605_02.xhtml#_idTextAnchor036) if you need an explanation
    of this acronym). The open-closed principle is honored because you are adding
    behavior without modifying existing classes. The SRP is honored because usually,
    the behavior you are adding is new and may have little to nothing to do with the
    purpose of the original class.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind the name comes from the idea that an object encapsulating new
    behavior can visit an existing, established class, allowing it to perform the
    new behavior. You’re literally teaching an old dog object new tricks.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a world where your body has an ability slot. You can slot in a new behavior
    as easily as slotting a memory card into a camera. Need to learn to fly a helicopter
    to escape evil secret agents? Slot the card with flight training and you can instantly
    fly any civilian or military aircraft! Do you need to cook like a 5-star chef?
    Slot a card with cooking skills and you’ll be able to defeat Gordon Ramsay or
    Bobby Flay in any cooking competition! Do you need moves at the nightclub? Slot
    a card with nightclub skills and you’ll dance the night away! Just be careful
    with that last one. There’s no telling what other skills might be on the card.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s shake that last example off and look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14: The Visitor pattern. ](img/B18605_Figure_8.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: The Visitor pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break it down, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our `Visitor` interface defines a set of methods required to implement a new
    superpower you wish to confer on an existing object graph. We’re fortunate that
    C# supports method overloading. Method overloading refers to a language’s ability
    to reuse method names as long as the method signature is different. If you’re
    not sure what this means, check out [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178)
    at the end of this book. We cover it there. Not every OOP language supports this
    capability, but C# does. Our interface defines several methods with the same name
    but with different argument types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A second interface called the `Element` interface defines how visitors are accepted.
    If you want new abilities in our future world, you’ll have to get a slot added
    to your skull so that we have someplace to insert our ability cards. Likewise,
    your class will need an additional method based on this interface. You don’t need
    to change any existing methods or logic in the class. You just need to add a method
    to accept visitors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Concrete visitor classes implement our interface and provide the new behavioral
    logic. Note that we did not use the `IElement` interface as the argument type.
    The concrete object type passed in determines which method is run based on method
    overloading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are your existing classes implementing the `Element` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A few things come to mind when I think of the Visitor pattern in C#. First,
    it feels a lot like the Decorator pattern, but with a focus on object graphs instead
    of individual classes. Maybe that’s just me?
  prefs: []
  type: TYPE_NORMAL
- en: Another similar pattern is the Composite pattern covered in [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089),
    and again in *Chapters 7* and *8*. Kitty and Phoebe used the Composite pattern
    to perform a set of calculations for weight and cost on a graph of objects used
    to comprise a bicycle drivetrain. Tom improved the design by weaving the Composite
    pattern into the object graph at design time. The difference is that the Composite
    pattern operates from outside the objects in the graph whereas the Visitor pattern
    is inserting new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the first time I read about the Visitor pattern, I immediately thought
    of extension methods. Extension methods are unique to C#. They allow you to add
    behaviors to existing classes using a separate class file. They are not an implementation
    of the Visitor pattern, but if your needs are simple, you might want to start
    with extension methods. If extension methods come up short, then try the more
    complex Visitor pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns beyond the realm of OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The field of OOP was really just the start. There are patterns beyond the realm
    of OOP that you have very likely heard of, but perhaps didn’t know were codified
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Software architecture patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An obvious area for finding more patterns is within the domain of software architecture.
    It may seem like we’ve been talking about software architecture this whole time.
    We have. However, software architecture isn’t bound to OOP. Every pattern in this
    book relies on using C# because it is an OOP language. Software architecture patterns
    span every language and really help us define systems, not just enhance the structure
    of our code. Let’s look at some examples you have probably heard of before now.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We actually covered this one—we just didn’t call it out as a pattern. This pattern
    involves **peer-to-peer** (**P2P**) architecture consisting of a server, and usually
    many clients. The clients make requests to the server and do something with the
    result. This is pretty much how the internet works.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Microservices pattern entails breaking large, monolithic applications into
    small, self-contained but interdependent services. The idea is to take the SRP
    to its ultimate implementation. Imagine a REST API with a handful of endpoints
    that together serve only one purpose such as password reset. Instead of password
    reset being built into a bigger API that does dozens of other things, the password
    reset becomes a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that it is easier to maintain tiny single-purpose APIs. The trade-off
    comes from the latency introduced between interdependent system calls and the
    resulting complexity of your network topology.
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC) pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Surely you’ve heard of this one! You see it in web applications when you split
    the application code into three layers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A model layer that contains code that represents the data model, usually via
    an **object-relational mapper** (**ORM**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view layer that represents the **user experience** (**UX**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A controller layer that represents the logic needed to accept requests from
    the view and process data returned from the model layer. This configuration embodies
    the ideals behind the **separation of concerns** (**SoC**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish-subscribe (pub-sub) pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another popular pattern you’ll see in many guises. Sometimes you’ll
    see object-level implementations such as what we saw in the Observer pattern covered
    in [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089). You’ll also see higher-level
    architectural implementations in software such as Redis, RabbitMQ, and Apache
    Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: In every case, the idea is to allow communication from a central source. Messages
    are sent to a publisher who in turn publishes the messages to relevant subscribers.
    This is vital to distributed architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Command Query Responsibility Segregation (CQRS) pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pattern is meant to solve the situation that arises when database queries
    for data occur far more frequently than database updates. If you have a reporting
    system where reports are generated but rarely subsequently modified, this is a
    good pattern to learn. Its solution generally entails segregating data that rarely
    changes but is commonly queried into a separate database called a data warehouse.
    This can boost performance on reads and writes because the responsibilities are
    segregated. The trade-off comes from the implementation cost, which often involves
    standing up a separate database server to handle the segregated loads.
  prefs: []
  type: TYPE_NORMAL
- en: Data access patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data access patterns occur wherever you have traditional code interacting with
    a relational, or even non-relational, database. Since relational databases have
    been around since 1970 and are largely unchanged and completely ubiquitous, it
    shouldn’t be surprising that they have their own set of patterns. I cut my teeth
    with a book by Clifton Nock titled *Data Access Patterns: Database Interactions
    in Object-Oriented Applications*. I’ll list the book’s details in the *Further
    reading* section at the end of the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Here are just a few patterns from that book you’ll probably recognize.
  prefs: []
  type: TYPE_NORMAL
- en: ORM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ever heard of **Entity Framework** (**EF**)? As a C# developer, you’d have to
    have lived beneath some sort of highly academic rock to have never heard of Microsoft’s
    flagship ORM. An ORM’s job is to map data between relational structures in **Structured
    Query Language** (**SQL**) databases such as SQL Server to objects in C#. If a
    pattern is a solution to a problem that occurs frequently, this might be the most
    important pattern in software development.
  prefs: []
  type: TYPE_NORMAL
- en: Implementations of this pattern, usually encapsulated in a third-party library,
    or in our case, within the .NET Framework, allow developers to work solely with
    C# objects. With an ORM, you never need to create or update table structures in
    your application’s database. You never need to figure out complicated joins or
    concatenate long SQL statements in your code. You create a set of objects that
    represent your database structure. You then query those model classes and work
    with data operations to manipulate your database.
  prefs: []
  type: TYPE_NORMAL
- en: The upside is if you don’t know—or don’t like—SQL, you never need to work with
    it directly. The trade-off is in application performance. EF code is known to
    run significantly slower at scale than direct connections to the database. It
    also adds one more layer of dependencies to your application. It’s just one more
    thing that can go wrong. If you’re sensing I’m not a fan, you’d be right. I like
    ORMs for small projects with a limited number of users. For example, if you’re
    making an app for internal use and you have limited time to create it, using an
    ORM might help you get the job done more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: If on the other hand you are making an application for a large user base, eschewing
    the convenience of an ORM in favor of implementing our next pattern directly gives
    you tremendous control over performance by allowing you to leverage the full capabilities
    of your database software.
  prefs: []
  type: TYPE_NORMAL
- en: Active Domain Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Active Domain Object** (**ADO**) pattern is a fun one because when you
    see ADO, you probably think of either Microsoft’s **ActiveX Data Objects** (**ADO**)
    or ADO’s older cousin **Data Access Object** (**DAO**). Then again, that might
    only be if you’re over 35 years old. It’s been a good while since those technologies
    were front and center.
  prefs: []
  type: TYPE_NORMAL
- en: The ADO pattern encapsulates data access and relevant object implementations.
    Their aim is to remove any direct interaction with the database outside the pattern
    implementation. Sound familiar? That’s pretty much what Microsoft ADO and DAO
    were designed to do. I doubt this is a coincidence.
  prefs: []
  type: TYPE_NORMAL
- en: Most developers don’t use this pattern, having generally moved to working with
    ORMs such as EF. However, if you have SQL skills, you can often make a more performant
    application by accessing the database directly via native drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Demand cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My wife and kids do this all the time. Just kidding, but not really. There are
    quite a few cache patterns. A demand cache is embodied by a cache that is populated
    lazily “on demand”. The main force at play here is you don’t know when the data
    will be needed, but you would like to only pay the price of retrieving the data
    once.
  prefs: []
  type: TYPE_NORMAL
- en: My application includes a demand cache as part of a web application. Some of
    the queries in my application return large recordsets or include considerable
    processing that can take several seconds to complete. That doesn’t sound bad,
    but for a web application, it is an eternity. My demand cache method checks the
    cache (which in my case is Redis) first when data is requested. If it’s there,
    the data is served from the cache. If it isn’t there, I retrieve and cache it.
    The first customer to request the data pays the performance penalty, but every
    customer after that gets the data very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another ubiquitous data processing term that is really a pattern. In
    database lingo, a transaction refers to multiple SQL statements that must be completed
    as a unit. For example, if you have an automatic teller machine and you want to
    withdraw money from one account and add it to another, you need this to occur
    as one unit of work—a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: You withdraw $100 from account A and add $100 to account B. If either SQL statement
    fails, you need to consider the whole transaction a failure and roll back all
    the changes entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Optimistic and pessimistic lock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nothing drives application developers crazier than dealing with locks in the
    database. An optimistic lock takes place in order to prevent missing database
    updates. You find this pattern used in **inventory management systems** (**IMSs**)
    where up-to-the-second, on-hand stock data is vital to selling that inventory.
    Last weekend, I bought a new clothes dryer at a popular store. My wife picked
    out the perfect dryer and the sign above the dryer said, “Order now and you’ll
    receive it in 3 days”. The salesman went to enter the order and found the units
    were not only out of stock, but the manufacturer wasn’t accepting back orders.
  prefs: []
  type: TYPE_NORMAL
- en: The sign assumed stock at the warehouse and was based on stale information.
    Now, replace the sign with a database query. The sales application queries to
    see if any dryers are in stock. At the exact same moment, at a store across town,
    someone else has just purchased the same model of dryer.
  prefs: []
  type: TYPE_NORMAL
- en: How can the clerk at the first store know whether there really is a dryer available?
    The optimistic lock pattern entails creating a version number on each row in a
    database table. The database in this scenario will optimistically assume the dryer
    is available if the row version number hasn’t changed since the transaction started
    and doesn’t lock the database row for update.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, in the same scenario, a pessimistic lock will prevent the clerk’s
    sale from going through if the second clerk’s transaction was in the middle of
    updating the inventory row data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you think you have an idea for your own design pattern? The GoF book presents
    a boilerplate documentation framework for publishing your own patterns. I won’t
    duplicate it fully here, but I will outline it for you. It involves four essential
    elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Name and classification
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The problem description
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The solution description
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consequences of using the pattern
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s talk a little about each section.
  prefs: []
  type: TYPE_NORMAL
- en: Name and classification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every pattern needs a name that describes the pattern. Most of the patterns
    out there have names that make you think of general words from normal language.
    The word *memento* refers to a physical object that invokes memories of times
    past. The word *singleton* invokes the idea there’s a single thing. Come up with
    a short, memorable name that invokes the idea behind the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need a classification. In this book, we observed the three classifications
    in the GoF book: Creational patterns, Structural patterns, and Behavioral patterns.
    You saw in the previous sections that other knowledge domains that use patterns
    have their own lists of classifications. Maybe your pattern fits into an existing
    classification. If not, you’ll need to invent a new classification.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible your pattern might have an alias; an “**also known as**”
    (**AKA**) name. The Decorator pattern is also known as a wrapper. Document any
    aliases for your pattern if any exist.
  prefs: []
  type: TYPE_NORMAL
- en: The problem description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section of your documentation describes the problem your pattern aims
    to solve. When the GoF describe the problem, they break it into several smaller
    sections, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Intent* refers to the overall goal of your pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Motivation*/*Forces* outlines why someone would use your pattern. This is
    deeper than “because it’s cool” or because it solves a particular problem. When
    we discussed antipatterns in the first chapter, we described a set of forces that
    caused the antipattern to come into being. In this section, we’re looking for
    similar driving factors around why your new pattern is relevant and useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applicability* lists the context for the pattern. Make a short list of situations
    where the pattern is useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it isn’t necessary to fill in every single niche, you’ll recognize elements
    we’ve used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The solution description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When describing the solution, you need to describe the elements used to construct
    the design. Expound on the relationships between the elements. Describe how the
    elements collaborate, and make sure to explain the responsibilities of each element.
    You might consider breaking this section into smaller chunks as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Participants* list classes, objects, interfaces, enumerations, and so on that
    participate in the pattern solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Collaboration* describes how the participants collaborate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Structure* will contain UML diagrams of a generic form of the pattern, and
    perhaps a diagram of a more real-life concrete use case. This is the format I
    have used in every pattern I covered in this book. I find the generic diagrams
    less useful by themselves. If a concrete example follows, developers can look
    at both diagrams and more easily relate them to their work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementation* contains a description of how to implement the pattern. In
    this book, I’ve used numbered diagrams to describe how the pieces fit together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sample Code* or *Pseudocode* mostly speaks for itself. I would recommend real-world
    examples instead of class A inheriting from class B, which uses class C in composition.
    That’s too abstract. If you want people to use your pattern, find ways to make
    it relevant to their work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consequences of using the pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should always discuss the positive outcomes and trade-offs that come with
    using your pattern. Most patterns have defenders and detractors. If you read up
    on patterns on the internet, you’ll see a healthy debate about how some patterns
    might be antipatterns. We presented such a case when we discussed the Singleton
    pattern in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063). The more complex a
    pattern, the more likely it is to have trade-offs. The Template Method pattern
    is extremely simple. I doubt whoever came up with that one lost any sleep over
    thinking about possible negative outcomes. In contrast, the Façade pattern presented
    in [*Chapter 4*](B18605_04.xhtml#_idTextAnchor078)presents a trade-off between
    the complexity of the third-party framework and ease of use for developers that
    don’t need everything the third-party framework exposes.
  prefs: []
  type: TYPE_NORMAL
- en: Not everybody likes patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We demonstrated in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)’s coverage
    of the Singleton pattern that not everybody agrees that patterns are a positive
    contribution to the field of software development. The usual argument is design
    patterns are simply workarounds for incapable, inefficient, or incomplete OOP
    languages. Academic literature has shown as many as 17 of the 23 patterns within
    the GoF book become unnecessary when you use languages such as **List Processing**
    (**LISP**) or Dylan. What? Who even uses those?
  prefs: []
  type: TYPE_NORMAL
- en: Another group of academic detractors advocates switching your paradigm from
    OOP to **aspect-oriented programming** (**AOP**) as a solution to all your problems.
    As you’re hopefully aware, OOP aims to solve problems by modeling things in the
    real world. AOP aims to model behavior as crosscutting concerns. AOP is not supposed
    to be a competitor with OOP, yet some arguments place it that way.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is there will always be a debate that says “If you would only
    switch to language X, framework Y, or paradigm Z, all your pattern problems will
    be solved!” My retort to that is to remind you to beware of the Golden Hammer!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Patterns are everywhere. There is a field called biomimicry that aims to study
    technology inspired by patterns in nature. It’s difficult to talk about software
    development anymore without bringing up **artificial intelligence** (**AI**),
    whose main job is to find patterns in massive amounts of data using techniques
    called **machine learning** (**ML**). The software industry has been humming along
    now since 1843 when Ada Lovelace wrote what most consider to be the first computer
    program. In that time, we have collectively run into the same challenges and frustrations
    over and over again. Eventually, we got smart enough to start writing things down
    and talking about them.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been learning patterns, which at their core are really just a way of communicating
    our best ideas as they relate to organizing and optimizing our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we briefly covered the patterns from the original GoF book
    that we didn’t cover in the earlier chapters as part of this book’s story. I left
    these patterns out for one or two reasons in each case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If a pattern was remarkably similar to another pattern already covered, I didn’t
    cover it. The State pattern is very similar to the Strategy pattern. The Strategy
    pattern fit my story, so that’s the one I used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a pattern was very complicated and rarely used, I didn’t cover it. The Memento
    pattern is a good example. There are easier ways to handle the use case of representing
    snapshots of objects such as .NET’s serialization features that negate the need
    for a complicated Memento pattern implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We went beyond GoF patterns, and even beyond OOP patterns to list some common
    and highly familiar patterns in other domains of software and database architecture.
    We concluded with a synopsis of how you might go about documenting your own patterns
    should you ever discover a new one. I left you in this chapter with a final warning.
    You’re going to be tempted to close this book and run through the office like
    a crazy person yelling “PATTERNS!” everywhere you go. Don’t laugh. I’ve seen it
    happen. If you do this, expect some eye rolls. Not everybody thinks patterns are
    a good idea, and sometimes they are right. Patterns themselves can easily succumb
    to the Golden Hammer antipattern. Remember—patterns are here to simplify and improve
    your software. If they make things slower or more complicated, you must abandon
    them in those cases. Patterns are tools, not dogma.
  prefs: []
  type: TYPE_NORMAL
- en: There’s just one loose end to tie up.
  prefs: []
  type: TYPE_NORMAL
- en: Sundance Square – Fort Worth, Texas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It was a hot spring day in Fort Worth, Texas. And it was the last day of the
    MS-150 bicycle rally. The MS-150 is an event that generates millions of dollars
    per year toward research into a cure for **multiple sclerosis** (**MS**). Thousands
    of cyclists in the Dallas area ride in the 150-mile, 2-day event. Most of the
    local bike shops have tents set up in Sundance Square, a shopping and entertainment
    district in the heart of Fort Worth. Bumble Bikes, being a platinum sponsor, has
    a large tent set up at the finish line.
  prefs: []
  type: TYPE_NORMAL
- en: Tom, Lexi, and Karina are working the tent, giving water and high-fives to the
    intrepid few that cross the finish line. While upward of 3,000 riders start the
    rally, fewer than 10% actually finish. Most quit along the way when their knees
    give out or their equipment breaks. Tom and Lexi are watching keenly for a group
    of riders who they fully expect to finish dead last. It’s a rally, not a race.
    The people who ride aren’t competing against each other—they’re competing with
    themselves to see if they have what it takes to complete the course. They start
    in Plano on day 1 and pedal 75 miles to Texas Motor Speedway where local **National
    Association for Stock Car Auto Racing** (**NASCAR**) races are held. The next
    day they start again but first, they do a lap on the speedway, then ride 75 more
    miles into Fort Worth.
  prefs: []
  type: TYPE_NORMAL
- en: '“*There they are!*”Lexi yells as she squints toward the top of a hill in the
    distance. *Team Bumbles* is cresting the hill, all riding brand new Hillcrest
    bicycles: Kitty, Phoebe, and most of the Bumble Bikes employees, along with Kitty
    and Phoebe’s father.'
  prefs: []
  type: TYPE_NORMAL
- en: 10 years have passed since his diagnosis. The chemotherapy and steroids had
    been ineffective in treating the disease. In fact, the steroids had caused a severe
    case of osteoporosis. The doctors had given up, saying there was nothing further
    that could be done. Kitty and Phoebe had prayed countless times, ultimately joined
    by an informal coalition of local churches.
  prefs: []
  type: TYPE_NORMAL
- en: The wheelchairs Kitty and Phoebe built were extremely helpful. They had built
    and distributed over 1,000 wheelchairs free of charge to children’s hospitals
    all over the world. Bicycle and wheelchair sales at Bumble Bikes grew steadily
    until it became the number 3 bicycle manufacturer in the world, and the only company
    to produce its products in the **United States** (**US**). MegaBikeCorp, the company
    where Kitty and Phoebe interned all those years ago, was ranked at number 19.
  prefs: []
  type: TYPE_NORMAL
- en: Their father had been using his *Texas Tank* for many years. The design had
    proved too expensive to mass produce, so they only made one. As much as he loved
    his *Tank*, every day he made it a practice to try to stand up. Most days he fell
    down. Until one day, he didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: As suddenly as it had started, one day it stopped. The doctors could not explain
    it. They had run out of ideas years ago. Kitty and Phoebe knew their prayers had
    been answered.
  prefs: []
  type: TYPE_NORMAL
- en: It took years of physical therapy. Electrical shock therapy was needed to get
    their father’s voice box working again after the disease had nearly destroyed
    the muscles in his throat. He took shots in the stomach every day for 2 years
    to cure the osteoporosis. He took short walks—a few blocks at first, but later
    it was a few miles. Month after month, and year after year, he got a little stronger.
    He traded his *Texas Tank* for one of Bumble Bikes’ new electric bicycles with
    a motor. Tom was happy to take the *Tank* off his hands. The new electric bike
    offered a motor to assist with pedaling. The motor didn’t do all the work—it just
    helped.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, he was able to ride a normal bicycle again, and today, he had ridden
    it 75 miles to the finish line with his daughters and a small armada of handicapped
    riders. Bumble Bikes had produced a hand-cranked bicycle for riders who couldn’t
    use their legs and invited any rider who didn’t have such a bicycle to ride with
    *Team Bumbles*.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone in the square stopped what they were doing and cheered as they saw
    the *back of the pack*, followed by a police escort crossing the line. It had
    been a very long road, not just because 75 miles is a long way to ride a bicycle
    in 1 day. The finish line meant so much more than the end of the rally. Most importantly,
    they crossed it as a family.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.redhat.com/architect/14-software-architecture-patterns](https://www.redhat.com/architect/14-software-architecture-patterns)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Nock, Clifton. Data Access Patterns: Database Interactions in Object-Oriented
    Applications. Boston: Addison-Wesley, 2004.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The companion website for this book: [https://csharppatterns.dev](https://csharppatterns.dev)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Appendix 1: A Brief Review of OOP Principles in C#'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The landscape of programming languages contains hundreds of choices. If you’re
    reading this book, you have probably come across C# at some point along your journey.
    For some, C# is the only language they’ve ever learned. For others, it’s the third
    or fourth. Maybe you develop in C# every day and have for many years, or maybe
    you’ve just picked it up, and it’s now your new best friend.
  prefs: []
  type: TYPE_NORMAL
- en: I realize that readers will be coming to this book with different levels of
    experience, different backgrounds, and different career objectives. I used to
    have a very popular video series published on LinkedIn Learning that was designed
    to teach C# to beginners. To be honest, this has always been my favorite audience.
    Teaching software development to newbies is like teaching magic in a jaded world
    sadly short of vision. I get to see *Aha!* moments nearly every week with my students
    at Southern Methodist University, where I teach at the Full Stack Code boot camp.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that excited me about the prospect of writing this book is
    this book helps you take the next step. Either you’ve just learned how to code
    or maybe you’ve been using the same magic tricks for many years with success,
    but you realize there’s still more to learn. Patterns are a great next step. Learning
    patterns makes you better at almost everything else in programming.
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that I don’t know where you are in your journey. If you’re
    a student of mine from SMU, you’ve learned JavaScript really well and you want
    to take the next step. C# is radically different from JavaScript. Jumping into
    this book from only knowing JavaScript would be hard, but not impossible. If you’re
    self-taught, you’ve probably focused on what I call “survival skills.” They include
    basic OOP plus how to work with a database and probably web technologies. If you’re
    in a university, and you’re learning how to code, your textbooks are likely not
    very illuminating. I know. I’ve taught at colleges and universities for 25 years.
    Usually, I write my own material because of the dearth of good books out there.
  prefs: []
  type: TYPE_NORMAL
- en: No matter where you are right now, or where you came from, this chapter is here
    to orient you. Originally, I had intended this to be the second chapter of this
    book. My editor wisely suggested we get into working with patterns as quickly
    as possible. She suggested an appendix, which we’ve mentioned throughout the book.
    You’ll either get a good review or a crash course in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this appendix, you can expect to learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A quick background on C# and how the language can be defined along a number
    of lines of taxonomy. That sounds fancy, but you’ll see it’s fairly basic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax mechanics of C# with enough length and detail to get you through
    this book. Since this book mainly deals with plain old C# objects (POCOs) and
    a few common types from .NET Framework such as Lists, this section is possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to set up the projects in the book using three common IDEs in Windows.
    There are two project types we use: command-line projects and libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to clone the sample code projects covered in the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix is largely an overview of basic topics rather than a collection
    of projects. With that said, at the end of the appendix, you are guided in the
    use of the three most popular C# IDEs on the market today. You’ll have a choice
    to make. Regardless of which IDE you choose, you’ll need a computer running the
    Windows operating system. I’m using Windows 10\. The projects used in this book
    probably work fine on a Mac or in Linux, but I didn’t test them there, so your
    mileage might vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow the IDE tutorials at the end of this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these IDEs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains Rider
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core 6 SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the completed project files for this chapter on GitHub at [https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/appendix-1](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/appendix-1).
  prefs: []
  type: TYPE_NORMAL
- en: A quick background of C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let me just say it out loud right off the bat: C# is a knock-off of Java. If
    you know Java, but not C#, you’re going to have a very easy time. Now, pretend
    I didn’t lead with that and allow me to slip on my corduroy sport coat. The one
    with the patches on the elbows. I have a tobacco pipe in the front pocket of the
    jacket sticking up so that you can see it. Naturally, in this day and age, nobody
    would dream of putting tobacco or anything else into it. That’d be wrong. But
    I need to look as much like a college professor as possible, so I can go all historical
    on you for a bit.'
  prefs: []
  type: TYPE_NORMAL
- en: The C# language is Microsoft’s flagship language product for corporate and game
    programming. It was designed by Anders Hjlsberg in the year 2000 AD. Some of my
    students claim I am ancient, so I figured I’d clarify by stating that it is, in
    fact, AD and not BC. The language was submitted and approved as a standardized
    language via the **European Computer Manufacturers Association** (**ECMA**). You
    might know this is as the same body that standardized JavaScript, which is really
    called ECMAScript. Many languages are standardized. This simply means that there
    is an open specification available for the language and that it is possible for
    others to create a competing implementation of a language based on the specification.
    C# is Microsoft’s implementation. There is an open source competitor called Mono
    that used to be popular in several arenas, including cross-platform mobile and
    game development.
  prefs: []
  type: TYPE_NORMAL
- en: When Microsoft introduced C#, it also released .NET Framework and Visual Studio.
    .NET Framework is a massive set of libraries that provides a language support
    infrastructure for C# along with other Microsoft languages. Each language supported
    can compile its code into an intermediate format. The intermediate form at, called
    **Microsoft Intermediate Language** (**MSIL**), can then execute using the .NET
    runtime. This makes the overall language architecture very similar to Java, which
    compiles to an intermediate form called bytecode, which is then executed on a
    **Java Virtual Machine** (**JVM**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The stated design goals for the language include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple, general-purpose, object-oriented language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for a strong, statically typed variable system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic bounds checking on array types and the detection of uninitialized
    variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code portability; code should be executable in a variety of environments
    without changing the code significantly and without recompiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s expand on these ideas.
  prefs: []
  type: TYPE_NORMAL
- en: C# is a general-purpose language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pretty much everyone has heard of an invention created by Richard Clyburn in
    1842\. I present you with an adjustable wrench in *Figure A.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.1: An adjustable wrench. You can use this for almost any wrenching
    job. If you’re in a jam, you can also use it to open bottles and drive nails.
    It’s a general-purpose tool just like the C# language, which can be used to make
    almost any kind of software ](img/Figure_A1.1_B18605.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.1: An adjustable wrench. You can use this for almost any wrenching
    job. If you’re in a jam, you can also use it to open bottles and drive nails.
    It’s a general-purpose tool just like the C# language, which can be used to make
    almost any kind of software'
  prefs: []
  type: TYPE_NORMAL
- en: We call them *crescent wrenches* in the US, while many other countries refer
    to them as *spanners*. This wrench is a general-purpose wrench. It can be used
    for a variety of tasks befitting a wrench from the loosening and tightening of
    metal fasteners on your IKEA furniture to installing a new engine in your ‘57
    Chevy, to installing a new garbage disposal for your kitchen sink.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the wrench in *Figure A1.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.2: This is a basin wrench. It’s only good for one thing: tightening
    down fastening nuts on faucet hardware under a sink. It is a special-purpose tool
    just like SQL is a special-purpose language. Both can only be used for one purpose
    ](img/B18605_Figure_A1.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.2: This is a basin wrench. It’s only good for one thing: tightening
    down fastening nuts on faucet hardware under a sink. It is a special-purpose tool
    just like SQL is a special-purpose language. Both can only be used for one purpose'
  prefs: []
  type: TYPE_NORMAL
- en: You might have never encountered one of these before. This odd-looking contraption
    is called a *basin wrench*. It has only one job. It is used to tighten the faucet
    coupling when installing a new kitchen or bathroom sink. The wrench head pivots
    across 180 degrees, so you can maneuver it around all the pipes. The long handle
    helps you deal with the sink bowl that protrudes downward, blocking your access
    were you to attempt this with a general-purpose wrench.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, there exist a few special-purpose languages, the most popular being
    **Structured Query Language** (**SQL**). SQL is only used to query relational
    databases. You can’t make a video game or an operating system with it.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, C# is a general-purpose language. It can be used to make
    just about anything from line-of-business software to AAA video games. And yes,
    someone did once try to make an operating system with C# called *SharpOS,* showing
    us that it is possible to write an operating system with C#.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest reason to choose C# as your main language of choice is the flexibility.
    Coupled with .NET Framework, you have thousands of building blocks. You can use
    them to build whatever software you might need.
  prefs: []
  type: TYPE_NORMAL
- en: C# is purely and fully object-oriented
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two major paradigms that you’ll see in programming languages: OOP
    and functional programming languages. Perhaps a third paradigm occurs when it
    is possible to mix the two within a single language. Let’s cover the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **OOP** | **Functional programming** |'
  prefs: []
  type: TYPE_TB
- en: '| Code is organized into classes as the primary building block of your program.
    | Code is organized into distinct functions, which use their arguments in place
    of properties. |'
  prefs: []
  type: TYPE_TB
- en: '| Methods often have side effects. They can change the state of the object
    from within the method. | Pure functions never have side effects. |'
  prefs: []
  type: TYPE_TB
- en: '| In OOP, we have support for mutable and immutable objects. | Function programming
    never supports mutable variables. If you want to change something, you have to
    create a new variable. |'
  prefs: []
  type: TYPE_TB
- en: '| Data is stored in properties within the object and is prioritized from a
    design perspective above methods that often serve only to mutate the state of
    the object. | The design goals are focused on functions. They take immutable inputs
    and produce an output. |'
  prefs: []
  type: TYPE_TB
- en: 'Figure A1.3: The difference between OOP and functional programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Some languages, such as C# and Java, are strictly object-oriented. Languages
    such as Haskell and F# are strictly functional, while languages such as JavaScript,
    Python, and PHP can support either or both paradigms. The original **Gang of Four**
    (**GoF**) software design patterns, which are the focus of this book, were built
    around OOP using a language called *SmallTalk*. Naturally, we’ll keep our focus
    strictly on OOP.
  prefs: []
  type: TYPE_NORMAL
- en: C# uses a static, strong type system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three schools of thought with respect to type systems. First, let
    me tell you what I mean by a **type system**. Programming languages share a common
    purpose: they all take some sort of input and turn it into some sort of output.
    The input and output for the program are called **data**. There are three basic
    types of data as far as your computer is concerned.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings** are alphanumeric data – think letters and numbers. If you can type
    it on your keyboard, it is alphanumeric.'
  prefs: []
  type: TYPE_NORMAL
- en: The second type of data is **numbers**. I think you know what this means. While
    numbers can be alphanumeric strings, you can’t use strings to do math. This distinction
    is at the heart of a strong type system, so remember this for just a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The third basic type of data is **booleans**. Booleans are binary, meaning they
    can have a value of either true or false. Sometimes, the value is expressed as
    0 (false) and 1 (true), or 0 (false) and not 0 (true).
  prefs: []
  type: TYPE_NORMAL
- en: The three basic types are called **primitive data types**. In a **strong type
    system**, you have to tell your program what kind of data you will be using when
    you declare a variable or create a function.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond primitive types, C# supports the ability to create your own types as
    objects. Like primitives, these types are strong. They are also static. A **static
    type system** means that when you say you are going to use a variable to hold
    a string, you can never change the variable to any other type. It is static, meaning
    it can never change its type.
  prefs: []
  type: TYPE_NORMAL
- en: While C# and many other languages use a strong and static type of system, other
    languages do not. JavaScript took the opposite approach. JavaScript uses a weak
    and dynamic type of system. In such a system, it is perfectly fine and normal
    to create a variable and assign a value of any type. Let’s say we create a variable
    called *foo* and set it equal to “this is a string.”
  prefs: []
  type: TYPE_NORMAL
- en: The very next line can assign a value of 9 to the variable of *foo*. The fact
    that you didn’t have to declare a type with the variable indicates a **weak type
    system**. The fact you can change the type any time you’d like indicates a dynamic
    type system. JavaScript is incredibly powerful and flexible, but it also feels
    very foreign for developers who learn a strong static system leading to the idea
    that JavaScript is a “toy language” and not for serious work. This is, of course,
    wholly false.
  prefs: []
  type: TYPE_NORMAL
- en: The third type of system that you’ll encounter is called duck typing. Likely
    the most famous system using duck typing is Python. In Python, you see the middle
    ground between strong static typing in C# and the weak dynamic system in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you don’t declare a type with your variables. However, the Python
    interpreter observes how the variable is used, and it infers a strong type. This
    kind of system is called duck typing because the designers who created this type
    of system claimed “If it walks like a duck and quacks like a duck, it’s a duck.”
  prefs: []
  type: TYPE_NORMAL
- en: Later versions of C# support also duck typing, so we’ll see some examples later.
  prefs: []
  type: TYPE_NORMAL
- en: C# has automatic bounds checking and detection for uninitialized variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# was created to correct deficiencies in other languages. You hear that for
    pretty much every new language created in the last 20 years. Some group hates
    the way something works in C or Java, so they make a new language. Usually, they
    are an amalgamation of the so-called good parts of other languages. If you don’t
    believe me, read up on Apple’s *Swift* language, the *Rust* language, or the *Golang*
    languages created by Google. C# isn’t any different.
  prefs: []
  type: TYPE_NORMAL
- en: Studies have shown that the lack of bounds checking and uninitialized variables
    are both major sources of software bugs. Really, then, the objective here is to
    create a language that makes it harder for developers to make mistakes. In the
    next few features, we’ll discuss embodying this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Bounds checking refers to arrays. An array is a special type that allows you
    to store multiple values in a single variable. Since C# is strongly typed, array
    elements must all be of the same type. You can have an array of strings, an array
    of numbers, or an array of objects. Furthermore, in C# when you define an array,
    you must tell your program how many elements you will put into the array. Once
    you set it, the size is fixed and you can’t change it without jumping through
    some proverbial hoops.
  prefs: []
  type: TYPE_NORMAL
- en: Uninitialized variables are not just representative of sloppy work – in some
    programming languages they can be dangerous. The C programming language comes
    to mind here. C went through some drastic changes over the last 10 years, but
    back when I was your age, the mantra of C was “With great power comes great responsibility.”
    I think that’s also Spiderman’s mantra. Maybe Peter Parker should have been a
    coder instead of a photographer.
  prefs: []
  type: TYPE_NORMAL
- en: In C, as in most languages, a variable is just a pointer to an address in memory.
    Computer memory is a lot like an apartment complex. In fact, older versions of
    C# and Visual Basic called their memory models “apartment threading.” Apartments
    are containers for you and your stuff. Some apartments are small and economical
    (unless you live in New York City, in which case they are simply small). Others
    are larger and more expensive. Regardless of their size, shape, and decor, their
    function is to hold you and your stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Each apartment in an apartment complex has an apartment address number. So,
    you can effectively say *I want to put my stuff in apartment 122*. If you get
    a raise at work, and you decide to upgrade, you can move your stuff into apartment
    300, which is larger. The address tells us where your stuff is located, and the
    manager of your apartment building knows how big each apartment is and how much
    it costs.
  prefs: []
  type: TYPE_NORMAL
- en: Computer memory works the same way. There are registers of addresses (such as
    the apartment complex) that can be told to store stuff of varying sizes. We can
    extend our analogy to say the apartment manager is the computer running your program.
    It knows where the containers are since it keeps a list of each apartment’s address
    and how much space each apartment occupies.
  prefs: []
  type: TYPE_NORMAL
- en: The addresses are not simple numbers such as 122 or 300\. They are a bit more
    complicated and are not easy to work with. So, instead of dealing with addresses,
    we can give our apartments, or containers, a straightforward human-sounding name
    that describes how your variable is being used in your program.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a container, such as an apartment, of a defined size (small
    and cheap versus big and expensive), it has an address. But instead of using that,
    you use whatever name you think is easy to use and remember.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine an apartment that was built as part of the building, but it is full
    of construction debris and trash left over from when it was built. Nobody has
    ever rented the apartment, so nobody has ever cleaned up the mess. This is an
    uninitialized variable. If someone wanted to rent the apartment and move in on
    the same day, that is, access the address, they would find it’s full of trash.
    When a running program with a strong static type system encounters trash that
    it doesn’t expect, the program crashes. If you have ever encountered a **blue
    screen of death** (**BSOD**) in Windows, you know what this looks like. Uninitialized
    variables will have whatever junk was left over from the last time that memory
    address was used. Back in the day, a major headache of working with C was manually
    allocating and deallocating memory. If you did it wrong, things crashed in the
    least graceful way possible. What the C developers really need is some way to
    handle garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: C# supports automated garbage collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The nightmare scenario we just covered shows the need for language improvements.
    C# is meant to be simple and useful. In C, back when C# was conceived, we were
    manually allocating memory addresses. This meant executing a statement that defined
    your allocation using a hexadecimal value. Most humans are doing well working
    in base 10\. Our old environments had us mentally converting decimal (base 10)
    numbers into base 8 (octal) and base 16 (hexadecimal) to do our memory allocations.
    Then, we used that memory, and when we were done, we needed to remember to deallocate
    the memory. In our apartment metaphor, this would entail moving out of the apartment
    and giving it thorough cleaning in the process. The apartment should be move-in
    ready when we deallocate.
  prefs: []
  type: TYPE_NORMAL
- en: What if we had a language that handled allocation and deallocation automatically?
    We do. C# has a garbage collection system that handles everything for you. You
    create a variable, and the details are taken care of by the .NET runtime. When
    your variable goes out of scope, it gets marked for cleanup and, ultimately, the
    garbage collection process in the runtime deallocates and cleans up the memory
    for you. As you can imagine, the manual allocation and deallocation of memory
    in a system that had no safety net was also a major source of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: C# code is highly portable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C# language specification aims at having portable code. In the earliest
    versions of C# and .NET, we weren’t very portable. Windows was all we had. You
    couldn’t run C# code on a Mac, Linux, or a phone. Gaming consoles were also out.
  prefs: []
  type: TYPE_NORMAL
- en: The open source community created Mono, an open source version of C# designed
    to run on Linux operating systems, but it has always been several years behind
    Microsoft’s implementation in C#. Eventually, Mono became a very popular way for
    C# developers to leverage their language skills to create mobile applications
    for the Android and iPhone platforms using Mono alongside a framework called Xamarin.
  prefs: []
  type: TYPE_NORMAL
- en: A game development engine called Unity 3D also leveraged Mono and brought a
    AAA quality game engine to the mass market. Up until then, game engines such as
    Unreal were strictly in-house. The only way to develop a quality game was to work
    at a company that could afford the very expensive SDKs. Unity 3D busted the game
    development industry wide open, and they used C#/Mono to do it.
  prefs: []
  type: TYPE_NORMAL
- en: As time moved on, Microsoft made each iteration of the language more portable.
    We saw a big shift when Microsoft announced its Azure cloud platform. They wisely
    understood most IT professionals were never going to use a system that limited
    them to Microsoft products. Linux owns the majority share of web servers. When
    cloud computing started to reach critical mass in terms of popularity, we saw
    a huge proliferation of open source compatibility introduced into Microsoft’s
    landscapes including .NET Core, which allows us to compile and run C#, or any
    .NET language, to run on nearly any type of hardware environment making your code
    truly portable. The portability comes from the .NET runtime. Let me explain what
    that means.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different ways any given programming language is able to execute
    code. First, there is code that can be compiled into native machine code. For
    this, you need a language such as C, C,++, or Rust. Programs that can be compiled
    this way run on “the bare metal,” making them very fast in terms of execution,
    but the languages required for this are typically more demanding to use. C and
    C++ require you to keep tabs on your memory utilization, which is the primary
    source of bugs written in these tools. Rust aims to eliminate memory errors with
    very strict compile time restrictions. Using these languages can be frustrating,
    and your time to market is usually slower, especially when adopting these languages
    for the first time. There’s a trade-off between developer productivity and the
    performance of the software when it runs for the users.
  prefs: []
  type: TYPE_NORMAL
- en: The second camp is languages that use interpreters. Usually, these languages
    are scripting languages such as Python, PERL, and Lua. These languages are built
    around developer productivity and, typically, sacrifice execution speed and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The third group is sort of in-between. All .NET languages, in a similar fashion
    to Java, compile to an intermediary binary format. Java calls this byte code.
    C# and other .NET languages call it **Common Intermediate Language** (**CIL**).
    These binary formats execute faster and more efficiently than an interpreted language,
    but they do require a runtime to execute the intermediate form.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember how the published version of code in any given language
    might perform. On the whole, compiled C# code is generally slower than the “bare
    metal” compiled languages, but not by much.
  prefs: []
  type: TYPE_NORMAL
- en: Language mechanics in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve mentioned already that C# is strictly an **object-oriented programming**
    (**OOP**) language. OOP languages support a set of abstract features, which you
    need to understand before we can continue. Firstly, OOP languages organize code
    differently than procedural languages. In OOP, we model elements from the real-world
    using code. The real-world elements are described using **properties**, **methods**,
    and **events**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I were modeling a circle, I might give it a set of properties
    as seen in Figure A1.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.4: A circle, like anything else, can be represented by describing
    it as a set of properties ](img/B18605_Figure_A1.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.4: A circle, like anything else, can be represented by describing
    it as a set of properties'
  prefs: []
  type: TYPE_NORMAL
- en: Using these properties, I can describe any circle I might want to draw on the
    screen in my program.
  prefs: []
  type: TYPE_NORMAL
- en: Effectively, properties are variables that belong to the circle. They contain
    the data that describes the circle. When describing a variable that belongs to
    an object, you refer to these as *properties*, *member variables*, or *members*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, objects describe the actions they might perform. When we talk
    about functions in the context of OOP, we call them methods. We could say our
    circle object has a method called `draw()` that draws the circle to the screen
    given the properties that describe it. We could also add a method to resize the
    circle. Methods are the same thing as functions, so we can pass in arguments.
    Our resize method will need to know the new radius of the circle. It might be
    called this way: `resize(100)`. This would change the radius of the circle from
    200 to 100\.'
  prefs: []
  type: TYPE_NORMAL
- en: Objects also commonly have a specialized set of methods designed to respond
    to events. Events can be described as *things that happen* while your program
    is running. Common examples might include the user clicking on the circle, hovering
    a cursor over the circle, right-clicking on the circle with your mouse, long-tapping
    the circle on a touch screen, or the passage of time. Maybe you want the circle
    to disappear after 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t necessary for an object to have all of these pieces. Some objects only
    represent data using properties. Some are just used for constants and methods,
    such as the `Math` class in C#. However, most of the time, there is a mixture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to objects being organized with properties and methods, there are
    a few other buzzwords to learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this sounds horribly complicated, but don’t worry, that’s what I’m here
    for. We’ll touch on all of these concepts within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: OOP first surfaced in the 1980s with the Ada programming language. Ada was named
    for programming pioneer August a Ada King, Countess of Lovelace. You’ve probably
    heard of her as Ada Lovelace. The language that bears her name was created under
    contract for the US **Department of Defense** (**DoD**) and was designed to replace
    over 450 disparate programming languages that were in use at the DoD at the time.
    As you can imagine, it had some big shoes to fill. The Ada language is to programming
    what the Tucker automobile was to the American automotive industry. The 1948 Tucker
    automobile was the first to offer standard seat belts, a water-cooled aluminum
    engine, disk brakes, fuel injection, and an independent suspension. These are
    all standard features of modern cars, and we’d be hard-pressed to consider buying
    a car today without them. However, they didn’t exist on cars designed and built
    in the 1940s, or certainly not all on one car.
  prefs: []
  type: TYPE_NORMAL
- en: The original Ada language supported object orientation, design by contract,
    strong typing, an explicit syntax for concurrency, tasks, message passing, encapsulation
    using private and protected classes, and code safety enforced by a compiler. Sound
    familiar? Many modern languages, including C#, include these features out of the
    box owing largely to the virtues embodied in Ada.
  prefs: []
  type: TYPE_NORMAL
- en: OOP became popular because it allows you to organize your software in a way
    that makes sense and is easy to comprehend. Developers who learn OOP first have
    trouble switching away from it. Having worked with both kinds of thinking for
    many years, I believe OOP is the best way to create large-scale software projects
    because it forces you to think a certain way. The main tenets of OOP, some of
    which are covered in SOLID principles, are like a built-in way to make your software
    maintainable, testable, and extensible in the safest way possible. I believe it
    is important to use an object-oriented language when you initially learn patterns.
    The original work on patterns was based on Java, which is remarkably similar to
    C#. Many of the ideas presented in this book won’t work or must be shoehorned
    into working with non-object-oriented, multi-paradigm, or dynamic languages. For
    example, JavaScript ES5 is considered object-oriented, but objects are dynamic.
    By this, I mean you can change the structure of any object, including those internally
    supported by the language at any time while your code is running. You can even
    alter all instances of an object owing to JavaScript’s use of prototype inheritance.
    JavaScript is weakly typed, and the list of types it supports is limited. Classes
    and encapsulation simply don’t exist in ES5\. It is difficult to study patterns
    in a language such as this because patterns require a foundational set of restrictive
    rules, which don’t fully exist in many other languages.
  prefs: []
  type: TYPE_NORMAL
- en: By choosing to work with C#, you align yourself with all the key tenets of developing
    software with well-known, battle-tested patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Variables in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I consider the simplest definition of a variable to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A variable is a named container that holds data in computer memory.*'
  prefs: []
  type: TYPE_NORMAL
- en: When you learn a programming language, you need to know whether the language
    is strongly or weakly typed.
  prefs: []
  type: TYPE_NORMAL
- en: In a **strongly typed** language, also referred to as a statically typed language,
    you must define your variables’ data type. You have to tell your program what
    kind of data you are storing in any given variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a **weakly typed language**, you don’t need to declare a type because, effectively,
    there is only one type: everything is an object.'
  prefs: []
  type: TYPE_NORMAL
- en: Here is a great way to think of it. Data can have a shape, as can a container.
    Containers also have a definite size. You cannot fit one pound of sugar into a
    container designed to hold no more than a quarter of a pound. However, you can
    fit that same pound of sugar into a 5-gallon bucket with room to spare.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# is statically typed with support for **implicit typing**, also known as
    **duck typing**. In a strongly typed language such as C#, you would see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int myNumber = 5;`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’re creating a variable called `myNumber`, of type `int`, and setting
    it to an initial value of `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit typing allows us to make a small change:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var myNumber = 5;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the type declaration appearing before the name, you use a one-size-fits-all
    keyword, `var`. The compiler will see these statements as identical. The compiler
    can figure out what type your variable is supposed to be based on its initial
    assignment. Here, we see an initial assignment of 5, so the compiler will assume
    you meant this to be an integer (`int`). If that’s not what you wanted, you can
    give the compiler a hint. Let’s say we really wanted `myNumber` to be the `decimal`
    type. Since there is no mathematical difference between 5 and 5.0, the compiler
    gets it wrong and, eventually, you get red wavy lines in your code indicating
    you have a problem. How can you specify the type and still use the `var` keyword
    syntax? Behold:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var myNumber = 5d;`'
  prefs: []
  type: TYPE_NORMAL
- en: We add a *d* as a suffix to the number. Just like that, the compiler now knows
    you want this to be a decimal. But I’m getting ahead of myself.
  prefs: []
  type: TYPE_NORMAL
- en: Signed numeric types delineated by memory size usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# supports signed and unsigned numeric types. Numbers in programming languages
    are handled in memory using a mathematical operation on binary numbers called
    two’s complement as seen in Figure A1.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.5: Integer representation on computers happens using a mathematical
    concept called two’s-complement. One year, I went to the office Halloween party
    as an integer. I had this figure printed on a t-shirt. The best costumes are the
    ones you have to explain ](img/B18605_Figure_A1.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.5: Integer representation on computers happens using a mathematical
    concept called two’s-complement. One year, I went to the office Halloween party
    as an integer. I had this figure printed on a t-shirt. The best costumes are the
    ones you have to explain'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a math geek, check out the Wikipedia page for this topic provided
    in the further reading section.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of us, this concept can be explained simply. Any variable that’s
    meant to store a number will have a minimum and maximum size for the number. For
    example, a common 32-bit integer (`int32`) has a range of -2,147,483,648 at the
    minimum end and a maximum value of 2,147,483,647\. We had to chop one off the
    maximum to account for zero. The size ranges are dictated by two’s complement
    given the amount of memory space used. The range I just showed you represents
    the capacity for a **signed** type, meaning it supports numbers less than zero.
    If you don’t care about negative values, C# allows you to use **unsigned** types
    that extend the range from 0 to 4,294,967,295.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# allows you to control memory usage by selecting from a myriad of signed
    and unsigned ranges. In other words, signed numeric types are delineated by memory
    size usage. I think this is a point that most developers forget or ignore since
    most of us, when we need an integer, just use `int`. I used an analogy earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '*You cannot fit one pound of sugar into a container designed to hold no more
    than a quarter of a pound. You can, however, fit that same pound of sugar into
    a 5-gallon bucket with room to spare.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lot of wasted space in the 5-gallon bucket. You can control the
    waste by selecting a type that has a range that is compatible with how it’s used.
    Think about how many times have you either seen or done this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int myAge = 54;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a huge waste of space. First, a person’s age can’t be a negative number.
    It makes sense to change this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uint myAge = 54;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’re using the unsigned version of the 32-bit integer. See if you can
    pick a more appropriate type from the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** | **Minimum** | **Maximum** | **Bits** |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | Boolean | False (0) | True (1) | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | Unsigned byte | 0 | 255 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `sbyte` | Signed byte | -128 | 127 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | Signed short integer | -32,768 | 32,767 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| `ushort` | Unsigned short integer | 0 | 65,535 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Signed integer | -2,147,483,648 | 2,147,483,647 | 32 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | Unsigned integer | 0 | 4,294,967,295 | 32 |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | Signed long integer | -9e18 | 9e18 | 64 |'
  prefs: []
  type: TYPE_TB
- en: '| `ulong` | Unsigned long integer | 0 | 1.8e19 | 64 |'
  prefs: []
  type: TYPE_TB
- en: 'Figure A1.6: A list of C# integer types with ranges and how much memory each
    consumes.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, as we move down the chart, we use more and more memory. A bit
    is the smallest thing a computer can work with. A 64-bit integer can only be understood
    using the term *±9 kajillion* or *18 kajillion* depending on whether it’s signed.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we use a 32-bit unsigned integer with a maximum value of 8 billion
    for a person’s age? Either we don’t know about numeric type delineations or we’re
    simply lazy, which is one of those debilitating forces we talked about in [*Chapter
    1*](B18605_01.xhtml#_idTextAnchor016). We’ve just broken a window that leads us
    into a big ball of mud. We should be using an unsigned byte that has a minimum
    value of 0 and a maximum value of 255\. Most normal humans, aside from Elvis,
    who is living on a secret island in Hawaii, and Chuck Norris, who is obviously
    immortal, don’t live past 100 years. When you consider the earth is about 4.5
    billion years old, you begin to see the folly of this common practice. If you
    do this, you’re in good company. Microsoft does it too throughout its C# documentation.
    I am tempted to quip writers make bad coders, but I’d be shooting myself in the
    foot if I did. I won’t fault you if you don’t immediately change all your production
    code from `int` to `byte` so long as you now realize you’re wasting a lot of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure A1.7* shows us all the valid integer types. There are similar names
    and ranges for floating-point numbers and text types. All of these types are considered
    `int` keyword mapping to the `Int32` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The real list turns out to be something like the list in *Figure A1.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Alias/primitive keyword** | **.NET type** |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | System.Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | System.Byte |'
  prefs: []
  type: TYPE_TB
- en: '| `sbyte` | System.Sbyte |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | System.Int16 |'
  prefs: []
  type: TYPE_TB
- en: '| `ushort` | System.Uint16 |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | System.Int32 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | System.Uint32 |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | System.Int64 |'
  prefs: []
  type: TYPE_TB
- en: '| `ulong` | System.UInt64 |'
  prefs: []
  type: TYPE_TB
- en: 'Figure A1.7: The full list of C# integer ranges with the alias in the first
    column and the real implementation class in the second column.'
  prefs: []
  type: TYPE_NORMAL
- en: C# allows for aliases, and often the alias points to the same class name expressed
    with an uppercase letter. All the primitive types are in the .NET `System` object.
    Almost every project you create in Visual Studio has a `using System` statement
    at the top. This is why you can see strings being created in several different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'A string defined using all lowercase characters works because of the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var string foo = "bar";`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A string defined with a capitalized `String` keyword works because of the `using
    System` statement that is likely at the top of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var String bar = "baz";`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can also write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var System.String fooBarBaz = "foo bar baz";`'
  prefs: []
  type: TYPE_NORMAL
- en: Honestly, I’ve never seen anybody do this. Years ago, when I taught introductory
    programming courses in C# at a nearby college, the difference between `String`
    and `string` was a widely asked question, especially coming from students who
    had previously studied Java. Java lacked these kinds of aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Separate character and string classes with different quotation marks used for
    each
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This point is short, but worth mentioning if you are coming from another language,
    or if you switch languages frequently. C# has separate class types for strings
    and characters. The string type is `System.String`. It’s an alias that is used
    far more frequently, which is just `string`. The character type, which is a single
    character string, is created using the `System.Char` class or just `char`. The
    quotation marks used in the assignment of values matter, too. Many languages,
    such as JavaScript and Python, allow you to use single and double quotes interchangeably.
    In C#, strings are denoted with double quotes, while characters are assigned using
    single quotes. They are not interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript has `Arrays` (a.k.a. what I’m hoping I get at work for writing a
    book). Python has `Lists`. Java has `ArrayLists`. C# has a broad set of **Collections**.
    C# has arrays such as JavaScript, but they are more limited. You have to set the
    number of items you are putting into the array in advance, and once set, that
    number can’t be easily changed. A more useful form of array in C# is the .NET
    List class.
  prefs: []
  type: TYPE_NORMAL
- en: 'List classes are like arrays, except you can add and remove items any time
    you need to. They are a lot more flexible. Lists are strongly typed, like everything
    else in C#. This means all the items in the List have to be the same type. C#
    has a system for this called `<>`). In the book, you’ll see references to `List<>`.
    This indicates a generic list, and once again, that just means you can put anything
    into the list as long as everything you put into it is of the same type. If you
    wanted to create a list of strings, it might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To use these generic collections, you have to add a statement at the top of
    your class file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Generic collections are some of the most versatile and widely used classes in
    .NET Framework. You will definitely encounter them early and often.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, my assumptions regarding your exposure to OOP have presupposed you know
    what a class is and its purpose. Just in case that’s an invalid assumption, let’s
    clear it up now. A *class* can be thought of as a blueprint for a house. The blueprint
    describes everything you need to know to build the house. You can use the blueprint
    to make as many houses as you need, and as you build them, you can change the
    individual properties on each house. It isn’t necessary that they all be the same
    size or color, or that they all have a certain number of windows. You can alter
    any of these properties when you build the house.
  prefs: []
  type: TYPE_NORMAL
- en: In most OOP languages, the class is the main form for defining how objects are
    constructed. There are even special methods called constructors, which run when
    an object is instantiated, which is to say when you create an instance of an object
    using the new keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the example of the `Person` class I used earlier. This time, I added
    all the parts so that I can show them to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A class has a few main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Using statements to define dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go over each part.
  prefs: []
  type: TYPE_NORMAL
- en: Using statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `using` keyword has a double meaning in C#. When you see it at the top of
    a class, it refers to the class’ dependencies. This is common in most languages.
    In Java and Python, the word is `import`. In JavaScript, it’s either `require`
    or `import` depending on which convention you use. In C#, the keyword is `using`.
    The statement signals to the compiler that some of the classes we’re going to
    reference in this class exist in other parts of our project, or even outside our
    project, which is the case when we use third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in order to use the `Console.WriteLine` method, which prints text
    to the console, first, we must declare that we will be using the `System` namespace.
    We do this with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Console` object is in the `System` namespace. The `using` statement tells
    the compiler we’ll be using classes from that namespace. That last statement makes
    for a natural segue into the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Namespaces are a way of organizing your code in C#. If you’re coming from Java,
    you’ve used packages. In Python, they’re called modules. In JavaScript, you export
    objects you want to expose in modular code. In C#, a namespace appears at the
    top of your class files. Usually, it corresponds to the name of your project.
    If you create folders inside your project to break up your code, usually, the
    namespace mirrors the folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding sample code, we have a namespace called `MyProject`, which
    would be the name of the C# project. If I made a folder called helpers to hold
    some helper objects, the namespace in those folders would be `MyProject.helpers`.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are not an absolute requirement. Most IDEs put them in automatically,
    so you’ll usually see them. Five years ago, when I last worked with the Unity
    3D game engine, the IDE didn’t put namespaces in the class code automatically.
    It’s possible to work without namespaces, but it’s rare. Visual Studio and Rider
    add the namespace automatically when you create the class. In VS Code, everything
    is manual, so you might have to add it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The class name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The line that names the class is not difficult to spot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You just use the keyword class followed by the name of the class. By convention,
    class names use the Pascal case convention, which means each word in the class
    name is represented by a capital letter. If we wanted to create a class to represent
    a floor manager at a retail outlet, we would call it `FloorManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, like properties and methods, can use access modifiers to define how
    they can be accessed. We’ll talk more about this later.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and instantiation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A constructor is a special method designed to run when you `Create an instance`
    = `instantiation`. See? It’s a fancy word every software developer needs to understand.
    Instantiation happens when you put the `new` keyword in front of a constructor
    method. This is why there is always a parenthesis at the end of your `new` statement.
    The constructor returns the instance of the object set up per any code in the
    constructor. If you don’t supply a constructor, the .NET compiler adds an empty
    one when you compile.
  prefs: []
  type: TYPE_NORMAL
- en: There are defining rules that govern the constructors. First, the constructor’s
    method name must match the name of the class. Second, you can’t define a return
    type since it is fixed to returning an instance of the class it is constructing.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# allows you to have multiple overloaded constructors. This means you can
    have more than one constructor as long as the type and number of arguments are
    different. Our code example from earlier features three constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the constructors are named `Person` because that is the name of the class.
    They must match the name of the class or they aren’t valid constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no return type specified. The return type would be between the public
    keyword and the name of the constructor method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though all three functions have the same name because they have different
    numbers of arguments, it’s legal. The first constructor has zero arguments, the
    second has one, and the third has two. This is called *method overloading* and
    is a form of polymorphism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors are a very useful way to establish the initial state of your object
    the instant the object is created. I often say that the number one job of a software
    developer is to make sure no object within your program is capable of entering
    an invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the constructor is syntactic overkill. C# will initialize
    the age property to 0 automatically. I initialize strings to empty strings because
    I don’t like the ambiguity of dealing with null values. Sometimes, your language
    of choice, in this case, C#, will try to handle things such as initialization
    for you. Relying on automatic language features will lead to mental laziness,
    one of the destructive forces I talk about in [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016)
    that leads to chaotic, unmaintainable code. If you don’t believe me, go to YouTube
    and find videos on JavaScript’s automatic semicolon insertion “feature.” You need
    to remember that your code is a set of instructions to be executed by one of the
    dumbest things on planet earth. Computers take everything literally, and if your
    instructions contain any ambiguity, bad comedy always ensues. Granted, some people
    call that job security, and everybody needs good war stories to tell. It’s like
    that one time someone on the team pasted an incomplete SQL update statement into
    SSMS pointed to a production database and updated all the customer records to
    one account. A system with a million users a day was down for 7 hours. To be clear,
    no, it wasn’t me. If it were, I would never speak of it. I’m making a point. That
    painful experience happened because someone was too lazy to do their job the right
    way. Personally, I’d rather do things right and keep my weekends free. When I
    write code, I am always explicit and intentional. It keeps me out of trouble.
    Always pay attention to your object’s state and write your code to guard against
    invalid states. Your constructors are the first line of defense. The second line
    of defense is encapsulation, which we’ll talk about shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Objects consist of state variables and functions capable of doing work on those
    state variables. This is a fancy way of saying an object is like a marriage between
    two common programming concepts: variables and functions. Classes are designed
    to represent real-world objects. Any object in the real world is defined by its
    descriptive properties. What color is it? Is it bigger than a breadbox? Physical
    objects are further defined by what they can do. A car can go, a dog can bark,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s focus on the objects’ descriptors. It’s easy to call them properties.
    A basketball has properties such as its circumference, its orange color, its black
    lines, and how much air it is holding. These are properties of the basketball.
    In C# classes, properties look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The word `public` is an access modifier. We described this earlier in the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Every property has a name. This property’s name is `Name`, and it is defined
    as a string.  The part that says `{ get; set; }` makes it an auto-implemented
    property, which is an easy form of encapsulation that I’ll explain later.
  prefs: []
  type: TYPE_NORMAL
- en: 'You access a property on an instantiated object using dot notation. For example,
    to set the `Name` property on a `Person` object, you instantiate and then set
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Access modifiers define the availability of properties, methods, and even classes
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Methods are functions attached to objects. Since C# is strictly object-oriented,
    we should probably always refer to them as methods rather than functions, but
    the words are effectively synonymous. Even the strongest adherent to OOP will
    occasionally slip and say *function*. With that out of the way, there are a few
    things to remember with respect to methods in C#. First, they follow the same
    rules as variables in that they are strongly typed. They need any arguments passed
    in to be typed as well as the return value to be typed. Like variables, the method
    names need to be unique within scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# uses C-like method signatures common to all C-based languages. A method
    signature consists of the parts of the method that define it as unique:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number and types of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the return value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding example, we have this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this method signature, we can see this method is public. It can be accessed
    by any class in our program. We can see that its name is `ToString` and that it
    takes no arguments. Furthermore, we can see this method is expected to return
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: This one has an extra keyword stuck between the access modifier and the return
    type. It says `override`. The `ToString()` method is on every object in C# because
    that method is in the Object base class. It is always inherited from the base
    class in every object you make. The base class implementation isn’t very useful.
    It is very common to override the function with something more useful. That is
    what’s happening in the preceding example. We’ve changed the implementation in
    the base class by overriding the implementation with our own. We do this in plenty
    of places within the projects covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This concept entails one of the most important aspects of OOP: the maintenance
    of the object’s state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, in *Figure A1.3*, I presented a circle with a set of properties with
    values that describe the circle you’re seeing. As your program runs, it’s likely
    those properties will change in response to events within that program. If you
    take a snapshot of that circle at any point in time during your program’s execution,
    you can talk about its current state. It’s currently sporting a radius of 200
    pixels, with a line color of black, and fill color of dark gray. Let’s create
    some code to represent our circle in the simplest way possible, without any encapsulation,
    so we can see it added later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, we create a `Circle` class, and within it, we define the fields
    based on our earlier discussion. Note that I did not say properties. Properties
    and fields are different in C#. Fields are simply member variables. These fields
    are wide open. Effectively, any other class can directly modify the fields at
    any time. Why is this bad? Remember, it’s all about guarding the state. It really
    doesn’t make sense to have a negative radius, which is why I used an unsigned
    short. Likewise, graphics coordinate systems on a computer are usually strictly
    positive, with 0,0 located in the upper-left corner of the screen. To that end,
    I used unsigned shorts here because we don’t need values beneath zero, and the
    upper value seems reasonable. So far, I’ve done everything right, except I haven’t
    guarded the state beyond limiting invalid values based on types.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine that you’re working on a program such as *Adobe Illustrator* or
    the open source program *Inkscape*. These programs deal with vector graphics,
    and they most definitely need a structure to handle a circle. Both programs are
    pretty big in terms of lines of code and the number of classes. I realize neither
    program is written in C#, but if they were, imagine all the different objects
    each program would have flying around at any given moment. If any one of them
    has the ability to, at any time, modify the properties of our circle object, finding
    and debugging odd behavior changes in the circle becomes nigh impossible. Usually,
    lack of encapsulation is caused by the cardinal sin of sloth, a lack of imagination,
    or both.
  prefs: []
  type: TYPE_NORMAL
- en: Our program could change any of these properties at any time. Encapsulation
    aims to prevent you from entering your object into an invalid state. For example,
    what if I try to specify a negative number for the radius? That doesn’t really
    make sense.
  prefs: []
  type: TYPE_NORMAL
- en: To protect our object from entering an invalid state, we can hide the properties
    behind access modifiers. Access modifiers are keywords that define “who or what”
    is allowed to make changes to an object’s state. In an ideal program, the object
    should always solely be in charge of its own state. A different object in the
    program shouldn’t be directly manipulating the radius. Aside from access problems,
    there’s nothing policing the type of data being passed in, other than our strongly
    typed variable system. To improve things, let’s start with the radius. Earlier,
    I mentioned that I thought `ushort` was an appropriate type because being unsigned,
    it doesn’t support negative values. Further, I think the next lowest unsigned
    type, byte, which tops out at 256, is too small. I can easily see needing the
    ability to make a circle larger than 256 pixels in diameter. But 65K is probably
    too big. Let’s say I want to limit the maximum radius to 1,000 pixels. This is
    probably smart because, in a large graphical composition, we might have thousands
    of circles and we should be thinking about our memory consumption. We can hide
    the radius field behind a special function that checks to see whether the radius
    you are setting is valid, in this case, a number between 0 and 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps at play here. First, you have to hide the radius with an
    access modifier. The most common access modifiers are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: Anything can access the property or method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: Only this object can access the property or method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected**: Only this object and its descendants can access the property
    or method. More on this after we talk about inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You’ll find these available in most object-oriented languages. C# has a few
    additional access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal**: Anything within the same assembly can access the property or
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected internal**: The property or method can only be accessed by code
    within the assembly wherein it was declared or from a subclass of the class where
    it was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private protected**: The property or method can be accessed by subclasses
    that are declared within the same assembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can visualize this using the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.8: Relative access levels by the caller’s location. ](img/B18605_Figure_A1.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.8: Relative access levels by the caller’s location.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to improving the `Circle` class. The first improvement we’ll
    make is adding a private access modifier to the radius field. I’ll also move `radius`
    to the top just so that it is easier to see for this discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The private access modifier tells us that only methods in “this particular
    object” are allowed to change the radius. That’s perfect, except now the radius
    field is totally hidden. There isn’t any way to set it from the outside, and we’ll,
    of course, need to do that at some point. Let’s change the access modifier to
    something more permissive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: OK. Now we’re back to where we started. The public access modifier means that
    anything can alter the radius. That’s not good! Dagnabbit!
  prefs: []
  type: TYPE_NORMAL
- en: 'We need private back, but we need it to be a little better. We need accessor
    methods to allow us to get and set the field’s value from outside this object,
    but in a manner we control. When I do this, I use a common convention of renaming
    the field so that it starts with an underscore. This is done so that we can easily
    remember it’s a private backing field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s add an accessor method that allows us to get the radius. The `get`
    method is commonly called a *getter*. We don’t need any restrictions on this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s deal with the real problem at hand, which is controlling how the
    radius is set. Another accessor method can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a `set` method, commonly called a *setter*, that can set the value.
    Note that its access modifier is public, which we just learned means anything
    can access it. This setter method contains code that checks to see whether the
    new radius conforms to the required range. If it does, it goes ahead and changes
    the radius to the new value. The object is now in command of its own state. You
    can’t just randomly set the value to an invalid number. You have to *ask* the
    object to change its radius value, and it doesn’t automatically say *OK* – it
    checks to make sure you didn’t pass something that doesn’t make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, accessor methods can be used to define a read-only property. By
    simply neglecting to create a public setter method, you limit the ability to set
    the value of the private field to other methods within this class.
  prefs: []
  type: TYPE_NORMAL
- en: C# auto-implemented properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re a C# veteran, you’re no doubt yelling at this book right now. Don’t
    do that. First, it makes you look crazy unless you have your earbuds in, then
    at least people around you will think you’re just yelling at your mother-in-law.
    Second, this book is very sensitive. You might hurt its feelings. I get it. The
    earlier example is definitely not how we usually make accessor methods in C# –
    at least not these days. Back when I was your age, gas was 35 cents per gallon,
    and that’s exactly how we did it. I like showing it to you that way because I
    think just throwing `int foo { get; set; }` at someone without explaining how
    it works is kind of mean, which is to say that’s how the average C# book might
    cover it. As we all know, *mean* is the average. Was that a math pun? Yes, I think
    it was.
  prefs: []
  type: TYPE_NORMAL
- en: Modern C# has a different syntax for defining properties predicated on the idea
    that most properties are really fields. But if you leave them as fields, your
    OOP professor will give you a B because you didn’t encapsulate them. We can’t
    have that. I could climb back up on my soapbox and decry their existence, but
    I have a page count I need to stay under, so let’s just see how they work and
    you can decide whether they are a good idea or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to say your class is fully encapsulated, but you don’t need any
    logic to control state, your code winds up with a lot of boilerplate code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a lot of code that doesn’t do anything. It only exists in the service
    of calling the class members *encapsulated*. In this case, there might not be
    a need to control the first and last name fields. I can’t think of any restrictions
    you might put on the kind of data, aside from it being a required field within
    a user interface. Let’s say the boilerplate is legitimate but we want to be modern
    and use auto-implemented properties. Your code can be reduced to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Auto-implemented properties allow you to use this shortened syntax if you don’t
    have logic to put in the getter and setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: Accessor logic with backing variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The real power of encapsulation happens when you use the accessor methods to
    control the state of your object. Your biggest job as a developer is making sure
    your object is incapable of entering into an invalid state. For example, take
    `Age`. A negative number in the age property doesn’t make sense. Neither does
    a billion years. The oldest human lifespan ever recorded that I know of was Methuselah,
    in the Old Testament, who live to be about 970 years old. Since there is no accessor
    logic, I can make the age 100 years or 1,000,000,000 years. If I want the controlling
    logic to limit the input values, I need to create something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a private backing variable called `_age`. We need this to hold
    the value since the property is now under the control of accessor logic. It is
    common to name private variables beginning with an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the logic. We don’t really need anything special on the getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The setter is where the magic happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then, we make the property with the auto-implemented method syntax, but this
    time, there’s more to it. Essentially, the syntax for the getter is a fat-arrow
    function that returns the `_age` backing variable. The setter is straightforward
    except for the value variable. Where does that come from? It’s magic. It’s part
    of the language for use in this scenario. It holds the value of whatever was passed
    into the setter.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# is a statically compiled language that supports a classical inheritance
    model. By statically compiled, I mean the structure of your objects can’t change
    unless you stop your running program, alter the source code for the class, recompile,
    and rerun. You can contrast C#’s static nature with a language designed to be
    dynamic: JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript breaks from a great many conventions, not the least of which is that
    it uses prototypes for inheritance instead of classes. For that matter, it doesn’t
    support encapsulation. It is based heavily on the idea of Lambda functions, which
    was also novel when JavaScript was invented. JavaScript uses lexical scope instead
    of the more conventional block scope we find in C#. In short, JavaScript is really
    weird when compared with C# if C# is the only language you know.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve established there’s more than one way to do inheritance, let’s
    switch back over to how it works in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose you are writing software to track the faculty and student body
    at a school, or university. You need to model a student class – maybe something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you need to model a `professor` class – maybe something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a problem here. There are a lot of properties that are redundant since
    they are used in both classes. OOAD would have us redesign these two classes by
    abstracting the common properties into a superclass. This leaves only those elements
    that are unique to the `Student` and `Professor` classes. The obvious targets
    for hoisting to the superclass are the following common properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FirstName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LastName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Courses`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less obvious targets for hoisting include the `AskParentsForMoney()` method
    in the student class and the `BegForResearchFunding()` method in the professor
    class. They effectively do the same thing. The only difference is who is being
    asked to part with cash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve dubbed the superclass `Person`. It has the common elements between the
    student and the professor. Now, let’s make the `Student` class inherit from the
    `Person` class. To signal inheritance, I’ll add a colon followed by the superclass
    on the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I’ll only keep the properties that aren’t defined in the superclass. There
    is just one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for methods. I only need those that are not in the superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I can do the same thing with the `Professor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, the class only contains the properties and methods unique to the `Professor`
    class. The common properties and methods are in the `Person` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The key to understanding inheritance is to vocalize the relationship between
    `Person`, `Student`, and `Professor`. We can say a `Student` *IS A* `Person` (debatable
    in their freshman and sophomore years), and we can say a `Professor` *IS A* `Person`
    (debatable after they get tenure). This vocalization both defines and illustrates
    the relationship between the superclass, sometimes called the parent class, and
    its descendants, called subclasses or children.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to a question: would it ever make sense to instantiate the `Person`
    class? The answer is no. `Person` is designed to be a parent class. It isn’t intended
    to be used directly. Classes that are not meant to be instantiated are called
    `Person` class was this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `abstract` keyword will prevent direct instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that inheritance is a vital part of your OOP toolbox. Inheritance
    is like eggs. It’s part of a balanced breakfast, but a really good breakfast has
    some fiber in it too. Let’s get some metaphorical fiber in our code by learning
    about interfaces. Interfaces do nothing to lessen your risk of heart disease like
    a good bowl of low-sugar oatmeal does. Using them might lower your stress levels
    later when you discover how flexible your code will be once you incorporate them,
    which is just as good. If you eat low-sugar oatmeal *and* use interfaces in your
    code, maybe you’ll give Elvis a run for his money in terms of lifespan.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **interface** defines all or part of the structure a class must take by defining
    the public method signatures and properties that must be present in the class.
    This is a powerful tool that allows you to create a specification for an object’s
    behavior. The power of interfaces is multiplied by the fact that you are not limited
    to implementing a single interface versus using subclassing where you are only
    allowed a single parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces serve to loosely define behavior or type. Here’s a shout-out to
    all the *Unity 3D* developers in the crowd: imagine creating a video game where
    the player battles zombies and ancient creatures conjured by the imagination of
    H.P. Lovecraft – oh, and cats because cats are scary. Each monster could have
    its own class. You could create an interface to define behaviors such as fighting,
    running, eating humans, and more. Such a video game might look like *Figure A1.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.9: A terrible video game design that masterfully uses interfaces
    to map behaviors to characters in the game. ](img/B18605_Figure_A1.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.9: A terrible video game design that masterfully uses interfaces
    to map behaviors to characters in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: With these interfaces, you could define behaviors on objects that don’t necessarily
    fit together in an inheritance chain and wind up with game code that is very easy
    to extend.
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit to interfaces versus inheritance is flexibility. In [*Chapter
    2*](B18605_02.xhtml#_idTextAnchor036), we learn about SOLID principles and we
    learn about techniques for avoiding tightly coupling your classes together. If
    you define a property on a class with a type of `Monster`, then only `Monster`
    or a subclass of `Monster` will work. Your class is tightly coupled to `Monster`.
    If you define it by an interface, such as `IEatHumans`, you can pass any object
    that implements the interface as long as all you need are the methods defined
    by that interface.
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Practically speaking, if next week the game director decides to add a new monster
    to the game, we don’t have to reshuffle our object hierarchy if the new monster
    doesn’t happen to fit the structure we’ve created. We just make a new class and
    use the interfaces to define its structure. Let’s code out what we have in *Figure
    A1.9* in C#, so we can see what this looks like in code instead of just a diagram.
    There are three interfaces used by the four characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IRun`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IFight`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IEatHumans`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start with the `IRun` interface. Making interfaces is pretty easy. All
    you need to do is specify the basics of the method signature – specifically, the
    return type, the name of the method, and the names and types of the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy. What we’ve done here is to specify that any class implementing
    this interface must have two methods, both of which have a `void` return type.
    One must be called `Jog()`, which takes no arguments, and the other must be called
    `Sprint()`, which also takes no arguments. If you’re using a good IDE, any class
    you create that implements an interface will mark your code with red squiggles
    until you meet all the requirements of the interfaces. Let’s do `IFight` next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`IFight` says any class that implements this interface must have a method called
    `Attack()`, which returns `void` and takes no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`IEatHumans` requires the implementing class to have a method called `Chomp()`,
    which takes no arguments and returns `void`. Interfaces are easy. Let’s look at
    how they’re used.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s make a class for `HelplessVictim`. The class implements the `IRun`
    interface. The syntax is the same as it is for inheritance. We use a colon to
    indicate the interface implementation, which would be the same if we were inheriting
    from a superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To satisfy the interface, we must implement two methods, `Jog()` and `Sprint()`,
    exactly as specified in the interface. That’s nice. What if we need to implement
    more than one interface? It’s not possible for a class to have two parent classes.
    C# mercifully doesn’t support multiple inheritance, which is the leading cause
    of clinical insanity among C++ programmers. However, classes can implement as
    many interfaces as you’d like. Let’s make the `AncientTerror` class, which implements
    three interfaces – `IRun`, `IFight`, and `IEatHumans`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`IRun` requires the same `Jog()` and `Sprint()` methods to be implemented.
    Note that it isn’t necessary to have the exact same implementation for the different
    classes. The instance methods simply have to conform to the interface. `IFight`
    requires the addition of a method called `Attack()`, which returns `void` and
    takes no arguments. `IEatHumans` requires us to add a `Chomp()` method per the
    interface.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll save the scariest monsters, the zombie and the house cat, as an exercise
    in the questions section at the end. Challenge yourself and see whether you can
    come up with the basic implementation for these remaining two classes!
  prefs: []
  type: TYPE_NORMAL
- en: IDEs for C# development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever I work in a new or unfamiliar language, the first thing I want to know
    about is the tools used to work in that language. Good tools make learning and
    working with the language much easier. Microsoft realized this, and when they
    released the C# language and the accompanying .NET runtime, they also released
    Visual Studio – an IDE written specifically for use with C# and another very popular
    programming language called Visual Basic.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Basic was Visual Studio’s predecessor. During the 1990s, Visual Basic
    was the most widely used development language product from Microsoft. The company
    also sold an IDE geared for C++ development called Visual C++, and briefly and
    ineffectively dabbled in Java with Visual J++. Of these toolkits, Visual Basic
    was by far the most important. At the time, Visual C++ was used by “serious” developers.
    Microsoft Windows is written in C and C++, so naturally, the tooling in Visual
    C++ was first and foremost designed to support that effort. Corporate software
    really became possible and mainstream with the BASIC language. In fact, the BASIC
    language formed the cornerstone of Microsoft itself. Bill Gates bought the rights
    for a BASIC compiler, and along with the **Microsoft Disk Operating System** (**MS-DOS**),
    he formed what would become one of the largest software companies in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Basic was designed by Alan Cooper. Cooper was a visionary. The Visual
    Basic UI was the first WYSIWYG design platform for computer software. Before the
    World Wide Web, we built software that ran solely on the desktop, and Visual Basic
    was the innovation that drove the industry.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that’s enough history. Today, there are three important IDEs I want to
    tell you about. Chances are you’ve used one of them already. These tools include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other IDEs out there, but these three are the most popular, complete,
    and frankly, important. If you use a Mac, it is worth mentioning that Visual Studio
    for Mac is not a port of Visual Studio. Earlier, I mentioned the open source version
    of C# called Mono. The team that developed Mono created an IDE called *Monodevelop*.
    It looks a lot like Apple’s X-Code IDE, and it was designed to allow Linux developers
    to write C# programs. *Monodevelop* was open source and was ultimately forked
    to become *Xamarin Studio*. *Xamarin Studio* is an IDE geared toward mobile development.
    Microsoft bought out Xamarin several years ago. A separate fork of the technology
    became Visual Studio for Mac. I mention it because it looks nothing like the IDEs
    we’ll be covering, so if you’re on a Mac, my screenshots won’t help much.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn patterns, you only need a fraction of the functionality these IDEs
    provide. In this section, I wanted to walk you through creating the two project
    types found in this book: the command-line project and the library project.'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line programs are the simplest programs you can make that will actually
    run. They have no user interface and are run from, you guessed it, the command
    line. Libraries are code projects used to house objects meant to be shared between
    projects. In [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063), I create a shared
    library that is used across many other chapters because they share a lot of the
    same code, as typing the same classes over and over would get very tedious.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at these IDEs starting with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio needs no further introduction. You can get a copy at [https://www.visualstudio.com](https://www.visualstudio.com).
    The IDE comes in three editions:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Professional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Enterprise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two are effectively identical except for how they are licensed. The
    Community Edition is free assuming you meet the licensing requirements. These
    things tend to change over time, so I’m not going to try to quote those requirements
    here. Review the Visual Studio website to see whether you qualify for a free license.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Professional is the paid version of the same tool. If you work
    for a company with a certain number of developers, or that makes a certain amount
    of revenue, you need to buy a subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise is a more expensive version of the paid editions and
    ships with a myriad of extra features not present in the Professional Edition.
  prefs: []
  type: TYPE_NORMAL
- en: Any of these editions will be fine for use with this book. I’ll be demonstrating
    the Community Edition, which, again, is indistinguishable from the Professional
    Edition.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a command-line project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having downloaded, installed, registered, and launched the IDE, you are greeted
    with a screen that looks something like *Figure A1.10:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.10: The opening screen for Visual Studio 2022\. ](img/B18605_Figure_A1.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.10: The opening screen for Visual Studio 2022.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Create a new project** button in the lower-right corner of the
    window. Doing this presents you with *Figure A1.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.11: Create a new project in Visual Studio using this dialog. ](img/B18605_Figure_A1.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.11: Create a new project in Visual Studio using this dialog.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re looking for the *Console App* project in C#. If you did a full install
    of Visual Studio, beware that the tool might show you Visual Basic projects as
    well as C#. Make sure you pick the C# version of the project template. Note that
    the icons on the templates denote the language they use, as shown in *Figure A1.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.12: Watch the icons on the project templates; it is easy to accidentally
    generate a new project in the wrong language. ](img/B18605_Figure_A1.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.12: Watch the icons on the project templates; it is easy to accidentally
    generate a new project in the wrong language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t see the **Console App** project template, you can search for it
    using the search dialog at the top, as shown in *Figure A.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.13: You can search for the console app template if you don’t see
    it listed. ](img/B18605_Figure_A1.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.13: You can search for the console app template if you don’t see
    it listed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Console App** template, and click on **Next** in the lower-right
    corner of the dialog. This takes you to a dialog titled **Configure your new project**,
    as shown in *Figure A1.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.14: Configuring your new project by giving it a name and location
    ](img/B18605_Figure_A1.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.14: Configuring your new project by giving it a name and location'
  prefs: []
  type: TYPE_NORMAL
- en: This dialog allows you to name your project and specify its location on your
    hard drives. You can also choose to name your solution differently than your project.
    A solution is a collection of projects bound into one set of files. This allows
    you to work on multiple related projects in a convenient way. Maybe you have a
    web application and a related command-line program that belong together. A solution
    allows you to store the related projects together. If you are storing related
    projects together, you might not want to name the solution the same as the project.
    For the exercises in this book, it doesn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to name the project `BicycleConsoleApp`. We’re going to name the
    solution `BicycleSolution`. Use a location on your computer that is convenient.
    The checkbox at the bottom specifies a folder structure. You can just leave it
    unchecked. Your project configuration should resemble *Figure A1.15*. Click on
    the **Next** button in the lower-right corner of the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.15: The Additional information dialog lets you set the framework
    for the project. ](img/B18605_Figure_A1.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.15: The Additional information dialog lets you set the framework
    for the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Additional information** dialog allows you to pick the .NET Framework
    type that you’ll use for development. The default at the time of this writing
    is **.NET 6.0 (Long-term support)**. Just accept the defaults as they are and
    click on the **Create** button. This will complete project creation, and you’ll
    see the full IDE, as shown in *Figure A1.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.16: The new project is created and ready in Visual Studio. ](img/B18605_Figure_A1.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.16: The new project is created and ready in Visual Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: Your project is ready! You can start developing your code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once your project has been created, you’ll be needing to add new classes. To
    add a class, right-click on the `BicycleConsoleApp` project, and you’ll find a
    context menu. Find the **Add** option and hover over it. A second menu expands.
    Find **Class...** at the bottom of the menu and click on it. You can see the menu
    layout in *Figure A1.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.17: The menu item for adding a class accessed from Solution Explorer
    in Visual Studio. ](img/B18605_Figure_A1.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.17: The menu item for adding a class accessed from Solution Explorer
    in Visual Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to specify what you wish to add using the dialog in *Figure
    A1.18*. In this case, we’re adding a class. Note there is also an option for adding
    an interface. You’ll need both, but right now, let’s focus on adding a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.18: The Add New Item dialog in Visual Studio can be used to add
    anything, including classes and interfaces. ](img/B18605_Figure_A1.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.18: The Add New Item dialog in Visual Studio can be used to add anything,
    including classes and interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Class**, then give the file a name that matches the name of the class
    you want to create. Usually, I honor the age-old Java convention of having one
    class per file. Click on the **Add** button, and the class will be created and
    added to your project.
  prefs: []
  type: TYPE_NORMAL
- en: To add an interface, follow the same procedure, but select **Interface** instead
    of **Class**. By convention, C# interfaces always start with the letter I (as
    in “Interface”), so name your file the same as what you plan to name your interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a library project to the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you created the command-line app project, Visual Studio also created a
    solution. Solutions are containers for projects. Even if you only have one project,
    it will be inside a solution. You can add more projects to the solution. This
    is a handy way of keeping related projects together.
  prefs: []
  type: TYPE_NORMAL
- en: Library projects are used to house reusable code designed to be accessible between
    projects. In *Chapters 3–5* of this book, I use a library for common classes like
    those that model the basic parts of the bicycle classes we’re building in those
    chapters. In the real world, you generally put your business logic in a library.
    When you do this, you can leverage that logic in a web application, a mobile application,
    and a desktop application without repeating your code in three places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a library project is easy. Right-click on the solution in the solution
    explorer. Locate the **Add** option, hover over it, and click on **New Project**.
    A new project dialog appears, as shown in *Figure A1.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.19: The context menu in Visual Studio used to add a new project
    to the solution. ](img/B18605_Figure_A1.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.19: The context menu in Visual Studio used to add a new project to
    the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `Library` into the search box at the top of the dialog. Make sure
    the class library template is using the C# language and not some other language
    such as Visual Basic or F#. Click on the `BicycleLibrary`. The location should
    be defaulting to the location of the solution and, by extension, the console app
    project we just made. Click on the **Next** button.
  prefs: []
  type: TYPE_NORMAL
- en: The next dialog allows you to select the .NET runtime for your project. Generally,
    you want these to match. We picked .NET 6.0 for the console app, so we should
    pick the same thing here. Click on the **Create** button, and Visual Studio will
    generate the project’s files for you.
  prefs: []
  type: TYPE_NORMAL
- en: Linking the library project to the console project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you can use the library, you must create a reference to it in the `BicycleConsoleApp`
    project. To create the reference, right-click on the **Dependencies** option in
    the console app, and then click on **Add Project Reference**. This reveals a dialog,
    as shown in *Figure A1.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.20: The menu used to add project dependencies to a project in Visual
    Studio. ](img/B18605_Figure_A1.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.20: The menu used to add project dependencies to a project in Visual
    Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Projects** option is at the top of the dialog and is probably already
    selected. You should see the name of your library project in the list. Click on
    the checkbox next to the library project you just made, and then click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: Your library is now available within your console app project.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing the library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you created the library project, Visual Studio created a file called `Class1.cs`.
    Let’s add a method to that class and then see how to reference it in the console
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Class1.cs` file in the class library project. Add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Save the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `Program.cs` file in the console app project. You should see
    a “Hello World” program. Replace the starter code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that as you type the code (type it, don’t copy and paste – copy and paste
    teaches you nothing!), you’ll find that IntelliSense is giving you hints on the
    method you added in the library. Effectively, you are using the code in the library
    as if it were part of the console app project!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s just one thing left to do: build the project.'
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the console project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# applications are compiled. If you’re used to an interpreted language such
    as JavaScript or Python, you might not be familiar with this step. The C# compiler,
    code-named `foo`, where `foo` is any given object, an augmented text editor will
    probably give you every possible option that could come after that dot. Really
    good editors might use probability or AI to narrow the field. Visual Studio only
    shows you viable options based on introspection. The latest versions of Visual
    Studio are starting to include AI features. When AI is combined with IntelliSense,
    the results are frightening. You can expect Visual Studio to write entire blocks
    of code for you, not just boilerplate; the actual methods in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Better code hints and early warnings about code mistakes are among the benefits
    of working with compiled languages. The compiler doesn’t allow the most common
    types of mistakes, so you find and fix them early because you must. The product
    of a compiled language is also generally faster in terms of execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building in Visual Studio is very simple, and there are a few ways to do it.
    The most straightforward is to run your program. To do this, just click on the
    green arrow in the toolbar. *Figure A1.21* shows the location of the **Run** button.
    Unfortunately, *Figure A1.21* isn’t in color. The book editor’s bosses muttered
    something about budgets and money not growing on trees. I haven’t met the boss
    of bosses at Packt, but I suspect they used to hang out with my father (God rest
    his soul) *A LOT*. The good news is you really can’t miss it in the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.21: Locate the green triangle in the IDE; this is the Run button.
    ](img/B18605_Figure_A1.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.21: Locate the green triangle in the IDE; this is the Run button.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the **Run** button, your program builds, and it is then executed
    with an attached debugger. You’ll see your running program, as shown in *Figure
    A1.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.22: The program runs in a window. ](img/B18605_Figure_A1.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.22: The program runs in a window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the program, press your computer’s *Any* key in the running console
    app window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.23: Press the Any key to exit Visual Studio’s program run; if your
    computer doesn’t have an Any key like mine, you can use the spacebar. ](img/B18605_Figure_A1.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.23: Press the Any key to exit Visual Studio’s program run; if your
    computer doesn’t have an Any key like mine, you can use the spacebar.'
  prefs: []
  type: TYPE_NORMAL
- en: The *Any* key is common on older keyboards. It does limit your ability to write
    code using the letter *H*. Since I live in Texas, I just use *J* instead. It’s
    a small price to pay for being able to quickly exit from your running programs.
  prefs: []
  type: TYPE_NORMAL
- en: If your computer doesn’t have an *Any* key, just press the spacebar. Note that
    the pause message isn’t part of your program, and it won’t be there if you publish
    your application. This is Visual Studio pausing the application. Console apps
    tend to run and exit in under a second. If something goes wrong, the program will
    finish, display an error, then kill the window before you have a chance to see
    anything. So, Visual Studio does you a solid and freezes the window before the
    program exits so that you can inspect it. Your program should have run without
    any errors.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief tour of Visual Studio. If you’re interested in a video
    walk-through that coaches you through setting up a Visual Studio development environment
    in Windows, you’ll find links for this at [https://csharppatterns.dev](https://csharppatterns.dev).
  prefs: []
  type: TYPE_NORMAL
- en: VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'VS Code bears a similar name to Visual Studio but is an entirely different
    beast. Rather than being a full-fledged IDE, VS Code is really an augmented text
    editor rather than a true IDE. We just covered Microsoft’s Gold Standard for editing
    tools. Why should I even talk about VS Code? The answer: VS Code currently has
    over 50% of the market share, making it the most popular tool used by most developers
    every day. There are some good reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: VS Code takes a fraction of the space as Visual Studio, which all-in requires
    nearly 45 GB of space. You can reduce the footprint of Visual Studio, but VS Code
    is still going to boast a smaller footprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code launches very quickly. Visual Studio doesn’t. You can use VS Code to
    quickly look at a repository you pulled off GitHub or some folder a colleague
    shared with you. Launching Visual Studio is a commitment. If you’re on a less
    powerful computer, you can likely catch up on your emails, take a quick peek at
    social media, get some coffee, and call your mother before you get the IDE’s opening
    screen. By the way, call your mother! She misses you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code works with nearly any programming language. Naturally, it works well
    with Microsoft-supported languages and other popular languages such as Golang
    or Rust. Also, you’ll find extensions that allow you to use it with oddball languages.
    The original GoF book used the SmallTalk programming language, which is offered
    by two extension vendors. You can find Ada, Haskell, and many more. Visual Studio
    is mainly used for mainstream work in Microsoft language products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code has a consistent user experience across all operating systems. Visual
    Studio is a Windows-only program. It won’t run in Linux. Visual Studio Mac is
    a completely different program and looks nothing like the Windows version. This
    consistency makes the tool a popular choice for schools, universities, and code
    boot camps like the one I teach at Southern Methodist University.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code has a lot going for it. Like Visual Studio, VS Code can also be downloaded
    at [https://www.visualstudio.com](https://www.visualstudio.com).
  prefs: []
  type: TYPE_NORMAL
- en: If VS Code is going to be your editor of choice, you’re going to need to install
    the .NET Core SDK to give you the tools and compilers to work with C#.
  prefs: []
  type: TYPE_NORMAL
- en: Installing .NET Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need the .NET Core SDK if you are going to work with VS Code. You can download
    it from [https://dotnet.microsoft.com/en-us/download](https://dotnet.microsoft.com/en-us/download).
    Naturally, that web address might change after this book is published, in which
    case you’ll have to be resourceful. Installing it is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: With VS Code and .NET Core SDK installed, you’re ready to get started. If you
    read the steps for setting up a project in Visual Studio, the steps for VS Code
    are very different.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual Studio creates a project and a solution in one step. This is VS Code.
    Each step is performed separately, and it is all done from the command line. Technically
    speaking, VS Code isn’t really involved. You use the `dotnet` command-line tool
    that was installed when you installed the .NET Core SDK. You can do all of this
    in Windows Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Windows Terminal comes with Windows 11, there is nothing further to install.
    If you’ve never used it, click on `Terminal`, as shown in *Figure A1.24*. Launch
    the app. If you’re still using Windows 10, search for `PowerShell` instead of
    `Terminal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.24: Most of the project setup work with VS Code happens in the
    Terminal window. ](img/B18605_Figure_A1.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.24: Most of the project setup work with VS Code happens in the Terminal
    window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Terminal (or PowerShell) open, type this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `-o` is for *output*. This tells the command to create a folder for the
    solution. In addition to creating the folder, the command generates a set of files
    in the `BicycleSolution` folder. Let’s take a look. Type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, type in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dir` (directory) command will list all the files in the current working
    directory. You should see something like *Figure A1.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.25: The result of our new solution command. ](img/B18605_Figure_A1.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.25: The result of our new solution command.'
  prefs: []
  type: TYPE_NORMAL
- en: We have a solution, but there’s nothing in it. We need some projects to make
    the solution useful.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a command-line project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll add a console application to the current solution folder. First,
    `cd` into the `BicycleSolution` folder. Going forward, the commands I’m giving
    you are based on the assumption that your present working directory is the `BicycleSolution`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the console app to the solution, type this command into the Terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new console app. Again, `-o` is for output. This tells the command
    what to call the project. The `dotnet` command generates the boilerplate files
    for the console app project, as shown in *Figure A1.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.27: Our command generated your file structure for the command-line
    project. ](img/B18605_Figure_A1.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.27: Our command generated your file structure for the command-line
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the app created, you need to add it to your solution using this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command can be seen in *Figure A1.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.28: The console app was successfully added to the solution. ](img/B18605_Figure_A1.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.28: The console app was successfully added to the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: There won’t be a visible change to the folder structure. The command alters
    the `BicycleSolution.sln` file to include the `BicycleConsoleApp` project. Your
    command-line project is ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a library project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Library projects are used to house reusable code designed to be accessible between
    projects. In *Chapters 3–5* of this book, I use a library for common classes like
    those that model the basic parts of the bicycle classes we’re building in those
    chapters. In the real world, you generally put your business logic in a library.
    When you do this, you can leverage that logic in a web application, a mobile application,
    and a desktop application without repeating your code in three places.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a library project in your solution folder, type the following command
    into your Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, the command creates a new project within the current solution. The
    `-o` switch tells the command what to name the output, which, in this case, is
    the name of the library project. Having created the library project, you need
    to add the project to your solution using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `dir` command to confirm that your folder structure looks like mine
    in *Figure A1.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.29: The project structure after creating the solution, the console
    app, and the library project. ](img/B18605_Figure_A1.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.29: The project structure after creating the solution, the console
    app, and the library project.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the library project, you need to set up a reference between
    the console app and the library project.
  prefs: []
  type: TYPE_NORMAL
- en: Linking the library to the console project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To link the console project to the library project, type in this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The library is linked to the console app project. We’ve spent a lot of time
    in the Terminal window. It’s time to start working in VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Launching VS Code and adding the C# extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding a class or an interface is easy in VS Code. You can launch VS Code from
    the Terminal window we’ve been using by typing in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You read it correctly: type in `code`, add a space and a period, and then press
    *Enter*. This command launches VS Code with the solution folder loaded. You’ll
    be greeted by your usual security warning, as shown in *Figure A1.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.30: Do you trust the files you just made? ](img/B18605_Figure_A1.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.30: Do you trust the files you just made?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you trust your own work, click on **Yes**. If you don’t, briefly close
    this book and ponder deeply on this. Consider whether it’s better to live in a
    beautiful boring secure world where no harm will ever come to you; a world filled
    with beautiful flowers whose aroma reminds you of only the best moments of your
    life. Or would you rather live in a world filled with high adventure and the possibility
    of total ruin? Pirate ships are safe hiding in port. But they are not meant to
    stay there! This is your moment! Go for it! Click on the **Yes, I trust the authors**
    button! I promise that if you do, you’ll turn a corner in your life. Grow a spine
    already and click on the button! Side note: my attorney wants me to remind you
    the author is not responsible for malware, computer damage, damage to your reputation,
    or pirate attacks resulting from clicking on this button.'
  prefs: []
  type: TYPE_NORMAL
- en: With your personal issues resolved, if you had them, let’s continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have mentioned that VS Code isn’t considered a full-fledged IDE. It is meant
    as a general-purpose coding tool and doesn’t assume anything about how you will
    use it. As such, VS Code doesn’t come with C# support baked in. Naturally, Microsoft
    has a plugin to help you with C#. You’ll probably be prompted to install the plugin
    as soon as the project opens. In case you aren’t, you can install it by following
    the steps shown in *Figure A1.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.30: Microsoft makes a free extension for VS Code that makes working
    with C# more enjoyable. ](img/B18605_Figure_A1.27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.30: Microsoft makes a free extension for VS Code that makes working
    with C# more enjoyable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, click on the **Extensions** button in the menu on the left-hand side
    of the interface (1). Then, search for this extension in the search bar (2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will narrow the list to a single extension. Click on it, and then click
    on the install button. VS Code is now fully aware of the C# language and the structure
    of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a class or interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Right-click on the `BicycleConsoleApp` folder in the explorer view and click
    on **New File**, as shown in *Figure A1.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.31: Right-click on the explorer area, and click on New File to
    create a new file. ](img/B18605_Figure_A1.28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.31: Right-click on the explorer area, and click on New File to create
    a new file.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you click on `.cs` extension. For example, I’m calling my file `Class1.cs`.
    If you’re creating an interface, it is standard practice to begin the filename
    with a capital I (as in “Interface”).
  prefs: []
  type: TYPE_NORMAL
- en: Adding code to the BicycleLibrary project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s add a method to the `BicycleLibrary` project so that we can verify it
    is linked and working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `Class1.cs` file in the `BicycleLibrary` project. This file was generated
    for you when you created the project. Click on the file, and it will open in the
    editor. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to save the file! Compare your project with mine, as shown in *Figure
    A1.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure S1.32: The library code has been added to Class1.cs in the BicycleLibrary
    project. ](img/B18605_Figure_A1.29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure S1.32: The library code has been added to Class1.cs in the BicycleLibrary
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s switch to the `Program.cs` file in the `BicycleConsoleApp` project.
    Replace the line `dotnet` generated with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you type, IntelliSense will show you the library method we added to the
    `BicycleLibrary` project as if it was within the `BicycleConsoleApp` project.
    Check your work against *Figure A1.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.33: The updated Program.cs file with our test code. ](img/B18605_Figure_A1.30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.33: The updated Program.cs file with our test code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our mission has been accomplished! There is just one thing left to do: build
    the project.'
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the console project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could switch back to our Terminal window, but VS Code has an integrated Terminal
    window. Using it is more convenient than constantly switching windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate it, use the keyboard shortcut *Ctrl* + *`* (control + backtick).
    Additionally, you can click on **View** and then **Terminal** from the main menu,
    as shown in *Figure A1.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.34: You can open the integrated Terminal window in VS Code using
    this menu item, or Ctrl + ` as a keyboard shortcut. ](img/B18605_Figure_A1.31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.34: You can open the integrated Terminal window in VS Code using
    this menu item, or Ctrl + ` as a keyboard shortcut.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the project will build the project and then execute the `BicycleConsoleApp`
    project’s executable file, which consists of the code in the `Program.cs` file.
    To run the program in the Terminal window, enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see the program being built, and the command-line project will run.
    You should see the “Hello from the Bicycle Library!” message in the Terminal window
    just like you see it in *Figure A1.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.35: This is the result of our test run. ](img/B18605_Figure_A1.32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.35: This is the result of our test run.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief tour of VS Code. If you’re interested in a video walk-through
    that coaches you through setting up a VS Code development environment in Windows,
    you’ll find links for this at [https://csharppatterns.dev](https://csharppatterns.dev).
  prefs: []
  type: TYPE_NORMAL
- en: Rider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JetBrains Rider is the most recent addition to the world of C# IDEs. JetBrains
    is known for making amazing IDEs for Java (*IntelliJ Idea*), Python (*Pycharm*),
    PHP (*PHPStorm*), and JavaScript (*WebStorm*) among others. They also built Google’s
    IDE for Android Development, *Android Studio*. In addition to IDEs, the company
    has a very popular add-in product for Visual Studio called *Resharper*. The tools
    in *Resharper* give you many similar features you’ll find in *Visual Studio Enterprise*
    at a fraction of the cost.
  prefs: []
  type: TYPE_NORMAL
- en: I used Rider to create this book, mainly because of the code formatting and
    refactoring tools available in the program. Also, I use several of their other
    IDEs regularly, and I have my keyboard shortcuts configured to be common in every
    language IDE I use. This is purely a personal preference. I knew I could produce
    this book more quickly with Rider.
  prefs: []
  type: TYPE_NORMAL
- en: Rider is not a free product. There is a lower-cost version available for solo
    developers, and the same product is sold at a higher rate for use in companies.
    Check out [https://www.jetbrains.com/rider](https://www.jetbrains.com/rider) for
    more information if you’re interested in using this tool.
  prefs: []
  type: TYPE_NORMAL
- en: Since I used Rider to create the book, I think it would be strange if I didn’t
    at least show you around. Let’s do this exercise one more time using Rider.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a command-line project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you launch Rider, you are greeted with the **Welcome** screen dialog.
    Click on the **New Project** button in the upper-right portion of the dialog box,
    as shown in *Figure A1.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.36: The welcoming screen in Rider with the New Project button highlighted.
    ](img/B18605_Figure_A1.33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.36: The welcoming screen in Rider with the New Project button highlighted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the button gives you another dialog, as shown in *Figure A1.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.37: Project creation in Rider. ](img/B18605_Figure_A1.34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.37: Project creation in Rider.'
  prefs: []
  type: TYPE_NORMAL
- en: With Rider, everything is on one screen. Find the `BicycleSolution` and `ProjectName`
    to `BicycleConsoleApp`. Click on the **Create** button and your project will be
    generated. The full IDE will appear, and you’ll find your project hierarchy in
    the explorer panel on the left-hand side of the IDE window.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a class or interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a class is the same as it is in the other two IDEs we’ve talked about
    so far. Right-click on the `BicycleSolution` project. A context menu appears,
    as shown in *Figure A1.38:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.38: The ability to add a class or interface to your project can
    be found in the context menu when you right-click on the project. ](img/B18605_Figure_A1.35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.38: The ability to add a class or interface to your project can be
    found in the context menu when you right-click on the project.'
  prefs: []
  type: TYPE_NORMAL
- en: Hover over the **Add** menu item, and then find **Class/Interface** in the sub-menu.
    Click on it. You will see a small dialog asking you to name the class or interface.
    There are a few more possibilities evident in the list, but this book is only
    concerned with classes and interfaces. Choose the **Class** option and name your
    class whatever you would like. As soon as you press *Enter*, you’ll see the class
    file added to your project.
  prefs: []
  type: TYPE_NORMAL
- en: When you need an interface, follow the same procedure, but instead of **Class**,
    select **Interface**. Don’t forget that in C#, the name convention for interfaces
    stipulates naming the interface starting with the letter I (as in “Interface”).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at adding a library project to our solution so that we can
    maximize code reuse between projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a library project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Library projects are used to house reusable code designed to be accessible between
    projects. In *Chapters 3–5* of this book, I use a library for common classes like
    those that model the basic parts of the bicycle classes we’re building in those
    chapters. In the real world, you generally put your business logic in a library.
    When you do this, you can leverage that logic in a web application, a mobile application,
    and a desktop application without repeating your code in three places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `BicycleSolution` in the explorer menu. Hover over the **Add**
    option and select **New Project...**. You can see this in *Figure A1.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.39: Adding a project to the solution in Rider is done by right-clicking
    on the solution, then hovering over Add, and then clicking on New Project. ](img/B18605_Figure_A1.36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.39: Adding a project to the solution in Rider is done by right-clicking
    on the solution, then hovering over Add, and then clicking on New Project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You get the same project dialog we started with. Locate the `BicycleLibrary`.
    Your project should match mine, as shown in *Figure A1.40*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.40: Set up your new library project as shown. ](img/B18605_Figure_A1.37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.40: Set up your new library project as shown.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Create** button, and you’ll find a new project added to the
    solution. Your explorer pane should look something like *Figure A1.41*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.41: The explorer pane shows both projects in our solution. ](img/B18605_Figure_A1.38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.41: The explorer pane shows both projects in our solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can use the library in our console app project, we need to link the
    two projects with a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Linking the library project to the console project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the explorer pane, locate the `BicycleConsoleApp` project and right-click
    on the `Dependencies` item in the project hierarchy. A context menu appears, as
    shown in *Figure A1.42*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.42: The context menu is displayed when you  right-click on the
    Dependencies item in the explorer pane. ](img/B18605_Figure_A1.39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.42: The context menu is displayed when you right-click on the Dependencies
    item in the explorer pane.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Add Reference**. A dialog appears like the one in *Figure A1.43*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.43: The Add Reference dialog in Rider. ](img/B18605_Figure_A1.40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.43: The Add Reference dialog in Rider.'
  prefs: []
  type: TYPE_NORMAL
- en: You should see the library project listed. Check the box next to the library,
    and then click on **Add**. You can now reference the library project from your
    console app project. Let’s try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the linked library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the `Class1.cs` file in the `BicycleLibrary` project. Add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That’s the third time I’ve typed in the same code. Thank goodness the English
    language doesn’t require authors to be DRY.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `Program1.cs` file in the `BicycleConsoleApp` project. Change
    the code in that file to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you type the code, you should see the code hints showing you that you have
    access to the library. Once the code has been entered, we’re ready to run a test.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the console project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with Visual Studio, you’re looking for a big green arrow that indicates the
    **Run** button in the toolbar. You can see this button highlighted, alas, not
    in color, in *Figure A1.44*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the **Run** button, your project builds and runs with an
    attached debugger just as it does in Visual Studio. Unlike Visual Studio, your
    program runs within Rider’s integrated Terminal just like it did in VS Code. You
    can see the result of my run in *Figure A1.44*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.44: The completed run of our test program in Rider; the Terminal
    window has been pointed out. ](img/B18605_Figure_A1.41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A1.44: The completed run of our test program in Rider; the Terminal
    window has been pointed out.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief tour of *Rider*. If you’re interested in a video walk-through
    that coaches you through setting up a *Rider* development environment in Windows,
    you’ll find links at [https://csharppatterns.dev](https://csharppatterns.dev).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix was meant to be a short summary of working with C#. I almost didn’t
    include it in the book. There are many other places you can get training and orientation
    for the language. I felt, though, having taught C# for decades that I might be
    able to more concisely, yet thoroughly, get you up to speed if you’re coming from
    a different language, have limited experience with C#, or if it’s been a while
    and you’re a little rusty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the way, we learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: C# is a standardized general-purpose, strictly OOP language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# uses a strong, static type system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# is designed with features designed to limit the most common problems found
    in C and C++ development such as bounds checking, effortless memory allocation,
    and automated garbage collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# supports many different kinds of numeric types, including signed and unsigned
    variants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make auto-implemented properties and methods and work with encapsulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the basic building blocks of OOP in C#, including inheritance and
    working with interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end of all that we were treated to a basic tutorial on the three most
    popular IDE choices for C#: Visual Studio, VS Code, and Rider. I called this appendix
    concise. I wouldn’t call it short, but consider the size of most C# books that
    only orient you in Visual Studio, and I think you’ll agree this is a bargain.
    If you have found yourself wanting more, head over to [https://csharppatterns.dev](https://csharppatterns.dev)
    where I have links to additional resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*C# Object-Oriented Programming for Beginners in C# and .NET* by Praveenkumar
    Bouna.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Visual Studio Code for C# Developers* by Praveenkumar Bouna.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Visual Studio 2022* by Hector Uriel Perez Rojas and Miguel Angel
    Teheran Garcia.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://csharppatterns.dev](https://csharppatterns.dev) has links to additional
    resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Appendix 2: A Primer on the Unified Modeling Language (UML)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don’t have to look hard to realize that designing software is a lot like
    designing anything else. In [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016), *There’s
    a Big Ball of Mud on Your Plate of Spaghetti*, we talked about the underpinning
    of software patterns coming from a pioneer in the field of architecture – not
    software architecture, but the traditions, engineering, and design practices involved
    in the architecture of buildings and cities. In 1977, Christopher Alexander documented
    a pattern language designed to form the basis for the best practices for building
    towns. His book described 253 patterns that were presented as the paragon of architectural
    design. The book broke everything down into objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-Oriented Analysis and Design** (**OOAD**), a practice that is adjunctive
    to **Object-Oriented Programming** (**OOP**), involves the design of an object
    structure separate from the exercise of writing code. This is usually the job
    of a software architect or a senior developer. Software architects are similar
    to architects of buildings: they design the structure of an application. This
    can be done before the implementation team, which is the team that is going to
    build what the architect designs, picks the programming language for a project.'
  prefs: []
  type: TYPE_NORMAL
- en: OOAD makes use of a set of documentation conventions codified as the **Unified
    Modeling Language** (**UML**). It sounds like a programming language, but it isn’t.
    Instead, it is a standard for creating diagrams that explains the structure and
    relationships between components in a software system.
  prefs: []
  type: TYPE_NORMAL
- en: Think of it this way. If you are a musical composer, you can write your notes
    in a musical score. You can do this without ever touching an instrument. If you
    are skillful in composition, you can write entire orchestral works on paper using
    sheet music notation. You can then hand your sheet music to an orchestra and a
    conductor, and assuming the orchestra comprises competent musicians, they should
    be able to play your music. Architects are like composers. Programmers are musicians,
    and the team lead or lead developer is the conductor.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, UML class diagrams are used to convey the structure of
    the pattern code to be implemented in our real-world projects. If you’ve never
    worked with the UML before, you’re going to need a short primer. This appendix
    is designed to be that primer. It isn’t a substitute for a graduate-level OOAD
    course, or even for reading a whole book on UML. I’m just going to cover the diagram
    conventions for the one type of diagram we use throughout the book so that you
    can understand the diagrams, and how they are converted to code.
  prefs: []
  type: TYPE_NORMAL
- en: Again, UML isn’t a coding language; it’s a specification for diagramming your
    code. There are 14 types of diagram in the UML 2.5 specification. We only need
    one; the most common among the different diagrams is the *class diagram*.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many tools for drawing UML diagrams, and although I have presented
    many such diagrams, I’ve taken the tool used to make them for granted. In the
    real world, this exercise often happens on a whiteboard. A whiteboard is fine
    for ephemeral drawings that get erased later. For this book, my diagrams need
    to be a bit more permanent, so here’s what I’m using:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer running the **Windows** operating system. I’m using **Windows 10**.
    Honestly, this doesn’t matter, since diagramming tools are plentiful for all operating
    systems, and there are many that will work in your browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A diagramming tool. I’m using **Microsoft Visio**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are quite a few UML tools on the market. Here is a short list of tools
    I’ve used over the years:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft Visio**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StarUML**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Altova UModel**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dia**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Umbrello**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Umlet**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Omnigraffle** (**Mac** only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more on the web. I tend to prefer apps that run on my computer
    versus browser-based solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class diagrams consist of several types of structures, and a set of connecting
    lines that express the relationship between the structures. The structures are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A class (obviously)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages (expanded and collapsed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Connecting lines between the structures show how those structures are related.
    The relationships we can express include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface realization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directed association
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last possible element on a UML diagram are the notes. Notes are just what
    you think they are. Sometimes, an architect needs to add a little more information
    than what the standard UML allows. Notes let you do that. You shouldn’t use them
    to write an epistle. Short notes in implementation logic are what you see most
    commonly.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the patterns in this book, you need to understand class diagrams.
    Every pattern in this book is expressed with at least one UML diagram. The most
    important patterns are covered with two diagrams each.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the parts of a UML diagram. They aren’t that hard to decipher
    once you realize the meaning of all the diagram’s pieces. Let’s start with the
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class diagram is a visual representation of an object’s class. Let’s say
    our program requires us to model a circle like the one in *Figure A2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.1: This is not a UML diagram of a circle.  ](img/B18605_Figure_A2.01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.1: This is not a UML diagram of a circle.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to model this in UML, the class diagram would look like *Figure A2.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.2: This is an example of a UML diagram. The class name, Circle,
    is at the top, followed by a list of properties, a dividing line, and a list of
    methods. The + indicates that they’re all public.  ](img/B18605_Figure_A2.02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.2: This is an example of a UML diagram. The class name, Circle, is
    at the top, followed by a list of properties, a dividing line, and a list of methods.
    The + indicates that they’re all public.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s not too difficult, right? It is a box split into three sections.
  prefs: []
  type: TYPE_NORMAL
- en: The top section contains the name of the class. The class is simply the codified
    version of what I put in my UML diagram. Understanding these details is central
    to the coverage in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)*, Getting Creative
    with Creational Patterns,* of creation patterns. These are patterns that revolve
    around object creation.
  prefs: []
  type: TYPE_NORMAL
- en: The middle box in *Figure A2.2* contains a list of the properties that are members
    of the class. Note they do not have types. Some people put types in the diagram.
    I was taught not to because that is an implementation detail. The architect simply
    designs; they don’t constrain the builder any more than necessary. The programmer
    that implements the diagram picks the types. If it happens that you are the architect
    and the developer, feel free to specify the types if that is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Beneath the list of properties, we draw a line to separate the properties section
    from the next section. Visio made this a dashed line for my drawings. The dashed
    line has no significance. It can be solid or whatever line style that appeals
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom box in *Figure A2.2* is a list of methods. It doesn’t include details
    on how to implement the methods, or what they do – just the names, and any arguments.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed there are `+` signs in the diagrams. These refer to your
    access modifiers. As with types, some architects put them in and some don’t. Others
    put them in when it is vitally important – when the class just won’t work unless
    that detail is honored. I succumbed to the temptation to make a cute diagram to
    show you what the access modifiers look like in *Figure A2.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.3: Access modifiers.  ](img/B18605_Figure_A2.03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.3: Access modifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: The plus sign (`internal`, but they are unique to C#, so UML won’t have a symbol
    for them. If you don’t understand these access modifiers, refer to [*Appendix
    1*](B18605_Appendix_1.xhtml#_idTextAnchor178).
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! UML class diagrams are very simple in nature. We’re not done yet
    though. UML diagrams can show different levels of detail. This really depends
    on your preferences and the audience for your diagrams. When I studied OOAD in
    graduate school, my instructor wanted me to put as few implementation details
    in the diagram as I could. This habit has stuck with me. I’ve seen other people
    diagram everything to the smallest detail. I’ve never been one for micromanaging,
    so I’m going to stick with leaving as much as possible up to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Abstract classes are classes we aren’t allowed to instantiate directly. You
    can only instantiate subclasses of an abstract class. Diagramming them requires
    one tiny change to the diagram. Here’s an example in *Figure A2.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.4: When diagramming abstract classes, type the name of the class
    in italics.  ](img/B18605_Figure_A2.04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.4: When diagramming abstract classes, type the name of the class
    in italics.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the `Shape` class is abstract and the `Circle` class is
    not. To specify a class as abstract, you need to type the name of the class in
    the top box in italics. Watch out for this! Sometimes, it can be hard to see,
    especially if your diagramming tool uses a cute font that makes italics difficult
    to spot.
  prefs: []
  type: TYPE_NORMAL
- en: Diagramming required types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are times when you absolutely must define a property type, method argument,
    or return type because the implementation absolutely requires it. In those cases,
    you can specify the types in a diagram, as I have in *Figure A2.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.5: You can specify particular types using a colon followed by the
    type.  ](img/B18605_Figure_A2.05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.5: You can specify particular types using a colon followed by the
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Image` class has a property here that absolutely must be of type `Shape`.
    It’s represented with a colon separating the property name and its type. Likewise,
    I can specify a return type for a method. The `Image` class has a method called
    `GetCircle()` that must return `Circle`. It is similarly specified with a colon
    and the type after the method signature is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A constructor is a special method that is called when an object is instantiated.
    [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178) covers this in detail
    if you’re not sure what I mean. A constructor must have the same name as the class
    where it is defined. For a lot of people, just seeing a method with the same name
    as the class is enough. It can also be drawn more formally, as shown in *Figure
    A2.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.6: Constructors in a UML diagram are difficult to miss.  ](img/B18605_Figure_A2.06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.6: Constructors in a UML diagram are difficult to miss.'
  prefs: []
  type: TYPE_NORMAL
- en: You can’t miss it. It’s the method with the obnoxious `<<constructor>>` in front
    of it. Since obnoxious things are very pedagogical, this is the convention I’ll
    be using.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t diagram every tiny detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the world of web design, designers use a trick when dealing with their clients
    that has been around for centuries. When working with initial designs, the objective
    is to get the layout right and not focus on copy. The difficulty arises when you
    try to put fake copy in a web page design. Your clients will focus on what the
    copy says, and they’ll try to word-smith the text on the page. The objective is
    to get buy-in on the design, but that can’t happen because all the stakeholders
    are wrapped up in what the placeholder text says.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around this, designers use *lorem ipsum* text. *Lorem ipsum* are words
    from a famous book on ethics attributed to the Roman statesman and poet Marcus
    Tullius Cicero. The text looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: “Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
    incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud
    exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute
    irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
    pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia
    deserunt mollit anim id est laborum.”
  prefs: []
  type: TYPE_NORMAL
- en: This text is placed in a design draft as a placeholder for the actual copy.
    Since the text is unintelligible, anyone looking at the design with this text
    in place isn’t tempted to critique the content. They focus on the design.
  prefs: []
  type: TYPE_NORMAL
- en: In UML, when you want to do this, you can use empty, or nearly empty, classes
    to encourage stakeholders, namely the developers, to focus on the pattern design
    instead of what you’ve named the properties.
  prefs: []
  type: TYPE_NORMAL
- en: I do this a lot within this book. The projects aren’t real, and the code doesn’t
    really matter beyond being pedagogical. We’re here to learn the patterns. You
    can expect to see a lot of diagrams like *Figure A2.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.7: When designing with patterns, it is normal to see classes without
    all the details filled in. The point is to design and critique the structure,
    not the content.  ](img/B18605_Figure_A2.07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.7: When designing with patterns, it is normal to see classes without
    all the details filled in. The point is to design and critique the structure,
    not the content.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Person` and `Teacher` classes, I used placeholders. In the `Student`
    class, I didn’t specify anything. Both notations are valid. When you have the
    structure down, you can choose to either fill in the missing properties, methods,
    and relationships or leave them as implementation details for the developers.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose the former, be careful. When you’re first getting used to working
    with UML, it is tempting to use it as a tool to specify minutiae. Resist this
    temptation. If you don’t, your diagrams will become so complicated that they lose
    their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces are extremely important to OOAD and pattern diagramming. Drawing
    them is not very different from drawing classes. They look the same except for
    an obnoxious `<<Interface>>` expressed in the title box on the diagram. You can
    see one in *Figure A2.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.7: An interface in UML.  ](img/B18605_Figure_A2.08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.7: An interface in UML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages only allow you to implement methods in interfaces. Interfaces
    in C# can specify public properties in addition to the usual public methods, so
    it is legitimate to see properties defined on an interface. To reiterate: all
    properties in methods in an interface have to be public. You’ll only ever see
    `+` symbols for the access modifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enumerations refer to a finite set of values that rarely change. For example,
    the list of states in the United States hasn’t changed in 70 years. The days of
    the week haven’t changed in thousands of years. These are good candidates for
    enumerations. Let’s look at a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'They can be used as types, with the effect of preventing spurious data from
    being passed into a property or variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is better than just making it a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: I set the variable to “`Wednesday"`, but as my `enum` reveals, my program is
    expecting a very specific value. The `"Wednesday"` string isn’t right. I could
    easily set any value as long as it is a string. If my class needs a day of the
    week, and I use an enumeration as the type, it would be impossible to pass in
    *Bruceday* as a day of the week. *Bruceday* only occurs in my house where every
    day is a beautiful, beautiful *Bruceday*. I’ve been trying to standardize it as
    an internationally recognized day off for years. I figured it was a lock when
    country superstar Alan Jackson recorded, “It’s Bruceday Somewhere.” At the last
    minute, he changed the title to “It’s Five O’Clock Somewhere.” I think it was
    a mistake. Apparently, you have to be a Nordic or Greek god, a main sequence star,
    or a planetary body before you are taken seriously.
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration, like interfaces, features an obnoxious notation added to the
    title box, as seen in *Figure A2.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.8: An enumeration in UML.  ](img/B18605_Figure_A2.09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.8: An enumeration in UML.'
  prefs: []
  type: TYPE_NORMAL
- en: When you draw an enumeration, the properties represent the values that go into
    the enumeration. Enumerations don’t have methods, so there won’t be anything in
    the lower part of the diagram. There aren’t any access modifiers either. Just
    the contents are shown.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Packages are collections of the preceding structures. In C#, you would call
    it a namespace. There are two ways to draw packages: expanded and collapsed. Expanded
    packages are drawn with a rectangle around the classes and structures that belong
    to that namespace. They are used to show the contents of the package.'
  prefs: []
  type: TYPE_NORMAL
- en: Collapsed packages don’t show the contents. They are just a representation of
    the namespace. You can see an example of both expanded and collapsed packages
    in *Figure A2.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.9: Expanded and collapsed packages in UML.  ](img/B18605_Figure_A2.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.9: Expanded and collapsed packages in UML.'
  prefs: []
  type: TYPE_NORMAL
- en: I only used the expanded package once in the book to express a dependency on
    a third-party library.
  prefs: []
  type: TYPE_NORMAL
- en: Connectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In business, one of the most important factors to success is the relationships
    between the people you work with. The same can be said of a system of classes,
    interfaces, enumerations, and packages. In addition to the structures in a class
    diagram, the diagrams perhaps more importantly express the relationships between
    the structures, using a standardized set of lines and symbols. These lines connect
    structures together. Let’s look at the relationships expressed in UML class diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance between two classes is presented with a solid line with an open
    triangular arrow on one end. For example, if I have a class called `Person`, and
    another class called `Student` that inherits from `Person`, the diagram would
    look like *Figure A2.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.10: Inheritance is represented with a solid line with an empty
    triangular arrow pointing to the based class.  ](img/B18605_Figure_A2.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.10: Inheritance is represented with a solid line with an empty triangular
    arrow pointing to the based class.'
  prefs: []
  type: TYPE_NORMAL
- en: The arrow should point from the inheriting class to the base class. You are
    expressing that a student **IS A** person. As a best practice, the base classes
    are always drawn above the subclasses, so the arrows should always be pointing
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Interface realization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed interfaces in [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178)
    if you’re not sure what these are about. Interfaces are the most flexible way
    to pass around dependencies without tightly coupling two objects together. This
    makes them very important to our study of patterns.
  prefs: []
  type: TYPE_NORMAL
- en: When a class implements an interface, you draw a dashed line from the class
    implementing the interface to the interface itself. The end of the line has a
    hollow arrow pointing to the interface, as shown in *Figure A2.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.11: An interface realization line is dashed, with a hollow arrow
    pointing from the implementing class to the interface.  ](img/B18605_Figure_A2.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.11: An interface realization line is dashed, with a hollow arrow
    pointing from the implementing class to the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composition refers to creating an object out of other objects. You are expressing
    a relationship by saying **HAS A**. To make a car object, you might need an engine
    object and a hood ornament object. You would say a car *has a* hood ornament,
    and you would be expressing composition. See *Figure A.12* for an example of composition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.12: Composition in UML is shown using a solid line, with a diamond
    on the end of the containing class.  ](img/B18605_Figure_A2.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.12: Composition in UML is shown using a solid line, with a diamond
    on the end of the containing class.'
  prefs: []
  type: TYPE_NORMAL
- en: In UML, composition is expressed as a solid line drawn between classes, with
    a filled diamond on one end. The diamond should be pointing to the class that
    has whatever you’re putting into it. In our `Car` class.
  prefs: []
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Association between two classes indicates that they interact with each other.
    A `driver` object interacts with a `car` object. The driver puts gas in the car.
    The car transports the driver to another place. To draw an association in UML,
    you use a solid line with no arrow, as seen in *Figure A2.13*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.13: Associations show objects that interact with each other.  ](img/B18605_Figure_A2.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.13: Associations show objects that interact with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aggregations are a type of association involving multiplicity. A `warehouse`
    object will have a relationship with inventory items expressed as “An order has
    many inventory items.” Don’t confuse it with composition. Not only does it seem
    like the same thing, but the symbols are also nearly identical. Aggregation is
    an empty diamond on a solid line, as seen in *Figure A2.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.14: Aggregation is an empty diamond on a solid line.  ](img/B18605_Figure_A2.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.14: Aggregation is an empty diamond on a solid line.'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation and composition are different. Composition refers to the construction
    of an object from other objects. Aggregation refers to a relationship where there
    is a one-to-one, one-to-many, or many-to-many relationship between objects, but
    the objects can stand alone. If we had a `CollegeCourse` object, we could express
    aggregation with `student` objects. There are many students in one class. If the
    college cancels the class, the students don’t instantly vanish. You can have a
    student without a class.
  prefs: []
  type: TYPE_NORMAL
- en: Directed association
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A directed association shows a container relationship. A `spaceship` object
    is related to `passenger` objects in this way. Passengers are contained within
    the spaceship. Note that the spaceship is not composed of passengers, so it’s
    not the same thing as composition. A directed association can be diagramed as
    seen in *Figure A2.15*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.15: Directed association between two classes.  ](img/B18605_Figure_A2.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.15: Directed association between two classes.'
  prefs: []
  type: TYPE_NORMAL
- en: The line is solid and the arrowhead is two lines rather than a triangle.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When one class depends on another, you will find yourself changing both classes
    when modifications are needed. If you change one, you have to change the other.
    Imagine an electrical plug and an electrical socket. They are truly designed to
    be physically dependent on one another. If you had to change the design for the
    plug, you’d probably have to change the socket design too, and vice versa. A dependency
    relationship between two classes is something we usually strive to avoid, even
    though they are unavoidable. That might sound very Zen, but I’m referring to a
    relationship between two classes. A dependency is expressed using a dashed line
    with a non-triangular arrowhead on the end, as seen in *Figure A.16*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.16: Dependencies between classes are drawn with a dashed line and
    an angular arrowhead pointing from the dependent to the dependence.  ](img/B18605_Figure_A2.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.16: Dependencies between classes are drawn with a dashed line and
    an angular arrowhead pointing from the dependent to the dependence.'
  prefs: []
  type: TYPE_NORMAL
- en: These relationships can be vocalized as A **depends on** B changing as little
    as possible. I added the last part to remind me of the SOLID principle discussed
    in [*Chapter 2*](B18605_02.xhtml#_idTextAnchor036)*,* *Prepping for Practical
    Real-World Applications of Patterns in C#* . The O in SOLID refers to the open-closed
    principle. Classes should be open for extension but closed for modification. Dependencies
    are unavoidable, but when you see them in the diagram, scrutinize them and implement
    them with care.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notes are just what you think they are. Sometimes, an architect needs to add
    a little more information than what standard UML allows. Notes let you do that.
    You can see an example in *Figure A2.17*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.17: This is what a note looks like in UML.  ](img/B18605_Figure_A2.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.17: This is what a note looks like in UML.'
  prefs: []
  type: TYPE_NORMAL
- en: You shouldn’t use them to write an epistle. Short notes in implementation logic
    are what you see most commonly.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UML class diagrams are easy to create and understand, or at least they should
    be. Unfortunately, many diagrams fall victim to the same forces I covered in [*Chapter
    1*](B18605_01.xhtml#_idTextAnchor016). They can be a Golden Hammer, and they can
    grow uncontrollably to become too complicated to be useful. Software succumbs
    to these forces slowly over time. Sometimes, it takes years to make a repository
    full of spaghetti. Diagrams tend to fall apart over the space of days. UML is
    a plan. If your plan is a messy disaster, how can your software be anything else?
  prefs: []
  type: TYPE_NORMAL
- en: To curb the tide of these destructive forces, I’m going to give you four hints
    to keep your diagrams useful, easy to read, and hopefully, keep you out of analysis
    paralysis.
  prefs: []
  type: TYPE_NORMAL
- en: Less is more – don’t try to put everything in one big diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'UML diagrams are meant to be used by the development team, but they are often
    shared with other project stakeholders. If you go to a meeting with a diagram
    that looks like the guidance system schematic for the Patriot missile system,
    you shouldn’t expect to be well received. The developers won’t appreciate you
    and management will not think highly of you. The UML for the project in [*Chapter
    6*](B18605_06.xhtml#_idTextAnchor110)*, Step Away from the IDE! Designing with
    Patterns Before You Code,* and [*Chapter 7*](B18605_07.xhtml#_idTextAnchor136),
    *Nothing Left but the Typing: Implementing the Wheelchair Project*, could easily
    become way too big if you try to diagram the entire project in one diagram. Check
    out *Figure A2.18*. Even if I printed it on a plotter 3 feet wide by 2 feet tall,
    the diagram would still be hard to read.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.18: Don’t do this! This diagram covers the entire project presented
    in Chapter 7\. It is too big, too complicated, and it won’t fit on one page.  ](img/B18605_Figure_A2.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.18: Don’t do this! This diagram covers the entire project presented
    in [*Chapter 7*](B18605_07.xhtml#_idTextAnchor136). It is too big, too complicated,
    and it won’t fit on one page.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s better to break the system down into small parts and diagram those. You’ll
    see this done in [*Chapter 7*](B18605_07.xhtml#_idTextAnchor136). Make diagrams
    of small systems and keep them simple. As a rule, I try to keep to one or two
    pages at most. If the diagram won’t fit on two standard sheets of paper, it is
    probably too big, and you will need to find a way to break it down into smaller
    pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t cross the lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the classic movie *Ghostbusters*, the heroes of the story invent a dangerous,
    high-tech proton accelerator that fires a stream of energy capable of trapping
    and holding ghosts. In the movie, the chief scientist who invented the technology
    warns his comrades to never cross the streams, meaning they should never let the
    bolts of energy from two proton packs cross one another. Try to imagine all life
    as you know it instantly coming to an end as all the atomic particles in your
    body explode at the speed of light. They called it a *total protonic reversal*.
    That’s bad.
  prefs: []
  type: TYPE_NORMAL
- en: Now, apply the same caution to crossing lines in your UML diagrams. Crossed
    lines are ambiguous. The best you can do is to make it look like a circuit diagram
    and have one line hop over another. You can see an example in *Figure A2.19*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.19: The connector between Class D and Class E crosses the line
    between Class C and Class A.  ](img/B18605_Figure_A2.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.19: The connector between Class D and Class E crosses the line between
    Class C and Class A.'
  prefs: []
  type: TYPE_NORMAL
- en: You’re not sure where they originate and where they terminate. If there is no
    way to draw a class diagram without crossing lines, it is probably too big.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t apply if the lines are going to the same place. Class B and Class
    C are both inheriting from Class A. Technically, their lines join rather than
    cross. When this happens, I make an effort to join the lines together so that
    they look like one line.
  prefs: []
  type: TYPE_NORMAL
- en: The most direct path for lines leads to a mess
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This best practice is baked into the better UML diagramming tools you’ll find
    online. Even Visio does it by default. Drawing straight lines between classes
    leads to a messy diagram. You can see what I mean in *Figure A2.20*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.20: Circuitous lines with right angles instantly make a diagram
    look better.  ](img/B18605_Figure_A2.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.20: Circuitous lines with right angles instantly make a diagram look
    better.'
  prefs: []
  type: TYPE_NORMAL
- en: It is better to draw a more circuitous line that is easy to follow and, as we
    already noted, doesn’t cross other lines.
  prefs: []
  type: TYPE_NORMAL
- en: Parents go above children
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are diagramming any sort of inheritance or interface implementation,
    you should always draw the parent element above, or at least higher than, the
    child element, as depicted in *Figure A2.21*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.21: Parent elements should always be above child elements, which
    means your arrows should always point up.  ](img/B18605_Figure_A2.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A2.21: Parent elements should always be above child elements, which
    means your arrows should always point up.'
  prefs: []
  type: TYPE_NORMAL
- en: This makes your diagram easier to follow as long as you are consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Keep your diagrams neat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spend time keeping your diagrams tidy. I’d give you the same advice for your
    code. Clean up things you aren’t using anymore. Correct your spelling. Details
    matter! I would add that you should pick fonts that are easy to read. Fonts in
    your diagram should show italics very well so that you can always see abstract
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix covered the UML. While it sounds like a programming language,
    it is really a standard way of drawing diagrams to represent structures and patterns
    of code. We only need 1 of the 14 recognized UML documents to get through this
    book, but the one we do use is used quite extensively.
  prefs: []
  type: TYPE_NORMAL
- en: The class diagram shows the structures of a system along with the relationships
    between those structures. The structures may be classes, interfaces, enumerations,
    and packages. Common relationships include inheritance, interface realization,
    composition, association, and more. Notes can be added to a diagram to add more
    details but should be kept concise.
  prefs: []
  type: TYPE_NORMAL
- en: We learned the best practices for UML class diagrams, including keeping a diagram
    as legible as possible. Avoid clutter in the diagram that comes from trying to
    define every single possible relationship between structures. Focus instead on
    those that are vital to the implementation of the diagram. A good diagram isn’t
    necessarily one that definitely conforms to the standards of UML. A good diagram
    is one that communicates quickly, with just enough detail to allow a developer
    to successfully implement the intent of the diagram, without micromanaging every
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Baumann, Henriette, Patrick Grassle, and Philippe Baumann. *UML 2.0 in action:
    A project-based tutorial*. Packt Publishing, 2005.'
  prefs: []
  type: TYPE_NORMAL
