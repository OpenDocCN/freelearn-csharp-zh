- en: Chapter 3.  Basic Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I''ll cover the core element of the program code built with
    the functional paradigm, that is, **function** . The notion of a function is ubiquitous
    indeed. In the world around us, it may mean plenty of things, from purpose of
    something to dependency and to work in a certain manner. But here, I will consider
    it through the prism of computer programming, where a function generally means
    a method of computing results based on inputs. This examination is going to include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The notion of a function, the function definition and type signature, pure functions,
    referential transparency, and side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function parameters and arguments: a special type `unit` , the parameter number
    and type, the return value and type, currying, partial function application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions, functions as arguments and return values, anonymous
    functions, functions as data type constituents, and functions as interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures, mutable values, and reference cells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference and inferred versus explicit types of function components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive function basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators as functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing functions and combinators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As my ultimate goal is to make you embrace the REPL-based development style
    and spirit inherent to idiomatic F#, I'm going to run each and every mentioned
    feature through FSI in order to demonstrate the cause and effect.
  prefs: []
  type: TYPE_NORMAL
- en: The notion of function in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin with an intuitive definition of a function that many of us heard
    in school algebra class: function is a relationship that for each valid input
    yields a single consistent result. Such definition is a good enough to reflect
    both the commonality and the difference of functions and relations. In mathematics,
    a function is a relation, although not each relation is a function, as a relation
    may represent multiple results for the same single input. In the following figure,
    relation **Rij** on the left side is just fine for the representation of a function,
    as any item from set **I** maps to the one and only one item of set **J** . However,
    relation **Rxy** on the right side of the same figure cannot represent a function
    as at least one item of **X** exists, which maps to more than one item of **Y**
    , which is indicated by red mapping arrows.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The notion of function in F#](img/Image00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Relations and functions
  prefs: []
  type: TYPE_NORMAL
- en: Another very important matter is the mapping consistency. Any function, when
    being repeatedly given the same input must yield the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Following our intuition, a function in programming languages, including F#,
    represents a computation where the result is determined by performing a transformation
    of a valid input. As with any concrete computation, it consumes some memory and
    certain time to complete and carries some kind of behavior. And the behavior,
    the way of the computation, and the manner of the transformation in turn is determined
    by the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: The function definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, the F# function carries a name, has a parameter(s), returns a result
    of some type, and has a body. The following figure illustrates the coupling of
    these components. A function resembles an opaque box performing some transformation
    of the input to the output. It hides the specific details of how the transformation
    is exactly performed, declaring only the purpose and the signature to the world,
    in other words, types of input and output. The function may be turned to a white
    transparent box if its definition is available, ripping the opaque box apart and
    revealing the details of implementation. However the definition may or may not
    be available; the latter case is typical for libraries and modules (remember the
    hiding of moving parts). I intentionally used input in place of parameter(s);
    I''ll later show that functions of multiple parameters can be presented with functions
    of just a single parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The function definition](img/Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Function components and the purpose
  prefs: []
  type: TYPE_NORMAL
- en: 'These function components are fastened together in a language syntax by binding
    a function value as shown in the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding binding is not the only way of defining functions in F#; it may
    carry a few additional elements for special cases. I'll cover these missing details
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding syntax, we may, for example, define the F# function for
    the computing of the area of a circle of the given radius, as shown in the following
    code (`Ch3_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `System.Math.PI` is a field of the .NET `System.Math` class representing
    the ratio of the circumference of a circle to its diameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the function defined as such with the argument value `5.0` for the
    radius parameter in FSI yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that F# does not introduce any keyword to return the function
    result. The result is just the value of the last expression calculated within
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: The function type signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s enter the sole name of the `circleArea` function into FSI, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The FSI response represents the `circleArea` type signature, (`float -> float`
    ), which means that it is a function that takes the argument of type `float` and
    returns the result of type `float` . This function type signature is very simple.
    As we dive deeper , we'll examine more complex examples of function signatures.
    I'll show you that reading and understanding them is an absolutely essential skill
    for a functional programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another detail that an attentive reader may have already spotted is this: how
    did the F# compiler jump to the conclusion that the type of `radius` is `float`
    ? For now, just take my word that the compiler derived this following a deterministic
    procedure named `type inference` . It plays an outstanding role in decreasing
    the amount of bugs in the F# code and also attributes to code succinctness. F#
    implements a very specific manner of statically inferring types called **Hindley-Milner
    type inference algorithm** ([https://en.wikipedia.org/wiki/Type_inference](https://en.wikipedia.org/wiki/Type_inference)
    ). I will devote substantial attention to the inferring of types later in the
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A computer function implementation may or may not have this key property of
    the more abstract function notion: the consistency of repeatedly returning the
    same result when being given the same argument(s). The `circleArea` function defined
    previously, apparently carries this property. It does not depend on anything beyond
    its arguments and definition and does not change anything around beyond simply
    returning an idempotent result. Functions that have these useful properties are
    considered **pure** , or **referentially transparent** ([https://en.wikipedia.org/wiki/Referential_transparency](https://en.wikipedia.org/wiki/Referential_transparency)
    ); otherwise, they depend on something or have side effects and are hence **impure**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me demonstrate a simple impure function, in the following code (`Ch3_1.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code in FSI yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, the `opaque` impurity gets apparent from simply observing its subsequent
    calls with repeated arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters and arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our sample function definition given by the following code (`Ch3_1.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `radius` identifier represents the function **parameter** , that is, the
    name for a value that is expected to be transformed by the function. The value
    supplied for the parameter upon the function use represents the function **argument**
    , as shown when we apply our function in the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`15.0` is the function''s argument in the preceding line.'
  prefs: []
  type: TYPE_NORMAL
- en: The tuples preview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, in order to reveal the further details about function parameters,
    a certain notion would be required, which logically belongs to a completely different
    language facility, specifically to data types. I'm talking about **tuples** .
    As it doesn't seem feasible to build an ideally straight storyline, I will provide
    a necessary preview here and then revisit the subject of tuples in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: A **tuple** ([https://msdn.microsoft.com/en-us/library/dd233200.aspx](https://msdn.microsoft.com/en-us/library/dd233200.aspx)
    ) is an immutable F# data type that represents a parenthesis enclosed, comma separated,
    ordered grouping of arbitrary values. That is, grouping assumes at least a pair
    of values. Types of these values are completely arbitrary, and it does not matter
    whether they are the same or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a tuple is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The constituent value of a tuple can be represented by an expression as well,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I will wrap up this brief preview by covering what the tuple type signature
    looks like. It is built from types of constituents following the established order
    and separated by the `*` symbol. So following this arrangement, the type of tuple
    `dateParts` shown in the preceding code is `int*string*int` .
  prefs: []
  type: TYPE_NORMAL
- en: Special type unit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is just another component of the functions realm, which comes from the
    distinction between computer programming functions and functions of mathematics.
    This is the special type with the sole purpose of denoting the absence of a parameter
    and/or result, namely `unit` . This type is the simplest imaginable and has just
    a single value, represented by just a pair of brackets that have nothing in between.
    The following is the representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Nevertheless, `unit` plays the important role of the absence indicator. This
    absence may manifest itself as shown in the following function definition, which
    can be a poor man''s generator of random numbers between 0 and 1000 (`Ch3_1.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you consider the preceding binding, then having `()` after `getNextRandom`
    is the only way to disambiguate the function binding that denotes the calculation
    process from just a value binding denoting the result of a single calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, if I run both binding variants using FSI, the difference should be
    memorable: without a `unit` parameter, `getNextRandom` is bound to just an immutable
    `int64` value; otherwise, it is bound to a function that has the (`unit -> int64`
    ) signature, and after being repeatedly called, it returns a different result
    each time. The following screenshot captures this distinction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Special type unit](img/Image00008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The argument unit differentiates between the value and function bindings
  prefs: []
  type: TYPE_NORMAL
- en: 'The similarly interesting case has place when `unit` is a value of expression
    returned from a function. Intuition should prompt you that if a function returns
    nothing, or rather `()` , then its purpose could be to induce a side effect. Let''s
    slightly change the definition of `getNextRandom` as shown in the following code
    (`Ch3_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, the function signature turns to (`unit -> unit` ), and calling it, just
    outputs a random number between 0 and 999, returning the result of type `unit`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Currying and partial function application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a simple function, `myPrintFunC` , which takes a `string` and
    an `int` as parameters and returns `unit` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The type of `myPrintFunC` is (`string -> int -> unit` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another, almost similar, simple function is `myPrintFunT` , which also takes
    a `string` and an `int` as parameters and returns `unit` , but the parameters
    are tupled as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The type of `myPrintFunT` is (`string*int -> unit` ).
  prefs: []
  type: TYPE_NORMAL
- en: Applying `myPrintFunC` `"The Answer is" 42` outputs `The Answer is 42` . Similarly,
    applying `myPrintFunT ("The Answer is", 42)` outputs `The Answer is 42` too. So
    what's the fuss about?
  prefs: []
  type: TYPE_NORMAL
- en: 'The fundamental distinction is in the manner in which these functions accept
    their arguments: arguments of `myPrintFunC` are curried, but arguments of `myPrintFunT`
    are tupled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of being familiar with tuples, you should not be surprised that `let
    t = ("The Answer is", 42)` in `myPrintFunT` outputs the same result: `The Answer
    is 42` . The signature of `myPrintFunT` prompted us of the single function parameter
    of the type `string*int` tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The case of `myPrintFunC` is more interesting. The arrow `->` in its signature
    is the right associative operation, so I can rewrite its signature as (`string
    -> (int -> unit)` ), correct? But wait a minute; isn''t (`int -> unit` ) representing
    a function that takes the `int` parameter and returns `unit` ? Yes, it does. So,
    getting back to `myPrintFunC` , why can''t I consider it as a function that takes
    the `string` parameter and returns a new interim function, in turn taking the
    `int` parameter and returning `unit` ? In the end, functions are first-class entities
    in F#, so a returned value can be of the function type. Now let''s turn back to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This still returns `The Answer is 42` . And in order to make the mechanics
    fully transparent, let''s play the preceding transformation step by step in FSI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Currying and partial function application](img/Image00009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Partial function application
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding screenshot illustrates, the `myPrintFunC` function is originally
    defined as having two parameters. When it is applied just to the first argument,
    it returns another function, `interimFun` , which has just one parameter that,
    if in turn is applied to the second argument, returns exactly the same result
    as the original function applied to both arguments. As may be expected, the result
    is `The Answer is 42` ; the fans of Douglas Adams already knew this.
  prefs: []
  type: TYPE_NORMAL
- en: My congratulations to you; you just grasped one of the utterly important techniques
    of functional programming, namely,  **partial function application** . Partial
    application is achieved by simply omitting one or more trailing function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: So, **currying** is built on the principle of partial function application.
    Any function definition of multiple parameters in a curried form is just a syntactic
    sugar for the process of currying, implicitly transforming the original definition
    to a composition of functions, each comprising one parameter. Currying is the
    default feature of F#; it makes partial function application available anytime.
  prefs: []
  type: TYPE_NORMAL
- en: The number and the type of function parameters and return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I want to reiterate the earlier findings in relation to the F# functions parameters
    and return value in order to leave you with a very simple mental model, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All F# functions have a single parameter and return a single result.
  prefs: []
  type: TYPE_NORMAL
- en: Functions without parameters and/or without a return value fit this model using
    a `unit` value in place of the omitted entities.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with multiple parameters and multiple return values may fit the preceding
    model by making the parameters and return values into a single tuple each.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that have multiple parameters in a curried form fit the singular parameter
    model via a recurrent transformation into a function, taking the first argument
    and returning the new function that has this argument partially applied.
  prefs: []
  type: TYPE_NORMAL
- en: Further fine grain details to the preceding principle come from the .NET side,
    when we deal with not only pristine F# functions, but also with static and instance
    methods of .NET libraries and our custom types. These will be covered in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've mentioned on many occasions that functions are first-class entities in
    F# because they can be used as arguments for other functions or can be returned
    from other functions as results. This is exactly the indication of higher-order
    functions. A higher-order function may have another function as a parameter, it
    may return another function as a result, or it may perform both these things.
  prefs: []
  type: TYPE_NORMAL
- en: All functions are considered function values in F#; this treatment allows you
    to not make any distinction between functions and other kinds of values in any
    context where values are used. I will cover some such contexts here, namely an
    argument to another function, a value returned from a function, and a part of
    a data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some situations, it makes sense to have the ability of defining a function
    that does not carry the explicit name. Typically, such an ability is nice to have
    for functions that are the subject of manipulation by higher-order functions.
    A concise way to set arguments or results that does not involve a full blown function
    definition is required. Why is that? The first consideration that comes to my
    head is that the name may be needed for the future reference. If a function is
    defined by the name and then this name is referred multiple times from other locations
    of the program code, then this function that has a name makes perfect sense. On
    the contrary, if the function is defined as an argument of a higher-order function
    and is never used outside this single occurrence, then the name is redundant.
    Another consideration is the use of function values; for example, using a function
    as an argument to another function may not require any name for the former.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax to define an anonymous function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, `parameter-list` represents tupled or curried parameter names, optionally
    carrying explicit parameter types. Note that anonymous functions defined with
    the `fun` keyword represent a **lambda expression** ([https://msdn.microsoft.com/en-us/library/dd233201.aspx](https://msdn.microsoft.com/en-us/library/dd233201.aspx)
    ). A lambda expression has the value represented by the anonymous function. Realizing
    this tidbit is important in order to understand the first-class treatment of functions
    in F#.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions as arguments is perhaps the most common use of functions in functional
    programs. Typical F# libraries are implemented as highly optimized sets of higher-order
    functions that can be tuned for any concrete task by providing specific functions
    as arguments. For example, a square scalar matrix 5 x 5 with main diagonal elements
    of 1s may be created using the `Array2D.init` library function. **Array2D.init**
    ([https://msdn.microsoft.com/en-us/library/ee353720.aspx](https://msdn.microsoft.com/en-us/library/ee353720.aspx)
    ) is a higher-order function that has a signature of (`int->int->(int->int->''T)->''T[,]`
    ), where the inner part of the signature represents the so-called **initializer**
    or the function that sets the individual elements of the matrix based on their
    indices. The following anonymous function for initializing the elements of a diagonal
    matrix according to their indices can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the achievement of this task in FSI by
    plugging the preceding function into the expression (`Ch3_2.fsx` ) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the sought-for matrix being built and shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions as arguments](img/Image00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using an anonymous function as an argument to a higher-order function
  prefs: []
  type: TYPE_NORMAL
- en: Functions as return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned in the function definition section, the function return value
    is just the value of the last expression. In order to return a function, we may
    use as the last expression of the host function: either an anonymous function
    definition, or a partial function application.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into this matter by performing a harder exercise. Quite frequently,
    it helps to have a function that allows you to accurately measure the duration
    of the execution of an arbitrary calculation wrapped into some other function.
    Furthermore, it is also helpful to have the information about the environment
    baked into measurement results.
  prefs: []
  type: TYPE_NORMAL
- en: So, I'm going to implement a higher-order function, `stopWatchGenerator` , which
    takes another function, `f` , with parameter, `x` , as its own arguments and returns
    a function value represented by an anonymous function with exactly the same signature.
    This anonymous function just wraps the calculation (`f x` ) with this calculation
    duration measurement taken with millisecond precision. It communicates the measured
    duration to the output device, accompanying it with the name of the main executable
    file. So, for 32-bit FSI, it would be just [`fsi` ]; for 64-bit FSI, it would
    be [`fsiAnyCPU` ]; and for a custom executable, it would be the name of the executable
    file. Sometimes, such utility can be pretty helpful, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is given in the following code (`Ch3_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Please note that I intentionally put explicit types for `stopWatchGenerator`
    arguments `f` , which is the function taking the argument of generic type `'a`
    and returning the result of generic type `'b` , and `x` , which is the value of
    type `'a` , and for the `stopWatchGenerator` return type, which is the function
    taking two curried arguments of types `('a->'b)` and `'a` and returning the result
    of type `'b` .
  prefs: []
  type: TYPE_NORMAL
- en: Does your head begin spinning yet? This is fine, please stay assured that you
    will get accustomed to these seemingly complicated manipulations and will soon
    find them as easy as apple pie.
  prefs: []
  type: TYPE_NORMAL
- en: The function `stopWatchGenerator` returns the sought anonymous function using
    the `fun` lambda expression, which creates the instance of .NET `System.Diagnostics.Stopwatch()`
    and wraps its start and take readings around the evaluation of the target expression
    (`f x` ).
  prefs: []
  type: TYPE_NORMAL
- en: The function `whatItTakes` is just a convenient abbreviation for the arrangement
    with function evaluation shadow timing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows two examples of using the generated function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions as return values](img/Image00011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A function returning another function in action
  prefs: []
  type: TYPE_NORMAL
- en: 'The first use case checks how much time is required in order to produce and
    add together the first 10 million positive numbers as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second use case demonstrates a way of calculating the pi with certain precision
    by applying the ****Gregory series**** ([http://mathworld.wolfram.com/GregorySeries.html](http://mathworld.wolfram.com/GregorySeries.html)
    ) method, using an arbitrary series length as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As the results indicate, the Gregory series is not the greatest formula for
    the calculation of pi; nevertheless, it can serve the purpose of demonstrating
    the power of function values.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as data type constituents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you may come up with a crafty question: "Values of primitive types may
    be combined into more complex types; for example, a handful of `int` values can
    be stored in an `int` array. If functions are really first-class values, they
    should allow a similar kind of composition as well. How about constructing an
    array of functions?"'
  prefs: []
  type: TYPE_NORMAL
- en: 'My answer is: "Sure, why not?" Let''s consider the following function definition
    (`Ch3_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `apply` takes two arguments, and if the first one, `case` , is
    in the range of `0` to `3` , it applies the corresponding math library trigonometry
    function to the second argument, `arg` . Otherwise, it just returns the `arg`
    value unchanged, just a dull no-brainer implementation. Let''s spice it up by
    arranging the functions into the array as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: I've used the F# `try...with` construction in order to sift instances of case
    values that require the specific function application from those that return just
    the `arg` echo.
  prefs: []
  type: TYPE_NORMAL
- en: This is achieved with the `[|sin; cos; asin; acos|]` construction that has the
    (`float -> float` ) `[]` signature. This means exactly what was expected, or an
    array of functions of the same type (taking the single argument of type `float`
    and returning a result of type `float` ). Each array element position is tied
    with the specific function instance with the help of the `[case]` indexer, or
    `[|sin; cos; asin; acos|]` `.[0]` yields `sin` , `[|sin; cos; asin; acos|]` `.[1]`
    yields `cos` , and so on. The value of the `[|sin; cos; asin; acos|].[case]` expression
    is a function where the case value is in the valid range of `0` to `3` . As such,
    it can be applied to `arg` , yielding the corresponding result. The `case` value
    out of the valid range entails the `System.IndexOutOfRangeException` exception
    and is caught and processed by simply returning the echoed value of `arg` . I
    must admit that abusing the exception mechanism the way it is done above is awful
    coding practice, but please forgive me for using it within the toy example while
    demonstrating some totally unrelated feature.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the light of the dual nature of F# being a functional-first language and
    at the same time supporting an object-oriented type system of .NET, it is worth
    taking a look at the relationship between functions and interfaces. The original
    **Gang of Four book** ([http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610)
    ) points to the following principle of reusable object-oriented design in its
    introduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Program to an interface, not an implementation.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From this standpoint, a function is the quintessence of an interface. While
    in the object-oriented world, an interface must be explicitly declared prior to
    one of its implementations may be substituted by another, in the functional programming
    realm, this declaration is excessive. As long as two or more functions have the
    same signatures, they may be used interchangeably in the code. Function signature
    is the equivalent of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: My previous example with the array of functions clearly demonstrates how the
    change of implementation can be achieved as simply as through changing the array
    element index value.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I already mentioned, the function result depends on parameters. Is this
    dependency exhaustive? Certainly not. The function definition exists in a lexical
    context and is free to use some entities from this context in the course of the
    transformation of arguments into the result. Let''s consider the following code
    example (`Ch3_5.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `enclose()` function does not have any parameters except `unit`
    . However, the result that''s returned depends on the free value `scope` that
    was in the lexical scope at the time of the function definition. Let `scope` value
    be bound to the `"old lexical scope"` value. This value gets captured, "closed"
    by the `enclose()` definition. Together, the contextual part and the definition
    form the special entity named **closure** . This process is schematically presented
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Closures](img/Image00012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A sample of a closure
  prefs: []
  type: TYPE_NORMAL
- en: 'Because they''re closed, the free values do not change. In the following sample,
    the value `scope` is later shadowed by the new value, `"new lexical scope"` .
    However, this does not change the value captured within the closure. This is reflected
    in the following figure, which shows the running of the last example in FSI, where
    both old and new scopes coexist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Closures](img/Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A simple closure in action
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I provide another example of closure, demonstrating this time the capturing
    and updating of the state in the closure created by the anonymous function definition
    (`Ch3_5.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, the `trackState` function captures its own argument into a
    closure accompanied by the anonymous function, which increments the local counter
    hidden in this closure on each invocation. The upcoming figure illustrates two
    independent closures, `counter1()` and `counter2()` , created off separate `trackState`
    invocations with different seeds tracking their own state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Closures](img/Image00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Closures representing objects
  prefs: []
  type: TYPE_NORMAL
- en: This sample highlights how closures can be used to represent inner fields even
    if the language does not really support objects. In this respect, as one of programming
    fables goes, **closures are a poor man's objects** ([http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent](http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent)
    ) indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the spirit of the functional-first language, F# values are immutable by default.
    However, the language offers facilities for the use of mutable values.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable variables can be created using the `let mutable` syntax of value binding
    and the `<-` assignment operator to mutate the earlier bound values. Mutable values
    bound with `let mutable` are stored on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Until F# v4.0, it was not allowed to write code capturing mutable values in
    closures, but beginning with the  v4.0 version of the language, this limitation
    has been lifted.
  prefs: []
  type: TYPE_NORMAL
- en: Reference cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative facility for mutable values is reference cells inherited from
    OCaml. These values are allocated on the heap using the `let` binding with the
    special `ref` function. The underlying value of a reference cell is accessed with
    the help of dereference operator `!` . The referenced value can be mutated by
    the special assignment operator `:=` .
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a subtle difference between mutable values and reference cells: mutable
    values are copied *by value* while reference cells are copied *by reference* .
    Let me offer you the code snippet illuminating this matter (`Ch3_6.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure demonstrates by running the preceding code snippet in
    FSI how this difference manifests itself: mutable values `x` and `y` are independent,
    so changing `y` value from being identical to `x` value to something different
    does not anyhow affect `x` ; their values stay different.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `rx` and `ry` reference the same object, so changing the underlying
    object via the `ry` reference simultaneously changes the previous object referenced
    by `rx` to the same one that `ry` references:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reference cells](img/Image00015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The difference between mutable and ref values
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have already outlined type inference earlier in the chapter. It is a feature
    of F# (as well as many other languages: C#, to begin with) that stems from its
    property of being statically typed. By following the natural code flow direction
    from top to bottom and from left to right, the F# compiler is capable of deriving
    types of values present in the code, including function types. This ability, in
    turn, allows you to omit explicit type declarations from the F# code. In the end,
    the code can be written faster, is quite succinct, and if it compiles, is consistent
    type-wise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Relying on type inference is not mandatory when writing the F# code. Adding
    an explicit declaration to the code may be especially meaningful in the following
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When the types cannot be inferred and the compiler prompts for the explicit
    declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the code's author believes that providing explicit type declaration in some
    cases may simplify the code understanding and improve its readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most obvious way of inferring the value type is during binding based on
    the type of the expression to the right of the `=` sign as shown in the following
    code (`Ch3_7.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For `s` , this is the type of literal on the right-hand side, or `string` .
    For `dict` , this is the `Dictionary<string, string list>` type of instance constructed
    on the right-hand side of the binding. In cases like the preceding one, adding
    explicit declarations of `s` and `dict` would just be adding unnecessary noise
    to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another rather obvious case is inferring a function signature based on its
    body definition in certain situations as shown in the following code (`Ch3_7.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, as `isWin` is used after `if` this fact allows the F# compiler to deduce
    its type as `bool` ; the return type is apparently `string` , so the signature
    of the `gameOutcome` function can be inferred as (`bool->string` ). Simple, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Not that simple case when type inference fails may be illustrated by the following
    (quite naive) snippet (`Ch3_7.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the F# compiler complains about `s.Length` and `s.Substring` with the
    following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lookup on object of indeterminate type based on information prior to this
    program point. A type annotation may be needed prior to this program point to
    constrain the type of the object. This may allow the lookup to be resolved.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Changing the function definition to `let truncator limit (s: string) =` makes
    the F# compiler happy again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, if I would not be that naive and take at least some effort to check
    arguments for corner cases, as shown in the slightly enhanced definition in the
    following code (`Ch3_7.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then, the compiler can infer a type of `s` as `string` from its use as the argument
    of the `System.String.IsNullOrEmpty` library function; the explicit type declaration
    is not required again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type inference gains more importance in the area of statically constrained
    generic types. Let''s consider a slightly more loaded example of the `logAndTrash`
    function, which takes an `ss` disposable collection, scribbles each `s` item as
    a separate text line into .NET `StringBuilder` , disposes the collection, and
    returns the eventual `StringBuilder` value for later consumption elsewhere as
    shown in the following code (`Ch3_7.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very nice of the F# compiler to infer a rather complicated signature
    of `logAndTrash` function that literally reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Or, in plain words, this is a function taking a value of generic type `'a` and
    returning an instance of `StringBuilder` , where `'a` must be a sequence of any
    generic type `'b` and at the same time be disposable.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up the cases of type inference illustrated by the code examples given
    earlier I offer you the following take-away tip.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types of values, functions, and generics with constraints in F# may be unambiguously
    inferred in many code contexts, including-but not limited to-literals, constructed
    instances, usage in certain expression parts, signatures of library or custom
    functions or methods.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive function basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I want to introduce you to the basics of recursive functions,
    leaving more detailed consideration for the more advanced contexts. At this point,
    I want to show how the F# default treatment of functions as non-recursive differs
    from a forced one when the function is explicitly declared recursive using the
    `let` binding modifier, `rec` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following far-fetched snippet (`Ch3_8.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `cutter` function here provides a non-empty string that's supposed to cut
    it from the left-hand side, symbol by symbol, until the argument is gone. Within
    the `cutter` body, there are two definitions of the `cut` internal function, of
    which the second definition apparently shadows the first. Also, it's important
    that within the second `cut` definition, it calls itself with the argument shortened
    from the left-hand side by one character, which is a clear case of **recursion**
    ([https://en.wikipedia.org/wiki/Recursion](https://en.wikipedia.org/wiki/Recursion)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the preceding code being fed to FSI and executed
    yielding some output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursive function basics](img/Image00016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Default non-recursive scoping of function definition
  prefs: []
  type: TYPE_NORMAL
- en: However, apparently, this code did not work as intended, as for the purpose
    of self-reference, the second instance of the `cut` definition is not lexically
    complete when `cut s.[1..]` occurs. The second `cut` definition did not shadow
    the first imitator instance of the `cut` definition, so the single output from
    the second (real) `cut` is followed by the single output from the imitator `cut`
    , and the computation is complete at this point. Oops, this is quite far from
    the intended output!
  prefs: []
  type: TYPE_NORMAL
- en: 'Things have changed dramatically in the following screenshot, where the second
    definition of `cut` is peppered with the `rec` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursive function basics](img/Image00017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Forced recursive scoping of the function definition
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the second definition of `cut` immediately shadows the first one, allowing
    the second inner `cut` function to really call itself, which reflects the changed
    output; now, the implementation behaves as conceived: all performed cutting is
    real.'
  prefs: []
  type: TYPE_NORMAL
- en: So, for now, you should be able to grasp that the `rec` modifier makes a function
    value available for referral immediately, without waiting until the function definition
    is lexically complete, thus enabling functions refer to themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Operators as functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is an operator, thinking abstractly? It can be seen as a function of one
    or two arguments that just have a concise name represented by a single symbol
    or a very few symbols. F# heartily supports this abstraction. For example, take
    a look at the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, on the left-hand side of the equality sign (`=` ), the `(%)` function
    is called with the arguments `10` and `3` . On the right-hand side of the equality
    sign (`=` ) just a `10 % 3` expression is present. Evaluating the whole expression
    in FSI shows its value as `true` because sub expressions on the left and right
    of the equality sign (`=)` are indeed identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the equality sign (`=` ) itself is also an operator. Evaluating
    the equality sign (`=` ) itself in FSI with the following expression `(=);;` will
    reveal the following function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding signature means that (`=` ) is simply a function that takes two
    arguments of generic type `'a` supporting equality and returns a `bool` value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the description of F# core operators, refer to **Core.Operators Module (F#)**
    ([https://msdn.microsoft.com/en-us/library/ee353754.aspx](https://msdn.microsoft.com/en-us/library/ee353754.aspx)
    ). Those of you who want to define your own operators, which is not a bad thing
    if done in moderation, I recommend ****Operator Overloading (F#)**** ([https://msdn.microsoft.com/en-us/library/dd233204.aspx](https://msdn.microsoft.com/en-us/library/dd233204.aspx)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function composition is perhaps the most fundamental skill to be mastered by
    a functional programmer. However simple it may sound, this is about combining
    some functions into a more powerful combination. This may sound close to the higher-order
    functions I have covered earlier, and it is close indeed. Function composition
    is just concentrating upon building chains of function applications that allow
    more powerful data transformations from the bunch of less complicated ones.
  prefs: []
  type: TYPE_NORMAL
- en: Combinators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How exactly does the function composition take place if, by definition, the
    functions considered the basis for composition are just sort of black boxes that
    can only consume arguments and produce results? This is correct; functions, arguments,
    and the single operation of an application are all that's required for composition
    (remember minimizing the moving parts). Still, composition is performed by functions
    as well. The function that somehow applies just its parameters or values (some
    of them may be function values) in order to produce results without involving
    any external context is named **combinator** . There is an entire branch of applied
    math, that is, **Combinatory logic** ([https://en.wikipedia.org/wiki/Combinatory_logic](https://en.wikipedia.org/wiki/Combinatory_logic)
    ) that is concerned, in particular, with the learning of combinators. This may
    take very capricious forms; those of you who want to delve deeper, I recommend
    that you Google the *idiot bird combinator* string and follow the links.
  prefs: []
  type: TYPE_NORMAL
- en: The id combinator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest representative of combinators is `id` . Entering `(id);;` into
    FSI reveals this function signature `('a -> 'a)` . In other words, this combinator
    takes any value and simply returns it without any transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Forward pipe |>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This combinator is the workhorse of idiomatic F#. Entering `(|>);` ; into FSI
    reveals this function signature `('a -> ('a -> 'b) ->'b)` . In other words, this
    combinator applies its second argument, which is a function `('a -> 'b)` , to
    its first argument `'a` , yielding the result `'b` .
  prefs: []
  type: TYPE_NORMAL
- en: Also, it may seem that the order cannot be that important; however, it is important
    indeed. One of the factors involved is type inference, which works better for
    the piped function composition (remember left to right).
  prefs: []
  type: TYPE_NORMAL
- en: Backward pipe <|
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Entering `(<|);` ; into FSI reveals this function signature: `((''a -> ''b)
    -> ''a -> ''b)` . In other words, this combinator applies its first argument `(''a
    -> ''b)` to the second `''a` , yielding the result `''b` . At first glance, this
    combinator may seem excessive. However, an important case when it becomes useful
    is in eliminating the need for parentheses around the argument and improving the
    readability of the code in the end.'
  prefs: []
  type: TYPE_NORMAL
- en: Forward composition >>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This combinator composes functions together. Entering `(>>);;` into FSI reveals
    this function signature `(('a -> 'b) -> ('b -> 'c) -> 'a -> 'c)` . In other words,
    having two functions and an argument, it applies the first function to the argument
    and the second function to the result of the first application.
  prefs: []
  type: TYPE_NORMAL
- en: Backward composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This combinator composes functions together as well, but it does that differently.
    Entering `(<<);` ; into FSI reveals this function signature `(('a -> 'b) -> ('c
    -> 'a) -> 'c -> 'b)` . In other words, having two functions and an argument, it
    applies the second function to the argument and then the first function to the
    result of the first application. Sometimes, such an application order can be convenient
    for improved readability or other reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I expect that this chapter moved your intuition in the direction of a handful
    of notions the functional-first nature of F# is based upon.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing and distilling these cornerstones from any relevant code context,
    you are now ready to absorb the main contents. In the next chapter, I'll turn
    to the cornerstone of F# programming techniques that is present in literally every
    data transformation, that is, *Pattern Matching* .
  prefs: []
  type: TYPE_NORMAL
