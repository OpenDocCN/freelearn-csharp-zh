- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the Different Domains in Software Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is dedicated to a modern software development technique called
    **domain-driven design** (**DDD**), which was first proposed by Eric Evans (see
    *Domain-Driven Design*: [https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20)).
    While DDD has existed for more than 15 years, it has achieved great success in
    the last few years because of its ability to cope with two important problems.'
  prefs: []
  type: TYPE_NORMAL
- en: The main problem is modeling complex systems that involve several domains of
    knowledge. No single expert has in-depth knowledge of the whole domain; this knowledge
    is instead split among several people. The second problem is that each expert
    speaks a language that is specific to his domain of expertise, so for effective
    communication between the experts and the development team, objects, interfaces,
    and methods must mimic the language of the domain experts. This means that the
    different modules that compose an application must use a different vocabulary
    for each domain of expertise. Consequently, the application must be split into
    modules that reflect the different domains of knowledge, and the interface between
    modules that deal with the different domains of knowledge must be carefully designed
    to carry out the necessary translations.
  prefs: []
  type: TYPE_NORMAL
- en: DDD copes with this problem by splitting the whole CI/CD cycle into independent
    parts, assigned to different teams. This way, each team can focus on a specific
    domain of knowledge by interacting only with the experts in that domain.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why the evolution of DDD is interleaved with the evolution of microservices
    and DevOps. Thanks to DDD, big projects can be split among several development
    teams, with each team having a different domain of knowledge. There are many reasons
    why a project is split among several teams, with the most common being the team’s
    size and all of its members having different skills and/or being in different
    locations. In fact, experience has proven that teams of more than 6–8 people are
    not effective, and, clearly, different skills and locations prevent tight interaction
    from occurring.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, the importance of the two aforementioned problems has grown in the
    last few years. Software systems have always taken up a lot of space inside every
    organization, and they have become more and more complex and geographically distributed.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, the need for frequent updates has increased so that these
    complex software systems can be adapted to the needs of a quickly changing market.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of the increasing complexity and need for frequent updates in software
    systems, we now face a scenario where it’s common to implement complex software
    systems with associated fast CI/CD cycles that always require more people to evolve
    and maintain them. In turn, this created a need for technologies that were adequate
    for high-complexity domains and for the cooperation of several loosely coupled
    development teams.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will analyze the basic principles, advantages, and common
    patterns related to DDD, as well as how to use them in our solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are software domains?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding DDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common DDD patterns and architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: As you progress through the second part of the book, you might find it enriching
    to revisit this particular chapter. Reflecting on these concepts with a deeper
    understanding can offer new insights and enhance your overall experience. Feel
    free to come back to this chapter as a resource whenever you encounter related
    ideas later on.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free Visual Studio 2022 Community Edition or better,
    with all the database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code snippets in this chapter can be found in the GitHub repository
    associated with this book: [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).'
  prefs: []
  type: TYPE_NORMAL
- en: What are software domains?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in *Chapter 2*, *Non-Functional Requirements*, and *Chapter
    3*, *Managing Requirements*, the transfer of knowledge from domain experts to
    the development team plays a fundamental role in software design. Developers try
    to communicate with experts and describe their solutions in a language that domain
    experts and stakeholders can also understand. However, often, the same word has
    a different meaning in various parts of an organization, and what appears to be
    the same conceptual entities have completely different shapes in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in our WWTravelClub use case, the order-payment and package-handling
    subsystems use completely different models for customers. The order-payment subsystem
    characterizes a customer by their payment methods, currency, bank accounts, and
    credit cards, while package-handling is more concerned with the locations that
    have been visited and/or the packages that have been purchased, the user’s preferences,
    and their geographical location. Moreover, while order-payment refers to various
    concepts with a language that we may roughly define as a **bank language**, package-handling
    uses a language that is typical of travel agencies/operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic way to cope with these discrepancies is to use a unique abstract
    entity called **customer**, which projects into two different views—the order-payment
    view and the package-handling view. Each projection operation takes some operations
    and some properties from the **customer** abstract entity and changes their names.
    Since domain experts only give us the projected views, our main task as system
    designers is to create a conceptual model that can explain all the views. The
    following diagram shows how different views are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Creating a unique model'
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of the classic approach is that we have a unique and coherent
    representation of the data of the domain. If this conceptual model is built successfully,
    all the operations will have a formal definition and purpose and the whole abstraction
    will be a rationalization of the way the whole organization should work, possibly
    highlighting and correcting errors and simplifying some procedures.
  prefs: []
  type: TYPE_NORMAL
- en: However, what are the downsides of this approach?
  prefs: []
  type: TYPE_NORMAL
- en: The sharp adoption of a new monolithic data model may cause an acceptable impact
    in a small organization when the software is destined for a small part of the
    overall organization, or when the software automates a small enough percentage
    of the data flow. However, if the software becomes the backbone of a complex,
    geographically distributed organization, sharp changes become unacceptable and
    unfeasible. On the one hand, big structured companies need to react quickly to
    market changes, but on the other hand, due to the complexity of their organizations,
    only gradual changes are feasible. Therefore, the changes in their organizations
    and information systems that are needed to adapt to the market must be gradual.
    In turn, a gradual transition is possible only if old data models can coexist
    with new data models, and if each of the various components of the organization
    is allowed to change at its own speed—that is, if each component of the organization
    can evolve independently of the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, as the complexity of a software system grows, several other issues
    make the unique data model of classical architectures hard to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Coherency issues**: Arriving at a uniquely coherent view of data becomes
    more difficult since we can’t retain the complexity when we break these tasks
    into smaller, loosely coupled tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difficulties updating**: As complexity grows, there is a need for frequent
    system changes, but it is quite difficult to update and maintain a unique global
    model. Moreover, bugs/errors that are introduced by changes in small subparts
    of the system may propagate to the whole organization through the uniquely shared
    model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team organization issues**: System modeling must be split among several teams,
    and only loosely coupled tasks can be given to separate teams; if two tasks are
    strongly coupled, they need to be given to the same team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallelism issues**: As we will discuss in more detail in *Chapter 11*,
    *Applying a Microservice Architecture to Your Enterprise Application*, the need
    to move to a microservice-based architecture often makes the bottleneck of a unique
    database unacceptable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language issues**: As the system grows, we need to communicate with more
    domain experts, each speaking a different language and each with a different view
    of that data model. Thus, we need to translate our unique model’s properties and
    operations to/from more languages to be able to communicate with them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the system grows, it becomes more inefficient to deal with records with hundreds/thousands
    of fields that project in smaller views. Such inefficiencies originate in database
    engines that inefficiently handle big records with several fields (memory fragmentation,
    problems with too many related indices, and so on). However, the main inefficiencies
    take place in **object-relational mappings** (**ORMs**) and business layers that
    are forced to handle these big records in their update operations. In fact, while
    query operations usually require just a few fields that have been retrieved from
    the storage engine, updates and business processing involve the whole entity.
    ORMs are described in detail in *Chapter 13*, *Interacting with Data in C# – Entity
    Framework Core*.
  prefs: []
  type: TYPE_NORMAL
- en: As the traffic in the data storage subsystem grows, we need read and update/write
    parallelism in all the data operations. As we will discover in *Chapter 12*, *Choosing
    Your Data Storage in the Cloud*, while read parallelism is easily achieved with
    data replication, write parallelism requires sharding; that is, splitting database
    records among several distributed databases, and it is difficult to shard a uniquely
    monolithic and tightly connected data model.
  prefs: []
  type: TYPE_NORMAL
- en: These issues are the reason for DDD’s success in the last few years because
    they were characterized by more complex software systems that became the backbones
    of entire organizations. DDD’s basic principles will be discussed in detail in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to DDD, we should not construct a unique domain model that projects
    into different views in each application subsystem. Instead, the whole application
    domain is split into smaller domains, each with its own data model. These separate
    domains are called **Bounded Contexts**. Each Bounded Context is characterized
    by the language used by the experts and used to name all the domain concepts and
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, each Bounded Context defines a common language used by both the experts
    and the development team called a **Ubiquitous Language**. Translations are not
    needed anymore, and if the development team uses C# interfaces as bases for its
    code, the domain expert is able to understand and validate them since all the
    operations and properties are expressed in the same language that’s used by the
    expert.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’re getting rid of a cumbersome unique abstract model, but now we have
    several separate models that we need to relate somehow. DDD proposes that we handle
    all these separate models (that is, all the Bounded Contexts) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**We need to add Bounded Context boundaries whenever the meanings of the language
    terms change**. For instance, in the WWTravelClub use case, order-payment and
    package-handling belong to different Bounded Contexts because they give a different
    meaning to the word **customer**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We need to explicitly represent relations among Bounded Contexts**. Different
    development teams may work on different Bounded Contexts, but each team must have
    a clear picture of the relationship between the Bounded Context it is working
    on and all the other models. For this reason, such relationships are represented
    in a unique document that’s shared with every team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We need to keep all the Bounded Contexts aligned with CI**.Meetings are organized
    and simplified system prototypes are built in order to verify that all the Bounded
    Contexts are evolving coherently—that is, that all the Bounded Contexts can be
    integrated into the desired application behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how the WWTravelClub example that we discussed
    in the previous section changes with the adoption of DDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, venn diagram  Description automatically generated](img/B19820_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Relationships between DDD-Bounded Contexts'
  prefs: []
  type: TYPE_NORMAL
- en: There is a relationship between the Customer entities of each Bounded Context,
    while the Purchase entity of the package-handling Bounded Context is related to
    the Payments. Identifying entities that map to each other in the various Bounded
    Contexts is the first step of formally defining the interfaces that represent
    all the possible communications among the contexts.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in the previous diagram, since payments are made after purchases,
    we can deduce that the order-payment Bounded Context must have an operation to
    create a payment for a specific customer. In this domain, new customers are created
    if they don’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: The payment creation operation is triggered immediately after purchase. Since
    several more operations are triggered after an item is purchased, we can implement
    all the communication related to a purchase event with the Publisher/Subscriber
    pattern we explained in *Chapter 6*, *Design Patterns and .NET 8 Implementation*.
    In DDD, these are known as **domain events**. Using events to implement communications
    between Bounded Contexts is very common since it helps keep Bounded Contexts loosely
    coupled.
  prefs: []
  type: TYPE_NORMAL
- en: Once an instance of either an event or an operation that’s been defined in the
    Bounded Context’s interface crosses the context boundary, it is immediately translated
    into the Ubiquitous Language of the receiving context. It is important that this
    translation be performed before the input data starts interacting with the other
    domain entities to prevent the Ubiquitous Language of the receiving domain from
    becoming contaminated by extra-contextual terms. An inadequate translation is
    usually evidenced by the domain experts complaining about “strange words.”
  prefs: []
  type: TYPE_NORMAL
- en: Each Bounded Context implementation must contain a domain model completely expressed
    in terms of the Bounded Context Ubiquitous Language (class and interface names
    and property and method names), with no contamination from other Bounded Contexts’
    Ubiquitous Languages, and without contamination from technical programming stuff.
    This is necessary to ensure good communication with domain experts and to ensure
    that domain rules are translated correctly into code so that they can be easily
    validated by domain experts.
  prefs: []
  type: TYPE_NORMAL
- en: When there is a strong mismatch between the communication language and the target
    Ubiquitous Language, an anti-corruption layer is added to the receiving Bounded
    Context boundary. The only purpose of this anti-corruption layer is to perform
    a language translation.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships among Bounded Contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The document that contains a representation of all the Bounded Contexts, along
    with the Bounded Contexts’ mutual relationships and interface definitions, is
    called a **context map**. The relationships between contexts contain organizational
    constraints that specify the kind of cooperation required among the teams that
    are working on the different Bounded Contexts. Such relationships don’t constrain
    the Bounded Context interfaces but do affect the way they may evolve during the
    software CI/CD cycle. They represent patterns of team cooperation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common patterns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partner**: This is the original pattern suggested by Eric Evans. The idea
    is that the two teams have a mutual dependency on each other for delivery. In
    other words, they decide together the Bounded Context’s mutual communication specifications
    during the software development lifecycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer/supplier development teams**: In this case, one team acts as a customer
    and another one acts as a supplier. In the preliminary stage, both teams define
    the interface of the customer side of the Bounded Context and some automated acceptance
    tests to validate it. After that, the supplier can work independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern works when the customer’s Bounded Context is the only active part
    that invokes the interface methods exposed by the other Bounded Context. This
    is adequate for the interaction between the order-payment and the package-handling
    contexts, where order-payment acts as a supplier since its functions are subordinate
    to the needs of package-handling. When this pattern can be applied, it decouples
    both the implementation and the maintenance of the two Bounded Contexts completely.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Conformist**: This is similar to the customer/supplier pattern, but in this
    case, the customer side accepts an interface that’s been imposed by the supplier
    side with no preliminary negotiation stage. This pattern offers no advantages
    to the other patterns, but sometimes we are forced into the situation depicted
    by the pattern since either the supplier’s Bounded Context is implemented in a
    preexisting product that can’t be configured/modified too much, or because it
    is a legacy subsystem that we don’t want to modify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth pointing out that the separation in Bounded Contexts is only effective
    if the resulting Bounded Contexts are loosely coupled; otherwise, the reduction
    of complexity that’s obtained by breaking a whole system into parts would be overwhelmed
    by the complexity of the coordination and communication processes.
  prefs: []
  type: TYPE_NORMAL
- en: However, if Bounded Contexts are defined with the language criterion—that is,
    Bounded Context boundaries are added whenever the Ubiquitous Language changes—this
    should actually be the case. In fact, different languages may arise as a result
    of a loose interaction between an organization’s subparts since the more each
    subpart has tight interactions inside of it and loose interactions with other
    subparts, the more each subpart ends up defining and using its own internal language,
    which differs from the language used by the other subparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, as all human organizations grow just by evolving into loosely coupled
    subparts, similarly, complex software systems may be implemented just as the cooperation
    of loosely coupled submodules: this is the only way humans are able to cope with
    complexity. From this, we can conclude that complex organizations/artificial systems
    can always be decomposed into loosely coupled subparts. We just need to understand
    *how*.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the basic principles we’ve mentioned so far, DDD provides a few basic
    primitives to describe each Bounded Context, as well as some implementation patterns.
    While Bounded Context primitives are an integral part of DDD, the patterns are
    simply useful heuristics we can use in our implementation, so their usage in some
    or all Bounded Contexts is not obligatory once we opt for DDD adoption.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will describe Bounded Context primitives, while the
    various patterns will be described in the remaining sections of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DDD entities represent domain objects that have a well-defined identity, as
    well as all the operations that are defined on them. They don’t differ too much
    from the entities of other, more classical approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference is that DDD stresses the entities’ object-oriented nature,
    while other approaches use them mainly as **records** whose properties can be
    written/updated without too many constraints.
  prefs: []
  type: TYPE_NORMAL
- en: DDD, on the other hand, forces strong SOLID principles on them to ensure that
    only certain information is encapsulated inside of them and that only certain
    information is accessible from outside of them, to stipulate which operations
    are allowed on them, and to set which business-level validation criteria apply
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, DDD entities are richer than the entities of record-based approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In the record-based approach, operations that manipulate entities are defined
    outside of them in classes that represent business and/or domain operations. In
    DDD, these operations are moved into the entity definitions as their class methods.
    The reason for this is that this approach offers better modularity and keeps related
    chunks of software in the same place so that they can be maintained and tested
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: More details on the difference between the record-based approach and the DDD
    approach will be given later on, in the *Repository pattern* subsection of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For the same reason, business validation rules that are specific for each entity
    are moved inside of DDD entities. DDD entity validation rules are business-level
    rules, so they must not be confused with database integrity rules or user-input
    validation rules. They contribute to the way entities represent domain objects
    by encoding the constraints the represented objects must obey.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, it might be obligatory to provide an entity property such as “Shipping
    Address” on a web page (user input validation rule), even though property is not
    obligatory in general (no corresponding business validation rule). In fact, the
    “Shipping Address” property becomes obligatory only if we need to ship something,
    so if the context of the web page is about shipping something, then “Shipping
    Address” must be obligatory as a user input in that specific web page but not
    as a general business rule.
  prefs: []
  type: TYPE_NORMAL
- en: User input validation will be discussed in more detail in *Chapter 17*, *Presenting
    ASP.NET Core*, which will show, in practice, how user input validation and business
    validation have different and complementary purposes. While business-level validation
    rules encode domain rules, input validation rules enforce the format of every
    single input (string length, correct email and URL formats, and so on), ensure
    that all the necessary input has been provided, enforce the execution of the chosen
    user machine interaction protocols, and provide fast and immediate feedback that
    drives the user to interact with the system.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that not all business validation rules can be encoded
    inside DDD entities. Business rules that are not specific to single DDD entities
    but involve the interaction of several entities must be encoded in the software
    module that handles and coordinates the interaction among entities. We will speak
    more about the software module that coordinates entity interactions later on in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The subsection that follows gives more details on entity-level validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Entity-level validation in .NET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In .NET, business validation can be carried out with one of the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the validation methods in all the class methods that modify the entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking the validation methods to all the property setters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorating the class and/or its properties with custom validation attributes
    and then invoking the `TryValidateObject` static method of the `System.ComponentModel.DataAnnotations.Validator`
    class on the entity each time it is modified. The .NET `System.ComponentModel.DataAnnotations`
    namespace contains predefined validation attributes (see [https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes](https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes)),
    but the developer can define also custom validation attributes by inheriting from
    the `System.ComponentModel.DataAnnotations.ValidationAttribute` abstract class
    (see [https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/](https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on validation attributes will be given in *Chapter 17*, *Presenting
    ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: Once detected, validation errors must be handled somehow; that is, the current
    operation must be aborted and the error must be reported to an appropriate error
    handler. The simplest way to handle validation errors is by throwing an exception.
    This way, both purposes are easily achieved and we can choose where to intercept
    and handle them. Unfortunately, as we discussed in the *Performance issues that
    need to be considered while programming in C#* section of *Chapter 2*, *Non-Functional
    Requirements*, exceptions imply big performance penalties and must be used to
    deal just with “exceptional circumstances” so, often, different options are considered.
    Handling errors in the normal flow of control would break modularity by spreading
    the code that’s needed to handle the error all over the stack of methods that
    caused the error, with a never-ending set of conditions all over that code. Therefore,
    more sophisticated options are needed.
  prefs: []
  type: TYPE_NORMAL
- en: A good alternative to exceptions is to notify errors to an error handler that
    is unique for each processing request. For instance, it can be implemented as
    a scoped service in the dependency injection engine. Being scoped, the same service
    instance is returned while each request is being processed so that the handler
    that controls the execution of the whole call stack can inspect possible errors
    when the flow of control returns to it, and can handle them appropriately. Unfortunately,
    this sophisticated technique can’t automatically abort the operation’s execution
    and return immediately to the most adequate controlling handler that is in the
    call stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why exceptions are often used for this scenario, notwithstanding their
    performance issues. The other option is the usage of a **result object** that
    informs the caller of the success of the operation in all method calls. However,
    result objects have their cons: they imply more coupling between the methods involved
    in the call stack, so during software maintenance, each change might require modifications
    in several methods.'
  prefs: []
  type: TYPE_NORMAL
- en: DDD entities in .NET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since DDD entities must have a well-defined identity, they must have properties
    that act as primary keys. It is common to override the `Object.Equals` method
    of all the DDD entities in such a way that two objects are considered equal whenever
    they have the same primary keys. This is easily achieved by letting all the entities
    inherit from an abstract `Entity` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following things in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth implementing an `IEntity<K>` interface that defines all the properties/methods
    of `Entity<K>`. This interface is useful whenever we need to hide data classes
    behind interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IsTransient` predicate returns `true` whenever the entity has been recently
    created and hasn’t been recorded in the permanent storage, so its primary key
    is still undefined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In .NET, it is good practice that, whenever you override the `Object.Equals`
    method of a class, you also override its `Object.GetHashCode` method so that class
    instances can be efficiently stored in data structures such as dictionaries and
    sets. That’s why the `Entity` class overrides it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth pointing out that once we’ve redefined the `Object.Equals` method
    in the `Entity` class, we can also override the `==` and `!=` operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entities are not the only data ingredient of DDD. Domain modeling also requires
    data with no unique identities. That’s why value objects were conceived.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Value objects, in contrast to entities, represent complex types that can’t be
    encoded with numbers or strings. Therefore, they have no identity and no principal
    keys. They have no operations defined on them and are immutable; that is, once
    they’ve been created, all their fields can be read but cannot be modified. For
    this reason, they are usually encoded with classes whose properties have protected/private
    setters.
  prefs: []
  type: TYPE_NORMAL
- en: Two value objects are considered equal when all their independent properties
    are equal. Some properties are not independent since they just show data that’s
    been encoded by other properties in a different way, as is the case for the ticks
    of `DateTime` and its representation of the date and time fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value objects are easily implemented with C# 12 `record` types since all `record`
    types automatically override the `Equals` method so that it performs a property-by-property
    comparison. Record types can also be made immutable by adequately defining their
    properties; once immutable objects are initialized, the only way to change their
    values is to create a new instance. Here is an example of how to modify a `record`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of how to define a `record`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `init` keyword is what makes `record` type properties immutable since it
    means they can only be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pass all the properties in the constructor instead of using initializers,
    the preceding definition can be simplified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Typical value objects include costs represented as a number and a currency symbol,
    locations represented as longitude and latitude, addresses, and contact information.
  prefs: []
  type: TYPE_NORMAL
- en: The way both entities and value objects typically interact with data storage
    in .NET applications is explained in *Chapter 13*, *Interacting with Data in C#
    – Entity Framework Core*.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have talked about entities as the **units** that are processed by
    a DDD-based business layer. However, several entities can be manipulated and made
    into single entities. An example of this is a purchase order and all of its items.
    In fact, it makes absolutely no sense to process a single order item independently
    of the order it belongs to. This happens because order items are actually subparts
    of an order, not independent entities.
  prefs: []
  type: TYPE_NORMAL
- en: There is no transaction that may affect a single order item without it affecting
    the order that the item is in. Imagine that two different people in the same company
    are trying to increase the total quantity of cement, but one increases the quantity
    of type-1 cement (item 1) while the other increases the quantity of type-2 cement
    (item 2). If each item is processed as an independent entity, both quantities
    will be increased, which could cause an incoherent purchase order since the total
    quantity of cement would be increased twice.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the whole order, along with all its order items, is loaded
    and saved with every single transaction by both people, one of the two will overwrite
    the changes of the other one, so whoever makes the final change will have their
    requirements set.
  prefs: []
  type: TYPE_NORMAL
- en: A purchase order, along with all its subparts (its order items), is called an
    **aggregate**, while the order entity is called the **root** of the aggregate.
    Aggregates always have roots since they are hierarchies of entities connected
    by **subpart** relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Since each aggregate represents a single complex entity, all the operations
    on it must be exposed by a unique interface. Therefore, the aggregate root usually
    represents the whole aggregate, and all the operations on the aggregate are defined
    as methods of the root entity.
  prefs: []
  type: TYPE_NORMAL
- en: When the aggregate pattern is used, the units of information that are transferred
    between the business layer and the data layer are called aggregates, queries,
    and query results. Thus, aggregates replace single entities.
  prefs: []
  type: TYPE_NORMAL
- en: In a few words, aggregates are in-memory representations of storage information
    that need to be dealt with as a single object. Being an in-memory representation
    based on an object-oriented paradigm, they take full advantage of all the benefits
    of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Domain events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Domain events are the main communication ingredient of DDD. While DDD doesn’t
    impose constraints on the way communication among bounded contexts is achieved,
    a communication based on the publisher/subscriber pattern described in *Chapter
    6*, *Design Patterns and .NET 8 Implementation*, maximizes independence among
    bounded contexts. Each bounded context publishes all information that might interest
    other bounded contexts, and interested bounded contexts subscribe. This way, the
    publisher doesn’t need to know about each subscriber and how it works, but just
    publish the result of its job in a general format. More implementation details
    will be given in the *Command handlers and domain events* subsection of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Common DDD patterns and architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this and the sections that follow, we will describe some of the patterns
    and architectures that are commonly used with DDD. Some of them can be adopted
    in all projects, while others can only be used for certain Bounded Contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, we should note that, from a conceptual point of view, the
    functionality of each application can be classified into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling the interaction with the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing business-related processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the storage engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the above groups uses a different language and different technologies.
    The first group uses the language of the target users and user interface technologies,
    the second group uses the language of the domain expert and is focused on application
    domain modeling, and the third group uses both language and technologies related
    to databases.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the architectures we will look at organize these functionalities in
    different ways. We will start with the classic layers architecture since it is
    simpler to understand, and then we will describe the more sophisticated onion
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Classic layers architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classic layers architecture organizes the three groups of functionalities
    as three loosely coupled sets of classes/interfaces called **layers**, put one
    after the other:'
  prefs: []
  type: TYPE_NORMAL
- en: The first layer in the sequence is the one that takes care of user interaction
    and is called the **presentation layer**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second layer in the sequence is the one that performs business-related processing
    and is called the **business layer**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third layer is the one dedicated to database interaction and is called the
    **data layer**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each layer can communicate directly just with the layer that precedes it and
    the layer that follows it, as shown in the figure below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Classic layers architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Each layer call can pass data to methods of public objects in the layer that
    follows it and receive the resulting data back.
  prefs: []
  type: TYPE_NORMAL
- en: The presentation layer handles not only graphics but also the whole user-machine
    interaction protocol. During its interaction protocol, the presentation layer
    uses business layer methods either to present data to the user or to update the
    application state.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, the business layer uses data layer methods to retrieve all data it
    needs to prepare the user answer from the data storage and to update the application
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Each layer offers a well-defined interface to the layer that precedes it while
    hiding all implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: The layer architecture promotes modularity since each layer doesn’t depend on
    how the layers that precede it are implemented, and avoids the possibility of
    the language used by each layer contaminating the language used by the others.
  prefs: []
  type: TYPE_NORMAL
- en: However, data exchanged in the classic layer architecture are record-type objects
    with no methods that encode any processing logic, since the whole processing logic
    is contained in the objects and methods that compose the three layers.
  prefs: []
  type: TYPE_NORMAL
- en: Since record-like objects used by the classic layers architecture are very different
    from DDD domain objects, which are rich objects that encode most of the business
    logic in their methods, the classic layers architecture has a poor match with
    DDD. That’s why an improvement on the classic layers architecture, called the
    onion architecture, has been proposed.
  prefs: []
  type: TYPE_NORMAL
- en: Onion architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the onion architecture, layers obey different rules and are defined in a
    slightly different way. There is:'
  prefs: []
  type: TYPE_NORMAL
- en: An outermost layer that takes care of all interactions with the application
    environment—that is, user interface, test software, and interaction with operating
    system and data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A domain layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the domain layer is an abstraction of the classical data layer based on
    the Ubiquitous Language. It is where DDD entities and value objects are defined,
    together with abstractions of the operations that retrieve and save them. For
    better modularity, all or some domain layer classes may be made internal and hidden
    behind public interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer, instead, defines operations that use the domain layer
    public interface (public interfaces and public classes) to get DDD entities and
    value objects and manipulate them to implement the application business logic.
    The DDD application layer is called **application services** since it exposes
    its functionalities through an API that is completely independent of the outermost
    layers. This way, for instance, any user interface layer and a test suite both
    call exactly the same methods to interact with the application logic.
  prefs: []
  type: TYPE_NORMAL
- en: The outermost layer contains the user interface, the functional test suites
    (if any), and the application interface with the infrastructure that hosts the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure represents the environment in which the application runs
    and includes the operating system, any devices, filesystem services, cloud services,
    and databases. The infrastructure interface is placed on the outermost level to
    ensure that no other onion layer depends on it. This maximizes both usability
    and modifiability.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure layer contains all the drivers needed to adapt the application
    to its environment. Infrastructure resources communicate with the application
    through these drivers, and, in turn, drivers expose the infrastructure resources
    to all application layers through interfaces that are associated with the drivers
    implementing them in the dependency injection engine. This way, adapting the application
    to a different environment just requires changing the drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sketch of the onion architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Onion architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Each ring is a layer. Inward from the outermost layer are the **application
    services**, and inward from the application services we have the **domain layer**,
    which contains the representation of the entities involved in the Bounded Context
    knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the application services and the domain layer can be split into sublayers,
    and all layers/sublayers must conform to the following rule: *Each layer may depend
    only on the inner layers.*'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the domain layer may be split into **Domain Model** and **Domain
    Services**, where Domain Modelis below Domain Services. The *Domain Model* layer
    contains the classes and interfaces that represent all domain objects, while the
    *Domain Services* layer contains the so-called repositories that are explained
    later on in this chapter in the *Repository pattern* and *Unit of work pattern*
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see later on in this chapter, it is common to interact with the domain
    layer through interfaces that are defined in a separate library and implemented
    in the domain layer. Thus, the domain layer must have a reference to the library
    containing all domain layer interfaces since it must implement those interfaces,
    while the application layer is where each domain layer interface is connected
    with its implementation through a record of the application layer dependency injection
    engine. More specifically, the only data layer objects referenced by the application
    layer are these interface implementations that are only referenced in the dependency
    injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: Outer layers that implement interfaces defined in the next inner layer are a
    common pattern used in the onion architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Each application layer operation requires the interfaces it needs from the dependency
    engine, uses them to get DDD entities and value objects, manipulates them, and
    possibly saves them through the same interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram that shows the relationships among the three layers discussed
    in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Relationships among the layers'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the domain layer contains the representation of the domain objects, the
    methods to use on them, validation constraints, and the domain layer’s relationship
    with various entities. To increase modularity and decoupling, communication among
    entities is usually encoded with events—that is, with the **Publisher/Subscriber
    pattern**. This means entity updates can trigger events that have been hooked
    to business operations, and these events act on other entities.
  prefs: []
  type: TYPE_NORMAL
- en: This layered architecture allows us to change the whole data layer without affecting
    the domain layer, which only depends on the domain specifications and language
    and doesn’t depend on the technical details of how the data is handled.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer contains the definitions of all the operations that may
    potentially affect several entities and the definitions of all the queries that
    are needed by the applications. Both business operations and queries use the interfaces
    defined in the domain layer to interact with the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: However, while business operations manipulate and exchange entities with these
    interfaces, queries send query specifications and receive generic **Data Transfer
    Objects** (**DTOs**) from them. In fact, the purpose of queries is just to show
    data to the user, not to act on them; accordingly, query operations don’t need
    whole entities with all their methods, properties, and validation rules, but just
    property tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Business operations are invoked either by other layers (typically the presentation
    layer) or by communication operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, the application layer operates on the interfaces defined in the
    domain layer instead of interacting directly with their data layer implementations,
    which means that the application layer is decoupled from the data layer. More
    specifically, data layer objects are only mentioned in the dependency injection
    engine definitions. All the other application layer components refer to the interfaces
    that are defined in the domain layers, and the dependency injection engine injects
    the appropriate implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application layer communicates with other application components through
    one or more of the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It exposes business operations and queries on a communication endpoint**,
    such as an HTTP Web API (see *Chapter 15*, *Applying Service-Oriented Architectures
    with .NET*). In this case, the presentation layer may connect to this endpoint
    or to other endpoints that, in turn, take information from this and other endpoints.
    Application components that collect information from several endpoints and expose
    them in a unique endpoint are called **gateways**. They may be either custom or
    general-purpose, such as Ocelot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is referenced as a library by an application that directly implements
    the presentation layer**, such as an ASP.NET Core MVC Web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It doesn’t expose all the information through endpoints and communicates
    some of the data it processes/creates to other application components that, in
    turn, expose endpoints**. Such communication is often implemented with the Publisher/Subscriber
    pattern to increase modularity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The repository pattern is an entity-centric approach to the definition of the
    domain layer interfaces: each entity—or better, each aggregate—has its own repository
    interface that defines how to retrieve and create it, and defines all queries
    that involve entities in the aggregate. The implementation of each repository
    interface is called a repository. Repositories are associated with aggregates
    instead of entities, since, as discussed in the *Aggregates* subsection, aggregates
    represent the minimum granularity that makes sense to consider in each data operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the repository pattern, each operation has an easy-to-find place where
    it must be defined: the interface of the aggregate the operation works on, or,
    in the case of a query, the aggregate that contains the root entity of the query.'
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern was initially conceived for the classical layer architecture
    and its record-like objects. Then, it was adapted to work with rich DDD entities/aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: Classical repositories contain all methods needed to handle record-like objects—that
    is, modification, creation and delete methods since record-like objects have no
    modification methods. DDD-adapted repositories, instead, only contain create and
    delete methods since all methods that modify each aggregate are defined as aggregate
    methods. Moreover, applications based on classic repositories and record-like
    objects do not have a unique record-like object that represents each domain aggregate,
    but there are several record-like objects, each containing a different view of
    the overall domain aggregate. Therefore, classic repositories have modification
    methods for several different record-like objects.
  prefs: []
  type: TYPE_NORMAL
- en: Both classic and DDD-adapted repositories have methods to retrieve data to be
    returned to the user. In both cases, this data is represented by record-like objects,
    since aggregates are built only when domain entities must be modified or created.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram below summarizes the differences between classical and DDD-adapted
    repository patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Classical and DDD-adapted repository pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Unit of work pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it is preferable for transactions to be confined within the boundary of
    a single aggregate design, sometimes application layer transactions might span
    several aggregates and, accordingly, might use several different repository interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, buying a travel involves the simultaneous modifications of the
    following entities:'
  prefs: []
  type: TYPE_NORMAL
- en: Hotel/travel available places
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer shopping basket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both operations must be accomplished in a single transaction since either they
    are both successful or they must both fail. Therefore, we need a way to execute
    operations on several entities/aggregates in a single transaction, while keeping
    the methods/code of the involved entities decoupled, according to object-oriented
    programming best practices.
  prefs: []
  type: TYPE_NORMAL
- en: The **Unit of Work** pattern is a solution that maintains the independence of
    the domain layer from the underlying domain layer implementation. It states that
    each repository interface must also contain a reference to a Unit of Work interface
    that represents the identity of the current transaction. This means that several
    repositories with the same Unit of Work reference belong to the same transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The Unit of Work pattern can be used with both aggregates and record-like entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the repository and the Unit of Work patterns can be implemented by defining
    some seed interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All repository interfaces inherit from `IRepository<T>` and bind `T` to the
    aggregate root or entity they are associated with, while Unit of Work simply implements
    `IUnitOfWork`. When `SaveEntitiesAsync()` is called, all pending modifications,
    deletions, and creations done on aggregates or record-like objects are saved in
    a single transaction in the storage engine. If a wider transaction that starts
    when some data is retrieved from the storage engine is needed, it must be started
    and committed/aborted by the application layer handler, which takes care of the
    whole operation with the help of the `IUnitOfWork` `StartAsync`, `CommitAsync`,
    and `RollbackAsync` methods. `IRepository<T>` inherits from an empty `IRepository`
    interface to help automatic repository discovery.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository associated with this book contains a `RepositoryExtensions`
    class whose `AddAllRepositories` `IServiceCollection` extension method automatically
    discovers all the repository implementations contained in an assembly and adds
    them to the dependency injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: Classic repository pattern versus DDD aggregates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DDD patterns discussed so far, such as aggregates and DDD-adapted repositories,
    ensure modularity and modifiability, and, since whole domain aggregates are loaded
    in memory, they also prevent various kinds of bugs due to wrong partial updates.
    However, each addition of new functionality is cumbersome since it usually involves
    a complex modeling activity, the reengineering or creation of whole aggregates,
    and the definition of several classes.
  prefs: []
  type: TYPE_NORMAL
- en: On the one hand, record-like objects are easier to define and we may define
    different classes for different usages. So, adding a new functionality simply
    requires the definition of an independent repository method, and possibly the
    definition of a new record-like class.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we need just to maintain travel descriptions and features. It is a very
    simple domain, and we need just to perform CRUD operations—that is, creating and
    deleting travels and modifying their features. In this case, there is no advantage
    in loading the whole aggregates in memory and performing all operations as methods
    of a unique entity class.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, with the classical repository pattern, we can load just the
    features of the travel we would like to modify, say a marketing-optimized description
    in some web pages, price in other pages where the user is an administrator with
    the power of deciding on prices, and so on. This way each operation uses a different
    object that is specific and optimized for that operation.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose now we are designing a complex resource allocation software for an industrial
    application. All properties of each entity are constrained by complex business
    rules, and also several entities are constrained by several complex business rules.
    Therefore, a partial update of a few properties has consequences that propagate
    to the whole entity and to other connected entities.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, each classical repository method would be forced to take into
    account all possible consequences of each property change, resulting in complex
    spaghetti code and in the recoding of the same operations several times in different
    repository methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, a DDD approach performs much better. We load in memory the full
    aggregates involved and let their methods handle the business rule complexity
    with the help of object-oriented best practices. It is enough that each aggregate
    encodes the behavior of the real word object it represents, with no need to care
    about consequences on other entities.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, when a Bounded Context is quite simple, meaning a few entities with
    a few interactions among them and a few different update operations, there is
    no doubt that the classic repository pattern is more convenient. On the other
    hand, when there are many entities, or complex entities, and many different update
    operations are added, repositories turn into spaghetti code with several partially
    overlapping methods, code duplication, and no easy-to-understand interaction rules.
  prefs: []
  type: TYPE_NORMAL
- en: A full example showing the DDD-adapted repository pattern is given in the *A
    frontend microservice* section of *Chapter 21, Case Study*, while a full example
    showing the classical repository pattern is given in the *Using client technologies*
    section of the same chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, as already pointed out, partial updates performed by several record-like
    projections of domain aggregates may cause bugs due to simultaneous modifications
    performed by different users.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when the probability of similar bugs becomes high because of complex
    update patterns, it is very dangerous to use the classic repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, again, complexity is the main factor that drives us to the usage of DDD
    patterns. Moreover, the need to centralize the triggering of domain events used
    to synchronize Bounded Context data stores (review the previous *Understanding
    domain-driven design* section) forces the loading of whole aggregates in memory,
    and the usage of DDD patterns. Therefore, when a Bounded Context needs to trigger
    several domain events in complex circumstances, we can’t use the simpler classic
    repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed the basic patterns of DDD, we can discuss some more
    advanced DDD patterns. In the next section, we will introduce the CQRS pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Command Query Responsibility Segregation (CQRS) pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In its general form, the usage of this pattern is quite easy: *use different
    structures to store/update and query data*. Here, the requirements regarding how
    to store and update data differ from the requirements of queries. This means that
    both the domain layer and application services of queries and store/update operations
    must be designed in completely different ways.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of DDD, the unit of storage is the aggregate, so additions, deletions,
    and updates involve aggregates. On the other hand, differently from storages/updates,
    queries don’t perform business operations but involve transformations of properties
    that have been taken from several aggregates (projections, sums, averages, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, while updates require entities enriched with business logic and constraints
    (methods, validation rules, encapsulated information, and so on), query results
    just need sets of property/value pairs, so DTOs with only public properties and
    no methods work well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its common form, the pattern can be depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19820_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Command and query processing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: The middle boxes (Handlers and Repository interfaces) represent operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The leftmost and rightmost boxes represent data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrows simply represent the direction of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main takeaway from this is that the extraction of query results doesn’t
    need to pass through the construction of entities and aggregates, but the fields
    shown in the query must be extracted from the storage engine and projected into
    ad hoc DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: However, in more complex situations, CQRS may be implemented in a stronger form.
    Namely, we can use different Bounded Contexts to store preprocessed query results.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the other option would be an aggregator microservice that queries all
    the necessary microservices in order to assemble each query result. However, recursive
    calls to other microservices to build an answer may result in unacceptable response
    times. Moreover, factoring out some preprocessing ensures better usage of the
    available resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Query handling is delegated to separated and specialized components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each query-handling component uses a database table for each query it must handle.
    There, it stores all fields to be returned by the query. This means that queries
    are not computed at each request, but precomputed and stored in specific database
    tables. Clearly, queries with child collections need additional tables, one for
    each child collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All components that process updates forward all changes to the interested query-handling
    components. Records are versioned so the query-handling components that receive
    the changes can apply them in the right order to their query-handling tables.
    In fact, since communication is asynchronous to improve performance, changes are
    not guaranteed to be received in the same order they were sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes received by each query-handling microservice are cached while they wait
    for the changes to be applied. Whenever a change has a version number that immediately
    follows the last change applied, it is applied to the right query-handling table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth noticing that the software “components” we mentioned above run as
    separate processes on possibly different machines, and are called microservices.
    They will be discussed in detail in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of this stronger form of the CQRS pattern transforms typical local
    database transactions into complex time-consuming distributed transactions since
    a failure in a single query preprocessor microservice should invalidate the whole
    transaction. As we will discuss in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*, implementing distributed transactions is usually
    unacceptable for performance reasons and sometimes is not supported at all, so
    the common solution is to renounce the idea of a database that is immediately
    consistent overall and to accept that the overall database will eventually be
    consistent after each update.
  prefs: []
  type: TYPE_NORMAL
- en: Transient failures can be solved with retry policies, which we will discuss
    in *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*,
    while permanent failures are handled by performing corrective actions on the already
    committed local transactions instead of pretending to implement an overall globally
    distributed transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you may be asking the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Why do we need to keep the original data once we have all the preprocessed
    query results? We will never use it to answer queries!”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the answers to this question are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They are the source of truth that we may need to recover from failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need them to compute new preprocessed results when we add new queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need them to process new updates. In fact, processing updates usually requires
    that some of the data is retrieved from the database, possibly shown to the user,
    and then modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, to modify an item in an existing purchase order, we need the whole
    order so that we can show it to the user and compute the changes so that we can
    forward it to other microservices. Moreover, whenever we modify or add data to
    the storage engine, we must verify the coherence of the overall database (unique
    key constraints, foreign key constraints, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection is dedicated to an extreme implementation of the CQRS pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Event sourcing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event sourcing is a more advanced implementation of the stronger form of CQRS.
    It is useful when the original Bounded Context is a **source of truth**—that is,
    for recovering from failures and for software maintenance. In this case, instead
    of updating data, we simply add events that describe the operation that was performed,
    such as *deleted record Id 15*, *changed the name to John in Id 21*, and so on.
    These events are immediately sent to all the dependent Bounded Contexts, and in
    the case of failures and/or the addition of new queries, all we have to do is
    reprocess some of them. For performance reasons, together with the events representing
    all changes, the current state is also maintained; otherwise, each time it is
    needed, it will need to be recomputed, replaying all events. Moreover, usually,
    the full state is cached after, say, every *N* changes. This way, if there is
    a crash or any kind of failure, only a few events must be replayed.
  prefs: []
  type: TYPE_NORMAL
- en: Replaying events can’t cause problems if events are **idempotent**—that is,
    if processing the same event several times has the same effect as processing it
    once.
  prefs: []
  type: TYPE_NORMAL
- en: As we will discuss in *Chapter 11*, *Applying a Microservice Architecture to
    Your Enterprise Application*, idempotency is a standard requirement for microservices
    that communicate through events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will describe a common pattern that’s used for handling
    operations that span several aggregates and several Bounded Contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Command handlers and aggregate events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the Command pattern, each application domain operation is handled
    by a so-called command handler. Since each command handler encodes a single application
    domain operation, all of its actions must take place in the same transaction because
    the operation must succeed or fail as a whole. Command handlers perform their
    job by calling aggregates and repository methods. However, some actions might
    be triggered by state changes inside aggregates, so they can’t be called by command
    handlers but must rely on some form of direct aggregate-to-aggregate communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep aggregates separated, usually, communication among aggregates and also
    with other Bounded Contexts is done through events. We already discussed domain
    events used to communicate with other bounded contexts in the *Domain events*
    subsection. However, direct communication among aggregates can also take advantage
    of the publisher/subscriber pattern to keep the code more modular and easy to
    modify. It is good practice to store all the events when they are triggered during
    the processing of each aggregate, instead of executing them immediately, in order
    to prevent event execution from interfering with the ongoing aggregate processing.
    This is easily achieved by adding the following code to the abstract `Entity`
    class defined in the *Entities* subsection of this chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `IEventNotification` is an empty interface that’s used to mark classes
    as events.
  prefs: []
  type: TYPE_NORMAL
- en: Event processing is usually performed immediately before changes are stored
    in the storage engine. Accordingly, a good place to perform event processing is
    immediately before the command handler calls the `SaveEntitiesAsync()` method
    of each `IUnitOfWork` implementation (see the *Repository pattern* subsection).
    Similarly, if event handlers can create other events, they must process them after
    they finish processing all their aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subscriptions to an event, `T`, can be provided as an implementation of the
    `IEventHandler<T>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Analogously, the command pattern is implemented with a `command` object, which
    contains all the input data of the application domain operation, while the code
    that implements the actual operation can be provided through a command handler
    that is an implementation of an `ICommandHandler<T>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ICommand` is an empty interface that’s used to mark classes as commands.
    `ICommandHandler<T>` and `IEventHandler<T>` are examples of the **Command pattern**
    we described in *Chapter 6*, *Design Patterns and .NET 8 Implementation*.
  prefs: []
  type: TYPE_NORMAL
- en: Each `ICommandHandler<T>` can be registered in the dependency injection engine
    so that classes that need to execute a command, `T`, can use `ICommandHandler<T>`
    in their constructor. This way, we decouple the abstract definition of a command
    (the class that implements `ICommand`) from the way it is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same construction can’t be applied to events, `T`, and their `IEventHandler<T>`,
    because when an event is triggered, we need to retrieve several instances of `IEventHandler<T>`
    and not just one. We need to do this since each event may have several subscriptions.
    However, a few lines of code can easily solve this difficulty. First, we need
    to define a class that hosts all the handlers for a given event type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Declaring a `handlers` `IEnumerable<IEventHandler<T>>` parameter in the `EventTrigger<T>`
    constructor lets a .NET dependency injection engine pass all `IEventHandler<T>`
    implementations available in the dependency injection container to this `handlers`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that each class that needs to trigger event `T` requires `EventTrigger<T>`
    and then passes the event to be triggered to its `Trigger` method, which, in turn,
    invokes all the handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to register `EventTrigger<T>` in the dependency injection engine.
    A good idea is to define the dependency injection extensions that we can invoke
    to declare each event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This `AddEventHandler` extension must automatically produce a dependency injection
    definition for `EventTrigger<T>` and must process all the handlers that are declared
    with `AddEventHandler` for each type, `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following extension class does this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `H` type passed to `AddEventHandler` is recorded in the dependency injection
    engine, and the first time `AddEventHandler` is called, `EventTrigger<T>` is also
    added to the dependency injection engine. Then, when an `EventTrigger<T>` instance
    is required by the dependency injection engine, all `IEventHandler<T>` types added
    to the dependency injection engine are created, collected, and passed to the `EventTrigger(IEnumerable<IEventHandler<T>>
    handlers)` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: When the program starts up, all the `ICommandHandler<T>` and `IEventHandler<T>`
    implementations can be retrieved with reflection and registered automatically.
    To help with automatic discovery, they inherit from `ICommandHandler` and `IEventHandler`,
    which are both empty interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `EventDIExtensions` class, which is available in this book’s GitHub repository,
    contains methods for the automatic discovery and registration of command handlers
    and event handlers. The GitHub repository also contains an `IEventMediator` interface
    and its `EventMediator` implementation, whose `TriggerEvents(IEnumerable<IEventNotification>
    events)` method retrieves all the handlers associated with the events it receives
    in its argument from the dependency injection engine and executes them. It is
    sufficient to have `IEventMediator` injected into a class so that it can trigger
    events. `EventDIExtensions` also contains an extension method that discovers all
    the queries that implement the empty `IQuery` interface and adds them to the dependency
    injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: A more sophisticated implementation is given by the `MediatR` NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the main reasons for the adoption of DDD and why
    and how it meets the needs of the market. We described how to identify domains
    and how to coordinate the teams that work on different domains of the same application
    with domain maps. Then, we analyzed the way DDD represents data with entities,
    value objects, and aggregates, providing advice and code snippets so that we can
    implement them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: We also described the onion architecture frequently used in conjunction with
    DDD-based projects, and compared it with the classical layer architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered some typical patterns that are used with DDD—that is, the repository
    and Unit of Work patterns, domain event patterns, CQRS, and event sourcing. Then,
    we learned how to implement them in practice. We also showed you how to implement
    domain events and the command pattern with decoupled handling so that we can add
    code snippets to real-world projects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What provides the main hints so that we can discover domain boundaries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main tool that’s used for coordinating the development of a separate
    Bounded Context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that each entry that composes an aggregate communicates with the
    remainder of the system with its own methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is there a single aggregate root?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many repositories can manage an aggregate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a repository interact with the application layer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the Unit of Work pattern needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the reasons for the light form of CQRS? What about the reasons for
    its strongest form?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main tool that allows us to couple commands/domain events with their
    handlers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that event sourcing can be used to implement any Bounded Context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eric Evans, Domain-Driven Design: [https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More resources on DDD can be found here: [https://domainlanguage.com/ddd/](https://domainlanguage.com/ddd/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A detailed discussion of CQRS design principles can be found here: [http://udidahan.com/2009/12/09/clarified-cqrs/](http://udidahan.com/2009/12/09/clarified-cqrs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on MediatR can be found on MediatR’s GitHub repository: [https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good description of event sourcing, along with an example of it, can be seen
    in the following blog post by Martin Fowler: [https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
