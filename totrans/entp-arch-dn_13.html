<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-265"><a id="_idTextAnchor470"/>13</h1>
<h1 id="_idParaDest-266"><a id="_idTextAnchor471"/>Externalization of Authorization</h1>
<p>The previous chapter was about business rules management in general. In this chapter, we will analyze a particular case of authorization management, since the rights and privileges of users are one of the most common uses of business rules that you can find in many applications. Since there exist two standards for authorization management (as already explored<a id="_idIndexMarker736"/> in <a href="B21293_08.xhtml#_idTextAnchor271"><em class="italic">Chapter 8</em></a>) we will quickly explain the first and more complete standard, namely <strong class="bold">XACML</strong> (short for, <strong class="bold">eXtensible Access Control Markup Language</strong>) because it helps <a id="_idIndexMarker737"/>understand how it relates to the <strong class="bold">Single Responsibility Principle</strong> (<strong class="bold">SRP</strong>); then, we will create a more complete example with<a id="_idIndexMarker738"/> the new, lighter, standard, which is <strong class="bold">OPA</strong> (short for, <strong class="bold">Open </strong><strong class="bold">Policy Agent</strong>).</p>
<p>We will then end this chapter (and the series of four chapters on the different parts of an ideal information system) by reflecting on how to implement this authorization in practice, which will open the way to the analysis and the implementation of the information system for <code>DemoEditor</code>, which has accompanied us so far, illustrating with examples the concepts studied, and it will, of course, also serve as a practical example of the implementations of what we learned in the previous chapter.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>A BRMS and authorization management</li>
<li>Applying authorization to our same information syst<a id="_idTextAnchor472"/>em</li>
</ul>
<h1 id="_idParaDest-267"><a id="_idTextAnchor473"/>A BRMS and authorization management</h1>
<p>As I quickly<a id="_idIndexMarker739"/> mentioned in the previous chapter, there is a functional domain in the <code>DemoEditor</code> sample information system where an externalized business rules engine would be interesting, and this domain is one of authorization. Before explaining the need to clarify the semantics of the “rights” business domain, examine the main paradigms to implement authorization in software applications, and also explain one of the standards associated with this function, which decomposes very well the different responsibilities it entai<a id="_idTextAnchor474"/>ls.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor475"/>The semantics of identity and authorization management</h2>
<p>As<a id="_idIndexMarker740"/> explained in <a href="B21293_09.xhtml#_idTextAnchor318"><em class="italic">Chapter 9</em></a>, semantics is the foundation of all things in architecture, and we will clarify the terms we use for certain concepts in order to not incorrectly define the business domain model. Thus, it is important to clearly define the<a id="_idIndexMarker741"/> different subdomains of <strong class="bold">Identity and Authorization Management</strong> (<strong class="bold">IAM</strong>) and how we name things inside of them. Let’s start with the concept associated with <strong class="bold">identification</strong> (who you are) and <strong class="bold">authentication</strong> (how you can prove your identity):</p>
<div><div><img alt="Figure 13.1 – Identification and authentication semantics" src="img/Figure_13.1_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Identification and authentication semantics</p>
<p>A first – and very important – point is that authorization should depend only on your identity (and, of course, some elements of context, but we will come to that later) and never on how you prove your identity. At least, this is how we are going to work on the information system for now. Of course, we may in the future have to take into account that some authentication methods are safer than others and that some applications may request a strong form of multi-factor authentication to open certain features. But this use case will be handled with the addition of attributes to identification to account for this. After all, even in this situation, an application does not need to know exactly what you authenticated but, rather, how strong a trust it can have in the identity that it is provided with.</p>
<p>There are already <a id="_idIndexMarker742"/>some cases like this in the standard identity profiles associated with OAuth; for example, in addition to the <code>email</code> attribute, the contact profile can provide an <code>email_validated</code> attribute that specifies that the identity provider has verified that the identified user indeed has control of a certain email address. This is a way of augmenting trust in the identification without the identity consumer knowing anything about <em class="italic">how</em> the email has been verified. We are not going to dig deeper into authentication, as this is a hugely sophisticated domain, and what we want to model precisely is the authorization domain. For now, let’s just remember that a given user can be authenticated by different accounts/ways to prove its identity.</p>
<p>The important aspect of what will follow is that users can belong to groups, which ultimately will bring them some commonalities in rights management. These groups can be formed in a hierarchical tree in order to ease complex management. Bear in mind that we are still in the identification domain, so belonging to a group does not directly give you certain rights. Groups are simply part of your identity, as are any other attributes such as <code>lastname</code> or <code>firstname</code>, to give examples from the OpenID Connect/JWT/OAuth standards.</p>
<p>Let’s now discuss the other half of IAM, which<a id="_idIndexMarker743"/> is <strong class="bold">authorization</strong> management. The main semantics are as follows:</p>
<div><div><img alt="Figure 13.2 – Authorization semantics" src="img/Figure_13.2_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Authorization semantics</p>
<p>The preceding diagram is, of course, just an example, and you may have your vocabulary for the terms used within it. But this is precisely the goal of such a semantics analysis; I know that some people use the word “<em class="italic">profiles</em>” to describe the groups of people from the identification domain, that some use the word “<em class="italic">group</em>” to discuss authorization groups, and that some others replace “<em class="italic">role</em>” with “<em class="italic">profile</em>.” But there are also people using other vocabulary, and the important thing is not who is right; as long as there is no established standard, everyone is. The important thing is to be able to understand univocally what we talk about. In this book, a group will be an entity that organizes sets of users that are similar in their identity, while a role will be a set of authorizations that are often used together.</p>
<p>Let’s explain <a id="_idIndexMarker744"/>in just a bit more detail the concept of permission, which is defined by pointing to a resource and an operation (or several, if this is easier in your model). For example, removing a book from the data referential service may be something that only some editors have the right to do; we would then design the corresponding permission by pointing to the <code>book</code> resource and the <code>DELETE</code> verb. The use of the REST-based vocabulary is, of course, intentional – first, it makes it more precise to explain what we mean; second, it allows for a precise alignment of what will happen in the software. In this case, this permission will be associated with the possibility of sending a <code>DELETE</code> verb to the <code>/api/books</code> API, and it is thus implemented without any possible confusion in the books data referential service.</p>
<p>Of course, some permissions are linked – a senior editor will not only be able to delete books but also create, modify, and read them. This is where roles come into play – grouping together many permissions that make sense together. This is where semantics is also important. Naming the editor role is a difficult choice because we will tend to use the word <code>editors</code> for two things that are fundamentally different: the group to which all users belong when they <code>editors</code> for the identification group and use a name such as <code>book-editor</code> for the role.</p>
<p>Semantics is important in another area – since there are several applications in an information system and each of them (at least the data referential service) deals with specific resources, it is important to specify the main resource in the name of the role; otherwise, they would get confused with each other. By the way, this is how we will group the two previous schemas, showing this multiplicity of “rights management targets” against the unicity of identification concerns:</p>
<div><div><img alt="Figure 13.3 – Each application takes care of its authorizations" src="img/Figure_13.3_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Each application takes care of its authorizations</p>
<p>Before we<a id="_idIndexMarker745"/> go into more detail about what is in the <strong class="bold">Authorization</strong> boxes, let’s make a useful digression on the way IAM is handled in many applications and how it should be used to obtain a neat business/IT alig<a id="_idTextAnchor476"/>nment.</p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor477"/>A digression on IAM implementation</h2>
<p>In most existing<a id="_idIndexMarker746"/> information systems, identification is still handled directly by many applications, leading to the well-known antipattern represented here:</p>
<div><div><img alt="Figure 13.4 – An antipattern where IAM is in many applications" src="img/Figure_13.4_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – An antipattern where IAM is in many applications</p>
<p>These <a id="_idIndexMarker747"/>multiple implementations of a unique feature are one of the most observed misalignment patterns in existing information systems. It leads not only to the duplication of accounts, making it more difficult to manage access rights, but also to the duplication of different passwords, which is a pain for users and quickly causes security issues because lots of them will use similar passwords across their line of business applications, making a password breach suddenly more impactful because the attack surface is increased.</p>
<p>One method that is often used by companies to compensate for this difficulty is to automate the “newcomer” process and implement some kind of tool that will automatically create accounts in every application of the information system. Unless you only have a legacy application and no intention of modernizing your system (for example, because the activity will be closed in a few years), this is always the worst move that can be done, as it tends to crystallize the problem – since you have added another (potentially costly) component to the system, you will be even less keen on changing it again. The following diagram shows the second antipattern in this approach:</p>
<div><div><img alt="Figure 13.5 – The process for a newcomer in its coupled version" src="img/Figure_13.5_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – The process for a newcomer in its coupled version</p>
<p>This diagram <a id="_idIndexMarker748"/>shows all the additional problems:</p>
<ul>
<li>The process is designed in the upper functional layer, but it cannot be modified by the business persons, since its execution is based on a job executed by an <strong class="bold">ETL</strong> application and, thus, can only be modified by technicians, which creates some time coupling (a change of regulation will be applied not when the business needs it but when the IT department can get around to in its many projects).</li>
<li>Talking about the many things the IT has to do, did you notice that the only actor in the BPMN is <strong class="bold">IT</strong>? This is logical since all tasks have been designed to be automated and IT is considered responsible for managing the users inside the software, simply because they are the ones who have installed it or know how to access the APIs. This is a very common problem; instead of having functional administrators taking full responsibility for their applications, they rely entirely on IT for this. Although this can be considered normal for technical tasks, this is a problem in this case because trusting IT to add users and determining their default permissions can be a recipe for regulatory disaster. After all, how could you be mad at an intern who has dealt with an urgent ticket from accounting by creating a user with a default password, not knowing that, in this legacy application, users are created by default with full rights, which allows the newcomer user to access the bank accounts of the company and empty them on their very first day in the job?</li>
<li>The process<a id="_idIndexMarker749"/> is directly implemented inside an ETL application, which is the number one misalignment antipattern. If you continue in this direction, very soon, all the business processes of the company will depend on one piece of software that, in addition, is a single point of failure in your IT system. What if it is discontinued? What if the editor suddenly raises prices? What if there is a general failure?</li>
<li>In some cases, the person doing the implementation may be lucky enough to be able to call a nice, backward compatible, and well-documented API such as on <code>Application A</code>, allowing for some kind of decoupling, or even the possibility to expose this API in the BCM. But in <code>Application B</code>, the API talks directly to a library of the application, making this interoperation brittle to any change of version. In <code>Application C</code>, it is even worse, since the only way found to automate the creation of an account was to insert lines directly into the database. The behavior might become completely erratic in the next version, or even as soon as you roll out in production because you have forgotten an important part of the persistence in your script, and so on.</li>
</ul>
<p>The preceding approach tends to embed in a system this antipattern, where each application takes care of its own identification and even authentication, whereas it should only handle authorization (this antipattern has to stay there, since the application handles the resources, and the permissions apply to these). Instead of this, the right move would be to progressively adopt the following correct pattern:</p>
<div><div><img alt="Figure 13.6 – A correct map of IAM responsibility" src="img/Figure_13.6_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – A correct map of IAM responsibility</p>
<p>In this case, the <a id="_idIndexMarker750"/>identification and authentication responsibilities are implemented by a dedicated piece of software (in our example, an Apache Keycloak IAM server, plugged into a Microsoft AD user directory) and all applications still take care of authorization on the resource they respectively manage, but they point to this unique identification feature that they need to apply the right permissions (again, without knowing anything about the authentication process). Of course, this would not be done in one day; you need to progressively equip your information system with an application that supports externalized authentication/identification. Nowadays, almost all modern enterprise-grade applications do so, and if they are browser-based, it is even possible in some cases to handle these responsibilities with a frontend protecting them if needed. And since you will likely always keep some legacy applications, you will certainly end up with a “middle of the journey” information system such as the following, which is already much better and easier to handle:</p>
<div><div><img alt="Figure 13.7 – The process for a newcomer in a perfectly aligned version" src="img/Figure_13.7_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – The process for a newcomer in a perfectly aligned version</p>
<p>Do not be put out by the added complexity to the diagram; it is simply more complete because I have added more details – in particular, the hardware layer, which had not been shown before. In this part of the information system, many advantages can be seen on the right of the diagram, but we will discuss them now in more detail:</p>
<ul>
<li>The implementation of the process can now be dedicated to any tool, and it will not have any coupling to the technical stack (except for the call to the Apache Keycloak API to add a global user, but it is extremely rare, as this can be based on the LDIF standard and a change of software would not be visible by the process users).</li>
<li>If the process had to be modified – for example, by adding another step for a legacy application that had been forgotten in the first version – it could be done by decision-makers alone. In the new version, this additional task would work like the existing one for the legacy accounting system – when a user-based task is completed, an email would be sent to the functional administrator of the application, together with a link to the procedure to add the requested user. When done, this person would click on a link in the email received to signal that the task is done, which would also close the process.</li>
<li>The first <a id="_idIndexMarker751"/>task dedicated to the IT department would still be manual, as there would be a form to fill in (the one from Apache Keycloak or – as represented here – a form provided by the BPMN engine that would call the API from Keycloak associated with the <code>Create user</code> function of the BCM). If the API from Keycloak follows the LDIF standard, it could be considered as the standardized unique point associated with the function in the information system, making it easier to replace Keycloak with another software if needed.</li>
<li>In addition, Keycloak acts as an indirection layer to the actual user’s directory. If this had to change to another directory, or even use identity federation and several directories, this would be transparent for any user of the API associated with the <code>Create </code><code>user</code> function.</li>
</ul>
<p>Of course, the problem of the legacy application would not completely disappear, but at least, in this configuration, the legacy impact is progressively reduced and the right functions are ready for the new and more modern applications to work in the way they should. Also, the legacy application is isolated into a silo and will be easier to discard in the future. In this example, we could start by removing the task from the process, and then suppress the old application with its locally coupled identification and authentication features. Finally, we have to verify that the old server with an unsupported or exotic, hard-to-maintain operating system does not serve any other software role in the<a id="_idTextAnchor478"/> system.</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor479"/>Role-based access control and attribute-based access control models</h2>
<p>After <a id="_idIndexMarker752"/>that rather long – but hopefully useful – digression into IAM implementations, we will return to where we<a id="_idIndexMarker753"/> were before, which is the fact that, in a good information system, identification and authentication features are unique for all applications, but the authorization feature is duplicated for each resource. Indeed, only the application that handles the resources knows how to handle the permissions on them. In our example with the book data referential service, we saw that a role called <code>book-edition</code> would make sense. But what about in an archiving system? Chances are we would find roles such as <code>archivist</code> or <code>readonly-verifier</code> in there, but <code>book-edition</code> would make no sense.</p>
<p>This is not to say that we could not find common role names between applications; on the contrary – similar names should be considered carefully because they do not mean the same thing. This is why it is so dangerous, even though it is frequently done, to name roles <code>administrator</code>. Of course, everyone understands what this means –users with this role can perform every operation in the software. But, specifically, the definition of “everything” can differ from one software to another. If you add to this situation a group called <code>administrators</code> inside your users’ directory, which is supposed to mean that the users in this group should have full permissions in every application, the confusion is increased.</p>
<p>I personally recommend restricting this situation to <code>domain-administrator</code> and arranging for your IT department to never be a functional administrator of an application, only of the machines they are installed on (which does not prevent them from indirectly seeing or manipulating data, but this is another problem that should be dealt with by contractual standards and full traceability of administrative actions).</p>
<p>To account for this, a better representation of the preceding diagram would be the following one:</p>
<div><div><img alt="Figure 13.8 – Affecting authorizations on permissions rather than resources" src="img/Figure_13.8_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Affecting authorizations on permissions rather than resources</p>
<p>The<a id="_idIndexMarker754"/> left-hand side is not <a id="_idIndexMarker755"/>as detailed in the preceding diagram, but this is what we wanted. Since we stated that authorizations should be based on identity, how could we do this in practice? One of the easiest and most commonly used ways is the following:</p>
<div><div><img alt="Figure 13.9 – A pure role-based access control approach" src="img/Figure_13.9_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – A pure role-based access control approach</p>
<p>When roles are associated (or “mapped”) to groups or directly to users, the paradigm of rights management is <a id="_idIndexMarker756"/>called <strong class="bold">Role-Based Access Control</strong> (<strong class="bold">RBAC</strong>). The main advantage of this approach is that it is very simple to implement. Since the person who administrated rights only sees the role, the diagram could even be represented like this from their point of view:</p>
<div><div><img alt="Figure 13.10 – A documented RBAC approach" src="img/Figure_13.10_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – A documented RBAC approach</p>
<p>This <a id="_idIndexMarker757"/>eases<a id="_idIndexMarker758"/> the work of developers as well because, as long as they respect the contractual text-based definition of the rights associated with the role, they can choose whatever implementation method for the role they prefer, or even a mix of them:</p>
<div><div><img alt="Figure 13.11 – Other possible role implementations in RBAC" src="img/Figure_13.11_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11 – Other possible role implementations in RBAC</p>
<p>The<a id="_idIndexMarker759"/> textual <a id="_idIndexMarker760"/>definition of the role may cause some trouble, due to the text’s imprecise nature and the potential for knowledge to become outdated over time, it is subject to approximation, particularly if the editor role has a high personnel turnover and/or does not document clearly its software features.</p>
<p>Since pure RBAC is quite restrictive, applications often allow for the direct mapping of granular permissions to users or groups, as schematized here:</p>
<div><div><img alt="Figure 13.12 – Fine-grained permission as an improvement on RBAC" src="img/Figure_13.12_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12 – Fine-grained permission as an improvement on RBAC</p>
<p>This <a id="_idIndexMarker761"/>extends the possibilities, but it also makes it much more difficult for functional administrators to keep track <a id="_idIndexMarker762"/>of the rights given to different users if these cases become more than just exceptions. As the number of users increases, the use of groups and roles becomes more and more important. The temptation to delegate some rights administration responsibility increases as well, but it is essential to implement this with rigid rules and train people carefully, as it can quickly become a mess, where users with the same job title end up with different rights, depending on who has given them these rights. Even worse, some users end up with full permissions on the software because the new functional administrator does not understand precisely how the rights management system works. This is yet another reason to not give this responsibility to IT, however tempting this may be, because they would have control of the technical part of the application.</p>
<p>Another, more <a id="_idIndexMarker763"/>sophisticated, way to extend the RBAC features is to shift to what is called <strong class="bold">Attribute-Based Access Control</strong> (<strong class="bold">ABAC</strong>). In this rights management paradigm, rules are set that link attributes from the identification to attributes of the resources:</p>
<div><div><img alt="Figure 13.13 – An ABAC approach" src="img/Figure_13.13_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13 – An ABAC approach</p>
<p>This <a id="_idIndexMarker764"/>allows us, for example, to <a id="_idIndexMarker765"/>overcome the limitations that would happen with RBAC in our sample <code>DemoEditor</code> information system, if authors simply added a <code>book-edition</code> role. Indeed, this role would either give them the right to read and write books, <code>books</code> resource but not specific books.</p>
<p>This is a job for ABAC, and the attributes it would use are the following:</p>
<div><div><img alt="Figure 13.14 – An ABAC implementation with a BRMS" src="img/Figure_13.14_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14 – An ABAC implementation with a BRMS</p>
<p>You will <a id="_idIndexMarker766"/>notice <a id="_idIndexMarker767"/>that permissions are still represented – and we could include roles as well – because ABAC is not exclusive of RBAC but, rather, complements it in its forthcoming.</p>
<p>What would happen technically in such a scenario is the following:</p>
<ul>
<li>An application would call the <code>GET</code> verb on <code>/api/books/978-2409002205</code>.</li>
<li>This request would be accompanied by a bearer-based authentication header.</li>
<li>The JWT token would include the custom attribute providing the author internal identifier (or another way to go would be to base the association to the author on the email or another standard attribute).</li>
<li>Upon reception of this request, the books referential service application would call the authorization central API, providing it with everything it knows about the request – the incoming JWT-born identity, the attributes of the book requested, and so on.</li>
<li>The authorization app would find the rule that applies to the situation – in this case, <code>GET</code> on a book.</li>
<li>It would first check that the incoming user has <code>author_id</code> and that this is the ID associated with one of the authors of the given book (looking at the <code>book_mainauthor_id</code> attribute and – if necessary – the <code>book_secondaryauthors_ids</code> array of attributes).</li>
<li>It <a id="_idIndexMarker768"/>would then check that the initial request to the book referential service does not contain something such as <code>$expand=release-information</code>, since this data will not be seen by the author.</li>
<li>It <a id="_idIndexMarker769"/>would realize it needs to check that the author has not been blocked and would call a <code>GET</code> request to <code>/api/authors/x24b72</code>. This would be done with a privileged account with full read rights, as we consider that the BRMS has a justified “right to know” due to its function in the system.</li>
<li>An alternative to this would be for the books referential service to provide an extended view of the book, just as if there had been a call to <code>/api/books/978-2409002205?$expand=authors</code>.</li>
<li>For most advanced authorization systems, these three checks would be done in parallel to save time.</li>
<li>If everything is correct, the BRMS will send a <code>200 OK</code> HTTP response to the call from the books referential service.</li>
<li>The book referential service would then grant the requested access.</li>
</ul>
<p>Of course, if anything goes wrong in these steps, the request will be refused with a <code>403 Forbidden</code> status code. This could happen if the rules are not respected, but also if the BRMS system does not respond in time. This behavior is expected, as the so-called “graceful degradation” would imply, for security reasons, that the system does not take any risk to disclose date data or allow any operation if it is not sure it is allowed. This means that the authorization is another SPOF in the system and should be operated corresponding to this requested level of service.</p>
<p>I hesitate to <a id="_idIndexMarker770"/>discuss <strong class="bold">ReBAC</strong> (<strong class="bold">Relationship-Based Access Control</strong>), which looks like a nice complement to the RBAC and ABAC paradigms but, at the time of writing, has not yet reached a mature enough state. In a nutshell, the principle of ReBAC is to manage authorizations based on links between entities; hence, it has a strong link to DDD. For example, this <a id="_idIndexMarker771"/>approach allows you to easily give writing permission to an author on<a id="_idIndexMarker772"/> their books while keeping the books of other authors with read-only permissions. This can, of course, also be done with ABAC, but ReBAC makes it a little bit simpler, by basing its functioning on relationships instead of simply attributes. To read a bit more about ReBAC, you can start at <a href="https://en.wikipedia.org/wiki/Relationship-based_access_control">https://en.wikipedia.org/wiki/Relationship-based_access_control</a> and then check what OSO states about this mode at <a href="https://www.osohq.com/academy/relationship-based-access-control-rebac">https://www.osohq.com/academy/relationship-based-access-control-rebac</a>.</p>
<p>OpenFGA (<a href="https://openfga.dev/">https://openfga.dev/</a>) is also a project that is worth looking at if you need a clean external authorization management system that is ReBAC-capable. Although still nascent, the project has already been referenced as a Cloud Native Computing Foundation project. If you want to check out what it could do for your authorization needs, one of the best ways to start is to tweak the samples provided in the sandbox (<a href="https://play.fga.dev/sandbox">https://play.fga.dev/sandbox</a>).</p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor481"/>The XACML approach</h2>
<p>Now<a id="_idIndexMarker773"/> that the different organizations of rights management have been discussed, we will start discussing a bit more about implementation and, by now, you will certainly have started wondering what kind of norms and standards are available to us. Since we have discussed the different steps to realize an ABAC implementation, it would be interesting to study one of the most complete<a id="_idIndexMarker774"/> specifications and explain how it would fit into these ABAC steps.</p>
<p><strong class="bold">XACML</strong> (<strong class="bold">eXtensible Access Control Markup Language</strong>) specifies how access control can be executed and administered. It is one of the most advanced ways to handle authorization and establishes five different responsibilities to do so:</p>
<ul>
<li>The policy administration point is where rules are defined</li>
<li>The policy retrieval point is where they are stored</li>
<li>The policy decision point is the engine that decides which decision should be taken</li>
<li>The policy information point is where additional attributes that are necessary for rule evaluation are gathered</li>
<li>The policy enforcement point is the place where the result of the decision is applied</li>
</ul>
<p>How these <a id="_idIndexMarker775"/>five responsibilities are spread across one or many applications defines how sophisticated a system will be. In the most simple approach, all five responsibilities can be implemented inside the data referential service that ultimately has to apply the enforcement point (since the data referential service is the one who owns the data, this cannot be externalized). In this mode, the data referential service not only stores the data but also stores the rules, executes them, and decides what it should do depending on the outcome. The only instance in which a responsibility could still be considered as external is if the referential service needs some external data, but it could very well store that as well. In this case, the responsibilities are affected like this:</p>
<div><div><img alt="Figure 13.15 – All authorization responsibilities integrated into an application" src="img/Figure_13.15_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.15 – All authorization responsibilities integrated into an application</p>
<p>By contrast, this is how we could spread the responsibilities in the previous organization of responsibilities we discussed previously:</p>
<div><div><img alt="Figure 13.16 – Authorization responsibilities completely spread across dedicated services" src="img/Figure_13.16_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.16 – Authorization responsibilities completely spread across dedicated services</p>
<p>In this <a id="_idIndexMarker776"/>very clean (but, of course, more expensive to set up) approach, each responsibility is completely separated, and the BRMS and data referential service work together in order to orchestrate them:</p>
<ol>
<li>Before any first interaction, a functional user connects to the PAP and designs the rules (just like what was done in the example previously with the DMN use).</li>
<li>These rules are stored in the associated database, which is the PRP.</li>
<li>The books referential service receives the initial request. It cannot make decisions on its own and delegates the PDP.</li>
<li>It communicates to the deployed BRE the context of the call, in order to get a decision from it.</li>
<li>The PDP needs to retrieve the rules in order to process them. It could call the PRP, but luckily, it has a local clone in our case, where we made the hypothesis that the JBPM server has been used and the console deployed a standalone runtime container for the rules execution.</li>
<li>The PDP may also need some additional information that it could collect through the PIP, which retrieves the <code>blocked</code> status for the author.</li>
<li>The PDP sends the result of its rules decision engine back to the books referential service.</li>
<li>As with the PEP, the books referential service uses the decision sent by the PDP to allow (or not) access to its data and possibly respond to the HTTP response that was presented.</li>
</ol>
<p>Before we show<a id="_idIndexMarker777"/> you a practical example of how to set this up, let me make another digression, this time on how serv<a id="_idTextAnchor482"/>ices should be separated.</p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor483"/>A digression on the granularity of microservices</h2>
<p>First of all, let’s draw a <a id="_idIndexMarker778"/>diagram for a less sophisticated and more common situation, where each data referential service contains its own PRP and PDP in addition to the PEP. In this case, the PAP is generally minimal, as rules are integrated into the code and do not allow for easy management, which means that PRP is simply the code base itself.</p>
<div><div><img alt="Figure 13.17 – The problem of authorization management when data is cloned" src="img/Figure_13.17_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.17 – The problem of authorization management when data is cloned</p>
<p>Can you spot the potential problem? The books referential service does not hold the author’s PDP/PRP, which is logical, since it is not responsible for it. However, it still stores a clone of the author’s data in order to quickly respond to API calls such as <code>/api/books/978-2409002205?$expand=authors</code>. This means that, since it does not know how to filter this kind of data, it might create a breach of confidential data if care is <a id="_idIndexMarker779"/>not taken. In a four-layer diagram, this problem can be seen from a strange misalignment that appears this way:</p>
<div><div><img alt="Figure 13.18 – A representation of the authorization antipattern in the four-layer diagram" src="img/Figure_13.18_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.18 – A representation of the authorization antipattern in the four-layer diagram</p>
<p>This kind of misalignment arises from the fact that authorization has been trusted by the application that stores the data. This way, since the data is duplicated, there are in fact two potentially different ways to apply authorization to the same data! This situation can also happen when we externalize data in a BRMS because the runtime and the PAP may not be synchronized, but the advantages in this case are much more important than the actual drawbacks. Indeed, the decoupling between the JBPM console and the BRE runtime container bears lots of added value – the console is a complex server whereas the runtime container is very light; it is much better to separate them because errors are prone to happen in the first, whereas the second one should have an excellent level of service. When the console is used to deploy a standalone server, it can then crash <a id="_idIndexMarker780"/>without this being a problem. The runtime, conversely, can be made extremely robust, since it is stripped of almost every bit of code that is not immediately necessary to execute the functions. The fact that the console deploys versions of the rulesets makes it possible to create as many runtime servers as needed for performance reasons (thus, you also avoid the SPOF problem, since this service is required by many others and should be extremely stable) without any risk of a lack of consistency, which would be a big problem (imagine explaining to your customers that their rights of access to their tenant data vary on every new request).</p>
<p>Still, this does not mean that all responsibilities should always be added to as many services and different processes as possible. Of course, it may be useful, but, as is often the case in information architecture, the most important thing is to strike the right balance. There have been so many pointless discussions on the internet over which is best between microservices and monolith applications that you can almost surmise the quality of an article just by looking at its title. Of course, the only correct response to what is best is, “<em class="italic">It depends,</em>” and any competent software architect knows that this is not a “one-size-fits-all” situation.</p>
<div><div><img alt="Figure 13.19 – Service granularity advantages and drawbacks" src="img/Figure_13.19_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.19 – Service granularity advantages and drawbacks</p>
<p>I realize I <a id="_idIndexMarker781"/>have been saying this every chapter or so, but it’s worth repeating – what should be a priority in the granularity of services for business functions? If you know that the authorization rules change very rarely and having to wait for a new release is not a problem, then implement what should be a priority in the granularity of services for business functions directly in the code of the associated referential service; you will get the best performance, and you only will have to deal with the problem of securing cloned data if you have some. If it is an issue, consider calling the other referential service if there is any doubt; it will also be a way to refresh part of your cloned data. Conversely, if you can foresee that authorization rules are going to change frequently or there are external circumstances, such as regulation, then consider progressively extracting responsibilities from your data referential service. Foreseeing this kind of thing is admittedly a fine line between over-anticipating and adopting too much of a DRY approach, but this is where judgment, long-time expertise, and having suffered from many previous <a id="_idTextAnchor484"/>experiences come in handy.</p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor485"/>Applying authorization to our sample information system</h1>
<p>XACML was <a id="_idIndexMarker782"/>explained previously but is quite a complex mechanism to put in place. Also, there is not a reference implementation of the protocol, although several products exist such as WSO², Balana, Axiomatics, or products from AT&amp;T. Although these all have their place in big information systems such as banks or insurance, they would be oversized for the small information system that we have decided to simulate in our example, so we are going to use something lighter and closer to t<a id="_idTextAnchor486"/>he main internet protocols.</p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor487"/>The Open Policy Agent alternative</h2>
<p>Open Policy Agent <a id="_idIndexMarker783"/>is a project that is supported by the Cloud Native Computing Foundation and that proposes a nice decoupling between grammar to describe policies. In short, OPA is to XACML what REST is to SOAP – a lightweight alternative that takes on 80% of the job with 20% of the complexity. Instead of installing a full-blown XACML server to show an example of externalizing the authorization responsibility, we are going to use Docker to customize an authorization engine.</p>
<p>OPA uses a declarative language named <code>Rego</code> to describe the policies that should be applied to data to make decisions. It can then execute these policies to provide JSON results that can be exploited in other services, or another part of the code if you use the OPA implementation as a component.</p>
<p>Technically, what will happen is that a request like the following will be sent to OPA, and it will respond with whether the requested access should be authorized or not:</p>
<pre class="source-code">
{
    "input": {
        "user": "jpgou",
        "operation": "all",
        "resource": "books.content",
        "book": "978-2409002205"
    }
}</pre> <p>In this example, the user <code>jpgou</code> requests full access to the <code>content</code> petal of the book, identified <a id="_idIndexMarker784"/>under the ISBN number <code>978-2409002205</code> in the system. If this is granted by the OPA server, it will respond with something like this:</p>
<pre class="source-code">
{
    "result": {
        "allow": true
    }
}</pre> <p>Before diving into the technology again, we need to be precise about what we want to achieve fro<a id="_idTextAnchor488"/>m a functional point of view.</p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor489"/>The functional needs of DemoEditor</h2>
<p>Let’s return <a id="_idIndexMarker785"/>to our <code>DemoEditor</code> sample and describe what should be done from the authorization’s point of view. Of course, in a publishing company, authors have permission to provide the content of books and adjust it as they will, but they should never be able to read the content of another author’s book, in order to avoid plagiarism or even intellectual property theft. Since there are editors who take care of authors, it is logical that they can at least read the content of the books from the authors they manage. Salespersons, on the other hand, do not have any editing responsibility, so they may know some information about the book to prepare sales and orders but have no reason to know anything about the editing process.</p>
<p>In this short description of the stakes at play in the rights management of <code>DemoEditor</code>, it is quite clear that pure RBAC will not be enough, and we will have to resort to ABAC to complete RBAC since there are rules based on the attributes of the book, namely who is the author, and even other information such as the link between authors and their editors. RBAC is simply not enough because an author has more rights on their own books than on the ones from a different author, although they both will benefit from the <code>author</code> authorization profile.</p>
<p>As will be explained in more detail in the following section, we will also add a few rules, such as the fact that salespersons can only see the book once it has reached a certain status, or another one allowing us to block the rights for an author that does not respect the editing contract and should be denied permissions. To do so, we will use the same metaphor <a id="_idIndexMarker786"/>that we used in <a href="B21293_09.xhtml#_idTextAnchor318"><em class="italic">Chapter 9</em></a>, where designating the different categories of data for books is like placing them in the petals of a flower, the core of which contains the most important, entity-defining data, such as the ISBN number and the title of the book. Although it may be tempting to define these petals based on the authorization rules, it is important to keep in mind they have to be drawn from functional constraints, and authorization management is one of th<a id="_idTextAnchor490"/>em, but still only one of them.</p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor491"/>Creating the authorization policies</h2>
<p>Starting with <a id="_idIndexMarker787"/>the definition of the authorization policies will allow us to do two things simultaneously:</p>
<ul>
<li>Explain what kind of authorization behavior we intend to put in place and how the data referential service for the books should work</li>
<li>Explore some of the <code>Rego</code> syntax and what is at play when externalizing authorizations with such a mechanism</li>
</ul>
<p>When writing the <code>policy.rego</code> file (just an arbitrary name) for the authorization management of the books data referential service, we need to start with a package name, which allows us to separate rules from different groups when they are executed in the same engine. The beginning of the file also contains some instructions to import specific keywords and functions (OPA supports plugins and extensions of the grammar to ease its use) or prepare data (which we will come back to further on in the chapter):</p>
<pre class="source-code">
package app.abac
import future.keywords
import data.org_chart</pre> <p>The body of the file then generally starts with a pattern where a main authorization attribute, which we will call <code>allow</code>, is broken down into several finer-grained decision policies. What we want to achieve is an authorization engine that, when exposed to a type of access, will send as a result whether this access should be granted or not. We will come back to this part later when demonstrating how to apply the rules engine, but for now, let’s <a id="_idIndexMarker788"/>continue with the policy-defining file and show how the behavior we discussed will be implemented:</p>
<pre class="source-code">
default allow := false
allow if {
    permission_associated_to_role
    no_author_blocking
    no_status_blocking
    authors_on_books_they_write
    editors_on_books_from_authors_they_manage
}</pre> <p>In order to implement security best practices, access is forbidden by default. This allows for what is called “graceful degradation” – if there is a problem in the authorization subsystem, it will default to the safest situation. In our case, the safest approach is to not allow access, since a lack of availability is, of course, less of a problem than disclosing data to a person who should not have been able to see it, with all the business consequences such an event could have. This is what the first line in the preceding code is about – setting to <code>false</code> the default value of the <code>allow</code> attribute.</p>
<p>The second operation states that, in order to make <code>allow</code> become <code>true</code>, we need to pass five different decisions, each of them needing to be evaluated to <code>true</code>. These decisions are, of course, named in such a way they will be easy to understand and debug (setting authorizations correctly is somewhat of a challenge, but this will almost never be 100% correct at the first attempt). The rest of the file will basically be about detailing these five main decisions, but before we declare how they work, we need to prepare some data. Indeed, as we will explain in the next section, we need some referential service data in order for the engine to make decisions. For example, since we stated that editors should have access to books from the authors they coach, there will be an obvious need for the engine to know about the links between authors and editors. Some other information, such as the status attribute of the book, will also be useful. All this data will mostly come from the data referential service to the engine, but it will be basic data, and we may glean some information from it before actually using the whole set of data to infer decisions.</p>
<p>One such<a id="_idIndexMarker789"/> piece of information is the roles the current user owns. As stated previously, we will need some bits of RBAC, even if it is not enough. That means the user will be linked to some roles, some of them directly and some of them through the user belonging to identification groups. The following grammar expresses precisely this:</p>
<pre class="source-code">
user_groups contains group if {
    some group in data.directory[input.user].groups
}
user_group_roles contains role if {
    some group in user_groups
    some role in data.group_mappings[group].roles
}
user_direct_roles contains role if {
    some role in data.user_mappings[input.user].roles
}
user_roles := user_group_roles | user_direct_roles</pre> <p>Groups can be found in a piece of data called <code>directory</code>, by looking at the entry in the list designated by the value of the input variable called <code>user</code>. Once this user is found in the list, the <code>groups</code> attribute will provide the list of identification groups. These will then be used to retrieve the roles associated with the groups, leveraging a collection called <code>group_mappings</code>. The same logic will be applied to a collection that sends the roles directly applied to a user, and the two role lists will simply be merged by the last operation shown in the preceding code.</p>
<p>We will also need information about the author potentially associated with the user. This is something I have not explained fully yet, briefly mentioning the fact that an author uses a user to access the information system from <code>DemoEditor</code> even if they are not really part of an organization, or at least not employees of it. This means that, first, access will have to be provided to them (we will come back to how to do this when implementing the associated function). This also means that there should be a way somehow to associate these two entities in the information system. A method that happens quite often is to use a verified <code>email</code> attribute to link them together. For the moment, we will just consider that the user’s information is contained in the <code>author</code> entity. The <a id="_idIndexMarker790"/>rule to retrieve the association is quite easy to write – it simply loops over the list of authors, and if the <code>user</code> associated with an author is the one the request for access relates to, then the author is the one we are looking for:</p>
<pre class="source-code">
user_author contains author if {
    some author in data.authors
    author.user == input.user
}</pre> <p>In fact, we should refer to authors rather than just an author because we know there will functionally be only one, but technically, we will use a list even if the name of the variable remains in the singular form, <code>user_author</code>.</p>
<p>The same applies to the book that the request talks about, as we need to retrieve its ID from the list of data to be able to make some decisions from rules on book attributes:</p>
<pre class="source-code">
book contains b if {
    some b in data.books[input.book]
}</pre> <p>In the case of an author, we also have to retrieve the list of books they are the writer of because some rules apply to this as well:</p>
<pre class="source-code">
author_books contains book if {
    some author in user_author
    some b in data.books
    b.editing.author == author.id
}</pre> <p>Now that all the necessary data is collected, we can start discussing the rules themselves, taking the five units of rules separately and breaking them down even more. The first rule that applies is that permissions should be owned by the user associated with the request. It will not be enough to grant access, but this is nonetheless a necessary <a id="_idIndexMarker791"/>constraint. In order to know whether the user should be allowed access to the resource they requested, all accesses provided by roles should be studied. If one corresponds to the type of resource and the operation requested, then it is a match, and the permission is applied:</p>
<pre class="source-code">
permission_associated_to_role if {
    some access in user_accesses_by_roles
    access.type == input.resource
    access.operation == input.operation
}</pre> <p>The following rule makes it happen that if someone gets a right to <code>books.content</code>, <code>books.sales</code>, or <code>books.editing</code> (one of the petals of the flower corresponding to the data referential service), then they automatically obtain a right to the core of the flower, which is logical, since having access to some data without being able to link it to a given entity would not prove to be very useful:</p>
<pre class="source-code">
permission_associated_to_role if {
    some access in user_accesses_by_roles
    "books" == input.resource
    access.operation == input.operation
}</pre> <p>Since we have two rules with the same name (<code>permission_associated_to_role</code>) instead of two rules with different names inside the same group, there is a big difference in processing, as it means that rules are considered to be separate by an “or” operator (and not all needs to be true for the result to be true, such as what was set up previously for <code>allow</code>). Also, we are even going to add a third case where this part of the policy should be granted, namely when the access provided contains <code>all</code> as an operation. In this case, whether the requested operation is <code>read</code>, <code>write</code>, or any other value, it will be granted (at least based on this criteria):</p>
<pre class="source-code">
permission_associated_to_role if {
    some access in user_accesses_by_roles
    access.type == input.resource
    access.operation == "all"
}</pre> <p>Now, the<a id="_idIndexMarker792"/> question should be, how is <code>user_accesses_by_roles</code> calculated? Well, this time, it is a bit more complicated, with a sub-decision that walks through some tree-like hierarchy of profiles and their associated accesses, contained in the <code>roles</code> entity of the data provided. We will return to the definition in the next section, but for now, it is important to know that we will use a hierarchy to set managers on top, and then salespersons and editors below, and authors under their editors. The interesting bit in this approach will be how easy it is to make it so that the role above receives all the permissions of the one below in the tree. After all, if a salesperson has the right to write the sales values, it is logical that their manager has at least the same rights. The syntax is harder to read, but do not worry about this, as the OPA documentation is well-written, and there are many examples available for even the most convoluted rules:</p>
<pre class="source-code">
user_accesses_by_roles contains access if {
    some role in user_roles
    some access in permissions[role]
}
roles_graph[entity_name] := edges {
    data.roles[entity_name]
    edges := {neighbor | data.roles[neighbor].parent == entity_name}
}
permissions[entity_name] := access {
    data.roles[entity_name]
    reachable := graph.reachable(roles_graph, {entity_name})
    access := {item | reachable[k]; item := data.roles[k].access[_]}
}</pre> <p>When <a id="_idIndexMarker793"/>dealing with the rule stating that an author can only have rights on books they are authors of, we need to apply a little trick. As usual, we start by setting access to false, in order to respect security best practices. And we will set it to <code>true</code> if we can follow the link of authoring when in the case of a book writer, and also simply in the case where the user is not a book writer. That may sound too relaxed a constraint, but remember that this is not the complete result. In this case, this is just the piece of decision that is about the link between an author and their books; if we are dealing with an editor, this rule simply does not apply, but some others will, and all of them need to align in order for the final, summarizing decision to be positive. The result is the following:</p>
<pre class="source-code">
default authors_on_books_they_write := false
authors_on_books_they_write if {
    some role in user_roles
    role != "book-writer"
}
authors_on_books_they_write if {
    some role in user_roles
    role == "book-writer"
    some author in user_author
    some b in data.books
    b.editing.author == author.id
    b.id == input.book
}</pre> <p>By now, you should start to be better accustomed to the <code>Rego</code> syntax, but the third part of the global authorization scheme still requires some thinking, as it needs you to traverse the <a id="_idIndexMarker794"/>whole organizational chart in order to retrieve the link between editors and “their” authors, since we need to apply the rule that an editor only has rights on books from the authors they manage:</p>
<pre class="source-code">
default editors_on_books_from_authors_they_manage := false
editors_on_books_from_authors_they_manage if {
    some role in user_roles
    role != "book-edition"
}
book_author contains b.editing.author if {
    some b in data.books
    b.id == input.book
}
editors_on_books_from_authors_they_manage if {
    some role in user_roles
    role == "book-edition"
    some author in book_author
    some b in data.books
    b.editing.author == author
    b.id == input.book
    user_hierarchy_ok
}
foundpath = path {
    [path, _] := walk(org_chart)
    some author in book_author
    path[_] == author
}
user_hierarchy_ok if {
    some user in foundpath
    user == input.user
}</pre> <p>The fourth <a id="_idIndexMarker795"/>part of the global decision is simpler – it considers that salespersons cannot see a book if it is not in a published or archived status. Again, in order to account for the “or” approach, we need to calculate twice the <code>readable_for_sales</code> attribute, initially set to <code>false</code> for security reasons, respectively for the two values of the status allowing access to the salespersons:</p>
<pre class="source-code">
default no_status_blocking := false
no_status_blocking if {
    some role in user_roles
    role != "book-sales"
}
default readable_for_sales := false
readable_for_sales if {
    book.status == "published"
}
readable_for_sales if {
    book.status == "archived"
}
no_status_blocking if {
    some role in user_roles
    role == "book-sales"
    readable_for_sales
}</pre> <p>The<a id="_idIndexMarker796"/> fifth and final part of the decision is even simpler, and we will not explain the code, simply the rule – if an author has been blocked, they cannot have any access to any book:</p>
<pre class="source-code">
default no_author_blocking := false
no_author_blocking if {
    some role in user_roles
    role != "book-writer"
}
no_author_blocking if {
    some role in user_roles
    role == "book-writer"
    some user in user_author
    user.restriction == "none"
}</pre> <p>Once syntax is complete, we need a second type of information to make a decis<a id="_idTextAnchor492"/>ion. This is what decision data is about.</p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor493"/>Adding some data in order to make decisions</h2>
<p>We had <a id="_idIndexMarker797"/>hinted in the previous section about the fact that data should be provided (and even inferred from other data) in order for the rules engine to be able to make a decision. Next, we will show what kinds of information we should put in place for our example to work. First, we need the definition of roles (remember that a role is a set of rights, each composed of a resource type and an operation type):</p>
<pre class="source-code">
"roles": {
    "book-direction": { "access": []},
    "book-sales": { "parent": "book-direction", "access": [{ "operation": "all", "type": "books.sales" }]},
    "book-edition": { "parent": "book-direction", "access": [{ "operation": "all", "type": "books.editing" }]},
    "book-writer": { "parent": "book-edition", "access": [{ "operation": "read", "type": "books.editing" }, { "operation": "all", "type": "books.content" }]}
}</pre> <p>The <a id="_idIndexMarker798"/>preceding JSON content also defines the notion of <code>parent</code>, which creates a tree of roles, with, for example, <code>book-sales</code> and <code>book-edition</code> placed under <code>book-direction</code>, which means that a director will automatically receive all the permissions granted by default to a salesperson <em class="italic">and</em> the ones granted to editors, in addition of course to the ones described directly on the role itself.</p>
<p>Some data about books will be sent in order to apply some specific rules that need this. In the following example, I have shown a list because I tested different combinations. In actual use, we could simply send the data associated with the only book we request OPA for to decide on its access, and nothing more, in order to preserve performance. Here is the associated data:</p>
<pre class="source-code">
"books": {
    "978-2409002205": { "id": "978-2409002205", "title": "Performance in .NET", "editing": { "author": "00024", "status": "published" }},
    "978-0000123456": { "id": "978-0000123456", "title": ".NET 8 and Blazor", "editing": { "author": "00025", "status": "draft" }}
}</pre> <p>Note that the preceding code is not expressed in a JSON array but as a structure. The same is true for data about authors:</p>
<pre class="source-code">
"authors": {
    "00024": { "id": "00024", "firstName": "Jean-Philippe", "lastName": "Gouigoux", "user": "jpgou", "restriction": "none" },
    "00025": { "id": "00025", "firstName": "Nicolas", "lastName": "Couseur", "user": "nicou" }}</pre> <p>The<a id="_idIndexMarker799"/> organizational chart allows us to define who is the big boss (<code>frfra</code>), define which salespersons and editors are below him (three persons in my example), and finally, to place two authors below the editor, codenamed <code>mnfra</code>:</p>
<pre class="source-code">
"org_chart": {
    "frfra": {
        "frvel": {},
        "cemol": {},
        "mnfra": {
            "00024": {},
            "00025": {}
        }
    }
}</pre> <p>We then simulate what would be sent by a user directory – for example, the groups that each user belongs to. This is somewhat artificial, as we would normally extract this for the JWT token that has been passed through identification, but this is what we will do when hitting the difficulty in code. For now, we will stay quite symbolic with the following tree:</p>
<pre class="source-code">
"directory": {
    "frfra": {"groups": ["board"]},
    "frvel": {"groups": ["commerce", "marketing"]},
    "cemol": {"groups": ["commerce"]},
    "mnfra": {"groups": ["editors", "quality"]},
    "jpgou": {"groups": ["authors"]},
    "nicou": {"groups": ["authors"]}
}</pre> <p>Of course, now <a id="_idIndexMarker800"/>we have the groups, we need the mappings to link them to roles in a true RBAC approach:</p>
<pre class="source-code">
"group_mappings": {
    "board": { "roles": ["book-direction"] },
    "commerce": { "roles": ["book-sales"] },
    "editors": { "roles": ["book-edition"] },
    "authors": { "roles": ["book-writer"] }
}</pre> <p>And since we have decided to be as complete as possible, we will allow – beyond pure RBAC – the possibility to also state some direct association between a user and a role, without the group intermediary:</p>
<pre class="source-code">
"user_mappings": {
    "frvel": { "roles": ["book-edition"] }
}</pre> <p>Now that everything is set for the server to output some results (rules and data), we can go to the next step, which is setting up a real OPA server, feeding it with th<a id="_idTextAnchor494"/>ese two files, and trying out some decisions.</p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor495"/>Deploying a Docker-based OPA server</h2>
<p>It is <a id="_idIndexMarker801"/>so easy to deploy with Docker that we would be asking for trouble not using it to test OPA. The command line to run the server is extremely simple:</p>
<pre class="console">
docker run -d -p 8181:8181 --name opa openpolicyagent/opa run --server --addr :8181</pre> <p>Once the server is up, we will start with a call to push policy definitions in it:</p>
<pre class="console">
curl --no-progress-meter -X PUT http://localhost:8181/v1/policies/app/abac --data-binary @policy.rego</pre> <p>Another<a id="_idIndexMarker802"/> call is used to send the data:</p>
<pre class="console">
curl --no-progress-meter -X PUT http://localhost:8181/v1/data --data-binary @data.json</pre> <p>Finally, we are able to test the OPA server with a simple request that is shown in the following code:</p>
<pre class="source-code">
{
    "input": {
        "user": "jpgou",
        "operation": "all",
        "resource": "books.content",
        "book": "978-2409002205"
    }
}</pre> <p>When called with the following command to send this text content to a <code>POST</code>-using API, the OPA server will send a result in JSON, the rest of the command taking care of retrieving only the part of the result we are interested in:</p>
<pre class="console">
curl --no-progress-meter -X POST http://localhost:8181/v1/data/app/abac --data-binary @input.json | jq -r '.result | .allow'</pre> <p>If executed as is, this normally sends <code>true</code>, meaning that this context of the request is granted by the OPA server. If you get rid of the last part of the command and display the whole response, you will get something like the following, which is really useful for debugging, since it shows the values for all intermediate decisions:</p>
<pre class="source-code">
{
  "result": {
    "allow": true,
    "author_books": [
      [
        "978-2409002205",
        "Performance in .NET",
        {
          "author": "00024",
          "status": "published"
        }
      ]
    ],
    "authors_on_books_they_write": true,
    "book": [
      "978-2409002205",
      "Performance in .NET",
      {
        "author": "00024",
        "status": "published"
      }
    ],
    "editors_on_books_from_authors_they_manage": true,
    "foundpath": [
      "frfra",
      "mnfra",
      "jpgou"
    ],
    "no_author_blocking": true,
    "no_status_blocking": true,
    "permission_associated_to_role": true,
    "permissions": {
      "book-direction": [
        {
          "operation": "all",
          "type": "books.content"
        },
        {
          "operation": "all",
          "type": "books.editing"
        },
        {
          "operation": "all",
          "type": "books.sales"
        },
        {
          "operation": "read",
          "type": "books.editing"
        }
      ],
      "book-edition": [
        {
          "operation": "all",
          "type": "books.content"
        },
        {
          "operation": "all",
          "type": "books.editing"
        },
        {
          "operation": "read",
          "type": "books.editing"
        }
      ],
      "book-sales": [
        {
          "operation": "all",
          "type": "books.sales"
        }
      ],
      "book-writer": [
        {
          "operation": "all",
          "type": "books.content"
        },
        {
          "operation": "read",
          "type": "books.editing"
        }
      ]
    },
    "readable_for_sales": false,
    "roles_graph": {
      "book-direction": [
        "book-edition",
        "book-sales"
      ],
      "book-edition": [
        "book-writer"
      ],
      "book-sales": [],
      "book-writer": []
    },
    "user_accesses_by_roles": [
      {
        "operation": "all",
        "type": "books.content"
      },
      {
        "operation": "read",
        "type": "books.editing"
      }
    ],
    "user_author": [
      {
        "firstName": "Jean-Philippe",
        "id": "00024",
        "lastName": "Gouigoux",
        "restriction": "none",
        "user": "jpgou"
      }
    ],
    "user_direct_roles": [],
    "user_group_roles": [
      "book-writer"
    ],
    "user_groups": [
      "authors"
    ],
    "user_hierarchy_ok": true,
    <a id="_idTextAnchor496"/>"user_roles": [
      "book-writer"
    ]
  }
}</pre> <h2 id="_idParaDest-279"><a id="_idTextAnchor497"/>Testing the authorizations</h2>
<p>These <a id="_idIndexMarker803"/>sample authorizations are not very complicated, but the level of complexity is enough to be hard to handle manually. There are many specific cases that pose questions. For example, if I told you that a manager requests access to the sales data of a book that has not been published yet, what do you think would happen? And, more importantly, what do you think should happen?</p>
<p>Also, the <code>Rego</code> syntax has a steep learning curve. Writing the rules presented previously took me a few hours, if not a day since I am not a specialist, and I am not sure they work exactly the way I think they do.</p>
<p>This is where having good testers is of utmost importance, and their ability to define a testing campaign, find all the corner cases, discuss them with the product owners/customers, and so on will be a great help. Such a test campaign will be created using a Gherkin syntax (see the following sample scenarios). If you use a tool such as SpecFlow, you can create many of these scenarios and test them automatically so that every modification to the rules grammar does not break anything. Once your complete set of tests is ready, you will obtain a report on whether all the series of tests have passed, ultimately reassuring you that all modes you have thought of are correct.</p>
<p>In order to install SpecFlow in Visual Studio, follow the instructions at <a href="https://docs.specflow.org/projects/getting-started/en/latest/index.html">https://docs.specflow.org/projects/getting-started/en/latest/index.html</a>. Then, you will need to create a project of type <code>SpecFlow Project</code>. The result will be some classes with examples of how to use SpecFlow, and we are going to adapt them to our specific needs, which is to test the authorization rules we have set up in OPA. We will use xUnit as the underlying test framework here, but you can, of course, modify this to your preferences:</p>
<div><div><img alt="Figure 13.20 – Creating a SpecFlow project" src="img/Figure_13.20_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.20 – Creating a SpecFlow project</p>
<p>The structure of the <a id="_idIndexMarker804"/>project created will be based on a sample called <code>Calculator</code>, and the very first action is to change the names to fit our own purpose, which is to test OPA:</p>
<div><div><img alt="Figure 13.21 – The SpecFlow project structure" src="img/Figure_13.21_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.21 – The SpecFlow project structure</p>
<p>The <code>OPA.feature</code> content is, in the first step, modified to the following Gherkin content:</p>
<pre class="source-code">
Feature: OPA
Scenario: An author has all rights to the content of their book
    Given book number 978-2409002205 with author id 00024 is in workInProgress status
    And user jpgou belongs to group authors
    And organizational chart is {"frfra":{"frvel":{},"cemol":{},"mnfra":{"00024":{},"00025":{}}}}
    And user jpgou is associated with author 00024 who has a level of restriction none
    When the user jpgou requests all access to the books.content petal of the book number 978-2409002205
    Then access should be accepted
Scenario: An author has no rights to the content of the book from another author
    Given book number 978-2409002205 with author id 00024 is in workInProgress status
    And user jpgou belongs to group authors
    And organizational chart is {"frfra":{"frvel":{},"cemol":{},"mnfra":{"00024":{},"00025":{}}}}
    And user jpgou is associated with author 00024 who has a level of restriction none
    When the user nicou requests read access to the books.content petal of the book number 978-2409002205
    Then access should be refused
Scenario: An author that has been blocked has no rights, even on their own books
    Given book number 978-2409002205 with author id 00024 is in workInProgress status
    And user jpgou belongs to group authors
    And organizational chart is {"frfra":{"frvel":{},"cemol":{},"mnfra":{"00024":{},"00025":{}}}}
    And user jpgou is associated with author 00024 who has a level of restriction blocked
    When the user jpgou requests all access to the books.content petal of the book number 978-2409002205
    Then access should be refused
Scenario: An editor has all rights to the content of the books from the authors they manage
    Given book number 978-2409002205 with author id 00024 is in workInProgress status
    And user jpgou belongs to group authors
    And user mnfra belongs to group editors
    And organizational chart is {"frfra":{"frvel":{},"cemol":{},"mnfra":{"00024":{},"00025":{}}}}
    And user jpgou is associated with author 00024 who has a level of restriction none
    When user mnfra requests all access to the books.content petal of the book number 978-2409002205
    Then access should be accepted
Scenario: An editor has no rights to the content of the books from the authors they do not manage
    Given book number 978-2409002205 with author id 00024 is in workInProgress status
    And user jpgou belongs to group authors
    And user mnfra belongs to group editors
    And organizational chart is {"frfra":{"frvel":{},"cemol":{},"mnfra":{"nicou":{}}}}
    And user jpgou is associated with author 00024 who has a level of restriction none
    When user mnfra requests all access to the books.content petal of the book number 978-2409002205
    Then access should be refused
Scenario: Refusing salesperson access to work-in-progress book
    Given book number 978-2409002205 with author id 00024 is in workInProgress status
    And user frvel belongs to the group commerce
    And organizational chart is {"frfra":{"frvel":{},"cemol":{},"mnfra":{"00024":{},"00025":{}}}}
    When the user frvel requests read access to the books.content petal of the book number 978-2409002205
    Then access should be refused</pre> <p>This <a id="_idIndexMarker805"/>syntax should be easy to read, even for non-developers; the idea of behavior-driven development is that functional people are able to express their requirements in such a language, called Gherkin (which has many more sophisticated features than we show here for simplicity reasons). In order for this Gherkin syntax to be transformed into an automated xUnit test, we need to create a correspondence between the lines in the scenario and the C# functions that implement this part of the test. This is done in the <code>OPAStepDefinitions.cs</code> file. For example, for the <code>Given</code> and <code>And</code> keywords (which are of the same notion), the corresponding functions will be as follows:</p>
<pre class="source-code">
[Given("book number (.*) with author id (.*) is in (.*) status")]
public void AddBookWithStatus(string number, string authorId, string status)
{
    _books.Add(new Book() { Number = number, AuthorId = authorId, Status = status });
}
[Given("user (.*) belongs to group (.*)")]
public void AddUserWithGroup(string login, string group)
{
    _users.Add(new User() { Login = login, Group = group });
}
[Given("user (.*) is associated to author (.*) who has level of restriction (.*)")]
public void AddAuthor(string login, string authorId, string restrictionLevel)
{
    _authors.Add(new Author() { Login = login, Id = authorId, Restriction = restrictionLevel });
}
[Given("organizational chart is (.*)")]
public void SetOrganizationChart(string orgChart)
{
    _orgChart = orgChart;
}</pre> <p>In the initialization part of the class containing this function, we will, of course, have a member to store the books (and other lists for other entities needed for the test scenarios):</p>
<pre class="source-code">
private static HttpClient _client;
private static List&lt;Author&gt; _authors;
private static List&lt;Book&gt; _books;
private static List&lt;User&gt; _users;
private static string _orgChart;
private static string _result;</pre> <p>The<a id="_idIndexMarker806"/> corresponding classes contain all that is needed to vary the context of the rules. As you can see, the first name and last name of the authors have not been integrated into the model, since we have a strong assurance that they cannot impact the output of the rules engine:</p>
<pre class="source-code">
public class Author
{
    public string Id { get; set; }
    public string Login { get; set; }
    public string Restriction { get; set; }
}
public class Book
{
    public string Number { get; set; }
    public string Status { get; set; }
    public string AuthorId { get; set; }
}
public class User
{
    public string Login { get; set; }
    public string Group { get; set; }
}
Some methods will be used to initiate the values for each scenario, and also for the entire feature:
[BeforeFeature]
public static void Initialize()
{
    _client = new HttpClient();
    _client.BaseAddress = new Uri("http://localhost:8181/v1/");
}
[BeforeScenario]
public static void InitializeScenario()
{
    _authors = new List&lt;Author&gt;();
    _books = new List&lt;Book&gt;();
    _users = new List&lt;User&gt;();
}</pre> <p>This <a id="_idIndexMarker807"/>will allow us, upon calling on the function associated with the <code>When</code> keyword, to realize the call to the so-called System Under Test (what we want to validate is the OPA server, which should have been started and customized with the <code>Rego</code> content and will listen on port <code>8181</code> in our setup):</p>
<pre class="source-code">
[When("user (.*) request (.*) access to the (.*) petal of the book number (.*)")]
public void ExecuteRequest(string login, string access, string perimeter, string bookNumber)
{
    StringBuilder sb = new StringBuilder();
    sb.AppendLine("{");
    sb.AppendLine("    \"roles\": {");
    sb.AppendLine("        \"book-direction\": { \"access\": []},");
    sb.AppendLine("        \"book-sales\": { \"parent\": \"book-direction\", \"access\": [{ \"operation\": \"all\", \"type\": \"books.sales\" }]},");
    sb.AppendLine("        \"book-edition\": { \"parent\": \"book-direction\", \"access\": [{ \"operation\": \"all\", \"type\": \"books.editing\" }]},");
    sb.AppendLine("        \"book-writer\": { \"parent\": \"book-edition\", \"access\": [{ \"operation\": \"read\", \"type\": \"books.editing\" }, { \"operation\": \"all\", \"type\": \"books.content\" }]}");
    sb.AppendLine("    },");
    sb.AppendLine("    \"books\": {");
    for (int i=0; i&lt;_books.Count; i++)
    {
        Book b = _books[i];
        sb.Append("        \"" + b.Number + "\": { \"id\": \"" + b.Number + "\", \"title\": \"***NORMALLY NO IMPACT ON RULES***\", \"editing\": { \"author\": \"" + b.AuthorId + "\", \"status\": \"" + b.Status + "\" }}");
        if (i &lt; _books.Count - 1) sb.AppendLine(","); else sb.AppendLine();
    }
    sb.AppendLine("    },");
    sb.AppendLine("    \"authors\": {");
    for (int i = 0; i &lt; _authors.Count; i++)
    {
        Author a = _authors[i];
        sb.AppendLine("        \"" + a.Id + "\": { \"id\": \"" + a.Id + "\", \"firstName\": \"***NORMALLY NO IMPACT ON RULES***\", \"lastName\": \"***NORMALLY NO IMPACT ON RULES***\", \"user\": \"" + a.Login + "\", \"restriction\": \"" + a.Restriction + "\" }");
        if (i &lt; _authors.Count - 1) sb.AppendLine(","); else sb.AppendLine();
    }
    sb.AppendLine("    },");
    sb.AppendLine("    \"org_chart\": " + _orgChart + ",");
    sb.AppendLine("    \"directory\": {");
    for (int i = 0; i &lt; _users.Count; i++)
    {
        User u = _users[i];
        sb.AppendLine("        \"" + u.Login + "\": {\"groups\": [\"" + u.Group + "\"]}");
        if (i &lt; _users.Count - 1) sb.AppendLine(","); else sb.AppendLine();
    }
    sb.AppendLine("    },");
    sb.AppendLine("    \"group_mappings\": {");
    sb.AppendLine("        \"board\": { \"roles\": [\"book-direction\"] },");
    sb.AppendLine("        \"commerce\": { \"roles\": [\"book-sales\"] },");
    sb.AppendLine("        \"editors\": { \"roles\": [\"book-edition\"] },");
    sb.AppendLine("        \"authors\": { \"roles\": [\"book-writer\"] }");
    sb.AppendLine("    },");
    sb.AppendLine("    \"user_mappings\": {");
    sb.AppendLine("    }");
    sb.AppendLine("}");
    var response = _client.PutAsync("data", new StringContent(sb.ToString(), Encoding.UTF8, "application/json")).Result;
    string input = "{ \"input\": { \"user\": \"" + login + "\","
        + " \"operation\": \"" + access + "\","
        + " \"resource\": \"" + perimeter + "\","
        + " \"book\": \"" + bookNumber + "\" } }";
    response = _client.PostAsync("data/app/abac", new StringContent(input, Encoding.UTF8, "application/json")).Result;
    if (response != null)
    {
        _result = response.Content.ReadAsStringAsync().Result;
    }
}
}</pre> <p>The final <a id="_idIndexMarker808"/>part of the test execution is carried out by the method associated with the <code>Then</code> keyword, which is the one running the asserts in order to simulate an automated test:</p>
<pre class="source-code">
[Then("access should be (.*)")]
public void ValidateExpectedResult(string expectedResult)
{
    JsonTextReader reader = new JsonTextReader(new StringReader(_result));
    reader.Read(); // Get first element
    reader.Read(); // Read result attribute
    reader.Read(); // Get element for result
    reader.Read(); // Read allow attribute
    bool? actual = reader.ReadAsBoolean(); // Get boolean value for allow attribute
    if (actual is null)
        throw new ApplicationException("Unable to find result");
    bool? expected = null;
    if (expectedResult == "refused") expected = false;
    if (expectedResult == "accepted") expected = true;
    if (expected is null)
        throw new ApplicationException("Unable to find expected value");
    Assert.Equal(expected, actual);
}</pre> <p>You now can <a id="_idIndexMarker809"/>display the Test Explorer by accessing it from the menu or using the <em class="italic">Ctrl</em> + <em class="italic">E</em> + <em class="italic">T</em> shortcut. The tests might not display at first, and you may have to run the solution generation for them to appear. Once they are displayed, you can run the scenarios one by one or simultaneously, and if everything works fine, they should confirm the rules work as intended and display everything with ticks on circles:</p>
<div><div><img alt="Figure 13.22 – The results of the SpecFlow tests" src="img/Figure_13.22_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.22 – The results of the SpecFlow tests</p>
<p>Six scenarios are not a lot for such a complex set of policies, and in the real world, a few dozen such scenarios would be welcome to form such a powerful harness that everyone would be convinced the system works perfectly as expected. But again, since this is not the main subject of the book, we will leave the automated tests of authorization rules here. By the way, I showed automated BDD tests created with SpecFlow because this is the framework I am used to, but there are alternatives that may be more suitable, depending on your needs and context. The important thing is not whether you use SpecFlow, Postman, or any other method but that such important ru<a id="_idTextAnchor498"/>les as authorizations should be verified carefully.</p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor499"/>Challenges with OPA</h2>
<p>OPA is a <a id="_idIndexMarker810"/>great approach to authorization rule implementation, but it still offers some challenges.</p>
<p>First of all, there is the complexity of writing rules, as previously discussed. Although this is quite logical as we try to fit some complex functional algorithms into just a few keywords, it can really be limiting for those trying to adopt OPA and the <code>Rego</code> syntax, only to be held up by many incorrect attempts at writing the right rule.</p>
<p>I personally experienced this, and to be perfectly honest, I still do not really understand how the following rule works:</p>
<pre class="source-code">
permissions[entity_name] := access {
    data.roles[entity_name]
    reachable := graph.reachable(roles_graph, {entity_name})
    access := {item | reachable[k]; item := data.roles[k].access[_]}
}</pre> <p>I know that it does because I have tested it, and I can see the point about walking through a tree and picking some data of the path, but the additional recurrent valuation of <code>access</code> combined with the use of the <code>_</code> keyword and the <code>reachable</code> function just make it too hard for me to write this on my own, without referring to some examples that others have written. It may be a lack of practice, but I have tried my fair share of exotic languages over almost four decades of programming, and I still think <code>Rego</code> might be one of the most complicated logics I have encountered. After a few attempts at using OpenFGA, it may be simpler to provide an equivalent authorization rule, but I cannot make a commitment to this, since I have not yet used this technology in a production-ready module.</p>
<p>Luckily, some documentation such as <a href="https://www.openpolicyagent.org/docs/latest/policy-reference/">https://www.openpolicyagent.org/docs/latest/policy-reference/</a> shows advanced examples, and I also found great advanced tips at <a href="https://www.fugue.co/blog/5-tips-for-using-the-rego-language-for-open-policy-agent-opa">https://www.fugue.co/blog/5-tips-for-using-the-rego-language-for-open-policy-agent-opa</a>, while links such as <a href="mailto:https://medium.com/@agarwalshubhi17/rego-cheat-sheet-5e25faa6eee8">https://medium.com/@agarwalshubhi17/rego-cheat-sheet-5e25faa6eee8</a> provided some clear explanation on how these complex syntaxes work.</p>
<p>Another <a id="_idIndexMarker811"/>challenge with OPA might come from the fact that HTTP API calls can cause performance problems if done in volume. And if your authorization rules are complex, chances are that you will be obliged to apply them to business entities one by one. So, how would you handle some calls requesting a list of entities? Calling the API hundreds of times or more is not an option. And what is true for a local Docker container is even more true for a service in the cloud such as OSO (<a href="https://www.osohq.com/">https://www.osohq.com/</a>) that proposes a SaaS solution for authorization rules.</p>
<p>Of course, the best approach is still paginating results, which is also good not only for ecological reasons, helping to reduce the strain on resources, but also for ergonomic reasons, by providing users with screens that are less cluttered with data and easier to read and comprehend. However, cases where you need volume may remain, and calling an HTTP server many times is not an elegant option anyway. Luckily, OPA can be accessed directly from your code if you use the Go language, or even as a WebAssembly module, making it possible (although not currently easy) to integrate it at the code level from many platforms.</p>
<p>Here’s a final thing to note on authorization management – in this chapter, you have seen a simplified version of the grammar and data that will be applied more realistically in the upcoming chapters. For example, I used simple identifiers instead of URN, some attributes were repeated in order to ease rule execution, and so on. I could have shown the policies in their final form but considered it better to show the work in progress for two reasons:</p>
<ul>
<li>Avoiding this additional complexity made it easier to concentrate on the subject of authorization rules</li>
<li>Showing these adjustments at the precise moment we need to make them will hopefully also make them more understandable, as the situation will show how the simple approach could c<a id="_idTextAnchor500"/>ause an evolution problem and help explain the change</li>
</ul>
<h1 id="_idParaDest-281"><a id="_idTextAnchor501"/>Summary</h1>
<p>In this chapter, we showed what a Business Rules Management System does, how useful it can be in an information system, and how we could implement one, starting with a functional example and then demonstrating another example relating to authorizations, which are one of the most used sets of business rules in software applications.</p>
<p>Just like for BPMN engines, BRMS engines are not used very often. In fact, business rules are – in the great majority of cases – implemented in code expressions or compiled into applications. This is absolutely normal because a BRMS represents an important investment, and implementing such complex applications really needs a strong business case, where business rules change very frequently or are associated with strict regulatory or marketing constraints, such as the necessity to trace all business rules and their changes, the capacity to simulate the effects of new versions of sets of business rules, and so on. We can conclude, then, that this approach is currently limited to very rare contexts. Things may, of course, change in the future, with the industrialization of information system design that we really long for, but at the present time, BPMNs and BRMSs are an effort that is almost always overkill.</p>
<p>And since two of the three parts of the ideal system are not worth using in most of an organization, this means this ideal system is really utopic. Moreover, even a centralized <strong class="bold">Master Data Management</strong> (<strong class="bold">MDM</strong>) approach is complicated. The MDM practices per se are applicable to every business domain, so there is no problem with a data referential service; they are not very complicated to set up, as we will see in practice in <a href="B21293_15.xhtml#_idTextAnchor548"><em class="italic">Chapter 15</em></a>, and they bring lots of business value and advantages. However, the ideal system aims for generic MDM, dynamically adjusting to every entity in the business context of an application. This step further is also out of the scope of this book, though static code generation for a data referential service is becoming a viable option, as we will show at the end of <a href="B21293_15.xhtml#_idTextAnchor548"><em class="italic">Chapter 15</em></a>.</p>
<p>In addition, we have shown that the three responsibilities of an ideal information system are, ultimately, quite entangled with each other:</p>
<ul>
<li>MDM uses business rules in its validation of data</li>
<li>A BRMS needs data from MDM in order to apply the business rules and decide their output value</li>
<li>A BPMN serves mainly as a collector of data to feed the MDM, while also consuming data from the MDM</li>
<li>A BPMN also uses business rules in order to know where to go in the different gateways (and, sometimes, to calculate some additional data during a given task)</li>
</ul>
<p>All this proves that, technically, this assembly of three generic servers for MDM, a BPMN, and a BRMS is not so feasible, and neither achieves a perfect decoupling. So, why did we bother in <a href="B21293_05.xhtml#_idTextAnchor164"><em class="italic">Chapter 5</em></a> and the last three chapters to talk about such an ideal system? Again, the answer lies in the business/IT alignment. The ideal system is not something that can be realized in practice in information systems today (and certainly not for at least a few more decades), but it has the great advantage of forcing an architect to think in terms of three generic, always applicable, functional responsibilities. Even if you use a unique software application, knowing how to separate the data management, business rules management, and business process execution provides a great step toward decoupling your information system (which is not achieved at all with <em class="italic">n</em>-tier architecture, for example). As you will see in the coming chapters, constructing an information system with these principles in mind will help us achieve a very complex goal, which is to be able to modify important functional rules and behaviors very easily and, in most cases, without any significant impact on the implementation.</p>
<p>In the next chapter, we will use everything we have learned so far to design the information system of <code>DemoEditor</code>. In the following chapters, we will finally get hands-on and implement all the different parts of this information system, using C# and .NET as a programming platform and Docker as deployment architecture.</p>
</div>


<div><h1 id="_idParaDest-282" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor502"/>Part 3: Building a Blueprint Application with .NET</h1>
<p>After a theoretical part and one on the architecture principles, we will now dive deep into the technical aspects of the method by implementing some important parts of the sample information system. We will create some ASP.NET services implementing the API contracts and a graphical user interface that uses them and implements some of the business processes. Since some features have been externalized to bring more industrial-grade quality, we will also show how to interact with these modules in a lowly coupled way. Plugging the services into the Apache Keycloak IAM, using standards such as OAuth and JWT, will of course be an important step, but we will also show electronic document management systems in a standard way and talk about many other external services. Finally, the external execution of business processes will be shown, with both orchestration and choreographic paradigms.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B21293_14.xhtml#_idTextAnchor503"><em class="italic">Chapter 14</em></a>, <em class="italic">Decomposing the Functional Responsibilities</em></li>
<li><a href="B21293_15.xhtml#_idTextAnchor548"><em class="italic">Chapter 15</em></a>, <em class="italic">Plugging Standard External Modules</em></li>
<li><a href="B21293_16.xhtml#_idTextAnchor588"><em class="italic">Chapter 16</em></a>, <em class="italic">Creating a Write-Only Data Referential Service</em></li>
<li><a href="B21293_17.xhtml#_idTextAnchor608"><em class="italic">Chapter 17</em></a>, <em class="italic">Adding Query to the Data Referential Service</em></li>
<li><a href="B21293_18.xhtml#_idTextAnchor622"><em class="italic">Chapter 18</em></a>, <em class="italic">Deploying Data Referential Services</em></li>
<li><a href="B21293_19.xhtml#_idTextAnchor634"><em class="italic">Chapter 19</em></a>, <em class="italic">Designing a Second Data Referential Service</em></li>
<li><a href="B21293_20.xhtml#_idTextAnchor647"><em class="italic">Chapter 20</em></a>, <em class="italic">Creating a Graphical User Interface</em></li>
<li><a href="B21293_21.xhtml#_idTextAnchor674"><em class="italic">Chapter 21</em></a>, <em class="italic">Extending the Interfaces</em></li>
<li><a href="B21293_22.xhtml#_idTextAnchor709"><em class="italic">Chapter 22</em></a>, <em class="italic">Integrating Business Processes</em></li>
</ul>
</div>
<div><div></div>
</div>
</body></html>