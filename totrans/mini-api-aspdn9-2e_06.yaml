- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Parameter Binding
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数绑定
- en: Context is a critical aspect of any API. The client has their own understanding
    of how data is structured, as does the server. For example, as the client, you
    will view API documentation that tells you to format a request payload in JSON
    format. You therefore create the JSON payload as per the API requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是任何 API 的关键方面。客户端对其数据结构有自己的理解，服务器也是如此。例如，作为客户端，你会查看 API 文档，告诉你以 JSON 格式格式化请求有效负载。因此，你将
    JSON 有效负载创建为符合 API 要求。
- en: When the API receives your payload, it is not guaranteed that the object you
    transmitted will remain as JSON (especially in an ASP.NET API), and a mechanism
    will often be in place to bind the JSON object to a strongly typed .NET object
    that the API can manipulate more easily within its own context.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当 API 接收到你的有效负载时，并不能保证你传输的对象会保持为 JSON 格式（尤其是在 ASP.NET API 中），通常会存在一种机制将 JSON
    对象绑定到 API 可以在其自身上下文中更容易操作的强类型 .NET 对象。
- en: Let us take another example. You (still as the client) make a **GET** request
    for all logs corresponding to a *job* with a particular ID. However, you want
    to restrict the number of logs returned to 100, which the API allows you to do.
    According to the API documentation, you can do this by including the job ID in
    the route, and an option in the query string specifying how many logs you wish
    to return.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子。你（仍然是客户端）对具有特定 ID 的 *作业* 所对应的所有日志发起一个 **GET** 请求。然而，你希望将返回的日志数量限制为
    100，API 允许你这样做。根据 API 文档，你可以通过在路径中包含作业 ID，并在查询字符串中指定你希望返回多少日志来实现这一点。
- en: When receiving this request from you as the client, the API will need to know
    where to look to retrieve these parameters, so that they can be used in the context
    of the request handler. This type of transformation of data between client and
    server during requests is known as **parameter binding** , and we are going to
    explore it in detail in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当 API 从你作为客户端接收这个请求时，它需要知道在哪里查找以检索这些参数，以便它们可以在请求处理程序的上下文中使用。这种在客户端和服务器之间在请求期间进行的数据转换称为
    **参数绑定**，我们将在本章中详细探讨它。
- en: 'In this chapter, we will explore the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Parameter binding sources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数绑定来源
- en: Binding precedence
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定优先级
- en: Creating custom parameter bindings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义参数绑定
- en: Parameter binding sources
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数绑定来源
- en: Out of the box, ASP.NET supports several different parameter binding types.
    Each binding type has a source from which it can bind. Additionally, each binding
    source is situated in a different location within the request, with various ways
    in which they can be bound to data structures in the API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ASP.NET 支持多种不同的参数绑定类型。每种绑定类型都有一个可以从中绑定的来源。此外，每个绑定来源在请求中的位置不同，它们可以以不同的方式绑定到
    API 中的数据结构。
- en: Let’s start with one of the most common binding sources, the route value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最常用的绑定来源之一，即路径值，开始。
- en: Route values
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径值
- en: A **route value** is simply a section of an API route. Look at a typical route
    and imagine it is split into sections delimited by each occurrence of the **/**
    character. Each of these resulting sections is a value within the route.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径值**仅仅是 API 路径的一部分。看看一个典型的路由，想象一下它被分割成由 **/** 字符分隔的部分。这些结果部分都是路径中的值。'
- en: 'Take this example: **/todoitems/2** . It would be split into two route value
    sections: **todoitems** and **2** .'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个例子为例：**/todoitems/2**。它将被分成两个路径值部分：**todoitems** 和 **2**。
- en: In this context, **2** is the route value we are interested in, because it is
    the ID of a **TodoItem** entity. So, how can we access this within an endpoint?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，**2** 是我们感兴趣的路径值，因为它是 **TodoItem** 实体的 ID。那么，我们如何在端点中访问它呢？
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we can see that the incoming route has been modified to add a
    value surrounded by curly braces. This **id** value is a placeholder for an integer
    value that will be passed in its place from the client’s perspective.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们可以看到传入的路由已被修改，添加了一个由大括号包围的值。这个 **id** 值是一个占位符，用于替换客户端传递的整数值。
- en: In the parameter of the lambda expression that follows the route, we declare
    that we are passing in an integer parameter, called **id** . We can do this thanks
    to ASP.NET’s routing module, which detects the route value placeholder and parses
    out the actual value, converting it to the data type needed for the lambda expression,
    which in this case is an integer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟随路由的lambda表达式参数中，我们声明我们正在传递一个整数参数，称为**id**。我们可以这样做，多亏了ASP.NET的路由模块，它可以检测路由值占位符并解析出实际值，将其转换为lambda表达式所需的数据类型，在这种情况下是整数。
- en: 'On the client’s side, the requested route might look like this: **https://myTodoAPI/todoitems/2**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，请求的路由可能看起来像这样：**https://myTodoAPI/todoitems/2**
- en: It is important to remember that in this example, if an item with an **id**
    value of **2** does not exist, the binding will not match, and the endpoint won’t
    hit at all, instead returning **404** **NOT FOUND** .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在这个例子中，如果不存在**id**值为**2**的项目，绑定将不会匹配，端点根本不会触发，而是返回**404** **NOT FOUND**。
- en: By declaring a route parameter in the endpoint, the **id** value of **2** found
    at the end of this route will be automatically detected and bound to the integer
    parameter declared in the lambda expression, allowing it to be used within the
    request.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在端点中声明路由参数，此路由末尾找到的**id**值为**2**将被自动检测并绑定到lambda表达式中声明的整数参数，从而允许它在请求中使用。
- en: Route values do not have to be automatically bound to the lambda expression
    parameters. They can be manually accessed within the request by passing an **HttpRequest**
    object as the parameter instead. On **HttpRequest** , there is a **RouteValues**
    collection that will be populated with the values you need for binding.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 路由值不必自动绑定到lambda表达式参数。它们可以通过传递**HttpRequest**对象作为参数在请求中手动访问。在**HttpRequest**上，有一个**RouteValues**集合，它将包含您用于绑定的值。
- en: 'This is useful if you have multiple types of parameter bindings and you want
    to make the request more readable. Here’s an example that passes in an **HttpRequest**
    parameter. This does not require any change on the client side, as it is already
    present. By adding it as a parameter, we are allowing the endpoint to access it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多种类型的参数绑定，并且想要使请求更易读，这很有用。以下是一个传递**HttpRequest**参数的示例。这不需要客户端进行任何更改，因为它已经存在。通过将其作为参数添加，我们允许端点访问它：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When making requests to an API, there are times when you need to be more granular
    about the state or the conditions of a query you’re making. In these situations,
    query strings can be added to the endpoint URL. This allows you to pass more specific
    parameters to the API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当向API发出请求时，有时您需要更细致地了解您正在进行的查询的状态或条件。在这些情况下，可以将查询字符串添加到端点URL中。这允许您向API传递更具体的参数。
- en: Query strings
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询字符串
- en: In the case of route values, they are often a direct route to data. Requesting
    something by an ID using a route value, on its own, produced a predictable result.
    However, data comes in many different forms, meaning that we often need to specify
    specific conditions that will transform the data we are retrieving in the required
    shape. **Query strings** allow us to achieve this. They sit at the end of a route,
    and they have their own notation that defines them, starting with a **?** character.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由值的情况下，它们通常是直接访问数据的一种方式。仅使用路由值通过ID请求某物会产生可预测的结果。然而，数据以许多不同的形式存在，这意味着我们经常需要指定特定的条件，这些条件将转换我们正在检索的数据，使其符合所需的形状。**查询字符串**允许我们实现这一点。它们位于路由的末尾，并且有自己的表示法，以一个**?**字符开始。
- en: Checking for the presence of query string parameters
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 检查查询字符串参数的存在
- en: The benefit of checking for the query strings before using them only if they
    exist is that we can make query string parameters optional (more on that in the
    next section). Otherwise, our code would assume that the client is always going
    to send query string values, therefore making them mandatory parameters for the
    endpoint. This is fine when intended, but in the examples shown in this chapter,
    the aim is to ensure that the client has the choice to either filter the data
    or not, using query string values.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用查询字符串之前检查它们是否存在的优点是，我们可以使查询字符串参数成为可选的（更多内容将在下一节中介绍）。否则，我们的代码将假设客户端总是会发送查询字符串值，因此将它们作为端点的强制参数。当这是预期的时候，这是可以的，但在本章中展示的示例中，目标是确保客户端可以选择是否使用查询字符串值来过滤数据。
- en: As we can see in this route, **https://myTodoAPI/todoitems?pastDue=true&priority=1**
    , the query string starts at the end of the route values with a **?** character.
    After this, a collection of key-value pairs is specified.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以在这个路由中看到的那样，**https://myTodoAPI/todoitems?pastDue=true&priority=1**，查询字符串从路由值的末尾开始，以一个
    **?** 字符为标志。之后，指定了一系列键值对。
- en: The purpose of the query string in the route is to pass a series of variables
    into the API, which can be used to filter the data that will be returned. In this
    case, the client is requesting any **TodoItem** that is past its due date, but
    also has a priority with a value of **1** .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 路由中查询字符串的目的是传递一系列变量到 API，这些变量可以用来过滤将要返回的数据。在这种情况下，客户端请求任何已过截止日期且优先级值为 **1**
    的 **TodoItem**。
- en: Optional query string parameters
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选查询字符串参数
- en: You can make it so that a parameter passed in is optional. It’s very simple;
    you just make the query string parameter you added to the endpoint nullable by
    affixing a **?** character to it. Then, in the body of your endpoint, you can
    check for the existence of an optional value. If the optional value is not null,
    you can use it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使传入的参数成为可选的。这非常简单；您只需通过在端点中添加的查询字符串参数后附加一个 **?** 字符来使其可空。然后，在端点的主体中，您可以检查可选值的是否存在。如果可选值不为空，您可以使用它。
- en: 'Here’s an example of an optional parameter used on an endpoint that fetches
    a todo item by ID. It allows the client to specify that the assignee must be a
    certain value. If the assignee value is not null and does not match the assignee
    value on the item, you can send a different response, such as **404** **NOT FOUND**
    :'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了在通过 ID 获取待办事项的端点上使用可选参数。它允许客户端指定分配者必须具有特定值。如果分配者值不为空且与项目上的分配者值不匹配，您可以发送不同的响应，例如
    **404** **NOT FOUND**：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On the server side, the query string parameters are bound as per the following
    example. In this example, we are also checking for the existence of certain query
    string key-value pairs and building the relevant query for the data based on the
    specified query string values, using **IQueryable** :'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，查询字符串参数绑定如下示例所示。在这个例子中，我们还在检查某些查询字符串键值对的存在，并根据指定的查询字符串值构建相关查询，使用 **IQueryable**：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ve spent most of our time so far passing parameters within the URLs of our
    requests. Let us explore parameters that exist outside of this, starting with
    headers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止的大部分时间都花在通过我们请求的 URL 传递参数上。让我们探索存在于这个范围之外的参数，从头部开始。
- en: Headers
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部
- en: '**Headers** are a classic component of general API architecture, providing
    important metadata about the request. They are like query strings in the sense
    that they are defined by a key-value structure, but the syntax used when applying
    them differs.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**头部** 是通用 API 架构的经典组件，提供了关于请求的重要元数据。在它们像查询字符串一样以键值结构定义的意义上，它们是相似的，但应用它们的语法有所不同。'
- en: 'Like query strings and route values, they can also be accessed from an **HttpRequest**
    object:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与查询字符串和路由值一样，它们也可以从 **HttpRequest** 对象中访问：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another critical parameter type that exists outside of the URL is the request
    body, sometimes referred to as the *payload.* ASP.NET has a clever feature that
    allows the payload’s contents to be automatically converted into a strongly typed
    object defined in the project. The feature is known as **object binding** .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个存在于 URL 之外的关键参数类型是请求体，有时被称为 *payload*。ASP.NET 具有一个巧妙的功能，可以将有效负载的内容自动转换为项目中定义的强类型对象。这个功能被称为
    **对象绑定**。
- en: Strongly typed object binding
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强类型对象绑定
- en: When representing objects in a request payload, it is extremely common for that
    object to be structured as JSON when the client creates the request. ASP.NET provides
    a convenient way of automatically binding incoming JSON parameters to a strongly
    typed object so that it can be easily used when handling the request.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当在请求有效负载中表示对象时，该对象在客户端创建请求时通常以 JSON 结构化。ASP.NET 提供了一种方便的方法，可以自动将传入的 JSON 参数绑定到项目中定义的强类型对象，以便在处理请求时易于使用。
- en: We have seen examples of this already in previous chapters, where we send a
    JSON payload representing a **TodoItem** object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中看到了这个例子，其中我们发送了一个表示 **TodoItem** 对象的 JSON 有效负载。
- en: If the JSON object can be parsed, ASP.NET allows you to implicitly declare that
    the request parameter is an object of type *x* – *x* in our example being a **TodoItem**
    object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JSON 对象可以被解析，ASP.NET 允许您隐式声明请求参数是类型为 *x* 的对象 – 在我们的例子中是 **TodoItem** 对象。
- en: 'To use implicit binding in this manner, simply declare a parameter of the type
    you wish to receive as a parameter in your endpoint, as shown in the following
    example, where we receive a new **TodoItem** to be created via a **POST** method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要以这种方式使用隐式绑定，只需在你的端点中声明一个参数，其类型是你希望接收的参数类型，如下例所示，我们通过**POST**方法接收一个要创建的新**TodoItem**：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Object binding is initiated thanks to the client sending a data structure represented
    by a string, within the body of the request. This is often the result of a developer
    formatting the payload after the data was gathered, before sending it to the API.
    However, if the data was gathered by a user, who could be entering the data in
    the **Graphical User Interface** ( **GUI** ) via a form, the process can be streamlined
    further, thanks to form values.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对象绑定是通过客户端在请求体中发送一个由字符串表示的数据结构来启动的。这通常是开发者在收集数据后格式化有效负载的结果，在将其发送到API之前。然而，如果数据是由用户收集的，用户可以通过**图形用户界面**（**GUI**）中的表单输入数据，这个过程可以通过表单值进一步简化。
- en: Form values
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单值
- en: API endpoints take in data and do something with it. What better use case can
    there be for data submission than a form? Minimal APIs support the receipt of
    **form values** , making them a suitable option for handling submissions from
    forms within a GUI.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: API端点接收数据并对它进行处理。还有什么比表单更好的数据提交用例吗？最小化API支持接收**表单值**，使它们成为处理GUI中表单提交的合适选项。
- en: 'Like the previous parameter examples, form values can be retrieved from their
    own dedicated member within an **HttpRequest** object, where they also exist in
    a key-value structure within an **IFormCollection** collection. The following
    code shows the retrieval of form values within a **PATCH** request:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的参数示例一样，表单值可以从**HttpRequest**对象中它们自己的专用成员中检索，它们也存在于**IFormCollection**集合中的键值结构中。以下代码显示了在**PATCH**请求中检索表单值：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So far, we’ve made some good progress exploring the various types of parameters
    that can be bound to API endpoints. In each of the previous examples, a lot is
    assumed about how these parameters should be bound. The location of the parameters,
    whether they be in the URL as query strings or in the request body, is *implicit*
    ; it does not require definition, instead occurring automatically. Inversely,
    there will be times when we will need to be *explicit* about how parameters are
    bound. This explicit binding can be achieved with **attributes** .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经取得了一些进展，探索了可以绑定到API端点的各种参数类型。在先前的每个示例中，我们对这些参数应该如何绑定有很多假设。参数的位置，无论是作为URL中的查询字符串还是请求体中的内容，是**隐式的**；它不需要定义，而是自动发生。相反，有时我们需要明确地说明参数的绑定方式。这种显式绑定可以通过**属性**来实现。
- en: Explicit binding with attributes
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用属性的显式绑定
- en: All the previous examples have something in common – they are accessible using
    keys from collections that exist within an **HttpRequest** object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前例都有一个共同点——它们都可以通过**HttpRequest**对象中存在的集合的键来访问。
- en: There is another way of binding these parameter types without needing to inject
    **HttpRequest** or its parent, **HttpContext** – attributes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一种绑定这些参数类型的方法，无需注入**HttpRequest**或其父级**HttpContext**——属性。
- en: The benefit of this is that we can make the code more readable and arguably
    improve the structure of the request, because the parameters can be bound from
    within the parentheses of the endpoint’s lambda expression, leaving the expression
    body dedicated exclusively to handling the request. As shown in the previous examples,
    we are using the parentheses to receive parameters but then performing explicit
    binding in the body, as well as executing handling logic, which can be somewhat
    messy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是我们可以使代码更易于阅读，并且可以说改善了请求的结构，因为参数可以从端点lambda表达式的括号内绑定，从而将表达式主体专门用于处理请求。如前所述的示例所示，我们使用括号来接收参数，然后在主体中进行显式绑定，以及执行处理逻辑，这可能会有些混乱。
- en: Parameter binding with attributes is simpler because you are explicitly stating
    that you have a parameter that should be bound from a specific location in the
    request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性进行参数绑定更简单，因为你明确表示你有一个参数应该从请求的特定位置绑定。
- en: Let us take query strings as an example. In the code block in the *Query strings*
    section, we were accessing query strings from within the endpoint body by index
    on **IQueryCollection** within the **HttpRequest** object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以查询字符串为例。在 *查询字符串* 部分的代码块中，我们通过在 **HttpRequest** 对象内的 **IQueryCollection** 上按索引访问查询字符串。
- en: 'The following code block demonstrates how this endpoint can be refactored to
    obtain query string values using attributes, reducing the amount of code and making
    it easier to read:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块演示了如何通过使用属性来重构此端点，以获取查询字符串值，从而减少代码量并使其更容易阅读：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you were to change the **[FromQuery]** attributes in this code slightly by
    removing the argument, for example, to **Name = "priority"** , the API would still
    match the query values, assuming that the name was specified in the query string.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这段代码中稍微改变一下 **[FromQuery]** 属性，例如，通过移除参数，将其改为 **Name = "priority"**，那么在假设查询字符串中指定了名称的情况下，API
    仍然会匹配查询值。
- en: All the parameter binding methods demonstrated previously in this chapter can
    be extracted in this way – by specifying in an attribute where the parameter should
    be bound from and then providing an object with the appropriate data type in which
    it can be bound.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面演示的所有参数绑定方法都可以以这种方式提取——通过在属性中指定参数应从何处绑定，然后提供一个具有适当数据类型的对象，以便可以将其绑定。
- en: Let us update another of our previous **POST** examples by checking the headers
    in this manner. For the purposes of demonstration, let us assume that when a client
    posts a new **TodoItem** , they can indicate whether another process should be
    triggered in the background by using a custom header.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这种方式更新我们之前的 **POST** 示例，检查头部信息。为了演示目的，让我们假设当客户端发布一个新的 **TodoItem** 时，他们可以通过使用自定义头部来指示是否应在后台触发另一个进程。
- en: 'The header can be explicitly bound using an attribute, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用属性显式绑定标题，如下所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’re ready to step into more advanced territory now, in which we can explore
    parameters that have been *injected* from a catalog of previously registered **services**
    .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进入更高级的领域，我们可以探索从先前注册的 **services** 目录中注入的参数。
- en: Binding parameters through dependency injection
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过依赖注入绑定参数
- en: Parameters can be bound to an endpoint that was not necessarily sent by the
    client. One example of this is dependencies. Where an API has dependencies registered
    for injection, they can be explicitly bound as parameters. Let us explore an example
    of this by rewriting the **GET** request example from the first code block in
    the *Explicit binding with* *attributes* section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以绑定到客户端不一定发送的端点。一个例子是依赖项。如果一个 API 为注入注册了依赖项，它们可以明确地作为参数绑定。让我们通过重写 *使用属性显式绑定*
    部分的第一个代码块中的 **GET** 请求示例来探索这个例子。
- en: 'First, as you can see in the code on GitHub, we’ve created a service called
    **TodoItemService** :'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如你在 GitHub 上的代码中所看到的，我们创建了一个名为 **TodoItemService** 的服务：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This service has been registered for dependency injection as a singleton service
    in **Program.cs** :'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务已在 **Program.cs** 中注册为单例服务用于依赖注入：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This means that we can now access this service from within an endpoint using
    the **[** **FromServices]** attribute:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在可以使用 **[** **FromServices]** 属性在端点内部访问此服务：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code, binding a service registered for dependency injection is demonstrated
    using a **[FromService]** attribute. This allows API endpoints to leverage reusable
    components easily.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，使用 **[FromService]** 属性演示了为依赖注入注册的服务绑定。这使得 API 端点能够轻松利用可重用组件。
- en: So far, we have looked at examples of various parameter types and how they are
    bound to API endpoints. Hopefully, it is clear that ASP.NET is taking care of
    the heavy lifting when it comes to resolving these parameters before binding.
    It is also important to understand the order in which this resolution of parameters
    happens. This is known as **binding precedence** .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了一些不同参数类型的示例以及它们如何绑定到 API 端点。希望这表明 ASP.NET 在绑定这些参数之前正在处理繁重的工作。了解参数解析的顺序也很重要。这被称为
    **绑定优先级**。
- en: Binding precedence
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定优先级
- en: ASP.NET has its own defined order in which it will bind parameters, known as
    its **order of precedence** . Using this order keeps resolution consistent and
    ensures that ASP.NET is resolving in a predictable way, starting with the most
    specific parameters to the least.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 有自己的参数绑定顺序，称为其 **优先级顺序**。使用此顺序保持解析的一致性，并确保 ASP.NET 以可预测的方式解析，从最具体的参数开始，到最不具体的参数结束。
- en: '*Figure 6* *.1* outlines the official order ASP.NET uses, which is useful to
    know as a developer, as it can help you anticipate any potential binding issues
    depending on the parameters in use.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.1* 概述了 ASP.NET 使用的官方顺序，这对于开发者来说很有用，因为它可以帮助你根据使用的参数预测任何潜在的绑定问题。'
- en: '![Figure 6.1: ASP.NET order of precedence for parameter binding](img/B20968_06_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：ASP.NET 参数绑定优先级顺序](img/B20968_06_01.jpg)'
- en: 'Figure 6.1: ASP.NET order of precedence for parameter binding'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：ASP.NET 参数绑定优先级顺序
- en: Let us look at a working example of how we can create custom binding logic,
    giving us more control over the way binding is executed on incoming parameters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个工作示例，说明我们如何创建自定义绑定逻辑，从而让我们对绑定执行的方式有更多的控制。
- en: Creating custom binding logic
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义绑定逻辑
- en: In this example, we are going to change the way we bind an incoming **TodoItem**
    , adding validation logic that will occur at the point of binding.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将改变绑定传入 **TodoItem** 的方式，添加在绑定点发生的验证逻辑。
- en: To implement this kind of custom binding, we need to implement a function within
    **TodoItem** . This function is static and is called **BindAsync()** .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种自定义绑定，我们需要在 **TodoItem** 中实现一个函数。这个函数是静态的，称为 **BindAsync()** 。
- en: '**BindAsync()** allows us to interrupt the binding process for an object and
    apply our own logic. Let us start by adding **BindAsync()** to the **TodoItem**
    class.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**BindAsync()** 允许我们中断对象的绑定过程并应用自己的逻辑。让我们首先将 **BindAsync()** 添加到 **TodoItem**
    类中。'
- en: 'In **TodoItem** , add the following static function below the property definitions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **TodoItem** 中，在属性定义下方添加以下静态函数：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we need to add a **try/catch** block so that we can perform JSON validation
    logic, catching any errors in the process. We are expecting to see exceptions
    of type **JsonException** if the validation fails, so we will explicitly catch
    this exception type in our **try/catch** block:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个 **try/catch** 块，以便我们可以执行 JSON 验证逻辑，捕获过程中的任何错误。我们预计如果验证失败，将看到类型为
    **JsonException** 的异常，因此我们将在我们的 **try/catch** 块中显式捕获此异常类型：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can start by accessing the body of the request and deserializing the
    raw JSON to a **TodoItem** instance. We will add options to ensure case is not
    factored into validation, and then check to see whether deserialization was successful.
    If it was not, the incoming parameter cannot be bound and the request is invalid,
    so we will return a **400 Bad Request** response. Update the **try** block with
    this code, shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以先访问请求体，并将原始 JSON 反序列化为 **TodoItem** 实例。我们将添加选项以确保不将大小写因素纳入验证，然后检查反序列化是否成功。如果没有成功，则传入的参数无法绑定，请求无效，因此我们将返回
    **400 Bad Request** 响应。更新 **try** 块中的此代码，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, we have now checked the validity of the JSON to be bound. In
    [*Chapter 5*](B20968_05.xhtml#_idTextAnchor094) , we explored an example of validation
    middleware for verifying that objects were created according to specific rules.
    We used **ValidationContext** along with the static type, **Validator** , to return
    a list of **ValidationResult** , which would determine the validity of the model.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已检查要绑定的 JSON 的有效性。在 [*第 5 章*](B20968_05.xhtml#_idTextAnchor094) 中，我们探讨了验证中间件的示例，用于验证对象是否根据特定规则创建。我们使用了
    **ValidationContext** 以及静态类型 **Validator** 来返回一个 **ValidationResult** 列表，这将确定模型的合法性。
- en: We can use this same logic in **BindAsync()** to implement validation of the
    object as part of the parameter binding process.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 **BindAsync()** 中使用相同的逻辑来实现对象验证，作为参数绑定过程的一部分。
- en: 'Add this logic to the **try** block to complete the custom binding logic:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将此逻辑添加到 **try** 块中，以完成自定义绑定逻辑：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we need to add the following basic logic to the **catch** block to
    handle any exceptions of type **JsonException** that are caught:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在 **catch** 块中添加以下基本逻辑来处理捕获的任何类型为 **JsonException** 的异常：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Refer to this chapter’s code in the accompanying GitHub repository to see the
    finished class: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考随附 GitHub 仓库中的本章代码以查看完成的类：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
- en: Custom parameter binding is a good example of ASP.NET’s flexible feature set.
    Minimal APIs may be labeled as such but that doesn’t mean they restrict custom
    configurations. Let us review what we have covered in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义参数绑定是 ASP.NET 灵活功能集的一个好例子。最小 API 可能被标记为这样的标签，但这并不意味着它们会限制自定义配置。让我们回顾一下本章我们所学到的内容。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The binding of parameters is a fairly broad subject, and we have certainly covered
    the bulk of it in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 参数绑定是一个相当广泛的主题，我们确实在本章中涵盖了大部分内容。
- en: We started by looking at how the different parameter types are bound, from route
    values and query strings right up to headers and the automatic binding provided
    for strongly typed objects.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先研究了不同参数类型的绑定方式，从路由值和查询字符串到头信息和为强类型对象提供的自动绑定。
- en: We then explored some alternative binding methods for these parameter types
    in the form of explicit attribute binding and the order of binding precedence,
    before looking at how dependency injection can be leveraged within requests to
    add parameters that may not have been received from the client.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看如何在请求中利用依赖注入添加可能未从客户端接收到的参数之前，我们首先探讨了这些参数类型的一些替代绑定方法，包括显式属性绑定和绑定优先级顺序。
- en: Finally, we worked through an example of custom parameter binding, adding custom
    validation to the binding logic of the **TodoItem** model.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过一个自定义参数绑定的示例，为 **TodoItem** 模型的绑定逻辑添加了自定义验证。
- en: This chapter is not the last we have seen of dependency injection in minimal
    APIs. In the next chapter, we will explore the topic in more detail.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并非我们最后一次看到最小 API 中的依赖注入。在下一章中，我们将更详细地探讨这个主题。
