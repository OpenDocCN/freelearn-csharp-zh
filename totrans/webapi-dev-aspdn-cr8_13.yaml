- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with SignalR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012), we introduced the concept
    of real-time web APIs. Various technologies can be used to implement real-time
    web APIs, such as gRPC streaming, long polling, **Server-Sent Events** (**SSE**),
    WebSockets, and so on. Microsoft provides an open-source library called SignalR
    to simplify the implementation of real-time web APIs. In this chapter, we will
    introduce the basics of SignalR and how to use SignalR to implement real-time
    web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Recap of real-time web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up SignalR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building SignalR clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using authentication and authorization in SignalR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending messages from other services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring SignalR hubs and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use SignalR to implement real-time
    web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the steps in this chapter, you can download the source code from the
    GitHub repository at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter13](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter13).
    You can use VS 2022 or VS Code to open the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to install the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js**: Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript
    engine. You can download the latest version of Node.js from [https://nodejs.org/en/](https://nodejs.org/en/).
    We will use it to install the required packages for the TypeScript client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recap of real-time web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced a few technologies that can be used to implement real-time web
    APIs in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012). Each technology has its
    pros and cons. To simplify the implementation of real-time web APIs, Microsoft
    provides SignalR, which supports multiple transports, such as WebSockets, SSE,
    and long polling. SignalR will automatically choose the best transport based on
    the client’s capabilities. On top of that, SignalR provides a simple programming
    model to implement real-time web APIs. Developers do not need to worry about the
    underlying transport details; instead, they can focus on the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalR was first introduced for ASP.NET in 2013\. As of now, SignalR has been
    rewritten for ASP.NET Core and is included in the ASP.NET Core framework. So,
    there are two different versions of SignalR: one for ASP.NET and one for ASP.NET
    Core. If you are using ASP.NET Core, you do not need to install any additional
    packages to use SignalR. There are also some differences between the ASP.NET version
    and the ASP.NET Core version of SignalR. For example, ASP.NET Core SignalR does
    not support Microsoft Internet Explorer. However, most modern applications are
    targeting modern browsers, so this should not be a big issue. In this chapter,
    we will focus on the ASP.NET Core version of SignalR.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike REST APIs, SignalR clients need to install a SignalR client library
    to communicate with SignalR servers. SignalR provides a couple of client libraries
    for different platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript client**: This is the most used client library because it can
    be used in both browsers and Node.js applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET client**: This client can be used for .NET applications, such as Xamarin,
    **Windows Presentation Foundation** (**WPF**), and Blazor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java client**: This client supports Java 8 and later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other clients, such as the C++ client and Swift client, are not officially supported
    by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: SignalR is a good choice for building real-time web APIs. For example, you can
    use SignalR to build a chat application, a real-time dashboard, voting applications,
    whiteboard applications, and so on. SignalR can push data to specific clients
    or groups of clients. It automatically manages connections between clients and
    servers. In the next section, we will introduce the basics of SignalR and build
    a simple chat application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SignalR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will build a simple chat application using SignalR. The
    chat application will allow users to send messages to a public chat room. The
    messages will be broadcast to all connected clients. This application contains
    four projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ChatApp.Server`: This is the ASP.NET Core web API project that provides a
    SignalR hub'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChatApp.TypeScriptClient`: This is a client application written in TypeScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChatApp.BlazorClient`: This is a client application written in Blazor, which
    is a web framework for building client-side applications using C#'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The code of this sample is based on the official SignalR sample provided by
    Microsoft. You can find the original source code at [https://github.com/aspnet/SignalR-samples/tree/main/ChatSample](https://github.com/aspnet/SignalR-samples/tree/main/ChatSample).
    We added the Blazor and MAUI clients to the sample.
  prefs: []
  type: TYPE_NORMAL
- en: The `ChatApp.Server` application is a simple ASP.NET Core web API application
    that is used to provide a SignalR hub. A SignalR hub is a class to manage connections
    between clients and servers. It is a high-level abstraction for SignalR real-time
    communication. A SignalR hub can be used to send messages to clients and receive
    messages from clients. A SignalR hub can also manage users and groups of clients.
    In ASP.NET Core SignalR, a hub is defined as a middleware component, so we can
    easily add it to the ASP.NET Core pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'A SignalR hub has a `Clients` property to manage connections between the server
    and the client. When a user connects to the SignalR hub, a new connection is created.
    One user can have multiple connections. The `Clients` property has some methods
    to manage connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`All` is used to call a method on all connected clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Caller` is used to call a method on the caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Others` is used to call a method on all connected clients except the caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client` is used to call a method on a specific client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clients` is used to call a method on specific connected clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Group` is used to call a method on a group of clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Groups` is used to call a method on multiple groups of clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User` is used to call a method on a specific user. Note that one user may
    have multiple connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Users` is used to call a method on specified users, including all connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllExcept` is used to call a method on all connected clients except specified
    clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupExcept` is used to call a method on a group of clients except specified
    clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OthersInGroup` is used to call a method on all clients in a group except the
    caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore some of these methods in the following sections. You can find
    the complete code of the sample in the `chapter13/v1` folder of the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, follow these steps to create a new solution and set up a `ChatApp.Server`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new solution called `ChatApp` using the `dotnet new` `sln` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Program.cs file and add the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'namespace ChatApp.Server.Hubs;public class ChatHub : Hub{    public Task SendMessage(string
    user, string message)    {        return Clients.All.SendAsync("ReceiveMessage",
    username, message);    }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to map the SignalR hub to a URL. Add the following code to the
    `Program.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the `launchSettings.json` file in the `Properties` folder. The default
    `launchSettings.json` file contains `http` and `https` URLs. By default, the `dotnet
    run` command will use the first `http` profile. We can specify for the launch
    profile to use the `https` URL. Use the following command to run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The SignalR hub is now ready for use. To test it, however, a client must install
    a SignalR client library in order to communicate with the hub. In the following
    section, we will construct client applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building SignalR clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will demonstrate how to use SignalR in different platforms by building
    three SignalR clients that consume the same SignalR hub provided by the `ChatApp.Server`
    application. The code for SignalR is largely the same across platforms, making
    it easy to learn and implement in your own applications. As such, you can refer
    to any of these applications to gain an understanding of how to consume a SignalR
    service in your client applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building a TypeScript client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first client we will build is a TypeScript client. This application is just
    a normal HTML page that uses the SignalR JavaScript client library to communicate
    with the SignalR hub. TypeScript is a superset of JavaScript that provides static
    typing and other features to help developers write better JavaScript code. TypeScript
    code is compiled into JavaScript code, so it can run in any JavaScript runtime,
    such as browsers and Node.js. To learn more about TypeScript, you can visit the
    official website at [https://www.typescriptlang.org/](https://www.typescriptlang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use TypeScript in the application, we need to install it. You can do so
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing TypeScript, you can use the following command to check the
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you see the version number, it means that TypeScript is installed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, follow these steps to create a TypeScript client:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `ChatApp.TypeScriptClient` in the solution folder.
    Then, create a `src` folder in the `ChatApp.TypeScriptClient` folder. The `src`
    folder is used to store the source code of the TypeScript client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file named `index.html` in the `src` folder and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code creates a simple HTML page that contains a textbox and a
    button. The `ul` element is used to display messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new file named `tsconfig.json` in the `ChatApp.TypeScriptClient` folder
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is the configuration file for the TypeScript compiler. It
    specifies the target version of JavaScript, the module system, and other options.
    It also specifies the TypeScript files to compile, such as `app.ts`. We will create
    an `app.ts` file in *step 6*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to set up `npm` so that we can install the required packages.
    Use the following command to initialize `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to install the required packages. Use the following command to
    install the required packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file named `app.ts` in the `src` folder and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code creates a SignalR connection to the SignalR hub. The `connection`
    object is used to send messages to the SignalR hub and receive messages from the
    SignalR hub. The `withURL()` method is used to specify the URL of the SignalR
    hub. In this case, we use `https://localhost:7159/chatHub` as the URL. If your
    SignalR hub is hosted on a different URL, you need to change it accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the page is loaded, the `connection` object has a couple of methods used
    in this sample:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`on()` method takes two parameters: the first parameter is the name of the
    method, which is `RecieveMessage()`, as we defined in the `ChatHub` class, and
    the second parameter is a callback function that is called when the message is
    received.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invoke()` method is called when the user clicks the `invoke()` method takes
    three parameters: the first parameter is the name of the method we want to invoke
    on the SignalR hub, which is `SendMessage()`, as we defined in the `ChatHub` class,
    the second parameter is the username, and the third parameter is the message.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to use the correct method names. Otherwise, the client will not be
    able to communicate with the SignalR hub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to compile the TypeScript code to JavaScript code. We will use
    Gulp to automate the compilation process. If you prefer to use other tools, such
    as Webpack, you can use them as well. Use the following command to install Gulp
    globally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'gulpfile.js in the ChatApp.TypeScriptClient folder and add the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `gulp` configuration file defines some tasks that are used to compile TypeScript
    code to JavaScript and generate a bundle file. Additionally, it copies HTML files
    to the `dist` folder, which is used to store the compiled JavaScript code and
    HTML files. If desired, the folder name can be changed. The bundle file loads
    the SignalR JavaScript client library and the compiled JavaScript code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a script to the `package.json` file to run `gulp` tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete `package.json` file should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the `index.html` file in the `src` folder to load the bundle file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to compile the TypeScript code and copy the HTML
    files to the `dist` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 13.1 – Running the TypeScript client in VS Code](img/B18971_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Running the TypeScript client in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: You can also try some other tools, such as `http-server`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start the SignalR server by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: // Enable CORSvar corsPolicy = new CorsPolicyBuilder()    .AllowAnyHeader()    .AllowAnyMethod()    .AllowCredentials()    .WithOrigins("http://127.0.0.1:3000")    .Build();builder.Services.AddCors(options
    =>{    options.AddPolicy("CorsPolicy", corsPolicy);});
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the SignalR server and refresh the web page. You should see the **Send**
    button is enabled. Enter a username and a message and click the **Send** button.
    You should see the message displayed in a list, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Sending a message from the TypeScript client](img/B18971_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Sending a message from the TypeScript client
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another browser tab and enter the same URL. Enter a different username
    and a message and click the **Send** button. You should see the message displayed
    in both browser tabs, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Sending a message from another browser tab](img/B18971_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Sending a message from another browser tab
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript client is now complete. This is a very simple client that does
    not use any JavaScript frameworks. The world of frontend development is changing
    rapidly. If you encounter any issues when testing the sample code, you can use
    any other JavaScript frameworks you like, such as React, Angular, or Vue.js. The
    code for SignalR is largely the same for different JavaScript frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Blazor client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second client we will build is a Blazor client. Blazor is a web framework
    for building client-side applications using C#. Blazor was first introduced as
    a part of ASP.NET Core 3.0 in 2018\. Blazor supports different hosting models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blazor Server**: In this hosting model, the Blazor application is hosted
    on an ASP.NET Core server. Remote clients connect to the server using SignalR.
    The server is responsible for handling user interactions and updating the UI over
    a SignalR connection. The application can use the full power of the .NET ecosystem
    and all ASP.NET Core features. This hosting model also allows the client to download
    a small amount of code, meaning the application loads fast, but it requires a
    persistent connection to the server. If the SignalR connection is lost, the application
    will not work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blazor WebAssembly**: This hosting model runs the Blazor application on a
    WebAssembly .NET runtime in the browser. The Blazor application is downloaded
    to the client, which means that this model requires a larger download size than
    the Blazor Server model. When a Blazor WebAssembly application is hosted within
    an ASP.NET Core application, it is called *hosted Blazor WebAssembly*. The hosted
    Blazor WebAssembly application can share code with the ASP.NET Core application.
    When a Blazor WebAssembly application is hosted in a static website without server-side
    code, it is called *standalone Blazor WebAssembly*. A standalone Blazor WebAssembly
    application acts like a pure client-side application, such as a React application,
    so it can be hosted on any web server or a **content delivery network** (**CDN**).
    Blazor WebAssembly applications can work offline, but the performance depends
    on the client’s hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blazor Hybrid**: This model allows a Blazor application to run in a .NET
    native app framework, such as WPF, Windows Forms, and MAUI. This model combines
    the power of the web and native applications, and it can use the full power of
    the .NET platform. It is suitable for building cross-platform applications because
    the Blazor code can be shared across different platforms. However, it is still
    required to package the application for different platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this sample application, we will use standalone Blazor WebAssembly to build
    the client application because a web-based application is one of the most seen
    scenarios. But it is also possible to use similar code for other hosting models.
    ASP.NET Core 8 brings some improvements to Blazor. To learn more about Blazor,
    you can visit the official website at [https://learn.microsoft.com/en-us/aspnet/core/blazor/](https://learn.microsoft.com/en-us/aspnet/core/blazor/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Blazor WebAssembly application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the root folder of the `ChatApp.sln` solution. Create a new Blazor
    WebAssembly application called `ChatApp.BlazorClient` and add the project to the
    solution using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'page directive in the /Components/Pages/Home.razor file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `using` statement imports the SignalR client library to the `Home` component.
    The `implements IAsyncDisposable` statement indicates that the `Home` component
    implements the `IAsyncDisposable` interface. The `IAsyncDisposable` interface
    is used to dispose of resources asynchronously. We will use it to dispose of the
    SignalR connection when the component is no longer in use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the end of the `Home.razor` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Blazor utilizes the `@code` directive to incorporate C# code into components.
    In this instance, we have defined a few fields and methods for the `Home` component.
    If you compare this code to its TypeScript counterpart, you will find that the
    logic is very similar. The `OnInitializedAsync()` method is used to set up a SignalR
    connection, while the `SendMessage()` method is used to invoke the `SendMessage()`
    method of the SignalR hub to send a message. The `DisposeAsync()` method is used
    to dispose of the SignalR connection when the component is no longer in use. Additionally,
    the `StateHasChanged()` method is used to notify the component to re-render the
    UI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to bind these fields to the UI. Add the following code before
    the `@``code` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Blazor uses the `@` symbol to indicate a C# expression. The `@bind` directive
    is used to bind the value of the input element to the specified field. The `@onclick`
    directive is used to bind the click event to the specified method. The `@foreach`
    directive is used to iterate over the messages and display them in a list. If
    you are familiar with any modern JavaScript frameworks, such as React, Angular,
    or Vue.js, you will find some similarities between Blazor and these frameworks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to configure the CORS policy for the SignalR server so that the
    Blazor client can connect to the SignalR hub. Check the `launchSettings.json`
    file in the `Properties` folder. Similar to the SignalR server application, we
    can use the `http` or `https` profile to run the Blazor client application. We
    will use the `https` file in this case. For example, the URL of the sample code
    uses `https://localhost:7093` to run the Blazor client application on the HTTPS
    profile. We need to update the CORS policy in the SignalR server. Update the `Program.cs`
    file of the `ChatApp.Server` project, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the SignalR server can accept cross-origin requests from the Blazor client
    application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the SignalR server application and the Blazor client application in separate
    terminals using the `dotnet run --launch-profile https` command. You can test
    the Blazor client application by opening the `https://localhost:7093` URL in the
    browser. The Blazor client can chat with the TypeScript client, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Chatting between the Blazor client and the TypeScript client](img/B18971_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Chatting between the Blazor client and the TypeScript client
  prefs: []
  type: TYPE_NORMAL
- en: SignalR provides the convenience of real-time communication. Developers do not
    need to operate the underlying transport details; instead, they can use the SignalR
    `Hub` class to send and receive messages easily. In the next section, we will
    explore more features of a SignalR hub.
  prefs: []
  type: TYPE_NORMAL
- en: Using authentication and authorization in SignalR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we used the `Hub` class to implement a simple chat
    app. The `Clients.All.SendAsync` method is used to send a message to all connected
    clients. Sometimes, we may want to send a message to a specific client or a group
    of clients. To manage users and groups, we need to know the identity of the user.
    In this section, we will explore how to use authentication and authorization in
    SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: By default, SignalR uses a `ClaimTypes.NameIdentifier` claim to differentiate
    users. The `ClaimTypes.NameIdentifier` claim is used to uniquely identify a user.
    We introduced claim-based authorization in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307),
    so we will follow the steps from that chapter to add authentication and authorization
    to the SignalR server application. If you are not familiar with ASP.NET Core authentication
    and authorization, you can refer to [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete code of the sample in the `chapter13/v2` folder of
    the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication and authorization to the SignalR server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add authentication and authorization to the SignalR server, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the required packages using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a connection string in the `appsettings.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add configurations for JWT tokens in the `appsettings.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use the same SignalR server as the authentication server. So, we will
    use the URL of the SignalR server as the audience and issuer. If you use a different
    authentication server, you need to change the audience and issuer accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'SignalR needs an `IUserIdProvider` interface to get the user ID. Create a new
    folder named `Services` in the `ChatApp.Server` project. Then, create a new class
    called `NameUserIdProvider` in the `Services` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code implements the `IUserIdProvider` interface. The `GetUserId`
    method returns the user ID of the current user. In this case, we use the username
    as the user ID. You can use any other unique value as the user ID. For example,
    if you want to use the email address as the user ID, you can create an `EmailBasedUserIdProvider`
    class as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `Program.cs` file to add authentication and authorization, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is similar to the code in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307).
    A difference is that we configured the `options.Events` property of the `JwtBearerOptions`
    object. The `OnMessageReceived` event is used to check the token in the query
    string. The reason is that WebSocket APIs and SSE do not support the standard
    `Authorization` header, so it is required to attach the token to the query string.
    If the token is found in the query string, it will be used to authenticate the
    user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also added the `IUserIdProvider` service to the `NameUserIdProvider` class
    we created earlier. If you want to use the `EmailBasedUserIdProvider` class, you
    need to change the code accordingly. Note that you must not use both at the same
    time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a database and run migrations using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Authorize]public class ChatHub : Hub{    // Omitted for brevity}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `ChatApp.Server` application, as well as any other client applications.
    Unfortunately, the TypeScript and Blazor clients will not be able to connect to
    the SignalR hub due to the need for user authentication. To access the SignalR
    hub, we need to authenticate the clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a login endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To authenticate the clients, we need to provide a login endpoint. We implemented
    a login endpoint in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307). You can follow
    the steps in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307) to implement the
    login endpoint or copy the code from the sample application. You need to create
    an `AccountController` class that contains register and login endpoints. You also
    need to add some models, such as the `LoginModel` and `AddOrUpdateUserModel` classes.
    With these classes, we can use the `account/register` and `account/login` endpoints
    to register and log in users.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note here is that when generating a JWT token, we need to add
    a `ClaimTypes.NameIdentifier` claim to the token. SignalR uses this claim to identify
    the user. The following code shows how to add a `ClaimTypes.NameIdentifier` claim
    to the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create some users for testing. Run the `ChatApp.Server` application
    and send a `POST` request to the `account/register` endpoint using Postman or
    any other HTTP client. The following code shows how to create a user using the
    `account/register` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Create more users such as `user2`, `user3`, and so on. We will use these users
    to test the `Groups` feature later.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the TypeScript client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can authenticate the TypeScript client. To do so, we need to update
    the UI to allow the user to enter the username and password. We also need to update
    the TypeScript code to send the username and password to the login endpoint. Follow
    these steps to update the TypeScript client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the HTML content in the `<body>` element as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code adds a login form to the HTML page. The login form contains
    a username textbox, a password textbox, and a login button. The `divChat` element
    now has a `lblUsername` element to display the username. The `divChat` element
    is hidden by default. We will show it after the user is authenticated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `app.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some codes are omitted. You can find the full code from the books GitHub repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the preceding code, we use the `fetch` API to send a `POST` request to the
    login endpoint. The login endpoint returns a JWT token if the user is authenticated.
    Then, we store the token in the local storage and show the username in the `divChat`
    element. We also adjusted the creation of the SignalR connection. The `accessTokenFactory`
    property is used to get the token from the local storage. You can add some logic
    to check whether the token is valid or expired. If the token is expired, you can
    redirect the user to the login page or use the `dist` folder:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **Live Preview** extension to run the web server. Run the SignalR server
    application as well. You will see a login form, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.5 – The login form](img/B18971_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – The login form
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the username and password you created earlier to log in. You should see
    a chat form, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Authenticated chat](img/B18971_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Authenticated chat
  prefs: []
  type: TYPE_NORMAL
- en: Now, the TypeScript client is authenticated. Next, we will authenticate the
    Blazor client.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the Blazor client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code to authenticate the Blazor client is very similar to the TypeScript
    client, so we will not list all the code here. You can find the code in the sample
    application. The following code shows how to log in and set a token to the SignalR
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we inject `HttpClient` to send a `POST` request to the
    login endpoint. Then, we set a token to the SignalR connection. The `AccessTokenProvider`
    property is used to get the token from the `_token` field. Similar to the TypeScript
    client, you can add some logic to check whether the token is valid or expired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the three applications. You can use different usernames to log in to the
    two clients and send messages. You should see messages are displayed in both clients,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Authenticated chat for different users](img/B18971_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Authenticated chat for different users
  prefs: []
  type: TYPE_NORMAL
- en: The clients now support authentication. Next, we will add more features to the
    chat app.
  prefs: []
  type: TYPE_NORMAL
- en: Managing users and groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we implemented basic authentication and authorization
    for the SignalR server. We also updated clients to authenticate users. In this
    section, we will explore how to manage users and groups in SignalR. We want to
    add features to the chat app to enable the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow users to know who is connected to the chat app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to send a message to a specific user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to join groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to send a message to a specific group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the complete code of the sample in the `chapter13/v3` folder of
    the GitHub repository. Let’s start with the first feature.
  prefs: []
  type: TYPE_NORMAL
- en: Managing events in SignalR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SignalR provides events to notify clients when a user connects or disconnects.
    We can override the `OnConnectedAsync()` and `OnDisconnectedAsync()` methods to
    handle these events. The following code shows how to override the `OnConnectedAsync()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When a client connects to the SignalR hub, the `OnConnectedAsync()` method will
    be called. In this case, we use the `Clients.All.SendAsync()` method to send a
    message to all connected clients. The `Context.User.Identity.Name` property is
    used to get the username of the current user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to override the `OnDisconnectAsync()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can update the TypeScript client to handle the `UserConnected` and
    `UserDisconnected` events. The following code shows how to handle the `UserConnected`
    event in the TypeScript client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in the Blazor client is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the SignalR server and the two clients. You should see the
    user’s connected and disconnected messages in the chat window. If you refresh
    the page or close the browser tab, you should see a user-disconnected message,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.8 – User-connected and -disconnec\uFEFFted messages](img/B18971_13_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – User-connected and -disconnected messages
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add a feature to allow users to send a message to a specific user.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message to a specific user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next feature we want to add is to allow users to send a message to a specific
    user. To do so, we need to know to whom the message is sent. SignalR uses a `ClaimTypes.NameIdentifier`
    claim to differentiate users. To simplify the code, we will pass the username
    as the target user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `Clients.User(user)` method to find the connection
    of the specified user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update the TypeScript client to add a textbox to enter the target username.
    The following code shows how to update the HTML content for the `divChat` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can invoke this method from the TypeScript client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, when the `txtToUser` field is not empty, we use the `SendMessageToUser()`
    method to send a message to a specified user. Otherwise, we use the `SendMessage()`
    method to send a message to all connected users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the Blazor client is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the sample application for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the three applications. This time, we need to open three browser tabs for
    testing. Use three different usernames to log in to the three clients. Then, we
    can send a message to a specific user, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Sending a message to a specific user](img/B18971_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Sending a message to a specific user
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 13**.9*, we sent a message to the `user1` user from `user2`. You
    can see that the message is displayed in the `user1` browser tab but not in the
    `user3` browser tab.
  prefs: []
  type: TYPE_NORMAL
- en: You can try to log in to the same username in different browser tabs. You will
    find that both browser tabs will receive the message. This is because SignalR
    uses the `ClaimTypes.NameIdentifier` claim to differentiate users. Each browser
    tab has a different SignalR connection, but they use the same username. Therefore,
    SignalR will treat them as the same user.
  prefs: []
  type: TYPE_NORMAL
- en: Using strongly typed hubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have added a couple of methods to the `ChatHub` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Each method calls the `SendAsync()` method with a string parameter. The string
    parameter is the name of the method to be invoked on the client. The `SendAsync()`
    method is a dynamic method, but it is not type-safe. If we misspell the method
    name, the compiler will not report any error. To improve type safety, we can use
    strongly typed hubs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use strongly typed hubs, we need to define a hub interface that contains
    client methods. The following code shows how to define a hub interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can update the `ChatHub` class to implement the `IChatClient` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `SendAsync()` method is no longer used. Instead,
    we use the `RecieveMessage()`, `UserConnected()`, and `UserDisconnected()` methods
    defined in the `IChatClient` interface. The `Hub` class is generic, so we need
    to specify the `IChatClient` interface as the generic type argument. Now, the
    `ChatHub` class is strongly typed. Note that if you use a strongly typed hub,
    the `SendAsync()` method is no longer available.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add a feature to allow users to join groups.
  prefs: []
  type: TYPE_NORMAL
- en: Joining groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SignalR allows users to join groups. The `Hub` class has a `Groups` property
    to manage groups. The type of the `Groups` property is the `IGroupManager` interface,
    which provides methods such as `AddToGroupAsync()`, `RemoveFromGroupAsync()`,
    and so on. The following code shows how to add a user to a group and remove a
    user from a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `Groups` property to manage groups. The `Context.ConnectionId`
    property is used to get the connection ID of the current user. The `Clients.Group`
    method is used to send a message to all users in the specified group so that they
    can know who has joined or left the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to update the UI to allow a user to enter the group name. Add
    the following code to the HTML content for the `divChat` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the TypeScript code to handle `JoinGroup` and `LeaveGroup` events. The
    following code shows how to handle the `JoinGroup` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows two event handlers for the `JoinGroup` and `LeaveGroup`
    events, which invoke the `AddToGroup()` and `RemoveFromGroup()` methods on the
    SignalR hub respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the Blazor client is very similar. We will not list the code here.
    You can find the code in the sample application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the client should be able to join and leave groups. When a user joins
    or leaves a group, the other users in the group will receive a message, as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Joining and leaving groups](img/B18971_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Joining and leaving groups
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 13**.10*, `user3` joined `group1` and then left `group1`. You can
    see that the other users in `group1` received messages.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add a feature to allow users to send a message to a specific group.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message to a group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code to send a message to a group is very similar to the code to send a
    message to a specific user. The following code shows how to send a message to
    a group in the `ChatHub` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses `Clients.Group(group)` to find connections of the users
    in the specified group. Then, it uses the `ReceiveMessage()` method defined in
    the `IChatClient` interface to send a message to users in the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Blazor client can invoke this method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We will not list the code for the TypeScript client here. You can find the code
    in the sample application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the client should be able to send a message to a specific group. The following
    figure shows how to send a message to a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Sending a message to a group](img/B18971_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – Sending a message to a group
  prefs: []
  type: TYPE_NORMAL
- en: You will see a message displayed for `user1` and `user3` as they are in the
    same group. But `user2` and `user4` will not see the message because they are
    not in `group1`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages from other services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have implemented a chat app that allows users to send messages to
    other users or groups. Sometimes, we need to send messages from other places.
    For example, when an event occurs, we may need to send a message to notify the
    users. In this section, we will explore how to send messages from other services.
    You can find the complete code of the sample in the `chapter13/v4` folder of the
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a REST API endpoint to allow other systems to send messages to
    the SignalR hub. Follow these steps to add a REST API endpoint in the `ChatApp.Server`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following models in the `Models` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These models are used to send messages to the SignalR hub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new controller or use the existing `AccountController` class in the
    sample application. We will create a `ChatController` class in the `Controllers`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject the `IHubContext<ChatHub`, `IChatClient>` service into the `ChatController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `IHubContext<ChatHub, IChatClient>` service is used to send messages to
    clients. In this example, we use a strongly typed hub. You can also inject the
    `IHubContext<ChatHub>` service if you use a normal SignalR hub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following actions to send messages to all users, a specific user, and
    a specific group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code uses the `hubContext.Clients` property to send messages to
    clients. Note that this endpoint is not authenticated. You can add authentication
    and authorization to this endpoint if required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the three applications. Use different users to log in and join the group.
    Then, you can test the `chat/all`, `chat/user`, and `chat/group` endpoints using
    Postman or any other HTTP client.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how to send messages from external services. In the next section, we
    will explore how to manage SignalR connections.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SignalR hubs and clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SignalR provides a `HubOptions` class to configure SignalR hubs. Also, SignalR
    clients have some configuration options. In this section, we will explore how
    to configure SignalR hubs and clients. You can find the complete code of the sample
    in the `chapter13/v5` folder of the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SignalR hubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the configuration options for SignalR hubs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KeepAliveInterval`: This property determines the interval at which a keep-alive
    message is sent to clients. If a client does not receive a message from the server
    within this period of time, it will send a `ping` message to the server in order
    to maintain the connection. When changing this value, it is important to also
    adjust the `serverTimeoutInMilliseconds` or `ServerTimeout` option in the client.
    For best results, it is recommended to set the `serverTimeoutInMilliseconds` or
    `ServerTimeout` option to a value that is double the value of the `KeepAliveInterval`
    property. The default value of `KeepAliveInterval` is 15 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClientTimeoutInterval`: This property determines the interval at which the
    server will consider the client disconnected if it has not received a message
    from the client. It is recommended to set `ClientTimeoutInterval` to a value that
    is double the value of the `KeepAliveInterval` property. The default value of
    `ClientTimeoutInterval` is 30 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnableDetailedErrors`: This property determines whether detailed error messages
    are sent to the client. The default value of `EnableDetailedErrors` is `false`
    as error messages may contain sensitive information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaximumReceiveMessageSize`: This property determines the maximum size of a
    message that the server will accept. The default value of `MaximumReceiveMessageSize`
    is 32 KB. Do not set this value to a very large value as it may cause **denial-of-service**
    (**DoS**) attacks and consume a lot of memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaximumParallelInvocationsPerClient`: This property determines the maximum
    number of hub method invocations that can be executed in parallel per client.
    The default value of `MaximumParallelInvocationsPerClient` is 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StreamBufferCapacity`: This property determines the maximum number of items
    that can be buffered in a client upload stream. The default value of `StreamBufferCapacity`
    is 10\. We will introduce streaming in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways to configure SignalR hubs. The first way is to provide a
    `HubOptions` object to all hubs. The following code shows how to configure the
    `ChatHub` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is to configure the SignalR hubs for each hub. The following
    code shows how to configure the `ChatHub` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is useful if you have multiple hubs and you want to configure
    them differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you change the `KeepAliveInterval` or `ClientTimeoutInterval`
    property of the SignalR hub, you need to update the `serverTimeoutInMilliseconds`
    or `ServerTimeout` option in the clients as well. The following code shows how
    to configure the TypeScript client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `HubConnection` object has the `keepAliveIntervalInMilliseconds` property
    and the `serverTimeoutInMilliseconds` property, which can be used to match the
    configuration in the server project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can configure the Blazor client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that the values of the `KeepAliveInterval` and `ClientTimeout/ServerTimeout`
    properties are the same in the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP configuration options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SignalR can automatically negotiate the transport protocol with the client.
    The default transport protocol is WebSockets. If the client does not support WebSockets,
    SignalR will use SSE or long polling. You can configure HTTP options for SignalR.
    The following code shows how to configure HTTP options for the `ChatHub` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code configures HTTP options for the `ChatHub` class using a `HttpConnectionDispatcherOptions`
    object. In this sample, we configured the `Transports` property to use WebSockets
    and long polling, but not SSE. In addition, we configured the `CloseTimeout` property
    of the `WebSockets` property to 10 seconds, and the `PollTimeout` property of
    the `LongPolling` property to 120 seconds. The default value of the `CloseTimeout`
    property is 5 seconds, meaning that after the server closes, the connection will
    be terminated if clients cannot close the connection within 5 seconds. The default
    value of the `PollTimeout` property is 90 seconds, meaning that the server will
    terminate a poll request after waiting for 90 seconds and then create a new poll
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The allowed transports can be configured in the client as well. We can configure
    the TypeScript client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how to configure the Blazor client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `HttpTransportType` enum has a `FlagsAttribute` attribute, so you can use
    the bitwise `OR` operator to combine multiple transport protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically reconnecting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, due to network issues, the SignalR connection may be disconnected.
    For example, if the user’s device is switched from Wi-Fi to cellular, or if the
    user’s device is in a tunnel, the SignalR connection may be disconnected. In this
    case, we want the client to automatically reconnect to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalR allows the client to automatically reconnect to the server if the connection
    is dropped. The following code shows how to configure the TypeScript client to
    automatically reconnect to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, you can configure the Blazor client as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, when the connection is dropped, the client will try to reconnect
    to the SignalR server in 0, 2, 10, and 30 seconds. You can configure the retry
    policy as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `withAutomaticReconnect()` method accepts an array of numbers to configure
    the delay duration in milliseconds. In the preceding code, the client will try
    to reconnect to the server in 0, 5, and 20 seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the Blazor client, you can configure the retry policy as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code configures the same retry policy as the TypeScript client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test the automatic reconnect feature, we can add a label to show the connection
    status. Add the following code to the HTML content for the `divChat` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update the TypeScript code to show the connection status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also enable debug logging to see the connection status. The following
    code shows how to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can find the complete code in the sample application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the SignalR server and the TypeScript client. Press *F12* to open the developer
    tools for the TypeScript client. Click the **Network** tab, and you can change
    network conditions to simulate network issues. For example, you can change the
    network to **Offline** to simulate network disconnection, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Simulating network disconnection in Chrome developer tools](img/B18971_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – Simulating network disconnection in Chrome developer tools
  prefs: []
  type: TYPE_NORMAL
- en: 'After you change the network to **Offline**, wait for a few seconds (depending
    on the timeout configuration), and you should see the client automatically reconnect
    to the server, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.13 – The client automatically reconnects to the server](img/B18971_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – The client automatically reconnects to the server
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the network back to Online, and you should see that the client reconnects
    to the server, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.14 – The client reconnects to the server after the network is back
    online](img/B18971_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.14 – The client reconnects to the server after the network is back
    online
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the client fails to reconnect to the server after trying four times, the
    `onclose` event will be triggered. You can add the event handler for the `onclose`
    event to handle the connection close event. For example, you can notify the user
    that the connection is closed and ask the user to refresh the page or manually
    reconnect to the server.
  prefs: []
  type: TYPE_NORMAL
- en: SignalR in ASP.NET Core 8.0 supports stateful reconnect, allowing the server
    to temporarily store messages when the client is disconnected. Upon reconnection,
    the client will use the same connection ID, and the server will replay any messages
    that were sent while the client was disconnected. This ensures that the client’s
    state is maintained and that no messages are lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable stateful reconnect, we need to configure the `AllowStatefulReconnects`
    option for the SignalR hub endpoint as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, the maximum buffer size of the stateful reconnect is 100,000 bytes.
    You can change the buffer size as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can configure the TypeScript client to use the stateful reconnect
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, you can configure the Blazor client as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To configure the buffer size of the Blazor client, you can configure the `HubConnectionOptions`
    object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Besides the automatic reconnect feature, you can also manually reconnect to
    the SignalR server if the connection is dropped. You can add an event handler
    for the `onclose` event or `Closed` event to handle the connection close event.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling SignalR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have implemented a chat app that allows users to send messages to
    other users or groups. We have also explored how to manage SignalR connections.
    You can also use a similar approach to build a real-time notification system,
    a real-time dashboard, and so on. However, the application can only run on a single
    server. If we want to scale the application, for example, using a load balancer
    to distribute requests to multiple servers, server *A* does not know the connections
    on server *B*.
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalR requires a persistent connection between the client and the server.
    That means requests from the same client must be routed to the same server. This
    is called *sticky sessions* or *session affinity*. This is required if you have
    multiple SignalR servers. Besides this requirement, there are some other considerations
    when you scale SignalR:'
  prefs: []
  type: TYPE_NORMAL
- en: If you host the application in Azure, you can use Azure SignalR Service. Azure
    SignalR Service is a fully managed service that helps you scale the SignalR application
    without worrying about the infrastructure. With Azure SignalR Service, you do
    not need to use sticky sessions as all clients connect to Azure SignalR Service.
    This service takes on the responsibility of managing connections and freeing up
    resources on the SignalR servers. For more information, please refer to [https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview](https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you host the application on your own infrastructure or other cloud providers,
    you can use Redis backplane to synchronize the connections. The Redis backplane
    is a Redis server that uses the pub/sub feature to forward messages to other SignalR
    servers. However, this approach requires sticky sessions for most cases, and the
    SignalR application instances require additional resources to manage connections.
    There are some other SignalR backplane providers, such as SQL Server, NCache,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not cover details of how to scale SignalR in this book. You can find
    more information in the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SignalR is a powerful library that simplifies the process of building real-time
    web applications. In this chapter, we explored how to use SignalR to build a chat
    app. We introduced basic concepts of SignalR, such as hubs, clients, and connections.
    We created clients using TypeScript and Blazor, which demonstrated how to use
    both TypeScript and .NET to build SignalR clients. We also discussed how to send
    messages to a specific user or group and how to secure SignalR connections using
    JWT authentication. Additionally, we explored how to configure SignalR hubs and
    clients, such as configuring the keep-alive interval, configuring HTTP options,
    and configuring the automatic reconnect feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we have covered a lot of features, there is still more to explore,
    such as streaming. For more information, please refer to the official documentation:
    [https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction](https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction).
    In the next chapter, we will explore how to deploy ASP.NET Core applications.'
  prefs: []
  type: TYPE_NORMAL
