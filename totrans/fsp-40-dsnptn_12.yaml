- en: Chapter 12. F# and OOP Principles/Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous chapters were aimed at developing and honing your taste for the usage
    patterns of functional programming, paying very occasional attention to comparison
    with OOP arrangements. This chapter caters to those of you who have an OOP background
    and may be anxiously expecting for the book to begin meticulously porting each
    and every one of the of **23 original Gang of Four object-oriented design patterns**
    ([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)
    ), one by one into F#.
  prefs: []
  type: TYPE_NORMAL
- en: I may disappoint you, as all topics covered so far indicate that staying with
    the functional-first facet of F# promoted by the book may make some of these patterns
    just irrelevant, intrinsic, or ubiquitous. In other words, the original patterns
    may morph into something much less fundamental compared to their role in the OOP
    world.
  prefs: []
  type: TYPE_NORMAL
- en: A similar transformation applies to OOP principles, collectively known as **SOLID**
    ([https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))
    ). That is, from a functional programming standpoint, these principles may become
    either granted, irrelevant, or just respected, without much extra effort required
    from developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to briefly demonstrate some cases of the morphing
    outlined in the preceding paragraphs. In this chapter, we will take a look at
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How OOP SOLID principles get morphed within the functional-first paradigm, and
    what exactly happens to each of these five pillars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How some of the specific design patterns (Command, Template, Strategy) diminish
    in role, or just become simply equivalent to bits and pieces of the functional-first
    paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will not attempt to lay out an exhaustive, thorough review. In the end, this
    book aims to develop skills and techniques of the functional-first paradigm, not
    any other paradigms supported by F#.
  prefs: []
  type: TYPE_NORMAL
- en: Morphing SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider how the functional programming paradigm morphs the five basic
    principles of the object-oriented design known under this bold acronym of **SOLID**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The gist of **Single Responsibility Principle** ([https://en.wikipedia.org/wiki/Single_responsibility_principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)
    ) ( **SRP** ), standing for the letter "S" in **SOLID** , in OOP terms is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"There should never be more than one reason for a class to change"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, if a class implementation is to be changed in response to two
    or more independent modifications to a functionality, this is an evidence of the
    **Single Responsibility Principle** ( **SRP** ) violation in its design. Following
    this principle in the OOP world entails designs consisting of many lean classes
    in lieu of fewer but bulkier classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider a function as a degenerate case of class free of encapsulated
    data and having only the single method, then this is nothing but a quintessence
    of SRP applied. The following figure illustrates this transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single Responsibility Principle](img/Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Honoring Single Responsibility Principle in functional programming
  prefs: []
  type: TYPE_NORMAL
- en: When we program in idiomatic F#, we compose the functions of a single purpose
    together. In other words, SRP is naturally promoted and enforced in F#.
  prefs: []
  type: TYPE_NORMAL
- en: Open/Closed Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Open/Closed Principle** ([https://en.wikipedia.org/wiki/Open/closed_principle](https://en.wikipedia.org/wiki/Open/closed_principle)
    ) ( **OCP** ), representing the letter "O" in **SOLID** , states that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"software entities (classes, modules, functions, etc.) should be open for
    extension, but closed for modification"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the pure OOP realm, such a property is granted by **inheritance** , both
    by direct **implementation inheritance** (that is, substituting a superclass with
    its subclass) and by **polymorphic implementation** (that is, just another implementation
    of a given interface that keeps itself closed to a modification but is open to
    additionally implementing other interfaces). Both of these forms of OCP are near,
    clear, and dear to the OOP facet of F#; however, they are not idiomatic to any
    extent. The functional-first mechanisms of extension in idiomatic F# are type
    augmentation and composition. The following figure serves as a cheat sheet here,
    as we have devoted a fair amount of attention in the book to these extension methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open/Closed Principle](img/Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Honoring Open/Closed Principle in functional programming
  prefs: []
  type: TYPE_NORMAL
- en: The figure above shows in a very compelling manner how simple, succinct, and
    to the point the extensibility mechanics is within the functional-first idioms.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The letter "L" in **SOLID** comes from **Liskov Substitution Principle** ([https://en.wikipedia.org/wiki/Liskov_substitution_principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
    ) ( **LSP** ) that states:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"objects in a program should be replaceable with instances of their subtypes
    without altering the correctness of that program"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As formulated **LSP** is concerned purely with OOP inheritance, it does not
    seem related to idiomatic F#. Nevertheless, I would mention at least the following
    three F# functional-first idioms that strongly enforce this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Referential transparency** : If a function is pure and produces a certain
    result given an argument of type `T` , then given the corresponding instance of
    type `S` that is a subtype of `T` as an argument, it must produce the identical
    result indeed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F# function argument type substitution** : Based on what has been discussed
    in the preceding bullet point, if we have a type `''S` that derives from type
    `''T` , then an instance of `''S` can be used as a substitute for the corresponding
    instance of `''T` ; so for the following function `f` : `''T -> ''R` , expression
    `f(''S())` *does not require any coercion* of the argument, as the following snippet
    demonstrates (`Ch12_1.fsx` ):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Immutability** : If we have built a valid immutable instance of `''S` , it
    cannot anyhow be invalidated by using it as a substitute for the instance of `''T`
    by the virtue of its immutability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Standing for the letter "I" in **SOLID** , **Interface Segregation Principle**
    ([https://en.wikipedia.org/wiki/Interface_segregation_principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
    ) ( **ISP** ) claims that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"many client-specific interfaces are better than one general-purpose interface"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, an interface that a client is linked with should not introduce
    dependencies that are not used by the client. The **ISP** is just SRP being applied
    to interfaces. Idiomatic F# fully supports ISP by statelessness and naturally
    segregated functions representing interfaces that contain exactly one method.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The letter " **D** " in **SOLID** stands for **Dependency Inversion Principle**
    ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
    ) ( **DIP** ) stating:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"depend upon abstractions, do not depend upon concretions"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following figure shows how **DIP** is achieved in OOP: if an instance of
    class `A` refers the instance of class `B` , this is a direct dependency violating
    DIP. This problem may be fixed by making an instance of class `A` dependent on
    the interface `IB` . So far, so good, but something must implement `IB` , right?
    Let it be the instance of class `B` , which is now a dependent of `IB` , so the
    inversion of dependency takes place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to notice that in idiomatic F#, the role of dependency inversion
    plays a vanilla higher-order function: for example, function `f` has a parameter
    function, `g`  which is used in defining `f` . When `f` is called, any of the
    argument functions `a` , `b` , or `c` may play the role of `g` as long as their
    signatures conform to `g` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Inversion Principle](img/Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Honoring Dependency Inversion Principle in functional programming
  prefs: []
  type: TYPE_NORMAL
- en: Diminishing patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to **SOLID** principles, many OOP design patterns in the context of
    idiomatic functional-first F# either diminish (sometimes to the extent of disappearing)
    or significantly morph. Let's take a quick look at some instances of such transformation.
    I will be using samples taken from the code base I authored, implementing payment
    applications for Jet.com. Samples are somewhat simplified to align with the book
    format.
  prefs: []
  type: TYPE_NORMAL
- en: The Command design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Command Design Pattern** ([https://en.wikipedia.org/wiki/Command_pattern](https://en.wikipedia.org/wiki/Command_pattern)
    ) in OOP stands for a behavioral design pattern where all the information required
    to perform an action at a later time is encapsulated in an object. But wait a
    minute; doesn't this exactly coincide with what a function is? That's right; almost
    any idiomatic F# pattern of dealing with a higher-order function to traverse a
    data structure while applying a lower-order function to each element can be considered
    an occurrence of the Command pattern. Mapping, folding, you name it - all fit
    into this category. Doing what the Command pattern prescribes is an ubiquitous
    idiom in functional-first F#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example: an order flow of a merchant participating in an
    e-commerce marketplace consists of transactions, each representing either **sale**
    or **refund** . By taking any continuous sequence of elements of the order flow,
    its running balance can be found. Now, the factor that makes things more interesting
    is that some orders may be nullified during an established period of time since
    their introduction being canceled. We are charged with tracking a running total
    for the marketplace finance department.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functional-first aspect of F# allows for a very clean, idiomatic solution.
    I begin with two core domain objects, representing order types and customer transactions,
    combining the order type and its cost of goods (`Ch12_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I continue with two core functions accounting for the total based on the order
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Equipped with this, it is time to define our **commands** in the pattern''s
    sense. Both `Order` and `Cancellation` will take a running total and a transaction
    and return a new running total adjusted accordingly (note that `Cancellation`
    mirrors `Order` in terms of the total):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m done! Let me just demonstrate the built code in action by applying it
    to a sample order flow in FSI. The results are presented in the following screenshot,
    where a sequence of some `orderFlow` transactions is run through orders yielding
    `totalForward` of $271.86 and then through cancelation, eventually yielding the
    expected running total `totalBackward` of $0.00:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Command design pattern](img/Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Command pattern as idiomatic F# folding
  prefs: []
  type: TYPE_NORMAL
- en: The Template design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Template design pattern** ([https://en.wikipedia.org/wiki/Template_method_pattern](https://en.wikipedia.org/wiki/Template_method_pattern)
    ) in OOP defines a common skeleton of an algorithm or a program, of which components
    can be overwritten but the general structure stays unchanged. Again, achieving
    this effect following the route that has functions as first class objects is trivial.
    For example, passing functions as parameters will work nicely, so the pattern
    diminishes to non-existing.
  prefs: []
  type: TYPE_NORMAL
- en: Idiomatic F# is even richer than this approach, allowing functions to cohesively
    keep participating in an interface and providing any of the concrete implementations
    in the form of an object expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn to a corresponding code sample taken from the enterprise codebase
    of Jet.com payment applications. The process of paying a partner participating
    in the Jet.com marketplace consists of three consecutive steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining payment requisites and the amount due based on the merchant ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Formatting a payment for the use of a specific payment method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Submitting payment advice to the bank for execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The template keeps the preceding parts together, allowing you to change each
    of the pieces to the case at the same time. As shown in the previous example,
    I begin with defining a few core domain entities (`Ch12_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `PayBy` represents a specific payment instrument (`Check` /`ACH` /`Wire`
    ), formatted `Payment` is just a type abbreviation, `BankReqs` represents a merchant's
    bank requisites for the account to accept the deposited payment, and `Merchant`
    wires together the merchant ID and bank requisites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I define the template as an interface that reflects parts of the payment
    process being cohesive (`Ch12_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This piece is quite straightforward; `GetPaymentDue` retrieves the given merchant's
    requisites and payment amount due from the relevant persisted store, `FormatPayment`
    performs the required payment advice formatting, and `SubmitPayment` takes care
    of delivering the advice to Jet's bank. Note that I intentionally didn't specify
    the payment format here as this detail may be delayed for the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, here, I provide a specific (mock) implementation for `ITemplate` . Still,
    you can see that this arrangement allows plenty of flexibility; in particular,
    I made a specific payment instrument a parameter of the implementation (`Ch12_3.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I wrap everything together into the function using the template (`Ch12_3.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, in order to see this code in action, I turn to FSI, presenting the
    results of running some mock payments in the following screenshot. I''ve omitted
    the complete script source from here for the sake of fitting the figure within
    a single book page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Template design pattern](img/Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Template pattern disappearing in idiomatic F#
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Strategy pattern** ([https://en.wikipedia.org/wiki/Strategy_pattern](https://en.wikipedia.org/wiki/Strategy_pattern)
    ) is simply about adjusting the algorithm behavior in runtime by implementing
    a family of algorithms and using them interchangeably. Once again, what could
    suit this purpose better than a functional-first setting with functions as first-class
    language citizens?
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the use of the Strategy pattern, I will use just another use case
    from Jet.com's Payment system. In its shipping operations, Jet.com uses multiple
    carriers, and due to the significant volume of shipments, it processes carrier
    invoices electronically. The gist of this processing is the loading of invoices
    from each carrier into a staging data table, and then merging the contents of
    this data table with corresponding persistent stores in the **upsert** ([https://en.wikipedia.org/wiki/Merge_(SQL)](https://en.wikipedia.org/wiki/Merge_(SQL))
    ) manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'I approach the implementation of this **EDI** ([https://en.wikipedia.org/wiki/Electronic_data_interchange](https://en.wikipedia.org/wiki/Electronic_data_interchange)
    ) by outlining the implementation of the core behavior first (`Ch12_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet indicates that the supported invoice formats are either
    `Excel` or `CSV` , and there are two generic functions available to load invoices,
    somehow delivered to a location in any acceptable format, into a data table, and
    to merge the filled data table with the existing contents of the corresponding
    persistent store.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good; these two functions may be made accessible via an interface
    whose implementation is to be specific for each of the supported carriers (`Ch12_4.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I provide specific implementations of the preceding interface for two
    of the carriers Jet.com engages into order shipments, namely FedEX and LaserShip
    (`Ch12_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now stay with me; we have two objects of the `ILoadVendorInvoices` type, each
    encapsulating its own carrier specifics. However, we can use them uniformly for
    EDI, as shown in the following function (`Ch12_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Just beautiful; now we can use instances of `LoadFedex` and `LoadLasership`
    to switch the behavior of EDI processing exactly in a manner the Strategy pattern
    prescribes. Let''s turn to FSI for the demonstration. The following screenshot
    shows the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Strategy pattern](img/Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Strategy pattern expressed using F# idioms
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter highlighted that the functional-first approach does not blindly
    contradicts principles and patterns of object-oriented programming. Sometimes
    it also supports and amplifies them.
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to devote the final chapter of this book to the subject of troubleshooting
    functional-first code, as it has certain specifics.
  prefs: []
  type: TYPE_NORMAL
