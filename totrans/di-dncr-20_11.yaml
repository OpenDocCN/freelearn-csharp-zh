- en: Best Practices and Other Related Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last chapter was a very interesting one as we explored Dependency Injection
    in different frameworks such as TypeScript, ES2015, and Angular 2\. This is the
    last chapter and we are going to discuss the coding and architectural practices
    proved to be the best while implementing Dependency Injection in the project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: It's obvious that, when you learn something new and try to implement it in your
    application, excitement might lead you to create a bad architecture. That would
    eventually lead to a bad practice because, after you code it for a few times unknowingly,
    it becomes a habit. Suppose, you get a requirement to save user details to the
    database. You will definitely send the details to the `Service Layer` method which
    in turn would connect to the `Data Access Layer` method, to save the details.
    Quickly (if you are new to the application and don't know about the architecture
    implemented), the first thing you would do is to use the `new` keyword to instantiate
    the dependencies and directly call the methods. In that way, we can't achieve
    loosely coupled modules. However, we could have designed the app and the layers
    in such a way that the consumers won't be able to generate coupling by any means.
    We will explore these techniques in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: So, exploring how to deliver your best with the concept you just learned is
    important for you and your app. For that reason, there are best practices which
    you should be aware of. Dependency Injection deals with Object Composition, Object
    Lifetime, and Interception as a whole, which should be ideally managed by DI Containers.
    If we try to deal with these building blocks ourselves instead of using a container
    to manage the dependencies, we might end up with a bad design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Although we can choose one DI Container, designing and refactoring our code
    accordingly to help the container to work with our classes might be an erroneous
    task.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will touch upon these points in detail to understand the
    real-time problems faced during the induction of DI into the projects. We will
    learn techniques to avoid bad habits in DI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and recommendations in Dependency Injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some recommended techniques to remove tight coupling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring and implementation of DI in legacy layered applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tightly coupled systems
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we have discussed *DI in .NET Core 2.0, Pillars of DI, DI Patterns,
    Anti-Patterns, DI in other frameworks*. Someone who is new to the DI concept might
    do make mistakes and it's normal. We will see more of such scenarios in upcoming
    sections. Before that, let's analyze something which you might find more often
    in ASP.NET MVC projects. If you don't, ask your colleagues and friends. You will
    definitely see such instances.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Let's see one simple controller without DI implemented and learn how to refactor
    that so that it will respect the principles of *Inversion of Control*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of Control states *Do not call us we will call you*. When a class
    tries to instantiate another class inside it, it basically creates a coupling
    with the second class. Now the first class creation depends on the second class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'If the second class fails, for any reason, we won''t be able to get the instance
    of the first class, as the constructor will break:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62615398-6b59-4eb3-8657-451926cf6fe7.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: The **Someone** in the picture can be an IoC Container.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: I would strongly recommend Mr. Shivprasad Koirala's article, if you want to
    grasp this concept in depth. Here is the link--[https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency](https://www.codeproject.com/Articles/29271/Design-pattern-Inversion-of-control-and-Dependency).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram depicts what we are going to do now. We will have a **Controller**
    depending on a **Service**, which in turn depends on a **Repository** for data:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a6cbf62-357a-46b5-9785-14b3fb11853a.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'First of all, let''s think of a simple controller and how that is generally
    implemented in projects. The following is a simple `UsersController` which has
    an action method `Edit`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are the conclusions (more accurately the problems), which can
    be made from the preceding code block:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '`UsersController` instantiates `UsersService` using the `new` keyword (creates
    an instance of a concrete class)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsersController` is tightly coupled with `UsersService`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As far as our knowledge from other chapters is concerned, we should definitely
    avoid both of the preceding points. This makes Unit Testing difficult. DI principles
    encourage us to utilize the area of the Composition Root to register all required
    classes/dependencies (such as `UsersService`) and then use a DI container to resolve
    the instances instead of using the `new` keyword whenever required.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is `UsersService`, which might look something like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Yet another concrete dependency with `UsersRepository`. `UsersService` now does
    the same kind of stuff as we saw in the case of the controller. In this example,
    the service is trying to pass the data returned from the repository. But in reality,
    it might do a lot of things. The important aspect here is how we are managing
    our dependencies inside a class which might get uglier as we build a complex system
    in the future. The exercise we are doing now is just to point out the problem,
    so don't go by the simplicity of the structure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository would look like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following diagram explains what has been done so far:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1e7fe9d-fda2-48ee-989f-a17cc250d795.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Everything stops here. This is the last in the queue. It gets the data from
    the `Users` table and sends it back to the client. This architecture works, but
    there are shortcomings which might get worse as you progress:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is not easy as the classes are tightly coupled with each other.
    For instance, `UsersController` depends on `UsersService`, which in turn depends
    upon `UsersRepository`, and then, at last, it deals with the database, while unit
    testing might fail due to database interactions.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this architecture grows and becomes a fully fledged application, then maintenance
    becomes difficult as the classes are wound up with dependencies all over which
    will be difficult to identify and manage.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no technique/method by which we can easily modify the dependencies.
    Suppose we want to implement another class for a service named `UsersNewService`
    and we want to use that instead of `UsersService`. It will be a tedious task as
    we have to identify all dependencies of `UsersService` and then change them everywhere.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, the concrete service reference might fail in certain circumstances
    where the method signatures may vary across different classes. For example, the `GetUser`
    method in both of these service classes may vary in the signature, making the
    developer's life difficult as you have to modify the `GetUser` caller methods
    as well, including service reference changes.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These flaws not only describe a poorly architected project but also become a
    developer's nightmare to refactor and maintain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The solution - refactoring with DI
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we all know, the Dependency Inversion Principle states the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: High-level modules should not depend on low-level modules. Both should depend
    on **abstractions**.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractions should not depend on details. Details should depend on abstractions.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, let's design the interfaces to abstract out the concrete classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Start from the last one in the hierarchy, which is the repository:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7487ff3b-e86b-480e-a7ac-5520ffbc3fd5.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'The abstraction for the repository would look like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, `UsersRepository` would implement `IUsersRepository` as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Interface extraction
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you know how easy it is to extract an interface out of a class? It''s very
    easy and effective with Visual Studio. Let''s see the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Hover on the concrete class; you will see a bulb at the left side.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on that to open a drop-down menu. Refer to the following screenshot:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a1663e5-99b6-41d1-9af6-3d7527067b01.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Select the `Extract` Interface.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A modal pops up which also lists the public members of the class. See the following
    screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ee3d902-fa21-4d9c-919a-7eda2914b586.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Hit OK. It will create the interface for you.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is another way to extract an interface. You can write the interface name
    and then do a *Ctrl* + *.* (dot) so that the option bubble appears. You need to
    select either of the top two options to generate the interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fc8f6e0-c1f6-4ecc-b9a3-6ae91d585fa9.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: However, there is a difference in comparison to the first approach; its marked
    with the red block. If you select either of the `Generate` options shown in the
    screenshot, it will create a block for interface with a blank block without any
    code inside it (indicated inside the red block). However, in the first case, we
    had the opportunity to select the public members to include them in the interface.
    Imagine a huge class with lots of public members. Undoubtedly, the first approach
    wins for obvious reasons as previously described.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright. Now we can modify the `UsersService` to inject the repository as a
    dependency instead of instantiating using the `new` keyword inside the constructor.
    The `IUsersService` interface can be designed as we did for the repository in
    order to use it inside the controller, which we will see in a while:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05c82b32-7b0b-461c-907c-2ba6bdfe3bf9.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: '`IUsersService` is just a simple interface with `GetUser` as a public member:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`UsersService` can be modified now to implement `IUsersService`. Injection
    can be done using the Constructor Injection pattern to inject the `IUserRepository`
    dependency:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This change will trigger a modification to the controller; otherwise the compiler
    would complain. Let''s make the compiler happy:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can now inject/insert the repository instance to the service inside the controller
    action `Edit`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have eliminated one concrete reference from the architecture that
    is from the `UsersService` class. It's very important to understand our goal.
    We are actually trying to get every dependency in one place so that the design
    gets simplified. Thus, with minimal change, we can easily inject different types
    of dependency into the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: For example, our `UsersService` is now taking responsibility for managing the
    `UsersRepository` dependency instead of the service managing it internally with
    a tight coupling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: However, we are still not done. We have another clearly visible dependency in
    the controller instantiated using the `new` keyword inside the action `Edit` and
    that is none other than the `UsersService`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactored injectible `UsersController` would look like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Simple, isn't it? Constructor Injection again comes to our rescue and allows
    us to inject the service so that we can use it for further operations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome, now we removed all dependencies. Go ahead and run the app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57020285-5416-42e4-b3e2-57a2503a9318.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, it threw an exception. It isn't a surprise. The framework would
    expect one parameter less constructor inside the controller which we don't have
    anymore and then it found one parameterized constructor accepting the `IUsersService`
    implementation instance which was never provided anywhere in the app. Thus, the
    exception was formulated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, I know what you are thinking. Adding one parameter less or default constructor
    won''t change the scene. Rather it will show the following in the browser:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fc28848-c597-42cc-9482-e8261406f8d4.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Moreover, DI does not recommend using multiple constructors, so that is not
    an option anyway.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Before we go ahead with the solution, let me summarise what we have done so
    far.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We created abstractions for concrete classes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We replaced new keywords with constructors injected with abstractions
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the process, we also modified the default constructor of `UsersController`
    to inject the `IUsersService` dependency
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we received exceptions. That is because we have neither instantiated
    any implementation of the `IUsersService` interface nor provided it to the constructor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to do two more things to make the app run. That is to let the compiler
    know what the implementations of the following are:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`IUsersService` interface'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IUsersRepository` interface'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That can be done with an IoC Container. As we are on .NET Core 2.0, let''s
    use the built-in container and see what happens. The `ConfigureServices` method
    of the `Startup` class would look like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s run the app now:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b96498fe-fcd1-4546-9f01-953678456324.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Finally, it runs. Everything is perfect and we got the output in the browser,
    thanks to the DI engine of .NET Core and yes, of course, to the progress you have
    made so far with the book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We did a fabulous job in refactoring the classes to inject dependencies instead
    of referring concrete classes which were inefficient and not maintainable. Still,
    the tight coupling is not totally eliminated. The service is still returning a
    database model class `User` instance to the controller.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a three-layered architecture, where the layers can be the `ASP.NET MVC
    Web App Layer`, `Service/Business Layer`, and `Data Access Layer`. If a developer
    uses the model classes directly in the presentation layer (`ASP.NET MVC Web App
    Layer`), that means it is tightly coupled and can't live without a reference to
    the `Data Access Layer` in the project. In the next section, we will see such
    a problem and try to refactor it to DI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Layered architecture
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a typical modern ASP.NET MVC web app, you will find a three-layered architecture
    with isolated components depending on each other as shown in the following diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/877c5277-733d-409e-8e5e-ef8fffdb14ff.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: When we say some layer depends on another, that means the layer that depends,
    needs instances of the dependency objects to perform certain operations. As we
    saw in the previous section, to get a user from the database, the controller was
    asking the service to provide it from the repository. Thus, we can easily separate
    the classes and package them as components or a class library, speaking technically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: That means my controller remains in `UI Layer` or `Presentation Layer`, `Service
    Class` make another layer who talks to the database through `Data Access Layer`
    classes. Now, as we chose Dependency Injection Technique to manage the dependencies,
    it's the responsibility of the IoC Container to provide the dependent `Data Access
    Layer` objects to the `Service Layer`, and `Service Layer` objects to the UI Layer.
    Most importantly, it takes the control from each layer for object creation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我的控制器仍然位于`UI Layer`或`Presentation Layer`，`Service Class`则创建另一个层，该层通过`Data
    Access Layer`类与数据库通信。现在，由于我们选择了依赖注入技术来管理依赖关系，因此IoC容器负责向`Service Layer`提供依赖的`Data
    Access Layer`对象，并向UI层提供`Service Layer`对象。最重要的是，它从每个层中接管了对象创建的控制权。
- en: The problem - The concrete class reference again
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 - 再次是具体类的引用
- en: I think you may not have noticed one thing in the last section. We tried to
    decouple the system as far as we could. But we have not totally achieved a loosely
    coupled architecture. Let me explain in the next paragraph.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '我想你可能没有注意到上一节中的一个东西。我们尽可能地解耦了系统。但我们并没有完全实现松散耦合的架构。让我在下一段中解释。 '
- en: 'Composition Root is the place where we register all the dependencies to be
    used by the application. The `ConfigureServices` method in the `Startup` class
    was the location of this dependency registration as we saw:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 组合根是注册所有应用程序将使用的依赖项的地方。`Startup`类中的`ConfigureServices`方法就是依赖项注册的位置，正如我们所看到的：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that we are saying, take the `UsersService` instance when `IUserService`
    dependency is required and the `UsersRepository` instance when `IUsersRepository`
    is required. So, basically, we now have to get the assembly references of both
    `Service Layer` and `Data Access Layer` in order to run this code without compilation
    issues. Check out the following screenshot, which proves what I just said:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们说，当需要`IUserService`依赖项时，取`UsersService`实例，当需要`IUsersRepository`时，取`UsersRepository`实例。所以，基本上，我们现在必须获取`Service
    Layer`和`Data Access Layer`的组件引用，才能在没有编译错误的情况下运行此代码。查看以下截图，它证明了我说的话：
- en: '![](img/d51c44e6-078c-46d8-95ee-81e4513f18c8.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d51c44e6-078c-46d8-95ee-81e4513f18c8.png)'
- en: Whatever classes we have designed so far are just separated out in these three
    layers. The repository is in the `Data Access Layer` and the service is inside
    the `Business Layer`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止设计的所有类都只是在这三个层次中分离出来。仓库位于`Data Access Layer`，而服务位于`Business Layer`内部。
- en: Clearly, you can see there is a `Business Layer` assembly reference in the UI
    Layer. As the `Business Layer` has a reference to the `Data Access Layer`, so
    automatically it is carried over to the UI Layer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，你可以看到在UI层中存在一个`Business Layer`的引用。由于`Business Layer`有一个对`Data Access Layer`的引用，所以它自动传递到UI层。
- en: Due to this, the `Presentation Layer` now has access to various implementations
    of the `Service Layer` and `Data Access Layer`. This is a very bad coding practice
    as we are trying to violate the layered architecture concept altogether. There
    is no separation existing between the layers. Moreover, developers can misuse
    the concrete class implementations, as they have direct access due to the assembly
    reference. This is not acceptable at all.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Presentation Layer`现在可以访问`Service Layer`和`Data Access Layer`的各种实现。这实际上是一种非常糟糕的编码实践，因为我们试图完全违反分层架构的概念。层与层之间没有存在分离。此外，由于开发者可以直接通过引用访问具体的类实现，他们可能会滥用这些实现。这是绝对不可接受的。
- en: Misuse of business and Data Access Layer assemblies
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业层和数据访问层组件的滥用
- en: 'Here we will discuss how we, as developers, could misuse the layers in the
    code by direct reference to the layers. Let''s try to understand a few scenarios
    where these assemblies can be misused in the `UI Layer`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论作为开发者，我们如何通过直接引用层来滥用代码中的层。让我们尝试理解一些在这些组件中可能被滥用的场景，特别是在`UI Layer`中：
- en: '**Direct Business Layer Service Access**: As we have a reference of `Business
    Layer`, so we can instantiate it and then call the `GetUser()` method. We needed
    a `Repository` instance for the `Service` constructor, which we can also easily
    provide.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接访问业务层服务**：由于我们有`Business Layer`的引用，因此我们可以实例化它，然后调用`GetUser()`方法。我们需要一个`Repository`实例用于`Service`构造函数，这也可以很容易地提供。'
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how we can easily instantiate the `UsersService` class by passing the `Repository`
    instance to its constructor. That means we still love the `new` keyword.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何可以轻松地通过将`Repository`实例传递给其构造函数来实例化`UsersService`类。这意味着我们仍然喜欢使用`new`关键字。
- en: '**Direct Data Access Repository Access**: Why go through `Service` when we
    have the `Data Access` reference? Why not directly deal with the Repository to
    get the data? Cool isn''t it!'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Yet another `new` keyword usage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct Data Layer Context Access**: Even better is the following approach
    where we don''t even need these intermediate `Service` or `Repository` instances.
    We can directly get data from contexts:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`DataContext` can provide the data directly inside the Controller Action as
    shown in the preceding code.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: We destroyed the layered architecture and the modules are not independent anymore.
    Rather the `Business Layer` and `Data Access Layer` are now tightly coupled with
    the `UI Layer`. This happened just because we had to register concrete implementations
    for the interfaces with the Service Collections inside the `ConfigureServices`
    method. For DI injection to take place, we need this registration step so that
    we can ask the container for dependencies whenever required.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have to find a way. Let's discover a best practice for this kind of
    problem.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Best practice for layered architecture
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, you can do a ton of things to improve the architecture and optimize
    the performance whilst using DI techniques; however, you can't remove the assemblies
    from inside the `bin` folder of the ASP.NET MVP web application. You need to understand
    that the problem lies with access to different concrete implementations of the `Business
    Layer` and `Data Access Layer` inside the `Presentation Layer`; as we saw how devastating
    it can be when developers try to play with the layers instead of properly using
    them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we need to figure out a way to overcome this situation and not allow
    the `Presentation Layer` to access the concrete classes of other layers while
    being benefited by Dependency Injection. The solution is MEF. Let's explore more
    in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Managed Extensibility Framework (MEF)
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before exploring MEF, let me summarize the problem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Tight coupling:** Concrete classes are referenced inside the `UI Layer` by
    DI during the `Startup` inside `ConfigureServices` method.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, we need to do some automation which enables us not to depend
    upon concrete classes of other layers. That is where MEF comes into the picture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: MEF is a library for creating lightweight extensible applications. With the help
    of MEF, developers can easily build the an app to automatically bind extensions
    together without any configurations. There is more on MEF at [https://docs.microsoft.com/en-us/dotnet/framework/mef/index](https://docs.microsoft.com/en-us/dotnet/framework/mef/index)[.](https://docs.microsoft.com/en-us/dotnet/framework/mef/index)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: We are not going deeply into the MEF; you can do that from the preceding link
    I shared. We just need to understand how we can solve our issue with MEF. For
    example, we have a `Service` class and a `Repository` class which we don't want
    to expose to UI for direct consumption as we saw in our preceding code snippets.
    MEF would do that for us by pulling the classes required to register the dependencies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the role MEF is going to play in our app:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84fe4a37-b067-4153-bc63-a5eed43e85ad.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: You can see we have `ModuleInit` classes in every layer with one `Init()` method
    and these classes implement a common interface called `IModule`. It's obvious
    that the DLLs of all the layers will be there in the `bin` folder of the ASP.NET
    MVC Web Project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the interesting scene. MEF gets all assemblies from the `bin` folder of
    the App, then it does the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Searches for the implementations of `IModule`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fires the `Init()` method of each found module.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will see the codes in different layers and how MEF can
    bring back loosely coupled modules to optimise the architecture.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Layers and MEF implementation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going into the code in some depth, let's first analyze the layers. So,
    there are three layers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Web App Layer:** Contains `Controller`, `View`, and so on. Most importantly,
    it has the entry point `Startup.cs`.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Business/Service Layer:** Contains the `Services` where we can include our
    business logic.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data Access Layer:** Contains `Contexts`, `DbSets`, and `Repository` for
    data retrieval from the database.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s have a quick look at the `Visual Studio Solution` window:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b265d83-5dbe-47be-acc9-6cc7b21a2e61.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: We have organized our classes into different layers. Interestingly, we have
    introduced another layer named as `Common Layer`, where we have placed all common
    code related to `Business Layer` and `Data Access Layer`. A common project is
    referenced both by `Business Layer` and `Data Access Layer`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: This common code will help us fetch the dependencies from assemblies related
    to different layers and package them into one (called `ModuleLoader`) so that
    the web app can call just one method to initiate everything. Let's understand
    each part one by one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Introduction of IUser
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal is to remove the concrete class access from the UI layer. We started
    to move all common items into one central layer called `Common`. As we moved `IUsersService`
    to `Common`, we identified a `GetUser` method, which is actually returning a concrete
    `User` instance. Moreover, `UserService` inside the `Business Layer` also has
    the same method as it implements `IUsersService`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how the return type of `GetUser` can be updated to
    `IUser` type instead of `User` type:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to get rid of this `User` class dependency, otherwise, `Common Layer`
    has to again refer to the `Data Access Layer` because the `User` resides in that,
    which is the same case for `Business Layer` to refer `Data Access`. Moreover,
    `Common` is designed to be referred by other layers and not to get other layers
    references inside itself. It should be free from project dependencies. This is
    important.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The solution is very easy. One `IUser` interface can be added inside the `Common/Entities/Users` directory,
    which will be used as a return type for the `GetUser` method. So, `GetUser` inside `UsersService`
    and `UsersRepository` can return the `IUser` type instead of the `User` instance.
    Now we can easily remove the coupling of `Data Access` with the `Common Layer`.
    Also `Data Access` coupling with the `Business Layer`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram tells us what was wrong when we used `User` class. We
    had references to the `Common Layer` and `Data Access Layer` in the `Business
    Layer`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb81c646-ecdf-482b-86ca-6c67be4f09f6.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'The following is the approach which is correct with an interface `IUser`, which
    allows us to reduce the coupling of layers:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f327c048-c7b6-4e4d-a3c2-f3097482ab56.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Now there is no need for a reference to the `Data Layer` inside the `Common
    Layer`. On the contrary, the `Business Layer` and `Data Layer` are dependent on
    `Common`, which is our intention.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The IModuleRegistrar interface
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `IModuleRegistrar` interface is responsible for adding the dependency into
    the service collection. Basically, the implementer of this interface will have
    an `Add()` method with the signature mentioned, which does the job of the `Add***` (`AddTransient`/`AddScoped`/`AddSingleton`)
    methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is present inside the `Common Layer`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The ModuleRegistrar class
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ModuleRegistrar`, which implements the previously mentioned interface, will
    look something like the following. This basically behaves as a wrapper for the
    built-in IoC Container to register dependencies:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice the two important aspects of this class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '`IServiceCollection` is injected into the constructor'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injected `IServiceCollection` used to add dependencies into the container using
    `ServiceDescriptor` instance
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class is a part of the Common Library.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Service Descriptor:** `IServiceCollection` is the collection of the service
    descriptors. A Service Descriptor instance when created can provide full information
    about a service or dependency. We have different methods for different lifestyles
    such as `AddTransient`, `AddScoped`, and `AddSingleton` to register dependencies.
    However, we can''t write all three methods to manage the dependencies at a commonplace.
    That is where a Service Descriptor can help takes lifetime as a parameter and
    can be added directly to the `ServiceCollection` using the `Add` method.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The IModule interface
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IModule` is the main hero of the architecture because this is the first thing
    which will be used by a Loader to recognize what modules are required to be fetched
    from all the assemblies that are targeted. This interface exposes one method, `Initialize()` which
    is invoked by the Loader to add dependencies into the container. Consider the
    following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This interface lies inside Common Library as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The ModuleInit class
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how the preceding `IModule` interface can be implemented inside
    the `Business Layer`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`ModuleInit` is present inside both the `Business Layer` and `Data Access Layer`.
    This class helps us to add different dependencies in each layer such as `UsersService`
    in `Business` and `UsersRepository` in `Data Access`. You can see how `UserService`
    is added to the registrar inside `Business Layer`. I am skipping `ModuleInit`
    of the `DataAccess Layer`. It''s just a change of one line inside `Initialize`.
    The following line of code can be added for `UserRepository` dependency registration
    inside `ModuleInit` of `Data Access Layer`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Just make a note of the bold part `([Export(typeof(IModule))])` in the last-but-one
    code block, which is very important. This is the attribute, which helps MEF to
    grab the `ModuleInit` classes in the specified assemblies, with the interface
    `IModule`. It can then easily call `Initialize` to start the process of registering
    dependencies. We will very soon see the code, that does this task for us.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Wait! We have a Constructor Injection here. And what is that used for? Actually,
    the code for registering the dependency lies inside the registrar, so we definitely
    need the `IModuleRegistrar` dependency in order to call `Add()` of `Registrar`,
    which registers the required dependency, for example, `UsersService` here inside
    `Business Layer`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the flow of controls during the process of dependency registrations.
    Typically the flow is like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`ModuleLoader` | `ModuleInit(IRegistrar)` | `ModuleRegistrar` | `Add()` (adds
    the dependency to collection):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram visualizes the work of **Module Loader** through the
    available layers as discussed:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64d3c9f2-a4db-427e-bc1b-a9bd16890fb0.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: The ModuleLoader class
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with MEF, we need a Nuget package known as </span>`Microsoft.Composition.`
    This will install `System.Composition` into the project. You need to add the package
    inside the `Common Layer`. `ContainerConfiguration` is the class present inside
    the `System.Composition.Hosting` namespace, which composes all assemblies and
    can provide us with a Container, from which we can easilyextract the required
    concrete implementations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is the `NuGet` Package preview shown in the NuGet
    Package Manager window when you search:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8b5c02b-44b6-42f5-9f65-79fe3ef5a5f3.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Finally the last, but not the least,  `ModuleLoader`. All that we have learned
    till now is managed by the Loader which is a static class with one method `LoadContainer`.
    This method is invoked by our MVC Web App `Startup` to initialize the dependency
    registration process. Let''s have a sneak peek at the codes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I have added comments over each step so that it will be easy for you to analyze
    the steps. The steps can be defined as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Get the `Web App Assembly Location`. As we are going to call this method from
    Web App and every other assembly is placed there, we need that location to find
    others.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find out, what other assemblies present in that particular location. However,
    we need to have DLLs of the layers we have in our app. For that reason, a pattern
    is necessary to recognize the assemblies of the layers. According to our layers,
    we only need to find all assembly names starting with PacktDIExamples and ending
    with `.dll`, because the Layer names are like `PacktDIExamples.Business.dll` and `PacktDIExamples.DataAccess.dll`.
    So, the pattern will be `PacktDIExamples.*.dll`. We will see the code sends this
    pattern to the `LoadContainer` in a moment. You can see the extracted modules
    shown in the Visual Studio tooltip while debugging, shown as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/118fd71a-eb45-4c62-a0c7-ab68c473a375.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: Create a container to hold all the assemblies using the `ContainerConfiguration`
    instance.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now `container.GetExports<IModule>()` is used to extract the `IModule` implementation
    from these assemblies.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `Initialize` method for each `IModule` implementations with a registrar
    instance as a dependency because the `Registrar` has the actual `Add` method for
    dependency registration with the `ServiceCollection`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I would advise you to put `try...catch` blocks in this method to handle the
    exceptions. Due to the space restrictions, I have not posted the `try...catch`
    block. I just want to show the core logic of a `ModuleLoader`. I have also removed
    the `usings`, which were taking up a lot of space. You can figure out the `usings`,
    anyway; if not, use Visual Studio. Hover on the red lines and then follow the
    steps which will include the required libraries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Executing the ModuleLoader.LoaderContainer() method from Web App
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the final step and the simplest one. See how we can call this Loader
    from the Web App inside the `Startup` as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As I mentioned, we need to send a pattern to fetch the Assembly names from `bin/debug/netcoreapp2.0`;
    otherwise, it will fetch all assemblies, which is unnecessary.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are sending the services to the `LoadContainer`. Now the previous
    code for registering the dependencies is commented, which got optimized by the `ModuleLoader.LoadContainer`
    call.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: What have we achieved with MEF?
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not yet realized the benefits of refactoring the layered architecture
    with MEF, have a close look at the following screenshot with explanations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Layers are separated
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Layers were tightly coupled as the UI was referencing the `Business Layer`
    and the `Data Access Layer`. Now after MEF, the UI is not tied to the `Data Access
    Layer` anymore. However, the UI has one `Business Layer` assembly reference as
    shown in the following screenshot. But that is not used anywhere inside the project.
    It is there because the assembly should be inside the `bin` folder so that the
    MEF Module is able to read it while initializing to export the `IModule` implementations.
    The following is a quick comparison of Project Dependencies before and after MEF:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a29dad10-90ff-43ba-b7a0-fd385789141e.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: If you try to remove the Business reference from the UI and run the app, it
    will throw an exception, as follows. And this is for obvious reasons. Unless you
    have the reference, MEF won't be able to extract the `IUsersService` implementation
    and register to the DI Container, simple!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the issue happens as soon as you hit the controller, as nothing has been
    registered to the `IServiceCollection`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3c845fb-67be-48ee-917b-ad6b5b5fc745.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: All classes inside layers are now internal
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of having `public` as the access specifiers for the classes, we can
    make them `internal` so that they are only accessible inside the assembly (this
    means only internally inside the Layer):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/ffb885fe-c0ca-4295-8741-62720a46541f.png)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: No concrete class instantiation inside the UI Layer
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before MEF implementation, we saw how, inside the `Edit` action method, we could
    directly reference the `Data Access Layer` and `Business Layer` classes. Now we
    won't be able to do this because the classes are not accessible anymore.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'That is proved from the compiler errors inside `UsersController` as shown in
    the following screenshot. Notice the tooltip preview, which indicates the unavailability
    of the UsersService. So, misusing classes of other layers is restricted even if
    you add the references:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bf50224-e455-4124-bc5d-b38f56c0f499.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: More layers can be added to the architecture
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When, in the future, you add more layers for optimisation or any other business-related
    requirements, that assembly can be simply referred to by the UI; then every dependency
    will automatically get registered to the IoC Container. Remember, you need have
    to a `ModuleInit` class implementing the interface `IModule` to automate the process.
    The application is totally flexible now, allowing new modules to be attached easily
    with no hassle.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern applications follow a layered architecture. Having a Dependency
    Injection technique to manage the dependencies required inside the layers is something
    we should be following. Having said that, we need to be careful with layer designs.
    That is because we applied DI, thinking that it would resolve issues of tight
    coupling with the dependencies of a class. However, we did not realize that the
    layers are getting connected with each other through concrete dependencies (such
    as the `User` instance return type).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '*Managed Extensibility Framework* provided us with a few easy steps to dynamically
    bind the dependencies from different layers, package them into one, and then register
    it to the container for further use by the controllers in the `UI Layer`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*托管扩展性框架*为我们提供了一些简单的步骤，用于动态绑定来自不同层的依赖项，将它们打包成一个，然后将其注册到容器中，以便 UI 层的控制器进一步使用。'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After learning DI Techniques, Patterns, Anti-Patterns and so on, we still needed
    some pointers to deal with practical scenarios where DI comes into play.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了 DI 技术、模式、反模式等内容之后，我们仍然需要一些指导来处理 DI 发挥作用的实际场景。
- en: We explored a few real-time application instances where DI can help eliminate
    coupling and introduce a cleaner dependency structure.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索了一些实时应用程序实例，其中 DI 可以帮助消除耦合并引入更清晰的依赖结构。
- en: Tightly coupled systems are often seen when a developer tries to be lazy and
    instantiates the required dependencies directly inside the class using the `new` operator.
    Keep in mind that new is glue. This not only instills a bad practice in you as
    a coder but also makes your code untestable. Unit testing becomes difficult. We
    learned the technique to deal with the problem of tight coupling by following
    DI techniques.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者试图偷懒，直接在类中使用 `new` 操作符实例化所需的依赖项时，经常会看到紧密耦合的系统。请记住，`new` 是粘合剂。这不仅在你作为编码者时养成了一种不良习惯，而且也使得你的代码不可测试。单元测试变得困难。我们通过遵循
    DI 技术学习了处理紧密耦合问题的技术。
- en: Then we realized that layering in an application is a common approach with applications.
    Having DI is definitely going to help us in the long run for layered systems.
    However, there might be loose ends in the layered approach which should be addressed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们意识到在应用程序中分层是一种常见的方法。拥有 DI 一定会在长期内帮助我们处理分层系统。然而，分层方法中可能存在一些悬而未决的问题，需要解决。
- en: MEF is the technique which we adopted to solve a couple of problems with layered
    architecture. By implementing MEF, the business or data layer implementations
    can be marked as internal so that they are not exposed to other layers. Also,
    layer architectural rules for the separation of concerns can remain intact with
    a DI container. Thus, the layers can breathe independently without any interference
    and decorate the architecture in such a way that the introduction of new modules
    into it becomes very smooth.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: MEF 是我们采用的技术，用于解决具有分层架构的一些问题。通过实现 MEF，业务或数据层实现可以被标记为内部，这样它们就不会暴露给其他层。此外，使用 DI
    容器，关注点分离的分层架构规则可以保持完整。因此，层可以独立呼吸，不受任何干扰，并以一种方式装饰架构，使得新模块的引入变得非常顺畅。
