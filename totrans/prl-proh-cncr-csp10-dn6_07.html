<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer031">
<h1 id="_idParaDest-83"><em class="italic"><a id="_idTextAnchor082"/>Chapter </em><em class="italic">5</em>: Asynchronous Programming with C#</h1>
<p>The .NET <strong class="bold">task asynchronous programming</strong> (<strong class="bold">TAP</strong>) model, which uses the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords, was<a id="_idIndexMarker226"/> introduced in .NET Framework 4.5. The C# language’s support for these keywords was released at the same time in C# 5. Now, a decade later, the TAP model is an integral part of most .NET developers’ toolsets. </p>
<p>This chapter will explain asynchronous programming in C#, explore how to use <strong class="source-inline">Task</strong> objects, and delve into best practices of using <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> for <strong class="bold">I/O-bound</strong> and <strong class="bold">CPU-bound</strong> scenarios with .NET.</p>
<p>In this chapter, you will learn about the following:</p>
<ul>
<li>More about asynchronous programming in .NET</li>
<li>Working with Task objects</li>
<li>Interop with synchronous code</li>
<li>Working with multiple background tasks</li>
<li>Asynchronous programming best practices</li>
</ul>
<p>By the end of this chapter, you will have a deeper understanding of asynchronous programming and should feel confident enough to add advanced async features to your team’s projects.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Technical requirements</h1>
<p>In this chapter, we will be using the .NET <strong class="bold">command-line interface </strong>(<strong class="bold">CLI</strong>) and Visual Studio Code to build and run the sample projects. To follow along with the examples, the following software is recommended:</p>
<ul>
<li>Visual Studio Code version 1.65 or later</li>
<li>.NET 6 or later</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 version 17.0 or later if you are using Windows 10 or 11, Visual Studio 2022 for Mac on macOS 10.13 or later, or JetBrains Rider will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05</a>.</p>
<p>Let’s get started by working our way through some examples that use the TAP model with <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>More about asynchronous programming in .NET</h1>
<p>There are <a id="_idIndexMarker227"/>two types of scenarios where async code is usually introduced:</p>
<ul>
<li><strong class="bold">I/O-bound operations</strong>: These involve resources fetched from the network or disk.</li>
<li><strong class="bold">CPU-bound operations</strong>: These are in-memory, CPU-intensive operations.</li>
</ul>
<p>In this section, we will create some real-world examples that use <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> for each type of operation. Whether you are waiting for an external process to complete or performing CPU-intensive operations within your application, you can leverage asynchronous code to improve your application’s performance. </p>
<p>Let’s start by looking at some examples of I/O-bound operations.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>I/O-bound operations</h2>
<p>When you <a id="_idIndexMarker228"/>are working with I/O-bound code that is <a id="_idIndexMarker229"/>constrained by file or network operations, your code should use <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> to wait for the operations to complete. </p>
<p>The .NET methods<a id="_idIndexMarker230"/> to perform network and file I/O are asynchronous, so the use of <strong class="source-inline">Task.Run</strong> will not be necessary:</p>
<ul>
<li><strong class="bold">Example 1</strong>: Let’s look at an example of an async method that reads the contents of a text file with the <strong class="source-inline">ReadToEndAsync</strong> method, splits the text where <strong class="source-inline">Environment.NewLine</strong> characters are found, and returns the data as a <strong class="source-inline">List&lt;string&gt;</strong> instance. Each line of text from the file is an item in the list:<p class="source-code">public async Task&lt;List&lt;string&gt;&gt; GetDataAsync</p><p class="source-code">    (string filePath)</p><p class="source-code">{</p><p class="source-code">    using var file = File.OpenText(filePath);</p><p class="source-code">    var data = await file.ReadToEndAsync();</p><p class="source-code">    return data.Split(new[] { Environment.NewLine },</p><p class="source-code">        StringSplitOptions.RemoveEmptyEntries)</p><p class="source-code">            .ToList();</p><p class="source-code">}</p></li>
<li><strong class="bold">Example 2</strong>: Another example of I/O-bound operations is a <strong class="bold">file download</strong>. We will take the concept from the previous example, but this time the file to be split and returned is hosted on a web server on the network. We will use the <strong class="source-inline">HttpClient</strong> class to download a file from the provided URL with the <strong class="source-inline">await</strong> keyword before splitting and returning the lines of text in a list:<p class="source-code">public async Task&lt;List&lt;string&gt;&gt; GetOnlineDataAsync</p><p class="source-code">    (string url)</p><p class="source-code">{</p><p class="source-code">    var httpClient = new HttpClient();</p><p class="source-code">    var data = await httpClient.GetStringAsync(url);</p><p class="source-code">    return data.Split(new[] { Environment.NewLine },</p><p class="source-code">        StringSplitOptions.RemoveEmptyEntries)</p><p class="source-code">            .ToList();</p><p class="source-code">}</p></li>
</ul>
<p>Those are some <a id="_idIndexMarker231"/>common I/O-bound operations, but what is a CPU-bound operation and how does it differ?</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>CPU-bound operations</h2>
<p>In this <a id="_idIndexMarker232"/>case, your application is not <a id="_idIndexMarker233"/>waiting for an external process to complete. The application itself is performing a CPU-intensive operation that takes time to complete, and you want the application to remain responsive until the operation has finished.</p>
<p>In this example, we<a id="_idIndexMarker234"/> have a method that accepts a <strong class="source-inline">List&lt;string&gt;</strong> instance where each item in the list contains an XML representation of this <strong class="source-inline">JournalEntry</strong> class:</p>
<pre class="source-code">[Serializable]</pre>
<pre class="source-code">public class JournalEntry</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    public string Title { get; set; }</pre>
<pre class="source-code">    public string Description { get; set; }</pre>
<pre class="source-code">    public DateTime EntryDate { get; set; }</pre>
<pre class="source-code">    public string EntryText { get; set; }</pre>
<pre class="source-code">}</pre>
<p>Let’s assume that <strong class="source-inline">EntryText</strong> can be extremely large because some users who write in the journal application will add dozens of pages of text to a single entry. Each entry is stored in a database as XML and the application that loads the entries has a <strong class="source-inline">DeserializeEntries</strong> method to deserialize each XML string and return the data as a <strong class="source-inline">List&lt;JournalEntry&gt;</strong> instance:</p>
<pre class="source-code">private List&lt;JournalEntry&gt; DeserializeEntries(List&lt;string&gt; </pre>
<pre class="source-code">    journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var deserializedEntries = new List&lt;JournalEntry&gt;();</pre>
<pre class="source-code">    var serializer = new XmlSerializer(typeof</pre>
<pre class="source-code">        (JournalEntry));</pre>
<pre class="source-code">    foreach (var xmlEntry in journalData)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        if (xmlEntry == null) continue;</pre>
<pre class="source-code">        using var reader = new StringReader(xmlEntry);</pre>
<pre class="source-code">        var entry = (JournalEntry)serializer.Deserialize</pre>
<pre class="source-code">            (reader)!;</pre>
<pre class="source-code">        if (entry == null) continue;</pre>
<pre class="source-code">        deserializedEntries.Add(entry);</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    return deserializedEntries;</pre>
<pre class="source-code">}</pre>
<p>After months<a id="_idIndexMarker235"/> of adding journal entries, users are complaining about the time it takes to load the existing entries. They would like to start creating a new entry while the data is loading. </p>
<p>Luckily, using <a id="_idIndexMarker236"/>asynchronous .NET code can keep an application’s user interface responsive while waiting for a long-running process to complete. The thread is free to perform other work until the non-blocking call is completed. By adding an async method named <strong class="source-inline">DeserializeJournalDataAsync</strong> that calls the existing method with an awaited <strong class="source-inline">Task.Run</strong> method, the client code can remain responsive while users create new journal entries:</p>
<pre class="source-code">public async Task&lt;List&lt;JournalEntry&gt;&gt; </pre>
<pre class="source-code">    DeserializeJournalDataAsync(List&lt;string&gt; journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    return await Task.Run(() =&gt; DeserializeEntries</pre>
<pre class="source-code">        (journalData));</pre>
<pre class="source-code">}</pre>
<p>If you’re <a id="_idIndexMarker237"/>working with serialized data in JSON format instead of XML, the synchronous and asynchronous methods of deserialization are very similar. This is because .NET provides both<a id="_idIndexMarker238"/> the <strong class="source-inline">Deserialize</strong> and <strong class="source-inline">DeserializeAsync</strong> methods in the <strong class="source-inline">System.Text.Json.JsonSerializer</strong> class. Here are both methods with their differences highlighted:</p>
<pre class="source-code">public <strong class="bold">List&lt;JournalEntry&gt;</strong> DeserialzeJsonEntries</pre>
<pre class="source-code">    (List&lt;string&gt; journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var deserializedEntries = new List&lt;JournalEntry&gt;();</pre>
<pre class="source-code">    foreach (var jsonEntry in journalData)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        if (string.IsNullOrWhiteSpace(jsonEntry)) continue;</pre>
<pre class="source-code">        <strong class="bold">deserializedEntries.Add(JsonSerializer.Deserialize</strong></pre>
<pre class="source-code"><strong class="bold">            &lt;JournalEntry&gt;(jsonEntry)!);</strong></pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    return deserializedEntries;</pre>
<pre class="source-code">}</pre>
<pre class="source-code">public <strong class="bold">async Task&lt;List&lt;JournalEntry&gt;&gt;</strong> Deserialize</pre>
<pre class="source-code">     JsonEntriesAsync(List&lt;string&gt; journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var deserializedEntries = new List&lt;JournalEntry&gt;();</pre>
<pre class="source-code">    foreach (var jsonEntry in journalData)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        if (string.IsNullOrWhiteSpace(jsonEntry)) continue;</pre>
<pre class="source-code">        <strong class="bold">using var stream = new MemoryStream(Encoding</strong></pre>
<pre class="source-code"><strong class="bold">            .Unicode.GetBytes(jsonEntry));</strong></pre>
<pre class="source-code"><strong class="bold">        deserializedEntries.Add((await JsonSerializer</strong></pre>
<pre class="source-code"><strong class="bold">            .DeserializeAsync&lt;JournalEntry&gt;(stream))!);</strong></pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    return deserializedEntries;</pre>
<pre class="source-code">}</pre>
<p>The <strong class="source-inline">Deserialize</strong> method accepts <strong class="source-inline">string</strong>, but <strong class="source-inline">DeserializeAsync</strong> does not. Instead, we must create a <strong class="source-inline">MemoryStream</strong> instance from the <strong class="source-inline">jsonEntry</strong> string to pass to <strong class="source-inline">DeserializeAsync</strong>. Other than that, only the return types of the methods differ.</p>
<p>Let’s wrap<a id="_idIndexMarker239"/> up this section by <a id="_idIndexMarker240"/>looking at one more method for handling JSON deserialization of a list of journal entries. In this example, the method that deserializes the data only processes a single JSON entry. A parent method named <strong class="source-inline">GetJournalEntriesAsync</strong> uses a LINQ <strong class="source-inline">Select</strong> operator to call <strong class="source-inline">DeserializeJsonEntryAsync</strong> for each string in the list and stores an <strong class="source-inline">IEnumerable&lt;Task&lt;JournalEntry&gt;&gt;</strong> instance in a <strong class="source-inline">getJournalTasks</strong> variable:</p>
<pre class="source-code">public async Task&lt;List&lt;JournalEntry&gt;&gt; </pre>
<pre class="source-code">    GetJournalEntriesAsync(List&lt;string&gt; journalData)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var journalTasks = journalData.Select(entry =&gt; </pre>
<pre class="source-code">        DeserializeJsonEntryAsync(entry));</pre>
<pre class="source-code">    return (<strong class="bold">await Task.WhenAll(journalTasks)</strong>).ToList();</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private async Task&lt;JournalEntry&gt; DeserializeJsonEntryAsync</pre>
<pre class="source-code">    (string jsonEntry)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    if (string.IsNullOrWhiteSpace(jsonEntry)) return new </pre>
<pre class="source-code">        JournalEntry();</pre>
<pre class="source-code">    using var stream = new MemoryStream</pre>
<pre class="source-code">        (Encoding.Unicode.GetBytes(jsonEntry));</pre>
<pre class="source-code">    return (await JsonSerializer.DeserializeAsync</pre>
<pre class="source-code">        &lt;JournalEntry&gt;(stream))!;</pre>
<pre class="source-code">}</pre>
<p>The highlighted <a id="_idIndexMarker241"/>code awaits all the <strong class="source-inline">Task</strong> objects in <strong class="source-inline">journalTasks</strong>, returning the results of every call as an array of <strong class="source-inline">JournalEntry</strong> objects. You can either declare <strong class="source-inline">GetJournalEntriesAsync</strong> with a return type of <strong class="source-inline">Task&lt;JournalEntry[]&gt;</strong> or use <strong class="source-inline">ToList</strong>, as we have in this sample, to return <strong class="source-inline">Task&lt;List&lt;JournalEntry&gt;&gt;</strong>. You can see how LINQ streamlines your code when it is necessary to iterate over a list of items and make an async call with each item.</p>
<p>You have seen some different ways to use async and await in your code for both I/O-bound and CPU-bound operations. </p>
<p>Next, we will discuss how <strong class="bold">nested async methods</strong> are chained and how to start the top level of that chain.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Nested async methods</h2>
<p>When it <a id="_idIndexMarker242"/>comes to using async methods, it is important to use <strong class="source-inline">await</strong> when you want to preserve the order of execution. It is also important to preserve that chain of awaited calls to the entry point for the current thread.</p>
<p>For example, if your <a id="_idIndexMarker243"/>application is a console application, the primary entry point is the <strong class="source-inline">Main</strong> method in <strong class="source-inline">Program.cs</strong>. If you cannot make this <strong class="source-inline">Main</strong> method <strong class="source-inline">async</strong>, then none of the method calls beneath <strong class="source-inline">Main</strong> are made with the <strong class="source-inline">await</strong> keyword. That is the reason why .NET now supports <strong class="source-inline">async</strong> <strong class="source-inline">Main</strong> methods. Now, when you create a new console application with .NET 6, it has an <strong class="source-inline">async</strong> <strong class="source-inline">Main</strong> method by default.</p>
<p>If the entry point for execution is an event handler, you should mark the event handler method as <strong class="source-inline">async</strong>. This is the only time you will see <strong class="source-inline">async</strong> methods with a <strong class="source-inline">void</strong> return type:</p>
<pre class="source-code">private async void saveButton_Click(object sender, </pre>
<pre class="source-code">    EventArgs e)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await SaveData();</pre>
<pre class="source-code">}</pre>
<p>Let’s look at <a id="_idIndexMarker244"/>an example of the right way to chain multiple nested async methods in a console application:</p>
<ol>
<li>Start by creating a new console application. Inside a folder named <strong class="source-inline">AsyncSamples</strong>, run the following command:<p class="source-code">dotnet new console –framework net6.0</p></li>
<li>When the process completes, open the new <strong class="source-inline">AsyncSamples.csproj</strong> in Visual Studio Code or your editor of choice.</li>
<li>Add a new class to the project named <strong class="source-inline">TaskSample</strong></li>
<li>Add the following code to the <strong class="source-inline">TaskSample</strong> class:<p class="source-code">public async Task DoThingsAsync()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Doing things in </p><p class="source-code">        {nameof(DoThingsAsync)}");</p><p class="source-code">    await DoFirstThingAsync();</p><p class="source-code">    await DoSecondThingAsync();</p><p class="source-code">    Console.WriteLine($"Did things in </p><p class="source-code">        {nameof(DoThingsAsync)}");</p><p class="source-code">}</p><p class="source-code">private async Task DoFirstThingAsync()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Doing something in </p><p class="source-code">        {nameof(DoFirstThingAsync)}");</p><p class="source-code">    await DoAnotherThingAsync();</p><p class="source-code">    Console.WriteLine($"Did something in </p><p class="source-code">        {nameof(DoFirstThingAsync)}");</p><p class="source-code">}</p><p class="source-code">private async Task DoSecondThingAsync()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Doing something in </p><p class="source-code">        {nameof(DoSecondThingAsync)}");</p><p class="source-code">    await Task.Delay(500);</p><p class="source-code">    Console.WriteLine($"Did something in </p><p class="source-code">        {nameof(DoSecondThingAsync)}");</p><p class="source-code">}</p><p class="source-code">private async Task DoAnotherThingAsync()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Doing something in </p><p class="source-code">        {nameof(DoAnotherThingAsync)}");</p><p class="source-code">    await Task.Delay(1500);</p><p class="source-code">    Console.WriteLine($"Did something in </p><p class="source-code">        {nameof(DoAnotherThingAsync)}");</p><p class="source-code">}</p></li>
<li>Now <a id="_idIndexMarker245"/>open <strong class="source-inline">Program.cs</strong> and<a id="_idIndexMarker246"/> add some code to call <strong class="source-inline">DoThingsAsync</strong>:<p class="source-code">using AsyncSamples;</p><p class="source-code">Console.WriteLine("Start processing"…");</p><p class="source-code">var taskSample = new TaskSample();</p><p class="source-code">await taskSample.DoThingsAsync();</p><p class="source-code">Console.WriteLi"e("Done processing"..");</p></li>
</ol>
<p>Let’s illustrate the order and hierarchy of the methods being called by our project. The <strong class="source-inline">Main</strong> method calls <strong class="source-inline">DoThingsAsync</strong>, which in turn calls <strong class="source-inline">DoFirstThingAsync</strong> and <strong class="source-inline">DoSecondThingAsync</strong>. Finally, within <strong class="source-inline">DoFirstThingAsync</strong>, <strong class="source-inline">DoAnotherThingAsync</strong> is called. When each of these <strong class="source-inline">async</strong> methods is called with the <strong class="source-inline">await</strong> operator, the order of operations is predictable:</p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="Figure 5.1: The order of operations for awaited methods " height="472" src="image/Figure_5.1_B18552.jpg" width="953"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: The order of operations for awaited methods</p>
<ol>
<li value="6">Run <a id="_idIndexMarker247"/>the program and examine the<a id="_idIndexMarker248"/> order of the console output. Everything should be executing in the expected order:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="Figure 5.2: Examining the output of the AsyncSamples console application " height="404" src="image/Figure_5.2_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: Examining the output of the AsyncSamples console application</p>
<ol>
<li value="7">Next, we <a id="_idIndexMarker249"/>will add two additional <a id="_idIndexMarker250"/>methods to the <strong class="source-inline">TaskSample</strong> class:<p class="source-code">public async Task DoingThingsWrongAsync()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Doing things in </p><p class="source-code">        {nameof(DoingThingsWrongAsync)}");</p><p class="source-code">    DoFirstThingAsync();</p><p class="source-code">    await DoSecondThingAsync();</p><p class="source-code">    Console.WriteLine($"Did things in </p><p class="source-code">        {nameof(DoingThingsWrongAsync)}");</p><p class="source-code">}</p><p class="source-code">public async Task DoBlockingThingsAsync()</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Doing things in </p><p class="source-code">        {nameof(DoBlockingThingsAsync)}");</p><p class="source-code">    DoFirstThingAsync().Wait();</p><p class="source-code">    await DoSecondThingAsync();</p><p class="source-code">    Console.WriteLine($"Did things in </p><p class="source-code">        {nameof(DoBlockingThingsAsync)}");</p><p class="source-code">}</p></li>
</ol>
<p>The <strong class="source-inline">DoingThingsWrongAsync</strong> method has removed the <strong class="source-inline">await</strong> from the call to <strong class="source-inline">DoFirstThingAsync</strong>. So, the execution of <strong class="source-inline">DoSecondThingAsync</strong> will begin before <strong class="source-inline">DoFirstThingAsync</strong> has been completed. That might be OK if none of the subsequent code relies on the processing that happens within <strong class="source-inline">DoFirstThingAsync</strong>. However, any unhandled exceptions inside a method that is not<a id="_idIndexMarker251"/> awaited will not automatically bubble up to the <strong class="source-inline">calling</strong> method. The <strong class="source-inline">Task</strong> instance for the call will have a <strong class="source-inline">Status</strong> value of <strong class="source-inline">Faulted</strong>, the <strong class="source-inline">IsFaulted</strong> property will be <strong class="source-inline">true</strong>, and the <strong class="source-inline">Exception</strong> property will contain the unhandled exception information.</p>
<p>In the<a id="_idIndexMarker252"/> preceding case, any unhandled exceptions in <strong class="source-inline">DoFirstThingAsync</strong> will go undetected. If you have a case where you are not awaiting a <strong class="source-inline">Task</strong> instance, be sure to monitor the status of the <strong class="source-inline">Task</strong> instance in case of exceptions. This is one of the reasons why you should never have an <strong class="source-inline">async void</strong> method. It does not return a <strong class="source-inline">Task</strong> instance to be awaited.</p>
<p>The <strong class="source-inline">DoBlockingThings</strong> method will maintain the correct order of operations, but by calling <strong class="source-inline">DoFirstThingAsync().Wait()</strong> instead of awaiting the call, the thread executing <strong class="source-inline">DoBlockingThings</strong> will be blocked. It will wait for the call to <strong class="source-inline">DoFirstThingAsync</strong> to complete instead of being free to pick <a id="_idIndexMarker253"/>up other work until the long-running async method completes. Using blocking calls such as <strong class="source-inline">Wait()</strong> or <strong class="source-inline">Result</strong> can quickly deplete the available threads in <strong class="source-inline">ThreadPool</strong>.</p>
<ol>
<li value="8">Update <strong class="source-inline">Program.cs</strong> to call all three of the public <strong class="source-inline">TaskSample</strong> methods:<p class="source-code">using AsyncSamples;</p><p class="source-code">Console.WriteLine("Start processing...");</p><p class="source-code">var taskSample = new TaskSample();</p><p class="source-code">await taskSample.DoThingsAsync();</p><p class="source-code">Console.WriteLine("Continue processing...");</p><p class="source-code">await taskSample.DoingThingsWrongAsync();</p><p class="source-code">Console.WriteLine("Continue processing...");</p><p class="source-code">await taskSample.DoBlockingThingsAsync();</p><p class="source-code">Console.WriteLine("Done processing...");</p></li>
<li>Now <a id="_idIndexMarker254"/>run the program and examine the console output to see how it is impacted by omitting <strong class="source-inline">await</strong> inside <strong class="source-inline">DoingThingsWrongAsync</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 5.3: Console output when calling all the TaskSample methods " height="685" src="image/Figure_5.3_B18552.jpg" width="1262"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: Console output when calling all the TaskSample methods</p>
<p>The <a id="_idIndexMarker255"/>output <a id="_idIndexMarker256"/>may differ a little each time, depending on how the <strong class="source-inline">ThreadPool</strong> threads are allocated. In this case, the second call to <strong class="source-inline">DoFirstThingAsync</strong> remains incomplete until the third call to that same method starts. Even though <strong class="source-inline">Program.cs</strong> awaits its call to <strong class="source-inline">DoingThingsWrongAsync</strong>, the code inside of that method was still executing after the next call to <strong class="source-inline">DoBlockingThingsAsync</strong> was invoked.</p>
<p>Things can get very unpredictable when async tasks are not awaited. You should always await a task unless you have a good reason not to do so. Next, let’s explore some properties and methods available in the <strong class="source-inline">Task</strong> class.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Working with Task objects</h1>
<p>Working<a id="_idIndexMarker257"/> directly with <strong class="source-inline">Task</strong> objects can be extremely useful when introducing threading to existing projects. As we saw in the previous section, it is important to update the entire call stack when introducing <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>. On a large code base, those changes could be extensive and would require quite a bit of regression testing.</p>
<p>You can<a id="_idIndexMarker258"/> instead use <strong class="source-inline">Task</strong> and <strong class="source-inline">Task&lt;TResult&gt;</strong> to wrap the existing methods that you want to run asynchronously. Both <strong class="source-inline">Task</strong> types represent the asynchronous work being done by a method or action. You use <strong class="source-inline">Task</strong> when a method would have otherwise returned void. Use <strong class="source-inline">Task&lt;TResult&gt;</strong> with methods that have a non-void return type. </p>
<p>Here are examples of two synchronous method signatures and their async equivalents:</p>
<pre class="source-code">public interface IAsyncExamples</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    void ProcessOrders(List&lt;Order&gt; orders);</pre>
<pre class="source-code">    Task ProcessOrdersAsync(List&lt;Order&gt; orders);</pre>
<pre class="source-code">    List&lt;Order&gt; GetOrders(int customerId);</pre>
<pre class="source-code">    Task&lt;List&lt;Order&gt;&gt; GetOrdersAsync(int customerId);</pre>
<pre class="source-code">}</pre>
<p>We have seen some examples of using <strong class="source-inline">Task</strong> objects in this chapter. Now it is time to explore additional properties, methods, and uses of these two types.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Exploring Task methods</h2>
<p>To start, we will <a id="_idIndexMarker259"/>discover some commonly used <strong class="source-inline">Task</strong> methods in practical examples. Consider the ProcessOrders method that accepts a list of orders to be processed and submitted. The four <strong class="source-inline">Task</strong> methods used are as follows:</p>
<ul>
<li><strong class="source-inline">Task.Run</strong>: Runs a <a id="_idIndexMarker260"/>method on a thread on the thread pool</li>
<li><strong class="source-inline">Task.Factory.StartNew</strong>: Runs <a id="_idIndexMarker261"/>a method on a thread on the thread pool, with <strong class="source-inline">TaskCreationOptions</strong> provided</li>
<li><strong class="source-inline">processOrdersTask.ContinueWith</strong>: When the <strong class="source-inline">processOrdersTask</strong> completes, it <a id="_idIndexMarker262"/>will execute the method provided on the same thread pool thread.</li>
<li><strong class="source-inline">Task.WaitAll</strong>: This<a id="_idIndexMarker263"/> method will block the current thread and wait for all tasks in the array.</li>
</ul>
<p>These <a id="_idIndexMarker264"/>methods have been highlighted in the following code:</p>
<pre class="source-code">public void ProcessOrders(List&lt;Order&gt; orders, int </pre>
<pre class="source-code">    customerId)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Task&lt;List&lt;Order&gt;&gt; processOrdersTask = Task.<strong class="bold">Run</strong>(() =&gt; </pre>
<pre class="source-code">        PrepareOrders(orders));</pre>
<pre class="source-code">    Task labelTask = Task.Factory.<strong class="bold">StartNew</strong>(() =&gt; </pre>
<pre class="source-code">        CreateLabels(orders), TaskCreationOptions</pre>
<pre class="source-code">            .LongRunning);</pre>
<pre class="source-code">    Task sendTask = processOrdersTask.<strong class="bold">ContinueWith</strong>(task =&gt; </pre>
<pre class="source-code">        SendOrders(task.Result));</pre>
<pre class="source-code">    Task.<strong class="bold">WaitAll</strong>(new[] { labelTask, sendTask });</pre>
<pre class="source-code">    SendConfirmation(customerId);</pre>
<pre class="source-code">}</pre>
<p>This is what is happening on each line of the preceding example:</p>
<ol>
<li value="1"><strong class="source-inline">Task.Run</strong> will create a new background thread and queue it on <strong class="source-inline">ThreadPool</strong></li>
<li><strong class="source-inline">Task.Factory.StartNew</strong> will also create a new background thread and queue it on <strong class="source-inline">ThreadPool</strong>. In addition, we are providing <strong class="source-inline">TaskCreattionOptions.LongRunning</strong> as a parameter of <strong class="source-inline">StartNew</strong> to indicate that creating additional threads is warranted because this task may take a while to complete. This will prevent delays for other tasks queued on <strong class="source-inline">ThreadPool</strong>.</li>
<li><strong class="source-inline">ContinueWith</strong> will queue <strong class="source-inline">SendOrders</strong> on a <strong class="source-inline">ThreadPool</strong> thread, but the thread will not start until <strong class="source-inline">processOrdersTask</strong> has been completed.</li>
<li><strong class="source-inline">Task.WaitAll</strong> is the synchronous equivalent of the <strong class="source-inline">async</strong> method, <strong class="source-inline">Task.WhenAll</strong>. It will block the current thread until <strong class="source-inline">labelTask</strong> and <strong class="source-inline">sendTask</strong> are complete.</li>
<li>Finally, <strong class="source-inline">SendConfirmation</strong> is called to notify the customer that their orders have been processed and sent.</li>
</ol>
<p>Using<a id="_idIndexMarker265"/> tasks in this way can achieve the same result as an <strong class="source-inline">async</strong> method that awaits tasks to achieve parallel processing. The main difference is that the current thread will be blocked at <em class="italic">step 4</em> when <strong class="source-inline">WaitAll</strong> is called.</p>
<p>Another useful method we will explore next is <strong class="source-inline">RunSynchronously</strong>. This starts a task but executes it synchronously on the current thread. The asynchronous equivalent is to call <strong class="source-inline">Start</strong> on a task. </p>
<p>In this example, the <strong class="source-inline">ProcessData</strong> method accepts a parameter indicating whether the data must be processed on the UI thread. It is possible that some data processing requires interacting with the UI to present the user with some options or other feedback:</p>
<pre class="source-code">public void ProcessData(object data, bool uiRequired)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Task processTask = new(() =&gt; DoDataProcessing(data));</pre>
<pre class="source-code">    if (uiRequired)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        // Run on current thread (UI thread assumed for </pre>
<pre class="source-code">            example)</pre>
<pre class="source-code">        processTask.RunSynchronously();</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    else</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        // Run on ThreadPool thread in background</pre>
<pre class="source-code">        processTask.Start();</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>Next, let’s explore <a id="_idIndexMarker266"/>some of the properties of the <strong class="source-inline">Task</strong> and <strong class="source-inline">Task&lt;TResult&gt;</strong> classes.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Exploring Task properties</h2>
<p>In this section, we<a id="_idIndexMarker267"/> will review the properties available on a <strong class="source-inline">Task</strong> object. Most of the properties are related to the status of a task, so we will start with the <strong class="source-inline">Status</strong> property. The <strong class="source-inline">Status</strong> property returns <strong class="source-inline">TaskStatus</strong>, which is an enumeration with eight possible values:</p>
<ul>
<li><strong class="source-inline">Created (0)</strong>: The task has been created and initialized but has not been scheduled on <strong class="source-inline">ThreadPool</strong>.</li>
<li><strong class="source-inline">WaitingForActivation (1)</strong>: The task is waiting to be scheduled by .NET</li>
<li><strong class="source-inline">WaitingToRun (2)</strong>: The task has been scheduled but has not started executing yet</li>
<li><strong class="source-inline">Running (3)</strong>: The task is currently running.</li>
<li><strong class="source-inline">WaitingForChildrenToComplete (4)</strong>: The task has been completed but there are attached child tasks that are still running or waiting to run</li>
<li><strong class="source-inline">RanToCompletion (5)</strong>: The task successfully ran to completion</li>
<li><strong class="source-inline">Canceled (6)</strong>: The task was canceled and acknowledged the cancellation</li>
<li><strong class="source-inline">Faulted (7)</strong>: An unhandled exception was encountered while executing the task</li>
</ul>
<p>The following properties of <strong class="source-inline">Task</strong> and <strong class="source-inline">Task&lt;TResult&gt;</strong> are shortcuts to check statuses:</p>
<ul>
<li><strong class="source-inline">IsCanceled</strong>: Returns <strong class="source-inline">true</strong> if the task’s <strong class="source-inline">Status</strong> is <strong class="source-inline">Canceled</strong></li>
<li><strong class="source-inline">IsCompleted</strong>: Returns <strong class="source-inline">true</strong> if the task’s <strong class="source-inline">Status</strong> is <strong class="source-inline">RanToCompletion</strong>, <strong class="source-inline">Canceled</strong>, or <strong class="source-inline">Faulted</strong></li>
<li><strong class="source-inline">IsCompletedSuccessfully</strong>: Returns <strong class="source-inline">true</strong> if the task’s <strong class="source-inline">Status</strong> is <strong class="source-inline">RanToCompletion</strong></li>
<li><strong class="source-inline">IsFaulted</strong>: Returns <strong class="source-inline">true</strong> if the task’s <strong class="source-inline">Status</strong> is <strong class="source-inline">Faulted</strong></li>
</ul>
<p>Using<a id="_idIndexMarker268"/> these properties can streamline status checks in your code. The remaining instance properties of the <strong class="source-inline">Task</strong> object follow:</p>
<ul>
<li><strong class="source-inline">AsyncState</strong>: Returns the state that was provided when creating the task. If no state was provided, this property returns <strong class="source-inline">null</strong></li>
<li><strong class="source-inline">CreationOptions</strong>: Returns the <strong class="source-inline">CreationOptions</strong> values that were provided when creating the task. If no options were provided, it defaults to <strong class="source-inline">TaskCreationOptions.None</strong>.</li>
<li><strong class="source-inline">Exception</strong>: Returns an <strong class="source-inline">AggregateException</strong> instance containing unhandled exceptions encountered while the task was running. <strong class="source-inline">Wait</strong> or <strong class="source-inline">WaitAll</strong> should be called in a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block that handles the <strong class="source-inline">AggregateException</strong> type.</li>
<li><strong class="source-inline">Id</strong>: A system-assigned identifier for the task</li>
</ul>
<p>Let’s take a quick look at how to correctly catch an <strong class="source-inline">AggregateException</strong> instance and inspect the <strong class="source-inline">Exception</strong> property of the faulted task:</p>
<pre class="source-code">Task ordersTask = Task.Run(() =&gt; ProcessOrders(orders, </pre>
<pre class="source-code">    123));</pre>
<pre class="source-code">try</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    ordersTask.Wait();</pre>
<pre class="source-code">    Console.WriteLine($"ordersTask Status: </pre>
<pre class="source-code">        {ordersTask.Status}");</pre>
<pre class="source-code">} </pre>
<pre class="source-code">catch (AggregateException)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine($"Exception in ordersTask! Error </pre>
<pre class="source-code">        message: {ordersTask.Exception.Message}");</pre>
<pre class="source-code">}   </pre>
<p>This <a id="_idIndexMarker269"/>code will write the status of the task to the console after completion. If an unhandled exception is encountered, the error message will be written to the console in the <strong class="source-inline">catch</strong> block.</p>
<p>Now that you’re more familiar with the members of <strong class="source-inline">Task</strong> and <strong class="source-inline">Task&lt;TResult&gt;</strong>, let’s discuss some use cases for calling synchronous code from async code and vice versa.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Interop with synchronous code</h1>
<p>When working with<a id="_idIndexMarker270"/> existing projects and introducing async code to the system, there will be points where synchronous and asynchronous code intersect. We have already seen some examples of how to handle this interop in this chapter. In this section, we will focus on that interop in both directions: sync calling async and async calling sync. </p>
<p>We will create a sample project with classes containing synchronous methods representing legacy code and another set of classes with modern <strong class="source-inline">async</strong> methods.</p>
<p>Let’s start by discussing how to consume <strong class="source-inline">async</strong> methods in your legacy synchronous code.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Executing async from synchronous methods</h2>
<p>In this example, we will be<a id="_idIndexMarker271"/> working with a .NET console application that gets a patient and their list of medications. The application will call a synchronous <strong class="source-inline">GetPatientAndMedications</strong> method that in turn calls an async <strong class="source-inline">GetPatientInfoAsync</strong> method:</p>
<ol>
<li value="1">Start by <a id="_idIndexMarker272"/>creating a new .NET console application</li>
<li>Add <strong class="source-inline">Patient</strong>, <strong class="source-inline">Provider</strong>, and <strong class="source-inline">Medication</strong> classes to a <strong class="source-inline">Models</strong> folder and <strong class="source-inline">HealthcareService</strong> and <strong class="source-inline">MedicationLoader</strong> classes to a <strong class="source-inline">SyncToAsync</strong> folder:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer030">
<img alt="Figure 5.4: The initial project structure for calling async from sync code " height="572" src="image/Figure_5.4_B18552.jpg" width="694"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4: The initial project structure for calling async from sync code</p>
<ol>
<li value="3">Add the necessary properties for the model classes:<p class="source-code">public class Medication</p><p class="source-code">{</p><p class="source-code">    public int Id { get; set; }</p><p class="source-code">    public string? Name { get; set; }</p><p class="source-code">}</p><p class="source-code">public class Provider</p><p class="source-code">{</p><p class="source-code">    public int Id { get; set; }</p><p class="source-code">    public string? Name { get; set; }</p><p class="source-code">}</p><p class="source-code">public class Patient</p><p class="source-code">{</p><p class="source-code">    public int Id { get; set; }</p><p class="source-code">    public string? Name { get; set; }</p><p class="source-code">    public List&lt;Medication&gt;? Medications { get; set; }</p><p class="source-code">    public Provider? PrimaryCareProvider { get; set; }</p><p class="source-code">}</p></li>
<li>Create<a id="_idIndexMarker273"/> the <strong class="source-inline">GetPatientInfoAsync</strong> method in the <strong class="source-inline">HealthcareService</strong> class. This method creates a patient with a provider and two medications after injecting a 2-second async delay:<p class="source-code">public async Task&lt;Patient&gt; GetPatientInfoAsync</p><p class="source-code">    (int patientId)</p><p class="source-code">{</p><p class="source-code">    await Task.Delay(2000);</p><p class="source-code">    Patient patient = new()</p><p class="source-code">    {</p><p class="source-code">        Id = patientId,</p><p class="source-code">        Name = "Smith, Terry",</p><p class="source-code">        PrimaryCareProvider = new Provider</p><p class="source-code">        {</p><p class="source-code">            Id = 999,</p><p class="source-code">            Name = "Dr. Amy Ng"</p><p class="source-code">        },</p><p class="source-code">        Medications = new List&lt;Medication&gt;</p><p class="source-code">        {</p><p class="source-code">            new Medication { Id = 1, Name = </p><p class="source-code">                "acetaminophen" },</p><p class="source-code">            new Medication { Id = 2, Name = </p><p class="source-code">                "hydrocortisone cream" }</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    return patient;</p><p class="source-code">}</p></li>
<li>Add the<a id="_idIndexMarker274"/> implementation for the <strong class="source-inline">MedicationLoader</strong> service:<p class="source-code">public class MedicationLoader</p><p class="source-code">{</p><p class="source-code">    private HealthcareService _healthcareService;</p><p class="source-code">    public MedicationLoader()</p><p class="source-code">    {</p><p class="source-code">        _healthcareService = new HealthcareService();</p><p class="source-code">    }</p><p class="source-code">    public Patient? GetPatientAndMedications(int </p><p class="source-code">        patientId)</p><p class="source-code">    {</p><p class="source-code">        Patient? patient = null;</p><p class="source-code">        try</p><p class="source-code">        {</p><p class="source-code">            <strong class="bold">patient = _healthcareService</strong></p><p class="source-code"><strong class="bold">               .GetPatientInfoAsync(patientId).Result;</strong></p><p class="source-code">        }</p><p class="source-code">        catch (AggregateException ae)</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine($"Error loading patient. </p><p class="source-code">                Message: {ae.Flatten().Message}");</p><p class="source-code">        }</p><p class="source-code">        if (patient != null)</p><p class="source-code">        {</p><p class="source-code">            patient = ProcessPatientInfo(patient);</p><p class="source-code">            return patient;</p><p class="source-code">        }</p><p class="source-code">        else</p><p class="source-code">        {</p><p class="source-code">            return null;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    private Patient ProcessPatientInfo(Patient </p><p class="source-code">        patient)</p><p class="source-code">    {</p><p class="source-code">        // Add additional processing here.</p><p class="source-code">        return patient;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>The <strong class="source-inline">GetPatientAndMedications</strong> method calls <strong class="source-inline">GetPatientInfoAsync</strong> and uses the <strong class="source-inline">Result</strong> property to synchronously wait for the <strong class="source-inline">async</strong> method to complete and return the value. Using <strong class="source-inline">Result</strong> is the same <a id="_idIndexMarker275"/>as using the <strong class="source-inline">Wait()</strong> method on an <strong class="source-inline">async</strong> method that returns no value. The current thread is blocked until the method completes.</p>
<p>We have wrapped the call in a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block that handles an <strong class="source-inline">AggregateException</strong> instance. If the call was successful, and the <strong class="source-inline">patient</strong> variable is not <strong class="source-inline">null</strong>, <strong class="source-inline">ProcessPatientInfo</strong> is called before returning the patient data to the caller.</p>
<ol>
<li value="6">Add this code to <strong class="source-inline">Program.cs</strong> to call the synchronous method:<p class="source-code">using SyncAndAsyncSamples.Models;</p><p class="source-code">using SyncAndAsyncSamples.SyncToAsync;</p><p class="source-code">Console.WriteLine("Hello, sync to async world!");</p><p class="source-code">var medLoader = new MedicationLoader();</p><p class="source-code">Patient? patient = medLoader.GetPatientAndMedications</p><p class="source-code">    (123);</p><p class="source-code">Console.WriteLine($"Loaded patient: {patient.Name} </p><p class="source-code">    with {patient.Medications.Count} medications.");</p></li>
<li>Run the program. You should see this output in the window:</li>
</ol>
<p class="source-code">Hello, sync to async world!</p>
<p class="source-code">Loaded patient: Smith, Terry with 2 medications.</p>
<p>Next, let’s try to load the same data but with an <strong class="source-inline">async</strong> method calling some legacy synchronous code.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Executing synchronous code as async</h2>
<p>In this <a id="_idIndexMarker276"/>example, we will mirror the previous example. There will be a <strong class="source-inline">PatientLoader</strong> instance with async methods calling a <strong class="source-inline">PatientService</strong> instance with a synchronous method:</p>
<ol>
<li value="1">Add a <strong class="source-inline">PatientService</strong> class to a new <strong class="source-inline">AsyncToSync</strong> folder in your project.</li>
<li>Create a <strong class="source-inline">GetPatientInfo</strong> method with a similar implementation to the <strong class="source-inline">GetPatientInfoAsync</strong> method in the previous example:<p class="source-code">public Patient GetPatientInfo(int patientId)</p><p class="source-code">{</p><p class="source-code">    <strong class="bold">Thread.Sleep(2000);</strong></p><p class="source-code">    Patient patient = new()</p><p class="source-code">    {</p><p class="source-code">        Id = patientId,</p><p class="source-code">        Name = "Smith, Terry",</p><p class="source-code">        PrimaryCareProvider = new Provider</p><p class="source-code">        {</p><p class="source-code">            Id = 999,</p><p class="source-code">            Name = "Dr. Amy Ng"</p><p class="source-code">        },</p><p class="source-code">        Medications = new List&lt;Medication&gt;</p><p class="source-code">        {</p><p class="source-code">            new Medication { Id = 1, Name = </p><p class="source-code">                "acetaminophen" },</p><p class="source-code">            new Medication { Id = 2, Name = </p><p class="source-code">                "hydrocortisone cream" }</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    return patient;</p><p class="source-code">}</p></li>
</ol>
<p>The differences here are that the method is not <strong class="source-inline">async</strong>, it returns a <strong class="source-inline">Patient</strong> instance instead of a <strong class="source-inline">Task&lt;Patient&gt;</strong> instance, and we’re injecting a delay with <strong class="source-inline">Thread.Sleep</strong> instead of <strong class="source-inline">Task.Delay</strong>.</p>
<ol>
<li value="3">Create <a id="_idIndexMarker277"/>the <strong class="source-inline">PatientLoader</strong> class in the <strong class="source-inline">AsyncToSync</strong> folder, and start its implementation by creating a new instance of <strong class="source-inline">PatientService</strong>:<p class="source-code">private PatientService _patientService = new </p><p class="source-code">    PatientService();</p></li>
<li>Now create the async version of <strong class="source-inline">ProcessPatientInfo</strong> from the previous example:<p class="source-code">private async Task&lt;Patient&gt; ProcessPatientInfoAsync</p><p class="source-code">    (Patient patient)</p><p class="source-code">{</p><p class="source-code">    await Task.Delay(100);</p><p class="source-code">    // Add additional processing here.</p><p class="source-code">    return patient;</p><p class="source-code">}</p></li>
<li>Now create the <strong class="source-inline">GetPatientAndMedsAsync</strong> method:<p class="source-code">public async Task&lt;Patient?&gt; GetPatientAndMedsAsync</p><p class="source-code">    (int patientId)</p><p class="source-code">{</p><p class="source-code">    Patient? patient = null;</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        <strong class="bold">patient = await Task.Run(() =&gt; </strong></p><p class="source-code"><strong class="bold">           _patientService.GetPatientInfo(patientId));</strong></p><p class="source-code">    }</p><p class="source-code">    catch (<strong class="bold">Exception e</strong>)</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine($"Error loading patient. </p><p class="source-code">            Message: {e.Message}");</p><p class="source-code">    }</p><p class="source-code">    if (patient != null)</p><p class="source-code">    {</p><p class="source-code">        <strong class="bold">patient = await ProcessPatientInfoAsync</strong></p><p class="source-code"><strong class="bold">            (patient);</strong></p><p class="source-code">        return patient;</p><p class="source-code">    }</p><p class="source-code">    else</p><p class="source-code">    {</p><p class="source-code">        return null;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>The <a id="_idIndexMarker278"/>primary differences from the last example are highlighted. The <strong class="source-inline">synchronous</strong> class to <strong class="source-inline">GetPatientInfo</strong> is wrapped in a call to <strong class="source-inline">await Task.Run</strong>, which will wait for the call without blocking the current thread from performing other work.</p>
<p>We are now using <strong class="source-inline">Exception</strong> instead of <strong class="source-inline">AggregateException</strong> in the <strong class="source-inline">catch</strong> block. You should always use <strong class="source-inline">AggregateException</strong> with blocking <strong class="source-inline">Wait</strong> and <strong class="source-inline">Result</strong> calls and use <strong class="source-inline">Exception</strong> with <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>.</p>
<p>Finally, the async call to <strong class="source-inline">ProcessPatientInfoAsync</strong> is awaited if the <strong class="source-inline">patient</strong> variable is not <strong class="source-inline">null</strong>.</p>
<ol>
<li value="6">Next <a id="_idIndexMarker279"/>update <strong class="source-inline">Program.cs</strong> to call the new <strong class="source-inline">PatientLoader</strong> code:<p class="source-code">using SyncAndAsyncSamples.AsyncToSync;</p><p class="source-code">using SyncAndAsyncSamples.Models;</p><p class="source-code">Console.WriteLine("Hello, async to sync world!");</p><p class="source-code">var loader = new PatientLoader();</p><p class="source-code">Patient? patient = await loader.GetPatientAndMedsAsync</p><p class="source-code">    (123);</p><p class="source-code">Console.WriteLine($"Loaded patient: {patient.Name} </p><p class="source-code">    with {patient.Medications.Count} medications.");</p></li>
<li>Run the program, and the output should look similar to the previous example:</li>
</ol>
<p class="source-code">Hello, async to sync world!</p>
<p class="source-code">Loaded patient: Smith, Terry with 2 medications.</p>
<p>By now, you should have a solid understanding of how to interop between asynchronous and synchronous code. Let’s move forward and create an example of loading data from several <strong class="source-inline">async</strong> methods in parallel.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Working with multiple background tasks</h1>
<p>In this section, we will<a id="_idIndexMarker280"/> see code samples for loading data from multiple sources in parallel, not waiting until the method is ready to return the data to the caller. The technique is slightly different for synchronous and asynchronous code, but the general idea is the same.</p>
<p>First, review this method that calls three async methods and uses <strong class="source-inline">Task.WhenAll</strong> to wait before returning the patient data:</p>
<pre class="source-code">public async Task&lt;Patient&gt; LoadPatientAsync(int patientId)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var taskList = new List&lt;Task&gt;</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        LoadPatientInfoAsync(patientId),</pre>
<pre class="source-code">        LoadProviderAsync(patientId),</pre>
<pre class="source-code">        LoadMedicationsAsync(patientId)</pre>
<pre class="source-code">    };</pre>
<pre class="source-code">    <strong class="bold">await Task.WhenAll(taskList.ToArray());</strong></pre>
<pre class="source-code">    _patient.Medications = _medications;</pre>
<pre class="source-code">    _patient.PrimaryCareProvider = _provider;</pre>
<pre class="source-code">    return _patient;</pre>
<pre class="source-code">}</pre>
<p>Now, review this synchronous version of the method, which uses <strong class="source-inline">Task.WaitAll</strong>:</p>
<pre class="source-code">public Patient LoadPatient(int patientId)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var taskList = new List&lt;Task&gt;</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        LoadPatientInfoAsync(patientId),</pre>
<pre class="source-code">        LoadProviderAsync(patientId),</pre>
<pre class="source-code">        LoadMedicationsAsync(patientId)</pre>
<pre class="source-code">    };</pre>
<pre class="source-code">    <strong class="bold">Task.WaitAll(taskList.ToArray());</strong></pre>
<pre class="source-code">    _patient.Medications = _medications;</pre>
<pre class="source-code">    _patient.PrimaryCareProvider = _provider;</pre>
<pre class="source-code">    return _patient;</pre>
<pre class="source-code">}</pre>
<p>Even this <a id="_idIndexMarker281"/>version of the code, which uses a blocking <strong class="source-inline">WaitAll</strong> call, will perform faster than making separate synchronous calls to the three methods.</p>
<p>The complete implementation of this <strong class="source-inline">ParallelPatientLoader</strong> class is available in the GitHub repository for this chapter. Let’s finish up the chapter by listing some best practices for using <strong class="source-inline">async</strong>, <strong class="source-inline">await</strong>, and <strong class="source-inline">Task</strong> objects.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Asynchronous programming best practices</h1>
<p>When<a id="_idIndexMarker282"/> working with async code, there are many best practices of which you should be aware. In this section, we will list the most important ones to remember in your day-to-day development. <strong class="bold">David Fowler</strong>, who is a veteran member of the ASP.NET team at Microsoft and a .NET expert, maintains an open source list of many other best practices. I recommend bookmarking this page for later reference while working with your own projects: <a href="https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming">https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming</a>. </p>
<p>These are my top recommendations (in no particular order) to follow when working with async code:</p>
<ol>
<li value="1">Always prefer <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> over synchronous methods and blocking calls such as <strong class="source-inline">Wait()</strong> and <strong class="source-inline">Result</strong>. If you are creating a new project, you should build with async in mind from the start.</li>
<li>Unless you are using <strong class="source-inline">Task.WhenAll</strong> to wait for multiple operations simultaneously, you should directly await a method rather than creating a <strong class="source-inline">Task</strong> instance and awaiting it.</li>
<li>Do <a id="_idIndexMarker283"/>not use <strong class="source-inline">async</strong> <strong class="source-inline">void</strong>. Your async methods should always return <strong class="source-inline">Task</strong>, <strong class="source-inline">Task&lt;TResult&gt;</strong>, <strong class="source-inline">ValueTask</strong>, or <strong class="source-inline">ValueTask&lt;TResult&gt;</strong>. The only exceptions are event handlers that have existing signatures that return <strong class="source-inline">void</strong>. Event <strong class="source-inline">Main</strong> methods can be async in .NET 6.</li>
<li>Do not mix blocking code and asynchronous code. Use <strong class="source-inline">async</strong> calls through the call stack.</li>
<li>Use <strong class="source-inline">Task.Run</strong> instead of <strong class="source-inline">Task.Factory.StartNew</strong> unless you need to pass additional parameters to one of the <strong class="source-inline">StartNew</strong> overloaded methods.</li>
<li>Long-running <strong class="source-inline">async</strong> methods should support cancellation. We will discuss cancellation in depth in <a href="B18552_11_ePub.xhtml#_idTextAnchor173"><em class="italic">Chapter 11</em></a>.</li>
<li>Synchronize the usage of shared data. Your code should add locks to prevent any overwriting of data in objects used across threads.</li>
<li>Always use <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> for I/O-bound work such as network and file access.</li>
<li>When you create an <strong class="source-inline">async</strong> method, add the <strong class="source-inline">Async</strong> suffix to its name. This helps to differentiate <strong class="source-inline">sync</strong> and <strong class="source-inline">async</strong> methods at a glance. An <strong class="source-inline">async</strong> method to return user information should be named <strong class="source-inline">GetUserInfoAsync</strong>, not <strong class="source-inline">GetUserInfo</strong>.</li>
<li>Do not use <strong class="source-inline">Thread.Sleep</strong> in async methods. If your code must wait for a fixed period, use <strong class="source-inline">await Task.Delay</strong>.</li>
</ol>
<p>Those are my 10 rules to get you started, but there are many more best practices for async development with .NET. We will discover more of them as we progress through the remaining chapters.</p>
<p>Let’s wrap up and review what we have learned about async programming in this chapter.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Summary</h1>
<p>In this chapter, we have covered quite a bit of information about asynchronous development with C# and. NET. We started by covering some of the ways to handle I/O-bound and CPU-bound operations in your applications. </p>
<p>Next, we created some practical examples that use the <strong class="source-inline">Task</strong> and <strong class="source-inline">Task&lt;TResult&gt;</strong> classes and discovered how to work with multiple <strong class="source-inline">Task</strong> objects. You got some practical advice for interop between modern asynchronous code and legacy synchronous methods. Finally, we covered some of the most important rules to remember when working with asynchronous code and <strong class="source-inline">Task</strong> objects.</p>
<p>In the next chapter, <a href="B18552_06_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, you will learn the ins and outs of parallel programming in .NET using the <strong class="bold">Task Parallel Library </strong>(<strong class="bold">TPL</strong>) and learn how to the avoid common pitfalls of parallel programming.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Questions</h1>
<ol>
<li value="1">Which property of <strong class="source-inline">Task</strong> makes a blocking call to return data from the underlying method?</li>
<li>Which <strong class="source-inline">async</strong> method of the <strong class="source-inline">Task</strong> class should be used to await multiple tasks?</li>
<li>What is the blocking equivalent of <strong class="source-inline">Task.WhenAll()</strong>?</li>
<li>What type should an <strong class="source-inline">async</strong> method always return?</li>
<li>Are <strong class="source-inline">async</strong> methods more suited to I/O-bound or CPU-bound operations?</li>
<li><em class="italic">True or false</em>: <strong class="source-inline">Async</strong> methods should never end with <strong class="source-inline">Async</strong> as their suffix.</li>
<li>What method can be used to wrap a synchronous method in an <strong class="source-inline">async</strong> call?</li>
</ol>
</div>
</div>
</body></html>