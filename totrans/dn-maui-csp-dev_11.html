<html><head></head><body>
		<div><h1 id="_idParaDest-207" class="chapter-number"><a id="_idTextAnchor216"/>11</h1>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor217"/>Exploring Advanced Topics</h1>
			<p>You now have the knowledge and skills of an intermediate .NET MAUI programmer. You’ve seen how to lay out controls and manage and manipulate those controls. You then learned about the MVVM design pattern. These are the fundamentals.</p>
			<p>After that, you advanced to Shell navigation, using SQLite for data persistence and the all-important skill of writing unit tests with mocks.</p>
			<p>This final chapter will take you beyond that level into the realm of expert .NET MAUI knowledge. In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Selecting data templates at runtime</li>
				<li>Managing visual state</li>
				<li>Utilizing Community Toolkit behaviors</li>
				<li>Taking action with triggers</li>
				<li>Validating forms</li>
			</ul>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor218"/>Technical requirements</h1>
			<p>The source code for this chapter can be found at <a href="https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/AdvancedTopics">https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/AdvancedTopics</a>. If you wish to follow along, be sure to use the code from the previous chapter.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor219"/>Selecting data templates at runtime</h1>
			<p>You saw <a id="_idIndexMarker485"/>data templates in use with collection views in <a href="B19723_05.xhtml#_idTextAnchor092"><em class="italic">Chapter 5</em></a>. Let’s revisit that code and expand upon it to allow us to modify the display of each object at runtime, based on the data in the object itself.</p>
			<p>To recap, we <a id="_idIndexMarker486"/>started with <code>PreferenceService</code>, where we mocked getting a list of <code>Preference</code> objects. Now, we can get that from the API, with just a little work. Modify <code>IPreferenceService</code> to remove <code>GetPreferencesMock</code>.</p>
			<p>Next, we need to significantly rework <code>PreferenceService</code> to interact with the client. Delete what you have and use the following:</p>
			<pre class="source-code">
using ForgetMeNot.ApiClient;
using ForgetMeNotDemo.Model;
namespace ForgetMeNotDemo.Services;
public class PreferenceService : IPreferenceService
{
  readonly Client apiClient;
  public PreferenceService(Client apiClient)
  {
    this.apiClient = apiClient;
  }
  public async Task&lt;List&lt;Preference&gt;&gt; GetPreferences()
  {
    try
    {
      var response = await apiClient.GetProfile();
      return response?.Preferences.Select(p =&gt; new
         Preference
      {
        PreferencePrompt = p.PreferencePrompt,
        PreferenceValue = p.PreferenceValue
      }).ToList();
    }
    catch (Exception e)
    {
      await Application.Current.MainPage.DisplayAlert
        ("Preferences error",
        "We were unable to get your preferences", "Ok");
      Console.WriteLine(e);
    }
    return null;
  }
}</pre>
			<p>There’s nothing <a id="_idIndexMarker487"/>new here; it is directly parallel to what we saw in <a href="B19723_10.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a> when obtaining the <em class="italic">Buddies</em>. Now that we have a collection of <code>Preference</code> objects, we can display them in a <code>CollectionView</code>, just as we did in <a href="B19723_05.xhtml#_idTextAnchor092"><em class="italic">Chapter 5</em></a> (as shown here in <code>PreferencesPage</code>, as seen in the previous chapter):</p>
			<pre class="source-code">
&lt;CollectionView
    ItemsSource="{Binding PreferenceList}"
    Margin="20,20,10,10"
    SelectionMode="None"&gt;
    &lt;CollectionView.ItemTemplate&gt;
        &lt;DataTemplate&gt;
            &lt;Grid ColumnDefinitions="*,2*"&gt;
                &lt;Entry
                    FontSize="10"
                    Grid.Column="0"
                    HorizontalOptions="Start"
                    HorizontalTextAlignment="Start"
                    Text="{Binding PreferencePrompt,
                        Mode=TwoWay}"
                    TextColor="{OnPlatform Black,
                                           iOS=White}" /&gt;
                &lt;Entry
                    FontSize="10"
                    Grid.Column="1"
                    HeightRequest="32"
                    HorizontalOptions="Start"
                    HorizontalTextAlignment="Start"
                    Text="{Binding PreferenceValue,
                      Mode=TwoWay}"
                    TextColor="{OnPlatform Black,
                                           iOS=White}"
                    WidthRequest="350" /&gt;
            &lt;/Grid&gt;
        &lt;/DataTemplate&gt;
    &lt;/CollectionView.ItemTemplate&gt;
&lt;/CollectionView&gt;</pre>
			<p>Notice that the <a id="_idIndexMarker488"/>CollectionView’s <code>ItemTemplate</code> is declared <em class="italic">inline</em>, in the declaration of <code>CollectionView</code> itself. That is not the only way to declare an <code>ItemTemplate</code>, however. Let’s see how to do it another way.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor220"/>Declaring ItemTemplates as resources</h2>
			<p>You can<a id="_idIndexMarker489"/> take <code>ItemTemplate</code> out of the definition of <code>CollectionView</code> and move it up into a <code>ResourceDictionary</code>:</p>
			<pre class="source-code">
    &lt;ContentPage.Resources&gt;  [1]
        &lt;ResourceDictionary&gt;
            &lt;DataTemplate x:Key="PreferenceTemplate"&gt; [2]
                &lt;Grid ColumnDefinitions="*,2*"&gt; [3]
                    &lt;Entry
                        FontSize="10"
                        Grid.Column="0"
                        HorizontalOptions="Start"
                        HorizontalTextAlignment="Start"
                        Text="{Binding PreferencePrompt,
                          Mode=TwoWay}"
                        TextColor="{OnPlatform Black,
                                iOS=White}" /&gt;
                    &lt;Entry
                        FontSize="10"
                        Grid.Column="1"
                        HeightRequest="32"
                        HorizontalOptions="Start"
                        HorizontalTextAlignment="Start"
                        Text="{Binding PreferenceValue,
                           Mode=TwoWay}"
                        TextColor="{OnPlatform Black,
                                         iOS=White}"
                        WidthRequest="350" /&gt;
                &lt;/Grid&gt;
            &lt;/DataTemplate&gt;
        &lt;/ResourceDictionary&gt;
    &lt;/ContentPage.Resources&gt;</pre>
			<p>Let’s look at <a id="_idIndexMarker490"/>what we’ve done here:</p>
			<ul>
				<li><code>[1]</code>: At the top of the file, we declared a <code>Resources</code> section with a <code>ResourceDictionary</code></li>
				<li><code>[2]</code>: We created <code>DataTemplate</code> and gave it a key so that we can refer to it later</li>
				<li><code>[3]</code>: The rest of <code>DataTemplate</code> is just as it was inside <code>CollectionView</code></li>
			</ul>
			<p><code>CollectionView</code> is now much simpler – it simply declares its <code>ItemTemplate</code> property to be our created <code>StaticResource</code>:</p>
			<pre class="source-code">
&lt;CollectionView
    ItemsSource="{Binding PreferenceList}"
    ItemTemplate="{StaticResource PreferenceTemplate}"
    Margin="20,20,10,10"
    SelectionMode="None"&gt;
&lt;/CollectionView&gt;</pre>
			<p>This is <a id="_idIndexMarker491"/>valuable but is hardly all that exciting except that it opens up a new possibility.</p>
			<p class="callout-heading">Where to put the DataTemplate</p>
			<p class="callout">Here, we show <code>DataTemplate</code> in the resources section, but you can put it in a different file as well.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor221"/>The DataTemplate selection</h2>
			<p>You can <a id="_idIndexMarker492"/>create two or more additional DataTemplates in the same <code>ResourceDictionary</code>. This allows you to have .NET MAUI examine each <em class="italic">item</em> as it is about to display it and choose among the available DataTemplates based on a condition.</p>
			<p>We know that when we get the preferences, some will have values and some will not. Let’s say we want to tell the user to enter a value by turning the prompt red when the value is empty. We can create two DataTemplates:</p>
			<pre class="source-code">
    &lt;ContentPage.Resources&gt;
        &lt;ResourceDictionary&gt;
            &lt;DataTemplate x:Key="PreferenceTemplate"&gt;  [1]
                &lt;Grid ColumnDefinitions="*,2*"&gt;
                    &lt;Entry
                        FontSize="10"
                        Grid.Column="0"
                        HorizontalOptions="Start"
                        HorizontalTextAlignment="Start"
                        Text="{Binding PreferencePrompt,
                           Mode=TwoWay}"
                        TextColor="{OnPlatform Black,  [2]
                                       iOS=White}" /&gt;
                    &lt;Entry
                        FontSize="10"
                        Grid.Column="1"
                        HeightRequest="32"
                        HorizontalOptions="Start"
                        HorizontalTextAlignment="Start"
                        Text="{Binding PreferenceValue,
                           Mode=TwoWay}"
                        TextColor="{OnPlatform Black,
                                               iOS=White}"
                        WidthRequest="350" /&gt;
                &lt;/Grid&gt;
            &lt;/DataTemplate&gt;
            &lt;DataTemplate x:Key=
              "PreferenceTemplateEmpty"&gt;
              [3]
                &lt;Grid ColumnDefinitions="*,2*"&gt;
                    &lt;Entry
                        FontSize="10"
                        Grid.Column="0"
                        HorizontalOptions="Start"
                        HorizontalTextAlignment="Start"
                        Text="{Binding PreferencePrompt,
                          Mode=TwoWay}"
                        TextColor="{OnPlatform Red,
                                   iOS=Yellow}" /&gt;    [4]
                    &lt;Entry
                        FontSize="10"
                        Grid.Column="1"
                        HeightRequest="32"
                        HorizontalOptions="Start"
                        HorizontalTextAlignment="Start"
                        Text="{Binding PreferenceValue,
                            Mode=TwoWay}"
                        TextColor="{OnPlatform Black,
                                               iOS=White}"
                        WidthRequest="350" /&gt;
                &lt;/Grid&gt;
            &lt;/DataTemplate&gt;
         &lt;/ResourceDictionary&gt;
    &lt;/ContentPage.Resources&gt;</pre>
			<p>Let’s take a<a id="_idIndexMarker493"/> look at this:</p>
			<ul>
				<li><code>[1]</code>: The first data template</li>
				<li><code>[2]</code>: The normal text colors</li>
				<li><code>[3]</code>: The second data template (with its own key)</li>
				<li><code>[4]</code>: The <em class="italic">empty</em> text colors</li>
			</ul>
			<p>Now, the obvious question is, how does .NET MAUI know which to display? For that, we need a <code>DataTemplateSelector</code>.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor222"/>The DataTemplateSelector class</h2>
			<p>The first thing you <a id="_idIndexMarker494"/>must do is create a class that will contain the logic as to which template to display. I’ve named that class <code>PreferenceDataTemplateSelector</code>. Since I only intend to have one, I put it in the <code>Services</code> folder:</p>
			<pre class="source-code">
using ForgetMeNotDemo.Model;
namespace ForgetMeNotDemo.Services;
public class PreferenceDataTemplateSelector :
  DataTemplateSelector  [1]
{
  public DataTemplate PreferenceTemplate { get; set; }
    [2]
  public DataTemplate PreferenceTemplateEmpty { get; set; }
  protected override DataTemplate OnSelectTemplate(object
    item,  [3] BindableObject container)
  {
    if (((Preference)item)?.PreferenceValue == null)
      return PreferenceTemplateEmpty;
    return ((Preference) item).PreferenceValue.Length &gt; 0 ?
      PreferenceTemplate : PreferenceTemplateEmpty;    [4]
  }
}</pre>
			<p>You must do the following:</p>
			<p><code>[1]</code>: Your class must derive from <code>DataTemplateSelector</code>.</p>
			<p><code>[2]</code>: You need a public property for each of your DataTemplates.</p>
			<p><code>[3]</code>: Override the <code>OnSelectTemplate</code> virtual method.</p>
			<p><code>[4]</code>: Add the logic as to which template to display.</p>
			<p>With the class in<a id="_idIndexMarker495"/> place, we need to have a corresponding resource.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor223"/>Adding the template selector to the page’s resources</h2>
			<p>Return <a id="_idIndexMarker496"/>to <code>PreferencesPage.xaml</code>. In the page declaration, add <code>Xmlns:services="clr-namespace:ForgetMeNotDemo.Services"</code>. Then, in <code>ResourceDictionary</code>, add the following:</p>
			<pre class="source-code">
&lt;services:PreferenceDataTemplateSelector
                PreferenceTemplate="{StaticResource
                    PreferenceTemplate}"
                PreferenceTemplateEmpty="{StaticResource
                    PreferenceTemplateEmpty}"
                x:Key="PreferenceDataTemplateSelector" /&gt;</pre>
			<p>This provides the link to the names in the class we just created. We now have the logic, but how do we hook it up to <code>CollectionView</code>?</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor224"/>Adding DataTemplateSelector to CollectionView</h2>
			<p>Hooking <a id="_idIndexMarker497"/>all this into <code>CollectionView</code> is <a id="_idIndexMarker498"/>as simple as setting an <code>ItemTemplate</code>:</p>
			<pre class="source-code">
&lt;CollectionView
    ItemTemplate="{StaticResource PreferenceDataTemplate
       Selector}"
    ItemsSource="{Binding PreferenceList}"
    Margin="20,20,10,10"
    SelectionMode="None" /&gt;</pre>
			<p>And it all comes together. <code>CollectionView</code> looks to <code>PreferenceDataTemplateSelector</code> in the resources, which is tied to the class we created<a id="_idIndexMarker499"/> that <a id="_idIndexMarker500"/>holds the logic as to which <code>DataTemplate</code> to show. The result is shown in <em class="italic">Figure 11</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_11.1_B19723.jpg" alt="Figure 11.1 – DataTemplate selection&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – DataTemplate selection</p>
			<p><code>DataTemplateSelector</code> is a very powerful way to control what is displayed at runtime. A similar mechanism is encapsulated in the concept of Visual State.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor225"/>Managing Visual State</h1>
			<p>Every <code>VisualElement</code> has a <em class="italic">Visual State</em> at any given moment (for example, does <code>VisualElement</code> have <em class="italic">focus</em>? Is it <em class="italic">selected</em>?). You can imagine responding to that state programmatically in C#, but <a id="_idIndexMarker501"/>there are advantages to responding to changes in visual state declaratively, in the XAML. Doing so puts more of the UI management in one place – your view (for example, <code>MainPage.xaml</code>).</p>
			<p class="callout-heading">VisualElement</p>
			<p class="callout"><code>VisualElement</code> is the base class of all controls (and pages).</p>
			<p>The object that sets visual properties on <code>VisualElement</code> based on its state is the <code>VisualStates</code> and displays a <code>VisualElement</code> according to the properties set in the XAML.</p>
			<p>This forces the question: what are visual states?</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor226"/>Defining the common visual states</h2>
			<p>.NET MAUI defines a <a id="_idIndexMarker503"/>set of common visual states:</p>
			<ul>
				<li><code>Normal</code></li>
				<li><code>Disabled</code></li>
				<li><code>Has focus</code></li>
				<li><code>Is selected</code></li>
				<li><code>Mouse over</code> (for Windows and macOS)</li>
			</ul>
			<p>.NET MAUI also allows you to define your own visual states, though that is less common.</p>
			<p>You use these visual states to set properties on <code>VisualElement</code>. For example, you might change the appearance of a button based on its <code>VisualState</code>. An example will make this much clearer.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor227"/>A button VisualState example</h2>
			<p>When you first<a id="_idIndexMarker504"/> go to the <strong class="bold">Login</strong> page, you will see that the <strong class="bold">Submit</strong> button is disabled. We’d like it to be gray. Once you fill in the <strong class="bold">Your Email</strong> and <strong class="bold">Password</strong> fields, the button should turn light green. If you tab to the button, it should signify that it has the focus by turning fully green. You can do all this declaratively by creating visual states, as shown in <em class="italic">Figure 11</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/1.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Visual states of buttons</p>
			<p>You can set the visual state on an individual button, or, as we will do here, you can put the visual state’s XAML into a style and apply it to all the buttons. Here is the complete <code>Style</code> for buttons:</p>
			<pre class="source-code">
&lt;Style x:Key="LoginButton" TargetType="Button"&gt; [1]
    &lt;Setter Property="Margin" Value="0,20,0,0" /&gt;
    &lt;Setter Property="TextColor" Value="Black" /&gt;
    &lt;Setter Property="WidthRequest" Value="125" /&gt;
    &lt;Setter Property="VisualStateManager
      .VisualStateGroups"&gt; [2]
        &lt;VisualStateGroupList&gt;
            &lt;VisualStateGroup x:Name="CommonStates"&gt; [3]
                &lt;VisualState x:Name="Normal"&gt; [4]
                    &lt;VisualState.Setters&gt; [5]
                        &lt;Setter Property="BackgroundColor"
                           Value="LightGreen" /&gt; [6]
                    &lt;/VisualState.Setters&gt;
                &lt;/VisualState&gt;
                &lt;VisualState x:Name="Focused"&gt;
                    &lt;VisualState.Setters&gt;
                        &lt;Setter Property="BackgroundColor"
                           Value="Green" /&gt;
                    &lt;/VisualState.Setters&gt;
                &lt;/VisualState&gt;
                &lt;VisualState x:Name="Disabled"&gt;
                    &lt;VisualState.Setters&gt;
                        &lt;Setter Property="BackgroundColor"
                          Value="Gray" /&gt;
                    &lt;/VisualState.Setters&gt;
                &lt;/VisualState&gt;
            &lt;/VisualStateGroup&gt;
        &lt;/VisualStateGroupList&gt;
    &lt;/Setter&gt;
&lt;/Style&gt;</pre>
			<p>Here, we have <a id="_idIndexMarker505"/>the following:</p>
			<ul>
				<li><code>[1]</code>: We start by declaring a normal <code>Style</code> – in this case, it’s implicit for every button</li>
				<li><code>[2]</code>: You may have one or more groups of visual states (we have one)</li>
				<li><code>[3]</code>: The first group (and in this case, the only one) is <code>CommonStates</code></li>
				<li><code>[4]</code>: We declare each <code>VisualState</code> in turn (here, we’re starting with <code>Normal</code>)</li>
				<li><code>[5]</code>: For each state, we can declare a set of Setters</li>
				<li><code>[6]</code>: Our first (and in this case, only) <code>Setter</code> sets the <code>BackgroundColor</code> property</li>
			</ul>
			<p>We then go on to set the <a id="_idIndexMarker506"/>Setters for all the other states. Notice that we did not set a <code>Setter</code> for <code>PointerOver</code>, which means that, on Windows and macOS, if you hover the mouse over the button, there will be no change.</p>
			<p>.NET MAUI defines specialized visual states for controls. For example, <code>Button</code> adds the <em class="italic">Pressed</em> state, while <code>CheckBox</code> adds the <em class="italic">IsChecked</em> state and <code>CollectionViews</code> adds <em class="italic">Selected</em>.</p>
			<p>The .NET MAUI Community Toolkit provides further help for managing the appearance and behavior of your app with a large collection of behaviors.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor228"/>Utilizing Community Toolkit behaviors</h1>
			<p>We’ve <a id="_idIndexMarker507"/>already seen one <em class="italic">behavior</em> from the <em class="italic">Community Toolkit</em> that turns an event into a command (<code>EventToCommandBehavior</code>), allowing us to respond to these events in our <code>ViewModel</code>.</p>
			<p class="callout-heading">The Community Toolkit is open source</p>
			<p class="callout">The Community Toolkit is not officially part of .NET MAUI and consists of code supplied by (surprise!) the community – that is, developers independent of Microsoft. That said, the Microsoft documentation includes and increasingly integrates the Community Toolkit.</p>
			<p><code>CommunityToolkit</code> provides a suite of behaviors to handle many other common programming needs. Many of these behaviors assist with validating input. For example, the <code>CommunityToolkit</code> includes the following:</p>
			<ul>
				<li>Character validation</li>
				<li>Numeric validation</li>
				<li>Required string validation</li>
				<li>Text validation</li>
				<li>URI validation</li>
			</ul>
			<p>You attach<a id="_idIndexMarker508"/> behaviors to controls. For example, let’s add a rule to the <strong class="bold">Login</strong> page stating that the username must be a valid email address. First, in the header, add the needed namespace:</p>
			<pre class="source-code">
Xmlns:behaviors=http://schemas.microsoft.com/dotnet/2022/maui/toolkit</pre>
			<p>You are then ready to test for a valid email using the Community Toolkit behavior:</p>
			<pre class="source-code">
&lt;Entry
    Grid.Column="1"
    Grid.ColumnSpan="2"
    Grid.Row="0"
    Placeholder="Please enter your email address"
    Text="{Binding LoginName}"
    WidthRequest="150"&gt;
    &lt;Entry.Behaviors&gt;   [1]
        &lt;behaviors:EmailValidationBehavior  [2]
            InvalidStyle="{StaticResource InvalidUserName}"
              [3]
            ValidStyle="{StaticResource ValidUserName}" [4]
            Flags="ValidateOnValueChanged" /&gt; [5]
    &lt;/Entry.Behaviors&gt;
&lt;/Entry&gt;</pre>
			<p>Do the<a id="_idIndexMarker509"/> following:</p>
			<p><code>[1]</code>: Begin the <code>Behaviors</code> section of the <code>Entry</code> tag.</p>
			<p><code>[2]</code>: Choose which behavior you want (in this case, email validation).</p>
			<p><code>[3]</code>: Identify the style for an invalid email address.</p>
			<p><code>[4]</code>: Identify the style for a valid email address.</p>
			<p><code>[5]</code>: Add validation behaviors. They have flags to indicate when to do the validation (in this case, when the value changes), as shown in the following figure:</p>
			<div><div><img src="img/Figure_11.3_B19723.jpg" alt="Figure 11.3 – Validation flags&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Validation flags</p>
			<p>There are several other non-validating behaviors as well. These include behaviors to assist with animating views, progress bar animation, a behavior to assist with customizing the color and style of your device’s status bar, and a behavior to trigger an action when the user stops typing.</p>
			<p>The last of these can be very helpful when allowing the user to search a large set of data. Rather than having the search be incremental as the user types, or forcing the user to tap a <strong class="bold">Search</strong> button, you can have the search begin when the user stops typing for a specified period:</p>
			<pre class="source-code">
Place the following code at the top of PreferencesPage.xaml
&lt;Entry Placeholder="Search" x:Name="SearchEntry"&gt;
    &lt;Entry.Behaviors&gt;
        &lt;behaviors:UserStoppedTypingBehavior
            Command="{Binding PreferencesSearchCommand}"
              [1]
            CommandParameter="{Binding Source={x:Reference
               SearchEntry}, Path=Text}"    [2]
            MinimumLengthThreshold="4"  [3]
            ShouldDismissKeyboardAutomatically="True" [4]
            StoppedTypingTimeThreshold="500" /&gt; [5]
    &lt;/Entry.Behaviors&gt;
&lt;/Entry&gt;</pre>
			<p>Let’s look at <a id="_idIndexMarker510"/>what this code does:</p>
			<ul>
				<li><code>[1]</code>: When the user stops typing, call this command in your <code>ViewModel</code></li>
				<li><code>[2]</code>: Pass this parameter (the text of <code>Entry</code>) to the command</li>
				<li><code>[3]</code>: Don’t execute the command unless at least this many characters have been entered</li>
				<li><code>[4]</code>: When you execute the command, put away the keyboard</li>
				<li><code>[5]</code>: Wait this long (half a second) to indicate the user has stopped typing</li>
			</ul>
			<p>When you add this to your XAML, and the user enters <code>Shoe</code> in the entry, the command is fired and the parameter is sent. <em class="italic">Figure 11</em><em class="italic">.4</em> shows the parameter being passed into the command handler in <code>PreferencesPageViewModel</code>:</p>
			<div><div><img src="img/Figure_11.4_B19723.jpg" alt="Figure 11.4 – Passing in the search string&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Passing in the search string</p>
			<p>Behaviors <a id="_idIndexMarker511"/>are a way to declare how the system should perform in XAML. Another powerful mechanism for moving responsive actions into the XAML triggers.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor229"/>Taking action with triggers</h1>
			<p><em class="italic">Triggers</em> allow<a id="_idIndexMarker512"/> you to declare how a control should appear in your XAML based on data changes. You can also use <em class="italic">state triggers</em> to change a control’s <em class="italic">Visual State</em>, as shown earlier.</p>
			<p>For example, we may want <a id="_idIndexMarker513"/>to enforce that the <code>DataTrigger</code>:</p>
			<pre class="source-code">
&lt;Button
    Command="{Binding DoCreateAccountCommand}"
    Grid.Column="1"
    Grid.Row="2"
    Style="{StaticResource LoginButton}"
    Text="Create Account"&gt;
    &lt;Button.Triggers&gt;  [1]
        &lt;DataTrigger
            Binding="{Binding Source={x:Reference
               passwordEntry}, Path=Text.Length}"
            TargetType="Button"
            Value="0"&gt; [2]
            &lt;Setter Property="IsEnabled" Value="False" /&gt;
              [3]
        &lt;/DataTrigger&gt;
    &lt;/Button.Triggers&gt;
&lt;/Button&gt;</pre>
			<p>Let’s look at <a id="_idIndexMarker515"/>what this<a id="_idIndexMarker516"/> code does:</p>
			<ul>
				<li><code>[1]</code>: This starts the <code>Triggers</code> collection of <code>Button</code>.</li>
				<li><code>[2]</code>: This creates a <code>DataTrigger</code> and sets it to bind to the length of the text in the entry control whose name is <code>passwordEntry</code>. Set <code>TargetType</code> to <code>Button</code> (required) and the value for it to trigger on (that is, if the length of the password entry text is <code>0</code>, then fire the trigger).</li>
				<li><code>[3]</code>: This code uses a setter to declare what happens when the trigger fires.</li>
			</ul>
			<p>In short, when the <strong class="bold">Password</strong> field is empty, the <strong class="bold">Create</strong> button should be disabled and as soon as it is not empty, the button should be enabled.</p>
			<p class="callout-heading">Unexpected behavior</p>
			<p class="callout">The field you are checking (<code>Password</code>) must have its text initialized to <code>""</code> for this to work. Otherwise, it will be null and the trigger may not act as expected. To solve this, initialize the property in <code>ViewModel</code>:</p>
			<p class="callout"><code>[</code><code>observableproperty]</code></p>
			<p class="callout"><code>public string password = </code><code>string.Empty;</code></p>
			<p>The <a id="_idIndexMarker517"/>result of this<a id="_idIndexMarker518"/> trigger is shown in <em class="italic">Figure 11</em><em class="italic">.5</em> and <em class="italic">Figure 11</em><em class="italic">.6</em>.</p>
			<div><div><img src="img/2.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Trigger when the Password field is empty</p>
			<p>In <em class="italic">Figure 11</em><em class="italic">.5</em>, the <strong class="bold">Password</strong> field is empty, while in <em class="italic">Figure 11</em><em class="italic">.6</em>, a character has been typed into the <strong class="bold">Password</strong> field:</p>
			<div><div><img src="img/3.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Trigger when the Password field is not empty</p>
			<p>For fun, change <code>Property</code> from <code>IsEnabled</code> to <code>IsVisible</code>. Now, the button is not there when you<a id="_idIndexMarker519"/> enter the page, but will appear when you put a<a id="_idIndexMarker520"/> character into the <strong class="bold">Password</strong> field.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor230"/>Summary</h1>
			<p>In this chapter, we reviewed four key advanced topics that allow you to manage the behavior of your app declaratively:</p>
			<ul>
				<li>Selecting data templates allows you to change the display of your data based on the specific content of each element in a collection</li>
				<li>Managing the view state allows you to modify the appearance of a control based on the <em class="italic">state</em> of that control (for example, does it have focus?)</li>
				<li>Behaviors allow, among other things, data validation and otherwise assist in providing actions that you declare</li>
				<li>Triggers change the appearance of controls based on data values in other controls or based on the state of other controls</li>
			</ul>
			<p>This brings us to the end of <code>.Net MAUI for C# Developers</code>. You are now fully equipped to create real-world professional .NET MAUI applications.</p>
			<p>The key to success with .NET MAUI, as with so many programming skills, is hands-on experience. If you are not currently working on a .NET MAUI project, you will want to assign one to yourself while this information is front and center in your mind.</p>
			<p>Here’s an application idea I’ve had for years, which you are free to write (and sell if you want). I’ll give it to you without restriction:</p>
			<p>Create a nice-looking application that gathers all the books on an online bookstore (using their public API) that you rated with five stars. Next, gather all the people who have also rated a large percentage of those books five stars. Exclude anyone who gave any of those books less than five stars. Now, take those people who seem to agree with you, and find any books they rated as five stars that you’ve not read yet. Those are books you’ll want to read.</p>
			<p>Enjoy the project! I hope you have enjoyed this book.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor231"/>Quiz</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li>Why would you use the Visual State Manager?</li>
				<li>How does .NET MAUI decide which data template to use?</li>
				<li>Name a behavior that is not used for validation.</li>
				<li>When a trigger fires, how does it know what to do?</li>
			</ol>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor232"/>You try it</h1>
			<p>Modify the <strong class="bold">Login</strong> page so that it does the following:</p>
			<ul>
				<li>Disables the <strong class="bold">Login</strong> button unless the username is a valid email address and the password has at least one character.</li>
				<li>Modifies the <strong class="bold">Forgot Password</strong> button to double in size and turn pink when you tab onto it (giving it the focus), and returns to its normal size and color when it loses focus</li>
			</ul>
		</div>
		<div><div></div>
		</div>
	

		<div><h1 id="_idParaDest-224"><a id="_idTextAnchor233"/>Assessments</h1>
			<p>This section contains answers to questions from all chapters.</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor234"/>Chapter 1, Assembling Your Tools and Creating Your  First App</h1>
			<ol>
				<li>You can create a new project from the launch dialog by choosing <strong class="bold">Create a new project</strong>. If you’ve been brought directly into Visual Studio, by clicking on <strong class="bold">File</strong> | <strong class="bold">New Project</strong>.</li>
				<li>Use <strong class="bold">View</strong> | <strong class="bold">Solution Explorer</strong>.</li>
				<li>The <code>.xaml</code> extension indicates that the file contains XAML markup.</li>
				<li>The code-behind file.</li>
				<li><code>MauiProgram.cs</code>.</li>
			</ol>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor235"/>Chapter 3, XAML and Fluent C#</h1>
			<ol>
				<li value="1">XAML is a markup language based on XML.</li>
				<li>XAML is used in .NET MAUI for declaring layouts and controls.</li>
				<li>Rather than writing in XAML, you can create your layouts and controls in C#.</li>
				<li>We nest a layout or a control inside a layout by using the <code>Children</code> property.</li>
				<li>An event handler is a method that is registered to an event in the UI.</li>
				<li>The event handler is in the code-behind.</li>
			</ol>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor236"/>Chapter 4, MVVM and Controls</h1>
			<ol>
				<li value="1">MVVM has two main advantages. First, it is nearly impossible to unit test a .NET MAUI application if your logic is in the code-behind file – putting the logic in <code>ViewModel</code> is essential, as we’ll see in the upcoming chapter on unit testing. Second, MVVM nicely decouples the UI from your logic, allowing you to change one without breaking the other.</li>
				<li>The all-important <code>BindingContext</code>. You typically assign <code>ViewModel</code> as the binding context for <code>View</code>.</li>
				<li>The <code>Entry</code> control and the <code>Editor</code> control.</li>
				<li>The <code>Label</code> control.</li>
				<li><code>SnackBar</code> is a highly configurable <code>Toast</code> – a popup that comes up from the bottom of the page and then can disappear either by its timer running out or by a user clicking on it.</li>
			</ol>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor237"/>Chapter 5, Advanced Controls</h1>
			<ol>
				<li value="1"><code>ActivityIndicator</code> shows that <em class="italic">something</em> is happening, while <code>ProgressBar</code> tells the user what fraction of the task is complete.</li>
				<li>The essential difference as far as we are concerned is that events are typically handled in the code-behind, while commands are handled in <code>ViewModel</code>. Handling commands in <code>ViewModel</code> is preferable because it makes creating unit tests easier or possible.</li>
				<li><code>WeakReferenceManager</code> is the primary object used in messaging, allowing <code>ViewModel</code> to send notifications to <code>View</code> or another <code>ViewModel</code> without a reference to that object, thus supporting loose coupling.</li>
				<li>Styles allow you to create a uniform appearance across instances of controls, centralizing the properties and providing all the advantages of well-factored code.</li>
				<li>One way to refactor styles is to create a base style and then use <code>BasedOn</code> to create derived types, adding or overriding properties as needed.</li>
			</ol>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor238"/>Chapter 6, Layout</h1>
			<ol>
				<li value="1">Stars, <code>auto</code>, and the value in dpi</li>
				<li>Allocate 100 dpi to the last column, the needed size for the second column, and then divide the first and third columns proportionally as 2:1</li>
				<li>The row and column offsets are defined by enumerated constants</li>
				<li><code>Grid</code> allows for more precise alignment and placement of controls</li>
				<li><code>BindableLayout</code> does not allow you to make selections</li>
			</ol>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor239"/>Chapter 7, Understanding Navigation</h1>
			<ol>
				<li value="1"><code>AppShell.xaml</code></li>
				<li><code>Title</code>, <code>ContentTemplate</code>, and <code>Icon</code></li>
				<li><code>AppShell.xaml.cs</code></li>
				<li><code>Shell.Current.GoToAsync</code></li>
				<li>URL syntax or using a dictionary</li>
			</ol>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor240"/>Chapter 8, Storing and Retrieving Data</h1>
			<ol>
				<li value="1"><code>Preferences</code> (not to be confused with <code>UserPreferences</code>).</li>
				<li>The key and a default value.</li>
				<li><strong class="bold">SQLite-net-pcl</strong> and possibly <strong class="bold">SQLitePCLRaw.bundle_green</strong>, if not included with <strong class="bold">SQLite-net-pcl</strong>.</li>
				<li><code>SQLiteAsyncConnection</code></li>
			</ol>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor241"/>Chapter 9, Unit Testing</h1>
			<ol>
				<li value="1">Unit tests are critical for ensuring the quality of your code and allow you to add to and change your code with the confidence of knowing that if you break something, you’ll find out about it right away.</li>
				<li>Most of the testable code in a .NET MAUI application will be in the ViewModel or, possibly, the services.</li>
				<li>When you need a slower service to test a method in your code, a mock can stand in for that service and give you immediate responses.</li>
				<li>In order to provide a mock to your test, you must be able to inject it into the code in lieu of the runtime object.</li>
			</ol>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor242"/>Chapter 10, Consuming REST Services</h1>
			<ol>
				<li value="1">A DTO is responsible for holding data that will be sent to and/or from the API.</li>
				<li>The database is now in the cloud and managed through the API. As the client, we don’t know, nor need to know, what kind of database is in use.</li>
				<li>It wraps all the API calls so that a client can interact with the API as if it were a <strong class="bold">Plain Old CLR </strong><strong class="bold">Object</strong> (<strong class="bold">POCO</strong>).</li>
				<li>Account creation is accomplished in the cloud via the API.</li>
				<li>Authentication is accomplished in the cloud via the API.</li>
			</ol>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor243"/>Chapter 11, Exploring Advanced Topics</h1>
			<ol>
				<li value="1">To modify the appearance of a control based on its <em class="italic">state</em>, such as whether or not it has the focus.</li>
				<li>In the XAML, add a <code>DataTemplateSelector</code> to indicate the potential templates and then add a class that derives from <code>DataTemplateSelector</code> that overrides <code>OnSelectTemplate</code> and returns <code>DataTemplate</code> to be displayed.</li>
				<li>We have seen the <code>EventToCommand</code> behavior, which allows you to add commands to controls that only have events, allowing you to handle the event/command in <code>ViewModel</code>.</li>
				<li>You add setters with the property to change and the value to set it to.</li>
			</ol>
		</div>
	</body></html>