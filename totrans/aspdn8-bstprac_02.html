<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-30"><a id="_idTextAnchor031"/>2</h1>
<h1 id="_idParaDest-31"><a id="_idTextAnchor032"/>CI/CD – Building Quality Software Automatically</h1>
<p>In my career, someone once said to me, “<em class="italic">CI/CD is dead, long live CI/CD</em>.” Of course, this phrase doesn’t mean it’s completely dead. It simply means CI/CD is now becoming the standard for software development, a common practice developers should adopt and learn during a software development life cycle. It is now considered part of your development process as opposed to being a shiny, new process.</p>
<p>In this chapter, we’ll review what <strong class="bold">Continuous Integration</strong>/<strong class="bold">Continuous Deployment</strong> (<strong class="bold">CI</strong>/<strong class="bold">CD</strong>) means and how to prepare your code for a pipeline. Once we’ve covered the necessary changes to include in your code, we’ll discuss what a common pipeline looks like for building software. Once we understand the pipeline process, we’ll look at two ways to recover from an unsuccessful deployment and how to deploy databases. We’ll also cover the three different types of cloud services available to you (on and off-premises and hybrid) and review a list of the top CI/CD providers on the internet. Finally, we’ll walk you through the process of creating a build for a sample application, along with other types of projects.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What is CI/CD?</li>
<li>Preparing your Code</li>
<li>Understanding the Pipeline</li>
<li>The Two “Falling” Approaches</li>
<li>Deploying Databases</li>
<li>The three Types of Build Providers</li>
<li>CI/CD Providers</li>
<li>Walkthrough of Azure Pipelines</li>
</ul>
<p>After you’ve completed this chapter, you’ll be able to identify flaws in software when you’re preparing code for software deployment, understand what a common pipeline includes in producing quality software, identify two ways of recovering from an unsuccessful deployment, know how to deploy databases through a pipeline, understand the different types of CI/CD providers, and know some key players in the CI/CD provider space.</p>
<p>Finally, we’ll walk through a common pipeline in Azure Pipelines to encompass everything we’ve learned in this chapter.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Technical requirements</h1>
<p>For this chapter, the only technical requirements include having access to a laptop and an account for one of the cloud providers mentioned in the <em class="italic">CI/CD providers</em> section (preferably Microsoft’s Azure Pipelines – don’t worry, it’s free).</p>
<p>Once you have reviewed how pipelines are created, you’ll be able to apply the same concepts to other cloud providers and their pipeline strategies.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/>What is CI/CD?</h1>
<p>In this section, we’ll learn about what continuous integration and continuous deployment mean to developers.</p>
<p><strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) is the process of merging all developers’ code<a id="_idIndexMarker043"/> into a mainline to trigger an automatic build process so that you can quickly identify issues with a code base using unit tests and code analysis.</p>
<p>When a developer checks their code into a branch, it’s reviewed by peer developers. Once accepted, it’s merged into a mainline and automatically starts a build process. This build process will be covered shortly.</p>
<p><strong class="bold">Continuous Deployment</strong> (<strong class="bold">CD</strong>) is the process of consistently creating<a id="_idIndexMarker044"/> software to deploy it at any time.</p>
<p>Once everything has been built through the automated process, the build prepares the compiled code and creates artifacts. These artifacts are used for consistent deployments across various environments, such as development, staging, and production.</p>
<p>The benefits of implementing a CI/CD pipeline<a id="_idIndexMarker045"/> outweigh not having one:</p>
<ul>
<li><strong class="bold">Automated Testing</strong>: When a commit is triggered, your tests are automatically executed along with your build. Think of this as someone always checking your code on commit.</li>
<li><strong class="bold">Faster Feedback Loops</strong>: As a developer, it’s always great to receive immediate feedback to find out whether something works or not. If you receive an email where the build broke, you’re on your own.</li>
<li><strong class="bold">Consistent Builds</strong>: Once you have a project being built on a build server, you can create builds on-demand – and consistently – with tests.</li>
<li><strong class="bold">Collaboration Between Teams</strong>: We’re all in this together and CI/CD includes developers, system administrators, project managers/SCRUM masters, and QA testers, to name a few, to accomplish the goal of creating great software.</li>
</ul>
<p>In this section, we reviewed the definition of what continuous integration and continuous deployment mean when developing software in an automated fashion and the benefits of implementing a CI/CD pipeline.</p>
<p>In the next section, we’ll learn about certain code practices to avoid when automating software builds.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor035"/>Preparing your Code</h1>
<p>In this section, we’ll cover certain aspects of your code<a id="_idIndexMarker046"/> and how they could impact the deployment of your software. Such software issues could include code not compiling (broken builds), avoiding relative path names, and making sure you wrote proper unit tests. These are a couple of the common errors I’ve experienced over the years; in this section, I’ll also provide solutions on how to fix them.</p>
<p>Before we review a CI pipeline, there are a few caveats we should address beforehand. Even though we covered a lot in the previous chapter regarding version control, your code needs to be in a certain state to achieve “one-button” builds.</p>
<p>In the following sections, you’ll learn how to prepare your code<a id="_idIndexMarker047"/> so that it’s “CI/CD-ready” and examine the problems you could experience when deploying your software and how to avoid them.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Building Flawlessly</h2>
<p>If a new person is hired<a id="_idIndexMarker048"/> and starts immediately, you want them to hit the ground running and begin developing software without delay. This means being able to point them to a repository and pull the code so that you can <em class="italic">immediately</em> run the code <em class="italic">with </em><em class="italic">minimal setup</em>.</p>
<p>I say “minimal setup” because there may be permissions involved to gain access to certain resources in the company so that they can be run locally.</p>
<p>Nevertheless, the code should be in a runnable state, send you to a simple screen of some kind, and notify the user to follow up on a permissions issue or provide some notification to resolve the problem.</p>
<p>In the previous chapter, we mentioned how the code should compile at all times. This means the following:</p>
<ul>
<li>The code should always compile after a clone or checkout</li>
<li>Unit tests should be included with the build, not in separate projects</li>
<li>Your commit messages to version control should be meaningful (they may be used for Release Notes)</li>
</ul>
<p>These standards allow your pipeline to fall into the pit of success. They help you create a build even faster and easier when your code is in a clean state.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor037"/>Avoiding Relative Path Names with File-based Operations</h2>
<p>One of the troublesome<a id="_idIndexMarker049"/> issues I’ve seen over the years when it comes to web applications is how files are accessed in a web application.</p>
<p>I’ve also seen file-based operations through a web page, where files were moved using relative paths and it went wrong. It involved deleting directories and it didn’t end well.</p>
<p>For example, let’s say you had a relative path to an image, as follows:</p>
<pre class="source-code">
../images/myimage.jpg</pre> <p>Now, let’s say you’re sitting on a web page, such as <code>https://localhost/kitchen/chairs</code>.</p>
<p>If you went back one directory, you’d be in the kitchen with a missing image, not at the root of the website. According to your relative path, you’re looking for an image directory at <code>https://localhost/kitchen/images/myimage.jpg</code>.</p>
<p>To make matters worse, if you’re using custom routing, this may not even be the normal path, and who knows where it’s looking for the image.</p>
<p>The best approach when preparing your code is to use a single slash (<code>/</code>) at the beginning of your URL since it’s considered “absolute:”</p>
<pre class="source-code">
/images/myimage.jpg</pre> <p>This makes it easier to navigate<a id="_idIndexMarker050"/> to the root when you’re locating files on a website, regardless of what environment you’re in. It doesn’t matter if you are on <a href="https://www.myfakewebsite.com/">https://www.myfakewebsite.com/</a> or <a href="http://localhost/">http://localhost/</a>, the root is the root, and you’ll always find your files when using a single slash at the beginning of your sources.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor038"/>Confirming that your Unit Tests are Unit Tests</h2>
<p>Tests in your code are created to provide<a id="_idIndexMarker051"/> checks and balances so that your code works as expected. Each test needs to be examined carefully to confirm it isn’t doing anything out of the ordinary.</p>
<p>Unit tests are considered tests against code in memory, whereas integration tests are tests that require <em class="italic">ANY</em> external resources:</p>
<ul>
<li>Do your tests access any files? Integration test.</li>
<li>Do you connect to a database to test something? Integration test.</li>
<li>Are you testing business logic? Unit test.</li>
</ul>
<p>As you’re beginning to surmise, when you build your application on another machine, cloud services do not have access to your database server and also may not have the additional files you need for each test to pass.</p>
<p>If you are accessing external resources, it may be a better approach to refactor your tests into something a little more memory-driven. I’ll explain why in <a href="B19493_07.xhtml#_idTextAnchor163"><em class="italic">Chapter 7</em></a>, when we’ll cover <strong class="bold">unit testing</strong>.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor039"/>Creating Environment Settings</h2>
<p>Whether you are in the middle<a id="_idIndexMarker052"/> of a project or are clicking <strong class="bold">Create New Project…</strong> for the first time, you need a way to create environment settings for your web application.</p>
<p>In ASP.NET Core applications, we are given <code>appsettings.json</code> and <code>appsettings.Development.json</code> configuration files out of the box. The <code>appsettings.json</code> file is meant to be a base configuration file and, depending on the environment, each <code>appsettings</code> file is applied and only existing properties are overwritten to the <code>appsettings.json</code> file.</p>
<p>One common example of this is connection strings and application paths. Depending on the environment, each file will have its own settings.</p>
<p>The environments need to be defined upfront as well. There will always be a development and release environment. There may be an option to create another environment called QA on another machine somewhere, so an <code>appsettings.qa.json</code> file would be required with its own environment-specific settings.</p>
<p>Confirm that these settings have been saved for each relevant environment since they are important in a CI/CD pipeline. <em class="italic">These environment settings should always be checked into version control with your solution/project</em> to assist the pipeline in deploying the right settings to the right environment.</p>
<p>In this section, we covered ways to prepare your code for a CI/CD pipeline by making sure we can build immediately after cloning or pulling the repository down locally, why we should avoid relative-based file paths, and confirmed we were using environment-specific application settings, making it easy to build and deploy our application.</p>
<p>With your code checked in, we can now move forward and describe all of the stages of a common pipeline.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Understanding the Pipeline</h1>
<p>In this section, we’ll cover the steps<a id="_idIndexMarker053"/> of what a common pipeline includes for building software when using a CI/CD service. When you reach the end of this section, you’ll understand every step of the process in a common pipeline so that you can produce quality software.</p>
<p>A CI pipeline is a collection of steps required to code, build, test, and deploy software. Each step is not owned by a particular person but by a team working together and focusing on the goal to produce exceptional software. The good news is that if you followed the previous chapter’s recommendations, you’re already ahead of the game.</p>
<p>Each company’s pipeline can vary from product to product, but there will always be a common set of steps for a CI process. It depends on how detailed your pipeline becomes based on your needs. The stages in the pipelines can be influenced by each stakeholder involved in the process. Of course, pulling code and building and testing are required for the developers, but a QA team requires the finished product (artifact) to be sent to another server for test purposes.</p>
<p><em class="italic">Figure 2</em><em class="italic">.1</em> shows one common pipeline:</p>
<div><div><img alt="Figure 2.1 – One example of a build pipeline" src="img/Figure_2.01_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – One example of a build pipeline</p>
<p>As shown in <em class="italic">Figure 2</em><em class="italic">.1</em>, the process is sequential when creating a software deployment. Here’s a summary of the steps:</p>
<ol>
<li>Pull code from a single repository.</li>
<li>Build the application.</li>
<li>Run unit tests/code analysis against the code that was built in <em class="italic">step 2</em>.</li>
<li>Create the artifacts.</li>
<li>Create a container (optional).</li>
<li>Deploy the artifact(s) to a server (development/QA/staging/production).</li>
</ol>
<p>Now that we’ve defined a common pipeline, let’s dig deeper into each step to learn what each process includes when you’re building your software.</p>
<p>In the following subsections, we’ll examine each process in detail based on the steps defined here.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>Pulling Code</h2>
<p>Before we build<a id="_idIndexMarker054"/> the application, we need to identify the project we’re building in our pipeline. The pipeline service requires a repository location. Once you’ve provided the repository URL, the service can prepare the repository for compilation on their server.</p>
<p>In the previous section, we mentioned why your code needs to compile flawlessly after cloning. The code is cloned and built on a completely different machine from yours. If the application only works on your computer and no one else’s, as the saying goes, “We’ll have to ship your computer to all of our users.” While this is a humorous saying in the industry, it’s generally frowned upon when writing and deploying software in the real world.</p>
<p>Each of the DevOps services has its benefits. For example, Azure Pipelines can examine your repository and make assumptions based on the structure of your project.</p>
<p>After analyzing<a id="_idIndexMarker055"/> the project, it uses a file format called YAML (pronounced Ya-mel) to define how the project should be built. While YAML is now considered a standard in the industry, we won’t deep-dive into everything YAML encompasses. YAML functionality could be a book on its own.</p>
<p>Azure takes your project’s assumptions and creates a YAML template on how it should build your application.</p>
<p>It knows how to compile the application, identify whether a container is included in the project, and also retrieve NuGet packages before performing the build.</p>
<p>One last thing to mention is that most DevOp services allow one repository per project. The benefits of this approach include the following:</p>
<ul>
<li><strong class="bold">Simplicity</strong>: It’s simpler to manage and build one application as opposed to orchestrating hundreds of applications in a project.</li>
<li><strong class="bold">Collaboration</strong>: Instead of multiple teams focusing on one large project, it’s easier to have one or two smaller teams working on a single, more manageable project.</li>
<li><strong class="bold">Faster builds</strong>: CI/CD pipelines are meant to provide fast feedback and even faster improvement. The smaller the project, the faster a build, test, and deployment<a id="_idIndexMarker056"/> will occur.</li>
</ul>
<p>With that said, we are now ready to build the application.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>Building the application</h2>
<p>As mentioned previously, YAML files<a id="_idIndexMarker057"/> define how the service proceeds with building your application.</p>
<p>It’s always a good practice to confirm the YAML file contains everything you need before building. If you have a simple project, the boilerplate included in the wizard may be all you need, but it allows you to make updates in case additional files are required, or other application checks.</p>
<p>It may take a couple of attempts to massage the YAML file, but once you get the file in a stable state, it’s great to see everything work as expected.</p>
<p>Make sure you have retrieved all your code before building the application. If this step fails, the process kicks out of the pipeline.</p>
<p>If you checked in bad code and the build fails, the proper authorities (developers or administrators) will be notified based on the alert level and you’ll be given the dunce hat or the stuffed monkey for breaking the build until someone else breaks it.</p>
<p>Next, we’ll focus on running unit tests and other tests against the application.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Running Unit Tests/Code Analysis</h2>
<p>Once the build is done, we can move forward<a id="_idIndexMarker058"/> with the unit tests and/or code analysis.</p>
<p>Unit tests should run against the compiled application. This includes unit tests and integration tests, but as we mentioned previously, be wary of integration tests. The pipeline services may not have access to certain resources, causing your tests to fail.</p>
<p>Unit tests, by nature, should be extremely fast. Why? Because you don’t want to wait for 30 minutes for unit tests to run (which is painful). If you have unit tests taking that long, identify the longest-running unit tests and refactor them.</p>
<p>Once the code has been compiled and loaded, unit tests should be running every 10-30 seconds as a general guideline since they are memory-based.</p>
<p>While unit and integration<a id="_idIndexMarker059"/> tests are common in most testing scenarios, there are additional checks you can add to your pipeline, which include identifying security issues and code metrics to generate reports at the end of your build.</p>
<p>Next, our build creates artifacts to be used for deployments.</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/>Creating Artifacts</h2>
<p>Once the build succeeds<a id="_idIndexMarker060"/> and all of the tests pass, the next step is to create an artifact of our build and store it in a central location.</p>
<p>As a general rule, it’s best to only create your binaries once. Once they’ve been built, they’re available at a moment’s notice. These artifacts can deploy a version to a server on a whim without going through the entire build process again.</p>
<p>The artifacts should be tamper-proof and never be modified by anyone. If there is an issue with the artifact, the pipeline should start from the beginning and create a new artifact.</p>
<p>Let’s move on to containers.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>Creating a Container</h2>
<p>Once you have created<a id="_idIndexMarker061"/> the self-contained artifact, an <em class="italic">optional</em> step is to build a container around it or install the artifact in the container. While most enterprises use various platforms and environments, such as Linux or Windows, “containerizing” an application with a tool such as Docker allows it to run on any platform while isolating the application.</p>
<p>With containers considered a standard in the industry, it makes sense to create a container so that it can easily be deployed to any platform, such as Azure, <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), or Google Cloud Provider. Again, this is an optional step, but it’s becoming an inevitable one in the industry.</p>
<p>When creating a new project with Visual Studio, you automatically get a container wrapper through a generated Docker file. This Dockerfile defines how the container will allow access to your application.</p>
<p>Once you’ve added the Dockerfile to your project, Azure identifies this as a container project and creates the container<a id="_idIndexMarker062"/> with the included project.</p>
<p>Lastly, we’ll examine deploying the software.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor046"/>Deploying the software</h2>
<p>Once everything<a id="_idIndexMarker063"/> has been generated, all we need to do is deploy the software.</p>
<p>Remember the environment settings in your <code>appsettings.json</code> file? This is where they come in handy for deployments.</p>
<p>Based on your environment, you can assign a task to merge the appropriate environment JSON file into the <code>appsettings.json</code> file on deployment.</p>
<p>Once you have your environment settings in order, you can define the destinations of your deployments any way you like.</p>
<p>Deployments can range from FTP-ing or WebDeploy-ing the artifact or pushing the container to a server somewhere. All of these options are available out of the box.</p>
<p>However, you must deploy the same way to every environment. The only thing that changes is the <code>appsettings</code> file.</p>
<p>After a successful (or unsuccessful) deployment, a report or notification should be sent to everyone involved in the deployment’s outcome.</p>
<p>In this section, we learned what a common pipeline includes and how each step relies on a successful previous step. If one step fails throughout the pipeline, the process immediately stops. This “conveyor belt” approach to software development provides repeatable steps, quality-driven software, and deployable software.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor047"/>The Two “Falling” Approaches</h1>
<p>In this section, we’ll learn about two ways to recover from a failed software deployment. After finishing this section, you’ll know how to use these two approaches to make a justified decision on recovering from a bad deployment.</p>
<p>In a standard pipeline, companies sometimes experience software glitches when deploying to a web server. Users may see an error message when they perform an action on the website.</p>
<p>What do you do when the software doesn’t work as expected? How does this work in the DevOps pipeline?</p>
<p>Every time you build software, there’s always a chance something could go wrong. You always need a backup plan <em class="italic">before</em> the software is deployed.</p>
<p>Let’s cover the two types of recovery methods we can use when software deployments don’t succeed.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/>Falling Backward (or fallback)</h2>
<p>If various bugs were introduced<a id="_idIndexMarker064"/> into the product and the previous version doesn’t appear to have these errors, it makes sense to revert the software or fall back to the previous version.</p>
<p>In a pipeline, the process at the end creates artifacts, which are self-contained, deployable versions of your product.</p>
<p>Here is an example<a id="_idIndexMarker065"/> of falling backward:</p>
<ol>
<li>Your software deployment was a success last week and was marked as version 1.1 (v1.1).</li>
<li>Over 2 weeks, development created two new features for the software and wanted to release them as soon as possible.</li>
<li>A new build was created and released called version 1.3 (v1.3).</li>
<li>While users were using the latest version (v1.3), they experienced issues with one of the new features, causing the website to show errors.</li>
<li>Since the previous version (v1.1) doesn’t have this issue and the impact is not severe, developers can redeploy v1.1 to the server so that users can continue to be productive<a id="_idIndexMarker066"/> again.</li>
</ol>
<p>This type of release is called <strong class="bold">falling backward</strong>.</p>
<p>If you have to replace a current version (v1.3) with a previous version (v1.1) (except for databases, which I’ll cover in a bit), you can easily identify and deploy the last-known artifact.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/>Falling Forward</h2>
<p>If the fallback approach<a id="_idIndexMarker067"/> isn’t a viable recovery strategy, the alternative is to fall forward.</p>
<p>When falling forward, the product team accepts the deployment with errors (warts and all) and continues to move forward with newer releases while placing a high priority on these errors and <em class="italic">acknowledging the errors will be fixed in the next or </em><em class="italic">future release</em>.</p>
<p>Here is a similar example<a id="_idIndexMarker068"/> of falling forward:</p>
<ol>
<li>Again, a software deployment was successful last week and was marked as version 1.5 (v1.5).</li>
<li>Over another 2 weeks, development created another new large feature for the software.</li>
<li>A new build was created and released called version 1.6 (v1.6).</li>
<li>While users were using the latest version (v1.6), they experienced issues with one of the new features, causing the website to show errors.</li>
<li>After analysis, the developers realized this was a “quick fix,” created the proper unit tests to show it was fixed, pushed a new release through the pipeline, and immediately deployed the fixed code in a new release (v1.7).</li>
</ol>
<p>This type of release is called <strong class="bold">falling forward</strong>.</p>
<p>The product team may have to examine each error and make a decision as to which recovery method is the best approach for the product’s reputation.</p>
<p>For example, if product features such as business logic or user interface updates are the issue, the best recovery method may be to fall forward since the impact on the system is minimal and a user’s workflow is not interrupted and productive.</p>
<p>However, if code <em class="italic">and</em> database updates are involved, the better approach would be to fall back – that is, restore the database and use a previous version of the artifact.</p>
<p>If it’s a critical feature and reverting is not an option, a “hotfix” approach (as mentioned in the previous chapter) may be required to patch the software.</p>
<p>Again, it depends on the impact each issue has left on the system as to which recovery strategy is the best approach.</p>
<p>In this section, we learned <a id="_idIndexMarker069"/>about two ways to recover from unsuccessful software deployments: falling backward and falling forward. While neither option is a mandatory choice, each approach should be weighed heavily based on the error type, the recovery time of the fix, and the software’s deployment schedule.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Deploying Databases</h1>
<p>Deploying application code<a id="_idIndexMarker070"/> is one thing but deploying databases can be a daunting task if not done properly. There are two pain points when deploying databases: structure and records.</p>
<p>With a database’s structure, you have the issue of adding, updating, and removing columns/fields from tables, along with updating the corresponding stored procedures, views, and other table-related functions to reflect the table updates.</p>
<p>With records, the process isn’t as tricky as changing a table’s structure. The frequency of updating records is not as regular, but when it does, happen that’s when you either want to seed a database with default records or update those seed records with new values.</p>
<p>The following sections will cover some common practices when deploying databases in a CI/CD pipeline.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor051"/>Backing up Before Deploying</h2>
<p>Since company <a id="_idIndexMarker071"/>data is essential to a business, it’s mandatory to back it up before making any modifications or updates to the database.</p>
<p>One recommendation is to make the entire database deploy a two-step process: back up the database, then apply the database updates.</p>
<p>The DevOps team can include a pre-deployment script to <em class="italic">automatically</em> back up the database before applying the database updates. If the backup was successful, you can continue deploying your changes to the database. If not, you can immediately stop the deployment and determine the cause of failure.</p>
<p>As discussed in the previous section, this is necessary for a “fallback” approach instead of a “fall forward” strategy.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Creating a Strategy for Table Structures</h2>
<p>One strategy for updating a table<a id="_idIndexMarker072"/> is to take a non-destructive approach:</p>
<ul>
<li><strong class="bold">Adding a column</strong>: When adding columns, place a default value on the column for when a record is created. This will prevent the application from erroring out when you add a record, notifying the user that a field didn’t have a value or is required.</li>
<li><strong class="bold">Updating/renaming a column</strong>: Updating a column is a little different because you may be changing a data type or value in the database. If you’re changing the column name and/or type to something else, add a new column with the new column type, make sure you default the value, and proceed to use it in your application code. Once the code is solid and is performing as expected, remove the old column from the table and then from your code.</li>
<li><strong class="bold">Removing a column</strong>: There are several different ways to handle this process. If the field was created with a default value, make the appropriate changes in your application code to stop using the column. When records are added to the table, the default value won’t create an error. Once the application code has been updated, <em class="italic">rename</em> the column in the table instead of deleting it. If your code is still using it, you’ll be able to identify the code issue and fix it. Once your code is running without error, it’ll be safe to remove the column from your table.</li>
</ul>
<p>While making the appropriate<a id="_idIndexMarker073"/> changes to table structures, don’t forget about updating the additional database code to reflect the table changes, including stored procedures, views, and functions.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Creating a Database Project</h2>
<p>If your Visual Studio solution<a id="_idIndexMarker074"/> connects to a database, there’s another project<a id="_idIndexMarker075"/> type you need to add to your solution called the Database Project type. When you add this project to your solution, it takes a snapshot of your database and adds it to your project as code.</p>
<p>Why include this in your solution? There are three reasons to include it in your solution:</p>
<ol>
<li>It provides a database schema as T-SQL when you create a database from scratch.</li>
<li>It allows you<a id="_idIndexMarker076"/> to version your database, in keeping with the <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) paradigm.</li>
<li>When you’re building your solution in Visual Studio, it automatically generates a DAC file from your Database Project for deployment with the option to attach a custom script. With the DAC included in your solution, the pipeline can deploy and update the database with the DAC file first. Once the database deployment (and backup) is finished, the pipeline can deploy the artifact.</li>
</ol>
<p>As you can see, it’s pretty handy to include with your solution.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor054"/>Using Entity Framework Core’s Migrations</h2>
<p>Entity Framework<a id="_idIndexMarker077"/> has come a long way since<a id="_idIndexMarker078"/> its early days. Migrations are another way to include database changes through C# as opposed to T-SQL.</p>
<p>Upon creating a migration, Entity Framework Core takes a snapshot of the database and <code>DbContext</code> and creates the delta between the database schema and <code>DbContext</code> using C#.</p>
<p>With the initial migration, the entire C# code is generated with an <code>Up()</code> method.</p>
<p>Any subsequent migrations will contain an <code>Up()</code> method and a <code>Down()</code> method for upgrading and downgrading the database, respectively. This allows developers to save their database delta changes, along with their code changes.</p>
<p>Entity Framework Core’s migrations are an alternative to using DACs and custom scripts. These migrations can perform database changes based on the C# code.</p>
<p>If you require seed records, then you can use Entity Framework Core’s <code>.HasData()</code> method for easily creating seed records for tables.</p>
<p>In this section, we learned <a id="_idIndexMarker079"/>how to prepare our database deployment by always creating a backup, looked at a common strategy for adding, updating, and deleting table fields, and learned<a id="_idIndexMarker080"/> how to deploy databases in a CI/CD pipeline using either a DAC or Entity Framework Core’s migrations.</p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor055"/>The three Types of Build Providers</h1>
<p>Now that we’ve learned how a standard pipeline works, in this section, we’ll look at the different types of pipeline providers.</p>
<p>The three types of providers are on-premises, off-premises, and hybrid.</p>
<p><strong class="bold">On-premises</strong> (meaning on-site or on-premises) relates to the software<a id="_idIndexMarker081"/> you own, which you can use to build your product at your company’s location. An advantage of on-premises build services is that once you purchase the software, you own it; there isn’t a subscription fee. So, if there’s a problem with the build server, you can easily look at the software locally to identify and fix the problem.</p>
<p><strong class="bold">Off-premises</strong> (or cloud) providers are the more common<a id="_idIndexMarker082"/> services used nowadays. Since everyone wants everything yesterday, it’s quicker to set up and is usually an immediate way to create a software pipeline.</p>
<p>As you can guess, <strong class="bold">hybrid services</strong> are a mix of on-premises and off-premises services. Some companies like to keep<a id="_idIndexMarker083"/> control of certain aspects of software development and send the artifacts to a remote server for deployment purposes.</p>
<p>While hybrid services<a id="_idIndexMarker084"/> are an option, it makes more sense to use off-premises services for automated software builds.</p>
<p>In this section, we learned about three types of providers: on-premises, off-premises, and hybrid services. While these services are used in various companies, the majority of companies lean toward off-premises (or cloud) services to automate their software builds.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor056"/>CI/CD Providers</h1>
<p>In this section, we’ll review<a id="_idIndexMarker085"/> a current list of providers on the internet to help you automate your builds. While there are other providers available, these are considered what developers use in the industry as a standard.</p>
<p>Since we are targeting ASP.NET Core, rest assured, each of these providers supports ASP.NET Core in its build processes and deployments.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>Microsoft Azure Pipelines</h2>
<p>Since Microsoft created ASP.NET Core, it only<a id="_idIndexMarker086"/> makes sense to mention its off-premises<a id="_idIndexMarker087"/> cloud offerings. It does offer on-premises and hybrid support as well. Azure Pipelines provides the most automated support for ASP.NET Core applications and deployment mechanisms to date.</p>
<p>While Azure is considered one of the biggest cloud providers in the world, I consider Azure Pipelines a small component under the Azure moniker.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can learn<a id="_idIndexMarker088"/> more about Azure Pipelines here: <a href="https://azure.microsoft.com/en-us/products/devops/pipelines/">https://azure.microsoft.com/en-us/products/devops/pipelines/</a>.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>GitHub Actions</h2>
<p>When Microsoft<a id="_idIndexMarker089"/> purchased GitHub back in June of 2018, GitHub came out with an automation pipeline with GitHub Actions in October of the same year.</p>
<p>Since GitHub is a provider of all things source code-related, GitHub Actions was considered an inevitable step toward making code deployable.</p>
<p>After signing up to Actions, you’ll notice the screens are very “Azure-ish” and provide a very similar interface when you’re building software pipelines.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can learn more about GitHub Actions here: <a href="https://github.com/features/actions">https://github.com/features/actions</a>.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Amazon CodePipeline</h2>
<p>With Amazon commanding<a id="_idIndexMarker090"/> a large lead in the e-commerce landscape<a id="_idIndexMarker091"/> and with its Amazon Web Services (AWS offering), it also provides automated pipelines for developers.</p>
<p>Its pipelines are broken down into categories:</p>
<ul>
<li><code>CodeCommit</code>: For identifying source code repositories</li>
<li><code>CodeArtifact</code>: A centralized location for build artifacts</li>
<li><code>CodeBuild</code>: A dedicated service for building your product based on updates in your repository, which are defined in <code>CodeCommit</code></li>
<li><code>CodeDeploy</code>: For managing environments for deploying software</li>
<li><code>CodePipelne</code>: The glue that holds it all together</li>
</ul>
<p>You can pick and choose the services you need based on your requirements. Amazon CodePipeline is similar to most cloud services, where you can use one service or all of them.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can learn more about<a id="_idIndexMarker092"/> Amazon CodePipeline here: <a href="https://aws.amazon.com/codepipeline/">https://aws.amazon.com/codepipeline/</a>.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>Google CI</h2>
<p>The final cloud provider<a id="_idIndexMarker093"/> is none other than Google CI. Google CI also provides the tools<a id="_idIndexMarker094"/> required to perform automated builds and deployments.</p>
<p>Google CI provides similar tools, such as Artifact Registry, source repositories, Cloud Build, and even private container registries.</p>
<p>As mentioned previously, once you understand how one cloud provider works, you’ll start to see similar offerings in other cloud providers.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can learn more<a id="_idIndexMarker095"/> about Google CI here: <a href="https://cloud.google.com/solutions/continuous-integration">https://cloud.google.com/solutions/continuous-integration</a>.</p>
<p>In this section, we examined four CI/CD cloud providers: Microsoft’s Azure Pipelines, GitHub Actions, Amazon’s CodePipeline, and Google’s CI. Any one of these providers is a suitable candidate for creating an ASP.NET Core pipeline.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor061"/>Walkthrough of Azure Pipelines</h1>
<p>With everything we’ve discussed <a id="_idIndexMarker096"/>so far, this section will take us through a standard pipeline with a web application every developer should be familiar with: the ASP.NET Core web application.</p>
<p>If you have a web application of your own, you’ll be able to follow along and make the modifications to your web application as well.</p>
<p>In this section, we’ll demonstrate what a pipeline consists of by considering a sample application and walking through all of the components that will make it a successful build.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Preparing the Application</h2>
<p>Before we move forward, we need<a id="_idIndexMarker097"/> to confirm whether the application in our version control is ready for a pipeline:</p>
<ul>
<li>Does the application compile and clone without errors?</li>
<li>Do <em class="italic">all</em> the unit tests that accompany the application pass?</li>
<li>Do you have the correct environment settings in your application? (For example, <code>appsettings.json</code>, <code>appsettings.qa.json</code>, and so on.)</li>
<li>Will you deploy this application to a Docker container? If so, confirm you have a Dockerfile in the root of your application.</li>
</ul>
<p>Again, the Dockerfile is optional, but most companies include one since they have numerous environments running on different operating systems. We’ll include the Dockerfile in our web application to complete the walkthrough.</p>
<p>Once everything has been confirmed in our checklist, we can move forward and create our pipeline.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Introducing Azure Pipelines</h2>
<p>Azure Pipelines is a free service<a id="_idIndexMarker098"/> for developers to use to automate, test, and deploy their software to any platform.</p>
<p>Since Azure is user-specific, you’ll have to log in to your<a id="_idIndexMarker099"/> Azure Pipelines account or create a new one at <a href="https://azure.microsoft.com/en-us/products/devops/pipelines/">https://azure.microsoft.com/en-us/products/devops/pipelines/</a>. Don’t worry – it’s free to sign up and create pipelines:</p>
<ol>
<li>To continue with this walkthrough, click on the <strong class="bold">Start free with GitHub</strong> button, as shown in <em class="italic">Figure 2</em><em class="italic">.2</em>:</li>
</ol>
<div><div><img alt="Figure 2.2 – The Azure Pipelines web page" src="img/Figure_2.02_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The Azure Pipelines web page</p>
<p>Once you’ve logged in to Azure Pipelines, you are ready to create a project.</p>
<ol>
<li value="2">Click <strong class="bold">New Project</strong> in the top right-hand corner. Enter details for <strong class="bold">Project Name</strong> and <strong class="bold">Description</strong> and determine whether it’s <strong class="bold">Private</strong> or <strong class="bold">Public</strong>.</li>
<li>Upon clicking <strong class="bold">Create</strong>, we need<a id="_idIndexMarker100"/> to define which repository to use in our pipeline.</li>
</ol>
<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>Identifying the Repository</h2>
<p>We haven’t designated<a id="_idIndexMarker101"/> a repository for Azure Pipelines to use yet. So, we need to import an existing repository:</p>
<ol>
<li> If you click on any option under <strong class="bold">Files</strong>, you’ll notice a message saying <strong class="bold">&lt;YourProjectNameHere&gt; is empty. Add some code!</strong>. Sounds like solid advice.</li>
<li>Click on the <strong class="bold">Import</strong> button under the <strong class="bold">Import a repository</strong> section, as shown in <em class="italic">Figure 2</em><em class="italic">.3</em>:</li>
</ol>
<div><div><img alt="Figure 2.3 – Importing a repository" src="img/Figure_2.03_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Importing a repository</p>
<ol>
<li value="3">Clicking on the <strong class="bold">Import</strong> button<a id="_idIndexMarker102"/> will result in a side panel popping out, asking where your source<a id="_idIndexMarker103"/> code is located. Currently, there is only Git and <strong class="bold">Team Foundation Version </strong><strong class="bold">Control</strong> (<strong class="bold">TFVC</strong>).</li>
<li>Since the code for <code>DefaultWebApp</code> is in Git, I copied the clone URL and pasted it into the text box, and then clicked the <strong class="bold">Import</strong> button at the bottom of the side panel, as shown in <em class="italic">Figure 2</em><em class="italic">.4</em>:</li>
</ol>
<div><div><img alt="Figure 2.4 – Identifying the repository Azure Pipelines will use" src="img/Figure_2.04_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Identifying the repository Azure Pipelines will use</p>
<p>Azure Pipelines will proceed to import the repository. The next screen will be the standard <strong class="bold">Explorer</strong> view everyone is used to seeing, with a tree view on the left of your repository and a detailed<a id="_idIndexMarker104"/> list of files from the current directory on the right-hand side.</p>
<p>With that, we have finished importing the repository into Azure Pipelines.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Creating the Build</h2>
<p>Now that we’ve imported<a id="_idIndexMarker105"/> our repository, Azure Pipelines makes this process extremely easy for us by adding a button called <strong class="bold">Set up build</strong>, as shown in <em class="italic">Figure 2</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 2.5 – Imported repository with a “Set up build” button as the next step" src="img/Figure_2.05_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Imported repository with a “Set up build” button as the next step</p>
<p>As vast as Azure Pipelines’ features can be, there are several preset templates to use for your builds. Each template pertains to a particular project in the .NET ecosystem, along with not-so-common projects as well:</p>
<ol>
<li>For our purposes, we’ll select the <strong class="bold">ASP.NET Core (.NET </strong><strong class="bold">Framework)</strong> option.</li>
<li>After the <strong class="bold">Configure</strong> step in our wizard (see the top?), we will come to the <strong class="bold">Review</strong> step, where we can examine the YAML file.</li>
<li>With that said, you aren’t excluded from adding tasks at any time. There is <strong class="bold">Show Assistant</strong> to help you with adding new tasks to your existing YAML file.</li>
</ol>
<p>For the DefaultWebApp example, we don’t need<a id="_idIndexMarker106"/> to update our YAML file because we don’t have any changes; this is because we want something very simple to create our build. The default YAML file looks like this:</p>
<pre class="source-code">
# ASP.NET Core (.NET Framework)
# Build and test ASP.NET Core projects targeting the full .NET Framework.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core
trigger:
- master
pool:
  vmImage: 'windows-latest'
variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'
steps:
- task: NuGetToolInstaller@1
- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(solution)'
- task: VSBuild@1
  inputs:
    solution: '$(solution)'
    msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:DesktopBuildPackageLocation="$(build.artifactStagingDirectory)\WebApp.zip" /p:DeployIisAppPath="Default Web Site"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'
- task: VSTest@2
  inputs:
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'</pre> <p>This new file that Azure Pipelines created is called <code>azure-pipelines.yml</code>. So, where does this new <code>azure-pipelines.yml</code> file reside when it’s created? It’s committed to the root of your repository. Once we’ve confirmed everything looks good in the YAML file, we can click the <strong class="bold">Save and </strong><strong class="bold">run</strong> button.</p>
<p>Once you’ve done this, a side panel <a id="_idIndexMarker107"/>will appear, asking you for a commit message and optional description, as well as to specify options on whether to commit directly to the master branch or create a new branch for this commit. Once you’ve clicked the <strong class="bold">Save and run</strong> button at the bottom of the side panel, it will commit your new YAML file to your repository and execute the pipeline immediately.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>Creating the Artifacts</h2>
<p>Once the build<a id="_idIndexMarker108"/> is running, you’ll see something similar to <em class="italic">Figure 2</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 2.6 – Queueing up our DefaultWebApp build process" src="img/Figure_2.06_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Queueing up our DefaultWebApp build process</p>
<p>As shown at the bottom of the preceding screenshot, my job’s status is <strong class="bold">Queued</strong>. Once it’s out of the queue and executing, you can watch the builds progress by clicking on <strong class="bold">Job</strong> next to the blue clock at the bottom.</p>
<p>In terms of <strong class="bold">DefaultWebApp</strong>, this is what the build process looks as seen in <em class="italic">Figure 2</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 2.7 – The build progress of DefaultWebApp" src="img/Figure_2.07_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – The build progress of DefaultWebApp</p>
<p>Congratulations! You have created a successful pipeline and artifact.</p>
<p>For the sake of not writing<a id="_idIndexMarker109"/> an entire book on Azure Pipelines, next, we will move on to creating releases.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor067"/>Creating a Release</h2>
<p>With a completed and successful<a id="_idIndexMarker110"/> build, we can now focus on releasing our software. Follow these steps:</p>
<ol>
<li>If you click on <strong class="bold">Releases</strong>, you’ll see we need to create a new release pipeline. Click the <strong class="bold">New </strong><strong class="bold">Pipeline</strong> button.</li>
<li>Immediately, you’ll see a side panel appear with a list of templates you can choose from. Select <strong class="bold">Empty job</strong> at the top of the side panel, as shown in <em class="italic">Figure 2</em><em class="italic">.8</em>:</li>
</ol>
<div><div><img alt="Figure 2.8 – Selecting an empty job template" src="img/Figure_2.08_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Selecting an empty job template</p>
<p>There is a term in <strong class="bold">Releases</strong> called <strong class="bold">Stages</strong> where your software can go through several stages before it’s sent to the final stage. These stages can also be synonymous with environments. These stages include development, QA, staging, and production. Once one stage has been approved (development), it moves to the next stage (QA) until the final one, which is usually production. However, these stages can get extremely complicated.</p>
<ol>
<li value="3">After you click the <strong class="bold">Apply</strong> button, you will see another side panel where you can define your stage. Since we are simply<a id="_idIndexMarker111"/> deploying the website, we’ll call this the <strong class="bold">Push to </strong><strong class="bold">Site</strong> stage.</li>
<li>After entering your <strong class="bold">Stage</strong> name (that just doesn’t sound right), click the <strong class="bold">X</strong> button to close the side panel and examine the pipeline.</li>
</ol>
<p>As shown in <em class="italic">Figure 2</em><em class="italic">.9</em>, we need to add an artifact:</p>
<div><div><img alt="Figure 2.9 – The Push ﻿to Site stage is defined, but there’s no artifact" src="img/Figure_2.09_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – The Push to Site stage is defined, but there’s no artifact</p>
<ol>
<li value="5">When you click <strong class="bold">Add an Artifact</strong>, another side panel will slide open and ask you to add the artifact. Since we created<a id="_idIndexMarker112"/> an artifact in the previous subsection, we can populate all of our inputs with the <strong class="bold">DefaultWebApp</strong> project and source, as shown in <em class="italic">Figure 2</em><em class="italic">.10</em>:</li>
</ol>
<div><div><img alt="Figure 2.10 – Adding the DefaultWebApp artifact to our release pipeline" src="img/Figure_2.10_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Adding the DefaultWebApp artifact to our release pipeline</p>
<ol>
<li value="6">Click <strong class="bold">Add</strong> to add your artifact<a id="_idIndexMarker113"/> to the pipeline.</li>
</ol>
<h2 id="_idParaDest-67"><a id="_idTextAnchor068"/>Deploying the Build</h2>
<p>Once we have defined<a id="_idIndexMarker114"/> our stages, we can attach certain deployment conditions, both before and after, to each stage. The ability to define post-deployment approvals, gates, and auto-redeploy triggers is possible but disabled by default for each stage.</p>
<p>In any stage, you can add, edit, or remove any task you want by clicking on the “x job, x tasks” link under each stage’s name, as shown in <em class="italic">Figure 2</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 2.11 – Stages allow you to add any number of tasks" src="img/Figure_2.11_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Stages allow you to add any number of tasks</p>
<p>Each stage has an agent job, which can perform any number of tasks. The list of tasks to choose from is mind-numbing. If you can think of it, there is a task for it.</p>
<p>For example, we can deploy a website using Azure, IIS Web Deploy, or even simply a file that’s been copied from one directory to another. Want to FTP the files over to a server? Click on the <strong class="bold">Utility</strong> tab and find <strong class="bold">FTP Upload</strong>.</p>
<p>Each task you add has parameters per topic and can easily be modified to suit a developer’s requirements.</p>
<p>In this section, we covered how to create a pipeline by preparing the application to meet certain requirements. We did this by introducing Azure Pipelines by logging in and adding our sample project, identifying the repository we’ll be using in our pipeline, and creating the build. Once we’d done<a id="_idIndexMarker115"/> this, we found our artifacts, created a release, and found a way to deploy the build.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor069"/>Summary</h1>
<p>In this chapter, we identified ways to prepare our code for a CI/CD pipeline so that we can build flawlessly, avoid relative path names with file-based operations, confirm our unit tests <em class="italic">are</em> unit tests, and create environment settings for our application. Once our code was ready, we examined what’s included in a common CI/CD pipeline, including a way to pull the code, build it, run unit tests with optional code analysis, create artifacts, wrap our code in a container, and deploy an artifact.</p>
<p>We also covered two ways to recover from a failed deployment using a fall-back or fall-forward approach. Then, we discussed common ways to prepare for deploying a database, which includes backing up your data, creating a strategy for modifying tables, adding a database project to your Visual Studio solution, and using Entity Framework Core’s migrations so that you can use C# to modify your tables.</p>
<p>We also reviewed the three types of CI/CD providers: on-premises, off-premises, and hybrid providers, with each one specific to a company’s needs, and then examined four cloud providers who offer full pipeline services: Microsoft’s DevOps Pipelines, GitHub Actions, Amazon’s CodePipeline, and Google’s CI.</p>
<p>Finally, we learned how to create a sample pipeline by preparing the application so that it meets certain requirements, logging in to Azure Pipelines and defining our sample project, identifying the repository we’ll be using in our pipeline, and creating the build. Once the build was complete, it generated our artifacts, and we learned how to create a release and find a way to deploy the build.</p>
<p>In the next chapter, we’ll learn about some of the best approaches for using middleware in ASP.NET Core.</p>
</div>
</body></html>