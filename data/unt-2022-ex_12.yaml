- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Completing the Adventure Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成冒险游戏
- en: In [*Chapter 8*](B18347_08.xhtml#_idTextAnchor151), we started by creating a
    flexible health system that can be added to any object to give it health, take
    damage, and heal. The system is extensible, meaning the things that can deal with
    damage and apply healing can be anything without the need to modify the `HealthSystem`
    class because we used interfaces to implement the behavior (not concrete class
    types). With objects now able to take damage, we continued by updating `Player`
    and enemy objects to use health – so, we have the semblance of a real game in
    the making.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18347_08.xhtml#_idTextAnchor151)中，我们首先创建了一个灵活的生命值系统，该系统可以被添加到任何对象中，使其具有生命值、受到伤害和恢复健康的功能。该系统是可扩展的，这意味着能够处理伤害和施加治疗的事物可以是任何东西，而无需修改`HealthSystem`类，因为我们使用了接口来实现行为（而不是具体的类类型）。现在对象能够受到伤害后，我们继续更新`Player`和敌人对象以使用生命值——因此，我们正在制作一个正在形成的真实游戏。
- en: We continued by creating a wave spawner that instantiates new enemies on a fixed
    time interval and integrates with the existing patrol behavior. This allows us
    to add more complex enemy behavior, which adds new challenges to the game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续创建一个波次生成器，在固定的时间间隔实例化新的敌人，并与现有的巡逻行为集成。这使我们能够添加更复杂的敌人行为，从而为游戏增加新的挑战。
- en: Finally, we further explored composition by refactoring some of our reusable
    components to explore a different approach to destroying the heal pickup object.
    The importance of good programming practices and interfaces to build flexible
    and extensible systems was highlighted through examples.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过重构一些可重用组件来进一步探索破坏治疗拾取对象的不同方法。通过示例强调了良好编程实践和接口在构建灵活和可扩展系统中的重要性。
- en: In this chapter, we’ll complete the adventure game by creating a simple quest
    system for collecting key pieces in the level that are required for solving an
    entryway security puzzle lock on the habitat station located on the planet’s surface.
    We will also introduce a new global event system for keeping our code loosely
    coupled. The event system will efficiently manage communication between various
    quest system components throughout the code base, so we’ll tackle that first.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过创建一个简单的寻宝系统来收集关卡中解决位于星球表面栖息地站入口安全锁所需的钥匙来完成冒险游戏。我们还将引入一个新的全局事件系统，以保持我们的代码松散耦合。该事件系统将有效地管理代码库中各个寻宝系统组件之间的通信，因此我们首先处理这个问题。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Creating an event system in C# to tie things together loosely
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#创建一个事件系统以松散地绑定事物
- en: Creating a quest system for a collecting keys mission
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为收集钥匙任务创建寻宝系统
- en: Solving the key puzzle and winning the game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决钥匙谜题并赢得游戏
- en: By the end of this chapter, you’ll be able to create a quest system that is
    integrated across different classes while being loosely coupled (that is, reducing
    dependency by not having external (concrete) class references) and scalable via
    the use of a new reusable global event system we’ll also create. You’ll also be
    able to integrate and customize a puzzle system for your use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建一个跨不同类集成的寻宝系统，同时保持松散耦合（即，通过不使用外部（具体）类引用来减少依赖），并通过使用我们将创建的新可重用全局事件系统来实现可扩展性。你还将能够集成和定制一个用于你自己的谜题系统。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along in this chapter while using the same artwork that was created
    for the project in this book, download the assets from the GitHub link provided
    in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本章中使用与本书项目中创建的相同艺术作品，请从本节提供的GitHub链接下载资源。
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop. Alternatively, you’ll need a graphics program that can
    export layered Photoshop PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and
    Affinity Photo).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随自己的艺术作品，你需要使用Adobe Photoshop创建类似的艺术作品。或者，你需要一个能够导出分层Photoshop PSD/PSB文件的图形程序（例如，Gimp、MediBang
    Paint、Krita和Affinity Photo）。
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub下载完整项目，链接为[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Creating an event system in C# to tie things together loosely
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C#创建一个事件系统以松散地绑定事物
- en: We won’t need a UML diagram here as the design is quite simple. We’ll use a
    `Dictionary` collection (a special kind of C# collection) to hold the name of
    an event that we’ll assign the event’s callback handlers. The added callback handlers
    will all be invoked when the event is triggered. Although I say this is simple,
    I didn’t introduce it earlier because a few programming concepts still needed
    to be covered first.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们不需要 UML 图，因为设计相当简单。我们将使用 `Dictionary` 集合（一种特殊的 C# 集合）来存储我们分配的事件名称，并将事件回调处理程序添加到其中。当事件被触发时，所有添加的回调处理程序都将被调用。尽管我说这很简单，但我之前没有介绍它，因为还需要先介绍一些编程概念。
- en: The new event system
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的事件系统
- en: 'Since a UML diagram won’t illustrate the functionality of `EventSystem` very
    well in this case, I’ve decided to create the following diagram as an introduction
    to the implementation (see *Figure 9**.1*):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 UML 图在这种情况下无法很好地说明 `EventSystem` 的功能，我决定创建以下图作为实现介绍的起点（见图 *9**.1*）：
- en: '![Figure 9.1 – EventSystem diagram](img/B18347_09_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – EventSystem 图](img/B18347_09_1.jpg)'
- en: Figure 9.1 – EventSystem diagram
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – EventSystem 图
- en: Before looking at the following code, do a quick mental exercise to see if you
    can visualize what the code should look like from this diagram.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看以下代码之前，先进行一下快速的心理练习，看看你是否能从这个图中想象出代码应该是什么样子。
- en: Given this diagram, here is the class template that makes up the basis for our
    new event system, minus some details we haven’t covered yet; is it similar to
    what you anticipated seeing?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个图，这是构成我们新事件系统基础类的模板，省略了一些我们尚未覆盖的细节；它是否与你预期的相似？
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You didn’t necessarily know what the `Dictionary` declaration would be – we
    haven’t covered it yet – but you at least knew that we needed a declaration for
    it, right?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不知道 `Dictionary` 的声明会是什么样子——我们还没有介绍它——但你至少知道我们需要为它声明，对吧？
- en: 'We have a few additional things to unpack here and introduce some new C# items,
    including `Dictionary`, `Delegate`, and generic types (as you’ve probably noticed,
    `<T>` and `T` sprinkled throughout the code):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还有一些额外的事情要解释，并介绍一些新的 C# 项目，包括 `Dictionary`、`Delegate` 和泛型类型（正如你可能注意到的，`<T>`
    和 `T` 在代码中随处可见）：
- en: '`Dictionary<string, Delegate>`: A C# `Dictionary` is a collection type that
    contains a list of `List`, a collection type that contains a single list of a
    type.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<string, Delegate>`：C# 的 `Dictionary` 是一种包含 `List` 的集合类型，而 `List`
    是一种包含单个列表的集合类型。'
- en: Let’s put this into some game development terms… a C# `Dictionary` is kind of
    like a magic bag where you can store lots of items and find anything you want,
    so long as it has a unique name. You can keep track of all the cool stuff your
    player will need on their adventure, keeping your game organized and awesome!
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们把这个问题用游戏开发术语来解释……C# 的 `Dictionary` 类似于一个魔法袋，你可以存储很多物品，只要它们有一个独特的名称，你就可以找到任何你想要的。你可以跟踪玩家在冒险中需要的所有酷炫物品，让你的游戏保持组织性和酷炫性！
- en: '`string` type, which indicates the key type for the item in the dictionary.
    We’ll set the key to identify the specific event by name, and the event handler
    methods will be *added* *to it*.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 类型，表示字典中项的键类型。我们将键设置为通过名称标识特定事件，并将事件处理程序方法添加到其中。'
- en: '`Delegate` type and is the value being stored for the specific key item. We’ll
    set the value to a delegate type, such as `UnityAction`, that can have method
    handlers added to it (note that here, `delegate` is the base type for `UnityAction`).
    The event can be triggered later by the event’s name, invoking all the assigned
    event handler methods. Simples!'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delegate` 类型，并且是存储在特定键项中的值。我们将值设置为可以添加方法处理器的委托类型，例如 `UnityAction`（注意，在这里，`delegate`
    是 `UnityAction` 的基类型）。事件可以通过事件名称触发，调用所有分配的事件处理程序方法。简单！'
- en: '`Dictionary`, we can assign a new empty dictionary by specifying just the `new`
    keyword. This is new for C# in Unity 2022.2 since previously, you’d have to specifically
    restate `Dictionary` and the types for *key* and *value* again here – but you’d
    still have to do this for serialized variables assignable in the **Inspector**
    view!'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary`，我们可以通过指定 `new` 关键字来分配一个新的空字典。这是 C# 在 Unity 2022.2 中的新特性，因为在之前，你不得不在这里再次明确地重述
    `Dictionary` 以及键和值的类型——但你还必须为在 **Inspector** 视图中可序列化的变量做同样的事情！'
- en: Dictionary (C#)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 字典（C#）
- en: '**Dictionary** represents a collection of keys and values. It has similar properties
    and methods compared to a **List** collection type. For additional reading, go
    to [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典**表示键值对的集合。它与**列表**集合类型具有相似的性质和方法。有关更多信息，请参阅[https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0)。'
- en: '`AddListener()`: We’ll call this method when we add an event to `EventSystem`.
    The method signature has the following parameters:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddListener()`: 当我们向`EventSystem`添加事件时，我们将调用此方法。方法签名具有以下参数：'
- en: '`<T>`: In C#, there is a programming concept called `T` represents *any type*
    as a generic type parameter. This allows you to define a method, class, parameter,
    or something else that can work with any type specified by the calling code, such
    as `string`, `int`, `float`, `Vector3`, `GameObject`, and so on. This allows reuse
    across different parts of the code without the need to use specific types and
    repeat the same code to support those types. It may sound a bit complicated this
    early on, but I hope it is understandable through the preceding example.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T>`: 在C#中，有一个名为`T`的编程概念，它代表*任何类型*作为泛型类型参数。这允许你定义一个方法、类、参数或其他可以与调用代码指定的任何类型一起工作的东西，例如`string`、`int`、`float`、`Vector3`、`GameObject`等。这允许在不同的代码部分之间重用，而无需使用特定类型并重复相同的代码来支持这些类型。这听起来可能有点复杂，但希望通过前面的示例可以理解。'
- en: Our use case for a generic type is to implement an event delegate that can pass
    in any type as an argument. This will become clearer as we work through the rest
    of `EventSystem`.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用泛型类型的用例是实现一个可以传递任何类型作为参数的事件委托。随着我们继续处理`EventSystem`的其余部分，这将会变得更加清晰。
- en: '`eventName`: A `string` type that uniquely identifies the event that’s been
    *registered* with `EventSystem`. It’s how we add additional listeners to a specific
    event and how we know what event to trigger.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eventName`: 一个`string`类型的字符串，用于唯一标识已与`EventSystem`注册的事件。这是我们向特定事件添加额外监听器以及我们知道要触发哪个事件的方式。'
- en: '`listener`: `UnityAction<T>`, which is the event delegate. `UnityAction` should
    be familiar since it was first introduced in [*Chapter 3*](B18347_03.xhtml#_idTextAnchor058),
    as an event listener that was used to update the UI. The difference here is that
    we are adding a generic parameter of the `T` type, which means the handler method
    can pass a single argument of any type when invoked.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listener`: `UnityAction<T>`，这是事件委托。`UnityAction`应该很熟悉，因为它首次在[*第三章*](B18347_03.xhtml#_idTextAnchor058)中介绍，作为一个用于更新UI的事件监听器。这里的区别在于我们添加了一个`T`类型的泛型参数，这意味着处理方法在调用时可以传递任何类型的单个参数。'
- en: '`RemoveListener()`: This is used when removing an event from `EventSystem`.
    The method signature is the same as that for `AddListener()`, so we don’t need
    to repeat ourselves here. However, there will be one glaringly obvious difference:
    we’ll be removing a method handler instead of adding one.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveListener()`: 这用于从`EventSystem`中删除事件。方法签名与`AddListener()`的签名相同，因此我们在这里不需要重复。然而，将有一个明显不同的地方：我们将删除一个方法处理程序而不是添加一个。'
- en: '`TriggerEvent()`: We’ll call this method when we want to invoke the specific
    event for which method handlers were added as listeners (via `AddListeners()`,
    of course). The method signature has the following parameters:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TriggerEvent()`: 当我们想要调用已通过`AddListeners()`添加方法处理程序作为监听器（当然）的特定事件时，我们将调用此方法。方法签名具有以下参数：'
- en: '`eventName`: Again, this is the event name string we’ll specify for invoking
    the method handlers (that is, the added listeners).'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eventName`: 同样，这是我们将用于调用方法处理程序（即添加的监听器）的事件名称字符串。'
- en: '`T arg`: The parameter value we’ll pass into the invoked methods that will
    be handled so that they can receive and process any required data. Again, being
    a generic type, `T`, we’ll be able to pass in an argument of any type (nice, right?).'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T arg`: 我们将传递给被调用方法的参数值，以便它们可以接收和处理所需的数据。再次强调，由于`T`是一个通用类型，我们可以传递任何类型的参数（不错，对吧？）。'
- en: In the preceding code, I said *event name*, but we won’t do something as silly
    as using string literals for the event names throughout the code base. Instead,
    let’s create an `EventConstants` class that we’ll use for the event names. This
    would be similar to how we added a `Tags` class when referencing tags assigned
    to our objects in the game through code (for example, `Player`).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我说的是 *事件名称*，但我们不会在整个代码库中使用字符串字面量来表示事件名称，这样做太愚蠢了。相反，让我们创建一个 `EventConstants`
    类，我们将使用它来表示事件名称。这就像我们在代码中通过添加 `Tags` 类来引用分配给游戏对象的标签时所做的（例如，`Player`）。
- en: 'Let’s define our first event name constant by creating the following `EventConstants`
    class, saved in the `Assets/Scripts/Systems` folder:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建以下 `EventConstants` 类来定义我们的第一个事件名称常量，该类保存在 `Assets/Scripts/Systems` 文件夹中：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The event name will be the *constant* (figuratively and literally) that loosely
    ties things together, so we don’t require concrete class references between classes
    that would observe and respond to events. Now, we can independently test our classes
    – via `Player` doesn’t need to specify a reference to `UIManager`, `Enemy`, and
    so on. We can also move a class to a new project without worrying about bringing
    in unnecessary classes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称将是 *常量*（在字面意义上和比喻意义上）将事物松散地联系在一起，所以我们不需要在观察和响应事件的类之间有具体的类引用。现在，我们可以独立测试我们的类——通过
    `Player` 不需要指定对 `UIManager`、`Enemy` 等的引用。我们还可以将一个类移动到新的项目中，而不用担心引入不必要的类。
- en: 'Now that we’ve learned about the event system template, as well as how we’ll
    specify events, let’s dig into the specifics of the implemented methods: `AddListener()`,
    `RemoveListener()`, and `TriggerEvent()`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了事件系统模板以及我们将如何指定事件，让我们深入了解实现的方法的具体细节：`AddListener()`、`RemoveListener()`
    和 `TriggerEvent()`。
- en: Event management methods
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件管理方法
- en: 'First, let’s look at the `AddListener()` method. To recap, `AddListener()`
    is responsible for adding an event to the dictionary of events if it doesn’t already
    exist (that is, registering the event) and adding the listener to the event’s
    handler method `delegate`, like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `AddListener()` 方法。为了回顾，`AddListener()` 负责将事件添加到事件字典中（如果它尚未存在，即注册事件），并将监听器添加到事件的处理方法
    `delegate` 中，如下所示：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break down the code here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这里的代码：
- en: '`ContainsKey()`: The very first thing we’ll need to do when adding an event
    to our dictionary of events is to see if we’ve already registered one of the same
    event names (pretty logical, right?). A C# `Dictionary` provides several methods
    here – similar to a C# `List` in many ways – for achieving this base functionality
    that we can leverage.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContainsKey()`：在我们将事件添加到事件字典时，我们首先需要做的是查看是否已经注册了相同名称的事件（这很合乎逻辑，对吧？）。C# `Dictionary`
    提供了几个方法来实现这一基本功能，这就像 C# `List` 一样，我们可以利用这些方法。'
- en: Specifically, we use `ContainsKey()` and pass in `eventName`. This will return
    a Boolean value of `true` if the key already exists in the dictionary and `false`
    if not, so we can use an `if` statement to evaluate and take the proper action.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具体来说，我们使用 `ContainsKey()` 并传入 `eventName`。如果键已经在字典中存在，这将返回一个布尔值 `true`，如果不存在则返回
    `false`，因此我们可以使用 `if` 语句来评估并采取适当的行动。
- en: '`Add()`: Working with the result returned from `ContainsKey()`, we’ll go ahead
    and add the event – using the event name as the key – to the dictionary using
    the `Add()` method (again, similar to C# `List`).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add()`：通过处理 `ContainsKey()` 返回的结果，我们将使用 `Add()` 方法（再次，类似于 C# `List`）将事件——使用事件名称作为键——添加到字典中。'
- en: Note that for the value parameter – as in `Add(key, value)` – we’re specifying
    `null` for the delegate. That’s simply because we’ll assign the listener to the
    delegate in the following line, where it doesn’t matter whether this event was
    just added.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，对于值参数——就像在 `Add(key, value)` 中——我们为委托指定了 `null`。这仅仅是因为我们将在下一行将监听器分配给委托，这时这个事件是否刚刚添加并不重要。
- en: '`_events[eventName]`: We can get the value for a specific event from the `_events`
    dictionary by simply specifying the key in square braces (this is similar to how
    we’d return the value of an array by specifying the index (`int`) in square braces).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_events[eventName]`：我们可以通过简单地指定方括号中的键来从 `_events` 字典中获取特定事件的值（这类似于我们通过指定方括号中的索引（`int`）来返回数组的值）。'
- en: '`(UnityAction<T>)`: Placing a type in parenthesis before another type is called
    casting in C#. Since `_events[eventName]` is a `Delegate` type, and `UnityAction`
    has delegate as its base type, we can operate on the event dictionary value as
    `UnityAction` via a type conversion by casting it (an explicit conversion). Here,
    again, `<T>` indicates we will use a generic for a parameter.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(UnityAction<T>)`: 在C#中将一个类型放在另一个类型之前称为类型转换。由于`_events[eventName]`是一个`Delegate`类型，而`UnityAction`以委托为其基类型，我们可以通过类型转换（显式转换）将事件字典的值作为`UnityAction`来操作。在这里，`<T>`表示我们将使用一个泛型参数。'
- en: Casting (C#)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换（C#）
- en: C# is a strongly typed language (or statically typed) at compile time, so once
    a variable is declared, it cannot be declared again as a different type. To overcome
    this, should you need to copy a value into a variable of another type, C# provides
    various type conversion operations, and casting is one of them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种在编译时强类型（或静态类型）的语言，因此一旦声明了一个变量，就不能将其再次声明为不同类型。为了克服这一点，如果你需要将值复制到另一个类型的变量中，C#提供了各种类型转换操作，类型转换就是其中之一。
- en: 'Here’s some additional reading: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的阅读材料：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions)。
- en: '`+ listener`: `UnityAction` allows you to add additional listeners; using the
    `+` (add) operator will enable us to do just that.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+ listener`: `UnityAction`允许你添加额外的监听器；使用`+`（添加）运算符将使我们能够做到这一点。'
- en: Note that just the `+` operator is the correct syntax to add a listener to a
    delegate that may be `null` or already has listeners, unlike previously, all the
    way back in [*Chapter 3*](B18347_03.xhtml#_idTextAnchor058), where we used the
    `+=` operator to add an event handler method when subscribing to events.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，仅使用`+`运算符是向可能为`null`或已具有监听器的委托添加监听器的正确语法，与之前不同，一直追溯到[*第3章*](B18347_03.xhtml#_idTextAnchor058)，在那里我们在订阅事件时使用`+=`运算符来添加事件处理方法。
- en: 'Now, let’s look at the opposite. For `RemoveListener()`, we want to remove
    an event listener when it’s no longer needed – especially when an object is destroyed
    – so that we don’t try invoking an invalid handler method reference. This is generally
    just good practice – for some listener types, not doing so can cause memory leaks:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看相反的情况。对于`RemoveListener()`，当不再需要事件监听器时（特别是当对象被销毁时），我们想要移除事件监听器，这样我们就不尝试调用无效的处理方法引用。这通常只是良好的实践——对于某些监听器类型，如果不这样做可能会导致内存泄漏：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We don’t need to break down the code here again because it’s essentially the
    same as `AddListener()`. The primary differences are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不需要再次分解代码，因为它基本上与`AddListener()`相同。主要区别如下：
- en: We don’t need to add the event in case it doesn’t exist; we only care if it
    does exist so that we can remove a listening handler method
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果事件不存在，我们不需要添加它；我们只关心它是否存在，以便我们可以移除一个监听处理方法。
- en: In place of the `+` operator, we use the `-` operator to remove the specified
    listener handler method
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`-`运算符代替`+`运算符来移除指定的监听器处理方法
- en: 'Lastly, we have the `TriggerEvent()` method. The naming of these methods has
    been self-explanatory so far, so it should be no surprise what’s next. However,
    we are doing something different here to retrieve the dictionary’s value for the
    `eventName` key that’s been provided to invoke the added handler methods:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`TriggerEvent()`方法。到目前为止，这些方法的命名已经足够直观，所以接下来应该不会令人惊讶。然而，我们在这里做了一些不同的事情，以检索字典中`eventName`键的值来调用添加的处理方法：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is how things work:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事情是如何工作的：
- en: '`_events.TryGetValue()`: You may find this syntax familiar since we’ve already
    used `TryGetComponent()` a few times. Very simply, we try to get the value for
    the specified `eventName` key, and if it exists, we return the value as an `out`
    parameter called `del`. The `if` evaluation will short-circuit if it’s not found,
    so `Invoke()` will only be called if a value is returned.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_events.TryGetValue()`: 你可能会发现这个语法很熟悉，因为我们已经几次使用了`TryGetComponent()`。非常简单，我们尝试获取指定`eventName`键的值，如果存在，我们将值作为名为`del`的`out`参数返回。如果未找到，`if`评估将短路，因此只有当返回值时才会调用`Invoke()`。'
- en: '`(del as UnityAction<T>)`: We introduce the `as` operator keyword here. Similar
    to how we used `()` to cast to another type, we can also use `as` for type conversion.
    Specifically, `as` is a good choice when working with a nullable type, which we
    want to do here because we’re also using the null-conditional operator (`?.`)
    so that we won’t erroneously try and call `Invoke()` on a null delegate.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(del as UnityAction<T>)`：我们在这里引入了 `as` 操作符关键字。类似于我们使用 `()` 来进行类型转换，我们也可以使用
    `as` 进行类型转换。特别是，当处理可空类型时，`as` 是一个好的选择，因为我们还使用空条件运算符 (`?.`)，这样我们就不会错误地尝试在空委托上调用
    `Invoke()`。'
- en: The as operator (C#)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: as 操作符（C#）
- en: The **as** operator converts objects to a different type but returns **null**
    if the conversion fails instead of throwing an exception like other type conversion
    techniques would.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**as** 操作符将对象转换为不同的类型，但如果转换失败则返回 **null**，而不是像其他类型转换技术那样抛出异常。'
- en: 'Here’s some additional reading: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的阅读材料：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator)。
- en: '`Invoke(arg)`: This is how we tie back into the generic parameter specified
    by `T` in the `UnityAction<T>` declaration for our listener delegate. The last
    part, bringing it full circle, will be the method signature for the handler method
    receiving the argument. This should all make sense when we get to the *Creating
    a quest system for a collecting keys mission* section, when we put the event system
    through its paces. Promise!'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke(arg)`：这是我们如何将监听器委托中由 `UnityAction<T>` 声明指定的泛型参数 `T` 连接到回的。最后一部分，形成一个完整的循环，将是接收参数的处理方法的签名。当我们到达
    *创建收集钥匙任务的任务系统* 部分时，所有这些都应该都清楚，我保证！'
- en: Next, so that we don’t overlook an essential detail for how we will access the
    event system from our classes that need to work with events, let’s make the event
    system a Singleton – an actual Singleton!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了我们不会忽略如何从需要处理事件的类中访问事件系统的一个基本细节，让我们将事件系统变成一个 Singleton - 一个真正的 Singleton！
- en: Enforcing a Singleton instance
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制单例实例
- en: Our `EventSystem` will be a **Singleton** instance so that it can be accessed
    from anywhere in our code. Still, we haven’t implemented a full Singleton pattern
    yet where only a single instance is guaranteed to exist. We’ll sort this out by
    enforcing the pattern and destroying any want-to-be duplicates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `EventSystem` 将是一个 **Singleton** 实例，这样我们就可以从代码的任何地方访问它。然而，我们还没有实现一个完整的 Singleton
    模式，其中只能保证存在一个实例。我们将通过强制执行该模式并销毁任何想要成为重复项的实例来解决这个问题。
- en: 'We saw a rudimentary implementation back in [*Chapter 3*](B18347_03.xhtml#_idTextAnchor058),
    where we just set the instance to a static variable without even attempting to
    seek and destroy additional instances being introduced (bad us). Here we go. Add
    the following `Instance` public static variable declaration and the new `Awake()`
    method code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 3 章*](B18347_03.xhtml#_idTextAnchor058) 中看到了一个基本的实现，我们只是将实例设置为一个静态变量，甚至没有尝试寻找和销毁被引入的额外实例（不好的做法）。现在我们来了。添加以下
    `Instance` 公共静态变量声明和新的 `Awake()` 方法代码：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The magic happens in the `Awake()` method, where we previously just did this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法发生在 `Awake()` 方法中，我们之前只是这样做：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can now check if our static `Instance` has been assigned yet; if not, assign
    it. However, if `Instance` was already assigned, a want-to-be duplicate will be
    added to our **Scene Hierarchy**. Let’s destroy it right away!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查我们的静态 `Instance` 是否已经被分配；如果没有，就分配它。但是，如果 `Instance` 已经被分配，一个想要成为重复项的实例将被添加到我们的
    **场景层次结构** 中。让我们立即销毁它！
- en: Our `EventManager` will need to hang around all the time to respond to registering
    and triggering events at any time, and from any class, throughout the life of
    our game, so we’ll need a way to keep it persistent.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `EventManager` 需要一直存在，以便在游戏的整个生命周期中，从任何类中随时响应注册和触发事件，因此我们需要一种方法来保持其持久性。
- en: 'Sometimes, the coding process feels like a game: find something, destroy that,
    keep this. So, if you’re not having fun, you’re doing something wrong!'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，编码过程就像一场游戏：找到这个，摧毁那个，保留这个。所以，如果你不觉得有趣，你就做错了什么！
- en: EventSystem | Complete code
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: EventSystem | 完整代码
- en: 'To view the complete code for the **EventSystem** class and all the event-related
    code in this chapter, visit this book’s GitHub repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章中 **EventSystem** 类的完整代码以及所有与事件相关的代码，请访问本书的 GitHub 仓库：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/).
- en: Singleton persistence
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例持久化
- en: Unity provides a way to keep particular objects persistent, no matter the current
    scene, survive loading new scenes, and more, and that is by using `DontDestroyOnLoad`.
    Simply calling it and passing the `GameObject` object you want to persist as the
    target parameter is all that’s needed. In our case, in `Awake()`, we’re passing
    in `gameObject`, which represents the current object the component (script) is
    attached to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了一种方法来保持特定对象持久，无论当前场景如何，都能在加载新场景时存活下来，等等，这就是通过使用 `DontDestroyOnLoad`。只需调用它并传递你想要持久化的
    `GameObject` 对象作为目标参数即可。在我们的情况下，在 `Awake()` 中，我们传递了 `gameObject`，它代表组件（脚本）附加到的当前对象。
- en: Additional reading | Unity documentation
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**DontDestroyOnLoad**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**DontDestroyOnLoad**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml).'
- en: Systems GameObject
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统GameObject
- en: 'Objects specified as `DontDestroyOnLoad` must be in the root of the `EventSystem`
    component. I would place this at the very top of the scene hierarchy to maintain
    some visible order of dependency for things – it’s entirely up to you how you
    choose to organize things here. Also, remember that you can add empty objects
    with the sole purpose of having organizational headers (don’t forget to set the
    tag to `EditorOnly`), as seen in the `Systems` object referenced in *Figure 9**.2*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 被指定为 `DontDestroyOnLoad` 的对象必须位于 `EventSystem` 组件的根目录。我会把它放在场景层次结构的顶部，以保持一些可见的依赖关系顺序——这完全取决于你如何选择在这里组织事物。此外，记得你可以添加空对象，仅用于组织标题（别忘了将标签设置为
    `EditorOnly`），正如在 *图 9.2* 中引用的 `Systems` 对象所示。2*：
- en: '![Figure 9.2 – Systems root GameObject](img/B18347_09_2.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 系统根 GameObject](img/B18347_09_2.jpg)'
- en: Figure 9.2 – Systems root GameObject
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 系统根 GameObject
- en: In this section, we learned how to create a global event system that allows
    our classes to remain loosely coupled because we don’t require type references
    of one class in another to respond to triggered actions. If the `EventSystem`
    component’s usage is still unclear, don’t fret – in the next section, we’ll cover
    an example straight away by creating a simple quest system based on it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建一个全局事件系统，它允许我们的类保持松散耦合，因为我们不需要在另一个类中引用类型来响应触发动作。如果 `EventSystem`
    组件的使用仍然不清楚，不要担心——在下一节中，我们将通过创建一个基于它的简单任务系统来立即提供一个示例。
- en: Creating a quest system for a collecting keys mission
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为收集钥匙任务创建任务系统
- en: 'Now that we have our super decoupled global event system, we’ll immediately
    put it to good use. Referring again to our GDD, we know that the player, at some
    point, has to collect some key pieces to solve a puzzle so that they can advance:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的超级解耦的全局事件系统，我们将立即将其用于实际用途。再次参考我们的 GDD，我们知道玩家在某个时候必须收集一些关键的部件来解决谜题，以便他们可以前进：
- en: '| **What is the secondary game mechanic for the** **adventure game?** | The
    player will search the environment for hidden parts of a key. The pieces will
    need to be combined correctly as input to gain access to the entryway of the habitat
    station. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **冒险游戏中的次要游戏机制是什么？** | 玩家将在环境中寻找隐藏的钥匙部分。这些部件需要正确组合作为输入，以获得进入栖息地站的入口。|'
- en: Table 9.1 – GDD quest reference
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 – GDD 任务参考
- en: A typical game system that can support “collecting a certain number of items”
    is a quest system. A possibly more simplified approach, but also a system-based
    approach to solving this problem, could be a basic inventory system. A quest system,
    however, will offer additional opportunities to provide a more complete example
    – especially for implementing the event system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以支持“收集一定数量的物品”的典型游戏系统是任务系统。一个可能更简化的方法，但也是一个基于系统的解决此问题的方法，可以是基本的库存系统。然而，任务系统将提供额外的机会来提供一个更完整的示例——特别是对于实现事件系统。
- en: 'Let’s have a quick look at what the player will be searching for during their
    quest and interacting with to regain entry to the habitat station constructed
    on the planet. The Kryk’zylx technology is a mystery to us, but suffice it to
    say, they like a good challenge when securing their bases. Both the key pieces
    that the evil plant entity has scattered and the entryway security puzzle lock
    with the missing pieces can be seen in the following figure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下玩家在寻宝过程中将寻找什么，以及与它们互动以重新进入在星球上建造的栖息地站。Kryk’zylx技术对我们来说是个谜，但 suffice
    it to say，他们在确保基地安全时喜欢挑战。邪恶植物实体散布的关键部件以及缺失部件的入口安全谜题锁都可以在以下图中看到：
- en: '![Figure 9.3 – Keys and security puzzle art](img/B18347_09_3.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 钥匙和安全谜题艺术](img/B18347_09_3.jpg)'
- en: Figure 9.3 – Keys and security puzzle art
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 钥匙和安全谜题艺术
- en: Our mission now is to code the quest system and flesh out the game mechanics
    required to implement it. So, let’s get started!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的任务是编写寻宝系统代码，并完善实现该系统所需的游戏机制。那么，让我们开始吧！
- en: The quest system
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻宝系统
- en: I’ll provide the code template for a `QuestSystem` class, similar to how the
    event system was introduced. However, I’ll give the full implementation this time
    because you’ll find it shares a similar design to `EventSystem`. I also won’t
    provide a diagram this time. I’m going to save it as a challenge for you to create
    one on your own at the end of this section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提供一个`QuestSystem`类的代码模板，类似于介绍事件系统的方式。然而，这次我将提供完整的实现，因为你会发现它与`EventSystem`有相似的设计。这次我也不会提供图表。我将把它作为一个挑战留给你，在本节结束时自己创建一个。
- en: 'Create a new script named `QuestSystem` in the `Assets/Scripts/Systems` folder
    with the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts/Systems`文件夹中创建一个名为`QuestSystem`的新脚本，并使用以下代码：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Okay, no, you’re not experiencing déjà vu. The basic concept for the `QuestSystem`
    code is a similar pattern to `EventSystem`. At its core, there’s also a C# `Dictionary`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，不，你并没有经历似曾相识的感觉。`QuestSystem`代码的基本概念与`EventSystem`类似，其核心也是一个C#的`Dictionary`。
- en: 'Here’s the breakdown:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是分解：
- en: '`Dictionary<string, bool>`: The declaration for the `_quests` dictionary will
    hold a `string` key to identify the quest’s name (similar to the event name),
    and the value for the entry will be of the `bool` type as an indication of whether
    the quest has been completed (that is, `true` equals completed).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<string, bool>`: `_quests`字典的声明将包含一个用于识别寻宝任务名称（类似于事件名称）的`string`键，而条目的值将为`bool`类型，作为任务是否完成的指示（即`true`表示已完成）。'
- en: '`StartQuest()`: Starting a quest means adding it to the dictionary if it’s
    not already added. Quests will be identified by a unique `questName` that’s passed
    in as the only argument. Simple. As. That.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartQuest()`: 开始一个寻宝任务意味着如果它尚未添加，则将其添加到字典中。寻宝任务将通过作为唯一参数传入的`questName`来识别，简单明了。'
- en: '`CompleteQuest()`: As stated earlier, we’re going to use the `_quest` value
    as the quest completion indicator, so if the specified quest exists in the dictionary,
    then we’ll assign `true` for its value (`bool` has a default value of `false`,
    which is why we didn’t need to assign this anywhere).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompleteQuest()`: 如前所述，我们将使用`_quest`值作为任务完成的指示器，因此如果指定的任务存在于字典中，则将其值赋为`true`（`bool`的默认值为`false`，这就是为什么我们不需要在任何地方分配这个值）。'
- en: We’ll be repeating ourselves a bit here again with how `QuestSystem` will be
    accessed when required since we’ll be using a Singleton pattern again. Primarily,
    however, we will decouple references to `QuestSystem` whenever possible by going
    through the global event system (that is, no tightly coupled objects).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将再次重复如何访问`QuestSystem`，因为我们将再次使用Singleton模式。然而，主要的是，我们将尽可能通过全局事件系统解耦对`QuestSystem`的引用（即，没有紧密耦合的对象）。
- en: 'Add the following declarations for the public static `Instance` property and
    the *Singleton management code* to the `Awake()` method, like so:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下声明添加到`Awake()`方法中的公共静态`Instance`属性和*Singleton管理代码*，如下所示：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the Singleton pattern solves a big problem for obtaining references to
    our core systems, but it also comes with some disadvantages compared to more complex
    patterns (for example, service locator patterns). We’re going to address one of
    these shortcomings now before proceeding further.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Singleton模式解决了获取核心系统引用的大问题，但与更复杂的模式（例如服务定位器模式）相比，它也有一些缺点。在进一步进行之前，我们将解决这些缺点之一。
- en: We have a potential problem with our systems because we require the `EventSystem`
    instance to be available to every other system when the game starts – being the
    core system loosely coupling everything together and playing nice. With that being
    the case, we must ensure it gets initialized first.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统存在一个潜在问题，因为我们要求在游戏开始时 `EventSystem` 实例对每个其他系统都是可用的——作为核心系统，松散耦合一切并保持良好。既然如此，我们必须确保它首先初始化。
- en: Script Execution Order
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本执行顺序
- en: To set the execution order for which script event functions are run (for example,
    the `Awake()` message event), Unity provides a **Script Execution Order** assignment
    in **Project Settings**. Quite simply, you can set a lower-ordered number for
    scripts you want to be initialized first and specifically before others that would
    rely on it being initialized.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置脚本事件函数的执行顺序（例如，`Awake()` 消息事件），Unity 在 **项目设置** 中提供了 **脚本执行顺序** 赋值。简单来说，你可以为想要首先初始化的脚本设置一个较低的顺序号，并确保它在依赖于它初始化的其他脚本之前。
- en: Additional reading | Unity documentation
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'Script Execution Order settings: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行顺序设置：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml)。
- en: For our usage here, we require `EventSystem` to be run before `QuestSystem`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在这里的使用，我们需要 `EventSystem` 在 `QuestSystem` 之前运行。
- en: Open **Edit** | **Project Settings…** | **Script** **Execution Order**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **编辑** | **项目设置…** | **脚本** **执行顺序**。
- en: If they’re not already in the list, add these two scripts to the list using
    the little plus (**+**) button at the bottom right.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它们还没有在列表中，请使用右下角的加号（**+**）按钮将这两个脚本添加到列表中。
- en: 'Then, click and drag them into the position indicated:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击并拖动它们到指示的位置：
- en: '![Figure 9.4 – Script Execution Order in Project Settings](img/B18347_09_4.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 项目设置中的脚本执行顺序](img/B18347_09_4.jpg)'
- en: Figure 9.4 – Script Execution Order in Project Settings
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 项目设置中的脚本执行顺序
- en: Click **Apply** when you’re finished.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击 **应用**。
- en: Additional reading | Unity documentation
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: Unity also provides a code solution for specifying the execution order of scripts
    using an attribute. The attribute is **[DefaultExecutionOrder(int)]**, and you
    can decorate the class declaration and set the order value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 还提供了一个使用属性指定脚本执行顺序的代码解决方案。该属性是 **[DefaultExecutionOrder(int)]**，你可以装饰类声明并设置顺序值。
- en: 'For example, adding this attribute to the **QuestSystem** class declaration
    would look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将此属性添加到 **QuestSystem** 类声明中的样子如下：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And speaking of execution, make sure to add the `QuestSystem` component to the
    `EventSystem`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 说到执行，确保将 `QuestSystem` 组件添加到 `EventSystem` 中）。
- en: Now, what’s a quest system without any quests?!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，没有任务的任务系统又是什么呢？！
- en: The quest
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: Your mission, should you choose to accept it, will be to find and collect the
    missing pieces that are required to solve the habitat entryway security puzzle
    lock. The quest object representing the actual quest with its requirements is
    arguably the essential part of any quest system. As you saw in the *Script Execution
    Order* section, keeping a list of the active quests is quite simple – we add a
    quest to a list and set a variable to `true` when it’s completed. Easy-peasy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择接受这个任务，你的任务将是找到并收集解决栖息地入口安全谜锁所需的缺失部件。代表实际任务及其要求的任务对象可以说是任何任务系统的基本部分。正如你在
    *脚本执行顺序* 部分所看到的，保持活动任务列表相当简单——我们向列表中添加一个任务，并在完成时将变量设置为 `true`。简单易懂。
- en: The next part of the quest system we’ll cover will be the quest code. Before
    we even get started, however, we will ensure that any quest we define will have
    a unique identifier that is easily assignable (even in the **Inspector** view).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的下一个任务系统部分将是任务代码。在我们开始之前，我们将确保我们定义的任何任务都将有一个易于分配的唯一标识符（即使在 **检查器** 视图中）。
- en: Name consistency
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称一致性
- en: The problem we’ll need to solve now is how to guarantee consistency for quest
    names without using magic strings, reference the quest names from different parts
    of the code, and have them selectable in the **Inspector** view.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要解决的问题是如何在不使用魔法字符串的情况下保证任务名称的一致性，从代码的不同部分引用任务名称，并在**检查器**视图中选择它们。
- en: We saw how to use `enum` when the simple `enum` similarly now, but instead of
    states for an FSM, we’re going to use it for unique quest name identifiers; again,
    as a reminder, we’re not going to rely on string literals! This is similar to
    how we’ve used string constants before (for example, event names and tags), but
    being an `enum` type over a constant means we have some added benefit, including
    when it comes to selecting from a list of available quests in the **Inspector**
    view!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 `enum`，现在类似地，但这次我们不是为 FSM 的状态使用它，而是要为唯一的任务名称标识符使用它；再次提醒，我们不会依赖于字符串字面量！这类似于我们之前如何使用字符串常量（例如，事件名称和标签），但作为一个
    `enum` 类型而不是常量，我们有一些额外的优势，包括在 **检查器** 视图中从可用任务列表中进行选择时！
- en: 'Create a new script named *QuestNames* in the `Assets/Scripts/Quests` folder.
    Replace all of the default script template code with the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts/Quests` 文件夹中创建一个名为 *QuestNames* 的新脚本。将所有默认脚本模板代码替换为以下代码：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is where we’ll define any new quest we add to the game. We’ve populated
    the `CollectKeysQuest` name and given it a unique ID of `10` (this is any arbitrary
    number that’s not already being used) – be sure to follow this pattern, assigning
    the name and ID, when adding additional quest names.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义任何新任务的地方。我们已经填充了 `CollectKeysQuest` 名称，并给它分配了一个唯一的 ID `10`（这是一个尚未使用的任意数字）——确保在添加额外的任务名称时遵循此模式，分配名称和
    ID。
- en: We’ll see how the quest names will be declared and referenced as we proceed
    with our coding mission to complete this quest system!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在继续我们的编码任务以完成这个任务系统时，看看任务名称是如何声明和引用的！
- en: Quest base class
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务基类
- en: Yup, that’s right, another base class means we will use more OOP design here!
    And since we covered this already in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041),
    it’s barely an inconvenience for you to bang this out, right? Our specific quests
    will then derive from the new quest base class we’ll write next, providing a template
    for consistency in implementing quests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，没错，另一个基类意味着我们在这里将使用更多的面向对象设计！而且因为我们已经在 [*第 2 章*](B18347_02.xhtml#_idTextAnchor041)
    中覆盖了这一点，所以对你来说这几乎不是什么不便，对吧？我们的特定任务将随后从我们将要编写的下一个新任务基类中派生出来，为实施任务提供一致性模板。
- en: We’ve already defined the quest names. A quest name will need to be a part of
    every quest, so let’s start by setting up the base class for our quests with that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了任务名称。每个任务都需要包含任务名称，所以让我们首先设置我们任务的基础类。
- en: 'Create a new script named `QuestBase` in the `Assets/Scripts/Quests` folder:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts/Quests` 文件夹中创建一个名为 `QuestBase` 的新脚本：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing to note is that the `QuestBase` class is declared as `public
    abstract class`. This means we won’t be able to use this class directly – we cannot
    add an abstract class to a `GameObject` object in the `QuestBase` (that is, this
    is only the *base template*).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，`QuestBase` 类被声明为 `public abstract class`。这意味着我们无法直接使用这个类——我们无法在 `QuestBase`
    中将抽象类添加到 `GameObject` 对象（即，这只是一个 *基础模板*）。
- en: 'Second, we can see the declaration for `QuestName`, which uses the `QuestNames`
    `enum` type we previously wrote. We have encapsulated a `private _questName` variable
    and decorated it with the `[SerializeField]` attribute so that it can be assigned
    in the `enum` type draws in the **Inspector** view:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以看到 `QuestName` 的声明，它使用了我们之前编写的 `QuestNames` 枚举类型。我们封装了一个 `private _questName`
    变量，并用 `[SerializeField]` 属性装饰它，以便可以在 **检查器** 视图中分配给枚举类型：
- en: '![Figure 9.5 – The Quest Name Inspector view assignment dropdown](img/B18347_09_5.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 任务名称检查器视图的分配下拉菜单](img/B18347_09_5.jpg)'
- en: Figure 9.5 – The Quest Name Inspector view assignment dropdown
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 任务名称检查器视图的分配下拉菜单
- en: The `_questName` value is made available to other classes via the `public QuestName`
    property – the expression body (`=>`) declares the property as a getter only (as
    in, you won’t be able to assign a value).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`_questName` 值通过 `public QuestName` 属性对其他类可用——表达式体 (`=>`) 声明该属性仅为获取器（即，您无法分配值）。'
- en: 'So far, so good. Still, this was a bit of a review since nothing we’ve covered
    here is new. The same goes for the first two methods we’ll declare for the `QuestBase`
    abstract class. We’ll use `virtual` methods for both `StartQuest()` and `QuestCompleted()`
    because the inheriting class may need to override the provided base functionality:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。然而，这只是一些复习，因为我们在这里覆盖的内容都不是新的。对于我们将为 `QuestBase` 抽象类声明的第一个两个方法也是如此。我们将对
    `StartQuest()` 和 `QuestCompleted()` 使用 `virtual` 方法，因为继承的类可能需要覆盖提供的基本功能：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code may be self-explanatory at this point, but it always helps to explain.
    Let’s break it down:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码可能已经很直观了，但解释总是有帮助的。让我们来分解一下：
- en: '`public virtual void StartQuest()`: This method has a `public` accessor because
    it is intended to be called from an external class to trigger the start of the
    quest. We call the quest system’s `StartQuest()` method (via its Singleton instance)
    and pass the unique quest identifier (that is, the `enum`-based quest name) to
    add it to the active quests `Dictionary` for later reference.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public virtual void StartQuest()`: 这个方法有一个`public`访问器，因为它打算从外部类调用以触发任务的开始。我们调用任务系统的`StartQuest()`方法（通过其单例实例），并将唯一的任务标识符（即基于`enum`的任务名称）传递给它，以便将其添加到活动任务的`Dictionary`中，以便稍后参考。'
- en: We use `virtual` in the method signature in case the inheriting class would
    need to do more than start the quest.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在方法签名中使用`virtual`，以防继承的类需要做更多的事情（比如，除了开始任务之外）。
- en: '`protected virtual QuestCompleted()`: This method has a `protected` accessor,
    so it can only be called within the class and by derived classes – not an external
    class because the logic to determine quest completion should be evaluated on the
    specific quest’s requirements and not some external factors.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected virtual QuestCompleted()`: 这个方法有一个`protected`访问器，因此它只能在类内部和派生类中调用——不能是外部类，因为确定任务完成逻辑应该基于特定任务的要求，而不是某些外部因素。'
- en: Again, we use `virtual` in the method signature in case the inheriting class
    would need to do something else (such as implementing different logic or behavior
    for different types of quests, such as side quests). For now, we’re simply logging
    a message to the console that the quest was completed.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，我们在方法签名中使用`virtual`，以防继承的类需要做其他事情（比如，为不同类型的任务实现不同的逻辑或行为，例如支线任务）。目前，我们只是将一条消息记录到控制台，表明任务已完成。
- en: 'Now for the fun part! We’ll be leaning on the event system to implement the
    following function: listening for when the quest has been completed. This is why
    we didn’t declare the `QuestCompleted()` method as `public` – `QuestCompleted()`
    is the handler method that’s passed into the event system as the listener:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候享受乐趣了！我们将依赖事件系统来实现以下功能：监听任务何时完成。这也是为什么我们没有将`QuestCompleted()`方法声明为`public`的原因——`QuestCompleted()`是作为监听器传递给事件系统的处理方法：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are just a few points in need of explanation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要解释的要点：
- en: '`OnEnable()`, `OnDisable()`: We add and remove the event system listeners for
    the base class, respectively. `AddListeners()` and `RemoveListeners()` can be
    overridden in the inheriting class if additional listeners need to be added for
    the specific quest.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnEnable()`, `OnDisable()`: 我们分别添加和移除基类的事件系统监听器。如果派生类需要为特定任务添加额外的监听器，则可以覆盖`AddListeners()`和`RemoveListeners()`。'
- en: '`AddListeners()`: Here, we add a listener to the event system for quest completion.
    We’ll use a string argument to pass the quest’s name as the parameter to the handler
    method.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddListeners()`: 在这里，我们向事件系统添加一个监听器以监听任务完成事件。我们将使用一个字符串参数将任务名称作为参数传递给处理方法。'
- en: '`RemoveListeners()`: We just need to remove the listener added in `AddListeners()`
    – remember, removing event listeners is always good practice!'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveListeners()`: 我们只需要移除在`AddListeners()`中添加的监听器——记住，移除事件监听器始终是良好的实践！'
- en: Note that even though it doesn’t make sense that simply removing a listener
    would require an argument for passing a parameter, we still need it because the
    delegate definition must match the method signature of the handler method that
    was added as the listener.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，尽管简单地移除监听器不需要传递参数在逻辑上没有意义，但我们仍然需要它，因为委托定义必须与添加为监听器的处理方法的签名相匹配。
- en: As the last step, add the string constant for `EventConstants.OnQuestCompleted`
    to the `EventConstants` script. Or, in your IDE, *OnQuestCompleted* should have
    that red squiggly line indicating the definition was not found. Go ahead and use
    your IDE’s refactoring tools to generate the variable (but ensure it is consistent
    with the other event name constants).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，将`EventConstants.OnQuestCompleted`的字符串常量添加到`EventConstants`脚本中。或者，在你的IDE中，*OnQuestCompleted*应该有一个红色的波浪线，表示定义未找到。接下来，使用你的IDE的重构工具生成变量（但确保它与其他事件名称常量保持一致）。
- en: With that, `QuestBase` has been completed! Now, prepare to make a specific quest
    class derived from the base class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，`QuestBase`已经完成了！现在，准备创建一个从基类派生的特定任务类。
- en: Collect keys quest
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集任务键
- en: We call the missing security puzzle key pieces that need to be collected *keys*,
    and three will be required to complete our quest. These are simple requirements
    for a simple quest, but we still need a way to not only explicitly declare the
    requirement but evaluate and communicate completion, too.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要收集的缺失的安全谜题关键部件称为“钥匙”，并且需要三个来完成我们的任务。这些是一个简单任务的基本要求，但我们仍然需要一种方法来不仅明确声明要求，还要评估和传达完成情况。
- en: 'We’ll start by creating a new script called `CollectKeysQuest` in the `Assets/Scripts/Quests`
    folder and inherit from `QuestBase` instead of `MonoBehaviour`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在 `Assets/Scripts/Quests` 文件夹中创建一个新的脚本，名为 `CollectKeysQuest`，并从 `QuestBase`
    继承，而不是从 `MonoBehaviour` 继承：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We also declare the number of keys required to be collected to complete this
    quest. `_numKeysRequired` will be `private` so that no other class has access
    to it, but we’ll use the `[SerializeField]` attribute to set this value in the
    `3`).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了完成这个任务所需的钥匙数量。`_numKeysRequired` 将是 `private` 的，这样就没有其他类可以访问它，但我们会使用 `[SerializeField]`
    属性来设置这个值在 `3`))。
- en: '`_keysCollected` will keep track of the number of keys the player has collected
    (`private` – it’s no one else’s business), and we’ll increment that value via
    the event system (so handy):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`_keysCollected` 将跟踪玩家收集的钥匙数量（`private` —— 这不是任何人的事），我们将通过事件系统（非常方便）来增加这个值：'
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Okay, it is a familiar pattern, but let’s clarify it still:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个熟悉的模式，但让我们还是澄清一下：
- en: '`override AddListeners()`: For this specific quest, we need to listen for when
    the player has collected a key. Using the event system, we don’t need to know
    anything about the `Player` object or even the script implemented to collect the
    key; we observe that a key was collected and handled with the `KeyCollected()`
    method. We use the `override` keyword here because we need more functionality
    than the base class alone provides:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override AddListeners()`: 对于这个特定的任务，我们需要监听玩家收集钥匙的时刻。使用事件系统，我们不需要了解任何关于 `Player`
    对象或甚至收集钥匙所实现的脚本；我们观察到收集到了钥匙，并使用 `KeyCollected()` 方法进行处理。我们在这里使用 `override` 关键字，因为我们需要的功能比基类本身提供的更多：'
- en: '`base.AddListeners()`: Speaking of what the base class provides, we still need
    it! We can still ensure the base class methods that are overridden by using the
    `base` keyword – for accessing base class members within the derived class.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base.AddListeners()`: 说到基类提供的内容，我们仍然需要它！我们仍然可以通过使用 `base` 关键字来确保覆盖基类的方法——在派生类中访问基类成员。'
- en: '`override RemoveListeners()`: You got it – maintaining good practice removing
    what listeners were added:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override RemoveListeners()`: 你明白了——保持良好的习惯，移除之前添加的监听器：'
- en: '`base.RemoveListeners()`: The same as for `base.AddListeners()`'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base.RemoveListeners()`: 与 `base.AddListeners()` 相同'
- en: '`KeyCollected()`: I promise we won’t have a breadcrumb trail of UNDONE tokens
    to follow again! But, for now, we’ll just increment the `_keysCollected` variable
    when the `OnKeyCollected` event is triggered:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyCollected()`: 我保证我们不会再次有要跟随的未完成的标记的面包屑路径！但，现在，当 `OnKeyCollected` 事件被触发时，我们只会增加
    `_keysCollected` 变量：'
- en: '`bool arg0`: Our `EventSystem` requires us to pass an argument with the handler
    event. We don’t need to pass any parameters for the key collected event, but we
    must still declare something! A bool value being the smallest type, I feel, is
    the least evil we can do here.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool arg0`: 我们的 `EventSystem` 要求我们传递一个带有处理事件的手柄参数。对于收集钥匙的事件，我们不需要传递任何参数，但我们必须声明点什么！布尔值是最小的类型，我觉得这是我们这里能做的最少的恶。'
- en: '`EventConstants.OnKeyCollected`: Be sure to add it to `EventCostants` to resolve
    the missing definition error.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventConstants.OnKeyCollected`: 一定要添加到 `EventConstants` 中以解决缺失定义的错误。'
- en: Excellent – we have a quest! Now, if only we could be given the quest! We don’t
    have snarky NPCs in our game standing on street corners, just giving out quests
    to any weary traveler passing through, so we’ll leverage some reusable components
    we already have to trigger the start of our quest.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 极好——我们有一个任务了！现在，如果只有我们能得到这个任务就好了！在我们的游戏中，没有那些站在街角、向任何经过的疲惫旅行者分发任务的刻薄NPC，所以我们将利用我们已有的可重用组件来触发我们任务的开始。
- en: Quest giver GameObject
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务提供者 GameObject
- en: We don’t need a new script for giving the quest to the player; we just need
    to start *Collect Keys Quest*. We can easily do that by creating a trigger volume
    in the environment, using our ever-so-useful and reusable `TriggerEvent` component,
    and simply calling the publicly declared `StartQuest()` method on a `CollectKeysQuest`
    component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为给玩家分配任务编写新的脚本；我们只需要开始**收集钥匙任务**。我们可以通过在环境中创建一个触发体积，使用我们非常有用且可重复使用的`TriggerEvent`组件，并在`CollectKeysQuest`组件上简单地调用公开声明的`StartQuest()`方法来轻松完成它。
- en: 'Here’s what it’ll look like in the **Scene** view and **Inspector** view:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在**场景**视图和**检查器**视图中的样子：
- en: '![Figure 9.6 – Quest giver object in the scene](img/B18347_09_6.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 场景中的任务提供者对象](img/B18347_09_6.jpg)'
- en: Figure 9.6 – Quest giver object in the scene
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 场景中的任务提供者对象
- en: Have a go at constructing the object and components that make up the *quest
    giver* object and place it in the level near where the player starts.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试构建组成**任务提供者**对象的对象和组件，并将其放置在玩家开始位置的附近。
- en: 'Did you manage to assemble it successfully? Let’s review the steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你成功组装了吗？让我们回顾一下步骤：
- en: Create a new GameObject in the scene and name it `Quest Giver – Keys Quest`,
    then position it in the level near where the player starts (refer to *Figure 9**.6*
    for an example).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个新的GameObject，并将其命名为`Quest Giver – Keys Quest`，然后将其放置在玩家开始位置的附近（参考*图9.6*以获取示例）。
- en: (*A*) Add the `CollectKeysQuest` script to the new object. *Collect Keys Quest*
    should be selected in the **Quest Name** dropdown since it’s our only quest, and
    set the number of keys required to three.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*A*) 将`CollectKeysQuest`脚本添加到新对象中。在**任务名称**下拉菜单中选择**收集钥匙任务**，因为我们只有一个任务，并将所需钥匙数量设置为三。
- en: (*B*) Add a `BoxCollider2D` component next (use the `true` because we don’t
    want the player to interact with this GameObject physically; we only want to use
    it as a trigger volume. Adjust the collider’s size to guarantee the player will
    collide with it.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*B*) 接下来添加一个`BoxCollider2D`组件（使用`true`，因为我们不希望玩家与这个GameObject进行物理交互；我们只想将其用作触发体积。调整碰撞体的尺寸以确保玩家会与之碰撞）。
- en: (*C*) Add a `TriggeredEvent` component and wire up the methods that are called
    when `OnTriggered()` is invoked.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*C*) 添加一个`TriggeredEvent`组件，并将当`OnTriggered()`被调用时调用的方法连接起来。
- en: Click the little plus (`CollectKeysQuest` component to the first event field
    and select the `CollectKeysQuest.StartQuest()` method from the drop-down list.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击小加号（将`CollectKeysQuest`组件拖到第一个事件字段，并从下拉列表中选择`CollectKeysQuest.StartQuest()`方法）。
- en: Drag `BoxCollider2D` to the second event field, select `BoxCollider2D.enabled`
    from the dropdown, and leave the checkbox unticked (that is, set `false`; this
    will disable the collider and prevent triggering *start the quest* additional
    times).
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BoxCollider2D`拖到第二个事件字段，从下拉菜单中选择`BoxCollider2D.enabled`，并保持复选框未勾选（即设置为`false`；这将禁用碰撞体，防止触发**开始任务**额外的次数）。
- en: Ensure only the player can trigger the quest start by ticking off `IsTriggeredByPlayer`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保只有玩家可以触发任务开始，通过勾选`IsTriggeredByPlayer`。
- en: As the final step, save the `Prefab` object in the `Assets/Prefabs` folder (by
    dragging it from the hierarchy into the **Project** window). That way, we can
    quickly drop a quest giver into the level later.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后一步，将`Prefab`对象保存在`Assets/Prefabs`文件夹中（通过从层次结构拖动到**项目**窗口）。这样，我们可以在以后快速将任务提供者放入场景中。
- en: Quest accepted! You wouldn’t start a quest that was impossible to complete,
    would you? Now, let’s see how we complete *Collect* *Keys Quest*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 任务已接受！你不会开始一个不可能完成的任务，对吧？现在，让我们看看我们如何完成**收集钥匙任务**。
- en: Quest completion
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务完成
- en: We’ve defined a specific quest, we’ve given the quest to the player, and now
    we must progress on the quest to complete it. Progress is made when we collect
    keys in the game level (you know, kind of like the collection game we completed
    as the first project in this book).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个特定的任务，我们已经给了玩家这个任务，现在我们必须在任务中取得进展以完成它。进展是在我们在游戏级别收集钥匙时取得的（你知道的，就像我们在本书的第一个项目中完成的收集游戏一样）。
- en: In the `CollectKeysQuest` class, as you know, the `KeyCollected()` method is
    called when the `OnKeyCollected` event is triggered. We left it at only incrementing
    the variable, keeping track of the number of keys collected. Let’s finish it up
    by evaluating whether the quest requirements have been satisfied to complete the
    quest.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CollectKeysQuest`类中，正如你所知，当`OnKeyCollected`事件被触发时，会调用`KeyCollected()`方法。我们只让它增加变量，以跟踪收集到的钥匙数量。现在让我们通过评估任务要求是否满足来完成这个任务。
- en: 'Complete the `KeyCollected` method by adding the `if` block, like so:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`if`块来完成`KeyCollected`方法，如下所示：
- en: '[PRE16]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A very simple `if` statement checks whether the incremented `_keysCollected`
    variable is greater than or equal to (`>=`) the number of keys required to complete
    the quest, as defined by the `_numKeysRequired` variable (set in the `then` we’ll
    do the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的`if`语句检查增加后的`_keysCollected`变量是否大于或等于（`>=`）完成任务所需的钥匙数量，该数量由`_numKeysRequired`变量定义（在`then`中我们将执行以下操作：
- en: Call `CompleteQuest()` on the `QuestSystem` Singleton instance and pass in the
    quest name as the parameter. We need to use `ToString()` on the `QuestName` variable
    because it is an `enum` value, and internally, it is stored as an `int` type;
    we need a `string` type as the argument.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`QuestSystem`单例实例上调用`CompleteQuest()`并传入任务名称作为参数。我们需要在`QuestName`变量上使用`ToString()`，因为它是一个`enum`值，在内部，它被存储为`int`类型；我们需要一个`string`类型的参数。
- en: Trigger the `OnQuestCompleted` event via the `EventSystem` Singleton instance
    and, again, pass in `QuestName` as a parameter. This is also a `string` type.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`EventSystem`单例实例触发`OnQuestCompleted`事件，并且再次传入`QuestName`作为参数。这同样是一个`string`类型。
- en: The *UNDONE token quest* is complete. Yay!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*未完成令牌任务*已完成。太好了！'
- en: Quest event constants added
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加了任务事件常量
- en: 'We need to add some event name constants to support what we just added for
    the quest system and *Collect Keys Quest*. As a recap, here’s what the `EventConstants`
    script should look like now. I have added some comments for some quick organization
    to keep things tidy:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一些事件名称常量来支持我们刚刚为任务系统和*收集钥匙任务*添加的内容。作为一个回顾，以下是现在的`EventConstants`脚本应该看起来像什么。我为一些快速组织添加了一些注释，以保持事情整洁：
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our quest system has come together nicely, but we’re still missing one final
    bit of functionality, and that is being able to know whether or not a quest that
    was started (that is, added to the `_quests` dictionary) has been completed (that
    is, the requirements of the quest mission have been satisfied, and `CompleteQuest()`
    was called).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务系统已经很好地组合在一起，但我们仍然缺少一个最终的功能，那就是能够知道是否有一个已经开始的任务（即，添加到`_quests`字典中）已经完成（即，任务任务的要求已经满足，并且调用了`CompleteQuest()`）。
- en: Quest status
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务状态
- en: 'To know the quest’s status, go ahead and add the following `IsQuestComplete()`
    method to the `QuestSystem` class:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道任务的状态，请继续在`QuestSystem`类中添加以下`IsQuestComplete()`方法：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You should recognize a familiar pattern here with `TryGetValue()` (as a method
    available in `Dictionary`) – we’ve covered a similar pattern with `TryGetComponent()`
    several times. `TryGetValue()` will return `true` if the value exists in the `_quests`
    dictionary. Then, set the returned value to the `out` variable, `status`, for
    immediate consumption by the following `if` block code. This is extremely convenient,
    and, as I’ve espoused, I’m a big fan of this pattern (even going so far as to
    replicate this pattern in my code).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在这里识别出一个熟悉的模式与`TryGetValue()`（作为`Dictionary`中可用的一种方法）——我们已经多次用`TryGetComponent()`覆盖了类似的模式。`TryGetValue()`如果`_quests`字典中存在值，将返回`true`。然后，将返回的值设置为`out`变量`status`，以便立即被下面的`if`块代码消费。这非常方便，正如我所说的，我是一个大粉丝（甚至在我的代码中复制了这个模式）。
- en: We’ll continue with short-circuiting the method by immediately returning the
    quest’s `status` from the `TryGetValue()` call. Otherwise, we return `false`,
    indicating a default condition of the quest not being complete due to it not even
    existing in the dictionary.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过立即从`TryGetValue()`调用中返回任务的状态来短路方法。否则，我们返回`false`，表示任务默认未完成，因为它甚至不在字典中。
- en: Now that we can query the status of a specific quest from our `QuestSystem`
    Singleton instance, we can create a reusable component to use in our game to respond
    accordingly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从我们的`QuestSystem`单例实例中查询特定任务的状态，我们可以创建一个可重用的组件，用于在我们的游戏中相应地做出反应。
- en: Quest completed component
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务完成组件
- en: We’ll need something to check for quest completion when the player gets to the
    habitat entryway. This will allow us to show the security puzzle lock if the quest
    has been completed or provide some other action if not.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家到达栖息地入口时，我们需要检查任务是否完成。这将允许我们显示安全谜题锁，如果任务已完成，或者如果没有完成，提供其他操作。
- en: 'Create a new script named `QuestHasCompleted` in the `Assets/Scripts/Quests`
    folder:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts/Quests`文件夹中创建一个名为`QuestHasCompleted`的新脚本：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This isn’t anything we haven’t seen before. The `QuestName` field will allow
    us to specify which quest we want to know the completion status for in the `UnityEvent`
    fields will enable us to set actions for complete and incomplete statuses. Simples.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们之前没有见过的。`QuestName` 字段将允许我们在 `UnityEvent` 字段中指定我们想要知道完成状态的哪个任务。简单来说。
- en: 'Here’s how an object based on this new component will look in the **Inspector**
    view:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于此新组件的对象在 **检查器** 视图中的外观：
- en: '![Figure 9.7 – Puzzle trigger object setup](img/B18347_09_7.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 谜题触发器对象设置](img/B18347_09_7.jpg)'
- en: Figure 9.7 – Puzzle trigger object setup
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 谜题触发器对象设置
- en: Let’s create this *puzzle trigger* object now and wire it up so that when the
    player enters the trigger volume, and if *Collect Keys Quest* has been completed,
    it will disable `PlayerInput` (ensuring the player can no longer move) and show
    **Puzzle** (solving the entryway security puzzle lock is the player’s goal for
    this level).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建这个 *谜题触发器* 对象，并将其连接起来，以便当玩家进入触发体积时，如果 *收集钥匙任务* 已完成，它将禁用 `PlayerInput`（确保玩家不能再移动）并显示
    **谜题**（解决入口安全谜题锁是玩家在这个关卡的目标）。
- en: 'Here’s how we construct a *Has the quest been* *completed?* object:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何构建一个 *任务是否已完成？* 对象的：
- en: Create a new empty GameObject in the `Puzzle Trigger` because we want to show
    the puzzle when the player reaches the habitat entryway.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Puzzle Trigger` 中创建一个新的空 GameObject，因为我们想在玩家到达栖息地入口时显示谜题。
- en: (*A*) Add a `QuestHasCompleted` component and select **Collect Keys Quest**
    from the dropdown of available quest names.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*A*) 添加一个 `QuestHasCompleted` 组件，并从可用的任务名称下拉菜单中选择 **收集钥匙任务**。
- en: Assign the following events for `OnQuestComplete()` (click the plus (`PlayerInput.enabled`
    from the dropdown, and leave the checkbox unticked. Disabling `PlayerInput` in
    this way will mean no input will be processed to enact with the player – we don’t
    want the player character to move any longer because it would now be time to solve
    the puzzle.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `OnQuestComplete()` 分配以下事件（点击加号，从下拉菜单中选择 `PlayerInput.enabled`，并取消勾选复选框。以这种方式禁用
    `PlayerInput` 将意味着不会处理任何输入以与玩家执行操作 – 我们不希望玩家角色再移动，因为现在应该是解决谜题的时候了。
- en: The following assignment is for our future selves; we’ll use a reference to
    the **Key Puzzle** object and make it active (display it) so that the player can
    work on solving it – **Key Puzzle** will be added in the last section of this
    chapter, so we’ll revisit this assignment then.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下分配是为了我们未来的自己；我们将使用对 **钥匙谜题** 对象的引用并将其激活（显示），以便玩家可以解决它 – **钥匙谜题** 将在本章的最后部分添加，那时我们将重新访问这个分配。
- en: (*B*) Add a `TriggeredEvent` component and assign the `QuestHasCompleted` component
    to the `OnTriggered` event, then select `QuestHasCompleted.CheckQuestComplete()`
    from the dropdown. Ensure **IsTriggeredByPlayer** is ticked.*   Don’t forget to
    add a `BoxCollider2D` component and set `true`; the size will be adjusted accordingly
    concerning the habitat entryway so that the player will interact with it when
    reaching it.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*B*) 添加一个 `TriggeredEvent` 组件，并将 `QuestHasCompleted` 组件分配给 `OnTriggered` 事件，然后从下拉菜单中选择
    `QuestHasCompleted.CheckQuestComplete()`。确保 **IsTriggeredByPlayer** 被勾选。*   不要忘记添加一个
    `BoxCollider2D` 组件并将其设置为 `true`；大小将根据栖息地入口进行调整，以便玩家在到达时与之交互。
- en: 'For placement, if you haven’t taken the liberty of adding the habitat entryway
    to your level yet, now’s the time! We haven’t explored every nuance of your level
    design while bringing everything together – naturally, you’ve been doing your
    level design homework:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于放置，如果您还没有将栖息地入口添加到您的关卡中，现在就是时候了！我们在将所有内容组合在一起时并没有探索您关卡设计的每一个细节 – 自然地，您一直在做您的关卡设计作业：
- en: Place the habitat entryway sprite *entryway* from the `Assets/Sprites/Object
    Elements` folder into the environment and use the `Background` **Sorting Layer**.
    You can organize it in the **Scene Hierarchy** using what we previously established
    as the **Level (Default)** | **In** **Back** structure.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将来自 `Assets/Sprites/Object Elements` 文件夹的栖息地入口精灵 *entryway* 放入环境中，并使用 `Background`
    **排序层**。您可以使用我们之前建立的 **Level (默认)** | **In** **Back** 结构在 **场景层次结构** 中对其进行组织。
- en: Place the **Puzzle Trigger** object at the entryway and set the collider size
    accordingly (refer to *Figure 9**.7* for an example).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **谜题触发器** 对象放置在入口处，并相应地设置碰撞器大小（参考 *图 9**.7* 中的示例）。
- en: As we saw in the preceding code and description, the `QuestHasCompleted` component
    has an event that is triggered when we check the status for both complete and
    incomplete quest statuses. We already populated the `OnQuestComplete()` event
    but also have an `OnQuestIncomplete()` event. We won’t be assigning any function
    here for now, but imagine that we could display a dialog to our player stating
    that the quest’s requirements haven’t been met for them to proceed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码和描述中看到的，`QuestHasCompleted` 组件有一个事件，当检查完成和不完整的任务状态时会被触发。我们已经填充了 `OnQuestComplete()`
    事件，但还有一个 `OnQuestIncomplete()` 事件。现在我们不会在这里分配任何函数，但想象一下，我们可以向玩家显示一个对话框，说明任务的完成要求尚未满足，他们无法继续。
- en: Challenge | Quest system diagram
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 | 任务系统图
- en: Create a basic object reference diagram for the quest system while using the
    event system diagram in *Figure 9**.1* as a reference. Don’t be so concerned with
    the shapes you choose to represent each part, but do be consistent and use the
    same shape for the same object type. If you want to challenge yourself further,
    create a UML diagram!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用图 9**.1** 中的事件系统图作为参考的同时，为任务系统创建一个基本对象引用图。不要过于关注你选择的代表每个部分的形状，但请保持一致，并使用相同的形状来表示相同的对象类型。如果你想进一步挑战自己，可以创建一个
    UML 图！
- en: Everything is in place for us to fully execute a quest’s life cycle. Now, we
    need to collect those pesky key pieces!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好执行一个任务的生命周期了。现在，我们需要收集那些讨厌的关键部件！
- en: Collecting keys
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集钥匙
- en: We’ve tackled player collectible items a few different ways now, so collectible
    key items will be a familiar concept. The only difference is that we will now
    rely on `EventSystem` to trigger a *key collected* event. As we already know,
    the `CollectKeysQuest` quest is listening for `OnKeyCollected` being invoked,
    so this is where we’ll implement triggering it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经以几种不同的方式处理了玩家的可收集物品，所以可收集的关键物品将是一个熟悉的概念。唯一的区别是，我们现在将依赖于 `EventSystem` 来触发一个
    *收集钥匙* 事件。正如我们已经知道的，`CollectKeysQuest` 任务正在监听 `OnKeyCollected` 被调用，所以这就是我们将实现触发它的地方。
- en: As you could probably also guess, we’re going to use a `Prefab` object for the
    puzzle piece keys (via **Prefab Variant**). So, that will require a component
    to implement the key collection behavior.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能也猜到的，我们将使用 `Prefab` 对象来制作谜题部件的钥匙（通过 **Prefab Variant**）。因此，这将需要一个组件来实现关键收集行为。
- en: KeyItem component
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KeyItem 组件
- en: 'First, let’s prepare the artwork we’ll use to make the collectible key pieces.
    For a visual reference, here’s what we’ll be working with for creating the key
    pieces and a placeholder security puzzle lock on the habitat entryway door (if
    it makes you nervous, try disregarding the encroaching plant entity’s vines):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们准备我们将用来制作可收集关键部件的艺术作品。为了视觉参考，以下是我们将用于创建关键部件和在栖息地入口门上的占位符安全谜题锁的内容（如果你感到紧张，试着忽略正在蔓延的植物实体的藤蔓）：
- en: '![Figure 9.8 – Key variants and entryway security puzzle lock](img/B18347_09_8.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 关键变体和入口安全谜题锁](img/B18347_09_8.jpg)'
- en: Figure 9.8 – Key variants and entryway security puzzle lock
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 关键变体和入口安全谜题锁
- en: Art assets
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术资产
- en: 'To follow along while using the same artwork that was created for this project,
    download the assets from this book’s GitHub repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用与本项目创建相同的艺术作品进行跟随，请从本书的 GitHub 存储库下载资产：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets)。
- en: 'Import the art assets for the security puzzle lock, the puzzle placeholder
    image, and the individual key pieces into `Assets/Sprites/Puzzle`. For the provided
    key pieces artwork, I’ve set the following properties for the desired size and
    placement:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将安全谜题锁、谜题占位符图像和单个钥匙部件的艺术资产导入到 `Assets/Sprites/Puzzle` 中。对于提供的钥匙部件艺术作品，我已设置了以下属性以实现所需的大小和位置：
- en: '`500`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`'
- en: '`X` and `Y` values so that the pivot is located in the center of the art:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X` 和 `Y` 值，以便枢轴位于艺术品的中心：'
- en: '![Figure 9.9 – Key pieces art – import settings](img/B18347_09_9.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 关键艺术品 – 导入设置](img/B18347_09_9.jpg)'
- en: Figure 9.9 – Key pieces art – import settings
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 关键艺术品 – 导入设置
- en: Now, let’s write the code for the collectible key item so that we’ll be ready
    to assemble the Prefabs for each key piece.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写收集关键物品的代码，以便我们准备好组装每个关键部件的预制件。
- en: 'Create a new script named `KeyItem` in the `Assets/Scripts` folder with the
    following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts` 文件夹中创建一个名为 `KeyItem` 的新脚本，代码如下：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, yes – there is where we specifically trigger the `OnKeyCollected` event!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是的——这就是我们特别触发`OnKeyCollected`事件的地方！
- en: This script for collecting items may be even more straightforward than the ones
    that came before it. We use `OnTriggerEnter2D()` to detect when the player enters
    the trigger volume. Does this mean we need a collider component as a sibling on
    the GameObject to which we attach the `KeyItem` script? Yes, that’s right – we
    need a `Collider2D` object with `CircleCollider2D`, keeping it nice and efficient.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个收集物品的脚本可能比之前的脚本更简单。我们使用`OnTriggerEnter2D()`来检测玩家何时进入触发体积。这意味着我们需要在附加`KeyItem`脚本的GameObject上添加一个作为兄弟的碰撞组件吗？是的，没错——我们需要一个具有`CircleCollider2D`的`Collider2D`对象，保持它既高效又简洁。
- en: Also, note that we’re comparing the tag of the collision object – using our
    `Tags.Player` constant – to ensure that only the player interacts with the trigger
    volume.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们正在比较碰撞对象的标签——使用我们的`Tags.Player`常量——以确保只有玩家与触发体积交互。
- en: Let’s give the event system `TriggerEvent()` call some additional attention
    because our event system requires a second parameter to be passed in as an event
    argument. We have to pass in *something*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对事件系统的`TriggerEvent()`调用给予一些额外的关注，因为我们的事件系统需要一个额外的参数作为事件参数传入。我们必须传入*某些东西*。
- en: As explained when the handler method was introduced, a bool value is the smallest
    data type in C# (1 byte); we’ll pass in `false` as the type’s value – we can also
    take the liberty of this meaning, “*True or false, will I pass an argument value
    for this event? False.*” We don’t even need to specify the `bool` type – as in
    `TriggerEvent<bool>()` – because the type can be inferred from the argument’s
    value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在处理方法介绍时解释的那样，布尔值是C#中最小的数据类型（1字节）；我们将传入`false`作为类型的值——我们也可以自由地这样理解，“*是或否，我会为这个事件传递一个参数值吗？否。*”我们甚至不需要指定`bool`类型——例如`TriggerEvent<bool>()`——因为类型可以从参数值推断出来。
- en: Lastly, we’ll destroy the key piece object because we collected it and no longer
    need it in the level. We’re just using `Destroy(gameObject)` directly here for
    brevity. Still, for consistency, if you’d like, you should be able to hook up
    the reusable `Destroyer` component for yourself by now (challenge accepted?).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将销毁键部件对象，因为我们已经收集了它，并且不再需要在关卡中使用它。我们在这里直接使用`Destroy(gameObject)`是为了简洁。不过，为了保持一致性，如果你愿意，现在你应该能够为自己连接可重用的`Destroyer`组件（挑战接受？）。
- en: Now, it’s time to construct the collectible key item Prefab!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候构建可收集的键物品预制件了！
- en: KeyItem Prefab and variants
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KeyItem 预制件和变体
- en: 'Creating Prefabs for reusable items in our project is second nature by now.
    Let’s breeze through the steps to create a new collectible key item **Prefab**;
    then, we’ll make **variants** that have all three key pieces and their individual
    artwork:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中创建可重用物品的预制件现在已经成为一种本能。让我们快速浏览一下创建新的可收集键物品**预制件**的步骤；然后，我们将制作具有所有三个键部件及其各自艺术作品的**变体**：
- en: Drag the `key1` Sprite (which we previously imported) from the `Assets/Sprites/Puzzle`
    folder in the **Project** window into the **Scene Hierarchy**.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前导入的`key1` Sprite（位于`Assets/Sprites/Puzzle`文件夹中）从**项目**窗口拖动到**场景层次结构**中。
- en: Double-click it to focus on it in the `(0, 0, 0)` if not, **Reset** the **Transform**
    option in the **Inspector** view so that it is – we don’t want any offsets being
    saved in the Prefab).
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击它，使其在`(0, 0, 0)`处聚焦（如果不是，请在**检查器**视图中的**变换**选项中**重置**，以确保没有偏移被保存在预制件中）。
- en: Rename `key1` to simply `key` (while selected at the top of the **Inspector**
    view, click it a second time, or use the *F2*/*Enter* key) – this will make sense
    later when we create the additional key variants.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`key1`重命名为简单的`key`（在**检查器**视图顶部选中时，点击它第二次，或使用*F2*/*Enter*键）——当我们创建额外的键变体时，这将会变得有意义。
- en: Right-click on it and select `Key1`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它，选择`Key1`。
- en: Add a `CircleCollider2D` sibling component to the `Key1` object and enable **Is
    Trigger**. Set the **Radius** value so that its hitbox is slightly larger than
    the puzzle piece Sprite (refer to *Figure 9**.10*).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CircleCollider2D`组件添加到`Key1`对象上，并启用**触发器**。设置**半径**值，使其击中框略大于拼图部件Sprite（参见图9.10）。
- en: Add the `KeyItem` script to the parent `Key1` object – there’s nothing to configure;
    all the behavior is handled in code.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`KeyItem`脚本添加到父`Key1`对象上——没有需要配置的内容；所有行为都在代码中处理。
- en: Drag `Key1` from the `Assets/Prefabs` folder in the **Project** window to make
    it a Prefab.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Key1`从**项目**窗口中的`Assets/Prefabs`文件夹拖动到`Key1`对象，使其成为一个预制件。
- en: 'Now, to create the additional key piece Prefabs as Prefab variants, follow
    these steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建额外的键件预制件作为Prefab变体，请按照以下步骤操作：
- en: Select `Key1` in the **Hierarchy** and press *Ctrl*/*Cmd* + *D* twice to make
    two duplicates of it.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择`Key1`，然后按*Ctrl*/*Cmd* + *D*两次以创建它的两个副本。
- en: Rename the duplicates `Key2` and `Key3`, respectively.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别重命名副本`Key2`和`Key3`。
- en: For `Key2`, on the child key object, change the `SpriteRenderer` `key2`. Then,
    do the same for `Key3`, and set the `key3`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Key2`，在子键对象上更改`SpriteRenderer`的`key2`。然后，对`Key3`做同样的操作，并设置`key3`。
- en: Drag `Key2` from the `Assets/Prefabs` folder. Then, in the `Key1` Prefab but
    override the `Key3`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Assets/Prefabs`文件夹中拖动`Key2`。然后，在`Key1`预制件中但覆盖`Key3`。
- en: Tip | Prefab Edit Mode | Variants
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 | Prefab编辑模式 | 变体
- en: Note that when opening **Prefab Variant** in **Prefab Edit Mode**, all overrides
    are indicated by a blue indicator along the left edge of the **Inspector** view.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当在**Prefab编辑模式**中打开**Prefab变体**时，所有覆盖项都由**检查器**视图左侧的蓝色指示器表示。
- en: 'Here are the key Prefabs and variants we just created:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们刚刚创建的关键Prefab和变体：
- en: '![Figure 9.10 – KeyItem pieces Prefabs](img/B18347_09_10.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 键项预制件](img/B18347_09_10.jpg)'
- en: Figure 9.10 – KeyItem pieces Prefabs
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 键项预制件
- en: The player can now collect the key pieces to complete the quest, but how should
    we place them in the level? First things first, delete the `Key1`, `Key2`, and
    `Key3` objects from the scene; we’re going to spawn them in.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家现在可以收集键件以完成任务，但我们应该如何在关卡中放置它们？首先，从场景中删除`Key1`、`Key2`和`Key3`对象；我们将生成它们。
- en: QuestSystem | Complete code
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: QuestSystem | 完整代码
- en: 'To view the complete code for the **QuestSystem** class and all the quest-related
    code in this chapter, visit this book’s GitHub repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看**QuestSystem**类以及本章中所有与任务相关的完整代码，请访问本书的GitHub仓库：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/)。
- en: Key instantiator – Randomness
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键生成器 – 随机性
- en: Let’s explore an easy way to implement some basic random instantiation of objects
    so that the game is different every time it’s played – addressing replayability
    is good for player engagement!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一种简单的方法来实现一些基本的随机实例化对象，以便每次游戏都不同 – 解决可重玩性对玩家参与度是有益的！
- en: Randomness in game design
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计中的随机性
- en: You’ll come across the topic of randomness in games in your game development
    journey – and not just for card games! The role of randomness in game design is
    appropriate for this entire chapter – heck, this entire book! So, keeping that
    in mind, this will be one of the most basic examples of how you can add randomness
    to a simple mechanic with effective results. In the level design, we will instantiate
    the three keys at random locations identified by a larger number of spawn points.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏开发之旅中，你将遇到游戏中的随机性主题 – 而不仅仅是纸牌游戏！随机性在游戏设计中的作用适用于整个章节 – 哎呀，整个书籍！所以，记住这一点，这将是你可以如何通过有效结果添加随机性到简单机制的最基本示例之一。在关卡设计中，我们将随机在由更多生成点标识的位置实例化三个键。
- en: The structure of the code will be to take an array of `KeyItem` (objects) (that
    is, the key pieces) and an array of `Transform` (positions) (that is, points placed
    throughout the level) as input and then output (that is, instantiate) the objects
    in order at the next randomly selected spawn point (being sure not to reuse any
    of the spawn points).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结构将是接收一个`KeyItem`（对象）数组（即键件）和一个`Transform`（位置）数组（即放置在关卡中的点）作为输入，然后输出（即实例化）对象，按下一个随机选择的生成点顺序（确保不重复使用任何生成点）。
- en: Did you visualize what the code could look like? Let’s see. Let’s walk through
    creating the code for each part.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你想象过代码可能的样子吗？让我们看看。让我们一步步创建每个部分的代码。
- en: Start by creating a new script named `KeyInstantiator` in the `Assets/Scripts`
    folder.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`Assets/Scripts`文件夹中创建一个名为`KeyInstantiator`的新脚本。
- en: 'We’ll declare the arrays that hold the key objects and the spawn points first:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明包含键对象和生成点的数组：
- en: '[PRE21]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we declared two arrays:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了两个数组：
- en: '`KeyItem[] _keyPrefabs`: This has been serialized so that it can be assigned
    in the `KeyItem` instead of a more generic `GameObject` because of the following
    reasons:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyItem[] _keyPrefabs`：由于以下原因，它已被序列化，以便可以在`KeyItem`中分配，而不是更通用的`GameObject`：'
- en: We only want Prefabs that include the `KeyItem` component to be assignable to
    the array.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只想将包含`KeyItem`组件的Prefab分配给数组。
- en: While referencing an item in the collection, we will consume the item as the
    `KeyItem` type and avoid making a `GetComponent<KeyItem>()` call.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引用集合中的项目时，我们将消耗项目作为`KeyItem`类型，并避免进行`GetComponent<KeyItem>()`调用。
- en: '`Transform[] _spawnPoints`; This has been serialized so that it can be assigned
    in the **Inspector** view; we’ll assign the GameObjects that are placed throughout
    the level where key pieces can potentially spawn. With game design in mind, be
    sure to place more than three in a level so that we’re not just randomizing what
    key piece appears at the same three positions – your limit will be the design
    or your level (and I’d be sure to place one of them where you happen to have several
    infected robots patrolling).'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transform[] _spawnPoints`; 这已经被序列化，以便可以在**检查器**视图中分配；我们将分配放置在关卡中关键部件可能生成的位置上的GameObject。考虑到游戏设计，请确保在关卡中放置超过三个，这样我们就不只是随机化三个相同位置出现的关键部件
    – 你的限制将是设计或你的关卡（并且我会确保在恰好有几个感染机器人巡逻的地方放置其中一个）。'
- en: Array (C#)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 数组（C#）
- en: An array is a type that’s declared with opposing square braces (**[]**) and
    represents a collection of items of that type. Items in the array are addressed
    by their index value, which starts at zero (for example, **_spawnPoints[0]** is
    the first **Transform** stored in the collection).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种用相对的方括号（**[]**）声明的类型，它表示该类型的项目集合。数组中的项目通过它们的索引值来标识，它从零开始（例如，**_spawnPoints[0]**是集合中存储的第一个**Transform**）。
- en: 'Here’s some additional reading: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/).'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的阅读材料：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/)。
- en: Next, we’ll add a `List` type to work with the currently available spawn points
    from the `_spawnPoints` array. Why are we doing this? We already have an `array`
    type, and now a `List` type? Yes. Arrays in C# are not easy to work with if we
    want to resize them (that is, remove an item), but a `List` type is.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向`Start()`方法的实现中添加一个`List`类型，以处理从`_spawnPoints`数组中当前可用的生成点。我们为什么要这样做？我们已经有了一个`array`类型，现在又有一个`List`类型？是的。在C#中，如果我们想要调整大小（即删除一个项目），数组就不容易处理，但`List`类型可以。
- en: 'Declare the following `List` type and add the `Start()` method with the spawn
    points assignment:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 声明以下`List`类型，并添加带有生成点分配的`Start()`方法：
- en: '[PRE22]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We declared a `List` type and initialized it in `Start()` with the `_spawnPoints`
    value:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个`List`类型，并在`Start()`中用`_spawnPoints`值初始化它：
- en: '`List<Transform> _availablePoints`: This is the `private` member variable because
    we’ll just work with the points inside the class. We’ll use this to determine
    the points available to instantiate a key.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<Transform> _availablePoints`: 这是一个`private`成员变量，因为我们只会在类内部处理这些点。我们将使用它来确定可以实例化关键点的点。'
- en: '`Start()`: We’ll scatter the key pieces throughout the level when the game
    starts… so we’ll use the `MonoBehaviour`-provided Unity message event `Start()`
    for that, yeah.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start()`: 游戏开始时，我们将把关键部件散布在整个关卡中……所以我们将使用Unity提供的`MonoBehaviour`消息事件`Start()`来做这件事，是的。'
- en: 'Now comes the fun part – random position instantiation! Add the following `foreach`
    loop to the `Start()` method’s implementation:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加随机位置实例化了 – 在`Start()`方法实现中添加以下`foreach`循环：
- en: '[PRE23]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Okay, let’s do a breakdown of this final section:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们分析这个最后的部分：
- en: '`foreach (var item in _keyPrefabs)`: We’re using `foreach` to iterate the available
    `KeyItem` Prefabs assigned in the **Inspector** view (all three of our key Prefab/variant
    pieces).'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foreach (var item in _keyPrefabs)`: 我们使用`foreach`来迭代在**检查器**视图中分配的可用`KeyItem`
    Prefabs（我们所有的三个关键Prefab/变体部件）。'
- en: '`Random.Range(0, _availablePoints.Count)`: A bit of magic? No, this is Unity’s
    `int` values, however, like in our use case; otherwise, it’s inclusive of the
    second number when using `float` values). We don’t want to use the `Count` value
    because array indexes are zero-based (so we’d have to specify `Count -` `1` otherwise):'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Random.Range(0, _availablePoints.Count)`: 这是一种魔法吗？不，这是Unity的`int`值，然而，在我们的用例中；否则，当使用`float`值时，它是包含第二个数字的）。我们不希望使用`Count`值，因为数组索引是从零开始的（因此我们否则必须指定`Count
    - 1`）：'
- en: Note that we obtain `_availablePoints.Count` every iteration. That’s because,
    only two lines below, we’re removing the randomly selected point from `List` by
    the `randomIndex` value that’s returned, so it’s not used again.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们每次迭代都会获取`_availablePoints.Count`。那是因为，在下面两行中，我们将通过返回的`randomIndex`值从`List`中删除随机选择的点，因此它不会被再次使用。
- en: Additional reading | Unity documentation
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**Random.Range()**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**Random.Range()**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml)。'
- en: '`Instantiate()`: We spawn the current `item` in the array into the scene at
    the randomly selected spawn point position, `randomIndex`, with zero rotation
    (that is, `Quaternion.Identity`).'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Instantiate()`: 我们将数组中的当前 `item` 在随机选择的出生点位置 `randomIndex` 处实例化到场景中，旋转为零（即
    `Quaternion.Identity`）。'
- en: '`RemoveAt(ramdomIndex)`: A C# `List` type provides a remove method that not
    only deletes an item from the collection but also resizes it. Hence, the `Count`
    property reflects the number of items that remain.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveAt(randomIndex)`: C# `List` 类型提供了一个删除方法，不仅可以从集合中删除一个项目，还可以调整其大小。因此，`Count`
    属性反映了剩余项目的数量。'
- en: It sounds like a lot when breaking it down like this, but it’s a short and sweet
    random placement script.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样分解时，听起来很多，但这只是一个简短而甜美的随机放置脚本。
- en: The last step is, of course, setting the instantiator up in our scene so that
    the key pieces can be placed in the game level.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步当然是设置实例化器在我们的场景中，以便可以将关键部件放置在游戏关卡中。
- en: Instantiator scene object setup
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实例化器场景对象设置
- en: 'Here’s what we’ll do to set up the new `KeyInstantiator` script on an object
    in our scene so that our keys are randomly spawned for the player to find:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们要做的是在我们的场景中设置新的 `KeyInstantiator` 脚本，以便我们的钥匙可以随机生成供玩家寻找：
- en: Create a `KeyInstantiator` component.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `KeyInstantiator` 组件。
- en: In the `Assets/Prefabs` folder in the **Project** window to the **KeyPrefabs**
    field.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Project** 窗口的 **Assets/Prefabs** 文件夹中到 **KeyPrefabs** 字段。
- en: Then, after placing – more than three! – GameObjects in the level that represent
    the possible spawn position of a key piece, select them in the **Hierarchy** and
    drag them to the **SpawnPoints** field in the **Inspector** view (don’t forget
    that you can lock the **Inspector** window so that it doesn’t change when you’re
    selecting the objects you want to assign).
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在关卡中放置 – 超过三个！ – 代表钥匙可能出生位置的 GameObject 之后，在 **Hierarchy** 中选择它们，并将它们拖到 **Inspector**
    视图的 **SpawnPoints** 字段（别忘了你可以锁定 **Inspector** 窗口，这样在您选择要分配的对象时它不会改变）。
- en: '*Figure 9**.11* shows the result of the preceding steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9**.11* 展示了前面步骤的结果：'
- en: '![Figure 9.11 – Key instantiator object setup](img/B18347_09_11.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 关键实例化对象设置](img/B18347_09_11.jpg)'
- en: Figure 9.11 – Key instantiator object setup
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 关键实例化对象设置
- en: You may have noticed the pink diamonds in the preceding figure. I’ve assigned
    a pink diamond icon (assignable at the top of the **Inspector** view) to the key
    spawn point objects so that they are easy to find in the **Scene** view while
    I’m working on the level design. I’ve also grouped the key spawn points under
    a parent **Key Spawn Points** object in the **Hierarchy**.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了前一个图中的粉色钻石。我已经将一个粉色钻石图标（可在 **Inspector** 视图的顶部分配）分配给关键出生点对象，以便我在进行关卡设计时在
    **Scene** 视图中容易找到它们。我还将关键出生点分组在 **Hierarchy** 中的父 **Key Spawn Points** 对象下。
- en: With that, we now have key pieces randomly placed in our level when the game
    starts. Next, we’ll sort out a drawing issue before moving on to solving the key
    puzzle!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，现在当游戏开始时，我们的关卡中就有了随机放置的关键部件。接下来，我们将在解决钥匙谜题之前解决一个绘图问题！
- en: Instantiated Sprite drawing order
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实例化精灵绘制顺序
- en: The key pieces will be instantiated on the `Default` `0` for the default values.
    Because we’ve set up our environment with *default objects* originating “in the
    center of the depth layers,” we can be confident that the instantiated pieces
    will not be obstructed. This can be compensated for when instantiated if needed,
    but this can simply be avoided if we take some care in the environment layout.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部件将在 `Default` 的 `0` 处实例化，对于默认值。因为我们已经将环境设置为从“深度层的中心”起源的 *默认对象*，我们可以确信实例化的部件不会被遮挡。如果需要，这可以在实例化时进行补偿，但如果我们对环境布局稍加注意，就可以简单地避免这种情况。
- en: In this section, we learned how to create a quest system, make new quests with
    unique properties and requirements for completion, assign a quest to the player,
    and query a quest’s status to advance the gameplay. We also saw how to utilize
    the event system to build other systems on top of its foundation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建一个任务系统，创建具有独特属性和完成要求的任务，将任务分配给玩家，并查询任务状态以推进游戏玩法。我们还看到了如何利用事件系统在其基础上构建其他系统。
- en: In the next section, we’ll integrate a sliding puzzle as the habitat entryway’s
    security lock system, where solving it wins the game.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将集成滑动拼图作为栖息地入口的安全锁系统，解决拼图即可赢得游戏。
- en: Solving the key puzzle and winning the game
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决关键谜题并赢得游戏
- en: We could spend a whole lot of time here designing a novel puzzle for the security
    lock system. Still, that falls outside the scope of this book and would not provide
    the learning opportunity I want to cover – that is, using third-party assets in
    your game. This isn’t to say that you shouldn’t strive to introduce a new and
    original idea in your game – any way you can differentiate your game and offer
    players a remarkable and unique experience is time well spent!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里花很多时间设计一个新颖的谜题用于安全锁系统。但这超出了本书的范围，也不会提供我想覆盖的学习机会 – 那就是在你游戏中使用第三方资产。这并不是说你不应该努力在你的游戏中引入新的原创想法
    – 任何能让你区分游戏并给玩家带来独特体验的方法都是值得的！
- en: We will use the well-known sliding tile puzzle for the habitat entryway’s security
    puzzle lock.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用众所周知的滑动拼图作为栖息地入口的安全谜题锁。
- en: Sliding tile puzzle
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动拼图
- en: I’ve only briefly mentioned the **Unity Asset Store**, but I want to bring some
    well-deserved attention to it now. The Unity Asset Store contains a wealth of
    assets that both Unity and third parties provide. You can find just about anything
    you would need for your games, including pre-made systems, frameworks, characters,
    animations, 2D and 3D art assets, music and sound effects, VFX, and more, in almost
    every genre and style you can imagine.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前只是简要提到了**Unity Asset Store**，但现在我想给它一些应得的关注。Unity Asset Store包含了Unity和第三方提供的丰富资源。你可以找到几乎所有你为游戏所需的东西，包括预制的系统、框架、角色、动画、2D和3D艺术资源、音乐和音效、VFX等等，几乎涵盖了你能想象到的每一个类型和风格。
- en: However, integrating solutions and assets from varying vendors isn’t always
    trivial. This section will be dedicated to both the value of leveraging existing
    pre-made assets and identifying some issues you may need to work through to have
    them functioning in your project. You may be thinking that I’ve alluded to a level
    of quality for third-party assets that indicates they are not good – while that
    may be true in some rare cases (buyer beware, as usual), issues can arise that
    have nothing to do with the asset and all to do with the changes and advances
    in technologies that comes with newer Unity version releases. Rather than continuing
    in abstract terms, let’s move forward with the specific example I’ll provide.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，整合来自不同供应商的解决方案和资源并不总是那么简单。本节将致力于利用现有预制资产的价值，并识别一些你可能需要解决的问题，以便它们能在你的项目中正常工作。你可能认为我暗示了第三方资产的质量水平，表明它们并不好
    – 虽然在某些罕见情况下这可能确实如此（如往常一样，买者需谨慎），但问题可能完全与资产无关，而是与新技术版本发布带来的技术和进步有关。而不是继续在抽象层面上讨论，让我们继续前进，看看我将提供的具体例子。
- en: 'For reference, here is the sliding tile puzzle we’ll create with the tiles
    already scrambled (refer to *Figure 9**.3* for the unscrambled version):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，以下是我们将创建的滑动拼图，拼图块已经打乱（参见图*9.3*查看未打乱的版本）：
- en: '![Figure 9.12 – Sliding puzzle scrambled tiles](img/B18347_09_12.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 滑动拼图打乱后的拼图块](img/B18347_09_12.jpg)'
- en: Figure 9.12 – Sliding puzzle scrambled tiles
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 滑动拼图打乱后的拼图块
- en: As mentioned previously, we’re going to leverage an existing asset from the
    Unity Asset Store to rapidly incorporate a sliding puzzle feature that will include
    everything necessary to slice an image into tiles, scramble the tiles, respond
    to user input for sliding the tiles, and calculate when the puzzle has been solved.
    If we had to develop on our own, all of these requirements would take significantly
    more time to create, code, debug, and test. Unity Asset Store assets generally
    come with the benefit of dozens of developers (or hundreds in some cases) using
    the assets in their projects and reporting back bugs and discrepancies to the
    asset developer for further improvement – and you directly benefit from others’
    efforts.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将利用Unity Asset Store中的一个现有资产，快速整合滑动拼图功能，这将包括将图像切割成拼图块、打乱拼图块、响应用户滑动拼图的输入，以及计算何时拼图被解决。如果我们必须独立开发，所有这些要求都需要更多的时间来创建、编码、调试和测试。Unity
    Asset Store的资产通常具有数十位（在某些情况下是数百位）开发者在其项目中使用这些资产并报告错误和差异给资产开发者的好处 – 你可以直接从他人的努力中受益。
- en: 'Without further ado, we’ll be using a free asset called **Sliding Tile Puzzle
    Game** by Hyper Luminal Games ([https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798](https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798)):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，我们将使用一个名为**滑动拼图游戏**的免费资源，由Hyper Luminal Games提供([https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798](https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798))：
- en: '![Figure 9.13 – Sliding Tile Puzzle Game](img/B18347_09_13.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – 滑动拼图游戏](img/B18347_09_13.jpg)'
- en: Figure 9.13 – Sliding Tile Puzzle Game
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 滑动拼图游戏
- en: Several steps will be required to use the asset in our Unity 2022 project due
    to changes in the **Unity Scripting API**, in addition to changes required to
    support **Universal RP** (**URP**), the *render pipeline* we’ve based the project
    on, since the time the asset was released (way back in 2016, for Unity 5).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**Unity脚本API**的变化，以及为了支持**通用渲染管线**（**URP**），即我们基于该项目的时间（早在2016年，Unity 5），我们需要执行几个步骤才能在Unity
    2022项目中使用该资源。
- en: Let’s get started by obtaining the asset and importing it into the project.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始获取资源并将其导入到项目中。
- en: Importing the sliding tile puzzle asset
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入滑动拼图资源
- en: After going through the process of purchasing an asset or clicking **Add to
    My Assets**, you have the option of using the **Open in Unity** button from within
    the Unity Asset Store. Alternatively, you may open the **Package Manager** window
    in the Unity Editor, select **My Assets** from the **Packages** dropdown, find
    the asset in the list, click **Download**, and then click **Import**.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成购买资源或点击**添加到我的资源**的过程后，你可以在Unity资源商店中使用**在Unity中打开**按钮。或者，你可以在Unity编辑器中打开**包管理器**窗口，从**包**下拉菜单中选择**我的资源**，在列表中找到资源，点击**下载**，然后点击**导入**。
- en: In my experience, most assets are designed to be imported into your existing
    project. Still, some assets are provided as *complete projects* and, therefore,
    cannot be imported directly into your project. The sliding tile puzzle asset requires
    an additional step to import into your project because it is provided as a complete
    project, and it’s best not to overwrite any of your current project settings!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，大多数资源都是设计为导入到你的现有项目中的。然而，一些资源作为**完整项目**提供，因此不能直接导入到你的项目中。滑动拼图资源需要额外的步骤才能导入到你的项目中，因为它是一个完整项目，最好不要覆盖任何当前项目设置！
- en: 'Let’s walk through the steps; this won’t take long:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来操作；这不会花费太多时间：
- en: 'Importing the sliding tile puzzle asset from the **Asset Store** page or **Package
    Manager** will produce the following **Importing a complete project** warning
    dialog:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**资源商店**页面或**包管理器**导入滑动拼图资源将产生以下**导入完整项目**警告对话框：
- en: '![Figure 9.14 – The Importing complete project dialog](img/B18347_09_14.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 导入完整项目对话框](img/B18347_09_14.jpg)'
- en: Figure 9.14 – The Importing complete project dialog
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 导入完整项目对话框
- en: Click the **Switch Project** button to create a temporary project the asset
    will be imported into. Unity will automatically generate a temporary project name.
    We’ll delete this project when we’re finished extracting the asset from it, so
    don’t worry.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**切换项目**按钮以创建一个临时项目，该资源将被导入其中。Unity将自动生成一个临时项目名称。当我们从该项目中提取资源完成后，我们将删除该项目，所以请放心。
- en: When Unity has opened and everything has finished importing, the `Assets/HyperLuminal`
    folder (found in the **Project** window).
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Unity打开并完成导入后，你将在**项目**窗口中找到`Assets/HyperLuminal`文件夹。
- en: Right-click on the `SlidingTilePuzzle` folder and select **Export Package…**.
    This will open an **Exporting package** dialog, where you can change what’s included
    in the export. We want everything, so click the **Export…** button in the bottom-right
    corner.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`SlidingTilePuzzle`文件夹并选择**导出包…**。这将打开一个**导出包**对话框，在这里你可以更改导出内容。我们希望包含所有内容，所以点击右下角的**导出…**按钮。
- en: When the file save window opens, enter `SlidingTilePuzzle` for the `.unitypackage`
    filename and pick an easily accessible folder; we will be importing from that
    same folder shortly.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文件保存窗口打开时，将`.unitypackage`文件名输入为`SlidingTilePuzzle`，并选择一个易于访问的文件夹；我们很快将从这个相同的文件夹导入。
- en: 'Close Unity. You will be prompted with a **Keep Project?** dialog. You can
    safely click the **Forget** button since we no longer need it:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭Unity。你将看到一个**保留项目？**对话框。你可以安全地点击**忘记**按钮，因为我们不再需要它：
- en: Note that even though you confirmed forgetting it, you may still see an erroneous
    project show up in Unity Hub that represents this temporary project. If so, remove
    it and delete the project folder.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，即使你确认忘记了它，你仍然可能在Unity Hub中看到一个错误的项目，代表这个临时项目。如果是这样，请将其删除并删除项目文件夹。
- en: 'Now, back in our game’s project, let’s import the saved `.unitypackage` file
    by going to `SlidingTilePuzzle.unitypackage` from the location we saved it in
    earlier:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到我们的游戏项目中，让我们通过从我们之前保存的位置打开`SlidingTilePuzzle.unitypackage`来导入保存的`.unitypackage`文件：
- en: '![Figure 9.15 – The Import Unity Package dialog](img/B18347_09_15.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15 – 导入Unity包对话框](img/B18347_09_15.jpg)'
- en: Figure 9.15 – The Import Unity Package dialog
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 导入Unity包对话框
- en: All the items should be marked as **New** unless we’ve previously imported the
    package. Go ahead and click **Import** so that we can continue integrating the
    sliding puzzle.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有项目都应标记为**新**，除非我们之前已导入该包。请继续点击**导入**，以便我们继续集成滑动拼图。
- en: Tip | Project organization
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 | 项目组织
- en: Asset vendors make their own choices on the location of their assets in the
    project folder structure, so importing many third-party assets can get a bit messy
    and unorganized. To maintain some level of sanity in your project files, I suggest
    placing all third-party assets under this **Assets/Third** **Party** folder.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 资产供应商会在项目文件夹结构中自行选择其资产的位置，因此导入许多第三方资产可能会变得有些杂乱无章。为了在项目文件中保持一定的理智，我建议将所有第三方资产放在这个**Assets/Third
    Party**文件夹下。
- en: For example, in *Figure 9**.15*, you can see *SlidingTilePuzzle*, which we will
    import to the **Assets/HyperLuminal** folder. Please create a new **Assets/Third
    Party** folder and move the **HyperLuminal** folder as a child of it. Mischief
    managed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在*图9.15*中，你可以看到*SlidingTilePuzzle*，我们将将其导入到**Assets/HyperLuminal**文件夹。请创建一个新的**Assets/Third
    Party**文件夹，并将**HyperLuminal**文件夹作为其子文件夹。问题解决。
- en: Now, let’s update the asset so that it works with our Unity 2022 project requirements.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新资产，使其符合我们的Unity 2022项目要求。
- en: Updating the puzzle tile shader
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新拼图瓷砖着色器
- en: Our first order of business is to update from the built-in legacy renderer to
    the URP renderer. In Unity 5, we only had the built-in renderer, so it makes sense
    that we’d need to convert items related to the render for this asset.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是更新从内置的遗留渲染器到URP渲染器。在Unity 5中，我们只有内置的渲染器，因此我们需要将与此资产相关的渲染相关项目进行转换是有意义的。
- en: If you were to open the `SlidingTilePuzzle` example scene in the `Assets/Third
    Party/HyperLuminal/SlidingTilePuzzle/Scenes` folder and enter **Play Mode** now,
    you’d get a giant pink square. Pink (or magenta) is the color Unity uses to represent
    a material or shader error – unless you’ve specifically made an object this color,
    seeing it in your **Scene** or **Game** view is generally not good.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在打开`Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scenes`文件夹中的`SlidingTilePuzzle`示例场景并进入**播放模式**，你会看到一个巨大的粉色方块。粉色（或洋红色）是Unity用来表示材质或着色器错误的颜色
    – 除非你专门创建了一个这个颜色的对象，否则在**场景**或**游戏**视图中看到它通常不是什么好事。
- en: 'The asset takes a Prefab approach for the type of sliding puzzle you want to
    make and provides Prefabs for `3x3`, `4x4`, and `5x5` sliding puzzles – we will
    make a 3x3 sliding puzzle and work with that specific `3x3` Prefab. Follow these
    steps to update the renderer-specific issues:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 该资产采用预制体方法来制作你想要的滑动拼图类型，并为`3x3`、`4x4`和`5x5`滑动拼图提供预制体 – 我们将制作一个3x3滑动拼图，并使用特定的`3x3`预制体。按照以下步骤更新渲染器特定问题：
- en: In the `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs` folder, duplicate
    the `SlidingTile_3by3` Prefab and rename it `SlidingTile_3by3_URP`.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs`文件夹中，复制`SlidingTile_3by3`预制体并将其重命名为`SlidingTile_3by3_URP`。
- en: Double-click on `SlidingTile_3by3_URP` to enter **Prefab** **Edit Mode**.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`SlidingTile_3by3_URP`进入**预制体****编辑模式**。
- en: Find the `ST_Puzzle Display` component and change the *Puzzle Shader* from `Mobile/Unlit`
    to `Packages/Universal RP/Shaders/2D/Sprite-Unlit-Default` – you must drag this
    shader in from the `Packages`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`ST_Puzzle Display`组件，将**拼图着色器**从`Mobile/Unlit`更改为`Packages/Universal RP/Shaders/2D/Sprite-Unlit-Default`
    – 你必须从`Packages`中拖动这个着色器。
- en: Save the Prefab.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存预制体。
- en: 'We have one more update to make for the renderer issues, and that’s on the
    puzzle tile itself, but first, we need a new **Universal RP Sprite** material.
    Follow these steps to update the asset:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对渲染器问题进行一次更新，那就是拼图瓷砖本身，但首先，我们需要一个新的**Universal RP Sprite**材质。按照以下步骤更新资产：
- en: Create a new *material* named `PuzzleTile 1` in the `Assets/Materials` folder
    and select it.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Materials` 文件夹中创建一个新的 *材质*，命名为 `PuzzleTile 1` 并选择它。
- en: In the **Shader** drop-down menu at the top of the **Inspector** view, select
    the **Universal Render** **Pipeline/2D/Sprite-Unlit-Default** shader.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 视图的顶部 **着色器** 下拉菜单中，选择 **通用渲染管线/2D/Sprite-Unlit-Default** 着色器。
- en: In the `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs` folder, we
    also have the `SlideTile` Prefab. Duplicate it and rename it `SlideTile_URP`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs` 文件夹中，我们还有一个 `SlideTile`
    预制体。复制它并将其重命名为 `SlideTile_URP`。
- en: Double-click on `SlideTile_URP` to enter **Prefab** **Edit Mode**.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `SlideTile_URP` 进入 **预制体编辑模式**。
- en: Find the `MeshRenderer` component and change `Element 0` to `PuzzleTile 1`.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 `MeshRenderer` 组件并将 `Element 0` 更改为 `PuzzleTile 1`。
- en: Save the Prefab.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存预制体。
- en: Now that the rendering issues of the `Sliding Tile Puzzle` asset have been updated,
    we are ready to work within our **Lit 2D (****URP)** scenes!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`滑动拼图` 资产的渲染问题已经更新，我们可以在 **Lit 2D (URP)** 场景中工作了！
- en: We only have one more issue with updating, and that’s for the interactivity
    – that is, being able to slide the tiles from player input.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在更新中只有一个问题，那就是交互性——也就是说，能够根据玩家输入滑动拼图。
- en: Updating the input system
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新输入系统
- en: The new input system is called new because… well, it’s new. Unity 5 only had
    the legacy `InputManager` system; of course, since we’re using the new input system
    in our project, we need to make some changes to support it. All the updates for
    the renderer were done in the editor, but now, we’ll have to change some code.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 新输入系统之所以被称为新，是因为……嗯，它是新的。Unity 5 只有一个传统的 `InputManager` 系统；当然，由于我们在项目中使用新的输入系统，我们需要进行一些更改以支持它。所有渲染器的更新都是在编辑器中完成的，但现在，我们得更改一些代码。
- en: 'Make the following code changes:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 进行以下代码更改：
- en: Find the `ST_PuzzleTile` script in the `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts`
    folder and open it in your IDE.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts` 文件夹中找到 `ST_PuzzleTile`
    脚本，并在你的 IDE 中打开它。
- en: 'Add a new `using` statement at the top of the script. We’ll need this `UnityEngine`
    namespace to support the code changes:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部添加一个新的 `using` 语句。我们需要这个 `UnityEngine` 命名空间来支持代码更改：
- en: '[PRE24]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the `IPointerClickHandler` interface to the class definition to support
    the new input system’s `pointer` `click` method:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `IPointerClickHandler` 接口添加到类定义中，以支持新输入系统的 `pointer` `click` 方法：
- en: '[PRE25]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At the bottom of the script, replace `void OnMouseDown()` with the following:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本底部，将 `void OnMouseDown()` 替换为以下内容：
- en: '[PRE26]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save the script and return to the Unity Editor; you’re done.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到 Unity 编辑器；你完成了。
- en: Unfortunately, you can no longer test the sliding puzzle using the vendor’s
    `SlidingTilePuzzle` example scene as-is.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你不能再使用供应商的 `SlidingTilePuzzle` 示例场景来测试滑动拼图。
- en: 'To test the updates and the final update requirements for every scene you want
    to use the sliding puzzle in, follow these steps:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试更新以及每个你想使用滑动拼图的场景的最终更新要求，请按照以下步骤操作：
- en: Create a new scene (**File** | **New Scene** or *Ctrl*/*Cmd* + *N*) and select
    the **Lit 2D (URP)** new scene template.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景（**文件** | **新建场景** 或 *Ctrl*/*Cmd* + *N*）并选择 **Lit 2D (URP)** 新场景模板。
- en: Add a `PhysicsRaycaster` component to **Main Camera**.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PhysicsRaycaster` 组件添加到 **主摄像机**。
- en: Add `UI Event System` to the scene. Ensure you update the `StandaloneInputModule`
    component for the new input system.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `UI Event System` 添加到场景中。确保更新 `StandaloneInputModule` 组件以支持新输入系统。
- en: Add the `SlidingTile_3by3_URP` Prefab to the scene.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SlidingTile_3by3_URP` 预制体添加到场景中。
- en: Enter **Play Mode**. Test. Enjoy.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 **播放模式**。测试。享受。
- en: And that completes all the updates required to modernize *Sliding Tile Puzzle*
    for the URP render and the new input system. Not too bad.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了对 *滑动拼图* 进行 URP 渲染和新输入系统现代化的所有更新要求。还不错。
- en: As you will see, the Unity Asset Store is a great resource with many talented
    asset publishers. It can help to save you (a lot of) time building game prototypes
    quickly, polishing your games, and creating vertical slices early (for seeking
    a publisher or investors in your project).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Unity 资产商店是一个极好的资源，拥有许多才华横溢的资产发布者。它可以帮助你快速构建游戏原型、打磨你的游戏，并在早期创建垂直切片（以寻找你的项目出版商或投资者）。
- en: We will, however, need one additional change to integrate the sliding puzzle
    into our gameplay. And that is adding an event for when the security puzzle lock
    has been solved so that we can trigger an appropriate action – a logical one at
    this point would be granting the player access to the habitat station. Open sesame!
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要进行一个额外的更改，以便将滑动拼图集成到我们的游戏玩法中。那就是添加一个当安全拼图锁被解决时的事件，以便我们可以触发适当的动作 – 在这一点上，一个合理的动作是授予玩家进入栖息地站点的权限。芝麻开门！
- en: Adding an event for completion
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加完成事件
- en: We won’t be covering any new ground with this task. We’ve added events in several
    different ways already. Our choice this time will be a `UnityEvent` event so that
    we can set the triggered handlers in the **Inspector** view.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们不会涉及任何新的内容。我们已经以几种不同的方式添加了事件。这次我们的选择将是一个`UnityEvent`事件，这样我们就可以在**检查器**视图中设置触发处理程序。
- en: 'Find the `ST_PuzzleDisplay` script in the `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts`
    folder and open it in your IDE. Then, modify the script with the following additions:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts`文件夹中找到`ST_PuzzleDisplay`脚本，并在您的IDE中打开它。然后，通过以下添加修改脚本：
- en: 'Add a new `using` statement at the top of the script as required for declaring
    our event:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部添加一个新的`using`语句，如需声明我们的事件：
- en: '[PRE27]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add a `public` `UnityEvent` event to be triggered when the puzzle is completed:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个在拼图完成时被触发的`public` `UnityEvent`事件：
- en: '[PRE28]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Modify the `CheckForComplete()` method by adding the `OnPuzzleComplete` invocation
    line within the `if(Complete)` block:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`if(Complete)`块内添加`OnPuzzleComplete`调用行来修改`CheckForComplete()`方法：
- en: '[PRE29]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We now have a convenient way to respond to the entryway security puzzle lock
    being solved/completed.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个方便的方式来响应入口处安全拼图锁被解决/完成。
- en: When we set up the `QuestHasCompleted` component on the habitat entryway, we
    left unfinished business for our future selves. We are now our future selves,
    so we can complete the `OnQuestComplete` event assignment and show our security
    puzzle lock to the player.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在栖息地入口处设置`QuestHasCompleted`组件时，我们为我们的未来自己留下了未完成的事情。现在我们是我们的未来自己，因此我们可以完成`OnQuestComplete`事件分配，并向玩家展示我们的安全拼图锁。
- en: Setting up a new puzzle prefab
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置新的拼图预制件
- en: Yup, that’s right – we’ll need another Prefab for the sliding puzzle lock. We’ll
    set that up now so that it’s shown to the player – with our image – when all three
    keys have been collected and they reach the habitat entryway.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，没错 – 我们还需要另一个预制件来表示滑动拼图锁。我们现在将设置它，以便在收集到所有三把钥匙并到达栖息地入口时向玩家显示 – 使用我们的图像。
- en: 'Follow these steps to create the new Prefab:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建新的预制件：
- en: Drag the `SlidingTile_3by3_URP` Prefab into the `0,` `0, 0`)).
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SlidingTile_3by3_URP`预制件拖动到`(0, 0, 0)`。
- en: Right-click on it and select `Key Puzzle Lock` – you’ll end up with the actual
    puzzle as the child (yes, this is our standard approach to Prefab structure, if
    you still weren’t sure).
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择`Key Puzzle Lock` – 你将得到实际的拼图作为子组件（是的，这是我们标准的预制件结构方法，如果你还不确定的话）。
- en: Find the `key_puzzle1-complete_512` image in the `Assets/Sprites/Puzzle` folder
    (this is one of the images we imported in the previous *KeyItem component* section)
    and change its import settings in the `512`
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Sprites/Puzzle`文件夹中找到`key_puzzle1-complete_512`图像（这是我们在之前的*KeyItem组件*部分中导入的图像之一），并在`512`中更改其导入设置
- en: 'Find the `ST_PuzzleDisplay` component and assign the following:'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到`ST_PuzzleDisplay`组件并分配以下内容：
- en: '*Puzzle* *Image*: `key_puzzle1-complete_512`'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*拼图图像*：`key_puzzle1-complete_512`'
- en: '*Puzzle Scale*: `0.7`, `0.7`, `0.7`:![Figure 9.16 – Sliding puzzle configuration](img/B18347_09_16.jpg)'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*拼图缩放*：`0.7`，`0.7`，`0.7`：![图9.16 – 滑动拼图配置](img/B18347_09_16.jpg)'
- en: Figure 9.16 – Sliding puzzle configuration
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 滑动拼图配置
- en: Now, disable the `SlidingTile_3by3_URP` object. Yes, you heard that right; we’re
    going to disable the object with the `ST_PuzzleDisplay` component on it because
    we only want the puzzle to show and do its trick when it’s triggered by the player
    reaching the habitat entryway with all three keys collected.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，禁用`SlidingTile_3by3_URP`对象。是的，你听到的没错；我们将禁用带有`ST_PuzzleDisplay`组件的对象，因为我们只想在玩家收集到所有三把钥匙并到达栖息地入口时显示拼图并执行其功能。
- en: Drag the `Assets/Prefabs` folder to create the puzzle lock Prefab.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Assets/Prefabs`文件夹拖动以创建拼图锁预制件。
- en: We now have our customized security puzzle lock ready to go! The final setup
    ensures it shows in place when required at the habitat entryway location.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了定制的安全拼图锁！最终的设置确保它在需要时在栖息地入口处显示。
- en: Adding the puzzle lock to the entryway
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将拼图锁添加到入口处
- en: 'We already set up our **Puzzle Trigger** at the location of the habitat entryway.
    Now, let’s add the security puzzle lock to its location so that it shows and is
    interactable in place at the entryway door. With everything already set up and
    ready to go, it’s a simple two-step process:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在栖息地入口处设置了我们的**拼图触发器**。现在，让我们将其安全拼图锁添加到该位置，以便它在入口门处显示并可交互。由于一切都已经设置好并准备就绪，这是一个简单的两步过程：
- en: 'Position the **Key Puzzle Lock** Prefab in the level nearby, slightly above,
    or right at the habitat entryway door. You can reference *Figure 9**.12* for where
    I placed it: at the door and just above the player character’s head.'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**钥匙拼图锁**预制件放置在关卡中靠近、略微上方或正好在栖息地入口门处。您可以参考*图9**.12*了解我放置的位置：在门上，正好在玩家角色头部上方。
- en: 'Show the sliding puzzle from the `QuestHasCompleted` component’s `OnQuestComplete()`
    event by doing the following:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下步骤显示由`QuestHasCompleted`组件的`OnQuestComplete()`事件触发的滑动拼图：
- en: Add a new entry for `OnQuestComplete()` as an additional action to `PlayerInput.enabled`
    by clicking the little plus (`SlidingTile_3by3_URP` child object of `GameObject`
    | `SetActive(bool)` from the function dropdown, and tick the checkbox to pass
    `true`.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击小加号（`SlidingTile_3by3_URP`是`GameObject`的子对象 | `SetActive(bool)`从函数下拉菜单，并勾选复选框以传递`true`），为`OnQuestComplete()`添加一个新条目作为`PlayerInput.enabled`的附加操作。
- en: That’s it! You can now fully test the quest life cycle, collect three keys scattered
    throughout the level to complete the quest, trigger an event for a completed quest,
    and solve an in-game sliding puzzle. Yay!
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在可以完全测试任务生命周期了，收集散布在关卡中的三个钥匙以完成任务，触发已完成任务的的事件，并解决游戏中的滑动拼图。太棒了！
- en: All that remains is what we need to do when beating the entryway puzzle lock
    – that is, winning.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是我们在解决入口拼图锁时需要做的事情——即胜利。
- en: Winning
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 胜利
- en: When the security puzzle lock is solved, we gain entry to the habitat station.
    The `OnPuzzleComplete()` `UnityEvent` event we just added to the `Sliding Tile
    Puzzle Game` code gets triggered, so this is our opportunity to do something for
    a win state.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当安全拼图锁被解决后，我们就可以进入栖息地站。我们刚刚添加到`Sliding Tile Puzzle Game`代码中的`OnPuzzleComplete()`
    `UnityEvent`事件被触发，所以这是我们为胜利状态做些事情的机会。
- en: My game design plan, and plan for this book’s projects, is to continue gameplay
    within the habitat station interior in [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187),
    where things will start having more depth. I don’t mean that figuratively; the
    project the next chapter introduces will be a 3D **first-person shooter** (**FPS**)
    game. For now, we’ll implement a nice cinematic fade to black and *To be continued…*.
    But how do we solve the problem of implementing a fade-out and on-screen text
    sequence without figuring out a bunch of synchronized linear timing code? Let’s
    see.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我的游戏设计计划和本书项目的计划是在[*第10章*](B18347_10.xhtml#_idTextAnchor187)中继续游戏玩法，在那里事情将开始变得更加深入。我并不是在比喻意义上说这个；下一章引入的项目将是一个3D**第一人称射击**（**FPS**）游戏。现在，我们将实现一个漂亮的黑白电影淡入，以及*待续…*。但是，我们如何在不知道大量同步线性时间代码的情况下解决实现淡出和在屏幕上显示文本序列的问题呢？让我们看看。
- en: Timeline
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间线
- en: '**Timeline** is not a new feature in Unity 2022\. It’s been around since Unity
    2017, but I feel it’s an underrated core feature that doesn’t get nearly the attention
    it deserves for game developers. For cinematic content creators, however, it was
    a game changer since Timeline allows the easy creation of linear sequences affecting
    almost any object in the scene.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间线**不是Unity 2022的新特性。它自Unity 2017以来就存在了，但我感觉它是一个被低估的核心特性，没有得到游戏开发者应有的关注。然而，对于电影内容创作者来说，它却是一个变革性的功能，因为时间线允许轻松创建影响场景中几乎所有对象的线性序列。'
- en: 'Timeline is based on two elements that work in tandem: a **Timeline** file-based
    asset and a **Playable Director** component. An important thing to note is that
    a Timeline instance is scene-based.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线基于两个协同工作的元素：一个基于**时间线**文件资产的资源和一个**可播放导演**组件。需要注意的是，时间线实例是场景相关的。
- en: Additional reading | Unity documentation
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity文档
- en: 'Timeline: [https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml).'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线：[https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml).
- en: 'We will leverage the pure power of Timeline’s simplicity to affect a set of
    objects linearly to knock out this ending fade-out. Let’s start by creating our
    Timeline instance:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用时间线简单性的纯粹力量，线性地影响一组对象，以消除这个结束淡出。让我们首先创建我们的时间线实例：
- en: First, create a location in our project to store Timeline assets. Create a new
    folder called `Assets/Timelines`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在项目中创建一个位置来存储时间轴资产。创建一个名为`Assets/Timelines`的新文件夹。
- en: Staying within the `Ending Timeline` by right-clicking and choosing **Create**
    | **Timeline**.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Ending Timeline`内通过右键单击并选择**创建** | **时间轴**。
- en: We can now open the **Timeline** window by double-clicking the **Ending Timeline**
    asset in the **Project** window.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过在**项目**窗口中双击**结束时间轴**资产来打开**时间轴**窗口。
- en: If you’re not used to working in a timescale of **Frames**, use the gear icon
    in the top-right corner of the **Timeline** window to select **Seconds** (as seen
    in *Figure 9**.17*).
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你习惯于在**帧**的时间尺度上工作，请使用**时间轴**窗口右上角的齿轮图标选择**秒**（如图9.17.17所示）。
- en: Finish the Timeline creation by dragging the **Ending Timeline** asset into
    the **Scene Hierarchy** to make the scene-based instance.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将**结束时间轴**资产拖动到**场景层次结构**中完成时间轴的创建，以创建基于场景的实例。
- en: 'We’ll use just two UI widgets to achieve the fade-out effect and title while
    following these steps:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个UI小部件来实现淡出效果和标题，按照以下步骤操作：
- en: In the `Canvas` component to the root of the `Image` component to fill the screen.
    We don’t need an image per se; just the default **Background** sprite will do
    nicely.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Image`组件的根组件中添加`Canvas`组件以填充屏幕。我们不需要特定的图像；默认的**背景**精灵就足够好了。
- en: 'Right-click `RectTransform`: `400`'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`RectTransform`：`400`
- en: '`TextMeshPro – Text (UI)`: `To` `be continued…`'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TextMeshPro – Text (UI)`: `待续…`'
- en: 'Lastly, we’ll bring these UI widgets into Timeline to set up the sequence.
    Follow these steps to add the widgets and define their respective sequence:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这些UI小部件拖入时间轴以设置序列。按照以下步骤添加小部件并定义它们各自的序列：
- en: Ensure that **Ending Timeline** is viewable in the **Timeline** window. If the
    **Timeline** window is not open, you can open it from **Window** | **Sequencing**
    | **Timeline**, then click on the **Endling Timeline** instance in the hierarchy.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**时间轴**窗口中可以看到**结束时间轴**。如果**时间轴**窗口没有打开，可以从**窗口** | **序列** | **时间轴**打开它，然后在层次结构中单击**Endling
    Timeline**实例。
- en: 'Drag `Image` `0` (transparent) to `255` (opaque) over 1.5 seconds:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Image` `0`（透明）拖动到`255`（不透明）处，持续1.5秒：
- en: Click the red *Start recording* circle button on the `000000`) with `0` to set
    the first keyframe.
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击红色**开始录制**圆形按钮（`000000`)，使用`0`设置第一个关键帧。
- en: Scrub `255` to set the second keyframe.
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`255`拖动以设置第二个关键帧。
- en: Stop recording.
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止录制。
- en: Drag **Text (TMP)** into the **Track List** section of the **Timeline** window
    and select **Add Activation Track** when prompted.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**文本（TMP）**拖动到**时间轴**窗口的**轨道列表**部分，并在提示时选择**添加激活轨道**。
- en: We want the text to show a heartbeat after the fade has completed, so drag the
    **Active** clip to the right in the timeline to 1.8 seconds. The GameObject for
    the **Text (TMP)** binding will only be active within the range of the clip in
    the timeline and deactivated outside of it. We’re done with the text. Easy-peasy.
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望文本在淡出完成后显示心跳，因此将**Active**剪辑在时间轴上拖动到1.8秒处。**Text (TMP)**绑定的GameObject将仅在时间轴剪辑的范围内活动，并在其外停用。文本部分完成。简单易懂。
- en: 'To preview the results of the timeline sequence in the **Game** view, click
    the **Play** button or press the spacebar:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 要在**游戏**视图中预览时间轴序列的结果，请单击**播放**按钮或按空格键：
- en: '![Figure 9.17 – Timeline ending fade out title](img/B18347_09_17.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17 – 时间轴结束淡出标题](img/B18347_09_17.jpg)'
- en: Figure 9.17 – Timeline ending fade out title
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 时间轴结束淡出标题
- en: If you enter `PlayableDirector` component was added to the Timeline instance
    when we dragged it into the scene.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入`PlayableDirector`组件是在我们将它拖入场景时添加到时间轴实例的。
- en: 'Select the `PlayableDirector` component values in the **Inspector** view:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**视图中选择`PlayableDirector`组件的值：
- en: '`PlayOnAwake` = `false`'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayOnAwake` = `false`'
- en: '`WrapMode` = `Hold`'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WrapMode` = `Hold`'
- en: 'We also want to ensure the UI widgets don’t have a visible state at design
    time in the editor. That way, they are not shown until we trigger the Timeline
    to play. Make the following changes to the UI widget values in the scene:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要确保在编辑器的设计时间中UI小部件没有可见状态。这样，它们就不会在我们触发时间轴播放之前显示。对场景中的UI小部件值进行以下更改：
- en: For the UI `Image` `0`.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于UI `Image` `0`。
- en: For the UI **Text (TMP)** object, deactivate the object (untick the checkbox
    at the top of the **Inspector** view).
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于UI **文本（TMP）**对象，停用对象（在**检查器**视图顶部取消勾选复选框）。
- en: Since we already recorded the color values and active state in the Timeline,
    we can safely set these values in the scene without affecting their sequenced
    behavior.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在时间线中记录了颜色值和活动状态，因此我们可以安全地在场景中设置这些值，而不会影响它们的序列行为。
- en: 'The only thing left to do now is to activate our ending sequence when the sliding
    puzzle is complete. Find the `SlidingTile_3by3_URP` object in the hierarchy and,
    on the `ST_PuzzleDisplay` component, add an action to `OnPuzzleComplete: Runtime
    Only`, `PlayableDirector.Play()`.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '现在唯一剩下的事情就是在滑动拼图完成时激活我们的结束序列。在层次结构中找到`SlidingTile_3by3_URP`对象，在`ST_PuzzleDisplay`组件上添加一个动作到`OnPuzzleComplete:
    Runtime Only`，`PlayableDirector.Play()`。'
- en: To be continued – or end of Act I, whichever you decide. Either way, this was
    just the equivalent of a tip-of-the-iceberg introduction to Timeline – it is an
    extremely powerful cutscenes, cinematics, and gameplay or audio sequences tool!
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 待续——或者第一幕的结束，由你决定。无论如何，这仅仅是对时间线的一个冰山一角介绍——它是一个极其强大的场景、电影和游戏或音频序列工具！
- en: In this section, you learned how to bring a third-party asset in from the Unity
    Asset Store, resolved to update the asset for use in Unity 2022, and extended
    the vendor-provided code with our own to trigger an event. You also received an
    introduction to Unity’s Timeline feature and created a simple but effective cinematic
    fade to black.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何从Unity Asset Store导入第三方资产，并将其更新为适用于Unity 2022，同时通过扩展供应商提供的代码来触发事件。你还了解了Unity的Timeline功能，并创建了一个简单但有效的全黑电影淡出效果。
- en: Summary
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create an efficient and convenient global
    event system to build out a quest system with components made in a flexible, scalable,
    and more maintainable way than with directly coupled classes. You also learned
    how to create a specific quest with unique requirements needing to be met before
    setting the quest state as completed while also learning how to introduce randomness
    for collecting required items.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建一个高效且方便的全局事件系统，以灵活、可扩展和更易于维护的方式构建比直接耦合类更复杂的寻宝系统。你还学习了如何创建一个具有独特要求的特定寻宝任务，在将寻宝状态设置为完成之前需要满足这些要求，同时学习了如何引入随机性以收集所需物品。
- en: We continued by learning how to import a third-party sliding puzzle asset from
    the Unity Asset Store and upgrade it for compatibility with Unity 2022 and the
    URP renderer while also extending upon the code to integrate it into our game
    code. We finished solving the security puzzle lock and winning the game with a
    cinematic Timeline sequence for fading to black.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续学习如何从Unity Asset Store导入第三方滑动拼图资产，并升级它以兼容Unity 2022和URP渲染器，同时扩展代码以将其集成到我们的游戏代码中。我们完成了安全拼图锁的解决，并通过一个用于全黑淡出的电影时间线序列赢得了游戏。
- en: In the next chapter, we’ll create a 3D FPS to continue the 2D adventure game
    directly. We will pick up right where we left off and enter the interior habitat
    environment, where we will learn about gray boxing to flesh out a playable 3D-level
    design with **ProBuilder** rapidly. We’ll also leverage another asset from the
    Unity Asset Store – but this time one provided directly by Unity – for our FPS
    character controller. We’ll also look at code reuse by converting some of our
    existing 2D components for use in 3D.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个3D FPS游戏，以直接继续2D冒险游戏。我们将从上次离开的地方继续，进入室内栖息地环境，在那里我们将学习灰色拳击，以快速用**ProBuilder**完善可玩3D关卡设计。我们还将利用Unity
    Asset Store中的另一个资产——但这次是Unity直接提供的——用于我们的FPS角色控制器。我们还将通过将一些现有的2D组件转换为3D使用来查看代码重用。
