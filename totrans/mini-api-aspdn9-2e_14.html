<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-170">
    <a id="_idTextAnchor200">
    </a>
    
     14
    
   </h1>
   <h1 id="_idParaDest-171">
    <a id="_idTextAnchor201">
    </a>
    
     Unit Testing, Compatibility, and Deployment of Minimal APIs
    
   </h1>
   <p>
    
     It’s an exciting time when you’re preparing to deploy an application to production.
    
    
     Before that can happen, there are many questions to be answered, namely, “Is this quality code?”, “Is everything going to work as intended?”, and “Will it be sustainable over a long period
    
    
     
      of time?”.
     
    
   </p>
   <p>
    
     To help set our minimal APIs up for success, testing is required before they go into the hands of users or become responsible for any critical
    
    
     
      business operations.
     
    
   </p>
   <p>
    
     This statement is
    
    <em class="italic">
     
      really
     
    </em>
    
     obvious.
    
    
     Of course we need to test, but in some cases, what is less obvious is
    
    <em class="italic">
     
      how
     
    </em>
    
     we will be testing.
    
    
     Unit and integration testing can help us in this area, offering an automated solution to testing our acceptance criteria, checking for new bugs introduced by code changes, often
    
    <a id="_idIndexMarker571">
    </a>
    
     referred to as
    
    <strong class="bold">
     
      regression
     
    </strong>
    
     , and giving us (in some IDEs literally) a red or green light
    
    
     
      for deployment.
     
    
   </p>
   <p>
    
     There is also compatibility to consider before deployment.
    
    
     What operating system are we deploying to?
    
    
     What kind of web server will be in use?
    
    
     Are we hosting in the cloud
    
    
     
      or on-premises?
     
    
   </p>
   <p>
    
     Finally, the appropriate method of deployment can be dictated by all of the preceding considerations.
    
    
     It seems like a lot, but it will be worth it when we inevitably deploy our minimal APIs with confidence that they will bring the intended value, and
    
    
     
      hopefully more.
     
    
   </p>
   <p>
    
     In this chapter, we will cover
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Unit testing and integration testing for
     
     
      
       minimal APIs
      
     
    </li>
    <li>
     
      Compatibility and migrating minimal APIs to .
     
     
      
       NET 9
      
     
    </li>
    <li>
     
      Deploying
     
     
      
       minimal APIs
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-172">
    <a id="_idTextAnchor202">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     Visual Studio 2022 or the latest version of Visual Studio code is recommended in order to run the code from this chapter.
    
    
     The code examples for this chapter are available in the GitHub repository
    
    
     
      at:
     
    
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     
      
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     To follow along with all deployment methods in this chapter, you will need to have access to an Azure subscription and be able to
    
    
     
      install Docker.
     
    
   </p>
   <h1 id="_idParaDest-173">
    <a id="_idTextAnchor203">
    </a>
    
     Unit testing and integration testing for minimal APIs
    
   </h1>
   <p>
    
     It’s highly likely that you’ve come across the terms unit testing and integration testing, but by way of a refresher, let’s briefly
    
    
     
      define them.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Unit testing
     
    </strong>
    
     involves testing individual components of functions of a code base in isolation, whereas integration testing checks how different components of modules of a system interact.
    
    
     In a minimal API, a unit
    
    <a id="_idIndexMarker572">
    </a>
    
     test may simply test that a service does what it
    
    <a id="_idIndexMarker573">
    </a>
    
     should, while an integration test would confirm that an HTTP request to the endpoint uses the services and other components
    
    
     
      together correctly.
     
    
   </p>
   <p>
    
     In short, you’re either testing a single unit of code, or you’re testing how different units interact with
    
    
     
      each other.
     
    
   </p>
   <p>
    
     Let’s create a unit test for a
    
    <a id="_idIndexMarker574">
    </a>
    
     service that does something very simple: calculate the sum of given
    
    <a id="_idIndexMarker575">
    </a>
    
     numerical values.
    
    
     Here is the service as it looks in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     , where it is registered for dependency injection and used as part of a
    
    
     
      POST endpoint:
     
    
   </p>
   <pre class="source-code">
public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);
        builder.Services.AddTransient&lt;CalculatorService&gt;();
        var app = builder.Build();
        app.MapPost(
            "/SumIntegers",
            (int[] integers,
             CalculatorService calculatorService) =&gt;
        {
            var result = calculatorService.Sum(integers);
            return Results.Ok(result);
        });
        app.Run();
    }
}</pre>
   <p>
    
     There are
    
    <a id="_idIndexMarker576">
    </a>
    
     several testing frameworks
    
    <a id="_idIndexMarker577">
    </a>
    
     we can implement, but to keep
    
    <a id="_idIndexMarker578">
    </a>
    
     things simple, I’m
    
    <a id="_idIndexMarker579">
    </a>
    
     going to
    
    
     
      use xUnit:
     
    
   </p>
   <ol>
    <li>
     
      Right-click your solution in Visual Studio and select
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        New Project…
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.1: Add a new project from within Solution Explorer" src="img/B20968_14_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.1: Add a new project from within Solution Explorer
    
   </p>
   <ol>
    <li value="2">
     
      Then
     
     <a id="_idIndexMarker580">
     </a>
     
      search for
     
     <strong class="bold">
      
       xUnit
      
     </strong>
     
      (or your
     
     <a id="_idIndexMarker581">
     </a>
     
      preferred testing
     
     <a id="_idIndexMarker582">
     </a>
     
      framework if you don’t wish to
     
     <a id="_idIndexMarker583">
     </a>
     
      follow
     
     
      
       along exactly).
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.2: Creating a new xUnit project" src="img/B20968_14_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.2: Creating a new xUnit project
    
   </p>
   <ol>
    <li value="3">
     
      If the
     
     <strong class="bold">
      
       Do not use top-level statements
      
     </strong>
     
      option is shown, I recommend unchecking it so
     
     <a id="_idIndexMarker584">
     </a>
     
      that you can
     
     <a id="_idIndexMarker585">
     </a>
     
      clearly see the namespaces you’re using
     
     <a id="_idIndexMarker586">
     </a>
     
      in each class.
     
     
      It is a
     
     <a id="_idIndexMarker587">
     </a>
     
      personal preference but it will make it easier for you to follow along with
     
     
      
       this example.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.3: Unchecking the Do not use top-level statements box" src="img/B20968_14_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.3: Unchecking the Do not use top-level statements box
    
   </p>
   <ol>
    <li value="4">
     
      Once you’ve created your test project within the solution, right-click
     
     <strong class="bold">
      
       Dependencies
      
     </strong>
     
      for the test project and add a project reference to your
     
     
      
       API project.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.4: Adding a reference to another project" src="img/B20968_14_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.4: Adding a reference to another project
    
   </p>
   <p>
    
     You now have two projects
    
    <a id="_idIndexMarker588">
    </a>
    
     in your solution.
    
    
     One is a minimal API project and the other is a testing project linked to
    
    
     
      the
     
    
    
     <a id="_idIndexMarker589">
     </a>
    
    
     
      former.
     
    
   </p>
   <p>
    
     We can now start writing some
    
    <a id="_idIndexMarker590">
    </a>
    
     tests.
    
    
     Let’s start with a simple unit test
    
    
     
      against
     
    
    
     <strong class="source-inline">
      
       CalculatorService
      
     </strong>
    
   </p>
   <p>
    
     In our test project, create
    
    <a id="_idIndexMarker591">
    </a>
    
     a new class called
    
    <strong class="source-inline">
     
      CalculatorTests
     
    </strong>
    
     .
    
    
     Then, update the code so that a method called
    
    <strong class="source-inline">
     
      Sum_Test()
     
    </strong>
    
     exists, with an attribute above the method
    
    
     
      signature,
     
    
    
     <strong class="source-inline">
      
       [Fact]
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
[Fact]
public void Sum_Test()
{
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      [Fact]
     
    </strong>
    
     attribute is what xUnit uses to mark a method as a test.
    
    
     I like to think of it in the sense that we are stating that the method represents something that should be fact; it should be objective.
    
    
     In this case, we want a test that proves the fact that the sum of a given collection of integers is equal to the value we are expecting it to be.
    
    
     Let’s explore this in more detail by writing the
    
    
     
      test logic.
     
    
   </p>
   <p>
    
     In the body of
    
    <strong class="source-inline">
     
      Sum_Test()
     
    </strong>
    
     , instantiate a new instance of
    
    <strong class="source-inline">
     
      CalculatorService
     
    </strong>
    
     and create an array of integers that we can use during
    
    
     
      our test:
     
    
   </p>
   <pre class="source-code">
var calculatorService = new CalculatorService();
int[] integers = [ 1, 1, 8 ];</pre>
   <p>
    
     Because we kept this simple, it is easy to see at a glance that the expected result for the sum of the values in
    
    <strong class="source-inline">
     
      integers
     
    </strong>
    
     must
    
    
     
      be
     
    
    
     <strong class="source-inline">
      
       10
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Add a call to the
    
    <strong class="source-inline">
     
      Sum()
     
    </strong>
    
     function within
    
    <strong class="source-inline">
     
      CalculatorService
     
    </strong>
    
     and store it in a variable.
    
    
     Also, add a hardcoded
    
    <a id="_idIndexMarker592">
    </a>
    
     variable of
    
    <strong class="source-inline">
     
      10
     
    </strong>
    
     for the
    
    
     
      expected result:
     
    
   </p>
   <pre class="source-code">
var result = calculatorService.Sum(integers);
var expectedResult = 10;</pre>
   <p>
    
     In unit testing, there is a principle
    
    <a id="_idIndexMarker593">
    </a>
    
     known as the
    
    <em class="italic">
     
      three As
     
    </em>
    
     , which stands
    
    <a id="_idIndexMarker594">
    </a>
    
     for arrange, act,
    
    
     
      and assert:
     
    
   </p>
   <ol>
    <li>
     
      The first step, arrange, forces
     
     <a id="_idIndexMarker595">
     </a>
     
      us to gather data and resources in a particular state so that testing
     
     <a id="_idIndexMarker596">
     </a>
     
      is possible.
     
     
      We have achieved this by creating an instance of
     
     <strong class="source-inline">
      
       CalculatorService
      
     </strong>
     
      , an array of integers we know should add up to 10, which we have also hardcoded into a variable for reference.
     
     
      Finally, we make the call to the
     
     <strong class="source-inline">
      
       Sum()
      
     </strong>
     
      function to obtain the
     
     
      
       actual result.
      
     
    </li>
    <li>
     
      The second step is act.
     
     
      This simply means that action is taken to enable the test to be evaluated.
     
     
      For example, if you’re testing a calculation between two integer values, the actual calculation would take place at
     
     
      
       this point.
      
     
    </li>
    <li>
     
      The final step is assert.
     
     
      An assertion is the test itself.
     
     
      In this, we will assert that our
     
     <strong class="source-inline">
      
       [Fact]
      
     </strong>
     
      is true.
     
     
      If the assertion is correct,
     
     <strong class="source-inline">
      
       [Fact]
      
     </strong>
     
      is true and the test will pass.
     
     
      If the assertion is incorrect, the test
     
     
      
       will fail.
      
     
    </li>
   </ol>
   <p>
    
     Different testing frameworks have their own implementation of an assertion, but the principle remains the same.
    
    
     In xUnit, a static class,
    
    <strong class="source-inline">
     
      Assert
     
    </strong>
    
     , holds various types of assertions that can be used during testing.
    
    
     For example, an assertion that something is null or not null is represented via
    
    <strong class="source-inline">
     
      Assert.Null()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Assert.NotNull()
     
    </strong>
    
     , respectively.
    
    
     Likewise, we can
    
    <a id="_idIndexMarker597">
    </a>
    
     assert that a statement is true
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       Assert.True()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We want to assert that
    
    <a id="_idIndexMarker598">
    </a>
    
     the expected result of
    
    <strong class="source-inline">
     
      Sum()
     
    </strong>
    
     is equal to the actual result.
    
    
     For this, we can
    
    
     
      use
     
    
    
     <strong class="source-inline">
      
       Assert.Equal()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
[Fact]
public void Sum_Test()
{
    var calculatorService = new CalculatorService();
    int[] integers = { 1, 1, 8 };
    var result = calculatorService.Sum(integers);
    var expectedResult = 10;
    Assert.Equal(result, expectedResult);
}</pre>
   <p>
    
     Running this test is as simple as right-clicking the method signature and selecting
    
    <strong class="bold">
     
      Run Tests
     
    </strong>
    
     .
    
    
     The test will run, and the
    
    <a id="_idIndexMarker599">
    </a>
    
     test result will be shown by Visual Studio in Test
    
    <a id="_idIndexMarker600">
    </a>
    
     Explorer.
    
    
     You should see a green circle next to the test to
    
    
     
      indicate success.
     
    
   </p>
   <div><div><img alt="Figure 14.5: The Test Explorer screen, showing available tests and their results" src="img/B20968_14_05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.5: The Test Explorer screen, showing available tests and their results
    
   </p>
   <p>
    
     A similar approach to writing tests can be taken for integration tests, the main difference being the scope of the test.
    
    
     For this example, a minimal API, a simple integration test’s scope could cover a whole endpoint.
    
    
     Let’s put this into practice by writing an integration test for the
    
    <strong class="source-inline">
     
      /sumintegers
     
    </strong>
    
     API endpoint that checks the resulting
    
    
     
      status code.
     
    
   </p>
   <p>
    
     To run this test, we will need to be able to access an
    
    <strong class="source-inline">
     
      HttpClient
     
    </strong>
    
     object and run
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     in the test project, because
    
    <a id="_idIndexMarker601">
    </a>
    
     the test needs to make a request against an endpoint.
    
    
     To make
    
    <a id="_idIndexMarker602">
    </a>
    
     this possible, you can make your test class implement
    
    <strong class="source-inline">
     
      IClassFixture
     
    </strong>
    
     of
    
    
     
      type
     
    
    
     <strong class="source-inline">
      
       WebApplicationFactory
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     IClassFixture usage in a test class
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      IClassFixture
     
    </strong>
    
     is an interface that allows objects to share scope across a class.
    
    
     In this case, we want to share the scope of a
    
    <strong class="source-inline">
     
      WebApplicationFactory
     
    </strong>
    
     object so that an
    
    <strong class="source-inline">
     
      HttpClient
     
    </strong>
    
     instance can be created for tests within
    
    
     
      the class.
     
    
   </p>
   <p>
    
     Because
    
    <strong class="source-inline">
     
      WebApplicationFactory
     
    </strong>
    
     needs
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.Mvc.Testing
     
    </strong>
    
     to be installed, use the NuGet package manager console to install
    
    
     
      this
     
    
    
     <a id="_idIndexMarker603">
     </a>
    
    
     
      package:
     
    
   </p>
   <pre class="console">
dotnet add package Microsoft.AspNetCore.Mvc.Testing</pre>
   <p>
    
     Update the
    
    <strong class="source-inline">
     
      CalculatorTests
     
    </strong>
    
     class so that it
    
    
     
      implements
     
    
    
     <strong class="source-inline">
      
       IClassFixture
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
public class CalculatorTests :
    IClassFixture&lt;WebApplicationFactory&lt;Program&gt;&gt;</pre>
   <p>
    
     This will require you to add a
    
    <a id="_idIndexMarker604">
    </a>
    
     constructor for the class, in which you can inject
    
    <strong class="source-inline">
     
      WebApplicationFactory
     
    </strong>
    
     .
    
    
     You can also use this
    
    <strong class="source-inline">
     
      WebApplicationFactory
     
    </strong>
    
     to create a new
    
    <strong class="source-inline">
     
      HttpClient
     
    </strong>
    
     for use during tests.
    
    
     Let’s store this in a
    
    <strong class="source-inline">
     
      readonly
     
    </strong>
    
     field so that we can keep things clean by not reinitializing it after the constructor
    
    
     
      has run:
     
    
   </p>
   <pre class="source-code">
private readonly HttpClient _httpClient;
public CalculatorTests(
    WebApplicationFactory&lt;Program&gt; applicationFactory)
{
    _httpClient = applicationFactory.CreateClient();
}</pre>
   <p>
    
     Finally, we can write our tests.
    
    
     Let’s
    
    <em class="italic">
     
      arrange
     
    </em>
    
     our test data by creating the required parameters as an array of
    
    <a id="_idIndexMarker605">
    </a>
    
     integers and then serializing them to a JSON string so that they can be added to the
    
    <a id="_idIndexMarker606">
    </a>
    
     body of
    
    
     
      the request:
     
    
   </p>
   <pre class="source-code">
[Fact]
public async Task SumIntegers_ShouldReturnOk()
{
    //Arrange
    var integers = new[] { 2, 4, 4 };
    var jsonContent = new
        StringContent(JsonSerializer.Serialize(integers),
        Encoding.UTF8,
        "application/json"
    );
}</pre>
   <p>
    
     Next, we can
    
    <em class="italic">
     
      act
     
    </em>
    
     by making
    
    <a id="_idIndexMarker607">
    </a>
    
     the POST request to the
    
    
     
      target endpoint:
     
    
   </p>
   <pre class="source-code">
// Act
var response = await _httpClient.PostAsync(
    "/SumIntegers", jsonContent);</pre>
   <p>
    
     Finally, we can
    
    <em class="italic">
     
      assert
     
    </em>
    
     that the
    
    <a id="_idIndexMarker608">
    </a>
    
     response code is the one we were expecting, in this case,
    
    
     <strong class="source-inline">
      
       200 OK
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
Assert.Equal(HttpStatusCode.OK, response.StatusCode);</pre>
   <p>
    
     You could also assert that the result is the expected one by checking the
    
    
     
      response content:
     
    
   </p>
   <pre class="source-code">
Assert.Equal(10, JsonSerializer.Deserialize&lt;int&gt;(await response.Content.ReadAsStringAsync()));</pre>
   <p>
    
     This integration test may look pretty similar to the original unit test we wrote earlier in this chapter, but it differs in the sense that it has a
    
    
     
      wider scope.
     
    
   </p>
   <p>
    
     By calling this test, we not only make a request to the target endpoint, but we also cover the testing of the
    
    
     
      encapsulated
     
    
    
     <strong class="source-inline">
      
       CalculatorService
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In both of these examples, integration and unit testing were conducted on pre-existing logic.
    
    
     If we were to adopt
    
    <strong class="bold">
     
      Test-Driven Development
     
    </strong>
    
     (
    
    <strong class="bold">
     
      TDD
     
    </strong>
    
     ), we would augment our practices by writing the tests before any logic.
    
    
     Obviously, we expect the tests to fail initially, but our goal is to write code
    
    <a id="_idIndexMarker609">
    </a>
    
     that allows the tests to pass.
    
    
     Assuming
    
    <a id="_idIndexMarker610">
    </a>
    
     your tests make the same assertions as your acceptance criteria from an API
    
    <a id="_idIndexMarker611">
    </a>
    
     requirements perspective, TDD is widely considered the optimal way to apply automated testing to a
    
    
     
      code base.
     
    
   </p>
   <p>
    
     TDD or not, however you approach
    
    <a id="_idIndexMarker612">
    </a>
    
     unit and integration testing, having test coverage will help to increase the quality of your minimal API code, and hopefully reduce
    
    <a id="_idIndexMarker613">
    </a>
    
     the number of reported
    
    
     
      bugs post-release.
     
    
   </p>
   <p>
    
     When it comes to the quality and stability of an API, testing the code’s logic is one aspect; but before moving to deployment, there is another aspect to be considered: that of compatibility.
    
    
     Let’s explore compatibility, with a particular focus on the latest version of .NET at the time of writing – .
    
    
     
      NET 9.
     
    
   </p>
   <h1 id="_idParaDest-174">
    <a id="_idTextAnchor204">
    </a>
    
     Compatibility and migrating minimal APIs to .NET 9
    
   </h1>
   <p>
    
     Let’s assume that you have already created a minimal API project, but the .NET version is not the latest.
    
    
     You wish to deploy the API, but
    
    <a id="_idIndexMarker614">
    </a>
    
     before you do so, you intend to bring the code base to the latest .NET version, which at the time of writing this book is 9.
    
    
     What
    
    <a id="_idIndexMarker615">
    </a>
    
     factors do we need to consider to be confident that our application will run efficiently on this new version, and how can we migrate
    
    
     
      to it?
     
    
   </p>
   <p>
    
     Before any .NET migration, it is critical that you consult Microsoft’s documentation, where any known breaking changes
    
    
     
      are outlined.
     
    
   </p>
   <p>
    
     .NET breaking changes fall into
    
    
     
      three categories:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Binary incompatible
      
     </strong>
     
      : Existing binaries
     
     <a id="_idIndexMarker616">
     </a>
     
      may fail to load and may need to
     
     
      
       be recompiled.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Source incompatible
      
     </strong>
     
      : Code may require
     
     <a id="_idIndexMarker617">
     </a>
     
      change in order
     
     
      
       to compile.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Behavioral change
      
     </strong>
     
      : Code and binaries may behave differently after update, meaning code changes would
     
     <a id="_idIndexMarker618">
     </a>
     
      
       be required.
      
     
    </li>
   </ul>
   <p>
    
     While Microsoft is usually pretty effective in avoiding major breaking changes, checking the documentation at
    
    <a href="https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0">
     
      https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0
     
    </a>
    
     ahead of time will provide valuable insight into any potential issues you may face.
    
    
     On top of this, if a breaking change does find its way into the minimal API post-update, unit and integration tests will increase the chances of the breaking changes
    
    
     
      being caught.
     
    
   </p>
   <p>
    
     Microsoft outlines breaking changes for different
    
    <a id="_idIndexMarker619">
    </a>
    
     areas of .NET.
    
    
     For minimal APIs, you will be most concerned with changes
    
    <a id="_idIndexMarker620">
    </a>
    
     in the area of ASP.NET, but ensure you review other areas, such as core .NET libraries, deployment, networking, SDK, MSBuild, and serialization, as these are secondary areas that are all relevant to
    
    
     
      minimal APIs.
     
    
   </p>
   <p>
    
     At the time of writing, there are only two breaking changes outlined in ASP.NET for .NET 9, which are
    
    
     
      summarized here:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       DefaultKeyResolution.ShouldGenerateNewKey
      
     </strong>
     
      : There is a different meaning behind Boolean (true/false) result returned in previous versions.
     
     
      This breaking change is caused by a redefinition of the
     
     <strong class="source-inline">
      
       true/false
      
     </strong>
     
      result returned by
     
     <strong class="source-inline">
      
       ShouldGenerateNewKey
      
     </strong>
     
      .
     
     
      Let’s delve into this in
     
     
      
       more detail:
      
     
     <ul>
      <li>
       
        When managing keys in your minimal API, if you’re using ASP.NET’s default implementation to generate the key, there is a Boolean that is provided to tell you whether a new key should
       
       
        
         be generated.
        
       
      </li>
      <li>
       
        Previously, the result of the Boolean was produced based on whether the default key was within two days
       
       
        
         of expiration.
        
       
      </li>
      <li>
       
        It was decided that “within two days” of expiration was not appropriate on its own, as there are other factors that could influence whether the key should be regenerated.
       
       
        Now, the result of
       
       <strong class="source-inline">
        
         ShouldGenerateNewKey
        
       </strong>
       
        is based on several factors related to
       
       <strong class="source-inline">
        
         IdefaultKeyResolver
        
       </strong>
       
        as well as whether or not a default key exists in the first place, rather than an arbitrary meaning based on whether the key is two days away
       
       
        
         from expiry.
        
       
      </li>
     </ul>
    </li>
    <li>
     
      When a minimal API application starts, you can specify in
     
     <strong class="source-inline">
      
       UseDefaultServiceProvider
      
     </strong>
     
      whether validation should be run on registered services and
     
     <a id="_idIndexMarker621">
     </a>
     
      service scopes.
     
     
      Previously, validation was always turned off by default.
     
     
      Let’s
     
     <a id="_idIndexMarker622">
     </a>
     
      break down this change a little further to see whether it affects your
     
     
      
       existing code:
      
     
     <ul>
      <li>
       
        The validation of services ensures that all services can be created
       
       
        
         at startup.
        
       
      </li>
      <li>
       
        The validation of scopes checks that scoped services are not resolved from the root provider, which would violate
       
       
        
         their scope.
        
       
      </li>
      <li>
       
        Overall, this meant that no validation was performed by default.
       
       
        You had to turn on the previous validation for it to be executed when the application is loaded.
       
       
        However, validation is now performed
       
       
        
         by default.
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     Based on this, there are no major breaking changes when moving a minimal API to .NET 9 (at least where ASP.NET Core is concerned).
    
    
     However, it is still important to be prepared for any potential change.
    
    
     With that in mind, how would we mitigate
    
    
     
      these changes?
     
    
   </p>
   <ul>
    <li>
     
      For
     
     <strong class="source-inline">
      
       DefaultKeyResolution.ShouldGenerateNewKey
      
     </strong>
     
      affecting key resolution, you only really need to act if you have written logic that is now redundant thanks to the way .NET 9 checks for an
     
     
      
       expired key.
      
     
     <p class="list-inset">
      
       For example, if previously you were checking that a default key exists, you no longer need to do this, because .NET 9 does this for you.
      
      
       The impact of this change is therefore
      
      
       
        fairly minimal.
       
      
     </p>
    </li>
    <li>
     
      For
     
     <strong class="source-inline">
      
       UseDefaultServiceProvider
      
     </strong>
     
      , the required changes are simple.
     
     
      If by updating your minimal API to .NET 9 you start to see errors on startup owing to the fact that validation of services and scope is now enabled by default, you must address the outputted
     
     
      
       validation errors.
      
     
    </li>
   </ul>
   <p>
    
     For most basic scenarios, it is unlikely that your minimal API is configured in such a way that services could not be resolved or
    
    <a id="_idIndexMarker623">
    </a>
    
     scoped services are being incorrectly resolved from the root provider, but it is
    
    <a id="_idIndexMarker624">
    </a>
    
     still important to be aware of
    
    
     
      these factors.
     
    
   </p>
   <p class="callout-heading">
    
     Accuracy at the time of writing and other affected areas of .NET
    
   </p>
   <p class="callout">
    
     It is important to emphasize that these changes were reported before the release of .NET 9, during its preview.
    
    
     Developers must consult Microsoft’s documentation before any migration to see whether any further breaking changes have been reported.
    
    
     Moreover, the summary provided in this book is only targeting ASP.NET Core, which is the main area we are concerned with when writing minimal APIs.
    
    
     However, other areas mentioned, such as the .NET SDK, networking, and serialization, could all affect minimal API projects depending on the
    
    
     
      use case.
     
    
   </p>
   <p>
    
     Now that we’ve explored the potential compatibility issues we face when publishing a minimal API application to .NET 9, let’s look at the various methods of deployment we have at
    
    
     
      our disposal.
     
    
   </p>
   <h1 id="_idParaDest-175">
    <a id="_idTextAnchor205">
    </a>
    
     Deploying minimal APIs
    
   </h1>
   <p>
    
     There are many different
    
    <a id="_idIndexMarker625">
    </a>
    
     ways to deploy a minimal API project, and exploring them all would be way out of the scope of this book.
    
    
     However, we can look at some of the most common
    
    
     
      deployment targets.
     
    
   </p>
   <h2 id="_idParaDest-176">
    <a id="_idTextAnchor206">
    </a>
    
     Deploying to Microsoft Azure App Service (cloud deployment)
    
   </h2>
   <p>
    
     Deploying to Azure App Service is very straightforward and can be achieved using a publish profile in Visual Studio.
    
    
     A
    
    <a id="_idIndexMarker626">
    </a>
    
     publish profile is a configuration object that specifies how a project should be deployed.
    
    
     It contains metadata about the type of runtime in play, the target architecture (x86, ARM, etc.), and the target host, which in this example will
    
    
     
      be Azure.
     
    
   </p>
   <p>
    
     For the purposes of this example, I’m assuming that an Azure App Service instance exists in your Azure subscription, to which you are allowed to deploy.
    
    
     If an App Service instance does not exist in Azure, you will need to create one.
    
   </p>
   <p>
    
     The pricing for Azure app services can be calculated via Microsoft’s pricing calculator at https://azure.microsoft.com/en-gb/pricing/calculator/.
    
    
     At the time of writing, there is a free tier that allows for basic testing which will probably be suitable for most people reading this book to practice their deployment.
    
    
     A basic tier app service currently costs approx $55-60 per month, but this can increase depending on the use case and the
    
    
     
      required specification.
     
    
   </p>
   <p>
    
     The creation of an App Service instance is out of the scope of
    
    
     
      this book:
     
    
   </p>
   <ol>
    <li>
     
      First, right-click on the project you wish to deploy in
     
     <strong class="bold">
      
       Solution Explorer
      
     </strong>
     
      in Visual Studio and then
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Publish…
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.6: Publishing from Solution Explorer in Visual Studio" src="img/B20968_14_06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.6: Publishing from Solution Explorer in Visual Studio
    
   </p>
   <p class="list-inset">
    
     If you don’t have any publish profiles already set up, you will see the
    
    <strong class="bold">
     
      Publish
     
    </strong>
    
     dialog.
    
    
     If
    
    <a id="_idIndexMarker627">
    </a>
    
     you don’t see this, it’s because you do already have a publish profile for another deployment.
    
    
     You can select
    
    <strong class="bold">
     
      Add a publish profile
     
    </strong>
    
     to open the
    
    <strong class="bold">
     
      Publish
     
    </strong>
    
     dialog if this is
    
    
     
      the case.
     
    
   </p>
   <ol>
    <li value="2">
     
      Once you see the
     
     <strong class="bold">
      
       Publish
      
     </strong>
     
      dialog,
     
     
      
       select
      
     
     
      <strong class="bold">
       
        Azure
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.7: Selecting a publish target in Visual Studio" src="img/B20968_14_07.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.7: Selecting a publish target in Visual Studio
    
   </p>
   <ol>
    <li value="3">
     
      Then select
     
     <strong class="bold">
      
       Azure App Service
      
     </strong>
     
      , ensuring that you select the correct operating system running on the target App Service in Azure (Windows
     
     
      
       or Linux).
      
     
     <p class="list-inset">
      
       The next screen will then request that you choose your Azure
      
      <a id="_idIndexMarker628">
      </a>
      
       subscription.
      
      
       If you’re not already logged in to Azure, you can connect using the option at the top right of
      
      
       
        the dialog.
       
      
     </p>
    </li>
    <li>
     
      Once connected, you should see your Azure subscription in the dropdown, along with the available App Service instances to deploy to.
     
     
      Select the service you wish to target and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.8: Choosing the target Azure App Service resource" src="img/B20968_14_08.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.8: Choosing the target Azure App Service resource
    
   </p>
   <ol>
    <li value="5">
     
      Finally, you will be
     
     <a id="_idIndexMarker629">
     </a>
     
      asked whether you wish to publish using a
     
     <strong class="source-inline">
      
       .pubxml
      
     </strong>
     
      file or via GitHub Actions.
     
     
      We won’t be covering continuous integration/continuous delivery pipelines such as GitHub Actions in this book, so
     
     
      
       select
      
     
     
      <strong class="bold">
       
        Publish
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.9: Choosing the publish output type" src="img/B20968_14_09.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.9: Choosing the publish output type
    
   </p>
   <p>
    
     Once this is complete, the dialog will close and your new publish profile is created.
    
    
     From there you can see and change the publish settings, such as what configuration you
    
    <a id="_idIndexMarker630">
    </a>
    
     will be publishing (almost always
    
    <strong class="bold">
     
      Release
     
    </strong>
    
     ), the framework which in our example is .NET9, the deployment mode, which is either
    
    <strong class="bold">
     
      Framework - dependent
     
    </strong>
    
     or
    
    <strong class="bold">
     
      Self - contained
     
    </strong>
    
     (More on that below) and the target runtime which in my example is
    
    
     <strong class="bold">
      
       64bit Linux
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 14.10: The newly created publish profile" src="img/B20968_14_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.10: The newly created publish profile
    
   </p>
   <p class="list-inset">
    
     Do this and your application
    
    <a id="_idIndexMarker631">
    </a>
    
     will be built before being deployed to the target App Service.
    
    
     Once completed, Visual Studio will automatically open a browser window and navigate to the minimal
    
    
     
      API’s URL.
     
    
   </p>
   <p class="callout-heading">
    
     Framework-dependent versus self-contained deployment modes
    
   </p>
   <p class="callout">
    
     You have two choices of deployment mode.
    
    <strong class="bold">
     
      Framework-dependent
     
    </strong>
    
     requires that .NET 9 (or whichever version you are
    
    <a id="_idIndexMarker632">
    </a>
    
     using) is installed on the target machine.
    
    <strong class="bold">
     
      Self-contained
     
    </strong>
    
     will package the runtime with the application.
    
    
     The former produces a smaller set of output files
    
    <a id="_idIndexMarker633">
    </a>
    
     but has the drawback of requiring the specific .NET version to be installed on the target machine, whereas the latter has a larger output but has fewer prerequisites for the target machine for the application to run, making it
    
    
     
      more portable.
     
    
   </p>
   <p>
    
     Next, let’s move on to deploying to a
    
    
     
      Docker container.
     
    
   </p>
   <h2 id="_idParaDest-177">
    <a id="_idTextAnchor207">
    </a>
    
     Deploying to a Docker container
    
   </h2>
   <p>
    
     ASP.NET and .NET Core are already well positioned to offer cross-platform functionality, but there are still subtle differences in
    
    <a id="_idIndexMarker634">
    </a>
    
     configuration depending on the host operating system.
    
    
     Containerizing your minimal API application with Docker can make it agnostic, meaning that it doesn’t care what operating system it’s
    
    
     
      running on.
     
    
   </p>
   <p>
    
     Firstly, you must ensure that Docker is installed on your system.
    
    
     Documentation outlining this is available at
    
    <a href="https://docs.docker.com/engine/install/">
     
      https://docs.docker.com/engine/install/
     
    </a>
    
     .
    
    
     For Windows, you will need to install Docker Desktop, documentation for which can be found here at
    
    <a href="https://docs.docker.com/desktop/install/windows-install/">
     
      https://docs.docker.com/desktop/install/windows-install/
     
    </a>
    
     , whereas for Linux, simply running Docker Engine
    
    
     
      should suffice.
     
    
   </p>
   <p>
    
     Once you have completed the install, you need to create a Dockerfile, which will describe how your minimal API project should be packaged into a Docker container as well as how it should run on the
    
    
     
      host machine.
     
    
   </p>
   <p>
    
     You can create this file within your project as a new item in
    
    
     
      Visual Studio:
     
    
   </p>
   <ol>
    <li>
     
      Select the button at the top left of
     
     <strong class="bold">
      
       Solution Explorer
      
     </strong>
     
      to change
     
     
      
       the view:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.11: Changing view options in Solution Explorer" src="img/B20968_14_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.11: Changing view options in Solution Explorer
    
   </p>
   <ol>
    <li value="2">
     
      Select
     
     
      <strong class="bold">
       
        Folder View
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.12: Switching to Folder View" src="img/B20968_14_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.12: Switching to Folder View
    
   </p>
   <ol>
    <li value="3">
     
      Then, right-click your project folder and select
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        New File
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.13: Creating a new file in the project within Folder View" src="img/B20968_14_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.13: Creating a new file in the project within Folder View
    
   </p>
   <ol>
    <li value="4">
     
      A Docker file has no name, just an extension of
     
     <strong class="source-inline">
      
       .dockerfile
      
     </strong>
     
      .
     
     
      Create this file.
     
     
      It should then open as a tab in Visual Studio.
     
     
      (There are reports of issues with Docker files not working unless they are called
     
     <strong class="source-inline">
      
       Dockerfile
      
     </strong>
     
      , so you can try this if you are having
     
     
      
       similar issues.)
      
     
    </li>
   </ol>
   <p>
    
     Now we can write the
    
    
     
      Docker file.
     
    
   </p>
   <p>
    
     First, we need to specify a
    
    <a id="_idIndexMarker635">
    </a>
    
     base image to be used for the runtime environment of the minimal API application.
    
    
     We can pull the official .NET 9 ASP.NET runtime image from Microsoft’s container registry
    
    
     
      like so:
     
    
   </p>
   <pre class="console">
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base</pre>
   <p>
    
     Then, we can tell Docker that we want to set the working directory inside the container to
    
    <strong class="source-inline">
     
      /app
     
    </strong>
    
     , so that any subsequent commands will be executed relative to this directory.
    
    
     We will also specify that we wish to expose port
    
    <strong class="source-inline">
     
      80
     
    </strong>
    
     on
    
    
     
      the container:
     
    
   </p>
   <pre class="console">
WORKDIR /app
EXPOSE 80</pre>
   <p>
    
     Next, we add a section that downloads the .NET 9 SDK, which will be required as the full runtime necessary for compiling the minimal API application.
    
    
     We then set the working directory again, this time to a folder of our choice; we’ll
    
    
     
      choose
     
    
    
     <strong class="source-inline">
      
       /src
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Following this, the entire content of the current directory is copied into the
    
    <strong class="source-inline">
     
      /src
     
    </strong>
    
     directory inside the container so that it can be built,
    
    <strong class="source-inline">
     
      dotnet restore
     
    </strong>
    
     is executed to add any NuGet packages required as dependencies, and the app is compiled in release mode to the
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     <strong class="source-inline">
      
       app
      
     </strong>
    
    
     
      folder:
     
    
   </p>
   <pre class="console">
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY . .
RUN dotnet restore
RUN dotnet publish -c Release -o /app</pre>
   <p>
    
     At this point in the execution, the container will have been built.
    
    
     Finally, we can add a section to the Docker file that runs the built container by copying the container assemblies and running from the DLL output by .NET
    
    
     
      after compilation:
     
    
   </p>
   <pre class="console">
FROM base AS final
WORKDIR /app
COPY --from=build /app .
ENTRYPOINT ["dotnet", "MyminimalAPIProject.dll"]</pre>
   <p>
    
     So far, we have specified how the image for the container should be built, but we haven’t yet triggered the build.
    
    
     To do this, open a terminal or command prompt window running from your project directory
    
    <a id="_idIndexMarker636">
    </a>
    
     and run the following command, replacing
    
    <strong class="source-inline">
     
      MYAPINAME
     
    </strong>
    
     with a suitable
    
    
     
      image name:
     
    
   </p>
   <pre class="console">
docker build -t MYAPINAME .</pre>
   <p>
    
     In this command, we are creating a tag for the image being built with the given name, and then we use
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     to indicate that the build context for the image is the current directory where the Docker file
    
    
     
      is located.
     
    
   </p>
   <p>
    
     Once built, you can run the container to start the app, which should be available to receive requests on a port of
    
    
     
      your choosing:
     
    
   </p>
   <pre class="console">
docker run -d -p 8080:80 --name MYCONTAINERNAME MYAPINAME</pre>
   <p>
    
     In this command, we have told Docker Engine to run the container with
    
    <strong class="source-inline">
     
      -d
     
    </strong>
    
     (detached mode), which
    
    <a id="_idIndexMarker637">
    </a>
    
     allows it to run in the background.
    
    
     We then used
    
    <strong class="source-inline">
     
      -p
     
    </strong>
    
     to specify that port
    
    <strong class="source-inline">
     
      80
     
    </strong>
    
     on the container should be mapped to port
    
    <strong class="source-inline">
     
      8080
     
    </strong>
    
     on the host machine.
    
    
     This means your minimal API will be available
    
    
     
      at
     
    
    
     <strong class="source-inline">
      
       http://localhost:8080
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Finally, there is one other method you can use that is extremely simple: deploying to the built-in Kestrel
    
    
     
      web server.
     
    
   </p>
   <h2 id="_idParaDest-178">
    <a id="_idTextAnchor208">
    </a>
    
     Deploying on-premises with Kestrel
    
   </h2>
   <p>
    
     If you simply want to host your minimal API as an ASP.NET Core application on a Windows machine, you can
    
    <a id="_idIndexMarker638">
    </a>
    
     create a new publish profile and then follow the publish
    
    <a id="_idIndexMarker639">
    </a>
    
     profile wizard in Visual Studio outlined earlier in this chapter.
    
    
     However, instead of choosing Azure as the target,
    
    
     
      choose
     
    
    
     <strong class="bold">
      
       Folder
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 14.14: Choosing Folder as the publish target" src="img/B20968_14_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.14: Choosing Folder as the publish target
    
   </p>
   <p>
    
     On selection, the wizard will ask you to specify a target folder to deploy to.
    
    
     This folder can be local, or it can be a network path on a
    
    
     
      remote server.
     
    
   </p>
   <p>
    
     Once published, the resulting
    
    <strong class="source-inline">
     
      .EXE
     
    </strong>
    
     file can be double-clicked and the application will run using the Kestrel web server, which listens on port
    
    <strong class="source-inline">
     
      5000
     
    </strong>
    
     
      by default.
     
    
   </p>
   <p>
    
     If you wish to change the port, you can do so via the
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file in your project by adding the following (e.g., change to
    
    
     
      port
     
    
    
     <strong class="source-inline">
      
       8080
      
     </strong>
    
    
     
      ):
     
    
   </p>
   <pre class="source-code">
"Kestrel": {
    "Endpoints": {
        "Http": {
            "Url": "http://*:8080"
        }
    }
}</pre>
   <p>
    
     We’ve explored a high-level overview of how we can prepare our minimal APIs
    
    <a id="_idIndexMarker640">
    </a>
    
     for their inevitable deployment
    
    <a id="_idIndexMarker641">
    </a>
    
     and consumption by end users.
    
    
     Now, we’re nearing the end of our journey.
    
    
     Let’s summarize what we’ve learned in this
    
    
     
      final chapter.
     
    
   </p>
   <h1 id="_idParaDest-179">
    <a id="_idTextAnchor209">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we’ve navigated through the crucial steps required to prepare minimal APIs for production, focusing on testing, compatibility with .NET 9, and deployment strategies.
    
    
     Each of these aspects plays a pivotal role in ensuring that your APIs are robust, compatible, and seamlessly delivered to
    
    
     
      end users.
     
    
   </p>
   <p>
    
     We explored unit testing, which isolates and validates individual components, and integration testing, which ensures that different parts of the system work together correctly.
    
    
     Through practical examples with xUnit, we demonstrated how to set up and execute these tests to validate functionality and performance.
    
    
     The key takeaway is that thorough testing—whether through unit tests or integration tests—helps catch potential issues early, reducing the likelihood of bugs slipping into production and ensuring that your API meets its
    
    
     
      acceptance criteria.
     
    
   </p>
   <p>
    
     Compatibility with .NET 9 is crucial for maintaining the longevity and efficiency of your minimal APIs.
    
    
     We discussed the importance of understanding breaking changes and adapting your code base accordingly.
    
    
     By keeping abreast of Microsoft’s documentation on .NET 9 changes, and leveraging unit and integration tests, you can mitigate the impact of any breaking changes.
    
    
     This proactive approach ensures that your APIs continue to function correctly with the latest .NET version and provides a smoother transition
    
    
     
      during migrations.
     
    
   </p>
   <p>
    
     Deployment encompasses several methods tailored to different environments and needs.
    
    
     We covered deployment to Microsoft Azure App Service, which offers a straightforward, scalable solution for cloud environments.
    
    
     We also explored containerization with Docker, providing a portable, cross-platform deployment option.
    
    
     For on-premises deployments, running minimal APIs directly with Kestrel offers a simple and effective approach.
    
    
     Each deployment method has its own set of configurations and considerations, such as choosing between framework-dependent and self-contained deployments or managing container ports and
    
    
     
      environment settings.
     
    
   </p>
   <p>
    
     Ensuring that your minimal APIs are well tested, compatible with the latest .NET versions, and deployed using the most suitable method empowers you to deliver high-quality, reliable software.
    
    
     By applying the practices outlined in this chapter, you set a solid foundation for successful deployment and long-term maintenance of your APIs, contributing to both immediate operational success and
    
    
     
      future scalability.
     
    
   </p>
   <p>
    
     We’re now at the end of our minimal API journey, and as the book ends, I hope you’ve gained a solid understanding of how to create minimal APIs in various use cases and that you’ve found the
    
    
     
      experience enjoyable.
     
    
   </p>
   <p>
    
     The book has been a joy for me to write as someone who is passionate about the use of minimal APIs in varying use cases and contexts.
    
    
     APIs are critical to nearly all modern software systems, and I think a good knowledge of minimal APIs and their advantages will give any .NET developer an edge in their
    
    
     
      programming career.
     
    
   </p>
   <p>
    
     Thanks for reading.
    
    
     Now go and build some more
    
    
     
      minimal APIs!
     
    
   </p>
  </div>
 </body></html>