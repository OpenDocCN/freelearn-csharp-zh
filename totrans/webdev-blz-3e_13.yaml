- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at testing. Writing tests for our projects
    will help us develop things rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: We can run tests to ensure we haven’t broken anything with the latest change.
    Also, we don’t have to invest our time in testing components manually since it
    is all done by the tests. Testing will improve the quality of the product since
    we’ll know that things that worked earlier still function as they should.
  prefs: []
  type: TYPE_NORMAL
- en: But writing tests for UI elements isn’t always easy; the most common way is
    to spin up the site, use tools that click on buttons, and then read the output
    to determine whether things work. The upside of this method is that we can test
    our site on different browsers and devices. The downside is that it usually takes
    a lot of time to do these tests. We need to spin up the website, start a web browser,
    verify the test, close the web browser, and repeat for the next test.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this method in Blazor as well (as with any ASP.NET site), but with
    Blazor, we have other opportunities when it comes to testing.
  prefs: []
  type: TYPE_NORMAL
- en: Steve Sanderson created an embryo of a test framework for Blazor that Microsoft
    MVP Egil Hansen picked up and continued the development of.
  prefs: []
  type: TYPE_NORMAL
- en: Egil’s framework is called **bUnit** and has become an industry standard in
    the Blazor community for testing Blazor components.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is bUnit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a test project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blazm` extension'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have read the previous chapters or use the `Chapter12` folder
    as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: If you are jumping into this chapter using the code from GitHub, make sure you
    have added the `Auth0` account information in the settings files. You can find
    the instructions in *Chapter 8*, *Authentication and Authorization*.
  prefs: []
  type: TYPE_NORMAL
- en: What is bUnit?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction, some tests spin up web browsers to test pages/components,
    but bUnit takes another approach.
  prefs: []
  type: TYPE_NORMAL
- en: bUnit is made specifically for Blazor. It can define and set up tests using
    C# or Razor syntax. It can mock JavaScript interop as well as Blazor’s authentication
    and authorization. To make our components more testable, sometimes we need to
    think about these things from the beginning or make minor changes to our code.
  prefs: []
  type: TYPE_NORMAL
- en: bUnit doesn’t rely on a web browser but renders the output internally and exposes
    it to us so that we can test against predefined outputs. This is also a limitation
    – we are not testing the real site; we are testing the component, so think of
    this as unit tests, not integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time for us to get our hands dirty, so let’s create a test project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a test project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to run tests, we need a test project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the **bUnit** templates, open PowerShell and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check which is the latest version of the templates on the bUnit web page: [https://bunit.dev/](https://bunit.dev/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, right-click the **MyBlog** solution and choose **Add** | **New
    Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for **bUnit**, select **bUnit Test Project** in the results, and then
    click **Next**. Sometimes, it takes time to find a template, and we can also change
    the **Project Type** dropdown to **bUnit** to find the template. We might need
    to reboot Visual Studio to find it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project `MyBlog.Tests`, leave the location as is, and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **xUnit** as the unit test framework and target framework: **.NET 8.0**,
    and click **Create**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! We now have a test project. Before we mock the API, let’s look at the
    different methods available to us so we can get a feel for how bUnit works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MyBlog.Tests`, we should have the following four files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_Imports.razor` contains the namespaces that we want all of our Razor files
    to have access to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Counter.razor` is a copy of the same `Counter` components we get by default
    in the Blazor template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CounterCSharpTest.cs` contains tests written in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CounterRazorTest.razor` contains tests written in Razor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with the `CounterCSharpTest.cs` file, which contains two tests:
    one that checks that the counter starts at `0` and one that clicks the button
    and verifies the counter is now `1`. These two simple tests make sense for testing
    the `Counter` component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CounterStartsAtZero` test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break this down. The `Fact` attribute tells the test runner that this
    is a *normal* test with no parameters. We can also use the `Theory` attribute
    to tell the test runner that the `test` method needs parameter values, but we
    don’t need parameters for this use case.
  prefs: []
  type: TYPE_NORMAL
- en: First, we arrange the test. Simply put, we set up everything we need to do the
    test. Egil uses `cut` as the component’s name, which stands for **component under
    testing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we run the `RenderComponent` method and pass in the component
    type, which is the `Counter` component. Next, we assert whether the component
    outputs the correct thing or not. We use the `Find` method to find the first paragraph
    tag and then verify that the HTML looks like `<p>Current count: 0</p>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second test is a bit more advanced, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous test, we start arranging by rendering our `Counter` component.
    The next step is acting, where we click the button. We look for the button and
    then click the button in our `Counter` component. There is only one button, so
    in this case, it’s safe to look for the button this way.
  prefs: []
  type: TYPE_NORMAL
- en: Then it’s time to assert again, and we check the markup in the same way as the
    previous test, but we look for `1` instead of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another alternative where we can write out tests with Razor syntax.
    If we look at the `CounterRazorTests.razor` files, we can see the exact same tests
    but with different syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is really only the way we render the component that differs. This does the
    same thing and is only a matter of preference. I prefer using the Razor version;
    it is easier to read, and it’s also easier to add parameters to our component
    while testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the tests and see whether they pass:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, bring up **Test Explorer** by searching for it using *Ctrl*
    + *Q*. We can also find it in **View** | **Test Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Run All Test** in the view. Test Explorer should look like *Figure
    13.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Visual Studio Test Explorer ](img/B21849_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Visual Studio Test Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Wonderful! Now, our first test is running and hopefully passing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a look at mocking the API.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to test our application. Testing the API is beyond
    the scope of this book, but we still need to test the components, which are dependent
    on the API. We could spin up the API and test against the API, but in this case,
    we are only interested in testing the Blazor component.
  prefs: []
  type: TYPE_NORMAL
- en: We can then mock the API or create a fake copy of the API that doesn’t read
    from the database but reads from a predefined dataset. This way, we always know
    what the output should be.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the interface we created for our API is just what we need to create
    a mock API.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t implement 100% of the tests for the project, so we don’t have to mock
    all the methods. Please feel free to implement tests for all methods as an exercise
    at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we can implement the mock API. We could spin up an in-memory
    database, but to keep things simple, we will choose the other option and generate
    posts when we ask for them:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MyBlog.Tests` project, add a project reference to the `SharedComponents`
    and `BlazorWebApp` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `BlogApiMock.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `IBlogApi` interface; the class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we will implement each of the methods so we can get data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For `BlogPost`, add the following code in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the GetBlogPostAsync method, we create a blog post and fill it with
    predefined information we can use later in our tests. The same thing goes for
    getting a list of blog posts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also say that we have a total of `10` blog posts in the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For categories, add the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we do the same thing: we create categories named `Category` followed
    by a number.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For comments, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create a comment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The same thing goes for tags; add the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will not add tests for other methods in the API. We do need to add them
    to the mock class to fulfill the interface:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have a mock API that does the same thing repeatedly so we can make reliable
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to write some tests. As I mentioned earlier in the chapter, we won’t
    create tests for the entire site; we will leave that to you to finish later if
    you want to. This is just to get a feel for how to write tests:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MyBlog.Tests` project, create a new folder called `Pages`. This is just
    so we can keep a bit of a structure (the same folder structure as the project
    we are testing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Pages` folder and create a new Razor component called `HomeTest.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `_Imports` file, add the following namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `HomeTest.razor` file, inherit from `TestContext` by adding the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will add the test. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We give our test a display name so we understand what it does. The test is pretty
    simplistic; we know we have `10` blog posts from the mock API. We also know that
    each blog post is rendered within an `article` tag. We find all `article` tags
    and make sure we have `10` in total.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we are using injection, we need to configure dependency injection, which
    we can do in the constructor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to add the `HomeTest` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will run when the class is created, and here, we declare that if
    the components ask for an instance of `BlogApi`, it will return an instance of
    our mock API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This works the same way as with Blazor Server, where we return an API that talks
    directly to the database, and with Blazor WebAssembly, where we return an instance
    of the API that talks to a web API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this case, it will return our mock API, which returns data that is easy to
    test. Now, we need to run the actual test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Delete the default tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio, bring up Test Explorer by searching for it using *Ctrl* +
    *Q*. We can also find it in **View** | **Test Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run our tests to see whether we get a green light, as shown in *Figure 13.2*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B21849_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Test Explorer with IndexTest'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a test that checks that 10 posts are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: bUnit is an excellent framework for testing, and the fact that it is explicitly
    written for Blazor so that it takes advantage of Blazor’s power makes it amazing
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a simplistic test for our blog, but bUnit has support for more
    advanced features, such as authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using bUnit, we can test authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: It is, however, not the components themselves that are doing the authentication.
    We added `AuthorizeRouteView` to `App.razor` in *Chapter 8*, *Authentication and
    Authorization*, so testing that in individual components won’t make a difference.
  prefs: []
  type: TYPE_NORMAL
- en: But we can use `AuthorizeView`, for example, and we have it in our blog in the
    `LoginStatus` component, which displays a login link when we are not authorized
    and a logout link when we are authorized. Please feel free to add these tests
    as we did in the previous section, or use them as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `AddTestAuthorization` method to authorize our tests like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This method adds `TestAuthorization` but is not authorized. The page will then
    display a link with the text `Log in`. To test when the user is authorized, we
    just set the user as authorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can add claims, roles, and much more. The user we utilize for testing does
    not correlate with the users or roles in the database; the authorization is mocked
    by bUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization could be tricky to test, but using bUnit is
    really simple. Testing JavaScript is a bit harder, but bUnit has a solution for
    that as well.
  prefs: []
  type: TYPE_NORMAL
- en: Testing JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing JavaScript is not supported by bUnit, which is understandable. We can,
    however, test the interop ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we have used the .NET 5 syntax for our JavaScript. In our `SharedComponents\ReusableComponents\BlogButton.razor`
    component, we make a JavaScript interop to confirm the deletion of an item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript call looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We make sure that we load the JavaScript module and then execute the `showConfirm`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript testing in bUnit can be done in two modes – `strict` and `loose`.
    The default value is `strict`, so we need to specify every module and every method.
  prefs: []
  type: TYPE_NORMAL
- en: If we choose `loose`, all methods will just return the default value. For a
    Boolean, it would return `false`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the preceding JavaScript call, we can do that by adding something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We set up a module with the same path to JavaScript as before. Then, we specify
    the method and any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we specify what the result should be. In this case, we return `true`,
    which would return from JavaScript if we want to delete the item. We could also
    verify whether the JavaScript method is being called. A complete example for testing
    this in the `ItemList` component would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Great job! We now have tests in our project. Even though we aren’t covering
    all the components, we should have all the building blocks to complete the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about bUnit, check out the following link: [https://bunit.dev/docs/getting-started/index.html](https://bunit.dev/docs/getting-started/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Their documentation is fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to know that it is also possible to use other testing frameworks.
    We use a combination of Playwright tests and bUnit but we test completely different
    things. You can find Playwright here: [https://playwright.dev/dotnet/docs/intro](https://playwright.dev/dotnet/docs/intro).'
  prefs: []
  type: TYPE_NORMAL
- en: Before we summarize this chapter, we have one more thing to talk about.
  prefs: []
  type: TYPE_NORMAL
- en: Blazm extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are things that are a bit tedious when developing Blazor applications.
    We have done many of those things throughout the book. I tend to spell things
    wrong when I code, and when creating an isolated CSS or JavaScript file, I tend
    to get the name wrong from time to time and even get the file extension wrong.
    So, I thought, is there a better way to do this?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, there is!
  prefs: []
  type: TYPE_NORMAL
- en: I built a Visual Studio extension that will add some very nice features to Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: But why in the world have I waited so long to talk about this!? Well, it’s important
    to learn the “real” way first, then take the shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check out the extension here: [https://marketplace.visualstudio.com/items?itemName=EngstromJimmy.BlazmExtension](https://marketplace.visualstudio.com/items?itemName=EngstromJimmy.BlazmExtension)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can help us add a code-behind file and isolated CSS and JavaScript files.
    It can also help us move namespaces into the `_imports` file and much more. But
    it can also help us generate tests, not the whole way, but it will help us on
    the way. Do you remember the `Alerts` component we used in *Chapter 4*? We can
    right-click that component and choose `Generate` **bUnit test**, and then as **Razor
    syntax**. It will generate the code to the clipboard so we can paste it where
    we want it. It will automatically give us this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is not perfect as we can see, but it gives us something to stand
    on. If we were to write a test for the `Alert` component, it would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We had to clean up some namespaces and add an assertion. It’s pretty neat if
    you ask me, but then again, I am pretty biased on this topic. I really hope this
    extension will help you, and I would love for you to give it a five-star review
    if you enjoy it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at testing our application. We looked at how we can
    mock an API to make reliable tests. We also covered how to test JavaScript interop
    as well as authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Tests can speed up our development and, most importantly, build quality. With
    bUnit combined with dependency injection, it is easy to build tests that can help
    us test our components.
  prefs: []
  type: TYPE_NORMAL
- en: Since we can test every component by itself, we don’t have to log in, navigate
    to a specific place on our site, and then test the entire page, as many other
    testing frameworks would have us do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our site contains reusable components, authentication, APIs, Blazor Server,
    Blazor WebAssembly, authentication, shared code, JavaScript interop, state management,
    and tests. We only have one more thing to do: ship it!'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Chapter 14*, *Deploying to Production*, it’s time to ship.
  prefs: []
  type: TYPE_NORMAL
