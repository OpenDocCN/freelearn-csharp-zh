- en: 6 Model-View-Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter delves into the Model-View-Controller (MVC) design pattern, a
    cornerstone of modern software architecture that intuitively structures your code
    around entities. MVC is perfect for CRUD operations or to tap into the advanced
    features unavailable in Minimal APIs. The MVC pattern partitions your application
    into three interrelated parts: Models, Views, and Controllers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Models**, which represent our data and business logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views**, which are the user-facing components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers**, that act as intermediaries, mediating the interaction between
    Models and Views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With its emphasis on the separation of concerns, the MVC pattern is a proven
    pattern for creating scalable and robust web applications. In the context of ASP.NET
    Core, MVC has provided a practical approach to building applications efficiently
    for years. While we discussed REST APIs in *Chapter 4*, this chapter provides
    insight into how to use MVC to create REST APIs. We also address using Data Transfer
    Objects (DTOs) within this framework.In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Controller design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MVC with DTOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our ultimate goal is clean, maintainable, and scalable code; the ASP.NET Core
    MVC framework is a favored tool for achieving this. Let's dive in!
  prefs: []
  type: TYPE_NORMAL
- en: The Model View Controller design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have explored the basics of REST and Minimal APIs, it is time to
    explore the MVC pattern to build ASP.NET Core REST APIs.Model-View-Controller
    (MVC) is a design pattern commonly used in web development. It has a long history
    of building REST APIs in ASP.NET and is widely used and praised by many.This pattern
    divides an application into three interconnected components: the Model, the View,
    and the Controller. A View in MVC formerly represented a user interface. However,
    in our case, the View is a data contract that reflects the REST API’s data-oriented
    nature.'
  prefs: []
  type: TYPE_NORMAL
- en: Dividing responsibilities this way aligns with the **Single Responsibility Principle**
    (**SRP**) explored in *Chapter 3*, *Architectural Principles*. However, this is
    not the only way to build REST APIs with ASP.NET Core, as we saw in *Chapter 5*,
    *Minimal APIs*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The new minimal API model mixed with the Request-EndPoint-Response (REPR) pattern
    can make building REST APIs leaner. We cover that pattern in *Chapter 18*, *Request-EndPoint-Response
    (REPR)*. We could see REPR as what ASP.NET Core Razor Pages are to page-oriented
    web applications, but for REST APIs.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We often design MVC applications around entities, and each entity has a controller
    that orchestrates its endpoints. We called those CRUD controllers. However, you
    can design your controller to fit your needs.In the past few decades, the number
    of REST APIs just exploded to a gazillion; everybody builds APIs nowadays, not
    because people follow the trend but based on good reasons. REST APIs have fundamentally
    transformed how systems communicate, offering various benefits that make them
    indispensable in modern software architecture. Here are a few key factors that
    contribute to their widespread appeal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Efficiency**: REST APIs promote efficient data sharing across different
    systems, fostering seamless interconnectivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal Communication**: REST APIs leverage universally recognized data
    formats like JSON or XML, ensuring broad compatibility and interoperability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backend Centralization**: REST APIs enable the backend to serve as a centralized
    hub, supporting multiple frontend platforms, including mobile, desktop, and web
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered Backends**: REST APIs facilitate the stratification of backends,
    allowing for the creation of foundational, low-level APIs that provide basic functionalities.
    These, in turn, can be consumed by higher-level, product-centric APIs that offer
    specialized capabilities, thus promoting a flexible and modular backend architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Measures**: REST APIs can function as gateways, providing security
    measures to protect downstream systems and ensuring data access is appropriately
    regulated—a good example of layering APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: REST APIs allow for the encapsulation of specific units
    of logic into reusable, independent modules, often leading to cleaner, more maintainable
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: due to their stateless nature, REST APIs are easier to scale
    up to accommodate increasing loads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These advantages greatly facilitate the reuse of backend systems across various
    user interfaces or even other backend services. Consider, for instance, a typical
    mobile application that needs to support iOS, Android, and web platforms. By utilizing
    a shared backend through REST APIs, development teams can streamline their efforts,
    saving significant time and cost. This shared backend approach ensures consistency
    across platforms while reducing the complexity of maintaining multiple codebases.
  prefs: []
  type: TYPE_NORMAL
- en: We explore different such patterns in *Chapter 19*, *Introduction to Microservices
    Architecture*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of REST APIs, the MVC pattern aims to streamline the process
    of managing an entity by breaking it down into three separate, interacting components.
    Rather than struggling with large, bloated blocks of code that are hard to test,
    developers work with smaller units that enhance maintainability and promote efficient
    testing. This compartmentalization results in small, manageable pieces of functionality
    that are simpler to maintain and test.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MVC divides the application into three distinct parts, where each has a single
    responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: The model represents the data and business logic we are modeling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: The view represents what the user sees. In the context of REST APIs,
    that usually is a serialized data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: The controller represents a key component of MVC. It orchestrates
    the flow between the client request and the server response. The primary role
    of the controller is to act as an HTTP bridge. Essentially, the controller facilitates
    the communication in and out of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code of a controller should remain minimalistic and not contain complex
    logic, serving as a thin layer between the clients and the domain.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We explore alternative points of view in *Chapter 14*, *Layering and Clean Architecture*.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is a diagram that represents the MVC flow of a REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Workflow of a REST API using MVC](img/file30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Workflow of a REST API using MVC'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we send the model directly to the client. In most
    scenarios, this is not ideal. We generally prefer sending only the necessary data
    portion, formatted according to our requirements. We can design robust API contracts
    by leveraging the Data Transfer Object (DTO) pattern to achieve that. But before
    we delve into that, let's first explore the basics of ASP.NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of ASP.NET Core web APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to create a REST API project in .NET, including the `dotnet
    new webapi` CLI command, also available from Visual Studio’s UI. Next, we explore
    a few pieces of the MVC framework, starting with the entry point.
  prefs: []
  type: TYPE_NORMAL
- en: The entry point
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first piece is the entry point: the `Program.cs` file. Since .NET 6, there
    is no more `Startup` class by default, and the compiler autogenerates the `Program`
    class. As explored in the previous chapter, using the minimal hosting model leads
    to a simplified `Program.cs` file with less boilerplate code.Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `Program.cs` file, the highlighted lines identify the minimum
    code required to enable ASP.NET Core MVC. The rest is very similar to the Minimal
    APIs code.
  prefs: []
  type: TYPE_NORMAL
- en: Directory structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The default directory structure contains a `Controllers` folder to host the
    controllers. On top of that, we can create a `Models` folder to store your model
    classes or use any other structure.
  prefs: []
  type: TYPE_NORMAL
- en: While controllers are typically housed in the `Controllers` directory for organizational
    purposes, this convention is more for the benefit of developers than a strict
    requirement. ASP.NET Core is indifferent to the file's location, offering us the
    flexibility to structure our project as we see fit.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Section 4, Applications Patterns*, explores many ways of designing applications.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we look at the central part of this pattern—the controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The easiest way to create a controller is to create a class inheriting from
    `ControllerBase`. However, while `ControllerBase` adds many utility methods, the
    only requirement is to decorate the controller class with the `[ApiController]`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'By convention, we write the controller’s name in its plural form and suffix
    it with `Controller`. For example, if the controller relates to the `Employee`
    entity, we’d name it `EmployeesController`, which, by default, leads to an excellent
    URL pattern that is easy to understand:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Get all employees: `/employees`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get a specific employee: `/employees/{id}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have a controller class, we must add actions. Actions are public methods
    that represent the operations that a client can perform. Each action represents
    an HTTP endpoint.More precisely, the following defines a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: A controller exposes one or more actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action can take zero or more input parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action can return zero or one output value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action is what handles the HTTP request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should group cohesive actions under the same controller, thus creating a
    loosely coupled unit.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example, the following represents the `SomeController` class containing
    a single `Get` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `Get` method (action) returns an empty `200 OK` response to the
    client. We can reach the endpoint at the `/api/some` URI. From there, we can add
    more actions.
  prefs: []
  type: TYPE_NORMAL
- en: The `ControllerBase` class gives us access to most of the same utility methods
    as we had with the Minimal APIs `TypedResults` class.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we look at returning value.
  prefs: []
  type: TYPE_NORMAL
- en: Returning values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Building a REST API aims to return data to clients and execute remote operations.
    Most of the plumbing is done for us by the ASP.NET Core code, including serialization.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the ASP.NET Core pipeline is customizable, which is out of the scope
    of this chapter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Before returning values, let’s look at a few valuable helper methods provided
    by the `ControllerBase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusCode` | Produces an empty response with the specified status code.We
    can optionally include a second argument to serialize in the response body. |'
  prefs: []
  type: TYPE_TB
- en: '| `Ok` | Produces a `200 OK` response, indicating the operation was successful.We
    can optionally include a second argument to serialize in the response body. |'
  prefs: []
  type: TYPE_TB
- en: '| `Created` | Produces a `201 Created` response, indicating the system created
    the entity.We can optionally specify the location where to read the entity and
    the entity itself as arguments.The `CreatedAtAction` and `CreatedAtRoute` methods
    give us options to compose the location value. |'
  prefs: []
  type: TYPE_TB
- en: '| `NoContent` | Produces an empty `204 No Content` response. |'
  prefs: []
  type: TYPE_TB
- en: '| `NotFound` | Produces a `404 Not Found` response, indicating the resource
    was not found. |'
  prefs: []
  type: TYPE_TB
- en: '| `BadRequest` | Produces a `400 Bad Request` response, indicating an issue
    with the client request, often a validation error. |'
  prefs: []
  type: TYPE_TB
- en: '| `Redirect` | Produces a `302 Found` response, accepting the `Location` URL
    as an argument.Different `Redirect*` methods produce `301 Moved Permanently`,
    `307 Temporary Redirect`, and `308 Permanent Redirect` responses instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `Accepted` | Produces a `202 Accepted` response, indicating the beginning
    of an asynchronous process.We can optionally specify the location the client can
    query to learn about the status of the asynchronous operation. We can also optionally
    specify an object to serialize in the response body.The `AcceptedAtAction` and
    `AcceptedAtRoute` methods give us options to compose the location value. |'
  prefs: []
  type: TYPE_TB
- en: '| `Conflict` | Produces a `409 Conflict` response, indicating a conflict occurred
    when processing the request, often a concurrency error. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: a subset of the ControllerBase methods producing an IActionResult.'
  prefs: []
  type: TYPE_NORMAL
- en: Other methods in the `ControllerBase` class are self-discoverable using IntelliSense
    (code completion) or in the official documentation. Most, if not all, of what
    we covered in *Chapter 5*, *Minimal APIs*, is also available to controllers.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The advantage of using a helper method is leveraging the ASP.NET Core MVC mechanism,
    making our life easier. However, you could manually manage the HTTP response using
    lower-level APIs like `HttpContext` or create custom classes that implement the
    `IActionResult` interface to hook your custom response classes into the MVC pipeline.Now
    let’s look at the multiple ways we can use to return data to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Return type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `void` | We can return `void` and manually manage the HTTP response using
    the `HttpContext` class.This is the most low-level and complex way. |'
  prefs: []
  type: TYPE_TB
- en: '| `TModel` | We can directly return the model, which ASP.NET Core will serialize.
    The problem with this approach is that we don’t control the status code, nor can
    we return multiple different results from the action. |'
  prefs: []
  type: TYPE_TB
- en: '| `ActionResult``IActionResult` | We can return one of those two abstractions.
    The concrete result can take many forms depending on the implementation that the
    action method returns.However, doing this makes our API less auto-discoverable
    by tools like SwaggerGen. |'
  prefs: []
  type: TYPE_TB
- en: '| `ActionResult<TModel>` | We can return the `TModel` directly and other results
    like a `NotFoundResult` or a `BadRequestResult`.This is the most flexible way
    that makes the API the most discoverable by the ApiExplorer. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.2: multiple ways to return data'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with an example where the actions return an instance of the `Model`
    class by leveraging the `Ok` method (highlighted code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with the preceding code is API discoverability. The `ApiExplorer`
    can’t know what the endpoints return. The `ApiExplorer` describes the actions
    as returning `200 OK` but doesn’t know about the `Model` class.To overcome this
    limitation, we can decorate our actions with the `ProducesResponseType` attribute,
    effectively circumventing the limitation as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we specify the return type as the first argument and
    the status code as the second. Using the constants of the `StatusCodes` class
    is a convenient way to reference standard status codes. We can decorate each action
    with multiple `ProducesResponseType` attributes to define alternate states, such
    as `404` and `400`.
  prefs: []
  type: TYPE_NORMAL
- en: With ASP.NET Core MVC, we can also define conventions that apply broad rules
    to our controllers, allowing us to define those conventions once and reuse them
    throughout our application. I left a link in the *Further reading* section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next, We explore how we can return a `Model` instance directly. The `ApiExplorer`
    can discover the return value of the method this way, so we do not need to use
    the `ProducesResponseType` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, thanks to **class conversion operators** (see *Appendix A* for more info),
    we can do the same with `ActionResult<T>`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The main benefit of using `ActionResult<T>` is to return other types of results.
    Here is an example showing this where the method returns either `Ok` or `NotFound`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, the `ApiExplorer` does not know about the `404 Not Found`, so we must
    document it using the `ProducesResponseType` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: We can return a `Task<T>` or a `ValueTask<T>` from the action method when the
    method body is asynchronous. Doing so lets you write the async/await code from
    the controller.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I highly recommend returning a `Task<T>` or a `ValueTask<T>` whenever possible
    because it allows your REST API to handle more requests using the same resources
    without effort. Nowadays, non-Task-based methods in libraries are infrequent,
    so you will most likely have little choice.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: We learned multiple ways to return values from an action. The `ActionResult<T>`
    class is the most flexible regarding feature support. On the other hand, `IActionResult`
    is the most abstract one.Next, we look at routing requests to those action methods.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Attribute routing maps an HTTP request to a controller action. Those attributes
    decorate the controllers and the actions to create the complete routes. We already
    used some of those attributes. Nonetheless, let’s visit those attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Route` attributes and `Http[Method]` attributes define what a user should
    query to reach a specific resource. The `Route` attribute allows us to define
    a routing pattern that applies to all HTTP methods under the decorated controller.
    The `Http[Method]` attributes determine the HTTP method used to reach that action
    method. They also offer the possibility to set an optional and additive route
    pattern to handle more complex routes, including specifying route parameters.
    Those attributes are beneficial in crafting concise and clear URLs while keeping
    the routing system close to the controller. All routes must be unique.Based on
    the code, `[Route("empty/[controller]")]` means that the actions of this controller
    are reachable through `empty/customers` (MVC ignores the `Controller` suffix).
    Then, the other attributes tell ASP.NET to map specific requests to specific methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Routing Attribute | HTTP Method | URL |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpGet` | `GET` | `empty/customers` |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpGet("{id}")` | `GET` | `empty/customers/{id}` |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpPost` | `POST` | `empty/customers` |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpPut("{id}")` | `PUT` | `empty/customers/{id}` |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpDelete("{id}")` | `DELETE` | `empty/customers/{id}` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.3: routing attributes of the example controller and their final URL'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the preceding table, we can even use the same attribute
    for multiple actions as long as the URL is unique. In this case, the `id` parameter
    is the `GET` discriminator.Next, we can use the `FromBody` attribute to tell the
    model binder to use the HTTP request body to get the value of that parameter.
    There are many of those attributes; here’s a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `FromBody` | Binds the JSON body of the request to the parameter’s type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FromForm` | Binds the form value that matches the name of the parameter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FromHeader` | Binds the HTTP header value that matches the name of the parameter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FromQuery` | Binds the query string value that matches the name of the parameter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FromRoute` | Binds the route value that matches the name of the parameter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FromServices` | Inject the service from the ASP.NET Core dependency container.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.4: MVC binding sources'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core MVC does many implicit binding, so you don’t always need to decorate
    all parameters with an attribute. For example, .NET injects the services we needed
    in the code samples, and we never used the `FromServices` attribute. Same with
    the `FromRoute` attribute.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, if we look back at `CustomersController`, the route map looks like the
    following (I excluded non-route-related code to improve readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL** | **Action/Method** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET empty/customers` | `GetAllAsync()` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET empty/customers/{id}` | `GetOneAsync(int id)` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST empty/customers` | `PostAsync([FromBody] Customer value)` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT empty/customers/{id}` | `PutAsync(int id, [FromBody] Customer value)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE empty/customers/{id}` | `DeleteAsync(int id)` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.5: the map between the URLs and their respective action methods'
  prefs: []
  type: TYPE_NORMAL
- en: When designing a REST API, the URL leading to our endpoints should be clear
    and concise, making it easy for consumers to discover and learn. Hierarchically
    grouping our resources by responsibility (concern) and creating a cohesive URL
    space help achieve that goal. Consumers (a.k.a. other developers) should understand
    the logic behind the endpoints easily. Think about your endpoints as if you were
    the consumer of the REST API. I would even extend that suggestion to any API;
    always consider the consumers of your code to create the best possible APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section explored the MVC pattern, how to create controllers and action
    methods, and how to route requests to those actions.We could talk about MVC for
    the remainder of the book, but we would be missing the point. The subset of features
    we covered here should be enough theory to fill the gap you might have had and
    allow you to understand the code samples that leverage ASP.NET Core MVC.Using
    the MVC pattern helps us follow the SOLID principles in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: The MVC pattern divides the rendering of a data structure into three
    different roles. The framework handles most of the serialization portion (the
    View), leaving us only two pieces to manage: the Model and the Controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: Each controller handles a subset of features and represents a smaller
    interface into the system. MVC makes the system easier to manage than having a
    single entry point for all routes, like a single controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we explore the **Data Transfer Object** pattern to isolate the API’s model
    from the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Using MVC with DTOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explores leveraging the **Data Transfer Object** (**DTO**) pattern
    with the MVC framework.
  prefs: []
  type: TYPE_NORMAL
- en: This section is the same as we explore in *Chapter 5*, *Minimal APIs*, but in
    the context of MVC. Moreover, the two code projects are part of the same Visual
    Studio solution for convenience, allowing you to compare the two implementations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a reminder, DTOs aim to *control the inputs and outputs of an endpoint* by
    decoupling the API contract from the application’s inner workings. DTOs empower
    us to define our APIs without thinking about the underlying data structures, leaving
    us to craft our REST APIs how we want.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss REST APIs and DTOs more in-depth in *Chapter 4*, *REST APIs*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Other possible objectives are to save bandwidth by limiting the amount of information
    the API transmits, flattening the data structure, or adding API features that
    cross multiple entities.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by analyzing a diagram that expands MVC to work with DTOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: MVC workflow with a DTO](img/file31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: MVC workflow with a DTO'
  prefs: []
  type: TYPE_NORMAL
- en: DTOs allow the decoupling of the domain from the view (data) and empower us
    to manage the inputs and outputs of our REST APIs independently from the domain.
    The controller still manipulates the domain model but returns a serialized DTO
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Project – MVC API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This code sample is the same as in the previous chapter but uses the MVC framework
    instead of Minimal APIs*.**Context**: we must build an application to manage customers
    and contracts. We must track the state of each contract and have a primary contact
    in case the business needs to contact the customer. Finally, we must display the
    number of contracts and the number of opened contracts for each customer on a
    dashboard.As a reminder, the model is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is straightforward. The only piece of logic is the `WorkStatus.State`
    property that returns `WorkState.New` when the work has not yet started on that
    contract, `WorkState.Completed` when all the work is completed, or `WorkState.InProgress`
    otherwise.The controllers leverage the `ICustomerRepository` interface to simulate
    database operations. The implementation is unimportant. It uses a `List<Customer>`
    as the database. Here’s the interface that allows querying and updating the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know about the underlying foundation, we explore a CRUD controller
    that does not leverage DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: Raw CRUD Controller
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many issues can arise if we create a CRUD controller to manage the customers
    directly (see `RawCustomersController.cs`). First, a little mistake from the client
    could erase several data points. For example, if the client forgets to send the
    contracts during a `PUT` operation, that would delete all the contracts associated
    with that customer. Here’s the controller code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code represents the customer update. So to mistakenly remove
    all contracts, a client could send the following HTTP request (from the `MVC.API.http`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That request would result in the following response entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, however, that customer had contracts (seeded when we started the
    application). Here’s the original data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, by exposing our entities directly, we are giving a lot of power
    to the consumers of our API. Another issue with this design is the dashboard.
    The user interface would have to calculate the statistics about the contracts.
    Moreover, if we implement paging the contracts over time, the user interface could
    become increasingly complex and even overquery the database, hindering our performance.
  prefs: []
  type: TYPE_NORMAL
- en: I implemented the entire API, which is available on GitHub but without UI.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we explore how we can fix those two use cases using DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: DTO controller
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To solve our problems, we reimplement the controller using DTOs. To make it
    easier to follow along, here are all the DTOs as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let’s fix our update problem, starting with the reimplementation of
    the update endpoint leveraging DTOs (see the `DTOCustomersController.cs` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the main differences are (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: The request body is now bound to the `UpdateCustomer` class instead of the `Customer`
    itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action method returns an instance of the `CustomerDetails` class instead
    of the `Customer` itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, we can see more code in our controller action than before. That’s
    because the controller now handles the data changes instead of the clients. The
    action now does:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the data from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the entity exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the input DTO to update the data, limiting the clients to a subset of properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proceed with the update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the entity still exists (handles conflicts).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the Customer into the output DTO and return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By doing this, we now control what the clients can do when they send a `PUT`
    request through the input DTO (`UpdateCustomer`). Moreover, we encapsulated the
    logic to calculate the statistics on the server. We hid the computation behind
    the output DTO (`CustomerDetails`), which lowers the complexity of our user interface
    and allows us to improve the performance without impacting any of our clients
    (loose coupling).Furthermore, we now use the `customerId` parameter.If we send
    the same HTTP request as before, which sends more data than we accept, only the
    customer''s name will change. On top of that, we get all the data we need to display
    the customer’s statistics. Here’s a response example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding response, only the customer’s name changed,
    but we now received the `statusWorkDone` and `statusTotalWork` fields. Lastly,
    we flattened the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: DTOs are a great resource to flatten data structures, but you don’t have to.
    You must always design your systems, including DTOs and data contracts, for specific
    use cases.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As for the dashboard, the “get all customers” endpoint achieves this by doing
    something similar. It outputs a collection of `CustomerSummary` objects instead
    of the customers themselves. In this case, the controller executes the calculations
    and copies the entity''s relevant properties to the DTO. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the action method:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the entities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the DTOs and calculate the number of open contracts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the DTOs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As simple as that, we now encapsulated the computation on the server.
  prefs: []
  type: TYPE_NORMAL
- en: You should optimize such code based on your real-life data source. In this case,
    a `static` `List<T>` is low latency. However, querying the whole database to get
    a count can become a bottleneck.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Calling the endpoint results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is now super easy to build our dashboard. We can query that endpoint once
    and display the data in the UI. The UI offloaded the calculation to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: User interfaces tend to be more complex than APIs because they are stateful.
    As such, offloading as much complexity to the backend helps. You can use a Backend-for-frontend
    (BFF) to help with this task. We explore ways to layer APIs, including the BFF
    pattern in *Chapter 19*, *Introduction to Microservices Architecture*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Lastly, you can play with the API using the HTTP requests in the `MVC.API.DTO.http`
    file. I implemented all the endpoints using a similar technique. If your controller
    logic becomes too complex, it is good practice to encapsulate it into other classes.
    We explore many techniques to organize application code in *Section 4*: *Applications
    patterns*.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A data transfer object allows us to design an API endpoint with a specific
    data contract (input and output) instead of exposing the domain or data model.
    This separation between the presentation and the domain is a crucial element that
    leads to having multiple independent components instead of a bigger, more fragile
    one. Using DTOs to control the inputs and outputs gives us more control over what
    the clients can do or receive.Using the data transfer object pattern helps us
    follow the SOLID principles in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: A DTO adds clear boundaries between the domain model and the API contract.
    Moreover, having an input and an output DTO help further separate the responsibilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: A DTO is a small, specifically crafted data contract (abstraction) with
    a clear purpose in the API contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Due to those smaller interfaces (ISP), DTOs allow changing the implementation
    details of the endpoint without affecting the clients because they depend only
    on the API contract (an abstraction).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have learned DTOs' added value, their role in an API contract, and the ASP.NET
    Core MVC framework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter explored the Model-View-Controller (MVC) design pattern, a well-established
    framework in the ASP.NET ecosystem that offers more advanced features than its
    newer Minimal APIs counterpart. Minimal APIs are not competing against MVC; we
    can use them together. The MVC pattern emphasizes the separation of concerns,
    making it a proven pattern for creating maintainable, scalable, and robust web
    applications. We broke down the MVC pattern into its three core components: Models,
    Views, and Controllers. Models represent data and business logic, Views are user-facing
    components (serialized data structures), and Controllers act as intermediaries,
    mediating the interaction between Models and Views. We also discussed using Data
    Transfer Objects (DTOs) to package data in the format we need, providing many
    benefits, including flexibility, efficiency, encapsulation, and improved performance.
    DTOs are a crucial part of the API contract.Now that we have explored principles
    and methodologies, it is time to continue our learning and tackle more design
    patterns and features. The following two chapters explore our first Gang of Four
    (GoF) design patterns and deep dive into ASP.NET Core dependency injection (DI).
    All of this will help us to continue on the path we started: to learn the tools
    to design better software.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the three components of the MVC design pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of a Controller in the MVC pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Data Transfer Objects (DTOs), and why are they important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the MVC pattern contribute to the maintainability of an application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does attribute routing work in MVC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some links to build on what we have learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using web API conventions: [https://adpg.link/ioKV](https://adpg.link/ioKV)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting started with Swashbuckle and ASP.NET Core: [https://adpg.link/ETja](https://adpg.link/ETja)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three components of the MVC design pattern are Models, Views, and Controllers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the MVC pattern, a Controller acts as an intermediary, mediating the interaction
    between Models and Views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use Data Transfer Objects (DTOs) to package data into a format that provides
    many benefits, including efficient data sharing, encapsulation, and improved maintainability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MVC pattern contributes to the maintainability of an application by separating
    concerns. Each component (Model, View, Controller) has a specific role and responsibility,
    making the code easier to manage, test, and extend. This separation allows changes
    to one component to have minimal impact on the others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attribute routing in MVC maps an HTTP request to a controller action. These
    attributes decorate the controllers and the actions to create the complete routes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
