<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.200rem;">
<head><title>Chapter&#160;4.&#160;Introduction to Concurrency in F#</title>
<link rel="stylesheet" href="../Styles/style0001.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<div class="chapter" title="Chapter&#160;4.&#160;Introduction to Concurrency in F#"><div class="titlepage" id="aid-11C3M2"><div><div><h1 class="title"><a id="ch04"></a>Chapter&#160;4.&#160;Introduction to Concurrency in F#</h1>
</div>
</div>
</div>
<p>Performance optimizations are not just about understanding the underlying platform, profiling, toolings and measurements, and data structures. Now, with the rising trend of multicore processors and at the same time, the increasing needs of responsive applications to be achieved as and when required, concurrency is not just becoming more relevant but also a necessary requirement across all kinds of enterprise applications, especially applications across all full stacks of layers of multi-tier architecture applications.</p>
<p>It is also evident that concurrency is one of those performance optimizations that are often misunderstood. Some common misunderstood samples have already been described in <a class="link" title="Chapter&#160;1.&#160;Performing Common Optimizations in F#" href="fsp-hiperf_cu01.html#aid-E9OE2">Chapter 1</a>, <span class="emphasis"><em>Performing Common Optimizations in F#</em></span>. In this chapter, we will focus on concurrency features in F# and also get to know the basic strategy behind the deciding factor of the actual implementation.</p>
<p>To understand the background reasoning for the chosen strategy, first we must get to know the features of concurrency in F# especially in F# 4.0. There is no noticeable difference between F# 3.0 and F# 4.0 in terms of the existing concurrency features. There are F# 4.0 additional features to have interop with .NET Task Parallel Library, as these interop features will be explained in this chapter.</p>
<p>Having a knowledge of measurement tooling, covered in <a class="link" title="Chapter&#160;2.&#160;Performance Measurement" href="fsp-hiperf_cu02.html#aid-K0RQ2">Chapter 2</a>, <span class="emphasis"><em>Performance Measurement</em></span>,&#160;qualitative knowledge of the mechanism of running F# code (the IL, tooling, and the GC), and having quantitative measures (the execution durations using timers and unit tests) are requirements in order to easily understand the importance of concurrency and the decisive factor of choosing the right concurrent model.</p>
<p>Throughout this chapter, we will see that there is no silver bullet for all kinds of concurrency problems. For example, using only parallel computation to handle I/O operations is not recommended because I/O operation is a good sample of a blocking thread. However, it is also important to identify which threads or processes are blocking threads. Combining this with asynchronous computation is recommended. Also, there is not a single concurrency feature that cannot be combined with other kinds of concurrency features, as will be introduced in this chapter.</p>
<p>This chapter gives a gentle overview of the concurrency features of F#, focusing on F# 4.0. We will also provide an overview of the best practices to implement and optimize it. Advanced topics of concurrency optimizations in F#, such as combining asynchrony and parallelism, the F# message passing agent,&#160;<code class="literal">MailboxProcessor</code>, and further interop with .NET TPL, will be described in <a class="link" title="Chapter&#160;5.&#160;Advanced Concurrency Support in F#" href="fsp-hiperf_cu05.html#aid-164MG2">Chapter 5</a>, <span class="emphasis"><em>Advanced Concurrency Support in F#</em></span>.</p>
<p>This chapter covers the following topics:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Introducing concurrency support in F# 4.0</li>
<li class="listitem">Identifying blocking threads</li>
<li class="listitem">Introducing asynchronous workflow</li>
</ul>
</div>
<div class="section" title="Introducing concurrency support in F# 4"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"></a>Introducing concurrency support in F# 4</h1>
</div>
</div>
</div>
<p>It is important to have concurrency support from the programming language perspective, especially as built-in language features. In F#, concurrency support in F# was available before F# 4.0. Two of the concurrency features: the asynchronous workflow and <code class="literal">MailboxProcessor</code> have been available since F# 1.9.</p>
<p>In a quick overview, F# has the following concurrency features:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Asynchronous workflow</li>
<li class="listitem">Asynchronous message passing using actor model and an F# special class that functions as an agent for message passing, <code class="literal">MailboxProcessor</code></li>
<li class="listitem">Parallel programming support for asynchronous workflow</li>
<li class="listitem">Interop with .NET Task Parallel Library (TPL)</li>
</ul>
</div>
<p>Asynchronous workflow is actually an implementation of a computation expression that is escalated as syntactic sugar. It is escalated within a block of asynchronous code that has calls to asynchronous functions, marked in the beginning with <code class="literal">async</code> as keyword.</p>
<p>From the perspective of conceptual concurrency, it is quite intuitive and easier to understand that F# has support for the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Asynchronous concurrency</strong></span>: in <code class="literal">async</code> and <code class="literal">MailboxProcessor</code></li>
<li class="listitem"><span class="strong"><strong>Parallel concurrency</strong></span>: parallel supports in asynchronous workflow and interop with .NET TPL</li>
</ul>
</div>
<p>Each of the supports is not a static solution for a single problem; for example, <code class="literal">MailboxProcessor</code> can be combined with parallel concurrency as well. It is also quite common to combine <code class="literal">MailboxProcessor</code> with async workflow, and then execute it in parallel as well.</p>
<p>There is no comparable built-in asynchronous message passing support in other languages such as C#/VB in the release of Visual Studio 2015. Even in .NET BCL, there is no message passing agent implementation at all. Some known message passing agents are available from outside .NET BCL, in the form of message passing combined with the actor model. Usually, they come in the form of a NuGet package available for download or in the form of a commercialized class library.</p>
<p>The discussion on the best practices and usage of <code class="literal">MailboxProcessor</code> will be discussed in <a class="link" title="Chapter&#160;5.&#160;Advanced Concurrency Support in F#" href="fsp-hiperf_cu05.html#aid-164MG2">Chapter 5</a>, <span class="emphasis"><em>Advanced Concurrency Support in F#</em></span>.</p>
<p>There is a known actor-based library of concurrency that comes from Microsoft Research; it is called Orleans. It is open source but it is unfortunately only optimized for cloud development and deployment especially in Azure. For more information about Orleans, visit:</p>
<p>
<a class="ulink" href="https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/">https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/</a>
</p>
<p>Fortunately, F# concurrency can be used and implemented in accordance with the other languages as well, as long as it's based on a common version of .NET CLR. We could also leverage the async-await model of C#/VB into the F# async workflow.</p>
<p>To use and to have interop with asynchronous methods in the .NET Framework that are designed for other asynchronous models with the F# asynchronous programming model, you create a function that returns an F# <code class="literal">async</code> object. The F# library has functions that make this easy to do.</p>
<p>On the implementation detail, F# concurrency support has the following building blocks:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Control.Async&lt;'T&gt;</strong></span>: This is a type in the <code class="literal">Microsoft.FSharp.Control</code> namespace to contain asynchronous operation.</li>
<li class="listitem"><span class="strong"><strong>The Control.Async</strong></span>: This is a class in the <code class="literal">Microsoft.FSharp.Control</code> namespace that contains all of the supports for asynchronous operations, support for .NET TPL, and for executing asynchronous workflow in parallel.</li>
<li class="listitem"><span class="strong"><strong>Control.AsyncBuilder</strong></span>: This is a builder class in <code class="literal">Microsoft.FSharp.Control</code>, to construct F# asynchronous workflow, including the implementation of <code class="literal">let!</code> and <code class="literal">use!</code> for containing the result of asynchronous operations.</li>
<li class="listitem"><span class="strong"><strong>F# asynchronous primitives</strong></span>: These are classes that may extend the existing .NET BCL with methods that implement F# asynchronous workflow, such as the <code class="literal">Control.WebExtension </code>and <code class="literal">Control.CommonExtension</code> modules. Both of them are in the <code class="literal">Microsoft.FSharp.Control</code> namespace.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>To further illustrate the relations, all of the asynchronous types, parallel types, and builders for asynchronous workflow are concentrated under the <code class="literal">Microsoft.FSharp.Control</code> namespace.</p>
<p>The hierarchical illustration is as shown in the following diagram:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00288.jpeg" alt="Introducing concurrency support in F# 4"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>F# asynchronous primitives are called <span class="strong"><strong>asynchronous primitives</strong></span> because they perform a single asynchronous task and return the result.</p>
<p>It is quite common that asynchronous workflow is often used to handle blocking threads. Whether we are aware of the existence of blocking threads or not, it is very important to know the traits or characteristics the blocking threads have and not just to understand the definitions of a blocking thread.</p>
</div>
</div>


<div class="section" title="Identifying blocking threads"><div class="titlepage" id="aid-12AK82"><div><div><h1 class="title"><a id="ch04lvl1sec28"></a>Identifying blocking threads</h1>
</div>
</div>
</div>
<p>A thread, from the perspective of interactions with other threads, is divided into two kinds: <span class="emphasis"><em>non-blocking thread</em></span> and <span class="emphasis"><em>blocking thread</em></span>. A non-blocking thread is usually a thread that does not block any other thread.</p>
<p>A blocking thread means a thread that does operations that often force the execution context to wait for other <span class="emphasis"><em>operations</em></span>. By nature, in this context of operations, there can be many kinds of operations and interactions with other kinds of subsystem components such as I/O and CPU thread counter such as the operation performed in <code class="literal">System.Threading.Thread.Sleep</code>.</p>
<div class="section" title="Overview of the background technical reasons for the blocking nature of I/O"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"></a>Overview of the background technical reasons for the blocking nature of I/O</h2>
</div>
</div>
</div>
<p>I/O is never separated from the implementation and usage of our application, especially applications that deal with networking and sending commands to an output device outside the scope of the subsystem, such as printers. It is often ignored, but it is becoming relevant that as a running application is expected to be as responsive as possible, the nature of any I/O operation cannot be ignored.</p>
<p>I/O operations have a tendency to force us to wait, although this wait should be treated as being placed in a different execution context rather than in the current thread. This is why the concept of having asynchronous operations is more relevant as the wait should not be synchronous.</p>
<p>Then why are I/O operations really <span class="emphasis"><em>blocking threads</em></span>?</p>
<p>Consider the following sample facts/scenarios:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">You send I/O commands to a printer (with the data) to print some data (usually, any kind of data formats supported by the underlying OS). There is no guarantee that the printer is always turned ON or that the printer is not busy. There can also be some forms of latency that we cannot control directly, such as network latency when transferring commands and data to be printed. Even when you are connecting your machine directly to the printer, there is no guarantee that the printer is always on and ready to process your commands. For example, your machine might have other running background processes that deal with other I/O, such as hard disks, especially when performing virus scans.</li>
<li class="listitem">You send HTTP requests on a host that you have tested with a ping before. There is no guarantee that at the time of sending the HTTP requests, the destination host is still available or that the host is even ready to process your requests and return responses. If the host is available and ready to process your requests, you cannot control exactly how quickly the destination host would reply with responses and how responsive it would be. Again, network latency also plays a huge role in dealing with roundtrips of HTTP request-response.</li>
<li class="listitem">A simple ping to any other host is also an I/O operation in action. Again, there is no guarantee that the destination host will respond to your ping (usually in ICMP packets).</li>
<li class="listitem">You are performing defragmentation on your local hard disk and expecting to do something else. Even with most of the Windows or other modern OSes such as Linux's distributions with latest kernel, there is no guarantee that you won't have to wait for the defragmentation to finish completely or that you can do other operations without interruptions from the defragmentation operations. Normally, you should not interrupt or even interfere with the current intentional I/O operations such as storage defragmentation. This is often misunderstood by a common computer user as bugs, although it is defragmentation that is obviously impacting storage as I/O. Therefore, it should not be considered as a bug in our code.</li>
</ul>
</div>
<p>Based on the preceding common facts, these I/O operations all have one thing in common: <span class="emphasis"><em>we have to wait</em></span>. It also clearly defines that I/O operation is one sample of a side-effect because we cannot control it fully and it is out of the scope of the current execution thread of our code.</p>
<p>The conclusion is obvious and quite clear: any I/O operation must be considered as a blocking thread.</p>
<p>These side effects should not be considered as bugs based on the nature of the operations running out of the scope boundary of the execution, but any errors, especially exceptions that might have occurred, must be handled. In other terms, these side effects must not be ignored and cannot be treated in a normal synchronous way because we have to wait for them to complete.</p>
<p>The best practices of exception handling (including the details when dealing with concurrency problems) will be discussed in detail in <a class="link" title="Chapter&#160;7.&#160;Language Features and Constructs Optimization" href="fsp-hiperf_cu07.html#aid-1ENBI1">Chapter 7</a>, <span class="emphasis"><em>Language Features and Constructs Optimization</em></span>.</p>
<p>It is easier to summarize blocking threads as part of operations that are also considered as blocking threads, such as I/O operations described previously.
</p>
</div>
<div class="section" title="Obvious trait of a blocking thread"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"></a>Obvious trait of a blocking thread</h2>
</div>
</div>
</div>
<p>In a simple definition, a&#160;blocking thread is part of any operation or function that <span class="emphasis"><em>waits for an event to occur or a time period to elapse</em></span>. While a blocking call is waiting, the operating system can often remove that thread from the scheduler, so it takes no CPU time until the event has occurred or the time has elapsed. Once the event has occurred, then the thread is placed back in the scheduler and can run when allocated a time slice.</p>
<p>It seems quite difficult to relate with I/O, but all I/O operations again always have a waitable behavior and can always be considered as blocking operations. This is not just a strong sample of a side effect. The operations that require us to wait are also available in other kinds of operations, especially if the operations are doing many things either in a definite amount of time or indefinite amount of time. We can parallelize this, but there is always a limited amount of computations available as opposed to the nature of most applications that usually do not care about this.</p>
<p>The context of waitable operations is the source of inspiration for the introduction of TPL in .NET 4.0, especially to define any task that is waitable as identified by the async-await pattern and the <code class="literal">TaskAwaiter</code> implementation. All of these waitable tasks can be used in asynchronous blocks.</p>
<div class="note" title="Note"><h3 class="title"><a id="note39"></a>Note</h3>
<p>It is also in sync with the C# 4 and VB 10 releases: the async models leverage these waitable patterns by enforcing all the tasks to be awaitable, wrapped in an awaiter of <code class="literal">TaskAwaiter</code>.</p>
</div>
<p>For example, you cannot always consider that your application will always run using the fastest CPU with many cores. Any assumption that your application will run successfully in many cores without paying attention to how you treat the concurrent running of your application can slow down your application performance.</p>
<p>Any successful enterprise application must be able to scale itself in a sense that it must consider that the number of users of the application can grow and that the operations they will engage when they use the applications can be arbitrarily complex. Therefore, paying attention to how the code will run across many CPU cores and also paying attention to the responsiveness of the application, especially paying attention to any blocking operations, are requirements, not just recommendations.</p>
<p>It also brings a more interesting fact that it is easier to get used to identifying blocking threads by identifying blocking operations first. Identifying blocking threads first is also a good practice to have a best practice mindset because we often misunderstand blocking threads as non-blocking threads due to common assumptions that applications usually running in modern CPUs are always fast by default.</p>
<p>The context of <span class="emphasis"><em>does not block any other thread</em></span> is often misunderstood. A thread can block other threads even if it was considered a non-blocking thread. For example, a very intensive computation that requires CPU-intensive operations, such as complex number-related calculations that are targeted for a specific CPU core, can block other threads that want to use any available core if the other core might be busy processing other calculations or processes.</p>
<p>Consider this sample illustrated scenario running on the 4th generation of Intel core i5 that has two physical cores:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00289.jpeg" alt="Obvious trait of a blocking thread"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The details of the scenario are as follows:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The running code runs on a machine that has the 4<sup>th</sup> generation of Intel core i5 processor. This processor has two physical cores and each core has two hyper-threading units.</li>
<li class="listitem">The running code (it acts as a process under the runtime context) asks to run on the 1<sup>st</sup> core explicitly, so it assumes that the remaining core (in this case, only one core) should be available for others.</li>
<li class="listitem">Then the other process suddenly runs in the background, and it needs a high thread affinity, for example, processes by antivirus software. Most antivirus software always try to ask for a higher thread affinity when they are scheduled to run a full scan at a scheduled time. Another sample is when a Windows update is performing a background installation update after it has finished downloading all of the updates available at the time the code runs.</li>
<li class="listitem">All of these other processes, therefore, are cramped into only one core, and they can interfere with each other so that one process may take over the entire CPU core cycle.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>Based on this scenario, a blocking thread can be caused by non I/O operations as well.</p>
<p>It is quite important to know or to keep up with the latest of x86/x64 processors as we should never assume that our code runs automatically in parallel, although we must not rely on the number of actual physical cores. It is also closely related to paying more attention to concurrency because the trends for the last 6 years have been leaning toward having more cores instead of having a higher speed of CPU clock. The intention here is clear: <span class="emphasis"><em>the awareness that concurrency is increasingly more relevant as the age of multicores outweigh the free increase of higher-speed CPUs</em></span>.</p>
<p>It is also a strong evidence that <span class="emphasis"><em>free lunch is over</em></span>, stated by Herb Sutter (we first mentioned this article in <a class="link" title="Chapter&#160;1.&#160;Performing Common Optimizations in F#" href="fsp-hiperf_cu01.html#aid-E9OE2">Chapter 1</a>, <span class="emphasis"><em>Performing Common Optimizations in F#</em></span>), is correct.</p>
<p>Therefore, this book is not going to describe the full characteristic details of Intel or AMD processors because it is outside the scope of this F# book.</p>
<p>For more information on the full specifications of Intel processors, please consult <a class="ulink" href="http://ark.intel.com/">http://ark.intel.com/</a>.</p>
<p>For more information on the specifications of AMD, please consult <a class="ulink" href="http://www.amd.com/en-us/products/processors/desktop">http://www.amd.com/en-us/products/processors/desktop</a>.</p>
<div class="note" title="Note"><h3 class="title"><a id="note40"></a>Note</h3>
<p>There are other processors supported by .NET, but most processors today are dominated by Intel and AMD. A sample of this is ARM, powering some WinRT machines for Windows 8 and Windows 8.1 tablets and Microsoft's own tablet, Surface. The ARM architecture is different from that of Intel and AMD, although it has multiple cores as well, and the market share for these processor-based devices is also very small. It can be safely assumed that since the introduction of Visual Studio 2015, the target processor architecture is for x86 and x64 only, unless you are targeting other kind of devices, such as mobile phones.</p>
</div>
<p>Now that we have a basic knowledge of what a blocking thread is, the next challenge is whether we have to wait and not do anything else or whether <span class="emphasis"><em>we can do other things while waiting</em></span>. Doing other things while waiting is actually an implementation of the asynchronous way. It is conceptually the same as the restaurant waiting problem we had visited in <a class="link" title="Chapter&#160;1.&#160;Performing Common Optimizations in F#" href="fsp-hiperf_cu01.html#aid-E9OE2">Chapter 1</a>, <span class="emphasis"><em>Performing Common Optimizations in F#</em></span>.</p>
<p>F# provides support for implementing asynchronous operations using asynchronous workflow without any complexity of having callback implementation.</p>
</div>
</div>


<div class="section" title="Introducing asynchronous workflow"><div class="titlepage" id="aid-1394Q2"><div><div><h1 class="title"><a id="ch04lvl1sec29"></a>Introducing asynchronous workflow</h1>
</div>
</div>
</div>
<p>Asynchronous support in F# is implemented nicely using async workflow computations.</p>
<p>The initial release of F# 1.0 did not have it. Asynchronous workflow was introduced in F# 1.9.2.9, and it is categorized as a workflow because it is actually an implementation of a computation expression (builder) that is escalated as a language block of <code class="literal">async</code>. It is also a good sample of a best practice in implementing function compositions and in expressively implementing <span class="strong"><strong>Monad</strong></span>. Monad is one of the functional composition implementations, an idea taken from or inspired by the category theory knowledge domain.</p>
<p>Function composition is actually a composition of computation operations; they can be functions or composite statements such as for loop constructs. It is also quite intuitive, and it's also easier to use as the necessary detailed composition operations are hidden. Usually, there is a <code class="literal">bind</code> operator to compose two functions (or computations).</p>
<p>The foundational theory of this is quite common, back to the world of set theory. Set theory is further extended in Category theory where composition is more emphasized between functions. For example, consider the following:</p>
<p>
<span class="emphasis"><em>f =&gt; f(x)</em></span>
</p>
<p>
<span class="emphasis"><em>g =&gt; g(x)</em></span>
</p>
<p>
<span class="emphasis"><em>f o g = f(g(x))</em></span>
</p>
<p>Here, the <span class="emphasis"><em>f o g</em></span> is read as <span class="emphasis"><em>f circle g</em></span> where <span class="emphasis"><em>circle</em></span> is the composition between the functions <span class="emphasis"><em>f</em></span> and <span class="emphasis"><em>g</em></span>.</p>
<div class="note" title="Note"><h3 class="title"><a id="note41"></a>Note</h3>
<p>Usually the composition in a Monad is expressed by the <code class="literal">bind</code> operator, symbolized as <span class="emphasis"><em>&gt;&gt;=</em></span> in many other functional programming languages such as Haskell. This composition of a function also implies that the return type of <span class="emphasis"><em>g</em></span> must be the same as the type of the parameter of <span class="emphasis"><em>f</em></span>. From the perspective of real-world functional programming, type safety is always enforced even though the type is not mentioned. Everything will always be inferred based on the type inference of the function's return type and the result of the currying functions.</p>
</div>
<p>The built-in workflows in F# are not just limited to the asynchronous workflow; there are Sequence and LINQ query workflows as well.</p>
<p>In asynchronous workflow, there is a <code class="literal">bind</code> builder (it is conceptually similar to bind in Monad) implemented to compose operations, but the implementation is hidden by the syntax of the <code class="literal">let!</code> keyword.</p>
<p>The implementation and optimization of a builder in F# to compose a workflow will be further discussed in <a class="link" title="Chapter&#160;7.&#160;Language Features and Constructs Optimization" href="fsp-hiperf_cu07.html#aid-1ENBI1">Chapter 7</a>, <span class="emphasis"><em>Language Features and Constructs Optimization</em></span>.</p>
<p>The implementation of F# computation expressions is also called a workflow because it usually defines the compositions of functions as the results of binding (<code class="literal">bind</code>) operations and control flows.</p>
<p>The goals of F# asynchronous workflow are as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Increase responsiveness by not blocking the running thread and get the other process done first.</li>
<li class="listitem">Ease programming in asynchronous concurrency without worrying about callback and explicit continuations.</li>
<li class="listitem">Intuitively, the code flows more naturally because the flow is not looking like going back and forth between a function that contains an asynchronous call and callback since callback is not called explicitly in the code.</li>
<li class="listitem">Compositional nature of asynchronous workflow means that it can be composed with other concurrencies such as parallelization.</li>
<li class="listitem">The asynchronous block implies that some basic I/O operations on the web usually have their own <span class="emphasis"><em>begin</em></span> and <span class="emphasis"><em>end</em></span> web operations. It is further supported and wrapped into F# Async primitives to ease interoperability with asynchronous models such as .NET Asynchronous Programming Model.</li>
<li class="listitem">The asynchronous block also provides exception handling in a compositional way and also in a safe manner without losing too much referential transparency.</li>
</ul>
</div>
<p>Asynchronous workflow is nicely wrapped in the following common syntax:</p>
<pre class="programlisting">async { &lt;expression&gt;... } 
</pre>
<p>The term <code class="literal">expression</code> is not only a single line of expression but can also be a compound expression. This means it can contain more than one statement as well.</p>
<div class="section" title="Getting to know asynchronous workflow"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"></a>Getting to know asynchronous workflow</h2>
</div>
</div>
</div>
<p>We can start looking at the first sample of <code class="literal">async</code> from MSDN Library. I have added the necessary detail on handling specific exceptions that may occur when we are dealing with HTTP request/response operations.</p>
<p>This is the code:</p>
<pre class="programlisting">open System 
open System.Net 
open System.IO 
open Microsoft.FSharp.Control.WebExtensions 
 
let urlList = [ "Microsoft.com", "http://www.microsoft.com/"  
                "MSDN", "http://msdn.microsoft.com/"  
                "Bing", "http://www.bing.com" 
              ] 
 
let fetchAsync(name, url:string) = 
    async {  
        try  
            let uri = new System.Uri(url) 
            let webClient = new WebClient() 
            let! html = webClient.AsyncDownloadString(uri) 
            printfn "Read %d characters for %s" html.Length name 
        with 
            | :? IOException as ex -&gt; printfn "IO Exception: %s" (ex.Message); 
            | :? System.Net.HttpListenerException as httplistenerexn -&gt; printfn "IO Exception: %s" (httplistenerexn.Message); 
            | genex -&gt; printfn "General Exception: %s" (genex.Message); 
    } 
 
let runAll() = 
    urlList 
    |&gt; Seq.map fetchAsync 
    |&gt; Async.Parallel  
    |&gt; Async.RunSynchronously 
    |&gt; ignore 
 
runAll() 
</pre>
<p>Let's visit the details of this sample.</p>
<p>The intention of this sample code is to download the content of a web page from a collection of URLs asynchronously while also executing the download of the web page of all URLs in parallel.</p>
<p>The <code class="literal">urlList</code> variable contains all URLs as a collection. F# will infer this collection as a list of tuple of <span class="emphasis"><em>string * string</em></span>. Then, this list is passed as a parameter to the <code class="literal">fetchAsync</code> function, which is then continued to be passed to the next sequence in the pipeline of the <code class="literal">|&gt;</code> pipeline operator. The <code class="literal">fetchAsync</code> function returns an <code class="literal">async</code> block, implying that it returns an <code class="literal">async</code> function.</p>
<p>In a simplified flow, the entire chain of function compositions is composed nicely using the pipelines of <code class="literal">|&gt;</code> within the&#160;<code class="literal">runAll</code> function as follows:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">urlList</code> is passed to the <code class="literal">Seq.map</code> function.</li>
<li class="listitem">The <code class="literal">Seq.map</code> function still needs one more parameter: the <code class="literal">map</code> function. The <code class="literal">map</code> function takes <code class="literal">fetchAsync</code> as a parameter. The result of <code class="literal">map</code> returns a sequence of functions.</li>
<li class="listitem">The sequence of functions is executed in parallel by <code class="literal">Async.Parallel</code>, which then returns an array of <code class="literal">async</code> functions. The executions are not yet run.</li>
<li class="listitem">The <code class="literal">async</code> block includes exception handlings. The difference from the code in MSDN Library is the way the handling of the exceptions. In our sample code, exception handling is&#160;more specific than the original code in MSDN Library. This specific exception handling model is very important, because the exception occurred might have resulted as different types of exceptions caused by any errors in HTTP request/response operations and the specific exception should be handled differently.</li>
<li class="listitem">The array of functions is then executed immediately by <code class="literal">Async.RunSynchronously</code>.</li>
<li class="listitem">The ignore construct ignores the returning result. It will be inferred further as a unit.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>Execute the code in F# scripting/interactive; then, within the interactive window, we will see the types inferred for <code class="literal">urlList</code>, <code class="literal">fetchAsync</code>, and <code class="literal">runAll</code> functions as follows:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00290.jpeg" alt="Getting to know asynchronous workflow"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The declaration of let for asynchronous workflow can be written in two ways, using <code class="literal">let</code> and <code class="literal">let!</code> (pronounced <span class="emphasis"><em>let bang</em></span>).</p>
<p>The sample uses <code class="literal">let!</code>; it means that the computation is focusing on returning a result. It means that the intention of the <code class="literal">async</code> operation is to execute the <code class="literal">download</code> function, <code class="literal">webClient.AsyncDownloadString(uri)</code>, and return the result, not the operation. Then, the thread on the <code class="literal">fetchAsync</code> scope is suspended. In other words, it is blocked because it waits for an event to be raised to notify that the process being waited for is completed. The outer thread (outside the <code class="literal">fetchAsync</code>) is not blocked.</p>
<p>All the code after the line of <code class="literal">webClient.AsyncDownloadString(uri)</code> is executed later, after the download is finished. However, the execution will not have to wait for the download to be completed; instead it will go outside the <code class="literal">async</code> block and execute the code after <code class="literal">fetchAsync</code> is called. In this sample, it will execute the code after the call to <code class="literal">fetchAsync</code>.</p>
<p>After the download is completed, the execution context returns to the code within the <code class="literal">async</code> block; it will point to the execution point of code after the call to <code class="literal">webClient.AsyncDownloadString(uri)</code>. The code at this point will be executed.</p>
<p>Because there is <code class="literal">Async.Parallel</code>, which executes all of the <code class="literal">fetchAsync</code> in parallel, the execution looks sequential, although the execution of the&#160;<code class="literal">AsyncDownloadString</code> calls is parallel.</p>
<p>In the sample, the execution is triggered by the call to the <code class="literal">Async.RunSynchronously</code> function.</p>
<p>The <code class="literal">let</code> means that the execution is not performed immediately; it is stored in a variable to be executed later. It does not return the result immediately.</p>
<p>Consider the following sample of <code class="literal">let</code> and <code class="literal">let!</code>:</p>
<pre class="programlisting">// let just stores the result as an asynchronous operation. 
let (result1 : Async&lt;byte[]&gt;) = stream.AsyncRead(bufferSize) 
// let! completes the asynchronous operation and returns the data. 
let! (result2 : byte[])  = stream.AsyncRead(bufferSize) 
</pre>
<p>
<code class="literal">let!</code> is conceptually equal to await in C# and VB as it awaits the actual result of <code class="literal">Task&lt;T&gt;</code>. It is still semantically different in its implementation.</p>
</div>
<div class="section" title="Using asynchronous with Dispose pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"></a>Using asynchronous with Dispose pattern</h2>
</div>
</div>
</div>
<p>There is another equivalent declaration to define the result of an asynchronous workflow using the&#160;<code class="literal">use!</code> keyword as compared to <code class="literal">let!</code>. The difference between <code class="literal">let!</code> and <code class="literal">use</code>/<code class="literal">use!</code> is in the usage: <code class="literal">use!</code> is used to handle asynchronous calls that will later dispose the object.</p>
<p>The <code class="literal">use!</code> keyword is the asynchronous counterpart of F#'s synchronous <code class="literal">use</code> and <code class="literal">using</code> keywords. In C#/VB, the concept of disposable is equal to the <code class="literal">using</code> keyword in C# and the <code class="literal">Using</code> keyword in VB, except that there is no comparable using model for disposable to be used in an asynchronous way.</p>
<p>The capture of a pattern, which is going to be disposed when not in use anymore before going out of scope, is called the Dispose pattern. It is also a sample of a coding design pattern. In today's programming language terms, the Dispose pattern is often escalated to have syntactic sugar, which is then translated as <code class="literal">try...finally</code> or (something else with similar semantics). Many programming languages have leveraged this Disposable pattern, not just C#, VB, and F#. It is also used in C++, Java, and other modern programming languages.</p>
<p>The following are the requirements for wrapping an object or type for usage in <code class="literal">use</code>/<code class="literal">use!</code>:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The result object must implement the&#160;<code class="literal">IDisposable</code> interface; therefore it must explicitly implement the <code class="literal">Dispose</code> method. However, in the real semantic of the Disposable pattern, it only looks for the implementation of the <code class="literal">Dispose()</code> method that has a <code class="literal">void Dispose()</code> signature.</li>
<li class="listitem">An unmanaged resource is highly recommended to implement <code class="literal">IDisposable</code>. The main reason for why it must explicitly implement the <code class="literal">Dispose</code> method is because the object with an explicit <code class="literal">Dispose</code> method is usually an unmanaged resource wrapped as a CLR object, such as <code class="literal">File</code>, network <code class="literal">Socket</code>, and database connection object.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>A managed object, if it is guaranteed to have no side effects, is also welcome to implement <code class="literal">IDisposable</code>.</p>
<p>The advantages of implementing the <code class="literal">IDisposable</code> interface and, at the same time, implementing our own <code class="literal">Dispose</code> method is that it minimizes the garbage collection overhead because implementing the <code class="literal">Dispose</code> method means that we decide the lifetime of the object before disposed.</p>
<p>Basically, the&#160;<code class="literal">use</code> and <code class="literal">use!</code> constructs in F# involve wrapping the <code class="literal">try...finally</code> pattern in the generated IL.</p>
<p>For example, consider the following scenario:</p>
<p>We are going to implement code that has usage of <code class="literal">use!</code>.</p>
<p>In the following sample, we are going to use the&#160;<code class="literal">SqlDataReader</code> class because it implements the&#160;<code class="literal">IDisposable</code> interface. This instance of <code class="literal">SqlDataReader</code>, the <code class="literal">dataReader</code> object, will be disposed after the execution of the asynchronous call is completed.</p>
<p>Here is the sample code:</p>
<pre class="programlisting">open System.Data 
open System.Data.SqlClient 
 
let UseBangSample (dbconstring: string) = 
    async { 
        use dbCon = new SqlConnection(dbconstring) 
        use sqlCommand = new SqlCommand("SELECT * FROM INFORMATION_SCHEMA.TABLES") 
        use! dataReader = Async.AwaitTask(sqlCommand.ExecuteReaderAsync(CommandBehavior.Default)) 
        printfn "Finished querying" 
    } 
</pre>
<p>Let's dive deeper into the previous sample code.</p>
<p>The code will only refer to <code class="literal">System.Data</code> and <code class="literal">System.Data.SqlClient</code>. Any references to <code class="literal">System</code>, <code class="literal">System.Data</code>, and <code class="literal">System.Data.Common</code> do not need the external reference to the library outside of BCL. Some of the classes (especially .NET primitive types) used in the code have namespace prefix of <code class="literal">System</code> are available at <code class="literal">mscorlib.dll</code> and <code class="literal">System.dll</code>. The F# compiler will automatically know the location of <code class="literal">mscorelib.dll</code> and <code class="literal">System.dll</code>. For SQL server-related database connections, we have to add reference to <code class="literal">System.Data.SqlCient.dll</code> in our project. This is the same for another library such as <code class="literal">System.Web.dll</code>. If you want to use other libraries such as <code class="literal">System.Web.dll</code>, you have to add a reference to it.</p>
<p>For normal F# code, you can add reference by adding library references to the project reference.</p>
<p>For F# scripting, you have to inform the compiler about the location of the DLL that you want to use by registering it manually before using it. It is recommended that you register it before any open statement so as to ensure that you have registered the necessary DLL at the first section of the script. The registration is done by using the compiler directive of <code class="literal">#r</code>.</p>
<p>For more information about the <code class="literal">#r</code> compiler directive of F#, please visit the MSDN Library at <a class="ulink" href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-directives-%5bfsharp%5d">https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-directives-%5bfsharp%5d</a>.</p>
<p>The <code class="literal">use!</code> keyword (called <span class="emphasis"><em>use bang</em></span>) will treat the <code class="literal">WebResponse</code> result from <code class="literal">req.AsyncGetResponse</code>.</p>
<p>We can examine the compiler result of the code sample by copying and pasting the code into any <code class="literal">.fs</code> code, or we can simply put the source code into the F# console project of a default file containing the main <code class="literal">EntryPoint</code>, <code class="literal">Program.fs</code>.</p>
<p>Compile it and open the executable file of the EXE using ILDASM. We will roughly see the following layout in the disassembled view:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00291.jpeg" alt="Using asynchronous with Dispose pattern"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Let's dive into the IL of the <code class="literal">async</code> block, starting from the <code class="literal">UseBangSample</code> method:</p>
<pre class="programlisting">.method public static class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1&lt;class [FSharp.Core]Microsoft.FSharp.Core.Unit&gt; 
        UseBangSample(string dbconstring) cil managed 
{ 
  // Code size       21 (0x15) 
  .maxstack  5 
  .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@) 
  IL_0000:  nop 
  IL_0001:  call       class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder [FSharp.Core]Microsoft.FSharp.Core.ExtraTopLevelOperators::get_DefaultAsyncBuilder() 
IL_0006:  stloc.0 
  IL_0007:  ldloc.0 
  IL_0008:  ldarg.0 
IL_0009:  ldloc.0 
IL_000a:  newobj     instance void Program/UseBangSample@10::.ctor(string, 
                                                                     class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder) 
  IL_000f:  callvirt   instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1&lt;!!0&gt; [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Delay&lt;class [FSharp.Core]Microsoft.FSharp.Core.Unit&gt;(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2&lt;class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1&lt;!!0&gt;&gt;) 
IL_0014:  ret 
} // end of method Program::UseBangSample 
</pre>
<p>The method calls <code class="literal">UseBangSample@10</code> by instantiating it, and then it calls the <code class="literal">Invoke</code> method. It is quite common in the generated IL as the class is treated as an executable operation like a delegate.</p>
<div class="note" title="Note"><h3 class="title"><a id="note42"></a>Note</h3>
<p>Ignore the cryptic names of the generated type and method of the IL. If you compile the code on your own, the resulting type and method might have different names. The source code and the related IL from ILDASM for this chapter is already set up and available for us to examine the IL assembly code with the related F# code.</p>
</div>
<p>The common flow is actually the execution of the <code class="literal">Invoke</code> method. In this context, the <code class="literal">Invoke</code> method of <code class="literal">UseBangSample@10</code> will be executed.</p>
<p>Let's dive into the IL of <code class="literal">UseBangSample@10.Invoke</code>:</p>
<pre class="programlisting">.method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1&lt;class [FSharp.Core]Microsoft.FSharp.Core.Unit&gt; 
        Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar) cil managed 
{ 
  // Code size       35 (0x23) 
  .maxstack  8 
  IL_0000:  nop 
IL_0001:  ldarg.0 
  IL_0002:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Program/UseBangSample@10::builder@ 
IL_0007:  ldarg.0 
  IL_0008:  ldfld      string Program/UseBangSample@10::dbconstring 
IL_000d:  newobj     instance void [System.Data]System.Data.SqlClient.SqlConnection::.ctor(string) 
  IL_0012:  ldarg.0 
  IL_0013:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Program/UseBangSample@10::builder@ 
  IL_0018:  newobj     instance void Program/'UseBangSample@11-1'::.ctor(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder) 
  IL_001d:  callvirt   instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1&lt;!!1&gt; [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Using&lt;class [System.Data]System.Data.SqlClient.SqlConnection,class [FSharp.Core]Microsoft.FSharp.Core.Unit&gt;(!!0, 
                                                                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2&lt;!!0,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1&lt;!!1&gt;&gt;) 
  IL_0022:  ret 
} // end of method UseBangSample@10::Invoke 
</pre>
<p>The line <code class="literal">IL_001d</code> explains the correlation between the IL and the corresponding code, the <code class="literal">use!</code> declaration. This <code class="literal">use!</code> will actually call the <code class="literal">FSharpAsyncBuilder.Using</code> builder to do the actual dispose pattern by instantiating <code class="literal">FSharp.AsyncBuilder</code> first.</p>
<p>All of these complex details are nicely hidden in the implementation detail of builders, in the implementations of the following three related Async types:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">Control.Async</code> for the <code class="literal">Async.*</code> methods</li>
<li class="listitem"><code class="literal">Control.AsyncBuilder</code> for the builder implementation of asynchronous workflow</li>
<li class="listitem"><code class="literal">Control.Async&lt;'T&gt;</code> type to contain the implementation result of asynchronous workflow</li>
</ul>
</div>
<p>Again, never mind the cryptic name of the generated code. As long as the name alias of the method and the classes is correct, we can simply deduce the use of <code class="literal">AsyncBuilder.Using</code> to handle the <code class="literal">use!</code> declaration in order to implement the Disposable pattern.</p>
<p>F# also comes with built-in asynchronous support for HTTP requests. This additional asynchronous operation is available in the&#160;<code class="literal">WebRequest</code> type, and it has been available under the <code class="literal">Microsoft.FSharp.Control.WebExtensions</code> namespace since F# 3.0. In F# version 2.0, it is available under the <code class="literal">Microsoft.FSharp.Control.CommonExtensions</code> namespace.</p>
<p>There has been a namespace reorganization in F# 3.0 and above as it is more aligned to the purpose or intent of the types and operations inside the namespace. For example, <code class="literal">WebRequest</code> related operations, now inside <code class="literal">Microsoft.FSharp.Control.WebExtensions</code>, were previously available under <code class="literal">Microsoft.FSharp.Control.CommonExtensions</code>.</p>
<div class="note" title="Note"><h3 class="title"><a id="note43"></a>Note</h3>
<p>The main reason for this reorganization is the stabilization and standardization of intents because F#, since F# 2.0 in Visual Studio 2010, is not just a research product anymore, it is becoming a commercial product or being productized. Again, the reorganization is also a working result of responding to developer feedbacks.</p>
</div>
<p>Always consult MSDN Library documentation for F# 4 and above. It is highly recommended to focus on F# 4 and the later versions. Further namespace changes are very unlikely in the next version, unless the feedback from the F# community is crucial and is agreed upon by the F# developer and designer team at Microsoft.</p>
<p>For more information on the starting guide to F# asynchronous workflow as computation expressions, please consult MSDN Library:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/asynchronous-workflows-%5bfsharp%5d">https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/asynchronous-workflows-%5bfsharp%5d</a>
</p>
<p>The details of computation expressions themselves and optimizing computation expressions will be discussed in <a class="link" title="Chapter&#160;7.&#160;Language Features and Constructs Optimization" href="fsp-hiperf_cu07.html#aid-1ENBI1">Chapter 7</a>,&#160;<span class="emphasis"><em>Language Features and Constructs Optimization</em></span>.</p>
</div>
<div class="section" title="Operations in asynchronous workflow"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"></a>Operations in asynchronous workflow</h2>
</div>
</div>
</div>
<p>The first sample in this chapter shows <code class="literal">Async.Parallel</code> and <code class="literal">Async.RunSynchronously</code> in action. These two belong to the F# <code class="literal">Control.Async</code> class with other functions as well.</p>
<p>The <code class="literal">Control.Async</code> class is available in the <code class="literal">Microsoft.FSharp.Control</code> namespace as we have witnessed by disassembling the code demonstrated in the&#160;<span class="emphasis"><em>Using asynchronous with Dispose pattern</em></span> section covered earlier. <code class="literal">Control.Async</code> cannot function alone when used in an asynchronous workflow block; it depends on the builders in the <code class="literal">Control.AsyncBuilder</code> type.</p>
<p>A complete starting point of reference for <code class="literal">Control.Async</code> as a type is available at <a class="ulink" href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async%5b't%5d-type-%5bfsharp%5d">https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async%5b't%5d-type-%5bfsharp%5d</a>.</p>
<p>All operations of the async workflow in F# are available at <a class="ulink" href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d">https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d</a>.</p>
<p>The following is a table of interesting operations (commonly used) in F# <code class="literal">async</code>:</p>
<div class="informaltable"><table border="1"><colgroup><col/>
<col/>
</colgroup>
<tbody><tr><td>
<p>
<span class="strong"><strong>Function</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>Quick Remark</strong></span>
</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">AsBeginEnd</code>
</p>
</td>
<td>
<p>Creates three functions that can be used to implement the .NET Framework <span class="strong"><strong>Asynchronous Programming Model</strong></span> (<span class="strong"><strong>APM</strong></span>) for the supplied asynchronous computation.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">AwaitEvent</code>
</p>
</td>
<td>
<p>
</p>
<p>Creates an asynchronous computation that waits for a single invocation of a CLI event by adding a handler to the event. Once the computation completes or is cancelled, the handler is removed from the event.</p>
<p>
</p>
<p>
<code class="literal">AwaitEvent</code> is the best fit to handle .NET EAP model.</p>
<p>
</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">AwaitIAsyncResult</code>
</p>
</td>
<td>
<p>Creates an asynchronous computation that will wait on the <code class="literal">IAsyncResult</code>. It is used for the .NET APM model.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">AwaitTask</code>
</p>
</td>
<td>
<p>Returns an asynchronous computation that waits for the given task (.NET TPL <code class="literal">Task</code>) to complete and returns its result.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">CancellationToken</code>
</p>
</td>
<td>
<p>Creates an asynchronous computation that returns the <code class="literal">System.Threading.CancellationToken</code> that manages the execution of the computation.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">DefaultCancellationToken</code>
</p>
</td>
<td>
<p>Gets the default cancellation token to run asynchronous computations.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">FromBeginEnd</code>
</p>
</td>
<td>
<p>Creates an asynchronous computation in terms of a Begin/End pair of actions in the style used in CLI APIs.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">FromContinuations</code>
</p>
</td>
<td>
<p>
</p>
<p>Creates an asynchronous computation that includes the current success, exception, and cancellation continuations. The callback function must eventually call exactly one of the given continuations.</p>
<p>
</p>
<p>This exact map of one cancellation for one continuation is also the same concept as .NET APM.</p>
<p>
</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">Ignore</code>
</p>
</td>
<td>
<p>Creates an asynchronous computation that runs the given computation and ignores its result.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">Parallel</code>
</p>
</td>
<td>
<p>Creates an asynchronous computation that executes all the given asynchronous computations, initially queueing each as work items and using a fork/join pattern.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">RunSynchronously</code>
</p>
</td>
<td>
<p>
</p>
<p>Runs the provided asynchronous computation and awaits its result.</p>
<p>
</p>
<p>When <code class="literal">RunSynchronously</code> is used to run an&#160;<code class="literal">async</code> block, it will run the code in the&#160;<code class="literal">async</code> block immediately in a separate runtime context as long as the code in the <code class="literal">async</code> block follows the pattern as defined in asynchronous workflow.</p>
<p>
</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">Sleep</code>
</p>
</td>
<td>
<p>Creates an asynchronous computation that will sleep for the given time. This is scheduled using a <code class="literal">System.Threading.Timer</code> object. The operation will not block operating system threads for the waiting duration.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">Start</code>
</p>
</td>
<td>
<p>Starts the asynchronous computation in the thread pool but does not await its result.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">StartAsTask</code>
</p>
</td>
<td>
<p>Executes a computation in the thread pool. Returns a <code class="literal">Task</code> that will be completed in the corresponding state once the computation terminates (produces the result, throws an exception, or gets canceled). If no cancellation token is provided, then the default cancellation token is used.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">StartChild</code>
</p>
</td>
<td>
<p>Starts a child computation within an asynchronous workflow. This allows multiple asynchronous computations to be executed simultaneously (in parallel). The child computation can be composed to start in parallel with other child computations using <code class="literal">Async.Parallel</code>.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">StartChildAsTask</code>
</p>
</td>
<td>
<p>Creates an asynchronous computation that starts the given computation as a <code class="literal">Task</code>.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">StartImmediately</code>
</p>
</td>
<td>
<p>Runs an asynchronous computation, starting immediately on the current operating system thread. The main difference between <code class="literal">Start</code> and <code class="literal">StartImmediately</code> is quite subtle but important: <code class="literal">StartImmediately</code> uses <code class="literal">ThreadPool</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>The operations in <code class="literal">ControlAsync</code> are not all targeted at working&#160;with .NET TPL. From the perspective of the available asynchronous model in .NET, the operations of <code class="literal">Control.Async</code> provide supports for the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">.NET Asynchronous Programming Model (APM)</li>
<li class="listitem">.NET Event-based Asynchronous Pattern (EAP)</li>
<li class="listitem">.NET Task Parallel Library (TPL), only available for .NET 4 with added asynchrony operations or programming support in .NET 4.5 and later. The Task asynchrony is called Task-based Asynchrony Pattern or TAP.</li>
</ul>
</div>
<p>Let's dive into the supports.</p>
<p>It is worth assessing that .NET TPL (including TAP) is considered to be a modern concurrency model. The legacy .NET asynchronous models are as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Asynchronous Programming Model, often abbreviated as APM</li>
<li class="listitem">Event-based Asynchronous Programming pattern (EAP)</li>
</ul>
</div>
<p>You might wonder why they are called <span class="strong"><strong>legacy models</strong></span>. They are legacy models in the sense that they are not supposed to be used anymore. Since .NET 4.0, the preferred model to be used is the .NET Task Parallel Library (TPL) model.</p>
<p>Using .NET TPL is recommended, not just because it is easier to use and more intuitive but also because every operation is wrapped as <code class="literal">Task</code> or <code class="literal">Task&lt;T&gt;</code> and it is easier to reason about your code. In F#, APM and EAP are usually handled using asynchronous-related operation methods but it is quite difficult to do in a real APM or EAP way.</p>
<p>It is recommended that APM and EAP should not be used anymore although they are still available in .NET 4.6. EAP is harder to implement than APM because it focuses on event handling, which&#160;usually happens on any action or operation that has event handling; otherwise, we have to handle the completed event on our own by implementing custom completed action's event handler.</p>
</div>
<div class="section" title="Creating child asynchronous workflow"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"></a>Creating child asynchronous workflow</h2>
</div>
</div>
</div>
<p>In F#, it is possible to create a nested asynchronous operation within an <code class="literal">async</code> block as the child or children of the current asynchronous workflow.</p>
<p>These children asynchronous workflows are executed in a sequence at first (based on the sequence of creation) but they do not have to finish simultaneously. They can run or start in parallel.</p>
<p>There are two operations to create a child asynchronous workflow: <code class="literal">Async.StartChild</code> and <code class="literal">Async.StartChildAsTask</code>. The <code class="literal">Async.StartChildAsTask</code> will return the resulting asynchronous workflow as <code class="literal">Task&lt;T&gt;</code> based asynchrony of Task-based Asynchronous Pattern or TAP.</p>
<p>This method is generally used with <code class="literal">let!</code> because it is supposed to return the result of a child asynchronous process, and this is why it is supposed to be bound to a process that returns a result, which is then to be observed or used by the parent asynchronous block.</p>
<p>The returning result of <code class="literal">Async.StartChild</code> is usually called <span class="strong"><strong>completor</strong></span> because it is typed as a computation that has to wait for completion. This is also described by the MSDN Library as follows:</p>
<div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>"When used in this way, each use of StartChild starts an instance of childComputation and returns a completor object representing a computation to wait for the completion of the operation. When executed, the completor awaits the completion of childComputation."</em></span>
</p>
</blockquote>
</div>
<p>Putting it simply, the completor is an object to contain the operation of the asynchronous process and wait for it to be completed. This is why the returning value of <code class="literal">Async.StartChild</code> is typed as <code class="literal">Async&lt;Async&lt;'T&gt;&gt;</code> instead of just <code class="literal">Async&lt;'T&gt;</code>.
</p>
<div class="note" title="Note"><h3 class="title"><a id="note44"></a>Note</h3>
<p>WARNING: The use of <code class="literal">use!</code> is not allowed to capture an asynchronous child; it will yield an unpredictable result. Future releases of F# will not allow this to be used. It is required to use <code class="literal">let!</code> instead. The main reason is that the nature of the asynchronous child is not for disposable objects as it is focused on the process, not on the object that is part of the result to be awaited, although the process contains an asynchronous function that may have a result as denoted by the <code class="literal">Async&lt;Async&lt;'T&gt;&gt;</code> type.</p>
</div>
<p>The following is a simple example from MSDN Library:</p>
<pre class="programlisting">open System.Windows.Forms 
 
let bufferData = Array.zeroCreate&lt;byte&gt; 100000000 
 
let asyncChild filename = 
        async { 
            printfn "Child job start: %s" filename 
            use outputFile = System.IO.File.Create(filename) 
            do! outputFile.AsyncWrite(bufferData) 
            printfn "Child job end: %s " filename 
        } 
 
let asyncParent = 
        async { 
            printfn "Parent job start." 
            let! childAsync1 = Async.StartChild(asyncChild "longoutput1.dat") 
            let! childAsync2 = Async.StartChild(asyncChild "longoutput2.dat") 
            let! result1 = childAsync1 
            let! result2 = childAsync2 
            printfn "Parent job end." 
        } 
 
 
let form = new Form(Text = "Test Form") 
let button = new Button(Text = "Start") 
form.Controls.Add(button) 
button.Click.Add(fun args -&gt; Async.Start(asyncParent) 
                             printfn "Completed execution." ) 
Application.Run(form) 
</pre>
<p>Ensure that <code class="literal">System.Windows.Forms</code> is available on the project references to run this sample.</p>
<p>For more information&#160;on <code class="literal">Async.StartChild</code>, including the sample code, visit the MSDN Library at <a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.startchild%5b%27t%5d-method-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.startchild%5b%27t%5d-method-%5bfsharp%5d</a>.</p>
<div class="note" title="Note"><h3 class="title"><a id="note45"></a>Note</h3>
<p>
<code class="literal">Async.StartChild</code> is not recommended to be used with the legacy .NET EAP. The result of the child asynchronous process can be placed in a different execution context and thread because EAP can be implemented during the event-driven nature of UI threads such as Windows Forms thread or WPF thread.
</p>
<p>
The risk of getting unpredictable results (side effects) may outweigh the comfort and ease of creating child asynchronous processes. The side effects of cross threads are also very hard to identify and debug. The only way to avoid the risks is by simply not using <code class="literal">Async.StartChild</code> against EAP or against the possibility of operating inside a UI thread such as Windows Forms or WPF.</p>
</div>
</div>
<div class="section" title="F# asynchronous workflow support for legacy .NET APM and EAP"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"></a>F# asynchronous workflow support for legacy .NET APM and EAP</h2>
</div>
</div>
</div>
<p>The F# asynchronous workflow still provides support for legacy .NET APM and EAP model, but the support is meant <span class="emphasis"><em>to consume</em></span> the model because it is not intended to fully implement our own custom APM and EAP models. It is called <span class="emphasis"><em>to consume</em></span> as F# has no support for implementing our own APM and EAP model, so it is not recommended to implement a custom APM or EAP in F#.</p>
<p>There is another reason why these APM and EAP models are not recommended anymore, especially when implementing your own custom models in F#. The complexity of going back and forth of having callbacks with side effects computation such as crossing CPU thread and UI thread is also a very strong reason.</p>
<p>The following operations are targeted at any .NET Asynchronous Programming Model (APM):</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">AsBeginEnd</code></li>
<li class="listitem"><code class="literal">AwaitIAsyncResult</code></li>
<li class="listitem"><code class="literal">FromBeginEnd</code></li>
</ul>
</div>
<p>The .NET APM is one of the legacy asynchronous models in .NET. It has a distinct pattern of having an operation prefixed with <code class="literal">Begin</code>, an operation prefixed with <code class="literal">End</code>, and a callback function to be called. For example, .NET <code class="literal">System.IO.FileStream</code> has <code class="literal">BeginRead</code> and <code class="literal">EndRead</code> methods. Each method has a delegate parameter that functions as callback.</p>
<p>The preferred way to support .NET APM in F# is by using <code class="literal">Async.FromBeginEnd</code> in order to be as flexible as we can to include the <code class="literal">Begin</code> operation, the <code class="literal">End</code> operation, and the parameter for the <code class="literal">Begin</code> and <code class="literal">End</code> operations. Using <code class="literal">Async.FromBeginEnd</code> is also the easiest way to leverage the existing .NET APM, which&#160;is usually available when dealing with I/O. For example, <code class="literal">System.IO.FileStream</code> and <code class="literal">System.Net.Sockets.Socket</code> have the pattern of <code class="literal">BeginXXX</code> and <code class="literal">EndXXX</code> methods.</p>
<p>Let's start by consulting the documentation for&#160;<code class="literal">Async.FromBeginEnd</code> (that has no parameter) in MSDN at&#160;<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.frombeginend%5b%27t%5d-method-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.frombeginend%5b%27t%5d-method-%5bfsharp%5d</a>.</p>
<p>The link has the shortest form of <code class="literal">Async.FromBeginEnd</code> (that does not need a parameter and only returns a result) syntax:</p>
<pre class="programlisting">static member FromBeginEnd : (AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt;'T) * ?(unit -&gt; unit) -&gt; Async&lt;'T&gt; 
</pre>
<p>If you need parameters (from 1 to 3 parameters), the syntaxes are as follows (the <code class="literal">static</code> member modifier is the same as the previous; it is omitted for simplicity):</p>
<pre class="programlisting">FromBeginEnd : 'Arg1 * ('Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt;'T) * ?(unit -&gt; unit) -&gt; Async&lt;'T&gt; 
FromBeginEnd : 'Arg1 * 'Arg2 * ('Arg1 * 'Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt;'T) * ?(unit -&gt; unit) -&gt; Async&lt;'T&gt; 
FromBeginEnd : 'Arg1 * 'Arg2 * 'Arg3 * ('Arg1 * 'Arg2 * 'Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt;'T) * ?(unit -&gt; unit) -&gt; Async&lt;'T&gt; 
</pre>
<p>Just looking at the signature might be confusing at first; fortunately, a sample usage of <code class="literal">Async.FromBeginEnd</code> is available in the MSDN Library.</p>
<p>The sample leverages <code class="literal">System.Net.Socket</code> by enhancing it using an implicit extension method, added on the existing <code class="literal">Socket</code> class.</p>
<p>Here is the code definition of the asynchronous operations sample:</p>
<pre class="programlisting">module SocketServer = 
 
    open System.Net 
    open System.Net.Sockets 
    open System.Collections.Generic 
 
    let toIList&lt;'T&gt; (data : 'T array) = 
        let segment = new System.ArraySegment&lt;'T&gt;(data) 
        let data = new List&lt;System.ArraySegment&lt;'T&gt;&gt;() :&gt; IList&lt;System.ArraySegment&lt;'T&gt;&gt; 
        data.Add(segment) 
        data 
 
    type Socket with  
        member this.MyAcceptAsync() = 
            Async.FromBeginEnd((fun (callback, state) -&gt; this.BeginAccept(callback, state)), 
                               this.EndAccept) 
        member this.MyConnectAsync(ipAddress : IPAddress, port : int) = 
            Async.FromBeginEnd(ipAddress, port, 
                               (fun (ipAddress:IPAddress, port, callback, state) -&gt; 
                                   this.BeginConnect(ipAddress, port, callback, state)), 
                               this.EndConnect) 
        member this.MySendAsync(data : byte array, flags : SocketFlags) = 
            Async.FromBeginEnd(toIList data, flags,  
                               (fun (data : IList&lt;System.ArraySegment&lt;byte&gt;&gt;, 
                                     flags : SocketFlags, callback, state) -&gt; 
                                         this.BeginSend(data, flags, callback, state)), 
                               this.EndSend) 
        member this.MyReceiveAsync(data : byte array, flags : SocketFlags) = 
            Async.FromBeginEnd(toIList data, flags,  
                               (fun (data : IList&lt;System.ArraySegment&lt;byte&gt;&gt;, 
                                     flags : SocketFlags, callback, state) -&gt; 
                                         this.BeginReceive(data, flags, callback, state)), 
                               this.EndReceive) 
</pre>
<p>The name of the method that contains an asynchronous call follows common guidelines: it has an <code class="literal">Async</code> suffix. For example, the <code class="literal">this.MyConnectAsync</code> method contains an asynchronous call to <code class="literal">Socket.BeginConnect</code> that follows the APM naming conventions.</p>
<p>
<code class="literal">Async.FromBeginEnd</code> uses the syntax for two parameters. It is also used to wrap and simultaneously handle the following pairs of the asynchronous Socket:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">BeginAccept</code> and <code class="literal">EndAccept</code> pair</li>
<li class="listitem"><code class="literal">BeginConnect</code> and <code class="literal">EndConnect</code> pair</li>
<li class="listitem"><code class="literal">BeginSend</code> and <code class="literal">EndSend</code> pair</li>
<li class="listitem"><code class="literal">BeginReceive</code> and <code class="literal">EndReceive</code> pair</li>
</ul>
</div>
<p>The related syntax on the MSDN Library is <code class="literal">Async.FromBeginEnd&lt;'Arg1,'Arg2,'T&gt;</code> because it needs two parameters (or arguments in MSDN Library terms).</p>
<p>To test those <code class="literal">Socket</code> methods in the <code class="literal">async</code> block, consider the following partial sample:</p>
<pre class="programlisting">    let port = 11000 
 
    let socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp) 
    let ipHostInfo = Dns.Resolve(Dns.GetHostName()) 
    let localIPAddress = ipHostInfo.AddressList.[0] 
    let localEndPoint = new IPEndPoint(localIPAddress, port) 
    socket.Bind(localEndPoint) 
 
    let connectSendReceive (socket : Socket) = 
        async { 
            do! socket.MyConnectAsync(ipHostInfo.AddressList.[0], 11000) 
            let buffer1 = [| 0uy .. 255uy |] 
            let buffer2 = Array.zeroCreate&lt;byte&gt; 255 
            let flags = new SocketFlags() 
            let! flag = socket.MySendAsync(buffer1, flags) 
            let! result = socket.MyReceiveAsync(buffer2, flags) 
            return buffer2 
        } 
</pre>
<p>For the complete documentation of <code class="literal">System.Net.Socket</code>, consult the MSDN Library at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.net.sockets.socket(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.net.sockets.socket(v=vs.110).aspx</a>.</p>
<p>For more information, consult .NET APM on the MSDN Library at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms228963(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/ms228963(v=vs.110).aspx</a>.</p>
<p>The EAP model simply models the implementation of asynchronous event-driven programming by using an event as the handler of the completed event. Unfortunately, it is not quite clear how the flow of waiting is implemented as the pattern focuses on what will happen when the operation is completed. It is also not clear about deciding the implementation detail of how the EAP is used to handle the I/O operations that are blocking by default.</p>
<p>F# supports EAP by providing one method, the <code class="literal">Async.AwaitEvent</code> operation.</p>
<p>Compared to APM, EAP focuses more on the completion of the action and the state of an object instead of getting the result of an operation.</p>
<p>For more information about the legacy .NET EAP model, consult:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms228969(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/ms228969(v=vs.110).aspx</a>
To illustrate F# support for EAP, we must understand and focus on the event programming model first.</p>
<p>The event programming model is actually not so different from the event-based approach of Windows UI programing, where a UI control has events for any kind of event happening to it, such as clicked, mouse over, focus, or lost focus. But there are some events that need to be handled with care, such as timer events. When a timer is active, it ticks on every period based on how long it takes to tick between intervals. Usually, when an interval is set, the timer implicitly makes us to wait until some time period has elapsed.</p>
<div class="note" title="Note"><h3 class="title"><a id="note46"></a>Note</h3>
<p>The use of a timer is crucial as sometimes the time elapsed may vary depending on what kind of timer we use. Avoid the use of a UI timer as much as possible because the resolution (the precision of timing) of a UI timer is lower than <code class="literal">System.Threading.Timer</code> or any other non-UI timer, as highlighted in <a class="link" title="Chapter&#160;2.&#160;Performance Measurement" href="fsp-hiperf_cu02.html#aid-K0RQ2">Chapter 2</a>, <span class="emphasis"><em>Performance Measurement</em></span>.</p>
</div>
<p>All of the execution is based on the sequence of events; it is also natural to call it an event-driven model. Unfortunately, this wait might take some time blocking the current thread. It is therefore recommended to handle this asynchronously.</p>
<p>If we look at the documentation for&#160;<code class="literal">Async.AwaitEvent</code> on the online MSDN Library, the documentation does not have a good explanation on how we relate this to .NET EAP.</p>
<p>The following is the sample code from the MSDN Library documentation:</p>
<pre class="programlisting">open System.Windows.Forms 
open System.IO 
 
let filename = "longoutput.dat" 
 
if File.Exists(filename) then File.Delete(filename) 
let watcher = new FileSystemWatcher(Directory.GetCurrentDirectory(), filename, NotifyFilter = NotifyFilters.LastWrite) 
watcher.Changed.Add &lt;| fun args -&gt; printfn "The file %s is changed." args.Name 
watcher.EnableRaisingEvents &lt;- true 
 
let async2 filename =  
    async {  
        printfn "Waiting for file system watcher notification." 
        // If you omit the call to AwaitEvent, an exception is thrown that indicates that the 
        // file is locked. 
        let! _args = Async.AwaitEvent(watcher.Changed) 
        printfn "Attempting to open and read file %s." filename 
        use inputFile = File.OpenRead(filename) 
        let! buffer = inputFile.AsyncRead(100000000) 
        printfn "Successfully read file %s." filename 
        return buffer 
    } 
</pre>
<p>This sample is quite simple, and at the same time, it directly shows the sample usage of <code class="literal">Async.AwaitEvent</code>. The sample <code class="literal">await</code> construct for any file or folder changes in a folder. If any changes occur (as a changed event), it will continue to print the file name and do some I/O operations, such as opening the file. The file is then read asynchronously.</p>
<p>For more information on <code class="literal">Async.AwaitEvent</code>, check out <a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.awaitevent%5b%27del%2c%27t%5d-method-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.awaitevent%5b%27del%2c%27t%5d-method-%5bfsharp%5d</a>.</p>
<p>We now have basic knowledge of how F# interops with .NET EAP, although the interoperability is not quite as straightforward as using the async-based <code class="literal">Task&lt;T&gt;</code>.</p>
</div>
<div class="section" title="Ignoring asynchronous operation asynchronously"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"></a>Ignoring asynchronous operation asynchronously</h2>
</div>
</div>
</div>
<p>
<code class="literal">Async.Ignore</code> is essentially the same as using <code class="literal">ignore</code>. However, it is semantically different as <code class="literal">Async.Ignore</code> must only be used to ignore asynchronous operations, not non-asynchronous operations.</p>
<p>The signature of <code class="literal">Async.Ignore</code> is as follows:</p>
<pre class="programlisting">static member Ignore : Async&lt;'T&gt; -&gt; Async&lt;unit&gt; 
</pre>
<p>
<code class="literal">Async.Ignore</code> implies that it cannot be used independently as it needs an <code class="literal">async</code> operation as its parameter.</p>
<p>
<code class="literal">Async.Ignore</code> has its ignore implementation asynchronously; therefore, it is guaranteed not to block the current thread synchronously. This means that it will not block the current thread of the calling function as well.</p>
<p>The common place of <code class="literal">Async.Ignore</code> is generally used to ignore the returning result of the following:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">All EAP-based asynchronous operations.</li>
<li class="listitem">All asynchronous operations that return nothing (<code class="literal">unit</code> in F#, <code class="literal">void</code> in C#, or the&#160;<code class="literal">Sub</code> procedure/method in VB).</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>Therefore, we must not use <code class="literal">Async.Ignore</code> if we want to examine or get the results from asynchronous operations. Also, <code class="literal">Async.Ignore</code> is already optimized for non-returning result of any asynchronous workflow.</p>
<div class="note" title="Note"><h3 class="title"><a id="note47"></a>Note</h3>
<p>Please do not confuse the non-returning result of asynchronous operations with the F# unit. The term non-returning result should be treated as simply intuitive-not returning any result-because the main focus here is the on completion of any actions.</p>
</div>
<p>It is recommended that you use <code class="literal">Async.Ignore</code> on F#-specific asynchronous workflows (including F# support on EAP) and .NET TPL instead of using it on other kinds of asynchronous models, as it is more predictable and more optimized.</p>
<p>Using <code class="literal">Async.Ignore</code> is also fine when combining with F#'s <code class="literal">MailboxProcessor</code> because <code class="literal">MailboxProcessor</code> is designed to be compatible; it's also recommended to use <code class="literal">MailboxProcessor</code> in asynchronous workflow blocks.</p>
</div>
<div class="section" title="Delaying asynchronous workflow"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"></a>Delaying asynchronous workflow</h2>
</div>
</div>
</div>
<p>What if we delay an asynchronous implementation without blocking the outside calling thread? We could do this easily by using <code class="literal">Thread.Sleep</code>, but <code class="literal">Thread.Sleep</code> always blocks the calling thread and not just the current execution thread. Therefore, <code class="literal">Thread.Sleep</code> always enforces us to wait synchronously instead of asynchronously. It is also often misunderstood that <code class="literal">Thread.Sleep</code> would not block as it actually blocks the current thread. We can wrap <code class="literal">Thread.Sleep</code> into an <code class="literal">async</code> block, but then the outside thread still has to wait for <code class="literal">Thread.Sleep</code> to finish first.</p>
<p>There is the&#160;<code class="literal">Async.Sleep</code> method to support delay asynchronously. The syntax is as follows:</p>
<pre class="programlisting">Sleep : int -&gt; Async&lt;unit&gt; 
</pre>
<p>Consider the following sample usage:</p>
<pre class="programlisting">Async.Sleep(100) 
</pre>
<p>It's still better to assume that any asynchronous delay implementation uses <code class="literal">Async.Sleep</code> instead of <code class="literal">Thread.Sleep</code> because <code class="literal">Async.Sleep</code> never blocks the current operating system threads.</p>
<p>According to a short description on MSDN Library, <code class="literal">Async.Sleep</code>:</p>
<div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>Creates an asynchronous computation that will sleep for the given time. This is scheduled using a System.Threading.Timer object. The operation will not block operating system threads for the duration of the wait.</em></span>
</p>
</blockquote>
</div>
<p>This is not the actual implementation detail because it depends on the current runtime. Internally, <code class="literal">Async.Sleep</code> creates an asynchronous operation that inserts the delay by calling <code class="literal">Task.Delay</code> internally if it's run under .NET Core or by using the asynchronous timer mechanism utilizing <code class="literal">System.Threading.Timer</code> for non-.NET Core, with the <span class="emphasis"><em>trampoline</em></span> algorithm in place.</p>
<div class="note" title="Note"><h3 class="title"><a id="note48"></a>Note</h3>
<p>The term <span class="emphasis"><em>actual implementation detail</em></span> means that the actual internal implementation detail will be changed in the next release of F#. We must also include the fact that F# core class libraries are open source as part of the Microsoft Visual F# open source repo on GitHub.</p>
</div>
<p>Therefore, there is a high possibility that the actual source code implementation of F# will change by the time this book is published. It could change based on the progress of feedbacks from Microsoft and external contributors. It is also quite common to always assume that the actual implementation will always be changed, based on the nature of open source contributions.</p>
<div class="note" title="Note"><h3 class="title"><a id="note49"></a>Note</h3>
<p>Starting from this chapter, we will sometimes visit the internal implementation of F# 4 core class libraries by looking at its source code. This is very important because we have to dig deeper than just using the libraries in order to fully understand what is happening behind the scenes of calling F# core functions. It is also a common best practice to increase our knowledge of the internal workings of how F# presents its features.</p>
</div>
<p>We can <span class="emphasis"><em>peek</em></span> at the source code of <code class="literal">Async.Sleep</code> on the F# GitHub repo (some comments have been omitted):</p>
<pre class="programlisting">#if FSHARP_CORE_NETCORE_PORTABLE 
        static member Sleep(dueTime : int) : Async&lt;unit&gt; =  
            // use combo protectedPrimitiveWithResync + continueWith instead of AwaitTask so we can pass cancellation token to the Delay task 
            unprotectedPrimitiveWithResync ( fun ({ aux = aux} as args) -&gt; 
                let mutable edi = null 
 
                let task =  
                    try  
                        Task.Delay(dueTime, aux.token) 
                    with exn -&gt; 
                        edi &lt;- ExceptionDispatchInfo.RestoreOrCapture(exn) 
                        null 
 
                match edi with 
                | null -&gt; TaskHelpers.continueWithUnit(task, args) 
                | _ -&gt; aux.econt edi 
            ) 
#else 
        static member Sleep(dueTime) : Async&lt;unit&gt; = 
unprotectedPrimitiveWithResync (fun ({ aux = aux } as args) -&gt; 
let timer = ref (None : Timer option) 
                let savedCont = args.cont 
                let savedCCont = aux.ccont 
                let latch = new Latch() 
                let registration = 
                    aux.token.Register( 
                        (fun _ -&gt; 
                            if latch.Enter() then 
                                match !timer with 
                                | None -&gt; () 
                                | Some t -&gt; t.Dispose() 
                                aux.trampolineHolder.Protect(fun () -&gt; savedCCont(new OperationCanceledException())) |&gt; unfake 
                            ), 
                        null) 
                let mutable edi = null 
                try 
                    timer := new Timer((fun _ -&gt; 
                                        if latch.Enter() then 
                                            registration.Dispose() 
                                            match !timer with 
                                            |  None -&gt; () 
                                            |  Some t -&gt; t.Dispose() 
                                            aux.trampolineHolder.Protect (fun () -&gt; savedCont()) |&gt; unfake), 
                                     null, dueTime=dueTime, period = -1) |&gt; Some 
                with exn -&gt; 
                    if latch.Enter() then  
                        edi &lt;- ExceptionDispatchInfo.RestoreOrCapture(exn) // post exception to econt only if we successfully enter the latch (no other continuations were called) 
 
                match edi with  
                | null -&gt; 
                    FakeUnit 
                | _ -&gt; 
                    aux.econt edi 
                ) 
#endif 
 
</pre>
<p>The full source code is available at <a class="ulink" href="https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/control.fs">https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/control.fs</a>.</p>
<p>For more information about <code class="literal">Async.Sleep</code> visit the MSDN Library, at <a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.sleep-method-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.sleep-method-%5bfsharp%5d</a>.</p>
<p>So far, we have covered how to declare an <code class="literal">async</code> block and delay it. Now, we need to know how to cancel it.</p>
</div>
<div class="section" title="Handling cancellation in asynchronous workflow"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"></a>Handling cancellation in asynchronous workflow</h2>
</div>
</div>
</div>
<p>It is quite possible that the user may cancel the ongoing asynchronous process even in the middle of an asynchronous operation.</p>
<p>In F#, the common way to have support for cancellation that can be done in the middle of any running asynchronous operation is as follows:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Requesting a token in the form of the&#160;<code class="literal">CancellationToken</code> type structure.</li>
<li class="listitem">This <code class="literal">CancellationToken</code> instance is obtained from <code class="literal">System.Threading.CancellationTokenSource</code>. Internally, <code class="literal">CancellationToken</code> will always be loaded and pushed onto a stack, which is later popped after use when the ongoing asynchronous operation is canceled.</li>
<li class="listitem"><code class="literal">CancellationToken</code> needs to know which one of the asynchronous operations to have cancellation support for. This can be done by linking <code class="literal">CancellationToken</code> with the asynchronous function by calling <code class="literal">Async.Start</code> or <code class="literal">Async.StartImmediate</code> with an override that has <code class="literal">CancellationToken</code> as a parameter.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>Before using <code class="literal">CancellationToken</code> and <code class="literal">CancellationTokenSource</code>, you need to ensure that references to the <code class="literal">System.Threading.dll</code> assembly are available on the project reference setting when the code is in an FS file or that you have registered the assembly manually when the code is in an FSX file and executed in scripting mode (in F# Interactive mode).</p>
<p>To add cancellation support as mentioned in Step 3, the linking of the asynchronous operation (usually wrapped as an <code class="literal">async</code> block) is done by linking the <code class="literal">async</code> function with <code class="literal">CancellationToken</code>, and this linking must be done carefully. This <code class="literal">CancellationToken</code> instance is a <span class="emphasis"><em>value typed object, so the instance of this CancellationToken must not be derived, and it must not be used and linked to other async functions</em></span>. It is also implicitly immutable, including the referential transparency of the initial design of <code class="literal">CancellationToken</code>.</p>
<p>This linking of the asynchronous operation is crucial; if the same value is linked to more than one <code class="literal">async</code> block, it will cancel each of the linked functions unpredictably because the same object value may interfere with other linked <code class="literal">async</code> blocks as well. This will violate the referential transparency and may therefore raise many unwanted side effects. Such multiple function linking is a bad practice as it will cause side effects such as unpredictable cancellation.</p>
<p>Because of the nature of <code class="literal">CancellationToken</code> as a structure (value type), multiple instances of different tokens of <code class="literal">CancellationToken</code> will always be stored and pushed into stacks, which is fast to store and retrieve (pop) as well.</p>
<p>Therefore, multiple linking to multiple <code class="literal">async</code> blocks from the same <code class="literal">CancellationToken</code> is not recommended and should not be allowed.</p>
<p>To see the usage sample of <code class="literal">CancellationToken</code>, we can revisit our existing <code class="literal">use!</code> sample and leverage the overloaded method of <code class="literal">ExecuteReaderAsync</code> with an additional <code class="literal">CancellationToken</code> parameter.</p>
<p>The existing code sample now looks as follows:</p>
<pre class="programlisting">open System 
open System.Data 
open System.Data.SqlClient 
open System.Threading 
open System.Threading.Tasks 
 
let UseBangCancellationSample (dbconstring: string, tokenSource:CancellationTokenSource) = 
    async { 
        <span class="strong"><strong>use dbCon = new SqlConnection(dbconstring) 
        use sqlCommand = new SqlCommand("SELECT * FROM INFORMATION_SCHEMA.TABLES") 
        use! dataReader = Async.AwaitTask(sqlCommand.ExecuteReaderAsync(CommandBehavior.Default, tokenSource.Token)) 
        printfn "Finished querying"</strong></span> 
    } 
</pre>
<p>The preceding sample code highlights the following steps to add cancellation support:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">UseBangCancellationSample</code> function shows that it takes a parameter, <code class="literal">tokenSource</code> typed as <code class="literal">CancellationTokenSource</code>. Then <code class="literal">CancellationToken</code> is taken from the <code class="literal">CancellationTokenSource.Token</code> property.</li>
<li class="listitem">To cancel the ongoing asynchronous operation, call the <code class="literal">Cancel</code> method of the <code class="literal">CancellationToken</code> instance, which is passed into the related asynchronous operation started.</li>
<li class="listitem">It is important that the instance of <code class="literal">CancellationToken</code> knows which asynchronous process it needs to cancel. In the preceding sample, <code class="literal">CancellationToken</code> is linked to <code class="literal">ExecuteReaderAsync</code> by setting it as a parameter.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>We now know how to utilize <code class="literal">CancellationToken</code> and <code class="literal">CancellationTokenSource</code> by leveraging the <code class="literal">System.Threading.Tasks</code> namespace. This also serves as a warm starter to the introduction to interoperability with the Task library and.NET TPL.</p>
</div>
<div class="section" title="Common conventions when implementing asynchronous operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"></a>Common conventions when implementing asynchronous operations</h2>
</div>
</div>
</div>
<p>We have seen samples of implementing calling asynchronous operations and wrapping them in asynchronous blocks. There are some patterns and best practices that we must follow in accordance with the F# implementation and .NET standards.</p>
<p>There are certain guidelines or standards that must be followed not only to enhance the code's readability but also because it will become easier to understand the code and reason about what it will do.</p>
<p>The following are some common conventions of implementing asynchronous workflow:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A method that has an asynchronous call inside it should be suffixed with Async, to define that this function or method contains an asynchronous call and must be called inside the asynchronous block.</li>
<li class="listitem">Any kind of event handling that has an asynchronous call should not be suffixed with Async, for example, the <code class="literal">Button1_Click</code> method to handle the Click event that has a call to <code class="literal">DownloadWebAsync</code>.</li>
<li class="listitem">An <code class="literal">async</code> block that needs to delay some operations should use <code class="literal">Async.Sleep</code> instead of <code class="literal">Thread.Sleep</code>. Otherwise, the current thread will be blocked; the execution will be observed as synchronous and will be executed synchronously instead of asynchronously.</li>
<li class="listitem">All I/O operations must be treated asynchronously. This includes I/O operations to send commands to other output devices such as printers, not just I/O in network or I/O to storage devices.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>Now that we know the basic usage of the <code class="literal">Control.Async</code> operations in F#, we will dive into the basic interop of asynchronous workflow with .NET TPL.</p>
</div>
</div>


<div class="section" title="Introduction to interop with .NET TPL"><div class="titlepage" id="aid-147LC2"><div><div><h1 class="title"><a id="ch04lvl1sec30"></a>Introduction to interop with .NET TPL</h1>
</div>
</div>
</div>
<p>F# has a high compatibility support for .NET TPL; it can nicely use the .NET TPL objects of <code class="literal">Task</code> and <code class="literal">Task&lt;T&gt;</code> back and forth. This means that F# can also use the <code class="literal">Task</code>/<code class="literal">Task&lt;T&gt;</code> results from other languages as well and not just from F#.</p>
<p>In .NET TPL, the concurrency support is not just for parallel programming, but also for the awaiter of the async-await model that has currently started in C# 5.0 and VB 11, as related in .NET 4.5 and later.</p>
<p>In this chapter, we will start from the overview of .NET TPL support in F# in terms of leveraging <code class="literal">Task</code> and <code class="literal">Task&lt;T&gt;</code>. We will discuss the interop perspective from outside of F#, such as interop with F# asynchronous workflow, in <a class="link" title="Chapter&#160;5.&#160;Advanced Concurrency Support in F#" href="fsp-hiperf_cu05.html#aid-164MG2">Chapter 5</a>, <span class="emphasis"><em>Advanced Concurrency Support in F#</em></span>.</p>
<div class="section" title="A quick overview of asynchronous programming in .NET TPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"></a>A quick overview of asynchronous programming in .NET TPL</h2>
</div>
</div>
</div>
<p>For asynchronous operations (or asynchronous programming, as is mostly mentioned in C#/VB documentation in MSDN) the async-await model relies heavily on the <code class="literal">Task</code> and <code class="literal">Task&lt;T&gt;</code> classes.</p>
<p>The <code class="literal">Task</code> class is for asynchronous operations that have no result; <code class="literal">Task&lt;T&gt;</code> is for asynchronous operations that have results. The generic parameter <code class="literal">T</code> is the type of the result.</p>
<p>
<code class="literal">Task&lt;T&gt;</code> contains the result in a property called <code class="literal">result</code>.</p>
<p>The <code class="literal">Task</code> and <code class="literal">Task&lt;T&gt;</code> classes are available under the <code class="literal">System.Threading.Tasks</code> namespace. For more information, consult the landing page of <code class="literal">System.Threading.Tasks</code> in .NET 4.6 on the MSDN Library at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.threading.tasks(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.threading.tasks(v=vs.110).aspx</a>.</p>
<p>In F#, the following are the operations that support <code class="literal">Task</code>/<code class="literal">Task&lt;T&gt;</code>:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">Async.AwaitTask</code></li>
<li class="listitem"><code class="literal">Async.StartAsTask</code></li>
<li class="listitem"><code class="literal">Async.StartChildAsTask</code></li>
</ul>
</div>
<p>All these methods have two overrides in common, one for dealing with <code class="literal">Task</code> with no result and the other for dealing with <code class="literal">Task&lt;T&gt;</code> that will return a <code class="literal">Task</code> with a result typed <code class="literal">T</code>. Dealing in this context means having interoperability with the Task-based Asynchrony Pattern (TAP) of .NET TPL</p>
<p>We are not going to reintroduce the detail of .NET TAP because we are focusing on best practices. For more information on .NET TAP in .NET 4.5 and 4.6 on MSDN Library, visit <a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh873175(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/hh873175(v=vs.110).aspx</a>.</p>
<p>The documentation for&#160;<code class="literal">Async.AwaitTask</code> and <code class="literal">Async.StartChildAsTask</code> does not provide a sample code for us at all. Only <code class="literal">Async.StartAsTask</code> has a very simple sample code.</p>
<p>Work to address these shortcomings in the Visual F# documentation repository is still in progress, and all of us are welcome to participate.</p>
<p>The following is the sample code in the <code class="literal">Async.StartAsTask</code> documentation, and we have to modify it to successfully run it under the UI thread:</p>
<pre class="programlisting">let async1 = 
async { 
   use outputFile = System.IO.File.Create("longoutput.dat") 
  do! outputFile.AsyncWrite(bufferData)  
} 
 
[&lt;EntryPoint&gt;] 
[&lt;STAThread&gt;] 
let main argv =  
    let form = new Form(Text = "Test Form") 
    let button = new Button(Text = "Start") 
    form.Controls.Add(button) 
    button.Click.Add(fun args -&gt; let task = Async.StartAsTask(async1) 
printfn "Do some other work..." 
task.Wait() 
printfn "done") 
    form.Show() 
    Application.Run(form) 
</pre>
<p>The code is explained as follows:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The asynchronous code is running within the UI thread of Windows Forms. Therefore, it is advisable that the main method be marked with the <code class="literal">System.STAThread</code> attribute.</li>
<li class="listitem">The <code class="literal">async</code> block is contained in the <code class="literal">async1</code> function. It is then executed using <code class="literal">Async.StartAsTask</code> with no result. It will then return a <code class="literal">Task</code> instead of <code class="literal">Task&lt;T&gt;</code>.</li>
<li class="listitem"><code class="literal">Async.StartAsTask</code> is written inside an inline event handler of the Click event, <code class="literal">button.Click</code>, by using addition to the current event handler of event Click. It is the same as <code class="literal">AddHandler</code> in VB or the syntactic sugar of the&#160;<code class="literal">+=</code> operator in C#.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>The original sample code in the MSDN Library does not have this <code class="literal">STAThread</code> attribute and it will yield an exception because <code class="literal">System.InvalidOperationException</code> has occurred due to the invalid cross thread, although the error message is quite confusing:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00292.jpeg" alt="A quick overview of asynchronous programming in .NET TPL"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>It literally gives the following as the reason:</p>
<pre class="programlisting">System.InvalidOperationException: Starting a second message loop on a single thread is not a valid operation. Use Form.ShowDialog instead. 
</pre>
<p>This is not the real error. The real error is in the code where we put&#160;the code/function that calls <code class="literal">Application.Run</code> marked with <code class="literal">STAThreadAttribute</code>. It is also quite common as it is often demonstrated by C#/VB samples in the default project template of Windows Forms.</p>
<p>Not just Windows Forms, the terms of operating under <code class="literal">STAThread</code> are also valid for WPF as well.</p>
<p>For a detailed explanation of <code class="literal">STAThread</code>, visit:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.stathreadattribute(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.stathreadattribute(v=vs.110).aspx</a>
</p>
<p>And for more information about the Thread apartment model (including STA and MTA with respect to COM), visit the MSDN Library at <a class="ulink" href="https://msdn.microsoft.com/library/ms809971.aspx">https://msdn.microsoft.com/library/ms809971.aspx</a>.</p>
<div class="note" title="Note"><h3 class="title"><a id="note50"></a>Note</h3>
<p>By default, F# and C# use MTA; VB uses STA. For a Windows Forms application, the default is using STA. STA and MTA have nothing to do with how you create <code class="literal">System.Threading.Thread</code>. It is a threading apartment model, not a general multithreading model.</p>
</div>
<p>For the other <code class="literal">Async.AwaitTask</code> and <code class="literal">Async.StartChildAsTask</code> samples, let's revisit the sample of <code class="literal">UseBangSample</code>: (with <code class="literal">Async.AwaitTask</code> highlighted):</p>
<pre class="programlisting">open System.Data 
open System.Data.SqlClient 
 
let UseBangSample (dbconstring: string) = 
    async { 
        use dbCon = new SqlConnection(dbconstring) 
        use sqlCommand = new SqlCommand("SELECT * FROM INFORMATION_SCHEMA.TABLES") 
<span class="strong"><strong>        use! dataReader = Async.AwaitTask(sqlCommand.ExecuteReaderAsync(CommandBehavior.Default))</strong></span> 
        printfn "Finished querying" 
    } 
</pre>
<p>The preceding code demonstrates how to await a result from an asynchronous operation by awaiting <code class="literal">Task&lt;T&gt;</code>. The <code class="literal">T</code> in this context is typed as <code class="literal">SqlDataReader</code>, inferred by the return builder of asynchronous workflow. The return builder is coded implicitly in the <code class="literal">use!</code> construct/keyword as nicely captured from the execution of the&#160;<code class="literal">ExecuteReaderAsync</code> method.</p>
</div>
</div>


<div class="section" title="Summary" id="aid-1565U1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"></a>Summary</h1>
</div>
</div>
</div>
<p>When we are developing any applications, starting from small mobile applications to a large-scale enterprise application, concurrency is becoming very relevant, not just because of the trend of multi-core CPUs but also because having optimizations on concurrency gives us many advantages as described in this chapter. Although there is no single solution for all concurrency problems and optimizations, we know that we could leverage concurrency support in F# and .NET.</p>
<p>In <a class="link" title="Chapter&#160;5.&#160;Advanced Concurrency Support in F#" href="fsp-hiperf_cu05.html#aid-164MG2">Chapter 5</a>, <span class="emphasis"><em>Advanced Concurrency Support in F#</em></span>, we will discuss the advanced topic of concurrency in F#, including one of F#'s unique features: the message-passing agent, <code class="literal">MailboxProcessor</code>.</p>
</div>
</body>
</html>