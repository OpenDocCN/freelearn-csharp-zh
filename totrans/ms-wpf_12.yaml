- en: Deploying Your Masterpiece Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署您的杰作应用程序
- en: So, we've designed and constructed our application framework, resources, and
    managers, added our Models, Views, and View Models, and after completing the development
    of our application, now it's time for deployment. In this chapter, we'll be looking
    at an overview of the three main methods of deploying WPF applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经设计和构建了我们的应用程序框架、资源和管理者，添加了我们的模型、视图和视图模型，在完成应用程序的开发后，现在是部署的时候了。在本章中，我们将概述部署WPF应用程序的三个主要方法。
- en: We'll start by investigating the original Windows Setup Project method, move
    on to discover the newer InstallShield Limited Edition Project method, and then
    progress to examine the recommended ClickOnce technology.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先研究原始的Windows设置项目方法，然后继续了解更新的InstallShield Limited Edition项目方法，最后将检查推荐的ClickOnce技术。
- en: Installing Windows applications
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Windows应用程序
- en: In days gone by, creating a Setup and Deployment project in Visual Studio was
    a confusing and complicated process. However, as with just about everything in
    .NET, successive updates over the years have resulted in ever-improved creation
    methods for these projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的日子里，在Visual Studio中创建设置和部署项目是一个令人困惑且复杂的过程。然而，正如.NET中的几乎所有事情一样，多年的连续更新导致了这些项目创建方法的持续改进。
- en: Introducing the Setup Project
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍设置项目
- en: 'The latest deployment technologies are simpler to use and provide an easily
    understandable method of performing the same steps as the earlier technologies.
    However, in older versions of Visual Studio, we might only have access to the
    older Visual Studio Installer project types, so let''s first investigate the standard
    Setup Project:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的部署技术使用起来更简单，提供了一种易于理解的方法来执行与早期技术相同的步骤。然而，在Visual Studio的旧版本中，我们可能只能访问旧的Visual
    Studio Installer项目类型，所以让我们首先研究标准的设置项目：
- en: '![](img/a6164ad0-f5ea-42b6-be6a-b90a3bc57343.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6164ad0-f5ea-42b6-be6a-b90a3bc57343.png)'
- en: After adding a Setup Project to the solution, a page opens up showing the file
    system on the target computer. On this File System Editor page, we can specify
    what we would like to install and where. The page is divided into two, with a
    tree View of the folders to be installed on the users' computers on the left and
    their folder contents on the right. By default, the left pane contains the `Application`,
    `Desktop`, and `Program Files` folders.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中添加一个设置项目后，会打开一个页面，显示目标计算机上的文件系统。在这个文件系统编辑器页面上，我们可以指定我们想要安装的内容以及安装位置。页面分为两部分，左侧是用户计算机上要安装的文件夹树视图，右侧是它们的文件夹内容。默认情况下，左侧面板包含`应用程序`、`桌面`和`程序文件`文件夹。
- en: If we would prefer to use other predefined locations, such as the `Fonts`, `Favorites`,
    or the `Common Files` folders, for example, then we can right-click on the background
    of these panes and select the Add Special Folder option. Typically, we would add
    a standard folder with our company's name into the `User's Programs Menu` folder
    and add a further folder named after our application into that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望使用其他预定义的位置，例如`字体`、`收藏夹`或`公共文件`文件夹，例如，那么我们可以右键单击这些面板的背景，并选择添加特殊文件夹选项。通常，我们会将带有我们公司名称的标准文件夹添加到`用户程序菜单`文件夹中，并在其中添加一个以我们的应用程序命名的文件夹。
- en: However, if we want to install our application as a 64 bit application, then
    we'll need to use this option to add the 64 bit `Program Files` folder to install
    into. To do so, we need to right-click on the File System on Target Machine item
    at the top of the tree View, select the Add Special Folder option, and then select
    the Program Files (64-bit) Folder item.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要将我们的应用程序作为64位应用程序安装，那么我们需要使用此选项将64位的`程序文件`文件夹添加到安装位置。为此，我们需要在树视图顶部的目标计算机文件系统上右键单击，选择添加特殊文件夹选项，然后选择程序文件（64位）文件夹项。
- en: Note that we should only perform this step if we want to have a 64 bit installation.
    We then need to set the project output of our startup project to the folder in
    the left pane, which represents our installation folder, whether 32 or 64 bit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只有在想要进行64位安装的情况下才应执行此步骤。然后我们需要将启动项目的项目输出设置为左侧面板中的文件夹，该文件夹代表我们的安装文件夹，无论是32位还是64位。
- en: We'll need to right-click on that folder and select the Add option and then
    the Project Outputs option from the contextual menu, and then select the Primary
    Output option that relates to our `CompanyName.ApplicationName` project. After
    doing so, we'll see a copy of the executable and other dependent files from its
    `bin` folder being included in our selected application folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要右键单击该文件夹，从上下文菜单中选择添加选项，然后选择与我们的`CompanyName.ApplicationName`项目相关的项目输出选项。完成此操作后，我们将看到从其`bin`文件夹中的可执行文件和其他依赖文件被包含在我们的所选应用程序文件夹中。
- en: Next, we can create a shortcut to our application on the machine that it was
    installed on by right-clicking the icon for the project output in the right pane
    and selecting the Create Shortcut to Primary output from CompanyName.ApplicationName
    (Active) option from the menu.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过在右侧窗格中右键单击项目输出的图标并从菜单中选择从CompanyName.ApplicationName（活动）创建快捷方式到主要输出选项来在安装了应用程序的机器上创建应用程序的快捷方式。
- en: We need to give it the same name as our application and set an icon for it,
    which we can do in its Properties window. We can then click and drag, or copy
    and paste it to the `User's Desktop` folder, or to whichever folder we want the
    shortcut to appear in.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要给它与我们的应用程序相同的名称，并为其设置一个图标，这可以在其属性窗口中完成。然后我们可以点击并拖动，或者复制并粘贴到`用户桌面`文件夹，或者我们希望快捷方式出现的任何文件夹。
- en: In addition to the executable and shortcut files, we can right-click a folder
    in the left pane and select the Add option and then the Folder and/or File options
    from the contextual menu and choose any other files that we may need to install
    on the user's computer. Once we have finished configuring the File System Editor,
    we can right-click on the project node in the Solution Explorer and select another
    page to edit from the View menu.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可执行文件和快捷方式文件外，我们还可以在左侧窗格中右键单击一个文件夹，从上下文菜单中选择添加选项，然后选择文件夹和/或文件选项，并选择我们可能需要在用户的计算机上安装的任何其他文件。一旦我们完成配置文件系统编辑器，我们可以在解决方案资源管理器中右键单击项目节点，并从视图菜单中选择另一个页面进行编辑。
- en: The Registry Editor page is next, and it enables us to make entries in the Windows
    Registry of the host computer. The left window pane acts as the registry View
    of the target computer, and we can use it in the same way as the Registry Editor
    to add new keys. This page also allows us to import registry keys from a `.reg`
    file if we right-click on an empty space and select Import.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表编辑器页面接下来，它使我们能够在宿主计算机的Windows注册表中进行条目。左侧窗口区域充当目标计算机的注册表视图，我们可以像使用注册表编辑器一样使用它来添加新键。此页面还允许我们在右键单击空白区域并选择导入时，从`.reg`文件导入注册表键。
- en: The File Types Editor page follows in the View menu and enables us to associate
    any custom file types that we may have created with our application. In doing
    so, after installation, Windows will then open our application whenever a file
    of one of the types specified on this page are clicked.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型编辑器页面位于视图菜单中，它使我们能够将我们可能创建的任何自定义文件类型与我们的应用程序关联起来。在这样做之后，安装完成后，每当点击此页面上指定类型之一的文件时，Windows都会打开我们的应用程序。
- en: The Setup Project enables us to display a number of default dialogs during installation,
    such as welcome, confirmation, and completion dialogs. It also provides the ability
    to reorder or remove these default dialogs, or add new ones from a predefined
    list. Each dialog provides an image field and different options, such as whether
    a progress bar should be displayed, or what text to display at different stages
    of the installation. This is achieved on the User Interface page.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装项目使我们能够在安装过程中显示多个默认对话框，例如欢迎、确认和完成对话框。它还提供了重新排序或删除这些默认对话框的能力，或者从预定义列表中添加新的对话框。每个对话框都提供图像字段和不同的选项，例如是否应显示进度条，或在安装的不同阶段显示什么文本。这是在用户界面页面上实现的。
- en: The Custom Actions Editor page enables us to specify assemblies that contain
    code in a particular form, that can be run after the application has been installed.
    These actions could be anything, such as popping up a small form and providing
    the user with some configuration options, or simply opening a particular web page
    after installation has completed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义操作编辑器页面使我们能够指定包含特定形式代码的程序集，这些代码可以在应用程序安装后运行。这些操作可以是任何事情，例如弹出一个小表单并提供用户一些配置选项，或者简单地安装完成后打开特定的网页。
- en: The final option in the View menu of the Setup Project opens the Launch Conditions
    Editor page. Here, we can specify prerequisite conditions that must be satisfied
    in order for the application to be installed. For example, we might require a
    particular version of the .NET Framework to be installed, or the host computer
    to have a particular registry key setting.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设置项目视图菜单中的最后一个选项打开启动条件编辑器页面。在这里，我们可以指定必须满足的先决条件，以便应用程序可以被安装。例如，我们可能需要安装特定版本的.NET
    Framework，或者主机计算机具有特定的注册表键设置。
- en: Once the project pages have all been appropriately completed, we just need to
    build the Setup and Deployment project to generate the setup files. However, we
    need to ensure that we build it correctly, dependent upon the selections that
    we made on the File System Editor page.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有项目页面都适当完成，我们只需构建设置和部署项目以生成设置文件。然而，我们需要确保我们正确构建它，这取决于我们在文件系统编辑器页面上的选择。
- en: For example, if we wanted to have a number of setup projects, let's say including
    32 bit and 64 bit installations, then we need to only build the 32 bit version
    of the Setup Project in the 32 bit solution platform and only build the 64 bit
    version in the 64 bit solution platform.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要有多个设置项目，比如说包括32位和64位安装，那么我们只需要在32位解决方案平台上构建设置项目的32位版本，并在64位解决方案平台上只构建64位版本。
- en: We can do this in the Configuration Manager in Visual Studio, which we can open
    from the last option in either the solution configuration or solution platform
    drop-down controls. If the `x86` and `x64` solution platforms do not already exist,
    we can add them by selecting the <New...> option from the solution platform drop-down
    control in the Configuration Manager dialog window.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Visual Studio的配置管理器中完成此操作，我们可以从解决方案配置或解决方案平台下拉控件中的最后一个选项打开它。如果`x86`和`x64`解决方案平台尚未存在，我们可以通过在配置管理器对话框窗口中的解决方案平台下拉控件中选择<新建...>选项来添加它们。
- en: To add the new solution platforms in the New Solution Platform dialog that opens,
    type either `x86` or `x64` in the Type or select the new platform field, select
    the <Empty> option from the Copy settings from drop-down control, and ensure that
    the Create new project platforms tick box is checked.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在打开的新解决方案平台对话框中添加新的解决方案平台，请在类型或选择新平台字段中键入`x86`或`x64`，从复制设置下拉控件中选择<空>选项，并确保已勾选创建新项目平台复选框。
- en: Once we have these two solution platforms, we can select them one at a time
    in the Active solution platform drop-down control in the Configuration Manager
    dialog window and tick and untick the relevant setup projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这两个解决方案平台，我们可以在配置管理器对话框窗口中的活动解决方案平台下拉控件中逐个选择它们，并勾选和取消勾选相关的设置项目。
- en: 'Here is a screenshot of the `x86` solutions selected:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是选择`x86`解决方案的截图：
- en: '![](img/4a6a52b9-4eaf-4f03-a2e2-25b4af850ff1.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a6a52b9-4eaf-4f03-a2e2-25b4af850ff1.png)'
- en: 'Here is a screenshot of the `x64` solutions selected:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是选择`x64`解决方案的截图：
- en: '![](img/6584d8a9-5b40-4d88-aade-0001e547b8c8.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6584d8a9-5b40-4d88-aade-0001e547b8c8.png)'
- en: Note that we must select Release in the solution configuration drop-down and
    then build our project to generate the setup files. If we have set up our build
    configuration correctly, then building the `x86` solution platform will generate
    the 32-bit setup files, and building the `x64` solution platform will generate
    the 64 bit setup files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须在解决方案配置下拉菜单中选择发布，然后构建我们的项目以生成设置文件。如果我们正确设置了构建配置，那么构建`x86`解决方案平台将生成32位设置文件，而构建`x64`解决方案平台将生成64位设置文件。
- en: It can be useful to uncheck the Build tick boxes for our deployment projects
    on all solution platforms when the Active solution configuration is set to Debug.
    Doing this will stop the deployment files from being regenerated every time that
    the solution is built while debugging and will therefore save time during any
    future development.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动解决方案配置设置为调试时，取消勾选所有解决方案平台上的部署项目构建复选框可能很有用。这样做将阻止在调试时每次构建解决方案时重新生成部署文件，因此可以在未来的开发中节省时间。
- en: Working with the InstallShield Limited Edition project
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用InstallShield Limited Edition项目
- en: 'To add a Setup Project in a modern version of Visual Studio, we need to select
    the InstallShield Limited Edition Project from the Setup and Deployment project
    type in the Other Project Types category in the left-hand pane of the Add New
    Project dialog window:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio的现代版本中添加设置项目时，我们需要从左侧窗格中添加新项目对话框窗口的“其他项目类型”类别中的“设置和部署”项目类型中选择InstallShield有限版项目：
- en: '![](img/7934c9fb-2391-48d9-967c-247f442cb1f4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7934c9fb-2391-48d9-967c-247f442cb1f4.png)'
- en: Note that this project type is already included with all paid versions of Visual
    Studio, but those who are using a free version may be directed to a website to
    download this functionality upon selection of the project type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此项目类型已包含在所有付费版本的Visual Studio中，但使用免费版本的用户在选择项目类型后可能会被引导到网站下载此功能。
- en: 'Once it''s installed and the project has been successfully added, a help wizard,
    or a Project Assistant window as InstallShield likes to call it, will be opened
    in Visual Studio to aid the process of configuring the installation project. It
    walks us through the various tasks that we may need to perform when creating our
    installer, page by page:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成并且项目已成功添加，Visual Studio中将打开一个帮助向导，或者像InstallShield喜欢称呼的那样，打开项目助理窗口，以协助配置安装项目的流程。它将我们引导通过创建安装程序时可能需要执行的各种任务，一页一页地进行：
- en: '![](img/f4cb5159-5741-4d22-b836-3195e3228b47.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4cb5159-5741-4d22-b836-3195e3228b47.png)'
- en: Each page is divided into two window panes; the right pane contains the various
    fields that we will edit to set our required specifications for the deployment,
    and the left pane contains additional options and contextual help topics, relevant
    to each page.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每一页都被分为两个窗口面板；右侧面板包含我们将要编辑的各种字段，以设置部署所需的规格，而左侧面板包含与每一页相关的附加选项和上下文帮助主题。
- en: The first page of the Project Assistant is the Application Information page,
    where we can provide general information about the application, such as the company
    name and website, the application name and version, and the icon to display with
    the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 项目助理的第一页是申请信息页面，在这里我们可以提供关于申请的一般信息，例如公司名称和网站、申请名称和版本，以及与申请一起显示的图标。
- en: The Installation Requirements page enables us to select one or more particular
    operating systems that our application is compatible with. In addition to this,
    we can also specify that our application has a dependency from a pre-existing
    list of third-party software, such as Adobe Reader, various versions of the .NET
    Framework, and a number of Microsoft products.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装要求页面使我们能够选择一个或多个与我们的应用程序兼容的特定操作系统。除此之外，我们还可以指定我们的应用程序依赖于一个现有的第三方软件列表，例如Adobe
    Reader、各种版本的.NET Framework以及许多Microsoft产品。
- en: While this list is short, it does contain the most likely prerequisite software
    titles. However, there are a couple of additional options, one of which enables
    us to create custom installation requirements. Upon clicking on this option, the
    System Search Wizard opens and lets us search for additional installation requirements,
    either by folder path, registry key, or by `.ini` file value, and enables us to
    choose what happens if the new requirement is not met during the installation
    process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个列表很短，但它确实包含了最可能需要的先决软件名称。然而，还有一些额外的选项，其中之一允许我们创建自定义安装要求。点击此选项后，系统搜索向导打开，并允许我们通过文件夹路径、注册表键或通过.ini文件值来搜索额外的安装要求，并允许我们选择在安装过程中如果新要求未满足时会发生什么。
- en: The Application Files page is next, and in it, we can add any required application
    files to the installation. The page is divided into two, with a tree View of the
    folders to be installed on the users' computers on the left and the folder contents
    on the right. The left pane contains a list of the most commonly used predefined
    folders, such as the `App Data`, `Common`, and `Program Files` folders.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个页面是应用程序文件页面，在这里我们可以将任何必需的应用程序文件添加到安装中。页面分为两部分，左侧是用户计算机上要安装的文件夹树视图，右侧是文件夹内容。左侧面板包含最常用的预定义文件夹列表，例如`App
    Data`、`Common`和`Program Files`文件夹。
- en: If we need to use other predefined locations, such as the `Desktop`, `Favorites`,
    or the `My Pictures` folders, for example, then we can right-click on an item
    in this pane and select the Show Predefined Folder option. In fact, if we want
    to install our application as a 64 bit application, then we'll need to use this
    option to add the 64 bit `Program Files` folder, in a similar way to the Setup
    Project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要使用其他预定义的位置，例如“桌面”、“收藏夹”或“我的图片”文件夹等，那么我们可以在这个面板上右键单击一个项目并选择显示预定义文件夹选项。实际上，如果我们想将我们的应用程序作为64位应用程序安装，那么我们需要使用这个选项来添加64位的“程序文件”文件夹，类似于设置项目。
- en: In order to do this, we can right-click on the Destination Computer item at
    the top of the tree View, select the Show Predefined Folder option, and then select
    the `ProgramFiles64Folder` item. We would then need to set the project output
    of our startup project to the folder in the left pane that represents our installation
    folder. Note that it will be suffixed with `[INSTALLDIR]` and, in our case, will
    be named `ApplicationName`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以在树视图的顶部右键单击“目标计算机”项，选择显示预定义文件夹选项，然后选择“ProgramFiles64Folder”项。然后我们需要将启动项目的项目输出设置为左侧面板中代表我们的安装文件夹的文件夹。请注意，它将附加“[INSTALLDIR]”后缀，在我们的情况下，将被命名为“ApplicationName”。
- en: We should click the Add Project Outputs button and select the Primary Output
    option that relates to our `CompanyName.ApplicationName` project to include a
    copy of the DLLs and other dependent files from its `bin` folder in the deployment.
    We can right-click the added output item to select further properties if required,
    or if we are using COM objects in our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该点击“添加项目输出”按钮并选择与我们的“CompanyName.ApplicationName”项目相关的“主要输出”选项，以便在部署中包含其“bin”文件夹中的DLL和其他依赖文件。如果需要，我们可以右键单击添加的输出项以选择进一步属性，或者如果我们正在使用应用程序中的COM对象。
- en: Next up is the Application Shortcuts page, where we can control which custom
    shortcuts the installation will include on the users' computer. Note that default
    shortcuts will automatically be added for the executable files that we have specified,
    but this page enables us to delete these, as well as add new ones, or even specify
    uninstallation shortcuts or alternative icons to use.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是应用程序快捷方式页面，在这里我们可以控制安装将在用户的计算机上包含哪些自定义快捷方式。请注意，默认快捷方式将自动添加到我们指定的可执行文件中，但这一页使我们能够删除这些快捷方式，以及添加新的快捷方式，甚至指定卸载快捷方式或替代图标。
- en: The Application Registry page follows and enables us to make entries in the
    Windows Registry of the computer that our application is being installed on. The
    left window pane mirrors the registry View of the destination computer and we
    can use it in the same way to add new keys. This page also allows us to import
    registry keys from a `.reg` file and open the registry editor for the source computer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序注册表页面紧随其后，使我们能够在我们应用程序安装的计算机的Windows注册表中进行条目。左侧窗口面板反映了目标计算机的注册表视图，我们可以以相同的方式使用它来添加新键。此页面还允许我们从`.reg`文件导入注册表键并打开源计算机的注册表编辑器。
- en: The last page is the Installation Interview page, where we can specify which
    dialog screens are displayed to the user during the installation. Here, we can
    optionally upload an End User License Agreement file in the **Rich Text Format**
    (**RTF**) file format to require the user to agree to.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个页面是安装访谈页面，在这里我们可以指定在安装过程中向用户显示哪些对话框屏幕。在这里，我们可以选择性地上传一个**富文本格式**（**RTF**）格式的最终用户许可协议文件，要求用户同意。
- en: Additionally, we can prompt the user to enter their username and company name
    and provide them with options to select the installation location and whether
    the application should open after the installation is complete. We can also specify
    custom images to be displayed in these dialog windows from this page.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以提示用户输入他们的用户名和公司名称，并为他们提供选择安装位置以及安装完成后是否打开应用程序的选项。我们还可以从这一页指定在这些对话框窗口中显示的自定义图片。
- en: Once the project assistant pages have all been appropriately completed, we just
    need to build the setup and deployment project to generate the setup files. However,
    we need to ensure that we build it correctly, dependent upon the selections that
    we made in the project assistant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有项目助手页面都适当完成，我们只需构建设置和部署项目以生成设置文件。然而，我们需要确保正确构建它，这取决于我们在项目助手中所做的选择。
- en: 'When using and focusing the InstallShield Limited Edition Project in the Solution
    Explorer in Visual Studio, we get an extra InstallShield LE menu item, and in
    it, we can find an Open Release folder... option. Clicking this option will open
    a folder window showing the setup project folder, in which we can find the installation
    files to distribute to the users:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Visual Studio的解决方案资源管理器中使用并聚焦于InstallShield Limited Edition项目时，我们会得到一个额外的InstallShield
    LE菜单项，在其中我们可以找到一个打开发布文件夹...选项。点击此选项将打开一个文件夹窗口，显示设置项目文件夹，在其中我们可以找到要分发给用户的安装文件：
- en: '![](img/97985992-45c1-4fd2-9a16-e84f681117de.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97985992-45c1-4fd2-9a16-e84f681117de.png)'
- en: Utilizing ClickOnce functionality
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用ClickOnce功能
- en: ClickOnce is an application deployment technology that enables us to deploy
    applications that can be installed, run, and updated with minimal interaction
    from the end user. In fact, the name ClickOnce comes from the ideal scenario,
    where each application could be installed with a single click.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ClickOnce 是一种应用程序部署技术，它使我们能够部署那些可以通过最小化与最终用户的交互来安装、运行和更新的应用程序。实际上，ClickOnce
    这个名字来源于一个理想场景，即每个应用程序都可以通过单次点击来安装。
- en: Each ClickOnce application is deployed into its own self-contained area on the
    host computer, with no access to other applications, rather than in one of the
    standard program files folders that the other deployment technologies use. Furthermore,
    they only grant the exact security permissions required by the application and
    so, can generally also be installed by non-administrative users.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ClickOnce应用程序都会部署到主机计算机上的一个独立区域，而不是使用其他部署技术所使用的标准程序文件文件夹中。此外，它们只授予应用程序所需的精确安全权限，因此通常也可以由非管理员用户安装。
- en: Another benefit of using ClickOnce is that it enables applications to be installed
    either from a web page, a network folder, or from physical media. We can also
    specify that applications installed using ClickOnce should check for updates at
    regular periods and can be easily updated by the end user, without requiring an
    administrator to be present.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ClickOnce的另一个好处是它使应用程序可以从网页、网络文件夹或物理媒体安装。我们还可以指定使用ClickOnce安装的应用程序应定期检查更新，并且可以由最终用户轻松更新，无需管理员在场。
- en: ClickOnce deployments contain an application manifest and a deployment manifest.
    The application manifest contains details of the application, such as its dependencies,
    required security permissions, and the location where updates will be available.
    The deployment manifest contains details of the deployment, such as the location
    of the application manifest and the target version of the application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ClickOnce部署包含应用程序清单和部署清单。应用程序清单包含有关应用程序的详细信息，例如其依赖项、所需的安全权限以及更新将可用的位置。部署清单包含有关部署的详细信息，例如应用程序清单的位置和应用程序的目标版本。
- en: ClickOnce is now the preferred method of deploying applications and is built
    right into the project properties of our startup project. We can open the properties
    window by either right-clicking on the `CompanyName.ApplicationName` project in
    the Solution Explorer and selecting the Properties option, by opening the project
    node and double-clicking on the Properties item, or by selecting the project node
    and pressing the *Alt* + *Enter* keys on the keyboard together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ClickOnce 现在是部署应用程序的首选方法，并且已经直接集成到我们的启动项目属性中。我们可以通过在解决方案资源管理器中右键单击 `CompanyName.ApplicationName`
    项目并选择属性选项，通过打开项目节点并双击属性项，或者通过选择项目节点并按键盘上的 *Alt* + *Enter* 键来打开属性窗口。
- en: In the project properties window, we can find the ClickOnce configuration fields
    in the Publish tab. In this tab, we can set the location of the publishing folder
    to a network shared folder or FTP server. This represents the location that files
    will be published to. Optionally, we can also specify the location that users
    will install the application from, if that will be different.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目属性窗口中，我们可以在发布选项卡中找到ClickOnce配置字段。在这个选项卡中，我们可以设置发布文件夹的位置为网络共享文件夹或FTP服务器。这表示文件将被发布到的位置。可选地，我们还可以指定用户将从中安装应用程序的位置，如果这将是不同的。
- en: We can dictate that the installation mode should make the application available
    online only, like a web application, or offline as well, like a typical desktop
    application. In this section, we also have the Application Files button, which
    opens a dialog window where we can specify which additional files to include in
    the deployment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定安装模式应使应用程序仅在网络上可用，就像一个Web应用程序，或者也可以离线使用，就像一个典型的桌面应用程序。在此部分，我们还有“应用程序文件”按钮，点击它将打开一个对话框窗口，我们可以指定要包含在部署中的哪些附加文件。
- en: All files from the solution that currently get built into the `bin` folder will
    be included by default, but we can exclude them if we prefer. Alternatively, we
    can add new files from the Solution Explorer by setting their Build Action to
    Content in the Properties window. We can also specify whether any executable files
    are prerequisites, or whether any other file types are data files. However this
    is set for us automatically and we do not need to make changes here unless we
    have specific requirements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有当前构建到“bin”文件夹中的文件都将被包含，但如果我们愿意，我们可以排除它们。或者，我们可以通过在属性窗口中将它们的构建操作设置为“内容”来从解决方案资源管理器添加新文件。我们还可以指定任何可执行文件是否是先决条件，或者任何其他文件类型是否是数据文件。然而，这些设置会自动进行，除非我们有具体要求，否则我们不需要在此处进行更改。
- en: Next, we see the Prerequisites button, which opens a dialog window that enables
    us to create a setup program to install any prerequisite components that we may
    have, such as the .NET Framework and the Windows Installer software. If the users'
    computers do not already have the required prerequisites installed, we can specify
    where the installer should access them from. This dialog is also automatically
    populated according to the requirements of the application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到“先决条件”按钮，点击它将打开一个对话框窗口，使我们能够创建一个设置程序来安装我们可能需要的任何先决组件，例如.NET框架和Windows
    Installer软件。如果用户的计算机尚未安装所需的先决条件，我们可以指定安装程序应从何处获取它们。此对话框也会根据应用程序的要求自动填充。
- en: In order to specify that the installed applications should check for updates,
    we can tick the The application should check for updates checkbox in the dialog
    that opens after clicking the Updates button in the Publish tab. We can also specify
    whether this occurs before or after the application starts, or after a certain
    period of time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定安装的应用程序应检查更新，我们可以在“发布”选项卡中点击“更新”按钮后打开的对话框中勾选“应用程序应检查更新”复选框。我们还可以指定这是在应用程序启动之前还是之后，或者是在一定时间之后发生。
- en: In the Application Updates dialog window, we can also stipulate that the application
    should be mandatorily updated to a particular version by ticking the Specify a
    minimum required version for this application checkbox and setting the version.
    Additionally, we can specify a further location that updates can be accessed from,
    if it is different to the publish location.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在“应用程序更新”对话框窗口中，我们还可以规定应用程序必须更新到特定版本，通过勾选“为此应用程序指定最小所需版本”复选框并设置版本。此外，如果我们希望更新位置与发布位置不同，我们还可以指定一个进一步的位置来获取更新。
- en: Finally, in the Install Mode and Settings section, we come to the Options button,
    which opens the Publish Options dialog window, where we can specify details such
    as the publisher and product names, and deployment and manifest settings, and
    associate our applications with our custom file types so that it will open when
    those file types are clicked.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在“安装模式和设置”部分，我们来到了“选项”按钮，点击它将打开“发布选项”对话框窗口，在这里我们可以指定诸如出版商和产品名称、部署和清单设置等详细信息，并将我们的应用程序与自定义文件类型关联起来，以便在点击这些文件类型时打开。
- en: The Deployment options enable us to specify a web page that users can use to
    download and install our ClickOnce application from, although if we enter `default.html`,
    we can use the default page that is generated for us. We can also specify whether
    the web page should automatically open, or whether the uploaded files should be
    verified after publishing the application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 部署选项使我们能够指定一个网页，用户可以使用该网页下载和安装我们的ClickOnce应用程序，尽管如果我们输入“default.html”，我们可以使用为我们生成的默认页面。我们还可以指定网页是否应自动打开，或者是否在发布应用程序后验证上传的文件。
- en: The final section in the Publish tab is the Publish Version section, where we
    can specify the current version of the application. Rather than update this manually
    each time we publish, we can optionally tick the Automatically increment revision
    with each publish checkbox to update the revision for us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 发布选项卡中的最后一节是发布版本节，我们可以在此指定应用程序的当前版本。而不是每次发布时都手动更新，我们可以可选地勾选“每次发布自动递增修订版”复选框以自动更新修订版。
- en: In this section, we have two publishing options. The Publish Wizard button opens
    a multi-page dialog window that walks us through many of the more essential options
    described previously and ends with publishing the application. While this is useful
    for the first time that we publish the application, we tend to use the other option,
    the Publish Now button, after that, which simply publishes the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们有两种发布选项。发布向导按钮打开一个多页对话框窗口，它引导我们通过之前描述的许多更重要的选项，并以发布应用程序结束。虽然这对于我们第一次发布应用程序很有用，但我们通常在之后使用另一个选项，即“立即发布”按钮，它只是简单地发布应用程序。
- en: Securing deployments
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护部署
- en: On the Security tab of the project properties window, we can specify the security
    permissions that our application requires. To do so, we can tick the Enable ClickOnce
    security settings checkbox and select whether our application is a full or partial
    trust application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目属性窗口的安全选项卡上，我们可以指定应用程序所需的权限。为此，我们可以勾选“启用ClickOnce安全设置”复选框并选择我们的应用程序是完全信任还是部分信任应用程序。
- en: For a typical desktop application, it is common to specify that it is a full
    trust application, but otherwise we can specify just the trust level that we require.
    Note that unless the application publisher is set as a trusted publisher on the
    end user's computer, they might be required to grant any required permissions
    during installation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的桌面应用程序，通常指定它是一个完全信任的应用程序，但否则我们可以指定所需的信任级别。请注意，除非应用程序发布者被设置为最终用户计算机上的受信任发布者，否则他们可能需要在安装过程中授予任何所需的权限。
- en: If we specify that our application is a partial trust application, then we can
    either select from pre-configured zones that contain specific groups of permissions,
    or select custom permissions, in which case, we can manually specify our required
    permissions directly in the application manifest file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定我们的应用程序是部分信任应用程序，那么我们可以从包含特定权限组的预配置区域中选择，或者选择自定义权限，在这种情况下，我们可以在应用程序清单文件中直接手动指定所需的权限。
- en: Note that even if we have specified our application as a partial trust application,
    we usually have full trust when developing. In order to develop using the same
    permissions that our application requires and therefore see the same errors as
    the users, we can click the Advanced button and tick the Debug this application
    with the selected permission set checkbox.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使我们已经将我们的应用程序指定为部分信任应用程序，我们在开发时通常具有完全信任。为了使用与应用程序所需的相同权限进行开发并因此看到与用户相同的错误，我们可以点击“高级”按钮并勾选“使用所选权限集调试此应用程序”复选框。
- en: On the Signing tab of the project properties window, we can optionally digitally
    sign the ClickOnce manifests by ticking the Sign the ClickOnce manifests checkbox.
    If we have a valid certificate that has been persisted in the computer's certificate
    store, then we can select it to sign the ClickOnce manifests using the Select
    from Store button.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目属性窗口的签名选项卡上，我们可以可选地通过勾选“签名ClickOnce清单”复选框来对ClickOnce清单进行数字签名。如果我们有一个保存在计算机证书存储中的有效证书，那么我们可以通过点击“从存储选择”按钮来选择它，以使用它来签名ClickOnce清单。
- en: Alternatively, if we have a **Personal Information Exchange** (**PFX**) file,
    we can sign the manifests with it by clicking on the Select from File button and
    selecting it in the file explorer that opens. If we don't currently have a valid
    certificate, we can optionally create one for testing purposes by clicking on
    the Create Test Certificate button.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们有一个**个人信息交换**（**PFX**）文件，我们可以通过点击“从文件选择”按钮并在打开的文件资源管理器中选择它来使用它来签署清单。如果我们目前没有有效的证书，我们可以通过点击“创建测试证书”按钮来可选地创建一个用于测试目的的证书。
- en: However, note that a test certificate should not be deployed with a production
    application as they do not contain verifiable information about the publisher.
    When installing the ClickOnce application with a test certificate, users will
    be informed that the publisher cannot be verified and asked to confirm whether
    they really want to install the application. For the peace of mind of the end
    users, a real certificate should be used and a copy stored in their Trusted Publishers
    Certificate Store.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，测试证书不应该与生产应用程序一起部署，因为它们不包含关于发布者的可验证信息。当使用测试证书安装ClickOnce应用程序时，用户将被告知发布者无法验证，并要求确认他们是否真的想要安装该应用程序。为了确保最终用户安心，应使用真实证书，并将副本存储在他们的受信任发布者证书存储中。
- en: We can also optionally sign the assembly by ticking the Sign the assembly checkbox
    and selecting a **Strong Name Key** (**SNK**) file from the associated drop-down
    control. If we haven't previously selected one, we can add a new one from the
    same drop-down control.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过勾选“签名程序集”复选框并从关联的下拉控件中选择一个**强名称密钥**（**SNK**）文件来可选地签名程序集。如果我们之前没有选择一个，我们可以从同一个下拉控件中添加一个新的。
- en: This completes the summary of the configuration pages used for a ClickOnce deployment.
    They provide practically the same settings as the other deployment technologies,
    except those to do with the location of the installed files and the security permissions
    that may be required to install. Let's now look at how we can safely store files
    on the host computer in non-full trust applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了用于ClickOnce部署的配置页面的总结。它们提供了与其他部署技术几乎相同的设置，除了与已安装文件的位置和可能需要安装的安全权限有关的设置。现在让我们看看我们如何在非完全信任应用程序中安全地存储文件在宿主计算机上。
- en: Isolating storage
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离存储
- en: One of the reasons why ClickOnce can be installed directly by the end users
    without the need for administrator assistance is because it is installed into
    a self-contained ecosystem that's separate from all other programs and, in general,
    isolated from the rest of the user's computer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ClickOnce可以直接由最终用户安装而无需管理员协助的原因之一是它被安装到一个自包含的生态系统中，该生态系统与其他所有程序都分开，并且通常与用户的其余计算机隔离。
- en: When we need to store data locally, we can run into security problems if we
    have not specified our application as a full trust application. In these situations,
    we can take advantage of isolated storage, which is a data storage mechanism that
    abstracts the actual location of the data on the hard drive, which remains unknown
    to both users and developers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在本地存储数据时，如果我们没有将我们的应用程序指定为完全信任的应用程序，我们可能会遇到安全问题。在这些情况下，我们可以利用隔离存储，这是一种抽象硬盘上数据实际位置的数据存储机制，对用户和开发者来说都是未知的。
- en: When we use isolated storage, the actual data compartment where the data is
    stored is generated from some aspects of each application so that it is unique.
    The data compartment contains one or more isolated storage files called stores,
    which reference where the actual data is stored. The amount of data that can be
    stored in each store can be limited by code in the application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用隔离存储时，实际存储数据的数据隔室是由每个应用的某些方面生成的，因此它是唯一的。数据隔室包含一个或多个称为存储的隔离存储文件，它们引用实际数据存储的位置。每个存储中可以存储的数据量可以通过应用程序中的代码进行限制。
- en: 'The actual physical location of the files will differ, depending upon the operating
    system running on the user''s computer and whether the store has roaming enabled
    or not. For all operating systems since Vista, the location is in the hidden `AppData`
    folder in the user''s personal user folder. Within this folder, it will either
    be found in the `Local` or `Roaming` folders, depending on the store''s settings:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的实际物理位置将根据用户计算机上运行的操作系统以及存储是否启用了漫游而有所不同。对于自Vista以来的所有操作系统，位置在用户的个人用户文件夹中的隐藏`AppData`文件夹中。在此文件夹中，它将位于`Local`或`Roaming`文件夹中，具体取决于存储的设置：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can store any type of file in isolated storage, but as an example, let''s
    take a look at how we could utilize it to store text files. Let''s first see the
    interface that we will use:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在隔离存储中存储任何类型的文件，但作为一个例子，让我们看看我们如何利用它来存储文本文件。让我们首先看看我们将使用的界面：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And now let''s see the concrete implementation for the interface:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看接口的具体实现：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As with the other manager classes, we declare the `HardDriveManager` class in
    the `CompanyName.ApplicationName.Managers` namespace. In the private `GetIsolatedStorageFile`
    method, we obtain the `IsolatedStorageFile` object that relates to the isolated
    storage store that we will save the user's data in by calling the `GetStore` method
    of the `IsolatedStorageFile` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他管理类一样，我们在`CompanyName.ApplicationName.Managers`命名空间中声明`HardDriveManager`类。在私有的`GetIsolatedStorageFile`方法中，我们通过调用`IsolatedStorageFile`类的`GetStore`方法来获取与我们将要保存用户数据的隔离存储存储相关的`IsolatedStorageFile`对象。
- en: This method has a number of overloads that enable us to specify the scope, application
    identity, evidence, and evidence types with which to generate the unique isolated
    storage file. In this example, we use the overload that takes the bitwise combination
    of the `IsolatedStorageScope` enumeration members and the domain and assembly
    evidence types, which we simply pass `null` for.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有多个重载版本，使我们能够指定用于生成唯一隔离存储文件的范围、应用程序标识、证据和证据类型。在这个例子中，我们使用了一个重载，它接受`IsolatedStorageScope`枚举成员的位组合以及域和程序集证据类型，我们简单地传递`null`。
- en: The scope input parameter here is interesting and requires some explanation.
    Isolated storage is always restricted to the user that was logged on and using
    the application when the store was created. However, it can also be restricted
    to the identity of the assembly, or to the assembly and application domain together.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的范围输入参数很有趣，需要一些解释。隔离存储始终限制在创建存储时登录并使用应用程序的用户。然而，它也可以限制到程序集的身份，或者到程序集和应用域的组合。
- en: When we call the `GetStore` method, it obtains a store that corresponds with
    the passed input parameters. When we pass the `User` and `Assembly` `IsolatedStorageScope`
    enumeration members, this acquires a store that can be shared between applications
    that use the same assembly, when used by the same user. Typically, this is allowed
    under the Intranet security zone, but not the Internet zone.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`GetStore`方法时，它获取与传递的输入参数相对应的存储。当我们传递`User`和`Assembly``IsolatedStorageScope`枚举成员时，这会获取一个可以在相同用户使用的情况下共享同一程序集的应用程序之间的存储。通常，这在内部网络安全区域是允许的，但在互联网区域则不允许。
- en: When we pass the `User`, `Assembly`, and `Domain` `IsolatedStorageScope` enumeration
    members, this acquires a store that can only be accessed by the user, when running
    the application that was used to create the store. This is the default and most
    common choice for most applications, and so these are the enumeration members
    that were used in our example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递`User`、`Assembly`和`Domain``IsolatedStorageScope`枚举成员时，这会获取一个只能由创建存储的应用程序运行的用户访问的存储。这是大多数应用程序的默认和最常见的选择，因此这些枚举成员被用于我们的示例中。
- en: Note that if we had wanted to enable the user to use roaming profiles but still
    be able to access their data from their isolated storage file, then we could have
    additionally included the `Roaming` enumeration member with the other members.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想启用用户使用漫游配置文件但仍能从他们的隔离存储文件中访问数据，那么我们可以另外包含`Roaming`枚举成员与其他成员一起。
- en: Returning to the `HardDriveManager` class now, in the `SaveTextFile` method,
    we first call the `GetIsolatedStorageFile` method to obtain the `IsolatedStorageFile`
    object. We then initialize an `IsolatedStorageFileStream` object with the filename
    specified by the `filePath` input parameter, the `OpenOrCreate` member of the
    `FileMode` enumeration and the storage file object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`HardDriveManager`类，在`SaveTextFile`方法中，我们首先调用`GetIsolatedStorageFile`方法来获取`IsolatedStorageFile`对象。然后，我们使用由`filePath`输入参数指定的文件名、`FileMode`枚举的`OpenOrCreate`成员以及存储文件对象来初始化一个`IsolatedStorageFileStream`对象。
- en: Next, we initialize a `StreamWriter` object with the `IsolatedStorageFileStream`
    variable and write the data from the `fileContents` input parameter to the file
    specified in the stream using the `Write` method of the `StreamWriter` class.
    Again, we enclose this in a `try...catch` block and would typically log any exceptions
    that might be thrown from this method, but omit this here for brevity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`IsolatedStorageFileStream`变量初始化一个`StreamWriter`对象，并使用`StreamWriter`类的`Write`方法将`fileContents`输入参数中的数据写入流中指定的文件。同样，我们将此操作放在`try...catch`块中，通常会记录可能从这个方法抛出的任何异常，但在这里为了简洁省略了这一步骤。
- en: In the `ReadTextFile` method, we initialize the `fileContents` variable to an
    empty string and then obtain the `IsolatedStorageFile` object from the `GetIsolatedStorageFile`
    method. We verify that the file specified by the `filePath` input parameter actually
    exists before attempting to access it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ReadTextFile`方法中，我们将`fileContents`变量初始化为空字符串，然后从`GetIsolatedStorageFile`方法中获取`IsolatedStorageFile`对象。在尝试访问之前，我们验证由`filePath`输入参数指定的文件实际上是否存在。
- en: We then initialize an `IsolatedStorageFileStream` object with the filename specified
    by the `filePath` input parameter, the `Open` member of the `FileMode` enumeration,
    and the isolated storage file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`filePath`输入参数指定的文件名、`FileMode`枚举的`Open`成员以及隔离存储文件初始化一个`IsolatedStorageFileStream`对象。
- en: Next, we initialize a `StreamReader` object with the `IsolatedStorageFileStream`
    variable and read the data from the file specified in the stream into the `fileContents`
    input parameter using the `Read` method of the `StreamReader` object. Once again,
    this is all enclosed in a `try...catch` block, and finally, we return the `fileContents`
    variable with the data from the file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`IsolatedStorageFileStream`变量初始化一个`StreamReader`对象，并使用`StreamReader`对象的`Read`方法将流中指定的文件数据读取到`fileContents`输入参数中。同样，这一切都包含在一个`try...catch`块中，最后，我们返回包含文件数据的`fileContents`变量。
- en: 'In order to use it, we must first register the connection between the interface
    and our runtime implementation with our `DependencyManager` instance:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，我们必须首先使用我们的`DependencyManager`实例将接口和我们的运行时实现之间的连接注册：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we can expose a reference to the new `IHardDriveManager` interface from
    our `BaseViewModel` class and resolve it using the `DependencyManager` instance:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从我们的`BaseViewModel`类中公开对新的`IHardDriveManager`接口的引用，并使用`DependencyManager`实例解决它：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then use it to save files to, or read files from, isolated storage from
    any View Model:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用它将文件保存到隔离存储中，或从任何视图模型中读取文件。
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Realistically, if we were to save user preferences in this way, they would typically
    be in an XML file, or in another format that is more easily parsed. However, for
    the purposes of this example, a plain string will suffice.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们以这种方式保存用户偏好，它们通常会存储在一个XML文件中，或者存储在一种更容易解析的格式中。然而，为了本例的目的，一个普通的字符串就足够了。
- en: 'As well as saving and loading files in an isolated storage store, we can also
    delete them and add or remove folders to better organize the data. We can add
    further methods to our `HardDriveManager` class and `IHardDriveManager` interface to
    enable us to manipulate the files and folders from within the user''s isolated
    storage store. Let''s take a look at how we can do this now:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在隔离存储中保存和加载文件外，我们还可以删除它们，添加或删除文件夹以更好地组织数据。我们可以在`HardDriveManager`类和`IHardDriveManager`接口中添加更多方法，以便我们能够从用户的隔离存储中操作文件和文件夹。现在让我们看看我们如何做到这一点：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Quite simply, the `DeleteFile` method accesses the `IsolatedStorageFile` object
    from the `GetIsolatedStorageFile` method and then calls its `DeleteFile` method,
    passing in the name of the file to delete, which is specified by the `filePath`
    input parameter, within another `try...catch` block.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，`DeleteFile`方法通过`GetIsolatedStorageFile`方法访问`IsolatedStorageFile`对象，然后调用其`DeleteFile`方法，传入要删除的文件名称，该名称由`filePath`输入参数指定，并在另一个`try...catch`块中执行。
- en: Likewise, the `CreateFolder` method obtains the `IsolatedStorageFile` object
    from the `GetIsolatedStorageFile` method and then calls its `CreateDirectory`
    method, passing in the name of the folder to create, specified by the `folderName`
    input parameter, within a `try...catch` block.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`CreateFolder`方法通过`GetIsolatedStorageFile`方法获取`IsolatedStorageFile`对象，然后调用其`CreateDirectory`方法，传入要创建的文件夹名称，该名称由`folderName`输入参数指定，并在一个`try...catch`块中执行。
- en: Similarly, the `DeleteFolder` method acquires the `IsolatedStorageFile` object
    by calling the `GetIsolatedStorageFile` method and then calls its `DeleteDirectory`
    method, passing in the name of the folder to delete, which is specified by the
    `folderName` input parameter, within another `try...catch` block.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`DeleteFolder`方法通过调用`GetIsolatedStorageFile`方法获取`IsolatedStorageFile`对象，然后调用其`DeleteDirectory`方法，传入要删除的文件夹名称，该名称由`folderName`输入参数指定，并在另一个`try...catch`块中执行。
- en: 'Now, let''s adjust our previous example to demonstrate how we can use this
    new functionality:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调整之前的示例，以展示我们如何使用这项新功能：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this extended example, we first create a folder named `Preferences` in the
    isolated storage store and then save the text file in that folder by prefixing
    the filename with the name of the folder and separated from the name with a forward
    slash.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个扩展示例中，我们首先在隔离存储存储中创建一个名为`Preferences`的文件夹，然后通过在文件名前加上文件夹名称并用正斜杠分隔来保存该文件夹中的文本文件。
- en: At a later stage, we can then read back the contents of the file by passing
    in the same file path to the `ReadTextFile` method. If we need to clear up the
    store afterward, or if the file was temporary, we can delete it by passing the
    same file path to the `DeleteFile` method. Note that we must first delete the
    contents of a folder in the store before we can delete the folder itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后的阶段，我们可以通过将相同的文件路径传递给`ReadTextFile`方法来读取文件的全部内容。如果我们需要在之后清理存储，或者如果文件是临时的，我们可以通过将相同的文件路径传递给`DeleteFile`方法来删除它。注意，我们必须首先删除存储中文件夹的内容，然后才能删除该文件夹本身。
- en: 'Also note that we can create subdirectories in the isolated storage store by
    chaining their names in the file path. For example, we can create a `Login` folder
    in the folder named `Preferences` by simply appending the subdirectory name to
    the end of the parent folder name and separating them with a forward slash again:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们可以在隔离存储存储中通过在文件路径中链接它们的名称来创建子目录。例如，我们可以在名为`Preferences`的文件夹中创建一个`Login`文件夹，只需将子目录名称追加到父文件夹名称的末尾，并用正斜杠再次分隔即可：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This concludes our look into isolated storage files in .NET. But before we end
    this chapter, let's briefly turn our attention to discover how to access our various
    application versions and, indeed, what they all relate to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对.NET中隔离存储文件的探讨。但在结束这一章之前，让我们简要地关注一下如何访问我们的各种应用程序版本，以及它们之间到底有什么联系。
- en: Accessing application versions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问应用程序版本
- en: 'In .NET, an application has a number of different versions, and so we have
    a number of alternative ways to access them. The version number that we discussed
    earlier and is displayed in the Publish Version section of the Publish tab of
    the project properties can be found using the `ApplicationDeployment` class from
    the `System.Deployment` DLL:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，一个应用程序有多个不同的版本，因此我们有多种不同的方式来访问它们。我们之前讨论的版本号，可以在项目属性的发布选项卡中的发布版本部分找到，可以使用`System.Deployment`
    DLL中的`ApplicationDeployment`类来找到：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we need to verify that the application has actually been deployed
    before we can access the `CurrentVersion` property of the `ApplicationDeployment`
    class, otherwise an `InvalidDeploymentException` will be thrown. This means that
    we cannot attain the published version while debugging our WPF applications, and
    so we should return some other value instead in these instances.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们能够访问`ApplicationDeployment`类的`CurrentVersion`属性之前，我们需要验证应用程序实际上已经被部署，否则将抛出`InvalidDeploymentException`异常。这意味着我们无法在调试我们的WPF应用程序时获取已发布的版本，因此在这些情况下，我们应该返回其他一些值。
- en: In order to view the remaining application versions, we first need to access
    the assembly that we want to know the version of. The code that we use to access
    the assembly will depend on where in the code we currently are. For example, we
    typically want to display the version of the startup assembly, but we may want
    to access it from a View Model in the `ViewModels` project instead.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看剩余的应用程序版本，我们首先需要访问我们想要知道版本的程序集。我们用来访问程序集的代码将取决于我们在代码中的当前位置。例如，我们通常想显示启动程序集的版本，但我们可能想从`ViewModels`项目中的视图模型访问它。
- en: 'We have a number of ways of accessing assemblies, depending on where they are
    in relation to the calling code. If we want to access the startup assembly from
    the startup project, then we can use the `Assembly.GetExecutingAssembly` method
    after adding `using` statements for the following namespaces:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种方式访问程序集，这取决于它们与调用代码的相对位置。如果我们想从启动项目访问启动程序集，那么在添加以下命名空间的`using`语句后，我们可以使用`Assembly.GetExecutingAssembly`方法：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To access the same assembly from a different project, we can use the `Assembly.GetEntryAssembly`
    method. Alternatively, we can access the startup project's assembly from a different
    project (if that project was called from the startup assembly) using the `Assembly.GetCallingAssembly`
    method. For the remaining examples here, we'll use the `GetEntryAssembly` method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要从不同的项目访问相同的程序集，我们可以使用`Assembly.GetEntryAssembly`方法。或者，我们可以使用`Assembly.GetCallingAssembly`方法从不同的项目访问启动项目的程序集（如果该项目是从启动程序集调用的）。对于这里剩余的示例，我们将使用`GetEntryAssembly`方法。
- en: 'In addition to the published version, we may also need to access the application''s
    assembly or file versions. The assembly version that we can set in the Assembly
    Information dialog window, which is accessible from the Application tab of the
    project properties window, can be accessed from the assembly using the following
    code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已发布的版本外，我们可能还需要访问应用程序的组件或文件版本。我们可以在项目属性窗口的应用程序选项卡中访问的组件信息对话框中设置的组件版本，可以通过以下代码从组件中访问：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The assembly version is used by the .NET Framework to load and link references
    to other assemblies at build and runtime. This is the version that is embedded
    when adding references to our projects in Visual Studio and if an incorrect version
    is found during a build, then an error will be raised.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 组件版本由.NET Framework用于在构建和运行时加载和链接对其他组件的引用。这是在Visual Studio中将引用添加到我们的项目时嵌入的版本，如果在构建过程中发现版本不正确，则会引发错误。
- en: Note that we can also set this value using the assembly level `AssemblyVersionAttribute`
    class in the `AssemblyInfo.cs` file of the project, which can be found in the
    Properties node of the project in the Solution Explorer.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以使用项目`AssemblyInfo.cs`文件中的组件级别`AssemblyVersionAttribute`类设置此值，该文件可以在解决方案资源管理器中的项目属性节点中找到。
- en: Instead of converting the returned `Version` object to a `string` directly,
    we may prefer to access the individual components that make up the version number.
    They comprise the Major, Minor, Build, and Revision component values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接将返回的`Version`对象转换为`string`相比，我们可能更喜欢访问构成版本号的各个组件。它们包括主版本、次要版本、构建和修订版本值。
- en: 'We could then chose to just output the Major and Minor components, along with
    the product name. Here''s an example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以选择只输出主版本和次要版本，以及产品名称。以下是一个示例：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we need the file version, which is used for non-ClickOnce deployments, we
    can pass the location of the assembly to the `GetVersionInfo` method of the `FileVersionInfo`
    class, as shown in the preceding code in the product name example, but access
    the `FileVersion` property instead:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要文件版本，该版本用于非ClickOnce部署，我们可以将组件的位置传递给`FileVersionInfo`类的`GetVersionInfo`方法，如产品名称示例中所示的前面代码，但访问`FileVersion`属性：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that we can also set this value in the Assembly Information dialog window,
    or by using the assembly level `AssemblyFileVersionAttribute` class in the `AssemblyInfo.cs`
    file of the project. This version can be seen in the Details tab of the file properties
    dialog window in Windows Explorer:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以在组件信息对话框中设置此值，或者使用项目`AssemblyInfo.cs`文件中的组件级别`AssemblyFileVersionAttribute`类。此版本可以在Windows资源管理器的文件属性对话框的详细信息选项卡中看到：
- en: '![](img/4bfa08e4-bd61-4a19-b228-a56bb7bd766a.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bfa08e4-bd61-4a19-b228-a56bb7bd766a.png)'
- en: 'The product version that the assembly is distributed with can be accessed in
    a similar way:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件一起分发的产品版本可以通过类似的方式访问：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that this version can also be seen in the Details tab of the file properties
    dialog window in Windows Explorer, along with the product name that we accessed
    earlier. Also note that in a WPF application, this value typically comes from
    the assembly file version.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此版本也可以在Windows资源管理器的文件属性对话框的详细信息选项卡中看到，包括我们之前访问的产品名称。另外，请注意，在WPF应用程序中，此值通常来自组件文件版本。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored a number of different ways to deploy our WPF applications.
    We looked over the older Setup Project type and the InstallShield Limited Edition
    Project type, but focused primarily on the newer ClickOnce technology. We investigated
    how ClickOnce deployments are made and how we can safely store and access data
    in isolated storage. We ended by looking at a number of ways to access the various
    application versions available to us in .NET.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了多种部署我们的WPF应用程序的方法。我们回顾了较旧的安装项目类型和InstallShield Limited Edition项目类型，但主要关注较新的ClickOnce技术。我们研究了ClickOnce部署是如何进行的，以及我们如何在隔离存储中安全地存储和访问数据。最后，我们探讨了在.NET中访问我们可用的各种应用程序版本的方法。
- en: In the final chapter of this book, we'll take a look at a summary of what has
    been covered throughout this book and investigate what you can do next to continue
    this journey. We'll suggest a few possible ways that you could extend our application
    framework further and what you can do to advance your application development
    in general.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们将回顾本书涵盖的内容的摘要，并探讨您接下来可以做什么来继续这段旅程。我们将建议一些可能的扩展我们的应用程序框架的方法，以及您如何推进您的一般应用程序开发。
