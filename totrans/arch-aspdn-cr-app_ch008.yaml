- en: 7 Strategy, Abstract Factory, and Singleton Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 策略模式、抽象工厂模式和单例设计模式
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的Discord书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的Discord服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到，属于早期访问订阅）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file32.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file32.png)'
- en: This chapter explores object creation using a few classic, simple, and yet powerful
    design patterns from the **Gang of Four** (**GoF**). These patterns allow developers
    to encapsulate and reuse behaviors, centralize object creation, add flexibility
    to our designs, or control object lifetime. Moreover, you will most likely use
    some of them in all software you build directly or indirectly in the future.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了使用**四人帮**（**GoF**）的一些经典、简单且强大的设计模式来创建对象。这些模式允许开发者封装和重用行为，集中对象创建，增加设计的灵活性，或控制对象的生命周期。此外，你很可能会在将来直接或间接构建的所有软件中使用其中的一些。
- en: '**GoF**'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**GoF**'
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides are the authors
    of *Design Patterns: Elements of Reusable Object-Oriented Software* (1994), known
    as the **Gang of Four** (**GoF**). In that book, they introduce 23 design patterns,
    some of which we revisit in this book.'
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides是《设计模式：可复用面向对象软件元素》（1994年）的作者，该书被称为**四人帮**（**GoF**）。在这本书中，他们介绍了23种设计模式，其中一些我们在本书中重新审视。
- en: 'Why are they that important? Because they are the building blocks of robust
    object composition and help create flexibility and reliability. Moreover, in *Chapter
    8*, *Dependency Injection*, we make those patterns even more powerful!But first
    things first. In this chapter, we cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它们如此重要？因为它们是健壮对象组合的构建块，有助于创建灵活性和可靠性。此外，在**第8章**，**依赖注入**中，我们将这些模式变得更加强大！但首先，在本章中，我们将介绍以下主题：
- en: The Strategy design pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The Abstract Factory design pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式
- en: The Singleton design pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例设计模式
- en: The Strategy design pattern
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The Strategy pattern is a behavioral design pattern that allows us to change
    object behaviors at runtime. We can also use this pattern to compose complex object
    trees and rely on it to follow the **Open/Closed Principle** (**OCP**) without
    much effort. Moreover, it plays a significant role in the *composition over inheritance*
    way of thinking. In this chapter, we focus on the behavioral part of the Strategy
    pattern. The next chapter covers how to use the Strategy pattern to compose systems
    dynamically.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是一种行为设计模式，它允许我们在运行时改变对象的行为。我们还可以使用这种模式来组合复杂的对象树，并依靠它来遵循**开闭原则**（**OCP**）而无需太多努力。此外，它在**组合优于继承**的思维方式中发挥着重要作用。在本章中，我们重点关注策略模式的行为部分。下一章将介绍如何动态地使用策略模式来组合系统。
- en: Goal
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The Strategy pattern aims to extract an algorithm (a strategy) from the host
    class needing it (the context or consumer). That allows the consumer to decide
    on the strategy (algorithm) to use at runtime.For example, we could design a system
    that fetches data from two different types of databases. Then we could apply the
    same logic to that data and use the same user interface to display it. To achieve
    this, we could use the Strategy pattern to create two strategies, one named `FetchDataFromSql`
    and the other `FetchDataFromCosmosDb`. Then we could plug the strategy we need
    at runtime in the `context` class. That way, when the consumer calls the `context`,
    the `context` does not need to know where the data comes from, how it is fetched,
    or what strategy is in use; it only gets what it needs to work, delegating the
    fetching responsibility to an abstracted strategy (an interface).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的目的是从需要它的宿主类（上下文或消费者）中提取算法（策略）。这允许消费者在运行时决定使用哪种策略（算法）。例如，我们可以设计一个系统，从两种不同类型的数据库中获取数据。然后我们可以应用相同的逻辑处理这些数据，并使用相同的用户界面来显示它们。为了实现这一点，我们可以使用策略模式创建两个策略，一个命名为`FetchDataFromSql`，另一个命名为`FetchDataFromCosmosDb`。然后我们可以在运行时将所需的策略插入到`context`类中。这样，当消费者调用`context`时，`context`不需要知道数据来自哪里，如何获取，或正在使用什么策略；它只需获取它需要工作的部分，将获取数据的责任委托给一个抽象的策略（接口）。
- en: Design
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'Before any further explanation, let’s take a look at the following class diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何进一步解释之前，让我们看一下以下类图：
- en: '![Figure 7.1: Strategy pattern class diagram](img/file33.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1：策略模式类图](img/file33.png)'
- en: 'Figure 7.1: Strategy pattern class diagram'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：策略模式类图
- en: 'Based on the preceding diagram, the building blocks of the Strategy pattern
    are the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图，策略模式的构建块如下：
- en: '`Context` is a class that depends on the `IStrategy` interface and leverages
    an implementation of the `IStrategy` interface to execute the `ExecuteAlgo` method.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context` 是一个依赖于 `IStrategy` 接口并利用 `IStrategy` 接口的实现来执行 `ExecuteAlgo` 方法的类。'
- en: '`IStrategy` is an interface defining the strategy API.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IStrategy` 是定义策略 API 的接口。'
- en: '`ConcreteStrategy1` and `ConcreteStrategy2` represent one or more different
    concrete implementations of the `IStrategy` interface.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteStrategy1` 和 `ConcreteStrategy2` 代表了 `IStrategy` 接口的一个或多个不同的具体实现。'
- en: In the following diagram, we explore what happens at runtime. The actor represents
    any code consuming the `Context` object.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们探索了运行时发生的情况。演员代表任何消耗 `Context` 对象的代码。
- en: '![Figure 7.2: Strategy pattern sequence diagram](img/file34.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：策略模式序列图](img/file34.png)'
- en: 'Figure 7.2: Strategy pattern sequence diagram'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：策略模式序列图
- en: 'When the consumer calls the `Context.SomeOperation()` method, it does not know
    which implementation is executed, which is an essential part of this pattern.
    The `Context` class should not be aware of the strategy it uses either. It should
    run the strategy through the interface, unaware of the implementation. That is
    the strength of the Strategy pattern: it abstracts the implementation away from
    both the `Context` class and its consumers. Because of that, we can change the
    strategy during either the object creation or at runtime without the object knowing,
    changing its behavior on the fly.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费者调用 `Context.SomeOperation()` 方法时，它不知道执行的是哪个实现，这是此模式的一个基本部分。`Context` 类也不应该知道它使用的策略。它应该通过接口运行策略，而对实现一无所知。这就是策略模式的优势：它将实现从
    `Context` 类及其消费者中抽象出来。正因为如此，我们可以在对象创建期间或运行时更改策略，而对象不知道，可以即时改变其行为。
- en: '**Note**'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We could even generalize that last sentence and extend it to any interface.
    Depending on an interface breaks the ties between the consumer and the implementation
    by relying on that abstraction instead.
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们甚至可以将最后一句推广到任何接口。依赖于接口打破了消费者和实现之间的联系，通过依赖这个抽象来实现。
- en: Project – Strategy
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 策略
- en: '**Context**: We want to sort a collection differently, eventually even using
    different sort algorithms (out of the scope of the example but possible). Initially,
    we want to support sorting the elements of any collection in ascending or descending
    order.To achieve this, we need to implement the following building blocks:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：我们希望以不同的方式对集合进行排序，最终甚至使用不同的排序算法（示例范围之外，但可能）。最初，我们希望支持按升序或降序对任何集合的元素进行排序。为了实现这一点，我们需要实现以下构建块：'
- en: The `Context` is the `SortableCollection` class.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context` 是 `SortableCollection` 类。'
- en: The `IStrategy` is the `ISortStrategy` interface.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IStrategy` 是 `ISortStrategy` 接口。'
- en: 'The concrete strategies are:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体的策略如下：
- en: '`SortAscendingStrategy`'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SortAscendingStrategy`'
- en: '`SortDescendingStrategy`'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SortDescendingStrategy`'
- en: 'The consumer is a small REST API that allows the user to change the strategy,
    sort the collection, and display the items. Let’s start with the `ISortStrategy`
    interface:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者是一个小的 REST API，允许用户更改策略、排序集合并显示项目。让我们从 `ISortStrategy` 接口开始：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That interface contains only one method that expects a string collection as
    input and returns an ordered string collection. Now let’s inspect the two implementations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口只包含一个方法，该方法期望输入一个字符串集合并返回一个有序的字符串集合。现在让我们检查这两个实现：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both implementations are super simple, using **Language Integrated Query** (**LINQ**)
    to sort the input and return the result directly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个实现都非常简单，使用 **语言集成查询**（**LINQ**）对输入进行排序并直接返回结果。
- en: '**Tip**'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When using expression-bodied methods, please ensure you do not make the method
    harder to read for your colleagues (or future you) by creating very complex one-liners.
    Writing multiple lines often makes the code easier to read.
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在使用表达式主体方法时，请确保您不会通过创建非常复杂的单行代码使方法对同事（或未来的您）更难阅读。编写多行代码通常会使代码更容易阅读。
- en: 'The next building block to inspect is the `SortableCollection` class. It is
    composed of multiple string items (the `Items` property) and can sort them using
    an `ISortStrategy`. On top of that, it implements the `IEnumerable<string>` interface
    through its `Items` property, making it iterable. Here’s the class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要检查的构建块是 `SortableCollection` 类。它由多个字符串项目（`Items` 属性）组成，可以使用 `ISortStrategy`
    对它们进行排序。在此基础上，它通过其 `Items` 属性实现了 `IEnumerable<string>` 接口，使其可迭代。以下是该类的代码：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `SortableCollection` class is the most complex one so far, so let’s take
    a more in-depth look:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortableCollection` 类是目前最复杂的一个，所以让我们更深入地了解一下：'
- en: 'The `_sortStrategy` field references the algorithm: an `ISortStrategy` implementation.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_sortStrategy` 字段引用了算法：一个 `ISortStrategy` 实现。'
- en: The `_items` field references the strings themselves.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_items` 字段引用了字符串本身。'
- en: The `Items` property exposes the strings to the consumers of the class.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Items` 属性将字符串暴露给类的消费者。'
- en: The constructor initializes the `Items` property using the `items` parameter
    and sets the default sorting strategy.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数使用 `items` 参数初始化 `Items` 属性，并设置默认的排序策略。
- en: The `SetSortStrategy` method allows consumers to change the strategy at runtime.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetSortStrategy` 方法允许消费者在运行时更改策略。'
- en: The `Sort` method uses the `_sortStrategy` field to sort the items.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sort` 方法使用 `_sortStrategy` 字段对项目进行排序。'
- en: The two `GetEnumerator` methods represent the implementation of the `IEnumerable<string>`
    interface and make the class enumerable through the `Items` property.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 `GetEnumerator` 方法代表了 `IEnumerable<string>` 接口的实现，并通过 `Items` 属性使类可枚举。
- en: With that code, we can see the Strategy pattern in action. The `_sortStrategy`
    field represents the current algorithm, respecting an `ISortStrategy` contract,
    which is updatable at runtime using the `SetSortStrategy` method. The `Sort` method
    delegates the work to the `ISortStrategy` implementation (the concrete strategy).
    Therefore, changing the value of the `_sortStrategy` field leads to a change of
    behavior of the `Sort` method, making this pattern very powerful yet simple. The
    highlighted code represents this pattern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们可以看到策略模式的作用。`_sortStrategy` 字段代表了当前的算法，遵守 `ISortStrategy` 合同，可以通过 `SetSortStrategy`
    方法在运行时更新。`Sort` 方法将工作委托给 `ISortStrategy` 实现（具体策略）。因此，更改 `_sortStrategy` 字段的值会导致
    `Sort` 方法的行为改变，使这个模式非常强大且简单。高亮显示的代码代表了这种模式。
- en: The `_items` field is an `ImmutableArray<string>`, which makes changing the
    list impossible from the outside. For example, a consumer cannot pass a `List<string>`
    to the constructor, then change it later. Immutability has many advantages.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`_items` 字段是一个 `ImmutableArray<string>`，这使得从外部更改列表变得不可能。例如，消费者不能将 `List<string>`
    传递给构造函数，然后稍后更改它。不可变性有许多优点。'
- en: 'Let’s experiment with this by looking at the `Consumer.API` project a REST
    API application that uses the previous code. Next is a breakdown of the `Program.cs`
    file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看 `Consumer.API` 项目来实验一下，这是一个使用之前代码的 REST API 应用程序。接下来是 `Program.cs` 文件的分解：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `data` member is the context, our sortable collection of items. Next, we
    look at some boilerplate code to create the application and serialize `enum` values
    as strings:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 成员是上下文，我们的可排序项目集合。接下来，我们看看创建应用程序和将 `enum` 值序列化为字符串的一些样板代码：'
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, the last part represents the consumer of the context:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一部分代表上下文的消费者：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we declared the following endpoints:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了以下端点：
- en: The first endpoint returns the `data` object when a client sends a `GET` request.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端发送 `GET` 请求时，第一个端点返回 `data` 对象。
- en: The second endpoint allows changing the sort strategy based on the `SortOrder`
    enum when a client sends a **PUT** request. Once the strategy is modified, it
    sorts the collection and returns the sorted data.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个端点允许在客户端发送 **PUT** 请求时根据 `SortOrder` 枚举更改排序策略。一旦策略被修改，它就会对集合进行排序并返回排序后的数据。
- en: The highlighted code represents the consumption of this implementation of the
    strategy pattern.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的代码代表了策略模式的实现。
- en: The `ReplaceSortStrategy` class is an input DTO. Combined with the `SortOrder`
    enum, they represent the data contract of the second endpoint.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ReplaceSortStrategy` 类是一个输入 DTO。与 `SortOrder` 枚举结合使用，它们代表了第二个端点的数据合约。'
- en: 'When we run the API and request the first endpoint, it responds with the following
    JSON body:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 API 并请求第一个端点时，它响应以下 JSON 主体：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, the items are in the order we set them because the code never
    called the `Sort` method. Next, let’s send the following HTTP request to the API
    to change the sort strategy to “descending”:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，项目按照我们设置的顺序排列，因为代码从未调用 `Sort` 方法。接下来，让我们向 API 发送以下 HTTP 请求以更改排序策略为“降序”：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After the execution, the endpoint responds with the following JSON data:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，端点响应以下 JSON 数据：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see from the content, the sorting algorithm worked. Afterward, the
    list will remain in the same order if we query the GET endpoint. Next, let’s look
    at this use case using a sequence diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从内容中我们可以看出，排序算法是有效的。之后，如果我们查询 GET 端点，列表将保持相同的顺序。接下来，让我们通过序列图来查看这个用例：
- en: '![Figure 7.3: Sequence diagram sorting the items using the “sort descending
    strategy”](img/file35.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3：使用“降序排序策略”对项目进行排序的序列图](img/file35.png)'
- en: 'Figure 7.3: Sequence diagram sorting the items using the “sort descending strategy”'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：使用“降序排序策略”对项目进行排序的序列图
- en: The preceding diagram shows the `Program` creating a strategy and assigning
    it to `SortableCollection` using its `SetSortStrategy` method. Then, when the
    `Program` calls the `Sort()` method, the `SortableCollection` instance delegates
    the sorting computation to the underlying implementation of the `ISortStrategy`
    interface. That implementation is the `SortDescendingStrategy` class (the **strategy**)
    which was set by the `Program` at the beginning.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了 `Program` 使用其 `SetSortStrategy` 方法创建一个策略并将其分配给 `SortableCollection`。然后，当
    `Program` 调用 `Sort()` 方法时，`SortableCollection` 实例将排序计算委派给 `ISortStrategy` 接口的底层实现。该实现是
    `SortDescendingStrategy` 类（即 **策略**），这是 `Program` 在开始时设置的。
- en: Sending another `PUT` request but specifying the `Ascending` sort order end
    up in a similar result, but the items would be sorted alphabetically.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 发送另一个 `PUT` 请求，但指定 `Ascending` 排序顺序，结果相似，但项目将按字母顺序排序。
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The HTTP requests are available in the `Consumer.API.http` file.
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HTTP 请求在 `Consumer.API.http` 文件中可用。
- en: From a strategy pattern perspective, the `SortableCollection` class (the **context**)
    is responsible for referencing and using the current strategy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从策略模式的角度来看，`SortableCollection` 类（即 **上下文**）负责引用和使用当前策略。
- en: Conclusion
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Strategy design pattern is very effective at delegating responsibilities
    to other objects, allowing you to hand over the responsibility of an algorithm
    to other objects while keeping its usage trivial. It also allows having a rich
    interface (context) with behaviors that can change at runtime.As we can see, the
    Strategy pattern is excellent at helping us follow the **SOLID** principles:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式在委派责任给其他对象方面非常有效，允许你在保持使用简单的同时，将算法的责任转交给其他对象。它还允许拥有一个丰富的接口（上下文），其行为可以在运行时改变。正如我们所见，策略模式在帮助我们遵循
    **SOLID** 原则方面表现出色：
- en: '**S**: It helps extract responsibilities from external classes and use them
    interchangeably.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：它有助于从外部类中提取责任，并可以互换使用。'
- en: '**O**: It allows extending classes without updating its code by changing the
    current strategy at runtime, which is pretty much the actual definition of the
    OCP.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：它允许在运行时通过更改当前策略来扩展类，而不需要更新其代码，这几乎就是 OCP 的实际定义。'
- en: '**L**: It does not rely on inheritance. Moreover, it plays a large role in
    the *composition over inheritance principle*, helping us avoid inheritance altogether
    and the LSP.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：它不依赖于继承。此外，它在 *组合优于继承原则* 中扮演着重要角色，帮助我们避免完全使用继承和 LSP。'
- en: '**I**: By creating smaller strategies based on lean and focused interfaces,
    the Strategy pattern is an excellent enabler of the ISP.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：通过创建基于精简和专注接口的小型策略，策略模式是 ISP 的优秀推动者。'
- en: '**D**: The creation of dependencies is moved from the class using the strategy
    (the context) to the class’s consumer. That makes the context depend on abstraction
    instead of implementation, inverting the flow of control.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：依赖关系的创建从使用策略（上下文）的类移动到类的消费者。这使得上下文依赖于抽象而不是实现，反转了控制流。'
- en: '**C# Features**'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**C# 特性**'
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you noticed C# features you are less familiar with, *Appendix A* explains
    many of them briefly.
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你注意到了你不太熟悉的 C# 特性，*附录 A* 简要解释了许多它们。
- en: Next, let’s explore the Abstract Factory pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索抽象工厂模式。
- en: The Abstract Factory design pattern
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式
- en: The Abstract Factory design pattern is a creational design pattern from the
    GoF. We use creational patterns to create other objects, and factories are a very
    popular way of doing that.The Strategy pattern is the backbone of dependency injection,
    enabling the composition of complex object trees, while factories are used to
    create some of those complex objects that can’t be assembled automatically by
    a dependency injection library. More on that in the next chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式是 GoF 中的一个创建型设计模式。我们使用创建型模式来创建其他对象，而工厂是做这件事的一种非常流行的方式。策略模式是依赖注入的骨干，它使得复杂对象树的组合成为可能，而工厂用于创建一些依赖注入库无法自动组装的复杂对象。关于这一点，将在下一章中详细介绍。
- en: Goal
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The Abstract Factory pattern is used to abstract the creation of a family of
    objects. It usually implies the creation of multiple object types within that
    family. A family is a group of related or dependent objects (classes).Let’s think
    about creating automotive vehicles. There are multiple vehicle types, and there
    are multiple models and makes for each type. We can use the Abstract Factory pattern
    to model this sort of scenario.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式用于抽象一组对象的创建。它通常意味着在该系列中创建多个对象类型。一个系列是一组相关或依赖的对象（类）。让我们考虑创建汽车车辆。有多种车辆类型，每种类型都有多种型号和品牌。我们可以使用抽象工厂模式来模拟这种场景。
- en: '**Note**'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The *Factory Method* pattern also focuses on creating a single type of object
    instead of a family. We only cover Abstract Factory here, but we use other types
    of factories later in the book.
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`工厂方法` 模式也侧重于创建单一类型的对象，而不是一个系列。我们在这里只介绍抽象工厂，但在本书的后面部分我们将使用其他类型的工厂。'
- en: Design
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'With Abstract Factory, the consumer asks for an abstract object and gets one.
    The factory is an abstraction, and the resulting objects are also abstractions,
    decoupling the creation of an object from its consumers.That allows adding or
    removing families of objects produced together without impacting the consumers
    (all actors communicate through abstractions).In our case, the family (the set
    of objects the factory can produce) is composed of a car and a bike, and each
    factory (family) must produce both objects.If we think about vehicles, we could
    have the ability to create low- and high-end models of each vehicle type. Here
    is a diagram representing how to achieve that using the Abstract Factory pattern:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象工厂模式，消费者请求一个抽象对象并得到一个。工厂是一个抽象，产生的对象也是抽象的，将对象的创建与其消费者解耦。这允许在不影响消费者的情况下添加或删除一起产生的对象系列（所有参与者都通过抽象进行通信）。在我们的例子中，这个系列（工厂可以生产的对象集合）由一辆汽车和一辆自行车组成，每个工厂（系列）必须生产这两个对象。如果我们考虑车辆，我们可能有能力创建每种车辆类型的低端和高端型号。以下是使用抽象工厂模式实现这一点的示意图：
- en: '![Figure 7.4: Abstract Factory class diagram](img/file36.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：抽象工厂类图](img/file36.png)'
- en: 'Figure 7.4: Abstract Factory class diagram'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：抽象工厂类图
- en: 'In the diagram, we have the following elements:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们有以下元素：
- en: 'The `IVehicleFactory` interface represents the Abstract Factory. It defines
    two methods: one that creates cars of type `ICar` and another that creates bikes
    of type `IBike`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IVehicleFactory` 接口代表抽象工厂。它定义了两个方法：一个用于创建 `ICar` 类型的汽车，另一个用于创建 `IBike` 类型的自行车。'
- en: The `HighEndVehicleFactory` class is a concrete factory implementing the `IVehicleFactory`
    interface. It handles high-end vehicle model creation, and its methods return
    `HighEndCar` or `HighEndBike` instances.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HighEndVehicleFactory` 类是一个实现了 `IVehicleFactory` 接口的具体工厂。它处理高端车辆型号的创建，并且其方法返回
    `HighEndCar` 或 `HighEndBike` 实例。'
- en: The `LowEndVehicleFactory` is a second concrete factory implementing the `IVehicleFactory`
    interface. It handles low-end vehicle model creation, and its methods return `LowEndCar`
    or `LowEndBike` instances.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowEndVehicleFactory` 是一个实现了 `IVehicleFactory` 接口的第二个具体工厂。它处理低端车辆型号的创建，并且其方法返回
    `LowEndCar` 或 `LowEndBike` 实例。'
- en: '`LowEndCar` and `HighEndCar` are two implementations of `ICar`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowEndCar` 和 `HighEndCar` 是 `ICar` 的两种实现。'
- en: '`LowEndBike` and `HighEndBike` are two implementations of `IBike`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowEndBike` 和 `HighEndBike` 是 `IBike` 的两种实现。'
- en: Based on that diagram, consumers use the concrete factories through the `IVehicleFactory`
    interface and should not be aware of the implementation used underneath. Applying
    this pattern abstracts away the vehicle creation process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据该图，消费者通过 `IVehicleFactory` 接口使用具体工厂，并且不应该意识到底层使用的实现。应用此模式抽象了车辆创建过程。
- en: Project – Abstract Factory
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 - 抽象工厂
- en: '**Context**: We need to support the creation of multiple models of vehicles.
    We also need to be able to add new models as they become available without impacting
    the system. To begin with, we only support high-end and low-end models, but we
    know this will change sooner rather than later. The program must only support
    the creation of cars and bikes.For the sake of our demo, the vehicles are just
    empty classes and interfaces because learning how to model vehicles is not necessary
    to understand the pattern; that would be noise. The following code represents
    those entities:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：我们需要支持创建多种车型。我们还需要能够在车型可用时添加新模型，而不会影响系统。起初，我们只支持高端和低端车型，但我们知道这迟早会改变。程序必须只支持创建汽车和自行车。为了我们的演示，车辆只是空的类和接口，因为学习如何建模车辆不是理解该模式所必需的；那将是噪音。以下代码代表这些实体：'
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we look at the part that we want to study—the factories:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看我们想要研究的部分——工厂：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The factories are simple implementations that describe the pattern well:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工厂是简单的实现，很好地描述了该模式：
- en: '`LowEndVehicleFactory` creates low-end models.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowEndVehicleFactory` 创建低端车型。'
- en: '`HighEndVehicleFactory` creates high-end models.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HighEndVehicleFactory` 创建高端车型。'
- en: 'The consumer of this code is an xUnit test project. Unit tests are often your
    first consumers, especially if you are doing **test-driven development** (**TDD**).To
    make the tests easier, I created the following base test class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的消费者是一个 xUnit 测试项目。单元测试通常是你的第一个消费者，特别是如果你在做 **测试驱动开发**（**TDD**）。为了使测试更容易，我创建了以下基类测试：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The key to that class is the following generic parameters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的关键是以下泛型参数：
- en: The `TConcreteFactory` parameter represents the type of concrete factory we
    want to test. Its generic constraint specifies that it must implement the `IVehicleFactory`
    interface and have a parameterless constructor.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TConcreteFactory` 泛型参数代表我们想要测试的具体工厂的类型。它的泛型约束指定它必须实现 `IVehicleFactory` 接口并且有一个无参构造函数。'
- en: The `TExpectedCar` parameter represents the type of `ICar` we expect from the
    `CreateCar` method.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TExpectedCar` 泛型参数代表我们从 `CreateCar` 方法期望的 `ICar` 类型。'
- en: The `TExpectedBike` parameter represents the type of `IBike` we expect from
    the `CreateBike` method.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TExpectedBike` 泛型参数代表我们从 `CreateBike` 方法期望的 `IBike` 类型。'
- en: 'The first test method contained by that class is the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含的第一个测试方法是以下内容：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding test method creates a vehicle factory using the TConcreteFactory
    generic parameter, then creates a car using that factory. Finally, it asserts
    ICar instance is of the expected type.The second test method contains by that
    class is the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试方法使用 `TConcreteFactory` 泛型参数创建一个车辆工厂，然后使用该工厂创建一辆车。最后，它断言 `ICar` 实例是期望的类型。第二个测试方法包含以下内容：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding test method is very similar and creates a vehicle factory using
    the `TConcreteFactory` generic parameter but then creates a bike instead of a
    car using that factory. Finally, it asserts `IBike` instance is of the expected
    type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试方法非常相似，使用 `TConcreteFactory` 泛型参数创建一个车辆工厂，但然后用该工厂创建一辆自行车而不是汽车。最后，它断言 `IBike`
    实例是期望的类型。
- en: I used the `ICar` and `IBike` interfaces to type the variables instead of `var`,
    to clarify the `result` variable type. In another context, I would have used `var`
    instead. The same applies to the `IVehicleFactory` interface.
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我使用 `ICar` 和 `IBike` 接口来对变量进行类型化，而不是 `var`，以明确 `result` 变量的类型。在另一个上下文中，我会使用
    `var`。同样适用于 `IVehicleFactory` 接口。
- en: 'Now, to test the low-end factory, we declare the following test class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试低端工厂，我们声明以下测试类：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That class solely depends on the `BaseAbstractFactoryTest` class and specifies
    the types to test for (highlighted).Next, to test the high-end factory, we declare
    the following test class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该类仅依赖于 `BaseAbstractFactoryTest` 类并指定了要测试的类型（高亮显示）。接下来，为了测试高端工厂，我们声明以下测试类：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Like the low-end factory, that class depends on the `BaseAbstractFactoryTest`
    class and specifies the types to test for (highlighted).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与低端工厂类似，该类依赖于 `BaseAbstractFactoryTest` 类并指定了要测试的类型（高亮显示）。
- en: In a more complex scenario where we can’t use the `new()` generic constraint,
    we can leverage an IoC container to create the instance of `TConcreteFactory`
    and optionally mock its dependencies.
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在更复杂的场景中，如果我们不能使用 `new()` 泛型约束，我们可以利用 IoC 容器来创建 `TConcreteFactory` 的实例，并可选地模拟其依赖项。
- en: 'With that test code, we created the following two sets of two tests:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用那段测试代码，我们创建了以下两组两个测试：
- en: A `LowEndVehicleFactory` class that should create a `LowEndCar` instance.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应该创建 `LowEndCar` 实例的 `LowEndVehicleFactory` 类。
- en: A `LowEndVehicleFactory` class that should create a `LowEndBike` instance.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应该创建 `LowEndBike` 实例的 `LowEndVehicleFactory` 类。
- en: A `HighEndVehicleFactory` class that should create a `HighEndCar` instance.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应该创建 `HighEndCar` 实例的 `HighEndVehicleFactory` 类。
- en: A `HighEndVehicleFactory` class that should create a `HighEndBike` instance.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应该创建 `HighEndBike` 实例的 `HighEndVehicleFactory` 类。
- en: 'We now have four tests: two for bikes and two for cars.If we review the tests’
    execution, both test methods are unaware of types. They use the Abstract Factory
    (`IVehicleFactory`) and test the `result` against the expected type without knowing
    what they are testing but the abstraction. That shows how loosely coupled the
    consumers (tests) and the factories are.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有四个测试：两个针对自行车，两个针对汽车。如果我们回顾测试的执行情况，两个测试方法都不了解类型。它们使用抽象工厂（`IVehicleFactory`）并测试
    `result` 是否符合预期类型，而不了解它们正在测试什么，只知道抽象。这显示了消费者（测试）和工厂之间的耦合是多么松散。
- en: We would use the `ICar` or the `IBike` instances in a real-world program to
    do something relevant based on the specifications. That could be a racing game
    or a rich person’s garage management system; who knows!
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在现实世界的程序中，我们会使用 `ICar` 或 `IBike` 实例根据规格执行相关操作。这可能是一个赛车游戏或富人的车库管理系统；谁知道呢！
- en: The important part of this project is **the abstraction of the object creation
    process**. The test code (consumer) is not aware of the implementations.Next,
    we extend our implementation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的关键部分是**对象创建过程的抽象化**。测试代码（消费者）并不了解实现。接下来，我们扩展我们的实现。
- en: Project – The mid-range vehicle factory
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 中端车辆工厂
- en: 'To prove the flexibility of our design based on the Abstract Factory pattern,
    let’s add a new concrete factory named `MidRangeVehicleFactory`. That factory
    should return a `MidRangeCar` or a `MidRangeBike` instance. Once again, the car
    and bike are just empty classes (of course, in your programs, they will do something):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们基于抽象工厂模式的设计的灵活性，让我们添加一个新的具体工厂，命名为 `MidRangeVehicleFactory`。该工厂应返回一个 `MidRangeCar`
    或 `MidRangeBike` 实例。再次强调，汽车和自行车只是空的类（当然，在你的程序中，它们将执行某些操作）：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The new `MidRangeVehicleFactory` looks pretty much the same as the other two:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `MidRangeVehicleFactory` 看起来几乎与另外两个相同：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, to test the mid-range factory, we declare the following test class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试中端工厂，我们声明以下测试类：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Like the low-end and high-end factories, the mid-range test class depends on
    the `BaseAbstractFactoryTest` class and specifies the types to test for (highlighted).If
    we run the tests, we now have the following six passing tests:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像低端和高端工厂一样，中端测试类依赖于 `BaseAbstractFactoryTest` 类，并指定要测试的类型（突出显示）。如果我们运行测试，我们现在有以下六个通过测试：
- en: '![Figure 7.5: Visual Studio Test Explorer showcasing the six passing tests.](img/file37.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5：Visual Studio 测试资源管理器展示了六个通过测试。](img/file37.png)'
- en: 'Figure 7.5: Visual Studio Test Explorer showcasing the six passing tests.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：Visual Studio 测试资源管理器展示了六个通过测试。
- en: So, without updating the consumer (the `AbstractFactoryTest` class), we added
    a new family of vehicles, the middle-end cars and bikes; kudos to the Abstract
    Factory pattern for that wonderfulness!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在未更新消费者（`AbstractFactoryTest` 类）的情况下，我们添加了一个新的车辆系列，即中端汽车和自行车；感谢抽象工厂模式为我们带来了这样的奇妙功能！
- en: Impacts of the Abstract Factory
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象工厂的影响
- en: 'Before concluding, what would happen if we packed everything in a large interface
    instead of using an Abstract Factory (breaking the ISP along the way)? We could
    have created something like the following interface:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在结论之前，如果我们不是使用抽象工厂（在过程中破坏了 ISP）而是将所有内容打包到一个大接口中，会发生什么？我们可以创建以下类似接口：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we can see, the preceding interface contains four specific methods and seems
    docile. However, the consumers of that code would be tightly coupled with those
    specific methods. For example, to change a consumer''s behavior, we’d need to
    update its code, like changing the call from `CreateHighEndBike` to `CreateLowEndBike`,
    which breaks the OCP. On the other hand, with the factory method, we can set a
    different factory for the consumers to spit out different results, which moves
    the flexibility out of the object itself and becomes a matter of composing the
    object graph instead (more on that in the next chapter).Moreover, when we want
    to add mid-range vehicles, we must update the `ILargeVehicleFactory` interface,
    which becomes a breaking change (the implementation(s) of the `ILargeVehicleFactory`
    must be updated). Here’s an example of the two new methods:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，前面的接口包含四个具体方法，看起来很温和。然而，该代码的消费者将与这些具体方法紧密耦合。例如，要改变消费者行为，我们需要更新其代码，比如将调用从`CreateHighEndBike`更改为`CreateLowEndBike`，这打破了OCP。另一方面，使用工厂方法，我们可以为消费者设置不同的工厂以产生不同的结果，这把灵活性从对象本身移出，变成了对象图组合的问题（更多内容将在下一章中讨论）。此外，当我们想添加中端车辆时，我们必须更新`ILargeVehicleFactory`接口，这变成了一个破坏性变更（`ILargeVehicleFactory`的实现必须更新）。以下是一个两个新方法的示例：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From there, once the implementation(s) are updated, if we want to consume the
    new mid-range vehicles, we need to open each consumer class and apply the changes
    there, which once again breaks the OCP.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，一旦实现更新，如果我们想消费新的中端车辆，我们需要打开每个消费者类并应用那里的更改，这再次打破了OCP。
- en: The most crucial part is understanding and seeing the coupling and its impacts.
    Sometimes, it's okay to tightly couple one or more classes together as we don’t
    always need the added flexibility the SOLID principles and some design patterns
    can bring.
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最关键的部分是理解和看到耦合及其影响。有时，将一个或多个类紧密耦合在一起是可以接受的，因为我们并不总是需要SOLID原则和一些设计模式所能带来的额外灵活性。
- en: Now let’s conclude before exploring the last design pattern of the chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索本章的最后一个设计模式之前，让我们先总结一下。
- en: Conclusion
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Abstract Factory pattern is excellent for abstracting away the creation
    of object families, isolating each family and its concrete implementation, leaving
    the consumers unaware of the family created at runtime by the factory.We talk
    more about factories in the next chapter; meanwhile, let’s see how the Abstract
    Factory pattern can help us follow the **SOLID** principles:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式非常适合抽象对象家族的创建，隔离每个家族及其具体实现，使消费者对工厂在运行时创建的家族一无所知。我们将在下一章中更多地讨论工厂；同时，让我们看看抽象工厂模式如何帮助我们遵循**SOLID**原则：
- en: '**S**: Each concrete factory is solely responsible for creating a family of
    objects. You could combine Abstract Factory with other creational patterns, such
    as the **Prototype** and **Builder** patterns for more complex creational needs.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 每个具体工厂只负责创建一组对象。您可以将抽象工厂与其他创建型模式结合使用，例如原型模式和建造者模式，以满足更复杂的创建需求。'
- en: '**O**: We can create new families of objects, like the mid-range vehicles,
    without breaking existing client code.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 我们可以创建新的对象家族，如中端车辆，而不会破坏现有的客户端代码。'
- en: '**L**: We aim at composition, so there’s no need for any inheritance, implicitly
    discarding the need for the LSP. If you use abstract classes in your design, you
    must ensure you don’t break the LSP when creating new abstract factories.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: 我们的目标是组合，因此不需要任何继承，这隐含地摒弃了LSP的需求。如果你在设计中使用抽象类，你必须确保在创建新的抽象工厂时不要破坏LSP。'
- en: '**I**: Extracting a small abstraction with many implementations where each
    concrete factory focuses on one family makes that interface very focused on one
    task instead of having a large interface that exposes all types of products (like
    the `ILargeVehicleFactory` interface).'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 从具有许多实现的抽象中提取一个小抽象，其中每个具体工厂专注于一个家族，这使得该接口非常专注于一项任务，而不是拥有一个暴露所有类型产品的庞大接口（如`ILargeVehicleFactory`接口）。'
- en: '**D**: By depending only on interfaces, the consumer is unaware of the concrete
    types it uses.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 通过仅依赖于接口，消费者对其使用的具体类型一无所知。'
- en: Next, we explore the last design pattern of the chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索本章的最后一个设计模式。
- en: The Singleton design pattern
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例设计模式
- en: 'The Singleton design pattern allows creating and reusing a single instance
    of a class. We could use a static class to achieve almost the same goal, but not
    everything is doable using static classes. For example, a static class can’t implement
    an interface. We can’t pass an instance of a static class as an argument because
    there is no instance. We can only use static classes directly, which leads to
    tight coupling every time.The Singleton pattern in C# is an anti-pattern, and
    we should rarely use it, if ever, and use dependency injection instead. That said,
    it is a classic design pattern worth learning to at least avoid implementing it.
    We explore a better alternative in the next chapter.Here are a few reasons why
    we are covering this pattern:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计模式允许创建和重用类的单个实例。我们可以使用静态类来实现几乎相同的目标，但不是所有事情都可以使用静态类完成。例如，静态类不能实现接口。我们不能将静态类的实例作为参数传递，因为没有实例。我们只能直接使用静态类，这每次都会导致紧密耦合。在C#中，单例模式是一个反模式，我们应该很少使用它，如果必须使用，则使用依赖注入代替。话虽如此，它是一个值得学习的经典设计模式，至少可以避免实现它。我们将在下一章探索一个更好的替代方案。以下是为什么我们要介绍这个模式的一些原因：
- en: It translates into a singleton scope in the next chapter.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将在下一章中转化为单例范围。
- en: Without knowing about it, you cannot locate it, try to remove it, or avoid its
    usage.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你知道它的存在，否则你无法定位它，尝试删除它或避免使用它。
- en: It is a simple pattern to explore.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个简单的模式可以探索。
- en: It leads to other patterns, such as the **Ambient Context** pattern.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导致其他模式，例如**环境上下文**模式。
- en: Goal
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The Singleton pattern limits the number of instances of a class to one. Then,
    the idea is to reuse the same instance subsequently. A singleton encapsulates
    both the object logic itself and its creational logic. For example, the Singleton
    pattern could lower the cost of instantiating an object with a large memory footprint
    since the program instantiates it only once.Can you think of a SOLID principle
    that gets broken right there?The Singleton pattern promotes that one object must
    have two responsibilities, breaking the **Single Responsibility Principle** (**SRP**).
    A singleton is the object itself and its own factory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式限制一个类的实例数量为单个。然后，想法是随后重用相同的实例。单例封装了对象逻辑本身及其创建逻辑。例如，单例模式可以降低实例化具有大内存占用对象的成本，因为程序只实例化一次。你能想到一个在这里被破坏的
    SOLID 原则吗？单例模式提倡一个对象必须有两个职责，这违反了**单一职责原则**（**SRP**）。单例既是对象本身也是它自己的工厂。
- en: Design
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'This design pattern is straightforward and is limited to a single class. Let’s
    start with a class diagram:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式很简单，仅限于一个类。让我们从类图开始：
- en: '![Figure 7.6: Singleton pattern class diagram](img/file38.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：单例模式类图](img/file38.png)'
- en: 'Figure 7.6: Singleton pattern class diagram'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：单例模式类图
- en: 'The `Singleton` class is composed of the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Singleton` 类由以下部分组成：'
- en: A private static field that holds its unique instance.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个私有静态字段，用于保存其唯一的实例。
- en: A public static `Create()` method that creates or returns the unique instance.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公共静态 `Create()` 方法，用于创建或返回唯一的实例。
- en: A private constructor, so external code cannot instantiate it without passing
    by the `Create` method.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个私有构造函数，因此外部代码不能通过 `Create` 方法之外的方式实例化它。
- en: You can name the `Create()` method anything or even get rid of it, as we see
    in the next example. We could name it `GetInstance()`, or it could be a static
    property named `Instance` or bear any other relevant name.
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以给 `Create()` 方法命名，甚至可以去掉它，就像我们在下一个例子中看到的那样。我们可以将其命名为 `GetInstance()`，或者它可以是名为
    `Instance` 的静态属性，或者可以有任何其他相关的名称。
- en: 'We can translate the preceding diagram to the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的图转换为以下代码：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The null-coalescing assignment operator `??=` assigns the new instance of `MySingleton`
    only if the `_instance` member is `null`. That line is equivalent to writing the
    following if statement:'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 空合并赋值运算符 `??=` 仅在 `_instance` 成员为 `null` 时才分配 `MySingleton` 的新实例。这一行等同于编写以下
    if 语句：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before discussing the code more, let’s explore our new class''s behavior. We
    can see in the following unit test that `MySingleton.Create()` always returns
    the same instance as expected:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在更深入讨论代码之前，让我们探索我们新类的行为。我们可以在以下单元测试中看到，`MySingleton.Create()` 总是返回预期的相同实例：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And voilà! We have a working Singleton pattern, which is extremely simple—probably
    the most simple design pattern that I can think of.Here is what is happening under
    the hood:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们得到了一个工作的单例模式，它极其简单——可能是我能想到的最简单的设计模式。以下是底层发生的事情：
- en: The first time that a consumer calls `MySingleton.Create()`, it creates the
    first instance of `MySingleton`. Since the constructor is `private`, it can only
    be created from the inside.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当消费者第一次调用`MySingleton.Create()`时，它创建了`MySingleton`的第一个实例。由于构造函数是`private`的，它只能从内部创建。
- en: The `Create` method then persists that first instance to the `_instance` field
    for future use.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后`Create`方法将第一个实例持久化到`_instance`字段，以供将来使用。
- en: When a consumer calls `MySingleton.Create()` a second time, it returns the `_instance`
    field, reusing the class's previous (and only) instance.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当消费者第二次调用`MySingleton.Create()`时，它返回`_instance`字段，重新使用类的先前（也是唯一）的实例。
- en: 'Now that we understand the logic, there is a potential issue with that design:
    it is not thread-safe. If we want our singleton to be thread-safe, we can `lock`
    the instance creation like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了逻辑，该设计存在一个潜在的问题：它不是线程安全的。如果我们想让我们的单例是线程安全的，我们可以像这样`锁定`实例创建：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we ensure two threads are not attempting to access the
    `Create` method simultaneously to ensure they are not getting different instances.
    Next, we improve our thread-safe example by making it shorter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们确保两个线程不会同时尝试访问`Create`方法，以确保它们不会得到不同的实例。接下来，我们通过缩短代码来改进我们的线程安全示例。
- en: An alternate (better) way
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种（更好的）方法
- en: 'Previously, we used the “long way” of implementing the Singleton pattern and
    had to implement a thread-safe mechanism. Now that classic is behind us. We can
    shorten that code and even get rid of the `Create()` method like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们使用实现单例模式的“长方法”，并不得不实现一个线程安全的机制。现在，那个经典的方法已经过去了。我们可以缩短代码，甚至可以像这样移除`Create()`方法：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code relies on the static initializer to ensure that only one
    instance of the `MySimpleSingleton` class is created and assigned to the `Instance`
    property.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码依赖于静态初始化器来确保只创建一个`MySimpleSingleton`类的实例，并将其分配给`Instance`属性。
- en: This simple technique should do the trick unless the singleton's constructor
    executes some heavy processing.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种简单的技术应该可以解决问题，除非单例的构造函数执行了一些重量级的处理。
- en: 'With the property instead of a method, we can use the singleton class like
    this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性而不是方法，我们可以这样使用单例类：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can prove the correctness of that claim by executing the following test
    method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下测试方法来证明这个说法的正确性：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is usually best to delegate responsibilities to the language or the framework
    whenever possible like we did here with the property initializer. Using a static
    constructor would also be a valid, thread-safe alternative, once again delegating
    the job to language features.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好是在可能的情况下将责任委托给语言或框架，就像我们在这里使用属性初始化器所做的那样。使用静态构造函数也是一个有效且线程安全的替代方案，再次将任务委托给语言特性。
- en: '**Beware of the arrow operator.**'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**小心箭头操作符。**'
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It may be tempting to use the arrow operator `=>` to initialize the `Instance`
    property like this: `public static MySimpleSingleton Instance => new MySimpleSingleton();`,
    but doing so would return a new instance every time. This would defeat the purpose
    of what we want to achieve. On the other hand, the property initializer runs only
    once.'
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能会诱使您使用箭头操作符`=>`来初始化`Instance`属性，如下所示：`public static MySimpleSingleton Instance
    => new MySimpleSingleton();`，但这样做会每次都返回一个新的实例。这将违背我们想要实现的目的。另一方面，属性初始化器只运行一次。
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The arrow operator makes the `Instance` property an expression-bodied member,
    equivalent to creating the following getter: `get { return new MySimpleSingleton();
    }`. You can consult *Appendix A* for more information about expression-bodies
    statements.'
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 箭头操作符使`Instance`属性成为一个表达式成员，相当于创建以下获取器：`get { return new MySimpleSingleton();
    }`。您可以查阅*附录A*了解更多关于表达式体语句的信息。
- en: Before we conclude the chapter, the Singleton (anti-)pattern also leads to a
    code smell.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，单例（反）模式也导致代码异味。
- en: Code smell – Ambient Context
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码异味 - 环境上下文
- en: 'That last implementation of the **Singleton** pattern led us to the **Ambient
    Context** pattern. We could even call the Ambient Context an anti-pattern, but
    let’s just state that it is a consequential code smell.I do not recommend using
    ambient contexts for multiple reasons. First, I do my best to avoid anything global;
    an ambient context is a global state. Globals, like static members in C#, can
    look very convenient because they are easy to access and use. They are always
    there and accessible whenever needed: easy. However, they bring many drawbacks
    in terms of flexibility and testability.When using an ambient context, the following
    occurs:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 那次对**单例**模式的实现让我们转向了**环境上下文**模式。我们甚至可以称环境上下文为反模式，但让我们只是指出它是一个有后果的代码异味。我不建议使用环境上下文，有多个原因。首先，我尽力避免任何全局的东西；环境上下文是一种全局状态。全局变量，如C#中的静态成员，看起来非常方便，因为它们易于访问和使用。它们总是存在，并且无论何时需要都可以访问：方便。然而，它们在灵活性和可测试性方面带来了许多缺点。在使用环境上下文时，以下情况会发生：
- en: '**Tight coupling**: global states lead to less flexible systems; consumers
    are tightly coupled with the ambient context.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密耦合**：全局状态导致系统灵活性降低；消费者与环境上下文紧密耦合。'
- en: '**Testing difficulty**: global objects are harder to replace, and we cannot
    easily swap them for other objects, like a mock.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试难度**：全局对象更难替换，我们无法轻易地用其他对象（如模拟对象）替换它们。'
- en: '**Unforseen impacts**: if some part of your system messes up your global state,
    that may have unexpected consequences on other parts of your system, and you may
    have difficulty finding out the root cause of those errors.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可预见的影响**：如果系统的一部分破坏了你的全局状态，这可能会对系统的其他部分产生意外的后果，并且你可能难以找出这些错误的根本原因。'
- en: '**Potential misuse**: developers could be tempted to add non-global concerns
    to the ambient context, leading to a bloated component.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在误用**：开发者可能会被诱惑将非全局关注点添加到环境上下文中，从而导致组件膨胀。'
- en: '**Fun fact**'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**有趣的事实**'
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Many years ago, before the JavaScript frameworks era, I fixed a bug in a system
    where some function was overriding the value of `undefined` due to a subtle error.
    This is an excellent example of how global variables could impact your whole system
    and make it more brittle. The same applies to the Ambient Context and Singleton
    patterns in C#; globals can be dangerous and annoying.
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 多年前，在JavaScript框架时代之前，我修复了一个系统中的错误，其中一个函数由于一个微小的错误而覆盖了`undefined`的值。这是一个很好的例子，说明了全局变量如何影响你的整个系统，并使其更加脆弱。同样，这也适用于C#中的环境上下文和单例模式；全局变量可能是危险的并且令人烦恼。
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rest assured that, nowadays, browsers won’t let developers update the value
    of `undefined`, but it was possible back then.
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请放心，如今，浏览器不会让开发者更新`undefined`的值，但那时是可能的。
- en: Now that we’ve discussed global objects, an ambient context is a global instance,
    usually available through a static property. The Ambient Context pattern can bring
    good things, but it is a code smell that smells bad.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了全局对象，环境上下文是一个全局实例，通常通过静态属性提供。环境上下文模式可以带来好处，但它是一个令人不快的代码异味。
- en: There are a few examples in .NET Framework, such as `System.Threading.Thread.CurrentPrincipal`
    and `System.Threading.Thread.CurrentThread`, that are scoped to a thread instead
    of being purely global like most static members. An ambient context does not have
    to be a singleton, but that is what they are most of the time. Creating a non-global
    (scoped) ambient context is harder and requires more work.
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在.NET Framework中，有一些例子，如`System.Threading.Thread.CurrentPrincipal`和`System.Threading.Thread.CurrentThread`，它们的范围是线程级别的，而不是像大多数静态成员那样纯粹是全局的。环境上下文不一定是单例，但大多数情况下它们是单例。创建非全局（线程级别）的环境上下文更困难，需要更多的工作。
- en: 'Is the Ambient Context pattern good or bad? I’d go with both! It is useful
    primarily because of its convenience and ease of use. Most of the time, it could
    and should be designed differently to reduce its drawbacks.There are many ways
    of implementing an ambient context, but to keep it brief and straightforward,
    we are focusing only on the singleton version of the ambient context. The following
    code is a good example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 环境上下文模式是好是坏？我会两者都接受！它之所以有用，主要是因为它的便利性和易用性。大多数情况下，它可以通过不同的设计来减少其缺点。实现环境上下文的方法有很多，但为了简洁明了，我们只关注环境上下文的单例版本。以下代码是一个很好的例子：
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That code is an exact copy of the `MySimpleSingleton` class, with a few subtle
    changes:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码是`MySimpleSingleton`类的精确副本，只有一些细微的变化：
- en: '`Instance` is named `Current`.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Instance`被命名为`Current`。'
- en: The `WriteSomething` method is new but has nothing to do with the Ambient Context
    pattern itself; it is just to make the class do something.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteSomething`方法虽然新，但与Ambient Context模式本身无关；它只是让类做些事情。'
- en: 'If we take a look at the test method that follows, we can see that we use the
    ambient context by calling `MyAmbientContext.Current`, just like we did with the
    last singleton implementation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看接下来的测试方法，我们可以看到我们通过调用`MyAmbientContext.Current`使用了环境上下文，就像我们在上一个单例实现中所做的那样：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The property could include a public setter or support more complex logic. Building
    the right classes and exposing the right behaviors is up to you and your specifications.To
    conclude this interlude, avoid ambient contexts and use instantiable classes instead.
    We see how to replace a singleton with a single instance of a class using dependency
    injection in the next chapter. That gives us a more flexible alternative to the
    Singleton pattern. We can also create a single instance per HTTP request, which
    saves us the trouble of coding it while eliminating the disadvantages.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可能包括一个公共设置器或支持更复杂的逻辑。构建正确的类和暴露正确的行为取决于你和你自己的规范。为了结束这个插曲，避免使用环境上下文，并使用可实例化的类。我们将在下一章中看到如何使用依赖注入来替换单例，这为我们提供了一个比单例模式更灵活的替代方案。我们还可以为每个HTTP请求创建一个单例实例，这既节省了我们编写代码的麻烦，又消除了其缺点。
- en: Conclusion
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Singleton pattern allows the creation of a single instance of a class for
    the whole lifetime of the program. It leverages a `private static` field and a
    `private` constructor to achieve its goal, exposing the instantiation through
    a `public static` method or property. We can use a field initializer, the `Create`
    method itself, a static constructor, or any other valid C# options to encapsulate
    the initialization logic.Now let’s see how the Singleton pattern can help us (not)
    follow the SOLID principles:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式允许在整个程序生命周期中创建一个类的单个实例。它利用一个`private static`字段和一个`private`构造函数来实现其目标，通过一个`public
    static`方法或属性来暴露实例化。我们可以使用字段初始化器、`Create`方法本身、静态构造函数或任何其他有效的C#选项来封装初始化逻辑。现在让我们看看单例模式如何帮助我们（或不）遵循SOLID原则：
- en: '**S**: The singleton violates this principle because it has two clear responsibilities:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 单例违反了这个原则，因为它有两个明显的责任：'
- en: It has the responsibility for which it has been created (not illustrated here),
    like any other class.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它承担了它被创建的责任（此处未展示），就像任何其他类一样。
- en: It has the responsibility of creating and managing itself (lifetime management).
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它承担了创建和管理自己的责任（生命周期管理）。
- en: '**O**: The Singleton pattern also violates this principle. It enforces a single
    static instance, locked in place by itself, which limits extensibility. It is
    impossible to extend the class without changing its code.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 单例模式也违反了这个原则。它强制执行一个单一的静态实例，由自己锁定在位置上，这限制了可扩展性。在不改变其代码的情况下，无法扩展这个类。'
- en: '**L**: There is no inheritance directly involved, which is the only good point.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: 没有直接涉及继承，这是唯一的优点。'
- en: '**I**: No C# interface is involved, which violates this principle. However,
    we can look at the class interface instead, so building a small targeted singleton
    instance would satisfy this principle.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 没有涉及C#接口，这违反了这个原则。然而，我们可以看看类接口，这样构建一个小型的目标单例实例就会满足这个原则。'
- en: '**D**: The singleton class has a rock-solid hold on itself. It also suggests
    using its static property (or method) directly without using an abstraction, breaking
    the DIP with a sledgehammer.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 单例类对自己有坚如磐石的控制。它还建议直接使用其静态属性（或方法），而不使用抽象，用大锤打破DIP原则。'
- en: 'As you can see, the Singleton pattern violates all the SOLID principles but
    the LSP and should be used cautiously. Having only a single instance of a class
    and always using that same instance is a common concept. However, we explore more
    proper ways to do this in the next chapter, leading me to the following advice:
    do not use the Singleton pattern, and if you see it used somewhere, try refactoring
    it out.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，单例模式违反了所有SOLID原则，除了LSP，应该谨慎使用。一个类只有一个实例，并且总是使用这个相同的实例是一个常见的概念。然而，我们在下一章中会探讨更合适的方法来做这件事，这让我得出以下建议：不要使用单例模式，如果你看到它被使用，尝试重构它。
- en: I suggest avoiding static members that create global states as a general good
    practice. They can make your system less flexible and more brittle. There are
    occasions where `static` members are worth using, but try keeping their number
    as low as possible. Ask yourself if you can replace that `static` member or class
    with something else before coding one.
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我建议避免创建全局状态的静态成员，这是一个通用的良好实践。它们可以使您的系统更不灵活且更脆弱。在某些情况下，`static`成员是值得使用的，但尽量将它们的数量保持在最低。在编码之前，问问自己是否可以用其他东西替换那个`static`成员或类。
- en: 'Some may argue that the Singleton design pattern is a legitimate way of doing
    things. However, in ASP.NET Core, I am afraid I have to disagree: we have a powerful
    mechanism to do it differently, called dependency injection. When using other
    technologies, maybe, but not with modern .NET.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论，单例设计模式是做事的合法方式。然而，在ASP.NET Core中，我恐怕不得不表示不同意：我们有一个强大的机制来做不同的事情，称为依赖注入。当使用其他技术时，也许可以，但不是在现代化的.NET中。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored our first GoF design patterns. These patterns
    expose some of the essential basics of software engineering, not necessarily the
    patterns themselves, but the concepts behind them:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了我们的第一个GoF设计模式。这些模式揭示了软件工程的一些基本概念，不一定是指模式本身，而是它们背后的概念：
- en: The Strategy pattern is a behavioral pattern that we use to compose most of
    our future classes. It allows swapping behavior at runtime by composing an object
    with small pieces and coding against interfaces, following the SOLID principles.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式是我们用来组合我们未来大多数类的行为模式。它允许通过组合小对象和针对接口进行编码，在运行时交换行为，遵循SOLID原则。
- en: The Abstract Factory pattern brings the idea of abstracting away object creation,
    leading to a better separation of concerns. More specifically, it aims to abstract
    the creation of object families and follow the SOLID principles.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式带来了抽象对象创建的想法，从而实现了关注点的更好分离。更具体地说，它旨在抽象对象系列的创建并遵循SOLID原则。
- en: Even if we defined it as an anti-pattern, the Singleton pattern brings the application-level
    objects to the table. It allows the creation of a single instance of an object
    that lives for the whole lifetime of a program. The pattern violates most SOLID
    principles.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们将它定义为反模式，单例模式也将应用程序级别的对象带到桌面上。它允许创建一个在整个程序生命周期中存在的对象的单个实例。该模式违反了大多数SOLID原则。
- en: We also peeked at the Ambient Context code smell, which is used to create an
    omnipresent entity accessible from everywhere. It is often implemented as a singleton
    and brings a global state object to the program.The next chapter explores how
    dependency injection helps us compose complex yet maintainable systems. We also
    revisit the Strategy, the Factory, and the Singleton patterns to see how to use
    them in a dependency-injection-oriented context and how powerful they really are.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了环境上下文代码异味，它用于创建一个无处不在的实体，可以从任何地方访问。它通常实现为单例，并将全局状态对象带到程序中。下一章将探讨依赖注入如何帮助我们构建复杂且可维护的系统。我们还回顾了策略、工厂和单例模式，看看如何在依赖注入导向的上下文中使用它们，以及它们实际上有多强大。
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习问题：
- en: Why is the Strategy pattern a behavioral pattern?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么策略模式是一个行为模式？
- en: How could we define the goal of the creational patterns?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何定义创建型模式的目标？
- en: If I write the code `public MyType MyProp => new MyType();`, and I call the
    property twice (`var v1 = MyProp; var v2 = MyProp;`), are `v1` and `v2` the same
    instance or two different instances?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我编写了代码 `public MyType MyProp => new MyType();`，并且我两次调用该属性（`var v1 = MyProp;
    var v2 = MyProp;`），`v1` 和 `v2` 是同一个实例还是两个不同的实例？
- en: Is it true that the Abstract Factory pattern allows us to add new families of
    elements without modifying the existing consuming code?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象工厂模式是否允许我们在不修改现有消费代码的情况下添加新元素系列？
- en: Why is the Singleton pattern an anti-pattern?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么单例模式是一个反模式？
- en: Answers
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: It helps manage behaviors at runtime, such as changing an algorithm in the middle
    of a running program.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它有助于在运行时管理行为，例如在程序运行过程中更改算法。
- en: The creational patterns are responsible for creating objects.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建型模式负责创建对象。
- en: '`v1` and `v2` are two different instances. The code on the right-hand side
    of the arrow operator is executed every time you call the property’s getter.'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`v1` 和 `v2` 是两个不同的实例。箭头操作符右侧的代码每次调用属性的getter时都会执行。'
- en: Yes, it is true. That’s the primary goal of the pattern, as we demonstrated
    in the `MidRangeVehicleFactory` code sample.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，这是该模式的主要目标，正如我们在`MidRangeVehicleFactory`代码示例中所展示的。
- en: The Singleton pattern violates the SOLID principles and encourages using global
    (static) state objects. We can avoid this pattern most of the time.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单例模式违反了SOLID原则，并鼓励使用全局（静态）状态对象。我们大多数情况下都可以避免使用这种模式。
