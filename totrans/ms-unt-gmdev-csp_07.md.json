["```cs\nnamespace FusionFuryGame\n{\n    public interface IHealth\n    {\n        float MaxHealth { get; set; }   // Property for maximum health\n        float CurrentHealth { get; set; }  // Property for current health\n        void TakeDamage(float damage);  // Method to apply damage\n        void SetMaxHealth();  // Method to set current health to max health\n        void Heal();            // Method to apply healing\n    }\n}\n```", "```cs\nnamespace FusionFuryGame\n{\n    public interface IDamage\n    {\n        float GetDamageValue();  // Method to retrieve the damage value\n    }\n}\n```", "```cs\nnamespace FusionFuryGame\n{\n    public class PlayerHealth : MonoBehaviour, IHealth\n    {\n        public static UnityAction onPlayerDied = delegate { };\n        public float startingMaxHealth = 100;  // Set a default starting maximum health for the player\n        public float healInterval = 2f;  // Time interval for healing\n        public float healAmount = 5f;    // Amount of healing per interval\n        private WaitForSeconds healIntervalWait;  // Reusable WaitForSeconds instance\n        private Coroutine healOverTimeCoroutine;\n        public float MaxHealth { get; set; }\n        public float CurrentHealth { get; set; }\n```", "```cs\n        void OnDestroy()\n        {\n            // Ensure to stop the healing coroutine when the object is destroyed\n            if (healOverTimeCoroutine != null)\n                StopCoroutine(healOverTimeCoroutine);\n        }\n        void Start()\n        {\n            SetMaxHealth();  // Set initial max health\n            healIntervalWait = new WaitForSeconds(healInterval);\n            StartHealingOverTime();\n        }\n```", "```cs\n        public void TakeDamage(float damage)\n        {\n            // Implement logic to handle taking damage\n            CurrentHealth -= damage;\n            // Check for death or other actions based on health status\n            if (CurrentHealth <= 0) onPlayerDied.Invoke();\n        }\n        public void SetMaxHealth()\n        {\n            MaxHealth = startingMaxHealth;\n        }\n        public void Heal()\n        {\n            CurrentHealth += healAmount;\n            CurrentHealth = Mathf.Min(CurrentHealth, MaxHealth);\n        }\n        private void StartHealingOverTime()\n        {\n            healOverTimeCoroutine = StartCoroutine(HealOverTime());\n        }\n        private IEnumerator HealOverTime()\n        {\n            while (true)\n            {\n                yield return healIntervalWait;\n                Heal();\n            }\n        }\n    }\n}\n```", "```cs\nnamespace FusionFuryGame\n{\n    public class PlayerCollision : MonoBehaviour\n    {\n        private PlayerHealth playerHealth;\n        private IDamage enemyDamage;\n        private void Start()\n        {\n            playerHealth = GetComponent<PlayerHealth>();\n        }\n        private void OnCollisionEnter(Collision collision)\n        {\n            if (collision.gameObject.CompareTag(\"Enemy\") || collision.gameObject.CompareTag(\"EnemyProjectile\"))\n            {\n                if (collision.gameObject.TryGetComponent(out enemyDamage))\n                {\n                    playerHealth.TakeDamage(enemyDamage.GetDamageValue());\n                }\n            }\n        }\n    }\n}\n```", "```cs\nnamespace FusionFuryGame\n{\n    public abstract class BaseProjectile : MonoBehaviour, IDamage\n    {\n        private float damage;\n        public virtual void SetDamageValue(float value)\n        {\n            damage = value;\n        }\n        public float GetDamageValue()\n        {\n            return damage;\n        }\n    }\n}\n```", "```cs\nnamespace FusionFuryGame\n{\n    public abstract class BaseWeapon : MonoBehaviour\n    {\n        [SerializeField] protected BaseProjectile attachedProjectile;\n        [SerializeField] protected float weaponPower;\n        [SerializeField] protected Transform muzzleTransform;\n        [SerializeField] protected float projectileForce;\n        public virtual void Shoot( float fireDamage)\n        {\n          // Instantiate the projectile from the object pool\n          GameObject projectileObject = ObjectPoolManager.Instance.GetPooledObject(attachedProjectile.tag);\n          if (projectileObject != null)\n          {\n            // Set the position of the projectile to the gun's muzzle position\n            projectileObject.transform.position = muzzleTransform.position;\n            // Get the rigid body component from the projectile\n            Rigidbody projectileRb = projectileObject.GetComponent<Rigidbody>();\n            if (projectileRb != null)\n            {\n               // Apply force to the projectile in the forward vector of the weapon\n               projectileRb.AddForce(muzzleTransform.forward * projectileForce, ForceMode.Impulse);\n               // Modify the fire damage by adding the current weapon's power\n               float modifiedDamage = fireDamage + weaponPower;\n               // Apply damage and other logic to the projectile (consider implementing IDamage interface)\n               attachedProjectile.SetDamageValue(modifiedDamage);\n            }\n            else\n            {\n               // Handle if the projectile doesn't have a rigid body\n               Debug.LogWarning(\"Projectile prefab is missing Rigidbody component.\");\n            }\n          }\n        }\n    }\n}\n```", "```cs\nnamespace FusionFuryGame\n{\n    public class SimpleGun : BaseWeapon\n    {\n        public override void Shoot( float fireDamage)\n        {\n            base.Shoot( fireDamage );\n            //Add here special logic for the gun if needed\n        }\n    }\n}\n```", "```cs\nnamespace FusionFuryGame {\n    public class PlayerShoot : MonoBehaviour\n    {\n        public static UnityAction onFire = delegate { };\n        [SerializeField] BaseWeapon currentWeapon;\n        [SerializeField] private float fireDamage;\n        [SerializeField] private float shootingInterval = 0.5f;  // Set the shooting interval in seconds\n        private float timeSinceLastShot = 0f;\n        private void Update()\n        {\n            timeSinceLastShot += Time.deltaTime;\n        }\n        private void OnEnable()\n        {\n            PlayerInput.onShoot += OnShootFire;\n        }\n        private void OnDisable()\n        {\n            PlayerInput.onShoot -= OnShootFire;\n        }\n        private void OnShootFire()\n        {\n            // Check if enough time has passed since the last shot\n            if (timeSinceLastShot >= shootingInterval)\n            {\n                // Shoot in the forward vector of the weapon and pass player power stat\n                currentWeapon.Shoot(fireDamage);\n                // Reset the timer\n                timeSinceLastShot = 0f;\n                // Invoke the onFire event\n                onFire.Invoke();\n            }\n        }\n    }\n}\n```", "```cs\nnamespace FusionFuryGame\n{\n    public interface IEnemyState\n    {\n        void EnterState(BaseEnemy enemy);\n        void UpdateState(BaseEnemy enemy);\n        void ExitState(BaseEnemy enemy);\n    }\n}\n```", "```cs\n    public class EnemyHealth : MonoBehaviour, IHealth\n    {\n        [SerializeField] float startingMaxHealth = 100;  // Set a default starting maximum health for the Enemy\n        private float maxHealth;\n        private float currentHealth;\n        [SerializeField] float healAmount = 5f;    // Amount of healing per interval\n        [SerializeField] float healInterval = 2f;  // Time interval for healing\n        private WaitForSeconds healIntervalWait;  // Reusable WaitForSeconds instance\n        private Coroutine healOverTimeCoroutine;\n        public UnityAction onEnemyDied = delegate { };\n        public float MaxHealth\n        {\n            get { return maxHealth; }\n            set { maxHealth = value; }\n        }\n        public float CurrentHealth\n        {\n            get { return currentHealth; }\n            set\n            {\n                currentHealth = Mathf.Clamp(value, 0, MaxHealth);\n                if (currentHealth <= 0)\n                {\n                    onEnemyDied.Invoke();\n                }\n            }\n        }\n        private void Start()\n        {\n            SetMaxHealth();  // Set initial max health\n            healIntervalWait = new WaitForSeconds(healInterval);\n            StartHealingOverTime();\n        }\n        public void SetMaxHealth()\n        {\n            MaxHealth = startingMaxHealth;\n        }\n        public void TakeDamage(float damage)\n        {\n            // Implement logic to handle taking damage\n            CurrentHealth -= damage;\n        }\n        //we can also just heal in some states only\n        public void Heal()\n        {\n            CurrentHealth += healAmount;\n            CurrentHealth = Mathf.Min(CurrentHealth, MaxHealth);\n        }\n        private void StartHealingOverTime()\n        {\n            healOverTimeCoroutine = StartCoroutine(HealOverTime());\n        }\n        private IEnumerator HealOverTime()\n        {\n            while (true)\n            {\n                yield return healIntervalWait;\n                Heal();\n            }\n        }\n    }\n```", "```cs\n  public class EnemyAnimations : MonoBehaviour\n  {\n      private Animator animator;\n      private void Start()\n      {\n          animator = GetComponent<Animator>();\n      }\n      public void StartAttackAnimations()\n      {\n          animator.SetBool(\"IsAttacking\", true);\n      }\n      public void StopAttackAnimations()\n      {\n          animator.SetBool(\"IsAttacking\", false);\n      }\n  }\n```", "```cs\n    public class EnemyCollision : MonoBehaviour\n    {\n        private IDamage playerDamage;\n        private EnemyHealth healthComponent;\n        private void Start()\n        {\n            healthComponent = GetComponent<EnemyHealth>();\n        }\n        //we can also make layers for them and reduce calculations of collision in layer matrix in project settings\n        private void OnCollisionEnter(Collision collision)\n        {\n            if (collision.gameObject.CompareTag(\"PlayerProjectile\"))\n            {\n                if (collision.gameObject.TryGetComponent(out playerDamage))\n                {\n                    healthComponent.TakeDamage(playerDamage.GetDamageValue());\n                }\n            }\n        }\n    }\n```", "```cs\n    public class EnemyShoot : MonoBehaviour , IDamage\n    {\n        [SerializeField] float damage; //when the enemy collide with the player\n        public BaseWeapon attachedWeapon;  // Reference to the attacted Weapon\n        [SerializeField] float fireDamage; //when the enemy shoot the player\n        public void FireProjectile()\n        {\n            attachedWeapon.Shoot(fireDamage);\n        }\n        public float GetDamageValue()\n        {\n            // You can implement more sophisticated logic here based on enemy stats\n            return damage;\n        }\n    }\n```", "```cs\n[RequireComponent(typeof(EnemyHealth) , typeof(EnemyAnimations) , typeof(EnemyShoot)) ]\n    [RequireComponent(typeof(EnemyCollision))]\n    public abstract class BaseEnemy : MonoBehaviour\n    {\n        public Transform player;\n        [HideInInspector] public NavMeshAgent navMeshAgent;\n        // Reference to the current state\n        protected IEnemyState currentState;\n        // Define the different states\n        public IEnemyState wanderState;\n        public IEnemyState idleState;\n        public IEnemyState attackState;\n        public IEnemyState deathState;\n        public IEnemyState chaseState;\n        public float attackRange = 5f;\n        [SerializeField] internal float chaseSpeed;\n        [SerializeField] internal float rotationSpeed;\n        internal EnemyAnimations animationComponent;\n        internal EnemyShoot shootComponent;\n        internal EnemyHealth healthComponent;\n        protected virtual void Start()\n        {\n            // Initialize states\n            wanderState = new WanderState();\n            idleState = new IdleState();\n            attackState = new AttackState();\n            chaseState = new ChaseState();\n            deathState = new DeathState();\n            // Set initial state\n            currentState = wanderState;\n            // Get references\n            player = GameObject.FindGameObjectWithTag(\"Player\").transform;\n            navMeshAgent = GetComponent<NavMeshAgent>();\n            animationComponent = GetComponent<EnemyAnimations>();\n            shootComponent = GetComponent<EnemyShoot>();\n            healthComponent = GetComponent<EnemyHealth>();\n            healthComponent.onEnemyDied += OnDied;\n        }\n        protected virtual void Update()\n        {\n            // Update the current state\n            currentState.UpdateState(this);\n        }\n```", "```cs\n        public bool PlayerInSight()\n        {\n            Vector3 directionToPlayer = player.position - transform.position;\n            float distanceToPlayer = directionToPlayer.magnitude;\n            // Create a ray from the enemy's position towards the player\n            Ray ray = new Ray(transform.position, directionToPlayer.normalized);\n            RaycastHit hit;\n            // Check if the ray hits something\n            if (Physics.Raycast(ray, out hit, distanceToPlayer))\n            {\n                // Check if the hit object is the player\n                if (hit.collider.CompareTag(\"Player\"))\n                {\n                    // The player is in sight\n                    return true;\n                }\n            }\n            // No direct line of sight to the player\n            return false;\n        }\n        public bool PlayerInRange()\n        {\n            Vector3 directionToPlayer = player.position - transform.position;\n            float distanceToPlayer = directionToPlayer.magnitude;\n            // Check if the player is within the attack range\n            if (distanceToPlayer <= attackRange)\n            {\n                // Calculate the angle between the enemy's forward direction and the direction to the player\n                float angleToPlayer = Vector3.Angle(transform.forward, directionToPlayer.normalized);\n                // Set a cone angle to define the attack range\n                float attackConeAngle = 45f; // Adjust this value based on your game's requirements\n                // Check if the player is within the cone angle\n                if (angleToPlayer <= attackConeAngle * 0.5f)\n                {\n                    // The player is in range and within the attack cone\n                    return true;\n                }\n            }\n            // Player is not within attack range or cone angle\n            return false;\n        }\n        public bool IsIdleConditionMet()\n        {\n            return !PlayerInSight() && !PlayerInRange();\n        }\n        public void TransitionToState(IEnemyState newState)\n        {\n            currentState?.ExitState(this);\n            currentState = newState;\n            currentState?.EnterState(this);\n        }\n           private void OnDied()\n        {\n            healthComponent.onEnemyDied -= OnDied;\n            // Trigger death logic if health reaches zero\n            TransitionToState(deathState);\n        }\n    }\n```", "```cs\n   public class IdleState : IEnemyState\n    {\n        private float idleTime = 3f; // Set the duration for which the enemy stays idle\n        private float timer; // Timer to track the idle time\n        public void EnterState(BaseEnemy enemy)\n        {\n            timer = 0f;\n        }\n        public void ExitState(BaseEnemy enemy)\n        {\n            //Logic for Exit\n        }\n        public void UpdateState(BaseEnemy enemy)\n        {\n            // Logic to be executed while in the idle state\n            timer += Time.deltaTime;\n            if (timer >= idleTime)\n            {\n                enemy.TransitionToState(enemy.wanderState);\n            }\n            else if (enemy.PlayerInSight())\n            {\n                enemy.TransitionToState(enemy.chaseState);\n            }\n            else if (enemy.PlayerInRange())\n            {\n                enemy.TransitionToState(enemy.attackState);\n            }\n        }\n    }\n```", "```cs\n    public class AttackState : IEnemyState\n    {\n        private float attackTimer;  // Timer to control the attack rate\n        private float timeBetweenAttacks = 1.5f;  // Adjust as needed based on your game's requirements\n        public void EnterState(BaseEnemy enemy)\n        {\n            enemy.animationsComponent.StartAttackAnimations();\n            attackTimer = 0f;\n        }\n        public void UpdateState(BaseEnemy enemy)\n        {\n            LookAtPlayer(enemy);\n            attackTimer += Time.deltaTime;\n            if (attackTimer >= timeBetweenAttacks)\n            {\n                AttackPlayer(enemy);\n                attackTimer = 0f;  // Reset the timer after attacking\n            }\n        }\n        public void ExitState(BaseEnemy enemy)\n        {\n            enemy.animationsComponent.StopAttackAnimations();\n        }\n        private void LookAtPlayer(BaseEnemy enemy)\n        {\n            Vector3 lookDirection = enemy.player.position - enemy.transform.position;\n            lookDirection.y = 0;  // Keep the enemy's rotation in the horizontal plane\n            Quaternion rotation = Quaternion.LookRotation(lookDirection);\n            enemy.transform.rotation = Quaternion.Slerp(enemy.transform.rotation, rotation, Time.deltaTime * enemy.rotationSpeed);\n        }\n        private void AttackPlayer(BaseEnemy enemy)\n        {\n            enemy.shootComponent.FireProjectile();\n        }\n    }\n```", "```cs\n[Serializable]\n public class CommonChallengeData\n {\n     public bool isCompleted;\n     public RewardType rewardType; // Type of reward\n     public int rewardAmount;      // Amount or value of the reward\n     … other challenge Data\n }\n```", "```cs\npublic abstract class BaseChallenge : MonoBehaviour\n {\n     public CommonChallengeData commonData;\n     public abstract void StartChallenge();\n     public abstract void CompleteChallenge();\n }\n```", "```cs\n    public class ChallengeManager : Singleton<ChallengeManager>\n    {\n        // Define different types of challenges\n        public enum ChallengeType\n        {\n            EnemyWaves,\n            TimeTrials,\n            LimitedResources,\n            NoDamageRun,\n            AccuracyChallenge\n        }\n        public GenericDictionary<ChallengeType, BaseChallenge> challengeDictionary = new GenericDictionary<ChallengeType, BaseChallenge>();\n        public void StartChallenge(ChallengeType challengeType)\n        {\n            if (challengeDictionary.TryGetValue(challengeType, out BaseChallenge challengeScript))\n            {\n                if (!challengeScript.commonData.isCompleted)\n                {\n                    SetCurrentChallenge(challengeScript);\n                    currentChallenge.StartChallenge();\n                }\n                else\n                {\n                    Debug.Log(\"Challenge already completed!\");\n                }\n            }\n            else\n            {\n                Debug.LogError($\"No challenge script found for ChallengeType {challengeType}\");\n            }\n        }\n        private BaseChallenge currentChallenge;\n        private void SetCurrentChallenge(BaseChallenge challengeScript)\n        {\n            if (currentChallenge != null)\n            {\n                currentChallenge.CompleteChallenge();\n            }\n            currentChallenge = challengeScript;\n        }\n    }\n```", "```cs\n    public class EnemyWavesChallenge : BaseChallenge\n    {\n        public int totalWaves = 5;  // Adjust as needed\n        private int currentWave = 0;\n        public override void StartChallenge()\n        {\n            if (!commonData.isCompleted)\n            {\n                StartCoroutine(StartEnemyWavesChallenge());\n            }\n            else\n            {\n                Debug.Log(\"Challenge already completed!\");\n            }\n        }\n        IEnumerator StartEnemyWavesChallenge()\n        {\n            while (currentWave < totalWaves)\n            {\n                yield return StartCoroutine(SpawnEnemyWave());\n                currentWave++;\n            }\n            CompleteChallenge();\n        }\n        public override void CompleteChallenge()\n        {\n            if (!commonData.isCompleted)\n            {\n                RewardManager.Instance.GrantReward(commonData);\n                commonData.isCompleted = true;\n            }\n            else\n            {\n                Debug.Log(\"Challenge already completed!\");\n            }\n        }\n        IEnumerator SpawnEnemyWave()\n        {\n            // Adjust spawn positions, enemy types, and other parameters based on your game\n            Debug.Log($\"Spawning Wave {currentWave + 1}\");\n            yield return new WaitForSeconds(2f);\n        }\n    }\n```", "```cs\n   public class LevelManager : Singleton<LevelManager>\n   {\n       public GenericDictionary<int, ChallengeType> levelChallengeMapping = new GenericDictionary<int, ChallengeType>();\n       public int currentLevel;\n       private void Start()\n       {\n           StartChallengeForCurrentLevel(currentLevel);\n       }\n       public void StartChallengeForCurrentLevel(int currentLevel)\n       {\n           if (levelChallengeMapping.TryGetValue(currentLevel, out ChallengeType challengeType))\n           {\n               // Start the challenge associated with the current level\n               ChallengeManager.Instance.StartChallenge(challengeType);\n           }\n           else\n           {\n               Debug.LogError($\"No challenge mapped for Level {currentLevel}\");\n           }\n       }\n   }\n```", "```cs\n    public class RewardManager : Singlton<RewardManager>\n    {\n        // Define different types of rewards\n        public enum RewardType\n        {\n            PowerUp,\n            UnlockableWeapon,\n            ScoreMultiplier,\n            SecretArea,\n            Coins\n        }\n        public void GrantReward(CommonChallengeData commonData)\n        {\n            // Add code here to handle the specific reward type\n            switch (commonData.rewardType)\n            {\n                case RewardType.PowerUp:\n                    // Grant temporary power-up\n                    break;\n                case RewardType.UnlockableWeapon:\n                    // Unlock a new weapon\n                    break;\n                case RewardType.ScoreMultiplier:\n                    ApplyScoreMultiplier(commonData.rewardAmount);\n                    break;\n                case RewardType.SecretArea:\n                    // Grant items found in a secret area\n                    break;\n                case RewardType.Coins:\n                    GrantCoins(commonData.rewardAmount);\n                    break;\n            }\n        }\n        private void ApplyScoreMultiplier(int multiplier)\n        {\n            ScoreManager.Instance.ApplyMultiplier(multiplier);\n            Debug.Log($\"Score Multiplier Applied: {multiplier}x\");\n        }\n        private void GrantCoins(int coinAmount)\n        {\n            CurrencyManager.Instance.AddCoins(coinAmount);\n            Debug.Log($\"Coins Granted: {coinAmount}\");\n        }\n    }\n```", "```cs\n   Public class CurrencyManager : Singlton<CurrencyManager>\n   {\n       private int currentCoins;\n       public void AddCoins(int amount)\n       {\n           currentCoins += amount;\n           Debug.Log($\"Coins: {currentCoins}\");\n       }\n   }\n```", "```cs\n    public class ScoreManager : Singlton<ScoreManager>\n    {\n        private float currentScore;\n        private int scoreMultiplier = 1;\n        public void ApplyMultiplier(int multiplier)\n        {\n            scoreMultiplier *= multiplier;\n        }\n        private void ResetMultiplier()\n        {\n            scoreMultiplier = 1;\n        }\n        public void AddScore(int scoreValue)\n        {\n            // Adjust score based on the current multiplier\n            currentScore += scoreValue * scoreMultiplier;\n            Debug.Log($\"Score: {currentScore}\");\n        }\n    }\n```"]