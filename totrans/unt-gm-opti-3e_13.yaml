- en: Tactical Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software engineers are an optimistic bunch and, as such, we often underestimate
    the amount of work it takes to fully implement new features or make changes to
    an existing code base. A common mistake is to only consider how long it will take
    to write the code that's required to create that feature. In such cases, we forget
    to include the time it takes for several important tasks. We often need to spend
    time refactoring other subsystems to support the changes we're making. This can
    happen either because we didn't think it would be necessary at the time, or because
    we thought of a better way to implement it halfway through, which can quickly
    turn into a rabbit hole dive of redesign and refactoring if we don't plan far
    ahead. We should also consider the time that's needed for testing and documentation.
    Even if a QA team does a testing pass against the change after it has been implemented,
    we still need to run through some scenarios on our own system during implementation
    in order to ensure that the change actually does what it's intended to do.
  prefs: []
  type: TYPE_NORMAL
- en: The one constant cost that's included in all performance optimization work is
    time. So, with limited time at our disposal to implement our features and keep
    everything working, an important skill for any developer to learn about is workflow
    optimization. Having a better understanding of the tools we use will save us more
    time in the long run, and hopefully provide the extra time we need to implement
    everything we want to, which applies not only to the Unity engine, but to every
    tool we use—IDEs, build systems, analytics systems, social media platforms, app
    stores, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of little nuances to using the Unity engine that can help improve
    our project workflow. However, quite a lot of the Editor's functionality is not
    well documented, well-known, or just not something we think about until after
    quite some time—we realize the fact that it could have been applied perfectly
    to solve a particular problem we were having 6 months ago.
  prefs: []
  type: TYPE_NORMAL
- en: The internet is crammed full of blogs, tweets, and forum posts that try to help
    other Unity developers learn about these useful features, but they only tend to
    focus on a handful of tips at a time. There doesn't seem to be any online resources
    that group many of them in one place. As a result, the internet browsers of intermediate
    and advanced Unity developers are probably bursting at the seams with links to
    these tips that we bookmark for later and then completely forget about.
  prefs: []
  type: TYPE_NORMAL
- en: So, because this book is primarily for such users, I felt like it was worth
    including a short chapter to pool many of these tips and tricks together into
    one location. This chapter serves as a reference list in the hope of saving us
    time during future development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Editor hotkey tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editor UI tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom Editor scripts and menu tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editor hotkey tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Editor is rife with hotkeys that can aid rapid development, and it's worth
    checking out the documentation. However, let's be honest—nobody reads the manual
    until they need something specific from it. In this section, we will go over some
    of the most useful, yet less well-known, hotkeys that are available when we're
    playing with the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: For each case we'll be looking at, the Windows hotkey is listed. If the macOS
    hotkey requires a different set of keystrokes, then it will be shown in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GameObjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GameObjects can be duplicated by selecting them in the Hierarchy window and
    pressing *Ctrl* + *D* (*cmd *+ *D*). New, empty GameObjects can be created by
    pressing *Ctrl* + *Shift* + *N* (*cmd* + *shift* + *N*).
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + *Shift* + *A* (*cmd* + *shift* + *A*) to quickly open the Add
    Component menu. From there, you can type in the name of the component you wish
    to add.
  prefs: []
  type: TYPE_NORMAL
- en: Scene window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pressing *Shift* + *F* will lock the camera on an object in the Scene window (assuming
    that the Scene window is open and visible), which can be helpful for tracking
    high-velocity objects or figuring out why objects may be falling out of our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Holding *Alt* and left-click and dragging with the mouse in the Scene window
    will make the Scene window's camera orbit the currently selected object (as opposed
    to looking around it). Holding *Alt* and right-click and dragging with the mouse
    in the Scene window will zoom the camera in/out (*Alt* + *Ctrl* + left-drag).
  prefs: []
  type: TYPE_NORMAL
- en: 'Holding *Ctrl* and left-click and dragging will cause the selected object to
    snap to the grid as it moves. The same can be done for rotation by holding *Ctrl* as
    we adjust the rotation widgets around the object. In the Scene window, you can
    click on the arrow near the grid icon (see the following screenshot) to open a
    window where we can edit the grid that objects snap to on a per-axis basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f276200-b30d-4812-9684-eedc2453e25a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Unity 2020.1, the snap to grid setting has been moved from the Scene view
    toolbar to the main window toolbar (where the Play/Pause/Step buttons are):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04831f19-3ccd-4e34-a5bc-36764e4476fc.png)'
  prefs: []
  type: TYPE_IMG
- en: We can force objects to snap to each other through their vertices by holding
    down the *V* key as we move an object around in the Scene window. By doing so,
    the selected object will automatically snap its vertices to the nearest vertex
    of the nearest object. This is very useful for aligning scene pieces, such as
    floors, walls, platforms, and other tile-based systems, without needing to make
    small manual position adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can duplicate array elements that have been exposed in the Inspector window
    by selecting them and pressing *Ctrl* + *D* (*cmd* + *D*). This will copy the
    element and insert it into the array immediately after the current selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove entries from an array of references (for example, an array of
    GameObjects) by selecting the element, right-clicking on it, and selecting Delete
    Array Element. This will strip the element and condense the array. Removing elements
    from arrays of primitive types (`int`, `float`, and so on) can be accomplished
    by simply pressing *delete* without the *shift* key (*cmd*) modifier being held
    down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31a751e3-cd0a-4931-ac6b-9c60afb8a67a.png)'
  prefs: []
  type: TYPE_IMG
- en: While holding down the right mouse button in the Scene window, we can use the *W*, *A*, *S*,
    and *D* keys to fly around with the camera in a typical first-person camera control
    style. The *Q* and *E* keys can also be used to fly up and down, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can press *Alt* and click on any Hierarchy window arrow (the small gray arrow
    to the left of any parent object's name) to expand the object's entire hierarchy,
    rather than just the next level in the Hierarchy window. This works on GameObjects
    in the Hierarchy window, folders and Prefabs within the Project window, lists
    in the Inspector window, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can save and restore object selections in the Hierarchy or Project windows much
    like a typical RTS game. Make the selection and press *Ctrl* + *Alt* + <*0-9*>
    (*cmd *+ *alt* + <*0*-*9*>) to save the selection. Press *Ctrl* + *Shift* + *<0*-*9>* (*cmd* + *shift* +
    <*0-9*>) to restore it. This is exceptionally useful if we find ourselves selecting
    the same handful of objects over and over again while we''re making adjustments.
    You can also find the save/load selections commands in Edit | Selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d84aacd2-8c0b-4702-8ea5-b7bc748ecb81.png)'
  prefs: []
  type: TYPE_IMG
- en: Pressing *Shift* + spacebar will expand the window under the mouse cursor so
    that it fills the entire Editor screen. Pressing it again will shrink the window
    and restore it to its previous location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pressing *Ctrl* + *Shift* + *P* (*cmd* + *shift* + *P*) will toggle the Pause button
    while in Playmode. This is usually an awkward key combination to press if we''re
    trying to pause in a hurry, so it often helps to create a custom hotkey for pausing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In-editor documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can quickly access the documentation of any Unity keyword or class by highlighting
    it in Visual Studio Community and pressing *Ctrl* + *'* (*cmd* + *'*). This will
    open the default browser and perform a search on the Unity documentation for the
    given keyword or class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that users with European keyboards may also need to hold down the *Shift* key
    for this feature to work.
  prefs: []
  type: TYPE_NORMAL
- en: The same can be done in Visual Studio by pressing *Ctrl* + *Alt* + *M*, followed
    by *Ctrl* + *H*.
  prefs: []
  type: TYPE_NORMAL
- en: Editor UI tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Editor's default behavior is designed to be efficient and satisfy every
    user; however, each of us is different, just like beautiful snowflakes, and so
    are our working preferences. Fortunately, Unity allows us to customize many aspects
    of the Editor's workflow. Let's see how with the following collection of tips.
  prefs: []
  type: TYPE_NORMAL
- en: Script Execution Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can prioritize which scripts will have their `Update()` and `FixedUpdate()` callbacks
    called before others by navigating to Edit | Project Settings | Script Execution
    Order. If we find ourselves trying to solve complex problems using this feature
    (with the exception of time-sensitive systems, such as audio processing), it implies
    that we've got some very fragile and tight coupling going on between our components.
    From a software design perspective, this can be a warning sign that we may need
    to approach the problem from another angle. However, this can be helpful to use
    as a quick fix.
  prefs: []
  type: TYPE_NORMAL
- en: Editor files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating Unity projects with a source control solution can be a little tricky.
    The first step is to include the `.meta` files that Unity generates for various
    assets; if we don't do this, then anyone pulling data into their local Unity project
    must regenerate their own metadata files. This could potentially cause conflicts,
    so it is essential that everyone uses the same versions. This can be enabled by
    navigating to Edit | Project Settings | Editor | Version Control | Mode | Visible
    Meta Files.
  prefs: []
  type: TYPE_NORMAL
- en: It can also be helpful to convert certain asset data into text-only format,
    rather than into binary data, to allow data files to be manually edited. This
    turns many data files into the much more human-readable YAML format. For instance,
    if we're using ScriptableObjects to store custom data, we can use a text editor
    to search for and edit these files without having to do it all through the Unity
    Editor and serialization system. This can save a lot of time, especially when
    we're searching for a particular data value or performing multi-editing across
    different derived types. This option can be enabled by navigating to Edit | Project
    Settings | Editor | Asset Serialization | Mode | Force Text.
  prefs: []
  type: TYPE_NORMAL
- en: The Editor has a log file that can be accessed by opening the Console window
    (where log messages are printed), left-clicking on the hamburger icon in the top
    right corner (which looks like three thin horizontal lines), and selecting Open
    Editor Log. This can help us get more information about build failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if we successfully built our project, it will contain a breakdown
    of the compressed file sizes of all of the assets that were packed into the executable,
    ordered by size. This is an extremely helpful way of figuring out which assets
    consume the majority of our application''s footprint (hint: it''s almost always
    texture files) and which files take up more space than we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ffba58c-a1b8-4e8b-ac08-5961623a10b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Additional windows can be added to the Editor by right-clicking on the title
    of an existing window and selecting Add Tab. This also allows us to add duplicate
    windows, such as having more than one Project window or Inspector window open
    at a time. This can be particularly useful for moving files between different
    locations via multiple Project windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1f14e08-c729-498a-adf6-3cb3d5f6d2e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Having duplicate Inspector windows can be virtually redundant, since they''ll
    show the exact same information when we click on a new object. However, by making
    use of the *lock icon*, we can lock the given Inspector window to its current
    selection. When we select an object, all the Inspector windows will be updated
    to show the object''s data, except for any locked Inspector windows, which continue
    to show the data of the object they were locked to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e369b91a-6711-489c-bcb1-f9b246ee6fa3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some common tricks that make use of window locking include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using two of the same window (Inspector, Animation, and so on) to compare two
    objects side by side or to easily copy data from one object to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching what happens to any dependent object if an object is tweaked during Playmode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting multiple objects in the Project window and then dragging and dropping
    them into a serialized array in the Inspector window without losing the original
    selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Inspector window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can enter calculations into numeric Inspector window fields. For example,
    typing `4*128` into an `int` field will resolve the value to `512`, sparing us
    from having to pull out a calculator or do the math in our head.
  prefs: []
  type: TYPE_NORMAL
- en: Array elements can be duplicated and deleted from a list (in the same fashion
    as hotkeys can) by right-clicking on the root element and selecting Duplicate
    Array Element or Delete Array Element.
  prefs: []
  type: TYPE_NORMAL
- en: A component's context menu can be accessed by clicking on the small *cog* icon
    in the upper right corner or by right-clicking on the name of the component. Every
    component's context menu contains a Reset option, which resets all of the values
    back to their default states, sparing us from having to reset values manually.
    This is useful when we're working with `Transform` components as this option will
    set the object's position and rotation to `(0,0,0)` and its scale to `(1,1,1)`.
  prefs: []
  type: TYPE_NORMAL
- en: It's commonly known that, if `GameObject` was spawned from a Prefab, then the
    entire object can be reverted back to its initial Prefab state using the Revert button
    at the top of the Inspector window. However, it's less well-known that individual
    values can be reverted by right-clicking on the name of the value and selecting Revert
    Value to Prefab. This restores the selected value while leaving the rest untouched.
  prefs: []
  type: TYPE_NORMAL
- en: The Inspector window has a Debug mode that can be accessed by left-clicking
    on the hamburger icon next to the lock icon and selecting Debug. This will disable
    all custom Inspector window drawing from Editor scripts and instead reveal all
    the pieces of raw data within the given `GameObject` and its components. Even `private` data
    fields become visible. Although they are grayed out and cannot be modified through
    the Inspector window, this still gives us a useful way of examining the `private` data
    and other hidden values during Playmode. The Debug mode of the Inspector window
    also reveals internal ObjectIDs, which can be useful if we're doing interesting things
    with Unity's serialization system and want to resolve conflicts. Since Editor
    scripts are also disabled in this mode, it can be useful to debug such scripts
    by comparing its internal data to what we are trying to reveal in our Editor script.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have an array of data elements serialized in the Inspector window, then
    they are typically labeled Element N, where `N` represents the array index of
    that element, starting from `0`. This can make it tricky to find a specific element
    if our array elements are a series of serialized classes or structs, which tend
    to have multiple children themselves. However, if the very first field in the
    object is a string, then the elements will be named after the value of the string
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f50cf3c4-9990-401b-96fd-b44c942321bb.png)'
  prefs: []
  type: TYPE_IMG
- en: When a mesh object is selected, the Preview subsection at the bottom of the Inspector window
    is often fairly small, which makes it hard for us to look at the details in the
    mesh and what it will look like when it appears in our scene. However, if we right-click
    on the top bar of the Preview subsection, it will be detached and enlarged into
    a separate Preview window, making it much easier for us to see our mesh. We don't
    have to worry about setting the detached window back to its original home because
    if the detached window is closed, then the Preview subsection will return to the
    bottom of the Inspector window.
  prefs: []
  type: TYPE_NORMAL
- en: The Project window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Project window's search bar allows us to filter for objects of a particular
    type by clicking on the small icon to the right of the search bar. This provides
    a list of different types that we can filter by revealing all the objects of that
    type within the entire project. However, selecting these options simply fills
    the search bar with a string of the `t:<type>` format, which applies the appropriate
    filter.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can simply type the equivalent strings into the search bar for the
    sake of speed. For instance, typing `t:prefab` will filter for all Prefabs, no
    matter where they are in the Hierarchy window. Similarly, `t:texture` will reveal
    textures, `t:scene` will reveal scene files, and so on. Adding multiple search
    filters to the search bar will include objects of all types (it doesn't reveal
    objects that only satisfy both filters). These filters are modifiers in addition
    to name-based filtering, so adding a plain text string will cause a name-based
    search to occur through the filtered objects. For example, `t:texture normalmap` will
    find all the texture files that include the word `normalmap` in their name.
  prefs: []
  type: TYPE_NORMAL
- en: If we're making use of Asset Bundles and the built-in labeling system, the Project window's
    search bar also allows us to hunt down bundled objects by their label using `l:<label
    type>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a `MonoBehaviour` script contains serialized references (using `[SerializeField]` or `public`)
    to Unity assets, such as meshes and textures, then we can assign default values
    to the script directly. Select the script file in the Project window; the Inspector window
    should contain a field for the asset so that we can drag and drop the default
    assignment into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d34f6416-57a8-4786-8c34-b771a4758c4b.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, the Project window splits files and folders into two columns and
    treats them separately. If we prefer the Project window to have a typical hierarchical
    folder and file structure, then we can set it to One Column Layout in its context
    menu (the hamburger icon at the top right). This can be a great space saver in
    some Editor layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Right-clicking on any object in the Project window and selecting Select Dependencies will
    reveal all the objects that this asset relies on so that it can exist, such as
    textures, meshes, and `MonoBehaviour` script files. For scene files, it will list
    all the entities that are referenced within that scene. This is helpful if we're
    trying to perform asset cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: The Hierarchy window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A less well-known feature of the Hierarchy window is its ability to perform
    component-based filtering within the currently active scene. This can be accomplished
    by typing `t:<component name>`. For example, typing `t:light` inside the Hierarchy window
    search bar will reveal all the objects in the scene that contain a Light component.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is not case-sensitive, but the string we input must match the full
    component name for the search to be completed. Components that derive from the
    given type will also be revealed, so typing `t:renderer` will reveal all the objects
    with derived components, such as `MeshRenderer` and `SkinnedMeshRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: The Scene and Game windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Scene window camera is not visible from the Game window, but it is generally
    a lot easier to move around and place through the use of the hotkeys we mentioned
    previously. The Editor allows us to align the selected object to the same position
    and rotate the Scene window camera by navigating to GameObject | Align with View or
    pressing *Ctrl* + *Shift* + *F* (*cmd* + *shift* + *F*). This means that we can
    use the camera controls to place the Scene window camera where we would like our
    object to be and place the object there by aligning it with the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can align the Scene window camera to the selected object by selecting GameObject | Align
    View to Selected (note that there is no hotkey for this on either Windows or macOS).
    This is useful for checking whether the given object is pointing in the right
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: We can perform similar component-based filtering on the Scene window, just like
    we can with the Hierarchy window, by using the `t:<component>` syntax within its
    search bar. This will cause the Scene window to only render objects containing
    the given component (or those that derive from it). Note that this textbox is
    linked to the same textbox in the Hierarchy window, so anything we type in one
    will automatically affect the other, which is very helpful when we're searching
    for elusive objects.
  prefs: []
  type: TYPE_NORMAL
- en: At the very top right of the Unity Editor is a dropdown menu labeled Layers.
    This contains a layer-based filtering and locking system for the Scene window.
    Enabling the eye icon for a given layer will show/hide all the objects of that layer within
    the Scene window. Toggling the lock icon will allow or prevent objects of the
    given layer from being selected or modified (through the Editor UI, at least).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is helpful when we wish to prevent someone from accidentally selecting
    and moving background objects that have already been placed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37a01587-902c-4fbf-953f-e6173e46467e.png)'
  prefs: []
  type: TYPE_IMG
- en: A well-known and useful feature of the Editor is that GameObjects can be given
    special icons or labels to make them easier to find in the Scene window. This
    is particularly helpful for objects with no renderer but that we wish to find easily.
    For instance, objects such as Lights and cameras have built-in icons that identify
    them in our Scene window more easily. However, the same gizmos can be revealed
    within the Game window by clicking on the Gizmos button at the top right of the Game window.
    The dropdown for this option determines what gizmos will be visible when this
    option is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Playmode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Playmode changes are not automatically saved, it is wise to modify the
    tint color that's applied during Playmode to make it blatantly obvious which mode
    we're currently working with. This value can be set by navigating to Edit | Preferences | Colors | Playmode
    tint.
  prefs: []
  type: TYPE_NORMAL
- en: Changes can be saved from Playmode simply using the clipboard. If we're tweaking
    an object in Playmode and we're happy with its settings, then we can copy the
    object into the clipboard using *Ctrl* + *C* (*cmd* + *C*) and paste it back into
    the scene once Playmode ends via *Ctrl* + *V* (*cmd* + *V*).
  prefs: []
  type: TYPE_NORMAL
- en: All of the settings that have been applied to the object at the time of the
    copy will be kept. The same can be done with individual values of entire components
    if we use the Copy Component and Paste Component options in the component's context
    menu. However, the clipboard can only contain data for one `GameObject`, component,
    or value at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach, which allows us to save the data of multiple objects during Playmode,
    is to create Prefabs from them by dragging and dropping them into the Project window
    at runtime once we're happy with the settings. If the original object was derived
    from a Prefab, and we wish to update it across all instances, then we only need to
    overwrite the old Prefab with the new one we created by dragging and dropping
    the copy on top of the original. Note that this also works while Playmode is active,
    but it can be dangerous since there is no dialog popup to confirm the overwrite.
    Be very careful not to overwrite the wrong Prefab.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Frame Skip button (the button to the right of the Pause button
    in the Editor) to iterate one frame at a time. This can be useful for watching
    frame by frame physics or gameplay behavior. Keep in mind that this causes one `FixedUpdate` and
    one `Update` to be called per iteration, in equal counts, which may not reflect
    the actual runtime behavior, where we tend to have an unequal number of calls
    to these callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: If the Pause button is enabled when Playmode begins, then the game will be paused
    just after the very first frame, giving us a chance to observe any anomalies that
    occurred during the initialization of our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a developer, you will spend a lot of time editing code. While artists
    and designers are playing with colorful images and visual effects, you may find
    yourself stuck in the black and white code editor domain. Coding may be hard sometimes,
    but it doesn't need to be tedious. In the following tips, we will learn how to
    simplify some of the most boring parts of the job.
  prefs: []
  type: TYPE_NORMAL
- en: General
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can modify various templates of the new script, as well as shader and compute
    shader files. This can be helpful if we want to remove the empty Update stubs
    which, as we covered in Chapter 2, *Scripting Strategies*, can cause unnecessary
    runtime overhead. These files can be found in the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows: `<Unity install>\Editor\Data\Resources\ScriptTemplates\`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS: `/Applications/Unity/Editor/Data/Resources/ScriptTemplates/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Assert` class allows for assert-based debugging, which some developers
    are more comfortable with, as opposed to exception-based debugging. Check out the Unity
    documentation for more information on `Assert`: [http://docs.unity3d.com/ScriptReference/Assertions.Assert.html](http://docs.unity3d.com/ScriptReference/Assertions.Assert.html).
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attributes are very useful meta-level tags that can be given to almost any target
    in C#. They are commonly used on fields and classes, allowing us to flag them
    with special properties so that they can be processed differently. Intermediate
    and advanced Unity developers will find it worthwhile to read the C# documentation
    on attributes and use their imagination to come up with their own attributes that
    help accelerate their workflow. There are quite a few attributes built into the
    Unity engine that can be exceptionally useful when used in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced users will note that attributes can also be given to enums, delegates,
    methods, parameters, events, modules, and even assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: Variable attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `[Range]` attribute can be added to an integer or floating-point field to
    convert it into a slider in the Inspector window. We can provide minimum and maximum
    values, thus limiting the range that the value can contain.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, if a variable is renamed, even if we do a refactor through our IDE,
    then the values are lost as soon as Unity recompiles the `MonoBehaviour` and makes
    the appropriate changes to any instances of the component. However, the `[FormerlySerializedAs]` attribute
    is incredibly helpful if we want to rename a variable that has been previously
    serialized, since it will copy the data from the variable that was named within
    the attribute into the given variable at compile time. No more lost data due to
    renaming stuff!
  prefs: []
  type: TYPE_NORMAL
- en: Note that it isn't safe to remove the `[FormerlySerializedAs]` attribute after
    the conversion is completed unless the variable has been manually changed and
    resaved into every relevant Prefab since the attribute was included. The `.prefab` data
    file will still contain the old variable name, and so it still needs the `[FormerlySerializedField]` attribute
    to figure out where it should place the data the next time the file is loaded
    (for example, when the Editor is closed and reopened). Thus, this is a helpful
    attribute, but extended use does tend to clutter up our code base a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Class attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `[SelectionBase]` attribute will mark any `GameObject` the component is
    attached to as the root of selection for the Scene window. This is especially
    useful if we have meshes that are children of other objects since we may want
    the parent object to be selected with the first click, instead of the object with
    the `MeshRenderer` component.
  prefs: []
  type: TYPE_NORMAL
- en: If we have components with a strong dependency, we can use the `[RequireComponent]` attribute
    to force level designers to attach vital components to the same `GameObject`.
    This ensures that any dependencies that our code base relies on will be satisfied
    by designers, without us having to write out a whole bunch of documentation for
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `[ExecuteInEditMode]` attribute will force the object''s `Update()`, `OnGUI()`,
    and `OnRenderObject()` callbacks to be called during Edit Mode. However, there
    are some caveats to this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method is only called if something changes in the scene, such
    as moving the camera around or changing an object property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnGUI()` is only called during Game window events and not for other window
    events, such as the Scene window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnRenderObject()` is called during any repaint event for the Scene and Game windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, this attribute gives such objects a different set of event hooks and
    entry points compared to typical Editor scripts, so it still has its uses.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add rich text tags to debug strings. Tags such as `<size>`, `<b>` (bold), `<i>` (italics),
    and `<color>` work on debug strings. This can help us differentiate between the
    different kinds of log messages and allows us to highlight specific elements,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message we will obtain is as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95010d6d-9171-49ff-ad7c-455b1351bf09.png)'
  prefs: []
  type: TYPE_IMG
- en: The `MonoBehaviour` class has a `print()` method for convenience, which does
    the same thing as `Debug.Log()`.
  prefs: []
  type: TYPE_NORMAL
- en: It can help to create a custom logger class, which automatically appends `\n\n` to
    the end of every log message. This will push away the unnecessary `UnityEngine.Debug:Log(Object)` clutter
    that tends to fill the Console window.
  prefs: []
  type: TYPE_NORMAL
- en: Useful links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity provides many useful tutorials on the usage of various scripting features,
    which primarily target beginner- and intermediate-level developers. These tutorials
    can be found at [https://unity3d.com/learn/tutorials/topics/scripting](https://unity3d.com/learn/tutorials/topics/scripting).
  prefs: []
  type: TYPE_NORMAL
- en: There's a helpful post on Unity Answers that provides a reference list that
    covers many of the different scripting and compilation errors we may run into
    during development. This can be found by searching for `Scripting` at [https://learn.unity.com/](https://learn.unity.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Nested coroutines is an interesting and useful area of scripting that is not
    well documented. However, the following old but still valid third-party blog post,
    which covers a lot of the interesting details, should be considered when working
    with nested coroutines: [http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper](http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper).
  prefs: []
  type: TYPE_NORMAL
- en: Custom Editor scripts and menu tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While it''s common knowledge that we can create an Editor menu item in an Editor
    script with the `[MenuItem]` attribute, a less well-known ability is being able
    to set custom hotkeys for menu items. For example, we can make the <q>K</q> key
    trigger our menu item method by defining that the `[MenuItem]` attribute ends
    with `_k`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can also include modifier keys such as *Ctrl* (*cmd*), *Shift*, and *Alt* using
    the `%`, `#`, and `&` characters, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`[MenuItem]` also has two overloads, which allow us to set two additional parameters:
    a Boolean that determines whether the menu item requires a validation method and
    an integer that determines the menu item''s priority in the Hierarchy window.'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the documentation for `[MenuItems]` for a complete list of available
    hotkey modifiers, special keys, and how to create validation methods: [http://docs.unity3d.com/ScriptReference/MenuItem.html](http://docs.unity3d.com/ScriptReference/MenuItem.html).
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to *ping* an object in the Hierarchy window, similar to
    what happens when we click on a `GameObject` reference in the Inspector window
    and call `EditorGUIUtility.PingObject()`.
  prefs: []
  type: TYPE_NORMAL
- en: The original implementation of the `Editor` class, and the way that most people
    learned how to write Editor scripts, originally involved writing all the logic
    and content drawing in the same class. However, the `PropertyDrawer` class is
    an effective way of delegating Inspector window drawings to a different class
    from the main `Editor` class. This effectively separates input and validation
    behavior from display behavior, thus allowing for more fine-tuned control of rendering
    on a per-field basis and more effective reuse of code. We can even use `PropertyDrawer` to
    override default Unity drawings for built-in objects, such as `Vector` and `Quaternion`.
  prefs: []
  type: TYPE_NORMAL
- en: '`PropertyDrawer` makes use of the `SerializedProperty` class to accomplish
    the serialization of individual fields, and they should be preferred when writing
    Editor scripts since they make use of built-in undo, redo, and multi-edit functionality.
    Data validation can be a little problematic, and the best solution is to use `OnValidate()` calls
    in the *setter* properties. A session at Unite 2013, by Unity Technologies developer
    Tim Cooper, explains the benefits and pitfalls of various serialization and validation
    approaches in great detail ([https://www.youtube.com/watch?v=Ozc_hXzp_KU](https://www.youtube.com/watch?v=Ozc_hXzp_KU)).'
  prefs: []
  type: TYPE_NORMAL
- en: We can add entries to component context menus and even the context menus of
    individual fields with the `[ContextMenu]` and `[ContextMenuItem]` attributes.
    This allows us to customize the Inspector window's behavior for our components
    without needing to write broad `Editor` classes or custom Inspector windows.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced users may find it useful to store custom data within Unity metadata
    files through the `AssetImporter.userData` variable. There's also a multitude
    of opportunities to make use of Reflection in the Unity code base. Ryan Hipple's
    session at Unite 2014 outlines a huge number of neat little hacks and tricks we
    can use with Reflection in the Unity Editor ([https://www.youtube.com/watch?v=SyR4OYZpVqQ](https://www.youtube.com/watch?v=SyR4OYZpVqQ)).
  prefs: []
  type: TYPE_NORMAL
- en: External tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following tips and tricks are related to topics outside the Unity Editor
    itself but can help Unity development workflow enormously.
  prefs: []
  type: TYPE_NORMAL
- en: The Twitter hashtag `#unitytips` is a great resource for useful tips and tricks
    for Unity development and is, in fact, where many of the tips in this chapter
    originate from. However, hashtags are difficult to filter for tips you haven't
    seen before, and it tends to be abused for marketing. A great resource that pulls
    together a bundle of weekly tips from `#unitytips` can be found at [http://devdog.io/blog](http://devdog.io/blog).
  prefs: []
  type: TYPE_NORMAL
- en: Googling Unity-related problems or concerns can be made a lot faster if we start
    the search with `site:unity3d.com`, which will filter all the results so that
    only those under the `unity3d.com` domain will appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the Unity Editor crashes, for whatever reason, then we can potentially restore
    our scene by renaming the following file to include the `.unity` extension (for
    scene files) and copying it into our `Assets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There is a great resource for game programming patterns (or, rather, typical
    programming patterns explained in a way that is pertinent to game development),
    and it's completely free and available online. The following guide includes more
    information on several of the design patterns and game features we explored in
    this book, such as the Singleton pattern, the Observer pattern, the Game loop,
    and doubling-up on frame buffers: [http://gameprogrammingpatterns.com/contents.html](http://gameprogrammingpatterns.com/contents.html).
  prefs: []
  type: TYPE_NORMAL
- en: Keep an eye on any session videos that come from Unite conferences whenever
    they happen (or better yet, try to attend them). A couple of panels at each conference
    are usually held by Unity employees and experienced developers who will share
    lots of cool and interesting things they've been able to accomplish with the Engine
    and Editor. In addition to this, make sure that you involve yourself in the Unity
    community through the forums on[ https://unity3d.com](https://unity3d.com/), Twitter,
    Reddit, Stack Overflow, Unity Answers, or at whatever social gathering places
    pop out of the woodwork in the coming years.
  prefs: []
  type: TYPE_NORMAL
- en: Every single tip that was included in this book wasn't conjured out of thin
    air. It started out as an idea or tidbit of knowledge that someone shared, somewhere,
    at some point, and somehow eventually found its way into this book. So, the best
    way to keep up to date on the best tips, tricks, and techniques is to keep our
    fingers on the pulse of where Unity is heading by staying involved in its community.
  prefs: []
  type: TYPE_NORMAL
- en: Other tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, this section contains tips that didn't quite fit into the other categories.
  prefs: []
  type: TYPE_NORMAL
- en: It's always a good idea to organize our scenes using empty GameObjects and use
    them as parents for a group of objects while naming them something sensible for
    that group. The only drawback to this method is that the empty object's transform
    is included during position or rotation changes and is included during recalculations.
    As we know, reparenting `GameObject` to another transform has its own costs. Proper
    object referencing, transform change caching, and/or use of `localPosition`/`localRotation` can
    be used to solve some of these problems adequately. In almost all cases, the benefits
    of having a workflow from scene organization are significantly more valuable than
    such trivial performance losses.
  prefs: []
  type: TYPE_NORMAL
- en: Animator Override Controllers were introduced way back in Unity v4.3 but tend
    to be forgotten or rarely mentioned. They are an alternative to standard Animation
    Controllers, which allow us to reference an existing Animation Controller and
    then override specific animation states so that we can use different animation
    files. This allows for much faster workflows since we don't need to duplicate
    and tweak Animation Controllers multiple times; we only need to change a handful
    of animation states.
  prefs: []
  type: TYPE_NORMAL
- en: The amazing customizability of the Unity Editor and its ever-growing feature
    set means that there are tons of little opportunities to improve workflows, and
    more are being discovered or invented every single day. The asset store marketplace
    is absolutely rife with different products that try to solve some kind of problem
    that modern developers are having trouble with, which makes it a great place to
    browse if we're looking for ideas or, if we're willing, drop some money to save
    us a ton of hassle.
  prefs: []
  type: TYPE_NORMAL
- en: Since these assets tend to sell to a broad audience, this keeps prices low,
    and we can pick up some amazingly useful tools and scripts for little to no cost.
    In almost all cases, it would take us a significant number of hours to develop
    the same solution ourselves. If we consider our time as valuable, then scanning
    the asset store once in a while can be a very cost-effective approach to development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of this book. Hopefully, you have enjoyed the ride. To
    reiterate, perhaps the most important tip in this book is to always make sure
    that you verify the source of the performance bottleneck via benchmarking before
    making a single change. The last thing we want to waste time on is chasing ghosts
    in the code base when 5 minutes of Profiler testing can save us an entire day
    of work. In a lot of cases, the solution requires a cost-benefit analysis to determine
    whether we're not sacrificing too much in any other area at the risk of adding
    further bottlenecks. Make sure that you have a reasonable understanding of the
    root cause of the bottleneck to avoid putting other performance metrics at risk. To
    also reiterate the second most important tip in this book, always profile and
    test after making changes to ensure they had the intended effect.
  prefs: []
  type: TYPE_NORMAL
- en: Performance enhancement is all about problem-solving, which can be a lot of
    fun since, due to the complexity of modern computer hardware, small tweaks can
    yield big rewards. There are many techniques that can be implemented to improve
    application performance or speed up our workflows. Some of these are hard to fully
    realize unless we have the necessary experience, skills, and time to implement
    them. In most cases, these fixes are relatively simple if we simply take the time
    to find and understand the source of the problem. So, go forth and use your repository
    of knowledge to make your games the best they can be!
  prefs: []
  type: TYPE_NORMAL
