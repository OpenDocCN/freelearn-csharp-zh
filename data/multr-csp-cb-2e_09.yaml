- en: Chapter 9. Using Asynchronous I/O
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。使用异步 I/O
- en: 'In this chapter, we will review asynchronous I/O operations in detail. You
    will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细回顾异步 I/O 操作。你将学习以下技巧：
- en: Working with files asynchronously
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理文件
- en: Writing an asynchronous HTTP server and client
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写异步 HTTP 服务器和客户端
- en: Working with a database asynchronously
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理数据库
- en: Calling a WCF service asynchronously
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步调用 WCF 服务
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, we already discussed how important it is to use asynchronous
    I/O operations properly. Why does it matter so much? To have a solid understanding,
    let's consider two kinds of applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经讨论了正确使用异步 I/O 操作的重要性。为什么这很重要？为了有一个坚实的理解，让我们考虑两种类型的应用程序。
- en: When we run an application on a client, one of the most important things is
    to have a responsive user interface. This means that no matter what is happening
    with the application, all user interface elements, such as buttons and progress
    bars, keep running fast, and the user gets an immediate reaction from the application.
    This is not easy to achieve! If you try to open the Notepad text editor in Windows
    and try to load a text document that is several megabytes in size, the application
    window will be frozen for a significant amount of time because the whole text
    is being loaded from the disk first, and only then does the program start to process
    user input.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在客户端运行应用程序时，最重要的事情之一是拥有一个响应式的用户界面。这意味着无论应用程序发生什么，所有的用户界面元素，如按钮和进度条，都保持快速运行，用户能够立即从应用程序中得到反应。这并不容易实现！如果你尝试在
    Windows 中打开记事本文本编辑器，并尝试加载一个几兆字节的文本文件，应用程序窗口将冻结一段时间，因为整个文本首先是从磁盘加载的，然后程序才开始处理用户输入。
- en: This is an extremely important issue, and in this situation, the only solution
    is to avoid blocking the UI thread at all costs. This in turn means that to prevent
    the blocking of the UI thread, every UI-related API must allow only asynchronous
    calls. This is the key reason behind redesigning APIs in the Windows 8 operating
    system by replacing almost every method with asynchronous analogs. But does it
    affect the performance if our application uses multiple threads to achieve this
    goal? Of course, it does! However, we could pay the price considering that we
    have only one user. It is good to have the application using all the power of
    the computer to be more effective, as all this power is intended for the single
    user who runs the application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其重要的问题，在这种情况下，唯一的解决方案是无论如何都要避免阻塞 UI 线程。这反过来又意味着为了防止阻塞 UI 线程，每个与 UI 相关的
    API 必须只允许异步调用。这正是 Windows 8 操作系统重新设计 API 的关键原因，几乎用异步类似物替换了所有方法。但是，如果我们的应用程序使用多个线程来实现这个目标，这会影响性能吗？当然，会的！然而，考虑到我们只有一个用户，我们可能需要付出这个代价。让应用程序利用计算机的全部力量来提高效率是很好的，因为所有这些力量都是为了运行应用程序的单个用户。
- en: Let's look at the second case, then. If we run the application on a server,
    we have a completely different situation. We have scalability as a top priority,
    which means that a single user should consume as little resource as possible.
    If we start to create many threads for each user, we simply cannot scale well.
    It is a very complex problem to balance our application resource consumption in
    an efficient way. For example, in ASP.NET, which is a web application platform
    from Microsoft, we use a pool of worker threads to serve client requests. This
    pool has a limited number of worker threads, and we have to minimize the use time
    for each worker thread to achieve scalability. This means that we have to return
    it to the pool as soon as possible so that it can serve another request. If we
    start an asynchronous operation that requires computation, we will have a very
    inefficient workflow. First, we take a worker thread from the thread pool to serve
    a client request. Then, we take another worker thread and start an asynchronous
    operation on it. Now, we have two worker threads serving our request, but we really
    need the first thread to be doing something useful! Unfortunately, the common
    situation is that we simply wait for the asynchronous operation to complete, and
    we consume two worker threads instead of one. In this scenario, asynchrony is
    actually worse than synchronous execution! We do not need to load all the CPU
    cores as we are already serving many clients and thus are using all the CPU computing
    power. We do not need to keep the first thread responsive as we have no user interface.
    Then, why should we use asynchrony in server applications?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看第二种情况。如果我们在一个服务器上运行应用程序，我们会遇到完全不同的状况。我们将可扩展性作为首要任务，这意味着单个用户应该尽可能少地消耗资源。如果我们为每个用户创建许多线程，我们根本无法很好地进行扩展。在高效地平衡我们的应用程序资源消耗方面，这是一个非常复杂的问题。例如，在微软的Web应用程序平台ASP.NET中，我们使用一个工作线程池来处理客户端请求。这个池中有限数量的工作线程，我们必须最小化每个工作线程的使用时间以实现可扩展性。这意味着我们必须尽快将其返回到池中，以便它可以处理另一个请求。如果我们启动一个需要计算的异步操作，我们将有一个非常低效的工作流程。首先，我们从线程池中取出一个工作线程来处理客户端请求。然后，我们再取出另一个工作线程并在其上启动一个异步操作。现在，我们有两个工作线程在处理我们的请求，但我们实际上只需要第一个线程做些有用的事情！遗憾的是，常见的情况是我们简单地等待异步操作完成，我们消耗了两个工作线程而不是一个。在这种情况下，异步操作实际上比同步执行还要差！我们不需要加载所有CPU核心，因为我们已经服务了许多客户端，因此正在使用所有的CPU计算能力。我们不需要保持第一个线程的响应性，因为我们没有用户界面。那么，为什么在服务器应用程序中要使用异步操作呢？
- en: The answer is that we should use asynchrony when there is an asynchronous I/O
    operation. Today, modern computers usually have a hard disk drive that stores
    files and a network card that sends and receives data over the network. Both of
    these devices have their own microcomputers that manage I/O operations on a very
    low level and signal the operating system about the results. This is again quite
    a complicated topic; but to keep the concept clear, we could say that there is
    a way for programmers to start an I/O operation and provide the operating system
    with code to callback when the operation is completed. Between starting an I/O
    task and its completion, there is no CPU work involved; it is done in the corresponding
    disk and network controller microcomputers. This way of executing an I/O task
    is called an I/O thread; they are implemented using the .NET thread pool and in
    turn use an infrastructure from the operating system called I/O completion ports.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，当存在异步I/O操作时，我们应该使用异步操作。今天，现代计算机通常有一个硬盘驱动器用于存储文件，以及一个网络卡用于在网络中发送和接收数据。这两个设备都有自己的微计算机，它们在非常低级别上管理I/O操作并向操作系统报告结果。这又是一个相当复杂的话题；但为了保持概念清晰，我们可以这样说，程序员有办法启动一个I/O操作，并提供给操作系统一段代码，当操作完成时由操作系统回调。在启动I/O任务和其完成之间，没有涉及CPU工作；这是在相应的磁盘和网络控制器微计算机上完成的。这种方式执行I/O任务被称为I/O线程；它们使用.NET线程池实现，并最终使用操作系统提供的I/O完成端口基础设施。
- en: In ASP.NET, as soon as an asynchronous I/O operation is started from a worker
    thread, it can be returned immediately to the thread pool! While the operation
    is going on, this thread can serve other clients. Finally, when the operation
    signals completion, the ASP.NET infrastructure gets a free worker thread from
    the thread pool (which could be different from the one that started the operation),
    and it finishes the operation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET 中，一旦从工作线程开始异步 I/O 操作，它就可以立即返回到线程池！在操作进行时，此线程可以服务其他客户端。最后，当操作发出完成信号时，ASP.NET
    基础设施从线程池中获取一个空闲的工作线程（可能不同于启动操作的那个线程），并完成操作。
- en: All right; we now understand how important I/O threads are for server applications.
    Unfortunately, it is very hard to check whether any given API uses I/O threads
    under the hood. The only way (besides studying the source code) is simply to know
    which .NET Framework class library leverages I/O threads. In this chapter, we
    will see how to use some of those APIs. You will learn how to work with files
    asynchronously, how to use network I/O to create an HTTP server and call the **Windows
    Communication Foundation** (**WCF**) service, and how to work with an asynchronous
    API to query a database.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧；我们现在已经理解了 I/O 线程对于服务器应用程序的重要性。不幸的是，检查任何给定的 API 是否在底层使用 I/O 线程非常困难。除了研究源代码之外，唯一的方法就是简单地知道哪些
    .NET Framework 类库利用了 I/O 线程。在本章中，我们将看到如何使用这些 API 之一。你将学习如何异步地处理文件，如何使用网络 I/O 创建
    HTTP 服务器并调用 **Windows Communication Foundation** (**WCF**) 服务，以及如何使用异步 API 查询数据库。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another important issue to consider is parallelism. For a number of reasons,
    an intensive parallel disk operation might have very poor performance. Be aware
    that parallel I/O operations are often very ineffective, and it might be reasonable
    to work with I/O sequentially, but in an asynchronous manner.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的重要问题是并行性。由于许多原因，密集的并行磁盘操作可能性能非常差。请注意，并行 I/O 操作通常非常无效，可能合理地以顺序方式处理 I/O，但以异步方式进行。
- en: Working with files asynchronously
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步处理文件
- en: This recipe walks us through how to create a file and how to read and write
    data asynchronously.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例指导我们如何创建文件以及如何异步地读取和写入数据。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe1`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐步执行此示例，你需要 Visual Studio 2015。没有其他先决条件。此示例的源代码可以在 `BookSamples\Chapter9\Recipe1`
    中找到。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to work with files asynchronously, perform the following
    steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何异步处理文件，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program runs, we create four files in different ways and fill them
    up with random data. In the first case, we use the `FileStream` class and its
    methods, converting an Asynchronous Programming Model API to a task; in the second
    case, we do the same, but we provide `FileOptions.Asynchronous` to the `FileStream`
    constructor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们以不同的方式创建四个文件并将它们填充随机数据。在第一种情况下，我们使用 `FileStream` 类及其方法，将异步编程模型 API
    转换为任务；在第二种情况下，我们做同样的事情，但向 `FileStream` 构造函数提供 `FileOptions.Asynchronous`。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is very important to use the `FileOptions.Asynchronous` option. If we omit
    this option, we can still work with the file in an asynchronous manner, but this
    is just an asynchronous delegate invocation on a thread pool! We use the I/O asynchrony
    with the `FileStream` class only if we provide this option (or bool `useAsync`
    in another constructor overload).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FileOptions.Asynchronous` 选项非常重要。如果我们省略此选项，我们仍然可以以异步方式处理文件，但这只是线程池上的异步委托调用！只有当我们提供此选项（或在另一个构造函数重载中提供
    bool `useAsync`）时，我们才使用 `FileStream` 类的 I/O 异步。
- en: The third case uses some simplifying APIs, such as the `File.Create` method
    and the `StreamWriter` class. It still uses I/O threads, which we are able to
    check using the `stream.IsAsync` property. The last case illustrates that oversimplifying
    is also bad. Here, we do not leverage the I/O asynchrony by imitating it with
    the help of asynchronous delegate invocation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个案例使用一些简化的API，例如`File.Create`方法和`StreamWriter`类。它仍然使用I/O线程，我们可以使用`stream.IsAsync`属性来检查。最后一个案例说明了过度简化也是不好的。在这里，我们没有利用I/O异步性，而是通过异步委托调用来模拟它。
- en: Now, we perform parallel asynchronous reading from files, sum up their content,
    and then sum it with each other. Finally, we delete all the files. As there is
    no asynchronous delete file in any non-Windows store application, we simulate
    the asynchrony using the `Task.Run` factory method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们执行从文件的并行异步读取，汇总其内容，然后将其与彼此相加。最后，我们删除所有文件。由于在任何非Windows商店应用程序中都没有异步删除文件，我们使用`Task.Run`工厂方法来模拟异步性。
- en: Writing an asynchronous HTTP server and client
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写异步HTTP服务器和客户端
- en: This recipe shows you how to create a simple asynchronous HTTP server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何创建一个简单的异步HTTP服务器。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe2`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步完成这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter9\Recipe2`中找到。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps demonstrate how to create a simple asynchronous HTTP server:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何创建一个简单的异步HTTP服务器：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: Add a reference to the `System.Net.Http` framework library.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对`System.Net.Http`框架库的引用。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here, we implement a very simple web server using the `HttpListener` class.
    There is also a `TcpListener` class for the TCP socket I/O operations. We configure
    our listener to accept connections from any host to the local machine on port
    `1234`. Then, we start the listener in a separate worker thread so that we can
    control it from the main thread.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`HttpListener`类实现了一个非常简单的Web服务器。还有一个`TcpListener`类用于TCP套接字I/O操作。我们配置监听器以接受来自任何主机到本地机器`1234`端口的连接。然后，我们在一个单独的工作线程中启动监听器，以便我们可以从主线程控制它。
- en: The asynchronous I/O operation happens when we use the `GetContextAsync` method.
    Unfortunately, it does not accept `CancellationToken` for cancelation scenarios;
    so, when we want to stop the server, we just call the `_listener.Abort` method,
    which abandons the connection and stops the server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`GetContextAsync`方法时发生异步I/O操作。不幸的是，它不接受`CancellationToken`用于取消场景；因此，当我们想要停止服务器时，我们只需调用`_listener.Abort`方法，这将放弃连接并停止服务器。
- en: To perform an asynchronous request on this server, we use the `HttpClient` class
    located in the `System.Net.Http` assembly and the same namespace. We use the `GetAsync`
    method to issue an asynchronous HTTP `GET` request. There are methods for other
    HTTP requests such as `POST`, `DELETE`, and `PUT` as well. `HttpClient` has many
    other options such as serializing and deserializing an object using different
    formats, such as XML and JSON, specifying a proxy server address, credentials,
    and so on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此服务器上执行异步请求，我们使用位于`System.Net.Http`程序集和相同命名空间中的`HttpClient`类。我们使用`GetAsync`方法发出异步HTTP
    `GET`请求。还有其他HTTP请求的方法，例如`POST`、`DELETE`和`PUT`等。`HttpClient`还有许多其他选项，例如使用不同的格式（如XML和JSON）序列化和反序列化对象，指定代理服务器地址、凭据等。
- en: When you run the program, you can see that the server has been started up. In
    the server code, we use the `GetContextAsync` method to accept new client connections.
    This method returns when a new client connects, and we simply output a very basic
    HTML language with the current date and time to the response. Then, we request
    the server and print the response headers and content. You can also open your
    browser and browse to `http://localhost:1234/`. Here, you will see the same response
    displayed in the browser window.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行程序时，您可以看到服务器已经启动。在服务器代码中，我们使用 `GetContextAsync` 方法来接受新的客户端连接。此方法在新客户端连接时返回，我们只需将当前日期和时间输出为非常基本的
    HTML 语言到响应中。然后，我们请求服务器并打印响应头和内容。您还可以打开浏览器并浏览到 `http://localhost:1234/`。在这里，您将在浏览器窗口中看到相同的响应。
- en: Working with a database asynchronously
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步处理数据库
- en: This recipe walks us through the process of creating a database, populating
    it with data, and reading data asynchronously.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将引导我们通过创建数据库、用数据填充它以及异步读取数据的过程。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe3`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要 Visual Studio 2015。无需其他先决条件。此配方的源代码可在 `BookSamples\Chapter9\Recipe3`
    中找到。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the process of creating a database, populating it with data,
    and reading data asynchronously, perform the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解创建数据库、用数据填充它以及异步读取数据的过程，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This program works with software called SQL Server 2014 LocalDb. It is installed
    with Visual Studio 2015 and should work fine. However, in case of errors, you
    might want to repair this component from the installation wizard.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序与名为 SQL Server 2014 LocalDb 的软件一起工作。它与 Visual Studio 2015 一起安装，应该可以正常工作。然而，如果出现错误，您可能希望从安装向导中修复此组件。
- en: 'We start with configuring paths to our database files. We place database files
    in the program-execution folder. There will be two files: one for the database
    itself and another for the transaction log file. We also configure two connection
    strings that define how we connect to our databases. The first one is to connect
    to the LocalDb engine to detach our database; if it already exists, delete and
    then recreate it. We leverage the I/O asynchrony while opening the connection
    and while executing the SQL commands using the `OpenAsync` and `ExecuteNonQueryAsync`
    methods, respectively.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先配置到数据库文件的路径。我们将数据库文件放置在程序执行文件夹中。将有两个文件：一个用于数据库本身，另一个用于事务日志文件。我们还配置了两个连接字符串，用于定义我们如何连接到数据库。第一个是连接到
    LocalDb 引擎以分离数据库；如果它已经存在，则删除并重新创建它。我们在打开连接和执行 SQL 命令时利用 I/O 异步性，分别使用 `OpenAsync`
    和 `ExecuteNonQueryAsync` 方法。
- en: After this task is completed, we attach a newly created database. Here, we create
    a new table and insert some data in it. In addition to the previously mentioned
    methods, we use `ExecuteScalarAsync` to asynchronously get a scalar value from
    the database engine, and we use the `SqlDataReader.ReadAsync` method to read a
    data row from the database table asynchronously.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务完成后，我们附加一个新创建的数据库。在这里，我们创建一个新表并在其中插入一些数据。除了之前提到的方法外，我们还使用 `ExecuteScalarAsync`
    以异步方式从数据库引擎获取标量值，并使用 `SqlDataReader.ReadAsync` 方法异步地从数据库表读取数据行。
- en: If we had a large table with large binary values in its rows in our database,
    then we would use the `CommandBehavior.SequentialAcess` enumeration to create
    the data reader and the `GetFieldValueAsync` method to get large field values
    from the reader asynchronously.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据库中有一个大表，其行包含大二进制值，那么我们会使用 `CommandBehavior.SequentialAcess` 枚举来创建数据读取器，并使用
    `GetFieldValueAsync` 方法异步地从读取器获取大字段值。
- en: Calling a WCF service asynchronously
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步调用 WCF 服务
- en: This recipe will describe how to create a WCF service, how to host it in a console
    application, how to make service metadata available to clients, and how to consume
    it in an asynchronous way.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将描述如何创建 WCF 服务，如何在控制台应用程序中托管它，如何使服务元数据对客户端可用，以及如何以异步方式使用它。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe4`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要Visual Studio 2015。没有其他先决条件。此配方的源代码可以在`BookSamples\Chapter9\Recipe4`中找到。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to work with a WCF service, perform the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用WCF服务，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: Add references to the `System.ServiceModel` library. Right-click on the `References`
    folder in the project and select the **Add reference…** menu option. Add references
    to the `System.ServiceModel` library. You can use the search function in the reference
    manager dialog, as shown in the following screenshot:![How to do it...](img/B05292_09_01.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对`System.ServiceModel`库的引用。在项目中的`References`文件夹上右键单击，并选择**添加引用…**菜单选项。添加对`System.ServiceModel`库的引用。您可以在引用管理器对话框中使用搜索功能，如图所示：![如何操作...](img/B05292_09_01.jpg)
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: WCF is a framework that allows us to call remote services in different ways.
    One of them, which was very popular some time ago, was used to call remote services
    via HTTP using an XML-based protocol called the **Simple Object Access Protocol**
    (**SOAP)**. It is quite common when a server application calls another remote
    service, and this could be done using I/O threads as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: WCF是一个框架，允许我们以不同的方式调用远程服务。其中之一，在一段时间前非常流行，是通过使用基于XML的协议**简单对象访问协议**（**SOAP**）通过HTTP调用远程服务。当服务器应用程序调用另一个远程服务时，这是很常见的，并且可以使用I/O线程来完成。
- en: Visual Studio 2015 has rich support for WCF services; for example, you can add
    references to such services with the **Add Service Reference** menu option. You
    could do this with our service as well because we provide service metadata.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015对WCF服务提供了丰富的支持；例如，您可以使用**添加服务引用**菜单选项添加对这类服务的引用。您也可以用我们的服务来做这件事，因为我们提供了服务元数据。
- en: To create such a service, we need to use a `ServiceHost` class that will host
    our service. We describe what service we will be hosting by providing a service
    implementation type and the base URI by which the service will be addressed. Then,
    we configure the metadata endpoint and the service endpoint. Finally, we handle
    the `Faulted` event in case of errors and run the host service.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这样的服务，我们需要使用`ServiceHost`类来托管我们的服务。我们通过提供服务实现类型和基础URI来描述我们将托管的服务。然后，我们配置元数据端点和服务端点。最后，在出现错误时处理`Faulted`事件，并运行托管服务。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Be aware that we need to have administrator privileges to run the service,
    since it uses HTTP bindings, which in turn use `http.sys` and thus require special
    permissions to be created. You can run Visual Studio under an administrator or
    run the following command in the elevated command prompt to add the necessary
    permissions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于它使用HTTP绑定，而HTTP绑定又使用`http.sys`，因此需要特殊权限来创建，我们需要有管理员权限来运行服务。您可以在管理员模式下运行Visual
    Studio，或者在提升的命令提示符中运行以下命令来添加必要的权限：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To consume this service, we create a client, and here is where the main trick
    happens. On the server side, we have a service with the usual synchronous method
    called `Greet`. This method is defined in the service contract, `IHelloWorldService`.
    However, if we want to leverage an asynchronous network I/O, we have to call this
    method asynchronously. We can do that by creating a new service contract with
    a matching namespace and service name, where we define both the synchronous and
    task-based asynchronous methods. In spite of the fact that we do not have an asynchronous
    method definition on the server side, we follow the naming convention, and the
    WCF infrastructure understands that we want to create an asynchronous proxy method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要消费此服务，我们创建一个客户端，这里就是主要技巧所在。在服务器端，我们有一个名为`Greet`的常规同步方法。此方法在服务合同`IHelloWorldService`中定义。然而，如果我们想利用异步网络I/O，我们必须异步调用此方法。我们可以通过创建一个新的服务合同，其中包含匹配的命名空间和服务名称，来定义同步和基于任务异步方法。尽管在服务器端我们没有异步方法定义，但我们遵循命名约定，WCF基础设施理解我们想要创建一个异步代理方法。
- en: Therefore, when we create an `IHelloWorldServiceClient` proxy channel, and WCF
    correctly routes an asynchronous call to the server-side synchronous method, if
    you leave the application running, you can open the browser and access the service
    using its URL, that is, `http://localhost:1234/HelloWorld`. A service description
    will be opened, and you can browse to the XML metadata that allows us to add a
    service reference from Visual Studio 2012\. If you try to generate the reference,
    you will see slightly more complicated code, but it is autogenerated and easy
    to use.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们创建一个 `IHelloWorldServiceClient` 代理通道，并且 WCF 正确地将异步调用路由到服务器端的同步方法时，如果你让应用程序继续运行，你可以打开浏览器并使用其
    URL 访问服务，即 `http://localhost:1234/HelloWorld`。将打开一个服务描述，你可以浏览到允许我们从 Visual Studio
    2012 添加服务引用的 XML 元数据。如果你尝试生成引用，你会看到稍微复杂一些的代码，但它是由自动生成的，并且易于使用。
