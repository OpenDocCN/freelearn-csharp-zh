["```cs\n    <ItemGroup>\n      <Using Include=\"System.Console\" Static=\"true\" />\n    </ItemGroup> \n    ```", "```cs\n    namespace Packt.Shared;\n    public class Person\n    {\n      #region Properties\n      public string? Name { get; set; }\n      public DateTimeOffset Born { get; set; }\n      public List<Person> Children { get; set; } = new();\n      #endregion\n      #region Methods\n      public void WriteToConsole()\n      {\n        WriteLine($\"{Name} was born on a {Born:dddd}.\");\n      }\n      public void WriteChildrenToConsole()\n      {\n        string term = Children.Count == 1 ? \"child\" : \"children\";\n        WriteLine($\"{Name} has {Children.Count} {term}.\");\n      }\n      #endregion\n    } \n    ```", "```cs\n    <ItemGroup>\n      <ProjectReference\n        Include=\"..\\PacktLibrary\\PacktLibrary.csproj\" />\n    </ItemGroup> \n    ```", "```cs\n    using Packt.Shared;\n    Person harry = new()\n    {\n      Name = \"Harry\",\n      Born = new(year: 2001, month: 3, day: 25,\n        hour: 0, minute: 0, second: 0,\n        offset: TimeSpan.Zero)\n    };\n    harry.WriteToConsole(); \n    ```", "```cs\n    Harry was born on a Sunday. \n    ```", "```cs\n    // Allow multiple spouses to be stored for a person.\n    public List<Person> Spouses { get; set; } = new();\n    // A read-only property to show if a person is married to anyone.\n    public bool Married => Spouses.Count > 0; \n    ```", "```cs\n    // Static method to marry two people.\n    public static void Marry(Person p1, Person p2)\n    {\n      ArgumentNullException.ThrowIfNull(p1);\n      ArgumentNullException.ThrowIfNull(p2);\n      if (p1.Spouses.Contains(p2) || p2.Spouses.Contains(p1))\n      {\n        throw new ArgumentException(\n          string.Format(\"{0} is already married to {1}.\",\n          arg0: p1.Name, arg1: p2.Name));\n      }\n      p1.Spouses.Add(p2);\n      p2.Spouses.Add(p1);\n    }\n    // Instance method to marry another person.\n    public void Marry(Person partner)\n    {\n      Marry(this, partner); // \"this\" is the current person.\n    } \n    ```", "```cs\n    public void OutputSpouses()\n    {\n      if (Married)\n      {\n        string term = Spouses.Count == 1 ? \"person\" : \"people\";\n        WriteLine($\"{Name} is married to {Spouses.Count} {term}:\");\n        foreach (Person spouse in Spouses)\n        {\n          WriteLine($\"  {spouse.Name}\");\n        }\n      }\n      else\n      {\n        WriteLine($\"{Name} is a singleton.\");\n      }\n    } \n    ```", "```cs\n    /// <summary>\n    /// Static method to \"multiply\" aka procreate and have a child together.\n    /// </summary>\n    /// <param name=\"p1\">Parent 1</param>\n    /// <param name=\"p2\">Parent 2</param>\n    /// <returns>A Person object that is the child of Parent 1 and Parent 2.</returns>\n    /// <exception cref=\"ArgumentNullException\">If p1 or p2 are null.</exception>\n    /// <exception cref=\"ArgumentException\">If p1 and p2 are not married.</exception>\n    public static Person Procreate(Person p1, Person p2)\n    {\n      ArgumentNullException.ThrowIfNull(p1);\n      ArgumentNullException.ThrowIfNull(p2);\n      if (!p1.Spouses.Contains(p2) && !p2.Spouses.Contains(p1))\n      {\n        throw new ArgumentException(string.Format(\n          \"{0} must be married to {1} to procreate with them.\",\n          arg0: p1.Name, arg1: p2.Name));\n      }\n      Person baby = new()\n      {\n        Name = $\"Baby of {p1.Name} and {p2.Name}\",\n        Born = DateTimeOffset.Now\n      };\n      p1.Children.Add(baby);\n      p2.Children.Add(baby);\n      return baby;\n    }\n    // Instance method to \"multiply\".\n    public Person ProcreateWith(Person partner)\n    {\n      return Procreate(this, partner);\n    } \n    ```", "```cs\n// Implementing functionality using methods.\nPerson lamech = new() { Name = \"Lamech\" };\nPerson adah = new() { Name = \"Adah\" };\nPerson zillah = new() { Name = \"Zillah\" };\n// Call the instance method to marry Lamech and Adah.\nlamech.Marry(adah);\n// Call the static method to marry Lamech and Zillah.\nPerson.Marry(lamech, zillah);\nlamech.OutputSpouses();\nadah.OutputSpouses();\nzillah.OutputSpouses();\n// Call the instance method to make a baby.\nPerson baby1 = lamech.ProcreateWith(adah);\nbaby1.Name = \"Jabal\";\nWriteLine($\"{baby1.Name} was born on {baby1.Born}\");\n// Call the static method to make a baby.\nPerson baby2 = Person.Procreate(zillah, lamech);\nbaby2.Name = \"Tubalcain\";\nadah.WriteChildrenToConsole();\nzillah.WriteChildrenToConsole();\nlamech.WriteChildrenToConsole();\nfor (int i = 0; i < lamech.Children.Count; i++)\n{\n  WriteLine(format: \"  {0}'s child #{1} is named \\\"{2}\\\".\",\n    arg0: lamech.Name, arg1: i,\n    arg2: lamech.Children[i].Name);\n} \n```", "```cs\nLamech is married to 2 people:\n  Adah\n  Zillah\nAdah is married to 1 person:\n  Lamech\nZillah is married to 1 person:\n  Lamech\nJabal was born on 05/07/2023 15:17:03 +01:00\nAdah has 1 child.\nZillah has 1 child.\nLamech has 2 children:\n  Lamech's child #0 is named \"Jabal\".\n  Lamech's child #1 is named \"Tubalcain\". \n```", "```cs\nstring s1 = \"Hello \";\nstring s2 = \"World!\";\nstring s3 = string.Concat(s1, s2);\nWriteLine(s3); // Hello World! \n```", "```cs\nstring s3 = s1 + s2; \n```", "```cs\n    #region Operators\n    // Define the + operator to \"marry\".\n    public static bool operator +(Person p1, Person p2)\n    {\n      Marry(p1, p2);\n      // Confirm they are both now married.\n      return p1.Married && p2.Married;\n    }\n    #endregion \n    ```", "```cs\n    // Define the * operator to \"multiply\".\n    public static Person operator *(Person p1, Person p2)\n    {\n      // Return a reference to the baby that results from multiplying.\n      return Procreate(p1, p2);\n    } \n    ```", "```cs\n    // Person.Marry(lamech, zillah);\n    if (lamech + zillah)\n    {\n      WriteLine($\"{lamech.Name} and {zillah.Name} successfully got married.\");\n    } \n    ```", "```cs\n    // Use the * operator to \"multiply\".\n    Person baby3 = lamech * adah;\n    baby3.Name = \"Jubal\";\n    Person baby4 = zillah * lamech;\n    baby4.Name = \"Naamah\"; \n    ```", "```cs\n    Lamech and Zillah successfully got married.\n    Lamech is married to 2 people:\n      Adah\n      Zillah\n    Adah is married to 1 person:\n      Lamech\n    Zillah is married to 1 person:\n      Lamech\n    Jabal was born on 05/07/2023 15:27:30 +01:00\n    Adah has 2 children.\n    Zillah has 2 children.\n    Lamech has 4 children:\n      Lamech's child #0 is named \"Jabal\".\n      Lamech's child #1 is named \"Tubalcain\".\n      Lamech's child #2 is named \"Jubal\".\n      Lamech's child #3 is named \"Naamah\". \n    ```", "```cs\n    // Non-generic lookup collection.\n    System.Collections.Hashtable lookupObject = new();\n    lookupObject.Add(key: 1, value: \"Alpha\");\n    lookupObject.Add(key: 2, value: \"Beta\");\n    lookupObject.Add(key: 3, value: \"Gamma\");\n    lookupObject.Add(key: harry, value: \"Delta\"); \n    ```", "```cs\n    int key = 2; // Look up the value that has 2 as its key.\n    WriteLine(format: \"Key {0} has value: {1}\",\n      arg0: key,\n      arg1: lookupObject[key]); \n    ```", "```cs\n    // Look up the value that has harry as its key.\n    WriteLine(format: \"Key {0} has value: {1}\",\n      arg0: harry,\n      arg1: lookupObject[harry]); \n    ```", "```cs\n    Key 2 has value: Beta\n    Key Packt.Shared.Person has value: Delta \n    ```", "```cs\n    // Define a generic lookup collection.\n    Dictionary<int, string> lookupIntString = new();\n    lookupIntString.Add(key: 1, value: \"Alpha\");\n    lookupIntString.Add(key: 2, value: \"Beta\");\n    lookupIntString.Add(key: 3, value: \"Gamma\");\n    lookupIntString.Add(key: harry, value: \"Delta\"); \n    ```", "```cs\n    /Users/markjprice/Code/Chapter06/PeopleApp/Program.cs(98,32): error CS1503: Argument 1: cannot convert from 'Packt.Shared.Person' to 'int' [/Users/markjprice/Code/Chapter06/PeopleApp/PeopleApp.csproj] \n    ```", "```cs\n    key = 3;\n    WriteLine(format: \"Key {0} has value: {1}\",\n      arg0: key,\n      arg1: lookupIntString[key]); \n    ```", "```cs\n    Key 3 has value: Gamma \n    ```", "```cs\npublic class Person\n{\n  public int MethodIWantToCall(string input)\n  {\n    return input.Length; // It doesn't matter what the method does.\n  } \n```", "```cs\nPerson p1 = new();\nint answer = p1.MethodIWantToCall(\"Frog\"); \n```", "```cs\ndelegate int DelegateWithMatchingSignature(string s); \n```", "```cs\n// Create a delegate instance that points to the method.\nDelegateWithMatchingSignature d = new(p1.MethodIWantToCall);\n// Call the delegate, which then calls the method.\nint answer2 = d(\"Frog\"); \n```", "```cs\n// For methods that do not need additional argument values passed in.\npublic delegate void EventHandler(object? sender, EventArgs e);\n// For methods that need additional argument values passed in as\n// defined by the generic type TEventArgs.\npublic delegate void EventHandler<TEventArgs>(object? sender, TEventArgs e); \n```", "```cs\npublic EventHandler? Shout; // This field could be null. \n```", "```cs\n    Shout(this, EventArgs.Empty); \n    ```", "```cs\n    Shout.Invoke(this, EventArgs.Empty); \n    ```", "```cs\n    IAsyncResult result = Shout.BeginInvoke(\n      this, EventArgs.Empty, null, null); \n    ```", "```cs\n    #region Events\n    // Delegate field to define the event.\n    public EventHandler? Shout; // null initially.\n    // Data field related to the event.\n    public int AngerLevel;\n    // Method to trigger the event in certain conditions.\n    public void Poke()\n    {\n      AngerLevel++;\n      if (AngerLevel < 3) return;\n      // If something is listening to the event...\n      if (Shout is not null)\n      {\n        // ...then call the delegate to \"raise\" the event.\n        Shout(this, EventArgs.Empty);\n      }\n    }\n    #endregion \n    ```", "```cs\n    using Packt.Shared; // To use Person.\n    // No namespace declaration so this extends the Program class\n    // in the null namespace.\n    partial class Program\n    {\n      // A method to handle the Shout event received by the harry object.\n      private static void Harry_Shout(object? sender, EventArgs e)\n      {\n        // If no sender, then do nothing.\n        if (sender is null) return;\n        // If sender is not a Person, then do nothing and return; else assign sender to p.\n        if (sender is not Person p) return;\n        WriteLine($\"{p.Name} is this angry: {p.AngerLevel}.\");\n      }\n    } \n    ```", "```cs\n    // Assign the method to the Shout delegate.\n    harry.Shout = Harry_Shout;\n    // Call the Poke method that eventually raises the Shout event.\n    harry.Poke();\n    harry.Poke();\n    harry.Poke();\n    harry.Poke(); \n    ```", "```cs\n    Harry is this angry: 3.\n    Harry is this angry: 4. \n    ```", "```cs\n// If sender is not a Person, then do nothing and return; else assign sender to p.\nif (sender is not Person p) return;\nWriteLine($\"{p.Name} is this angry: {p.AngerLevel}.\"); \n```", "```cs\n    public **event** EventHandler? Shout; \n    ```", "```cs\n    Program.cs(41,13): error CS0079: The event 'Person.Shout' can only appear on the left hand side of += or -= \n    ```", "```cs\n    // Assign the method to the Shout **event** delegate.\n    harry.Shout **+**= Harry_Shout; \n    ```", "```cs\n    // Another method to handle the event received by the harry object.\n    private static void Harry_Shout_2(object? sender, EventArgs e)\n    {\n      WriteLine(\"Stop it!\");\n    } \n    ```", "```cs\n    // Assign the method**(s)** to the Shout event delegate.\n    harry.Shout += Harry_Shout;\n    **harry.Shout += Harry_Shout_2;** \n    ```", "```cs\n    Harry is this angry: 3.\n    Stop it!\n    Harry is this angry: 4.\n    Stop it! \n    ```", "```cs\nnamespace System\n{\n  public interface IComparable\n  {\n    int CompareTo(object? obj);\n  }\n  public interface IComparable<in T>\n  {\n    int CompareTo(T? other);\n  }\n} \n```", "```cs\n    using Packt.Shared;\n    partial class Program\n    {\n      private static void OutputPeopleNames(\n        IEnumerable<Person?> people, string title)\n      {\n        WriteLine(title);\n        foreach (Person? p in people)\n        {\n          WriteLine(\"  {0}\",\n            p is null ? \"<null> Person\" : p.Name ?? \"<null> Name\");\n          /* if p is null then output: <null> Person\n             else output: p.Name\n             unless p.Name is null then output: <null> Name */\n        }\n      }\n    } \n    ```", "```cs\n    Person?[] people =\n    {\n      null,\n      new() { Name = \"Simon\" },\n      new() { Name = \"Jenny\" },\n      new() { Name = \"Adam\" },\n      new() { Name = null },\n      new() { Name = \"Richard\" }\n    };\n    OutputPeopleNames(people, \"Initial list of people:\");\n    Array.Sort(people);\n    OutputPeopleNames(people,\n      \"After sorting using Person's IComparable implementation:\"); \n    ```", "```cs\n    Unhandled Exception: System.InvalidOperationException: Failed to compare two elements in the array. ---> System.ArgumentException: At least one object must implement IComparable. \n    ```", "```cs\n    public class Person :**IComparable****<****Person****?>** \n    ```", "```cs\n    public int CompareTo(Person? other)\n    {\n      throw new NotImplementedException();\n    } \n    ```", "```cs\n    int position;\n    if (other is not null)\n    {\n      if ((Name is not null) && (other.Name is not null))\n      {\n        // If both Name values are not null, then\n        // use the string implementation of CompareTo.\n        position = Name.CompareTo(other.Name);\n      }\n      else if ((Name is not null) && (other.Name is null))\n      {\n        position = -1; // this Person precedes other Person.\n      }\n      else if ((Name is null) && (other.Name is not null))\n      {\n        position = 1; // this Person follows other Person.\n      }\n      else // Name and other.Name are both null.\n      {\n        position = 0; // this and other are at same position.\n      }\n    }\n    else if (other is null)\n    {\n      position = -1; // this Person precedes other Person.\n    }\n    else // this and other are both null.\n    {\n      position = 0; // this and other are at same position.\n    }\n    return position; \n    ```", "```cs\n    Initial list of people:\n      Simon\n      <null> Person\n      Jenny\n      Adam\n      <null> Name\n      Richard\n    After sorting using Person's IComparable implementation:\n      Adam\n      Jenny\n      Richard\n      Simon\n      <null> Name\n      <null> Person \n    ```", "```cs\n    namespace Packt.Shared;\n    public class PersonComparer : IComparer<Person?>\n    {\n      public int Compare(Person? x, Person? y)\n      {\n        int position;\n        if ((x is not null) && (y is not null))\n        {\n          if ((x.Name is not null) && (y.Name is not null))\n          {\n            // If both Name values are not null...\n            // ...then compare the Name lengths...\n            int result = x.Name.Length.CompareTo(y.Name.Length);\n            // ...and if they are equal...\n            if (result == 0)\n            {\n              // ...then compare by the Names...\n              return x.Name.CompareTo(y.Name);\n            }\n            else\n            {\n              // ...otherwise compare by the lengths.\n              position = result;\n            }\n          }\n          else if ((x.Name is not null) && (y.Name is null))\n          {\n            position = -1; // x Person precedes y Person.\n          }\n          else if ((x.Name is null) && (y.Name is not null))\n          {\n            position = 1; // x Person follows y Person.\n          }\n          else // x.Name and y.Name are both null.\n          {\n            position = 0; // x and y are at same position.\n          }\n        }\n        else if ((x is not null) && (y is null))\n        {\n          position = -1; // x Person precedes y Person.\n        }\n        else if ((x is null) && (y is not null))\n        {\n          position = 1; // x Person follows y Person.\n        }\n        else // x and y are both null.\n        {\n          position = 0; // x and y are at same position.\n        }\n        return position;\n      }\n    } \n    ```", "```cs\n    Array.Sort(people, new PersonComparer());\n    OutputPeopleNames(people,\n      \"After sorting using PersonComparer's IComparer implementation:\"); \n    ```", "```cs\n    After sorting using PersonComparer's IComparer implementation:\n      Adam\n      Jenny\n      Simon\n      Richard\n      <null> Name\n      <null> Person \n    ```", "```cs\npublic interface IGamePlayer // Defaults to internal.\n{\n  void Lose(); // Defaults to public. Could be set to internal.\n}\npublic interface IKeyHolder\n{\n  void Lose();\n}\npublic class Human : IGamePlayer, IKeyHolder\n{\n  // Implicit implementation must be public.\n  public void Lose() // Implicit implementation.\n  {\n    // Implement losing a key.\n    WriteLine(\"Implementation for losing a key.\");\n  }\n  // Explicit implementation can be any access modifier.\n  void IGamePlayer.Lose() // Defaults to private.\n  {\n    // Implement losing a game.\n    WriteLine(\"Implementation for losing a game.\");\n  }\n}\nHuman human = new();\nhuman.Lose(); // Calls implicit implementation of losing a key.\n// Outputs: Implementation for losing a key.\n((IGamePlayer)human).Lose(); // Calls explicit implementation of losing a game.\n// Outputs: Implementation for losing a game.\n// Alternative way to do the same.\nIGamePlayer player = human as IGamePlayer;\nplayer.Lose(); // Calls explicit implementation of losing a game.\n// Outputs: Implementation for losing a game. \n```", "```cs\n    namespace Packt.Shared;\n    public interface IPlayable\n    {\n      void Play();\n      void Pause();\n    } \n    ```", "```cs\n    namespace Packt.Shared;\n    public class DvdPlayer : IPlayable\n    {\n      public void Pause()\n      {\n        WriteLine(\"DVD player is pausing.\");\n      }\n      public void Play()\n      {\n        WriteLine(\"DVD player is playing.\");\n      }\n    } \n    ```", "```cs\n    namespace Packt.Shared;\n    public interface IPlayable\n    {\n      void Play();\n      void Pause();\n    **void****Stop****()** **// Default interface implementation.**\n     **{**\n     **WriteLine(****\"Default implementation of Stop.\"****);**\n     **}**\n    } \n    ```", "```cs\n    int thisCannotBeNull  = 4;\n    thisCannotBeNull = null; // CS0037 compiler error!\n    WriteLine(thisCannotBeNull);\n    int? thisCouldBeNull = null;\n    WriteLine(thisCouldBeNull);\n    WriteLine(thisCouldBeNull.GetValueOrDefault());\n    thisCouldBeNull = 7;\n    WriteLine(thisCouldBeNull);\n    WriteLine(thisCouldBeNull.GetValueOrDefault()); \n    ```", "```cs\n    Cannot convert null to 'int' because it is a non-nullable value type \n    ```", "```cs\n    //thisCannotBeNull = null; // CS0037 compiler error! \n    ```", "```cs\n    4\n    0\n    7\n    7 \n    ```", "```cs\n    // The actual type of int? is Nullable<int>.\n    Nullable<int> thisCouldAlsoBeNull = null;\n    thisCouldAlsoBeNull = 9;\n    WriteLine(thisCouldAlsoBeNull); \n    ```", "```cs\nstring firstName; // Allows null but gives warning when\npotentially null.\nstring? lastName; // Allows null and does not give warning if\nnull. \n```", "```cs\n<PropertyGroup>\n  ...\n **<Nullable>enable</Nullable>**\n</PropertyGroup> \n```", "```cs\n<PropertyGroup>\n  ...\n **<Nullable>disable</Nullable>**\n</PropertyGroup> \n```", "```cs\n#nullable disable \n```", "```cs\n#nullable enable \n```", "```cs\n<NoWarn>CS8600;CS8602</NoWarn> \n```", "```cs\n#pragma warning disable CS8602\nWriteLine(firstName.Length);\nWriteLine(lastName.Length);\n#pragma warning restore CS8602 \n```", "```cs\n    namespace Packt.Shared;\n    public class Address\n    {\n      public string? Building;\n      public string Street;\n      public string City;\n      public string Region;\n    } \n    ```", "```cs\n    public string Street **=** **string****.Empty**;\n    public string City;\n    public string Region;\n    **public****Address****()**\n    **{**\n     **City =** **string****.Empty;**\n     **Region =** **string****.Empty;**\n    **}**\n    **// Call the default parameterless constructor**\n    **// to ensure that Region is also set.**\n    **public****Address****(****string** **city****) :** **this****()**\n    **{**\n     **City = city;**\n    **}** \n    ```", "```cs\n    using Packt.Shared; // To use Address. \n    ```", "```cs\n    Address address = new(city: \"London\")\n    {\n      Building = null,\n      Street = null,\n      Region = \"UK\"\n    }; \n    ```", "```cs\n    CS8625 Cannot convert null literal to non-nullable reference type. \n    ```", "```cs\n    Street = null**!**, // null-forgiving operator. \n    ```", "```cs\n    WriteLine(address.Building.Length);\n    WriteLine(address.Street.Length); \n    ```", "```cs\n    CS8602 Dereference of a possibly null reference. \n    ```", "```cs\n    WriteLine(address.Building?.Length); \n    ```", "```cs\n    Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object. \n    ```", "```cs\n    if (address.Street is not null)\n    {\n      WriteLine(address.Street.Length);\n    } \n    ```", "```cs\n// Check that the variable is not null before using it.\nif (thisCouldBeNull != null)\n{\n  // Access a member of thisCouldBeNull.\n  int length = thisCouldBeNull.Length;\n  ...\n} \n```", "```cs\nif (!(thisCouldBeNull is null))\n{ \n```", "```cs\nif (thisCouldBeNull is not null)\n{ \n```", "```cs\nstring authorName = null;\nint? authorNameLength;\n// The following throws a NullReferenceException.\nauthorNameLength = authorName.Length;\n// Instead of throwing an exception, null is assigned.\nauthorNameLength = authorName?.Length; \n```", "```cs\n// Result will be 25 if authorName?.Length is null.\nauthorNameLength = authorName?.Length ?? 25; \n```", "```cs\npublic void Hire(Person manager, Person employee)\n{\n  if (manager is null)\n  {\n    throw new ArgumentNullException(paramName: nameof(manager));\n  }\n  if (employee is null)\n  {\n    throw new ArgumentNullException(paramName: nameof(employee));\n  }\n  ...\n} \n```", "```cs\npublic void Hire(Person manager, Person employee)\n{\n  ArgumentNullException.ThrowIfNull(manager);\n  ArgumentNullException.ThrowIfNull(employee);\n  ...\n} \n```", "```cs\npublic void Hire(Person manager!!, Person employee!!)\n{\n  ...\n} \n```", "```cs\n    namespace Packt.Shared;\n    public class Employee : Person\n    {\n    } \n    ```", "```cs\n    Employee john = new()\n    {\n      Name = \"John Jones\",\n      Born = new(year: 1990, month: 7, day: 28,\n        hour: 0, minute: 0, second: 0, offset: TimeSpan.Zero)\n    };\n    john.WriteToConsole(); \n    ```", "```cs\n    John Jones was born on a Saturday. \n    ```", "```cs\n    public string? EmployeeCode { get; set; }\n    public DateOnly HireDate { get; set; } \n    ```", "```cs\n    john.EmployeeCode = \"JJ001\";\n    john.HireDate = new(year: 2014, month: 11, day: 23);\n    WriteLine($\"{john.Name} was hired on {john.HireDate:yyyy-MM-dd}.\"); \n    ```", "```cs\n    John Jones was hired on 2014-11-23. \n    ```", "```cs\n    namespace Packt.Shared;\n    public class Employee : Person\n    {\n      public string? EmployeeCode { get; set; }\n      public DateOnly HireDate { get; set; }\n    **public****void****WriteToConsole****()**\n     **{**\n     **WriteLine(format:**\n    **\"{0} was born on {1:dd/MM/yy} and hired on {2:dd/MM/yy}.\"****,**\n     **arg0: Name, arg1: Born, arg2: HireDate);**\n     **}**\n    } \n    ```", "```cs\n    John Jones was born on 28/07/90 and hired on 01/01/01.\n    John Jones was hired on 2014-11-23. \n    ```", "```cs\npublic **new** void WriteToConsole() \n```", "```cs\n    WriteLine(john.ToString()); \n    ```", "```cs\n    Packt.Shared.Employee \n    ```", "```cs\n    #region Overridden methods\n    public override string ToString()\n    {\n      return $\"{Name} is a {base.ToString()}.\";\n    }\n    #endregion \n    ```", "```cs\nprotected internal virtual void OnConfiguring(\nDbContextOptionsBuilder optionsBuilder)\n{\n} \n```", "```cs\n    John Jones is a Packt.Shared.Employee. \n    ```", "```cs\npublic interface INoImplementation // C# 1 and later.\n{\n  void Alpha(); // Must be implemented by derived type.\n}\npublic interface ISomeImplementation // C# 8 and later.\n{\n  void Alpha(); // Must be implemented by derived type.\n  void Beta()\n  {\n    // Default implementation; can be overridden.\n  }\n}\npublic abstract class PartiallyImplemented // C# 1 and later.\n{\n  public abstract void Gamma(); // Must be implemented by derived type.\n  public virtual void Delta() // Can be overridden.\n  {\n    // Implementation.\n  }\n}\npublic class FullyImplemented : PartiallyImplemented, ISomeImplementation\n{\n  public void Alpha()\n  {\n    // Implementation.\n  }\n  public override void Gamma()\n  {\n    // Implementation.\n  }\n}\n// You can only instantiate the fully implemented class.\nFullyImplemented a = new();\n// All the other types give compile errors.\nPartiallyImplemented b = new(); // Compile error!\nISomeImplementation c = new(); // Compile error!\nINoImplementation d = new(); // Compile error! \n```", "```cs\npublic sealed class ScroogeMcDuck\n{\n} \n```", "```cs\nnamespace Packt.Shared;\npublic class Singer\n{\n  // Virtual allows this method to be overridden.\n  public virtual void Sing()\n  {\n    WriteLine(\"Singing...\");\n  }\n}\npublic class LadyGaga : Singer\n{\n  // The sealed keyword prevents overriding the method in subclasses.\n  public sealed override void Sing()\n  {\n    WriteLine(\"Singing with style...\");\n  }\n} \n```", "```cs\n    public override string ToString()\n    {\n      return $\"{Name}'s code is {EmployeeCode}.\";\n    } \n    ```", "```cs\n    Employee aliceInEmployee = new()\n      { Name = \"Alice\", EmployeeCode = \"AA123\" };\n    Person aliceInPerson = aliceInEmployee;\n    aliceInEmployee.WriteToConsole();\n    aliceInPerson.WriteToConsole();\n    WriteLine(aliceInEmployee.ToString());\n    WriteLine(aliceInPerson.ToString()); \n    ```", "```cs\n    Alice was born on 01/01/01 and hired on 01/01/01\n    Alice was born on a Monday\n    Alice's code is AA123\n    Alice's code is AA123 \n    ```", "```cs\n    Employee explicitAlice = aliceInPerson; \n    ```", "```cs\n    Employee explicitAlice = **(Employee)**aliceInPerson; \n    ```", "```cs\n    **if** **(aliceInPerson** **is** **Employee)**\n    **{**\n     **WriteLine(****$\"****{****nameof****(aliceInPerson)}** **is an Employee.\"****);**\n      Employee explicitAlice = (Employee)aliceInPerson;\n    **// Safely do something with explicitAlice.**\n    **}** \n    ```", "```cs\n    aliceInPerson is an Employee. \n    ```", "```cs\nif (aliceInPerson is Employee explicitAlice)\n{\n  WriteLine($\"{nameof(aliceInPerson)} is an Employee.\");\n  // Safely do something with explicitAlice.\n} \n```", "```cs\nif (!(aliceInPerson is Employee)) \n```", "```cs\nif (aliceInPerson is not Employee) \n```", "```cs\n    Employee? aliceAsEmployee = aliceInPerson as Employee;\n    if (aliceAsEmployee is not null)\n    {\n      WriteLine($\"{nameof(aliceInPerson)} as an Employee.\");\n      // Safely do something with aliceAsEmployee.\n    } \n    ```", "```cs\n    aliceInPerson as an Employee. \n    ```", "```cs\n    namespace Packt.Shared;\n    public class PersonException : Exception\n    {\n      public PersonException() : base() { }\n      public PersonException(string message) : base(message) { }\n      public PersonException(string message, Exception innerException)\n        : base(message, innerException) { }\n    } \n    ```", "```cs\n    public void TimeTravel(DateTime when)\n    {\n      if (when <= Born)\n      {\n        throw new PersonException(\"If you travel back in time to a date earlier than your own birth, then the universe will explode!\");\n      }\n      else\n      {\n        WriteLine($\"Welcome to {when:yyyy}!\");\n      }\n    } \n    ```", "```cs\n    try\n    {\n      john.TimeTravel(when: new(1999, 12, 31));\n      john.TimeTravel(when: new(1950, 12, 25));\n    }\n    catch (PersonException ex)\n    {\n      WriteLine(ex.Message);\n    } \n    ```", "```cs\n    Welcome to 1999!\n    If you travel back in time to a date earlier than your own birth, then the universe will explode! \n    ```", "```cs\n        using System.Text.RegularExpressions; // To use Regex.\n        namespace Packt.Shared;\n        public class StringExtensions\n        {\n          public static bool IsValidEmail(string input)\n          {\n            // Use a simple regular expression to check\n            // that the input string is a valid email.\n            return Regex.IsMatch(input,\n              @\"[a-zA-Z0-9\\.-_]+@[a-zA-Z0-9\\.-_]+\");\n          }\n        } \n        ```", "```cs\n    string email1 = \"pamela@test.com\";\n    string email2 = \"ian&test.com\";\n    WriteLine(\"{0} is a valid e-mail address: {1}\",\n      arg0: email1,\n      arg1: StringExtensions.IsValidEmail(email1));\n    WriteLine(\"{0} is a valid e-mail address: {1}\",\n      arg0: email2,\n      arg1: StringExtensions.IsValidEmail(email2)); \n    ```", "```cs\n    pamela@test.com is a valid e-mail address: True\n    ian&test.com is a valid e-mail address: False \n    ```", "```cs\n    public **static** class StringExtensions\n    {\n      public static bool IsValidEmail(**this** string input)\n      { \n    ```", "```cs\n    WriteLine(\"{0} is a valid e-mail address: {1}\",\n      arg0: email1,\n      arg1: email1.IsValidEmail());\n    WriteLine(\"{0} is a valid e-mail address: {1}\",\n      arg0: email2,\n      arg1: email2.IsValidEmail()); \n    ```", "```cs\npublic class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public Person SetName(string name)\n    {\n        Name = name;\n        return this;\n    }\n    public Person SetAge(int age)\n    {\n        Age = age;\n        return this;\n    }\n} \n```", "```cs\nPerson person = new()\n  .SetName(\"John Doe\")\n  .SetAge(30); \n```", "```cs\npublic class Car\n{\n  public string Model { get; set; }\n  public string Color { get; set; }\n} \n```", "```cs\npublic static class CarExtensions\n{\n  public static Car SetModel(this Car car, string model)\n  {\n    car.Model = model;\n    return car;\n  }\n  public static Car SetColor(this Car car, string color)\n  {\n    car.Color = color;\n    return car;\n  }\n} \n```", "```cs\nCar car = new()\n  .SetModel(\"Tesla Model S\")\n  .SetColor(\"Red\"); \n```", "```cs\n    namespace Packt.Shared;\n    // A mutable record class.\n    public record class C1\n    {\n      public string? Name { get; set; }\n    }\n    // An immutable record class.\n    public record class C2(string? Name);\n    // A mutable record struct.\n    public record struct S1\n    {\n      public string? Name { get; set; }\n    }\n    // Another mutable record struct.\n    public record struct S2(string? Name);\n    // An immutable record struct.\n    public readonly record struct S3(string? Name); \n    ```", "```cs\n    C1 c1 = new() { Name = \"Bob\" };\n    c1.Name = \"Bill\";\n    C2 c2 = new(Name: \"Bob\");\n    c2.Name = \"Bill\"; // CS8852: Init-only property.\n    S1 s1 = new() { Name = \"Bob\" };\n    s1.Name = \"Bill\";\n    S2 s2 = new(Name: \"Bob\");\n    s2.Name = \"Bill\";\n    S3 s3 = new(Name: \"Bob\");\n    s3.Name = \"Bill\"; // CS8852: Init-only property. \n    ```", "```cs\n    void M1() { /* implementation */ } \n    ```", "```cs\n// These are both \"classic\" interfaces in that they are pure contracts.\n// They have no functionality, just the signatures of members that\n// must be implemented.\ninterface IAlpha\n{\n  // A method that must be implemented in any type that implements\n  // this interface.\n  void M1();\n}\ninterface IBeta\n{\n  void M2(); // Another method.\n}\n// A type (a struct in this case) implementing an interface.\n// \": IAlpha\" means Gamma promises to implement all members of IAlpha.\nstruct Gamma : IAlpha\n{\n  void M1() { /* implementation */ }\n}\n// A type (a class in this case) implementing two interfaces.\nclass Delta : IAlpha, IBeta\n{\n  void M1() { /* implementation */ }\n  void M2() { /* implementation */ }\n}\n// A sub class inheriting from a base aka super class.\n// \": Delta\" means inherit all members from Delta.\nclass Episilon : Delta\n{\n  // This can be empty because this inherits M1 and M2 from Delta.\n  // You could also add new members here.\n}\n// A class with one inheritable method and one abstract method\n// that must be implemented in sub classes. A class with at least\n// one abstract member must be decorated with the abstract keyword\n// to prevent instantiation.\nabstract class Zeta\n{\n  // An implemented method would be inherited.\n  void M3() { /* implementation */ }\n  // A method that must be implemented in any type that inherits\n  // this abstract class.\n  abstract void M4();\n}\n// A class inheriting the M3 method from Zeta but it must provide\n// an implementation for M4.\nclass Eta : Zeta\n{\n  void M4() { /* implementation */ }\n}\n// In C# 8 and later, interfaces can have default implementations\n// as well as members that must be implemented.\n// Requires: .NET Standard 2.1, .NET Core 3.0 or later.\ninterface ITheta\n{\n  void M3() { /* implementation */ }\n  void M4();\n}\n// A class inheriting the default implementation from an interface\n// and must provide an implementation for M4.\nclass Iota : ITheta\n{\n  void M4() { /* implementation */ }\n} \n```", "```cs\n    Rectangle r = new(height: 3, width: 4.5);\n    WriteLine($\"Rectangle H: {r.Height}, W: {r.Width}, Area: {r.Area}\");\n    Square s = new(5);\n    WriteLine($\"Square H: {s.Height}, W: {s.Width}, Area: {s.Area}\");\n    Circle c = new(radius: 2.5);\n    WriteLine($\"Circle H: {c.Height}, W: {c.Width}, Area: {c.Area}\"); \n    ```", "```cs\n    Rectangle H: 3, W: 4.5, Area: 13.5\n    Square H: 5, W: 5, Area: 25\n    Circle H: 5, W: 5, Area: 19.6349540849362 \n    ```"]