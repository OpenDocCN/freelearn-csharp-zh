["```cs\n    <CollectionView.ItemTemplate>\n        <DataTemplate>\n            ...\n                <Image\n                    Aspect=\"AspectFill\"\n                    HorizontalOptions=\"Fill\"\n                    Source=\"{Binding IsFavorite}\"\n                    VerticalOptions=\"Fill\" />\n                ...\n                <Label\n                    Grid.Row=\"1\"\n                    Margin=\"20,5,20,40\"\n                    FontSize=\"16\"\n                    HorizontalOptions=\"Fill\"\n                    HorizontalTextAlignment=\"Start\"\n                    MaxLines=\"2\"\n                    Text=\"{Binding Titel}\"\n                    TextColor=\"Black\"\n                    VerticalOptions=\"Center\" />\n            ...\n        </DataTemplate>\n    </CollectionView.ItemTemplate>\n    ```", "```cs\n    [0:] Microsoft.Maui.Controls.Xaml.Diagnostics.Binding\n    Diagnostics: Warning: 'False' cannot be converted to\n    type 'Microsoft.Maui.Controls.ImageSource'\n    [0:] Microsoft.Maui.Controls.Xaml.Diagnostics.Binding\n    Diagnostics: Warning: 'Titel' property not found on\n    'Recipes.Client.Core.ViewModels.RecipeListItemView\n    Model', target property: 'Microsoft.Maui\n    bool value cannot be converted to an ImageSource type. The second warning signals that a property named Titel cannot be found on the RecipeListItemViewModel. That, of course, is a typo!\n    ```", "```cs\npublic class DoNothingConverter : IValueConverter\n{\n    public object Convert(object value,\n        Type targetType, object parameter,\n        CultureInfo culture)\n    {\n        // Break here to inspect value during debugging\n        return value;\n    }\n    public object ConvertBack(object value,\n        Type targetType, object parameter,\n        CultureInfo culture)\n    {\n        // Break here to inspect value during debugging\n        return value;\n    }\n}\n```", "```cs\n    <ContentPage\n        x:Class=\"Recipes.Mobile.RecipesOverviewPage\"\n        ...\n        xmlns:conv=\"clr-namespace:\n          Recipes.Mobile.Converters\"\n        ... >\n        <ContentPage.Resources>\n            ...\n            <conv:DoNothingConverter\n                x:Key=\"doNothingConverter\" />\n        </ContentPage.Resources>\n        ...\n    </ContentPage>\n    ```", "```cs\n    <Image\n        ...\n        Source=\"{Binding IsFavorite,\n        Converter={StaticResource doNothingConverter}}\"\n        VerticalOptions=\"Fill\" />\n    ...\n    <Label\n        ...\n        Text=\"{Binding Titel,\n        Converter={StaticResource doNothingConverter}}\"\n        TextColor=\"Black\"\n        VerticalOptions=\"Center\" />\n    ```", "```cs\n<!-- RelativeSource binding fails on Behaviors! -->\n<toolkit:IconTintColorBehavior\n    TintColor=\"{Binding IsFavorite,\n    Source={RelativeSource AncestorType={x:Type local:\nRelativeSource binding in the IcontTintColorBehavior. This can be bypassed by leveraging element binding, as shown in the next code block:\n\n```", "```cs\n\n Next, let’s discuss the things to look out for when working with Dependency Injection.\nServices and Dependency Injection pitfalls\nIn your MVVM journey, DI plays a crucial role in providing essential functionality to your application. However, even in the world of DI, there can be pitfalls waiting to catch you off guard. This section is dedicated to unveiling the most common pitfalls and equipping you with the knowledge to navigate them effectively.\nUnable to resolve service for type\nA `System.InvalidOperationException` stating `RecipesOverviewViewModel` in the DI container:\n![Figure 14.2: InvalidOperationException thrown](img/B20941_14_02.jpg)\n\nFigure 14.2: InvalidOperationException thrown\nThe exception gives you all the information you need as it clearly states what type is missing while trying to create a particular type.\nRegistering the missing dependency in the `MauiProgram` class (or anywhere you do your registrations) should fix the issue.\nLet’s have a look at another common exception in the context of DI.\nNo parameterless constructor defined for type\nA `System.MissingMethodException` can be thrown in the following scenario:\n\n*   Shell is used to perform navigation\n*   The BindingContext (a ViewModel) of a page is injected through the page’s constructor\n*   The page isn’t registered in the DI container\n\nAs long as a page doesn’t have any dependencies that need to be injected through the constructor, it doesn’t need to be registered in the DI container, as its default constructor is being used by Shell to instantiate the page. However, when the page has one or more dependencies, we need to register it in the DI container. That way, Shell can ask the container to resolve an instance of the needed page.\nRegistering the page in the DI container solves this issue.\nA much more subtle pitfall when it comes to DI is not registering the services appropriately. Let’s have a look.\nIncorrect service registration\nIn the context of DI, one common pitfall stems from improperly registering services, leading to issues that can affect your application’s functionality:\n\n*   **Resource intensiveness**: If you register a service as transient when it should be a singleton, you may encounter resource-intensive behavior. This occurs because a new instance of the service is created every time it’s requested. For services that involve resource-intensive operations, such as establishing database connections or managing file handles, this frequent creation can lead to performance bottlenecks and resource exhaustion. Such issues can significantly impact your application’s performance and stability.\n*   **Unintended shared state**: Conversely, if you mistakenly register a service as a singleton when it should be transient, you may inadvertently introduce an unintended shared state. In this scenario, changes made to the service’s state or properties affect all parts of your application that depend on that service. This shared state can lead to unpredictable behavior and make debugging challenging, as the source of the problem may not be immediately apparent. It’s crucial to align the service’s registration with its intended usage to avoid such pitfalls.\n\nTo mitigate these issues, carefully consider the intended scope and usage of each service during registration. Ensure that services requiring a single shared instance across your application are registered as singletons, while services that should have unique instances for each request are registered as transient. By making informed decisions about service registration, you can prevent these common pitfalls and ensure your application functions as intended.\nIn the final section, let’s have a look at common problems around custom controls and value converters.\nFrequent custom control and converter problems\nMost of the issues that arise when working with custom controls regularly have to do with bindable properties. Often, a small typo or a little oversight might cause your custom control to not react as expected or to display the wrong data.\nTroubleshooting bindable properties\nOn a custom control, there is a lot of ceremony needed to define bindable properties. It’s very easy to make a mistake that is very hard to spot when troubleshooting. Here are a couple of things to look out for:\n\n*   The `propertyName` parameter in the `Create` method: Make sure the `propertyName` parameter matches the exact naming of the property:\n\n    ```", "```cs\n\n    As this code sample shows, it is advised to use the `nameof` expression to prevent typos!\n\n     *   The `returnType` parameter in the `Create` method: The second parameter of the `BindableProperty`’s `Create` method is the `returnType`, which must match the type of the property:\n\n    ```", "```cs\n\n     *   The `declaringType` parameter in the `Create` method: This parameter should be the type of the class where the property is defined:\n\n    ```", "```cs\n\n     *   It’s also important to make sure the getter and setter of the property call the `GetValue` and `SetValue`, passing in the correct `BindableProperty`:\n\n    ```", "```cs\n\nWhenever there is a discrepancy between the provided values in the `BindableProperty`’s `Create` method and the values on the control itself, or when the property doesn’t get or set the value correctly on the `BindableProperty`, the bindable property will not work as expected. So, it’s crucial to double-check these values!\nBinding to the BindingContext\nAs already stipulated in [*Chapter 11*](B20941_11.xhtml#_idTextAnchor182), *Creating MVVM-Friendly Controls,* it is crucial that custom controls don’t depend on their `BindingContext`! The reason is that you can’t control that, as it is inherited from the parent the custom control is used on. Instead, you should only bind to the (bindable) properties that you’ve defined on the control itself. This can easily be achieved by leveraging relative or element binding, just like we did with the `FavoriteControl`:\n\n```", "```cs\n\n Any binding statements on a custom control that don’t have an explicit source set will bind to the `BindingContext` of the parent, which we don’t control. When a custom control works in one place but not in the other, chances are high that there is some binding going on that is not relative to the control itself. So, always double-check the binding statements in your custom control!\nFinally, let’s have a quick look at the issues that might arise when working with value converters.\nValue converter issues\nConverters play a crucial role in data transformation within your app. However, their logic might not always behave as expected. It’s a seemingly trivial issue, but one that is frequently underestimated. The solution? Simple yet powerful: write unit tests! In [*Chapter 13*](B20941_13.xhtml#_idTextAnchor223), *Unit Testing,* we’ve highlighted how easy it is to unit test value converters. Paying attention to the logic within converters, testing them rigorously, and handling special cases will ensure that your converters perform reliably.\nSummary\nNow that we’ve reached the end of this short chapter, I hope you’ve gained valuable insights and tips for effectively troubleshooting issues that can arise in an MVVM context. Remember, the road to mastering MVVM is an ongoing journey, and troubleshooting and debugging are indispensable companions on this path. These challenges, though sometimes frustrating, are valuable teachers that will deepen your understanding and proficiency in MVVM. Embrace them as opportunities to grow, and in doing so, you’ll become a more proficient and confident MVVM developer. Your journey doesn’t end here; it evolves with each issue you resolve.\nAs we wrap up this final chapter, I want to extend my heartfelt congratulations to you for completing this book’s journey into the world of MVVM in .NET MAUI. Throughout this book, you’ve delved into the intricacies of the MVVM pattern, explored the capabilities of .NET MAUI, and built your very own *Recipes!* app.\nOnce again, congratulations on your accomplishment, and may your MVVM and .NET MAUI journey continue to be rewarding and filled with exciting projects!\nFurther reading\nTo learn more about the topics that were covered in this chapter, take a look at the following resource:\n*XAML data binding* *diagnostics*: [https://learn.microsoft.com/en-us/visualstudio/xaml-tools/xaml-data-binding-diagnostics?view=vs-2022](https://learn.microsoft.com/en-us/visualstudio/xaml-tools/xaml-data-binding-diagnostics?view=vs-2022)\n\n```"]