<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-162"><a id="_idTextAnchor867"/>10</h1>
<h1 id="_idParaDest-163"><a id="_idTextAnchor868"/>Building a Real-Time Game</h1>
<p>In this chapter, we will build a multi-player, head-to-head game app with real-time communication. In the app, you will be able to connect to a game server and view a list of other players that are also connected. You can then select a player to request a game with them and, provided they accept, play a game of <em class="italic">Sticks &amp; Stones</em>. We will look at how we can use SignalR to implement a real-time connection with the server.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>How to use SignalR in a .NET MAUI app</li>
<li>How to use control templates </li>
<li>How to use XAML triggers to update the interface</li>
<li>How to use XAML styling in a .NET MAUI app</li>
</ul>
<p>Let’s get started.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor869"/>Technical requirements</h1>
<p>Before you start building the app for this project, you need to build the backend that we detailed in <em class="italic">Chapter 9</em>, <em class="italic">Setting Up a Backend for a Game Using Azure Services</em>. You will also need to have Visual Studio for Mac or PC installed, as well as the .NET MAUI components. See <em class="italic">Chapter 1</em>, <em class="italic">Introduction to .NET MAUI</em>, for more details on how to set up your environment. The source code for this chapter is available in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/ten/main">https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/ten/main</a>.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor870"/><a id="_idTextAnchor871"/>Project overview</h1>
<p>When building a <a id="_idIndexMarker991"/>head-to-head game app, it is really important to have real-time communication because the user expects the other players’ moves to arrive more or less immediately. To achieve this, we will use SignalR, which is a library for real-time communication. SignalR will use WebSockets if they are available and, if not, it will have several fallback options it can use instead. In the app, we will use SignalR to send updates on player and game status through the Azure Functions that we built in <em class="italic">Chapter 9</em>.</p>
<p>The build time for this project is about 180 minutes.<a id="_idTextAnchor872"/></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor873"/>Getting started</h1>
<p>We can use either Visual Studio on a PC or Mac to complete this project. To build an iOS app using Visual Studio for PC, you have to have a Mac connected. If you don’t have access to a Mac at all, you can choose to just build the Android part of the<a id="_idTextAnchor874"/> app.</p>
<p>Let’s review from <em class="italic">Chapter 9</em> what the game is all about.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor875"/>An overview of the game</h2>
<p><em class="italic">Sticks &amp; Stones</em> is a turn-based <a id="_idIndexMarker992"/>social game based on the concepts of two childhood games mashed into one, Dots and Boxes (<a href="https://en.wikipedia.org/wiki/Dots_and_boxes">https://en.wikipedia.org/wiki/Dots_and_boxes</a>) and Tic-Tac-Toe (<a href="https://en.wikipedia.org/wiki/Tic-tac-toe">https://en.wikipedia.org/wiki/Tic-tac-toe</a>). The game board is laid out in a three-by-three grid. Each player will take a turn placing a stick along the side of a box, between two dots, to earn one point. If a stick completes a box, then the player takes ownership of the box, earning five points. The game is won when a player owns three boxes in a row, horizontally, vertically, or diagonally. If no player can own three boxes in a row, the winner of the game is determined by the player with the highest score.</p>
<p>To keep the app and the service side relatively simple, we will eliminate a lot of state management. When the player opens the app, they will have to connect to the game service. They will have to provide a gamer tag, or username, and an email address. Optionally, they can upload a picture of themselves to use as a profile picture.</p>
<p>Once connected, the player will then see a list of all the other players connected to the same game service; this is called the Lobby. The player’s status of either <strong class="bold">Ready to play</strong> or <strong class="bold">In a match</strong> is displayed along with the player’s gamer tag and profile picture. If the player is not in a match, a button is available to challenge the player to a match.</p>
<p>Challenging a player to a match will cause the app to prompt the opponent to respond to the challenge, either accept or decline it. If the opponent accepts the challenge, then both players are navigated to a new game board where the player who received the challenge will have the first turn. Both players’ statuses will update to <strong class="bold">In a match</strong> in all the other players’ lobbies.</p>
<p>Play will alternate between players as they choose a location to place a single stick. Each time a stick is placed by a player, the game board and score will update on both players’ devices. When a stick is placed that completes one or more squares, the player then wins that square, and a pile of stones is placed in the center of the square. When all sticks have been placed, or a player owns three stones in a row, the game is over, the players navigate back to the Lobby, and their status is updated to “Ready to play.”</p>
<p>If a player <a id="_idIndexMarker993"/>leaves the app during a game, then they will have forfeited the match and the remaining opponent will be credited with the win and navigated back to the Lobby.</p>
<p>Now that we understand what we want to build, let’s get down to the details.</p>
<p>We recommend that you use the same solution we used in <em class="italic">Chapter 9</em>, <em class="italic">Setting Up a Backend for a Game Using Azure Services</em>, because this will make code sharing easier. If you don’t want to go through all of <em class="italic">Chapter 9</em>, you can get the completed source from <em class="italic">Chapter 9</em><em class="italic">, </em>at <a href="https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/nine/main">https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition/tree/chapters/nine/main</a>.</p>
<p>We will build this app in four sections:</p>
<ul>
<li><strong class="bold">Services</strong> – All the <a id="_idIndexMarker994"/>classes that are needed to connect and interact with the Azure Functions backend that was built in <em class="italic">Chapter 9</em>, <em class="italic">Setting Up a Backend for a Game Using </em><em class="italic">Azure Services</em>.</li>
<li><strong class="bold">Connect page</strong> – This <a id="_idIndexMarker995"/>will consist of the view and view model needed to allow a user to connect to the game server as a player.</li>
<li><strong class="bold">Lobby page</strong> – The <a id="_idIndexMarker996"/>Lobby is where the player can send and receive challenges with other players. In this section, we will build the view and view model for the lobby.</li>
<li><strong class="bold">Game page</strong> – This is <a id="_idIndexMarker997"/>where players can take turns playing a game of <em class="italic">Sticks and Stones</em>. In this section, we will build the view and view model needed to make that happen.</li>
</ul>
<p>Let’s start by creating the project for the .NET MAU<a id="_idTextAnchor876"/>I app.</p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor877"/>Building the game app</h1>
<p>It’s time <a id="_idIndexMarker998"/>to start building the app. Open the <code>SticksAndStones</code> solution from the previous chapter and follow these steps to create the project:</p>
<ol>
<li>Open the <strong class="bold">Create a new project</strong> wizard by selecting <strong class="bold">File</strong>, <strong class="bold">Add</strong>, then <strong class="bold">New Project…</strong> from the Visual Studio menu:</li>
</ol>
<div><div><img alt="Figure 10.1 – File | Add | New Project…" src="img/B19214_10_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – File | Add | New Project…</p>
<ol>
<li value="2">In the search field, type <code>maui</code> and select the <strong class="bold">.NET MAUI App</strong> item from the list, or select <a id="_idIndexMarker999"/>it from <strong class="bold">Recent project templates</strong> if it is listed:</li>
</ol>
<div><div><img alt="Figure 10.2 – Create a new p﻿roject" src="img/B19214_10_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Create a new p<a id="_idTextAnchor878"/>roject</p>
<ol>
<li value="3">Click <strong class="bold">Next</strong>.</li>
<li>Enter <code>SticksAndStones.App</code> as the name of the app and, under <strong class="bold">Solution</strong>, select <strong class="bold">Add to solution</strong>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 10.3 – Configure your new project" src="img/B19214_10_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Configure your new project</p>
<ol>
<li value="5">Click <strong class="bold">Next</strong>.</li>
<li>The last <a id="_idIndexMarker1000"/>step will prompt you for the version <a id="_idIndexMarker1001"/>of .NET Core to support. At the time of writing, .NET 6 is <a id="_idIndexMarker1002"/>available as <strong class="bold">Long-Term Support</strong> (<strong class="bold">LTS</strong>), and .NET 7 is available as <strong class="bold">Standard Term Support</strong>. For the purposes of this book, we will assume that you will be using .NET 7:</li>
</ol>
<div><div><img alt="Figure 10.4 – Additional information" src="img/B19214_10_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Additional information</p>
<ol>
<li value="7">Finalize the setup by clicking <strong class="bold">Create</strong> and wait for Visual Studio to create the project.</li>
</ol>
<p>Now we <a id="_idIndexMarker1003"/>have created the .NET MAUI project for our game screens, let’s configure it so that it’s ready to add the services and views. We will need to add a project reference to the <code>SticksAndStones.Shared</code> project, as well as a few NuGet packages. Follow these steps to complete the setup of the <code>SticksAndStones.App</code> project:</p>
<ol>
<li>Right-click the <code>SticksAndStones.App</code> project in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Properties</strong>.</li>
<li>In the <code>Default namespace</code>.</li>
<li>Change the <code>$(MSBuildProjectName.Split(".")[0].Replace(" ", "</code><code>_"))</code>.<p class="list-inset">This will split the project name on <code>"."</code>, using only the first part and replacing any spaces with underscores. </p></li>
<li>Add a NuGet Package reference to <code>CommunityToolkit.Mvvm</code> as, in other chapters, we will be using this package to simplify the implementation of data bindings to properties and commands.</li>
<li>Add a NuGet Package reference to <code>CommunityToolkit.Maui</code>. We will be using the <code>GravatarImageSource</code> class from this package to render an avatar for <a id="_idIndexMarker1004"/>the user. For .NET 7, you will need to use version 6.1.0 of the NuGet package. 7.0+ has .NET 8 as a dependency.</li>
<li>Open the <code>MauiProgram.cs</code> file and add the highlighted line shown here:<pre class="source-code">
<strong class="bold">using CommunityToolkit.Maui;</strong>
using Microsoft.Extensions.Logging;
namespace SticksAndStones.App
{
    public static class MauiProgram
    {
        public static MauiApp CreateMauiApp()
        {
            var builder = MauiApp.CreateBuilder();
            builder
                .UseMauiApp&lt;App&gt;()
                .ConfigureFonts(fonts =&gt;
                {
                    fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
                    fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
                })
                <strong class="bold">.UseMauiCommunityToolkit();</strong>
#if DEBUG
            builder.Logging.AddDebug();
#endif
            return builder.Build();
        }
    }
}</pre><p class="list-inset">This will <a id="_idIndexMarker1005"/>configure <code>CommunityToolkit</code> for use within the app.</p></li> <li>Add a NuGet package reference to <code>Microsoft.Extensions.Logging.Abstractions</code>. This package is used to log messages from the Azure Functions functions for debugging.</li>
<li>Add a NuGet package reference to <code>Microsoft.Extensions.Logging.Debugging</code>. This package is used to log messages from the Azure Functions functions for debugging.</li>
<li>Add a NuGet package reference to <code>Microsoft.AspNetCore.SignalR.Client</code>. This package is required for the app to connect to the SignalR Hub we created in <em class="italic">Chapter 9</em> and receive messages.</li>
<li>Add a Project reference to the <code>SticksAndStones.Shared</code> project. This will give us access to the messages and objects we created in <em class="italic">Chapter 9</em>.</li>
</ol>
<p>That’s it for projec<a id="_idTextAnchor879"/><a id="_idTextAnchor880"/><a id="_idTextAnchor881"/>t creation. Next, we will start with creating classes that interact directly with ou<a id="_idTextAnchor882"/><a id="_idTextAnchor883"/>r service.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor884"/>Creating the game services</h2>
<p>The first <a id="_idIndexMarker1006"/>thing we will do is create a service that will be used to communicate with the Azure Functions functions service created in <em class="italic">Chapter 9</em>, <em class="italic">Setting Up a Backend for a Game Using Azure Services</em>. The service will be broken down into three main classes:</p>
<ul>
<li><code>GameService</code> – Methods and properties for calling the Azure Functions and receiving SignalR messages.</li>
<li><code>ServiceConnection</code> – Holds the references to <code>HttpClient</code> and SignalR Hub instances. Also provides methods for safely making calls using <code>HttpClient</code>.</li>
<li><code>Settings</code> – Stores and retrieves the URL for the server used by <code>HttpClient</code>. It also stores the connection details provided by the user.</li>
</ul>
<p>We will start with the <code>Settings</code> class since both <code>GameService</code> and <code>ServiceConnection</code> will depend on <code>Settings</code>. </p>
<h3>Creating the Settings service</h3>
<p>The <code>Settings</code> service is used to store values that are needed between app runs. It will use <a id="_idIndexMarker1007"/>the .NET MAUI <code>Preferences</code> class to store these values in a cross-platform manner. Use the following steps to implement the <code>Settings</code> class:</p>
<ol>
<li>In the <code>SticksAndStones.App</code> project, create a new folder named <code>Services</code>.</li>
<li>In the newly created <code>Services</code> folder, create a new class named <code>Settings</code>.</li>
<li>Make the class public.</li>
<li>Create a <code>const string</code> field named <code>LastPlayerKey</code> and initialize it like so:<pre class="source-code">
private const string LastPlayerKey = nameof(LastPlayerKey);</pre></li> <li>Create a <code>const string</code> field named <code>ServerUrlKey</code> and initialize it like this:<pre class="source-code">
private const string ServerUrlKey = nameof(ServerUrlKey);</pre><p class="list-inset">These <a id="_idIndexMarker1008"/>two fields are used by the .NET MAUI <code>Preferences</code> class to store the values for the server URL and the login details for the last time the user logged in.</p></li> <li>Add a <code>private const string</code> field named <code>ServerUrlDefault</code> as follows:<pre class="source-code">
#if DEBUG &amp;&amp; ANDROID
    private const string ServerUrlDefault = "http://10.0.2.2:<strong class="bold">7071</strong>/api";
#else
    private const string ServerUrlDefault = "http://localhost:<strong class="bold">7071</strong>/api";
#endif
ServerlUrlDefault</strong> value for Android devices. The <code>10.0.2.2</code> IP address is a special value used by the Android emulators to be able to access the host computer’s <code>localhost</code> address. This is very useful when testing the app using the <strong class="bold">Azurite</strong> development environment for Azure Functions.</pre><p class="list-inset">You may need to adjust the port number, highlighted in the preceding listing, for your specific development environment. Azure Functions will display the server URL when started from Visual Studio, as shown in the following screenshot:</p></li> </ol>
<div><div><img alt="Figure 10.5 – Azure Functions console output" src="img/B19214_10_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Azure Functions console output</p>
<p class="callout-heading">Using the Azure Functions hosted in Azure</p>
<p class="callout">If you followed the steps in the <em class="italic">Chapter 9</em> section called <em class="italic">Deploying the functions to Azure</em>, then you can use the URL for the Azure Function App created in <em class="italic">Chapter 9</em>, in the <em class="italic">Creating the Azure service for functions</em> section. The URL is displayed on the <strong class="bold">Overview</strong> tab of the Azure Functions App. </p>
<ol>
<li value="7">Now, add <a id="_idIndexMarker1009"/>a <code>public string</code> property named <code>ServerUrl</code> with the following implementation:<pre class="source-code">
public string ServerUrl
{
    get =&gt; Preferences.ContainsKey(ServerUrlKey) ?
                Preferences.Get(ServerUrlKey, ServerUrlDefault) :
                ServerUrlDefault;
    set =&gt; Preferences.Set(ServerUrlKey, value);
}</pre><p class="list-inset">This code will get the server URL from the <code>Preferences</code> store if it is present; if not, it will use the <code>serverUrlDefault</code> value. The property will store the new value in the <code>Preferences</code> store.</p></li> <li>Add the following <code>using</code> declarations at the top of the <code>Settings.cs</code> file:<pre class="source-code">
using SticksAndStones.Models;
using System.Text.Json;</pre><p class="list-inset">This will enable us to use our model and the <code>JsonSerializer</code> classes.</p></li> <li>Create <a id="_idIndexMarker1010"/>a new property named <code>LastPlayer</code> that is of the <code>Player</code> type, as follows:<pre class="source-code">
public Player LastPlayer
{
    get
    {
        if (Preferences.ContainsKey(LastPlayerKey))
        {
            var playerJson = Preferences.Get(LastPlayerKey, string.Empty);
            return JsonSerializer.Deserialize&lt;Player&gt;(playerJson, new JsonSerializerOptions(JsonSerializerDefaults.Web)) ?? new();
        }
        return new();
    }
    set =&gt; Preferences.Set(LastPlayerKey, JsonSerializer.Serialize(value, new JsonSerializerOptions(JsonSerializerDefaults.Web)));
}</pre><p class="list-inset">Here, the property <code>set</code> method will convert the <code>Player</code> object to a <code>Json</code> string <a id="_idIndexMarker1011"/>before storing it in <code>Preferences</code> and, when getting the property, if it exists in the <code>Preferences</code> store, convert the stored <code>Json</code> to a <code>Player</code> object. If there is no value in the <code>Preferences</code> store, then the <code>get</code> method will return an empty <code>Player</code> object.</p></li> <li>The final step for the <code>Settings</code> class is to register it with the dependency injection container. Open the <code>MauiProgram.cs</code> file in the <code>SticksAndStones.App</code> project, then add the following highlighted code to the <code>CreateMauiApp</code> method:<pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    builder
        .UseMauiApp&lt;App&gt;()
        .ConfigureFonts(fonts =&gt;
        {
            fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
            fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
        });
#if DEBUG
        builder.Logging.AddDebug();
#endif
<strong class="bold">    builder.Services.AddSingleton&lt;Services.Settings&gt;();</strong>
        return builder.Build();
    }</pre></li> </ol>
<p>With <a id="_idIndexMarker1012"/>the <code>Settings</code> class complete, we can now focus on the <code>ServiceConnection</code> class.</p>
<h3>Creating the ServiceConnection class</h3>
<p>The <code>ServiceConnection</code> class encapsulates the functionality needed to communicate with the Azure Functions service. It has methods to call the function methods and return the results, with appropriate error handling. It is also responsible for <a id="_idIndexMarker1013"/>initializing the SignalR Hub instance that is used for real-time communication. The <code>ServiceConnection</code> class has a couple of dependencies that we need, so let’s put them together first.</p>
<p>The first thing to add is logging. Having logging during debugging can be very helpful in figuring out problems, especially when dealing with asynchronous processes. Communicating with Azure Functions will have a lot of asynchronous operations. To enable logging while debugging, add the highlighted code to the <code>CreateMauiApp</code> method in the <code>MauiProgram</code> class in the <code>SticksAndStones.App</code> project:</p>
<pre class="source-code">
#if DEBUG
        builder.Logging.AddDebug();       
<strong class="bold">        builder.Services.AddLogging(configure =&gt;</strong>
<strong class="bold">        {</strong>
<strong class="bold">            configure.AddDebug();</strong>
<strong class="bold">        });</strong>
#endif
        builder.Services.AddSingleton&lt;Services.Settings&gt;();
        return builder.Build();</pre> <p>This <a id="_idIndexMarker1014"/>will add an instance of <code>ILoggingProvider</code> to the services container. The <code>ILoggerProvider</code> instance will provide instances of <code>ILogger&lt;T&gt;</code>. This will enable the use of <code>ILogger&lt;T&gt;</code> as a dependency in the <code>ServiceConnection</code> class constructor.</p>
<p class="callout-heading">More on logging providers</p>
<p class="callout">Read more <a id="_idIndexMarker1015"/>about how logging providers work, and logging in general, at <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers">https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers</a>.</p>
<p>Now, when making requests to APIs using HTTP, it is a common and good practice to use asynchronous calls so that you do not block the main or UI thread. All UI updates, such as animation, button clicks, taps on the screen, or text changes, happen on the UI thread. HTTP calls can take a non-trivial amount of time to complete, which can cause the app to become unresponsive to a user.</p>
<p>Error handling in asynchronous programming can be difficult. To help with errors when making API calls, we are going to use a couple of classes to encapsulate the exceptions; these classes are <code>AsyncError</code> and <code>AsyncExceptionError</code>. We need <code>AsyncError</code> and <code>AsyncExceptionError</code> because it is a bad practice to serialize and deserialize any class instances that derive from <code>System.Exception</code>. Not all classes derived from <code>System.Exception</code> are serializable, and even if they are, you may not be able to deserialize them due to a missing type – for example, the type is available on the server but not on the client. Create a new file named <code>AsyncError.cs</code> in the <code>SticksAndStones.App</code> project and replace the contents with the following code:</p>
<pre class="source-code">
using System.Text.Json.Serialization;
namespace SticksAndStones;
public record AsyncError
{
    [JsonPropertyName("message")]
    public string Message { get; set; }
}
public record AsyncExceptionError : AsyncError
{
    [JsonPropertyName("innerException")]
    public string InnerException { get; set; }
}</pre> <p>The <code>AsyncError</code> class has a single property, <code>Message</code>. The <code>Message</code> property is decorated with the <code>JsonPropertyName</code> attribute so that it can be serialized if needed, using a lowercase version of the property name. <code>AsyncExceptionError</code> inherits from <code>AsyncError</code> and adds an additional property, <code>InnerException</code>. The <code>InnerException</code> property is also attributed with <code>JsonPropertyName</code>.</p>
<p>The last class we will need is <code>AsyncLazy&lt;T&gt;</code>. You may have already used <code>Lazy&lt;T&gt;</code> in other <a id="_idIndexMarker1016"/>applications you have written. It’s very handy when you want to delay the creation of a class until right before you need it. If you never need it, it doesn’t get created. But <code>Lazy&lt;T&gt;</code> does not work great with asynchronous programming, so if you wanted to lazy instantiate a class that is created asynchronously, that becomes tedious. Luckily for us, Stephen Toub, who works for Microsoft on the .NET team, created <code>AsyncLazy&lt;T&gt;</code>. To add it to the <code>SticksAndStones.App</code> project, create a new file named <code>AsyncLazy~1.cs</code> and replace the contents with the following:</p>
<pre class="source-code">
using System.Runtime.CompilerServices;
namespace SticksAndStones;
// AsyncLazy&lt;T&gt;, Microsoft, Stephen Toub, .NET Parallel Programming Blog, https://devblogs.microsoft.com/pfxteam/asynclazyt/
public class AsyncLazy&lt;T&gt; : Lazy&lt;Task&lt;T&gt;&gt;
{
    public AsyncLazy(Func&lt;T&gt; valueFactory) :
        base(() =&gt; Task.Factory.StartNew(valueFactory))
    { }
    public AsyncLazy(Func&lt;Task&lt;T&gt;&gt; taskFactory) :
        base(() =&gt; Task.Factory.StartNew(() =&gt; taskFactory()).Unwrap())
    { }
    public TaskAwaiter&lt;T&gt; GetAwaiter() { return Value.GetAwaiter(); }
}</pre> <p class="callout-heading">Learn more about AsyncLazy&lt;T&gt;</p>
<p class="callout">Visit <a id="_idIndexMarker1017"/>the .NET blog to learn more about how Stephen Toub created the <code>AsyncLazy&lt;T&gt;</code> class: <a href="https://devblogs.microsoft.com/pfxteam/asynclazyt/">https://devblogs.microsoft.com/pfxteam/asynclazyt/</a>.</p>
<p>That <a id="_idIndexMarker1018"/>completes the changes needed to start implementing the <code>ServiceConnection</code> class. To create the class, follow these steps:</p>
<ol>
<li>Create a new class named <code>ServiceConnection</code> in the <code>SticksAndStones.App</code> project in the <code>Services</code> folder.<p class="list-inset">Change the class to <code>public sealed</code> and inherit from <code>IDisposable</code>:</p><pre class="source-code">
<strong class="bold">public sealed</strong> class ServiceConnection <strong class="bold">: IDisposable</strong></pre></li> <li>Modify <a id="_idIndexMarker1019"/>the namespace declarations at the top of the file to the following:<pre class="source-code">
using Microsoft.AspNetCore.Http.Connections.Client;
using Microsoft.AspNetCore.SignalR.Client;
using Microsoft.Extensions.Logging;
using SticksAndStones.Models;
using System.Net;
using System.Net.Http.Json;
using System.Text.Json;</pre><p class="list-inset">These are needed to reference the types needed in the following steps.</p></li> <li>Add the following <code>private</code> fields to the class:<pre class="source-code">
private readonly ILogger log;
private readonly HttpClient httpClient;
private readonly JsonSerializerOptions serializerOptions;</pre><p class="list-inset">The <code>serializerOptions</code> is used to make sure the JSON that is sent and received from the Azure Functions functions can be serialized and deserialized properly.</p></li> <li>Now, add a <code>public</code> property named <code>Hub</code>. The type for <code>Hub</code> is <code>AsyncLazy&lt;HubConnection&gt;</code>. <code>HubConnection</code> is the type from the SignalR client library that is used to receive messages from the SignalR service. The property should look like the following:<pre class="source-code">
public AsyncLazy&lt;HubConnection&gt; Hub { get; private set; }</pre><p class="list-inset"><code>HubConnection</code> is initialized in the <code>ConnectHub</code> method. But first, let’s add the constructor.</p></li> <li>The <a id="_idIndexMarker1020"/>constructor for the <code>ServiceConnection</code> class has two parameters: <code>ILogger</code><strong class="source-inline">
&lt;ServiceConnection&gt;</strong> and a <code>Settings</code> parameter. In the body of the constructor, the <code>private</code> fields created in <em class="italic">step 3</em> are initialized as follows:<pre class="source-code">
public ServiceConnection(ILogger&lt;ServiceConnection&gt; logger, Settings settings)
{
    httpClient = new()
    {
        BaseAddress = new Uri(settings.ServerUrl)
    };
    httpClient.DefaultRequestHeaders.Accept.Add(new("application/json"));
    serializerOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);
    log = logger;
}</pre><p class="list-inset">The <code>logger</code> and <code>settings</code> parameters are provided by the .NET MAUI dependency injection service. The <code>httpClient</code> field is initialized and it’s <code>BaseAddress</code> is assigned the settings <code>ServerUrl</code> property as a URI. Then, <code>DefaultHeaders</code> is modified to indicate to the server that the results are expected to be in JSON format. The <code>serializerOptions</code> instance is initialized to the defaults for <code>Web</code>, which is consistent with the formatting used by Azure Functions. Finally, the <code>log</code> field is initialized with the <code>logger</code> parameter value.</p></li> <li>Now, let’s implement the <code>Dispose</code> method. It will clean up any values that will potentially hold on to any native resources, such as networks, file handles, and so on. The two values that this class has references to that need to be disposed of are <code>httpClient</code> and <code>Hub</code>. Note that we will not have to call <code>Dispose</code> ourselves as the .NET MAUI dependency injection system will do that. Add the following code to the <code>ServiceConnection</code> class:<pre class="source-code">
public void Dispose()
{
    httpClient?.Dispose();
    Hub?.Value?.Dispose();
    GC.SuppressFinalize(this);
}</pre></li> <li>Now, add the class to dependency injection by adding the following highlighted line <a id="_idIndexMarker1021"/>of code to the <code>MauiProgram.cs</code> file:<pre class="source-code">
builder.Services.AddSingleton&lt;Services.Settings&gt;();
<strong class="bold">builder.Services.AddSingleton&lt;Services.ServiceConnection&gt;();</strong>
return builder.Build();</pre></li> <li>Initializing the <code>Hub</code> property will happen in the <code>ConnectHub</code> method. The configuration for the SignalR SignalR Hub connection is returned to the app in the <code>Connect</code> function result. Since we haven’t and won’t make that call before this class is constructed, we can’t create the <code>Hub</code> in the constructor. The configuration is needed before you can initialize the <code>Hub</code> instance. The <code>ConnectHub</code> method has a single parameter of <code>ConnectionInfo</code>. Add the method <a id="_idIndexMarker1022"/>using the following code snippet:<pre class="source-code">
public void ConnectHub(ConnectionInfo config)
{
    Hub = new(async () =&gt;
    {
        var connectionBuilder = new HubConnectionBuilder();
        connectionBuilder.WithUrl(config.Url, (HttpConnectionOptions obj) =&gt;
        {
            obj.AccessTokenProvider = async () =&gt; await Task.FromResult(config.AccessToken);
        });
        connectionBuilder.WithAutomaticReconnect();
        var hub = connectionBuilder.Build();
        await hub.StartAsync();
        return hub;
    });
}</pre><p class="list-inset">This method initializes the <code>Hub</code> property to a new <code>AsyncLazy&lt;HubConnection&gt;</code> instance. The constructor for <code>AsyncLazy&lt;T&gt;</code> takes <code>Func&lt;T&gt;</code>, which is provided using the anonymous method syntax. The anonymous method is also decorated as an <code>async</code> method, meaning that it will contain an awaited method call. The anonymous method takes no parameters and, in the body, starts by creating a new <code>HubConnectionBuilder</code>. Then, the <code>WithUrl</code> extension method is called on <code>HubConnectionBuilder</code> to set the URL for the SignalR service and provide the <code>AccessToken</code> value needed to make the connection. <code>AccessTokenProvider</code> is a <code>Task&lt;string&gt;</code> so the <code>config.AccessToken</code> is provided through another <code>async</code> anonymous function. The <code>WithAutomaticReconnect</code> method sets <code>HubConnection</code> instance to automatically try reconnecting the SignalR service if the connection is lost. If <code>WithAutomaticReconnect</code> isn’t called, then the app is responsible for reconnecting if the connection is lost. The <code>HubConnection</code> instance is created by calling <code>HubConnectionBuilder.Build</code>. The <code>Hub</code> instance is then started with <code>StartAsync</code>, which is awaited, and then the <code>Hub</code> is returned. The <a id="_idIndexMarker1023"/>thing to remember here is that when <code>ConnectHub</code> is called, the anonymous function isn’t executed. The method won’t be called until the first time a property or method of the <code>Hub</code> property is accessed.</p></li> </ol>
<p>The <code>ServiceConnection</code> class contains two helper functions that are used from the <code>GameService</code> class to make HTTP requests to the Azure Functions service. The first, <code>GetAsync&lt;T&gt;</code>, takes two parameters: a URL and a dictionary of query parameters to pass along with the URL. It returns an instance, <code>T</code>, and <code>AsyncError</code> as a <code>Tuple</code>. The <code>GetAsync</code> method will use the <code>GET</code> HTTP method when making the HTTP request. The other helper method, <code>PostAsync&lt;T&gt;</code>, uses the <code>POST</code> HTTP method and accepts two parameters: a URL, and an object to send in the body of the request formatted as JSON. It will return an instance of <code>T</code> from the response.</p>
<p><code>The</code> <code>GetAsync&lt;T&gt;</code> and <code>PostAsync&lt;T&gt;</code> use a couple of helper methods; use the following code snippet to add them to the <code>ServiceConnection</code> class:</p>
<pre class="source-code">
UriBuilder GetUriBuilder(Uri uri, Dictionary&lt;string, string&gt; parameters)
=&gt; new(uri)
{
    Query = string.Join("&amp;",
    parameters.Select(kvp =&gt;
            $"{kvp.Key}={kvp.Value}"))
};
async ValueTask&lt;AsyncError?&gt; GetError(HttpResponseMessage responseMessage, Stream content)
{
    AsyncError? error;
    if (responseMessage.StatusCode == HttpStatusCode.Unauthorized)
    {
        log.LogError("Unauthorized request {@Uri}", responseMessage.RequestMessage?.RequestUri);
        return new()
        {
            Message = "Unauthorized request."
        };
    }
    try
    {
        error = await JsonSerializer.DeserializeAsync&lt;AsyncError&gt;(content, serializerOptions);
    }
    catch (Exception e)
    {
        error = new AsyncExceptionError()
        {
            Message = e.Message,
            InnerException = e.InnerException?.Message,
        };
    }
    log.LogError("{@Error} {@Message} for {@Uri}", responseMessage.StatusCode, error?.Message, responseMessage?.RequestMessage?.RequestUri);
    return error;
}</pre> <p>The <code>GetUriBuilder</code> method will return a new <code>UriBuilder</code> from the provided URL and <code>Dictionary</code> of key-value pairs to use in the query string. The <code>GetError</code> method will return either an <code>AsyncError</code> object or <code>AsyncExceptionError</code> object based <a id="_idIndexMarker1024"/>on the status code or the contents of the response from the HTTP method call. </p>
<p>Now, we can add the <code>GetAsync&lt;T&gt;</code> method to the <code>ServiceConnection</code> class using the following code:</p>
<pre class="source-code">
public async Task&lt;(T Result, AsyncError Exception)&gt; GetAsync&lt;T&gt;(Uri uri, Dictionary&lt;string, string&gt; parameters)
{
    var builder = GetUriBuilder(uri, parameters);
    var fullUri = builder.ToString();
    log.LogDebug("{@ObjectType} Get REST call @{RestUrl}", typeof(T).Name, fullUri);
    try
    {
        var responseMessage = await httpClient.GetAsync(fullUri);
        log.LogDebug("Response {@ResponseCode} for {@RestUrl}", responseMessage.StatusCode, fullUri);
        if (responseMessage.IsSuccessStatusCode)
        {
            try
            {
                var content = await responseMessage.Content.ReadFromJsonAsync&lt;T&gt;();
                log.LogDebug("Object of type {@ObjectType} parsed for {@RestUrl}", typeof(T).Name, fullUri);
                return (content, null);
            }
            catch (Exception e)
            {
                log.LogError("Error {@ErrorMessage} for when parsing ${ObjectType} for {@RestUrl}", e.Message, typeof(T).Name, fullUri);
                return (default, new AsyncExceptionError()
                {
                    InnerException = e.InnerException?.Message,
                    Message = e.Message
                });
            }
        }
        log.LogDebug("Returning error for @{RestUrl}", fullUri);
        return (default, await GetError(responseMessage, await responseMessage.Content.ReadAsStreamAsync()));
    }
    catch (Exception e)
    {
        log.LogError("Error {@ErrorMessage} for REST call ${ResUrl}", e.Message, fullUri);
        // The service might not be happy with us, we might have connection issues etc..
        return (default, new AsyncExceptionError()
        {
            InnerException = e.InnerException?.Message,
            Message = e.Message
        });
    }
}</pre> <p>While this method is a little long, what it is doing is not all that complicated. First, it uses the <code>GetUriBuilder</code> method to create the <code>UriBuilder</code> instance and build the <code>fullUri</code> string value from that. Then, it makes an HTTP <code>GET</code> call using <code>the HttpClient</code> instance to the URL. If there is any failure, the exception handler will catch it and return an <code>AsynExceptionError</code>. If there are no errors in making the request and the response code indicates success, then the result is processed and returned. Otherwise, the result content is read for an error, and if it is found, it is returned. When the <code>GetAsync&lt;T&gt;</code> method returns, it will always return two items: the response of the <code>T</code> type and <code>AsyncError</code>. If either one of them isn’t present, then their default value is returned or <code>null</code>.</p>
<p>Review <a id="_idIndexMarker1025"/>and add the following code snippet to the <code>ServiceConnection</code> class to implement the <code>PostAsync&lt;T&gt;</code> method:</p>
<pre class="source-code">
public async Task&lt;(T Result, AsyncError Exception)&gt; PostAsync&lt;T&gt;(Uri uri, object parameter)
{
    log.LogDebug("{@ObjectType} Post REST call @{RestUrl}", typeof(T).Name, uri);
    try
    {
        var responseMessage = await httpClient.PostAsJsonAsync(uri, parameter, serializerOptions);
        log.LogDebug("Response {@ResponseCode} for {@RestUrl}", responseMessage.StatusCode, uri);
        await using var content = await responseMessage.Content.ReadAsStreamAsync();
        if (responseMessage.IsSuccessStatusCode)
        {                
            if(string.IsNullOrEmpty(await.responseMessage.Content.ReadAsStringAsync()))
                return (default, null);
            try
            {
                log.LogDebug("Parse {@ObjectType} SUCCESS for {@RestUrl}", typeof(T).Name, uri);
                var result = await responseMessage.Content.ReadFromJsonAsync&lt;T&gt;();
                log.LogDebug("Object of type {@ObjectType} parsed for {@RestUrl}", typeof(T).Name, uri);
                return (result, null);
            }
            catch (Exception e)
            {
                log.LogError("Error {@ErrorMessage} for when parsing ${ObjectType} for {@RestUrl}", e.Message, typeof(T).Name, uri);
                return (default, new AsyncExceptionError()
                {
                    InnerException = e.InnerException?.Message,
                    Message = e.Message
                });
            }
        }
        log.LogDebug("Returning error for @{RestUrl}", uri);
        return (default, await GetError(responseMessage, content));
    }
    catch (Exception e)
    {
        log.LogError("Error {@ErrorMessage} for REST call ${ResUrl}", e.Message, uri);
        // The service might not be happy with us, we might have connection issues etc..
        return (default, new AsyncExceptionError()
        {
            InnerException = e.InnerException?.Message,
            Message = e.Message
        });
    }
}</pre> <p>This <a id="_idIndexMarker1026"/>method is mostly the same as <code>GetAsync&lt;T&gt;</code> with a couple of minor changes. First, it does not need to call <code>GetUriBuilder</code> to add the parameters to the <code>Uri</code> <code>QueryString</code>, as the parameters are sent as part of the request body. Second, it uses the HTTP <code>POST</code> method instead of <code>GET</code>. With those changes, much of the method is error handling to make sure that we return the right data.</p>
<p>And that completes the <code>ServiceConnection</code> class. <code>ServiceConnection</code> and the <code>Settings</code> service classes will be used in the next section, where we create the <code>GameService</code> class.</p>
<h3>Creating the GameService class</h3>
<p>The <code>GameService</code> class is a layer between the UI and the network. It uses the <code>ServiceConnection</code> class, which handles the specific network calls to create the logic <a id="_idIndexMarker1027"/>we need to interact with the Azure Functions functions. For each of the functions that we created in <em class="italic">Chapter 9</em>, there is a corresponding method in the <code>GameService</code> class to make the call to the function and return the result, if any.</p>
<p>Follow these steps to create and initialize the class:</p>
<ol>
<li>Create a new class named <code>GameService</code> in the <code>SticksAndStones.App</code> project under the <code>Services</code> folder.</li>
<li>Change the class definition to <code>public sealed</code> and inherit from the <code>IDisposable</code> interface:<pre class="source-code">
<strong class="bold">public sealed</strong> class GameService <strong class="bold">: IDisposable</strong></pre></li> <li>Add <a id="_idIndexMarker1028"/>the following namespace declarations to the top of the file:<pre class="source-code">
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.AspNetCore.SignalR.Client;
using SticksAndStones.Messages;
using SticksAndStones.Models;</pre></li> <li>The <code>GameService</code> class will depend on both the <code>Settings</code> service and the <code>ServiceConnection</code> service, so we need to add them to the constructor and store the references in class fields, as shown here:<pre class="source-code">
private readonly ServiceConnection service;
private readonly Settings settings;
public GameService(Settings settings, ServiceConnection service)
{
    this.service = service;
    this.settings = settings;
}
GameService</strong> class. .NET MAUI will provide the <code>Settings</code> and <code>ServiceConnection</code> instances through dependency injection.</pre></li> <li>Implement the <code>IDisposable</code> interface by adding the following method to the <code>GameService</code> class:<pre class="source-code">
public void Dispose()
{
    service.Dispose();
    GC.SuppressFinalize(this);
}</pre></li> <li>Now, add <a id="_idIndexMarker1029"/>the class to dependency injection by adding the following highlighted line of code to the <code>MauiProgram.cs</code> file:<pre class="source-code">
#if DEBUG
            builder.Logging.AddDebug();
#endif
            builder.Services.AddSingleton&lt;Services.Settings&gt;();
           builder.Services.AddSingleton&lt;Services.ServiceConnection&gt;();
<strong class="bold">            builder.Services.AddSingleton&lt;Services.GameService&gt;();</strong>
            return builder.Build();</pre></li> </ol>
<p>We will start with the <code>Connect</code> method. <code>Connect</code> will accept a <code>Player</code> object to connect as and return an updated <code>Player</code> object. Additionally, if the connection is successful, it will configure the SignalR Hub. To create the <code>Connect</code> function, follow these steps:</p>
<ol>
<li>Create a <code>private</code> field of <code>SemaphoreSlim</code> called <code>semaphoreSlim</code> and initialize the field with a new instance with an initial and maximum count of <code>1</code>:<pre class="source-code">
public sealed class GameService : IDisposable
{
<strong class="bold">    private readonly SemaphoreSlim semaphoreSlim = new(1, 1);</strong>
    private readonly ServiceConnection service;</pre><p class="list-inset"><code>The SemaphoreSlim</code> class is a great way to limit the number of threads performing an operation <a id="_idIndexMarker1030"/>at a time. In our case, we only want one thread making the network calls at a time. It will be used in all the methods that make network calls from the <code>GameService</code> class.</p></li> <li><code>GameService</code> will track the current player in a <code>public</code> property called <code>CurrentPlayer</code>; add the property to the class using the following code:<pre class="source-code">
private readonly Settings settings;
public Player CurrentPlayer { get; private set; } = new Player() { Id = Guid.Empty, GameId = Guid.Empty };</pre><p class="list-inset">The property is initialized to an empty <code>Player</code> object.</p></li> <li>Once the user has connected as a player, we will also need somewhere to store the list of online players. To do that, add the following property to the <code>GameService</code> class:<pre class="source-code">
public ObservableCollection&lt;Player&gt; Players { get; } = new();</pre></li> <li><code>The GameService</code> class also tracks the current status of the connection in a property called <code>IsConnected</code>; add the property using the following code snippet to the <code>GameService</code> class:<pre class="source-code">
public bool IsConnected { get; private set; }</pre></li> <li>Add a <code>public async</code> method named <code>Connect</code> to the <code>GameService</code> class. It should <a id="_idIndexMarker1031"/>return <code>Task&lt;Player&gt;</code> and take a single <code>Player</code> as a parameter, as shown:<pre class="source-code">
public async Task&lt;Player&gt; Connect(Player player)
{
}</pre></li> <li>Within the <code>Connect</code> method, the first step is to make sure there is only one thread operating in the method at a time:<pre class="source-code">
await semaphoreSlim.WaitAsync();</pre><p class="list-inset">This uses the <code>async</code>/<code>await</code> structures in C# to create a lock that only releases when there are enough open slots in <code>SemaphoreSlim</code>. Since <code>the</code> <code>SemaphoreSlim</code> instance was only initialized with a single slot, only one thread can process the <code>Connect</code> method at a time.</p></li> <li>To make sure <code>the</code> <code>SemaphoreSlim</code> instance releases the slot, we need to add exception handling around the rest of the method and call <code>Release</code> at the end. Add the following code snippet to the <code>Connect</code> method:<pre class="source-code">
try
{
}
finally
{
    semaphoreSlim.Release();
}
return CurrentPlayer;</pre><p class="list-inset">The <code>try</code>/<code>finally</code> block ensures that we will always call <code>Release</code> at the conclusion <a id="_idIndexMarker1032"/>of the method, which will prevent <code>the</code> <code>SemaphoreSlim</code> instance from being starved, preventing any additional thread from entering the method. Lastly, we return the value of <code>CurrentPlayer</code>, which we will set next within the <code>try</code> block.</p></li> </ol>
<p class="callout-heading">There is another way to handle SemaphoreSlim</p>
<p class="callout">Using a <code>try</code>/<code>catch</code>/<code>finally</code> block works, but it is a little clunky if you handle all your exceptions properly, or don’t have any. Tom Dupont has published a helper class on his blog that <a id="_idIndexMarker1033"/>allows you to use a <code>using</code> statement to manage the lifetime of <code>the</code> <code>SemaphoreSlim</code> instance. You can read his post at <a href="http://www.tomdupont.net/2016/03/how-to-release-semaphore-with-using.html">http://www.tomdupont.net/2016/03/how-to-release-semaphore-with-using.html</a>. Here is an example of using his extension:</p>
<p class="callout"><code>using var handle = </code><code>semaphoreSlim.UseWaitAsync();</code></p>
<ol>
<li value="8">Within the <code>try</code> block, add the following lines of code:<pre class="source-code">
CurrentPlayer = player;
var (response, error) = await service.PostAsync&lt;ConnectResponse&gt;(new($"{settings.ServerUrl}/Connect"), new ConnectRequest(player));
if (error is null)
{
    service.ConnectHub(response.ConnectionInfo);
    response.Players.ForEach(Players.Add);
    CurrentPlayer = response.Player;
    IsConnected = true;
}
else
{
    WeakReferenceMessenger.Default.Send&lt;ServiceError&gt;(new(error));
}</pre><p class="list-inset">This <a id="_idIndexMarker1034"/>block of code handles the call to the <code>Connect</code> function in the Azure Functions service. We start by setting the passed-in player details as the <code>CurrentPlayer</code> property. Then, <code>the player</code> instance is packaged into a <code>ConnectRequest</code> object and we pass that into a call to <code>PostAsync&lt;T&gt;</code> on the <code>ServiceConnection</code> instance. The URL is created from the <code>ServerUrl</code> property stored in the <code>Settings</code> service concatenated with <code>/Connect</code>. The response is expected to be of the <code>ConnectResponse</code> type and we store that in response. If we do not get any error, then we can call <code>ConnectHub</code> on the <code>ServiceConnection</code> instance, populate our <code>Players</code> collection, and set <code>the</code> <code>CurrentPlayer</code> property to the returned <code>Player</code> instance, which will have additional details from the server. If anything goes awry, then the error object will be populated, and we will send a message that contains that error to the UI.</p><p class="list-inset"><code>ServiceError</code> is the first message that we need to send to <code>ViewModel</code> instances from <code>the GameService</code> class. It is used to send errors from <code>the</code> <code>ServiceConnection </code>instance to <code>ViewModel</code> instances. We will add the <code>ServiceError</code> class in the next steps.</p></li> </ol>
<ol>
<li value="1">In the <code>SticksAndStones.App</code> project, create a new folder named <code>Messages</code>.</li>
<li>Create a new class named <code>ServiceError</code> in the <code>Messages</code> folder of the <code>SticksAndStones.App</code> project.</li>
<li>The <code>ServiceError</code> message is a simple wrapper around the <code>AyncError</code> object <a id="_idIndexMarker1035"/>that can be used to send a message back to a view model. Replace the contents of the <code>ServiceError.cs</code> file with the following:<pre class="source-code">
using CommunityToolkit.Mvvm.Messaging.Messages;
namespace SticksAndStones.Messages;
internal class ServiceError : ValueChangedMessage&lt;AsyncError&gt;
{
    public ServiceError(AsyncError error) : base(error)
    {
    }
}</pre></li> <li>Finally, since we are using <code>SemaphoreSlim</code> and it can hold onto native resources, we should make sure that those are released properly. Add the following highlighted code to the <code>Dispose</code> method to clean up the <code>semaphoreSlim</code> field:<pre class="source-code">
public void Dispose()
{
<strong class="bold">    semaphoreSlim.Release();</strong>
<strong class="bold">    semaphoreSlim.Dispose();</strong>
    service.Dispose();
    GC.SuppressFinalize(this);
}</pre></li> </ol>
<p>The concludes the <code>Connect</code> method for now. </p>
<p>The <a id="_idIndexMarker1036"/>next three methods are called from the <code>Lobby</code> page. The first method is used to refresh the list of players. It is called when the user pulls down the list causing a refresh, or if the SignalR Hub is reconnected. To implement <code>the</code> <code>RefreshPlayerList</code> method, follow these steps:</p>
<ol>
<li><code>the</code> <code>RefreshPlayerList</code> method takes no arguments and returns <code>Task</code>; add the method to the <code>GameService</code> class as follows:<pre class="source-code">
public async Task RefreshPlayerList()
{
    await semaphoreSlim.WaitAsync();
    try
    {
        var getAllPlayers = service.GetAsync&lt;GetAllPlayersResponse&gt;(new($"{settings.ServerUrl}/Players/GetAll"), new Dictionary&lt;string, string&gt; { { "id", $"{CurrentPlayer.Id}" } });
        var (response, error) = await getAllPlayers;
        if (error is null)
        {
            Players.Clear();
            response.Players.ForEach(Players.Add);
        }
        else
        {      WeakReferenceMessenger.Default.Send&lt;ServiceError&gt;(new(error));
        }
    }
    finally
    {
        semaphoreSlim.Release();
    }
}</pre></li> <li>To refresh <a id="_idIndexMarker1037"/>the list of players when the SignalR Hub reconnects, add the following highlighted code to the <code>Connect</code> method:<pre class="source-code">
if (error is null)
{
    service.ConnectHub(response.ConnectionInfo);
    response.Players.ForEach(Players.Add);
    CurrentPlayer = response.Player;
    <strong class="bold">(await service.Hub).Reconnected += (s) =&gt; { return RefreshPlayerList(); };</strong>
}</pre><p class="list-inset">This line of code is interesting. First, we await <code>service.Hub</code>, then set the <code>Reconnected</code> event to an anonymous function that calls <code>RefreshPlayerList</code>. If you recall, the <code>Hub</code> property in the <code>ServiceConnection</code> class is <code>AsyncLazy&lt;T&gt;</code>. The first time we reference the <code>Hub</code> property, it will initialize itself, asynchronously, hence the <code>await</code> call.</p></li> </ol>
<p>The next method that is used from the <code>Lobby</code> page is <code>IssueChallenge</code>. The <code>IssueChallenge</code> method is called from the <code>Lobby</code> page when a player wishes to play a match against another player. The <code>IssueChallenge</code> method does not return any <a id="_idIndexMarker1038"/>value since the actual response to the challenge will come back through the SignalR Hub. The method will send the request to the server and handle any errors, as shown here:</p>
<pre class="source-code">
public async Task IssueChallenge(Player opponent)
{
    await semaphoreSlim.WaitAsync();
    try
    {
        var (response, error) = await service.PostAsync&lt;IssueChallengeResponse&gt;(new($"{settings.ServerUrl}/Challenge/Issue"), new IssueChallengeRequest(CurrentPlayer, opponent));
        if (error is not null)
        {         WeakReferenceMessenger.Default.Send&lt;ServiceError&gt;(new(error));
        }
    }
    finally
    {
        semaphoreSlim.Release();
    }
}</pre> <p>Add the preceding code to the <code>GameService</code> class. The <code>SendChallengeResponse</code> method, which is called when the opposing player responds to a challenge, is very similar to the <code>IssueChallenge</code> method, as shown:</p>
<pre class="source-code">
public async Task SendChallengeResponse(Guid challengeId, Models.ChallengeResponse challengeResponse)
{
    await semaphoreSlim.WaitAsync();
    try
    {
        var (response, error) = await service.PostAsync&lt;string&gt;(new($"{settings.ServerUrl}/Challenge/Ack"), new AcknowledgeChallengeRequest(challengeId, challengeResponse));
        if (error is not null)
        {         WeakReferenceMessenger.Default.Send&lt;ServiceError&gt;(new(error));
        }
    }
    finally
    {
        semaphoreSlim.Release();
    }
}</pre> <p>Add <a id="_idIndexMarker1039"/>the <code>SendChallengeResponse</code> method to the <code>GameService</code> class. That completes the methods needed to support the <code>Lobby</code> page. The final page in our app is the <code>Game</code> page. There are three more methods that are needed by the <code>Game</code> page. Follow these steps to add them:</p>
<ol>
<li>Add the <code>EndTurn</code> method, which will send the player’s move to the <code>Game</code> server, using the following code snippet:<pre class="source-code">
public async Task&lt;(Game?, string?)&gt; EndTurn(Guid gameId, int position)
{
    await semaphoreSlim.WaitAsync();
    try
    {
        var (response, error) = await service.PostAsync&lt;ProcessTurnResponse&gt;(new($"{settings.ServerUrl}/Game/Move"), new ProcessTurnRequest(gameId, CurrentPlayer, position));
        if (error is not null)
        {
            return (null, error.Message);
        }
        else return (response.Game, null);
    }
    finally
    {
        semaphoreSlim.Release();
    }
}</pre><p class="list-inset"><code>EndTurn</code> is very <a id="_idIndexMarker1040"/>similar to the <code>IssueChallenge</code> and <code>SendChallengeResponse</code> methods, with a minor exception: it returns the updated <code>Game</code> object and an error message if present.</p></li> <li><code>the</code> <code>GetPlayerId</code> method is a small helper function to search the <code>Players</code> list and return the <code>Player</code> instance that matches the ID passed in. Use the following code snippet to add the <code>GetPlayerById</code> method:<pre class="source-code">
public Player? GetPlayerById(Guid playerId)
{
    if (playerId == CurrentPlayer.Id)
        return CurrentPlayer;
    return (from p in Players where p.Id == playerId select p).FirstOrDefault();
}</pre></li> <li><code>the</code> <code>GetMatchById</code> method is the last method that will make a call to the backend. In this case, it will <a id="_idIndexMarker1041"/>retrieve a <code>Match</code> object given an ID. Using the following code snippet, add <code>GetMatchById</code> to the <code>GameService</code> class:<pre class="source-code">
public async Task&lt;Match&gt; GetMatchById(Guid matchId)
{
    await semaphoreSlim.WaitAsync();
    try
    {
        var (response, error) = await service.GetAsync&lt;GetMatchResponse&gt;(new($"{settings.ServerUrl}/Match/{matchId}"), new());
        if (error != null) { }
        if (response.Match != null)
            return response.Match;
        return new Match();
    }
    finally
    {
        semaphoreSlim.Release();
    }
}</pre></li> </ol>
<p>The <a id="_idIndexMarker1042"/>final piece to <code>the</code> <code>GameService</code> class is the handling of the events received through the SignalR Hub. To refresh our memory from <em class="italic">Chapter 9</em>, the backend functions will send the following events to the clients via SignalR:</p>
<ul>
<li><code>PlayerUpdatedEventArgs</code></li>
<li><code>ChallengeEventArgs</code></li>
<li><code>GameStartedEventArgs</code></li>
<li><code>GameUpdatedEventArgs</code></li>
</ul>
<p>We will handle each of these events in the <code>GameService</code> method. To implement the handlers for these events, follow these steps:</p>
<ol>
<li>When the <code>Hub</code> receives <code>PlayerUpdatedEventArgs</code>, we will need to update <code>Player</code> in the <code>Players</code> collection with the new values. We will create a helper function to handle that work, as follows:<pre class="source-code">
private void PlayerStatusChangedHandler(PlayerUpdatedEventArgs args)
{
    var changedPlayer = (from player in Players
                         where player.Id == args.Player.Id
                         select player).FirstOrDefault();
    if (changedPlayer is not null)
    {
        changedPlayer.MatchId = args.Player.MatchId;
    }
    else if (args.Player.Id != CurrentPlayer.Id)
    {
        Players.Add(args.Player);
    }
}</pre><p class="list-inset">The <code>PlayerStatusChangedHandler</code> method will locate the changed player <a id="_idIndexMarker1043"/>in the <code>Players</code> collection and update the relevant fields of the instance or add it if it doesn’t exist.</p></li> <li>To call <code>the</code> <code>PlayerStatusUpdateHandler</code> class when the <code>PlayerUpdated</code> event is received, add the following highlighted code to the <code>Connect</code> method:<pre class="source-code">
if (error is null)
{
    service.ConnectHub(response.ConnectionInfo);
    response.Players.ForEach(Players.Add);
    CurrentPlayer = response.Player;
    IsConnected = true;
<strong class="bold">    (await service.Hub).On&lt;PlayerUpdatedEventArgs&gt;(Constants.Events.PlayerUpdated, PlayerStatusChangedHandler);</strong>
    (await service.Hub).Reconnected += (s) =&gt; { return RefreshPlayerList(); };
}</pre></li> </ol>
<p>The <a id="_idIndexMarker1044"/>other three events will send messages to the <code>ViewModel</code> instance using <code>WeakReferenceManager</code>. First, we need to add the message types, using the following steps:</p>
<ol>
<li>Add a new class named <code>ChallengeReceived</code> to the <code>Messages</code> folder in the <code>SticksAndStones.App</code> project.</li>
<li>Replace the contents of the <code>ChallengeReceived.cs</code> file with the following:<pre class="source-code">
using CommunityToolkit.Mvvm.Messaging.Messages;
using SticksAndStones.Models;
namespace SticksAndStones.Messages;
public class ChallengeRecieved : ValueChangedMessage&lt;Player&gt;
{
    public Guid Id { get; init; }
    public ChallengeRecieved(Guid id, Player challenger) : base(challenger)
    {
        Id = id;
    }
}</pre></li> <li>Add a new class named <code>MatchStarted</code> in the <code>Messages</code> folder of the <code>SticksAndStones.App</code> project.</li>
<li>Replace <a id="_idIndexMarker1045"/>the contents of the <code>MatchStarted.cs</code> file with the following code:<pre class="source-code">
using CommunityToolkit.Mvvm.Messaging.Messages;
using SticksAndStones.Models;
namespace SticksAndStones.Messages;
public class MatchStarted : ValueChangedMessage&lt;Match&gt;
{
    public MatchStarted(Match match) : base(match)
    {
    }
}</pre></li> <li>Add a new class named <code>MatchUpdated</code> to the <code>SticksAndStones.App</code> project in the <code>Messages</code> folder.</li>
<li>Replace the contents of the <code>MatchUpdated.cs</code> file with the following code:<pre class="source-code">
using CommunityToolkit.Mvvm.Messaging.Messages;
using SticksAndStones.Models;
namespace SticksAndStones.Messages;
class MatchUpdated : ValueChangedMessage&lt;Match&gt;
{
    public MatchUpdated(Match match) : base(match)
    {
    }
}</pre></li> <li>To send <a id="_idIndexMarker1046"/>a message when the event is received, add the following highlighted code to the <code>Connect</code> method in the <code>GameService</code> class:<pre class="source-code">
service.ConnectHub(response.ConnectionInfo);
response.Players.ForEach(Players.Add);
CurrentPlayer = response.Player;
IsConnected = true;
(await service.Hub).On&lt;PlayerUpdatedEventArgs&gt;(Constants.Events.PlayerUpdated, PlayerStatusChangedHandler);
<strong class="bold">(await service.Hub).On&lt;ChallengeEventArgs&gt;(Constants.Events.Challenge, (args) =&gt; WeakReferenceMessenger.Default.Send(new ChallengeRecieved(args.Id, args.Challenger)));</strong>
<strong class="bold">(await service.Hub).On&lt;MatchStartedEventArgs&gt;(Constants.Events.MatchStarted, (args) =&gt; WeakReferenceMessenger.Default.Send(new MatchStarted(args.Game)));</strong>
<strong class="bold">(await service.Hub).On&lt;MatchUpdatedEventArgs&gt;(Constants.Events.MatchUpdated, (args) =&gt; WeakReferenceMessenger.Default.Send(new MatchUpdated(args.Game)));</strong>
(await service.Hub).Reconnected += (s) =&gt; { return RefreshPlayerList(); };</pre></li> </ol>
<p>That <a id="_idIndexMarker1047"/>concludes the <code>GameService</code> class. We have all the methods needed to interact with the backend functions and we are handling the events that are being sent to the clients. The next portion of the chapter will add the pages needed to present the <a id="_idTextAnchor885"/><a id="_idTextAnchor886"/>screens to the user, starting with the <strong class="bold">Connect</strong> page.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor887"/>Creating the Connect page</h2>
<p>The <strong class="bold">Connect</strong> page, as shown in <em class="italic">Figure 10</em><em class="italic">.6</em>, is the first screen a user is presented with after <a id="_idIndexMarker1048"/>the app loads. The page contains four main elements: an entry box for the player’s gamer tag, an entry box for the player’s email address, an image control for the player’s avatar, and the <strong class="bold">Connect</strong> button.</p>
<div><div><img alt="Figure 10.6 – The Connect page" src="img/B19214_10_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – The Connect page</p>
<p>The <strong class="bold">Connect</strong> page will consist of several parts:</p>
<ul>
<li>A <code>ViewModel</code> file called <code>ConnectViewModel.cs</code></li>
<li>A XAML file called <code>ConnectView.xaml</code>, which contains the layout</li>
<li>A code-behind file called <code>ConnectView.xaml.cs</code>, which will carry out the data-binding process</li>
<li>A XAML file containing the layout for a custom button control, called <code>ActivityButton.xaml</code></li>
<li>The code-behind for <code>ActivityButton</code> in <code>ActivityButton.xaml.cs</code></li>
</ul>
<p>We will <a id="_idIndexMarker1049"/>begin the implementation of the <code>ConnectViewModel</code> first. </p>
<h3>Adding ConnectViewModel</h3>
<p><code>ConnectViewModel</code> – along with <code>LobbyViewModel</code> and <code>GameView</code> model – will inherit <a id="_idIndexMarker1050"/>from a single base class called <code>ViewModelBase</code>. The <code>ViewModelBase</code> class provides the necessary functionality to implement refreshing the page. Not all pages will use this feature, but it will be available. To add <code>ViewModelBase</code>, follow these steps:</p>
<ol>
<li>Create a new folder named <code>ViewModels</code> in the <code>SticksAndStones.App</code> project.</li>
<li>Add a new class named <code>ViewModelBase</code> in the <code>ViewModels</code> folder.</li>
<li>Add the following namespace declarations at the top of the <code>ViewModelBase.cs</code> file:<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;</pre></li> <li>Change the class declaration to <code>public abstract partial</code> and derive the class from <code>ObservableRecipient</code>:<pre class="source-code">
<code>ObservableRecipient</code> comes from <code>CommunityToolkit</code>. If you have worked through the other chapters in this book, you will have seen view models that derive from <code>ObservableObject</code>, which implements <code>INotifyPropertyChanged</code>. <code>ObservableRecipient</code> extends <code>ObservableObject</code> and adds built-in support for working with implementations of the .NET MAUI <code>IMessage</code> interface. To learn more about <code>ObservableRecipient</code>, visit <a href="https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/observablerecipient">https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/observablerecipient</a>.</p></li> <li>Add a <code>private bool</code> field named <code>canRefresh</code> with the <code>ObservableProperty</code> attribute:<pre class="source-code">
[ObservableProperty]
private bool canRefresh;</pre></li> <li>Add a <code>private bool</code> field named <code>isRefreshing</code> with the <code>ObservableProperty</code> attribute:<pre class="source-code">
[ObservableProperty]
private bool isRefreshing;</pre></li> <li>Add a <code>private</code> method named <code>CanExecuteRefresh</code> that takes no parameters <a id="_idIndexMarker1051"/>and returns a <code>bool</code>. The method signature and implementation are in the following code snippet:<pre class="source-code">
private bool CanExecuteRefresh() =&gt; CanRefresh &amp;&amp; !IsRefreshing;</pre></li> <li>Add a new <code>protected virtual</code> method named <code>RefreshInternal</code> that returns a <code>Task</code> and its implementation returns <code>Task.CompletedTask</code>, as shown here:<pre class="source-code">
protected virtual Task RefreshInternal() =&gt; Task.CompletedTask;</pre></li> <li>Add the <code>Refresh</code> method as shown here:<pre class="source-code">
[RelayCommand(CanExecute = nameof(CanExecuteRefresh))]
public async Task Refresh()
{
    IsRefreshing = true;
    await RefreshInternal();
    IsRefreshing = false;
    return;
}</pre><p class="list-inset">The <code>Refresh</code> method is a <code>Command</code>, meaning that it can be bound to XAML elements as <code>RefreshCommand</code>. The <code>CanExecuteRefresh</code> method is used to determine <a id="_idIndexMarker1052"/>the enabled/disabled state for the command. The command itself flips the <code>IsRefreshing</code> Boolean and calls the <code>RefreshInternal</code> method where classes derived from <code>ViewModelBase</code> would put the specific implementation.</p></li> </ol>
<p>Now that <code>ViewModelBase</code> has been implemented, we can implement <code>ConnectViewModel</code>. The <code>ConnectViewModel</code> class has bindable properties for the player’s gamer tag and email address and various states for commands. Finally, there is a command to establish a connection to the game services. Let’s implement the <code>ConnectViewModel</code> class by following these steps:</p>
<ol>
<li>Create a new class named <code>ConnectViewModel</code> in the <code>ViewModels</code> folder.</li>
<li>Alter the class definition to <code>public partial</code> and derive from <code>ViewModelBase</code>, as shown here:<pre class="source-code">
<strong class="bold">public partial</strong> class ConnectViewModel : <strong class="bold">ViewModelBase</strong>
{
}</pre></li> <li><code>ConnectViewModel</code> depends on <code>GameService</code> and the <code>Settings</code> service so let’s add a constructor to acquire them through dependency injection and <code>private</code> fields to store their values, as shown here:<pre class="source-code">
public partial class ConnectViewModel : ViewModelBase
{
    private readonly GameService gameService;
    private readonly Settings settings;
    public ConnectViewModel(GameService gameService, Settings settings)
    {
        this.gameService = gameService;
        this.settings = settings;
    }
}</pre></li> <li>To use <a id="_idIndexMarker1053"/>the <code>GameService</code> and <code>Settings</code> classes, you’ll need to add a namespace declaration to the top of the file:<pre class="source-code">
using SticksAndStones.Services;</pre></li> <li>Add a <code>private string</code> field named <code>gamerTag</code> attributed with <code>ObservableProperty</code> to make it bindable, as shown in the following code snippet:<pre class="source-code">
[ObservableProperty]
private string gamerTag;</pre></li> <li>Add a <code>private string</code> field named <code>emailAddress</code> attributed with <code>ObservableProperty</code> to make it bindable, as shown in this code snippet:<pre class="source-code">
[ObservableProperty]
private string emailAddress;</pre></li> <li>In the <a id="_idIndexMarker1054"/>constructor for <code>ConnectViewModel</code>, initialize the bindable properties from the last time the user connected, as shown in the following snippet:<pre class="source-code">
{
    this.gameService = gameService;
    this.settings = settings;
    // Load Player settings
    var player = settings.LastPlayer;
    Username = player.GamerTag;
    EmailAddress = player.EmailAddress;
}</pre></li> <li>The <strong class="bold">Connect</strong> page does not need to refresh the view, so disable that functionality by adding the following line of code to the beginning of the constructor:<pre class="source-code">
CanRefresh = false;</pre></li> <li>To implement the <code>Connect</code> command, we will need four things: a <code>string</code> indicating the status of the command, a <code>bool</code> to indicate the current state of the command, a method to return if the command is enabled, and the method for the command itself. To add the status as a string, add the following code above the constructor in the <code>ConnectViewModel</code> class:<pre class="source-code">
[ObservableProperty]
private string connectStatus;</pre><p class="list-inset">We mark this field with <code>ObservableProperty</code> so that it is bindable into the view.</p></li> <li>To add the <code>isConnecting</code> field to track the state of the command, add the following code under the <code>connectStatus</code> field:<pre class="source-code">
[ObservableProperty]
private bool isConnecting;</pre></li> <li>The <code>CanExecuteConnect</code> method will return <code>true</code> if the command is enabled, and <code>false</code> if not. Add the method using the following code snippet under the <code>isConnecting</code> field:<pre class="source-code">
private bool CanExecuteConnect() =&gt; !string.IsNullOrEmpty(GamerTag) &amp;&amp; !string.IsNullOrEmpty(EmailAddress) &amp;&amp; !IsConnecting;</pre></li> <li>The <code>Connect</code> command will call a <code>Connect</code> method to establish the connection <a id="_idIndexMarker1055"/>with the game server. This is mostly just to keep the methods small and manageable. Add the following private <code>Connect</code> method to the <code>ConnectViewModel</code> class:<pre class="source-code">
private async Task&lt;Player&gt; Connect(Player player)
{
    // Get SignalR Connection
    var playerUpdate = await gameService.Connect(player);
    if (gameService.IsConnected)
    {
        // If the player has an in progress match, take them to it.
        if (gameService.CurrentPlayer?.MatchId != Guid.Empty)
        {
            await Shell.Current.GoToAsync($"///Match", new Dictionary&lt;string, object&gt;() { { "MatchId", gameService.CurrentPlayer.MatchId } });
        }
        else
        {
            await Shell.Current.GoToAsync($"///Lobby");
        }
    }
    return playerUpdate;
}</pre><p class="list-inset">This method will call the <code>Connect</code> method on the <code>GameService</code> class passing <a id="_idIndexMarker1056"/>in the player details. If the connection is successful, then the user is navigated to the Lobby page, unless they are currently in a game, in which case, they are navigated to the Game page.</p></li> </ol>
<p class="callout-heading">Navigation in .NET MAUI Shell</p>
<p class="callout">In .NET MAUI, navigation <a id="_idIndexMarker1057"/>is performed by calling <code>GotoAsync</code> from the <code>Shell</code> object. The <code>Shell</code> object can be obtained by either casting <code>App.Current.MainPage</code> to a <code>Shell</code> object, or by using the <code>Shell.Current</code> property. The route passed to <code>GotoAsync</code> can be either relative to the current location or absolute. The valid forms of relative and absolute routes are as follows:</p>
<p class="callout"><code>• route</code> – The route will be searched for upward from the current position and, if found,  pushed onto the navigation stack</p>
<p class="callout"><code>• /route</code> – The route will be searched for downward from the current position and, if found, pushed onto the navigation stack</p>
<p class="callout"><code>• //route</code> – The route will be searched for upward from the current position and, if found, will replace the navigation stack</p>
<p class="callout"><code>• ///route</code> – The route will be searched for downward from the current position and, if found, will replace the navigation stack</p>
<p class="callout">To learn more about routes and navigation, visit <a href="https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation">https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation</a>.</p>
<ol>
<li value="13">Add the <a id="_idIndexMarker1058"/>method implementing the <code>Connect</code> command to the bottom of the <code>Connect</code><strong class="source-inline">
ViewModel</strong> class using the following code snippet:<pre class="source-code">
    [RelayCommand(CanExecute = nameof(CanExecuteConnect))]
    public async Task Connect()
    {
        IsConnecting = true;
        ConnectStatus = "Connecting...";
        var player = settings.LastPlayer;
        player.GamerTag = GamerTag;
        player.EmailAddress = EmailAddress;
        player.Id = (await Connect(player)).Id;
        settings.LastPlayer = player;
        ConnectStatus = "Connect";
        IsConnecting = false;
    }</pre><p class="list-inset">The command is very straightforward. It sets the <code>IsConnecting</code> and <code>ConnectStatus</code> properties, then updates the <code>Player</code> values from the view. Then, it calls <code>Connect</code>, passing in the current <code>Player</code> instance. The ID of the returned player is captured and set back on <code>LastPlayer</code> in <code>Settings</code>. Finally, the <code>ConnectStatus</code> and <code>IsConnecting</code> properties are set back to their defaults.</p></li> <li>To wrap <a id="_idIndexMarker1059"/>things up, we need to add a couple of attributes to make sure that properties are updated appropriately as values change. For instance, when the <code>IsConnecting</code> property is changed, we need to ensure that the <code>CanExecuteConnect</code> method is evaluated again. To do this, we add the <code>NotifyCanExecuteChangeFor</code> attribute to the <code>IsConnecting</code> field, as shown here:<pre class="source-code">
[ObservableProperty]
<strong class="bold">[NotifyCanExecuteChangedFor(nameof(ConnectCommand))]</strong>
private bool isConnecting;</pre><p class="list-inset">Since the <code>gamerTag</code> field and <code>emailAddress</code> field are also referenced in the <code>CanExecuteConnect</code> method, we should add the attribute to those fields as well, as shown here:</p><pre class="source-code">[ObservableProperty]
<strong class="bold">[NotifyCanExecuteChangedFor(nameof(ConnectCommand))]</strong>
private string gamerTag;
[ObservableProperty]
<strong class="bold">[NotifyCanExecuteChangedFor(nameof(ConnectCommand))]</strong>
private string emailAddress;</pre></li> </ol>
<p>We have <a id="_idIndexMarker1060"/>nearly completed <code>ConnectViewModel</code>. The final feature to implement is the handling of messages that we may receive from <code>GameService</code>. The <code>ObservableObject</code> implementation from <code>CommunityToolkit</code> provides a feature to make subscribing and unsubscribing to these messages clean. To implement the message handlers, follow these steps:</p>
<ol>
<li>Add a new <code>private</code> method named <code>OnServiceError</code> to the <code>ConnectViewModel</code> class, using the following code snippet:<pre class="source-code">
private void OnServiceError(AsyncError error)
{
    MainThread.BeginInvokeOnMainThread(async () =&gt;
    {
        await Shell.Current.CurrentPage.DisplayAlert("There is a problem...", error.Message, "Ok");
    });
}</pre></li> <li>We will subscribe to the <code>ServiceError</code> messages from the <code>OnActivated</code> event method of the <code>ObservableObject</code> class, Add the following method to the <code>ConnectViewModel</code> class to subscribe to the <code>ServiceError</code> message:<pre class="source-code">
protected override void OnActivated() =&gt; Messenger.Register&lt;ServiceError&gt;(this, (r, m) =&gt; OnServiceError(m.Value));</pre></li> <li>To unsubscribe from the <code>ServiceError</code> messages, add the following method to the <code>ConnectViewModel</code> class:<pre class="source-code">
protected override void OnDeactivated() =&gt; Messenger.Unregister&lt;ServiceError&gt;(this);</pre></li> <li>In the constructor for <code>ConnectViewModel</code>, we need to enable the <code>OnActivated</code> and <code>OnDeactivated</code> events that are raised by <code>ObservableObject</code>. These events are the recommended places to subscribe and unsubscribe to messages. Add the following line of code to the end of the constructor to enable the events:<pre class="source-code">
IsActive = true;</pre><p class="list-inset">Setting <code>IsActive</code> to <code>true</code> will cause the <code>OnActivated</code> event to fire. Setting it to <code>false</code> will cause the <code>OnDeactivated</code> event to fire.</p></li> <li>To have <a id="_idIndexMarker1061"/>the <code>OnDeactivated</code> event fire, we need to set <code>IsActive</code> to <code>false</code>. In the <code>Connect</code> method, add the highlighted line of code:<pre class="source-code">
private async Task&lt;Player&gt; Connect(Player player)
{
    // Get SignalR Connection
    var playerUpdate = await gameService.Connect(player);
    if (gameService.IsConnected)
    {
<strong class="bold">        IsActive = false;</strong>
        // If the player has an in progress match, take them to it.
        if (gameService.CurrentPlayer?.MatchId != Guid.Empty)
        {
            await Shell.Current.GoToAsync($"///Match", new Dictionary&lt;string, object&gt;() { { "MatchId", gameService.CurrentPlayer.MatchId } });
        }
        else
        {
            await Shell.Current.GoToAsync($"///Lobby");
        }
    }
    return playerUpdate;
}</pre></li> <li>Open the <code>MauiProgram.cs</code> file in the <code>SticksAndStones.App</code> project and <a id="_idIndexMarker1062"/>add the following highlighted line to register <code>ConnectViewModel</code> with dependency injection:<pre class="source-code">
builder.Services.AddSingleton&lt;Services.GameService&gt;();
<strong class="bold">builder.Services.AddTransient&lt;ViewModels.ConnectViewModel&gt;();</strong>
return builder.Build();</pre></li> </ol>
<p>This concludes the implementation of <code>ConnectViewModel</code>. The <code>ConnectViewModel</code> class controls the entry of the user’s gamer tag and email. It connects the user to the game server using their player details.</p>
<h3>Adding the Connect view</h3>
<p>The <code>Connect</code> view <a id="_idIndexMarker1063"/>looks fairly <a id="_idIndexMarker1064"/>simple, but there is a lot to it. We will break down the creation of the view into three sections: </p>
<ul>
<li>Creating the <code>ActivityButton</code> control:<p class="list-inset">The <code>ActivityButton</code> control is the button used to initiate a connection to the backend services. While a simple button might do the trick, what if we had an animation that indicated the <code>connect</code> operation was in progress and the text of the button updated as well? That is what <code>ActivityButton</code> will do, in a reusable control.</p></li>
<li>Creating the images:<p class="list-inset">There are a few images used on this page. All of them were generated using AI. We’ll explore how that was done.</p></li>
<li>Building the view:<p class="list-inset">This is where we bring <code>ActivityButton</code> together with our custom images and the built-in controls of .NET MAUI to make <code>ConnectView</code> appear as it does in the figures.</p></li>
</ul>
<p>Let’s start by building the <code>ActivityButton</code> control.</p>
<h4>Creating the ActivityButton control</h4>
<p>So, what <a id="_idIndexMarker1065"/>is this <code>ActivityButton</code> control? It’s basically a button with an <code>ActivityIndicator</code> that will only show up while the task behind the button is doing its work. The complexity of this control comes from the fact that we are making a general-purpose control instead of a specialized control. So, for all intents and purposes, it needs to act like a normal <code>Button</code> and <code>ActivityIndicator</code>. We are only going to implement the feature that we need for this application, but even then, it’s still a reusable control. </p>
<p>From <code>Button</code>, we want to have the following XAML attributes:</p>
<ul>
<li><code>Text</code>, <code>FontFamily</code>, and <code>FontSize</code></li>
<li><code>Command</code> and <code>CommandParameter</code></li>
</ul>
<p>From <code>ActivityIndicator</code>, we will have <code>IsRunning</code>.</p>
<p>Each of these XAML elements will be bindable, like their original properties. An example of what <a id="_idIndexMarker1066"/>the XAML might look like for declaring this control as an element would be as follows:</p>
<pre class="source-code">
&lt;controls:ActivityButton IsRunning="{Binding IsConnecting}" 
                         Text="{Binding ConnectStatus}" 
                         BackgroundColor="#e8bc65" 
                         Command="{Binding ConnectCommand}" 
                         HorizontalOptions="Center"
                         WidthRequest="200"
                         HeightRequest="48"/&gt;</pre> <p>This listing comes from the actual XAML we will be creating for <code>ConnectView.xaml</code> later in this section.</p>
<p>The attributes that are copied from the two underlying controls need to be able to bind to the view model. This requires that they are implemented as bound properties. To create a bound property, you need two things: a property and a <code>BindableProperty</code> that references the property. The <code>BindableProperty</code> provides the functionality to keep the view model property, which implements <code>INotifyPropertyChanged</code>, with the property of the control. Let’s create the <code>Command</code> bindable property as an example:</p>
<ol>
<li>Create a new folder named <code>Controls</code> in the <code>SticksAndStones.App</code> project.</li>
<li>Add a new .NET MAUI <code>ContentView</code> (XAML) called <code>ActivityButton</code>.</li>
<li>Open the <code>ActivityButton.xaml.cs</code> file.</li>
<li>Create a new <code>public ICommand</code> property named <code>Command</code>, as shown in the following listing:<pre class="source-code">
public ICommand Command
{
    get =&gt; (ICommand)GetValue(CommandProperty);
    set { SetValue(CommandProperty, value); }
}</pre><p class="list-inset"><code>BindableProperty</code> properties have a circular reference with the properties they are <a id="_idIndexMarker1067"/>bound to, so you will get red squigglies until we complete the next step. This looks like almost every other property we have created, except that the <code>get</code> and <code>set</code> methods are just delegating to the <code>GetValue</code> and <code>SetValue</code> methods, respectively. <code>GetValue</code> and <code>SetValue</code> are provided by the <code>BindableObject</code> class, which <code>ContentView</code> ultimately inherits from. <code>GetValue</code> and <code>SetValue</code> are the <code>BindableObject</code> equivalents to <code>INotifyPropertyChanged</code> for view models. Calling them not only stores the values but also sends notifications that the value has changed.</p></li> <li>Now, add the <code>BindableProperty</code> property for the <code>Command</code> property, using the following code snippet:<pre class="source-code">
public static readonly BindableProperty CommandProperty = BindableProperty.Create(
    propertyName: nameof(Command),
    returnType: typeof(ICommand),
    declaringType: typeof(ActivityButton),
    defaultBindingMode: BindingMode.TwoWay);</pre><p class="list-inset"><code>CommandProperty</code> is of the <code>BindableProperty</code> type and is created by using the <code>Create</code> factory method of the <code>BindableProperty</code> class. We pass in the name of the property we are binding to (<code>Command</code>), the type that property returns (<code>Icommand</code>), the declaring type (which is <code>ActivityButton</code> in this case), and then what mode we want the binding to have. There are four options for <code>BindingMode</code>:</p><ul><li><code>OneWay</code> – The default, propagates changes from the source (the view model) to the target (the control)</li><li><code>OneWayToSource</code> – This is the reverse of <code>OneWay</code>, propagating changes from the target (the control) to the source (the view model)</li><li><code>TwoWay</code> – This propagates changes in both directions</li><li><code>OneTime</code> – This propagates the changes only when <code>BindingContext</code> changes and all <code>INotifyPropertyChanged</code> events are ignored</li></ul><p class="list-inset">These two pieces – the normal property that you would use in most of your C# classes, and <code>BindableProperty</code> – provide the complete functionality we need to create the custom control. </p></li> </ol>
<p>Now that <a id="_idIndexMarker1068"/>we understand how to implement <code>BindableProperty</code> on a XAML control, we can complete the implementation of <code>ActivityButton</code>.</p>
<p>Let’s start by updating the XAML and then we will follow that with the remaining <code>BindableProperty</code> implementations. The following steps will walk you through creating the control:</p>
<ol>
<li>The template we chose to create the XAML and <code>.cs</code> files is not quite what we need for <code>ActivityButton</code>. We will need to alter the underlying root control from <code>ContentView</code> to <code>Frame</code>. We use <code>Frame</code> to wrap our layout with a border. Open the <code>ActivityButton.cs</code> file and update the class definition to inherit from <code>Frame</code> instead of <code>ContentView</code>, as follows:<pre class="source-code">
public partial class ActivityButton : <code>ActivityButton.xaml</code> file and modify it to look like the following:<pre class="source-code">
&lt;<strong class="bold">Frame</strong>  
             
             x:Class="SticksAndStones.Controls.ActivityButton"&gt;
&lt;/<code>ContentView</code> to <code>Frame</code>, also remove the contents of <code>Frame</code> as we won’t be reusing it.</p></li> <li>Let’s name our control to make it easier to reference it later. Typically, in C#, if you want <a id="_idIndexMarker1069"/>to reference the instance of the class, you will use the <code>this</code> keyword. That doesn’t exist by default in XAML so add the <code>x:Name</code> attribute with the value of <code>this</code> to mimic C#.</li>
<li>Update the <code>Frame</code> element and add the <code>BackgroundColor</code> attribute with a value of <code>{x:StaticResource Primary}</code>. <code>Primary</code> is defined in the <code>Resources/Styles/Colors.xaml</code> file and we can reference it using the <code>StaticResource</code> extension method.</li>
<li>Update the <code>Frame</code> element and add the <code>CornerRadius</code> attribute with a value of <code>5</code>. This will give our button rounded corners.</li>
<li>Add the <code>Padding</code> attribute with a value of <code>12</code> to the <code>Frame</code> element. This will ensure that there is plenty of whitespace around the control. The <code>Frame</code> element should now look like the following:<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;Frame 
             
             x:Class="SticksAndStones.Controls.ActivityButton"
        <strong class="bold">x:Name="this"</strong>
        <strong class="bold">BackgroundColor="{x:StaticResource Primary}"</strong>
        <strong class="bold">CornerRadius="5"</strong>
        <strong class="bold">Padding="12"</strong>&gt;
&lt;/Frame&gt;</pre></li> <li>To get <code>ActivityIndicator</code> and <code>Label</code> centered side by side within <code>Frame</code>, we will use <code>HorizontalStackLayout</code> contained in <code>VerticalStackLayout</code>. <code>StackLayout</code> controls ignore the alignment options <a id="_idIndexMarker1070"/>for the direction of the control, so, for example, <code>VerticalStackLayout</code> ignores the <code>VerticalOptions</code> property of its children and <code>HorizontalStackLayout</code> ignores the <code>HorizontalOptions</code> property of its children. This is because, by its nature, <code>HorizontalStackLayout</code> is in control of laying out its children in the horizontal plane, and the same is true for <code>VerticalStackLayout</code>, except in the vertical plane. Add the following highlighted code to the XAML:<pre class="source-code">
&lt;Frame 
             
             x:Class="SticksAndStones.Controls.ActivityButton"
        BackgroundColor="{x:StaticResource Primary}"
        CornerRadius="5"
        Padding="12"&gt;
<strong class="bold">    &lt;VerticalStackLayout&gt;</strong>
<strong class="bold">        &lt;HorizontalStackLayout HorizontalOptions="CenterAndExpand" Spacing="10"&gt;</strong>
<strong class="bold">        &lt;/HorizontalStackLayout&gt;</strong>
<strong class="bold">    &lt;/VerticalStackLayout&gt;</strong>
&lt;/Frame&gt;</pre></li> <li>Within the <code>HorizontalStackLayout</code> element, add the following XAML:<pre class="source-code">
&lt;ActivityIndicator HeightRequest="15" WidthRequest="15"
                   Color="{x:StaticResource White}" 
                   IsRunning="{Binding Source={x:Reference this},Path=IsRunning}"
                   IsVisible="{Binding Source={x:Reference this},Path=IsRunning}"
                   VerticalOptions="CenterAndExpand"/&gt;</pre><p class="list-inset"><code>ActivityIndicator</code> will have a <code>Height</code> and <code>Width</code> value of <code>15</code> and a <code>Color</code> value of <code>White</code>. The <code>IsRunning</code> and <code>IsVisible</code> properties are bound to <a id="_idIndexMarker1071"/>the control’s <code>IsRunning</code> property. We haven’t created the <code>IsRunning</code> property yet, so this won’t work until we do. The <code>x:Reference</code> markup extension allows us to bind the property to the parent control, which we named <code>this</code> in <em class="italic">step 3</em>.</p></li> <li>Now, we can add <code>Label</code> within <code>HorizontalStackLayout</code> using the following XAML:<pre class="source-code">
&lt;Label x:Name="buttonLabel" TextColor="{x:StaticResource White}" 
       Text="{Binding Source={x:Reference this},Path=Text}" 
       FontSize="15"
       VerticalOptions="CenterAndExpand"
       VerticalTextAlignment="Center" 
       HorizontalTextAlignment="Start" /&gt;</pre></li> <li>When the <a id="_idIndexMarker1072"/>user taps or clicks anywhere in <code>Frame</code>, <code>Command</code> should be run. To configure that, we will use <code>GestureRecognizer</code>. <code>GestureRecognizer</code> is XAML’s way of providing event handlers. There are several different kinds of <code>GestureRecognizer</code>:<ul><li><code>DragGestureRecognizer</code> and <code>DropGestureRecognizer</code></li><li><code>PanGestureRecognizer</code></li><li><code>PinchGestureRecognizer</code></li><li><code>PointerGestureRecognizer</code></li><li><code>SwipeGestureRecognizer</code></li><li><code>TapGestureRecognizer</code></li></ul><p class="list-inset">For <code>ActivityButton</code>, we are interested in <code>TapGestureRecognizer</code>. Since the action to take is undefined until this control is used on a view, <code>TapGestureRecognizer</code> will invoke a command when <code>Frame</code> is tapped. Add the following XAML to the <code>Frame</code> element to create <code>TapGestureRecognizer</code>:</p><pre class="source-code">
&lt;Frame.GestureRecognizers&gt;
    &lt;TapGestureRecognizer Command="{Binding Source={x:Reference this},Path=Command}" CommandParameter="{Binding Source={x:Reference this},Path=CommandParameter}" /&gt;
&lt;/Frame.GestureRecognizers&gt;</pre><p class="list-inset">The <code>Command</code> attribute and the <code>CommandParameter</code> attribute of <code>TapGestureRecognizer</code> are set to bind to the parent controls’ <code>Command</code> and <code>CommandParameter</code> properties.</p><p class="list-inset">If the <code>IsRunning</code> property is <code>true</code>, then <code>Frame</code> should be disabled, and the reverse is true as well. <code>DataTrigger</code> is a XAML way of setting properties of one control <a id="_idIndexMarker1073"/>based on changes in another control’s properties. To add the triggers for <code>Frame</code>, add the highlighted XAML to the control:</p><pre class="source-code">&lt;Frame.Triggers&gt;
    &lt;DataTrigger TargetType="Frame" Binding="{Binding Source={x:Reference this},Path=IsBusy}" Value="True"&gt;
        &lt;Setter Property="IsEnabled" Value="False" /&gt;
    &lt;/DataTrigger&gt;
    &lt;DataTrigger TargetType="Frame" Binding="{Binding Source={x:Reference this},Path=IsBusy}" Value="False"&gt;
        &lt;Setter Property="IsEnabled" Value="True" /&gt;
    &lt;/DataTrigger&gt;
&lt;/Frame.Triggers&gt;</pre></li> <li>That concludes the XAML portion of the control. Open the <code>ActivityButton.xaml.cs</code> file and we can add the missing properties, starting with <code>CommandParameter</code>:<pre class="source-code">
public static readonly BindableProperty CommandParameterProperty = BindableProperty.Create(
    propertyName: nameof(CommandParameter),
    returnType: typeof(object),
    declaringType: typeof(ActivityButton),
    defaultBindingMode: BindingMode.TwoWay);
public object CommandParameter
{
    get =&gt; GetValue(CommandParameterProperty);
    set { SetValue(CommandParameterProperty, value); }
}</pre><p class="list-inset">Add the previous code listing to the <code>ActivityButton</code> class. Other than the name, there isn’t anything significant about this property from the <code>Command</code> property. <code>CommandParameter</code> allows you to specify parameters to pass to <code>Command</code>, but using XAML.</p></li> <li>The <code>Label</code> <a id="_idIndexMarker1074"/>control is populated from the <code>Text</code> property. To add the <code>Text</code> property, add the following code to the <code>ActivityButton</code> class:<pre class="source-code">
public static readonly BindableProperty TextProperty = BindableProperty.Create(
    propertyName: nameof(Text),
    returnType: typeof(string),
    declaringType: typeof(ActivityButton),
    defaultValue: string.Empty,
    defaultBindingMode: BindingMode.TwoWay);
public string Text
{
    get =&gt; (string)GetValue(TextProperty);
    set { SetValue(TextProperty, value); }
}</pre><p class="list-inset">In the case of the <code>Text</code> property, <code>returnType</code> has changed to <code>string</code>, but otherwise, it’s similar to <code>Command</code> and <code>CommandParameter</code>.</p></li> <li>The next property we need to implement is the <code>IsRunning</code> property, as follows:<pre class="source-code">
public static readonly BindableProperty IsRunningProperty = BindableProperty.Create(
    propertyName: nameof(IsRunning),
    returnType: typeof(bool),
    declaringType: typeof(ActivityButton),
    defaultValue: false);
public bool IsRunning
{
    get =&gt; (bool)GetValue(IsRunningProperty);
    set { SetValue(IsRunningProperty, value); }
}</pre></li> <li>To allow <a id="_idIndexMarker1075"/>the size and font of the text to be changed, we implement the <code>FontSize</code> and <code>FontFamily</code> properties:<pre class="source-code">
public static readonly BindableProperty FontFamilyProperty = BindableProperty.Create(
    propertyName: nameof(FontFamily),
    returnType: typeof(string),
    declaringType: typeof(ActivityButton),
    defaultValue: string.Empty,
    defaultBindingMode: BindingMode.TwoWay);
public string FontFamily
{
    get =&gt; (string)GetValue(Label.FontFamilyProperty);
    set { SetValue(Label.FontFamilyProperty, value); }
}
public static readonly BindableProperty FontSizeProperty = BindableProperty.Create(
    nameof(FontSize),
    typeof(double),
    typeof(ActivityButton),
    Device.GetNamedSize(NamedSize.Small, typeof(Label)),
    BindingMode.TwoWay);
public double FontSize
{
    set { SetValue(FontSizeProperty, value); }
    get { return (double)GetValue(FontSizeProperty); }
}</pre></li> </ol>
<p>That <a id="_idIndexMarker1076"/>completed <code>ActivityButton</code>. We will use <code>ActivityButton</code> in the <em class="italic">Creating the Connect view</em> section right after we create the images we need for the game.</p>
<h4>Creating images using Bing Image Creator</h4>
<p>There <a id="_idIndexMarker1077"/>are a few images that are used in the game. They are as follows:</p>
<ul>
<li>A horizontal stick</li>
<li>A vertical stick</li>
<li>A pile of stones</li>
</ul>
<p>Creating these images can be quite time-consuming and, based on your artistic abilities, not quite what you expected. It is quite possible that for your app you may opt to hire a graphics <a id="_idIndexMarker1078"/>designer or artist to create your digital assets for you. Recently, a new option has become available, and that is to <a id="_idIndexMarker1079"/>use AI to generate images. In this section, we will look at how to use <strong class="bold">Bing Image Creator</strong> to create the images that are needed for the game.</p>
<p>Bing Image Creator uses an English description of the scene that you would like to see and attempts to create it. There are a few keywords that you can use to direct the Image Creator in the artistic style of the image to create, such as <em class="italic">game art</em>, <em class="italic">digital art</em>, or <em class="italic">photorealistic</em>.</p>
<p>Let’s get started by creating the stick image:</p>
<ol>
<li>Open <a href="https://bing.com/create">https://bing.com/create</a> in Microsoft Edge or your favorite web browser.</li>
<li>If asked, log in with your Microsoft account. This can be the same account that you used in <em class="italic">Chapter 9</em> to log in to the Azure portal.</li>
<li>In the prompt box, type in the following prompt, then press <strong class="bold">Create</strong>:<pre class="source-code">
A single wood stick, positioned horizontally, with five stubs where branches would be and no leaves, no background, game art</pre><p class="list-inset">Image Creator will generate four different images based on your description. If you aren’t satisfied with the result, adjust the description slightly and try again. The more descriptive you are, the better your result. Try to get a stick that is nearly vertical or horizontal since it will be easier to rotate and crop the image. It will also look much better if it is on a bright white background.</p></li> </ol>
<div><div><img alt="Figure 10.7 – An Image Creator sample set of images" src="img/B19214_10_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – An Image Creator sample set of images</p>
<ol>
<li value="4">Once <a id="_idIndexMarker1080"/>you have an image you are satisfied with, click on the image to open it up.</li>
<li>Click the <strong class="bold">Download</strong> button to save the image to your local computer.</li>
<li>Now, open the downloaded file in your favorite image editor. The images created by Image Creator are roughly 1024 x 1024, and ideally, the image should be a 3:9 ratio, or around 300 x 900 pixels. Using your image editor tools, crop the image so that it is roughly 300 x 900 pixels.</li>
<li>Save the image as either <code>hstick.jpeg</code> if the stick is orientated horizontally, or <code>vstick.jpeg</code> if vertically, in the <code>Resources/Images</code> folder of the <code>SticksAndStones.App</code> project.</li>
<li>Using the same image editing tools, rotate the image 90 degrees so that it is the opposite orientation and save the image in the <code>Resources/</code><code>I</code><code>mages</code> folder as <code>hstick.jpeg</code> if the stick is now orientated horizontally, or <code>vstick.jpeg</code> if vertically.</li>
</ol>
<p>We <a id="_idIndexMarker1081"/>have nearly half of the images that we need to create. Let’s work on creating the stones next:</p>
<ol>
<li>Open <a href="https://bing.com/create">https://bing.com/create</a> in Microsoft Edge or your favorite web browser.</li>
<li>If asked, log in with your Microsoft account. This can be the same account that you used in <em class="italic">Chapter 9</em> to log in to the Azure portal.</li>
<li>In the prompt box, type in the following prompt, then press <strong class="bold">Create</strong>:<pre class="source-code">
3 grey stones, arranged closely together, no background, game art</pre></li> <li>Work the prompt to get three stones nicely piled together, preferably on a white background, as shown here:</li>
</ol>
<div><div><img alt="Figure 10.8 – Three stones on a white background" src="img/B19214_10_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Three stones on a white background</p>
<ol>
<li value="5">When <a id="_idIndexMarker1082"/>you are satisfied with the generated image, click the image to open it.</li>
<li>Click the <strong class="bold">Download</strong> button to save the image to your local computer.</li>
<li>Now, open the downloaded file in your favorite image editor. Since the stones are supposed to be a square image, we can just save the file into the <code>Resources/Images</code> folder as <code>stones.jpeg</code>.</li>
</ol>
<p class="callout-heading">Don’t have an image editor?</p>
<p class="callout">Don’t have a favorite image editor? If you are on Windows, Paint does the job nicely, or you can use Visual Studio to edit images. On macOS, you can use Preview.</p>
<p>Excellent, we now have the sticks and the stones needed to play the game, and that concludes <a id="_idIndexMarker1083"/>the use of Image Creator to generate our game’s images. You can always go back to the site and review previous results, which is a nice feature. Now, we can move forward with creating the <code>Connect</code> view.</p>
<h4>Creating the Connect view</h4>
<p>The <code>Connect</code> view is the first UI other than the splash screen the user is going to see in the app. <em class="italic">Figure 10</em><em class="italic">.6</em> provides a representation of what the final view will look like. The images may be different if you decide to generate your own of course. We will break this section <a id="_idIndexMarker1084"/>into three parts. First, we will create the top portion of the view containing the static content, then move on to creating the middle portion of the view containing the entry controls, and then, finally, the <strong class="bold">Connect</strong> button. Let’s get started with the top section of the view by following these steps:</p>
<ol>
<li>In the <code>SticksAndStones.App</code> project, create a folder named <code>Views</code>.</li>
<li>Right-click on the <code>Views</code> folder, select <strong class="bold">Add</strong>, and then click <strong class="bold">New Item...</strong>.<p class="list-inset">If you are using Visual Studio 17.7 or later, click the <strong class="bold">Show </strong><strong class="bold">All</strong><strong class="bold"> Templates</strong> button in the dialog that pops up; otherwise, move to the next step.</p></li>
<li>Under the <strong class="bold">C# Items</strong> node on the left, select <strong class="bold">.</strong><strong class="bold">NET MAUI</strong>.</li>
<li>Selec<a id="_idTextAnchor888"/>t <code>ConnectView.xaml</code>.</li>
<li>Click <strong class="bold">Add</strong> to create the page.<p class="list-inset">Refer to the following screenshot to view the preceding information:</p></li>
</ol>
<div><div><img alt="Figure 10.9 – Adding a new .NET MAUI ContentPage (XAML)" src="img/B19214_10_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Adding a new .NET MAUI ContentPage (XAML)</p>
<ol>
<li value="6">Change the title of the view to <code>Sticks &amp;amp; Stones</code>. Since XAML is a dialect of XML, the ampersand (<code>&amp;</code>) must be escaped as <code>&amp;amp;</code> in the string.<p class="list-inset">Add the <a id="_idIndexMarker1085"/>following highlighted namespaces to the <code>ContentView</code> element. They will provide us access to the classes in the <code>ViewModels</code>, <code>Controls</code>, and <code>Toolkit</code> namespaces:</p><pre class="source-code">
&lt;ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
<strong class="bold">        xmlns:viewModels=</strong><strong class="bold">“</strong><strong class="bold">clr-namespace:SticksAndStones.ViewModels”</strong>
<strong class="bold">        xmlns:controls=</strong><strong class="bold">“</strong><strong class="bold">clr-namespace:SticksAndStones.Controls”</strong>
<strong class="bold">              xmlns:toolkit=</strong><strong class="bold">“</strong><strong class="bold">http://schemas.microsoft.com/dotnet/2022/maui/toolkit”</strong>
             x:Class=“SticksAndStones.Views.ConnectView”
             Title=“Sticks and Stones”&gt;</pre></li> <li>To make <a id="_idIndexMarker1086"/>IntelliSense happy with the bindings we will be adding, define the view model that the view is using by adding the <code>x:DataType</code> attribute to the <code>ContentView</code> element, as shown:<pre class="source-code">
&lt;ContentPage  xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
        xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
        xmlns:controls=“clr-namespace:SticksAndStones.Controls”
             xmlns:toolkit=“http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
             x:Class=“SticksAndStones.Views.ConnectView”
        <strong class="bold">x:DataType=</strong><strong class="bold">“</strong><strong class="bold">viewModels:ConnectViewModel”</strong>
        Title=“Sticks and Stones”&gt;</pre></li> <li>We don’t want the user to use any navigation, such as the <code>Shell</code>-provided <code>Back</code> button, other than what is provided on this page, so disable it using the highlighted code in the following listing:<pre class="source-code">
&lt;ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
        xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
        xmlns:controls=“clr-namespace:SticksAndStones.Controls”
             xmlns:toolkit=“http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
             x:Class=“SticksAndStones.Views.ConnectView”
        x:DataType=“viewModels:ConnectViewModel”
        Title=“Sticks and Stones”
        <code>BackgroundColor</code> of the entire view to <code>White</code>, which will make the images <a id="_idIndexMarker1087"/>blend better, by adding the following highlighted code:<pre class="source-code">
&lt;ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
        xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
        xmlns:controls=“clr-namespace:SticksAndStones.Controls”
             xmlns:toolkit=“http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
             x:Class=“SticksAndStones.Views.ConnectView”
        x:DataType=“viewModels:ConnectViewModel”
        Title=“Sticks &amp;amp; Stones”
        NavigationPage.HasNavigationBar=“False”
        <code>Grid</code> control that has four rows defined; add the following code within the <code>ContentPage</code> element:<pre class="source-code">
&lt;Grid Margin=“40”&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height=“8*”/&gt;
        &lt;RowDefinition Height=“2*”/&gt;
        &lt;RowDefinition Height=“8*”/&gt;
        &lt;RowDefinition Height=“1*”/&gt;
    &lt;/Grid.RowDefinitions&gt;
&lt;/Grid&gt;</pre><p class="list-inset"><code>Grid</code> uses a <code>Margin</code> value of <code>40</code> to provide plenty of whitespace around the images and controls. The first row at <code>8</code> units will contain the logo for the app. The second row will contain the text <code>Sticks &amp; Stones</code>. The third row will have the avatar image, email, and gamer tag entry controls. The final row will contain the <code>Connect</code> button.</p><p class="list-inset">Recall that the <code>Height</code> units are relative, so row <code>0</code>, the first row, will be four times higher than row <code>1</code> and eight times higher than row <code>3</code>, the final row. The <code>*</code> symbol in the <code>Height</code> value indicates that the row can expand if needed.</p></li> <li>To arrange our generated images into a box-like layout, another <code>Grid</code> control is used. Add the following listing to the view between the <code>&lt;/Grid.RowDefinitions&gt;</code> and <code>&lt;/</code><code>Grid&gt;</code> tags:<pre class="source-code">
&lt;Grid Grid.Row=“0” WidthRequest=“150” HeightRequest=“150”&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width=“1*” /&gt;
        &lt;ColumnDefinition Width=“5*” /&gt;
        &lt;ColumnDefinition Width=“1*” /&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height=“1*” /&gt;
        &lt;RowDefinition Height=“4*” /&gt;
        &lt;RowDefinition Height=“1*” /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Image Grid.Row=“0” Grid.Column=“1” Source=“hstick.jpeg” Aspect=“Fill”/&gt;
    &lt;Image Grid.Row=“1” Grid.Column=“0” Source=“vstick.jpeg” Aspect=“Fill”/&gt;
    &lt;Image Grid.Row=“1” Grid.Column=“1” Source=“stones.jpeg” Aspect=“AspectFit”/&gt;
    &lt;Image Grid.Row=“1” Grid.Column=“2” Source=“vstick.jpeg” Aspect=“Fill”/&gt;
    &lt;Image Grid.Row=“2” Grid.Column=“1” Source=“hstick.jpeg” Aspect=“Fill”/&gt;
&lt;/Grid&gt;</pre><p class="list-inset">This <code>Grid</code> control defines three rows and three columns. The content of <code>Grid</code> is entirely <a id="_idIndexMarker1089"/>made up of <code>Image</code> controls. <code>Grid</code> is positioned in row <code>0</code> of its parent <code>Grid</code>. The children of the grid, the <code>Image</code> controls, are positioned by setting the <code>Grid.Row</code> and <code>Grid.Column</code> attributes on the <code>Image</code> control. The stick images use the <code>Aspect</code> attribute set to <code>Fill</code>. <code>Fill</code> allows the image to scale to completely fill the content area; to do so, it may not scale uniformly along both the <em class="italic">x</em> and <em class="italic">y</em> axis. The stones use an <code>Aspect</code> value of <code>AspectFit</code>. This will uniformly scale the image till at least one side fits, which may cause letterboxing. There are two more options for the <code>Aspect</code> property: <code>Center</code>, which does no scaling, and <code>AspectFill</code>, which will scale until both axes have filled the view, which may cause clipping.</p></li> <li><code>A Label</code> element containing the text <code>Connect to Sticks &amp; Stones</code> is added to the outer <code>Grid</code> control and it’s placed in row <code>1</code>, which is the second row of <code>Grid</code>. Add the following code to the outer <code>Grid</code> control after the inner <code>Grid</code> control added in <em class="italic">step 11</em>:<pre class="source-code">
&lt;Label Grid.Row="1" Text="Connect to Sticks &amp;amp; Stones" FontSize="20" TextColor="Black" FontAttributes="Bold" Margin="0,0,0,20" HorizontalOptions="Center"/&gt;</pre></li> <li>The next <a id="_idIndexMarker1090"/>section of the page contains the avatar image, gamer tag entry, and email entry controls. <code>HorizontalStackLayout</code> and <code>VerticalStackLayout</code> controls are used to arrange the controls. Add the following snippet to the outer <code>Grid</code> control after the <code>Label</code> control added in <em class="italic">step 12</em>:<pre class="source-code">
&lt;HorizontalStackLayout Grid.Row="2" HorizontalOptions="Center"&gt;
    &lt;VerticalStackLayout Spacing="10" &gt; 
        &lt;Image HeightRequest="96" WidthRequest="96" BackgroundColor="LightGrey"&gt;
            &lt;Image.Source&gt;
                &lt;toolkit:GravatarImageSource
                    Email="{Binding EmailAddress}"
                    Image="MysteryPerson" /&gt;
            &lt;/Image.Source&gt;
        &lt;/Image&gt;
    &lt;/VerticalStackLayout&gt;
    &lt;VerticalStackLayout Spacing="10" &gt;
        &lt;Entry Placeholder="username" Keyboard="Email" Text="{Binding Username}" HorizontalTextAlignment="Start" HorizontalOptions="FillAndExpand"/&gt;
        &lt;Entry Placeholder="user@someaddress.com" Keyboard="Email" Text="{Binding EmailAddress}" HorizontalTextAlignment="Start" HorizontalOptions="FillAndExpand"/&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/HorizontalStackLayout&gt;</pre><p class="list-inset">The <code>HorizontalStackLayout</code> control is assigned to the <code>Grid</code> row <code>2</code>, the third row. It is also <a id="_idIndexMarker1091"/>centered horizontally within the row. The first <code>VerticalStackLayout</code> arranges the controls that make up the <a id="_idIndexMarker1092"/>avatar. It contains an <code>Image</code> element, whose source is set to an instance of <code>GravatarImageSource</code>. <code>GravatarImageSource</code> uses the <code>EmailAddress</code> property of <code>ConnectViewModel</code> is bound to the <code>Email</code> property of <code>GravatarImageSource</code>. The image will automatically update on changes to <code>EmailAddress</code>. The <code>Image</code> property uses the <code>MysteryPerson</code> value to provide a plain profile when there isn’t a Gravatar available for the email address. The second <code>VerticalStackLayout</code> contains two <code>Entry</code> controls: the first, for the gamer tag, is bound to the <code>Username</code> property of <code>ConnectViewModel</code>, and the second is bound to the <code>EmailAddress</code> property of <code>ConnectViewModel</code>. The <code>Keyboard</code> attribute determines which virtual keyboard is displayed when the focus is on the control. See <a href="https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/entry#customize-the-keyboard">https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/entry#customize-the-keyboard</a> for more information on customizing the keyboard.</p></li> <li>The final control to add to <code>ConnectView</code> is the <code>Connect</code> button. Use the following snippet to add the button to the view:<pre class="source-code">
&lt;controls:ActivityButton Grid.Row="3" 
                         IsRunning="{Binding IsConnecting}" 
                         Text="{Binding ConnectStatus}" 
                         BackgroundColor="#e8bc65" 
                         Command="{Binding ConnectCommand}" 
                         HorizontalOptions="Center" 
                         WidthRequest="200" 
                         HeightRequest="48"/&gt;</pre><p class="list-inset">The <code>Connect</code> button <a id="_idIndexMarker1093"/>uses the <code>ActivityButton</code> control created in the <em class="italic">Creating the ActivityButton control</em>. The control is positioned in row <code>3</code>, the fourth row, and the <code>IsRunning</code> attribute is bound to the <code>ConnectViewModel.IsConnecting</code> method. The <code>Text</code> attribute of the button is bound to the <code>ConnectViewModel.ConnectStatus</code> property, and finally, <code>Command</code> is bound to the <code>ConnectViewModel.Connect</code> method.</p></li> <li>Open the <code>MauiProgram.cs</code> file in the <code>SticksAndStones.App</code> project and add the following highlighted line to register <code>ConnectView</code> with dependency injection:<pre class="source-code">
builder.Services.AddSingleton&lt;Services.GameService&gt;();
builder.Services.AddTransient&lt;ViewModels.ConnectViewModel&gt;();
<strong class="bold">builder.Services.AddTransient&lt;Views.ConnectView&gt;();</strong>
return builder.Build();</pre></li> <li>Now, we need to consume the <code>ConnectViewModel</code> instance through dependency <a id="_idIndexMarker1094"/>injection and set it as the binding object. Open the <code>ConnectView.Xaml.cs</code> file and modify it as follows:<pre class="source-code">
<strong class="bold">using SticksAndStones.ViewModels;</strong>
namespace SticksAndStones.Views;
public partial class ConnectView : ContentPage
{
    public ConnectView(<strong class="bold">ConnectViewModel viewModel</strong>)
    {
        <strong class="bold">this.BindingContext = viewModel;</strong>
        InitializeComponent();
    }
}</pre></li> <li>Finally, we need to set <code>ConnectView</code> as the first view displayed. Open the <code>AppShell.xaml</code> file in the <code>SticksAndStones.App</code> project and update the contents of the <code>Shell</code> element as shown:<pre class="source-code">
&lt;Shell
    x:Class="SticksAndStones.App.AppShell"
    
    
    
    <strong class="bold"></strong>
    Shell.FlyoutBehavior="Disabled"&gt;
    &lt;ShellItem Route="Connect"&gt;
        &lt;ShellContent ContentTemplate="{DataTemplate views:ConnectView}" /&gt;
    &lt;/ShellItem&gt;
&lt;/Shell&gt;</pre></li> </ol>
<p>The first <a id="_idIndexMarker1095"/>of the three views in the app is complete. To test it out, follow these steps:</p>
<ol>
<li>In Visual Studio, right-click the <code>SticksAndStones.Functions</code> project in <strong class="bold">Solution Explorer</strong>, then select <strong class="bold">Debug</strong> | <strong class="bold">Start </strong><strong class="bold">Without Debugging</strong>.</li>
<li>In <code>SticksAndStones.App</code> project and select <strong class="bold">Set as </strong><strong class="bold">Startup Project</strong>.</li>
<li>Press <em class="italic">F5</em> to start the <code>SticksAndStones.App</code> project using the debugger.</li>
</ol>
<p>The <code>Lobby</code> page, which will allow us to start games with other players.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor889"/>Creating the Lobby page</h2>
<p>The <code>Lobby</code> page displays the list of connected players and allows a player to challenge another to <a id="_idIndexMarker1096"/>a match. As additional players connect to the server, they are added to the list of available players. <em class="italic">Figure 10</em><em class="italic">.10</em> shows the two views for the page, one with connected players, and the empty view when there are no additional players connected.</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 10.10 – The Lobby views" src="img/B19214_10_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – The Lobby views</p>
<p>Each player is displayed on a card with their avatar image, gamer tag, status, and a button to allow the player to challenge the other to a match.</p>
<p>This page is comprised of two <code>ViewModel</code> classes, not one. As you might expect, there is the <code>LobbyViewModel</code> class, the <code>LobbyViewModel</code> which class has a collection of <code>PlayerViewModel</code> instances. In addition to the <code>ViewModel</code> classes, there is the <code>LobbyView</code> class. Let’s get started by creating the <code>PlayerViewModel</code> class.</p>
<h3>Adding PlayerViewModel</h3>
<p><code>PlayerViewModel</code> is very much like all our other <code>ViewModel</code> classes but with one slight <a id="_idIndexMarker1097"/>difference: it isn’t bound directly to a view in the same way. Otherwise, it has the same purpose: abstract the model, in this case, <code>Player</code>, away from the UI that displays it. <code>PlayerViewModel</code> provides all the needed binding properties to display each individual player card in <code>LobbyView</code>. To add <code>PlayerViewModel</code>, follow these steps:</p>
<ol>
<li>In the <code>SticksAndStones.App</code> project, under the <code>ViewModels</code> folder, create a new class named <code>PlayerViewModel</code>.</li>
<li>Add the following namespaces to the top of the file:<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SticksAndStones.Models;
using SticksAndStones.Services;</pre></li> <li>Add the following code to the class:<pre class="source-code">
private readonly Player playerModel;
private readonly GameService gameService;
public PlayerViewModel(Player player, GameService gameService)
{
    playerModel = player;
    this.gameService = gameService;
}</pre><p class="list-inset">This adds two <code>private</code> fields to hold the values of the arguments passed to the constructor. As with <code>ConnectViewModel</code>, the constructor arguments are provided by dependency injection. </p></li> <li>The player card displays the player’s gamer tag, avatar, and status. Add the following code to the <code>PlayerViewModel</code> class to add the <code>Id</code> and <code>GamerTag</code> properties:<pre class="source-code">
public Guid Id =&gt; playermodel.Id;
public string GamerTag =&gt; playerModel.GamerTag;</pre><p class="list-inset">For <code>PlayerViewModel</code>, some of the properties that we bind to are not implemented with <code>ObservablePropertyAttribute</code>. That is because we are providing their values from the <code>Player</code> model directly. So, the <code>get</code> method <a id="_idIndexMarker1098"/>of the property just returns the corresponding property of the model object. There is no defined <code>set</code> method, so this property is essentially a one-way data binding.</p></li> <li>The <code>Status</code> property is a little different since it does not exist on our <code>Player</code> model. The <code>Status</code> property is a textual indication of whether the player is in a match or not. The <code>Player</code> model does have a <code>MatchId</code> property, so if the <code>Player</code> model has a valid <code>MatchId</code> (i.e., not <code>Guid.Empty</code>), then the status would be <code>"In a match"</code>; otherwise, that status would be <code>"Waiting for opponent"</code>. Add the following code to <code>PlayerViewModel</code> to implement the <code>Status</code> property:<pre class="source-code">
public bool IsInMatch =&gt; !(playerModel.MatchId == Guid.Empty);
public string Status =&gt; IsInMatch switch
{
    true =&gt; "In a match",
    false =&gt; "Waiting for opponent"
};</pre><p class="list-inset">The <code>IsInMatch</code> property is used to simplify the <code>Status</code> property implementation. It will also be used later in the class. The <code>Status</code> property is a simple switch on <code>IsInMatch</code> and returns the proper <code>string</code> value.</p></li> <li>To add <a id="_idIndexMarker1099"/>a command to handle the <code>Challenge</code> button, add the following code to the <code>PlayerViewModel</code> class:<pre class="source-code">
[ObservableProperty]
[NotifyPropertyChangedFor(nameof(ChallengeStatus))]
private bool isChallenging = false;
public string ChallengeStatus =&gt; IsChallenging switch
{
    true =&gt; "Challenging...",
    false =&gt; "Challenge"
};
public bool CanChallenge =&gt; !IsInMatch &amp;&amp; !IsChallenging;
[RelayCommand(CanExecute = nameof(CanChallenge))]
public void Challenge(PlayerViewModel opponent)
{
    MainThread.BeginInvokeOnMainThread(async () =&gt;
    {
        IsChallenging = true;
        bool answer = await Shell.Current.CurrentPage.DisplayAlert("Issue Challenge!", $" You are about to challenge {GamerTag} to a match!\nAre you sure?", "Yes", "No");
        if (answer)
        {
            await gameService.IssueChallenge(opponent.Player);
        }
        IsChallenging = false;
    });
    return;
}</pre><p class="list-inset">The command is prevented from executing while it is currently waiting for a challenge response, which makes sense – no need to nag the other player. The <code>IsChallenging</code> property is set to <code>true</code> while challenging and <code>false</code> when it is complete. The <code>CanChallenge</code> property is a combination of <code>IsInMatch</code> and <code>IsChallenging</code>, meaning that you can’t challenge the same player while you have an existing challenge in progress, and you can’t challenge a player who is already in a match with another player. <code>ChallengeStatus</code>, which is used as the text for the button, is bound to the <code>IsChallenging</code> value and updates when that property is updated. You may have noticed that our command takes a single parameter. This is used to operate on the correct player. </p></li> </ol>
<p>That <a id="_idIndexMarker1100"/>completes <code>PlayerViewModel</code>. Next, <code>LobbyViewModel</code> is used to encapsulate the collection of <code>PlayerViewModel</code> objects.</p>
<h3>Adding LobbyViewModel</h3>
<p><code>LobbyViewModel</code> is a <a id="_idIndexMarker1101"/>fairly straightforward implementation. It has a collection of <code>PlayerViewModel</code> objects that are exposed to the UI, it allows the user to pull to refresh the view, and it handles the messages of <code>ChallengeReceived</code>, <code>MatchStarted</code>, and <code>ServiceError</code>. Follow these steps to implement <code>LobbyViewModel</code>:</p>
<ol>
<li>In the <code>SticksAndStones.App</code> project, inside the <code>ViewModels</code> folder, create a new class named <code>LobbyViewModel</code>.</li>
<li>Add the following namespaces to the top of the file:<pre class="source-code">
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using CommunityToolkit.Mvvm.Messaging;
using SticksAndStones.Messages;
using SticksAndStones.Models;
using SticksAndStones.Services;</pre></li> <li>Modify <a id="_idIndexMarker1102"/>the class declaration to a <code>public partial</code> class that inherits from <code>ViewModelBase</code>, as shown:<pre class="source-code">
<code>LobbyViewModel</code> class:<pre class="source-code">
private readonly GameService gameService;
public ObservableCollection&lt;PlayerViewModel&gt; Players { get; init; }
public LobbyViewModel(GameService gameService)
{
    this.gameService = gameService;
    Players = new(from p in gameService.Players
                  where p.Id != gameService.CurrentPlayer.Id
                  select new PlayerViewModel(p, gameService));
    CanRefresh = true;
    IsActive = true;
}</pre><p class="list-inset"><code>LobbyViewModel</code> receives an instance of <code>GameService</code> via dependency injection. The <code>gameService</code> instance is used to initialize the <code>Players</code> list. The <code>Players</code> property from the <code>GameService</code> class is a collection of the <code>Player</code> model, whereas <code>Players</code> in <code>LobbyViewModel</code> is an <code>ObservableCollection</code> <code>instance</code> of <code>PlayerViewModel</code>. We use <code>ObservableCollection</code> because it provides support for <code>INotifyPropertyChanged</code> and <code>INotifyCollectionChanged</code> when it is <a id="_idIndexMarker1103"/>bound automatically. A LINQ query is used to get all the current players and add them to the <code>Players</code> <code>ObservableCollection</code>. <code>CanRefresh</code> from <code>ViewModelBase</code> is set to <code>true</code>, which enables <code>RefreshCommand</code>. Finally, <code>IsActive</code> is set to <code>true</code>, which enables the <code>OnActivated</code> and <code>OnDeactivated</code> events.</p></li> <li>The <code>GameService.Players</code> list will be updated as players connect to the server. However, these changes do not get propagated to the <code>LobbyViewModel.Players</code> collection automatically. By implementing a handler for the <code>CollectionChanged</code> event of the <code>GameService.Players</code> property, we can then update the <code>LobbyViewModel.Players</code> collection appropriately. Add the following method to the <code>LobbyViewModel</code> class:<pre class="source-code">
private void OnPlayersCollectionChanged(object? sender, 
NotifyCollectionChangedEventArgs e)
{
    if (e.Action == NotifyCollectionChangedAction.Add)
    {
        foreach (var player in e.NewItems.Cast&lt;Player&gt;())
        {
            Players.Add(new PlayerViewModel(player, gameService));
        }
    }
    else if (e.Action == NotifyCollectionChangedAction.Remove)
    {
        foreach (var player in e.OldItems.Cast&lt;Player&gt;())
        {
            var toRemove = Players.FirstOrDefault(p =&gt; p.Id == player.Id);
            Players.Remove(toRemove);
        }
    }
    else if (e.Action == NotifyCollectionChangedAction.Replace)
    {
    }
    else if (e.Action == NotifyCollectionChangedAction.Reset)
    {
        Players.Clear();
    }
}</pre><p class="list-inset">The <code>OnPlayersCollectionChanged</code> method is an implementation of <code>Notify</code><strong class="source-inline">
CollectionChangedEventHandler</strong>. It is called by the <code>Observable</code><strong class="source-inline">
Collection.CollectionChanged</strong> event. The event is called <a id="_idIndexMarker1104"/>whenever an item in the collection is added, removed, or updated. It is also called when the entire collection is cleared. This method handled the <code>NotifyCollectionChangedAction</code> values of <code>Add</code>, <code>Remove</code>, and <code>Reset</code>.</p></li> <li>The <code>Players.CollectionChanged</code> event is assigned to the <code>OnPlayers</code><strong class="source-inline">
CollectionChanged</strong> method in the <code>OnActivated</code> event handler. Add the <code>OnActivated</code> and <code>OnDeactivated</code> methods using the following listing:<pre class="source-code">
protected override void OnActivated()
{
    gameService.Players.CollectionChanged += OnPlayersCollectionChanged;
    // If the player has an in progress match, take them to it.
    if (gameService.CurrentPlayer?.MatchId != Guid.Empty)
    {
        MainThread.InvokeOnMainThreadAsync(async () =&gt;
        {
            IsActive = false;
            await Shell.Current.GoToAsync(Constants.ArgumentNames.MatchId, new Dictionary&lt;string, object&gt;() { { "MatchId", gameService.CurrentPlayer.MatchId } });
        });
    }
}
protected override void OnDeactivated()
{
    gameService.Players.CollectionChanged -= OnPlayersCollectionChanged;
}</pre><p class="list-inset">In the <code>OnActivated</code> method, the <code>CollectionChanged</code> event is assigned to the <code>OnPlayersCollectionChanged</code> method and unassigned in the <code>OnDeactivated</code> method. In <code>OnActivated</code>, there is also a check to see whether <a id="_idIndexMarker1105"/>the player is already in a match. If they are, then the app navigates to the <code>Match</code> view immediately. When navigating to the <code>Match</code> view, we send an argument for <code>Match</code>. This will be either the <code>MatchId</code> or the <code>Match</code> model.</p></li> <li>Open the <code>Constants.cs</code> file in the <code>SticksAndStones.Shared</code> project to add the following code snippet to the <code>Constants</code> class:<pre class="source-code">
public class ArgumentNames
{
    public static readonly string Match = nameof(Match);
    public static readonly string MatchId = nameof(MatchId);
}</pre></li> <li>While <a id="_idIndexMarker1106"/>in the Lobby, there are three messages that need to be handled: <code>ChallengeReceived</code>, <code>MatchStarted</code>, and <code>ServerError</code>. Add the code in the following listing to add the handlers for each of these messages:<pre class="source-code">
private void OnChallengeReceived(Guid challengeId, Player opponent)
{
    MainThread.BeginInvokeOnMainThread(async () =&gt;
    {
        bool answer = await Shell.Current.CurrentPage.DisplayAlert("You have been challenged!", $"{opponent.GamerTag} has challenged you to a match of Sticks &amp; Stones, do you accept?", "Yes", "No");
        await gameService.SendChallengeResponse(challengeId, answer ? Models.ChallengeResponse.Accepted : Models.ChallengeResponse.Declined);
    });
}
private void OnMatchStarted(Match match)
{
    MainThread.BeginInvokeOnMainThread(async () =&gt;
    {
        IsActive = false;
        await Shell.Current.GoToAsync($"///Match", new Dictionary&lt;string, object&gt;() { { Constants.ArgumentNames.Match, match } });
    });
}
private void OnServiceError(AsyncError error)
{
    MainThread.BeginInvokeOnMainThread(async () =&gt;
    {
        IsActive = false;
        await Shell.Current.CurrentPage.DisplayAlert("There is a problem...",error.Message, "Ok");
    });
}</pre><p class="list-inset">In <code>OnChallengeReceived</code>, the user is prompted to accept or decline the challenge. Their response is then sent to the challenger via the <code>SendChallengeResponse</code> method of the <code>GameService</code> class. <code>OnMatchStarted</code> will navigate the user to the <code>Match</code> view. Finally, <code>OnServiceError</code> will display the error to the user.</p></li> <li>Add <a id="_idIndexMarker1107"/>the following snippet to the top of the <code>OnActivated</code> method to register to receive the messages:<pre class="source-code">
Messenger.Register&lt;ChallengeRecieved&gt;(this, (r, m) =&gt; OnChallengeReceived(m.Id, m.Value));
Messenger.Register&lt;MatchStarted&gt;(this, (r, m) =&gt; OnMatchStarted(m.Value));
Messenger.Register&lt;ServiceError&gt;(this, (r, m) =&gt; OnServiceError(m.Value));</pre></li> <li>Add the following snippet to the end of the <code>OnDecactived</code> method to stop receiving messages:<pre class="source-code">
Messenger.Unregister&lt;ChallengeRecieved&gt;(this);
Messenger.Unregister&lt;MatchStarted&gt;(this);
Messenger.Unregister&lt;ServiceError&gt;(this);</pre></li> <li>To refresh the <code>Players</code> list when the user pulls down on the list in the UI, add the <a id="_idIndexMarker1108"/>following method to the <code>LobbyViewModel</code> class:<pre class="source-code">
protected override async Task RefreshInternal()
{
    await gameService.RefreshPlayerList();
    return;
}</pre></li> <li><code>LobbyViewModel</code> needs to be registered with dependency injection, so open the <code>MauiProgram.cs</code> file and add the following highlighted line of code:<pre class="source-code">
builder.Services.AddTransient&lt;ViewModels.ConnectViewModel&gt;();
<strong class="bold">builder.Services.AddTransient&lt;ViewModels.LobbyViewModel&gt;();</strong>
builder.Services.AddTransient&lt;Views.ConnectView&gt;();</pre></li> </ol>
<p><code>LobbyViewModel</code> is now complete, and it is time to create the view!</p>
<h3>Adding the Lobby view</h3>
<p><code>The Lobby</code> view simply displays a list of connected players with their avatar, gamertag and current status. To build the <code>LobbyView</code> follow these steps:</p>
<ol>
<li>Right-click on the <code>Views</code> folder of the <code>SticksAndStone.App</code> project, select <strong class="bold">Add</strong>, and then click <strong class="bold">New Item...</strong>.<p class="list-inset">If you <a id="_idIndexMarker1109"/>are using Visual Studio 17.7 or later, click the <strong class="bold">Show all Templates</strong> button in the dialog that pops up; otherwise, move to the next step.</p></li>
<li>Under the <strong class="bold">C# Items</strong> node on the left, select <strong class="bold">.</strong><strong class="bold">NET MAUI</strong>.</li>
<li>Select <code>LobbyView.xaml</code>.</li>
<li>Click <strong class="bold">Add</strong> to create the page.<p class="list-inset">Refer to the following screenshot to view the preceding information:</p><div><img alt="" role="presentation" src="img/B19214_10_11.jpg"/></div></li>
</ol>
<p class="IMG---Figure"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Adding a new .NET MAUI ContentPage (XAML)</p>
<ol>
<li value="5">Open the <code>LobbyView.xaml.cs</code> file and add the following <code>using</code> declaration:<pre class="source-code">
using SticksAndStones.ViewModels;</pre></li> <li>Make the following highlighted changes to the constructor:<pre class="source-code">
public LobbyView(<strong class="bold">LobbyViewModel viewModel</strong>)
{
<strong class="bold">    this.BindingContext = viewModel;</strong>
    InitializeComponent();
}</pre><p class="list-inset">These <a id="_idIndexMarker1110"/>changes allow for dependency injection to supply the <code>LobbyViewModel</code> instance to the view, which is then assigned to <code>BindingContext</code>.</p></li> <li>Open the <code>AppShell.xaml</code> file and add the following code snippet to the <code>ContentPage</code> element:<pre class="source-code">
&lt;ShellItem Route="Lobby"&gt;
    &lt;ShellContent ContentTemplate="{DataTemplate views:LobbyView}" /&gt;
&lt;/ShellItem&gt;</pre><p class="list-inset">This registers the <code>"Lobby"</code> route and directs it to <code>LobbyView</code>.</p></li> <li>Open the <code>MauiProgram.cs</code> file and add the following highlighted line of code:<pre class="source-code">
builder.Services.AddTransient&lt;Views.ConnectView&gt;();
<strong class="bold">builder.Services.AddTransient&lt;Views.LobbyView&gt;();</strong>
return builder.Build();</pre><p class="list-inset">This will register <code>LobbyView</code> with dependency injection so that <code>DataTemplate</code> can locate it.</p></li> <li>Open the <code>LobbyView.xaml</code> file and change the <code>Title</code> attribute of the <code>ContentPage</code> element to <code>"Lobby"</code>.</li>
<li>Add <a id="_idIndexMarker1111"/>the following highlighted namespaces to the <code>LobbyView</code> element; they will provide us access to the classes in the <code>ViewModels</code>, <code>Controls</code>, and <code>Toolkit</code> namespaces:<pre class="source-code">
&lt;ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
<strong class="bold">        xmlns:viewModels=</strong><strong class="bold">“</strong><strong class="bold">clr-namespace:SticksAndStones.ViewModels</strong><strong class="bold">”</strong>
<strong class="bold">        xmlns:controls=</strong><strong class="bold">“</strong><strong class="bold">clr-namespace:SticksAndStones.Controls</strong><strong class="bold">”</strong>
<strong class="bold">        xmlns:toolkit=</strong><strong class="bold">“</strong> <strong class="bold">http://schemas.microsoft.com/dotnet/2022/maui/toolkit</strong><strong class="bold">”</strong>
             x:Class=“SticksAndStones.Views.LobbyView”&gt;</pre></li> <li>To make IntelliSense happy with the bindings we will be adding, define the view model that the view is using by adding the <code>x:DataType</code> attribute to the <code>LobbyView</code> element, as shown:<pre class="source-code">
&lt;ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
        xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
        xmlns:controls=“clr-namespace:SticksAndStones.Controls”
        xmlns:toolkit=“ http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
        <strong class="bold">x:DataType=</strong><strong class="bold">“</strong><strong class="bold">viewModels:LobbyViewModel</strong><strong class="bold">”</strong>
             x:Class=“SticksAndStones.Views.LobbyView”&gt;</pre></li> <li>We <a id="_idIndexMarker1112"/>don’t want the user to use any navigation, such as the <code>Shell</code>-provided <code>Back</code> button, other than what is provided on this page, so disable it using the highlighted code in the following listing:<pre class="source-code">
&lt;ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
        xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
        xmlns:controls=“clr-namespace:SticksAndStones.Controls”
        xmlns:toolkit=“ http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
        x:Class=“SticksAndStones.Views.LobbyView”
        x:DataType=“viewModels:LobbyViewModel”
        <code>BackgroundColor</code> value of the entire view to <code>White</code>, which will make the images blend better, by adding the following highlighted code:<pre class="source-code">
&lt;ContentPage xmlns=“http://schemas.microsoft.com/dotnet/2021/maui”
              xmlns:x=“http://schemas.microsoft.com/winfx/2009/xaml”
        xmlns:viewModels=“clr-namespace:SticksAndStones.ViewModels”
        xmlns:controls=“clr-namespace:SticksAndStones.Controls”
        xmlns:toolkit=“ http://schemas.microsoft.com/dotnet/2022/maui/toolkit”
             x:Class=“SticksAndStones.Views.ConnectView”
        x:DataType=“viewModels:ConnectViewModel”
        Title=“ConnectView”
        NavigationPage.HasNavigationBar=“False”
        <code>ContentPage</code> with the following code snippet:<pre class="source-code">
&lt;RefreshView IsRefreshing=“{Binding IsRefreshing}” Command=“{Binding RefreshCommand}”&gt;
    &lt;ScrollView Padding=“5”&gt;
        &lt;CollectionView ItemsSource=“{Binding Players}” Margin=”5,5,5,0 SelectionMode=“None”&gt;
        &lt;/CollectionView&gt;
    &lt;/ScrollView&gt;
&lt;/RefreshView&gt;</pre><p class="list-inset">For <code>LobbyView</code>, there is a vertical scrolling list of players. The root element is <code>RefreshView</code>. Its <code>IsRefreshing</code> attribute is bound to the <code>IsRefreshing</code> property of <code>LobbyViewModel</code>. <code>The</code> <code>Command</code> attribute for <code>RefreshView</code> is bound to <code>RefreshCommand</code>, which will end up executing the <code>RefreshInternal</code> method of <code>LobbyViewModel</code>. <code>IsRefreshing</code> and <code>RefreshCommand</code> are implemented in the <code>BaseViewModel</code> class. Inside <code>RefreshView</code> is <code>ScrollView</code>, which provides scrolling capability to have a large list. Inside <code>ScrollView</code> is <code>CollectionView</code>, which will display each <code>Player</code> instance as an individual item, so <code>ItemsSource</code> is bound to the <code>Players</code> property of <code>LobbyViewModel</code>. As there is no real need to select individual <code>Player</code> items, <code>SelectionMode</code> is set to <code>none</code>.</p></li> <li>When the list is empty, it is nice to display something to the user so that they aren’t left wondering what happened. <code>CollectionView</code> has an <code>EmptyView</code> property <a id="_idIndexMarker1114"/>that is used to configure what is displayed when there are no items. Add the following code snippet immediately following the <code>ContentPage</code> start opening tag:<pre class="source-code">
&lt;ContentPage.Resources&gt;
    &lt;ContentView x:Key="BasicEmptyView"&gt;
        &lt;StackLayout&gt;
            &lt;Label Text="No players available"
                   Margin="10,25,10,10"
                   FontAttributes="Bold"
                   FontSize="18"
                   HorizontalOptions="Fill"
                   HorizontalTextAlignment="Center" /&gt;
        &lt;/StackLayout&gt;
    &lt;/ContentView&gt;
&lt;/ContentPage.Resources&gt;</pre><p class="list-inset">This defines a page resource containing <code>ContentView</code> with a <code>Key</code> value of <code>"BasicEmptyView"</code>. The view contains <code>StackLayout</code>, which has <code>Label</code> as a child with the text <code>"No players available"</code>. Appropriate styling is applied to make sure it’s large enough and has enough surrounding whitespace.</p></li> <li> Add the <a id="_idIndexMarker1115"/>following attribute to the <code>CollectionView</code> element:<pre class="source-code">
EmptyView="{StaticResource BasicEmptyView}"</pre><p class="list-inset">This binds <code>BasicEmptyView</code> to the <code>EmptyView</code> property of <code>CollectionView</code>. <em class="italic">Figure 10</em><em class="italic">.12</em> shows the result if you run the app and log in:</p></li> </ol>
<div><div><img alt="Figure 10.12 – Lobby with no players" src="img/B19214_10_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Lobby with no players</p>
<ol>
<li value="17">The player card will also use a static resource, which just makes the file a little easier to read, and less indenting. Add the following code snippet to the <code>ContentView.Resources</code> element, under the <code>BasicEmptyView</code> element:<pre class="source-code">
&lt;DataTemplate x:Key="PlayerCardViewTemplate" x:DataType="viewModels:PlayerViewModel"&gt;
    &lt;ContentView&gt;
        &lt;Border StrokeShape="RoundRectangle 10,10,10,10" BackgroundColor="AntiqueWhite" Padding="3,3,3,3" Margin="5,5,5,5"&gt;
            &lt;Grid&gt;
                &lt;Grid.ColumnDefinitions&gt;
                    &lt;ColumnDefinition Width="50" /&gt;
                    &lt;ColumnDefinition Width="4*" /&gt;
                    &lt;ColumnDefinition Width="2*" /&gt;
                &lt;/Grid.ColumnDefinitions&gt;
                &lt;toolkit:AvatarView Grid.Column="0" Margin="0" BackgroundColor="LightGrey" HeightRequest="48" WidthRequest="48" CornerRadius="25" VerticalOptions="Center" HorizontalOptions="Center"&gt;
                    &lt;toolkit:AvatarView.ImageSource&gt;
                        &lt;toolkit:GravatarImageSource
                            Email="{Binding EmailAddress}"
                            Image="MysteryPerson" /&gt;
                    &lt;/toolkit:AvatarView.ImageSource&gt;
                &lt;/toolkit:AvatarView&gt;
                &lt;VerticalStackLayout Grid.Column="1" Margin="10,0,0,0"&gt;
                    &lt;Label Text="{Binding GamerTag}" HorizontalTextAlignment="Start" FontSize="Large" BackgroundColor="AntiqueWhite" /&gt;
                    &lt;Label Text="{Binding Status}" HorizontalTextAlignment="Start" FontSize="Caption" BackgroundColor="AntiqueWhite"/&gt;
                &lt;/VerticalStackLayout&gt;
                &lt;controls:ActivityButton Grid.Column="2" IsRunning="{Binding IsChallenging}" Text="{Binding ChallengeStatus}" BackgroundColor="#e8bc65" Command="{Binding ChallengeCommand}" CommandParameter="{Binding .}" IsVisible="{Binding CanChallenge}" Margin="5"/&gt;
            &lt;/Grid&gt;
        &lt;/Border&gt;
    &lt;/ContentView&gt;
&lt;/DataTemplate&gt;</pre><p class="list-inset"><code>DataTemplate</code> will display the player’s avatar. To do so, it will use an <code>Image</code> control <a id="_idIndexMarker1116"/>and <code>GravatarImageSource</code> the same way as was done in the <em class="italic">Creating the Connect view</em> section. A <code>DataTemplate</code> element is needed since this is used for <code>ItemTemplate</code>, then the obligatory <code>ContentView</code>. Then, <code>Border</code> is defined. It uses a special <code>Stroke</code> shape to round out the edges of the rectangle instead of having square corners, and a color of <code>AntiqueWhite</code> is applied as the <code>BackgroundColor</code> value. Additional shapes to use for <code>Border</code> include <code>Ellipse</code>, <code>Line</code>, <code>Path</code>, <code>Polygon</code>, <code>Polyline</code>, and <code>Rectangle</code>. See the <code>Border</code> documentation at <a href="https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/border">https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/border</a> for more details. Inside <code>Border</code>, there is a <code>Grid</code> control that defines three columns. The first column contains the avatar image and has a width of <code>50</code>, the next column contains the gamer tag and the status of the player, stacked vertically, and the third column contains the <code>Challenge</code> button.</p><p class="list-inset">For the avatar, the <code>AvatarView</code> control from <code>CommunityToolkit</code> is used. It provides a round version of the image.</p><p class="list-inset">The <code>Challenge</code> button uses the <code>ActivityButton</code> control, and is bound to the <code>IsChallenging</code>, <code>CanChallenge</code>, <code>ChallengeStatus</code>, and <code>ChallengeCommand</code> properties of <code>PlayerViewModel</code>.</p></li> <li>To use <code>PlayerCardViewTemplate</code> as <code>ItemTemplate</code> of <code>CollectionView</code>, add the following attribute to the <code>CollectionView</code> element:<pre class="source-code">
ItemTemplate="{StaticResource PlayerCardViewTemplate}"</pre></li> </ol>
<p>That <a id="_idIndexMarker1117"/>completes the <code>Lobby</code> page. At this point, you should be able to launch <code>SticksAndStone.Functions</code> and connect with the <code>SticksAndStones.App</code> project to see the different layouts provided by the <code>Lobby</code> view. There is only one more page to create to complete the game, and that is the <code>Match</code> page.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor890"/>Creating the Match page</h2>
<p>The <code>Match</code> page displays the game board with the players and score. It also manages the <a id="_idIndexMarker1118"/>gameplay, allowing each player to take their turn placing a stick. As each player takes their turn, the board updates to show the current state of the match. Let’s get started with creating the <code>ViewModel</code> classes.</p>
<h3>Creating the ViewModel classes</h3>
<p>There <a id="_idIndexMarker1119"/>are two <a id="_idIndexMarker1120"/>different <code>ViewModel</code> classes used in the <code>Match</code> page, just as there were in the <code>Lobby</code> page, one for the game and a second for the player details.</p>
<h4>Adding MatchPlayerViewModel</h4>
<p><code>MatchPlayerViewModel</code> is the <a id="_idIndexMarker1121"/>abstraction between the <code>Player</code> model and <code>MatchView</code>. <code>MatchPlayerViewModel</code> needs to expose the <code>Id</code>, <code>GamerTag</code>, and <code>EmailAddress</code> values from the <code>Player</code> model to <code>MatchView</code>. In addition, since each player has a score, the player’s score from the <code>Match</code> model is exposed to <code>MatchView</code>. There are a couple of additional properties that are needed as well:</p>
<ul>
<li><code>IsPlayersTurn</code>:<p class="list-inset">This is used to determine whether <code>MatchPlayerViewModel</code> is the current player.</p></li>
<li><code>PlayerToken</code>:<p class="list-inset">This is used to map each player to a token to track which player has placed which stick. A token, either <code>-1</code> or <code>1</code>, is used because it makes determining a winner easier than if it was using the <code>Id</code> property, which is a <code>Guid</code>. Review the <em class="italic">Processing turns section of </em><em class="italic">Chapter 9</em>, for a refresher on how the winner is determined.</p></li>
</ul>
<p> To <a id="_idIndexMarker1122"/>create <code>MatchPlayerViewModel</code>, follow these steps:</p>
<ol>
<li>Create a new class named <code>MatchPlayerViewModel</code> in the <code>ViewModels</code> folder of the <code>SticksAndStones.App</code> project.</li>
<li>Modify the <code>using</code> declarations to the following at the top of the file:<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
using SticksAndStones.Models;</pre></li> <li>Add the <code>public</code> and <code>partial</code> modifiers to the class and make it inherit from <code>ObservableObject</code>, as shown:<pre class="source-code">
<strong class="bold">public partial</strong> class MatchPlayerViewModel: <strong class="bold">ObservableObject</strong>
{
}</pre></li> <li><code>MatchPlayerViewModel</code> is an abstraction of both the <code>Player</code> and <code>Match</code> models, which will be passed in through the constructor. Create the fields and the constructor, as shown in the following listing:<pre class="source-code">
private readonly Player playerModel;
private readonly Match matchModel;
public MatchPlayerViewModel(Player player, Match match)
{
    this.playerModel = player;
    this.matchModel = match;
}</pre></li> <li>The <code>PlayerToken</code> property is <code>1</code> if the <code>Player</code> model is <code>PlayerOne</code> in the <code>Match</code> model; otherwise, it is <code>-1</code>. Add the <code>PlayerToken</code> property using as shown here:<pre class="source-code">
public int PlayerToken =&gt; playerModel.Id == matchModel.PlayerOneId ? 1 : -1;</pre></li> <li>The <code>IsPlayersTurn</code> property <a id="_idIndexMarker1123"/>will return <code>true</code> if the <code>Player</code> model is the <code>NextPlayer</code> of the <code>Match</code> model, as shown here:<pre class="source-code">
public bool IsPlayersTurn =&gt; playerModel.Id == matchModel.NextPlayerId;</pre></li> <li>The <code>Id</code>, <code>GamerTag</code>, and <code>EmailAddress</code> properties all just map directly to the corresponding property from the <code>Player</code> model. This is the same implementation that was used in <code>PlayerViewModel</code> for the <code>Lobby</code> page. Use the following listing to add the properties to <code>MatchPlayerViewModel</code>:<pre class="source-code">
public Guid Id =&gt; playerModel.Id;
public string GamerTag =&gt; playerModel.GamerTag;
public string EmailAddress =&gt; playerModel.EmailAddress;</pre></li> <li>The final <a id="_idIndexMarker1124"/>property that is needed for <code>MatchPlayerViewModel</code> is the <code>Score</code> property. The <code>Score</code> property is mapped to either the <code>PlayerOneScore</code> or <code>PlayerTwoScore</code> property from the <code>Match</code> model, depending on which player the <code>Player</code> model is. Use the following listing to add the <code>Score</code> property to <code>MatchPlayerViewModel</code>:<pre class="source-code">
public int Score =&gt; playerModel.Id == matchModel.PlayerOneId ? matchModel.PlayerOneScore : matchModel.PlayerTwoScore;</pre></li> </ol>
<p>That is all there is to <code>MatchPlayerViewModel</code>. The next section will walk you through creating <code>MatchViewModel</code>.</p>
<h4>Adding MatchViewModel</h4>
<p><code>MatchViewModel</code> needs to provide the functionality for all the gameplay. It provides the two <code>MatchPlayerViewModel</code> objects for display in the header of the page, and the board <a id="_idIndexMarker1125"/>to display where sticks have been played and which stones have been captured. It also provides the needed functionality for players to take their turn and forfeit the game if they choose. To implement <code>MatchViewModel</code>, follow these steps:</p>
<ol>
<li>Create a new class in the <code>ViewModels</code> folder of the <code>SticksAndStones.App</code> project named <code>MatchViewModel</code>.</li>
<li>Modify the <code>using</code> declarations section at the top of the page to match the following listing:<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using SticksAndStones.Models;
using SticksAndStones.Services;</pre></li> <li>Add the <code>public</code> and <code>partial</code> class modifiers to the class, inherit from <code>ViewModelBase</code>, and implement <code>IQueryAttributable</code>, as shown:<pre class="source-code">
public partial class MatchViewModel : ViewModelBase, IQueryAttributable</pre><p class="list-inset">Recall <a id="_idIndexMarker1126"/>that in <code>ConnectViewModel</code> and <code>LobbyViewModel</code>, when they navigate to <code>Match</code>, they pass an argument – either <code>MatchId</code> or the <code>Match</code> instance itself. <code>IQueryAttributable</code> is how that argument is passed to <code>MatchViewModel</code>. The implementation for <code>IQueryAttributable</code> is provided in a later step.</p></li> <li><code>MatchViewModel</code> only has a single dependency, <code>GameService</code>, so add a field to store the instance and a constructor to accept the instance as a parameter, as shown in the following listing:<pre class="source-code">
private readonly GameService gameService;
public MatchViewModel(GameService gameService)
{
    this.gameService = gameService;
}</pre></li> <li>When <code>MatchViewModel</code> is loaded, it will need to process the arguments, either the <code>Match</code> instance or a <code>MatchId</code> value. Either argument will end up with a <code>Match</code> instance that is used for displaying the board in the view, and from that, create two instances of <code>MatchPlayerViewModel</code> for player one and player two. Add <code>match</code>, <code>playerOne</code>, and <code>playerTwo</code> fields to the <code>MatchViewModel</code> class to hold those instances, as shown here:<pre class="source-code">
[ObservableProperty]
private Match match;
[ObservableProperty]
private MatchPlayerViewModel playerOne;
[ObservableProperty]
private MatchPlayerViewModel playerTwo;</pre></li> <li><code>IQueryAttributable</code> is used to process the arguments passed to the view model. Well, it is one way of doing it. The <code>IQueryAttributable</code> interface has only <a id="_idIndexMarker1127"/>one method defined, <code>ApplyQueryAttributes</code>. The .NET MAUI routing system will automatically call the <code>ApplyQueryAttributes</code> method if the view model implements the <code>IQueryAttributable</code> interface. To add the implementation for <code>IQueryAttributable</code>, use the following listing:<pre class="source-code">
public async Task ApplyQueryAttributes(IDictionary&lt;string, object&gt; query)
{
    Match match = null;
    if (query.ContainsKey(Constants.ArgumentNames.Match))
    {
        match = query[Constants.ArgumentNames.Match] as Match;
    }
    if (query.ContainsKey(Constants.ArgumentNames.MatchId))
    {
        var matchId = new Guid($"{query[Constants.ArgumentNames.MatchId]}");
        if (matchId != Guid.Empty)
        {
            match = await gameService.GetMatchById(matchId);
        }
    }
        LoadMatch(match);
    });
}
private void LoadMatch(Match match)
{ 
    if (match is null) return;
    PlayerOne = new MatchPlayerViewModel(gameService.GetPlayerById(match.PlayerOneId), match);
    PlayerTwo = new MatchPlayerViewModel(gameService.GetPlayerById(match.PlayerTwoId), match);
    this.Match = match;
}</pre><p class="list-inset"><code>ApplyQueryAttributes</code> has a single parameter query, which is a dictionary of key-value pairs with the key as a string and the value as an object. The key ID is the name of the parameter as was passed in – for example, <code>"Match"</code> or <code>"MatchId"</code>. The method will check for the existence of the <code>"Match"</code> key being present and get the value as <code>Match</code> if it is. If the <code>"MatchId"</code> key is present, then <code>GameService</code> is used to get the <code>Match</code> model from <code>Id</code>. If there is no value for <code>match</code>, then the method returns; otherwise; initialize the two instances of <code>GamePlayerViewModel</code> and store them and <code>Match</code> in the <code>ViewModel</code> properties. The <code>LoadMatch</code> method is called from <code>ApplyQueryAttributes</code> since we will need the same functionality when the <code>UpdateMatch</code> event is received. </p></li> <li>Before we <a id="_idIndexMarker1128"/>can allow a player to choose a location to place a stick, it must be their turn. Create a property named <code>IsCurrentPlayersTurn</code> using the following listing:<pre class="source-code">
public bool IsCurrentPlayersTurn =&gt; gameService.CurrentPlayer.Id == (Match?.NextPlayerId ?? Guid.Empty);</pre></li> <li>Anytime the <code>Match</code> object is updated, <code>IsCurrentPlayersTurn</code> needs to be updated as well, since it depends on values in the <code>Match</code> property. To have this happen automatically, use the <code>NotifyPropertyChangedFor</code> attribute from <code>CommunityToolkit</code>. Add the highlighted line in the following code listing:<pre class="source-code">
[ObservableProperty]
<strong class="bold">[NotifyPropertyChangedFor(nameof(IsCurrentPlayersTurn))]</strong>
private Match match;</pre><p class="list-inset">Now, whenever the <code>Match</code> property is changed, the <code>NotfiyPropertyChanged</code> method will also be called for <code>IsCurrentPlayersTurn</code>. See <em class="italic">the Defining a ViewModel base class</em> section<em class="italic"> </em>in <em class="italic">Chapter 2</em>, for a refresher on implementing the <code>INotifyPropertyChanged</code> interface.</p></li> <li>The game allows the player to try out different positions of the stick before committing. If this is the current player’s turn, the one connected and using the app, then the <code>SelectStick</code> method will place a stick at the location chosen by the user. The choice is not sent to the server until the user clicks the <code>lastSelectedStick</code> field. Add the following listing to implement the <code>SelectStick</code> method:<pre class="source-code">
int lastSelectedStick = -1;
[RelayCommand(CanExecute = nameof(IsCurrentPlayersTurn))]
private void SelectStick(string arg)
{
    if (gameService.CurrentPlayer is null) return;
    if (Match is null) return;
    
    if (int.TryParse(arg, out var pos))
    {
        pos--; // adjust for 0 based indexes
        if (lastSelectedStick != -1 &amp;&amp; lastSelectedStick != pos)
            Match.Sticks[lastSelectedStick] = 0;
        if (Match.Sticks[pos] != 0)
            return;
        Match.Sticks[pos] = gameService.CurrentPlayer.Id == PlayerOne.Id ? PlayerOne.PlayerToken : PlayerTwo.PlayerToken;
        lastSelectedStick = pos;
        OnPropertyChanged(nameof(Match));
    }
}</pre><p class="list-inset">The value of <code>-1</code> for <code>lastSelectedStick</code> is used to mean no stick. The <code>SelectStick</code> method is exposed as a <code>Command</code> instance via <code>RelayCommandAttribute</code>. The <code>Is</code><strong class="source-inline">
CurrentPlayersTurn</strong> property is used to <a id="_idIndexMarker1130"/>determine whether the command can execute. Recall from <em class="italic">Chapter 9</em> that the <code>Sticks</code> elements will have one of three values: <code>-1</code> for player one, <code>0</code> for empty, and <code>1</code> for player two. After determining whether the stick position is valid, the method raises the <code>OnPropertyChanged</code> event for the <code>Match</code> property, which causes the bindings to update.</p></li> <li>After deliberating on which position to place their next stick, the player has three options: send their move to the server and end their turn, be indecisive and undo their move, or give up and exit the match. Add the <code>Play</code> method to <code>MatchViewModel</code> using the following code snippet:<pre class="source-code">
[RelayCommand]
private async Task Play()
{
    if (lastSelectedStick == -1)
    {
        await Shell.Current.CurrentPage.DisplayAlert("Make a move", "You must make a move before you play.", "Ok");
        return;
    }
    if (await Shell.Current.CurrentPage.DisplayAlert("Make a move", "Are you sure this is the move you want, this can't be undone.", "Yes", "No"))
    {
        var (newMatch, error) = await gameService.EndTurn(Match.Id, lastSelectedStick);
        if (error is not null)
        {
            await Shell.Current.CurrentPage.DisplayAlert("Error in move", error, "Ok");
            return;
        }
        lastSelectedStick = -1;
    }
}</pre><p class="list-inset">The <code>Play</code> method <a id="_idIndexMarker1131"/>is exposed as a <code>Command</code> so that it can be bound to by UI elements.</p></li> <li>The <code>Undo</code> method is called when the player taps the <code>lastSelectedStick</code> position and the value of <code>lastSelectedStick</code>. Add the <code>Undo</code> method, as shown in the following code listing:<pre class="source-code">
[RelayCommand]
private async Task Undo()
{
    if (lastSelectedStick != -1)
    {
        if (await Shell.Current.CurrentPage.DisplayAlert("Undo your move", "Are you sure you don't want to play this move?", "Yes", "No"))
        {
            OnPropertyChanging(nameof(Match));
            Match.Sticks[lastSelectedStick] = 0;
            OnPropertyChanged(nameof(Match));
            lastSelectedStick = -1;
            return;
        }
    }
}</pre><p class="list-inset">Again, the <code>RelayCommand</code> attribute is applied to the method to allow it to be bound to by UI elements.</p><p class="list-inset">The <code>Forfeit</code> method is called when the player uses the <code>Forfeit</code> method to the <code>MatchViewModel</code> class:</p><pre class="source-code">[RelayCommand]
private async Task Forfeit()
{
    var returnToLobby = true;
    if (!Match.Completed)
    {
        returnToLobby = await Shell.Current.CurrentPage.DisplayAlert("W A I T", "Returning to the Lobby will forfeit your match, are you sure you want to do that?", "Yes", "No"))
    if (returnToLobby)
    {
        await Shell.Current.GoToAsync("///Lobby");
    }
}</pre></li> <li>When the <a id="_idIndexMarker1133"/>opposing player sends their move to the server, it is received in the app as a <code>MatchUpdated</code> event from the SignalR service. Add the handler for the <code>MatchUpdated</code> event using the following listing:<pre class="source-code">
void OnMatchUpdated(object r, Messages.MatchUpdated m)
{
    LoadMatch(m.Value);
    if (Match.WinnerId != Guid.Empty &amp;&amp; Match.Completed == true)
    {
        MainThread.InvokeOnMainThreadAsync(async () =&gt;
        {
            if (Match.WinnerId == gameService.CurrentPlayer.Id)
            {
                await Shell.Current.CurrentPage.DisplayAlert("Congratulations!", $"You are victorious!\nPress the back button to return to the lobby.", "Ok");
            }
            else
            {
                await Shell.Current.CurrentPage.DisplayAlert("Bummer!", $"You were defeated, better luck next time!\nPress the back button to return to the lobby.", "Ok");
            }
        });
        return;
    }
}</pre></li> <li>To register the <code>MatchUpdated</code> event handler, the <code>Register</code> method is called <a id="_idIndexMarker1134"/>from <code>OnActivated</code>, and <code>UnRegister</code> is called from <code>OnDeactivated</code>, as shown in the following listing:<pre class="source-code">
protected override void OnActivated()
{
    Messenger.Register(this, (MessageHandler&lt;object, Messages.MatchUpdated&gt;)OnMatchUpdated);
}
protected override void OnDeactivated()
{
    Messenger.Unregister&lt;Messages.MatchUpdated&gt;(this);
}</pre></li> <li>Register <code>MatchViewModel</code> with dependency injection by adding the following highlighted <a id="_idIndexMarker1135"/>line of code to the <code>CreateMauiApp</code> method in the <code>MauiProgram.cs</code> file:<pre class="source-code">
builder.Services.AddTransient&lt;ViewModels.ConnectViewModel&gt;();
builder.Services.AddTransient&lt;ViewModels.LobbyViewModel&gt;();
<strong class="bold">builder.Services.AddTransient&lt;ViewModels.MatchViewModel&gt;();</strong>
builder.Services.AddTransient&lt;Views.ConnectView&gt;();
builder.Services.AddTransient&lt;Views.LobbyView&gt;();</pre></li> </ol>
<p class="callout-heading">Why is it called IQueryAttributable? That feels awkward</p>
<p class="callout">The reason <a id="_idIndexMarker1136"/>behind the name of the interface is that naming things is hard. The system for passing arguments to a view model can be either declarative or not. The declarative way uses <code>QueryPropertyAttribute</code> to map the query parameter to a property on the view model. If you choose not to use the attributes, but instead handle the mapping yourself manually, you declare your class <code>IQueryAttributable</code>, as in I could have used <code>QueryPropertyAttribute</code> but I choose not to. For more information, visit <a href="https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation#pass-data">https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/shell/navigation#pass-data</a>.</p>
<h3>Adding the Match view</h3>
<p>This page <a id="_idIndexMarker1137"/>is complex, so we are going to break it down into smaller, more manageable chunks. First, the basic page layout is defined including the commands that are available to the player: <code>Play</code>, <code>Undo</code>, and <code>Forfeit</code>. Next, the scoreboard area is defined with the player’s gamer tag, Gravatar, and scores. Finally, the game board is defined and laid out in a three-by-three grid. Let’s get started by creating the view and the layout.</p>
<h4>Create the view</h4>
<p>The <code>Match</code> view is not unlike any of the other views that have been created except that it has <a id="_idIndexMarker1138"/>many more elements than preview views. Let’s get started by creating the view and some basic elements by following these steps:</p>
<ol>
<li>Right-click on the <code>Views</code> folder of the <code>SticksAndStone.App</code> project, select <strong class="bold">Add</strong>, and then click <strong class="bold">New Item...</strong>.<p class="list-inset">If you are using Visual Studio 17.7 or later, click the <strong class="bold">Show all Templates</strong> button in the dialog that pops up; otherwise, move to the next step.</p></li>
<li>Under the <strong class="bold">C# Items</strong> node on the left, select <strong class="bold">.</strong><strong class="bold">NET MAUI</strong>.</li>
<li>Select <code>MatchView</code>.</li>
<li>Click <strong class="bold">Add</strong> to create the page.<p class="list-inset">Refer to the following screenshot to view the preceding information:</p></li>
</ol>
<div><div><img alt="Figure 10.13 – Adding a new .NET MAUI ContentPage (XAML)" src="img/B19214_10_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Adding a new .NET MAUI ContentPage (XAML)</p>
<ol>
<li value="5">Open the <code>MatchView.xaml.cs</code> file and add the following <code>using</code> declaration:<pre class="source-code">
using SticksAndStones.ViewModels;</pre></li> <li>Make <a id="_idIndexMarker1139"/>the following highlighted changes to the constructor:<pre class="source-code">
public MatchView(<strong class="bold">MatchViewModel viewModel</strong>)
{
<strong class="bold">    this.BindingContext = viewModel;</strong>
    InitializeComponent();
}</pre><p class="list-inset">These changes allow for dependency injection to supply the <code>MatchViewModel</code> instance to the view, which is then assigned to <code>BindingContext</code>.</p></li> <li>Open the <code>AppShell.xaml</code> file and add the following code snippet to the <code>ContentPage</code> element:<pre class="source-code">
&lt;ShellItem Route="Match"&gt;
    &lt;ShellContent ContentTemplate="{DataTemplate views:MatchView}" /&gt;
&lt;/ShellItem&gt;</pre><p class="list-inset">This <a id="_idIndexMarker1140"/>registers the <code>"Match"</code> route and directs it to <code>MatchView</code>.</p></li> <li>Open the <code>MauiProgram.cs</code> file and add the following highlighted line of code:<pre class="source-code">
builder.Services.AddTransient&lt;Views.ConnectView&gt;();
builder.Services.AddTransient&lt;Views.LobbyView&gt;();
<strong class="bold">builder.Services.AddTransient&lt;Views.MatchView&gt;();</strong>
return builder.Build();</pre><p class="list-inset">This will register <code>MatchView</code> with dependency injection so that <code>DataTemplate</code> can locate it.</p></li> <li>Open the <code>MatchView.xaml</code> file and remove the <code>Title</code> attribute of the <code>ContentPage</code> element.</li>
<li>Add the following highlighted namespaces to the <code>MatchView</code> element. They will provide us access to the classes in the <code>ViewModels</code>, <code>Converters</code>, and <code>Controls</code> namespaces:<pre class="source-code">
&lt;ContentPage 
             
<strong class="bold">        </strong>
<strong class="bold">        </strong>
<strong class="bold">        </strong>
        x:Class="SticksAndStones.Views.GameView"&gt;</pre></li> <li>To make <a id="_idIndexMarker1141"/>IntelliSense happy with the bindings we will be adding, define the view model that the view is using by adding the <code>x:DataType</code> attribute to the <code>MatchView</code> element, as shown:<pre class="source-code">
&lt;ContentPage 
             
        
        
        
        <strong class="bold">x:DataType="viewModels:GameViewModel"</strong>
        x:Class="SticksAndStones.Views.GameView"&gt;</pre></li> </ol>
<p><code>MatchView</code> uses a few icons from the Font Awesome font library, so we will need to download and install the library so that it is available in the app.</p>
<h4>Downloading and configuring Font Awesome</h4>
<p>Font Awesome is a free collection of images packaged into a font. .NET MAUI has excellent <a id="_idIndexMarker1142"/>support for using Font Awesome in toolbars, navigation bars, and all over the place. It’s not strictly needed to make <a id="_idIndexMarker1143"/>this<a id="_idTextAnchor891"/> app, but we think that it’s worth the extra round trip since you are most likely going to need something like this in your new killer app.</p>
<p>Downloading the font is straightforward. Please note the renaming of the file – it is not really needed but it’s easier to edit configuration files and such if they have a simpler name. Follow these steps to acquire and copy the font to each project:</p>
<ol>
<li>Browse to <a href="https://fontawesome.com/download">https://fontawesome.com/download</a>.</li>
<li>Click the <strong class="bold">Free for Desktop</strong> button to download Font Awesome.</li>
<li>Unzip the downloaded file, then locate the <code>otfs</code> folder.</li>
<li>Rename the <code>Font Awesome 5 Free-Solid-900.otf</code> file to <code>FontAwesome.otf</code> (you can keep the original name, but it’s just less to type if you rename it). Your filename may be different since Font Awesome is continually updating but it should be similar.</li>
<li>Copy <code>FontAwesome.otf</code> to the <code>Resources/Fonts</code> folder in the <code>SticksAndStones.App</code> project.</li>
</ol>
<p>It would be nice if all that was needed was to copy the font file into the project folders. A lot does happen with just that action. The default .NET MAUI template includes all the fonts in the <code>Resources/Fonts</code> folder with the following item definition in the <code>News.csproj</code> file:</p>
<pre class="source-code">
&lt;!-- Custom Fonts --&gt;
&lt;MauiFont Include="Resources\Fonts\*" /&gt;</pre> <p>This ensures that the font files are processed and included in the app package automatically. What is left is to register the font with the .NET MAUI runtime so it is available to our XAML resources. To do that, add the following highlighted line to the <code>MauiProgram.cs</code> file:</p>
<pre class="source-code">
.ConfigureFonts(fonts =&gt;
{
    fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
    fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
    <strong class="bold">fonts.AddFont("FontAwesome.otf", "FontAwesome");</strong>
})</pre> <p>This line <a id="_idIndexMarker1144"/>adds an alias that we can use in the <a id="_idIndexMarker1145"/>next section to create static resources. The first parameter is the filename for the font file, and the second is the alias for the font that you can use in the <code>FontFamily</code> attribute.</p>
<h4>Defining the layout</h4>
<p>Now that <a id="_idIndexMarker1146"/>Font Awesome is installed and configured in .NET MAUI, <code>TitleView</code> can use it. Add the custom title area and the main layout by following these steps:</p>
<ol>
<li>First, override <code>TitleView</code> of the <code>Shell</code> element and provide a new container to hold the buttons:<pre class="source-code">
&lt;Shell.TitleView&gt;
    &lt;Grid&gt;
        &lt;HorizontalStackLayout HorizontalOptions="Start"&gt;
        &lt;/HorizontalStackLayout&gt;
        &lt;HorizontalStackLayout HorizontalOptions="End"&gt;
        &lt;/HorizontalStackLayout&gt;
    &lt;/Grid&gt;
&lt;/Shell.TitleView&gt;</pre><p class="list-inset">The buttons are arranged in two segments, one aligned to the left or start of the window and the other aligned to the right or end of the window.</p></li> <li>The player can at any point decide they no longer wish to continue playing. To exit the match, the player can use the <code>Start</code> section of <code>TitleView</code> and bind <code>ForfeitCommand</code> in <code>MatchViewModel</code>, add the highlighted code from the following snippet :<pre class="source-code">
&lt;HorizontalStackLayout HorizontalOptions="Start"&gt;
<strong class="bold">    &lt;ImageButton Command="{Binding ForfeitCommand}" ToolTipProperties.Text="Return to the </strong><strong class="bold">l</strong><strong class="bold">obby."&gt;</strong>
<strong class="bold">        &lt;ImageButton.Source&gt;</strong>
<strong class="bold">            &lt;FontImageSource Glyph="&amp;#xf0a8;" FontFamily="FontAwesome" Color="White" Size="28" /&gt;</strong>
<strong class="bold">        &lt;/ImageButton.Source&gt;</strong>
<strong class="bold">    &lt;/ImageButton&gt;</strong>
&lt;/HorizontalStackLayout&gt;</pre></li> <li>When it is the player’s turn, they have two buttons that are enabled, <code>Play</code> and <code>Undo</code>. The <code>Play</code> and <code>Undo</code> buttons are placed in the <code>TitleView</code> area of the .NET MAUI page. Add the following highlighted code to add the <code>Play</code> and <code>Undo</code> buttons to <code>TitleView</code>:<pre class="source-code">
&lt;HorizontalStackLayout HorizontalOptions="End"&gt;
<strong class="bold">    &lt;ImageButton Command="{Binding UndoCommand}" IsVisible="{Binding IsCurrentPlayersTurn}" ToolTipProperties.Text="Undo the last stick placement."&gt;</strong>
<strong class="bold">        &lt;ImageButton.Source&gt;</strong>
<strong class="bold">            &lt;FontImageSource Glyph="&amp;#xf0e2;" FontFamily="FontAwesome" Color="White" Size="28" /&gt;</strong>
<strong class="bold">        &lt;/ImageButton.Source&gt;</strong>
<strong class="bold">    &lt;/ImageButton&gt;</strong>
<strong class="bold">    &lt;ImageButton Command="{Binding PlayCommand}" IsVisible="{Binding IsCurrentPlayersTurn}" ToolTipProperties.Text="Send the stick placement, and end my turn."&gt;</strong>
<strong class="bold">        &lt;ImageButton.Source&gt;</strong>
<strong class="bold">            &lt;FontImageSource Glyph="&amp;#xf1d8;" FontFamily="FontAwesome" Color="White" Size="28" /&gt;</strong>
<strong class="bold">        &lt;/ImageButton.Source&gt;</strong>
<strong class="bold">    &lt;/ImageButton&gt;</strong>
&lt;/HorizontalStackLayout&gt;</pre></li> <li>Remove <a id="_idIndexMarker1148"/>the default <code>VerticalStackLayout</code> element in <code>ContentView</code> and add the following code:<pre class="source-code">
&lt;ContentView&gt;
    &lt;Grid&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="4*" /&gt;
            &lt;RowDefinition Height="2*" /&gt;
            &lt;RowDefinition Height="6*" /&gt;
            &lt;RowDefinition Height="2*" /&gt;
        &lt;/Grid.RowDefinitions&gt;
    &lt;/Grid&gt;
&lt;/ContentView&gt;</pre><p class="list-inset">This adds a <code>Grid</code> control with four rows. The first and third rows will contain the scoreboard and the game board, respectively, while the second and fourth rows are padding.</p></li> </ol>
<p>The main <a id="_idIndexMarker1149"/>layout is ready. Next, the scoreboard is added to the first row of the layout.</p>
<h4>Creating the scoreboard</h4>
<p>The scoreboard contains each player’s avatar, gamer tag, and score. The elements are bound to <a id="_idIndexMarker1150"/>the respective fields of <code>MatchPlayerViewModel</code> for the player. The <code>Match</code> object has two properties, <code>PlayerOne</code> and <code>PlayerTwo</code>, each of which is a <code>MatchPlayerViewModel</code>. To add the scoreboard, follow these steps:</p>
<ol>
<li>Each player is identified by a different color. To add each color as a resource, open the <code>Colors.xaml</code> file in the <code>Resources/Styles</code> folder of the <code>SticksAndStones.App</code> project and add the following lines to the <code>ResourceDictionary</code> element:<pre class="source-code">
&lt;Color x:Key="PlayerOne"&gt;#6495ED&lt;/Color&gt;
&lt;Color x:Key="PlayerTwo"&gt;#CD5C5C&lt;/Color&gt;</pre></li> <li>The scoreboard uses <code>HorizontalStackLayout</code> for the outer container. Add the following code to the <code>Grid</code> element:<pre class="source-code">
&lt;HorizontalStackLayout Grid.Row="0" HorizontalOptions="CenterAndExpand" Margin="10" BindableLayout.ItemsSource="{Binding Players}"&gt;
&lt;/HorizontalStackLayout&gt;</pre><p class="list-inset"><code>HorizontalStackLayout</code> is assigned to row <code>0</code> of the <code>Grid</code>, and its contents are bound to the <code>Players</code> property of the view model, using <code>BindableLayout.ItemsSource</code>. <code>BindableLayout</code> is the underlying interface that supports all layout controls, such as <code>AbsoluteLayout</code> and <code>FlexLayout</code>.</p></li> <li>Each player will have their own card within <code>HorizontalStackLayout</code>. Since the control is bound to the <code>Players</code> property, which is an array of <code>MatchPlayerViewModels</code>, the <code>BindableLayout.ItemTemplate</code> property <a id="_idIndexMarker1151"/>provides the view that each item in <code>Players</code> is displayed with. The cards are laid out using a <code>Border</code> element and nested <code>VerticalStackLayout</code> elements. Add the following highlighted code to <code>HorizontalStackLayout</code>:<pre class="source-code">
&lt;HorizontalStackLayout Grid.Row="0" HorizontalOptions="CenterAndExpand" Margin="10"&gt;
<strong class="bold">    &lt;BindableLayout.ItemTemplate&gt;</strong>
<strong class="bold">        &lt;DataTemplate&gt;</strong>
<strong class="bold">            &lt;Border x:DataType="viewModels:MatchPlayerViewModel" Padding="0" Margin="2" StrokeShape="RoundRectangle 10,10,10,10" HeightRequest="175"&gt;</strong>
<strong class="bold">                &lt;VerticalStackLayout Padding="2" HorizontalOptions="Center"&gt;</strong>
<strong class="bold">                &lt;/VerticalStackLayout&gt;</strong>
<strong class="bold">            &lt;/Border&gt;</strong>
<strong class="bold">        &lt;/DataTemplate&gt;</strong>
<strong class="bold">    &lt;/BindableLayout.ItemTemplate&gt;</strong>
&lt;/HorizontalStackLayout&gt;</pre></li> <li>The <code>Border</code> element is the outermost container for the player card. To set the border color and background color of the <code>Border</code> element based on <code>PlayerToken</code>, triggers are used (<a href="https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/triggers">https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/triggers</a>) – specifically, <code>DataTrigger</code> is used to set attribute values based on some other value. Add the following code to the <code>Border</code> element:<pre class="source-code">
&lt;Border.Triggers&gt;
    &lt;DataTrigger TargetType="Border" Binding="{Binding PlayerToken}" Value="1" &gt;
        &lt;Setter Property="Stroke" Value="{StaticResource PlayerOne}" /&gt;
        &lt;Setter Property="BackgroundColor" Value="{StaticResource PlayerOne}" /&gt;
    &lt;/DataTrigger&gt;
    &lt;DataTrigger TargetType="Border" Binding="{Binding PlayerToken}" Value="-1" &gt;
        &lt;Setter Property="Stroke" Value="{StaticResource PlayerTwo}" /&gt;
        &lt;Setter Property="BackgroundColor" Value="{StaticResource PlayerTwo}" /&gt;
    &lt;/DataTrigger&gt;
&lt;/Border.Triggers&gt;</pre><p class="list-inset">The <code>DataTrigger</code> binding <a id="_idIndexMarker1152"/>attribute is compared to the <code>Value</code> attribute. If they are equal, then the <code>Setter</code> elements of <code>DataTrigger</code> are executed. In this case, if the <code>PlayerToken</code> property is <code>-1</code>, then set the <code>Stroke</code> and <code>BackgroundColor</code> attributes of <code>Border</code> to the <code>PlayerOne</code> color that was defined in <em class="italic">step 1</em>. Otherwise, if the <code>PlayerToken</code> property is equal to <code>-1</code>, then set the <code>Stroke</code> and <code>BackgroundColor</code> attributes to the <code>PlayerTwo</code> color.</p></li> <li><code>VerticalStackLayout</code> contains another <code>VerticalStackLayout</code> and <code>Border</code> element, as shown in the following highlighted code:<pre class="source-code">
<strong class="bold">&lt;VerticalStackLayout BackgroundColor="{Binding PlayerToken, Converter={StaticResource PlayerToColor}}" Padding="2" HorizontalOptions="Center"&gt;</strong>
<strong class="bold">    &lt;VerticalStackLayout&gt;</strong>
<strong class="bold">    &lt;/VerticalStackLayout&gt;</strong>
<strong class="bold">    &lt;Border Padding="0" WidthRequest="96" StrokeShape="RoundRectangle 10,10,10,10" StrokeThickness="0"&gt;</strong>
<strong class="bold">        &lt;Image IsVisible="{Binding IsPlayersTurn}" Source="hstick.jpeg" Aspect="AspectFit" MaximumHeightRequest="36"/&gt;</strong>
<strong class="bold">    &lt;/Border&gt;</strong>
<code>VerticalStackLayout</code> will be used to hold <code>GamerTag</code>, <code>AvatarImage</code>, and the player’s score, which is added in the next step. <code>Border</code> contains a horizontal <a id="_idIndexMarker1153"/>stick image whose <code>IsVisible</code> attribute is bound to the <code>IsPlayersTurn</code> property. The stick is used as a visual indicator of which player’s turn it is. If it is not the player’s turn, the image is not displayed.</p></li> <li>Within the second <code>VerticalStackLayout</code> are a <code>Label</code> and a <code>FlexLayout</code>. Add the following highlighted code:<pre class="source-code">
<strong class="bold">&lt;VerticalStackLayout&gt;</strong>
<strong class="bold">    &lt;Label Text="{Binding GamerTag}" HorizontalOptions="FillAndExpand" HorizontalTextAlignment="Center" FontSize="18" FontFamily="OpenSansSemibold"/&gt;</strong>
<strong class="bold">    &lt;FlexLayout Margin="3"&gt;</strong>
<strong class="bold">    &lt;/FlexLayout&gt;</strong>
<code>FlexLayout</code> contains the visual elements to display <code>AvatarImage</code> and <code>Score</code>. Add the <a id="_idIndexMarker1154"/>following highlighted code to <code>FlexLayout</code>:<pre class="source-code">
<strong class="bold">&lt;FlexLayout Margin="3"&gt;</strong>
<strong class="bold">    &lt;toolkit:AvatarView FlexLayout.Order="0" Margin="0" BackgroundColor="LightGrey" HeightRequest="85" WidthRequest="85" CornerRadius="50" VerticalOptions="Center" HorizontalOptions="Center"&gt;</strong>
<strong class="bold">        &lt;toolkit:AvatarView.ImageSource&gt;</strong>
<strong class="bold">            &lt;toolkit:GravatarImageSource</strong>
<strong class="bold">                Email="{Binding EmailAddress}"</strong>
<strong class="bold">                Image="MysteryPerson" /&gt;</strong>
<strong class="bold">        &lt;/toolkit:AvatarView.ImageSource&gt;</strong>
<strong class="bold">        &lt;toolkit:AvatarView.Triggers&gt;</strong>
<strong class="bold">            &lt;DataTrigger TargetType="toolkit:AvatarView" Binding="{Binding Path=PlayerToken}" Value="-1"&gt;</strong>
<strong class="bold">                &lt;Setter Property="FlexLayout.Order" Value="1" /&gt;</strong>
<strong class="bold">            &lt;/DataTrigger&gt;</strong>
<strong class="bold">        &lt;/toolkit:AvatarView.Triggers&gt;</strong>
<strong class="bold">    &lt;/toolkit:AvatarView&gt;</strong>
<strong class="bold">    &lt;Label FlexLayout.Order="1" Text="{Binding Score}" FontSize="48" Padding="5" MinimumWidthRequest="65" HorizontalTextAlignment="Center"&gt;</strong>
<strong class="bold">        &lt;Label.Triggers&gt;</strong>
<strong class="bold">            &lt;DataTrigger TargetType="Label" Binding="{Binding Path=PlayerToken}" Value="-1"&gt;</strong>
<strong class="bold">                &lt;Setter Property="FlexLayout.Order" Value="0" /&gt;</strong>
<strong class="bold">            &lt;/DataTrigger&gt;</strong>
<strong class="bold">        &lt;/Label.Triggers&gt;</strong>
<strong class="bold">    &lt;/Label&gt;</strong>
<code>FlexLayout</code> control, the order in which the <code>FlexLayout</code> children <a id="_idIndexMarker1155"/>are displayed is governed by the <code>FlexLayout.Order</code> attribute. Similar to <code>Grid</code> with its <code>Grid.Row</code> and <code>Grid.Column</code> properties on its children, the <code>Order</code> attribute is set on the child. The order of the children in <code>FlexLayout</code> is changed through the use of <code>Trigger</code>. On <code>AvatarView</code>, <code>DataTrigger</code> will set the <code>FlexLayout.Order</code> attribute to <code>"1"</code> if the <code>PlayerToken</code> property is equal to <code>-1</code>, which is <code>PlayerTwo</code>. On the <code>Label</code>, <code>DataTrigger</code> sets the <code>FlexLayout.Order</code> attribute to <code>"0"</code>, effectively swapping the two elements.</p></li> </ol>
<p>And that concludes the scoreboard. The final part of <code>MatchView</code> is the largest: the board. Read on to learn how to create the board visuals.</p>
<h4>Creating the game board</h4>
<p>The game <a id="_idIndexMarker1156"/>board is composed of three different elements. These elements are dots in the corners of each square, sticks (both horizontal and vertical), and stones. These elements are laid out as shown here:</p>
<div><div><img alt="Figure 10.14 – The game board" src="img/B19214_10_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – The game board</p>
<p>The board uses a <code>Grid</code> control to provide the basic layout. Using 7 columns and 7 rows will provide cells for each of the elements: 16 dots, 9 stones, and 24 sticks. Add the following <a id="_idIndexMarker1157"/>code to provide the basic layout of the game board to the top-level <code>Grid</code> element:</p>
<pre class="source-code">
&lt;Grid Grid.Row="2" BackgroundColor="White" Margin="10,40,10,0" MaximumHeightRequest="410" MaximumWidthRequest="400" &gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="1*" /&gt;
        &lt;ColumnDefinition Width="5*" /&gt;
        &lt;ColumnDefinition Width="1*" /&gt;
        &lt;ColumnDefinition Width="5*" /&gt;
        &lt;ColumnDefinition Width="1*" /&gt;
        &lt;ColumnDefinition Width="5*" /&gt;
        &lt;ColumnDefinition Width="1*" /&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="1*" /&gt;
        &lt;RowDefinition Height="4*" /&gt;
        &lt;RowDefinition Height="1*" /&gt;
        &lt;RowDefinition Height="4*" /&gt;
        &lt;RowDefinition Height="1*" /&gt;
        &lt;RowDefinition Height="4*" /&gt;
        &lt;RowDefinition Height="1*" /&gt;
    &lt;/Grid.RowDefinitions&gt; 
&lt;/Grid&gt;</pre> <p>Let’s start by adding the corners to the grid, since they are the simplest. To define a corner, use a <code>Label</code> with the text <code>"&amp;#x26AB;"</code>, which is the hexadecimal character code for a dot. To center the dot horizontally and vertically, set <code>HorizontalOptions</code> and <code>VerticalOptions</code> to <code>"Center"</code>. Your basic element would look like the following:</p>
<pre class="source-code">
&lt;Label Text="&amp;#x26AB" HorizontalOptions="Center" VerticalOptions="Center" /&gt;</pre> <p>Without the <code>Grid.Row</code> and <code>Grid.Column</code> attributes, the <code>Label</code> will be put into row <code>0</code> and column <code>0</code>. There are 16 corners in the grid, and they occupy all the even-numbered cells, so <code>(0,0)</code>, <code>(0,2)</code>, <code>(0,4)</code>, <code>(0,6)</code>, <code>(2,0)</code>, <code>(2,2)</code>, and so on. Fully defined labels <a id="_idIndexMarker1158"/>for the first row would look like the following:</p>
<pre class="source-code">
            &lt;Label Grid.Row="0" Grid.Column="0" Text="&amp;#x26AB" HorizontalOptions="Center" VerticalOptions="Center" /&gt;
            &lt;Label Grid.Row="0" Grid.Column="2" Text="&amp;#x26AB" HorizontalOptions="Center" VerticalOptions="Center" /&gt;
            &lt;Label Grid.Row="0" Grid.Column="4" Text="&amp;#x26AB" HorizontalOptions="Center" VerticalOptions="Center" /&gt;
            &lt;Label Grid.Row="0" Grid.Column="6" Text="&amp;#x26AB" HorizontalOptions="Center" VerticalOptions="Center" /&gt;</pre> <p>When you work this out for all 16 rows, that’s a lot of duplication of the <code>Text</code>, <code>HorizontalOptions</code>, and <code>VerticalOptions</code> attributes. By using a <code>Style</code> element, that duplication can be eliminated. A <code>Style</code> element contains <code>Setter</code> elements such as the <code>DataTrigger</code> elements. When <code>Style</code> is applied to the element, the <code>Setter</code> elements are used to update the target element’s attributes. Use the following steps to add the corner elements to the <code>Grid</code> control using <code>Style</code>:</p>
<ol>
<li>Add the following <code>Style</code> element to the <code>ContentPage.Resources</code> element:<pre class="source-code">
&lt;Style x:Key="dotLabel"
        TargetType="Label"&gt;
    &lt;Setter Property="Text" Value="&amp;#x26AB;" /&gt;
    &lt;Setter Property="HorizontalOptions" Value="Center" /&gt;
    &lt;Setter Property="VerticalOptions" Value="Center" /&gt;
&lt;/Style&gt;</pre><p class="list-inset">This <code>Style</code> element is identified by the <code>x:Key</code> attribute. </p></li> <li>Add a <code>Label</code> to the <code>Grid</code> control created at the start of this section. </li>
<li>Set the <code>Grid.Row</code> attribute of the <code>Label</code> to <code>0</code>.</li>
<li>Set the <code>Grid.Column</code> attribute of the <code>Label</code> to <code>0</code>.</li>
<li>Set the <code>Style</code> attribute to the <code>{StaticResource dotLabel}</code> value. The <code>Style</code> attribute is <a id="_idIndexMarker1159"/>used to specify which style should be applied to the element. Since <code>Style</code> is defined in the <code>ContentView.Resources</code> element, it is a <code>StaticResource</code>.</li>
<li>The completed <code>Label</code> should look like the following:<pre class="source-code">
&lt;Label Grid.Row="0" Grid.Column="0" Style="{StaticResource dotLabel}" /&gt;</pre></li> <li>Now, copy the <code>Label</code> just created and increase the <code>Grid.Column</code> value by two, and repeat this step until you have four <code>Label</code> elements with the same <code>Grid.Row</code> value.</li>
<li>Copy the last <code>Label</code> created in <em class="italic">step 7</em> and increase the <code>Grid.Row</code> value by two and reset the value of <code>Grid.Column</code> to <code>0</code>. Now, repeat <em class="italic">step 7</em> using the updated <code>Grid.Row</code> value, and stop when there are four labels with a <code>Grid.Row</code> value of <code>6</code>.</li>
<li>The labels <a id="_idIndexMarker1160"/>should look like the following listing:<pre class="source-code">
&lt;Label Grid.Row="0" Grid.Column="0" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="0" Grid.Column="2" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="0" Grid.Column="4" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="0" Grid.Column="6" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="2" Grid.Column="0" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="2" Grid.Column="2" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="2" Grid.Column="4" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="2" Grid.Column="6" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="4" Grid.Column="0" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="4" Grid.Column="2" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="4" Grid.Column="4" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="4" Grid.Column="6" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="6" Grid.Column="0" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="6" Grid.Column="2" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="6" Grid.Column="4" Style="{StaticResource dotLabel}" /&gt;
&lt;Label Grid.Row="6" Grid.Column="6" Style="{StaticResource dotLabel}" /&gt;</pre></li> </ol>
<p>Now that the corners are done, we can start on the game pieces: the sticks and stones. Since the sticks and stones have some similarities, we can create a common control to help display them all. However, they are visualized entirely differently. What is needed is a common <a id="_idIndexMarker1161"/>interface to define the <code>BindableProperty</code> properties and use that on different layouts.<code>.NET</code> <code>MAUI</code> <code>uses</code> <code>ControlTemplate</code> resources to allow for the customization, or even complete replacement, of the visual elements that comprise a control. Many controls in .NET MAUI can be customized using a <code>ControlTemplate</code>, if they derive from <code>ContentView</code> or <code>ContentPage</code>. Let’s get started with the sticks and stones by adding the custom control, then the <code>ControlTemplate</code> resources for sticks and stones, by following these steps:</p>
<ol>
<li>Create a new class in the <code>Controls</code> folder of the <code>SticksAndStones.App</code> project named <code>GamePieceView</code>.</li>
<li>Update the class definition to match the following listing:<pre class="source-code">
namespace SticksAndStones.Controls;
<strong class="bold">public partial</strong> class GamePieceView <strong class="bold">: ContentView</strong>
{
}</pre></li> <li>Add a <code>string</code> property and a <code>BindableProperty</code> property named <code>GamePiecePosition</code> and <code>GamePiecePositionProperty</code>, respectively, as shown in the following listing:<pre class="source-code">
public static readonly BindableProperty GamePiecePositionProperty = BindableProperty.Create(nameof(GamePiecePosition), typeof(string), typeof(GamePieceView), string.Empty);
public string GamePiecePosition
{
    get =&gt; (string)GetValue(GamePiecePositionProperty);
    set =&gt; SetValue(GamePiecePositionProperty, value);
}</pre><p class="list-inset"><code>GamePiecePosition</code> is used <a id="_idIndexMarker1162"/>to determine the array index in either <code>Sticks</code> or <code>Stones</code> properties on <code>GameViewModel</code>.</p></li> <li>Add an <code>int</code> property and <code>BindableProperty</code> named <code>GamePieceState</code> and <code>GamePieceStateProperty</code>, respectively, as shown in the following listing:<pre class="source-code">
public static readonly BindableProperty GamePieceStateProperty = BindableProperty.Create(nameof(GamePieceState), typeof(int), typeof(GamePieceView), 0, BindingMode.TwoWay);
public int GamePieceState
{
    get =&gt; (int)GetValue(GamePieceStateProperty);
    set =&gt; SetValue(GamePieceStateProperty, value);
}</pre><p class="list-inset"><code>GamePieceState</code> is the owner of the piece: <code>1</code> for <code>PlayerOne</code>, <code>0</code> for no one, and <code>-1</code> for <code>PlayerTwo</code>.</p></li> <li>Add a <code>string</code> property and <code>BindableProperty</code> named <code>GamePieceDirection</code> and <code>GamePieceDirectionProperty</code>, respectively, as shown in the following listing:<pre class="source-code">
public static readonly BindableProperty GamePieceDirectionProperty = BindableProperty.Create(nameof(GamePieceDirection), typeof(string), typeof(GamePieceView), null);
public string GamePieceDirection
{
    get =&gt; (string)GetValue(GamePieceDirectionProperty);
    set =&gt; SetValue(GamePieceDirectionProperty, value);
}</pre><p class="list-inset"><code>GamePieceDirection</code> is only needed for <code>Sticks</code> and is either <code>Horizontal</code> or <code>Vertical</code>.</p></li> <li>Open the <code>MatchView.Xaml</code> file again and let’s add a control template for all the sticks. Add <a id="_idIndexMarker1163"/>the following snippet to the <code>ContentView.Resources</code> element:<pre class="source-code">
&lt;ControlTemplate x:Key="StickViewControlTemplate"&gt;
&lt;/ControlTemplate&gt;</pre><p class="list-inset">This defines a <code>ControlTemplate</code> element with a key of <code>StickViewControlTemplate</code>. The key is used to apply the <code>ControlTemplate</code> element to the control.</p></li> <li>There are two elements to each stick visual: the number displayed on a label, and the stick image, which uses the <code>Image</code> control inside a border to give it the outline, colored by the player that placed the stick. The other interesting aspect is that the <code>Label</code> and <code>Border</code> controls need to be layered on top of one another. To accomplish this, a <code>Grid</code> control is used and both elements are placed in the same cell. To add the <code>Grid</code>, <code>Label</code>, <code>Border</code>, and <code>Image</code> controls, use the following listing, and add them to the <code>ControlTemplate</code> element:<pre class="source-code">
&lt;Grid Margin="0" Padding="0"&gt;
    &lt;Label Text="{TemplateBinding GamePiecePosition}" IsVisible="False" HorizontalTextAlignment="Center" VerticalTextAlignment="Center" TextColor="Red" FontAttributes="Bold" &gt;
    &lt;/Label&gt;
    &lt;Border Padding="3" BackgroundColor="Transparent" StrokeShape="RoundRectangle 5" Stroke="Transparent"&gt;
        &lt;Image Aspect="Fill"&gt;
        &lt;/Image&gt;
    &lt;/Border&gt;
&lt;/Grid&gt;</pre><p class="list-inset"><code>Grid</code> has <code>Margin</code> and <code>Padding</code> values of <code>0</code> so that it doesn’t occupy any screen <a id="_idIndexMarker1164"/>real estate. The <code>Label</code> control’s <code>Text</code> attribute is bound using <code>TemplateBinding</code> to the <code>GamePiecePosition</code> property. <code>TemplateBinding</code> differs slightly from <code>Binding</code> in that <code>TemplateBinding</code> uses the control this <code>ControlTemplate</code> is applied to as <code>DataContext</code>. Since this <code>ControlTemplate</code> will be applied to instances of <code>GamePieceView</code>, it will bind to the <code>Bindable</code> properties of those controls.</p><p class="list-inset">Inspecting the <code>Image</code> control from <em class="italic">step 7</em>, you’ll find that it doesn’t specify which image is displayed. For <code>Sticks</code>, one of two images is displayed: either <code>hstick.jpeg</code> for horizontal sticks or <code>vstick.jpeg</code> for vertical sticks, and if there is no stick at that location, then the control should not be visible. The following listing uses <code>DataTrigger</code> to set the values of <code>IsVisible</code> and <code>Source</code> of the <code>Image</code> control using <code>TemplateBinding</code> to the <code>GamePieceState</code> and <code>GamePieceDirection</code> properties. Add this code to the <code>Image</code> control of <code>ControlTemplate</code>: </p><pre class="source-code">&lt;Image.Triggers&gt;
    &lt;DataTrigger TargetType="Image" Binding="{TemplateBinding Path=GamePieceState}" Value="0"&gt;
        &lt;Setter Property="IsVisible" Value="False" /&gt;
    &lt;/DataTrigger&gt;
    &lt;DataTrigger TargetType="Image" Binding="{TemplateBinding Path=GamePieceDirection}" Value="Horizontal"&gt;
         &lt;Setter Property="Source" Value="hstick.jpeg" /&gt;
    &lt;/DataTrigger&gt;
    &lt;DataTrigger TargetType="Image" Binding="{TemplateBinding Path=GamePieceDirection}" Value="Vertical"&gt;
         &lt;Setter Property="Source" Value="vstick.jpeg" /&gt;
    &lt;/DataTrigger&gt;
&lt;/Image.Triggers&gt;</pre></li> <li>The <code>Border</code> control also uses <code>DataTrigger</code> to outline the stick in the color of the player <a id="_idIndexMarker1165"/>that placed the stick. Add the following code to the <code>Border</code> element, after <code>Image</code>:<pre class="source-code">
&lt;Border.Triggers&gt;
    &lt;DataTrigger TargetType="Border" Binding="{TemplateBinding GamePieceState}" Value="1" &gt;
        &lt;Setter Property="Stroke" Value="{StaticResource PlayerOne}" /&gt;
    &lt;/DataTrigger&gt;
    &lt;DataTrigger TargetType="Border" Binding="{TemplateBinding GamePieceState}" Value="-1" &gt;
        &lt;Setter Property="Stroke" Value="{StaticResource PlayerTwo}" /&gt;
    &lt;/DataTrigger&gt;
&lt;/Border.Triggers&gt;</pre><p class="list-inset">Two triggers are needed to switch between <code>PlayerOne</code> (<code>1</code>) and <code>PlayerTwo</code> (<code>-1</code>). The <code>Stroke</code> attribute of the <code>Border</code> control is set to the color resource of the player. If neither trigger is active, then the default <code>Stroke</code> value of <code>Transparent</code> from the <code>Border</code> element is used. In this way, if there is no stick, <code>GamePieceState</code> is <code>0</code>, and the border is transparent. If <code>GamePieceState</code> is <code>1</code>, then <code>Stroke</code> will have the color defined by the resource named <code>PlayerOne</code>, and if <code>GamePieceState</code> is <code>-1</code>, then the <code>Stroke</code> value will be the resource named <code>PlayerTwo</code>.</p></li> <li>When the <a id="_idIndexMarker1166"/>user is making their move during their turn, they will tap or click on the label to place their stick in that position. To call <code>SelectStickCommand</code> when that occurs, the <code>Border</code> control binds <code>TapGestureRecognizer</code> to the <code>GameViewModel.SelectStickCommand</code> property and passes <code>GamePiecePosition</code> along as a parameter. Add the following listing to the <code>Border</code> element, after the <code>Border.Triggers</code> element:<pre class="source-code">
&lt;Border.GestureRecognizers&gt;
    &lt;TapGestureRecognizer Command="{Binding Source={RelativeSource AncestorType={x:Type viewModels:GameViewModel}}, Path=SelectStickCommand}" CommandParameter="{TemplateBinding GamePiecePosition}" /&gt;
&lt;/Border.GestureRecognizers&gt;</pre></li> <li>Finally, take a close look at the <code>Label</code> element; you will see that the <code>IsVisible</code> attribute is set to <code>False</code>. If there is no stick placed at this position, then we <a id="_idIndexMarker1167"/>need the label with the position displayed. That can be accomplished by using <code>DataTrigger</code>; the label’s <code>IsVisible</code> property can be set to <code>True</code>, making the label visible if <code>GamePieceState</code> is <code>0</code>, meaning no stick has been placed there yet. Add the following listing to the <code>Label</code> element:<pre class="source-code">
&lt;Label.Triggers&gt;
    &lt;DataTrigger TargetType="Label" Binding="{TemplateBinding Path=GamePieceState}" Value="0"&gt;
        &lt;Setter Property="IsVisible" Value="True" /&gt;
    &lt;/DataTrigger&gt;
&lt;/Label.Triggers&gt;</pre></li> </ol>
<p>That completes the control template for the sticks. Next, create the control template for <code>Stones</code> by following these steps:</p>
<ol>
<li>Right below the <code>ControlTemplate</code> created for the sticks, add the following code:<pre class="source-code">
&lt;ControlTemplate x:Key="StoneViewControlTemplate"&gt;
&lt;/ControlTemplate&gt;</pre><p class="list-inset">Just like with the control template for sticks, the <code>ControlTemplate</code> uses a key to locate the right template.</p></li> <li>The <code>Stones</code> template is a little less complex than the <code>Sticks</code> template. Here, we just have the <code>Border</code> control with an <code>Image</code> control as a child. <code>DataTrigger</code> is used again to select the right border color, and if the stones are not present, then the border is not visible. Use the following code sample and add it to the <code>ControlTemplate</code> created in <em class="italic">step 1</em>:<pre class="source-code">
&lt;Border Margin="3" Padding="5" HorizontalOptions="Center" VerticalOptions="Center" StrokeShape="RoundRectangle 5" StrokeThickness="3"&gt;
    &lt;Border.Triggers&gt;
        &lt;DataTrigger TargetType="Border" Binding="{TemplateBinding GamePieceState}" Value="0"&gt;
            &lt;Setter Property="IsVisible" Value="False" /&gt;
        &lt;/DataTrigger&gt;
        &lt;DataTrigger TargetType="Border" Binding="{TemplateBinding GamePieceState}" Value="1" &gt;
            &lt;Setter Property="Stroke" Value="{StaticResource PlayerOne}" /&gt;
        &lt;/DataTrigger&gt;
        &lt;DataTrigger TargetType="Border" Binding="{TemplateBinding GamePieceState}" Value="-1" &gt;
            &lt;Setter Property="Stroke" Value="{StaticResource PlayerTwo}" /&gt;
        &lt;/DataTrigger&gt;
    &lt;/Border.Triggers&gt;
    &lt;Image Source="stones.jpeg" Aspect="Fill" /&gt;
&lt;/Border&gt;</pre><p class="list-inset">You may <a id="_idIndexMarker1168"/>have noticed a difference between the triggers in this listing versus the triggers in the <code>Sticks</code> control template. In <code>Sticks</code>, the <code>IsVisible</code> attribute was set on <code>Image</code>, not <code>Border</code>, and you may want to know why that is. The explanation is simple; if the border is not visible, it will not receive <code>TapGuesture</code> events. The <code>Grid</code> element cannot register <code>GestureRecognizer</code>, so the event cannot be captured there either. </p></li> </ol>
<p>The <code>ControlTemplates</code> that are needed for the stick and stone images are in place; now, they need to be associated with the <code>GamePieceView</code> control elements. A <code>Style</code> can set the <code>ControlTemplate</code> property of a <code>GamePieceView</code> element, but how will it determine that this element is a stick or a stone? <code>Style</code> elements have a <code>Class</code> property that can be used to further refine which styles are applied to a control. If the control <a id="_idIndexMarker1169"/>has a matching class name listed in its <code>StyleClass</code> attribute, then that <code>Style</code> element is applied. Let’s use sticks as an example, by following these steps:</p>
<ol>
<li>Add a new <code>Style</code> element to the <code>ContentView.Resources</code> element, as shown in the following listing:<pre class="source-code">
&lt;Style TargetType="controls:GamePieceView"
        Class="Stick"&gt;
    &lt;Setter Property="ControlTemplate"
            Value="{StaticResource StickViewControlTemplate}" /&gt;
&lt;/Style&gt;</pre><p class="list-inset">This style is only applied to elements that are of the <code>GamePiece</code> type and have the <code>Stick</code> class listed in the <code>StyleClass</code> attribute. A matching element might look like the following:</p><pre class="source-code">&lt;<strong class="bold">controls:GamePieceView</strong> Grid.Row="0" Grid.Column="1" <strong class="bold">StyleClass="Stick"</strong> 
                        GamePiecePosition="01" GamePieceState="{Binding Game.Sticks[0]}" GamePieceDirection="Horizontal" /&gt;</pre><p class="list-inset">The highlighted sections show the parts of the control that are used to match the <code>Style</code> element. <code>StyleClass</code> can have more than one name listed; just use a comma to separate the names.</p></li> <li>Add a new <code>Style</code> element. This time, it will be to apply <code>StoneViewControlTemplate</code>, as shown in the following listing:<pre class="source-code">
&lt;Style TargetType="controls:GamePieceView"
        Class="Stone"&gt;
    &lt;Setter Property="ControlTemplate"
            Value="{StaticResource StoneViewControlTemplate}" /&gt;
&lt;/Style&gt;</pre></li> </ol>
<p>That is all <a id="_idIndexMarker1170"/>that is required for the stick and stone elements to be added to the game board grid. To add the remaining elements, follow these steps:</p>
<ol>
<li>There are seven rows of sticks: four rows of three and three rows of four. They are nearly identical, but not quite. Locate the <code>Grid</code> that defines the gameboard; it will already have the corner dots added. Right after the 16 dot elements, add the following listing for the first row of sticks:<pre class="source-code">
&lt;controls:GamePieceView Grid.Row="0" Grid.Column="1" StyleClass="Stick"
                        GamePiecePosition="01" GamePieceState="{Binding Game.Sticks[0]}" GamePieceDirection="Horizontal" /&gt;
&lt;controls:GamePieceView Grid.Row="0" Grid.Column="3" StyleClass="Stick" 
                        GamePiecePosition="02" GamePieceState="{Binding Game.Sticks[1]}" GamePieceDirection="Horizontal" /&gt;
&lt;controls:GamePieceView Grid.Row="0" Grid.Column="5" StyleClass="Stick" 
                        GamePiecePosition="03" GamePieceState="{Binding Game.Sticks[2]}" GamePieceDirection="Horizontal" /&gt;</pre><p class="list-inset">Each stick in the first row is displayed horizontally. Each stick is given its own position in the <code>GamePiecePosition</code> attribute and <code>GamePieceState</code> is bound to the <code>Game.Sticks</code> object for this stick. The <code>Sticks</code> array is zero-based so the indexes for the array are one less than <code>GamePiecePosition</code>.</p></li> <li>Add the <a id="_idIndexMarker1171"/>code for the second row of sticks using the following listing:<pre class="source-code">
&lt;controls:GamePieceView Grid.Row="1" Grid.Column="0" StyleClass="Stick"
                        GamePiecePosition="04" GamePieceState="{Binding Game.Sticks[3]}" GamePieceDirection="Vertical" /&gt;
&lt;controls:GamePieceView Grid.Row="1" Grid.Column="2" StyleClass="Stick" 
                        GamePiecePosition="05" GamePieceState="{Binding Game.Sticks[4]}" GamePieceDirection="Vertical" /&gt;
&lt;controls:GamePieceView Grid.Row="1" Grid.Column="4" StyleClass="Stick" 
                        GamePiecePosition="06" GamePieceState="{Binding Game.Sticks[5]}" GamePieceDirection="Vertical" /&gt;
&lt;controls:GamePieceView Grid.Row="1" Grid.Column="6" StyleClass="Stick"
                        GamePiecePosition="07" GamePieceState="{Binding Game.Sticks[6]}" GamePieceDirection="Vertical" /&gt;</pre><p class="list-inset">These elements are all <code>Vertical</code> instead of <code>Horizontal</code>; otherwise, they follow the same pattern as the previous step. Keep on going to add the remaining rows.</p></li> <li>Use the <a id="_idIndexMarker1172"/>following listing to add the third row of sticks:<pre class="source-code">
&lt;controls:GamePieceView Grid.Row="2" Grid.Column="1" StyleClass="Stick"
                        GamePiecePosition="08" GamePieceState="{Binding Game.Sticks[7]}" GamePieceDirection="Horizontal" /&gt;
&lt;controls:GamePieceView Grid.Row="2" Grid.Column="3" StyleClass="Stick"
                        GamePiecePosition="09" GamePieceState="{Binding Game.Sticks[8]}" GamePieceDirection="Horizontal" /&gt;
&lt;controls:GamePieceView Grid.Row="2" Grid.Column="5" StyleClass="Stick"
                        GamePiecePosition="10" GamePieceState="{Binding Game.Sticks[9]}" GamePieceDirection="Horizontal" /&gt;</pre></li> <li>Use the following listing to add the fourth row of sticks:<pre class="source-code">
&lt;controls:GamePieceView Grid.Row="3" Grid.Column="0" StyleClass="Stick"
                        GamePiecePosition="11" GamePieceState="{Binding Game.Sticks[10]}" GamePieceDirection="Vertical" /&gt;
&lt;controls:GamePieceView Grid.Row="3" Grid.Column="2" StyleClass="Stick"
                        GamePiecePosition="12" GamePieceState="{Binding Game.Sticks[11]}" GamePieceDirection="Vertical" /&gt;
&lt;controls:GamePieceView Grid.Row="3" Grid.Column="4" StyleClass="Stick"
                        GamePiecePosition="13" GamePieceState="{Binding Game.Sticks[12]}" GamePieceDirection="Vertical" /&gt;
&lt;controls:GamePieceView Grid.Row="3" Grid.Column="6" StyleClass="Stick"
                        GamePiecePosition="14" GamePieceState="{Binding Game.Sticks[13]}" GamePieceDirection="Vertical" /&gt;</pre></li> <li>Use the <a id="_idIndexMarker1173"/>following listing to add the fifth row of sticks:<pre class="source-code">
&lt;controls:GamePieceView Grid.Row="4" Grid.Column="1" StyleClass="Stick"
                        GamePiecePosition="15" GamePieceState="{Binding Game.Sticks[14]}" GamePieceDirection="Horizontal" /&gt;
&lt;controls:GamePieceView Grid.Row="4" Grid.Column="3" StyleClass="Stick"
                        GamePiecePosition="16" GamePieceState="{Binding Game.Sticks[15]}" GamePieceDirection="Horizontal" /&gt;
&lt;controls:GamePieceView Grid.Row="4" Grid.Column="5" StyleClass="Stick" 
                        GamePiecePosition="17" GamePieceState="{Binding Game.Sticks[16]}" GamePieceDirection="Horizontal" /&gt;</pre></li> <li>Use the <a id="_idIndexMarker1174"/>following listing to add the sixth row of sticks:<pre class="source-code">
&lt;controls:GamePieceView Grid.Row="5" Grid.Column="0" StyleClass="Stick"
                        GamePiecePosition="18" GamePieceState="{Binding Game.Sticks[17]}" GamePieceDirection="Vertical" /&gt;
&lt;controls:GamePieceView Grid.Row="5" Grid.Column="2" StyleClass="Stick"
                        GamePiecePosition="19" GamePieceState="{Binding Game.Sticks[18]}" GamePieceDirection="Vertical" /&gt;
&lt;controls:GamePieceView Grid.Row="5" Grid.Column="4" StyleClass="Stick"
                        GamePiecePosition="20" GamePieceState="{Binding Game.Sticks[19]}" GamePieceDirection="Vertical" /&gt;
&lt;controls:GamePieceView Grid.Row="5" Grid.Column="6" StyleClass="Stick" 
                        GamePiecePosition="21" GamePieceState="{Binding Game.Sticks[20]}" amePieceDirection="Vertical" /&gt;</pre></li> <li>Use the following listing to add the seventh row of sticks:<pre class="source-code">
&lt;controls:GamePieceView Grid.Row="6" Grid.Column="1" StyleClass="Stick"
                        GamePiecePosition="22" GamePieceState="{Binding Game.Sticks[21]}" GamePieceDirection="Horizontal" /&gt;
&lt;controls:GamePieceView Grid.Row="6" Grid.Column="3" StyleClass="Stick"
                        GamePiecePosition="23" GamePieceState="{Binding Game.Sticks[22]}" GamePieceDirection="Horizontal" /&gt;
&lt;controls:GamePieceView Grid.Row="6" Grid.Column="5" StyleClass="Stick" 
                        GamePiecePosition="24" GamePieceState="{Binding Game.Sticks[23]}" GamePieceDirection="Horizontal" /&gt;</pre></li> <li>The sticks <a id="_idIndexMarker1175"/>are all added, so now we need to add the stones. Use the following listing to add the nine <code>Stone</code> elements to the game board <code>Grid</code> control following the sticks:<pre class="source-code">
&lt;controls:GamePieceView Grid.Row="1" Grid.Column="1" StyleClass="Stone" GamePieceState="{Binding Game.Stones[0]}" /&gt;
&lt;controls:GamePieceView Grid.Row="1" Grid.Column="3" StyleClass="Stone" GamePieceState="{Binding Game.Stones[1]}" /&gt;
&lt;controls:GamePieceView Grid.Row="1" Grid.Column="5" StyleClass="Stone" GamePieceState="{Binding Game.Stones[2]}" /&gt;
&lt;controls:GamePieceView Grid.Row="3" Grid.Column="1" StyleClass="Stone" GamePieceState="{Binding Game.Stones[3]}" /&gt;
&lt;controls:GamePieceView Grid.Row="3" Grid.Column="3" StyleClass="Stone" GamePieceState="{Binding Game.Stones[4]}" /&gt;
&lt;controls:GamePieceView Grid.Row="3" Grid.Column="5" StyleClass="Stone" GamePieceState="{Binding Game.Stones[5]}" /&gt;
&lt;controls:GamePieceView Grid.Row="5" Grid.Column="1" StyleClass="Stone" GamePieceState="{Binding Game.Stones[6]}" /&gt;
&lt;controls:GamePieceView Grid.Row="5" Grid.Column="3" StyleClass="Stone" GamePieceState="{Binding Game.Stones[7]}" /&gt;
&lt;controls:GamePieceView Grid.Row="5" Grid.Column="5" StyleClass="Stone" GamePieceState="{Binding Game.Stones[8]}" /&gt;</pre></li> </ol>
<p>This is a <a id="_idIndexMarker1176"/>wrap on the game app. You can now test out the project in the next section.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor892"/>Testing the completed project</h2>
<p>This project <a id="_idIndexMarker1177"/>has spanned two chapters, with <em class="italic">Chapter 9</em><em class="italic">, Setting Up a Backend for a Game Using Azure Services , and this chapter, Building a Real-Time Game</em>. Since this is a two-player turn-based game, getting all the components configured correctly can be a challenge. Follow these steps to test out your game locally on Windows:</p>
<ol>
<li>The first step is to get the service running in the background. In Visual Studio, right-click the <code>SticksAndStones.Functions</code> project and select <strong class="bold">Debug</strong> | <strong class="bold">Start Without Debugging</strong> or press <em class="italic">Ctrl</em> + <em class="italic">F5</em>. </li>
</ol>
<div><div><img alt="Figure 10.15 – Starting the Azure Functions service" src="img/B19214_10_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Starting the Azure Functions service</p>
<p class="list-inset">That should <a id="_idIndexMarker1178"/>launch a terminal window with the Azure Functions service running.</p>
<ol>
<li value="2">Now, two clients are needed to play the game. On Windows, that means the Windows client and the Android client. Start with the Windows client first, and use the same method that was used for Functions. Make sure the Windows target is selected in the <strong class="bold">Debug</strong> options:</li>
</ol>
<div><div><img alt="Figure 10.16 – Selecting Windows as the Debug target" src="img/B19214_10_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Selecting Windows as the Debug target</p>
<ol>
<li value="3">Right-click <a id="_idIndexMarker1179"/>the <code>SticksAndStones.App</code> project and then select <strong class="bold">Debug</strong> | <strong class="bold">Start Without Debugging</strong> or press <em class="italic">Ctrl</em> + <em class="italic">F5</em>. A new window should open with the login page displayed.</li>
<li>Now, switch the <strong class="bold">Debug</strong> target to Android:</li>
</ol>
<div><div><img alt="Figure 10.17 – Selecting Android as the Debug target" src="img/B19214_10_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Selecting Android as the Debug target</p>
<ol>
<li value="5">Now, either use <em class="italic">F5</em> to debug the app in an Android emulator, or <em class="italic">Ctrl</em> + <em class="italic">F5</em> to just run the app.</li>
<li>Log in to each app using a different email and gamer tag.</li>
</ol>
<div><div><img alt="Figure 10.18 – Log in to the game" src="img/B19214_10_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – Log in to the game</p>
<ol>
<li value="7">Challenge <a id="_idIndexMarker1180"/>the other player to a match!</li>
</ol>
<div><div><img alt="Figure 10.19 – Challenge issued" src="img/B19214_10_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.19 – Challenge issued</p>
<ol>
<li value="8">Try to <a id="_idIndexMarker1181"/>best yourself in a game of <em class="italic">Sticks </em><em class="italic">and Stones</em>!</li>
</ol>
<div><div><img alt="Figure 10.20 – The match has started" src="img/B19214_10_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.20 – The match has started</p>
<p class="callout-heading">Android: cleartext http traffic to 10.0.2.2 not permitted</p>
<p class="callout">If you are attempting to test the game using the Android client, you will probably hit this error when you try to send a move to the server. Fortunately, the resolution is easy. Open the <code>MainApplication.cs</code> file in the <code>Platforms/Android</code> folder and modify the <code>Application</code> attribute on the <code>MainApplication</code> class to match the following:</p>
<p class="callout"><code>[Application(UsesCleartextTraffic = </code><code>true)]</code></p>
<p>If you <a id="_idIndexMarker1182"/>encounter any errors or something just<a id="_idTextAnchor893"/> doesn’t work the way you expect it to, go back through all the steps and make sure you didn’t miss anything. Otherwise, congratulations on making it through this project.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor894"/>Summary</h1>
<p>That’s that! Excellent work! There is so much in the chapter that it is hard to keep this summary short. In this chapter, we created a game app that connects to our backend. We created a service that managed the calls to the backend service and handled errors, all asynchronously. We have learned how to respond to messages from SignalR, and how to send and receive messages within the app using the <code>IMessenger</code> interface. We created custom controls and used them across multiple pages. We learned how to style an app with XAML styling, how to use control templates, and how to select them using styles. We explored routes and how they work in a multi-page .NET MAUI app. We examined triggers and how we can use them to update the interface without using C# code and converters.</p>
<p>Now, reward yourself and challenge a friend to a match in your new game.</p>
<p>In the next chapter, we will dive into Blazor and .NET MAUI together.</p>
</div>
</body></html>