<html><head></head><body>
		<div><h1 id="_idParaDest-155" class="chapter-number"><a id="_idTextAnchor221"/>5</h1>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor222"/>Error Handling</h1>
			<p>Welcome to <a href="B21069_05.xhtml#_idTextAnchor221"><em class="italic">Chapter 5</em></a>! You are doing great! In this chapter, we will discuss a new approach provided by functional programming to handle errors. We will do so through the help of the following sections:</p>
			<ul>
				<li>Traditional error handling in C#</li>
				<li>The Result type</li>
				<li>Railway-Oriented Programming (ROP)</li>
				<li>Designing your own error-handling mechanisms</li>
				<li>Practical tips for functional error handling</li>
				<li>Traditional versus functional error handling comparison</li>
				<li>Patterns and anti-patterns in functional error handling</li>
			</ul>
			<p>Steve is really upset today because he spent the last three days fixing errors and didn’t have time to write even a single line of new code. Moreover, benchmark tests showed that the code with try-catch blocks works much slower than the one without them and that there are a lot of these blocks in his code. So he decided to ask Julia whether there was a way to handle errors better with a functional approach. She sent Steve a big article about error handling using functional programming.</p>
			<p>As you can see, this chapter delves into the functional techniques, which will help you not just handle errors but do so in a manner that’s clean, efficient, and maintainable. And before we dig in, let’s look at these three self-assessment tasks.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor223"/>Task 1 – Custom error types and result usage</h1>
			<p>Here’s a <a id="_idIndexMarker259"/>function in Steve’s tower defense game that upgrades a tower <a id="_idIndexMarker260"/>and returns a boolean. Refactor it to return a <code>Result</code> type instead, with a custom error when the upgrade fails:</p>
			<pre class="source-code">
public bool UpgradeTower(Tower tower)
{
     // Tower upgrading logic...
     if (/* upgrade fails */)
     {
                  return false;
     }
     return true;
}</pre>			<h1 id="_idParaDest-158"><a id="_idTextAnchor224"/>Task 2 – Utilizing ROP for validation and processing</h1>
			<p>Steve has <a id="_idIndexMarker261"/>a workflow that involves parsing, validating, and <a id="_idIndexMarker262"/>processing an enemy spawn. Refactor it <a id="_idIndexMarker263"/>using <strong class="bold">Railway-Oriented Programming</strong> (<strong class="bold">ROP</strong>) to improve the error-handling flow:</p>
			<pre class="source-code">
public void ProcessEnemySpawn(string enemyData)
{
     var parsedData = ParseEnemyData(enemyData);
     if (parsedData.IsValid)
     {
                  var validation = ValidateEnemySpawn(parsedData);
                  if (validation.IsValid)
                  {
                      SpawnEnemy(validation.Enemy);
                  }
     }
}</pre>			<h1 id="_idParaDest-159"><a id="_idTextAnchor225"/>Task 3 – Implementing a Retry mechanism using functional techniques</h1>
			<p>Write <a id="_idIndexMarker264"/>a function that <a id="_idIndexMarker265"/>implements a retry mechanism for a flaky tower firing operation and returns a <code>Result</code> type. The function should retry the operation a specified number of times before returning an error:</p>
			<pre class="source-code">
public bool TowerFire(Tower tower, Enemy enemy)
{
     // Sometimes works and returns true
     // sometimes doesn't and returns false
}</pre>			<p>If these tasks are easy for you, you are free to skip this chapter for now and return later when you have read all the others or have any questions about error handling.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor226"/>Traditional error handling in C#</h1>
			<p>Every C# <a id="_idIndexMarker266"/>developer, whether a novice or an expert, has come across <a id="_idIndexMarker267"/>the try-catch block. It’s been the main protection against unexpected behaviors and system failures. Let’s revisit this conventional mechanism before understanding what the functional paradigm offers.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor227"/>try-catch blocks</h2>
			<p>The try-catch <a id="_idIndexMarker268"/>block attempts an operation, and if it fails, the control is <a id="_idIndexMarker269"/>transferred to the catch block, ensuring the application doesn’t crash. For instance, let’s say we’re working with a simple file-reading operation:</p>
			<pre class="source-code">
string content;
try
{
    content = File.ReadAllText("file.txt");
}
catch (FileNotFoundException ex)
{
    content = string.Empty;
    LogException(ex, "File not found. Check the file location.");
}
catch (IOException ex)
{
    content = string.Empty;
    LogException(ex, "An IO error occurred. Try again.");
}</pre>			<p>Here, we log <a id="_idIndexMarker270"/>different <a id="_idIndexMarker271"/>messages depending on the type of the raised exception.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor228"/>Exceptions</h2>
			<p>C# offers <a id="_idIndexMarker272"/>two primary <a id="_idIndexMarker273"/>categories of exception types:</p>
			<ul>
				<li><code>NullReferenceException</code>, <code>IndexOutOfRangeException</code>, or the ones we just encountered: <code>FileNot</code><strong class="source-inline">
FoundException</strong> and <code>IOException</code>.</li>
				<li><strong class="bold">Application exceptions</strong>: These are custom exceptions created for specific application <a id="_idIndexMarker276"/>needs. Let’s say you’re developing <a id="_idIndexMarker277"/>an e-commerce platform, and you need an exception for an out-of-stock item. Here’s how you might design it:<pre class="source-code">
public class OutOfStockException : Exception
{
    public OutOfStockException(string itemName) : base($"{itemName} is out of stock.") { }
}</pre><p class="list-inset">Later, check the item’s stock:</p><pre class="source-code">if(item.Stock &lt;= 0)
{
    throw new OutOfStockException(item.Name);
}</pre></li>			</ul>
			<p>Custom exceptions empower developers to communicate specific error scenarios, ensuring that error handling is informative.</p>
			<p>Steve slumped in his chair, frustration etched on his face. He’d spent the last three days battling bugs in his tower defense game, and the codebase was becoming a maze of try-catch blocks. Just then, his phone buzzed. It was a message from Julia.</p>
			<p>Julia: <em class="italic">How’s the game </em><em class="italic">coming along?</em></p>
			<p>Steve: <em class="italic">Not great. I’m drowning in error handling. Got any functional programming wisdom </em><em class="italic">for me?</em></p>
			<p>Julia: <em class="italic">As a matter of fact, I do. Let me tell you about a more elegant way to </em><em class="italic">handle errors...</em></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor229"/>The Result type</h1>
			<p>Instead of dealing with exceptions after they occur, what if we designed our code to anticipate <a id="_idIndexMarker278"/>and elegantly communicate errors? Please welcome the <code>Result</code> type, a cornerstone of functional error handling.</p>
			<p>At its core, the <code>Result</code> type encapsulates either a successful value or an error. It might sound similar to exceptions, but there’s a key difference: errors become first-class citizens, directly influencing your application’s flow.</p>
			<p>In contrast to the <code>Option</code> type that can only distinguish existing values from non-existing, the <code>Result</code> type describes the error that happened and, more importantly, can be used to chain methods application. We will discuss that technique later in this chapter.</p>
			<p>For instance, traditionally, a method might return a value or throw an exception:</p>
			<pre class="source-code">
public Product GetProduct(int id)
{
    var product = _productRepository.Get(id);
    if(product is null)
    {
        throw new ProductNotFoundException($"Product with ID {id} was not found.");
    }
    return product;
}</pre>			<p>In contrast, with the <code>Result</code> type, the method communicates both its intention and possible failure more explicitly:</p>
			<pre class="source-code">
public Result&lt;Product, string&gt; GetProduct(int id)
{
    var product = _productRepository.Get(id);
    if(product is null)
    {
        return Result&lt;Product, string&gt;.Fail($"Product with ID {id} not found.");
    }
    return Result&lt;Product, string&gt;.Success(product);
}</pre>			<p>This code <a id="_idIndexMarker279"/>is more explicit. No hidden exceptions. No unexpected behaviors. Just clear, honest communication.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor230"/>Implementing the Result type</h2>
			<p>Let’s dive <a id="_idIndexMarker280"/>a bit deeper and see what a general implementation of the <code>Result</code> type looks like:</p>
			<pre class="source-code">
public class Result&lt;T, E&gt;
{
    private T _value;
    private E _error;
    public bool IsSuccess { get; private set; }
    private Result(T value, E error, bool isSuccess)
    {
        _value = value;
        _error = error;
        IsSuccess = isSuccess;
    }
    public T Value
    {
        get
        {
            if (!IsSuccess) throw new InvalidOperationException("Cannot fetch Value from a failed result.");
            return _value;
        }
    }
    public E Error
    {
        get
        {
            if (IsSuccess) throw new InvalidOperationException("Cannot fetch Error from a successful result.");
            return _error;
        }
    }
    public static Result&lt;T, E&gt; Success(T value) =&gt; new Result&lt;T, E&gt;(value, default, true);
    public static Result&lt;T, E&gt; Fail(E error) =&gt; new Result&lt;T, E&gt;(default, error, false);
}</pre>			<h2 id="_idParaDest-165"><a id="_idTextAnchor231"/>Using the Result type</h2>
			<p>Usage <a id="_idIndexMarker281"/>of the <code>Result</code> type leads to a more systematic approach to error handling:</p>
			<pre class="source-code">
var productResult = GetProduct(42);
if (productResult.IsSuccess)
{
    DisplayProduct(productResult.Value);
}
else
{
    ShowError(productResult.Error);
}</pre>			<p>No more scattered try-catch blocks. Now errors become just another path your code can take, leading to more predictable and maintainable systems.</p>
			<p>The <code>Result</code> type fundamentally shifts how we view errors: not as sudden interruptions, but as anticipated outcomes. As we go further, you’ll see how this functional tool integrates with other advanced techniques, creating a new approach to error management.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor232"/>Railway-Oriented Programming (ROP)</h1>
			<p>Steve <a id="_idIndexMarker282"/>was intrigued by the Result type, but he still had questions.</p>
			<p>Steve: <em class="italic">This is great for individual operations, but what about when I have a series of steps that all need </em><em class="italic">to succeed?</em></p>
			<p>Julia: <em class="italic">I’m glad you asked. Let me introduce you to </em><em class="italic">Railway-Oriented Programming.</em></p>
			<p>At the heart of functional programming is the drive for predictability and clarity. Although traditional error-handling techniques are powerful, they often scatter the error-handling logic across the codebase. ROP, inspired by this railway track-switching analogy, offers a cohesive, structured approach to error handling, keeping your code both expressive and streamlined.</p>
			<p>ROP provides <a id="_idIndexMarker283"/>a systematic way to manage errors in a sequence of operations. Think of it as managing two parallel tracks: the success track (happy path) and the error track. Operations run sequentially on the happy path. However, as soon as an error is encountered, the flow is diverted to the error track, bypassing subsequent operations.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor233"/>The essence of Bind</h2>
			<p>Central to ROP is the Bind function. It takes an operation and a subsequent operation to execute if <a id="_idIndexMarker284"/>the first one succeeds. However, if an <a id="_idIndexMarker285"/>error occurs, it bypasses the second operation, and the error is immediately propagated:</p>
			<pre class="source-code">
public static Result&lt;Tout, E&gt; Bind&lt;Tin, Tout, E&gt;(this Result&lt;Tin, E&gt; input, Func&lt;Tin, Result&lt;Tout, E&gt;&gt; bindFunc)
{
    return input.IsSuccess ? bindFunc(input.Value) : Result&lt;Tout, E&gt;.Fail(input.Error);
}</pre>			<h2 id="_idParaDest-168"><a id="_idTextAnchor234"/>Chaining operations with Bind</h2>
			<p>Imagine <a id="_idIndexMarker286"/>a series <a id="_idIndexMarker287"/>of steps where we do the following:</p>
			<ol>
				<li>Parse input</li>
				<li>Validate parsed data</li>
				<li>Transform validated data</li>
				<li>Store transformed data</li>
			</ol>
			<p>ROP lets <a id="_idIndexMarker288"/>us express <a id="_idIndexMarker289"/>these steps as a cohesive chain:</p>
			<pre class="source-code">
public Result&lt;bool, string&gt; HandleData(string input)
{
    return ParseInput(input)
           .Bind(parsedData =&gt; ValidateData(parsedData))
           .Bind(validData =&gt; TransformData(validData))
           .Bind(transformedData =&gt; StoreData(transformedData));
}</pre>			<h2 id="_idParaDest-169"><a id="_idTextAnchor235"/>Composable error handling with ROP</h2>
			<p>A strength of ROP is that it fosters composable error handling. Each component of your application <a id="_idIndexMarker290"/>can define its own error scenarios, and when these components are chained together, the combined operation can handle a broader spectrum of errors without losing granularity.</p>
			<p>Consider <a id="_idIndexMarker291"/>having separate components for user input, business logic, and database operations. Each component can have its own error definitions. When operations from these components are chained together, the system can seamlessly handle errors from any component, creating a unified error-handling strategy.</p>
			<pre class="source-code">
public Result&lt;DBResponse, CompositeError&gt; ProcessUserRequest(string userInput)
{
    return GetUserInput(userInput)
           .Bind(inputData =&gt; ApplyBusinessLogic(inputData))
           .Bind(businessData =&gt; UpdateDatabase(businessData));
}</pre>			<p>Here, <code>CompositeError</code> might encapsulate errors from input validation, business logic violations, and database failures.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor236"/>Handling diverse error types</h2>
			<p>One <a id="_idIndexMarker292"/>challenge with a straightforward ROP implementation is that it assumes a unified error type <a id="_idIndexMarker293"/>throughout the chain. However, real-world scenarios often involve diverse error types. To manage this, you can introduce a mechanism to convert or map error types:</p>
			<pre class="source-code">
public static Result&lt;TOut, EOut&gt; Bind&lt;TIn, TOut, EIn, EOut&gt;(
    this Result&lt;TIn, EIn&gt; input,
    Func&lt;TIn, Result&lt;TOut, EOut&gt;&gt; bindFunc,
    Func&lt;EIn, EOut&gt; errorMap)
{
    return input.IsSuccess ? bindFunc(input.Value) : Result&lt;TOut, EOut&gt;.Fail(errorMap(input.Error));
}</pre>			<p>This enhanced <code>Bind</code> function maps one error type to another, enabling more complex and varied error-handling scenarios.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor237"/>Benefits of isolation</h2>
			<p>ROP isolates error handling, ensuring that your main business logic remains uncluttered. When <a id="_idIndexMarker294"/>reading through the core operations, one can focus purely on the main logic without being distracted by error-handling intricacies.</p>
			<p>For developers, this isolation simplifies cognitive load. They can trust the system to handle errors and focus on crafting the primary logic. When debugging, the structured nature of ROP makes it crystal clear where things might have gone off the rails, thus, simplifying the troubleshooting process.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor238"/>Extending ROP for asynchronous operations</h2>
			<p>In <a id="_idIndexMarker295"/>modern applications, a lot <a id="_idIndexMarker296"/>of methods are asynchronous. ROP can be adapted <a id="_idIndexMarker297"/>to asynchronous operations using techniques such as <code>BindAsync</code>:</p>
			<pre class="source-code">
public static async Task&lt;Result&lt;TOut, E&gt;&gt; BindAsync&lt;TIn, TOut, E&gt;(
    this Result&lt;TIn, E&gt; input,
    Func&lt;TIn, Task&lt;Result&lt;TOut, E&gt;&gt;&gt; bindFuncAsync)
{
    return input.IsSuccess ? await bindFuncAsync(input.Value) : Result&lt;TOut, E&gt;.Fail(input.Error);
}</pre>			<p>With <code>BindAsync</code>, you can now chain asynchronous operations just as easily, making ROP versatile in both synchronous and asynchronous contexts.</p>
			<p>Having delved deep into ROP, we witness a paradigm shift in how we perceive and handle errors. Instead of treating errors as exceptional events, ROP integrates them into the very logic of our application, resulting in more robust, readable, and maintainable code.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor239"/>Designing your own error-handling mechanisms</h1>
			<p>As Steve <a id="_idIndexMarker298"/>began refactoring his code, he realized that the pre-built solutions didn’t quite fit all his game’s unique scenarios.</p>
			<p>Steve: <em class="italic">Julia, I think I need to create some custom error types for my game. Is </em><em class="italic">that okay?</em></p>
			<p>Julia: <em class="italic">More than okay. In fact, let’s talk about how you can design your own error-handling mechanisms tailored to your </em><em class="italic">game’s needs.</em></p>
			<p>When creating your own functional error handling, a <code>Result</code> type is a prime starting point. Let it <a id="_idIndexMarker299"/>be generic enough to cater to different scenarios:</p>
			<pre class="source-code">
public class Result&lt;TSuccess, TFailure&gt;
{
    public TSuccess SuccessValue { get; }
    public TFailure FailureValue { get; }
    public bool IsSuccess { get; }
    //... Constructors and other methods ...
}</pre>			<h2 id="_idParaDest-174"><a id="_idTextAnchor240"/>Use factory methods for creation</h2>
			<p>Factory <a id="_idIndexMarker300"/>methods provide clarity and ease of use:</p>
			<pre class="source-code">
public static class Result
{
    public static Result&lt;T, string&gt; Success&lt;T&gt;(T value) =&gt; new Result&lt;T, string&gt;(value, default, true);
    public static Result&lt;T, string&gt; Fail&lt;T&gt;(string error) =&gt; new Result&lt;T, string&gt;(default, error, false);
}</pre>			<p>The usage is as follows:</p>
			<pre class="source-code">
var successResult = Result.Success("Processed!");
var errorResult = Result.Fail("Oops! Something went wrong.");</pre>			<h2 id="_idParaDest-175"><a id="_idTextAnchor241"/>Extend with Bind</h2>
			<p>Use the <code>Bind</code> method <a id="_idIndexMarker301"/>to add more fluency:</p>
			<pre class="source-code">
public Result&lt;TOut, TFailure&gt; Bind&lt;TOut&gt;(Func&lt;TSuccess, Result&lt;TOut, TFailure&gt;&gt; func)
{
    return IsSuccess ? func(SuccessValue) : new Result&lt;TOut, TFailure&gt;(default, FailureValue, false);
}</pre>			<h2 id="_idParaDest-176"><a id="_idTextAnchor242"/>Customize error types</h2>
			<p>Rather than <a id="_idIndexMarker302"/>just using strings, create specific error types to convey detailed information:</p>
			<pre class="source-code">
public class ValidationError
{
    public string FieldName { get; }
    public string ErrorDescription { get; }
    //… Constructor and methods ...
}</pre>			<p>Then, use them as follows:</p>
			<pre class="source-code">
public Result&lt;User, ValidationError&gt; ValidateUser(User user)
{
    if (string.IsNullOrEmpty(user.Name))
    {
        return Result.Fail&lt;User, ValidationError&gt;(new ValidationError("Name", "Name cannot be empty."));
    }
    //... Other validations ...
    return Result.Success&lt;User, ValidationError&gt;(user);
}</pre>			<h2 id="_idParaDest-177"><a id="_idTextAnchor243"/>Leverage extension methods</h2>
			<p>Extension <a id="_idIndexMarker303"/>methods can offer enhanced readability:</p>
			<pre class="source-code">
public static class ResultExtensions
{
    public static bool IsFailure&lt;TSuccess, TFailure&gt;(this Result&lt;TSuccess, TFailure&gt; result)
    {
        return !result.IsSuccess;
    }
}</pre>			<p>Use them as follows:</p>
			<pre class="source-code">
if (result.IsFailure())
{
    // Handle the failure scenario
}</pre>			<h2 id="_idParaDest-178"><a id="_idTextAnchor244"/>Integration with existing code</h2>
			<p>By wrapping <a id="_idIndexMarker304"/>legacy methods, we can seamlessly integrate with non-functional code:</p>
			<pre class="source-code">
public static Result&lt;T, Exception&gt; TryExecute&lt;T&gt;(Func&lt;T&gt; action)
{
    try
    {
        return Result.Success(action());
    }
    catch (Exception ex)
    {
        return Result.Fail&lt;T, Exception&gt;(ex);
    }
}</pre>			<h2 id="_idParaDest-179"><a id="_idTextAnchor245"/>Always iterate and refine</h2>
			<p>Custom <a id="_idIndexMarker305"/>error mechanisms are living entities. As your application grows, keep iterating and refining based on feedback and new requirements.</p>
			<p>Designing your own error-handling mechanisms not only empowers you with tailor-fit solutions but also deepens your understanding of the functional paradigm. Dive in, get hands-on, and watch as your applications become models of robustness and clarity.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor246"/>Practical tips for functional error handling</h1>
			<p>A week <a id="_idIndexMarker306"/>into refactoring, Steve was making progress, but he felt overwhelmed by all the new concepts.</p>
			<p>Steve: <em class="italic">I’m not sure I’m doing </em><em class="italic">this right…</em></p>
			<p>Julia: <em class="italic">Don’t worry, it’s normal to feel that way when learning a new paradigm. Let me share some practical tips that’ll help you navigate this </em><em class="italic">new territory.</em></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor247"/>Avoid null with options</h2>
			<p>Try to <a id="_idIndexMarker307"/>never return null. It sounds simple, yet it’s a pitfall waiting to trip up the unwary. Why? Because nulls are very easy to get, however, it is much harder to handle them properly and if you don’t do it well, it can lead to cascading failures:</p>
			<pre class="source-code">
public User FindUser(string login)
{
    // This can return null!
    return users.FirstOrDefault(u =&gt; u.Login.Equals(login));
}</pre>			<p>Turn this around:</p>
			<pre class="source-code">
public Option&lt;User&gt; FindUser(string login)
{
    var user = users.FirstOrDefault(u =&gt; u.Login.Equals(login));
    return user is not null ? Option.Some(user) : Option.None&lt;User&gt;();
}</pre>			<h2 id="_idParaDest-182"><a id="_idTextAnchor248"/>Logging errors</h2>
			<p>Logging <a id="_idIndexMarker308"/>is vital, but try to avoid side effects that ruin the functional approach. A good idea here is to delegate the act of logging, keeping functions pure:</p>
			<pre class="source-code">
public Result&lt;Order, Error&gt; ProcessOrder(int id, Action&lt;string&gt; logError)
{
    if (invalid(id))
    {
        logError($"Invalid order id: {id}");
        return Result.Fail&lt;Order, Error&gt;(new Error("Invalid ID"));
    }
    // ... process further ...
}</pre>			<h2 id="_idParaDest-183"><a id="_idTextAnchor249"/>Two strategies To replace exceptions</h2>
			<p>I know <a id="_idIndexMarker309"/>that in some cases your first <a id="_idIndexMarker310"/>instinct might be to use a try-catch. Resist. Use these strategies to stick to the functional paradigm.</p>
			<h3>Safe execution</h3>
			<p>Create a <a id="_idIndexMarker311"/>method that will execute any code in an exception-free way:</p>
			<pre class="source-code">
public static Result&lt;T, E&gt; SafelyExecute&lt;T, E&gt;(Func&lt;T&gt; function, E error)
{
    try
    {
        return Result.Success(function());
    }
    catch
    {
        return Result.Fail&lt;T, E&gt;(error);
    }
}</pre>			<p>The <a id="_idIndexMarker312"/>usage is as follows:</p>
			<pre class="source-code">
var orderResult = SafelyExecute(() =&gt; GetOrder(orderId), new DatabaseError("Failed getting order"));</pre>			<h3>Fallback</h3>
			<p>For some <a id="_idIndexMarker313"/>operations, you can provide a fallback result:</p>
			<pre class="source-code">
public Result&lt;Order, string&gt; GetOrderWithFallback(int orderId)
{
    var orderResult = GetOrder(orderId);
    return orderResult.IsSuccess ? orderResult : Result.Success(new DefaultOrder());
}</pre>			<h2 id="_idParaDest-184"><a id="_idTextAnchor250"/>Anticipate errors – make it predictable</h2>
			<p>Instead of <a id="_idIndexMarker314"/>waiting for errors, anticipate them. Validate your data before using it in processing. You can do it manually or with the help of guard clauses:</p>
			<pre class="source-code">
public Result&lt;Order, string&gt; ProcessOrder(int id)
{
    if (id &lt; 0)
    {
        return Result.Fail&lt;Order, string&gt;("ID cannot be negative.");
    }
    // ... further processing ...
}</pre>			<h2 id="_idParaDest-185"><a id="_idTextAnchor251"/>Embrace composition</h2>
			<p>Use <a id="_idIndexMarker315"/>function composition for cleaner <a id="_idIndexMarker316"/>error handling:</p>
			<pre class="source-code">
var result = GetData()
             .Bind(Validate)
             .Bind(Process)
             .Bind(Save);</pre>			<h2 id="_idParaDest-186"><a id="_idTextAnchor252"/>Educate your team</h2>
			<p>Lastly, ensure <a id="_idIndexMarker317"/>everyone’s on board. A consistent approach to error handling ensures clarity and reliability.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor253"/>Traditional versus functional error handling comparison</h1>
			<p>Every <a id="_idIndexMarker318"/>developer experiences it sooner or later: running into an error while coding. But as the coding world <a id="_idIndexMarker319"/>has changed, so has the way we deal with these problems. Let’s look at the clear differences between the old and new ways of handling errors in C# and understand why this new approach is becoming more popular.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor254"/>The traditional way</h2>
			<p>In <a id="_idIndexMarker320"/>traditional OOP, exceptions are the go-to mechanism:</p>
			<ul>
				<li><strong class="bold">Throwing exceptions</strong>: We <a id="_idIndexMarker321"/>rely on <a id="_idIndexMarker322"/>system or custom exceptions when things go wrong:<pre class="source-code">
public User GetUser(int id)
{
    if (id &lt; 0)
        throw new ArgumentOutOfRangeException(nameof(id));
    // ... fetch the user ...
}</pre></li>				<li><strong class="bold">Catching exceptions</strong>: Use <a id="_idIndexMarker323"/>try-catch <a id="_idIndexMarker324"/>blocks to handle and possibly recover from errors:<pre class="source-code">
try
{
    var user = GetUser(-5);
}
catch (ArgumentOutOfRangeException ex)
{
    Console.WriteLine(ex.Message);
}</pre></li>			</ul>
			<p>The <a id="_idIndexMarker325"/>benefits of the traditional way are as follows:</p>
			<ul>
				<li>Most developers are accustomed to using exceptions, making it a well-understood approach</li>
				<li>Fine-grained error handling is possible with different exception types</li>
			</ul>
			<p>However, there <a id="_idIndexMarker326"/>are also some drawbacks:</p>
			<ul>
				<li>Exceptions can disrupt the natural flow of code execution</li>
				<li>Exception handling introduces a performance overhead</li>
				<li>It can be hard to reason about and can lead to “exception hell”</li>
			</ul>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor255"/>The functional way</h2>
			<p>Functional <a id="_idIndexMarker327"/>programming prefers a more graceful form of <a id="_idIndexMarker328"/>error handling:</p>
			<ul>
				<li><strong class="bold">Use constructs such as </strong><strong class="bold">Result types</strong>:<pre class="source-code">
public Result&lt;User, string&gt; GetUser(int id)
{
    if (id &lt; 0)
    {
        return Result.Fail&lt;User, string&gt;("ID cannot be negative.");
    }
    // ... get and return the user ...
}</pre><p class="list-inset">Consuming <a id="_idIndexMarker329"/>the preceding function becomes straightforward:</p><pre class="source-code">var userResult = GetUser(-5);
if (userResult.IsFailure)
{
    Console.WriteLine(userResult.Error);
}</pre></li>				<li><strong class="bold">ROP</strong>:<pre class="source-code">
var result = GetData()
             .Bind(ValidateData)
             .Bind(ProcessData);</pre></li>			</ul>
			<p>The <a id="_idIndexMarker330"/>benefits of the functional way are as follows:</p>
			<ul>
				<li>Clearer intent and flow</li>
				<li>Avoids the exception performance overhead</li>
				<li>Easier chaining of operations</li>
			</ul>
			<p>There <a id="_idIndexMarker331"/>are also a couple of drawbacks:</p>
			<ul>
				<li>Developers may be required t<a id="_idTextAnchor256"/>o learn new concepts</li>
				<li>Less granularity compared to traditional exceptions</li>
			</ul>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor257"/>Comparative analysis</h2>
			<p>Let’s <a id="_idIndexMarker332"/>take a closer look at <a id="_idIndexMarker333"/>the differences between traditional exception handling and functional programming when it comes to performance, readability, and maintainability:</p>
			<ul>
				<li><strong class="bold">Performance</strong>: Traditional exception handling can be slower due to the overhead of creating exception objects and unwinding the stack. FP offers a more predictable performance profile.</li>
				<li><strong class="bold">Readability</strong>: try-catch blocks can clutter code, making it less readable. Often these blocks contain also code that cannot throw exceptions. FP encapsulates errors within data, making code flow apparent.</li>
				<li><strong class="bold">Maintainability</strong>: Traditional methods spread error handling, making maintenance complex. FP encourages isolated, pure functions, which simplifies debugging and testing.</li>
			</ul>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor258"/>Making the shift</h2>
			<p>Starting <a id="_idIndexMarker334"/>with FP error handling might seem odd, especially if you’ve lived all your life in the traditional paradigm. But once you make the switch, the benefits are profound. Remember:</p>
			<ul>
				<li>Start small. Refactor a section of your codebase and observe the difference.</li>
				<li>Embrace pure functions. They’ll simplify your error-handling story.</li>
				<li>Educate your team. A shared understanding is pivotal.</li>
			</ul>
			<p>In conclusion, while <a id="_idIndexMarker335"/>traditional error handling has served us well for years, the functional paradigm offers a fresher, more systematic approach. By representing errors as first-class citizens within our data types, we write more maintainable code. The choice between the two often boils down to the problem domain, team familiarity, and project requirements. But if you want clarity and expressiveness, the functional route is the way.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor259"/>Patterns and anti-patterns in functional error handling</h1>
			<p>Functional <a id="_idIndexMarker336"/>programming has redefined our approach to error handling. By bringing errors into the realm of data, we ensure safer, more predictable code. But as with any paradigm, there are right ways and pitfalls. Let’s look at the patterns that can help you and also the anti-patterns.</p>
			<p>There are several patterns that can help you handle errors in a more functional way. These patterns are designed to enhance the quality, readability, and maintainability of your code. Here are some of the key patterns to consider:</p>
			<ul>
				<li><strong class="bold">Rich custom </strong><strong class="bold">error types</strong><p class="list-inset">Instead of generic strings or codes, use detailed types to describe errors:</p><pre class="source-code">
public Result&lt;User, UserError&gt; GetUser(int id)
{
    if (id &lt; 0)
        return Result.Fail&lt;User, UserError&gt;(new InvalidIdError(id));
    // ... other checks and logic ...
}</pre></li>				<li><strong class="bold">Leveraging composition</strong><p class="list-inset">Chain <a id="_idIndexMarker337"/>multiple functions seamlessly to maintain clear logic flow:</p><pre class="source-code">
GetData()
    .Bind(Validate)
    .Bind(Process)
    .Bind(Store);</pre></li>				<li><strong class="bold">Pattern matching </strong><strong class="bold">with errors</strong><p class="list-inset">This ensures every error scenario is addressed:</p><pre class="source-code">
switch (GetUser(5))
{
    case Success&lt;User&gt; user:
        // Handle user
        break;
    case Failure&lt;UserError&gt; error when error.Value is InvalidIdError:
        // Handle invalid ID error
        break;
    // ... other cases ...
}</pre></li>				<li><strong class="bold">Isolating </strong><strong class="bold">side effects</strong><p class="list-inset">Keep your <a id="_idIndexMarker338"/>core logic pure and handle side effects, such as logging or I/O, separately:</p><pre class="source-code">
public Result&lt;TSuccess, TError&gt; ComputeValue&lt;TSuccess, TError&gt;(Data data)
{
    if (data.IsValid())
    {
        TSuccess value = PerformComputation(data);
        return new Result&lt;TSuccess, TError&gt;(value);
    }
    else
    {
        TError errorDetails = GetErrorDetails(data);
        return new Result&lt;TSuccess, TError&gt;(errorDetails);
    }
}</pre><p class="list-inset">The usage is as follows:</p><pre class="source-code">var result = ComputeValue&lt;MySuccessType, MyErrorType&gt;(data);
if (result.IsSucces<a id="_idTextAnchor260"/>s)
{
    HandleSuccess(result.Value);
}
else
{
    HandleError(result.Error);
}</pre></li>			</ul>
			<p>There <a id="_idIndexMarker339"/>are also some anti-patterns that can make your error handling more complex and error-prone:</p>
			<ul>
				<li><code>Result</code> types can confuse other software developers:</p><pre class="source-code">
public Result&lt;int, string&gt; Compute()
{
    if (condition)
    {
        throw new Exception("Oops!");
    }
    // ... return some result ...
}</pre></li>				<li><strong class="bold">Unclear errors</strong><p class="list-inset">Returning vague errors eliminates the value of FP’s expressive error handling:</p><pre class="source-code">
return Result.Fail&lt;User, string&gt;("Something went wrong.");</pre></li>				<li><strong class="bold">Ignoring errors</strong><p class="list-inset">Just getting the value without addressing potential failures breaks the idea of FP error handling. An example is when you have a Result type as a method output, but don’t check it:</p><pre class="source-code">
var result = GetData();
ProcessData(result.Value);</pre></li>				<li><strong class="bold">Overcomplicating with </strong><strong class="bold">custom types</strong><p class="list-inset">While <a id="_idIndexMarker340"/>detailed error types are beneficial, creating one for every minor deviation can overcomplicate things. Please don’t do errors like these:</p><pre class="source-code">
public class NameMissingFirstCharacterError : NameError { /* ... */ }
public class NameMissingLastCharacterError : NameError { /* ... */ }</pre></li>			</ul>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor261"/>Exercises</h2>
			<p>Steve was eager to apply his newfound knowledge of functional error handling to his tower defense game. Julia, impressed by his enthusiasm, presented him with three challenges to test his understanding and improve his code.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor262"/>Exercise 1</h2>
			<p>Here’s the function that upgrades a tower and returns a boolean. Refactor it to return a <code>Result</code> type instead, with a custom error when the payment fails:</p>
			<pre class="source-code">
public bool UpgradeTower(Tower tower)
{
     // Tower upgrading logic...
     if (/* upgrade fails */)
     {
                  return false;
     }
     return true;
}</pre>			<h2 id="_idParaDest-195"><a id="_idTextAnchor263"/>Exercise 2</h2>
			<p>Steve has a workflow that involves parsing, validating, and processing an enemy spawn. Refactor it using Railway-Oriented Programming to improve the error-handling flow:</p>
			<pre class="source-code">
public void ProcessEnemySpawn(string enemyData)
{
     var parsedData = ParseEnemyData(enemyData);
     if (parsedData.IsValid)
     {
              var validation = ValidateEnemySpawn(parsedData);
              if (validation.IsValid)
              {
                  SpawnEnemy(validation.Enemy);
              }
     }
}</pre>			<h2 id="_idParaDest-196"><a id="_idTextAnchor264"/>Exercise 3</h2>
			<p>Write a function that implements a retry mechanism for a flaky operation and returns a <code>Result</code> type. The function should retry the operation a specified number of times before returning an error:</p>
			<pre class="source-code">
public bool TowerFire(Tower tower, Enemy enemy)
{
     // Sometimes works and returns true
     // sometimes doesn't and returns false
}</pre>			<p>Try to do these exercises yourself, and when finished, you can check your work with the following solutions.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor265"/>Solutions</h1>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor266"/>Exercise 1</h2>
			<p>Refactor the method to use a <code>Result</code> type with a custom error that encapsulates failure details:</p>
			<pre class="source-code">
public enum TowerUpgradeError
{
     InsufficientResources,
     MaxLevelReached,
     TowerDestroyed
}
public Result&lt;bool, TowerUpgradeError&gt; UpgradeTower(Tower tower)
{
     // Tower upgrading logic...
     if (/* insufficient resources */)
     {
                  return Result.Fail&lt;bool, TowerUpgradeError&gt;(TowerUpgradeError.InsufficientResources);
     }
     else if (/* max level reached */)
     {
                  return Result.Fail&lt;bool, TowerUpgradeError&gt;(TowerUpgradeError.MaxLevelReached);
     }
     else if (/* tower is destroyed */)
     {
                  return Result.Fail&lt;bool, TowerUpgradeError&gt;(TowerUpgradeError.TowerDestroyed);
     }
     return Result.Ok&lt;bool, TowerUpgradeError&gt;(true);
}</pre>			<h2 id="_idParaDest-199"><a id="_idTextAnchor267"/>Exercise 2</h2>
			<p>Steve refactored his enemy spawning system using ROP, creating a clean pipeline for processing enemy data:</p>
			<pre class="source-code">
public Result&lt;Enemy, EnemySpawnError&gt; ProcessEnemySpawn(string enemyData)
{
     return ParseEnemyData(enemyData)
                  .Bind(ValidateEnemySpawn)
                  .Bind(SpawnEnemy);
}
// Assume these methods are implemented to return Result&lt;T, EnemySpawnError&gt;
public Result&lt;ParsedEnemyData, EnemySpawnError&gt; ParseEnemyData(string data) { /* ... */ }
public Result&lt;ValidatedEnemy, EnemySpawnError&gt; ValidateEnemySpawn(ParsedEnemyData data) { /* ... */ }
public Result&lt;Enemy, EnemySpawnError&gt; SpawnEnemy(ValidatedEnemy enemy) { /* ... */ }</pre>			<h2 id="_idParaDest-200"><a id="_idTextAnchor268"/>Exercise 3</h2>
			<p>For the flaky tower firing mechanism, Steve implemented a retry function that attempts the operation multiple times before giving up:</p>
			<pre class="source-code">
public Result&lt;bool, string&gt; TryTowerFire(Tower tower, Enemy enemy, int maxRetries)
{
     for (int attempt = 0; attempt &lt; maxRetries; attempt++)
     {
                  if (TowerFire(tower, enemy))
                  {
                      return Result.Ok&lt;bool, string&gt;(true);
                  }
     }
     return Result.Fail&lt;bool, string&gt;($"Tower firing failed after {maxRetries} attempts.");
}</pre>			<p>These exercises take you from understanding to applying functional principles in practical coding scenarios. They encourage you to think and code functionally, recognizing error handling not as an afterthought but as an integral part of the coding process.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor269"/>Summary</h1>
			<p>In this chapter, we progressed from traditional methods of error handling to functional approaches. We identified the strengths, challenges, patterns, and anti-patterns of the FP way.</p>
			<p>Functional programming offers not just a way to code, but a mindset shift. By treating errors as data, we benefit from type safety, expressiveness, and predictability.</p>
			<p>However, our goal is not to get rid of all exceptions and nulls but to create more readable and resilient software. Luckily, with the development of C#, functional error handling is becoming easier and more integrated.</p>
			<p>Like all paradigms, functional programming is not a silver bullet. While errors as data can be powerful, you have to remember the real world where your code runs. Networking failures, database outages, and hardware malfunctions are realities. Striking a balance between functional purity and real-world pragmatism is key.</p>
			<p>A couple of times in this chapter, we used delegates, and in order to get a better understanding of them and their role in functional programming, in the next chapter we will delve into the concepts of higher-order functions and delegates.</p>
		</div>
	</body></html>