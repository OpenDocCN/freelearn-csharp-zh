- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Push Your Application with Performance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用性能推动你的应用程序
- en: With each new release of **ASP.NET**, the ASP.NET team continues to make performance
    a priority. When ASP.NET Core introduced a different way of building web applications
    with streamlined enhancements (including **middleware** and **Razor Pages**) the
    focus was continually on improving the C# language as well. These technologies
    are what give ASP.NET its spark and speed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个新版本的**ASP.NET**发布，ASP.NET团队继续将性能作为优先事项。当ASP.NET Core引入了一种使用流线化增强（包括**中间件**和**Razor
    Pages**）构建Web应用程序的新方法时，重点始终是改进C#语言。正是这些技术赋予了ASP.NET其火花和速度。
- en: ASP.NET is cross-platform, has built-in support for dependency injection, is
    open source, and is one of the fastest-performing frameworks in the industry.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET是跨平台的，内置了对依赖注入的支持，是开源的，并且在行业中是性能最快的框架之一。
- en: While this is an ASP.NET book with a chapter on performance, there will be additional
    aspects of web development that are equally as important. We’ll stay focused on
    ASP.NET and C# performance as much as possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一本关于性能的ASP.NET书籍，但其中还将包含同样重要的Web开发的其他方面。我们将尽可能专注于ASP.NET和C#的性能。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Why Performance Matters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能为何重要
- en: Establishing Baselines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立基线
- en: Applying Performance Best Practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用性能最佳实践
- en: By the end of this chapter, you’ll understand the importance of performance
    in your application, how to establish client-side and server-side baselines and
    techniques on how to optimize the client-side resources for faster delivery, and
    finally, how to deliver content faster with server-side performance techniques
    such as optimizing HTML, implementing various caching techniques, and identifying
    slow queries.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解性能在你应用程序中的重要性，如何建立客户端和服务器端基线和优化客户端资源以提高交付速度的技术，以及最后如何通过优化HTML、实施各种缓存技术以及识别慢查询等服务器端性能技术来更快地交付内容。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'When creating baselines and testing performance for your web application, there
    is a need for an IDE or editor you feel comfortable with for writing code. We
    recommend using your favorite editor to view the GitHub repository. Our recommendations
    include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建基线和测试Web应用程序的性能时，你需要一个你感到舒适的IDE或编辑器来编写代码。我们建议使用你最喜欢的编辑器来查看GitHub仓库。我们的建议包括以下内容：
- en: '**Visual Studio** (preferably the latest version)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio**（最好是最新版本）'
- en: '**Visual** **Studio Code**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual** **Studio Code**'
- en: '**JetBrains Rider**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JetBrains Rider**'
- en: The code for this chapter is located in Packt Publishing’s GitHub repository,
    located at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于Packt Publishing的GitHub仓库中，网址为[https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices)。
- en: Why Performance Matters
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能为何重要
- en: Performance takes many shapes and forms in web development since there are so
    many moving pieces to make a website always ready and available to our users.
    As a developer, if someone asked for help regarding a website being slow, what
    advice would you recommend? It’s a tough question to answer verbally without examining
    the website. With websites, there may be times when performance isn’t just one
    technology; the problem may be more than one bottleneck.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，性能有多种形态和形式，因为有许多移动部件使网站始终准备好并可供我们的用户使用。作为一名开发者，如果有人请求关于网站速度慢的帮助，你会推荐什么建议？在没有检查网站的情况下，这是一个难以用言语回答的问题。对于网站来说，可能有时性能不仅仅是一种技术；问题可能不止一个瓶颈。
- en: For instance, when loading a web page in the browser, do you see content appear,
    but images take a long time and paint row by row? How about accessing the database?
    Do you have slow queries where the server takes a minute to retrieve records?
    Are web APIs performing at more than two seconds for each request?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当在浏览器中加载网页时，你是否看到内容出现，但图片加载很慢，并且逐行渲染？关于访问数据库呢？你是否遇到服务器需要一分钟才能检索记录的慢查询？Web
    API的每个请求是否超过两秒？
- en: As you can see, performance is an analysis of an entire website including browser,
    server, C#, API, and database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，性能是对整个网站的分析，包括浏览器、服务器、C#、API和数据库。
- en: Amazon published a study calculating that if a page load slowed down by even
    1 second on their website, it could cost them $1.6B in sales.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊发布了一项研究，计算如果他们的网站页面加载速度慢了1秒钟，可能会给他们造成16亿美元的销售额损失。
- en: How one second could cost Amazon $1.6 billion in sales
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一秒钟可能让亚马逊损失 16 亿美元销售额
- en: The research was reported by Fast Company and is located at [https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales](https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这项研究由 Fast Company 报道，可在 [https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales](https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales)
    找到。
- en: While this is a head-turner, there is a more recent article on how Netflix replaced
    React with plain JavaScript (more commonly called Vanilla JavaScript). This provided
    huge gains in performance. In the case study, it reported one page had 300 KB
    of JavaScript, which is a lot. However, compared to other websites such as [CNN.com](http://CNN.com)
    (4.4 MB of JavaScript) and [USAToday.com](http://USAToday.com) (1.5 MB of JavaScript),
    300 KB of JavaScript is considered minimal.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很引人注目，但最近还有一篇关于 Netflix 如何用纯 JavaScript（通常称为 Vanilla JavaScript）取代 React
    的文章。这带来了巨大的性能提升。在案例研究中，它报告了一个页面有 300 KB 的 JavaScript，这相当多。然而，与其他网站如 [CNN.com](http://CNN.com)（4.4
    MB 的 JavaScript）和 [USAToday.com](http://USAToday.com)（1.5 MB 的 JavaScript）相比，300
    KB 的 JavaScript 被认为是微不足道的。
- en: A Netflix web performance case study
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix 网络性能案例研究
- en: Google Chrome Engineering Lead *Addy Osmani* wrote an article about the performance
    gains Netflix experienced through optimizations. The case study can be found at
    [https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9](https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Google Chrome 工程主管 *Addy Osmani* 写了一篇关于 Netflix 通过优化获得性能提升的文章。案例研究可在 [https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9](https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9)
    找到。
- en: With these specific scenarios and case studies, many companies took notice and
    focused primarily on performance. Even Microsoft focused its efforts on performance
    by submitting its results to TechEmpower’s industry framework benchmark results.
    As a result of the constant improvement, ASP.NET is now ranked as one of the fastest
    platforms for the web.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些特定的场景和案例研究，许多公司开始关注性能。甚至微软也通过向 TechEmpower 的行业框架基准结果提交其结果，将精力集中在性能上。由于持续的改进，ASP.NET
    现在被评为最快的网络平台之一。
- en: TechEmpower framework benchmark results
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TechEmpower 框架基准结果
- en: 'Every year, TechEmpower updates its results in a chart that can be found at
    [https://techempower.com/benchmarks/](https://techempower.com/benchmarks/). As
    of July 19, 2022, ASP.NET is ranked #9 in performance.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每年，TechEmpower 都会更新其结果，这些结果可以在 [https://techempower.com/benchmarks/](https://techempower.com/benchmarks/)
    的图表中找到。截至 2022 年 7 月 19 日，ASP.NET 在性能排名中位列第 9。
- en: 'Finally, with Google as the most dominant player in the search engine industry,
    it attached how fast a page loads to your **search engine result pages** (**SERPs**).
    Translation: the speed of your site is one of the ranking factors for how high
    you are in the search results (which we’ll discuss in the next section).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为搜索引擎行业中最具主导地位的玩家，谷歌将页面加载速度与你的 **搜索引擎结果页面**（**SERPs**）联系起来。也就是说，你网站的加载速度是影响你在搜索结果中排名高低的重要因素（我们将在下一节中讨论）。
- en: Google using site speed in web search ranking
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌在网页搜索排名中使用网站速度
- en: On Google’s blog, they mentioned that page speed is another factor taken into
    account when ranking your website. The post is found at [https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking](https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌的博客上，他们提到，在排名你的网站时，页面速度是考虑的另一个因素。该帖子可在 [https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking](https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking)
    找到。
- en: Performance is one of my favorite topics. The idea of making small changes that
    lead to large performance gains is definitely exciting. It also can be visually
    apparent as well. This chapter is meant to assist in using techniques and tools
    to identify those performance issues on any website.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是我最喜欢的主题之一。通过进行小的改动来获得大的性能提升的想法无疑是令人兴奋的。它也可以直观地显现出来。本章旨在帮助使用技术和工具来识别任何网站上的性能问题。
- en: The good news is, in past chapters, we’ve already mentioned specific ways to
    improve performance that we’ll refer back to when relevant. As I’ve said in [*Chapter
    4*](B19493_04.xhtml#_idTextAnchor086), performance should be the top priority
    when building ASP.NET web applications, with security running a close second.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，在过去的章节中，我们已经提到了一些提高性能的具体方法，当相关时我们将回顾这些方法。正如我在[*第4章*](B19493_04.xhtml#_idTextAnchor086)中说的，性能在构建ASP.NET
    Web应用程序时应该是首要任务，其次是安全性。
- en: Performance has always been a mix between an art and a science as you’ll see
    in some of the sections in this chapter. There is *perceived* performance and
    then there’s *actual* performance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 性能始终是艺术和科学的结合，正如你将在本章的一些部分中看到的那样。有**感知**性能，然后有**实际**性能。
- en: Actual performance is a measurement when an activity or task immediately responds
    and notifies the user that it’s finished. An immediate response is a goal. Perceived
    performance is a subjective measurement where users experience an activity or
    task as quick, even when it isn’t. One example of perceived performance is when
    the user requests a web page and the browser renders the page immediately. The
    content continues to load in the background while keeping the user’s focus by
    allowing them to scroll through the page waiting for the additional content. As
    a result, users think the site is “fast” because it responded immediately. Spinners
    and progress bars are other ways to achieve perceived performance while something
    is processing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际性能是一个测量活动或任务立即响应并通知用户已完成的活动。立即响应是一个目标。感知性能是一个主观的测量，用户将活动或任务体验为快速，即使它并不真正如此。感知性能的一个例子是当用户请求一个网页，浏览器立即渲染页面。内容在后台继续加载，同时通过允许用户滚动页面等待额外内容来保持用户的注意力。因此，用户认为网站“快速”，因为它立即响应。旋转器和进度条是其他在处理过程中实现感知性能的方法。
- en: While perceived performance is a way to divert a user’s attention while waiting
    for a process to complete, this chapter will focus more on actual performance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然感知性能是在等待过程完成时分散用户注意力的方式，但本章将更多地关注实际性能。
- en: In the next section, we’ll learn how to create baselines for client-side and
    server-side code using public web tools and specific server tools such as **Visual
    Studio Performance Profiler**, **Benchmark.net**, and **Application Insights**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用公共Web工具和特定的服务器工具，如**Visual Studio性能分析器**、**Benchmark.net**和**Application
    Insights**，来创建客户端和服务器端代码的基线。
- en: Establishing Baselines
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立基线
- en: So, how do you know you’re experiencing a slowdown on a website? Is it because
    of a recent release of a software product, or a new NuGet package installed causing
    the slowdown?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何知道你在网站上遇到了速度减慢的问题？是因为最近发布了软件产品，还是安装了新的NuGet包导致速度减慢？
- en: While identifying an issue, you may be asking yourself, “what changed?” But
    the question everyone *should* be asking is “how do you measure performance?”
    In order to measure it, there needs to be a baseline of what’s expected when it
    comes to performance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别问题时，你可能自己在问，“发生了什么变化？”但每个人都**应该**问的问题是“你如何衡量性能？”为了衡量它，需要有一个关于性能预期的基线。
- en: Each part of your application should include performance tests. Whether it’s
    the frontend, a C# subsystem, a web API, or the database, the proper systems should
    be in place to notify the team when a system isn’t performing as expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的每个部分都应该包含性能测试。无论是前端、C#子系统、Web API还是数据库，都应建立适当的系统来通知团队当系统未按预期表现时。
- en: Using Client-Side Tools
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用客户端工具
- en: Issues on the client side are mostly due to load times, delivery of resources
    not found (such as HTML pages, images, CSS, and JavaScript), or JavaScript errors
    in general. However, this doesn’t mean the entire problem is on the client.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的问题大多是由于加载时间、未找到的资源（如HTML页面、图像、CSS和JavaScript）的交付，或者一般的JavaScript错误。然而，这并不意味着整个问题都在客户端。
- en: Creating a baseline for your client-side code should be conducted through a
    testing tool such as **Cypress** or **Selenium** during development and recording
    the duration of tests. Compare the latest scenarios with previous test results
    to see where there is a time difference.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，应该通过像**Cypress**或**Selenium**这样的测试工具为客户端代码创建基线，并记录测试的持续时间。将最新的场景与之前的测试结果进行比较，以查看时间差异在哪里。
- en: Another approach for determining a baseline is to use various tools on the web
    such as the tools listed in this section. Think of these tools as like taking
    your car to the mechanic for maintenance. These tools scan your public website,
    analyze all aspects of the site, and provide a report on how to fix each issue
    found.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 确定基线的另一种方法是使用网络上的各种工具，例如本节中列出的工具。将这些工具想象成像把您的车送到机械师那里进行维护一样。这些工具扫描您的公共网站，分析网站的所有方面，并提供一份关于如何修复每个发现的问题的报告。
- en: 'Some of the tools to give you insights into the performance of a website include
    the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可以为您提供网站性能洞察的工具包括以下内容：
- en: '**Google PageSpeed Insights** ([https://pagespeed.web.dev](https://pagespeed.web.dev)):
    Google uses its search engine to rank your site and provides an exceptional tool
    to help with website problems.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google PageSpeed Insights** ([https://pagespeed.web.dev](https://pagespeed.web.dev)):
    Google 使用其搜索引擎对您的网站进行排名，并提供一个出色的工具来帮助解决网站问题。'
- en: '**Lighthouse** ([https://developer.chrome.com/docs/lighthouse/](https://developer.chrome.com/docs/lighthouse/)):
    If your site isn’t publicly accessible to analyze from one of these tools, you
    can use the Lighthouse extension to run tests on the site in-house. Lighthouse
    produces a full report of recommendations on how to make your site perform better.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lighthouse** ([https://developer.chrome.com/docs/lighthouse/](https://developer.chrome.com/docs/lighthouse/)):
    如果您的网站无法公开访问以供这些工具分析，您可以使用 Lighthouse 扩展在内部运行网站测试。Lighthouse 会生成一份全面的报告，推荐如何使您的网站表现更好。'
- en: '**GTMetrix** ([https://gtmetrix.com](https://gtmetrix.com)): GTMetrix is a
    tool I’ve been using over the years and it continues to impress and improve each
    year. It provides a performance summary, speed visualization, and recommendations.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GTMetrix** ([https://gtmetrix.com](https://gtmetrix.com)): 多年来我一直使用 GTMetrix，并且它每年都在给人留下深刻印象并不断改进。它提供性能摘要、速度可视化和推荐。'
- en: '**Google Search Console** ([https://search.google.com/search-console](https://search.google.com/search-console)):
    Google created this for administrators of websites to identify performance issues
    along with other general maintenance tools, such as what people are typing into
    Google to find your website.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Search Console** ([https://search.google.com/search-console](https://search.google.com/search-console)):
    Google 为网站管理员创建了这个工具，用于识别性能问题以及其他一般维护工具，例如人们输入 Google 搜索以找到您的网站的内容。'
- en: '**DevTools**: DevTools is a panel of web developer tools located inside of
    Google Chrome, Mozilla Firefox, Apple Safari, and Microsoft Edge to help web developers
    analyze web pages, and it’s becoming the IDE of the internet. Pressing F12 in
    the browser will open the panel.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevTools**: DevTools 是位于 Google Chrome、Mozilla Firefox、Apple Safari 和 Microsoft
    Edge 内的网页开发者工具面板，用于帮助开发者分析网页，并且它正成为互联网的 IDE。在浏览器中按 F12 键将打开此面板。'
- en: These tools are great for gauging how well your site performs on the internet
    and how it performs based on the last revision. If your last release takes 0.5
    seconds to load and the latest release now takes three seconds, it’s time to examine
    what changed. What better way to check this than to automate the process (refer
    to [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031)) by reporting on the performance
    issue before deploying the site?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具非常适合评估您的网站在互联网上的表现以及基于最新修订的表现如何。如果您的上一个版本加载需要 0.5 秒，而最新版本现在需要三秒，那么是时候检查一下发生了什么变化。有什么比在部署网站之前通过报告性能问题来自动化这个过程（参考
    [*第 2 章*](B19493_02.xhtml#_idTextAnchor031)）更好的方法吗？
- en: Using Server-Side Tools
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用服务器端工具
- en: With ASP.NET, creating baselines for your code is just as easy with a number
    of tools at your disposal.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ASP.NET，创建代码基线与您可用的各种工具一样简单。
- en: In this section, we’ll review some of the tools available for creating a baseline
    for your code such as Visual Studio, Benchmark.net, Application Insights, and
    other tools such as NDepend.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些可用于创建代码基线的工具，例如 Visual Studio、Benchmark.net、Application Insights
    以及其他工具，如 NDepend。
- en: Visual Studio Performance Tools
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio 性能工具
- en: With Visual Studio being a solid IDE in the industry, the ability to gauge C#
    performance was becoming more prevalent because if code was slow, developers wanted
    a way to locate the bottleneck.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Visual Studio 在业界是一个稳固的 IDE，因此评估 C# 性能的能力变得越来越普遍，因为如果代码运行缓慢，开发者希望有一种方法来定位瓶颈。
- en: '![Figure 10.1 – Performance Profiler in Visual Studio 2022](img/B19493_10_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – Visual Studio 2022 中的性能分析器](img/B19493_10_01.jpg)'
- en: Figure 10.1 – Performance Profiler in Visual Studio 2022
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Visual Studio 2022 中的性能分析器
- en: 'When starting **Performance Profiler**, you’re presented with a list of options:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动 **性能分析器** 时，您将看到一个选项列表：
- en: '![Figure 10.2 – List of available options before running Performance Profiler](img/B19493_10_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 运行性能分析器之前可用的选项列表](img/B19493_10_02.jpg)'
- en: Figure 10.2 – List of available options before running Performance Profiler
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 运行性能分析器之前可用的选项列表
- en: As you can see, there are a vast number of options crossing multiple touchpoints.
    For example, there is a **Database** option to look at how your queries are performing
    in the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有大量选项跨越多个接触点。例如，有一个**数据库**选项来查看您的查询在应用程序中的性能。
- en: The metrics for databases are similar to the **Entity Framework** details explaining
    the duration it took to execute the query. Another option is identifying where
    async/await problems can occur as well as memory usage and object allocation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的度量与解释查询执行持续时间的Entity Framework细节相似。另一个选项是确定异步/等待问题可能发生的地方，以及内存使用和对象分配。
- en: Benchmark.net
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Benchmark.net
- en: If there are smaller, self-contained methods required to test, one of the best
    tools around for micro-benchmarking is Benchmark.net ([https://benchmarkdotnet.org/](https://benchmarkdotnet.org/)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要较小的、自包含的方法进行测试，Benchmark.net是进行微基准测试的最佳工具之一（[https://benchmarkdotnet.org/](https://benchmarkdotnet.org/))。
- en: Benchmark.net takes specific methods and tests them with different scenarios.
    The one caveat to this is that the Benchmark project *must* be a console application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Benchmark.net对特定方法进行测试，并使用不同的场景进行测试。需要注意的是，Benchmark项目*必须*是一个控制台应用程序。
- en: 'As an example, if we wanted to test the age-old debate as to which is faster
    between string concatenation or a `StringBuilder` class, we would write two benchmark
    tests to determine which was faster, as shown in the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想测试一个古老的争论，即字符串连接和`StringBuilder`类哪个更快，我们会编写两个基准测试来确定哪个更快，如下所示：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we created a string in one scenario and an instance of
    a `StringBuilder()` class in another. To accomplish the same goal, we add 10,000
    ‘a’s and start the benchmark.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在一个场景中创建了一个字符串，在另一个场景中创建了一个`StringBuilder()`类的实例。为了达到相同的目标，我们添加了10,000个‘a’并开始基准测试。
- en: 'Based on the results in *Figure 10**.3*, the obvious choice is to use `StringBuilder()`
    for performing large string concatenations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图10.3中的结果，显然的选择是使用`StringBuilder()`进行大型字符串连接：
- en: '![Figure 10.3 – Comparing the performance of a string concatenation versus
    a StringBuilder() class](img/B19493_10_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 比较字符串连接与`StringBuilder()`类的性能](img/B19493_10_03.jpg)'
- en: Figure 10.3 – Comparing the performance of a string concatenation versus a StringBuilder()
    class
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 比较字符串连接与`StringBuilder()`类的性能
- en: In regards to creating a baseline, we added an additional parameter to our `[Benchmark]`
    attribute in our first scenario, called `Baseline`, and set it to `true`. This
    tells Benchmark.net to use this as our baseline when measuring the performance
    of our other methods. You can have any number of methods to achieve the same result,
    but everything will be compared to the one method with `Baseline=true` in the
    Benchmark attribute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建基线，我们在第一个场景中为我们的`[Benchmark]`属性添加了一个额外的参数，称为`Baseline`，并将其设置为`true`。这告诉Benchmark.net在测量其他方法的性能时使用这个作为我们的基线。你可以有任意数量的方法来实现相同的结果，但所有内容都将与`Benchmark`属性中`Baseline=true`的方法进行比较。
- en: For small, compact methods, Benchmark.net is definitely a great tool for providing
    insight into ways to create faster code using micro-optimizations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型、紧凑的方法，Benchmark.net无疑是提供关于如何使用微优化创建更快代码洞察的绝佳工具。
- en: Application Insights
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用洞察
- en: 'Microsoft’s Application Insights is meant to be a general-purpose analysis
    tool for collecting telemetry about everything your application does. Once set
    up, Application Insights can collect data about the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的应用洞察（Application Insights）旨在成为一个通用的分析工具，用于收集关于应用程序所做一切活动的遥测数据。一旦设置好，应用洞察可以收集以下数据：
- en: Requests – web pages and API calls
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求 – 网页和API调用
- en: Dependencies – what is your application loading behind the scenes?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项 – 应用程序在幕后加载了什么？
- en: Exceptions – every exception your application throws
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常 – 应用程序抛出的每个异常
- en: Performance counters – automatically identifying slowdowns
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能计数器 – 自动识别减速
- en: Heartbeats – is the application still up and running?
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 心跳 – 应用程序是否仍在运行？
- en: Logs – a centralized location for collecting all types of logs for your application
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录 – 收集应用程序所有类型日志的集中位置
- en: When adding Application Insights, Application Insights *does* require an Azure
    subscription.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加 Application Insights 时，Application Insights *确实*需要一个 Azure 订阅。
- en: Application Insights additional material
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Application Insights 补充材料
- en: There are various ways to set up Application Insights and way too many to cover
    in this chapter. For more information on Application Insights and how to set it
    up for your application, navigate to [https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core](https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Application Insights 有多种方式，本章中涵盖的太多，无法一一介绍。有关 Application Insights 的更多信息以及如何为你的应用程序设置它，请访问
    [https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core](https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core)。
- en: 'Some other recommendations for creating baselines and identifying bottlenecks
    include the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基线和识别瓶颈的一些其他建议包括以下内容：
- en: '**JetBrains dotTrace/dotMemory** – dotTrace is a performance profiler tool,
    and dotMemory is a memory profiler tool. Both are exceptional tools and perform
    deep dives into how well your application performs. dotTrace and dotMemory give
    you the ability to compare a baseline of results against another set of results
    (“comparing snapshots”).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JetBrains dotTrace/dotMemory** – dotTrace 是一个性能分析工具，dotMemory 是一个内存分析工具。这两个工具都非常出色，能够深入了解你的应用程序性能。dotTrace
    和 dotMemory 允许你比较一组结果与另一组结果的基础（“比较快照”）。'
- en: '**RedGate ANTS Performance Profiler/Memory Profiler** – With the ability to
    profile .NET code and memory allocations, the ANTS Performance and Memory Profiler
    demonstrates a similar approach to performance and memory profiling while conducting
    a deep-dive analysis while your code is running.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RedGate ANTS 性能分析器/内存分析器** – ANTS 性能和内存分析器具有分析 .NET 代码和内存分配的能力，在运行代码时进行深度分析，展示了类似性能和内存分析的方法。'
- en: '`if..else` or switches). These can be user-defined as well to meet your code
    quality requirements using **Code Query for LINQ** (**CQLinq**). NDepend also
    has capabilities to integrate into your CI/CD pipeline to automate the process.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if..else`或开关（switches）。这些也可以由用户自定义，以满足你的代码质量要求，使用**LINQ 代码查询**（**CQLinq**）。NDepend
    还具有集成到你的 CI/CD 管道中来自动化此过程的能力。'
- en: '**Build-it-yourself metrics** – Back in [*Chapter 7*](B19493_07.xhtml#_idTextAnchor163),
    we explained how to “identify slow integration tests.” Using the diagnostic Stopwatch
    on your unit, integration, and APIs, you can perform and report on these metrics
    even before sending out a release.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义指标** – 在 [*第 7 章*](B19493_07.xhtml#_idTextAnchor163) 中，我们解释了如何“识别慢速集成测试”。使用单元、集成和
    API 上的诊断计时器，你可以在发布之前执行和报告这些指标。'
- en: When these tools examine your application, they perform analysis on how to optimize
    your code by finding hotspots. If the hotspot is called enough times, your application’s
    performance will suffer. The path to get to this hotspot is called the **hot path**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些工具检查你的应用程序时，它们会通过寻找热点来分析如何优化你的代码。如果热点被调用足够多次，你的应用程序的性能将受到影响。到达这个热点的路径被称为**热路径**。
- en: Databases
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库
- en: While you can create a baseline with databases, most optimizations are done
    at the database level by analyzing stored procedures, index management, and schema
    definitions. Each database type has its own performance tools for finding bottlenecks.
    For now, we’ll focus specifically on **SQL** **Server** tools.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用数据库创建基线，但大多数优化都是在数据库级别通过分析存储过程、索引管理和模式定义来完成的。每种数据库类型都有自己的性能工具来查找瓶颈。现在，我们将专注于
    **SQL** **Server** 工具。
- en: SQL Server Management Studio (SSMS) Profiler
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL Server Management Studio (SSMS) Profiler
- en: With **SSMS** using a profiler interface, developers have the ability to identify
    whether a particular ad-hoc query, stored procedure, or table isn’t performing
    as expected.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **SSMS** 的分析器界面，开发者能够识别特定的即席查询、存储过程或表是否未按预期执行。
- en: 'SQL Server Profiler is located under the **Tools** option as the first menu
    item, as shown in *Figure 10**.4*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server Profiler 位于 **工具** 选项下的第一个菜单项，如图 *图 10.4* 所示：
- en: '![Figure 10.4 – SQL Server Profiler in SSMS](img/B19493_10_04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – SSMS 中的 SQL Server Profiler](img/B19493_10_04.jpg)'
- en: Figure 10.4 – SQL Server Profiler in SSMS
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – SSMS 中的 SQL Server Profiler
- en: On running SQL Server profiler, every request sent to the database is logged
    along with how long it took, how many reads and writes are necessary, and the
    results returned.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 SQL Server 分析器时，发送到数据库的每个请求都会被记录，包括它花费了多长时间，需要多少读取和写入，以及返回的结果。
- en: Query Store
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询存储
- en: One of the latest features of SQL Server 2016 is the **Query Store**. The Query
    Store provides you with insight into how to improve performance on SQL Server.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 2016的最新功能之一是**Query Store**。Query Store为您提供了关于如何提高SQL Server性能的见解。
- en: 'Once enabled (right-click on database | **Properties** | **Query Store** |
    **Operation Mode: On**), it’ll begin analyzing your SQL Server workload when actively
    being used and make recommendations on how to improve performance.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用（右键单击数据库 | **属性** | **Query Store** | **操作模式：开启**），它将在积极使用时开始分析您的SQL Server工作负载，并提出改进性能的建议。
- en: Once the data is collected, the metrics are available using stored procedures
    to identify slow-performing queries.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 数据收集完成后，可以通过存储过程使用指标来识别性能较慢的查询。
- en: Query Store additional material
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Query Store附加材料
- en: For additional material on Microsoft’s Query Store, navigate to [https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store](https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store).
    For performance tuning using Query Store, navigate to [https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store](https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Microsoft的Query Store的附加材料，请访问[https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store](https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store)。有关使用Query
    Store进行性能调整的信息，请访问[https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store](https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store)。
- en: 'In this section, we covered why establishing baselines is important while listing
    various client-side tools such as Google Page Speed Insights, Lighthouse, GTMetrix,
    Google Search Console, and Chrome DevTools for gauging performance. We also looked
    at server-side tools such as Visual Studio Performance Profiler, Benchmark.net,
    Application Insights, JetBrains dotMemory and dotTrace, RedGate ANTS Performance
    Profiler/Memory Profiler, and NDepend for identifying issues with codebases. With
    databases, we mentioned two tools to identify performance bottlenecks: SQL Server
    Management Studio Profiler and Query Store. We also mentioned hotspots, or hot
    paths, where frequently called, unoptimized code could cause performance issues
    in your application.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了为什么建立基线很重要，并列出了各种客户端工具，如Google Page Speed Insights、Lighthouse、GTMetrix、Google
    Search Console和Chrome DevTools，用于衡量性能。我们还探讨了服务器端工具，如Visual Studio性能分析器、Benchmark.net、Application
    Insights、JetBrains dotMemory和dotTrace、RedGate ANTS性能分析器/内存分析器和NDepend，用于识别代码库中的问题。对于数据库，我们提到了两个用于识别性能瓶颈的工具：SQL
    Server Management Studio Profiler和Query Store。我们还提到了热点，或热点路径，频繁调用的未优化代码可能导致您的应用程序出现性能问题。
- en: The next section will cover the best practices for some client-side and server-side
    techniques, but will mostly focus on server-side optimizations using C#.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将涵盖一些客户端和服务器端技术的最佳实践，但主要将侧重于使用C#进行服务器端优化。
- en: Applying Performance Best Practices
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用性能最佳实践
- en: As mentioned at the beginning of this chapter, the content in this chapter applies
    to client *and* server techniques to get the most out of your ASP.NET websites.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，本章内容适用于客户端和服务器技术，以充分利用您的ASP.NET网站。
- en: In this section, we’ll first focus on optimizing the client by applying image
    optimization, minimizing your requests, using CDNs, and other tips to improve
    client-side performance. Then we’ll focus on server-side techniques such as optimizing
    your HTML, caching, and **Entity Framework Core** performance techniques along
    with identifying slow queries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先将重点放在通过应用图像优化、最小化请求、使用CDN和其他提示来优化客户端性能。然后我们将关注服务器端技术，例如优化您的HTML、缓存以及**Entity
    Framework Core**性能技术，以及识别慢查询。
- en: Optimizing client-side performance
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化客户端性能
- en: In this section, we’ll learn about image optimizations, identifying Google’s
    **Core Web Vitals** metrics, using a CDN when applicable, how to minimize requests,
    and where to place scripts and styles.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习关于图像优化、识别Google的**核心Web Vitals**指标、在适用时使用CDN、如何最小化请求以及在哪里放置脚本和样式。
- en: Fixing Image Optimization
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复图像优化
- en: According to the Web Almanac ([https://almanac.httparchive.org/en/2022/media#bytesizes](https://almanac.httparchive.org/en/2022/media#bytesizes)),
    image optimization is one of the worst problems on the web. The number of devices
    required to support it doesn’t make this any easier. Let’s see how we can optimize
    this experience.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据《网络年鉴》（[https://almanac.httparchive.org/en/2022/media#bytesizes](https://almanac.httparchive.org/en/2022/media#bytesizes)），图像优化是网络上的一个严重问题。需要支持的设备数量并没有使这个问题变得更容易。让我们看看我们如何可以优化这个体验。
- en: 'Here’s the basic usage of an `<``img>` tag:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `<img>` 标签的基本用法：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, for responsive layouts, the `<img>` tag has an `srcset` attribute:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于响应式布局，`<img>` 标签有一个 `srcset` 属性：
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code identifies the size of the viewport (the web page) and loads
    the appropriate image. The `max-width` media condition says that if the viewport
    is 640px, use the 400px image. If the max-width is over 640px and less than 800px,
    use the 800px image.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码识别视口大小（网页）并加载适当的图像。`max-width` 媒体条件表示，如果视口为 640px，则使用 400px 图像。如果最大宽度超过
    640px 且小于 800px，则使用 800px 图像。
- en: 'This allows you to support a number of different responsive layouts. Once you
    define the layout for your site, images should complement the layout size as well.
    What does this mean? For every image, you should have an image created for each
    responsive layout. For example, the preceding default image logo should have three
    images: `logo-400.jpg`, `logo-800.jpg`, and `logo-1024.jpg`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您支持多种不同的响应式布局。一旦您为您的网站定义了布局，图像也应与布局大小相匹配。这意味着什么？对于每张图像，您应该为每个响应式布局创建一个图像。例如，前面的默认图像标志应该有三个图像：`logo-400.jpg`、`logo-800.jpg`
    和 `logo-1024.jpg`。
- en: Also, the `loading="lazy"` tells the browser to defer loading the images until
    the browser can determine the size of the viewport to display the proper image.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`loading="lazy"` 指示浏览器在确定视口大小以显示正确图像之前延迟加载图像。
- en: Finally, images can become extremely large and can contain encoded data such
    as GPS data when a picture is taken. Compressing an image is the process of removing
    the extra data, making the image smaller and quicker to load in a browser. This
    is a server-side task and can be included as a task in your client-side task runner
    (previously discussed in [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，图像可以变得非常大，并且可能包含编码数据，如 GPS 数据，当拍照时。压缩图像是移除额外数据的过程，使图像变小并加快在浏览器中的加载速度。这是一个服务器端任务，可以将其作为客户端任务运行器中的任务（之前在
    [*第 6 章*](B19493_06.xhtml#_idTextAnchor137) 中讨论过）。
- en: 'The minimum steps for image optimization should look like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图像优化的最小步骤应如下所示：
- en: '**Determine the site’s responsive layouts** – Identify the sizes you need for
    your images (400px, 800px, etc.)'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定网站的响应式布局** – 确定您需要的图像大小（400px、800px 等）'
- en: '**Create the images based on the layouts** – There should be a resized image
    for each layout size.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**根据布局创建图像** – 应该为每个布局大小提供一个调整大小的图像。'
- en: '**Optimize the images** – For each image on your site, compress the images
    so they are smaller and load faster by removing the extra data attached to each
    image. Use image services such as Optimazilla ([https://imagecompressor.com/](https://imagecompressor.com/))
    or TinyPNG ([https://tinypng.com/](https://tinypng.com/)).'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优化图像** – 对于您网站上每张图像，通过移除附加到每张图像的额外数据来压缩图像，使它们更小并加载更快。使用图像服务，如 Optimazilla
    ([https://imagecompressor.com/](https://imagecompressor.com/)) 或 TinyPNG ([https://tinypng.com/](https://tinypng.com/))。'
- en: '`srcset` and `sizes` attributes so the browser can determine the best image
    to display based on the viewport size.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `srcset` 和 `sizes` 属性，以便浏览器可以根据视口大小确定要显示的最佳图像。
- en: Image optimization is too big a topic for a small chapter, but this quick overview
    should be enough to provide a better experience for website users.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图像优化是一个太大的主题，不适合小章节，但这个快速概述应该足以为网站用户提供更好的体验。
- en: Minimizing requests
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小化请求
- en: Most of the aforementioned client-side tools for creating baselines can be used
    to identify where multiple requests are made for resources. On average, websites
    have 58 requests for JavaScript and CSS (that’s *not* counting images). Each request
    causes latency and depending on the resource, it’ll take longer than a user is
    willing to wait.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数上述客户端工具都可以用来识别资源请求的多个位置。平均而言，网站有 58 次对 JavaScript 和 CSS 的请求（这还不包括图像）。每次请求都会造成延迟，并且根据资源的不同，加载时间可能会超过用户愿意等待的时间。
- en: We’ve already learned how to use a better approach when structuring your JavaScript
    and CSS back in [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137), eliminating a
    large number of requests for your JavaScript and CSS files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第6章*](B19493_06.xhtml#_idTextAnchor137)中学习了如何使用更好的方法来结构化JavaScript和CSS，从而减少了JavaScript和CSS文件的大量请求。
- en: 'Finally, if there’s a large number of consistent-sized images and you’re calling
    each one separately, a better approach would be to create one large image (sprite
    sheet) containing all of the images and use CSS to display them. Instead of your
    browser requesting 15 social network logos, make one call to an image and split
    them out using CSS, as shown in *Figure 10**.5*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果有大量大小一致的图像，并且你分别调用每个图像，那么一个更好的方法是将所有图像创建为一个大型图像（精灵图），并使用CSS来显示它们。而不是让浏览器请求15个社交网络标志，你可以调用一个图像，并使用CSS将它们分割出来，如图*图10.5*所示：
- en: '![Figure 10.5 – Sprite sheet of 32x32 social network icons](img/B19493_10_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 32x32社交网络图标精灵图](img/B19493_10_05.jpg)'
- en: Figure 10.5 – Sprite sheet of 32x32 social network icons
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 32x32社交网络图标精灵图
- en: 'To use this sprite sheet, the CSS would look like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个精灵图，CSS将看起来如下：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The background identifies which image to use as a background by using the offset
    top and left positions. To display the RSS icon in HTML, it would be presented
    as the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 背景通过使用偏移的顶部和左侧位置来标识要使用的图像作为背景。要在HTML中显示RSS图标，它将呈现如下：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Such services to create sprites include CodeShack’s Images to Sprite Sheet Generator
    ([https://codeshack.io/images-sprite-sheet-generator/](https://codeshack.io/images-sprite-sheet-generator/))
    and Toptal’s CSS Sprites Generator ([https://www.toptal.com/developers/css/sprite-generator](https://www.toptal.com/developers/css/sprite-generator)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建精灵图的服务包括CodeShack的图像到精灵图生成器([https://codeshack.io/images-sprite-sheet-generator/](https://codeshack.io/images-sprite-sheet-generator/))和Toptal的CSS精灵生成器([https://www.toptal.com/developers/css/sprite-generator](https://www.toptal.com/developers/css/sprite-generator))。
- en: Using CDNs
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CDN
- en: If a site uses a large number of static files, using a **content delivery network**
    (**CDN**) provides a much-needed service of delivering content based on location.
    These geographically based servers cache files so they’re delivered quicker based
    on where a user is located.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个网站使用大量的静态文件，使用**内容分发网络**（**CDN**）提供了基于位置提供内容所需的服务。这些基于地理位置的服务器缓存文件，以便根据用户的位置更快地提供。
- en: For example, if someone in California requests a file from Nevada, it’s quicker
    than someone requesting the file from England. The closer the content, the quicker
    the user receives it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果加利福尼亚的人请求内华达州的文件，比从英国请求文件要快。内容越接近，用户接收的速度就越快。
- en: Final thoughts on client-side performance
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于客户端性能的最终想法
- en: 'While there are a ton of client-side tips we could cover, let’s close this
    section out with some final thoughts on making the client quicker:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以覆盖大量的客户端技巧，但让我们以一些关于使客户端更快的最终想法来结束这一节：
- en: '**Scripts at the bottom, styles at the top** – Avoid placing scripts in the
    header, but absolutely place the styles in the header. Placing scripts at the
    bottom confirms the **Document Object Model** (**DOM**) is completely loaded and,
    if immediately executed, JavaScript is able to find the DOM elements because they’ve
    already been rendered.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本在底部，样式在顶部** – 避免在页眉中放置脚本，但绝对将样式放在页眉中。将脚本放在底部可以确认**文档对象模型**（**DOM**）已完全加载，如果立即执行，JavaScript能够找到DOM元素，因为它们已经被渲染。'
- en: '**Apply Google’s Core Web Vitals to your site** – If you’re using either Lighthouse
    or Google’s Page Speed Insights, you’ll notice the following acronyms for identifying
    your site’s performance: FCP (First Contentful Paint), LCP (Largest Contentful
    Paint), CLS (Cumulative Layout Shift), and FID (First Input Delay). Review these
    terms at [https://web.dev/vitals](https://web.dev/vitals) to provide a better
    web experience for your users.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将Google的核心Web Vitals应用于您的网站** – 如果你使用Lighthouse或Google的Page Speed Insights，你会注意到以下缩写用于识别您网站的性能：FCP（首次内容填充），LCP（最大内容填充），CLS（累积布局偏移），和FID（首次输入延迟）。在[https://web.dev/vitals](https://web.dev/vitals)上查看这些术语，以提供更好的用户体验。'
- en: '`<details>`/`<summary>` HTML tags may be enough. Also, browsers are becoming
    even more modern and evolved with new tags such as the `<dialog>` tag where JavaScript
    isn’t necessary. Refer to [https://caniuse.com/](https://caniuse.com/) for browser
    support.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<details>`/`<summary>` HTML 标签可能就足够了。此外，浏览器正变得越来越现代化和进化，出现了如 `<dialog>` 标签等新标签，其中不需要
    JavaScript。有关浏览器支持情况，请参考 [https://caniuse.com/](https://caniuse.com/)。'
- en: In this section, you learned how to optimize the client side by optimizing your
    images, along with how CDNs improve the loading of your static content and how
    to minimize your requests to lower latency issues. For our final notes, we examined
    some tips such as placing scripts at the bottom and styles at the top, applying
    Google’s Core Web Vitals to websites, providing sites that are responsive regardless
    of device, and using HTML instead of JavaScript where it makes sense.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何通过优化图像来优化客户端，以及如何通过 CDN 提高您的静态内容加载速度，以及如何最小化您的请求以降低延迟问题。在我们的最后笔记中，我们检查了一些提示，例如将脚本放在底部，将样式放在顶部，将
    Google 的 Core Web Vitals 应用到网站上，提供无论设备如何都响应式的网站，以及在合理的地方使用 HTML 而不是 JavaScript。
- en: In the next section, we’ll shift our focus from the client to the server side
    and look at some of the common practices when optimizing C# and Entity Framework
    Core.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从客户端转向服务器端，并查看在优化 C# 和 Entity Framework Core 时的一些常见实践。
- en: Common Server-side Practices
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的服务器端实践
- en: With C# being such a robust language, there are so many ways to create a web
    application. As you saw in [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114) with
    Entity Framework Core, each design pattern fit a certain need but worked the same
    regardless of the pattern. The good news with these performance techniques is
    they apply to web standards and design patterns already used in the industry.
    One such example is ETags. At one point, they were considered a separate web concept
    requiring specific code. Now, when using static files, these ETags are integrated
    into websites without any additional coding. They’re considered a web standard
    with browsers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C# 是一种如此健壮的语言，因此有如此多的方式来创建网络应用程序。正如您在 [*第 5 章*](B19493_05.xhtml#_idTextAnchor114)
    中使用 Entity Framework Core 所见，每种设计模式都满足特定的需求，但无论模式如何，它们都工作得一样好。这些性能技术的好消息是，它们适用于业界已经使用的网络标准和设计模式。一个这样的例子是
    ETags。在某个时刻，它们被认为是一个独立的网络概念，需要特定的代码。现在，当使用静态文件时，这些 ETags 无需任何额外编码就集成到网站中。它们被视为浏览器中的网络标准。
- en: What we’re going to address in this section is how to improve performance by
    adding these web standards and design patterns to our own web application to make
    it even faster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何通过将以下网络标准和设计模式添加到我们自己的网络应用程序中，以提升性能。
- en: In this section, we’ll learn about the various performance enhancements we can
    apply to your code using C#, including quick performance gains you can apply immediately
    to your own website, and we’ll learn how to add a middleware component to optimize
    your HTML, improve Entity Framework Core performance with only four letters, and
    identify slow Entity Framework Core queries.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用 C# 对您的代码应用各种性能提升，包括您可以立即应用到您自己的网站上的快速性能提升，我们将学习如何添加中间件组件以优化您的
    HTML，仅用四个字母就能提高 Entity Framework Core 的性能，并识别缓慢的 Entity Framework Core 查询。
- en: Applying quick performance wins
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用快速性能提升
- en: 'While some of these quick hits are well-known (and some have been covered in
    previous chapters), it doesn’t hurt to review them to get the most performance
    out of your website:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其中一些快速技巧是众所周知的（并且一些已经在之前的章节中介绍过），但回顾它们以从您的网站中获得最佳性能并不会造成伤害：
- en: '**Turn Debug Off** – When you run your application with debug mode, additional
    information is compiled into each assembly for debugging purposes. When changed
    to release mode, you are getting an optimized version of your assemblies for deployment.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭调试模式** – 当您以调试模式运行应用程序时，为调试目的，将编译额外的信息到每个程序集。当切换到发布模式时，您将获得用于部署的优化版本程序集。'
- en: '**Use async/await** – As mentioned in previous chapters, using async/await
    provides performance benefits and should be used for tasks involving file I/O,
    database, and API calls.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 async/await** – 如前几章所述，使用 async/await 提供性能优势，并且应该用于涉及文件 I/O、数据库和 API 调用的任务。'
- en: '**Use the database** – When using Entity Framework Core, try to assess the
    goal and evaluate the best approach: whether it’s an Entity Framework Core simple
    data access method or whether a stored procedure would provide faster performance.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用数据库** – 当使用Entity Framework Core时，尝试评估目标并评估最佳方法：是使用Entity Framework Core简单数据访问方法，还是存储过程能提供更快的性能。'
- en: '`ChangeState` management such as updating an entity, use `.AsNoTracking()`
    to reduce the Entity Framework overhead.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.AsNoTracking()`来减少更新实体时的Entity Framework开销的`ChangeState`管理。
- en: While these are some tips to give a web application a quick lift in performance,
    we’re now ready to dive into more involved code-based techniques.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是一些给Web应用快速提升性能的技巧，但我们现在准备深入到更复杂的基于代码的技术。
- en: Optimizing the HTML
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化HTML
- en: 'Since we learned about optimizing images (in the last section) and optimizing
    JavaScript and CSS (in [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137)), we now
    need to focus on the *other* client-side resource: HTML.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学习了优化图像（在上一个章节中）和优化JavaScript和CSS（在第[*6章*](B19493_06.xhtml#_idTextAnchor137)中），我们现在需要关注*其他*客户端资源：HTML。
- en: When you “view source” in the browser, you’d like to see this beautifully formatted
    document that everyone can understand. But when the browser receives this document,
    it doesn’t care how big it is or even how “pretty” it is. The browser simply parses
    and renders the HTML as it comes in.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中“查看源代码”时，你希望看到这个格式美观、人人都能理解的文档。但当一个浏览器接收到这个文档时，它并不关心它有多大，甚至不关心它有多“漂亮”。浏览器只是简单地解析和渲染传入的HTML。
- en: Have you noticed how much space is wasted in this document for the sake of formatting?
    For example, let’s load the “Buck’s Coffee Shop” web page.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到为了格式化，在这个文档中浪费了多少空间？例如，让我们加载“Buck’s Coffee Shop”网页。
- en: 'In the **Network** tab in Chrome DevTools, we see it’s 4.1 KB:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome DevTools的**网络**标签页中，我们看到它是4.1 KB：
- en: '![Figure 10.6 – Approximate size of Buck’s Coffee Shop with spaces (4.1 KB)](img/B19493_10_06.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – Buck’s Coffee Shop带有空格的大致大小（4.1 KB）](img/B19493_10_06.jpg)'
- en: Figure 10.6 – Approximate size of Buck’s Coffee Shop with spaces (4.1 KB)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – Buck’s Coffee Shop带有空格的大致大小（4.1 KB）
- en: Since the browser doesn’t care, wouldn’t it be better if we could reduce the
    size of the HTML?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器并不关心，如果我们能减小HTML的大小，岂不是更好？
- en: 'Middleware can assist with this. If we use our standard middleware template
    from [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031), we can create an `HtmlShrink`
    component:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以协助完成这项工作。如果我们使用第[*2章*](B19493_02.xhtml#_idTextAnchor031)中的标准中间件模板，我们可以创建一个`HtmlShrink`组件：
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code contains our familiar middleware scaffolding. Our `HtmlShrinkMiddleware`
    component now instantiates an `HtmlShrinkStream` class to perform our compression,
    removing any whitespace in the HTML. Also, we created the standard extension at
    the bottom of the code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含我们熟悉的中间件脚手架。我们的`HtmlShrinkMiddleware`组件现在实例化一个`HtmlShrinkStream`类来执行我们的压缩，移除HTML中的任何空白。同时，我们在代码底部创建了标准的扩展。
- en: 'Our `HtmlShrinkStream` class is shown in the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`HtmlShrinkStream`类的示例：
- en: '[PRE6]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our `HtmlShrinkStream` class, our efforts are concentrated on the `Write()`
    method. We look at the buffer received, turn it into an HTML string, replace all
    whitespace by using a RegEx, and finally, write the `buffer` to the `responseStream`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`HtmlShrinkStream`类中，我们的努力集中在`Write()`方法上。我们查看接收到的缓冲区，将其转换为HTML字符串，使用正则表达式替换所有空白，最后将`buffer`写入`responseStream`。
- en: 'We can now add our `HtmlShrink` middleware extension to our pipeline by adding
    the following line to our `Program.cs` file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过在`Program.cs`文件中添加以下行来将我们的`HtmlShrink`中间件扩展添加到我们的管道中：
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once added, any HTML received in the browser will be stripped of any whitespace.
    If we look at Buck’s Coffee Shop home page, we can see everything works, but if
    we view the source, we can see everything is a little more compact:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加，浏览器接收到的任何HTML都将去除任何空白。如果我们查看Buck’s Coffee Shop的主页，我们可以看到一切正常，但如果我们查看源代码，我们可以看到一切变得更加紧凑：
- en: '![Figure 10.7 – Viewing the source of Buck’s Coffee Shop home page](img/B19493_10_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 查看Buck’s Coffee Shop主页的源代码](img/B19493_10_07.jpg)'
- en: Figure 10.7 – Viewing the source of Buck’s Coffee Shop home page
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 查看Buck’s Coffee Shop主页的源代码
- en: 'It may not look pretty, but if we look at the **Network** tab in Chrome DevTools,
    we can see a difference in what was sent to the browser:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来不太美观，但如果我们查看Chrome DevTools中的**网络**标签页，我们可以看到发送到浏览器的内容之间的差异：
- en: '![Figure 10.8 – Size of Buck’s Coffee Shop home page without spaces (3.3 KB)](img/B19493_10_08.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 没有空格的Buck咖啡店主页大小（3.3 KB）](img/B19493_10_08.jpg)'
- en: Figure 10.8 – Size of Buck’s Coffee Shop home page without spaces (3.3 KB)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 没有空格的Buck咖啡店主页大小（3.3 KB）
- en: That’s almost 20% smaller than the original size.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎比原始大小小了20%。
- en: Enabling DbContext pooling
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用DbContext池
- en: Connection pooling is the ability to reuse a connection for multiple users.
    By default, database connections already use connection pooling through a `SqlConnection`.
    This concept was applied to Entity Framework Core’s `DbContext`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池是能够为多个用户重用连接的能力。默认情况下，数据库连接已经通过`SqlConnection`使用连接池。这个概念被应用到Entity Framework
    Core的`DbContext`中。
- en: If a web application uses Entity Framework Core heavily, you want the best performance
    available. All it takes is to update your middleware `DbContext` connection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Web应用程序大量使用Entity Framework Core，你希望获得最佳性能。只需更新你的中间件`DbContext`连接即可。
- en: 'For example, I might have the following line in my middleware:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可能在中间件中有以下一行：
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can immediately improve our performance by adding four letters to this line:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在这行添加四个字母立即提高我们的性能：
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the `AddDbContextPool<>()` method contains the same syntax, but after
    a `DbContext` is done, it will reset its state and store it for later when a new
    instance of the `DbContext` is required. We are recycling our `DbContext`s!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AddDbContextPool<>()`方法包含相同的语法，但`DbContext`完成后，它将重置其状态并将其存储起来，以便在需要新的`DbContext`实例时使用。我们正在回收我们的`DbContext`！
- en: Depending on how large your `DbContext` is, every time a new instance is created,
    the creation of the DbContext takes time. Using the `.AddDbContextPool<>()` method
    gives us the performance boost we need.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的`DbContext`大小，每次创建新实例时，创建DbContext都会花费时间。使用`.AddDbContextPool<>()`方法为我们提供了所需的性能提升。
- en: Entity Framework Core DbContext pooling benchmarks
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core DbContext池基准测试
- en: Microsoft performed benchmarks with and without DbContext pooling. With DbContext
    pooling implemented, the performance increased by over 50%. Microsoft even included
    the source code to the benchmark code. The results can be found at [https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks](https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 微软对有和无DbContext池的进行了基准测试。在实现DbContext池后，性能提高了超过50%。微软甚至包括了基准代码的源代码。结果可以在[https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks](https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks)找到。
- en: Identifying slow queries
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别慢查询
- en: The ability to identify slow queries is sometimes difficult, since we are in
    Visual Studio and may not see what’s happening behind the scenes when sending
    a query to the database. So, how do we find these slow queries in our web application?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在Visual Studio中，发送查询到数据库时可能看不到幕后发生的事情，因此识别慢查询有时可能很困难。那么，我们如何在Web应用程序中找到这些慢查询呢？
- en: 'In the DbContext’s `OnConfiguring()` method, add a `.LogTo()` method to your
    `DbContextOptionsBuilder` and you’ll see every database call and the time it took
    to execute it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在DbContext的`OnConfiguring()`方法中，向你的`DbContextOptionsBuilder`添加`.LogTo()`方法，你将看到每个数据库调用及其执行时间：
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `.LogTo()` method will produce the following log entry:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`.LogTo()`方法将生成以下日志条目：'
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For this particular query, it took *46ms* to execute. The `.LogTo()` method
    provides an easy way to identify whether a query is performing to the best of
    its ability or is a likely candidate for optimization.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的查询，执行耗时为*46ms*。`.LogTo()`方法提供了一个简单的方法来识别查询是否正在最佳性能下运行，或者是否可能是优化的候选。
- en: In this section, we learned some bite-sized optimizations along with a new middleware
    to shrink your HTML, how to speed up Entity Framework Core using DbContext pooling,
    and how to locate slow queries throughout your application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了一些小型的优化，以及一个新的中间件来缩小HTML，如何使用DbContext池加快Entity Framework Core的速度，以及如何在应用程序中定位慢查询。
- en: In the next section, we’ll focus on the various types of caching and how each
    one is different and can work collectively to improve the overall performance
    of your application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将关注各种缓存类型以及每种类型如何不同，并且如何协同工作以改善应用程序的整体性能。
- en: Understanding caching
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解缓存
- en: 'Since caching is extremely important to a web application, it’s only fitting
    it gets its own section to cover all of the possible types of caching available.
    In the industry, there’s a saying: “the best database call is no call at all.”
    They’re likely referring to caching.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓存对 Web 应用程序至关重要，因此它自然应该有一个单独的部分来涵盖所有可能的缓存类型。在业界，有一句俗语：“最好的数据库调用就是根本不调用。”他们可能是在指缓存。
- en: In this section, we’ll learn the different types of caching that include response
    and output caching, data caching, and caching static files.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习包括响应和输出缓存、数据缓存以及缓存静态文件在内的不同类型的缓存。
- en: Using response caching and output caching
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用响应缓存和输出缓存
- en: Whether making a call to a web page or an API, the ability to cache data is
    extremely important. Implementing a simple caching strategy to immediately return
    data is efficient.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是调用网页还是 API，缓存数据的能力都极其重要。实施简单的缓存策略以立即返回数据是高效的。
- en: '`ResponseCaching` is a middleware extension that is best suited for GET or
    HEAD API requests from a client. When utilizing response caching, .NET uses the
    standard HTTP caching semantics.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseCaching` 是一个中间件扩展，非常适合来自客户端的 GET 或 HEAD API 请求。当使用响应缓存时，.NET 使用标准的
    HTTP 缓存语义。'
- en: 'RFC 9111: HTTP caching'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 9111：HTTP 缓存
- en: For additional material on HTTP caching, navigate to [https://www.rfc-editor.org/rfc/rfc9111](https://www.rfc-editor.org/rfc/rfc9111).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 HTTP 缓存的资料，请访问 [https://www.rfc-editor.org/rfc/rfc9111](https://www.rfc-editor.org/rfc/rfc9111)。
- en: 'To add response caching, the builder must add it to the services and the application
    (app) must “use” it, as shown in the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加响应缓存，构建器必须将其添加到服务和应用程序（app）中，如下所示：
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once in place, any API call would provide the cached data from the browser by
    default.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实施，任何 API 调用都会默认通过浏览器提供缓存的数据。
- en: ResponseCaching middleware
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ResponseCaching 中间件
- en: For more details on `ResponseCaching`, navigate to [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `ResponseCaching` 的详细信息，请访问 [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware)。
- en: 'However, for most web UIs such as Razor Pages, `OutputCaching` is the better
    option because browsers set request headers to prevent caching. `OutputCaching`’s
    configuration is similar to `ResponseCaching`, as shown in the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大多数 Web UI，如 Razor Pages，`OutputCaching` 是更好的选择，因为浏览器会设置请求头以防止缓存。`OutputCaching`
    的配置与 `ResponseCaching` 类似，如下所示：
- en: '[PRE13]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the middleware configuration, we add the `AddOutputCache()` method to the
    services collection and place the `UseOutputCache()` method after the `UseRouting()`
    method and, if it’s used, after the `UseCors()` method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件配置中，我们在服务集合中添加 `AddOutputCache()` 方法，并在 `UseRouting()` 方法之后（如果使用了，则在 `UseCors()`
    方法之后）放置 `UseOutputCache()` 方法。
- en: 'When the `OutputCache` is added to the middleware, this doesn’t mean we are
    automatically caching our UI pages. We also need to identify which pages are cached
    by adding an `[OutputCache]` attribute to the Razor Page class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `OutputCache` 被添加到中间件时，这并不意味着我们自动缓存了我们的 UI 页面。我们还需要通过在 Razor 页面类中添加 `[OutputCache]`
    属性来标识哪些页面被缓存：
- en: '[PRE14]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If no parameters are defined in the attribute, the default policy for caching
    pages is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在属性中未定义任何参数，缓存页面的默认策略如下：
- en: HTTP 200 status codes are cached
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 200 状态码被缓存
- en: HTTP GET or HEAD requests are cached
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP GET 或 HEAD 请求被缓存
- en: Responses where cookies are set are *not* cached
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置了 cookie 的响应不会被缓存
- en: Responses to authenticated requests are *not* cached
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对认证请求的响应不会被缓存
- en: Response caching is meant for caching on the client side or through the browser
    and output caching is cached on the server. If two users access the same page
    from two different browsers, response caching won’t help since each browser will
    cache the page in each browser. However, if output caching was implemented, this
    would cache the page on the server and quickly deliver the page to both users.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 响应缓存旨在客户端或通过浏览器进行缓存，而输出缓存则是在服务器上进行缓存。如果两个用户从两个不同的浏览器访问同一页面，响应缓存将不起作用，因为每个浏览器都会在每个浏览器中缓存页面。然而，如果实现了输出缓存，这将会在服务器上缓存页面，并快速将页面提供给两个用户。
- en: Caching your pages gives users a better experience when coupled with data caching,
    which we’ll discuss next.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存页面与数据缓存结合使用时，可以为用户提供更好的体验，我们将在下一节讨论。
- en: Implementing data caching
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现数据缓存
- en: When a user visits a website, they are shown a certain amount of data based
    on who they are. For example, when the first user visits a blog, they could be
    presented with the same data as the next visitor to the site. If the data doesn’t
    change that often, it doesn’t make sense to travel all the way back to the database
    to retrieve the same data again. Data caching helps us solve this problem. Data
    caching is taking commonly used data and storing it for a period of time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问一个网站时，他们会根据他们的身份看到一定量的数据。例如，当第一个用户访问一个博客时，他们可能会看到下一个访问该网站的访客相同的数据。如果数据不经常改变，就没有必要回到数据库去检索相同的数据。数据缓存帮助我们解决这个问题。数据缓存是将常用数据存储一段时间。
- en: 'Let’s look at an example to show the approach. Since we’re using Entity Framework
    Core, we’ll have an existing service (`CoffeeService`) containing a simple `.GetAll()`
    method returning all of the coffees. We can wrap a new caching class around the
    service called `CacheCoffeeService`, as shown in the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示这种方法。由于我们使用的是 Entity Framework Core，我们将有一个现有的服务 (`CoffeeService`)，其中包含一个简单的
    `.GetAll()` 方法，返回所有的咖啡。我们可以在服务周围包装一个新的缓存类，称为 `CacheCoffeeService`，如下所示：
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`CacheCoffeeService` inherits from `CoffeeService` and uses the `ICachedCoffeeService`
    interface. The `ICachedCoffeeService` interface should be *exactly* the same as
    `CoffeeService` except for one minor detail: a reload parameter added to each
    call with a default of false.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`CacheCoffeeService` 继承自 `CoffeeService` 并使用 `ICachedCoffeeService` 接口。`ICachedCoffeeService`
    接口应该与 `CoffeeService` 完全相同，除了一个小的细节：每个调用都添加了一个默认为 `false` 的重新加载参数。'
- en: If we can’t find the entire list of coffees in the cache or we decide we want
    to reload the entire coffee list, we make a call to the base class (`CoffeeService.GetAll())`),
    save the new list to the cache, and return the entire list.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在缓存中找不到完整的咖啡列表，或者我们决定要重新加载整个咖啡列表，我们将调用基类 (`CoffeeService.GetAll()`)，将新列表保存到缓存中，并返回整个列表。
- en: By default, when you call `CachedCoffeeService.GetAll()` with no parameters,
    you’ll get the cached version of the list. Pass a `true` to the `.GetAll()` and
    you’ll refresh your cache and receive the latest list of coffees.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你不带参数调用 `CachedCoffeeService.GetAll()` 时，你会得到列表的缓存版本。传递一个 `true` 给 `.GetAll()`，你将刷新你的缓存并接收最新的咖啡列表。
- en: 'This approach provides the benefit of combining a caching layer with standard
    data access, giving us the best of both worlds. When creating these data caches,
    the benefit is immediately obvious: gaining performance by using memory as your
    database, which is thread-safe. However, be wary of how many tables or how much
    data you are storing in the cache.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法提供了将缓存层与标准数据访问相结合的好处，让我们两全其美。在创建这些数据缓存时，好处立即显而易见：通过使用内存作为数据库来提高性能，这是线程安全的。然而，要注意你在缓存中存储了多少表或多少数据。
- en: 'While it may seem like a trade-off using memory as a database, another caching
    option is using a distributed cache. A distributed cache is a cache shared across
    multiple app servers and provides the following benefits:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用内存作为数据库可能看起来是一种权衡，但另一种缓存选项是使用分布式缓存。分布式缓存是在多个应用服务器之间共享的缓存，并提供了以下好处：
- en: It is coherent/aware of requests across servers
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对服务器间的请求是一致的/有意识的
- en: If the power goes out for a server, the cached data is persisted
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务器断电，缓存的数据会持久化
- en: As mentioned, a distributed cache doesn’t use local memory
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，分布式缓存不使用本地内存
- en: Some of the best candidates for data caching are small lookup tables (< 100
    records) and rarely-accessed table data.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 数据缓存的最佳候选者是一些小的查找表（< 100 条记录）和很少访问的表数据。
- en: Caching static files
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存静态文件
- en: With all of these static files such as images, CSS, and JavaScript available
    to our web application, you’d think there would be a way to cache these files
    as well.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些静态文件（如图像、CSS 和 JavaScript）都可用于我们的 Web 应用程序，你可能会认为有方法可以缓存这些文件。
- en: 'In the `.UseStaticFiles()` method, there is a context parameter containing
    an `HttpContext`, so we can use the response object to change the cache-control
    headers for our static files:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.UseStaticFiles()` 方法中，存在一个包含 `HttpContext` 的上下文参数，因此我们可以使用响应对象来更改静态文件的缓存控制头：
- en: '[PRE16]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code takes our static files middleware component and allows a
    `StaticFileOptions` instance, which also has an `OnPrepareResponse` event available
    to us. For our cache duration, we set every static file header’s cache duration
    to 24 hours.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将我们的静态文件中间件组件与一个 `StaticFileOptions` 实例相结合，该实例还提供了一个可供我们使用的 `OnPrepareResponse`
    事件。对于我们的缓存持续时间，我们将每个静态文件头部的缓存持续时间设置为24小时。
- en: 'If we wanted to disable caching, we would modify the response to change the
    following headers:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要禁用缓存，我们会修改响应以更改以下头信息：
- en: '[PRE17]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code sample disables caching for every static file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例禁用了每个静态文件的缓存。
- en: Again, while these files are cached on the server’s local memory, keep in mind
    that when the power goes down, so does the cache.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽管这些文件在服务器本地内存中缓存，但请注意，当电源关闭时，缓存也会消失。
- en: If you wanted to cache a certain folder or file type, the `ctx` parameter contains
    not only a `Context` property of the `HttpContext` type, but a `File` property
    containing an `IFileInfo` type that includes `FileInfo` data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要缓存某个文件夹或文件类型，`ctx` 参数不仅包含 `HttpContext` 类型的 `Context` 属性，还包含一个包含 `IFileInfo`
    类型的 `File` 属性，该属性包含 `FileInfo` 数据。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While we covered a lot in this chapter, there are additional ways to achieve
    performance in web applications using more advanced techniques. The methods covered
    in this chapter are the best approaches for achieving performance in ASP.NET web
    applications. More than ever, performance is now considered one of the more important
    features in web applications, since it’s now usually tied to a company’s finances.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本章中涵盖了大量内容，但还有其他方法可以通过更高级的技术在Web应用程序中实现性能。本章中介绍的方法是实现ASP.NET Web应用程序性能的最佳方法。现在，性能被认为是Web应用程序中更重要的特性之一，因为它通常与公司的财务状况紧密相关。
- en: In this chapter, we first learned why performance matters by showing the effects
    of a slow website, how minor adjustments can produce large dividends, and how
    search engines reward websites for performance improvements.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先通过展示慢速网站的影响，说明微小的调整可以产生巨大的回报，以及搜索引擎如何奖励性能改进的网站，来了解性能的重要性。
- en: We learned how to create baselines to identify possible bottlenecks using performance
    tools to analyze the client and server-side code with various tools.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用性能工具分析客户端和服务器端代码来创建基线以识别可能的瓶颈。
- en: Then, we learned about client-side techniques to optimize images, using CDNs
    to improve the loading of static content, and how to minimize your requests to
    lower latency issues. We also examined some quick tips such as placing scripts
    at the bottom and styles at the top, reviewing Google’s Core Web Vitals to understand
    how they gauge website performance, and using HTML instead of JavaScript where
    it’s relevant.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了客户端优化图像的技术，使用CDN来提高静态内容的加载，以及如何最小化请求以降低延迟问题。我们还考察了一些快速提示，例如将脚本放在底部，将样式放在顶部，回顾Google的Core
    Web Vitals以了解它们如何衡量网站性能，以及在相关的地方使用HTML而不是JavaScript。
- en: Finally, we focused on the server side by reviewing some small, immediate optimizations
    along with improving performance by optimizing HTML before it’s sent back to the
    client. From there, we learned how to speed up Entity Framework Core by adding
    DbContext pooling and identifying slow queries. The final piece to our performance
    chapter was implementing caching, which included learning about response caching,
    output caching, data caching, and how to cache static files.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过回顾一些小的、立即的优化以及通过在发送回客户端之前优化HTML来提高性能，专注于服务器端。从那里，我们学习了如何通过添加DbContext池和识别慢查询来加快Entity
    Framework Core的速度。我们性能章节的最后一部分是实现缓存，这包括学习响应缓存、输出缓存、数据缓存以及如何缓存静态文件。
- en: In the appendix, we’ll examine some programming guidelines, along with what
    ASP.NET 8 projects look like nowadays.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录中，我们将检查一些编程指南，以及现在的ASP.NET 8项目看起来是什么样子。
