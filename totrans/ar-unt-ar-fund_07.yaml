- en: '*Chapter 5*: Using the AR User Framework'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use the `ARFramework` scene template,
    we will add a main menu for placing virtual objects in the environment. If you
    skipped that chapter or just read through it, you can find the scene template
    and assets in the files provided on this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we'll extend the framework with a new *PlaceObject-mode* that
    prompts the user to tap to place a virtual object in the room. The user will have
    a choice of objects from the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: In the latter half of the chapter, I'll discuss some advanced AR application
    issues including making an AR-optional project, determining whether a device supports
    a specific AR feature, and adding localization to your **User Interface** (**UI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with the ARFramework scene template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a main menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding PlaceObject mode and instructional UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring the menu buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing a Build And Run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding tracked objects when not needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an AR-optional project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining whether a device supports specific AR features at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding localization features to a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you'll be more familiar with the AR user framework
    developed for this book, which we'll use in subsequent chapters as we build a
    variety of different AR application projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the project in this chapter, you need Unity installed on your
    development computer, with a mobile device connected that supports AR applications
    (see [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013), *Setting Up
    for AR Development,* for instructions), including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Universal Render Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input System package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XR Plugin for your target device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AR Foundation package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We assume you have installed the assets from the Unity `ARF-samples.unitypackage`
    created in [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)*, Your
    First AR Scene*.
  prefs: []
  type: TYPE_NORMAL
- en: Also from [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037), *Your
    First AR Scene,* we created an **AR Input Actions** asset that we'll use in this
    project, containing an **action map** named **ARTouchActions** including (at least)
    a **PlaceObject** action.
  prefs: []
  type: TYPE_NORMAL
- en: We also assume you have the `ARFramework` scene template created in [*Chapter
    4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*, Creating an AR User Framework*,
    along with all the prerequisite Unity packages detailed at the beginning of [*Chapter
    4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077) *Creating an AR User Framework*.
    A copy of the template and assets can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)
    (not including the third-party packages that you should install yourself).
  prefs: []
  type: TYPE_NORMAL
- en: 'The AR user framework requires the following prerequisites, as detailed in
    [*Chapter 4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*, Creating an AR
    User Framework*, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Addressables package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Localization package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TextMesh Pro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DOTween package from the Asset Store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Serialized Dictionary Lite package from the Asset Store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The completed scene for this chapter can also be found in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, we'll create a simple demo AR scene starting with the `ARFramework`
    scene template and building up the user framework structure we have set up.
  prefs: []
  type: TYPE_NORMAL
- en: With the framework, when the app first starts, Startup-mode is enabled and the
    AR Session is initialized. Once the session is ready, it transitions to Scan-mode.
  prefs: []
  type: TYPE_NORMAL
- en: If the AR Session determines that the current device does not support AR, Scan-mode
    will transition to NonAR-mode instead. Presently this just puts a text message
    on the screen. See the *Making an AR-optional project* section near the end of
    this chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: In Scan-mode, the user is prompted to use their device camera to slowly scan
    the room until AR features are detected, namely, horizontal planes. The **ScanMode**
    script checks for any tracked planes and then transitions to Main-mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this, our plan is to add the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: The AR session will be configured to detect and track horizontal planes. We'll
    also render point clouds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Main-mode will show a main menu with buttons that lets the user choose objects
    to place in the real-world environment. You can find your own models to use here,
    but we'll include three buttons for a cube, a sphere, and a virus (created in
    [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)*, Your First AR
    Scene*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a place-object button is selected, it will enable a new PlaceObject-mode
    that prompts the user to tap to place the objects onto a detected plane.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tapping on a tracked horizontal plane will create an instance of the object
    in the scene. The app then goes back to Main-mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracked AR features (planes and point clouds) will be hidden in Main-mode, and
    visible in PlaceObject-mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I have chosen to provide a cube, a sphere, and a virus (the virus model was
    created in [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)*, Your
    First AR Scene*). Feel free to find and use your own models instead. The prefab
    assets I will be using are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assets/ARF-samples/Prefabs/` folder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/ARF-samples/Prefabs/` folder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/_ARFBookAssets/Chapter02/Prefabs/` folder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a simple AR demo that will help you become more familiar with the AR
    user framework we developed and will use in subsequent projects in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the ARFramework scene template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, we''ll create a new scene named `FrameworkDemo` using the `ARFramework`
    scene template, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File | New Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **New Scene** dialog box, select the **ARFramework** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Scenes/` folder in your project's `Assets` folder, give it the name
    `FrameworkDemo`, and press **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: Unintended clone dependencies'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When creating a new scene from a scene template, if you're prompted right away
    for a name to save the file under, this indicates your scene template has some
    clone dependencies defined. If this is not your intention, cancel the creation,
    select the template asset in your Project window, and ensure all the **Clone**
    checkboxes are cleared in the **Dependencies** list. Then try creating your new
    scene again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The new AR scene already has the following game objects included from the template:'
  prefs: []
  type: TYPE_NORMAL
- en: The **AR Session** game object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **AR Session Origin** rig with the raycast manager and plane manager components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI Canvas** is a screen space canvas with Startup UI, Scan UI, Main UI, and
    NonAR UI child panels. It also has the UI Controller component script that we
    wrote.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction Controller** is a game object with the Interaction Controller
    component script we wrote that helps the app switch between interaction modes,
    including Startup, Scan, Main, and NonAR modes. It also has a **Player Input**
    component configured with the **AR Input Actions** asset we previously created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **OnboardingUX** prefab from the AR Foundation Demos project that provides
    AR session status and feature detection status messages, and animated onboarding
    graphics prompts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set up the app title now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, unfold the **UI Canvas** object, and unfold its
    child **App Title Panel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Title Text** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its `Place Object Demo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The default AR Session Origin already has an AR Plane Manager component. Let''s
    ensure it''s only detecting horizontal planes. Let''s add a point cloud visualization
    too. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **AR Session Origin** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, set the **AR Plane Manager | Detection Mode** to **Horizontal**
    by first selecting **Nothing** (to clear the list) and then selecting **Horizontal**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `ar point cloud`, then add an **AR Point Cloud Manager** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a point cloud visualizer prefab and set the `Assets/ARF-samples/Prefabs/`
    folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your work with **File | Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've created a new scene based on the ARFramework template and added AR trackables
    managers for point clouds and horizontal planes. Next, we'll add the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a main menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main menu UI resides under the Menu UI panel (under UI Canvas) in the scene
    hierarchy. We will add a menu panel with three buttons to let you add a cube,
    a sphere, and a virus. We''ll create a menu sub-panel and arrange the menu buttons
    horizontally. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy**, unfold the **UI Canvas**, and unfold its child **Main
    UI** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, remove the temporary **Main** mode text element. *Right-click* the child
    **Text** object and select **Delete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* the `Main Menu`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `175`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I set my background `255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `layout`, then select **| Horizontal Layout Group**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Horizontal Layout Group** component check the **Control Child Size
    | Width** and **Height** checkboxes (leave the others at their default values,
    **Use Child Scale** unchecked, and **Child Force Expand** checked). The Main Menu
    panel looks like this in the Inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The Main Menu panel settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01-MainMenu-insp.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – The Main Menu panel settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll add three buttons to the menu using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* the `Cube Button`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select its child text object, and set the `Cube` and `48`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* the `Sphere Button` and change its text to `Sphere`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 3* again, renaming it `Virus Button`, and changing the text to
    `Virus`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting scene hierarchy of the Main Menu is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_5.02-mainmenu-hier.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Main Menu hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'I decided to go further and add a sprite image of each model to the buttons.
    I created the images by screen-capturing a view of each model, edited them with
    Photoshop, saved them as PNG files, and in Unity made sure the image''s **Texture
    Type** is set to **Sprite (2D and UI)**. I then added a child **Image** element
    to the buttons. The result is as shown in the following image of my menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Main Menu with icon buttons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03-mainmenu-iconbuttons.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Main Menu with icon buttons
  prefs: []
  type: TYPE_NORMAL
- en: Thus far we have created a Main Menu panel with menu buttons under the Main
    UI. When the app goes into Main-mode, this menu will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll add a UI panel that prompts the user to tap the screen to place
    an object into the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding PlaceObject-mode with instructional UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user picks an object from the main menu, the app will enable PlaceObject-mode.
    For this mode, we need a UI panel to prompt the user to tap the screen to place
    the object. Let's create the UI panel first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PlaceObject UI panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **PlaceObject UI** panel should be similar to the **Scan UI** one, so we
    can duplicate and modify it using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, unfold the **UI Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* the `PlaceObject UI`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold **PlaceObject UI** and select its child **Animated Prompt**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, set the **Animated Prompt | Instruction** to **Tap To
    Place**. The resulting component is shown in the following screenshot:![Figure
    5.4 – Animated Prompt settings for the PlaceObject UI panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.04-placeobjectui-insp.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.4 – Animated Prompt settings for the PlaceObject UI panel
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we add the panel to the UI Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy**, select the **UI Canvas** object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Inspector**, at the bottom-right of the **UI Controller** component,
    click the **+** button to add an item to the UI Panels dictionary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `PlaceObject` as text in the **Id** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the **PlaceObject UI** game object from the **Hierarchy** onto the **Value**
    slot. The UI Controller component now looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – UI Controller''s UI Panels list with PlaceObject added'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05-uicontroller-insp.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – UI Controller's UI Panels list with PlaceObject added
  prefs: []
  type: TYPE_NORMAL
- en: We added an instructional user prompt for the **PlaceObject** UI. When the user
    chooses to add an object to the scene, this panel will be displayed. Next, we'll
    add the **PlaceObject** mode and script.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PlaceObject mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add a mode to the framework, we create a child GameObject under the **Interaction
    Controller** and write a mode script. The mode script will show the mode's UI,
    handle any user interactions, and then transition to another mode when it is done.
    For PlaceObject-mode, it will display the **PlaceObject UI** panel, wait for the
    user to tap the screen, instantiate the prefab object, and then return to Main-mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `PlaceObjectMode` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by creating a new script in your `Scripts/` folder using *right-click*
    `PlaceObjectMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the file to open it for editing and replace the default content,
    starting with the following declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The script will use APIs from `ARFoundation` and `ARSubsystems` so we specify
    these in the `using` statements at the top of the script. It will use the `ARRaycastManager`
    to determine which tracked plane the user has tapped. Then it will instantiate
    the `placedPrefab` into the scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the mode is enabled, we will show the **PlaceObject UI** panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the user selects an object from the Main Menu, we need to tell `PlaceObjectMode`
    which prefab to instantiate, given the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then when the user taps the screen, the Input System triggers an `OnPlaceObject`
    event (given the `touchPosition` to the `PlaceObject` function, which does a `Raycast`
    to find the tracked horizontal plane. If found, we `Instantiate` the `placedPrefab`
    at the `hitPose` location and orientation. And then the app returns to Main-mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now add the mode to the Interaction Controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PlaceObject Mode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **PlaceObjectMode** script from the **Project** window onto the **PlaceObject**
    **Mode** object adding it as a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **AR Session Origin** object from the **Hierarchy** onto the **Place
    Object Mode | Raycaster** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we'll add the mode to the **Interaction Controller**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Hierarchy**, select the **Interaction Controller** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, at the bottom-right of the **Interaction Controller**
    component, click the **+** button to add an item to the **Interaction Modes**
    dictionary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the `PlaceObject` text in the **Id** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the **PlaceObject Mode** game object from the **Hierarchy** onto the **Value**
    slot. The **Interaction Controller** component now looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The Interaction Controller''s Interaction Modes list with PlaceObject
    added'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.06-interactionmodes-insp.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – The Interaction Controller's Interaction Modes list with PlaceObject
    added
  prefs: []
  type: TYPE_NORMAL
- en: We have now added a `OnPlaceObject` input action event. Upon the input event,
    we use Raycast to determine where in the 3D space the user wants to place the
    object, then the script instantiates the prefab and returns to Main-mode.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to wire up the main menu buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the menu buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the user presses a main menu button to add an object to the scene, the
    button will tell `PlaceObjectMode` which prefab is to be instantiated. Then PlaceObject
    mode is enabled, which prompts the user to tap to place the object and handles
    the user input action. Let''s set up the menu buttons now using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Unfold the **Main Menu** game object in the **Hierarchy** by navigating to **UI
    Canvas / Main UI / Main Menu** and select the **Cube Button** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its **Inspector**, on the **Button** component, in its **OnClick** section,
    press the **+** button in the bottom right to add an event action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy**, drag the **PlaceObject Mode** object onto the **OnClick
    Object** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Function** selection list, choose **PlaceObject Mode | SetPlacedPrefab**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Assets/ARF-samples/Prefabs/` folder and drag the **AR Placed Cube**
    prefab into the **Game Object** slot for this click event in **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let the button enable PlaceObject Mode. In its **Inspector**, on the **Button**
    component, in its **OnClick** section, press the **+** button in the bottom right
    to add another event action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy**, drag the **Interaction Controller** object onto the
    **OnClick** event's **Object** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Function** selection list, choose **InteractionController | EnableMode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the string parameter field, enter `PlaceObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Cube Button object''s Button component now has the following **OnClick**
    event settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The OnClick events for the Cube Button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07-cubebutton-onclick-insp.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – The OnClick events for the Cube Button
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat these steps for the Sphere Button and Virus Button. As a shortcut we
    can copy/paste the component settings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With the **Cube Button** selected in the **Hierarchy**, over in the **Inspector**,
    click the three-dot context menu for the **Button** component, and select **Copy
    Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy**, select the **Sphere Button** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its **Inspector**, click the three-dot context menu for the **Button** component,
    and select **Paste Component Values**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Assets/ARF-samples/Prefabs/` folder and drag the **AR Placed Sphere**
    prefab into the **Game Object** slot for this click event in **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, repeat *steps 1-4* for the `Prefabs` folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your work using **File | Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Everything should be set up now. We created a new scene using the `PlaceObjectMode`
    script that handles user input actions and instantiates the prefab, and wired
    it all up to the main menu buttons. Let's try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Performing a Building and Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build and run the project, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Build Settings** window using **File | Build Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `FrameworkDemo`) is not already in the **Scenes In Build** list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the `FrameworkDemo` scene is the only one checked in the **Scenes
    In Build** list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Build And Run** to build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the project builds successfully, it starts up in Startup-mode while the
    AR Session is initializing. Then it goes into Scan-mode that prompts the user
    to scan the environment, until at least one horizontal plane is detected and tracked.
    Then it goes into Main-mode and displays the main menu. Screen captures of the
    app running on my phone in each of these modes are shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Screen captures of Startup-mode, Scan-mode, and Main-mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08-app-1-3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Screen captures of Startup-mode, Scan-mode, and Main-mode
  prefs: []
  type: TYPE_NORMAL
- en: On pressing one of the menu buttons, the app goes into PlaceObject-mode, prompting
    the user to tap to place an object. Tapping the screen instantiates the object
    at the specified location in the environment. Then the app returns to Main-mode.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a working demo AR application for placing various virtual objects
    onto horizontal surfaces in your environment. One improvement might be to hide
    the trackable objects in Main-mode and only display them when needed in PlaceObject-mode.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding tracked objects when not needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the app first starts tracking, we show the trackable planes and point clouds.
    This is useful feedback to the user when the app first starts and subsequently
    when placing an object. But once we have objects placed in the scene, these trackable
    visualizations can be distracting and unwanted. Let's only show the object while
    in PlaceObject-mode and hide them after at least one virtual object has been placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In AR Foundation, hiding the trackables requires two separate things: hiding
    the existing trackables that have already been detected, and preventing new trackables
    from being detected and visualized. We will implement both.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, we can write a separate component on **PlaceObject mode**
    that shows the trackables when enabled and hides them when disabled. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in your `Scripts/` folder named `ShowTrackablesOnEnable`
    and open it for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the class, add variable references to `ARSessionOrigin`, `ARPlaneManager`,
    and `ARPointCloudManager`. Also, we will now remember the most recently placed
    object in `lastObject`, and initialize them in `Awake`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I've also added an `isStarted` flag that we'll use to prevent the visualizers
    from being hidden when the app starts up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Info: OnEnable and OnDisable can be called before Start'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the life cycle of a `MonoBehaviour` component, `OnEnable` is called when
    the object becomes enabled and active. `OnDisable` is called when the script object
    becomes inactive. `Start` is called on the first frame the script is enabled,
    just before `Update`. See [https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our app, it is possible for `OnDisable` to get called before `Start` (when
    we're initializing the scene from `InteractionController`). To prevent `ShowTrackables(false)`
    from getting called before the scene has started, we use an `isStarted` flag in
    this script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will show the trackables when the mode is enabled and hide them when disabled
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These call `ShowTrackables`, which we implement as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting `SetTrackablesActive(false)` will hide all the existing trackables.
    Disabling the trackable manager component itself will prevent new trackables from
    being added. We check for null managers in case the component is not present in
    `ARSessionOrigin`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in Unity, select the **PlaceObject Mode** game object in the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `ShowTrackablesOnEnable` script onto the **PlaceObject Mode** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **AR Session Origin** object from the **Hierarchy** into the **Inspector**
    and drop it onto the **Show Trackables On Enable | Session Origin** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene using **File | Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now when you click **Build And Run** again, the trackables will be shown when
    PlaceObject Mode is enabled, and will be hidden when disabled. Thus, the trackables
    will be visible when Main mode is first enabled but after an object has been placed
    and the app goes back to Main-mode, the trackables will be hidden. This is the
    behavior we desire. The PlaceObject-mode and subsequent Main-mode are shown in
    the following screen captures of the project running on my phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Screen captures of PlaceObject-mode, and subsequent Main-mode
    with trackables hidden'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.09-app-4-5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Screen captures of PlaceObject-mode, and subsequent Main-mode with
    trackables hidden
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: Disable trackables by modifying the plane detection mode'
  prefs: []
  type: TYPE_NORMAL
- en: To disable plane detection, the method I'm using is to disable the manager component.
    This is the technique given in the example `PlaneDetectionController.cs` script
    in the AR Foundation Samples project. Alternatively, the Unity ARCore XR Plugin
    docs ( [https://docs.unity3d.com/Packages/com.unity.xr.arcore@4.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.xr.arcore@4.1/manual/index.html))
    recommend disabling plane detection by setting the `ARPlaneManager` detection
    mode to the value `PlaneDetectionMode.None`.
  prefs: []
  type: TYPE_NORMAL
- en: We've now completed a simple AR project to place various virtual objects on
    horizontal planes detected in the environment, using our AR user framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further improvements you could add to the project include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A reset button in the main menu to remove any virtual objects already placed
    in the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only allow one instance of a virtual object to be placed in the scene at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ability to move and resize an existing object (see [*Chapter 7*](B15145_07_Final_SB_epub.xhtml#_idTextAnchor170)*,
    Gallery: Editing Virtual Objects*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you think of more improvements? Let us know.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rest of this chapter, we'll discuss some advanced onboarding and user
    experience features you may want to include in your projects at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced onboarding issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll review some other issues related to AR onboarding,
    AR sessions, and devices, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Making an AR-optional project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining whether the device supports a specific AR feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding localization to your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an AR-optional project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications are intended to be run specifically using AR features and
    should just quit (after a friendly notification to the user) if it's not supported.
    But other applications may want to behave like an ordinary mobile app with an
    extra optional capability of supporting AR features.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a game I recently created, Epoch Resources (available for Android
    at [https://play.google.com/store/apps/details?id=com.parkerhill.EpochResources&hl=en_US&gl=US](https://play.google.com/store/apps/details?id=com.parkerhill.EpochResources&hl=en_US&gl=US),
    and iOS at [https://apps.apple.com/us/app/epoch-resources/id1455848902](https://apps.apple.com/us/app/epoch-resources/id1455848902))
    is a planetary evolution incremental game with a 3D planet you mine for resources.
    It offers an optional AR-viewing mode where you can "pop" the planet into your
    living room and continue playing the game in AR, as shown in the following image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Epoch Resources is an AR-optional game'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10-EpochResources.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Epoch Resources is an AR-optional game
  prefs: []
  type: TYPE_NORMAL
- en: For an AR-optional application, your app will probably start up as an ordinary
    non-AR app. Then at some point the user may choose to turn on AR-specific features.
    That's when you'll activate the AR Session and handle the onboarding UX.
  prefs: []
  type: TYPE_NORMAL
- en: None of the projects in this book implement AR-optional so this is an informational
    discussion only. To start, you'll tell the XR Plugin that AR is optional by going
    to **Edit | Project Settings | XR Plug-in Management** and selecting **Requirement
    | Optional** (instead of **Required**) for each of your platforms (ARCore and
    ARKit are set separately).
  prefs: []
  type: TYPE_NORMAL
- en: You will need a mechanism for running with or without AR. One approach is to
    have separate AR and non-AR scenes that are loaded as needed (see [https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html)).
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Epoch Resources game, we did not create two separate scenes.
    Rather the scene contains two cameras, the normal default camera for non-AR mode
    and the AR Session Origin (with child camera) for AR mode. We then flip between
    the two cameras when the user toggles viewing modes.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue you may run into is determining whether the user's device supports
    a specific AR feature at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Determining whether the device supports a specific AR feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible that your app requires a specific AR feature that is not supported
    by all devices. We can ask the Unity AR subsystems what features are supported
    by getting the subsystem descriptor records.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we are interested in detecting vertical planes. Some older
    devices may support AR but only horizontal planes. The following code illustrates
    how to get and check plane detection support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The types of descriptors available in AR Foundation include the following (their
    purpose is self-evident from their names):'
  prefs: []
  type: TYPE_NORMAL
- en: '`XRPlaneSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRRaycastSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRFaceSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRImageTrackingSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XREnvironmentProbeSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRAnchorSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRObjectTrackingSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRParticipantSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRDepthSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XROcclusionSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRCameraSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRSessionSubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XRHumanBodySubsystemDescriptor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation for the AR Subsystems API and these descriptor records can be
    found at [https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.html).
    For example, the `XRPlaneSubsystemDescriptor` record we used here is documented
    at [https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRPlaneSubsystemDescriptor.Cinfo.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRPlaneSubsystemDescriptor.Cinfo.html).
  prefs: []
  type: TYPE_NORMAL
- en: If you are planning to distribute your application in different countries, you
    may also be interested in localization.
  prefs: []
  type: TYPE_NORMAL
- en: Adding localization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Localization is the translation of text strings and other assets into local
    languages. It can also specify date and currency formatting, alternative graphics
    for national flags, and so on, to accommodate international markets and users.
    The Unity Localization package provides a standard set of tools and data structures
    for localizing your application. More information can be found at [https://docs.unity3d.com/Packages/com.unity.localization@0.10/manual/QuickStartGuide.html](mailto:https://docs.unity3d.com/Packages/com.unity.localization@0.10/manual/QuickStartGuide.html).
    We do not use localization in any projects in this book, except where already
    supported by imported assets such as the Onboarding UX assets from the AR Foundation
    Demos project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity Onboarding UX assets has built-in support for localization of the
    user prompts and explanation of scanning problems. The `ReasonsUX` localization
    tables given with the Onboarding UX project, for example, can be opened by selecting
    **Window | Asset Management | Localization Tables** and is shown in the following
    screenshot. You can see, for example, the second-row **INIT** key says in English,
    **Initializing augmented reality**, along with the same string translated into
    many other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The ReasonsUX localization tables included in Onboarding UX
    assets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11-Localization-tables.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – The ReasonsUX localization tables included in Onboarding UX assets
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, the **Initializing augmented reality** message, for example, is
    retrieved with a call like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we added the onboarding UX prefab (`ARFoundationDemos/UX/Prefabs/ScreenspaceUI`)
    to our scene, I had you disable the **Localization Manager** component because
    it gives runtime errors until it is set up. Provided you''ve installed the **Localization**
    package via **Package Manager** as described earlier in this chapter, we can set
    it up now for the project using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Localization** settings window by going to **Edit | Project Settings
    | Localization**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Assets/ARFOundationDemos/Common/Localization/` and drag the `LocalizationSettings`
    asset onto the **Location Settings** slot (or use the *doughnut* icon to open
    the **Location Setting Select** dialog box).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the settings window, click **Add All**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **OnboardingUX** object and in the **Inspector**,
    enable the **Localization Manager** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Addressables Groups** window using **Window | Asset Management |
    Addressables | Groups**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Addressables Groups** menu bar, select **Build | New Build | Default
    Build Script**. You will need to do this for each target platform you are building
    (for example, once for Android and once for iOS).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see in this last step, the Localization package uses Unity's new
    **Addressables** system for managing, packing, and loading assets from any location
    locally or over the internet ([https://docs.unity3d.com/Packages/com.unity.addressables@1.12/manual/index.html](https://docs.unity3d.com/Packages/com.unity.addressables@1.12/manual/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Note that as I'm writing this, the Onboarding UX `LocalizationManager` script
    does not select the language at runtime. The language must be set in the Inspector
    and compiled into your build.
  prefs: []
  type: TYPE_NORMAL
- en: The AR UI framework we built in this chapter can be used as a template for new
    scenes. Unity makes it easy to set that up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got a chance to use the AR user framework we developed in
    the previous [*Chapter 4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*, Creating
    an AR User Framework*, in a simple AR *Place Object Demo* project. We created
    a new scene using the `ARFramework` scene template that implements a state machine
    mechanism for managing user interaction modes. It handles user interaction with
    a controller-view design pattern, separating the control scripts from the UI graphics.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the scene includes the AR Session and AR Session Origin components
    required by AR Foundation. The scene is set up with a Canvas UI containing separate
    panels that will be displayed for each interaction mode. It also includes an Interaction
    Controller that references separate mode objects, one for each interaction mode.
  prefs: []
  type: TYPE_NORMAL
- en: The modes (and corresponding UI) given with the template are Startup, Scan,
    Main, and NonAR. An app using this framework first starts in Startup-mode while
    the AR Session is initializing. Then it goes into Scan-mode, prompting the user
    to scan the environment for trackable features, until a horizontal plane is detected.
    Then it goes into Main-mode and displays the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we added a main menu that is displayed during Main-mode and
    that contains buttons for placing various virtual objects in the environment.
    Pressing a button enables a new PlaceObject-mode that we added to the scene. When
    PlaceObject-mode is enabled, it displays an instructional animated prompt for
    the user to tap to place an object in the scene. After an object is added, the
    app returns to Main-mode, and the trackables are hidden so you can see your virtual
    objects in the real world without any extra distractions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go beyond a simple demo project and begin to build
    a more complete AR application – a photo gallery where you can place framed photos
    of your favorite pictures on the drab walls in your home or office.
  prefs: []
  type: TYPE_NORMAL
