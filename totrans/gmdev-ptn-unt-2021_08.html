<html><head></head><body>
        

                            
                    Managing Game Events with the Event Bus
                
            
            
                
<p class="mce-root">The Event Bus acts as a central hub that manages a specific list of global events that objects can choose to subscribe to or publish. It's the most straightforward pattern related to event managing that I have in my toolbox. It reduces the process of assigning the role of subscriber or publisher to an object into a single line of code. As you can imagine, this can be beneficial when you need results quickly. But like most simple solutions, it has some drawbacks and limitations, which we will explore further on.</p>
<p class="mce-root">In the code example presented in this chapter, we will use the Event Bus to broadcast specific race events to components that need to listen for changes in the overall state of the race. But it's essential to keep in mind; I'm proposing using the Event Bus as a solution for managing global race events because of its simplicity and not its scalability. So it might not be the best solution in all cases, but it is one of the most straightforward patterns to implement, as we will see in the following sections.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>An overview of the Event Bus pattern </li>
<li>The implementation of a Race Event Bus</li>
</ul>
<p>This chapter includes simplified skeleton code examples for the sake of brevity and clarity. If you wish to review a complete implementation of the pattern in the context of an actual game project, open the <kbd>FPP</kbd> folder in the GitHub project. You can find the link under the <em>Technical requirements</em> section.</p>
<h1 id="uuid-55d5fce1-e8b1-4f7a-b564-2771c0dcc9fe">Technical requirements</h1>
<p>We will also be using the following specific Unity engine API features:</p>
<ul>
<li><kbd>Static</kbd></li>
<li><kbd>UnityEvents</kbd></li>
<li><kbd>UnityActions</kbd></li>
</ul>
<p>If you are unfamiliar with these concepts, please review <a href="c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml">Chapter 3</a>, <em>A Short Primer to Programming in Unity</em>.</p>
<p>The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter06">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter06</a>.<a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021"/></p>
<p class="mce-root">Check out the following video to see the code in action: <br/>
<a href="https://bit.ly/2U7wrCM">https://bit.ly/2U7wrCM</a>.</p>
<p>If you find yourself having problems understanding the mechanism behind delegates, keep in mind that they are similar to function pointers in C/C++. In simple terms, a delegate points to a method. And delegates are often used to implement event handlers and callbacks. An action is a type of delegate that you can use with a method that has a void return type.</p>
<h1 id="uuid-4e09dde8-4e1d-42d7-942a-0f97116fd27a">Understanding the Event Bus pattern</h1>
<p>When an event is raised by an object (publisher), it sends out a signal that other objects (subscribers) can receive. The signal is in the form of a notification that can indicate the occurrence of an action. In an event system, an object broadcasts an event. Only those objects that subscribe to it will be notified and choose how to handle it. So, we can imagine it as having a sudden burst of a radio signal that only those with antennas tuned to a specific frequency can detect.</p>
<p class="mce-root">The Event Bus pattern is a close cousin of the Messaging system and Publish-Subscribe patterns, the latter being the more accurate name for what the Event Bus does. The keyword in the title of this pattern is the term <em>bus</em>. In simple computing terms, a bus is a connection between components. In the context of this chapter, the components will be objects that can be publishers or listeners of events.</p>
<p class="mce-root">Hence, the Event Bus is a way to connect objects through events by using a publish-subscribe model. It's possible to accomplish a similar model with a pattern such as the Observer and native C# events. However, those alternatives have some drawbacks. For example, in a typical implementation of the Observer pattern, a tight coupling might occur, as observers (listeners) and subjects (publishers) might become dependent and aware of each other.</p>
<p class="mce-root">But the Event Bus, at least in the way we will implement it in Unity, abstracts and simplifies the relations between publishers and subscribers, so they are entirely unaware of one another. Another advantage is that it reduces the process of assigning the role of publisher or subscriber to a single line of code. Therefore, the Event Bus is a valuable pattern to learn and have in your back pocket. As you can see in the following diagram, it does act as a middleman between publishers and subscribers:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/272dfd72-4bd9-4a96-a736-c192239f3c9a.png" style="width:25.08em;height:34.33em;"/></p>
<p>Figure 6.1 – Diagram of the Event Bus pattern</p>
<p>As you can see from the diagram, there are three main ingredients:</p>
<ul>
<li><strong>Publishers</strong>: These objects can publish specific types of events declared by the Event Bus to subscribers.</li>
<li><strong>Event Bus</strong>: This object is responsible for coordinating the transmission of events between publishers and subscribers.</li>
<li><strong>Subscribers</strong>: These objects register themselves as subscribers of specific events through the Event Bus.</li>
</ul>
<h2 id="uuid-a23079a8-8f7f-4623-a462-b3f560601e61">Benefits and drawbacks of the Event Bus pattern</h2>
<p>The <strong>benefits</strong> of the Event Bus pattern are as follows:</p>
<ul>
<li><strong>Decoupling</strong>: The main benefit of using an event system is that it decouples your objects. Objects can communicate through events instead of directly referencing each other.</li>
<li><strong>Simplicity</strong>: The Event Bus offers simplicity by abstracting the mechanism of publishing or subscribing to an event from its clients.</li>
</ul>
<p>The <strong>drawbacks</strong> of the Event Bus pattern are as follows:</p>
<ul>
<li><strong>Performance</strong>: Under the hood of any event system, there's a low-level mechanism that manages messaging between objects. And so there might be a slight performance cost when using an event system, but depending on your target platform, it could be minuscule.</li>
<li><strong>Global</strong>: In this chapter, we implement the Event Bus with static methods and properties to make it easier to access from anywhere in our code. There is always a risk when using globally accessible variables and states as they can make debugging and unit testing more difficult. However, this is a very contextual drawback and not an absolute. </li>
</ul>
<p>UnityEvents can actually accept up to four generic-type arguments. This can make it possible to pass event-specific data to subscribers. Review the following Unity API documentation section for more details: <a href="https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Events.UnityEvent.html">https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Events.UnityEvent.html</a><a href="https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html">.</a><a href="https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html"/></p>
<h2 id="uuid-76730fd1-2a73-465a-b88f-86947898dfab">When to use the Event Bus</h2>
<p>I have used the Event Bus in the past for the following:</p>
<ul>
<li><strong>Rapid prototyping</strong>: I use the Event Bus pattern often when rapidly prototyping new game mechanics or features. With this pattern, I can easily have components that trigger each other's behaviors with events while keeping them decoupled. This pattern permits us to add and remove objects as subscribers or publishers with a single line of code, which is always helpful when you want to prototype something quickly and easily.</li>
<li><strong>Production code</strong>: I use the Event Bus in production code if I can't find a justifiable reason to implement a more sophisticated approach to managing game events. It's a pattern that does the job well if you don't need to handle complex event types or structures.</li>
</ul>
<p>I would avoid using a globally accessible Event Bus like the one presented in this chapter to manage events that don't have a "global scope." For instance, if I have a UI component in the HUD that displays a damage alert when the player collides with an obstacle, it would be inefficient to publish a collision event through the Event Bus as it's a localized interaction between the bike and an object on the track. Instead, I would use something like an Observer pattern because, in that scenario, I only need one UI component to observe a specific change in the state of an object, in this case, the bike. As a rule of thumb, every time you have to implement a system that uses events, go through the list of known patterns, choose one suitable for your use case, but don't always fall back to the easiest one, which, in my opinion, is the Event Bus.</p>
<h2 id="uuid-e5fffb1e-87fd-4c77-a481-a533f4c1cd21">Managing global race events</h2>
<p>The project we are working on is a racing game, and most races are structured in stages. The following is a shortlist of typical racing stages: </p>
<ul>
<li><strong>Countdown</strong>: At this stage, the bike is stopped behind the start line while a countdown timer is running down.</li>
<li><strong>Race start</strong>: Once the clock hits zero, the green light signal is turned on, and the bike moves forward on the track.</li>
<li><strong>Race finish</strong>: The moment the player crosses the finish line, the race is over.</li>
</ul>
<p>In between the start and finish of the race, certain events can be triggered that could change the current state of the race:</p>
<ul>
<li><strong>Race pause</strong>: The player could pause the game while still racing.</li>
<li><strong>Race quit</strong>: The player could quit the race at any time.</li>
<li><strong>Race stop</strong>: The race could stop suddenly if the player is involved in a fatal crash.</li>
</ul>
<p>So we want to broadcast a notification that signals the occurrence of each stage of the race and any other important event in between that will change the overall state of the race. This approach will permit us to trigger specific behaviors of components that need to behave in certain ways depending on the current context of the race. </p>
<p>For example, here are some components that will get updated depending on a specific state of the race:</p>
<ul>
<li><strong>HUD</strong>: The race status indicator will change depending on the context of the race <strong>HUD</strong> (<strong>heads-up display</strong>).</li>
<li><strong>RaceTimer</strong>: The race timer will only start at the start of the race and stops when the player crosses the finish line.</li>
<li><strong>BikeController</strong>: The bike controller releases the brakes of the bike once the race starts. This mechanism prevents the player from launching onto the track before the green light.</li>
<li><strong>InputRecorder</strong>: At the start of the race, the input replay system will start recording the player's inputs so that they can be replayed later on.</li>
</ul>
<p>All these components have specific behaviors that have to be triggered at particular stages of the race. So we will use the Event Bus to implement these global race events.</p>
<h1 id="uuid-c0547448-0121-4c5c-9b58-b35aa20d08ac">Implementing a Race Event Bus</h1>
<p>We are going to implement the Race Event Bus in two easy steps:</p>
<ol>
<li>To start, we need to expose the specific race event types that we support, which we will do with the following enum:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.EventBus<br/>{<br/>    public enum RaceEventType<br/>    {<br/>        COUNTDOWN, START, RESTART, PAUSE, STOP, FINISH, QUIT<br/>    }<br/>}</pre>
<p style="padding-left: 60px">It's important to note that the preceding enum values represent specific events outlining the stages of a race, from start to finish. So we are restricting ourselves to handling events with just a global scope.</p>
<ol start="2">
<li>The next part is the core component of the pattern, the actual game event bus class, which we will call <kbd>RaceEventBus</kbd>, to be more domain-specific in the naming convention of our classes:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine.Events;<br/>using System.Collections.Generic;<br/><br/>namespace Chapter.EventBus<br/>{<br/>    public class RaceEventBus<br/>    {<br/>        private static readonly <br/>            IDictionary&lt;RaceEventType, UnityEvent&gt; <br/>            Events = new Dictionary&lt;RaceEventType, UnityEvent&gt;();<br/><br/>        public static void Subscribe<br/>            (RaceEventType eventType, UnityAction listener) {<br/>            <br/>            UnityEvent thisEvent;<br/><br/>            if (Events.TryGetValue(eventType, out thisEvent)) {<br/>                thisEvent.AddListener(listener);<br/>            }<br/>            else {<br/>                thisEvent = new UnityEvent();<br/>                thisEvent.AddListener(listener);<br/>                Events.Add(eventType, thisEvent);<br/>            }<br/>        }<br/><br/>        public static void Unsubscribe<br/>            (RaceEventType type, UnityAction listener) {<br/><br/>            UnityEvent thisEvent;<br/><br/>            if (Events.TryGetValue(type, out thisEvent)) {<br/>                thisEvent.RemoveListener(listener);<br/>            }<br/>        }<br/><br/>        public static void Publish(RaceEventType type) {<br/><br/>            UnityEvent thisEvent;<br/><br/>            if (Events.TryGetValue(type, out thisEvent)) {<br/>                thisEvent.Invoke();<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The key ingredient of our class is the <kbd>Events</kbd> dictionary. This acts as a ledger in which we maintain a list of relations between event types and subscribers. By keeping it <kbd>private</kbd> and <kbd>readonly</kbd>, we are ensuring that it can't be overwritten by another object directly.</p>
<p>Therefore, a client must call the <kbd>Subscribe()</kbd> public static method to add itself as a subscriber of a specific event type. The <kbd>Subscribe()</kbd> method takes two parameters; the first is the race event type, and the second one is the callback function. Because <kbd>UnityAction</kbd> is a delegate type, it provides us with a way to pass a method as an argument.</p>
<p>Hence, when a client object calls the <kbd>Publish()</kbd> method, the registered callback methods of all the subscribers of a specific race event type will get called at the same time.</p>
<p>The <kbd>Unsubscribe()</kbd> method is self-explanatory as it permits objects to remove themselves as subscribers of a specific event type. Thus, their callback methods will not be called by the Event Bus when an object publishes an event.</p>
<p>If this still looks abstract, it will be made clear as we implement client classes in the next section and see how we can use the Event Bus to trigger behaviors of objects at specific moments in the proper sequence.</p>
<h2 id="uuid-0300fa64-17a8-48a3-ba1f-7f1b4d82882b">Testing the Race Event Bus</h2>
<p>Now that we have the core elements of the pattern in place, we can write some code to test our <kbd>RaceEventBus</kbd> class. For reasons of brevity, I have removed all the behavior code in each client class to focus on the use of the pattern:</p>
<ol>
<li class="mce-root">For starters, we are going to write a countdown timer that subscribes to the <kbd>COUNTDOWN</kbd> race event type. Once the <kbd>COUNTDOWN</kbd> event is published, it will trigger a 3-second countdown to the start of the race. And at the exact moment the count reaches its end, it will publish the <kbd>START</kbd> event to signal the beginning of the race:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>namespace Chapter.EventBus<br/>{<br/>    public class CountdownTimer : MonoBehaviour<br/>    {<br/>        private float _currentTime;<br/>        private float duration = 3.0f;<br/><br/>        void OnEnable() {<br/>            RaceEventBus.Subscribe(<br/>                RaceEventType.COUNTDOWN, StartTimer);<br/>        }<br/><br/>        void OnDisable() {<br/>            RaceEventBus.Unsubscribe(<br/>                RaceEventType.COUNTDOWN, StartTimer);<br/>        }<br/><br/>        private void StartTimer() {<br/>            StartCoroutine(Countdown());<br/>        }<br/><br/>        private IEnumerator Countdown() {<br/>            _currentTime = duration;<br/><br/>            while (_currentTime &gt; 0) {<br/>                yield return new WaitForSeconds(1f);<br/>                _currentTime--;<br/>            }<br/><br/>            RaceEventBus.Publish(RaceEventType.START);<br/>        }<br/><br/>        void OnGUI() {<br/>            GUI.color = Color.blue;<br/>            GUI.Label(<br/>                new Rect(125, 0, 100, 20), <br/>                "COUNTDOWN: " + _currentTime);<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">The most significant lines of code in the preceding class are the following:</p>
<pre style="padding-left: 60px">void OnEnable() {<br/>    RaceEventBus.Subscribe(<br/>        RaceEventType.COUNTDOWN, StartTimer);<br/>}<br/><br/>void OnDisable() {<br/>    RaceEventBus.Unsubscribe(<br/>        RaceEventType.COUNTDOWN, StartTimer);<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">Every time the <kbd>CountdownTimer</kbd> object is enabled, the <kbd>Subscribe()</kbd> method is called. And when the opposite happens, and it gets disabled, it unsubscribes itself. We are doing this to ensure that the object is listening to an event when it's active or doesn't get called by <kbd>RaceEventBus</kbd> when disabled or destroyed.</p>
<p style="padding-left: 60px" class="mce-root">The <kbd>Subscribe()</kbd> method takes two arguments – the event type, and a callback function. This means that the <kbd>StartTimer()</kbd> method of <kbd>CountdownTimer</kbd> will be called by <kbd>RaceEventBus</kbd> every time the <kbd>COUNTDOWN</kbd> event is published.</p>
<ol start="2">
<li class="mce-root">Next up, we will implement a skeleton of the <kbd>BikeController</kbd> class to test out the <kbd>START</kbd> and <kbd>STOP</kbd> events:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.EventBus <br/>{<br/>    public class BikeController : MonoBehaviour <br/>    {<br/>        private string _status;<br/><br/>        void OnEnable() {<br/>             RaceEventBus.Subscribe(<br/>                 RaceEventType.START, StartBike);<br/><br/>             RaceEventBus.Subscribe(<br/>                 RaceEventType.STOP, StopBike);<br/>        }<br/><br/>        void OnDisable() {<br/>             RaceEventBus.Unsubscribe(<br/>                 RaceEventType.START, StartBike);<br/><br/>             RaceEventBus.Unsubscribe(<br/>                 RaceEventType.STOP, StopBike);<br/>        }<br/><br/>        private void StartBike() {<br/>             _status = "Started";<br/>        }<br/><br/>        private void StopBike() {<br/>             _status = "Stopped";<br/>        }<br/><br/>        void OnGUI() {<br/>             GUI.color = Color.green;<br/>             GUI.Label(<br/>                 new Rect(10, 60, 200, 20), <br/>                 "BIKE STATUS: " + _status);<br/>         }<br/>     }<br/>}</pre>
<ol start="3">
<li>And lastly, we are going to write an <kbd>HUDController</kbd> class. This doesn't do much except display a button to stop the race once it starts:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.EventBus<br/>{<br/>    public class HUDController : MonoBehaviour<br/>    {<br/>        private bool _isDisplayOn;<br/><br/>        void OnEnable() {<br/>            RaceEventBus.Subscribe(<br/>                RaceEventType.START, DisplayHUD);<br/>        }<br/><br/>        void OnDisable() {<br/>            RaceEventBus.Unsubscribe(<br/>                RaceEventType.START, DisplayHUD);<br/>        }<br/><br/>        private void DisplayHUD() {<br/>            _isDisplayOn = true;<br/>        }<br/><br/>        void OnGUI() {<br/>            if (_isDisplayOn)<br/>            {<br/>                if (GUILayout.Button("Stop Race"))<br/>                {<br/>                    _isDisplayOn = false;<br/>                    RaceEventBus.Publish(RaceEventType.STOP);<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<ol start="4">
<li>To test the sequence of events, we need to attach the following client class to a GameObject in an empty Unity scene. With this, we will be able to trigger the countdown timer:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.EventBus<br/>{<br/>    public class ClientEventBus : MonoBehaviour<br/>    {<br/>        private bool _isButtonEnabled;<br/><br/>        <br/>        void Start()<br/>        {<br/>            gameObject.AddComponent&lt;HUDController&gt;();<br/>            gameObject.AddComponent&lt;CountdownTimer&gt;();<br/>            gameObject.AddComponent&lt;BikeController&gt;();<br/><br/>            _isButtonEnabled = true;<br/>        }<br/><br/>        <br/>        void OnEnable()<br/>        {<br/>            RaceEventBus.Subscribe(<br/>                RaceEventType.STOP, Restart);<br/>        }<br/><br/>        void OnDisable()<br/>        {<br/>            RaceEventBus.Unsubscribe(<br/>                RaceEventType.STOP, Restart);<br/>        }<br/><br/>        private void Restart()<br/>        {<br/>            _isButtonEnabled = true;<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            if (_isButtonEnabled)<br/>            {<br/>                if (GUILayout.Button("Start Countdown"))<br/>                {<br/>                    _isButtonEnabled = false;<br/>                    RaceEventBus.Publish(RaceEventType.COUNTDOWN);<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">The preceding example might seem overly simplified, but its purpose is to showcase how we can trigger individual object behaviors in a specific sequence with events while keeping them decoupled. None of the objects communicate with one another directly.</p>
<p class="mce-root">Their only common point of reference is <kbd>RaceEventBus</kbd>. Therefore, we could easily add more subscribers and publishers; for instance, we could have a <kbd>TrackController</kbd> object listen for the <kbd>RESTART</kbd> event to know when to reset the race track. And thus, we can now sequence the triggering of behaviors of core components with events, each presenting a particular stage of the race.</p>
<p>Action is a delegate that points to a method that accepts one or more arguments but returns no value. For instance, you should use Action when your delegate points to a method that returns void. UnityAction behaves like Actions in native C#, except UnityActions was designed to be used with UnityEvents.</p>
<h2 id="uuid-f5c98fb8-c21c-4310-993f-31a174aa9b4c">Reviewing the Event Bus implementation</h2>
<p>By using the Event Bus, we can trigger behaviors while keeping core components decoupled. It's straightforward for us to add or remove objects as subscribers or publishers. We also defined a specific list of global events that represent every stage of a race. Therefore, we can now start sequencing and triggering behaviors of core components, from the start to the end of a race, and anything in between.</p>
<p class="mce-root">In the next section, we will review some alternative solutions to the Event Bus, with each solution offering a different approach that might be a better solution depending on context.</p>
<h1 id="uuid-630e5313-7868-4adb-b182-e82a643d0977">Reviewing some alternative solutions</h1>
<p>Event systems and patterns are a vast topic, and it's a subject matter we can't cover in depth in this book. Therefore, we have prepared a shortlist of patterns to consider when implementing an event system or mechanism, but keep in mind that there's a lot more out there, and we encourage you as a reader to continue exploring the topic beyond the limited scope of this book:</p>
<ul>
<li><strong>Observer</strong>: An oldie but goodie pattern in which an object (subject) maintains a list of objects (observers) and notifies them of an internal state change. It's a pattern to consider when you need to establish a one-to-many relationship between a group of entities.</li>
<li><strong>Event Queue</strong>: This pattern permits us to store events generated by publishers in a queue and forward them to their subscribers at a convenient time. This approach decouples the temporal relationship between publishers and subscribers.</li>
<li><strong>ScriptableObjects</strong>: It's possible to create an event system with ScriptableObjects in Unity. The key benefit of this approach is that it makes it easier to author new custom game events. If you need to build a scalable and customizable event system, this might be the way to go.</li>
</ul>
<p>If you are asking yourself why we are not showcasing more advanced event systems in this book, including those implemented with ScriptableObjects, the answer is that the core intent of this book is to introduce readers to design patterns, not overwhelm them with complexity. We offer a first-step introduction to core concepts, but encourage readers to seek more advanced material as they progress.</p>
<h1 id="uuid-451e6349-9fd0-4689-83c7-5be04e7e853d">Summary</h1>
<p>In this chapter, we reviewed the Event Bus, a simple pattern that simplifies the process of publishing and subscribing to events in Unity. It's a tool that helps during rapid prototyping or when you have a defined list of global events to manage. However, it has its limits of use, and it's always wise to explore other options before committing to using a globally accessible event bus.</p>
<p>In the next chapter, we will implement a system that will allow us to replay player inputs. Many racing games have replay and rewind features, and with the Command pattern, we will attempt to build one from scratch.</p>


            

            
        
    </body></html>