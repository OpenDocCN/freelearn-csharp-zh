- en: Chapter 2. Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is the process of finding, identifying, and fixing bugs (errors or
    mistakes) in your code, and there are many ways to achieve this. To script effectively,
    you'll need to be aware of the most common workflows and toolsets available to
    you for debugging in Unity. Before considering them further, however, it's important
    to be aware of the general limitations of debugging and what it cannot achieve.
    Debugging is not a magical cure-all to remove all bugs and guarantee an error-free
    application. The computer scientist Edsger W. Dijkstra said, *"Program testing
    can be used to show the presence of bugs, but never to show their absence"*. The
    crucial point is that during testing, you might encounter one or more errors.
    These errors can be identified, tested, and repaired through debugging. Yet, your
    tests—though perhaps extensive and careful—will never cover every possible case
    or scenario on every hardware platform under all conditions, as these combinations
    could be practically infinite. So, you can never be absolutely certain to have
    found all the possible bugs. Even on the release day, there could still be bugs
    in your game, which your testing couldn't detect. Of course, there might actually
    be no bugs remaining at all, but you cannot know this with absolute certainty.
    So, debugging is not about achieving an error-free application. Its aims are more
    modest. It's about systematically testing your game in many common and reasonable
    situations to find and correct as many errors as you encounter or, at least, as
    many severe errors as your time and budget permits. In any case, debugging is
    a critical part of scripting, because without it, you will have no way of tracing
    and fixing errors. Debugging techniques range from simple to complex, and in this
    chapter, we'll cover a broad spectrum of them.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation errors and the console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debugging typically refers to error-busting techniques for runtime use; that
    is, it refers to the things you can do to find and correct errors when your game
    is running. This understanding of debugging, of course, presupposes that your
    code is already valid and compiled. The implicit assumption is that you can write
    valid statements in C# and compile code, and you just want to find runtime errors
    that occur as a result of program logic. Thus, the focus is not on syntax but
    on logic, and this is indeed true. However, in this section, I''ll speak very
    briefly about code compilation, about writing valid code, and using the console
    to find and correct errors of validity. This is important, both to introduce the
    **Console** window generally and also to establish a firm basis of thinking about
    debugging in more depth. Consider the following code sample 2-1 script file (`ErrorScript.cs`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To compile the preceding code sample 2-1, simply save the script file in MonoDevelop
    (*Ctrl* + *S*) and then refocus the Unity Editor window. From here, compilation
    will happen automatically. If it doesn't, you can also right-click on the script
    file from the **Project** panel and choose **Reimport** from the context menu.
    For the code sample 2-1, two errors are generated, and these will be shown in
    the **Console** window. If you don't already have the **Console** window open,
    it could be shown by selecting the **Console** option from **Window** from the
    application menu. The **Console** window is highly important, and you'll almost
    always want it open somewhere in the interface. This is where Unity as an engine
    communicates with you as a developer. Thus, if your code has compile errors, Unity
    would list them to **Console**, letting you know what they are.
  prefs: []
  type: TYPE_NORMAL
- en: The code sample 2-1 generates two compile-time errors, as shown in the following
    screenshot. These happen because lines 11 and 16 refer to the variable `mynumber`
    that doesn't exist, although `MyNumber` does (case sensitivity). Compile-time
    errors such as these are critical because they render your code invalid. This
    means you cannot compile your code and run your game until the errors are corrected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Compilation errors and the console](img/0655OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing compilation errors in the Console window
  prefs: []
  type: TYPE_NORMAL
- en: If compilation errors are not shown in **Console** as expected, then make sure
    that the errors filter is enabled. To enable this, click on the error filter icon
    (a red exclamation mark icon) in the top-right corner of the **Console** window.
    The **Console** window features three filters, comments (**A**), warnings (**B**),
    and errors (**C**), as shown in the following screenshot, to hide and show specific
    messages. These toggle the visibility of each message type in the **Console**
    window. Comments refer to the messages that you, as a programmer, explicitly print
    to the **Console** window from your code using the `Debug.Log` statement. We'll
    see examples of this shortly (you can also use the `Print` function). Warnings
    refer to potential issues or wastages detected in your code. These are syntactically
    valid and will compile even if ignored by you, but they might cause problems or
    have unintended and wasteful results. Errors refer to any compile-time errors
    found in your code that affect its compilation validity, such as with code sample
    2-1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Compilation errors and the console](img/0655OT_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enabling/disabling the Console window filters
  prefs: []
  type: TYPE_NORMAL
- en: 'When the console fills with more than one error, the errors are typically listed
    in the order in which they were detected by the compiler, that is, from top to
    bottom. It''s considered best practice to tackle errors in order, because earlier
    errors can cause later ones. Thus, resolving earlier errors can, potentially,
    resolve later ones. To resolve an error, start by double-clicking on the error
    from the **Console** window, and MonoDevelop will open automatically, highlighting
    the line where the error itself was found or where the error was first detected.
    It is important to note that MonoDevelop will take you to the line where the error
    was first detected, although resolving the error will not always involve editing
    that line specifically. Depending on the issue, you will need to change to a different
    line than theone highlighted. If you double-click on the top error (first error)
    in **Console**, as generated by the code sample 2-1, MonoDevelop will open and
    highlight line 11\. You can fix this error in two ways: either by renaming `mynumber`
    to `MyNumber` in line 11 or by renaming the variable `MyNumber` to `mynumber`
    in line 6\. Now, consider the following code sample 2-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Code sample 2-2 fixes the errors in code sample 2-1\. However, it leaves us
    with a warning instead (as shown in the following screenshot). This indicates
    that the variable `MyNumber` is never used. It's assigned a value in lines 11
    and 16, but this assignment is never of any ultimate consequence for the application.
    Here, this warning could be ignored and the code would remain valid. Warnings
    should be seen primarily as recommendations made by the compiler about your code.
    How you handle them is ultimately your choice, but I recommend that you try to
    eliminate both errors and warnings wherever practical.
  prefs: []
  type: TYPE_NORMAL
- en: '![Compilation errors and the console](img/0655OT_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try to eliminate both errors and warnings
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Debug.Log – custom messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps, the oldest and most well-known debugging technique in Unity is to
    use `Debug.Log` statements to print diagnostic messages to **Console**, thus illustrating
    program flow and object properties. This technique is versatile and appealing
    because it can be used in practically every **Integrated Development Environment**
    (**IDE**) and not just MonoDevelop. Further, all the Unity objects, including
    vector and color objects, have a convenient `ToString` function that allows their
    internal members (such as *X*, *Y*, and *Z*) to be printed to a human-readable
    string—one that can be easily sent to the console for debugging purposes. For
    example, consider the following code sample 2-3\. This code sample demonstrates
    an important debugging workflow, namely, printing a status message about an object
    at its instantiation. This script, when attached to a scene object, prints its
    world position to **Console**, along with a descriptive message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot demonstrates the output of this code in **Console**
    when attached to a cube `GameObject`. The `Debug.Log` message is printed in the
    main console message list. If the message is selected with the mouse, **Console**
    will also indicate a script file and line associated with the statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with Debug.Log – custom messages](img/0655OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debug.Log messages can convert objects to strings, and the Console window also
    indicates an associated script file and line
  prefs: []
  type: TYPE_NORMAL
- en: The main limitations of `Debug.Log` as a debugging technique relate to code
    cleanliness and program complexity. First, the `Debug.Log` statements require
    you to explicitly add code to your source files. When you're done debugging, you'll
    need to either remove the `Debug.Log` statements manually or leave them there,
    which is wasteful and results in confusion, especially if you have to add the
    additional `Debug.Log` statements in many other places. Second, though `Debug.Log`
    is useful to target specific problems or monitor specific variables over time,
    it's ultimately awkward to get a higher-level picture of your code and its execution
    to trace errors whose presence you detect but whose location is entirely unknown.
    These criticisms, however, shouldn't be regarded as advice to avoid using the
    `Debug.Log` statements entirely. They should be considered only to use them appropriately.
    `Debug.Log` works best when an error or problem can be traced to a prime suspect
    object, and you want to observe or monitor its values to see how they change or
    update, especially during events such as `OnStart`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Removing the Debug.Log statements**'
  prefs: []
  type: TYPE_NORMAL
- en: When your game is ready to build and ship, remember to remove or comment away
    any `Debug.Log` statements for extra cleanliness.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the ToString method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code sample 2-3 demonstrates the convenience of the `ToString`
    method when used in conjunction with the `Debug.Log` debugging. `ToString` lets
    you convert an object to a human-readable string that can be output to **Console**.
    In C#, every class inherits the `ToString` method by default. This means that
    using inheritance and polymorphism, you can override the `ToString` method of
    your class that customizes it as required and produce a more readable and accurate
    debug string that represents your class members. Consider the following code sample
    2-4 that overrides `ToString`. If you get into the habit of overriding `ToString`
    for every class you make, your classes will become easier to debug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code can be seen in the **Console** window, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overriding the ToString method](img/0655OT_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Overriding the ToString method to customize debug messages for a class
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**String.Format**'
  prefs: []
  type: TYPE_NORMAL
- en: Line 30 of the code sample 2-3 uses the `String.Format` function to build a
    complete string. This function is useful when you need to make one long string
    that includes both literal statements and variable values, which could be different
    types. By inserting the tokens `{0}, {1}, {2}…` inside the string argument, the
    `Format` function will substitute them for the subsequent function arguments in
    the order in which they are provided; that is, `String.Format` will concatenate
    your string argument at the location of the tokens, with string versions of your
    function arguments. Thus, the string `{0}` will be replaced with `OgreName.ToString()`.
    For more information on `String.Format`, see the online documentation at [http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can section off and isolate blocks of code between the release and debug
    versions that allow you to run debug-specific code when specific flags are enabled.
    When debugging games, for example, you''ll frequently develop two sets or variations
    of code: the release code and the debug code. Imagine a common scenario where
    to find and resolve a bug in the code, you resort to inserting the `Debug.Log`
    statements that print out the values of variables and states of classes. You might
    even insert additional lines, such as `if` statements and loops, to test out alternative
    scenarios and explore how objects react. After amending the code for a while,
    the problem seems repaired, so you remove the additional debug code and continue
    testing as you did earlier. However, later, you discover that the problem has
    returned, or a similar one has arisen. So now you wish you''d kept the debug code
    after all, because it''d be useful again. You might promise yourself that next
    time, you''ll simply comment out the debug code as opposed to deleting it entirely.
    This will let you simply remove the commenting should the code be needed again.
    However, of course, having to comment and uncomment code is also tedious, especially
    if there''re many lines, and they are scattered across multiple files and parts
    of files. You can, however, resolve this problem and similar ones using custom
    global defines. In essence, a global define is a special preprocessor flag that
    you can enable or disable to conditionally compile or exclude blocks of your code.
    By setting the flag to `true`, Unity will automatically compile one version of
    your code, and by setting it to `false`, Unity will compile the other version.
    This will allow you to maintain two versions or variations of your code in only
    one set of source files: one for debug and one for release. Let''s see this in
    practice in Unity. Consider the following code sample 2-5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines 09–12 feature the core functionality using the preprocessor directives
    `#if` and `#endif` conditional. This conditional is not executed at runtime like
    a regular `if` statement, but at compile time. At compile time, Unity will decide
    whether the global define `SHOW_DEBUG_MESSAGES` is specified or active. If, and
    only if, it is, then lines 10 and 11 will be compiled, otherwise the compiler
    will ignore these lines, treating them as comments. Using this feature, you can
    isolate all debug code within an `#if #endif` block that checks for a debug define
    and activates and deactivates the code on the basis of the `SHOW_DEBUG_MESSAGES`
    define, which applies project-wide to all source files. The question that then
    remains is how is the define set. To set the global define, navigate to **Edit**
    | **Project Settings** | **Player** from the application menu. Then, enter the
    define name in the **Scripting Define Symbols** field, making sure that you press
    the *Enter* key after entering the name to confirm the change, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overriding the ToString method](img/0655OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding global custom defines from the Unity Editor, which lets you conditionally
    compile code
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Removing defines and adding multiple defines**'
  prefs: []
  type: TYPE_NORMAL
- en: Simply entering the name of your global define in the **Scripting Define Symbols**
    field is enough for it to take effect and apply across your code. You can delete
    the name to remove the define, but you can also prefix the name with `/` (for
    example, `/SHOW_DEBUG_MESSAGE`) to disable the define, thus making it easier to
    re-enable it later. You can also add multiple defines, separating each with the
    semicolon symbol (for example, `DEFINE1;DEFINE2;DEFINE3…`).
  prefs: []
  type: TYPE_NORMAL
- en: Visual debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging with abstract or textual representations of data (such as `Debug.Log`)
    is often adequate but not always optimal. Sometimes, a picture is worth a thousand
    words. So, for example, when coding the line-of-sight functionality for enemies
    and other characters that allow them to see the player and other objects whenever
    they come in range, it's useful to get a live and graphical representation of
    where the line of sight actually is in the viewport. This line of functionality
    is drawn in terms of lines or as a wireframe cube. Similarly, if an object is
    following a path, it'd be great to draw this path in the viewport that displays
    it as a colored line. The purpose of this is not to create visual aids that will
    really show in the final game but simply to ease the debugging process that lets
    us get a better idea of how the game is working. These kinds of helpers or gizmos
    are a part of visual debugging. Unity already provides us with many gizmos automatically,
    such as the wireframe bounding box for colliders and frustum for cameras. However,
    we also have the ability to create our own gizmos for our own objects. This section
    explores gizmos further.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, many Unity objects, such as colliders, trigger volumes,
    NavMesh Agents, cameras, and lights, already offer their own visual aids and gizmos
    when they are selected. These are shown by default in the **Scene** viewport unless
    you switch them off or reduce their size to zero. So, if you''ve added a native
    Unity object and don''t see a gizmo in the **Scene** viewport, then be sure to
    check the **Gizmo** panel that is accessible from the **Scene** toolbar via the
    **Gizmo** button. Enable all the gizmos you want to see and adjust the **Size**
    slider that increases or decreases the gizmo size (choose a size that is best
    for you), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual debugging](img/0655OT_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enabling gizmos in the Scene view
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Gizmos in the Game tab**'
  prefs: []
  type: TYPE_NORMAL
- en: Gizmos don't show by default in the **Game** tab. You can, however, change this
    behavior easily using the **Gizmo** button in the top-right corner of the **Game**
    tab toolbar. This menu works just like the **Gizmos** menu for the **Scene** tab,
    as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code sample 2-6\. This is a sample class that can be
    attached to an object and it relies on the Unity gizmo class to draw a custom
    range of helper gizmos. More information can be found online at [http://docs.unity3d.com/ScriptReference/Gizmos.html](http://docs.unity3d.com/ScriptReference/Gizmos.html).
    Here, this sample class draws a bounding wireframe sphere of a specified radius
    centered on the object that represents its range of attack. In addition, it draws
    a line-of-sight vector that represents the object''s forward direction, providing
    a visual indication of the way the object is facing. All of these gizmos are drawn
    inside the `OnDrawGizmos` event of `MonoBehaviour` on the condition that the variable
    `DrawGizmos` is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how to draw gizmos that helps with debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual debugging](img/0655OT_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drawing gizmos
  prefs: []
  type: TYPE_NORMAL
- en: Error logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you compile and build your game to distribute to testers, whether they''re
    collected together in an office or scattered across the globe, you''ll need a
    way to record errors and exceptions as and when they happen during gameplay. One
    way to do this is through logfiles. Logfiles are human-readable text files that
    are generated on the local computer by the game at runtime, and they record the
    details of errors as they occur, if any occur at all. The amount of information
    you record is a matter for careful consideration, as logging too much detail can
    obfuscate the file and too little can render the file useless. However, once a
    balance is reached the tester will be able to send you the log for inspection,
    and this will, hopefully, allow you to quickly pin-point errors in your code and
    repair them effectively, that is without introducing new errors! There are many
    ways to implement logging behavior in Unity. One way is using the native `Application`
    class to receive exception notifications by way of delegates. Consider the following
    code sample 2-7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 2-7:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 22**: A new `StreamWriter` object is created to write debug strings
    to a file on the computer. The file is created inside `Application.persistentDataPath`;
    this points to a system location that is always writable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 30**: The `Application.RegisterLogCallBack` method is invoked with a
    function reference to `HandleLog` as an argument. This relies on delegates. In
    short, a reference to the `HandleLog` function is passed, and this will be called
    when an error or exception occurs that allows us to write details to a logfile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 45**: The `WriteLine` method of `StreamWriter` is called to print textual
    data to the logfile when an error occurs. The error information is provided by
    Unity through the `HandleLog` arguments: `logString`, `stackTrace`, and `LogType`.
    The `StreamWriter` class is part of the Mono Framework, which is an open source
    implementation of the Microsoft NET Framework. More information on `StreamWriter`
    can be found at [http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the quickest ways to test out your error logger is to create a divide
    by zero error. Don't forget to insert a `Debug.Log (Application.persistentDataPath);`
    line somewhere in your code to print the logfile path to the **Console** window.
    This can help you quickly find the logfile on your system via Windows Explorer
    or Mac Finder. Note that the `persistentDataPath` variable is used as opposed
    to an absolute path, because it varies from operating system to operating system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot shows how to print errors to a text-based logfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Error logging](img/0655OT_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Printing errors to a text-based logfile can make debugging and bug fixing easier
  prefs: []
  type: TYPE_NORMAL
- en: 'What are delegates in C#? Imagine that you''re able to create a variable and
    assign it a function reference instead of a regular value. Having done this, you
    can invoke the variable just like a function to call the referenced function at
    a later time. You can even reassign the variable to reference a new and different
    function later. This, in essence, is how delegates work. If you''re familiar with
    C++, delegates are practically equivalent to the function pointers. Thus, delegates
    are special types that can reference and invoke functions. They''re ideal to create
    extensible callback systems and event notifications. For example, by keeping a
    list or array of delegate types, potentially, many different classes can register
    themselves as listeners for callbacks by adding themselves to the list. More information
    on C# can be found at [http://msdn.microsoft.com/en-gb/library/ms173171.aspx](http://msdn.microsoft.com/en-gb/library/ms173171.aspx).
    Consider the following code sample 2-8 for an example of the delegate usage in
    C# with Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Editor debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s sometimes claimed that Unity has no debugging tools built into the editor,
    but this is not quite true. With Unity, you can play your game and edit the scene
    at the same time while the game is running. You can even observe and edit properties
    in the Object Inspector, both private and public, as we saw earlier. This can
    give you a complete and graphical picture of your game at runtime; and allow you
    to detect and observe a wide range of potential errors. This form of debugging
    should not be underestimated. To get the most from in-editor debugging, activate
    the **Debug** mode from the Object Inspector by clicking on the context menu icon
    in the top-right corner of the inspector and then choose **Debug** from the menu,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editor debugging](img/0655OT_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing the Debug mode from the Object Inspector
  prefs: []
  type: TYPE_NORMAL
- en: Next, make sure that your viewports are configured appropriately so that they
    allow you to see both the **Scene** and **Game** views simultaneously during the
    **Play** mode, along with the **Stats** panel. To achieve this, disable the **Maximize
    on Play** button from the **Game** tab toolbar if it's activated. Then, arrange
    the **Scene** and **Game** tabs side-by-side in the interface, or else arrange
    them across multiple monitors if you have more than one. Multiple monitors are
    strongly recommended if your budget allows, but a single monitor can work well
    too, provided you invest extra time arranging and sizing each window to best meet
    your needs. In addition, you'll generally want the **Console** window visible
    and the **Project** panel hidden to prevent accidental selection and movement
    of assets, as shown in the following screenshot. Remember that you can also customize
    the Unity GUI Layout. For more information see [http://docs.unity3d.com/Manual/CustomizingYourWorkspace.html](http://docs.unity3d.com/Manual/CustomizingYourWorkspace.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![Editor debugging](img/0655OT_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugging games from the editor using a single monitor layout
  prefs: []
  type: TYPE_NORMAL
- en: Once you're ready for in-editor debugging, click on the play button on the toolbar
    and use pause if you ever need to stop game events to inspect a specific object
    and its values from the Object Inspector. Remember that you can still use the
    transform (position, rotation, and scale) tools in-game to reposition the player
    or enemies, thus trying out new values and seeing which ones work and which ones
    do not. Most importantly, however, all edits to the scene in the **Game** mode,
    via the Object Inspector or transform tools, are temporary and will revert back
    after the **Play** mode ends. For this reason, if you need to make permanent changes
    to settings, then you would need to make them in the **Edit** mode. You can, of
    course, copy and paste values between the **Play** and **Edit** modes using the
    **Component** context menu at any time, as shown in the following screenshot.
    Remember that the hot key (*Ctrl* + *P*) toggles between the **Play** mode and
    (*Ctrl* + *Shift* + *P* between paused and unpaused). A full list of Unity hot
    keys is listed at [http://docs.unity3d.com/Manual/UnityHotkeys.html](http://docs.unity3d.com/Manual/UnityHotkeys.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![Editor debugging](img/0655OT_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Copying and pasting component values via the Component context menu
  prefs: []
  type: TYPE_NORMAL
- en: Using the profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One additional tool that's used partly for debugging and partly for optimization
    is the **Profiler** window, which is available only in Unity Pro by clicking on
    the **Profiler** tab in **Window** in the application menu, as shown in the following
    screenshot. In short, the profiler gives you a statistical top-down view of how
    time and workload is distributed across the different parts of your game and across
    system hardware components, such as the CPU and graphics card. Using profiler,
    you can determine, for example, how much time is consumed by camera rendering
    in the scene compared to physics calculations or to audio functionality, as well
    as to other categories. It lets you measure performance, compare numbers, and
    assess where performance can be improved. The profiler is not really a tool that
    alerts you to the presence of bugs in your code specifically. However, if you're
    experiencing performance problems in running the game, such as lags and freezes,
    then it could guide you to where optimizations can be made. For this reason, the
    profiler is a tool to which you'll turn if you decide that performance is an issue
    for your game and you need an educated, studied analysis of where to start implementing
    improvements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the profiler](img/0655OT_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The profiler is typically used to diagnose performance issues
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run your game with the **Profiler** window open, the graph will populate
    with statistics about the most recent frames. The profiler doesn''t usually record
    information about all the frames since the game began, but only the most recent
    ones as will fit into memory sensibly. There is a toggleable "deep profile" method
    available in the upper toolbar of the **Profiler** window, which allows you (in
    theory) to get extra information about your game, but I''d recommend that you
    avoid this mode. It can cause performance issues with the Unity Editor when running
    asset-heavy and code-heavy games, and it can even freeze the editor altogether.
    Instead, I''d recommend that you only use the default mode. When using this mode,
    in most cases, you''ll want to disable the visualization of **VSync** from the
    **CPU Usage** area to get a better view of other performance statistics, including
    **Rendering** and **Scripts**, as shown in the following screenshot. To do this,
    simply click on the **VSync** icon in the graph index area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the profiler](img/0655OT_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Disabling the VSync display from the CPU usage area in the Profiler window
  prefs: []
  type: TYPE_NORMAL
- en: 'The horizontal axis of the graph represents frames—the most recent frames added
    to the memory buffer. This axis keeps populating with new data while the game
    is running. The vertical axis represents time or computational expense: higher
    values are expressive of a more demanding and slower frame time. After the graph
    is filled with some data during the **Play** mode, you can pause the game to examine
    its state. Select the frames from the graph to view more information on game performance
    during that frame. When you do this, the **Hierarchy** panel in the bottom half
    of the **Profile** window fills with function data about the code that is being
    executed on the selected frame. When viewing the graph, it''s good practice to
    watch for sudden increases (peaks or spikes), as shown in the following screenshot.
    These indicate frames of sudden and intense activity. Sometimes, they can be one-off
    occurrences that are either unavoidable due to hardware operations or that happen
    legitimately and are not the source of performance problems, such as scene transitions
    or loading screens.'
  prefs: []
  type: TYPE_NORMAL
- en: However, they can indicate trouble too, especially if they happen regularly.
    So, when diagnosing performance issues, looking for spikes is a good place to
    start your investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the profiler](img/0655OT_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting a frame from the profiler graph
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Hierarchy** view lists all the main functions and events in code that
    executes on the selected frame. For each function, there are several crucial properties
    such as **Total**, **Self**, **Time ms**, and **Self ms**, which are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the profiler](img/0655OT_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Examining function calls during selected frames
  prefs: []
  type: TYPE_NORMAL
- en: 'Let'' s discuss these crucial properties in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Total and Time ms**: The **Total** column represents the proportion of frame
    time consumed by the function. The value of **49.1%**, for example, means that
    49.1 percent of the total time required for the selected frame was consumed by
    the function, including any time taken to call subfunctions (functions called
    within the function). The **Time ms** column expresses the frame consumption time
    in absolute terms, measured in milliseconds. Together, these two values give you
    both a relative and absolute measure of how expensive calling the function is
    on each frame and in total.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self and Self ms**: The **Total** and **Total ms** settings measure the expense
    of the function for the selected frame, but they include the total time spent
    inside other functions that were invoked from within the function. Both **Self**
    and **Self ms** exclude this time and express only the total time spent within
    the function, minus any additional time waiting for other functions to complete.
    These values are often the most important when seeking to pinpoint a specific
    function that causes performance problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on the Unity Profiler can be found at [http://docs.unity3d.com/Manual/ProfilerWindow.html](http://docs.unity3d.com/Manual/ProfilerWindow.html).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with MonoDevelop – getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we encountered the `Debug.Log` method of debugging to print helper
    messages to the console at critical moments in the code to help us see how the
    program executes. This method, while functional, however, suffers some significant
    drawbacks. First off, when writing larger programs with many `Debug.Log` statements
    it's easy to effectively "spam" the console with excessive messages. This makes
    it difficult to differentiate between the ones you need and the ones you don't.
    Second, it's generally a bad practice to change your code by inserting the `Debug.Log`
    statements simply to monitor program flow and find errors. Ideally, we should
    be able to debug without changing our code. Therefore, we have compelling reasons
    to find alternative ways to debug. MonoDevelop can help us here. Specifically,
    in the latest releases of Unity, MonoDevelop can natively attach itself to a running
    Unity process. In doing this, we get access to a range of common debugging tools,
    the kind encountered when developing other types of software, such as breakpoints
    and traces. Presently, the connectivity between MonoDevelop and Unity can be buggy
    however, for some users on some systems. However, when working as intended, MonoDevelop
    can offer a rich and useful debugging experience that allows us to move beyond
    simply writing the `Debug.Log` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start debugging with MonoDevelop, let''s consider breakpoints. When debugging
    code, you''ll likely need to observe the program flow when it reaches a specified
    line. A breakpoint lets you mark one or more lines in a source file from MonoDevelop,
    and when the program runs in Unity, its execution will pause at the first breakpoint.
    At this pause, you get the opportunity to examine the code and the status of variables
    as well as to inspect and edit their values. You can also continue execution with
    stepping. This lets you push execution forward to the next line, following the
    normal program logic line-by-line. You get the opportunity of inspecting your
    code in each line as it passes. Let''s see an example case. The following code
    sample 2-9 shows a simple script file. When attached to an object, it retrieves
    a list of all objects in the scene (including itself) and then sets their position
    to the world origin (0, 0, 0) when the **Start** function is executed, which occurs
    at level startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set a breakpoint in the highlighted line via MonoDevelop. This will
    pause the program execution whenever it reaches this line. To set the breakpoint,
    position your mouse cursor on the highlighted line, right-click on the left-hand
    gray margin, and choose **New Breakpoint**. Otherwise, use the MonoDevelop application
    menu to choose the **New Breakpoint** option in **Run**, or you can also press
    the *F9* key (or you can left-click on the line number), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new breakpoint in MonoDevelop
  prefs: []
  type: TYPE_NORMAL
- en: 'The breakpoint line will be highlighted in red. To get this breakpoint to work
    properly with Unity when the game runs, you''ll need to attach MonoDevelop to
    the running Unity process. To do this, make sure that the Unity Editor is running
    alongside MonoDevelop and then choose the **Attach to Process** option from **Run**
    from the MonoDevelop application menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Attach to Process
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Attach to Process** dialog appears, and the **Unity Editor** should be
    listed as **Process Name** to which MonoDevelop can be attached. The **Debugger**
    drop-down list in the bottom-left corner of the window should be specified as
    **Unity Debugger**. Select the **Unity Editor** option and then choose the **Attach**
    button, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select Unity Editor from the Attach to Process dialog
  prefs: []
  type: TYPE_NORMAL
- en: When MonoDevelop is attached to Unity as a process, two new bottom-aligned panes
    will dock themselves to the MonoDevelop interface, and these include the **Watch**
    window and the **Immediate** window, as shown in the following screenshot. These
    windows offer additional debugging information and views when your game runs in
    the Unity Editor, as we'll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Two new panes dock themselves to MonoDevelop when attaching to a Unity process
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, return to the Unity Editor and make sure that the script file `DebugTest.cs`,
    as shown in code sample 2-9, is attached to an object in the scene and that the
    scene includes other objects (any objects, such as cubes or cylinders). Then,
    run your game using the play button from the Unity toolbar, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running from the Unity Editor in preparation for debugging with MonoDevelop
  prefs: []
  type: TYPE_NORMAL
- en: When you press the play button on the Unity toolbar with MonoDevelop attached,
    the execution of Unity will freeze when the breakpoint is reached (the break mode).
    The focus will switch to the MonoDevelop window with the breakpoint line highlighted
    in yellow inside the source file that indicates the current step of execution,
    as shown in the following screenshot. During this mode, you cannot use the Unity
    Editor, and you cannot switch between viewports or even edit settings inside the
    Object Inspector as you can with in-editor debugging. MonoDevelop is waiting exclusively
    for your input to resume execution. The next few sections will consider some useful
    debugging tools that you can use in the break mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Entering the break mode from within MonoDevelop
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with MonoDevelop – the Watch window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Watch** window allows you to view the value of a variable that's active
    in memory in the current step, and this includes both local and global variables.
    One way to quickly add a watch for a variable while it is in the break mode is
    to highlight it in the code editor and then hover your mouse over it. When you
    do this, leaving the mouse hovered for a few seconds, a pop-up window appears
    automatically. This window allows the full inspection of a variable, as shown
    in the following screenshot. You can contract and expand the members of a class
    and examine the state of all its variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inspecting a variable with hover watches in the break mode
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inspect practically all variable values for any active object using
    this hover method. However, typically, you''ll want to place a more permanent
    watch on a variable and even a group of variables so that you can see their values
    collated together in a list. For this, you can use the **Watch** window docked
    in the bottom-left corner of the MonoDevelop interface. To add a new watch in
    this window, right-click inside the **Watch** list and choose **Add watch** from
    the context menu, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a watch to the Watch window
  prefs: []
  type: TYPE_NORMAL
- en: On adding a new watch, you can enter any valid expression or variable name in
    the **Name** field, and the resultant value will be shown in the **Value** column,
    as shown in the following screenshot. The values shown in the **Watch** field
    are valid for the current line of execution only, and they will change as the
    program progresses. Remember that you can add a watch for any valid variable that
    can be referenced in the current scope, including `name`, `tag`, `transform.position`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a watch to the Watch window
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the **Watch** window to examine any valid variables and expressions,
    whether they pertain to the active class or line of code. This means you can see
    the value for global variables and any variables related to other classes or objects,
    as long as they''re valid and in memory. However, if you''re only interested in
    viewing local variables, that is, variables whose scope is relevant to the block
    of code being executed in the current step, then you could use the **Locals**
    window instead of **Watch**. This window automatically adds watches for all the
    local variables. You don''t need to add them manually. Here, the **Locals** window
    is by default tabbed next to the **Watch** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inspecting local variables only with the Locals window
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t see any of the relevant **Debug** windows in the MonoDevelop
    interface, such as the **Watch** window or the **Locals** window, you can show
    or hide them manually by clicking on the **Debug Windows** option in **View**
    from the MonoDevelop application menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'One great thing about the **Watch** and **Locals** windows is that they offer
    read and write access to variables. This means that you''re not restricted to
    simply viewing variable values, but you can write to them as well, changing the
    variable from within MonoDevelop. To do this, simply double-click on the **Value**
    field from either the **Watch** or **Locals** window and then enter a new value
    for the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Editing values from the Watch window
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with MonoDevelop – continue and stepping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reaching a breakpoint and inspecting your code, it''s likely that you''ll
    want to exit from the break mode and continue program execution in some way. You
    might want to continue program execution, which effectively hands program control
    back to Unity. This allows the execution to continue as normal, until it meets
    the next breakpoint, if any. This method effectively resumes execution as normal,
    and it''ll never pause again unless a new breakpoint is encountered. To continue
    in this way from MonoDevelop, press the *F5* key or press the play button from
    the MonoDevelop toolbar. Otherwise, choose the **Continue Debugging** option in
    **Run** from the MonoDevelop application menu, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – continue and stepping](img/0655OT_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exiting the break mode and resuming with Continue Debugging
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many occasions, however, where you don''t want to continue execution
    in this way. Instead, you want to step execution over the lines of code, line
    by line, evaluating each line as it progresses and examining the program flow
    to see how variables change and are affected by statements. The step mode effectively
    lets you observe the program flow as it happens. There are three main kinds of
    steps in debugging: step over, step into, and step out. Step over instructs the
    debugger to move to the next line of code and then to pause again, awaiting your
    inspection as though the next line were a new breakpoint. If an external function
    call is encountered in the next line, the debugger would invoke the function as
    usual and then step to the next line without stepping into the function. In this
    way, the function is "stepped over". The function still happens, but it happens
    in the continue mode, and the next step or breakpoint is set in the next line
    after the function. To step over, press *F10*, choose the **Step Over** command
    in **Run** from the application menu, or press the **Step Over** button in the
    MonoDevelop toolbar, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – continue and stepping](img/0655OT_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Stepping over code moves execution to the next statement without stepping into
    an external function
  prefs: []
  type: TYPE_NORMAL
- en: If an external function call is encountered, the **Step Into** (*F11*) command
    allows debugging to enter this function. This effectively sets the next breakpoint
    in the first line of the entered function that allows debugging to resume in the
    next step. This can be useful if you need to observe how many functions are working
    together. If, at any point, you want to exit the entered function by moving it
    forward in the continue mode, you could use the **Step Out** (*Shift* + *F11*)
    command, and the execution would resume in the next line in the outer function.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with MonoDevelop – call stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More complex programs typically involve lots of functions and function calls.
    During execution, functions can invoke other functions, and these functions can
    go on to invoke yet more functions in an intricate chain of functions within functions.
    This means that when setting breakpoints inside functions, you can never know
    how the function was invoked initially when it''s actually called at runtime.
    The breakpoint tells you that program execution has reached the specified line,
    but it doesn''t tell you how execution arrived there in the first place. Sometimes,
    it might be easy to deduce, but at other times it can be much harder, especially
    when functions are invoked within loops, conditionals, and nested loops and conditionals.
    Consider the following code sample 2-10, which has been amended from the earlier
    code sample 2-9\. This class contains several functions that invoke other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If a breakpoint is set in line 38 of code sample 2-10 (highlighted), execution
    will pause when this line is reached. By reading this sample, we can see that
    one route to that function is by the `Start` function calling `Func01`, `Func01`
    calling `Func02`, and then `Func02` finally calling `Func03`. But how do we know
    that this is the only route? It''s technically possible, for example, for another
    class and function elsewhere in the project to invoke `Func03` directly. So, how
    can we know the route by which we''ve reached this function in this step while
    debugging? Based on the tools examined so far, we can''t. However, we can use
    the **Call Stack** window. This window, displayed by default in the bottom-right
    corner of the MonoDevelop interface, lists all the function calls that were made
    to reach the active function for the current step that leads back to the first
    or initial function call. It gives us a breadcrumb trail of function names that
    leads from the active function to the first or initial function. Thus, **Call
    Stack** lists function names upside down, the active or most recent function being
    at the top of the stack that leads downwards to the earliest or first function
    at the bottom of the stack. You can also access the functions at their locations
    to assess the variables in their scope, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – call stack](img/0655OT_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using Call Stack to trace how a function was initiated during program execution
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with MonoDevelop – the Immediate window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For games, the **Immediate** window acts like the **Console** window, as found
    in many first-person shooter games such as *Unreal*, *Half Life*, or *Call of
    Duty*. The **Immediate** window is docked by default in the bottom-right corner
    of the MonoDevelop interface. It becomes active in the break mode. Using it, we
    can enter expressions and statements that are evaluated immediately as though
    they were part of the source code for this step. We can get and set the values
    for active variables as well as perform additional operations. We can write any
    valid expression, such as `2+2` and `10*5`. The result of these expressions is
    output in the next line in the **Immediate** window, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – the Immediate window](img/0655OT_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Evaluating expressions inside the Immediate window
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you''re not simply restricted to writing isolated statements that
    involve basic arithmetical operations, such as addition and subtraction. You can
    write full expressions that include active variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – the Immediate window](img/0655OT_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing more advanced expressions in the Immediate window
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the **Immediate** window is especially useful to test code, write alternative
    scenarios in the **Immediate** window, and see how they evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with MonoDevelop – conditional breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Breakpoints are critical for debugging, and represents the starting point at
    which application execution pauses into a debug state. Often, they''ll be just
    what you need to set a breakpoint and start debugging! However, there are times
    when breakpoints, in their default configuration, can become annoying. One example
    is when a breakpoint is set inside a loop. Sometimes, you only want the breakpoint
    to take effect or pause execution after a loop has exceeded a specified number
    of iterations, as opposed to taking effect from the beginning and on every iteration
    afterwards. By default, a breakpoint inside a loop will pause the execution on
    every iteration, and if the loop is long, such pausing behavior can quickly become
    tiresome. To resolve this, you can set breakpoint conditions that specify the
    states that must be true for the breakpoint to take effect. To set a breakpoint
    condition, right-click on the breakpoint and choose **Breakpoint Properties**
    from the context menu, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – conditional breakpoints](img/0655OT_02_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing Breakpoint Properties to set a condition
  prefs: []
  type: TYPE_NORMAL
- en: Selecting **Breakpoint Properties** will display the **Breakpoint Properties**
    dialog where conditions for the breakpoint can be specified. In the **Condition**
    section, choose the **Break when condition is true** option and then use the **Condition
    expression** field to specify the condition that determines the breakpoint. For
    loop conditions, the expression `i>5` will trigger the breakpoint when the loop
    iterator has exceeded `5`. Of course, the variable `i` should be substituted for
    your own variable names.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – conditional breakpoints](img/0655OT_02_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting conditions for a breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with MonoDevelop – tracepoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tracepoints can offer you a neater alternative to using `Debug.Log` statements
    that, as we''ve seen, force us to amend the code we''re debugging. Tracepoints
    work like breakpoints, in that they mark lines within your source file. They don''t
    change the code itself, but (unlike breakpoints) they don''t pause the program
    execution when encountered by the debugger. Instead, they perform a specified
    instruction automatically. Typically, they print a debug statement to the **Application
    Output** window in MonoDevelop, though not to the Unity''s **Console**. To set
    a breakpoint in line 16 of code sample 2-10, position your cursor on line 16 and
    select **Add Tracepoint** in **Run** from the application menu (or press *Ctrl*
    + *Shift* + *F9*), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – tracepoints](img/0655OT_02_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding Tracepoint to the selected line in MonoDevelop
  prefs: []
  type: TYPE_NORMAL
- en: 'On selecting the **Add Tracepoint** option, MonoDevelop will show the **Add
    Tracepoint** dialog. The **Trace Text** field allows you to input the text to
    be printed to the **Application Output** window when the tracepoint is encountered
    at runtime. You can also insert the curly braces opening and closing symbols to
    define the regions in the string where expressions should be evaluated. This lets
    you print the values of variables into the debug string, such as `"Loop counter
    is {i}"`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – tracepoints](img/0655OT_02_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting Tracepoint Text
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on **OK**, the tracepoint is added to the selected line. Inside
    MonoDevelop, the line will be marked with a diamond shape as opposed to a circle;
    this diamond shape indicates a breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – tracepoints](img/0655OT_02_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inserting a tracepoint
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the tracepoint in the selected line in the code editor and running
    the application via the attachment with MonoDevelop, the game will run as normal,
    directly from the Unity Editor. However, when the tracepoint is encountered, the
    application will not pause or enter the break mode as it would with breakpoints.
    Instead, the tracepoint will automatically output its printed statements to MonoDevelop''s
    **Application Output** window, without causing a pause. By default, this window
    is docked at the bottom of the MonoDevelop interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging with MonoDevelop – tracepoints](img/0655OT_02_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tracepoints can print statements such as Debug.Log to the Application Output
    window in MonoDevelop
  prefs: []
  type: TYPE_NORMAL
- en: Tracepoints are an effective and helpful alternative to using the `Debug.Log`
    statements inside Unity, and you don't need to amend your code in any way to use
    them as you do with `Debug.Log`. Unfortunately, they don't print directly to Unity's
    **Console**. Instead, they appear inside the **Application Output** window in
    MonoDevelop. However, as long as you recognize this, working with tracepoints
    can be a powerful and useful method to find and remove bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter considered the process of debugging, which is centrally about
    finding and removing errors from your game. There are many methods to achieve
    this end, especially in Unity. Specifically, the methods considered here included
    the `Debug.Log` statement, perhaps the simplest of all debugging methods. Using
    this technique, `Debug.Log` statements are inserted into your code in critical
    lines, and these print diagnostic messages to Unity''s **Console**. Next, we looked
    at is custom defines: using them, you can section off and isolate blocks of your
    code between the release and debug versions; this allows you to run debug-specific
    code when specific flags are enabled. Then, we looked at error logging. This chapter
    demonstrated how to create an error logger class that integrates with native Unity''s
    application class, using delegates. We also saw the profiler; the Unity profiler
    is a pro-only feature that gives us a high-level statistical insight into how
    processing is distributed over time and system resources. In addition, we explored
    in-editor debugging and visual debugging to gain a clearer visual insight into
    our scene, and factors that affect object behavior. Finally, we saw MonoDevelop
    debugging, which does not require us to edit our code. These include breakpoints,
    tracepoints, steps, and watches. Next up, we''ll explore how to work with `GameObjects`.'
  prefs: []
  type: TYPE_NORMAL
