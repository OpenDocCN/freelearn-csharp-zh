<html><head></head><body>
		<div id="_idContainer087">
			<h1 id="_idParaDest-71"><a id="_idTextAnchor072"/><a id="_idTextAnchor073"/><em class="italic">Chapter 3</em>: Managing Scripts and Taking a Mock Test</h1>
			<p>In this chapter, we are going to continue structuring our game by applying a Singleton design pattern to our <strong class="source-inline">GameManager</strong> script. This will allow our game to move on to another scene while keeping the script managers functioning and preventing them from being wiped (thereby preserving our data). We will then make a start on other details of our script and observe how information (such as the player's lives) travels through the game's frameworks. If and when the player dies, a life is deducted. If and when the player loses all of their lives, the game over scene will be triggered.</p>
			<p>We will be extending our original code and introducing enemy points so that when we hit our enemies with bullets, the enemy will disappear as usual, but will also generate points. This scoring mechanism will be handled by a new score manager that we will be creating.</p>
			<p>We'll also be adding sound to the player's bullets, which is a straightforward task. This will introduce us to extending and tweaking our audio sources, which we'll proceed with in a later chapter.</p>
			<p>Finally, we will be quizzing ourselves with a couple of questions that suit the theme of this book, preparing you for the exam. The questions will cover what we have already learned, and if you have been following along with this book, you'll have a strong chance of passing.</p>
			<p>By the end of this chapter, we will have extended our game's framework, added more features to our game, and tested our knowledge with some Unity exam questions.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Adding a <strong class="bold">Singleton</strong> design pattern</li>
				<li>Setting up our <strong class="source-inline">ScenesManager</strong> script</li>
				<li>Creating lives for the player</li>
				<li>Scoring enemy hits</li>
				<li>Creating sounds for the player's bullets</li>
				<li>Mock test</li>
			</ul>
			<p>The next section will introduce the core exam skills that are covered in this chapter.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor074"/>The core exam skills covered in this chapter</h1>
			<p><em class="italic">Programming core interactions</em>:</p>
			<ul>
				<li>Implementing and configuring game object behavior and physics</li>
			</ul>
			<p><em class="italic">Programming for scene and environment design</em>:</p>
			<ul>
				<li>Determining scripts for implementing audio assets</li>
				<li>Identifying methods for implementing game object instantiation, destruction, and management</li>
			</ul>
			<p><em class="italic">Working in professional software development teams</em>:</p>
			<ul>
				<li>Recognizing techniques for structuring scripts for modularity, readability, and reusability</li>
			</ul>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor075"/>Technical requirements</h1>
			<p>The project content for this chapter can be found at <a href="https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_03">https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_03</a>.</p>
			<p>You can download the entirety of each chapter's project files at <a href="https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition">https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition</a>.</p>
			<p>All content for this chapter is held in the chapter's <strong class="source-inline">unitypackage</strong> file, including a <strong class="source-inline">Complete</strong> folder that holds all of the work we'll be carrying out in the chapter.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3xW4Zte">https://bit.ly/3xW4Zte</a>.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Adding a Singleton design pattern</h1>
			<p>As you will recall, back in <em class="italic">Chapter 1, Setting Up and Structuring Our Project</em>, we spoke about design patterns and how useful they are for maintaining our code. One of the design <a id="_idIndexMarker275"/>patterns we briefly covered was the Singleton pattern. Without repeating ourselves, the Singleton pattern gives us global access to code that can then be obtained at a point in our game. So, where can we see the benefits of using the Singleton design pattern? Well, we could use it so that Unity always keeps certain scripts accessible, no matter what scene we are in. We have already added a lot of structuring to our game framework and we still have a couple of manager scripts to add, such as <strong class="source-inline">ScoreManager</strong> and <strong class="source-inline">ScenesManager</strong>.</p>
			<p>Now is a good time to give all of the manager scripts global access to all other scripts in the game. Managers give a general overview of what is going on and steer which way the game needs to go without getting caught up in the details of the other scripts that are running during gameplay.</p>
			<p>In our current setup, when we run the <strong class="source-inline">testLevel</strong> scene, our <strong class="source-inline">GameManager</strong> object is in the <strong class="bold">Hierarchy</strong> window. We also have—and will be adding—more manager scripts to this game object. Currently, when we change scenes, our <strong class="source-inline">GameManager</strong> script, which sets up our scene's camera and lights, is no longer present.</p>
			<p>To stop our <strong class="source-inline">GameManager</strong> game object and script from being wiped, we are going to add a Singleton design pattern so that our <strong class="source-inline">GameManager</strong> script will always be in the scene. This design pattern will also make it so that there is only one <strong class="source-inline">GameManager</strong> script (which is where this design pattern gets its name from).</p>
			<p>In the following instructions, we will extend our original <strong class="source-inline">GameManager</strong> code to work as a Singleton script. Double-click on the <strong class="source-inline">GameManager</strong> script and let's make a start:</p>
			<ol>
				<li>At the beginning of the class, we need to add a <strong class="source-inline">static</strong> variable and a <strong class="source-inline">public static</strong> property, both referring to our <strong class="source-inline">GameManager</strong> script:<p class="source-code">static GameManager instance;</p><p class="source-code">public static GameManager Instance</p><p class="source-code">{</p><p class="source-code">  get { return instance; }</p><p class="source-code">}</p></li>
			</ol>
			<p>The reason we do this is that <strong class="source-inline">static</strong> means there is only one type of game manager. This is what we want; we don't want to have multiple instances of the same manager.</p>
			<ol>
				<li value="2">Next, we need to check and assign our <strong class="source-inline">instance</strong> variable with the <strong class="source-inline">GameManager</strong> class when the script begins with the <strong class="source-inline">Awake</strong> function.</li>
			</ol>
			<p>The <strong class="source-inline">Awake</strong> function ends with a Unity function called <strong class="source-inline">DontDestroyOnLoad</strong>. This will make sure the game object holding our <strong class="source-inline">GameManager</strong> class will not be destroyed if the scene changes.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If the player dies and loses all their lives, we can move from the level scene we are on to the <strong class="source-inline">gameOver</strong> scene, but we won't wipe the <strong class="source-inline">GameManager</strong> game object from the scene as this holds the main core methods to run the game.</p>
			<ol>
				<li value="3">Add an <strong class="source-inline">else</strong> loop <a id="_idIndexMarker276"/>to prevent any possible duplicate <strong class="source-inline">GameManager</strong> game objects. We can see these two steps in the following code block:<p class="source-code">  void Awake()</p><p class="source-code">  {</p><p class="source-code">    if(instance == null)</p><p class="source-code">    {</p><p class="source-code">      instance = this;</p><p class="source-code">      DontDestroyOnLoad(this);</p><p class="source-code">    }</p><p class="source-code">    else</p><p class="source-code">    {</p><p class="source-code">      Destroy(this.gameObject);</p><p class="source-code">    }</p><p class="source-code">    </p><p class="source-code">  }</p></li>
				<li>To make our code easier to identify, wrap the code we just typed out in the <strong class="source-inline">Awake</strong> function and put it in a method called <strong class="source-inline">CheckGameManagerIsInTheScene</strong>.</li>
				<li>Call the <a id="_idIndexMarker277"/>method from the <strong class="source-inline">Awake</strong> function.<p class="callout-heading">Tip</p><p class="callout">A similar method to <strong class="source-inline">DontDestroyOnLoad</strong> is <strong class="source-inline">MoveGameObjectToScene</strong>, which can be used to carry a single game object over to another scene. This could be useful for moving a player from one scene to another: <a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.MoveGameObjectToScene.html">https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.MoveGameObjectToScene.html</a>.</p></li>
			</ol>
			<p>That's it, our Singleton design pattern is done! The following screenshot shows a snippet of what our <strong class="source-inline">GameManager</strong> script should look like:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_3.01_B18381.jpg" alt="Figure 3.1 – Singleton code pattern in our GameManager script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Singleton code pattern in our GameManager script</p>
			<ol>
				<li value="6">Finally, save the <strong class="source-inline">GameManager</strong> script.</li>
			</ol>
			<p>We have <a id="_idIndexMarker278"/>created a Singleton design pattern that will not be wiped away when we alternate through the scenes in our game, giving us global control of our game no matter which scene we are in.</p>
			<p>Now, we can jump into adding the <strong class="source-inline">ScenesManager</strong> script and attaching it to the same game object as <strong class="source-inline">GameManager</strong> (in its <strong class="bold">Inspector</strong> window).</p>
			<p>Setting up our ScenesManager script</p>
			<p>We will take some responsibility away from the <strong class="source-inline">GameManager</strong> script by making another <a id="_idIndexMarker279"/>manager script to be more consistent with the data and methods it holds. <strong class="source-inline">ScenesManager</strong> will take and send information to and from <strong class="source-inline">GameManager</strong>. The following diagram shows how close to <strong class="source-inline">GameManager</strong> our <strong class="source-inline">ScenesManager</strong> script is within the framework when only communicating with <strong class="source-inline">GameManager</strong>:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_3.02_B18381.jpg" alt="Figure 3.2 – ScenesManager location in the Killer Wave UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – ScenesManager location in the Killer Wave UML</p>
			<p>The purpose of <strong class="source-inline">ScenesManager</strong>, apart from taking the workload off <strong class="source-inline">GameManager</strong>, is to deal with anything related to creating or changing a scene. This doesn't mean we only focus on adding and removing game levels; a scene can also consist of a start up logo, a title screen, a menu, and a game over screen, all of which are part of the <strong class="source-inline">ScenesManager</strong> script's responsibility.</p>
			<p>In this section, we will be setting up a scene template and two methods. The first method will be responsible for resetting the level if the player dies (<strong class="source-inline">ResetScene()</strong>); the second will be the game over screen (<strong class="source-inline">GameOver()</strong>).</p>
			<p>Let's make a start by creating a new script in the same way that we did in <a href="B18381_02_Epub.xhtml#_idTextAnchor048"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Adding and Manipulating Objects</em>. Follow these steps:</p>
			<ol>
				<li value="1">Name the script <strong class="source-inline">ScenesManager</strong>.</li>
				<li>Add the <a id="_idIndexMarker280"/>script to the <strong class="source-inline">GameManager</strong> game object. If you need further details on adding a script to a game object, check out the <em class="italic">Adding our script to a game object</em> section of the previous chapter.</li>
				<li>With our <strong class="source-inline">GameManager</strong> game object selected from the <strong class="bold">Hierarchy</strong> window, go to the <strong class="bold">Inspector</strong> window. We should now have the <strong class="source-inline">GameManager</strong> and <strong class="source-inline">ScenesManager</strong> scripts attached, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_3.03_B18381.jpg" alt="Figure 3.3 – GameManager game object holding two scripts (GameManager and ScenesManager)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – GameManager game object holding two scripts (GameManager and ScenesManager)</p>
			<p>Let's open the <strong class="source-inline">ScenesManager</strong> script and start coding:</p>
			<ol>
				<li value="1">Because we are obviously going to be closing and loading scenes, we are going to need to import an extra library into our <strong class="source-inline">ScenesManager</strong> script that supports these operations:<p class="source-code"><strong class="bold">using UnityEngine.SceneManagement;</strong></p><p class="source-code"><strong class="bold">using UnityEngine;</strong></p></li>
				<li>We will have a public class in our script name, followed by the usual <strong class="source-inline">MonoBehaviour</strong> being inherited:<p class="source-code"><strong class="bold">public class ScenesManager : MonoBehaviour</strong></p><p class="source-code"><strong class="bold">{</strong></p></li>
			</ol>
			<p>Now, we need <a id="_idIndexMarker281"/>to create a list of references for our scenes, as mentioned earlier. I currently have the following scenes labeled:</p>
			<ul>
				<li><strong class="source-inline">bootUp</strong>: Credits to game</li>
				<li><strong class="source-inline">title</strong>: Name of the game with an instruction to start</li>
				<li><strong class="source-inline">shop</strong>: Buy upgrades before starting the game</li>
				<li><strong class="source-inline">level1</strong>: First level</li>
				<li><strong class="source-inline">level2</strong>: Second level</li>
				<li><strong class="source-inline">level3</strong>: Final level</li>
				<li><strong class="source-inline">gameOver</strong>: Game over—delays until going back to the title scene</li>
			</ul>
			<p>We will be labeling these scenes as enumerations (which are denoted as <strong class="source-inline">enum</strong> in the C# language). These values stay consistent.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you would <a id="_idIndexMarker282"/>like to know more about enumeration, check out <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum</a>.</p>
			<ol>
				<li value="3">Enter the following code into the <strong class="source-inline">ScenesManager</strong> script:<p class="source-code">  Scenes scenes;</p><p class="source-code">  public enum Scenes</p><p class="source-code">  {</p><p class="source-code">    bootUp,</p><p class="source-code">    title,</p><p class="source-code">    shop,</p><p class="source-code">    level1,</p><p class="source-code">    level2,</p><p class="source-code">    level3,</p><p class="source-code">    gameOver</p><p class="source-code">  }</p></li>
			</ol>
			<p>We will be <a id="_idIndexMarker283"/>making and adding these scenes in their respective order in the Unity Editor later on in the book. Before we do so, let's add two methods, starting with the <strong class="source-inline">ResetScene()</strong> method, which is typically used when the player dies and the current level is reloaded. The other method, <strong class="source-inline">GameOver()</strong>, is typically called when the player loses all of their lives or when the game is complete.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor077"/>Adding the ResetScene() method</h2>
			<p>The <strong class="source-inline">ResetScene()</strong> method will <a id="_idIndexMarker284"/>be called when the player loses a <a id="_idIndexMarker285"/>life but still has another remaining. In this short method, we will set its accessibility to <strong class="source-inline">public</strong> and it returns nothing (<strong class="source-inline">void</strong>).</p>
			<p>Within this method, we will refer to Unity's <strong class="source-inline">SceneManager</strong> script (not to be confused with our <strong class="source-inline">ScenesManager</strong> class), followed by Unity's <strong class="source-inline">LoadScene</strong> method. We now need to provide a parameter to tell <strong class="source-inline">LoadScene</strong> which scene we are going to load.</p>
			<p>We use Unity's <strong class="source-inline">SceneManager</strong> script again, but this time we use <strong class="source-inline">GetActiveScene().buildIndex</strong>, which basically means getting the value number of the scene. We send this scene number to <strong class="source-inline">SceneManager</strong> to load the scene again (<strong class="source-inline">LoadScene</strong>):</p>
			<p class="source-code">  public void ResetScene()</p>
			<p class="source-code">  {</p>
			<p class="source-code">    SceneManager.LoadScene(SceneManager.GetActiveScene().    buildIndex);</p>
			<p class="source-code">  }</p>
			<p>A small <a id="_idIndexMarker286"/>but effective method, this <a id="_idIndexMarker287"/>can be called whenever we need the scene to reset. Let's now move on to the <strong class="source-inline">GameOver()</strong> method.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>Adding the GameOver() method</h2>
			<p>This method, as you may expect, is called when the player has lost all of their lives and the game <a id="_idIndexMarker288"/>ends, which means we need <a id="_idIndexMarker289"/>to move the player on to another scene.</p>
			<p>In this method, we continue adding to the <strong class="source-inline">ScenesManager</strong> script:</p>
			<p class="source-code">  public void GameOver()</p>
			<p class="source-code">  {</p>
			<p class="source-code">    SceneManager.LoadScene("gameOver");</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Similar to the previous method, we refer to this method as <strong class="source-inline">public</strong> with <strong class="source-inline">void return</strong>. Within the method, we call the same Unity function, <strong class="source-inline">SceneManager.LoadScene</strong>, but this time, we call the <strong class="source-inline">SceneManager</strong> Unity function, followed by the name of the scene we want to load by name (in this case, <strong class="source-inline">gameOver</strong>).</p>
			<p class="callout-heading">More Information</p>
			<p class="callout"><strong class="source-inline">SceneManager.LoadScene</strong> also <a id="_idIndexMarker290"/>offers a <strong class="source-inline">LoadSceneMode</strong> function, which gives us the option of using one of two properties. By default, the first property is <strong class="source-inline">Single</strong>, which closes all the scenes and loads the scene we want. The second property is <strong class="source-inline">Additive</strong>, which adds the next scene alongside the current one. This could be useful when swapping out scenes, such as a loading screen, or keeping <a id="_idIndexMarker291"/>the previous scene's settings. For more information about <strong class="source-inline">LoadScene</strong>, check out <a href="https://docs.unity3d.com/ScriptReference/SceneManagement.LoadSceneMode.html">https://docs.unity3d.com/ScriptReference/SceneManagement.LoadSceneMode.html</a>.</p>
			<p>That's our <strong class="source-inline">GameOver()</strong> method <a id="_idIndexMarker292"/>made, and when used in the same way as our <strong class="source-inline">ResetScene()</strong> method, it can be called globally. <strong class="source-inline">GameOver()</strong> can be called not only when the player loses all their lives but also when the user completes the game. It can also be used if, somehow, the game crashes, and as a default reset, we proceed to the <strong class="source-inline">gameOver</strong> scene.</p>
			<p>The next method to bring into our <strong class="source-inline">ScenesManager</strong> script is <strong class="source-inline">BeginGame()</strong>. This method is called when we need to start playing our game.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Adding the BeginGame() method</h2>
			<p>In this <a id="_idIndexMarker293"/>short section, we will add the <strong class="source-inline">BeginGame()</strong> method to our <strong class="source-inline">ScenesManager</strong> script as this will be called to start playing <a id="_idIndexMarker294"/>our game after visiting the <strong class="source-inline">shop</strong> scene, which we will cover in <a href="B18381_05_Epub.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a><em class="italic">,</em> <em class="italic">Creating a Shop Scene for Our Game</em>.</p>
			<p>With the <strong class="source-inline">ScenesManager</strong> script still open from the previous section, add the following method:</p>
			<p class="source-code">   public void BeginGame()</p>
			<p class="source-code">  {</p>
			<p class="source-code">    SceneManager.LoadScene("testLevel");</p>
			<p class="source-code">  }</p>
			<p>The code that we have just entered makes a direct call to run the <strong class="source-inline">testLevel</strong> scene, which we play our game in already. However, as our game begins to grow, we will use more than one scene.</p>
			<p>The next thing to do is to create our scenes and add them to the Unity build menu, so let's do that next. Remember to save the <strong class="source-inline">ScenesManager</strong> script before returning to the Unity Editor.</p>
			<p>Adding scenes to our Build Settings window</p>
			<p>Our game will consist of multiple scenes through which the player will need to navigate before <a id="_idIndexMarker295"/>they can fly their spaceship through the levels. This will result in them either dying or completing each <a id="_idIndexMarker296"/>level and the game, and then being taken <a id="_idIndexMarker297"/>back to the <strong class="source-inline">title</strong> scene. This is also known as a game loop. Let's start by going back to Unity and, in the Project window, creating and adding our new scenes. Follow these steps:</p>
			<ol>
				<li value="1">Go to the <strong class="source-inline">Assets/Scene</strong> folder that we created at the beginning of the previous chapter.</li>
				<li>Inside the <strong class="bold">Scene</strong> folder, in the open space, right-click so that the dropdown appears, and then click <strong class="bold">Create</strong>, followed by <strong class="bold">Scene</strong>, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_3.04_B18381.jpg" alt="Figure 3.4 – Creating an empty scene in the Unity Editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Creating an empty scene in the Unity Editor</p>
			<ol>
				<li value="3">A scene <a id="_idIndexMarker298"/>file will appear. Rename it <strong class="source-inline">bootUp</strong>.</li>
				<li>Repeat <a id="_idIndexMarker299"/>this process for the <strong class="source-inline">shop</strong>, <strong class="source-inline">level1</strong>, <strong class="source-inline">level2</strong>, <strong class="source-inline">level3</strong>, <strong class="source-inline">gameOver</strong>, and <strong class="source-inline">title</strong> scene files.</li>
			</ol>
			<p>Once <a id="_idIndexMarker300"/>we have made all of our scenes, we need to let Unity know that we want these scenes to be recognized and applied to the project build order. This is a similar process to what we did in the last chapter when adding <strong class="source-inline">testLevel</strong> to the <strong class="bold">Build Settings</strong> window. To apply the other scenes to the list, do the following:</p>
			<ol>
				<li value="5">From the top of the Unity Editor, click on <strong class="bold">File</strong> | <strong class="bold">Build Settings</strong>.</li>
				<li>The <strong class="bold">Build Settings</strong> window will open, and you should have <strong class="source-inline">testLevel</strong> in the list already. If you don't, fear not as we will be adding all our scenes to the <strong class="bold">Scenes In Build</strong> list.</li>
				<li>From <a id="_idIndexMarker301"/>the <strong class="bold">Project</strong> window, click and <a id="_idIndexMarker302"/>drag each scene into the <strong class="bold">Build Settings | Scenes</strong> <strong class="bold">in</strong> <strong class="bold">Build</strong> open space.</li>
			</ol>
			<p>Once <a id="_idIndexMarker303"/>we have added all the scenes, order them as follows:</p>
			<ul>
				<li><strong class="source-inline">bootUp</strong></li>
				<li><strong class="source-inline">title</strong></li>
				<li><strong class="source-inline">shop</strong></li>
				<li><strong class="source-inline">testLevel</strong></li>
				<li><strong class="source-inline">level1</strong></li>
				<li><strong class="source-inline">level2</strong></li>
				<li><strong class="source-inline">level3</strong></li>
				<li><strong class="source-inline">gameOver</strong><p class="callout-heading">Tip</p><p class="callout">Note that each scene automatically has a camera and a light by default in its <strong class="bold">Hierarchy</strong> window. This is fine and we will customize them later on in this book.</p></li>
			</ul>
			<p>The <strong class="bold">Build Settings</strong> window should now look as follows:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_3.05_B18381.jpg" alt="Figure 3.5 – Build Settings current Scenes In Build list order&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Build Settings current Scenes In Build list order</p>
			<p>The <a id="_idIndexMarker304"/>reason why we <a id="_idIndexMarker305"/>are putting our scenes in this order is so that <a id="_idIndexMarker306"/>there is a logical progression in the levels. As you can see at the far right of each scene in the previous screenshot, the scenes are counted in increments.  So, the first level to load will be the <strong class="source-inline">bootUp</strong> scene.</p>
			<p>Now that we have added multiple scenes to our game, we can consider the fact that we may <a id="_idIndexMarker307"/>not want our camera <a id="_idIndexMarker308"/>and light setup methods in our <strong class="source-inline">GameManager</strong> method <a id="_idIndexMarker309"/>to run in every scene of our game. Let's briefly return to our <strong class="source-inline">GameManager</strong> script and update our <strong class="source-inline">LightSetup</strong> and <strong class="source-inline">CameraSetup</strong> methods, as well as a few other things.</p>
			<h4>Updating our GameManager script</h4>
			<p>In this <a id="_idIndexMarker310"/>section, we are going to return to the <strong class="source-inline">GameManager</strong> script and make it so that the <strong class="source-inline">CameraSetup</strong> and <strong class="source-inline">LightSetup</strong> methods are called when we are controlling our spaceship only.</p>
			<p>To update our <strong class="source-inline">GameManager</strong> script to support various scenes for our lights and camera, we need to do the following:</p>
			<ol>
				<li value="1">In the Unity Editor, navigate to <strong class="source-inline">Assets/Script</strong> from the <strong class="bold">Project</strong> window.</li>
				<li>In the <strong class="source-inline">GameManager</strong> script, scroll down to the <strong class="source-inline">Start</strong> function and remove the <strong class="source-inline">LightSetup();</strong> and <strong class="source-inline">CameraSetup();</strong> methods.</li>
				<li>Next, we will enter two static global variables at the top of the <strong class="source-inline">GameManager</strong> script with the rest of the global variables:<p class="source-code">public static int currentScene = 0;</p><p class="source-code">public static int gameLevelScene = 3;</p><p class="source-code">bool died = false;</p><p class="source-code">public bool Died</p><p class="source-code">{</p><p class="source-code"> get {return died;}</p><p class="source-code"> set {died = value;}</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">currentScene</strong> is an integer that will keep the number of the current scene we are on, which we will use in the following method. The second variable, <strong class="source-inline">gameLevelScene</strong>, will hold the first level we play, which we will use later on in this chapter.</p>
			<ol>
				<li value="4">Still in <a id="_idIndexMarker311"/>the <strong class="source-inline">GameManager</strong> script, create an <strong class="source-inline">Awake</strong> function and enter the following code:<p class="source-code">void Awake()</p><p class="source-code">{ </p><p class="source-code">    CheckGameManagerIsInTheScene();</p><p class="source-code">    currentScene = UnityEngine.SceneManagement.SceneManager.</p><p class="source-code">        GetActiveScene().buildIndex;</p><p class="source-code">    LightAndCameraSetup(currentScene);</p><p class="source-code">}</p></li>
			</ol>
			<p>In the code we just entered, we store the <strong class="source-inline">buildIndex</strong> number (the numbers we have to the right of each scene in our Build Settings window from the previous section) in the <strong class="source-inline">currentScene</strong> variable. We then send the <strong class="source-inline">currentScene</strong> value to our new <strong class="source-inline">LightandCameraSetup</strong> method.</p>
			<ol>
				<li value="5">The last piece of code to add to our <strong class="source-inline">GameManager</strong> script is the <strong class="source-inline">LightandCameraSetup</strong> method, which takes an integer parameter:<p class="source-code">  void LightAndCameraSetup(int sceneNumber)</p><p class="source-code">  {</p><p class="source-code">    switch (sceneNumber)</p><p class="source-code">    {</p><p class="source-code">      //testLevel, Level1, Level2, Level3</p><p class="source-code">      case 3 : case 4 :case 5: case 6:</p><p class="source-code">      {</p><p class="source-code">        LightSetup();</p><p class="source-code">        CameraSetup();</p><p class="source-code">        break;</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p></li>
			</ol>
			<p>In the code we just wrote, we ran a <strong class="source-inline">switch</strong> statement to check the value of the <strong class="source-inline">sceneNumber</strong> variable, and if it falls into the <strong class="source-inline">3</strong>, <strong class="source-inline">4</strong>, <strong class="source-inline">5</strong>, or <strong class="source-inline">6</strong> values, we run <strong class="source-inline">LightSetup</strong> and <strong class="source-inline">CameraSetup</strong>.</p>
			<ol>
				<li value="6">Save the <strong class="source-inline">GameManager</strong> script.</li>
			</ol>
			<p>To reflect <a id="_idIndexMarker312"/>on this section, we have created a structure of empty scenes that will each serve a purpose in our game. We have also created a <strong class="source-inline">ScenesManager</strong> script that will either reset a scene when the player wins or dies and/or move to the game over scene.</p>
			<p>Now that we have our scenes in place and the start of the <strong class="source-inline">ScenesManager</strong> script has been built, we can focus on the player's life system.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/>Creating lives for the player</h1>
			<p>In this section, we are going to make it so that the player has a set number of lives. If and when <a id="_idIndexMarker313"/>the player collides with an enemy, the player will die, the scene will reset, and a life will be deducted from the player. When all the lives are gone, we will introduce the game over scene.</p>
			<p>We will be working with the following scripts in this section:</p>
			<ul>
				<li><strong class="source-inline">GameManager</strong></li>
				<li><strong class="source-inline">SceneManager</strong></li>
				<li><strong class="source-inline">Player</strong></li>
			</ul>
			<p>Let's start <a id="_idIndexMarker314"/>by revisiting the <strong class="source-inline">GameManager</strong> script and setting up the ability to give and take the player's lives:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">GameManager</strong> script and enter the following code:<p class="source-code"><strong class="bold">public static int playerLives = 3;</strong></p></li>
			</ol>
			<p>At the top of the script, just after entering the class and inheritance, enter a <strong class="source-inline">static</strong> (meaning only one) integer type labeled <strong class="source-inline">playerLives</strong>, along with the value <strong class="source-inline">3</strong>.</p>
			<p>Next, we need to create a new method for our <strong class="source-inline">GameManager</strong> script that will ensure the player loses a life. After we make this new method, the <strong class="source-inline">Player</strong> script will call it when it makes contact with an enemy.</p>
			<p>Let's continue with our <strong class="source-inline">GameManager</strong> script.</p>
			<ol>
				<li value="2">To create the <strong class="source-inline">LifeLost</strong> method, enter the following code in our <strong class="source-inline">GameManager</strong> class:<p class="source-code"><strong class="bold"> public void LifeLost()</strong></p><p class="source-code"><strong class="bold">{</strong></p></li>
			</ol>
			<p>We need this to be a <strong class="source-inline">public</strong> method so that it can be accessed from outside of the script. It's set to <strong class="source-inline">void</strong>, meaning nothing is returned from the method, and it's followed by the name of the method with empty brackets as it isn't taking any arguments.</p>
			<ol>
				<li value="3">So, within the <strong class="source-inline">LifeLost()</strong> method, we will check the player's lives with an <strong class="source-inline">if</strong> statement with the following code:<p class="source-code">    //lose life</p><p class="source-code">    if (playerLives &gt;= 1)</p><p class="source-code">    {</p><p class="source-code">      playerLives--;</p><p class="source-code">      Debug.Log("Lives left: "+playerLives);</p><p class="source-code">      GetComponent&lt;ScenesManager&gt;().ResetScene();</p><p class="source-code">    }</p></li>
			</ol>
			<p>After reviewing the <strong class="source-inline">if</strong> statement code we have entered, we will make a start by adding a comment to let ourselves or other developers know what this condition is doing (<strong class="source-inline">//lose life</strong>). We will then add the <strong class="source-inline">if</strong> statement condition, checking <a id="_idIndexMarker315"/>whether the player has more than or equal to one life left. If the player does have one or more lives left, we will deduct the player's lives by 1 with the <strong class="source-inline">--</strong> operator, which is just a quicker way of saying <strong class="source-inline">playerLives = playerLives - 1;</strong>.</p>
			<p>The line of code following on from the deduction of the player's lives isn't required, but it will notify us, in the Unity Editor <strong class="bold">Console</strong> window, with an information box telling us how many lives the player has left (for debugging purposes), as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_3.06_B18381.jpg" alt="Figure 3.6 – Console window displaying how many lives the player has left&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Console window displaying how many lives the player has left</p>
			<p>Following on from displaying how many lives the player has left in the <strong class="bold">Console</strong> window, we will refer to the <strong class="source-inline">ScenesManager</strong> script, which is attached to the <strong class="source-inline">GameManager</strong> game object. We can use <strong class="source-inline">GetComponent</strong> to access the <strong class="source-inline">ScenesManager</strong> script's <strong class="source-inline">ResetScene</strong> method, which will reset our scene.</p>
			<ol>
				<li value="4">We will now enter the <strong class="source-inline">else</strong> condition, which indicates that the player has died:<p class="source-code">    else</p><p class="source-code">    {</p><p class="source-code">      playerLives = 3;</p><p class="source-code">      GetComponent&lt;ScenesManager&gt;().GameOver();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>If our player doesn't have any more lives left, that means the <strong class="source-inline">if</strong> statement condition isn't met, so we <a id="_idIndexMarker316"/>can then offer an <strong class="source-inline">else</strong> condition. Within the scope of our <strong class="source-inline">else</strong> statement, we reset our player's lives back to <strong class="source-inline">3</strong>.</p>
			<p>We then access the <strong class="source-inline">GameOver()</strong> method from the <strong class="source-inline">ScenesManager</strong> class, which will take us from the scene we are on over to the <strong class="source-inline">gameOver</strong> scene.</p>
			<p>Lastly, all that we need to do now is to make our <strong class="source-inline">Player</strong> script call the <strong class="source-inline">LifeLost</strong> method when the player has collided with the enemy or the enemy's bullets:</p>
			<ol>
				<li value="1">Save the <strong class="source-inline">GameManager</strong> script.</li>
				<li>From the <strong class="bold">Project</strong> window, navigate to the <strong class="source-inline">Player</strong> script (<strong class="source-inline">Assets/Script</strong>).</li>
				<li>Scroll down to its <strong class="source-inline">Die</strong> method.</li>
				<li>Starting from above the destroy line (<strong class="source-inline">Destroy(this.gameObject);</strong>), enter the following code:<p class="source-code"><strong class="bold">GameManager.Instance.LifeLost();</strong></p></li>
			</ol>
			<p>Note that we can call the <strong class="source-inline">GameManager</strong> script directly without finding the game object in the scene by using code such as <strong class="source-inline">GetComponent</strong> to acquire a script. This is the power of using the Singleton design pattern, calling directly to the <strong class="source-inline">LifeLost</strong> method.</p>
			<ol>
				<li value="5">Save the <strong class="source-inline">Player</strong> script.</li>
				<li>Press <strong class="bold">Play</strong> in the Unity Editor and collide with an enemy.</li>
			</ol>
			<p>The level should reset with a message in the <strong class="bold">Console</strong> window showing that we have a particular number of lives left. Repeat this three more times. When the third life is lost, our scene should change from <strong class="source-inline">testLevel</strong> to <strong class="source-inline">gameOver</strong>.</p>
			<p>The following screenshot shows the <strong class="bold">Console</strong> window tab selected and logging the lives <a id="_idIndexMarker317"/>that are lost; also, above the <strong class="bold">Console</strong> section is the <strong class="bold">Hierarchy</strong> window, showing that our game has gone from <strong class="source-inline">testLevel</strong> to the <strong class="source-inline">gameOver</strong> scene:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_3.07_B18381.jpg" alt="Figure 3.7 – Players lives being depleted and the gameOver scene being loaded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Players lives being depleted and the gameOver scene being loaded</p>
			<p>With minimal code, we have now made it so that our player has a number of lives. We have introduced a <strong class="source-inline">ScenesManager</strong> script into our game framework that talks directly to <strong class="source-inline">GameManager</strong>, regardless of restarting and changing scenes.</p>
			<p>As a side note, you might have noticed that when we changed to the <strong class="source-inline">gameOver</strong> scene, our <strong class="source-inline">GameManager</strong> game object was carried over into the <strong class="source-inline">gameOver</strong> scene. If you recall the <em class="italic">Adding a Singleton design pattern</em> section, we set up the <strong class="source-inline">CheckGameManagerIsInTheScene</strong> method, which is called in the <strong class="source-inline">Awake</strong> function. This means that just because we are in a different scene, it doesn't mean the <strong class="source-inline">Awake</strong> function is called again.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Remember, the <strong class="source-inline">Awake</strong> function will only run when the script is active and will only run once, even if the script is attached to a game object and is carried through scenes.</p>
			<p>This is because our <strong class="source-inline">gameOver</strong> scene only carried the <strong class="source-inline">GameManager</strong> game object over to the <strong class="source-inline">gameOver</strong> scene. It wasn't activated, which means the <strong class="source-inline">Awake</strong> function wasn't called.</p>
			<p>We have <a id="_idIndexMarker318"/>our basic lives and scene structure, and we have also used the <strong class="bold">Console</strong> window to help us acknowledge the changes.</p>
			<p>Before we move on, you may notice that when the player dies, the lights get darker in the scene. The following screenshot shows what I mean:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_3.08_B18381.jpg" alt="Figure 3.8 – Lights have darkened in our game&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Lights have darkened in our game</p>
			<p>As you can see in the previous screenshot, on the left is the scene we start with, and on the right is the scene when the player has died. To fix this, we just need to make it so that we generate our lighting manually instead of it being autogenerated by Unity.</p>
			<p>To prevent our lighting from going dark between scenes, we need to do the following:</p>
			<ol>
				<li value="1">At the top of the Unity Editor, click on <strong class="bold">Window</strong> | <strong class="bold">Lighting</strong> | <strong class="bold">Settings</strong>.</li>
				<li>The <strong class="bold">Lighting Settings</strong> window will appear. At the bottom of the window, uncheck <strong class="bold">Auto Generate</strong> and click on the button next to it, <strong class="bold">Generate Lighting</strong>. Use the following screenshot for reference:</li>
			</ol>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_3.09_B18381.jpg" alt="Figure 3.9 – Unchecked Auto Generate box and the Generate Lighting button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Unchecked Auto Generate box and the Generate Lighting button</p>
			<ol>
				<li value="3">This will take a minute as Unity will be setting up the new light settings. Once this is done, save the Unity project and that should fix it.</li>
			</ol>
			<p>Note that <a id="_idIndexMarker319"/>we will likely need to set the lighting manually for other scenes, such as the other levels and the <strong class="source-inline">shop</strong> scene, later on in this book.</p>
			<p>Let's now turn our focus to the enemy and add some functionality so that when it is destroyed by the player, we can add a score to <strong class="source-inline">ScoreManager</strong>, which is a new script that we will be making next.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor081"/>Scoring enemy hits</h1>
			<p>As with most games, we need <a id="_idIndexMarker320"/>a scoring system to show how well the player has done at the end of the game. Typically, with side-scrolling shooter games, the player is rewarded for each kill they make. If we turn to our game framework diagram, we can see that <strong class="source-inline">ScoreManager</strong> is hooked up to <strong class="source-inline">GameManager</strong> like <strong class="source-inline">ScenesManager</strong> was:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_3.10_B18381.jpg" alt="Figure 3.10 – Killer Wave UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Killer Wave UML</p>
			<p>Our code for adding a scoring system will once again be minimal. We also want flexibility so that different <a id="_idIndexMarker321"/>enemies are worth different points. We also want it so that when we add another enemy to our game with a different scoring point, we can avoid altering our code each time.</p>
			<p>We will be working with the following scripts in this section:</p>
			<ul>
				<li><strong class="source-inline">EnemyWave</strong></li>
				<li><strong class="source-inline">ScoreManager</strong></li>
				<li><strong class="source-inline">ScenesManager</strong></li>
				<li><strong class="source-inline">SOActorModel</strong></li>
			</ul>
			<p>Since the scoring system is an integral factor in our game, it would make sense to add a simple integer to <strong class="source-inline">SOActorModel</strong> that injects common values into our game objects. This trend will then follow on to other scripts. Let's start adding some code to our already-made scripts before we introduce <strong class="source-inline">ScoreManager</strong>.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor082"/>Preparing the code for the ScoreManager script</h2>
			<p>If you recall <a href="B18381_01_Epub.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up and Structuring Our Project</em>, we spoke about the SOLID principles and how important it is to add to our code rather than change it, or we risk errors <a id="_idIndexMarker322"/>and our code may start mutating and <a id="_idIndexMarker323"/>eventually become unfit for purpose. In order to prepare, we will add code to the scripts that we have already made to fit our <strong class="source-inline">ScoreManager</strong> script into place. Let's start with <strong class="source-inline">SOActorModel</strong> first. Follow these steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">SOActorModel</strong> script from the <strong class="bold">Project</strong> window.</li>
				<li>Anywhere within our list of variables in the <strong class="source-inline">SOActorModel</strong> script, add the following code, which will be used to contain the enemy's score:<p class="source-code"><strong class="bold">public int score;</strong></p></li>
				<li>Save the <strong class="source-inline">SOActorModel</strong> script.</li>
			</ol>
			<p>Before we add more code to the other scripts to fit <strong class="source-inline">ScoreManager</strong> into our game, we need to acknowledge that we have made a change to our <strong class="source-inline">ScriptableObject</strong> template.</p>
			<p>Let's check our <strong class="source-inline">BasicWave Enemy</strong> scriptable object in the Unity Editor. Follow these steps:</p>
			<ol>
				<li value="1">From the <strong class="bold">Project</strong> window, navigate to the <strong class="source-inline">Assets/ScriptableObject</strong> folder.</li>
				<li>Click once on <strong class="bold">BasicWave Enemy</strong> and you will see that the <strong class="bold">Inspector</strong> window has a <strong class="bold">Score</strong> input field.</li>
				<li>Give the <strong class="bold">Score</strong> field of <strong class="source-inline">BasicWave Enemy</strong> a value of your choice. I'm giving it a value of <strong class="source-inline">200</strong>. It really doesn't matter what value you give it as long as it's more than <strong class="source-inline">0</strong>. The following screenshot shows the <strong class="bold">BasicWave Enemy</strong> section with its updated <strong class="bold">Score</strong> value:</li>
			</ol>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_3.11_B18381.jpg" alt="Figure 3.11 – enemy_wave score property and value added&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – enemy_wave score property and value added</p>
			<p>We have updated the <strong class="source-inline">BasicWave Enemy</strong> scriptable object. We now need to focus on the <strong class="source-inline">EnemyWave</strong> script to create and receive this new variable.</p>
			<ol>
				<li value="4">Open the <strong class="source-inline">EnemyWave</strong> script.</li>
				<li>At the <a id="_idIndexMarker324"/>top of the script, where <a id="_idIndexMarker325"/>we have our <strong class="source-inline">health</strong>, <strong class="source-inline">travelSpeed</strong>, and other global variables, add an extra variable to the list:<p class="source-code"><strong class="bold">int score;</strong></p></li>
			</ol>
			<p>We now need to update the <strong class="source-inline">score</strong> variable from the <strong class="source-inline">ScriptableObject</strong> value.</p>
			<ol>
				<li value="6">In the <strong class="source-inline">EnemyWave</strong> script, scroll down until you find the <strong class="source-inline">ActorStats</strong> method, then add the following extra line of code:<p class="source-code"><strong class="bold">score = actorModel.score;</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">EnemyWave</strong> script now has a <strong class="source-inline">score</strong> variable that is set from the value given to it by <strong class="source-inline">SOActorModel</strong>. The last thing we need to do is send the score value to <strong class="source-inline">ScoreManager</strong> when the enemy dies due to the actions of the player. Before we do that, let's create and code our <strong class="source-inline">ScoreManager</strong> script.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Setting up our ScoreManager script</h2>
			<p>The purpose <a id="_idIndexMarker326"/>of the <strong class="source-inline">ScoreManager</strong> script is to total up the score of the player during their game, concluding <a id="_idIndexMarker327"/>when they arrive at the <strong class="source-inline">gameOver</strong> scene. We could also give the <strong class="source-inline">ScoreManager</strong> script other score-related functionality, such as the ability to store our score data on the device that we are playing the game on or to send the score data to a server for an online scoreboard. For now, we will keep things simple and just collect the player's score.</p>
			<p>We can create and add our <strong class="source-inline">ScoreManager</strong> script to the game framework, as follows:</p>
			<ol>
				<li value="1">Create and attach a script called <strong class="source-inline">ScoreManager</strong> to the <strong class="source-inline">GameManager</strong> game object, similar to how we did with <strong class="source-inline">ScenesManager</strong>.</li>
			</ol>
			<p>If you can't remember how to do this, then check out the <em class="italic">Setting up our ScenesManager script</em> section of this chapter. The following screenshot shows <strong class="source-inline">ScoreManager</strong> attached to the <strong class="source-inline">GameManager</strong> game object in the <strong class="bold">Inspector</strong> window:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_3.12_B18381.jpg" alt="Figure 3.12 – ScoreManager script added to the GameManager game object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – ScoreManager script added to the GameManager game object</p>
			<p>Next, we are going to open the <strong class="source-inline">ScoreManager</strong> script and add code that will hold and send score data. Open the <strong class="source-inline">ScoreManager</strong> script and enter the following code:</p>
			<p class="source-code"><strong class="bold">using UnityEngine;</strong></p>
			<p>By default, we require the <strong class="source-inline">UnityEngine</strong> library, as previously mentioned.</p>
			<ol>
				<li value="2">Continue <a id="_idIndexMarker328"/>by checking and <a id="_idIndexMarker329"/>entering the name of the class:<p class="source-code"><strong class="bold">public class ScoreManager : MonoBehaviour</strong></p><p class="source-code"><strong class="bold">{</strong></p></li>
			</ol>
			<p>This is a public class, with <strong class="source-inline">ScoreManager</strong> inheriting <strong class="source-inline">MonoBehaviour</strong> to increase the functionality of the script.</p>
			<ol>
				<li value="3">Next, we add our variables and properties to our script. The only value we are concerned about is <strong class="source-inline">playerScore</strong>, which is private to the script (because we don't want other classes to have access). This variable is also set to <strong class="source-inline">static</strong>, meaning we don't need duplicate references for this variable.</li>
			</ol>
			<p>Following on from this is our <strong class="source-inline">public</strong> property, which gives outside classes access to the <strong class="source-inline">playerScore</strong> variable. As you'll notice, the <strong class="source-inline">PlayerScore</strong> property returns an integer. Within this property, we use the <strong class="source-inline">get</strong> accessor to return our private <strong class="source-inline">playerScore</strong> integer. It is a good habit to keep our variables private, or you risk exposing your code to other classes, which can result in errors. The following code shows you how to complete this step:</p>
			<p class="source-code">    static int playerScore;</p>
			<p class="source-code">    public int PlayersScore </p>
			<p class="source-code">    {</p>
			<p class="source-code">        get</p>
			<p class="source-code">        {</p>
			<p class="source-code">            return playerScore;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="callout-heading">Accessors</p>
			<p class="callout">To find out more about accessors, check out <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get</a>.</p>
			<ol>
				<li value="4">We will <a id="_idIndexMarker330"/>now move on to the <strong class="source-inline">SetScore</strong> method; it is public and doesn't return a value (<strong class="source-inline">void</strong>), with the <strong class="source-inline">SetScore</strong> name taking in an integer parameter named <strong class="source-inline">incomingScore</strong>. Within <a id="_idIndexMarker331"/>this method, we use <strong class="source-inline">incomingScore</strong> to add to the <strong class="source-inline">playerScore</strong> script (as its total score):<p class="source-code">  public void SetScore(int incomingScore)</p><p class="source-code">    {</p><p class="source-code">        playerScore += incomingScore;</p><p class="source-code">    }</p></li>
				<li>The last method to add is the <strong class="source-inline">ResetScore</strong> method. Enter the following code:<p class="source-code"> public void ResetScore()</p><p class="source-code">  {</p><p class="source-code">    playerScore = 00000000;</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>We can call this method at the beginning or end of a game to stop the score from carrying on into the next game.</p>
			<ol>
				<li value="6">Save the script.</li>
			</ol>
			<p>As mentioned earlier, we can now return to the <strong class="source-inline">EnemyWave</strong> script to send the value of the enemy's score points to the <strong class="source-inline">ScoreManagers</strong> method, <strong class="source-inline">SetScore</strong>, thereby adding them to the player's total score:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">EnemyWave</strong> script from the <strong class="bold">Project</strong> window and scroll down to the <strong class="source-inline">OnTriggerEnter</strong> Unity function.</li>
				<li>Within the scope of the <strong class="source-inline">if</strong> statement labeled <strong class="source-inline">if (health &lt;= 0)</strong>, enter the following line of code at the top of its scope:<p class="source-code"><strong class="bold">GameManager.Instance.GetComponent&lt;ScoreManager&gt;().SetScore(score);</strong></p></li>
			</ol>
			<p>When <a id="_idIndexMarker332"/>this particular enemy <a id="_idIndexMarker333"/>dies as a result of the player, this line of code will send the enemy's <strong class="source-inline">score</strong> value directly to the <strong class="source-inline">playerScore</strong> variable and increment it toward its total until the player loses all of their lives.</p>
			<ol>
				<li value="3">Finally, to confirm the score has totaled correctly, let's do what we did before with the <strong class="source-inline">playerLives</strong> integer in the <strong class="source-inline">LifeLost</strong> method of the <strong class="source-inline">GameManager</strong> script and add a <strong class="source-inline">Debug.Log</strong> message to the <strong class="bold">Console</strong> window.</li>
				<li>In the <strong class="source-inline">ScenesManager</strong> script under the <strong class="source-inline">GameOver()</strong> method, add the following line of code at the top within its scope:<p class="source-code">Debug.Log("ENDSCORE: " +</p><p class="source-code">  GameManager.Instance.GetComponent&lt;ScoreManager&gt;</p><p class="source-code">     ().PlayersScore);</p></li>
			</ol>
			<p>This code will tell us how much the player has scored because it directly accesses <strong class="source-inline">ScoreManager</strong> and grabs the <strong class="source-inline">PlayerScore</strong> property when the game is over. The following screenshot shows an example of a totaled score:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Figure_3.13_B18381.jpg" alt="Figure 3.13 – Game over score value displayed in the Console window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Game over score value displayed in the Console window</p>
			<ol>
				<li value="5">Finally, save all the scripts.</li>
			</ol>
			<p>In this section, we introduced the <strong class="source-inline">ScoreManager</strong> script with its basic working structure of totaling <a id="_idIndexMarker334"/>up our end score and displaying <a id="_idIndexMarker335"/>the final count in the <strong class="bold">Console</strong> window. We have also added more code to a selection of scripts without deleting and changing any of their content. Next, we will be doing something different that doesn't involve any coding but gets us more familiar with Unity's sound components.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor084"/>Creating sounds for the player's bullets</h1>
			<p>Up until now, our game has been silent, but sound is an important factor in any game. In this section, we will <a id="_idIndexMarker336"/>be introducing our first sound component. We will <a id="_idIndexMarker337"/>make a start by creating sound effects for when our player fires a bullet.</p>
			<p>Feel free to add your own type of bullet sound if you wish. You can add sound to your player's standard bullets as follows:</p>
			<ol>
				<li value="1">In the Unity Editor, navigate to the <strong class="bold">Project</strong> window and create a new folder inside the <strong class="source-inline">Resources</strong> folder. Name the new folder <strong class="source-inline">Sound</strong>.</li>
				<li>Drag and drop the <strong class="source-inline">Player_Bullet</strong> prefab from the <strong class="bold">Project</strong> panel into the <strong class="bold">Hierarchy</strong> panel.</li>
				<li>With <strong class="source-inline">Player_Bullet</strong> still selected, click on the <strong class="bold">Add Component</strong> button in the <strong class="bold">Inspector</strong> panel.</li>
				<li>In its dropdown, start typing (and select) <strong class="source-inline">Audio Source</strong>.</li>
				<li>Drag and <a id="_idIndexMarker338"/>drop the <strong class="source-inline">PlayerLaser.mp3</strong> file into the <strong class="bold">AudioClip</strong> section of the <strong class="bold">Audio Source</strong> component. The following screenshot shows <strong class="source-inline">Player_Bullet</strong> selected. The audio file at the bottom left needs to be dragged into the <strong class="bold">Audio Source</strong> component at the right:</li>
			</ol>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_3.14_B18381.jpg" alt="Figure 3.14 – Adding sound file to the Player_Bullet's Audio Source game object in the &#13;&#10;Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Adding sound file to the Player_Bullet's Audio Source game object in the Inspector window</p>
			<ol>
				<li value="6"><strong class="bold">Play on Awake</strong> is automatically ticked. As you can imagine, as soon as <strong class="source-inline">Player_Bullet</strong> is instantiated, the sound will play.</li>
				<li>If the volume is too high, simply lower it in the <strong class="bold">Audio Source</strong> component of the <strong class="bold">Inspector</strong> window.<p class="callout-heading">Information</p><p class="callout">As well as the <strong class="bold">Volume</strong> option in the <strong class="bold">Audio Source</strong> component, there is <strong class="bold">Pitch</strong> to change the sound of our bullet and <strong class="bold">Stereo Pan</strong> to make the sound more dominant in the left or right speaker. Finally, because this is a two-dimensional game, we don't want the sound to be affected by how close our camera is to the bullet. So, we slide the <strong class="bold">Spatial Blend</strong> toggle all the way to the left to make sure it is not affected by its distance.</p></li>
				<li>Finally, click on <strong class="bold">Overrides | Apply All </strong> in the top-right corner to save and update the <strong class="source-inline">Player_Bullet</strong> prefab and remove the bullet from the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Play the scene and start firing. You will hear laser noises, and, in the scene view, you will see speaker symbols now attached to the player's bullets.</li>
			</ol>
			<p>That brings us <a id="_idIndexMarker339"/>to the end of this short section on audio, but we will cover more on audio throughout this book. Don't forget that if you get stuck at any point, check the <strong class="source-inline">Complete</strong> folder for this chapter and compare the scenes and code to make sure nothing is missing.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor085"/>Summary</h1>
			<p>In this chapter, we have extended our game framework structure by implementing and reinforcing the <strong class="source-inline">GameManager</strong> script by extending its code. This means that it will never be deleted, regardless of scene changes. We have also introduced the score and scenes managers, which were originally planned in our game framework. These two additional managers take responsibility away from the game manager and add additional features to your game. We ensured these scripts don't mutilate our original code (removing, overflowing, or compensating for our game manager). Your game now has a working scoring system, as well as multiple scenes that can be restarted and changed with very little code. We also introduced sound, which we'll implement in more detail in later chapters.</p>
			<p>In the next chapter, we'll focus less on code-heavy content and instead concern ourselves with the art of the game. Even though we are programmers, we need to understand how to manipulate assets and how to animate with Unity's API. With just a little bit of coding, this will allow us to understand the connection between the Editor and our script. We'll also touch on some particle effects.</p>
			<p>Well done—you've done and covered a lot. Before we move on, have a go at the following questions. They resemble what you will encounter in your programmer exam.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor086"/>Mock test</h1>
			<p>This is your first mini mock test. These tests represent sections of your final Unity exam. This first mini mock test consists of just five questions. Later on in this book, we'll introduce more mini mock tests with more questions.</p>
			<p>Fortunately, you will only be tested on what we have covered so far:</p>
			<ol>
				<li value="1">You have been asked to develop a horror survival game where your player relies on a pocket torch. Here is what you've coded so far:<p class="source-code">void Start()</p><p class="source-code">{</p><p class="source-code">    Light playersTorch = GetComponent&lt;Light&gt;();</p><p class="source-code">    playersTorch.lightMapBakeType = LightMapBakeType.    Mixed;</p><p class="source-code">    playersTorch.type = LightType.Area;</p><p class="source-code">    playersTorch.shadows = LightShadows.Soft;</p><p class="source-code">    playersTorch.range = 5f;</p><p class="source-code">}</p></li>
			</ol>
			<p>You notice, however, that the player's torch isn't casting any light or shadows. What should you change for this code to work as desired?</p>
			<ol>
				<li>Set <strong class="source-inline">playersTorch.lightBakeType</strong> to <strong class="source-inline">LightmapBakeType.Realtime</strong>.</li>
				<li>Set <strong class="source-inline">playersTorch.range</strong> to <strong class="source-inline">10</strong>.</li>
				<li>Set <strong class="source-inline">playersTorch.shadows</strong> to <strong class="source-inline">LightShadows.Hard</strong>.</li>
				<li>Set <strong class="source-inline">playersTorch.type</strong> to <strong class="source-inline">LightType.Point</strong>.</li>
			</ol>
			<ol>
				<li value="2">You have started creating your first indie game, Super Moped Racer 64. You have coded your input controls to work with a joystick and started testing your moped around corners. You've noticed that after taking the moped around the first corner, the moped continues turning even after you've let go of the joystick.</li>
			</ol>
			<p>You've checked your code and the joystick and both seem to be working fine, suggesting the issue is with the input manager.</p>
			<p>What change should you make within the input manager?</p>
			<ol>
				<li>Increase the gravity.</li>
				<li>Set <strong class="source-inline">Snap</strong> to <strong class="source-inline">true</strong>.</li>
				<li>Increase <strong class="source-inline">Deadzone</strong>.</li>
				<li>Decrease <strong class="source-inline">Sensitivity</strong>.</li>
			</ol>
			<ol>
				<li value="3">You have started to template a game framework with pen and paper. You have drawn up several manager scripts that will all lead to the creation of a single <strong class="source-inline">GameManager</strong> script. You only require one <strong class="source-inline">GameManager</strong> script, which will always be in your scene.</li>
			</ol>
			<p>Which design pattern suits having a <strong class="source-inline">GameManager</strong> script in a persistent instance role?</p>
			<ol>
				<li>Prototype</li>
				<li>Abstract Factory</li>
				<li>Singleton</li>
				<li>Builder</li>
			</ol>
			<ol>
				<li value="4">You have been requested to create a prototype for a side-scrolling game where your player throws rocks at their enemies. The game works well and the camera moves from left to right until the level is over. To throw a rock, your code instantiates a prefab of a rock, which is then given a force (<strong class="source-inline">Rigidbody.AddForce</strong>) to launch the rock to give the illusion of the rock being thrown.</li>
			</ol>
			<p>Your lead developer says that your method is costing too much in-memory performance and wants you to store a maximum of 10 rocks from within an array of rocks using a design pattern. Once a rock is used, instead of being destroyed, it should return to the array.</p>
			<p>What design pattern is the developer referring to?</p>
			<ol>
				<li>Abstract Factory</li>
				<li>Object Pool</li>
				<li>Dependency Injection</li>
				<li>Builder</li>
			</ol>
			<p>That's the end of your first mini mock test. To check your answers, refer to the <a href="B18381_Appendix_Epub.xhtml#_idTextAnchor245"><em class="italic">Appendix</em></a> section at the back of this book. How did you do? To review any incorrect answers, I suggest flicking back through the last couple of chapters to the relevant section and refreshing your memory where needed. Sadly, exams can be a bit of a memory game. Everyone's memory is different, and the majority of people that pass these exams have failed on certain sections before passing.</p>
			<p>Either way, the more you complete these tests, the stronger you will become at them. Just stay focused and you'll get through it!</p>
		</div>
	</body></html>