# *第9章*：使用端点路由

在本章中，我们将讨论**ASP.NET Core**中的新端点路由。我们将学习端点路由是什么，它是如何工作的，它在哪些地方被使用，以及你如何创建自己的路由到自己的端点。

在本章中，我们将涵盖以下主题：

+   探索端点路由

+   创建自定义端点

+   创建一个更复杂的端点

本章中的主题涉及ASP.NET Core架构的路由层：

![图9.1 – ASP.NET Core架构

](img/Figure_9.1_B17996.jpg)

图9.1 – ASP.NET Core架构

# 技术要求

对于这个系列，我们只需要设置一个小型的空Web应用程序：

[PRE0]

就这些了！使用Visual Studio Code打开应用程序：

[PRE1]

本章中的所有代码示例都可以在本书的**GitHub**仓库中找到：[https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09)。

# 探索端点路由

要了解**端点路由**，你需要了解什么是**端点**以及什么是**路由**。

**端点**是应用程序的一部分，当路由将进入的请求映射到它时，它会被执行。让我们更详细地分析这个定义。

客户端通常从服务器请求资源。在大多数情况下，客户端是浏览器。资源由URL定义，指向特定的目标。在大多数情况下，目标是网页。它也可能是一个请求特定数据的移动应用，该数据来自JSON Web API。应用请求的数据在URL中定义。

这意味着进入的请求也由URL定义。另一方面，正在执行的端点映射到特定的路由。路由是一个URL或URL的模式。ASP.NET Core开发者已经熟悉这样的路由模式：

[PRE2]

如果路由或路由模式与进入请求的URL匹配，请求就会被映射到该端点。在这种情况下，请求被映射到MVC端点。

ASP.NET Core可以映射到以下端点：

+   控制器（例如，MVC或Web API）

+   Razor Pages

+   SignalR（和Blazor Server）

+   gRPC服务

+   健康检查

大多数端点都有非常简单的路由模式。只有MVC和Web API端点使用更复杂的模式。Razor页面的路由定义基于实际页面的文件夹和文件结构。

在ASP.NET Core 2.2引入端点之前，路由仅在MVC和Web API中存在。**Razor Pages**中的隐式路由是内置的，而SignalR还没有准备好。那时，Blazor和gRPC还没有出现，健康检查最初被实现为一个中间件组件。

端点路由被引入以将路由与实际端点分离。这使得框架更加灵活，并且意味着新的端点不需要实现自己的路由方式。这样，端点可以使用现有的灵活路由技术来映射到特定的路由。

接下来，我们将看到如何创建自己的自定义端点。

# 创建自定义端点

创建端点最简单的方法是使用基于 lambda 的端点：

[PRE3]

这将 `/map` 路由映射到一个简单的端点，该端点将单词 `"OK"` 写入响应流。

关于先前 .NET 6.0 版本的一则说明

在 .NET 6.0 之前，你会在 `Startup.cs` 文件中传递给 `UseEndpoints` 方法的 lambda 中定义的 `endpoints` 对象上映射自定义端点。在 .NET 6.0 及 `Program.cs` 文件中的新 `app` 对象中。

你可能需要将 `Microsoft.AspNetCore.Http` 命名空间添加到 `using` 语句中。

你还可以将特定的 HTTP 方法（如 `GET`、`POST`、`PUT` 和 `DELETE`）映射到一个端点。以下代码展示了如何映射 `GET` 和 `POST` 方法：

[PRE4]

我们还可以将两个或多个 HTTP 方法映射到一个端点：

[PRE5]

这些端点看起来像我们在 [*第 8 章*](B17996_08_ePub.xhtml#_idTextAnchor124) *编写自定义中间件* 中看到的基于 lambda 的终止中间件组件。这些是终止管道并返回结果的中间件组件，例如基于 HTML 的视图、JSON 结构化数据或类似内容。端点路由是创建输出的更灵活方式，并且应该从 ASP.NET Core 3.0 及以后的版本开始使用。

在 [*第 8 章*](B17996_08_ePub.xhtml#_idTextAnchor124) *编写自定义中间件* 中，我们看到了我们可以像这样分支管道：

[PRE6]

这也创建了一个路由，但这个路由只会监听以 `/map` 开头的 URL。如果你希望有一个能够处理类似 `/map/{id:int?}` 的模式的路由引擎，同时匹配 `/map/456` 而不是 `/map/abc`，你应该使用新的路由，就像在本节前面所展示的那样。

这些基于 lambda 的端点对于简单场景很有用。然而，由于它们定义在 `Program.cs` 中，如果你开始使用这种基于 lambda 的方法实现更复杂的场景，事情会很快变得混乱。

因此，我们应该尝试找到一种更结构化的方式来创建自定义端点。

# 创建更复杂的端点

在本节中，我们将逐步创建一个更复杂的端点。让我们通过编写一个非常简单的健康检查端点来实现，这类似于如果你在 **Kubernetes** 集群内部运行应用程序或只是告诉他人你的健康状态时可能需要的情况：

1.  微软建议从定义API开始，从开发者的角度添加端点。我们在这里也是这样做。这意味着我们首先会添加一个`MapSomething`方法，但不包含实际实现。这将是一个在`IEndpointRouteBuilder`对象上的扩展方法。我们将称之为`MapMyHealthChecks`：

    [PRE7]

    新的端点应该以与预构建端点相同的方式添加，以免混淆需要使用它的开发者。

    现在我们已经知道了这个方法应该是什么样子，让我们来实施它。

1.  创建一个新的静态类`MapMyHealthChecksExtensions`，并在`MapMyHealthChecks`对象内部放置一个扩展方法，该扩展方法扩展`IEndpointRouteBuilder`并返回一个`IEndpointConventionBuilder`对象。我将其放置在`MapMyHealthChecksExtensions.cs`文件中：

    [PRE8]

    这只是一个框架。让我们先从实际的端点开始，然后再使用它。

1.  实际的端点将被编写为一个*终止*中间件组件——也就是说，一个不调用下一个组件的中间件组件（参见[*第8章*](B17996_08_ePub.xhtml#_idTextAnchor124)，*编写自定义中间件*）并创建输出到响应流：

    [PRE9]

    实际的工作是在`Invoke`方法中完成的。目前，这实际上并没有做更多的事情，只是以纯文本形式响应`OK`和`200` HTTP状态，如果你只是想显示你的应用程序正在运行，这是完全可以接受的。你可以自由地扩展这个方法，添加实际的检查，例如检查数据库或相关服务的可用性，例如。然后，你需要更改HTTP状态和与检查结果相关的输出。

    让我们使用这个终止中间件。

1.  让我们回到`MapMyHealthChecks`方法的框架。我们现在需要创建自己的管道，并将其映射到给定的路由。将以下行放置在该方法中：

    [PRE10]

1.  这种方法允许你只为这个新的管道添加一些额外的中间件。`WithDisplayName`扩展方法将配置的显示名称设置为端点。

1.  就这样！在你的IDE中按*F5*启动应用程序，并在浏览器中调用`https://localhost:7111/myhealth`。你应该在浏览器中看到**OK**：

![图9.2 – 端点路由输出的截图](img/Figure_9.2_B17996.jpg)

图9.2 – 端点路由输出的截图

请注意端口号可能不同。你还可以将现有的终止中间件组件转换为路由端点，以获得更灵活的路由。这就是本章的全部内容！

# 摘要

ASP.NET Core知道许多处理请求和向请求客户端提供信息的方式。端点路由是一种基于请求的URL和请求方法提供资源的方式。

在本章中，您学习了如何使用终止中间件组件作为端点，并将其映射到新的路由引擎，以实现更高的灵活性，匹配您希望用于向请求客户端提供信息的路由。

每个网络应用程序都需要了解其用户，以便允许或限制对应用程序特定区域或特定数据的访问。在下一章中，我们将展示如何配置身份验证以识别您的用户。
