<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-220"><a id="_idTextAnchor232" class="pcalibre1 pcalibre calibre6"/>12</h1>
<h1 id="_idParaDest-221" class="calibre5"><a id="_idTextAnchor233" class="pcalibre1 pcalibre calibre6"/>Enhancing the FPS Game with Audio</h1>
<p class="calibre3">In <a href="B18347_11.xhtml#_idTextAnchor212" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 11</em></a>, we transformed a gray-boxed prototype environment by replacing modular Prefabs with high-quality 3D models, preserved Prefabs with extra behavior in Prefab Mode, and applied new materials. We also added objects to the environment by painting Prefabs, telling surface stories by placing wear-and-tear decals, and implementing lighting and shadow setups for real-time and baked lighting.</p>
<p class="calibre3">To improve the player experience, we have to work on the sound design aspect of our game. Until now, we haven’t given much attention to audio <a id="_idIndexMarker1181" class="pcalibre1 pcalibre calibre6"/>and <strong class="bold">sound effects</strong> (<strong class="bold">SFX</strong>). Let’s change that now by developing an audio manager and reusable audio player components system. This will allow us to easily add audio and SFX to our game, even for designers and artists who may not have much experience with coding.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:<a id="_idTextAnchor234" class="pcalibre1 pcalibre calibre6"/></p>
<ul class="calibre17">
<li class="calibre15">Adding audio using the Audio Mixer</li>
<li class="calibre15">Building an immersive soundscape with music, SFX, and ambiance</li>
<li class="calibre15">Enhancing the audio experience with footsteps and reverb zone<a id="_idTextAnchor235" class="pcalibre1 pcalibre calibre6"/>s</li>
<li class="calibre15">Deeper SOLID refactoring</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to code an audio manager and its components to play game music and SFX through an Audio Mixer. You will also gain an understanding of the differences between playing 2D and 3D sound and how to reuse audio playing components to create new sound behavior, such as footstep sounds. Additionally, you will learn how to add effects zones to your game’s level.</p>
<h1 id="_idParaDest-222" class="calibre5">Technical requirements<a id="_idTextAnchor236" class="pcalibre1 pcalibre calibre6"/></h1>
<p class="calibre3">You can download the complete project on GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<h1 id="_idParaDest-223" class="calibre5"><a id="_idTextAnchor237" class="pcalibre1 pcalibre calibre6"/>Adding audio using the Audio Mixer</h1>
<p class="calibre3">In any interactive<a id="_idIndexMarker1182" class="pcalibre1 pcalibre calibre6"/> experience, sound is pivotal in enveloping <a id="_idIndexMarker1183" class="pcalibre1 pcalibre calibre6"/>the player in the game world. This section will introduce different ways to play audio using Unity’s audio tooling. You’ll learn how to elevate your game’s audio experience by effectively utilizing music, both 2D and 3D SFX, ambient noise, and reverb zones.</p>
<p class="calibre3">Let’s get started by defining what sound design is.</p>
<h2 id="_idParaDest-224" class="calibre8"><a id="_idTextAnchor238" class="pcalibre1 pcalibre calibre6"/>Sound design 101 for games</h2>
<p class="calibre3">Good sound<a id="_idIndexMarker1184" class="pcalibre1 pcalibre calibre6"/> design can significantly enhance<a id="_idIndexMarker1185" class="pcalibre1 pcalibre calibre6"/> the player’s experience and immersion in the game. Play your favorite game but turn off the sound, and you’ll see quite quickly that the experience is not the same!</p>
<p class="calibre3">Several audio concepts come together to form the foundation of sound design in creating the atmosphere for an immersive world. While I’ll be introducing sound design components, just know it’s more art than technical in bringing all the concepts together – this is the job of a sound designer!</p>
<p class="calibre3">We’ll be implementing audio scripts that will enable us to add the following elements of sound design:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Music/background music</strong>: Set the<a id="_idIndexMarker1186" class="pcalibre1 pcalibre calibre6"/> mood with music! Also, changes in music at the right moments of gameplay can be impactful to the player.</li>
<li class="calibre15"><strong class="bold">SFX</strong>: Every time the player swings their sword, picks up a coin, bumps into a crate, or defeats an enemy, SFX is crucial for player immersion and enhancing the gameplay experience.</li>
<li class="calibre15"><strong class="bold">Ambience or atmosphere</strong>: The environmental sounds, or background noise, you hear that sets the scene and lets you know you are in a real living place. Generally, 3D audio changes based on the player’s position and orientation to an audio source in the environment, which can greatly enhance immersion.</li>
<li class="calibre15"><strong class="bold">Character dialogue</strong>: Yes, dialogue is sound design too. The style of their voice can further define a character. Voice can also be used to drive a story-driven narrative.</li>
<li class="calibre15"><strong class="bold">UI feedback</strong>: <em class="italic">Clicks</em>, <em class="italic">boops</em>, and <em class="italic">beeps</em> on button presses and changes in the UI when the player is interacting provide a satisfying feedback experience that you don’t want<a id="_idIndexMarker1187" class="pcalibre1 pcalibre calibre6"/> to omit from your overall sound design.</li>
</ul>
<p class="calibre3">Gathering all of the preceding sound design elements together into a cohesive audio soundscape for a game experience is another job performed by the sound designer, and it is called <a id="_idIndexMarker1188" class="pcalibre1 pcalibre calibre6"/>audio mixing. <strong class="bold">Audio mixing</strong> allows for further engineering of the audio experience and can include additional audio tooling such as filters, effects, and reverb zones.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">When it comes to audio, there are many factors to consider, such as formats, file size, compression quality, looping capabilities, and runtime performance – for starters. While a deep dive into the technical aspects of varying audio formats is not within the scope of this chapter, rest assured that I won’t shy away from pointing out crucial format details wherever necessary in the upcoming sections.</p>
<p class="callout">You can read more about audio here: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/Audio.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/Audio.xhtml</a>.</p>
<p class="calibre3">Now that we<a id="_idIndexMarker1189" class="pcalibre1 pcalibre calibre6"/> understand sound design, we’ll put on our <em class="italic">audio developer hat</em> and add audio to our 3D FPS game.</p>
<h2 id="_idParaDest-225" class="calibre8"><a id="_idTextAnchor239" class="pcalibre1 pcalibre calibre6"/>Adding audio to the game</h2>
<p class="calibre3">We’ll start by <a id="_idIndexMarker1190" class="pcalibre1 pcalibre calibre6"/>adding an Audio Mixer. Even though I mentioned audio mixing last in the previous section, we’ll add the capability to mix our game audio first and patch every audio component through it.</p>
<h3 class="calibre10">Working with the Audio Mixer</h3>
<p class="calibre3">The <strong class="bold">Audio Mixer</strong> asset <a id="_idIndexMarker1191" class="pcalibre1 pcalibre calibre6"/>will allow us to set levels for each sound element we define independently – tailoring our game’s soundscape. It will also allow us to change levels when required in gameplay and provides a convenient way for the player to adjust levels to their taste via UI controls.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">You can read more about the Audio Mixer here: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioMixer.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioMixer.xhtml</a>.</p>
<p class="calibre3">To add an Audio Mixer, we’ll first have to ensure we have our project open in Unity and have our habitat interior level design scene from <a href="B18347_10.xhtml#_idTextAnchor187" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, open (e.g., <code>Habitat </code><code>Interior 1</code>).</p>
<p class="calibre3">We can now create a new <code>AudioMixer 1</code> in a new <code>Assets/Audio</code> folder (using the <strong class="bold">Create</strong> | <strong class="bold">Audio Mixer</strong> menu). Once you’ve created <strong class="bold">AudioMixer 1</strong>, double-clicking on it (in the <strong class="bold">Project</strong> window) will open the <strong class="bold">Audio Mixer</strong> window, as shown here:</p>
<div><div><img alt="Figure 12.1 – Audio Mixer setup" src="img/B18347_12_01.jpg" class="calibre143"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Audio Mixer setup</p>
<p class="calibre3">With the <strong class="bold">Audio Mixer</strong> window open, we can now add groups for the channels of audio we’ll want to mix the levels for.</p>
<p class="calibre3">Add the following groups (see <em class="italic">Figure 12</em><em class="italic">.1</em> for reference) by clicking the big plus sign (<strong class="bold">+</strong>) to the right of the <strong class="bold">Groups</strong> heading. Note that when the group first appears, the field is highlighted so that you can give it a name right away:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Music</strong>: The level at which the game’s music will be played is set with this group</li>
<li class="calibre15"><strong class="bold">SFX</strong>: The game’s SFX level will be set with this group</li>
<li class="calibre15"><strong class="bold">Ambient</strong> [sound]: All of the environmental ambiance and noise will be set with this group</li>
</ul>
<p class="callout-heading">Tip</p>
<p class="callout">In <strong class="bold">Play Mode</strong>, there<a id="_idIndexMarker1192" class="pcalibre1 pcalibre calibre6"/> is a toggle button called <strong class="bold">Edit in Play Mode</strong> in the <strong class="bold">Audio Mixer</strong> window. This toggle, when enabled, allows us to adjust or mix audio levels while playtesting.</p>
<p class="calibre3">In <em class="italic">Figure 12</em><em class="italic">.1</em>, you can see I left all the levels at zero except for the <code>-16</code> to see how loud that sounds during gameplay – it should be lower so as not to drown out the SFX.</p>
<p class="calibre3">Okay, that was easy! We’ll continue coding our way through creating the audio system with components<a id="_idIndexMarker1193" class="pcalibre1 pcalibre calibre6"/> for playing the different sound elements in the following sections. It all starts with an audio manager class.</p>
<h3 class="calibre10">Creating a simple audio manager</h3>
<p class="calibre3">Following what<a id="_idIndexMarker1194" class="pcalibre1 pcalibre calibre6"/> should be a recognizable code architecture at this point in the book, introduced in <a href="B18347_02.xhtml#_idTextAnchor041" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, section <em class="italic">SOLID principles and design patterns</em>, we’ll create an audio manager class by following SOLID principles. Specifically, we’ll rely on the SOLID <strong class="bold">open-closed principle</strong> (<strong class="bold">OCP</strong>) and <a id="_idIndexMarker1195" class="pcalibre1 pcalibre calibre6"/>polymorphism, and also introduce an interface for our different types of audio player components responsible for playing the different kinds of sounds in the game.</p>
<p class="calibre3">Now, let us create a C# script in a new <code>Assets/Scripts/Audio</code> folder named <code>AudioManager</code>. We’ll start by adding the necessary variable declarations:</p>
<pre class="source-code">
using UnityEngine.Audio;
public class AudioManager : MonoBehaviour
{
    [SerializeField] private AudioMixerGroup _groupMusic;
    [SerializeField] private AudioMixerGroup _groupSFX;
    [SerializeField] private AudioMixerGroup _groupAmbient;
    private AudioSource _audioSource2D, _audioSourceMusic;
}</pre> <p class="calibre3">Here, we can see the groundwork for implementing the Audio Mixer groups we configured in the previous section. We’ve also declared some <code>AudioSource</code> variables for sound playback – these will be explained as we add to the code while implementing the play audio<a id="_idIndexMarker1196" class="pcalibre1 pcalibre calibre6"/> functionality in the following <em class="italic">Building an immersive soundscape with music, SFX, and </em><em class="italic">ambiance</em> subsections.</p>
<p class="callout-heading">Important note</p>
<p class="callout">I’m just going to assume by now that you know that if we have a class inheriting from <strong class="source-inline1">MonoBehaviour</strong>, we need a <strong class="source-inline1">using UnityEngine;</strong> statement at the top of the C# script. As you should also know, this <strong class="source-inline1">using</strong> statement is already there from the default script template. :)</p>
<p class="calibre3">Again, one of the key functions the <code>AudioManager</code> class will handle for us is setting the Audio Mixer group for the type of audio we want to play. This will ensure sound designers can use the Audio Mixer to set the initial audio playback levels of the game (i.e., designing the soundscape).</p>
<p class="calibre3">Now, add the following code to the <code>AudioManager</code> class:</p>
<pre class="source-code">
public enum AudioType { Music, SFX, Ambient };
private AudioMixerGroup
    GetAudioMixerGroup(AudioType audioType)
        =&gt; audioType switch
    {
        AudioType.SFX =&gt; _groupSFX,
        AudioType.Music =&gt; _groupMusic,
        AudioType.Ambient =&gt; _groupAmbient,
    };</pre> <p class="callout-heading">switch expression (C#)</p>
<p class="callout">You can read more about pattern-matching expressions using the <strong class="source-inline1">switch</strong> keyword here: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression</a>.</p>
<p class="calibre3">Here, we’ve <a id="_idIndexMarker1197" class="pcalibre1 pcalibre calibre6"/>created an <code>AudioType</code> enum that we’ll use to map an audio player component to an Audio Mixer group. We’ve added the <code>GetAudioMixerGroup()</code> method to get the appropriate Audio Mixer group by using a <code>switch</code> expression and passing in an <code>AudioType</code> enum. This will all become clearer in the next section when we create our first audio player component.</p>
<p class="callout-heading">Discards (C#)</p>
<p class="callout">Note that the compiler will generate a warning if the switch expression in the preceding code doesn’t handle all possible input values. In that case, we could use the following discard pattern so all possible input values are handled – avoiding a console warning:

_ =&gt; throw new ArgumentOutOfRangeException(nameof(AudioType),
    $"Not expected audioType value: {audioType}"),</p>
<p class="callout">The underscore (<strong class="source-inline1">_</strong>) is a placeholder variable that won’t hold a value and is not intended to be used.</p>
<p class="callout">You can read more about discards here: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards</a>.</p>
<p class="calibre3">With the <code>AudioManager</code> class we have coded up until now, we are ready to start making the audio player components! But before we do that, we’ll need to have a way to access <code>AudioManager</code> to call on its methods. So, we’ll continue to use the Singleton pattern for our managers – go ahead and add the required code for it now.</p>
<p class="calibre3">As a reminder, here<a id="_idIndexMarker1198" class="pcalibre1 pcalibre calibre6"/> it is:</p>
<pre class="source-code">
public static AudioManager Instance { get; private set; }
private void Awake()
{
    if (Instance == null)
        Instance = this;
    else
        Destroy(gameObject);
    DontDestroyOnLoad(gameObject);
}</pre> <p class="calibre3">To add the <code>AudioManager</code> script, a class derived from <code>MonoBehaviour</code>, to our project, create a new GameObject named <code>AudioManager</code> in the <code>AudioManager</code> script to it.</p>
<p class="calibre3">We can now assign the <code>AudioMixerGroup</code> fields by clicking and dragging the group from the <strong class="bold">Audio Mixer</strong> window or using the field’s <strong class="bold">Object Picker</strong> window (the small circle icon at the right side of the field), using <em class="italic">Figure 12</em><em class="italic">.2</em> as a guide.</p>
<div><div><img alt="Figure 12.2 – AudioManager mixer groups assignment" src="img/B18347_12_02.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.2 – AudioManager mixer groups assignment</p>
<p class="calibre3">Done! Well, we don’t actually have any methods to play sound in our audio manager… yet…</p>
<p class="calibre3">The audio manager <a id="_idIndexMarker1199" class="pcalibre1 pcalibre calibre6"/>foundation for the game is in place, so we can now begin writing the individual components to play the different types of audio needed in the game.</p>
<h1 id="_idParaDest-226" class="calibre5"><a id="_idTextAnchor240" class="pcalibre1 pcalibre calibre6"/>Building an immersive soundscape with music, SFX, 
and ambiance</h1>
<p class="calibre3">We’ll cover<a id="_idIndexMarker1200" class="pcalibre1 pcalibre calibre6"/> writing<a id="_idIndexMarker1201" class="pcalibre1 pcalibre calibre6"/> audio<a id="_idIndexMarker1202" class="pcalibre1 pcalibre calibre6"/> player components for what I consider the most common scenarios for the type of game audio we’ll need. We’ll have components for playing music, SFX, and ambient sounds. We’ll also cover playing the sound in 2D or 3D space, as required or desired, for each type of audio player component.</p>
<p class="calibre3">Everything that plays sound in Unity requires an <code>AudioSource</code> component (think of it as a speaker, and you can have many), and the scene requires a single <code>AudioListener</code> (think of it as the microphone). By default, our main camera in the scene comes with the <code>AudioListener</code> component already added – so we’re good; there is nothing further to do there.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">You can read more about the Audio Listener here: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioListener.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioListener.xhtml</a>.</p>
<p class="calibre3">As seen in the <code>AudioManager</code> implementation, it’s important to note that we are ensuring all audio player components direct audio playback through <code>AudioManager</code> so that the correct Audio Mixer group is used. This design is intentional, so anyone adding an audio player component (developer, designer, artist, etc.) won’t have to remember to set the correct mixer group for the specific component type. This will be super simple to accomplish because – you guessed it – we’ll use an interface (as we’ll soon see when coding our audio player components).</p>
<p class="callout-heading">Project audio files</p>
<p class="callout">The audio files that will be used in the <a id="_idIndexMarker1203" class="pcalibre1 pcalibre calibre6"/>following sections are all either public domain or <strong class="bold">Creative Commons Zero</strong> (<strong class="bold">CC0</strong>) (<a href="https://creativecommons.org/publicdomain/zero/1.0/deed.en" class="pcalibre1 pcalibre calibre6">https://creativecommons.org/publicdomain/zero/1.0/deed.en</a>) and are available from the <strong class="source-inline1">Audio-Assets</strong> folder in the GitHub repo, from the individual Unity project assets folders, or from the original download links provided in the corresponding sections.</p>
<p class="callout">The GitHub repo audio assets for this chapter can be found here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Audio-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Audio-Assets</a>.</p>
<p class="calibre3">Okay, on <a id="_idIndexMarker1204" class="pcalibre1 pcalibre calibre6"/>to <a id="_idIndexMarker1205" class="pcalibre1 pcalibre calibre6"/>our <a id="_idIndexMarker1206" class="pcalibre1 pcalibre calibre6"/>first audio player component. Time to play some sweet music!</p>
<h2 id="_idParaDest-227" class="calibre8"><a id="_idTextAnchor241" class="pcalibre1 pcalibre calibre6"/>Playing music</h2>
<p class="calibre3">We’ll delve into<a id="_idIndexMarker1207" class="pcalibre1 pcalibre calibre6"/> the technical aspects of incorporating music into your games. A music composer is responsible for creating impactful soundtracks that resonate with your audience and become synonymous with your game’s identity. Therefore, I highly recommend partnering with a composer for your projects to achieve this level of quality.</p>
<p class="calibre3">However, if you are looking for a more budget-friendly option, you can use sourced music, where composers create pre-made soundtracks in different genres that can be purchased and used in your project (sometimes, as in our case here, even for free).</p>
<p class="calibre3">But, before we can assign any music clips to an audio player component, we first have to create one.</p>
<p class="callout-heading">Warning!</p>
<p class="callout">The <strong class="source-inline1">AudioPlayerMusic</strong> class introduced next will not follow the SOLID OCP. This is intentional. We will instead use this initially coded approach as an example to be refactored for the remainder of the audio player components. Hopefully, it will serve as a reinforcement learning opportunity to solidify knowledge.</p>
<p class="calibre3">We’re starting with playing music, so create a new C# script named <code>AudioPlayerMusic</code> in a new <code>Assets/Scripts/Audio</code> folder with the following fields and methods declared:</p>
<pre class="source-code">
public class AudioPlayerMusic : MonoBehaviour
{
    [SerializeField] private AudioClip _musicClip;
    [SerializeField] private bool _playOnStart = true;
    private void Start()
    {
        if (_playOnStart)
            Play();
    }
    private void Play()
        =&gt; AudioManager.Instance.PlayMusic(_musicClip);
}</pre> <p class="calibre3">Now, let’s have a look at what we did here:</p>
<ul class="calibre17">
<li class="calibre15"><code>_musicClip</code>: An audio clip holds the audio data representing the sound to be played, which supports many popular audio file formats (<code>.wav</code>, <code>.mp3</code>, and <code>.ogg</code> being the most used). In the <strong class="bold">Inspector</strong> window, this variable will be assigned a reference to an audio file asset from the <strong class="bold">Project</strong> window folder for our game’s music to be played.</li>
</ul>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">You can read more about audio clips here: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml</a>.</p>
<ul class="calibre17">
<li class="calibre15"><code>_playOnStart</code>: This variable is a simple Boolean flag we’ll set in the <strong class="bold">Inspector</strong> to tell this audio player component to start playing when the game begins or not.</li>
<li class="calibre15"><code>Start()</code>: We evaluate the value of <code>_playOnStart</code> in the <code>Start()</code> Unity message event method and call <code>Play()</code> if <code>true</code>. Simple.</li>
<li class="calibre15"><code>Play()</code>: This is where the magic happens, where we tell <code>AudioManager</code> to start playing our lovely music’s audio clip.</li>
</ul>
<p class="calibre3">As you can see, we call a <code>PlayMusic()</code> method in the <code>AudioManager</code> Singleton instance. However, the <a id="_idIndexMarker1208" class="pcalibre1 pcalibre calibre6"/>method doesn’t yet exist. Let’s fix this now to complete the playing music functionality.</p>
<h3 class="calibre10">Adding the PlayMusic() method to AudioManager</h3>
<p class="calibre3">Now, add <a id="_idIndexMarker1209" class="pcalibre1 pcalibre calibre6"/>the <code>PlayMusic()</code> method<a id="_idIndexMarker1210" class="pcalibre1 pcalibre calibre6"/> to the <code>AudioManager</code> class<a id="_idIndexMarker1211" class="pcalibre1 pcalibre calibre6"/> as follows:</p>
<pre class="source-code">
public void PlayMusic(AudioClip clip)
{
    if (_audioSourceMusic == null)
        _audioSourceMusic =
            gameObject.AddComponent&lt;AudioSource&gt;();
    _audioSourceMusic.outputAudioMixerGroup = _groupMusic;
    _audioSourceMusic.clip = clip;
    _audioSourceMusic.spatialBlend = 0f; // 2D
    _audioSourceMusic.loop = true;
    _audioSourceMusic.Play();
}</pre> <p class="calibre3"><code>AudioManager</code> will play the music directly by adding <code>AudioSource</code> to the GameObject it resides with:</p>
<pre class="source-code">
gameObject.AddComponent&lt;AudioSource&gt;();</pre> <p class="calibre3">Then, following the architecture we established, set the appropriate mixer group, the music clip passed in as a parameter to the <code>_audioSourceMusic</code> audio source, and the remaining properties set the music to play in 2D space and on an infinite loop.</p>
<p class="calibre3">The <code>_audioSourceMusic</code> properties for playing music are as follows:</p>
<ul class="calibre17">
<li class="calibre15"><code>spatialBlend = 0f</code>: Based on the player’s position in the environment, we don’t want the music to be heard differently, so setting the spatial blend property to <code>0f</code> makes it a full 2D sound.</li>
</ul>
<p class="callout-heading">Tip</p>
<p class="callout">When adding 2D audio sources to the scene, note that their transform position in world space won’t matter; the audio listener always hears them.</p>
<ul class="calibre17">
<li class="calibre15"><code>loop = true</code>: This one is pretty clear – does <code>loop</code> equal <code>true</code>? Yup. Then play the audio clip in a loop forever! Otherwise, play it once.</li>
</ul>
<p class="calibre3">The remaining properties for an <code>AudioSource</code> component will be set to their default values, which will all be just fine for background music.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">You can learn more about <strong class="source-inline1">AudioSource</strong> here: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml</a>.</p>
<p class="calibre3">Finally, the music is played using the <code>Play()</code> method on <code>_audioSourceMusic</code>. All that remains to<a id="_idIndexMarker1212" class="pcalibre1 pcalibre calibre6"/> get the music playing <a id="_idIndexMarker1213" class="pcalibre1 pcalibre calibre6"/>in <a id="_idIndexMarker1214" class="pcalibre1 pcalibre calibre6"/>our game is to add <code>AudioPlayerMusic</code> to our scene.</p>
<h3 class="calibre10">Implementing AudioPlayerMusic</h3>
<p class="calibre3">Implementing <a id="_idIndexMarker1215" class="pcalibre1 pcalibre calibre6"/>our music audio player component<a id="_idIndexMarker1216" class="pcalibre1 pcalibre calibre6"/> means adding the <code>AudioPlayerMusic</code> script to our scene (no surprise here).</p>
<p class="calibre3">In the <code>AudioPlayerMusic</code> as a sibling component to the <code>AudioManager</code> component on the <code>AudioManager</code> object in the <strong class="bold">Hierarchy</strong>. <em class="italic">Figure 12</em><em class="italic">.3</em> shows our final music audio player component setup.</p>
<div><div><img alt="Figure 12.3 – Adding AudioPlayerMusic to the AudioManager object" src="img/B18347_12_03.jpg" class="calibre144"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Adding AudioPlayerMusic to the AudioManager object</p>
<p class="calibre3">We can see in the preceding figure that the audio clip for the music is already assigned to the <code>Arpent</code> audio file to our project now and make that assignment.</p>
<p class="calibre3">If you haven’t yet<a id="_idIndexMarker1217" class="pcalibre1 pcalibre calibre6"/> imported the audio assets from the project <a id="_idIndexMarker1218" class="pcalibre1 pcalibre calibre6"/>GitHub repo, refer back to the <em class="italic">Building an immersive soundscape with music, SFX, and ambiance</em> section and do that now. We’ll need the audio files for the next step and the following sections.</p>
<p class="calibre3">The music file we’ll be using for our game is <code>Arpent.mp3</code> and comes from FreePD (<a href="https://freepd.com/music/Arpent.mp3" class="pcalibre1 pcalibre calibre6">https://freepd.com/music/Arpent.mp3</a>). The music is licensed CC0, meaning we can use it for free.</p>
<p class="calibre3">Ensure the <code>Arpent.mp3</code> file is imported to the <code>Assets/Audio/Music</code> folder. Then, with the file selected in the <strong class="bold">Project</strong> window, let’s adjust the import settings in the <strong class="bold">Inspector</strong> window to something appropriate for what is generally a longer music clip – you can see in the <strong class="bold">Inspector</strong> window in the following figure that the music file is nearly three minutes long (<strong class="bold">2:42.064</strong> to be exact).</p>
<div><div><img alt="Figure 12.4 – Audio clip import Inspector settings" src="img/B18347_12_04.jpg" class="calibre145"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Audio clip import Inspector settings</p>
<p class="callout-heading">Important note</p>
<p class="callout">You’ll have noticed by now that when we select assets in the <strong class="bold">Project</strong> window, the <strong class="bold">Inspector</strong> will adjust to the type of asset chosen, so the import settings will look different.</p>
<p class="calibre3">Settings to note that <a id="_idIndexMarker1219" class="pcalibre1 pcalibre calibre6"/>we’ve changed here are as<a id="_idIndexMarker1220" class="pcalibre1 pcalibre calibre6"/> follows:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Load In Background</strong>: Enabling loading the audio file in the background for lengthy or high-quality music files ensures the game runs smoothly since asynchronous loading (i.e., not blocking the main thread) eliminates frame drops and the possibility of stuttering</li>
<li class="calibre15"><strong class="bold">Load Type</strong>: For longer music files, it’s advised to set this to <strong class="bold">Streaming</strong> so all of the audio data is not loaded into memory all at once</li>
<li class="calibre15"><code>70</code>% is generally a good balance for music – file size versus quality</li>
</ul>
<p class="callout-heading">Audio Clip Import Settings | Unity documentation</p>
<p class="callout">You can learn more about audio clip <strong class="bold">Inspector</strong> options here: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioClip.xhtml</a>.</p>
<p class="calibre3">When you’ve made these changes, clicking the <code>AudioPlayerMusic</code> component by selecting the <code>AudioManager</code> object in the <code>Arpent</code> music file to the <strong class="bold">Music Clip</strong> field, and we’re done!</p>
<p class="calibre3">Save your scene and enter Play Mode to hear music play when the game starts. If you don’t hear anything, you may need to toggle the <em class="italic">mute audio</em> icon in the <strong class="bold">Game</strong> view, as seen here:</p>
<div><div><img alt="Figure 12.5 – Game mute audio toggle" src="img/B18347_12_05.jpg" class="calibre146"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Game mute audio toggle</p>
<p class="calibre3">We’ve started on <a id="_idIndexMarker1221" class="pcalibre1 pcalibre calibre6"/>our journey of audio immersion and exploration in Unity! Hearing music playing is a nice way of establishing the mood and setting the stage for our gameplay. Game sound designers carefully choose music tracks to create the desired emotional and thematic tone, evoking wonder, mystery, or the unknown to establish an expansive and intriguing atmosphere. Upon hearing the <em class="italic">Arpent</em> music track, I realized it would be a perfect fit for the sci-fi environment and the player’s exploration of the habitat station for this level.</p>
<p class="calibre3">But as<a id="_idIndexMarker1222" class="pcalibre1 pcalibre calibre6"/> great as <a id="_idIndexMarker1223" class="pcalibre1 pcalibre calibre6"/>playing music is, I’m sure you already know that a game is nothing without sound effects!</p>
<h2 id="_idParaDest-228" class="calibre8"><a id="_idTextAnchor242" class="pcalibre1 pcalibre calibre6"/>Playing SFX</h2>
<p class="calibre3">Tell me, would <a id="_idIndexMarker1224" class="pcalibre1 pcalibre calibre6"/>a particular series of sci-fi movies (set in a galaxy far away) be complete without its iconic sound of laser swords humming then cutting through the air and clashing? The answer is no… no, it wouldn’t.</p>
<p class="calibre3">SFX are the unsung heroes of game development – only 50% of the game is complete without them (no, you cannot argue this). So, what are we waiting for… these SFX aren’t going to play themselves!</p>
<h3 class="calibre10">SOLID refactoring with the IPlaySound interface</h3>
<p class="calibre3">We’re going to<a id="_idIndexMarker1225" class="pcalibre1 pcalibre calibre6"/> refactor <a id="_idIndexMarker1226" class="pcalibre1 pcalibre calibre6"/>for SOLID principles<a id="_idIndexMarker1227" class="pcalibre1 pcalibre calibre6"/> now. Specifically, <code>AudioManager</code> will be closed for modification, adhering to the OCP. For the <em class="italic">open</em> part, we’ll pass in the type of audio player object – this is also the polymorphism part – each with its own implementation (i.e., modification) to play sound, and the audio player types implement an interface: <code>IPlaySound</code>. The interface ensures we have a consistent public method to call on each different audio player object type we implement.</p>
<p class="calibre3">We are making an exception to the <em class="italic">closed-for-modification</em> principle by allowing the use of the <code>AudioType</code> enum. This decision is based on making it easier for developers and designers to add audio player components. By simplifying the process and preventing potential mistakes, we aim to save time and eliminate the need for manual assignment of audio groups. The trade-off is that we’ll need to modify <code>AudioManager</code> whenever a new mixer group is added, which I’m okay with.</p>
<p class="calibre3">With all that explanation out of the way, let’s look at the <code>IPlaySound</code> interface. Create a new C# script named <code>IPlaySound</code> in the <code>Assets/Scripts/Audio</code> folder with the following code:</p>
<pre class="source-code">
using AudioType = AudioManager.AudioType;
public interface IPlaySound
{
    AudioType PlayAudioType { get; }
    void PlaySound(AudioSource source);
}</pre> <p class="calibre3">Here is the breakdown of the interface declarations:</p>
<ul class="calibre17">
<li class="calibre15"><code>using AudioType</code>: Sometimes, we must distinguish a type name shared across namespaces. We defined that <code>AudioManger.AudioType</code> and <code>AudioType</code> exist in <code>UnityEngine</code>. So, we need to tell the script which one we want. To do that, we use an alias: <code>using AudioType = </code><code>AudioManager.AudioType;</code>.</li>
</ul>
<p class="callout-heading">The using alias (C#)</p>
<p class="callout">You can learn more about the <strong class="source-inline1">using</strong> alias here: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#usingalias" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#usingalias</a></p>
<ul class="calibre17">
<li class="calibre15"><code>PlayAudioType</code>: This property will get the default value we assign from our <code>AudioType</code> enum. We will set <code>AudioMixerGroup</code> based on this value for the specific type of audio player component we’re making – and avoid any assignment mistakes in the <strong class="bold">Inspector</strong>.</li>
<li class="calibre15"><code>PlaySound()</code>: Exactly as its name states, the implementing class will use this method to play the audio clip.</li>
</ul>
<p class="calibre3">And that’s all we need for our interface. Our audio manager class can now implement multiple audio<a id="_idIndexMarker1228" class="pcalibre1 pcalibre calibre6"/> players <a id="_idIndexMarker1229" class="pcalibre1 pcalibre calibre6"/>without <a id="_idIndexMarker1230" class="pcalibre1 pcalibre calibre6"/>modification, following the SOLID OCP, by passing each different audio player class by the interface type. The audio player classes that implement the interface will provide unique play functionality.</p>
<p class="calibre3">Let’s see our first example by writing the play SFX component. Create a new script named <code>AudioPlayerSFX</code> in the <code>Assets/Scripts/Audio</code> folder with the following code:</p>
<pre class="source-code">
using AudioType = AudioManager.AudioType;
public class AudioPlayerSFX : MonoBehaviour, IPlaySound
{
    [SerializeField] private AudioClip _audioClip;
    [Range(0f, 1f)]
    [SerializeField] private float _volume = 1f;
    public void Play() =&gt;
        AudioManager.Instance.PlayAudio(this);
}</pre> <p class="calibre3">First, we added the <code>IPlaySound</code> interface to the <code>AudioPlayerSFX</code> class declaration to conform to our audio player component design.</p>
<p class="calibre3">Next, we have<a id="_idIndexMarker1231" class="pcalibre1 pcalibre calibre6"/> these core variables <a id="_idIndexMarker1232" class="pcalibre1 pcalibre calibre6"/>and <a id="_idIndexMarker1233" class="pcalibre1 pcalibre calibre6"/>methods that will be common to all the audio player components since they are all considered required for playing sound:</p>
<ul class="calibre17">
<li class="calibre15"><code>_audioClip</code>: Every audio player component needs a clip to play. This variable refers to the audio clip asset assigned via the <strong class="bold">Inspector</strong> and then played.</li>
<li class="calibre15"><code>_volume</code>: Not every audio file will have the same levels for its playback, or, for some sounds in the game, they may satisfy the sound design by playing at a lower volume; set with this variable in the <strong class="bold">Inspector</strong>.</li>
<li class="calibre15"><code>Play()</code>: The public method we’ll call to start playing the assigned audio clip using the <code>AudioManager</code> Singleton instance’s <code>PlayAudio()</code> method (which we’ll be adding in the next section).</li>
</ul>
<p class="calibre3">When calling the audio manager’s <code>PlayAudio()</code> method, note that we’re passing in <code>this</code> as the parameter. The <code>this</code> keyword refers to the current class instance – in this case, <code>AudioPlayerSFX</code>, but the parameter type we will use for declaring <code>PlayAudio()</code> will be <code>IPlaySound</code>. This is the magic of polymorphism. We’ll pass in <code>this</code> as the type parameter, representing any number of different classes for unique audio player functionality, but all accessible as <code>IPlaySound</code>.</p>
<p class="callout-heading">this (C#)</p>
<p class="callout">You can read more about the <strong class="source-inline1">this</strong> keyword for class instances here: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this</a></p>
<p class="calibre3">Now, implement the <code>IPlaySound</code> interface’s public properties and methods (remember, interface declarations must be <code>public</code>):</p>
<pre class="source-code">
    public AudioType PlayAudioType =&gt; AudioType.SFX;
    public void PlaySound(AudioSource source)
        =&gt; source.PlayOneShot(_audioClip, _volume);</pre> <p class="calibre3">Without repeating the interface details again here, let’s delve into the assignments:</p>
<ul class="calibre17">
<li class="calibre15"><code>PlayAudioType</code>: Here is where we pre-assign the <code>AudioType</code> value for the Audio Mixer group we want this audio player component to use.</li>
<li class="calibre15"><code>PlaySound()</code>: Here is where we actually play the sound with the audio-playing code specific to this type of audio player component, using the referenced<a id="_idIndexMarker1234" class="pcalibre1 pcalibre calibre6"/> audio<a id="_idIndexMarker1235" class="pcalibre1 pcalibre calibre6"/> source. In<a id="_idIndexMarker1236" class="pcalibre1 pcalibre calibre6"/> the case of SFX, we’ll use the <code>PlayOneShot()</code> method because it allows playing multiple sounds on a single <code>AudioSource</code> component.</li>
</ul>
<p class="calibre3">Note that the <code>AudioSource</code> component being passed in here will be added to the <code>AudioManager</code> object for the 2D SFX. So, there is no need to add an <code>AudioSource</code> component to the objects with this audio player component added. You’ll see how this works in the next section when we add to <code>AudioManager</code>.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">You can read more about <strong class="source-inline1">PlayOneShot()</strong> here: 
<a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayOneShot.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayOneShot.xhtml</a></p>
<p class="calibre3">To provide some additional clarity to this architecture, now that you’ve seen the code and how the method calls are set, let’s look<a id="_idIndexMarker1237" class="pcalibre1 pcalibre calibre6"/> at a <code>AudioPlayerSFX</code> and <code>AudioManager</code> relationship:</p>
<div><div><img alt="Figure 12.6 – Audio architecture UML class diagram" src="img/B18347_12_06.jpg" class="calibre147"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Audio architecture UML class diagram</p>
<p class="calibre3">The code calls on the audio manager – <code>AudioManager.PlayAudio()</code> – to assign the correct Audio Mixer group. It then uses the interface to call back to its specific play sound function (with the audio source responsible for playing the sound) – <code>IPlaySound.PlaySound()</code>. It’ll become even clearer as we implement additional audio player components in the subsequent sections, each with a unique play sound function for playing 3D SFX and ambient sounds.</p>
<p class="calibre3">This finishes <a id="_idIndexMarker1238" class="pcalibre1 pcalibre calibre6"/>up our audio<a id="_idIndexMarker1239" class="pcalibre1 pcalibre calibre6"/> player <a id="_idIndexMarker1240" class="pcalibre1 pcalibre calibre6"/>component for playing SFX, but it’s not done yet because it won’t play anything with the audio manager’s <code>PlayAudio()</code> method not existing. Let’s solve this problem now by updating our audio manager.</p>
<h3 class="calibre10">Updating AudioManager</h3>
<p class="calibre3">Bringing it all<a id="_idIndexMarker1241" class="pcalibre1 pcalibre calibre6"/> together <a id="_idIndexMarker1242" class="pcalibre1 pcalibre calibre6"/>now, we’re adding in the <code>AudioManager.PlayAudio()</code> method to set the assigned mixer group and call back to the passed-in component’s specific <code>PlaySound()</code> functionality to play the audio – in this case, an SFX.</p>
<p class="calibre3">Now, open the <code>AudioManager</code> script and add the following method:</p>
<pre class="source-code">
    public void PlayAudio(
        IPlaySound player,
        AudioSource source = null)
    {
        if (source == null)
            source = AudioSourcePlaySFX;
        source.outputAudioMixerGroup =
            GetAudioMixerGroup(player.PlayAudioType);
        player.PlaySound(source);
    }</pre> <p class="calibre3"><code>PlayAudio()</code> will be closed for modification so its structure is suitable for any number of audio<a id="_idIndexMarker1243" class="pcalibre1 pcalibre calibre6"/> player components that implement the <code>IPlaySound</code> interface. As such, we’ve made the second argument in the method signature, <code>source</code>, have a default value of <code>null</code>.</p>
<p class="calibre3">For playing 2D sounds, we’re not going to require every object in the scene that will play a sound to have <code>AudioSource</code> attached to it. Having too many <code>AudioSource</code> components in the scene can potentially lead to performance issues related to memory usage, processing overhead, and audio clipping if too many of those audio sources are playing simultaneously (see the <em class="italic">Optimization note</em> information that follows because Unity limits the number of audio sources that can play simultaneously).</p>
<p class="calibre3">For an audio source with a <code>null</code> value, we’re first going to assume it’s a 2D sound that will be played – 3D sounds will have their own audio source passed in. We’ll use a <code>private</code> property to get an instance of <code>AudioSource</code> for playing the audio clip (using a property getter) instead of using a <code>private</code> method to return (i.e., <code>get</code>) the <code>AudioSource</code> reference in the class requiring it.</p>
<p class="calibre3">Let’s go ahead and add the <code>AudioSourcePlaySFX</code> property to <code>AudioManager</code> now so we have a valid audio source component added to the scene for playing our 2D sounds:</p>
<pre class="source-code">
private AudioSource AudioSourcePlaySFX
{
    get
    {
        if (_audioSource2D == null)
        {
            _audioSource2D = new
                GameObject().AddComponent&lt;AudioSource&gt;();
            _audioSource2D.spatialBlend = 0f; // 2D
        }
        return _audioSource2D;
    }
}</pre> <p class="calibre3">For this property, you<a id="_idIndexMarker1244" class="pcalibre1 pcalibre calibre6"/> can see we have a getter <a id="_idIndexMarker1245" class="pcalibre1 pcalibre calibre6"/>defined. It evaluates the <code>private</code> member <code>_audioSource2D</code> (previously added) to see whether it already has an <code>AudioSource</code> component assigned to it, and if not, uses the <code>AddComponent()</code> method to add one to the scene (as a sibling on the same GameObject as <code>AudioManager</code>).</p>
<p class="calibre3">It then sets the <code>spatialBlend</code> value to ensure 2D playback of the sound and returns the new <code>AudioSource</code> to have its mixer group assigned and then passed back to the audio player component for playing the sound. Whew!</p>
<p class="callout-heading">Optimization note</p>
<p class="callout">Note that for the <strong class="source-inline1">AudioSource</strong> component that plays the SFX sounds, we have a limit to the number of audio clips that can be played simultaneously. <strong class="source-inline1">AudioSource</strong> supports 32 voices, and each audio clip consumes 2 voices to play. Using the <strong class="source-inline1">PlayOneShot()</strong> method, we can play several audio clips up to this limit, at which point it will start clipping. You may have already guessed that we can support additional audio clips by object pooling the <strong class="source-inline1">AudioSource</strong> object via the <strong class="source-inline1">AudioManager</strong> component. Refer back to <a href="B18347_06.xhtml#_idTextAnchor116" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>.</p>
<p class="calibre3">Great, all our audio playback needs should be satisfied per our architecture at this point. Let’s see how to<a id="_idIndexMarker1246" class="pcalibre1 pcalibre calibre6"/> implement playing SFX in our scene <a id="_idIndexMarker1247" class="pcalibre1 pcalibre calibre6"/>now before moving on to making additional audio player components.</p>
<h3 class="calibre10">Implementing AudioPlaySFX – Unity event</h3>
<p class="calibre3">To add our first <a id="_idIndexMarker1248" class="pcalibre1 pcalibre calibre6"/>SFX to the game, let’s <a id="_idIndexMarker1249" class="pcalibre1 pcalibre calibre6"/>revisit something you’re already familiar with: our health pickup. Having followed along in the previous chapters – such as <a href="B18347_10.xhtml#_idTextAnchor187" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, section <em class="italic">Recharging aka healing</em> – you should have one in your scene already. Find and select it. Now, let’s add the <code>AudioPlayerSFX</code> component to the root GameObject. As seen in the following figure, it’s added just below the <code>Destroyer (</code><code>Script)</code> component.</p>
<div><div><img alt="Figure 12.7 – Health pickup SFX" src="img/B18347_12_07.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Health pickup SFX</p>
<p class="calibre3">Assign <code>AudioPlayerSFX</code> to play a sound when <code>OnHealEvent</code> is triggered from the preceding <code>PickupHeal</code> component.</p>
<ol class="calibre14">
<li class="calibre15">On the <code>PickupHeal (Script)</code> component, click the plus (<code>UnityEvent</code> field.</li>
<li class="calibre15">Click and drag the <code>AudioPlayerSFX</code> component (by its title bar) to the new entry.</li>
<li class="calibre15">In the function selector dropdown, select <strong class="bold">AudioPlayerSFX</strong> | <strong class="bold">Play()</strong>.</li>
</ol>
<p class="calibre3">Okay, it’s all <a id="_idIndexMarker1250" class="pcalibre1 pcalibre calibre6"/>wired<a id="_idIndexMarker1251" class="pcalibre1 pcalibre calibre6"/> up, but we’re missing something… what sound will we play?!</p>
<h3 class="calibre10">Assigning the audio clip</h3>
<p class="calibre3">The sound<a id="_idIndexMarker1252" class="pcalibre1 pcalibre calibre6"/> file <a id="_idIndexMarker1253" class="pcalibre1 pcalibre calibre6"/>we’ll be using for our health pickup is <code>item-pickup-v1.wav</code>. It comes from the Freesound website (https://freesound.org/people/DeltaCode/sounds/678384/) and is licensed CC0, which means we can use it for free.</p>
<p class="calibre3">Ensure the <code>item-pickup-v1.wav</code> file is imported to the <code>Assets/Audio/SFX</code> folder. Unlike with the music audio file, we’ll use the default import settings values for this sound file. Return to the <code>AudioPlayerSFX</code> component on the healing pickup, then click and drag the <code>item-pickup-v1</code> file to the <strong class="bold">Audio Clip</strong> field. At the top of the <strong class="bold">Inspector</strong>, click <strong class="bold">Apply All</strong> in the <strong class="bold">Prefab</strong> | <strong class="bold">Overrides</strong> dropdown to ensure all the health pickup instances in the level are updated to include playing the SFX.</p>
<p class="calibre3">Playtest the level, adjust the <code>AudioPlayerSFX</code> component as needed, and take notice of the 2D sound playback. Next, we’ll play SFX in 3D space so you can hear the difference.</p>
<p class="callout-heading">Playing SFX for UI feedback</p>
<p class="callout">Adding SFX to button clicks is also an essential aspect of game sound design. It significantly enhances the game’s overall polish and improves player satisfaction. It may seem like a small detail, but it can substantially affect how players perceive and interact with your game UI. For a UI button, use the <strong class="source-inline1">AudioPlayerSFX</strong> component and wire up the <strong class="source-inline1">Play()</strong> method to the button’s <strong class="source-inline1">On Click()</strong> event in the <strong class="bold">Inspector</strong>.</p>
<p class="calibre3">Now that we have<a id="_idIndexMarker1254" class="pcalibre1 pcalibre calibre6"/> created an audio player component with our refactored<a id="_idIndexMarker1255" class="pcalibre1 pcalibre calibre6"/> approach, the remainder will follow the same setup, so we’ll just bang the rest of these out.</p>
<h2 id="_idParaDest-229" class="calibre8"><a id="_idTextAnchor243" class="pcalibre1 pcalibre calibre6"/>Playing SFX 3D</h2>
<p class="calibre3">Unlike with the <code>AudioPlayerSFX</code> component, where we did not add an <code>AudioSource</code> component<a id="_idIndexMarker1256" class="pcalibre1 pcalibre calibre6"/> to the GameObject for playing the 2D sound, we will add one here because we want a “speaker in 3D space” to emanate the sound. The player, via the <code>AudioListener</code> component on the <code>Player</code> object, will hear the sound as you naturally would in a real-world environment – whichever “ear” is turned toward the source of the sound will hear it. Hearing sounds in 3D space further builds on the player’s immersion in your game world, so we definitely want to take advantage of 3D audio!</p>
<p class="calibre3">Noting the preceding information concerning <code>AudioSource</code>, we’ll ensure the developer/designer adding a “play 3D sound effect” component to an object configures an audio source for this sound by requiring the <code>AudioSource</code> component to be added as a sibling.</p>
<p class="calibre3">Now, create a new script named <code>AudioPlayerSFX3D</code> in the <code>Assets/Scripts/Audio</code> folder, and start with the following code for the audio source requirements:</p>
<pre class="source-code">
using AudioType = AudioManager.AudioType;
[RequireComponent(typeof(AudioSource))]
public class AudioPlayerSFX3D : MonoBehaviour, IPlaySound
{
    [SerializeField] private AudioSource _audioSource;
    private void OnValidate()
        =&gt; _audioSource = GetComponent&lt;AudioSource&gt;();
}</pre> <p class="calibre3">This is what we did here:</p>
<ul class="calibre17">
<li class="calibre15"><code>[RequireComponent]</code>: By decorating the class with this attribute, we require that a sibling component <a id="_idIndexMarker1257" class="pcalibre1 pcalibre calibre6"/>exist on this GameObject. Specifically, we need an <code>AudioSource</code> component because this will be a 3D sound.</li>
<li class="calibre15"><code>OnValidate()</code>: We can use this Unity message event to pre-assign the <code>_audioSource</code> variable with the <code>AudioSource</code> instance added by the <code>RequireComponent</code> attribute. <code>OnValidate()</code> only runs in the Editor and is called when the script is loaded or a value changes in the <strong class="bold">Inspector</strong>.</li>
<li class="calibre15"><code>IPlaySound</code>: Don’t forget to add the interface! We’re required to implement the interface for all our audio player components.</li>
</ul>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">You can read more about <strong class="source-inline1">OnValidate()</strong> here: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnValidate.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnValidate.xhtml</a></p>
<p class="calibre3">Let’s continue by borrowing from the <code>AudioPlayerSFX</code> class; we’ll also have <code>_audioClip</code> and <code>_volume</code> serialized private member variables. To those, we’ll add an additional field for assigning the 2D to 3D sound ratio with a <code>_blend2Dto3D</code> variable (which we’ll use to assign to the <code>AudioSource.spatialBlend</code> property).</p>
<p class="calibre3">So, add the following<a id="_idIndexMarker1258" class="pcalibre1 pcalibre calibre6"/> code:</p>
<pre class="source-code">
public class AudioPlayerSFX3D : MonoBehaviour, IPlaySound
{
    …
    [SerializeField] private AudioClip _audioClip;
    [Range(0f, 1f)]
    [SerializeField] private float _volume = 1f;
    [Tooltip("0 = 2D, 1 = 3D"), Range(0f, 1f)]
    [SerializeField] private float _blend2Dto3D;
    …
    public void Play() =&gt;
        AudioManager.Instance.PlayAudio
            (this, _audioSource);
}</pre> <p class="calibre3">The <code>Play()</code> method here is only slightly different from the previous <code>AudioPlayerSFX</code> implementation of <code>Play()</code> in that we’re now passing the audio source reference to <code>AudioManager</code>. As a reminder, we need to do this because we want to assign playback to the correct Audio Mixer group before playing the sound.</p>
<p class="calibre3">Speaking of playing the sound, now, implement the <code>IPlaySound</code> interface public properties and methods:</p>
<pre class="source-code">
public class AudioPlayerSFX3D : MonoBehaviour, IPlaySound
{
    public AudioType PlayAudioType =&gt; AudioType.SFX;
    …
    public void PlaySound(AudioSource source)
    {
        source.spatialBlend = _blend2Dto3D;
        source.PlayOneShot(_audioClip, _volume);
    }
}</pre> <p class="calibre3">We’ve set <code>PlayAudioType</code> to play the sound using the SFX mixer group while the <code>PlaySound()</code> method remains largely the same – except we’re setting the<code> source.spatialBlend</code> value before using <code>PlayOneShot()</code> to play the audio clip at the transform<a id="_idIndexMarker1259" class="pcalibre1 pcalibre calibre6"/> position of this object (in 3D space) and at the set volume level.</p>
<p class="callout-heading">PlayClipAtPoint() | Unity documentation</p>
<p class="callout">Those of you familiar with the Unity scripting API may wonder why I didn’t just use the <strong class="source-inline1">AudioSource.PlayClipAtPoint(_audioClip, transform.position, _volume)</strong> static method.</p>
<p class="callout">Well, the reason falls back to the primary goal of implementing the <strong class="source-inline1">AudioManager</strong> class the way we did – and that is to ensure the Audio Mixer groups are being utilized for all the distinct audio player components. While <strong class="source-inline1">PlayClipAtPoint()</strong> does play an audio clip at a position in 3D world space, it does not work with the Audio Mixer, which ruled it out as an option.</p>
<p class="callout">You can read more about <strong class="source-inline1">AudioSource.PlayClipAtPoint()</strong> here: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayClipAtPoint.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/AudioSource.PlayClipAtPoint.xhtml</a></p>
<p class="calibre3"><code>AudioPlayerSFX3D.Play()</code> now calls <code>AudioManager.Instance.PlayAudio()</code> with the added <code>_audioSource</code> parameter. The passed-in audio source is modified in <code>AudioManager</code> and passed back to the interface implemented <code>PlaySound()</code> method to use the audio player component’s specific functionality to play the sound.</p>
<p class="callout-heading">Note on code architecture</p>
<p class="callout">The relationship between <strong class="source-inline1">AudioManager</strong> and the <strong class="source-inline1">AudioPlayerSFX3D</strong> class may seem cyclical since we’ve implemented playing the sound with the interface and not within <strong class="source-inline1">AudioManager</strong>. This is an okay trade-off in the architecture for me here because I’ve prioritized composition, ease of use, and eliminating errors for <strong class="bold">Inspector</strong> assignments in Unity. Doing things in Unity sometimes means developing novel approaches and compromises to otherwise “standard approaches” to C# OOP software development. I came to terms with that long ago. :)</p>
<p class="calibre3">We’ll now follow <a id="_idIndexMarker1260" class="pcalibre1 pcalibre calibre6"/>through with the new 3D audio player component by looking at an implementation again.</p>
<h3 class="calibre10">Implementing AudioPlaySFX3D – Animation event</h3>
<p class="calibre3">Much like<a id="_idIndexMarker1261" class="pcalibre1 pcalibre calibre6"/> how we revisited an object we previously <a id="_idIndexMarker1262" class="pcalibre1 pcalibre calibre6"/>created for playing SFX (the health pickup), we’ll do the same here and add a 3D SFX to the door-opening animation we created in <a href="B18347_10.xhtml#_idTextAnchor187" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>. The following figure shows the sliding door Prefab – we’ll add the 3D sound effect when it slides open.</p>
<div><div><img alt="Figure 12.8 – Sliding door 3D SFX" src="img/B18347_12_08.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Sliding door 3D SFX</p>
<p class="calibre3">Because the door does not have a component with an exposed <code>UnityEvent</code> being invoked, as with the health pickup, we have to trigger the sound playing differently. We’ll still use an event, but <a id="_idIndexMarker1263" class="pcalibre1 pcalibre calibre6"/>this event is one we’ll add to the<a id="_idIndexMarker1264" class="pcalibre1 pcalibre calibre6"/> door-opening animation directly.</p>
<p class="calibre3">Follow these steps to add the 3D SFX to the sliding door animation:</p>
<ol class="calibre14">
<li class="calibre15">Open the <code>Door_Triggered</code> Prefab for editing.</li>
<li class="calibre15">Add the <code>AudioPlayerSFX3D</code> component to the same object as the <code>Animator</code> component. As seen in <em class="italic">Figure 12</em><em class="italic">.8</em>, it’s added just below the <code>Animator</code> component on the <code>Sliding_Door_01</code> child object.</li>
<li class="calibre15">Now, while <code>Sliding_Door_01</code> is still selected in the <strong class="bold">Hierarchy</strong> window, open the <strong class="bold">Animation</strong> window by going to <strong class="bold">Window</strong> | <strong class="bold">Animation</strong> | <strong class="bold">Animation</strong> (or press <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">6</em>).</li>
<li class="calibre15">Using the following <strong class="bold">Animation</strong> window figure as a reference, scrub the timeline a frame or two ahead, then click the <strong class="bold">Add Event</strong> button. This will add an <strong class="bold">Animation Event</strong> check mark to the timeline and select it (it will be blue when selected and white when not).</li>
</ol>
<div><div><img alt="Figure 12.9 – Adding an animation event" src="img/B18347_12_09.jpg" class="calibre148"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Adding an animation event</p>
<p class="calibre3">When <strong class="bold">Animation Event</strong> is selected, the <strong class="bold">Inspector</strong> window will show a <strong class="bold">Function</strong> drop-down menu<a id="_idIndexMarker1265" class="pcalibre1 pcalibre calibre6"/> so that we can choose a method to invoke for the event.</p>
<ol class="calibre14">
<li value="5" class="calibre15">Select <strong class="bold">AudioPlayerSFX3D</strong> | <strong class="bold">Methods</strong> | <strong class="bold">Play()</strong> in<a id="_idIndexMarker1266" class="pcalibre1 pcalibre calibre6"/> the <strong class="bold">Function</strong> drop-down.</li>
</ol>
<p class="callout-heading">Animation event | Unity documentation</p>
<p class="callout">The <strong class="source-inline1">AudioPlaySFX3D</strong> component must be on the same object as the <strong class="source-inline1">Animator</strong> component to select <strong class="source-inline1">Play()</strong> in the <strong class="bold">Function</strong> drop-down from the <strong class="bold">Animation</strong> timeline.</p>
<p class="callout">Additional reading | <em class="italic">Using Animation Events</em>: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/script-AnimationWindowEvent.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/script-AnimationWindowEvent.xhtml</a></p>
<ol class="calibre14">
<li value="6" class="calibre15">Save the Prefab (or apply overrides) because we’re done wiring up the sliding door for playing the 3D SFX!</li>
</ol>
<p class="calibre3">Hold on a second, don’t<a id="_idIndexMarker1267" class="pcalibre1 pcalibre calibre6"/> jump the gun and start entering Play <a id="_idIndexMarker1268" class="pcalibre1 pcalibre calibre6"/>Mode to test it out just yet… we still need to assign the sound the door will play when sliding open!</p>
<h3 class="calibre10">Assigning the audio clip</h3>
<p class="calibre3">I was somehow<a id="_idIndexMarker1269" class="pcalibre1 pcalibre calibre6"/> tempted<a id="_idIndexMarker1270" class="pcalibre1 pcalibre calibre6"/> to grab the sound of the <em class="italic">Star Trek: The Next Generation</em> Enterprise NCC-1701-D’s sliding door opening sound, but yeah, copyright laws and all. ;)</p>
<p class="calibre3">Not to worry, Freesound is to the rescue again! The sound file we’ll be using for our sliding doors is <code>cua-ien-tu-mo.wav</code> (in Vietnamese, <em class="italic">của điện tử mở</em> or “open electronics”), which you can download here: https://free<a id="_idTextAnchor244" class="pcalibre1 pcalibre calibre6"/>sound.org/people/SieuAmThanh/sounds/511540/. It is also licensed CC0.</p>
<p class="calibre3">Ensure the <code>cua-ien-tu-mo.wav</code> file is imported to the <code>Assets/Audio/SFX</code> folder and go back to the <code>AudioPlayerSFX3D</code> component by opening the <code>Door_Triggered</code> Prefab again. Click and drag the <code>cua-ien-tu-mo</code> file to the <strong class="bold">Audio Clip</strong> field, then click <strong class="bold">Save</strong>.</p>
<p class="calibre3">Playtest the level, adjust the <code>AudioPlayerSFX3D</code> component as needed, and take notice of the 3D sound playback.</p>
<p class="callout-heading">3D Sound Settings | Unity documentation</p>
<p class="callout">Use the <strong class="bold">3D Sound Settings</strong> section of the <strong class="source-inline1">AudioSource</strong> component to adjust the sound as desired for the spatial effect you’re looking for. The parameters in this section are applied proportionally to the <strong class="bold">Spatial </strong><strong class="bold">Blend</strong> parameter.</p>
<p class="callout">You can learn more about audio source properties here: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.xhtml</a>.</p>
<p class="calibre3">The next audio player component we’ll tackle is also for 3D sound – in the next section, let’s make an audio player for ambient sounds.</p>
<h2 id="_idParaDest-230" class="calibre8"><a id="_idTextAnchor245" class="pcalibre1 pcalibre calibre6"/>Playing ambient sound</h2>
<p class="calibre3">Adding ambient <a id="_idIndexMarker1271" class="pcalibre1 pcalibre calibre6"/>3D sounds to a game’s environment is essential for defining the setting, bringing it to life, and enhancing the player’s sensory experience. While adding ambient sound to our environment, let’s keep in mind that it’s crucial to match the sounds to the setting, layer different sound elements to create the soundscape, and change or vary the sound – interactively or not.</p>
<p class="calibre3">We first need our ambient audio player component to get started adding ambient sounds to our level. Because ambient sound is 3D in nature, we’ll again take the same approach as our 3D SFX and rely on an audio source added to our object to produce its sound.</p>
<p class="calibre3">We’ll use <code>Play()</code> on the <code>AudioSource</code> component directly this time because other methods, such as <code>PlayOneShot()</code>, cannot trigger looping sounds. However, there are some limitations to using <code>AudioSource.Play()</code>. It only allows one audio clip to be played simultaneously with an audio source. Calling <code>Play()</code> on an audio source that is already playing will stop the audio source and start the clip again. But we only care about the ability to loop the audio for playing ambient sounds in the environment so these limitations are not an issue here.</p>
<p class="calibre3">Let’s take care of setting up the <code>AudioSource</code> component right away. Create a new script named <code>AudioPlayerAmbient</code> in the <code>Assets/Scripts/Audio</code> folder and add the<a id="_idIndexMarker1272" class="pcalibre1 pcalibre calibre6"/> following code:</p>
<pre class="source-code">
[RequireComponent(typeof(AudioSource))]
public class AudioPlayerAmbient : MonoBehaviour, IPlaySound
{
    [SerializeField] private AudioSource _audioSource;
    private void OnValidate()
        =&gt; _audioSource = GetComponent&lt;AudioSource&gt;();
}</pre> <p class="calibre3">Next, we’ll need the <strong class="bold">Inspector</strong> field to assign the audio clip for the ambient sound to play on this object and the required play methods. Add the following code:</p>
<pre class="source-code">
public class AudioPlayerAmbient : MonoBehaviour, IPlaySound
{
    …
    [SerializeField] private AudioClip _audioClip;
    private void Start() =&gt; Play();
    public void Play() =&gt;
        AudioManager.Instance.PlayAudio(this, _audioSource);
}</pre> <p class="calibre3">The specifics related to the methods added to play ambient sounds are as follows:</p>
<ul class="calibre17">
<li class="calibre15"><code>Start()</code>: Ambient sounds always play! (That’s a rule I just came up with.) So, we’ll start playing the ambient sound when the level begins. Note that because this is a 3D sound and configured with its specific audio source attached to the 3D object in the environment, the player will only hear it when they are within range.</li>
<li class="calibre15"><code>Play()</code>: Similar to what we did before, we’re calling the audio manager <code>PlayAudio()</code> method and passing in the ambient sound’s <code>AudioSource</code> component to modify it and assign the correct Audio Mixer group for playback.</li>
</ul>
<p class="calibre3">Again, implement the <code>IPlaySound</code> interface’s public properties and methods so the audio manager <a id="_idIndexMarker1273" class="pcalibre1 pcalibre calibre6"/>knows which Audio Mixer group to use:</p>
<pre class="source-code">
using AudioType = AudioManager.AudioType;
…
public class AudioPlayerAmbient : MonoBehaviour, IPlaySound
{
    public AudioType PlayAudioType =&gt; AudioType.Ambient;
    …
    public void PlaySound(AudioSource source)
    {
        source.clip = _audioClip;
        source.spatialBlend = 1f;   // 3D
        source.loop = true;
        source.Play();
    }
}</pre> <p class="calibre3">This is an ambient sound, so we must set <code>PlayAudioType</code> to <code>Ambient</code> and then play the audio clip indefinitely for this audio player component’s specific <code>PlaySound()</code> method functionality, like this:</p>
<ol class="calibre14">
<li class="calibre15">Set <code>source.clip</code> to the <code>_audioClip</code> value (set in the <strong class="bold">Inspector</strong>).</li>
<li class="calibre15">Set <code>spatialBlend = 1f</code> much like how we enforced music to play in 2D (<code>0f</code>) within the <code>AudioPlayerMusic</code> component. Here, we’ll enforce the audio to play as a fully 3D sound.</li>
<li class="calibre15">Set <code>source.loop</code> to <code>true</code>. This is because ambient sounds continuously loop indefinitely!</li>
<li class="calibre15">Play the sound using <code>source.Play()</code> because we cannot use <code>PlayOneShot()</code> for a looping sound.</li>
</ol>
<p class="calibre3">Okay, these various audio-playing components have really come together! In the next section, let’s continue<a id="_idIndexMarker1274" class="pcalibre1 pcalibre calibre6"/> providing example implementations for each with an ambient sound.</p>
<h3 class="calibre10">Implementing PlayAmbientSound</h3>
<p class="calibre3">First things first, we<a id="_idIndexMarker1275" class="pcalibre1 pcalibre calibre6"/> need to identify <a id="_idIndexMarker1276" class="pcalibre1 pcalibre calibre6"/>something in our environment to use as an example ambient sound implementation. Let’s look at the models provided by Polypix Studios for an answer… I see we have a 3D model Prefab asset imported to the <code>Assets/Polypix 3D Assets/Prefabs</code> folder called <strong class="bold">Ventilation 1</strong>.</p>
<p class="calibre3">Let’s use this as a ventilation shaft inlet somewhere on our level. These types of things generally have something running – making noise – that pulls and circulates the air. A perfect environmental audio addition!</p>
<p class="callout-heading">Art assets</p>
<p class="callout">The art assets used in this section are available from the GitHub project files repo. The <strong class="source-inline1">Ventilation 1</strong> Prefab, in particular, is available from the <strong class="source-inline1">Art-Assets</strong> folder included in the <strong class="source-inline1">3DArtwork.zip</strong> file (or from the Unity project files directly): <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets</a>.</p>
<p class="calibre3">Add the <code>Ventilation 1</code> Prefab from the <code>Assets/Polypix 3D Assets/Prefabs</code> folder to the level somewhere – by dragging it in from the <strong class="bold">Project</strong> window – to give a lovely ambiance to one of the habitation station’s rooms. In <em class="italic">Figure 12</em><em class="italic">.10</em>, I’ve added it to a rather sparse-looking room that needs some interest.</p>
<div><div><img alt="Figure 12.10 – Ventilation ambient sound" src="img/B18347_12_10.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.10 – Ventilation ambient sound</p>
<p class="calibre3">With the ventilation <a id="_idIndexMarker1277" class="pcalibre1 pcalibre calibre6"/>shaft inlet added to the scene, let’s<a id="_idIndexMarker1278" class="pcalibre1 pcalibre calibre6"/> add the ambient 3D sound audio player component.</p>
<ol class="calibre14">
<li class="calibre15">Open the <code>Ventilation 1</code> Prefab in Prefab Edit Mode.</li>
<li class="calibre15">Use your preferred method to add the <code>AudioPlayerAmbient</code> component to the root object.</li>
<li class="calibre15">An <code>AudioSource</code> component will automatically be added when we add the audio player component (due to the <code>RequireComponent</code> attribute).</li>
<li class="calibre15">Unlike the previous audio player components, where we provided fields for <code>AudioSource</code> component to tailor the sound to the proper environmental audio effect for its location.</li>
</ol>
<p class="calibre3">Before we continue configuring the audio source, it would help to have a sound to play so we can make the proper adjustments.</p>
<p class="calibre3">The sound file we’ll use for our ventilation shaft inlet is <code>metro-subway-hallway-corner-noise-heavy-ventilation-rumble.flac</code> (no, I didn’t name it!). It comes from Freesound (<a href="https://freesound.org/people/kyles/sounds/455811/" class="pcalibre1 pcalibre calibre6">https://freesound.org/people/kyles/sounds/455811/</a>) and is licensed CC0 (still free to use).</p>
<p class="calibre3">Ensure the <code>metro-subway-hallway-corner-noise-heavy-ventilation-rumble.flac</code> file is imported to the <code>Assets/Audio/Ambient</code> folder. We’ll make a few changes to the import settings values for this sound file.</p>
<p class="calibre3">Referring<a id="_idIndexMarker1279" class="pcalibre1 pcalibre calibre6"/> back to <em class="italic">Figure 12</em><em class="italic">.4</em> for an import settings<a id="_idIndexMarker1280" class="pcalibre1 pcalibre calibre6"/> reference, set the following:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Force To Mono</strong> = true, <strong class="bold">Normalize</strong> = true: Disregard the L/R stereo channels of the sound file (combine them) and set the audio levels to a normalized value.</li>
<li class="calibre15"><strong class="bold">Load In Background</strong> = true: Loads the larger-sized audio file without causing the main thread to lag. Sound will start playing once the file is loaded (which may not be at the start of the scene being loaded).</li>
<li class="calibre15"><strong class="bold">Load Type</strong> = <strong class="bold">Streaming</strong>: Decode audio with minimal memory use from disk and using a separate CPU thread.</li>
<li class="calibre15"><code>30</code>: Balance playback quality and file size by adjusting the compression slider for a compressed clip. Keep the file small for distribution while maintaining playback quality.</li>
</ul>
<p class="calibre3">Return to the <code>AudioPlayerAmbient</code> component on the ventilation shaft inlet, then click and drag the <code>metro-subway-hallway-corner-noise-heavy-ventilation-rumble</code> file to the <code>Ventilation 1</code> Prefab (by clicking <strong class="bold">Save</strong> in Prefab Edit Mode, or at the top of the <strong class="bold">Inspector</strong>, click <strong class="bold">Apply All</strong> in the <strong class="bold">Prefab</strong> | <strong class="bold">Overrides</strong> dropdown).</p>
<p class="calibre3">Before we playtest the level with the ambient sound playing, let’s review the 3D sound settings that affect<a id="_idIndexMarker1281" class="pcalibre1 pcalibre calibre6"/> how ambient sound can<a id="_idIndexMarker1282" class="pcalibre1 pcalibre calibre6"/> be heard in the environment.</p>
<h3 class="calibre10">3D ambient sound settings</h3>
<p class="calibre3">It’s time to <a id="_idIndexMarker1283" class="pcalibre1 pcalibre calibre6"/>put our sound designer hat on! When<a id="_idIndexMarker1284" class="pcalibre1 pcalibre calibre6"/> we added the audio player component to the ventilation shaft inlet Prefab, I mentioned we’d tailor the sound directly using the audio source properties.</p>
<p class="calibre3">Referring to the <code>270</code> to influence how the sound is distributed in 3D space. Lower values create more directional sound (heard only in front of the source), whereas higher values produce more omnidirectional sound (can be heard from wider angles). A value of <code>360</code> would make it seem like the sound is coming from everywhere around the listener.</p>
<p class="callout-heading">Tip | Open the Properties window</p>
<p class="callout">In the <strong class="bold">Inspector</strong>, right-clicking on the <strong class="bold">AudioSource</strong> component title, then clicking <strong class="bold">Properties…</strong> will open it in a floating <strong class="bold">Properties</strong> window. You can do this for objects, components, and file assets from most windows in the Unity Editor.</p>
<p class="calibre3">Playtest the level, adjust the <strong class="bold">Spread</strong> value of the audio source as desired, and take notice of the ambient sound’s playback.</p>
<p class="calibre3">In this section, we learned how to create components to play audio for different auditory experiences and implement them on objects in our environment. In the next section, we’ll add to immersion in the environment by adding footstep sounds to the player.</p>
<h1 id="_idParaDest-231" class="calibre5"><a id="_idTextAnchor246" class="pcalibre1 pcalibre calibre6"/>Enhancing the audio experience with footsteps and reverb zones</h1>
<p class="calibre3">Creating an <a id="_idIndexMarker1285" class="pcalibre1 pcalibre calibre6"/>immersive and enjoyable gaming experience requires paying close attention to sound design. Even seemingly simple elements, such as footstep sounds, play a significant role in grounding characters in their environment and conveying a sense of physicality and presence.</p>
<p class="calibre3">With footsteps in particular, it’s crucial to have a variety of footstep sounds to randomize them and adjust tempo or cadence based on the player’s speed to prevent auditory fatigue and repetition (you could even take it so far as to have different sounds for each surface type the player walks on).</p>
<p class="calibre3">Optimizing how continuously randomized audio clips are played back is also essential to ensure the process doesn’t negatively impact the game’s performance.</p>
<p class="calibre3">With our footstep sounds implementation, we will address all these factors. Considering the audio player components and manager code we’ve already written, the implementation is more straightforward than you may think.</p>
<h2 id="_idParaDest-232" class="calibre8"><a id="_idTextAnchor247" class="pcalibre1 pcalibre calibre6"/>Reusing audio player code</h2>
<p class="calibre3">Nothing could be<a id="_idIndexMarker1286" class="pcalibre1 pcalibre calibre6"/> simpler <a id="_idIndexMarker1287" class="pcalibre1 pcalibre calibre6"/>than starting with one of our existing audio player components to play the footstep sounds! So, we’ll rely on <code>AudioPlayerSFX</code> for the footsteps and not create footstep sounds with a new direct implementation of the <code>IPlaySound</code> interface. I mean, we could, but we’d just be duplicating the functionality that <code>AudioPlayerSFX</code> already provides. For those of you keeping track, the cards in play here are code <a id="_idIndexMarker1288" class="pcalibre1 pcalibre calibre6"/>reuse, <strong class="bold">don’t repeat yourself</strong> (<strong class="bold">DRY</strong>), <strong class="bold">keep it simple, silly</strong> (<strong class="bold">KISS</strong>), and<a id="_idIndexMarker1289" class="pcalibre1 pcalibre calibre6"/> let’s also claim the single responsibility card.</p>
<p class="calibre3">This time, instead of requiring a built-in component provided by the Unity game engine, we’ll require our own <code>AudioPlayerSFX</code> component to be added to the GameObject that we’re adding a new play footstep sounds component to.</p>
<p class="calibre3">Let’s see this implementation by creating a new <code>AudioPlayerFootsteps</code> script in the <code>Assets/Scripts/Audio</code> folder with the following initial code:</p>
<pre class="source-code">
[RequireComponent(typeof(AudioPlayerSFX))]
public class AudioPlayerFootsteps : MonoBehaviour
{
    [SerializeField]
    private float _walkInterval = 0.5f;
    private AudioPlayerSFX _playerSFX;
    private float _timerStep;
    private void OnValidate()
        =&gt; _playerSFX = GetComponent&lt;AudioPlayerSFX&gt;();
    private void Start()
        =&gt; _timerStep = _walkInterval;
}</pre> <p class="calibre3">Remember, the <code>RequireComponent</code> attribute forces a composition pattern by combining components to<a id="_idIndexMarker1290" class="pcalibre1 pcalibre calibre6"/> implement<a id="_idIndexMarker1291" class="pcalibre1 pcalibre calibre6"/> the desired functionality. So, as mentioned previously, we’ve required the <code>AudioPlayerSFX</code> component and pre-assigned the reference to the <code>_playerSFX</code> variable in the <code>OnValidate()</code> method.</p>
<p class="calibre3">We also declare these variables:</p>
<ul class="calibre17">
<li class="calibre15"><code>_walkInterval</code>: This variable value should match the cadence, or speed, of the player walking – in other words, the time between the footstep sound playing</li>
<li class="calibre15"><code>_timerStep</code>: This variable will hold the current interval for footstep sounds to play (spoiler alert: we’ll have different values assigned based on whether the player is walking or sprinting)</li>
</ul>
<p class="calibre3">Okay, we have the base boilerplate code in place. Let’s add our footstep audio clips list variable and an update loop to play a random footstep sound from the list at the assigned time interval:</p>
<pre class="source-code">
public class AudioPlayerFootsteps : MonoBehaviour
{
    …
    [SerializeField]
    private AudioClip[] _footstepSounds;
    …
    private void Update()
    {
        float currentStepInterval = _walkInterval;
        _timerStep -= Time.deltaTime;
        if (_timerStep &lt;= 0)
        {
            _playerSFX.Play(_footstepSounds[
                Random.Range(0, _footstepSounds.Length)]);
            _timerStep = currentStepInterval;
        }
    }
}</pre> <p class="calibre3">And here, we’ve <a id="_idIndexMarker1292" class="pcalibre1 pcalibre calibre6"/>done <a id="_idIndexMarker1293" class="pcalibre1 pcalibre calibre6"/>precisely what’s needed:</p>
<ul class="calibre17">
<li class="calibre15"><code>_footstepSounds</code>: Here, we have our <code>AudioClip[]</code> array of footstep sound file assets that will be randomly selected and played at the set time interval. Refer to <em class="italic">Figure 12</em><em class="italic">.11</em> for a sneak peek at this <strong class="bold">Inspector</strong> assignment.</li>
<li class="calibre15"><code>Update()</code>: The update loop will keep our <code>_timeStep</code> variable current with its new time. Then, we’ll evaluate to see whether <code>_timeStep</code> has expired to play the following randomly selected clip. We finish up by resetting <code>_timeStep</code> to delay the next play at intervals.</li>
</ul>
<p class="calibre3">Looking good! Optionally, we can do a bit better for code readability, and that would be with a quick refactor extracting the code that gets a <a id="_idTextAnchor248" class="pcalibre1 pcalibre calibre6"/>random footstep sound into a local function, like so:</p>
<pre class="source-code">
    AudioClip GetRandomFootstepClip()
        =&gt; _footstepSounds[
            Random.Range(0, _footstepSounds.Count)];</pre> <p class="calibre3">The line of code for playing the SFX would now look like this:</p>
<pre class="source-code">
    if (_timerStep &lt;= 0)
    {
        _playerSFX.Play(GetRandomFootstepClip());</pre> <p class="calibre3">It’s, again, a quick, optional<a id="_idIndexMarker1294" class="pcalibre1 pcalibre calibre6"/> refactor <a id="_idIndexMarker1295" class="pcalibre1 pcalibre calibre6"/>that doesn’t change the functionality. Still, one that makes for better code readability – and anything that helps code readability is worth the little bit of extra work for clarity (for someone else looking at your code or yourself in six months), and if it requires a bit more, add a code comment!</p>
<p class="callout-heading">Complete code for the audio player components</p>
<p class="callout">Don’t forget, at any time, if you need to see the completed code for these sections, you can find it at the GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio</a></p>
<p class="calibre3">The <code>AudioPlayerFootsteps</code> component doesn’t play sound itself. As we know, it uses <code>PlaySoundSFX.Play()</code> and passes an audio clip as the parameter. The only problem is that <code>Play()</code> doesn’t currently accept a parameter! Let’s fix that now by adding a method overload.</p>
<h2 id="_idParaDest-233" class="calibre8"><a id="_idTextAnchor249" class="pcalibre1 pcalibre calibre6"/>Adding a method overload to AudioPlayerSFX</h2>
<p class="calibre3">So, now, we’ll<a id="_idIndexMarker1296" class="pcalibre1 pcalibre calibre6"/> overload <a id="_idIndexMarker1297" class="pcalibre1 pcalibre calibre6"/>the <code>Play()</code> method in <code>AudioPlayerSFX</code> to add the required <code>AudioClip</code> parameter for the current audio clip for the footstep we want to play (well, that was randomly selected for us to play).</p>
<p class="calibre3">In <code>AudioPlayerSFX</code>, add the following method with its code:</p>
<pre class="source-code">
    public void Play(AudioClip clip)
    {
        _audioClip = clip;
        AudioManager.Instance.PlayAudio(this);
    }</pre> <p class="calibre3">We already have a <code>Play()</code> method without a parameter, so we’re overloading the <code>Play()</code> method now by declaring another with the same method name but with a different method signature (because we’ve added the <code>AudioClip</code> parameter). Now, when <code>Play()</code> is called, the one that matches the method signature will be the specific method executed – either with the passed-in audio clip or without.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Avoid frequent clip changes: It’s important to remember that repeatedly changing an <strong class="source-inline1">AudioSource</strong> clip can be less efficient than using multiple audio sources or the <strong class="source-inline1">AudioSource.PlayOneShot()</strong> method. In such cases, it’s recommended to use the <strong class="source-inline1">PlayOneShot()</strong> method, as it allows you to play a clip without changing the audio source’s main clip.</p>
<p class="calibre3">We can now move on to adding the footstep sounds to our player character in the next section.</p>
<h2 id="_idParaDest-234" class="calibre8"><a id="_idTextAnchor250" class="pcalibre1 pcalibre calibre6"/>Implementing AudioPlayerFootsteps</h2>
<p class="calibre3">Okay, this will<a id="_idIndexMarker1298" class="pcalibre1 pcalibre calibre6"/> be <a id="_idIndexMarker1299" class="pcalibre1 pcalibre calibre6"/>our fifth implementation of an audio player component, so there’s no reason to delay. Let’s go right ahead and add to <code>PlayerCapsule</code>. Since we’ll be requiring some of the other components already on the <code>PlayerCapsule</code> object in the next section (such as <code>CharacterController</code> and <code>PlayerInput</code>), we’ll want to add <code>AudioPlayerFootsteps</code> right to the root of this object.</p>
<p class="calibre3">Now that we’ve added <code>AudioPlayerFootsteps</code>, you should have seen <code>AudioPLayerSFX</code> added, thanks to the <code>RequireComponent</code> attribute, so that takes care of the ability to play sound through the SFX Audio Mixer channel. All that’s left to do to get something playing is to add the sound files to the <code>_footstepSounds</code> array in the <strong class="bold">Inspector</strong>.</p>
<p class="calibre3">The sound files we’ll use this time come from the Unity Asset Store. We’ll use <code>Classic Footstep SFX (Free)</code> by Matthew Anett (<a href="https://assetstore.unity.com/packages/audio/sound-fx/classic-footstep-sfx-173668" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/audio/sound-fx/classic-footstep-sfx-173668</a>). From its name, you can see that we can use it freely in our projects. Yay!</p>
<p class="calibre3">Ensure the <code>Classic Footstep SFX (Free)</code> package is imported to your project. By default, this will be the <code>Assets/Classic Footstep SFX</code> folder. Unlike with the other audio files, since this is a package, the import settings are already set for us by the author, so we’re <a id="_idIndexMarker1300" class="pcalibre1 pcalibre calibre6"/>all <a id="_idIndexMarker1301" class="pcalibre1 pcalibre calibre6"/>set to start using them.</p>
<p class="calibre3">Follow these steps to assign the provided footstep sound files to the <code>AudioPlayerFootsteps</code> component’s <code>_footstepSounds</code> array field:</p>
<ol class="calibre14">
<li class="calibre15">Return to the <code>AudioPlayerFootsteps</code> component on <code>PlayerCapsule</code> and lock the <strong class="bold">Inspector</strong> window (using the little <em class="italic">lock</em> icon at the top-right of the <strong class="bold">Inspector</strong> tab). By locking the window, no matter what we select, the <strong class="bold">Inspector</strong> will stay on this window, which is essential for selecting multiple objects in the <strong class="bold">Project</strong> window to be assigned to a component field.</li>
<li class="calibre15">With the <code>Assets/Classic Footstep SFX/Floor</code> folder in the <strong class="bold">Project</strong> window.</li>
<li class="calibre15">While within the <code>Floor_step0</code>), then hold <em class="italic">Shift</em> and click on the last sound file, or any range of files to select them.</li>
<li class="calibre15">With the sound files selected, click and drag (from anywhere in the selection) to the <strong class="bold">Footstep Sounds</strong> field label, and you’ll see the mouse cursor change from an arrow to an arrow with a box and a plus sign. Releasing the mouse button while hovering over the field name will populate the array with all the sound files in the selection.</li>
<li class="calibre15">You can unlock the <strong class="bold">Inspector</strong> window now and check the assignment of the sound files by expanding the array (with the arrow to the left of the <strong class="bold">Footstep Sounds</strong> field label) as seen in <em class="italic">Figure 12</em><em class="italic">.11</em>. Note that I’ve only shown five assigned for <a id="_idIndexMarker1302" class="pcalibre1 pcalibre calibre6"/>brevity<a id="_idIndexMarker1303" class="pcalibre1 pcalibre calibre6"/> in the figure.</li>
</ol>
<div><div><img alt="Figure 12.11 – AudioPlayerFootsteps component assignments" src="img/B18347_12_11.jpg" class="calibre149"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.11 – AudioPlayerFootsteps component assignments</p>
<p class="calibre3">If you try to use the <code>AudioPlayerFootsteps</code> code as it sits now, you’re going to be hearing footsteps all the darn time because there are no conditional statements to tell us when we should not play footsteps! That just won’t do, so let’s modify <code>AudioPlayerFootsteps</code> with a conditional check.</p>
<p class="calibre3">First, we need a reference to the player character controller… so add a new field to <code>AudioPlayerFootsteps</code> to hold the reference (you’ll have to set the reference in the <strong class="bold">Inspector</strong> for this field manually, so don’t forget to – you inevitably will fail, I know I do):</p>
<pre class="source-code">
    [SerializeField]
    private CharacterController _characterController;</pre> <p class="calibre3">We can now evaluate “Is the player grounded or moving?” by adding the following <code>if</code> statement:</p>
<pre class="source-code">
    private void Update()
    {
        if (!_characterController.isGrounded
            || _characterController.velocity.magnitude &lt;= 0)
            return;
        …</pre> <p class="calibre3">Using <code>return</code>, we short-circuit the <code>Update()</code> method so it doesn’t continue and, therefore, doesn’t play any footstep sounds. Groovy.</p>
<p class="calibre3">At this stage, playtesting will give us our footstep sounds only while walking. However, we can also have the player sprint by holding the <em class="italic">Shift</em> key while moving forward. The problem we currently face is that the interval for the footstep sounds is consistent, resulting in sprinting<a id="_idIndexMarker1304" class="pcalibre1 pcalibre calibre6"/> sounding <a id="_idIndexMarker1305" class="pcalibre1 pcalibre calibre6"/>identical to walking. We can quickly solve this problem by adding a condition for a second interval, specifically for sprinting.</p>
<h2 id="_idParaDest-235" class="calibre8"><a id="_idTextAnchor251" class="pcalibre1 pcalibre calibre6"/>Implementing sprinting</h2>
<p class="calibre3">Okay, that setup<a id="_idIndexMarker1306" class="pcalibre1 pcalibre calibre6"/> made it <a id="_idIndexMarker1307" class="pcalibre1 pcalibre calibre6"/>sound like this would be difficult. It is not. It’s barely inconvenient because we’ll tap directly into the <strong class="bold">Player </strong><strong class="bold">Input</strong> functionality.</p>
<p class="calibre3">When we provide input – by pressing keys or using a gamepad – the Input System processes those keys through the <strong class="bold">Player Input</strong> component, which, in turn, sends out message events. So, all we have to do is add a method handler (i.e., listener) for the one sent when the player wants to start sprinting. In <em class="italic">Figure 12</em><em class="italic">.12</em>, that’s <strong class="bold">OnSprint</strong>, and we can see it listed right on the <strong class="bold">Player Input</strong> component in the box just under <strong class="bold">Behavior</strong>.</p>
<div><div><img alt="Figure 12.12 – Player Input SendMessage() to GameObject list" src="img/B18347_12_12.jpg" class="calibre150"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Player Input SendMessage() to GameObject list</p>
<p class="calibre3">Adding the ability to respond to the player sprinting is now just a matter of updating the <code>AudioPlayerFootsteps</code> class <a id="_idIndexMarker1308" class="pcalibre1 pcalibre calibre6"/>with<a id="_idIndexMarker1309" class="pcalibre1 pcalibre calibre6"/> the required code. Add the following:</p>
<pre class="source-code">
using UnityEngine.InputSystem;
public class AudioPlayerFootsteps : MonoBehaviour
{
    …
    [SerializeField] private float _sprintInterval = 0.3f;
    private bool _isSprinting;
    …
    public void OnSprint(InputValue value)
        =&gt; _isSprinting = value.isPressed;
}</pre> <p class="calibre3">We add a new variable to assign the time interval for sprinting in the <code>_sprintInterval</code> and a related Boolean variable to evaluate whether the player is currently sprinting or not, with <code>_isSprinting</code>. Then, <code>OnSprint()</code> will set <code>_isSprinting</code> to <code>true</code> or <code>false</code> depending on <code>value.isPressed</code> passed in from the Input System.</p>
<p class="calibre3">All we need to do now is assign the proper step interval to the <code>_currentStepInterval</code> variable that will be used along with the <code>_timerStep</code> variable for playing footsteps at the correct time interval. Do so by making the following changes to the <code>Update()</code> method:</p>
<pre class="source-code">
    private void Update()
    {
        if (!_characterController.isGrounded
            || _characterController.velocity.magnitude &lt;= 0)
            return;
        float currentStepInterval =
            _isSprinting ? _sprintInterval : _walkInterval;
        …</pre> <p class="calibre3">And that wraps up footstep sounds! Playtesting now should produce footsteps matching the player while walking or sprinting. This is precisely the attention to detail that sets your games apart from the field – players notice and appreciate an indie developer’s efforts with things like this.</p>
<p class="calibre3">One additional attention to immersive sound details in your level that you can quickly add to<a id="_idIndexMarker1310" class="pcalibre1 pcalibre calibre6"/> the<a id="_idIndexMarker1311" class="pcalibre1 pcalibre calibre6"/> production value of your game soundscape is reverb zones, and the next section will show the simple steps to add one.</p>
<h2 id="_idParaDest-236" class="calibre8"><a id="_idTextAnchor252" class="pcalibre1 pcalibre calibre6"/>Adding reverb zones</h2>
<p class="calibre3">Reverb zones<a id="_idIndexMarker1312" class="pcalibre1 pcalibre calibre6"/> simulate <a id="_idIndexMarker1313" class="pcalibre1 pcalibre calibre6"/>the acoustics of sound in different spaces, whether echoing in a large warehouse or dampening in a small storage room, adding depth to the soundscape and enhancing the game’s atmosphere as the player moves between different areas in a level.</p>
<p class="calibre3">Additionally, simulating the acoustic properties can assist in storytelling and subtly guide player emotions and expectations, which is just another tool game designers can use to build more immersive and believable gaming experiences.</p>
<p class="calibre3">Find some key areas in your level where you feel the acoustics would be affected by the scale of the space. Using <em class="italic">Figure 12</em><em class="italic">.13</em>, we’ll use the following example to add a reverb zone to one of the larger rooms of the level:</p>
<ol class="calibre14">
<li class="calibre15">Add an empty GameObject to the scene and position it in the center of a large room.</li>
<li class="calibre15">Rename<a id="_idIndexMarker1314" class="pcalibre1 pcalibre calibre6"/> the GameObject <code>Reverb Zone</code> (optionally, parent it to an object to organize all zones in the <strong class="bold">Hierarchy</strong>).</li>
<li class="calibre15">Add an <code>AudioReverbZone</code> component to the <code>Reverb </code><code>Zone</code> object.</li>
</ol>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">You can read more about reverb zones here: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioReverbZone.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioReverbZone.xhtml</a></p>
<ol class="calibre14">
<li value="4" class="calibre15">Choose an appropriate <strong class="bold">ReverbPreset</strong> option. Or, select <strong class="bold">User</strong> and customize the property sliders underneath to your desired effect. In the following figure, you can see I chose the <strong class="bold">Hangar</strong> preset.</li>
</ol>
<div><div><img alt="Figure 12.13 – Reverb zone placement and settings" src="img/B18347_12_13.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Reverb zone placement and settings</p>
<p class="calibre3">And that’s all that’s required to add the reverb zone to our level – playtest and adjust the zone properties to your liking. However, we’ll want to ensure that the music playback isn’t affected by the reverb zone (that wouldn’t make sense for the music to be affected by the environmental changes, would it?).</p>
<p class="calibre3">We can do this very<a id="_idIndexMarker1315" class="pcalibre1 pcalibre calibre6"/> easily<a id="_idIndexMarker1316" class="pcalibre1 pcalibre calibre6"/> in our code – we <em class="italic">have to</em> because we don’t have a resident <code>AudioSource</code> sitting on a GameObject in our scene for playing music; we’re adding it via code.</p>
<p class="calibre3">So, in our <code>AudioManager</code> script, in the <code>PlayMusic()</code> method, simply add this line to the list of audio source music settings we assign:</p>
<pre class="source-code">
_audioSourceMusic.bypassReverbZones = true;</pre> <p class="calibre3">That’s it! Our music playback will no longer be affected by the reverb zone, while the remainder of the playing sounds, especially the footstep sounds, will be.</p>
<p class="calibre3">This brings us to the end of adding audio to our game. In this section, we learned how to create varying audio playback components that route through an audio manager class to establish the rules for how sound is played with this system.</p>
<p class="calibre3">We now have an audio toolset at our disposal to handle most use cases for the different types of audio playback a game requires. You can now revisit the earlier projects in the book to add your own sound design and level up the gameplay experience for the player. Have fun while wearing your sound designer hat!</p>
<p class="calibre3">Next, we’ll have <a id="_idIndexMarker1317" class="pcalibre1 pcalibre calibre6"/>a quick look <a id="_idIndexMarker1318" class="pcalibre1 pcalibre calibre6"/>at how we can refactor our audio player components to better adhere to the SOLID principles.</p>
<h1 id="_idParaDest-237" class="calibre5"><a id="_idTextAnchor253" class="pcalibre1 pcalibre calibre6"/>Deeper SOLID refactoring</h1>
<p class="calibre3">We can take the<a id="_idIndexMarker1319" class="pcalibre1 pcalibre calibre6"/> OCP of the SOLID principles further by using an abstract base class that all audio player classes derive from. This can add further required implementations and default behavior and would then be a<a id="_idIndexMarker1320" class="pcalibre1 pcalibre calibre6"/> classic <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) inheritance example.</p>
<p class="callout-heading">OOP SOLID principles reminder</p>
<p class="callout">In OOP, the derived class inherits all base class members and can also add its members. However, it’s essential to keep<a id="_idIndexMarker1321" class="pcalibre1 pcalibre calibre6"/> the <em class="italic">Liskov substitution</em> principle of the SOLID principles in mind when using derived classes. The <em class="italic">L</em> principle states that objects of a base class should be replaceable with objects of a derived class without changing the correctness of the program. In simpler terms, any program that uses a base class reference should be able to use any derived classes without knowing it. For OOP, this is polymorphism, which allows us to write more general code that works with any audio-playing class.</p>
<p class="calibre3">Let’s take a look at how we might write an abstract base class that the audio-playing classes in our project could inherit from:</p>
<pre class="source-code">
using AudioType = AudioManager.AudioType;
public abstract class AudioPlayerBase : MonoBehaviour, IPlaySound
{
    [SerializeField] protected AudioClip _audioClip;
    public abstract AudioType PlayAudioType { get; }
    public virtual void PlaySound(AudioSource source)
        =&gt; source.PlayOneShot(_audioClip);
    public virtual void Play()
        =&gt; AudioManager.Instance.PlayAudio(this);
}</pre> <p class="calibre3">Here is what we did:</p>
<ul class="calibre17">
<li class="calibre15"><code>_audioClip</code>: The field is <a id="_idIndexMarker1322" class="pcalibre1 pcalibre calibre6"/>marked protected, which means inherited classes can access it. Makes things pretty easy, eh?</li>
<li class="calibre15"><code>abstract PlayAudioType</code> (property): This abstract property ensures that each derived class will define its own <code>AudioType</code> value. This is a good use of an abstract property because it enforces each audio-playing class to specify its own <code>AudioType</code> value.</li>
<li class="calibre15"><code>PlaySound()</code>: The method provides a default implementation for playing a sound that all inheriting classes can share. Because we included the <code>virtual</code> keyword in the method signature, if a derived class needs a different behavior, it can override this method. We must also define <code>PlaySound()</code> – and <code>PlayAudioType</code> – because we must implement the <code>IPlaySound</code> interface!</li>
<li class="calibre15"><code>Play()</code>: The method provides a way to play the specified <code>AudioClip</code>. Here, we’re delegating the play functionality to the <code>AudioManager</code> instance, adhering to our pattern and assigning the <code>AudioMixerGroup</code> group accordingly for the <code>AudioType</code> value. Note it’s also <code>virtual</code>, so it can be overridden by inheriting classes if a different behavior is needed.</li>
</ul>
<p class="calibre3">The <code>AudioPlayerBase</code> abstract base class provides a good foundation for creating specific audio-playing classes – as many different kinds as needed. We’ve enforced a consistent interface for our classes to provide default implementations for behavior while allowing for customization by the inheriting classes. Yay!</p>
<p class="calibre3">Now that you’ve seen how we can approach an abstract base class that all our audio-playing classes can derive from, go ahead and try the refactor yourself! The project code on the GitHub link for the chapter has already provided an example of a refactored <code>AudioPlayerSFX3D_Derived</code> component that inherits from the <code>AudioPlayerBase</code> abstract base class, so you can use that as a reference (give it an honest try, no peeking).</p>
<p class="callout-heading">AudioPlayerBase completed code</p>
<p class="callout">To view the completed<a id="_idIndexMarker1323" class="pcalibre1 pcalibre calibre6"/> code for the <strong class="source-inline1">AudioPlayerBase</strong> class and an example of an inherited class, visit the GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch12/Unity-Project/Assets/Scripts/Audio</a></p>
<p class="calibre3">In this section, we learned how to refactor our code to be more aligned with the SOLID programming principles. While our code is pretty complete already (I’m sure someone could always think of more types of audio player components to extend), this refactor makes it even easier<a id="_idIndexMarker1324" class="pcalibre1 pcalibre calibre6"/> to extend upon the code to add additional audio player component types without having to modify the manager class.</p>
<h1 id="_idParaDest-238" class="calibre5"><a id="_idTextAnchor254" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this “audio chapter,” we extensively covered adding audio to our game by introducing an audio manager and individual reusable audio player components. We used the audio manager as a fool-proof implementation for designers and developers alike to target the appropriate mixer group for setting playback levels for the game’s soundscape.</p>
<p class="calibre3">We continued by coding individual audio components for sound playback of the different types of audio common in most games – music, SFX, and ambient sound. We created these reusable audio player components following SOLID programming principles so we can extend additional types of audio components without modifying the manager class. We finished with a footsteps sound example showing how we can compose components for a simple implementation and also quickly add an environmental audio effect with reverb zones.</p>
<p class="calibre3">In the next chapter, we’ll continue to flesh out the game by adding an intelligent non-player character (NPC). We’ll accomplish this by, again, refactoring our previous 2D code for 3D usage as well as introducing cutting-edge technology for dynamic enemies utilizing sensors, a behavior tree, and machine learning (AI) techniques.</p>
</div>
</div></body></html>