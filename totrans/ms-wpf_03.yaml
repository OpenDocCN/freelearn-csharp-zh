- en: Writing Custom Application Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义应用程序框架
- en: In this chapter, we will investigate application frameworks and the benefits
    that they can bring us. We find out the differences between providing this functionality
    via base classes and interfaces and also discover other ways to build functionality
    into our frameworks. We will then use this newfound knowledge to begin to construct
    our own application framework to streamline our future application development.
    The chapter will finish off by inspecting a variety of techniques to ensure that
    our applications maintain the essential Separation of Concerns that MVVM provides.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究应用程序框架及其能为我们带来的好处。我们将了解通过基类和接口提供此功能之间的差异，并发现将功能构建到我们的框架中的其他方法。然后，我们将利用这些新获得的知识来开始构建我们自己的应用程序框架，以简化我们未来的应用程序开发。本章将以检查各种技术结束，以确保我们的应用程序保持MVVM提供的必要关注点分离。
- en: What is an application framework?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是应用程序框架？
- en: In the simplest terms, an application framework is comprised of a library of
    classes that, together, provide the most common functionality required by an application.
    By using an application framework, we can vastly reduce the amount of work and
    time that is required to create the various parts of the application. In short,
    they support the future development of the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，应用程序框架由一个类库组成，这些类库共同提供了应用程序所需的最常见功能。通过使用应用程序框架，我们可以大大减少创建应用程序各个部分所需的工作量和时间。简而言之，它们支持应用程序的未来发展。
- en: In typical three-tier applications, the framework often extends through all
    layers of the application; the **Presentation Layer**, the **Business Layer**,
    and the **Data Access Layer**. In a WPF application using the MVVM pattern, we
    can, therefore, see aspects of the application framework in all three components
    of the pattern; the Models, the View Models, and the Views.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的三层应用程序中，框架通常扩展到应用程序的所有层；即**表示层**、**业务层**和**数据访问层**。因此，在采用MVVM模式的WPF应用程序中，我们可以在模式的三个组件中看到应用程序框架的各个方面；即模型、视图模型和视图。
- en: Apart from the obvious benefits of the reduced production times and effort involved
    in creating our application components, application frameworks also provide many
    additional benefits. Typical application frameworks promote reusability, which
    is one of the core aims of **Object-Oriented Programming** (**OOP**). They do
    this by providing generic interfaces and/or base classes that can be used to define
    the various application components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建我们的应用程序组件所涉及的生产时间和努力减少的明显好处外，应用程序框架还提供了许多额外的优势。典型的应用程序框架促进可重用性，这是面向对象编程（**OOP**）的核心目标之一。它们通过提供通用的接口和/或基类来实现这一点，这些接口和基类可以用来定义各种应用程序组件。
- en: By reusing these application framework interfaces and base classes, we also
    instill a sense of uniformity and consistency throughout the application. Furthermore,
    as these frameworks generally provide additional functionality, or services, the
    developers working on the application can save further time when requiring this
    particular functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重用这些应用程序框架接口和基类，我们还在整个应用程序中灌输了一种统一性和一致性。此外，由于这些框架通常提供额外的功能或服务，因此从事应用程序开发的开发人员在需要这种特定功能时可以节省更多时间。
- en: Concepts like modularity, maintainability, testability, and extensibility can
    also be realized by using an application framework. These frameworks often come
    with the ability to run individual components independently of each other and
    this fits WPF and the MVVM pattern extremely well. Additionally, application frameworks
    can also supply patterns of implementation to further simplify the process of
    constructing new application components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用应用程序框架，还可以实现诸如模块化、可维护性、可测试性和可扩展性等概念。这些框架通常具有独立运行各个组件的能力，这与WPF和MVVM模式非常契合。此外，应用程序框架还可以提供实现模式，以进一步简化构建新应用程序组件的过程。
- en: Different frameworks are created for different technologies and WPF already
    have a few publicly available. Some are relatively lightweight, like the **MVVM
    Light Toolkit** and the **WPF Application Framework** (**WAF**), while others
    are more heavyweight, like **Caliburn.Micro** and the now open source **Prism**.
    While it is likely that you may have used one or more of these frameworks at work,
    instead of investigating these in this chapter, we'll look at how to create our
    own lightweight custom framework, that will implement just the features that we
    need.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为不同的技术创建了不同的框架，WPF已经有一些公开可用的框架。有些相对较轻量级，如**MVVM Light Toolkit**和**WPF Application
    Framework**（**WAF**），而有些则更重量级，如**Caliburn.Micro**和现在开源的**Prism**。虽然你可能在工作中可能使用过这些框架之一或多个，但在这个章节中，我们将探讨如何创建我们自己的轻量级自定义框架，它将只实现我们需要的功能。
- en: Encapsulating common functionality
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装通用功能
- en: 'Probably the most commonly used interface in any WPF application would be the
    `INotifyPropertyChanged` interface, as it is required to correctly implement data
    binding. By providing an implementation of this interface in our base class, we
    can avoid having to repeatedly implement it in every single View Model class.
    It is, therefore, a great candidate for inclusion in our base class. There are
    a number of different ways to implement it depending on our requirements, so let''s
    take a look at the most basic first:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何WPF应用程序中，最常用的接口可能是`INotifyPropertyChanged`接口，因为它需要正确实现数据绑定。通过在我们的基类中提供这个接口的实现，我们可以避免在每个单独的ViewModel类中重复实现它。因此，它非常适合包含在我们的基类中。根据我们的需求，有多种不同的实现方式，所以让我们先看看最基本的实现：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In all forms of this implementation, we first need to declare the `PropertyChanged`
    event. This is the event that will be used to notify the various binding sources
    and targets of changes to the data bound values in our application. Note that
    this is the only requirement of the `INotifyPropertyChanged` interface. There
    is no `NotifyPropertyChanged` method that we have to implement, so you may well
    come across differently named methods that perform the same functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有形式的这个实现中，我们首先需要声明`PropertyChanged`事件。这是我们用来通知应用程序中数据绑定值更改的各种绑定源和目标的唯一事件。请注意，这是`INotifyPropertyChanged`接口的唯一要求。我们没有必须实现的`NotifyPropertyChanged`方法，因此你可能会遇到不同名称的方法，但它们执行的功能是相同的。
- en: 'Of course, without the method, just implementing the event would do nothing.
    The basic idea of this method is that as usual, we first check for `null`, and
    then raise the event, passing the raising class instance as the `sender` parameter
    and the name of the property that changed in the `PropertyChangedEventArgs`. We
    have already seen that the null conditional operator in C# 6.0 provides us with
    a shorthand notation for this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有这个方法，仅仅实现事件什么也不会发生。这个方法的基本思想是，像往常一样，我们首先检查`null`，然后引发事件，将引发事件的类实例作为`sender`参数和`PropertyChangedEventArgs`中更改的属性名称传递。我们已经看到，C#
    6.0中的空条件运算符为我们提供了这个的简写符号：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the declared access modifier on this method is `protected`, to ensure
    that all View Models that derive from this base class will have access to it,
    while non-deriving classes will not. Furthermore, the method is also marked as
    `virtual`, so that the derived classes can override this functionality if required.
    In the View Models, this method would be called from a property like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个方法的声明访问修饰符是`protected`，以确保所有从该基类派生的ViewModel都可以访问它，而未派生的类则不能。此外，该方法也被标记为`virtual`，以便派生类在需要时可以覆盖这个功能。在ViewModel中，这个方法可以通过如下属性调用：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, a new attribute was added in .NET 4.5, that gives us a shortcut to
    use with this implementation. The `CallerMemberNameAttribute` class enables us
    to automatically obtain the name of the method caller, or more specifically in
    our case, the name of the property that called the method. We can use it with
    an optional input parameter with a default value, like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在.NET 4.5中增加了一个新的特性，它为我们提供了使用这个实现的快捷方式。`CallerMemberNameAttribute`类使我们能够自动获取方法调用者的名称，或者更具体地说，在我们的情况下，是调用方法的属性名称。我们可以使用它，并带有可选的默认值输入参数，如下所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The calling property can then be simplified to this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的属性可以简化为这样：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s worth noting at this point that in .NET 4.5.3, another improvement to
    calling the most basic implementation of this method was introduced. The `nameof`
    operator also enables us to avoid using strings to pass the property name, as
    passing strings can be error prone. This operator basically converts the name
    of a property, variable, or method to a string at compile time, so the end result
    is exactly the same as passing the string, but less error prone when renaming
    definitions. Using the preceding property as an example, let''s see how this operator
    is used:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此值得指出的是，在.NET 4.5.3中，对调用此方法最基本实现的改进也被引入。`nameof`运算符还使我们能够避免使用字符串来传递属性名称，因为传递字符串可能会出错。此运算符基本上在编译时将属性、变量或方法的名称转换为字符串，因此最终结果与传递字符串完全相同，但在重命名定义时更不容易出错。以先前的属性为例，让我们看看这个运算符是如何使用的：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are also other tricks that we can employ too. For example, we often need
    to notify the Framework that more than one property value has changed at once.
    Visualize a scenario where we have two properties named `Price` and `Quantity`,
    and a third property named `Total`. As you can imagine, the value of the `Total`
    property will come from the calculation of the `Price` value multiplied by the
    `Quantity` value:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用其他技巧。例如，我们经常需要通知框架同时更改多个属性值。设想一个场景，我们有两个名为`Price`和`Quantity`的属性，以及一个名为`Total`的第三个属性。正如你可以想象的那样，`Total`属性的值将来自`Price`值乘以`Quantity`值的计算：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, this property has no setter, *so where should we call the* `NotifyPropertyChanged`
    *method from?* The answer is simple. We need to call it from *both* of the constituent
    property setters, as they can both affect the resulting value of this property.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此属性没有设置器，*那么我们应该从哪里调用* `NotifyPropertyChanged` *方法呢？* 答案很简单。我们需要从 *两个* 组成属性设置器中调用它，因为它们都可以影响此属性的结果值。
- en: 'Traditionally, we would have to call the `NotifyPropertyChanged` method once
    for each constituent property and once for the `Total` property. However, it is
    possible to rewrite our implementation of this method to enable us to pass multiple
    property names to it in a single call. For this, we can make use of the `params`
    keyword to enable any number of input parameters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们必须为每个组成部分属性调用一次`NotifyPropertyChanged`方法，以及为`Total`属性调用一次。然而，我们可以重写此方法的实现，使其能够在单个调用中传递多个属性名称。为此，我们可以使用`params`关键字来启用任意数量的输入参数：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When using the `params` keyword, we need to declare an array type input parameter.
    However, this array merely holds the input parameters and we do not need to supply
    an array when calling this method. Instead, we provide any number of input parameters
    of the same type and they will be implicitly added to the array. Going back to
    our example, this enables us to call the method like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`params`关键字时，我们需要声明一个数组类型的输入参数。然而，这个数组仅仅持有输入参数，我们调用此方法时不需要提供数组。相反，我们可以提供任意数量的相同类型的输入参数，它们将被隐式地添加到数组中。回到我们的例子，这使我们能够像这样调用方法：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We therefore have a variety of different ways to implement this method, depending
    on what suits our requirements. We can even add a number of overloads of the method
    to provide the users of our framework with more choices. We''ll see a further
    enhancement to this method later, but for now, let''s see what our `BaseViewModel`
    class might look like so far:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有多种不同的方法来实现此方法，具体取决于我们的需求。我们甚至可以添加多个方法重载，为我们的框架用户提供更多选择。我们将在稍后看到此方法的进一步增强，但现在，让我们看看我们的`BaseViewModel`类到目前为止可能的样子：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To summarize, we started with an interface that declared a single event. The
    interface itself provides no functionality and in fact, we as the implementers,
    have to provide the functionality, in the form of the `NotifyPropertyChanged`
    method and the calling of that method each time a property value changes. But
    the reward for doing this is that the UI controls are listening and responding
    to those events and so, by implementing this interface, we have gained this additional
    data binding capability.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们从一个声明单个事件的接口开始。接口本身不提供任何功能，实际上，作为实现者，我们必须提供功能，以`NotifyPropertyChanged`方法的形式，并在每次属性值更改时调用该方法。但这样做的好处是UI控件正在监听并响应这些事件，因此，通过实现此接口，我们已经获得了这种额外的数据绑定能力。
- en: However, we can provide functionality in our application framework in a number
    of different ways. The two main ways are through the use of base classes and interfaces.
    The main difference between these two approaches relate to the amount of development
    that the users of our framework will have to accomplish in order to create the
    various application components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以在我们的应用程序框架中以多种不同的方式提供功能。这两种主要方式是通过使用基类和接口。这两种方法之间的主要区别在于，我们的框架用户为了创建各种应用程序组件需要完成多少开发工作。
- en: When we use interfaces, we are basically supplying a contract that the developers
    will have to honor, by providing the implementation themselves. However, when
    we use base classes, we are able to provide that implementation for them. So generally,
    base classes provide ready-written functionality, whereas interfaces rely on the
    developers to provide some or all of that functionality for themselves.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用接口时，我们基本上是在提供一个开发者必须遵守的合同，即通过自己提供实现来遵守。然而，当我们使用基类时，我们能够为他们提供这种实现。因此，通常基类提供现成的功能，而接口则依赖于开发者自己提供部分或全部这些功能。
- en: We've just seen an example of implementing an interface in our View Model base
    class. Let's now take a look at what else we can encapsulate in our other framework
    base classes and compare the differences between providing features or functionality
    in base classes and interfaces. Let's turn our attention to our Data Model classes
    now.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了在视图模型基类中实现接口的一个例子。现在，让我们看看我们可以在其他框架基类中封装什么，并比较在基类和接口中提供功能或功能性的差异。现在，让我们将注意力转向我们的数据模型类。
- en: In base classes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在基类中
- en: We have seen that in a WPF application, it is essential for us to have an implementation
    of the `INotifyPropertyChanged` interface in our View Model base class. Likewise,
    we will also need a similar implementation in our Data Model base class. Remember
    that when Data Models are mentioned here, we are discussing the business Model
    classes that are combined with the View Model properties and functionality from
    the second application structure example in [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working with WPF*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在一个WPF应用程序中，在我们的视图模型基类中实现`INotifyPropertyChanged`接口是至关重要的。同样，我们也将需要在我们的数据模型基类中实现类似的接口。记住，当在这里提到数据模型时，我们正在讨论与视图模型属性和功能结合使用的业务模型类，这些类来自第二应用程序结构示例的[第1章](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml)，《以更智能的方式使用WPF》。
- en: 'All of these `DataModel` classes will need to extend their base class because
    they will all need to have access to its `INotifyPropertyChanged` implementation.
    As we progress through the chapters in this book, we will see more and more reasons
    why we need separate base classes for our Data Models and View Models. For example,
    let''s imagine that we want to provide these Data Models with some simple auditing
    properties and investigate what our base class might look like:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些`DataModel`类都需要扩展它们的基类，因为它们都需要访问其`INotifyPropertyChanged`实现。随着我们在这本书的章节中不断前进，我们将看到越来越多的原因说明为什么我们需要为我们的数据模型和视图模型使用单独的基类。例如，让我们想象一下，我们想要为这些数据模型提供一些简单的审计属性，并调查我们的基类可能看起来像什么：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we see our auditing properties, along with the hidden `INotifyPropertyChanged`
    implementation that we saw earlier. For now, let's keep the implementation the
    same as that of the `BaseViewModel` class. Note that using this particular base
    class would result in all derived classes getting access to these properties,
    whether they needed them or not.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们的审计属性，以及我们之前看到的隐藏的`INotifyPropertyChanged`实现。现在，让我们保持实现与`BaseViewModel`类相同。请注意，使用这个特定的基类会导致所有派生类都能访问这些属性，无论它们是否需要。
- en: 'We might then decide to declare another base class, so that we can have one
    that provides access to our implementation of the `INotifyPropertyChanged` interface
    and one that extends that base class and adds the new auditable properties shown
    earlier. In this way, all derived classes can make use of the `INotifyPropertyChanged`
    interface implementation and the classes that require the auditable properties
    as well can be derived from the second base class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能然后决定声明另一个基类，这样我们就可以有一个提供对`INotifyPropertyChanged`接口实现的访问的基类，以及一个扩展该基类并添加之前显示的新可审计属性的基类。通过这种方式，所有派生类都可以使用`INotifyPropertyChanged`接口实现，并且需要可审计属性的那些类也可以从第二个基类派生：
- en: '![](img/3683da7b-cf5e-4248-9817-6c312b354894.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3683da7b-cf5e-4248-9817-6c312b354894.png)'
- en: For this basic example, we seem to have solved our problem. If these auditable
    properties were the only properties that we wanted to provide to our derived classes,
    then this would not be such a bad situation. However, an average a framework will
    typically provide far more than this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个基本示例，我们似乎已经解决了问题。如果这些可审计属性是我们想要提供给派生类的唯一属性，那么这种情况就不会那么糟糕。然而，一个平均的框架通常会提供比这更多的功能。
- en: Let's now imagine that we wanted to provide some basic undo capability. We'll
    see an example of this later in this chapter, but for now we'll keep this simple.
    Without actually specifying the required members of this new base class, let's
    just think about this first.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在想象一下，如果我们想提供一些基本的撤销能力。我们将在本章后面看到这个例子，但现在我们保持简单。在不实际指定这个新基类所需成员的情况下，让我们先考虑这个问题。
- en: 'Now we have a situation where we already have two different base classes and
    we want to provide some further functionality. *Where should we declare our new
    properties?* We could derive from either one, or indirectly, from both of the
    existing base classes, as shown in the following diagram, in order to create this
    new *synchronizable* base class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们面临的情况是我们已经有了两个不同的基类，我们还想提供一些额外的功能。*我们应该在哪里声明我们的新属性？* 我们可以从任何一个派生，或者间接地从现有的两个基类中派生，如图所示，以创建这个新的*可同步*基类：
- en: '![](img/fb648ff4-7899-45fe-8384-951ca879067f.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb648ff4-7899-45fe-8384-951ca879067f.png)'
- en: So now, we could have four different base classes that the developers, that
    use our framework could extend. There could be some confusion as to exactly which
    base class they need to extend, but overall, this situation is still just about
    manageable. However, imagine if we want to provide some additional properties
    or functionality in one or more levels of base class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们可能有四个不同的基类，开发者可以使用我们的框架扩展。他们可能会对确切需要扩展哪个基类感到困惑，但总体来说，这种情况仍然只是勉强可控。然而，想象一下，如果我们想在基类的某个或多个级别提供一些额外的属性或功能。
- en: In order to enable every combination of functionality from these base classes,
    we could end up with as many as eight separate base classes. Each additional level
    of functionality that we provide will either double the total number of base classes
    that we have, or mean that the developers sometimes have to derive from a base
    class with functionality or properties that they do not require. Now that we have
    uncovered a potential problem of utilizing base classes, let's see if declaring
    interfaces can help with this situation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些基类中的每一个功能组合都能被启用，我们可能最终会有多达八个不同的基类。我们提供的每个额外功能级别要么会使我们拥有的基类总数翻倍，要么意味着开发者有时不得不从具有他们不需要的功能或属性的基类中派生。既然我们已经揭示了一个使用基类的潜在问题，让我们看看声明接口是否可以帮助解决这个问题。
- en: Through interfaces
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过接口
- en: 'Going back to our auditing example, we could have declared these properties
    in an interface instead. Let''s see what this might look like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的审计示例，我们可以在接口中声明这些属性。让我们看看这可能会是什么样子：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, if a developer requires these properties, they can implement this interface
    as well as extending the Data Model base class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个开发者需要这些属性，他们可以实施这个接口，同时扩展数据模型基类：
- en: '![](img/de114e5f-d44f-454d-bf16-834b289774d7.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de114e5f-d44f-454d-bf16-834b289774d7.png)'
- en: 'Let''s see an example of this in code now:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看代码中的例子：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Initially then, it seems as though this could be a better way to go, but let's
    continue to investigate the same scenario that we looked at with the base classes.
    Let's now imagine that we want to provide the same basic undo capability using
    interfaces. We didn't actually investigate which members would be required for
    this, but it will require both properties and methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，这似乎是一个更好的方法，但让我们继续调查我们之前查看的基类场景。现在让我们想象一下，我们想使用接口提供相同的基本撤销能力。我们实际上并没有调查需要哪些成员来完成这个任务，但它将需要属性和方法。
- en: This is where the interface approach starts to break down somewhat. We can ensure
    that implementers of our `ISynchronization` interface have particular properties
    and methods, but we have no control over their implementation of those methods.
    In order to provide the ability to undo changes, we need to provide the actual
    implementation of these methods, rather than just the required scaffolding.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: If this was left up to the developers to implement each time they used the interface,
    they might not implement it correctly, or perhaps they might implement it differently
    in different classes and break the consistency of the application. Therefore,
    to implement some functionality, it seems as though we really do need to use some
    kind of base class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: However, we also have a third option that involves a mix of the two approaches.
    We could implement some functionality in a base class, but instead of deriving
    our Data Model classes from it, we could add a property of that type to them,
    so that they can still access its public members.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'We could then declare an interface that simply has a single property of the
    type of this new base class. In this way, we would be free to add the different
    functionality from different base classes to just the classes that require them.
    Let''s look at an example of this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `Auditable` class would have the same properties as those in the previous
    `IAuditable` interface shown in the preceding code. The new `IAuditable` interface
    would be implemented by the Data Model classes by simply declaring a property
    of type `Auditable` :'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It could be used by the framework, for example, to output the names of each
    user and when they were created into a report. In the following example, we use
    the **Interpolated Strings** syntax that was introduced in C# 6.0 for constructing
    our string. It''s like the `string.Format` method, but with the method call replaced
    with a `$` sign and the numerical format items replaced with their related values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Most interestingly, as this interface could be implemented by many different
    types of object, the preceding code could also be used with objects of different
    types. Note this slight difference:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's worth pointing out this useful ability to work with objects of different
    types is not limited to interfaces. This can also be achieved just as easily with
    base classes. Imagine a View that enabled the end user to edit a number of different
    types of object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'If we added a property named `PropertyChanges`, that returned details of changed
    properties, into the `BaseSynchronizableDataModel` class that we will see later,
    in the *Constructing a custom application framework* section, we could use this
    very similar code to display a confirmation of the changes from each object back
    to the user:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have a number of choices when it comes to encapsulating pieces of pre-packaged
    functionality into our Data Model classes. Each of these methods that we have
    investigated so far have strengths and weaknesses. If we're sure that we want
    some pre-written functionality in every one of our Data Model classes, like that
    of the `INotifyPropertyChanged` interface, then we can simply encapsulate it in
    a base class and derive all of our Model classes from that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在将一些预包装功能封装到我们的数据模型类中时，我们有多种选择。我们迄今为止调查的每种方法都有其优点和缺点。如果我们确定我们想在每个数据模型类中都包含一些预写的功能，比如
    `INotifyPropertyChanged` 接口，那么我们只需在基类中封装它，并让所有模型类从该基类派生。
- en: If we just want our Models to have certain properties or methods that can be
    called from other parts of the framework, but are not concerned with the implementation,
    then we can use interfaces. If we want some combination of the two ideas, then
    we can implement a solution using the two methods together. It is up to us to
    choose the solution that best fits the requirements in hand.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想让我们的模型拥有某些属性或方法，这些方法可以从框架的其他部分调用，但我们不关心实现细节，那么我们可以使用接口。如果我们想结合这两种想法，那么我们可以通过结合使用这两种方法来实现解决方案。选择最适合当前需求的解决方案取决于我们。
- en: With Extension Methods
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展方法
- en: There is a further method of providing additional functionality to the developers
    of our application that was mentioned when investigating the application structures
    in the [Chapter 2](b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml), *Debugging WPF
    Applications*. It is through the use of Extension Methods. If you are not familiar
    with this amazing .NET feature, Extension Methods enable us to write methods that
    can be used on objects that we did not create.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查 [第 2 章](b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml) *调试 WPF 应用程序* 中的应用程序结构时，提到了一种向应用程序开发者提供额外功能的方法。这是通过使用扩展方法实现的。如果你不熟悉这个令人惊叹的
    .NET 功能，扩展方法使我们能够编写可以在我们未创建的对象上使用的方法。
- en: At this stage, it's worth pointing out that we don't generally write Extension
    Methods for classes that we have declared. There are two main reasons for this.
    The first is that we created these classes and so we have access to their source
    code and can therefore simply declare new methods in these classes directly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，指出一点是值得的，我们通常不会为我们声明的类编写扩展方法。这有两个主要原因。第一个原因是，我们创建了这些类，因此我们可以访问它们的源代码，因此可以直接在这些类中声明新方法。
- en: The second reason is that there will be a reference to our `Extensions` project
    added to most other projects, including our `DataModels` project, so that they
    can all take advantage of the extra capabilities. Therefore, we can't add references
    to any of our other projects into the `Extensions` project, because it would create
    circular dependencies.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是，我们的 `Extensions` 项目将被添加到大多数其他项目中，包括我们的 `DataModels` 项目，这样它们都可以利用额外的功能。因此，我们不能将任何其他项目的引用添加到
    `Extensions` 项目中，因为这会创建循环依赖。
- en: 'You are probably aware of Extension Methods already, although perhaps inadvertently,
    as most of the **LINQ** methods are Extension Methods. Once declared, they can
    be used just like the ordinary methods that were declared within the various classes
    that we are extending, although they are differentiated by having different icons
    in the Visual Studio IntelliSense display:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道扩展方法了，尽管可能是不经意间了解的，因为大多数 **LINQ** 方法都是扩展方法。一旦声明，它们就可以像在扩展的各种类中声明的普通方法一样使用，尽管在
    Visual Studio IntelliSense 显示中它们有不同的图标：
- en: '![](img/b025a8dd-5545-49ef-9722-864eaca65af2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b025a8dd-5545-49ef-9722-864eaca65af2.png)'
- en: The basic principle when declaring them is to have a static class, where each
    method has an extra input parameter prefixed with the `this` keyword, that represents
    the object being extended. Note that this extra input parameter must be declared
    first in the parameter list and that it will not be visible in IntelliSense when
    calling the method on an instance of an object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 声明它们的基本原则是有一个静态类，其中每个方法都有一个额外的输入参数，该参数以 `this` 关键字为前缀，表示被扩展的对象。请注意，这个额外的输入参数必须在参数列表中首先声明，并且在调用对象实例上的方法时在
    IntelliSense 中不可见。
- en: 'Extension Methods are declared as static methods, but are typically called
    using instance method syntax. A simple example should help to clarify this situation.
    Let''s imagine that we want to be able to call a method on each item in a collection.
    In fact, we''ll see an example of this being used in our `BaseSynchronizableCollection`
    class later in this chapter, but now, let''s see how we can do this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法被声明为静态方法，但通常使用实例方法语法来调用。一个简单的例子应该有助于澄清这种情况。让我们假设我们想要能够在集合中的每个项上调用一个方法。实际上，我们将在本章后面的`BaseSynchronizableCollection`类中看到这个例子是如何被使用的，但现在，让我们看看我们如何做到这一点：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we see the `this` input parameter that specifies the instance of the
    target type that this Extension Method is called on. Remember that this won''t
    appear in the parameter list in IntelliSense in Visual Studio, unless it is called
    through the static class itself, as shown in the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`this`输入参数指定了调用此扩展方法的目标类型的实例。记住，除非它通过静态类本身调用，否则这个参数不会出现在Visual Studio的IntelliSense参数列表中，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside this method, we simply iterate through the collection items, calling
    the `Action` specified by the `action` input parameter and passing in each item
    as its parameter. After adding a `using` directive to the `CompanyName.ApplicationName.Extensions`
    namespace, let''s see how this method is more usually called:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法内部，我们简单地遍历集合项，调用由`action`输入参数指定的`Action`，并将每个项作为其参数传入。在将`using`指令添加到`CompanyName.ApplicationName.Extensions`命名空间之后，让我们看看这个方法通常是如何被调用的：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, you can now see the power of Extension Methods and the benefits that they
    can bring us. If some functionality that we want is not already provided by a
    certain class in the .NET Framework, then we can simply add it. Take this next
    example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你现在可以看到扩展方法的力量以及它们能为我们带来的好处。如果我们想要的功能还没有由.NET Framework中的某个类提供，我们就可以简单地添加它。以下是一个例子。
- en: 'Here is an Extension Method that has been sorely missed from the existing LINQ
    Extension Methods. As with the other LINQ methods, this one also works on the
    `IEnumerable<T>` interface and, therefore, also any collection that extends it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从现有的LINQ扩展方法中非常需要的扩展方法。与其他的LINQ方法一样，这个方法也作用于`IEnumerable<T>`接口，因此也作用于任何扩展它的集合：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's first look at the declaration of this method. We can see that our source
    collection will be of type `TSource`. Note that this is exactly the same as if
    the generic type parameter were named `T`, like in our other examples, except
    that this provides a little more detail as to the use of this type parameter.
    This naming has come from the `Enumerable.OrderBy<TSource, TKey>` method, where
    type `TSource` parameter represents our source collection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看这个方法的声明。我们可以看到我们的源集合将是类型`TSource`。注意，这与我们的其他例子中泛型类型参数被命名为`T`的情况完全相同，只是这提供了一点关于这个类型参数使用的细节。这种命名来自`Enumerable.OrderBy<TSource,
    TKey>`方法，其中类型`TSource`参数代表我们的源集合。
- en: Next, we notice that the method name is suffixed by two generic type parameters;
    first, the `TSource` parameter, and then the `TKey` parameter. This is because
    we require two generic type parameters for the input parameter of type `Func<TSource,
    TKey>`. If you're not familiar with the `Func<T, TResult>` delegate, as Microsoft
    calls it, it simply encapsulates any method that has a single input parameter
    of type `T` and returns a value of type `TResult`, or, in our case, `TKey`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们注意到方法名称后面跟着两个泛型类型参数；首先，是`TSource`参数，然后是`TKey`参数。这是因为我们需要两个泛型类型参数来指定类型为`Func<TSource,
    TKey>`的输入参数。如果你不熟悉微软称之为`Func<T, TResult>`的委托，它简单地说就是封装了任何具有单个输入参数类型`T`并返回类型为`TResult`的值的任何方法，或者在我们的情况下，返回`TKey`。
- en: '"*Why are we using this* `Func<T, TResult>` *delegate*?", I hear you asking.
    Well, it''s simple really; using this class, we can provide the developers with
    an object of the same type as those in the source collection and the ability to
    select a member of that class, in particular, the property that they want to perform
    the distinct query on. Before looking at the rest of this method, let''s see it
    in use:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: “*我们为什么要使用这个* `Func<T, TResult>` *委托*？”你可能会问。其实很简单；使用这个类，我们可以为开发者提供一个与源集合中相同的类型的对象，并能够选择该类的一个成员，特别是他们想要在它上面执行唯一查询的属性。在查看这个方法的其余部分之前，让我们看看它是如何被使用的：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's envisage that we had a collection of `User` objects that had all purchased
    items. This collection could contain the same `User` object more than once, if
    they purchased more than one item. Now, let's imagine that we wanted to compile
    a collection of unique users from the original collection, so as not to send multiple
    bills to people that ordered multiple items. This method would return a single
    member for each distinct `Id` value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想一下，我们有一个`User`对象的集合，这些对象都购买了商品。这个集合可能包含同一个`User`对象多次，如果他们购买了多个商品。现在，让我们想象一下，我们想要从原始集合中编译一个唯一的用户集合，这样就不会向订购多个商品的人发送多个账单。这个方法将为每个不同的`Id`值返回单个成员。
- en: 'Referring back to the source code for this method, the `User` class represents
    the `TSource` parameter and this is shown in the Lambda expression in the example
    as the `u` input parameter. The `TKey` parameter is determined by the type of
    the class member that is selected by the developer, in this case, by the `Guid`
    `Id` value. This example could be written slightly differently to make it clearer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 回到这个方法的源代码，`User`类代表`TSource`参数，这可以在示例中的Lambda表达式中看到，即`u`输入参数。`TKey`参数由开发者选择的类成员的类型决定，在这种情况下，是通过`Guid`的`Id`值。这个例子可以稍作修改以使其更清晰：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, our `Func<TSource, TKey>` can be seen here, with a `User` input parameter
    and a `Guid` return value. Now, let's focus on the magic of our method. We see
    a `HashSet` of type `Guid` in our case being initialized. This type of collection
    is essential to this method, as it allows only unique values to be added.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`Func<TSource, TKey>`可以在这里看到，有一个`User`输入参数和一个`Guid`返回值。现在，让我们关注我们方法的魔法。我们看到一个`Guid`类型的`HashSet`在我们的例子中被初始化。这种类型的集合对这个方法至关重要，因为它允许只添加唯一值。
- en: Next, we iterate through our source collection, of type `User` in this case,
    and attempt to add the relevant property value of each item in the collection
    into the `HashSet`. In our case, we're adding the values of the identities of
    each `User` object into this `HashSet`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历我们的源集合，在这个例子中是`User`类型，并尝试将集合中每个项目的相关属性值添加到`HashSet`中。在我们的例子中，我们将每个`User`对象的身份值添加到这个`HashSet`中。
- en: If the identity value is unique and the `HashSet<T>.Add` method returns `true`,
    we yield, or return that item from our source collection. The second and each
    subsequent time that a used `Id` value is read, it is rejected. This means that
    only the first items with unique identity values are returned from this method.
    Note that in this example, we are not interested in the purchases, but in the
    unique users that made them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果身份值是唯一的，并且`HashSet<T>.Add`方法返回`true`，我们就产生，或从我们的源集合返回该物品。第二次以及每次读取已使用的`Id`值时，它将被拒绝。这意味着只有具有唯一身份值的第一个项目从这个方法返回。注意，在这个例子中，我们感兴趣的并不是购买，而是做出这些购买的唯一用户。
- en: We've now managed to create our very own LINQ-style Extension Method. However,
    not all of our Extension Methods need to be so ground breaking. Often, they can
    be used to simply encapsulate some commonly used functionality.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功创建了我们的LINQ风格的扩展方法。然而，并不是所有的扩展方法都需要如此具有突破性。通常，它们可以用来简单地封装一些常用的功能。
- en: 'In a way, we can use them as simple convenience methods. Take a look at the
    following example that is used in the *With Converters* section later in this
    chapter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，我们可以将它们用作简单的便利方法。看看以下例子，它将在本章后面的*With Converters*部分中使用：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this method, we attempt to get the `FieldInfo` object that relates to the
    instance of the relevant enumeration provided by the `value` input parameter.
    If the attempt fails, we simply return the name of the particular instance. If
    we succeed however, we then use the `GetCustomAttributes` method of that object,
    passing the type of the `DescriptionAttribute` class, to retrieve an array of
    attributes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们尝试获取与由`value`输入参数提供的特定枚举实例相关的`FieldInfo`对象。如果尝试失败，我们简单地返回特定实例的名称。如果我们成功，然后我们使用该对象的`GetCustomAttributes`方法，传递`DescriptionAttribute`类的类型，来检索一个属性数组。
- en: If we have declared a value in the `DescriptionAttribute` of this particular
    enumeration instance, then it will always be the first item in the attribute array.
    If we have not set a value, then the array will be empty and we return the name
    of the instance instead. Note that as we used the base `Enum` class in this method,
    we are able to call this method on any enumeration type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在特定枚举实例的`DescriptionAttribute`中声明了一个值，那么它将始终是属性数组中的第一个项。如果我们没有设置值，那么数组将为空，我们将返回实例的名称。注意，由于我们在该方法中使用了基`Enum`类，因此我们可以在任何枚举类型上调用此方法。
- en: When creating these methods, it should be noted that there is no requirement
    to put them into separate classes that are split by type, as we have done here.
    There are no specified naming conventions either and, in fact, it is also totally
    viable to put all of your Extension Methods into a single class. However, if we
    have a large number of Extension Methods of a particular type, then it can help
    with maintenance to have this separation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '在创建这些方法时，应该注意的是，没有要求将它们放入由类型分开的单独类中，就像我们在这里所做的那样。也没有特定的命名约定，实际上，将所有扩展方法放入一个类中也是完全可行的。然而，如果我们有大量特定类型的扩展方法，那么这种分离可以帮助维护。 '
- en: 'Before moving on, let''s take a look at one final example of these Extension
    Methods. One of the most useful traits of an Extension Method is the ability to
    add new or missing functionality to existing classes from the .NET Framework.
    For example, let''s see how we can replicate Linq and define a simple `Count`
    method for the `IEnumerable` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看看这些扩展方法的一个最终示例。扩展方法最有用的特性之一是能够向现有的.NET Framework类添加新的或缺失的功能。例如，让我们看看我们如何复制Linq并为`IEnumerable`类定义一个简单的`Count`方法：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, this method requires little explanation. It literally just counts
    the number of items in the `IEnumerable` collection and returns that value. As
    simple as it is, it proves to be useful, as we'll see in a later example. Now
    that we have investigated Extension Methods, let's turn our attention to another
    way of building further abilities into our framework, this time focusing on the
    Views component.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个方法几乎不需要解释。它实际上只是计算`IEnumerable`集合中的项目数量并返回该值。虽然它很简单，但它证明是有用的，正如我们将在后面的示例中看到的那样。现在我们已经研究了扩展方法，让我们将注意力转向另一种将更多能力构建到我们的框架中的方法，这次专注于视图组件。
- en: In UI controls
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在UI控件中
- en: 'One another common way to include functionality in an application framework
    is to encapsulate it into custom controls. In doing so, we can expose the required
    functionality using Dependency Properties, while hiding the implementation details.
    This is also another great way to promote reusability and consistency throughout
    the application. Let''s take a look at a simple example of a `UserControl` that
    wraps the functionality of the `System.Windows.Forms.FolderBrowserDialog` control:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序框架中包含功能的一种常见方式是将它封装到自定义控件中。这样做，我们可以使用依赖属性公开所需的功能，同时隐藏实现细节。这也是在应用程序中推广重用性和一致性的另一种极好方式。让我们看看一个简单的`UserControl`示例，它封装了`System.Windows.Forms.FolderBrowserDialog`控件的功能：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This simple `UserControl` just contains a textbox with its `Text` property data
    bound to the `FolderPath` Dependency Property that is declared in our control's
    code behind. Remember that it is perfectly acceptable to use the code behind of
    a `UserControl` for this purpose when using MVVM. Note that we have used a `RelativeSource`
    binding here because nothing has been set to this control's `DataContext` property.
    We'll find out much more about data binding in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*, but for now, let's continue.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的`UserControl`只包含一个文本框，其`Text`属性数据绑定到我们在控制代码背后声明的`FolderPath`依赖属性。记住，在使用MVVM时，使用`UserControl`的代码背后进行此操作是完全可接受的。注意，我们在这里使用了`RelativeSource`绑定，因为没有设置此控制器的`DataContext`属性。我们将在[第4章](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml)“精通数据绑定”中了解更多关于数据绑定的信息，但现在，让我们继续。
- en: 'You may notice that we have attached a handler for the `PreviewMouseLeftButtonUp`
    event in the code behind and as no business-related code is being used there,
    this is also perfectly acceptable when using MVVM. The only other notable code
    here is that we set the `Cursor` property to show an arrow when users mouse over
    our control. Let''s now take a look at the code behind of the  `UserControl` and
    see how the functionality is encapsulated:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们在代码后部附加了一个`PreviewMouseLeftButtonUp`事件处理器，并且由于那里没有使用业务相关的代码，所以在使用MVVM时这也是完全可以接受的。这里唯一值得注意的代码是我们将`Cursor`属性设置为当用户将鼠标悬停在我们的控件上时显示箭头。现在让我们看看`UserControl`的代码后部，看看功能是如何封装的：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We start with our `using` directives and see an example of a using alias directive.
    In this case, we don't want to add a normal `using` directive for the `System.Windows.Forms`
    assembly because it contains many UI-related classes that have names that clash
    with those in the required `System.Windows` assembly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`using`指令开始，并看到一个使用别名指令的示例。在这种情况下，我们不想为`System.Windows.Forms`程序集添加一个正常的`using`指令，因为它包含许多与UI相关的类，这些类的名称与所需的`System.Windows`程序集中的名称冲突。
- en: To avoid these conflicts, we can create an alias for the single type that we
    are interested in using from that assembly. To clarify, Microsoft decided not
    to reinvent the wheel, or, in this case, the `FolderBrowserDialog` control, in
    the `System.Windows` assembly, and so we need to add a reference to the `System.Windows.Forms`
    assembly and use the one from there.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些冲突，我们可以为我们要从该程序集中使用的单个类型创建一个别名。为了明确起见，微软决定不在`System.Windows`程序集中重新发明轮子，或者说在这个例子中，不重新发明`FolderBrowserDialog`控件，因此我们需要添加对`System.Windows.Forms`程序集的引用，并使用其中的控件。
- en: Looking at this class, we see that much of this code is taken up with the declarations
    of the Dependency Properties of the control. We have the `FolderPath` property
    that will hold the file path of the folder that is selected from the `Windows.Forms`
    control, and the `OpenFolderTitle` property that will populate the title bar of
    the `FolderBrowserDialog` window when displayed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这个类，我们看到大部分代码都是关于控件的依赖属性声明。我们有`FolderPath`属性，它将保存从`Windows.Forms`控件中选择的文件夹的文件路径，以及`OpenFolderTitle`属性，它将在显示`FolderBrowserDialog`窗口时填充标题栏。
- en: Next, we see the `TextBox_PreviewMouseLeftButtonUp` event handler that handles
    the `PreviewMouseLeftButtonUp` event of the single `TextBox` element in our control.
    In this method, we first verify that the user is not selecting text from, or scrolling,
    the `TextBox` control and then, if `true`, we call the `ShowFolderPathEditWindow`
    method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到处理我们控件中单个`TextBox`元素的`PreviewMouseLeftButtonUp`事件的`TextBox_PreviewMouseLeftButtonUp`事件处理器。在这个方法中，我们首先验证用户没有从`TextBox`控件中选择文本或滚动，然后，如果条件为`true`，我们调用`ShowFolderPathEditWindow`方法。
- en: In order to verify that the user is not selecting text, we simply check the
    length of the `SelectedText` property of the `TextBox` control. In order to confirm
    that the user is not scrolling the `TextBox` control, we compare the relative
    horizontal position of the user's click with the length of the `TextBox` element
    minus the width of its vertical scroll bar to ensure that their mouse is not over
    the scroll bar, if present.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证用户没有选择文本，我们只需检查`TextBox`控件`SelectedText`属性的长度。为了确认用户没有滚动`TextBox`控件，我们比较用户点击的相对水平位置与`TextBox`元素的长度减去其垂直滚动条的宽度，以确保鼠标没有位于（如果存在的话）滚动条上。
- en: The `ShowFolderPathEditWindow` method first prepares to display the `Windows.Forms`
    control. It sets the `defaultFolderPath` variable to either the current value
    of the `FolderPath` property, if one is set, or the current user's `Documents`
    folder, using the `Environment.GetFolderPath` method and the `Environment.SpecialFolder.MyDocuments`
    enumeration.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowFolderPathEditWindow`方法首先准备显示`Windows.Forms`控件。它将`defaultFolderPath`变量设置为`FolderPath`属性的当前值，如果已设置，或者使用`Environment.GetFolderPath`方法和`Environment.SpecialFolder.MyDocuments`枚举设置当前用户的`Documents`文件夹。'
- en: It then calls the `ShowFolderBrowserDialog` method to launch the actual `FolderBrowserDialog`
    control and retrieve the selected folder path. If a valid folder path is selected,
    we set its value to the data bound `FolderPath` property directly, but note that
    we could have set it in other ways.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它调用`ShowFolderBrowserDialog`方法来启动实际的`FolderBrowserDialog`控件并检索选定的文件夹路径。如果选定了有效的文件夹路径，我们直接将其值设置为数据绑定的`FolderPath`属性，但请注意，我们也可以以其他方式设置它。
- en: It would be very easy to add an `ICommand` property to our control in order
    to return the selected folder path instead of using this direct assignment. This
    could be useful in cases where we don't want the data bound value to be set instantly;
    for example, if the control was used in a child window that needed a confirmation
    button to be clicked before the data bound value could be updated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的控件中添加一个 `ICommand` 属性以返回选定的文件夹路径，而不是使用这种直接赋值，将非常容易。在不需要立即设置数据绑定值的情况下，这可能很有用；例如，如果控件被用于需要点击确认按钮后才能更新数据绑定值的子窗口中。
- en: The `ShowFolderBrowserDialog` method wraps the use of the `FolderBrowserDialog`
    class in a `using` statement, to ensure that it is disposed of, once it has been
    used. It utilizes the `defaultFolderPath` variable and the `OpenFolderTitle` property
    when setting up the actual `FolderBrowserDialog` control. Note that this `OpenFolderTitle`
    property is simply here to demonstrate how we can expose the required properties
    from the `FolderBrowserDialog` element in our control. In this way, we can encapsulate
    the use of the `Windows.Forms` control and assembly within our control.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowFolderBrowserDialog` 方法将 `FolderBrowserDialog` 类的使用封装在 `using` 语句中，以确保一旦使用后就被释放。它使用
    `defaultFolderPath` 变量和 `OpenFolderTitle` 属性来设置实际的 `FolderBrowserDialog` 控件。请注意，这个
    `OpenFolderTitle` 属性只是用来展示我们如何从 `FolderBrowserDialog` 元素中公开所需的属性到我们的控件中。这样，我们就可以封装
    `Windows.Forms` 控件和程序集的使用。'
- en: Note that we could have added extra Dependency Properties to enable the users
    of our framework to have further control over the settings in the `FolderBrowserDialog`
    control. In this basic example, we simply hardcoded a positive value for the `FolderBrowserDialog.ShowNewFolderButton`
    property, but we could have exposed that as another property.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以添加额外的依赖属性，使用户能够进一步控制 `FolderBrowserDialog` 控件中的设置。在这个基本示例中，我们只是硬编码了 `FolderBrowserDialog.ShowNewFolderButton`
    属性的正值，但我们可以将其公开为另一个属性。
- en: We could have also added a browse button and maybe even a clear button to clear
    the selected folder value. We could have then added additional `bool` Dependency
    Properties to control whether those buttons should be displayed or not. There
    are many other ways that we could improve this control, but it still demonstrates
    how we can encapsulate functionality into our Views components. We'll see another
    View-related way to capture little snippets of functionality in the following
    section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个浏览按钮，甚至可能添加一个清除按钮来清除选定的文件夹值。然后我们可以添加额外的 `bool` 依赖属性来控制这些按钮是否显示。我们可以以许多其他方式改进这个控件，但它仍然展示了我们如何将功能封装到我们的视图组件中。我们将在下一节中看到另一种与视图相关的方法来捕获功能的小片段。
- en: With converters
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用转换器
- en: Converters are yet another way that we can package up useful functionality in
    our framework. We've already seen a useful example of the `IValueConverter` interface
    in [Chapter 2](b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml), *Debugging WPF Applications*,
    but while that was a very simple example, converters can actually be very versatile.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器是我们可以在框架中打包有用功能的另一种方式。我们已经在 [第2章](b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml)
    中看到了 `IValueConverter` 接口的一个有用示例，*调试WPF应用程序*，但尽管这是一个非常简单的示例，转换器实际上可以非常灵活。
- en: 'Long before Microsoft introduced their `BooleanToVisibilityConverter` class,
    developers had to create their own versions. We often need to convert the `UIElement.Visibility`
    enumeration to or from a variety of different types, and so it is a good idea
    to start with a `BaseVisibilityConverter` class that can serve multiple converter
    classes. Let''s see what that entails:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在微软推出他们的 `BooleanToVisibilityConverter` 类之前，开发者不得不自己创建版本。我们经常需要将 `UIElement.Visibility`
    枚举转换为或从各种不同类型转换，因此从 `BaseVisibilityConverter` 类开始是一个好主意，它可以服务于多个转换器类。让我们看看这包括什么：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This converter requires one value to represent the visible value and as there
    is only one corresponding value in the `UIElement.Visibility` enumeration, that
    will clearly be the `Visibility.Visible` instance. It also requires a single value
    to represent the invisible value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此转换器需要一个值来表示可见值，由于在 `UIElement.Visibility` 枚举中只有一个相应的值，因此这显然将是 `Visibility.Visible`
    实例。它还需要一个值来表示不可见值。
- en: As such, we declare the `FalseVisibility` enumeration with the two corresponding
    values from the `UIElement.Visibility` enumeration and the `FalseVisibilityValue`
    property to enable users to specify which value should represent the false state.
    Note that the most commonly used `Visibility.Collapsed` value is set as the default
    value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们声明了`FalseVisibility`枚举，包含来自`UIElement.Visibility`枚举的两个对应值和`FalseVisibilityValue`属性，以使用户能够指定哪个值应表示假状态。请注意，最常用的`Visibility.Collapsed`值被设置为默认值。
- en: 'Users can set the `FalseVisibilityState` property when using the control and
    this sets the protected `FalseVisibilityValue` property internally. Finally, we
    see the indispensable `IsInverted` property that is optionally used to invert
    the result. Let''s see what our `BoolToVisibilityConverter` class looks like now:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在使用控件时设置`FalseVisibilityState`属性，这将在内部设置受保护的`FalseVisibilityValue`属性。最后，我们看到不可或缺的`IsInverted`属性，它可选地用于反转结果。现在让我们看看我们的`BoolToVisibilityConverter`类看起来像什么：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We start by specifying the data types involved in the implementation of the
    converter in the `ValueConversion` attribute. This helps tools to know what types
    are being used in the converter, but also makes it clear to the users of our framework.
    Next, we extend our `BaseVisibilityConverter` base class and extend the required
    `IValueConverter` interface.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`ValueConversion`属性中指定转换器实现中涉及的数据类型。这有助于工具了解转换器中使用了哪些类型，同时也使我们的框架的用户清楚。接下来，我们扩展我们的`BaseVisibilityConverter`基类，并扩展所需的`IValueConverter`接口。
- en: In the `Convert` method, we first check the validity of our `value` input parameter,
    if valid, we convert it to a `bool` variable, taking the `IsInverted` property
    setting into consideration. We return the `DependencyProperty.UnsetValue` value
    for invalid input values. Finally, we resolve the output value from this `bool`
    variable to either the `Visibility.Visible` instance, or the value of the `FalseVisibilityValue`
    property.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Convert`方法中，我们首先检查我们的`value`输入参数的有效性，如果有效，我们将其转换为`bool`变量，同时考虑`IsInverted`属性的设置。对于无效的输入值，我们返回`DependencyProperty.UnsetValue`值。最后，我们从这个`bool`变量解析输出值，要么是`Visibility.Visible`实例，要么是`FalseVisibilityValue`属性的值。
- en: In the `ConvertBack` method, we also check the validity of our `value` input
    parameter first. We return the `DependencyProperty.UnsetValue` value for invalid
    input values again, otherwise we output a `bool` value that specifies whether
    the input parameter of type `Visibility` is equal to the `Visibility.Visible`
    instance, while again taking the value of the `IsInverted` property into consideration.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ConvertBack`方法中，我们首先检查我们的`value`输入参数的有效性。对于无效的输入值，我们再次返回`DependencyProperty.UnsetValue`值，否则我们输出一个`bool`值，该值指定输入参数的类型`Visibility`是否等于`Visibility.Visible`实例，同时再次考虑`IsInverted`属性的值。
- en: 'Note that use of the `IsInverted` property enables users to specify that elements
    should become visible when the data bound `bool` value is `false`. This can be
    incredibly useful when we want to have one object visible upon a certain condition
    and another object hidden dependent upon the same condition. We can declare two
    converters from this class like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用`IsInverted`属性允许用户指定当数据绑定的`bool`值为`false`时，元素应该变为可见。这在我们需要根据同一条件使一个对象可见而另一个对象隐藏时非常有用。我们可以像这样声明从这个类中派生的两个转换器：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As stated, we often need to convert to and from the `UIElement.Visibility`
    enumeration from a variety of different types. Let''s now look at an example of
    a conversion to and from the `Enum` type. The principle is the same as the last
    example, where a single data bound value represents the `Visibility.Visible` instance
    and all other values represent the hidden or collapsed state:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如所述，我们经常需要从各种不同类型转换为`UIElement.Visibility`枚举，或者从`UIElement.Visibility`枚举转换为其他类型。现在让我们看看一个从`Enum`类型转换到和从`Enum`类型转换的例子。原理与上一个例子相同，其中单个数据绑定值表示`Visibility.Visible`实例，而所有其他值表示隐藏或折叠状态：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, we start by specifying the data types involved in the implementation
    of the converter in the `ValueConversion` attribute. In the `Convert` method,
    we first check the validity of our `value` input parameter, if valid, we convert
    it to the `string` representation of the value. This particular class uses the
    `parameter` input parameter to pass the specified enumeration instance that will
    represent the visible value, and so it is set to the `targetValue` variable as
    a `string`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在`ValueConversion`属性中指定了转换器实现中涉及的数据类型。在`Convert`方法中，我们首先检查`value`输入参数的有效性，如果有效，我们将它转换为值的`string`表示形式。这个特定的类使用`parameter`输入参数来传递将表示可见值的指定枚举实例，因此它被设置为`targetValue`变量作为一个`string`。
- en: We then create a `bool` value by comparing the current enumeration instance
    with the target instance. Once we have our `bool` value, the last two lines replicate
    those in the `BoolToVisibilityConverter` class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过比较当前枚举实例与目标实例来创建一个`bool`值。一旦我们有了我们的`bool`值，最后两行代码与`BoolToVisibilityConverter`类中的代码相同。
- en: The `ConvertBack` method implementation is somewhat different. Logically speaking,
    we are unable to return the correct enumeration instance for a hidden visibility,
    as it could be any value except the visible value passed through the `parameter`
    input parameter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertBack`方法的实现略有不同。从逻辑上讲，我们无法为隐藏的可见性返回正确的枚举实例，因为它可以是除了通过`parameter`输入参数传递的可见值之外的任何值。'
- en: As such, we are only able to return that specified value if the element is visible
    and the `IsInverted` property is `false`, or if it is not visible and the `IsInverted`
    property is `true`. For all other input values, we simply return the `DependencyProperty.UnsetValue`
    property to state that there is no value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只能返回指定的值，如果元素是可见的并且`IsInverted`属性为`false`，或者如果元素不可见并且`IsInverted`属性为`true`。对于所有其他输入值，我们简单地返回`DependencyProperty.UnsetValue`属性，以表示没有值。
- en: 'Another incredibly useful thing that converters can do is to convert individual
    enumeration instances to particular images. Let''s look at an example that relates
    to our `FeedbackManager`, or, more accurately, the `Feedback` objects that get
    displayed. Each `Feedback` object can have a particular type that is specified
    by the `FeedbackType` enumeration, so let''s look at that first:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器可以做的另一件非常有用的事情是将单个枚举实例转换为特定的图像。让我们看看一个与我们的`FeedbackManager`相关的例子，或者更准确地说，是显示的`Feedback`对象。每个`Feedback`对象可以有一个特定的类型，该类型由`FeedbackType`枚举指定，所以让我们先看看这个：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make this work, we obviously need a suitable image for each enumeration
    instance, except for the `None` instance. Our images will reside in a folder named
    Images in the root folder of the startup project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这起作用，显然我们需要为每个枚举实例提供一个合适的图像，除了`None`实例。我们的图像将位于启动项目根目录下的名为Images的文件夹中：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once again, we start by specifying the data types involved in the converter
    in the `ValueConversion` attribute. In the `Convert` method, we use C# 6.0 Pattern
    Matching to check the validity of our `value` input parameter and to cast it to
    a `FeedbackType` instance, if valid. We then use that in a `switch` statement,
    to generate the relevant image name for each enumeration instance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在`ValueConversion`属性中指定了转换器中涉及的数据类型。在`Convert`方法中，我们使用C# 6.0模式匹配来检查`value`输入参数的有效性，并将其转换为`FeedbackType`实例，如果有效。然后我们使用它在`switch`语句中，为每个枚举实例生成相关的图像名称。
- en: If an unknown instance is used, we return the `DependencyProperty.UnsetValue`
    value. In all other cases, we use String Interpolation to build up the full file
    path of the relevant image and then return it from the converter as the converted
    value. As the `ConvertBack` method in this converter has no valid use, it is not
    implemented and simply returns the `DependencyProperty.UnsetValue` value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了未知实例，我们返回`DependencyProperty.UnsetValue`值。在所有其他情况下，我们使用字符串插值来构建相关图像的完整文件路径，然后从转换器返回它作为转换值。由于这个转换器的`ConvertBack`方法没有有效用途，它没有实现，并简单地返回`DependencyProperty.UnsetValue`值。
- en: You may have noticed that we specified type `ImageSource` in the `ValueConversion`
    attribute, but we returned a `string`. This is possible because XAML uses the
    relevant type converter to convert the `string` into an `ImageSource` object automatically
    for us. Exactly the same thing occurs when we set an `Image.Source` property with
    a `string` in XAML.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在`ValueConversion`属性中指定了类型`ImageSource`，但我们返回了一个`string`。这是可能的，因为XAML使用相关的类型转换器自动将`string`转换为`ImageSource`对象。当我们用XAML中的`string`设置`Image.Source`属性时，发生的情况完全相同。
- en: As with other parts of our framework, we can make our converters even more useful,
    when we combine functionality from other areas. In this particular example, we
    utilize one of the Extension Methods that was shown earlier in this chapter. To
    remind you, the `GetDescription` method will return the value of the `DescriptionAttribute`
    that is set on each enumeration instance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们框架的其他部分一样，当我们结合其他领域的功能时，我们可以使我们的转换器更加有用。在这个特定的例子中，我们利用了本章前面展示的扩展方法之一。为了提醒您，`GetDescription`
    方法将返回设置在每个枚举实例上的 `DescriptionAttribute` 的值。
- en: 'The `DescriptionAttribute` enables us to associate any `string` value with
    each of our enumeration instances, so this is a great way to output a user-friendly
    description for each instance. An example of this would be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`DescriptionAttribute` 允许我们将任何 `string` 值与我们的每个枚举实例关联起来，因此这是为每个实例输出用户友好描述的绝佳方式。以下是一个例子：'
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this way, instead of displaying the names of the instances in a `RadioButton`
    control, for example, we could display the more humanized descriptions from these
    attributes. Let''s have a look at this converter class now:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，例如，我们可以在 `RadioButton` 控件中显示实例的名称，而不是显示这些属性中更人性化的描述。现在让我们看看这个转换器类：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we're now accustomed to doing, we start by specifying the data types used
    in the converter in the `ValueConversion` attribute. In the `Convert` method,
    we again check the validity of our `value` input parameter and return the `DependencyProperty.UnsetValue`
    value if it is invalid.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在习惯做的那样，我们首先在 `ValueConversion` 属性中指定转换器中使用的数据类型。在 `Convert` 方法中，我们再次检查我们的
    `value` 输入参数的有效性，如果它无效，则返回 `DependencyProperty.UnsetValue` 值。
- en: If it is valid, we cast it to a `Enum` instance and then use the power of our
    Extension Method to return the value from each instance's `DescriptionAttribute`.
    In doing so, we are able to expose this functionality to our Views and to enable
    the users of our framework to utilize it directly from the XAML. Now that we have
    a general understanding of the various ways that we can encapsulate functionality
    into our framework, let's focus on starting construction of our base classes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是有效的，我们将它转换为 `Enum` 实例，然后使用我们扩展方法的力量从每个实例的 `DescriptionAttribute` 返回值。通过这样做，我们能够将此功能暴露给我们的视图，并使用户能够直接从
    XAML 中利用它。现在，我们已经对如何将功能封装到我们的框架中的各种方式有了基本的了解，让我们专注于开始构建我们的基类。
- en: Constructing a custom application framework
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义应用程序框架
- en: There will be different requirements for different components, but typically,
    the properties and functionality that we build into our Data Model base classes
    will be utilized and made more useful by our other base classes, so let's start
    by looking at the various Data Model base classes first.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的组件，可能会有不同的要求，但通常，我们将构建到我们的数据模型基类中的属性和功能将被我们的其他基类利用并变得更有用，所以让我们首先看看各种数据模型基类。
- en: 'One thing that we need to decide is whether we want any of our Data Model base
    classes to be generic or not. The difference can be subtle, but important. Imagine
    that we want to add some basic undo functionality into a base class. One way that
    we can achieve this would be to add an object into the base class that represents
    the unedited version of the Data Model. In an ordinary base class, it would look
    like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要决定的是，我们是否希望我们的数据模型基类中的任何一个都是泛型的。这种差异可能很微妙，但很重要。想象一下，我们想在基类中添加一些基本的撤销功能。我们可以实现这一目标的一种方法是在基类中添加一个表示数据模型未编辑版本的对象。在一个普通基类中，它看起来是这样的：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In a generic base class, it would look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个通用基类中，它看起来是这样的：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To make this property more useful, we''ll need to add some further methods.
    First, we''ll see the non-generic versions:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个属性更有用，我们需要添加一些额外的功能。首先，我们将看到非通用版本：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s look at the generic versions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看通用版本：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last few members of this base class would be the same for both versions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类的最后几个成员在这两个版本中都是相同的：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We started with the `OriginalState` property which holds the unedited version
    of the Data Model. After that, we see the abstract `CopyValuesFrom` method that
    the developers will need to implement and we'll see an example of that implementation
    shortly. The `Clone` method simply calls the `CopyValuesFrom` method in order
    to perform a deep clone of the Data Model.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `OriginalState` 属性开始，它持有数据模型的未编辑版本。之后，我们看到开发人员需要实现的抽象 `CopyValuesFrom` 方法，我们很快就会看到一个实现示例。`Clone`
    方法简单地调用 `CopyValuesFrom` 方法以执行数据模型的深度克隆。
- en: Next, we have the abstract `PropertiesEqual` method that the developers will
    need to implement in order to compare each property in their classes with those
    from the `dataModel` input parameter. Again, we'll see this implementation shortly,
    but you may be wondering why we don't just override the `Equals` method, or implement
    the `IEquatable.Equals` method for this purpose.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个名为 `PropertiesEqual` 的抽象方法，开发人员需要实现这个方法以便将他们类中的每个属性与 `dataModel` 输入参数中的属性进行比较。同样，我们很快就会看到这个实现，但你可能想知道为什么我们不直接重写
    `Equals` 方法，或者实现 `IEquatable.Equals` 方法来达到这个目的。
- en: The reason why we don't want to use either of those methods is because they,
    along with the `GetHashCode` method, are used by the WPF Framework in various
    places and they expect the returned values to be immutable. As our object's properties
    are very much mutable, they cannot be used to return the values for those methods.
    Therefore, we have implemented our own version. Now, let's return to the description
    of the remainder of this code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想使用这些方法的原因是，它们以及 `GetHashCode` 方法在 WPF 框架的多个地方被使用，并且它们期望返回的值是不可变的。由于我们的对象的属性非常可变，它们不能用于返回这些方法的值。因此，我们实现了自己的版本。现在，让我们回到这段代码剩余部分的描述。
- en: The `HasChanges` property is the property that we would want to data bind to
    a UI control to indicate whether a particular object had been edited. The `Synchronize`
    method sets a deep clone of the current Data Model to the `originalState` field
    and, importantly, notifies the WPF Framework of a change to the `HasChanges` property.
    This is done because the `HasChanges` property has no setter of its own and this
    operation will affect its value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasChanges` 属性是我们希望将其数据绑定到 UI 控件以指示特定对象是否已被编辑的属性。`Synchronize` 方法将当前数据模型的深度克隆设置到
    `originalState` 字段中，并且重要的是，它通知 WPF 框架 `HasChanges` 属性发生了变化。这样做是因为 `HasChanges`
    属性没有自己的设置器，这个操作将影响其值。'
- en: It is very important that we set a cloned version to the `originalState` field,
    rather than simply assigning the actual object reference to it. This is because
    we need to have a completely separate version of this object to represent the
    unedited version of the Data Model. If we simply assigned the actual object reference
    to the `originalState` field, then its property values would change along with
    the Data Model object and render it useless for this feature.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将克隆版本设置到 `originalState` 字段中非常重要，而不是简单地将其实际对象引用赋值给它。这是因为我们需要一个完全独立的对象版本来表示数据模型的未编辑版本。如果我们只是将实际对象引用赋值给
    `originalState` 字段，那么它的属性值会随着数据模型对象的变化而变化，使其对于这个功能变得无用。
- en: The `RevertState` method first checks that the Data Model has been synchronized
    and then copies the values back from the `originalState` field to the Model. Finally,
    it calls the `Synchronize` method to specify that this is the new, unedited version
    of the object and notifies the WPF Framework of a change to the `HasChanges` property.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`RevertState` 方法首先检查数据模型是否已同步，然后将 `originalState` 字段中的值复制回模型。最后，它调用 `Synchronize`
    方法来指定这是新版本的对象，并且通知 WPF 框架 `HasChanges` 属性发生了变化。'
- en: 'So, as you can see, there are not many differences between these two versions
    of the base class. In fact, the differences can be seen more clearly in the implementation
    of the derived classes. Let''s now focus on their implementations of the example
    abstract methods, starting with the non-generic versions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你所看到的，这两个版本的基类之间没有太多差异。实际上，差异在派生类的实现中可以更清楚地看到。现在，让我们专注于它们对示例抽象方法的实现，从非泛型版本开始：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Before discussing this code, let''s first see the generic implementations:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这段代码之前，让我们先看看泛型实现：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At last, we can see the difference between using generic and non-generic base
    classes. Without using generics, we have to use base class input parameters, which
    will need to be cast to the appropriate type in each of the derived classes before
    we can access their properties. Attempting to cast inappropriate types causes
    Exceptions, so we generally try to avoid these situations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到使用泛型和非泛型基类的区别。不使用泛型时，我们必须使用基类输入参数，在访问它们的属性之前，需要在每个派生类中将这些参数转换为适当类型。尝试转换不适当的类型会导致异常，所以我们通常尽量避免这些情况。
- en: On the other hand, when using a generic base class, there is no need to cast,
    as the input parameters are already of the correct type. In short, generics enable
    us to create type-safe Data Models and avoid duplicating type specific code. Now
    that we have seen the benefit of using generic classes, let's take a pause from
    generics for a moment and look at this base class a bit closer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用泛型基类时，不需要进行转换，因为输入参数已经是正确的类型。简而言之，泛型使我们能够创建类型安全的Data模型并避免重复特定类型的代码。既然我们已经看到了使用泛型类的益处，让我们暂时放下泛型，更仔细地看看这个基类。
- en: Some of you may have noticed that the only places where the WPF Framework is
    notified of changes to our `HasChanges` property is in the `Synchronize` and `RevertState`
    methods. However, in order for this functionality to work properly, we need to
    notify the framework every time the values of any properties are changed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些同学可能已经注意到，WPF框架通知我们`HasChanges`属性变化的地方只有`Synchronize`和`RevertState`方法。然而，为了使这个功能正常工作，我们需要在每次任何属性的值发生变化时通知框架。
- en: 'We could rely on the developers to call the `NotifyPropertyChanged` method,
    passing the `HasChanges` property name each time they call it for each property
    that changes, but if they forgot to do this, it could lead to errors that could
    be difficult for them to track down. Instead, a better solution would be for us
    to override the default implementation of the `INotifyPropertyChanged` interface
    from the base class and notify changes to the `HasChanges` property for them each
    time it is called:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以依赖开发者每次调用`NotifyPropertyChanged`方法时传递`HasChanges`属性名，针对每个发生变化的属性进行调用，但如果他们忘记这样做，可能会导致难以追踪的错误。相反，一个更好的解决方案是我们覆盖基类中`INotifyPropertyChanged`接口的默认实现，并在每次调用时为他们通知`HasChanges`属性的变化：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first method will raise the `PropertyChanged` event, passing the name of
    the `HasChanges` property just once, regardless of how many property names were
    passed to the method. The second method also performs a check to ensure that it
    will refrain from raising the event with the `HasChanges` property name more than
    once, so these implementations remain efficient.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法将引发`PropertyChanged`事件，只传递一次`HasChanges`属性的名称，无论传递给方法多少个属性名。第二种方法也执行检查以确保它不会多次引发带有`HasChanges`属性名称的事件，因此这些实现保持高效。
- en: Now, our base class will work as expected and the `HasChanges` property will
    correctly update when other properties in the Data Model classes are changed.
    This technique can also be utilized in other scenarios; for example, when validating
    our property values, as we'll see later in [Chapter 9](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml),
    *Implementing Responsive Data Validation*. For now though, let's return to see
    what else we can achieve with generics.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的基类将按预期工作，并且当数据模型类中的其他属性发生变化时，`HasChanges`属性将正确更新。这种技术也可以在其他场景中使用；例如，在我们稍后将在[第9章](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml)中看到的实现响应式数据验证时。不过，现在让我们暂停一下泛型的使用，更仔细地看看这个基类。
- en: 'Another area where generics are often used relates to collections. I''m sure
    that you''re all aware that we tend to use the `ObservableCollection<T>` class
    in WPF applications because of its `INotifyCollectionChanged` and `INotifyPropertyChanged`
    implementations. It is customary, but not essential, to extend this class for
    each type of Data Model class that we have:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经常使用泛型的地方与集合相关。我相信你们都知道，我们倾向于在WPF应用程序中使用`ObservableCollection<T>`类，因为它实现了`INotifyCollectionChanged`和`INotifyPropertyChanged`。对于每种数据模型类，扩展这个类是惯例，但不是必需的：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, instead of doing this, we can declare a `BaseCollection<T>` class
    that extends the `ObservableCollection<T>` class and adds further functionality
    into our framework for us. The users of our framework can then extend this class
    instead:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，而不是这样做，我们可以声明一个 `BaseCollection<T>` 类，它扩展了 `ObservableCollection<T>` 类，并为我们添加了更多的功能到我们的框架中。我们的框架用户可以扩展这个类：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'One really useful thing that we can do is to add a generic property of type
    `T` into our base class, that which will represent the currently selected item
    in a data bound collection control in the UI. We could also declare some delegates
    to notify developers of changes to either selection or property values. There
    are so many shortcuts and helper methods that we can provide here, dependent on
    requirements, so it''s worth spending some time investigating this. Let''s take
    a look at a few possibilities:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的真正有用的一件事是将一个泛型属性 `T` 添加到我们的基类中，它将代表 UI 中数据绑定集合控件中当前选中的项。我们还可以声明一些委托来通知开发人员关于选择或属性值的变化。这里有很多快捷方式和辅助方法，我们可以根据需求提供，所以花些时间调查这一点是值得的。让我们看看一些可能性：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There's quite a lot to digest here, so let's go over each part carefully. We
    start with our private member of type `T` that will back our `CurrentItem` property.
    We then find a few overloads of the constructor that enable us to initialize our
    collection from either a collection, or any number of input parameters of the
    relevant type.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有很多内容需要消化，所以让我们仔细地过一遍每一部分。我们首先从我们的私有成员 `T` 类型开始，它将支持我们的 `CurrentItem` 属性。然后我们发现了一些构造函数的重载，使我们能够从集合或相关类型的任意数量的输入参数中初始化我们的集合。
- en: Next, we see the `CurrentItem` property from [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working with WPF*, again, but now with some further context.
    If a class has subscribed to the `CurrentItemChanged` property, we will call the
    delegate from here, passing both the new and old values of the current item. The
    `IsEmpty` property is just an efficient convenience property for our developers
    to call when they need to know whether the collection has any content or not.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到来自 [第 1 章](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml)，《使用 WPF 的更智能的方法》，的
    `CurrentItem` 属性，再次，但现在有一些进一步的上下文。如果一个类已订阅了 `CurrentItemChanged` 属性，我们将从这里调用委托，传递当前项的新旧值。`IsEmpty`
    属性只是一个高效的便利属性，供开发人员在需要知道集合是否有内容时调用。
- en: After this, we see the collection delegates and the relevant property wrappers
    that enable the developers that will use our framework to make use of them. Next,
    we see the convenient `GetNewItem` and `AddEmptyItem` methods, which both generate
    a new item of the `T` generic type parameter, before returning or adding them
    to the collection, respectively. This is the reason that we needed to add the
    `new()` generic type constraint to the class definition; this type constraint
    specifies that the generic type used must have a parameterless constructor.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们看到集合委托和相关的属性包装器，使将使用我们的框架的开发人员能够利用它们。接下来，我们看到方便的 `GetNewItem` 和 `AddEmptyItem`
    方法，这两个方法都生成一个 `T` 泛型类型参数的新项，在分别返回或添加到集合之前。这就是为什么我们需要在类定义中添加 `new()` 泛型类型约束的原因；这个类型约束指定使用的泛型类型必须有一个无参数的构造函数。
- en: And now we reach the various `Add` methods of the collection; note that every
    way to add an item to the collection must be handled, so that we can attach our
    `Item_PropertyChanged` handler to the `PropertyChanged` event of each added item
    to ensure consistent behavior.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了集合的各种 `Add` 方法；请注意，必须处理向集合添加项的每一种方式，这样我们就可以将我们的 `Item_PropertyChanged`
    处理程序附加到每个添加项的 `PropertyChanged` 事件上，以确保一致的行为。
- en: We therefore call our `Add` methods from all other overloads and helper methods
    and call the base `Collection.Add` method from there. Note that we actually attach
    our handler inside the protected `InsertItem` method, as this overridden method
    is called from the `Add` methods in the `Collection` class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从所有其他重载和辅助方法中调用我们的 `Add` 方法，并从那里调用基类的 `Collection.Add` 方法。请注意，我们实际上是在受保护的
    `InsertItem` 方法中附加我们的处理程序，因为这个重写的方法是从 `Collection` 类中的 `Add` 方法调用的。
- en: Likewise, the protected `SetItem` method will be called by the `Collection`
    class when items are set using the index notation, so we must handle that too.
    Similarly, when items are removed from the collection, it is equally, if not more,
    important to remove the reference to our event handler from each object. Failing
    to do so can result in memory leaks, as the reference to the event handler can
    keep the Data Model objects from being disposed by the garbage collector.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当使用索引表示法设置项目时，受保护的`SetItem`方法将由`Collection`类调用，因此我们也必须处理这一点。同样，当从集合中移除项目时，移除对每个对象的事件处理程序的引用同样重要，如果不是更重要的话。未能这样做可能会导致内存泄漏，因为对事件处理程序的引用可能会阻止垃圾回收器销毁数据模型对象。
- en: As such, we also need to handle every method of removing objects from our collection.
    To do this, we override a few more protected methods from the `Collection` base
    class. The `ClearItems` method will be called internally when users call the `Clear`
    method on our collection. Equally, the `RemoveItem` method will be called when
    users call any of the public removal methods, so it is the optimal place to remove
    our handler.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还需要处理从我们的集合中移除对象的每个方法。为此，我们覆盖了`Collection`基类的一些更多受保护的方 法。当用户在我们的集合上调用`Clear`方法时，`ClearItems`方法将在内部被调用。同样，当用户调用任何公共移除方法时，将调用`RemoveItem`方法，因此这是移除我们的处理程序的理想位置。
- en: Skipping the `ResetCurrentItemPosition` method for now, at the bottom of the
    class, we reach the `Item_PropertyChanged` event handling method. If the item
    that has had the property changed is the current item in the collection, then
    we raise the `ItemPropertyChanged` delegate that is connected with the `CurrentItemPropertyChanged`
    property.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在暂时跳过`ResetCurrentItemPosition`方法，在类的底部，我们到达了`Item_PropertyChanged`事件处理方法。如果属性已更改的项目是集合中的当前项目，那么我们将引发与`CurrentItemPropertyChanged`属性连接的`ItemPropertyChanged`委托。
- en: For every property change notification, regardless of whether the item is the
    current item or not, we then raise the `INotifyPropertyChanged.PropertyChanged`
    event. This enables developers that use our framework to be able to attach a handler
    to the `PropertyChanged` event directly on our collections and to be able to discover
    when any property has been changed on any of the items in the collection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个属性更改通知，无论项目是否是当前项目，我们随后都会引发`INotifyPropertyChanged.PropertyChanged`事件。这使得使用我们框架的开发者能够直接在我们的集合上附加处理程序到`PropertyChanged`事件，并能够发现集合中任何项目的任何属性是否已更改。
- en: You may also have noticed a few places in the collection class code where we
    set the value of the `CurrentItem` property. The option chosen here is to always
    select the first item in the collection automatically, but it would be a simple
    change to have the last item selected instead, for example. As always, these kinds
    of details will depend on your specific requirements.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了在集合类代码中的一些地方，我们设置了`CurrentItem`属性的值。这里选择的选项是自动选择集合中的第一个项目，但也可以简单地改为选择最后一个项目，例如。像往常一样，这些细节将取决于你的具体需求。
- en: Another benefit of declaring these base collection classes is that we can utilize
    the properties and extend the functionality that is built into our base Data Model
    classes. Thinking back to the simple example of our `BaseSynchronizableDataModel`
    class, let's see what we could add into a new base collection class to improve
    this functionality.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 声明这些基本集合类的另一个好处是，我们可以利用属性并扩展我们基础数据模型类中内置的功能。回顾一下我们简单的`BaseSynchronizableDataModel`类示例，让我们看看我们可以在新的基础集合类中添加什么来改进这个功能。
- en: 'Before we can do this however, we need to be able to specify that the objects
    in our new collection have implemented the properties and methods from the `BaseSynchronizableDataModel`
    class. One option would be to declare our new collection class like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够做到这一点之前，我们需要能够指定我们新集合中的对象已实现了`BaseSynchronizableDataModel`类的属性和方法。一个选项是像这样声明我们的新集合类：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, in C#, we can only extend a single base class, while we are free to
    implement as many interfaces as we like. A more preferable solution would therefore
    be for us to extract the relevant synchronization properties from our base class
    into an interface, and then add that to our base class definition:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在C#中，我们只能扩展单个基类，而我们可以自由实现尽可能多的接口。因此，一个更可取的解决方案是从我们的基类中提取相关的同步属性到一个接口中，然后将该接口添加到我们的基类定义中：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We could then specify this new generic constraint on our new collection class
    like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像这样在我们的新集合类中指定这个新的泛型约束：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that any other generic constraints that are placed on the `BaseSynchronizableDataModel`
    class will also need to be added to the `where T` part of this declaration. If,
    for example, we needed to implement another interface in the base class and we
    did not add the same constraint for the `T` generic type parameter in the base
    collection class, then we would get a compilation error when attempting to use
    instances of our base class as the `T` parameter. Let''s now look at this new
    base class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何放置在 `BaseSynchronizableDataModel` 类上的其他泛型约束也需要添加到这个声明的 `where T` 部分。例如，如果我们需要在基类中实现另一个接口，并且我们没有在基集合类中对
    `T` 泛型类型参数添加相同的约束，那么在尝试使用基类的实例作为 `T` 参数时，我们会得到编译错误。现在让我们看看这个新的基类：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While remaining simple, this base collection class provides some powerful functionality.
    We start off with the class declaration, with its generic type constraints that
    are inherited from both our target `T` type classes and our `BaseCollection<T>`
    class. We've then implemented the constructor overloads and passed initialization
    duties straight to the base class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然保持简单，但这个基集合类提供了一些强大的功能。我们从类声明开始，其中包含了从我们的目标 `T` 类型类和 `BaseCollection<T>` 类继承的泛型类型约束。然后我们实现了构造函数重载，并将初始化任务直接传递给基类。
- en: Note that had we wanted to attach an additional level of event handlers to our
    collection items, we would follow the pattern from the base class, rather than
    calling the base class constructors in this way.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想要给我们的集合项附加一个额外的事件处理程序级别，我们应该遵循基类的模式，而不是以这种方式调用基类的构造函数。
- en: The `HasChanges` property can be used as a flag to detect whether any item in
    the collection has any changes or not. This would typically be tied to the `canExecute`
    parameter of a save command, so that the save button would become enabled when
    any item in the collection had been edited and disabled if the changes were undone.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasChanges` 属性可以用作标志来检测集合中的任何项是否有任何更改。这通常与保存命令的 `canExecute` 参数相关联，以便当集合中的任何项被编辑时，保存按钮会变为启用状态，如果更改被撤销，则禁用。'
- en: The `AreSynchronized` property simply specifies whether the items in the collection
    have all been synchronized or not, but the real beauty of this class is in the
    `ChangedCollection` property. Using a simple LINQ filter, we return only the items
    from the collection that have changes. Imagine a scenario where we enable the
    user to edit multiple items at once. With this property, our developers could
    extract just the items that they need to save from the collection with zero effort.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`AreSynchronized` 属性简单地指定集合中的项目是否都已经同步，但这个类的真正美妙之处在于 `ChangedCollection` 属性。使用简单的
    LINQ 过滤器，我们只返回集合中发生变化的项。想象一下这样一个场景，我们允许用户一次性编辑多个项目。有了这个属性，我们的开发者可以轻松地从集合中提取他们需要保存的项。'
- en: Finally, this class provides one method to enable the synchronization of all
    of the items in the collection at once and another to undo the changes of all
    of the edited items in the collection likewise. Note the use of the custom `ForEach` Extension
    Method in these last two methods; if you remember from the earlier *With Extension
    Methods* section, it enables us to perform an action on each item in the collection.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个类提供了一个方法来一次性同步集合中的所有项，另一个方法可以撤销集合中所有已编辑项的更改。注意这两个最后方法中使用了自定义的 `ForEach`
    扩展方法；如果你还记得前面 *With Extension Methods* 部分的内容，它使我们能够对集合中的每个项执行操作。
- en: Through the use of the properties and methods of our Data Model base classes
    by other parts of our framework, we are able to extend their functionality further.
    While building composite functionality from different components in this way is
    generally optional, it can also be necessary, as we'll see later in the book.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其他部分框架使用我们的数据模型基类的属性和方法，我们能够进一步扩展它们的功能。虽然以这种方式从不同的组件构建组合功能通常是可选的，但它也可能是必要的，正如我们在本书后面的内容中将会看到的。
- en: The more common functionality that we can build into our application framework
    base classes, the less work the developers that use our framework will have to
    do when developing the application. However, we must plan carefully and not force
    the developers to have unwanted properties and methods in order to extend a particular
    base class that has some other functionality that they do want.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将更常见的功能构建到我们的应用程序框架基类中，这样使用我们框架的开发人员在开发应用程序时需要做的工作就越少。然而，我们必须精心规划，不要强迫开发人员拥有他们不想要的属性和方法，以扩展具有他们想要的某些其他功能的特定基类。
- en: Typically, there will be different requirements for different components. The
    Data Model classes will generally have more base classes than View Models because
    they play a bigger role than View Models. The View Models simply provide the Views
    with the data and functionality that they require. However, the Data Model classes
    contain the data, along with validation, synchronization, and possibly animation
    methods and properties. With this in mind, let's look again at the View Model
    base class.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不同的组件会有不同的要求。数据模型类通常比视图模型类有更多的基类，因为它们比视图模型扮演着更重要的角色。视图模型只是为视图提供它们所需的数据和功能。然而，数据模型类包含了数据，以及验证、同步，以及可能的方法和属性。考虑到这一点，让我们再次看看视图模型基类。
- en: 'We have already seen that we will need an implementation of the `INotifyPropertyChanged`
    interface in our base class, *but what else should we implement?* If every View
    will be providing some specific functionality, such as saving and deleting items
    for example, then we can also add commands straight into our base class and abstract
    methods that each derived View Model class will have to implement:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在我们的基类中需要实现`INotifyPropertyChanged`接口，*但还需要实现什么？* 如果每个视图都将提供一些特定的功能，例如保存和删除项目，那么我们也可以直接在我们的基类中添加命令和抽象方法，每个派生视图模型类都必须实现：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Again, it is important to declare this command as being virtual, in case the
    developers need to provide their own, different implementation of it. An alternative
    to this arrangement would be to just add abstract properties for each command,
    so that the individual implementations would be completely up to the developers:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，声明这个命令为虚拟的是很重要的，以防开发人员需要提供他们自己的、不同的实现。这种安排的替代方案是只为每个命令添加抽象属性，这样具体的实现就完全取决于开发人员：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: While on the subject of commands, you may remember our basic implementation
    of `ActionCommand` from [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working with WPF*. At this point, it is worth taking a short
    detour to investigate this further. Note that while the basic implementation shown
    works well most of the time, it can catch us out occasionally and we may notice
    that a button hasn't become enabled when it should have.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论命令的同时，你可能还记得我们在[第1章](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml)中提到的`ActionCommand`的基本实现，*一种更智能的WPF工作方式*。在这个时候，值得短暂偏离主题，进一步研究这个问题。请注意，虽然展示的基本实现大多数时候都工作得很好，但它有时可能会让我们陷入困境，我们可能会注意到一个按钮没有在应该的时候变为可用。
- en: Let's look at an example of this. Imagine that we have a button in our UI that
    opens a folder for the user to view files from and is enabled when a certain condition
    is met in the `ICommand.CanExecute` method. Let's say that this condition is that
    the folder should have some content. After all, there's no point in opening an
    empty folder for the user.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。想象一下，在我们的UI中有一个按钮，它为用户打开一个文件夹以查看文件，并在`ICommand.CanExecute`方法中满足某个条件时启用。假设这个条件是文件夹应该有一些内容。毕竟，为用户打开一个空文件夹是没有意义的。
- en: Now, let's imagine that this folder will be filled when the user performs some
    other operation in the UI. The user clicks the button that starts this folder-filling
    function and the application begins to fill it. At the point that the filling
    function is complete and the folder now holds some content, the open folder button
    should become enabled, as its associated command's `CanExecute` condition is now
    `true`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象当用户在UI中执行其他操作时，这个文件夹会被填充。用户点击启动这个文件夹填充功能的按钮，应用程序开始填充它。当填充功能完成，文件夹现在包含了一些内容时，打开文件夹按钮应该变为可用状态，因为其关联命令的`CanExecute`条件现在是`true`。
- en: Nevertheless, the `CanExecute` method won't be called at that point and why
    should it? The button and, indeed, the `CommandManager` class has no idea that
    this background process was occurring and that the condition of the `CanExecute`
    method has now been met. Luckily, we have a couple of options to address this
    situation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`CanExecute`方法在那个点不会被调用，为什么应该调用它呢？按钮以及`CommandManager`类都不知道这个后台过程正在发生，以及`CanExecute`方法的条件现在已经满足。幸运的是，我们有一些选项来解决这个问题。
- en: One option is to raise the `CanExecuteChanged` event manually to make the data
    bound command sources recheck the output of the `CanExecute` method and update
    their enabled state accordingly. To do this, we could add another method into
    our `ActionCommand` class, but we would have to rearrange a few things first.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是手动引发`CanExecuteChanged`事件，使数据绑定命令源重新检查`CanExecute`方法的输出并相应地更新其启用状态。为此，我们可以在`ActionCommand`类中添加另一个方法，但首先我们需要重新排列一些事情。
- en: 'The current implementation doesn''t store any references to the event handlers
    that get attached to the `CanExecuteChanged` event. They''re actually being stored
    in the `CommandManager` class, as they''re just passed straight through for the
    `RequerySuggested` event to handle. In order to be able to raise the event manually,
    we''ll need to store our own references to the handlers and, to do that, we''ll
    need an `EventHandler` object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现并未存储附加到`CanExecuteChanged`事件的任何处理程序引用。实际上，这些引用被存储在`CommandManager`类中，因为它们只是直接传递给`RequerySuggested`事件以进行处理。为了能够手动引发事件，我们需要存储我们自己的处理程序引用，为此，我们需要一个`EventHandler`对象：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we''ll need to add the references to the handlers that get attached and
    remove those that get detached, while still passing references of them through
    to the `RequerySuggested` event of the `CommandManager`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加引用到被附加的处理程序，并移除那些被断开连接的处理程序，同时仍然将它们的引用传递给`CommandManager`的`RequerySuggested`事件：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The final change to our `ActionCommand` class is to add the method that we
    can call to raise the `CanExecuteChanged` event when we want the command sources
    of the UI controls to retrieve the new `CanExecute` value and update their enabled
    states:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`ActionCommand`类的最后修改是添加一个方法，当我们想要UI控件命令源检索新的`CanExecute`值并更新其启用状态时，可以调用此方法来引发`CanExecuteChanged`事件：
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We are now able to raise the `CanExecuteChanged` event whenever we need to,
    although we''ll also need to change our use of the `ActionCommand` class to do
    so. Whereas previously, we were simply returning a new instance each time its
    getter was called, we''ll now need to keep a reference to each command that we
    want to have this ability:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够在需要时随时引发`CanExecuteChanged`事件，尽管我们也需要更改对`ActionCommand`类的使用方式。以前，每次调用其getter时，我们只是简单地返回一个新实例，而现在我们需要保留每个我们想要具有此能力的命令的引用：
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you are unfamiliar with the `??` operator shown in the preceding code, it
    is known as the **null-coalescing operator** and simply returns the left-hand
    operand if it is not `null`, or the right-hand operand if it is. In this case,
    the right-hand operand will initialize the command and set it to the `saveCommand`
    variable. Then, to raise the event, we call the new `RaiseCanExecuteChanged` method
    on our `ActionCommand` instance when we have completed our operation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对前面代码中显示的`??`运算符不熟悉，它被称为**空合并运算符**，它简单地返回左操作数如果不是`null`，或者如果它是，则返回右操作数。在这种情况下，右操作数将初始化命令并将其设置为`saveCommand`变量。然后，为了引发事件，我们在完成操作后调用我们的`ActionCommand`实例上的新`RaiseCanExecuteChanged`方法：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: While our method is built into the `ActionCommand` class, at times we may not
    have access to the particular instance that we need to raise the event on. It
    should therefore be noted at this point that there is another, more direct way
    that we can get the `CommandManager` class to raise its `RequerySuggested` event.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的方法集成在`ActionCommand`类中，但有时我们可能无法访问我们需要在其上引发事件的特定实例。因此，在此应指出，我们还有另一种更直接的方法可以使`CommandManager`类引发其`RequerySuggested`事件。
- en: In these cases, we can simply call the `CommandManager.InvalidateRequerySuggested`
    method. We should also be aware that these methods of raising the `RequerySuggested`
    event will only work on the UI thread, so care should be taken when using them
    with asynchronous code. Now that our short command-related detour is complete,
    let's return to take a look at what other common functionality we might want to
    put into our View Model base class.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们可以简单地调用 `CommandManager.InvalidateRequerySuggested` 方法。我们还应该意识到，这些引发
    `RequerySuggested` 事件的方 法只能在 UI 线程上工作，因此在使用异步代码时应小心。现在我们的与命令相关的短暂偏离已经完成，让我们回到查看我们可能想要放入我们的视图模型基类中的其他常见功能。
- en: 'If we have chosen to use generic base classes for our Data Models, then we
    can take advantage of that in our `BaseViewModel` class. We can provide generic
    methods that utilize members from these generic base classes. Let''s take a look
    at some simple examples:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择为我们的数据模型使用泛型基类，那么我们可以在我们的 `BaseViewModel` 类中利用这一点。我们可以提供利用这些泛型基类成员的泛型方法。让我们看看一些简单的例子：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we see three simple methods that encapsulate more common functionality.
    Note that we must specify the same generic type constraints that are declared
    on our bass classes. Failure to do so would either result in compilation errors
    or us not being able to use our Data Model classes with these methods.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到三个简单的方法，它们封装了更常见的功能。请注意，我们必须指定与我们的基类上声明的相同泛型类型约束。未能这样做将导致编译错误，或者我们无法使用这些方法与我们的数据模型类一起使用。
- en: The `AddNewDataTypeToCollection` and `InsertNewDataTypeToCollection` methods
    are almost identical and start by creating a new item of the relevant type using
    the `GetNewItem` method of our generic `BaseSynchronizableCollection` class. Next,
    we see another use for our `IAuditable` interface. In this case, we set the `CreatedOn`
    date of the new item if it implements this interface.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddNewDataTypeToCollection` 和 `InsertNewDataTypeToCollection` 方法几乎相同，它们首先使用我们的泛型
    `BaseSynchronizableCollection` 类的 `GetNewItem` 方法创建相关类型的新项目。接下来，我们看到我们对 `IAuditable`
    接口的使用。在这种情况下，如果新项目实现了此接口，我们将设置新项目的 `CreatedOn` 日期。'
- en: Because we declared the generic type constraint on the `T`-type parameter that
    specifies that it must be, or extend, the `BaseSynchronizableDataModel` class,
    we are able to call the `Synchronize` method to synchronize the new item. We then
    add the item to the collection and set it as the value of the `CurrentItem` property.
    Finally, both methods return the new item.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `T`-类型参数上声明了泛型类型约束，指定它必须是或扩展 `BaseSynchronizableDataModel` 类，因此我们可以调用
    `Synchronize` 方法来同步新项目。然后我们将项目添加到集合中，并将其设置为 `CurrentItem` 属性的值。最后，这两个方法都返回新项目。
- en: The last method performs the opposite action; it removes an item from the collection.
    Before doing so, it checks the item's position in the collection and sets the
    `CurrentItem` property to the next item if possible, or the next nearest item
    if the removed item was the last item in the collection.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法执行相反的操作；它从集合中删除一个项目。在这样做之前，它会检查项目在集合中的位置，如果可能，将 `CurrentItem` 属性设置为下一个项目，或者如果被删除的项目是集合中的最后一个项目，则设置为下一个最近的项目。
- en: Once again, we see how we can encapsulate commonly used functionality into our
    base class and save the users of our framework both time and effort in reimplementing
    this functionality in each View Model class. We can package up any common functionality
    that we require in this manner. Having now seen several examples of providing
    functionality in our base classes, let's now turn our attention to providing separation
    between the components of our framework.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们看到如何将常用功能封装到我们的基类中，并为我们的框架的用户节省时间和精力，避免在每个视图模型类中重新实现此功能。我们可以以这种方式打包我们需要的任何常见功能。现在我们已经看到了在基类中提供功能的一些示例，让我们现在将注意力转向在框架的组件之间提供分离。
- en: Separating the Data Access Layer
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离数据访问层
- en: 'Now that we''ve had a look at providing a variety of functionality through
    our base classes and interfaces, let''s investigate how we can provide the Separation
    of Concerns that is crucial when using the MVVM pattern. Once again, we turn to
    the humble interface to help us achieve this. Let''s view a simplified example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过我们的基类和接口提供了各种功能，让我们来探讨如何提供在使用 MVVM 模式时至关重要的关注点分离。再次，我们转向谦逊的接口来帮助我们实现这一点。让我们看看一个简化的例子：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We start off with a very simple interface. Of course, real applications will
    have a great many more methods than this, but the principle is the same, regardless
    of the complexity of the interface. So here, we just have a `GetUser` and a `SaveUser`
    method that our `DataProvider` classes need to implement. Now, let''s look at
    the `ApplicationDataProvider` class:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个非常简单的界面开始。当然，实际应用将会有比这多得多的方法，但无论界面的复杂程度如何，原理都是相同的。因此，这里我们只有一个`GetUser`和一个`SaveUser`方法，这是我们的`DataProvider`类需要实现的方法。现在，让我们看看`ApplicationDataProvider`类：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This `ApplicationDataProvider` class uses some simple LINQ to SQL to query
    and update a database for the `User` specified by the `id` value provided. That
    means that this particular implementation of the interface requires a connection
    to a database. We want to avoid having this dependency when testing our application,
    so we''ll need another implementation of the interface to use for testing purposes.
    Let''s take a look at our mock implementation now:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ApplicationDataProvider`类使用一些简单的LINQ to SQL来查询和更新由`id`值指定的`User`数据库。这意味着这个接口的特定实现需要连接到一个数据库。我们希望在测试应用程序时避免这种依赖，因此我们需要为测试目的使用接口的另一个实现。现在让我们看看我们的模拟实现：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this `MockDataProvider` implementation of the `IDataProvider` interface,
    we can see that the data is just manually mocked. In fact, it just returns the
    one single `User` from the `GetUser` method and always returns `true` from the
    `SaveUser` method, so it's fairly useless.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`MockDataProvider`对`IDataProvider`接口的实现中，我们可以看到数据只是手动模拟的。实际上，它只是从`GetUser`方法返回一个单一的`User`，并且总是从`SaveUser`方法返回`true`，所以它相当无用。
- en: In a real-world application, we would either utilize a mocking framework, or
    manually mock up some more substantial testing data. Still, this will suffice
    for the point that we are focusing on here. Now that we've seen the classes involved,
    let's look at how they might be used.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们可能会利用一个模拟框架，或者手动模拟一些更实质的测试数据。尽管如此，这足以说明我们在这里关注的点。现在我们已经看到了相关的类，让我们看看它们可能的使用方式。
- en: The idea is that we have some sort of `DataController` class or classes that
    sit between the `IDataProvider` interface and the View Model classes. The View
    Model classes request data from the `DataController` class and, in turn, it requests
    data through the interface.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是我们有一些`DataController`类或类，它们位于`IDataProvider`接口和视图模型类之间。视图模型类从`DataController`类请求数据，然后它通过接口请求数据。
- en: 'It therefore mirrors the methods of the interface and typically introduces
    some extra functionality, such as feedback handling for example. Let''s see what
    our simplified `DataController` class looks like:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它反映了接口的方法，并且通常引入一些额外的功能，例如反馈处理等。让我们看看我们的简化版`DataController`类是什么样的：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As we can see, the `DataController` class has a private member variable of
    type `IDataProvider`, which is populated in its constructor. It is this variable
    that is used to access the application data source. When the application is running,
    an instance of our `ApplicationDataProvider` class is used to instantiate the
    `DataController` class, and so our actual data source is used:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`DataController`类有一个私有的成员变量，类型为`IDataProvider`，它在构造函数中被填充。正是这个变量用于访问应用程序数据源。当应用程序运行时，我们的`ApplicationDataProvider`类的一个实例被用来实例化`DataController`类，因此我们实际的数据源被使用：
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, when we are testing our application, we can use an instance of our
    `MockDataProvider` class to instantiate the `DataController` class instead, thereby
    eliminating our dependency on the actual data source:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们测试应用程序时，我们可以使用我们的`MockDataProvider`类的一个实例来实例化`DataController`类，从而消除对实际数据源的依赖：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this way, we can swap out the code that provides the data for the View Models,
    while keeping the rest of the code unchanged. This enables us to test the code
    in the View Models without having to be connected to our actual data storage device.
    In the next section, we'll see better ways to initialize these classes, but for
    now, let's see what else our `DataController` class could do for us.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以在保持其余代码不变的情况下替换掉为视图模型提供数据的代码。这使得我们能够在不连接到实际数据存储设备的情况下测试视图模型中的代码。在下一节中，我们将看到更好的初始化这些类的方法，但就目前而言，让我们看看我们的`DataController`类还能为我们做什么。
- en: 'Interfaces become more useful when they are used by parts of the application
    framework, other than the implementing classes. Apart from than defining some
    auditing properties and having the possibility of outputting their values, our
    earlier `IAuditable` interface example is not overly useful. We could however,
    extend its functionality further in our `DataController` class by automatically
    updating its values. We''ll need to add some more members to achieve this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当接口被应用程序框架的各个部分使用，而不仅仅是实现类时，它们就更有用了。除了定义一些审计属性和有输出它们值的可能性之外，我们早期的`IAuditable`接口示例并不特别有用。然而，我们可以通过在`DataController`类中自动更新其值来进一步扩展其功能。为此，我们需要添加一些额外的成员：
- en: '[PRE65]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We first need to add a property of type `User` that we will use to set the
    value of the current user of the application. This can be set as new users login
    to the application. Next, we need a method to update the "*updated*" values of
    our `IAuditable` interface. Again, we add a generic type constraint to ensure
    that only objects that implement our interface can be passed into this method.
    The result of this is that the developers that use our application framework can
    easily update these values:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要添加一个类型为`User`的属性，我们将用它来设置应用程序当前用户的价值。这可以在新用户登录应用程序时设置。接下来，我们需要一个方法来更新我们的`IAuditable`接口的“更新”值。同样，我们添加一个泛型类型约束，以确保只有实现我们接口的对象才能传递到这个方法中。结果是，使用我们应用程序框架的开发者可以轻松地更新这些值：
- en: '[PRE66]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We could add a similar method to set the "*created*" audit properties when
    adding new objects:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为添加新对象时设置类似的“创建”审计属性的方法：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Continuing this example, we could extend the constructor of our `DataController`
    class to accept a `User` input parameter that we can use to set our `CurrentUser`
    property with:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个例子，我们可以扩展我们的`DataController`类的构造函数，以接受一个`User`输入参数，我们可以使用它来设置`StateManager`类中的`CurrentUser`属性：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We could then expose our data source to our View Models through their base
    class using a `CurrentUser` property in the `StateManager` class and the `DependencyManager`
    class that we''ll see in the following sections:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`StateManager`类中的`CurrentUser`属性和接下来的章节中我们将看到的`DependencyManager`类，将我们的数据源暴露给我们的视图模型通过它们的基类：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Essentially, anything, that we need to do to the data coming from our application
    data source can be achieved in a single `DataController` class. However, if we
    require several different modifications, then we could alternatively create several
    controller classes and chain them together, with each performing their separate
    tasks in turn.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们需要对来自应用程序数据源的数据进行的任何操作都可以在单个`DataController`类中实现。然而，如果我们需要几个不同的修改，那么我们可以创建几个控制器类并将它们链接在一起，每个类依次执行它们各自的任务。
- en: 'As they could all implement the same methods, they could all potentially implement
    the same interface:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们都可以实现相同的方法，它们都可以潜在地实现相同的接口：
- en: '![](img/23988467-63fb-4345-b6a8-a037bc9ad54c.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23988467-63fb-4345-b6a8-a037bc9ad54c.png)'
- en: We'll see an example of this in [Chapter 10](506906a3-83cb-4b51-9ac5-3c00e650198a.xhtml),
    *Completing That Great User Experience*, but now that we have a good idea on how
    best to setup our application data source connections to provide the separation
    required by the MVVM pattern, we can focus on the next way of building functionality
    into our framework. Let's move on to discover how we can plug more complex and/or
    specialized functionality into our framework.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第10章[完成卓越的用户体验](506906a3-83cb-4b51-9ac5-3c00e650198a.xhtml)中看到一个例子，但现在我们已经对如何设置我们的应用程序数据源连接以提供MVVM模式所需的分离有了很好的理解，我们可以专注于将功能构建到我们的框架中的下一个方式。让我们继续探索如何将更复杂和/或特殊的功能插入到我们的框架中。
- en: Providing services
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供服务
- en: The job of the base classes and interfaces in our application framework are
    to encapsulate functionality that is commonly used by our View Models and Data
    Models. When the required functionality is more complex, or when it involves particular
    resources, or external connections, we implement it in separate service, or manager
    classes. For the remainder of this book, we will refer to these as manager classes.
    In larger applications, these are typically provided in a separate project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序框架中，基类和接口的职责是封装我们的视图模型和数据模型常用的功能。当所需的功能更复杂，或者当它涉及特定的资源或外部连接时，我们在单独的服务或管理类中实现它。在本书的剩余部分，我们将把这些称为管理类。在更大的应用程序中，这些通常在单独的项目中提供。
- en: Encapsulating them in a separate project enables us to reuse the functionality
    from these classes in our other applications. Which classes we use in this project
    will depend on the requirements of the application that we're building, but it
    will often include classes that provide the ability to send emails, to access
    the end user's hard drive, to export data in various formats, or to manage global
    application state for example.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们封装在单独的项目中，使我们能够在我们其他应用程序中重用这些类的功能。我们在这个项目中使用的类将取决于我们正在构建的应用程序的需求，但通常包括提供发送电子邮件、访问最终用户的硬盘驱动器、以各种格式导出数据或管理全局应用程序状态等能力的类。
- en: We will investigate a number of these classes in this book, so that we have
    a good idea of how to implement our own custom manager classes. The most commonly
    used of these classes can normally be accessed directly from the base View Model
    class via properties. There are a few different ways that we can expose these
    classes to the View Models, so let's examine them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中研究这些类中的许多，以便我们有一个很好的想法，知道如何实现我们自己的自定义管理器类。这些类中最常用的通常可以通过基视图模型类中的属性直接访问。我们可以以几种不同的方式将这些类暴露给视图模型，让我们来检查它们。
- en: 'When a manager class is used often, and for short durations each time, we can
    expose a new instance of them each time, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理器类经常使用，并且每次使用时间较短时，我们可以每次都暴露一个新的实例，如下所示：
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'However, if a manager class is required for the life of the application because
    it must remember a particular state or configuration, for example, then we typically
    use the `static` keyword in one way or another. The simplest option would be to
    declare a normal class, but expose it via a static property:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果因为必须记住特定的状态或配置，在应用程序的生命周期中需要使用管理器类，那么我们通常会以某种方式使用`static`关键字。最简单的选择是声明一个普通类，但通过静态属性来暴露它：
- en: '[PRE71]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: An alternative method of having one and only one instance of a class being instantiated
    and having it stay alive for as long as the application is running is for us to
    use the Singleton pattern. While it was all the rage twenty or so years ago, it
    has unfortunately recently fallen foul of more modern programming principles,
    such as the likes of SOLID, which states that each class should have a single
    responsibility.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个类只有一个实例被实例化并且在整个应用程序运行期间保持活跃，我们可以使用单例模式。虽然二十年前它非常流行，但不幸的是，它最近受到了更多现代编程原则的抨击，例如SOLID原则，该原则指出每个类应该只有一个职责。
- en: 'The Singleton pattern breaks this principle as it serves whatever purpose we
    design it for, but it is also responsible for instantiating itself and maintaining
    a single access point. Before discussing the merits and pitfalls of this pattern
    further, let''s take a look at how we might implement it in our manager class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式打破了这一原则，因为它服务于我们为其设计的任何目的，但它也负责实例化自身并保持一个单一的访问点。在进一步讨论这个模式的优点和缺点之前，让我们看看我们如何在管理器类中实现它：
- en: '[PRE72]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that it can be implemented in a variety of ways, but this particular way
    uses lazy initialization, where the instance is not instantiated until it is first
    referenced via the `Instance` property. Using the `??` operator again, the `Instance`
    property getter can be read as "return the one and only instantiated instance
    if it is not `null`, or, if it is, instantiate the one and only instance and then
    return it." The significant part of this pattern is that as there is no public
    constructor and, therefore, the class cannot be externally instantiated, this
    property is the sinlgle way to access the internal object.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它可以以多种方式实现，但这种方式使用的是延迟初始化，即实例只有在第一次通过`Instance`属性引用时才会被实例化。再次使用`??`运算符，`Instance`属性的getter可以读作“如果它不是`null`，则返回唯一的实例，如果是，则实例化唯一的实例然后返回它。”这个模式的关键部分是，由于没有公共构造函数，因此类不能被外部实例化，这个属性是访问内部对象的唯一方式。
- en: 'However, this is the very part that causes trouble for some developers, as
    this makes inheritance impossible with these classes. In our case though, we won''t
    need to extend our `StateManager` class, so that is not a concern for us. Others
    may point to the problem that exposing this Singleton class, as shown in the following
    code, will tightly couple it to the base View Model class that it is declared
    in:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这正是给一些开发者带来麻烦的部分，因为这使得这些类无法进行继承。在我们的情况下，我们不需要扩展我们的`StateManager`类，所以这不是我们的问题。其他人可能会指出，像以下代码所示的那样公开这个Singleton类，将使其与声明的基视图模型类紧密耦合：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: While this is true, what harm is that with this class? Its purpose is to maintain
    the state of user settings, common or default values, and values for UI display
    and operation statuses. It contains no resources and no real reason to avoid using
    it when running unit tests, so in this case, the tight coupling is inconsequential.
    In this regard, the Singleton pattern continues to be a useful tool in the right
    situations, but we should certainly be aware of its pitfalls all the same.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是真的，但这个类有什么危害呢？它的目的是维护用户设置的状态、常用或默认值以及UI显示和操作状态。它不包含任何资源，也没有任何真正的理由在运行单元测试时避免使用它，所以在这种情况下，紧密耦合是无足轻重的。在这方面，Singleton模式在适当的情况下仍然是一个有用的工具，但我们确实应该意识到它的陷阱。
- en: 'However, if a particular manger class does utilize resources or creates some
    form of connection with the outside world, for example, like an `EmailManager`
    would, then we will need to create an interface for it to maintain our Separation
    of Concerns. Remember that interfaces enable us to disconnect the actual application
    components and replace them with mock components while testing. In these cases,
    we have to expose the functionality in the base classes slightly differently:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一个特定的管理类确实使用了资源或与外部世界建立了某种形式的连接，例如，像`EmailManager`那样，那么我们需要为它创建一个接口来维护我们的关注点分离。记住，接口使我们能够在测试时断开实际的应用程序组件，并用模拟组件替换它们。在这些情况下，我们必须在基类中稍微不同地公开功能：
- en: '[PRE74]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The general idea here is for us to have no direct contact with the manager class
    in hand, instead accessing its functionality through the interface methods and
    properties. By doing this, we are able to decouple the manager class from the
    View Models that use it and therefore enable them to be used independently of
    each other. Note that this is a very simple example of Dependency Injection.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思路是我们不直接与当前的手头管理类接触，而是通过接口方法和属性来访问其功能。通过这样做，我们能够将管理类与其使用的视图模型解耦，从而使得它们可以独立使用。请注意，这是一个非常简单的依赖注入示例。
- en: Implementing Dependency Injection
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现依赖注入
- en: Dependency injection is a well-known design pattern that aids in decoupling
    various components of an application. If one class uses another class to perform
    some functionality internally, then the class that is internally used becomes
    a dependency of the class that uses it. It cannot achieve its objectives without
    it. In some cases, this is not a problem, but in others, it can represent a huge
    problem.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种众所周知的设计模式，有助于解耦应用程序的各个组件。如果一个类使用另一个类来执行某些内部功能，那么被内部使用的类就成为了使用它的类的依赖。没有它，它无法实现其目标。在某些情况下，这可能不是问题，但在其他情况下，它可能代表一个巨大的问题。
- en: For example, let's imagine that we have a `FeedbackManager` class that is responsible
    for providing operational feedback to the end users. In that class, we have a
    `FeedbackCollection` instance that holds the `Feedback` objects that are currently
    being displayed to the current user. Here, the `Feedback` objects are a dependency
    of the `FeedbackCollection` instance and that, in turn, is a dependency of the
    `FeedbackManager` class.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们有一个`FeedbackManager`类，它负责向最终用户提供操作反馈。在这个类中，我们有一个`FeedbackCollection`实例，它持有当前显示给当前用户的`Feedback`对象。在这里，`Feedback`对象是`FeedbackCollection`实例的依赖，而反过来，它是`FeedbackManager`类的依赖。
- en: These objects are all tightly coupled, which is usually a bad thing in software
    development. However, they are also tightly related by necessity. A `FeedbackCollection`
    object would be useless without the `Feedback` objects, as would the `FeedbackManager`
    object.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象之间都是紧密耦合的，这在软件开发中通常是不好的事情。然而，由于必要性，它们之间也是紧密相关的。没有`Feedback`对象，`FeedbackCollection`对象将毫无用处，同样，`FeedbackManager`对象也是如此。
- en: In this particular case, these objects require this coupling to make them useful
    together. This is called composition, where the individual parts form a whole,
    but do little on their own, so it really is no problem for them to be connected
    in this way.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，这些对象需要这种耦合才能使它们共同有用。这被称为组合，其中各个部分形成一个整体，但各自单独作用很小，因此它们以这种方式连接实际上并不成问题。
- en: On the other hand, let's now contemplate the connection between our View Models
    and our DAL. Our View Models will definitely need access to some data, so it would
    at first seem to make sense to encapsulate a class in our View Models that provides
    the data that it requires.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，现在让我们考虑我们的视图模型和我们的数据访问层（DAL）之间的联系。我们的视图模型肯定需要访问一些数据，所以最初看起来在视图模型中封装一个提供所需数据的类的做法似乎是合理的。
- en: While that would certainly work, it would unfortunately result in the DAL class
    becoming a dependent of the View Model class. Moreover, it would permanently couple
    our View Model component to the DAL and break the Separation of Concerns that
    MVVM provides. The kind of connection that we require in this situation is more
    like aggregation, where the individual parts are useful on their own.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这当然可以工作，但不幸的是，它会导致数据访问层（DAL）类成为视图模型类的依赖项。此外，它将永久地将我们的视图模型组件与数据访问层耦合起来，破坏了
    MVVM 提供的关注点分离。在这种情况下，我们需要的连接更像是聚合，其中各个部分单独就有用。
- en: In these cases, we want to be able to use the individual components separately
    and to avoid any tight coupling between them. Dependency Injection is a tool that
    we can use to provide this separation for us. In the absolute simplest terms,
    Dependency Injection is implemented through the use of interfaces. We've already
    seen some basic examples of this in the `DataController` class from the *Separating
    the Data Access Layer* section, and the `EmailManager` example from the previous
    section.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们希望能够单独使用各个组件，并避免它们之间有任何紧密耦合。依赖注入是我们可以使用的一种工具，为我们提供这种分离。在绝对最简单的术语中，依赖注入是通过使用接口实现的。我们已经在
    *分离数据访问层* 部分的 `DataController` 类和一些基本示例中看到了这一点，以及上一节中的 `EmailManager` 示例。
- en: 'However, they were very basic examples and there are a variety of ways of improving
    them. Many application frameworks will provide the ability for developers to use
    Dependency Injection to inject the dependencies into their classes and we can
    do the same with ours. In its simplest form, our `DependencyManager` class will
    simply need to register the dependencies and provide a way to resolve them when
    required. Let''s take a look:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们只是非常基础的示例，有各种方法可以改进它们。许多应用程序框架将提供开发人员使用依赖注入将依赖项注入其类的能力，我们也可以用我们的方法做到同样的事情。在其最简单的形式中，我们的
    `DependencyManager` 类只需注册依赖项并提供在需要时解决它们的方法。让我们看看：
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You may have noticed that we are using the Singleton pattern again for this
    class. In this case, it again fits our requirements exactly. We want one, and
    only one, instance of this class to be instantiated and we want it to stay alive
    for as long as the application is running. When testing, it is used to inject
    our mock dependencies into the View Models, so it is part of the framework that
    enables our Separation of Concerns.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们再次使用了 Singleton 模式来处理这个类。在这种情况下，它再次完全符合我们的要求。我们希望只有一个实例被实例化，并且我们希望它在应用程序运行期间保持活跃。在测试时，它用于将模拟依赖项注入视图模型，因此它是使我们的关注点分离成为可能的框架的一部分。
- en: The `Count` property and the `ClearRegistrations` method are more useful for
    testing than when running the application and the real action goes on in the `Register`
    and `Resolve` methods. The `Register` method registers the interface type represented
    by the `S` generic type parameter, with the concrete implementation of that interface
    represented by the `T` generic type parameter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count` 属性和 `ClearRegistrations` 方法在测试时比在运行应用程序时更有用，因为真正的操作发生在 `Register` 和
    `Resolve` 方法中。`Register` 方法注册由 `S` 泛型类型参数表示的接口类型，该接口的具体实现由 `T` 泛型类型参数表示。'
- en: As the `S` generic type parameter must be an interface, an `ArgumentException`
    is thrown at runtime if the type parameter class supplied is not one. A further
    check is performed to ensure that the type specified by the `T` generic type parameter
    actually implements the interface specified by the `S` generic type parameter,
    and a further `ArgumentException` is thrown if the check fails.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `S` 泛型类型参数必须是接口，如果提供的类型参数类不是接口，则在运行时会抛出 `ArgumentException`。然后执行进一步检查，以确保由
    `T` 泛型类型参数指定的类型实际上实现了由 `S` 泛型类型参数指定的接口，如果检查失败，则抛出进一步的 `ArgumentException`。
- en: The method then verifies the fact that the type parameter provided is not already
    in the `Dictionary` and adds it if it is unique in the collection. Therefore,
    in this particular implementation, we can only specify a single concrete implementation
    for each supplied interface. We could change this to either update the stored
    reference if an existing type was passed again, or even to store multiple concrete
    types for each interface. It all depends on the application requirements.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该方法验证提供类型参数的事实，即它尚未在 `Dictionary` 中，如果它是集合中的唯一项，则添加它。因此，在这个特定的实现中，我们只能为每个提供的接口指定一个具体实现。我们可以将其更改为在再次传递现有类型时更新存储的引用，或者甚至为每个接口存储多个具体类型。这完全取决于应用程序的需求。
- en: Note the generic type constraint declared on this method that ensures that the
    type parameters will at least be classes. Unfortunately, there is no such constraint
    that would allow us to specify that a particular generic type parameter should
    be an interface. However, this type of parameter validation should be used where
    possible, as it helps the users of our framework to avoid using these methods
    with inappropriate values.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个方法上声明的通用类型约束，它确保类型参数至少是类。不幸的是，没有这样的约束可以让我们指定特定的通用类型参数应该是一个接口。然而，这种类型的参数验证应该在可能的情况下使用，因为它有助于我们的框架用户避免使用这些方法的不适当值。
- en: The `Resolve` methods use some simple reflection to return the concrete implementations
    of the interface types represented by the generic type parameters used. Again,
    note the generic type constraints declared by these two methods, that specify
    that the type used for type `T` parameter must be a class. This is to prevent
    the `Activator.CreateInstance` methods from throwing an `Exception` at runtime,
    if a type that could not be instantiated were used.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resolve` 方法使用一些简单的反射来返回由用于泛型类型参数的通用类型参数表示的接口类型的具体实现。再次注意，这两个方法声明的通用类型约束，指定用于类型
    `T` 参数的类型必须是类。这是为了防止 `Activator.CreateInstance` 方法在运行时抛出 `Exception`，如果使用了无法实例化的类型。'
- en: The first overload can be used for classes without any constructor parameters,
    and the second has an additional `params` input parameter to pass the parameters
    to use when instantiating classes that require constructor parameters.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载可用于没有任何构造函数参数的类，第二个有一个额外的 `params` 输入参数，用于在实例化需要构造函数参数的类时传递参数。
- en: 'The `DependencyManager` class can be set up during application startup, using
    the `App.xaml.cs` file. To do this, we first need to find the following `StartupUri`
    property setting in the `Application` declaration at the top of the `App.xaml`
    file:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`DependencyManager` 类可以在应用程序启动时设置，使用 `App.xaml.cs` 文件。为此，我们首先需要在 `App.xaml`
    文件的顶部 `Application` 声明中找到以下 `StartupUri` 属性设置：'
- en: '[PRE76]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We then need to replace this `StartupUri` property setting with the following
    `Startup` property setting:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这个 `StartupUri` 属性设置替换为以下 `Startup` 属性设置：
- en: '[PRE77]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In this example, `App_Startup` is the name of the initialization method that
    we want to be called at startup. Note that as the WPF Framework is no longer starting
    the `MainWindow` class, it is now our responsibility to do so:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`App_Startup` 是我们希望在启动时调用的初始化方法的名称。请注意，由于 WPF 框架不再启动 `MainWindow` 类，现在这是我们的责任：
- en: '[PRE78]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When we want to inject these dependencies into a View Model in the application
    at runtime, we could use the `DependencyManager` class like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望在运行时将这些依赖项注入到应用程序的 View Model 中时，我们可以像这样使用 `DependencyManager` 类：
- en: '[PRE79]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The real beauty of this system is that when testing our View Models, we can
    register our mock manager classes instead. The same preceding code will then resolve
    the interfaces to their mock concrete implementations, thereby freeing our View
    Models from their actual dependencies:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的真正美在于，当测试我们的 View Model 时，我们可以注册我们的模拟管理类。然后，相同的代码将解析接口到它们的模拟具体实现，从而让我们的
    View Model 从它们的实际依赖中解脱出来：
- en: '[PRE80]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We''ve now seen the code that enables us to swap out our dependent classes
    with mock implementations when we are testing our application. However, we''ve
    also seen that not all of our manager classes will require this. So, what exactly
    represents a dependency? Let''s take a look at a simple example involving a UI
    popup message box:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了代码，它使我们能够在测试应用程序时用模拟实现替换我们的依赖类。然而，我们也看到并非所有管理类都需要这样做。那么，究竟什么是依赖呢？让我们看看一个涉及UI弹出消息框的简单例子：
- en: '[PRE81]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, we have an interface that declares a single method. This is the method
    that the developers will call from the View Model classes when they need to display
    a message box in the UI. It will use a real `MessageBox` object during runtime,
    but that uses a number of enumerations from the `System.Windows` namespace.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个声明单个方法的接口。这是开发人员在需要从视图模型类中在UI中显示消息框时将调用的方法。它在运行时将使用真实的`MessageBox`对象，但该对象使用`System.Windows`命名空间中的多个枚举。
- en: We want to avoid interacting with these enumeration instances in our View Models,
    as that will require adding a reference to the `PresentationFramework` assembly
    and tie our View Models to part of our Views component.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望避免在视图模型中与这些枚举实例交互，因为这将需要添加对`PresentationFramework`程序集的引用，并将我们的视图模型绑定到我们视图组件的一部分。
- en: We therefore need to abstract them from our interface method definition. In
    this case, we have simply replaced the enumerations from the `PresentationFramework`
    assembly with custom enumerations from our domain that merely replicate the original
    values. As such, there is little point in showing the code for these custom enumerations
    here.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要从我们的接口方法定义中抽象它们。在这种情况下，我们只是将`PresentationFramework`程序集中的枚举替换为我们域中的自定义枚举，这些枚举仅仅复制了原始值。因此，在这里展示这些自定义枚举的代码几乎没有意义。
- en: 'While it''s never a good idea to duplicate code, it''s an even worse idea to
    add a UI assembly like the `PresentationFramework` assembly to our `ViewModels`
    project. By encapsulating this assembly within the `Managers` project and converting
    its enumerations, we can expose the functionality that we need from it without
    tying it to our View Models:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然复制代码从来都不是一个好主意，但将像`PresentationFramework`这样的UI程序集添加到我们的`ViewModels`项目中更是糟糕。通过在`Managers`项目中封装这个程序集并转换其枚举，我们可以暴露我们需要的功能，而无需将其绑定到我们的视图模型：
- en: '[PRE82]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We start with our `using` directives and see further examples of using alias
    directives. In this case, we created some enumeration classes with the same names
    as those from the `System.Windows` namespace. To avoid the conflicts that we would
    have caused by adding a standard `using` directive for our `CompanyName.ApplicationName.DataModels.Enums`
    namespace, we add aliases to enable us to work with just the types from our namespace
    that we require.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`using`指令开始，并进一步查看使用别名指令的示例。在这种情况下，我们创建了一些与`System.Windows`命名空间中相同的枚举类。为了避免添加`CompanyName.ApplicationName.DataModels.Enums`命名空间的标准`using`指令可能引起的冲突，我们添加了别名，以便我们只需使用我们命名空间中所需的类型。
- en: 'After this, our `WindowManager` class simply converts the UI-related enumeration
    values to and from our custom enumerations, so that we can use the functionality
    of the message box, but not be tied to its implementation. Imagine a situation
    where we need to use this to output an error message:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们的`WindowManager`类只是将UI相关的枚举值转换为我们自定义枚举，这样我们就可以使用消息框的功能，而不会绑定到其实现。想象一下我们需要用它来输出错误消息的情况：
- en: '[PRE83]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: When execution reaches this point, a message box will pop up, displaying an
    error message with an error icon and heading. The application will freeze at this
    point while waiting for user feedback and, if the user does not click a button
    on the popup, it will remain frozen indefinitely. If execution reaches this point
    during a unit test and there is no user to click the button, then our test will
    freeze indefinitely and never complete.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行到达这一点时，将弹出一个消息框，显示带有错误图标和标题的错误消息。应用程序将在此处冻结，等待用户反馈。如果用户没有在弹出窗口中点击按钮，它将无限期地保持冻结状态。如果在单元测试期间执行到达这一点而没有用户点击按钮，那么我们的测试将无限期地冻结，永远不会完成。
- en: In this example, the `WindowManager` class is dependent upon having a user present
    to interact with it. Therefore, if the View Models used this class directly, they
    would also have the same dependency. Other classes might have a dependency on
    an email server, database, or other type of resource, for example. These are the
    types of classes that View Models should only interact with via interfaces.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'In doing so, we provide the ability to use our components independently from
    each other. Using our `IWindowManager` interface, we are able to use our `ShowMessageBox`
    method independently of the end users. In this way, we are able to break the user
    dependency and run our unit tests without them. Our mock implementation of the
    interface can simply return a positive response each time and the program execution
    can continue unheeded:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This simple example shows another method of exposing functionality from a source
    to our View Models, but without it becoming a dependency. In this way, we can
    provide a whole host and variety of capabilities to our View Models, while still
    enabling them to function independently.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: We now have the knowledge and tools to build functionality into our application
    framework in many different ways, yet our probe into application frameworks is
    still not quite complete. One other essential matter is that of connecting our
    Views with our View Models. We'll need to decide how the users of our framework
    should do this, so let's look at some choices.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Views with View Models
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In WPF, there are several ways to connect our Views to their data sources.
    We''ve all seen examples of the simplest method of a View setting its `DataContext`
    property to itself in its code behind:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: However, this should only ever be used for quick demonstrations and never in
    our real-world applications. If we need to data-bind to properties declared in
    a View's code behind, let's say for a particular custom `UserControl`, then we
    should use `RelativeSource` bindings instead. We'll find out more about this in
    [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml), *Becoming Proficient
    with Data Binding*, but for now, let's continue looking at the alternative ways
    to connect the Views with their data sources.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'The next simplest method utilizes the data templating Model that is built into
    the WPF Framework. This topic will also be covered in much more detail in [Chapter
    4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml), *Becoming Proficient with Data
    Binding*, but, in short, a `DataTemplate` is used to inform the WPF Framework
    how we want it to render data objects of a particular type. The simple example
    shows how we could define the visual output of our `User` objects:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this example, the `DataType` property specifies which type of object this
    relates to and therefore, which properties the containing XAML bindings have access
    to. Keeping it simple for now, we just output the name of each `User` in this
    `DataTemplate`. When we data-bind one or more `User` objects to a UI control that
    is within the scope of this `DataTemplate`, they will each be rendered by the
    WPF Framework as a `TextBlock` that specifies their name.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`DataType` 属性指定了这与哪种类型的对象相关联，因此，包含的 XAML 绑定可以访问哪些属性。为了简单起见，我们现在只输出这个
    `DataTemplate` 中每个 `User` 的名称。当我们将一个或多个 `User` 对象数据绑定到位于此 `DataTemplate` 范围内的
    UI 控件时，WPF 框架将它们各自渲染为指定其名称的 `TextBlock`。
- en: 'When the rendering engine of the WPF Framework comes across a custom data object,
    it looks for a `DataTemplate` that has been declared for its type and, if it finds
    one, it renders the object according to the XAML contained within the relevant
    template. This means that we can create a `DataTemplate` for our View Model classes
    that simply specifies their related View classes as the rendering output:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当 WPF 框架的渲染引擎遇到一个自定义数据对象时，它会寻找为其类型声明的 `DataTemplate`，如果找到了，它就会根据相关模板中包含的 XAML
    来渲染该对象。这意味着我们可以为我们的视图模型类创建一个 `DataTemplate`，它只需指定其相关的视图类作为渲染输出：
- en: '[PRE87]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In this example, we have specified that when the WPF Framework sees an instance
    of our `UserViewModel` class, it should render it as one of our `UserView` classes.
    At this point, it will set our View Model instance to the `DataContext` property
    of the related View implicitly. The only downside to this method is minimal, and
    is that we have to add a new `DataTemplate` to our `App.xaml` file for each of
    our View-View Model pairs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们指定当 WPF 框架看到我们的 `UserViewModel` 类的实例时，它应该将其渲染为我们 `UserView` 类之一。此时，它将我们的视图模型实例隐式地设置为相关视图的
    `DataContext` 属性。这种方法的不利之处很小，我们只需为每个视图-视图模型对添加一个新的 `DataTemplate` 到我们的 `App.xaml`
    文件中。
- en: 'This method of connection works View Model first, where we supply the View
    Model instance and the WPF Framework takes care of the rest. In these cases, we
    typically use a `ContentControl` that has its `Content` property data bound to
    a `ViewModel` property, which the application View Models are set to. The WPF
    Framework notes the type of the View Model that is set and renders it according
    to its specified `DataTemplate`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连接方法首先处理视图模型，其中我们提供视图模型实例，WPF 框架负责其余部分。在这些情况下，我们通常使用一个 `ContentControl`，其
    `Content` 属性数据绑定到一个 `ViewModel` 属性，该属性被设置为应用程序的视图模型。WPF 框架记录设置的视图模型类型，并按照其指定的
    `DataTemplate` 进行渲染：
- en: '[PRE88]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is the preferred version of View to View Model connections for many, as
    the WPF Framework is left to take care of most of the details. However, there
    is another way to construct these connections that adds a layer of abstraction
    to the process.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，这是视图到视图模型连接的首选版本，因为 WPF 框架被留给处理大多数细节。然而，还有另一种构建这些连接的方法，它为这个过程添加了一层抽象。
- en: Locating View Models
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位视图模型
- en: 'For this method, we need to create interfaces for each of our View Models.
    It''s called View Model Location and it''s fairly similar to the Dependency Injection
    example that we have already seen. In fact, we could even use our existing `DependencyManager`
    to achieve a similar result. Let''s take a quick look at that first:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种方法，我们需要为每个视图模型创建接口。这被称为视图模型定位，它与我们已经看到的依赖注入示例相当相似。事实上，我们甚至可以使用我们现有的 `DependencyManager`
    来实现类似的结果。让我们先快速看一下：
- en: '[PRE89]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In this example, we associate the `IUserViewModel` interface with the `UserViewModel`
    concrete implementation of that interface in some initialization code and later,
    resolve the dependency, before setting it as the View's `DataContext` value. After
    declaring our Views in the XAML, they automatically hook themselves up to their
    related View Models at runtime.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在一些初始化代码中将 `IUserViewModel` 接口与该接口的 `UserViewModel` 具体实现相关联，然后在设置它为视图的
    `DataContext` 值之前解决依赖关系。在声明我们的视图后，它们在运行时自动将自己连接到相关的视图模型。
- en: This method of connecting Views to View Models works View first, where we declare
    the View and it instantiates its own View Model and sets its own `DataContext`.
    The downside with this method is that we have to create an interface for all of
    our View Models and register and resolve each of them using the `DependencyManager`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将视图连接到视图模型的方法首先处理视图，其中我们声明视图，它实例化自己的视图模型并设置自己的 `DataContext`。这种方法的不利之处在于，我们必须为所有视图模型创建接口，并使用
    `DependencyManager` 注册和解析每个接口。
- en: 'The main difference between this implementation and that of a View Model Locator
    is that a locator provides a level of abstraction from our Singleton class, which
    enables us to indirectly instantiate our View Models from the XAML, without using
    the code behind. They also have a little extra specific functionality that enables
    dummy data to be used at design time. Let''s take a look at the simplest possible
    example:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 与视图模型定位器的实现相比，主要区别在于定位器为我们从 Singleton 类提供了一层抽象，这使得我们能够间接地从 XAML 中实例化我们的视图模型，而不使用代码后端。它们还具有一些额外的特定功能，允许在设计时使用占位数据。让我们看看最简单的例子：
- en: '[PRE90]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Here, we have a very basic View Model Locator that simply locates a single
    View Model. It is important that this View Model class has an empty constructor
    so that it can be instantiated from the XAML. Let''s see how we can do this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个非常基础的视图模型定位器，它只是简单地定位一个单一的视图模型。这个视图模型类必须有一个空构造函数，以便可以从 XAML 中实例化它。让我们看看我们如何做到这一点：
- en: '[PRE91]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As a side note, you may have noticed that our `ViewModelLocator` class has been
    declared in the `Views` project. The location of this class is not very important,
    but it must have references to both the `ViewModels` and the `Views` projects,
    and this severely limits the number of projects in which it can reside. Typically,
    the only projects that will have access to the classes from both of these projects
    will be the `Views` project and the startup project.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，你可能已经注意到我们的 `ViewModelLocator` 类是在 `Views` 项目中声明的。这个类的位置并不重要，但它必须引用 `ViewModels`
    和 `Views` 项目，这严重限制了它可以存在的项目数量。通常，只有 `Views` 项目和启动项目会访问这两个项目中的类。
- en: Getting back to our example, an instance of the `ViewModelLocator` class is
    declared in the View's `Resources` section and this will only work if we have
    a parameterless constructor (including the default parameterless constructor that
    is declared for us if we do not explicitly declare a constructor). Without a parameterless
    constructor, we will receive an error in the Visual Studio designer.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，`ViewModelLocator` 类的实例是在视图的 `Resources` 部分声明的，并且这只有在我们有无参构造函数的情况下才会工作（包括如果我们没有显式声明构造函数，系统为我们声明的默认无参构造函数）。如果没有无参构造函数，我们在
    Visual Studio 设计器中将会收到错误。
- en: Our View sets its own `DataContext` property in XAML this time, using a binding path
    to the `UserViewModel` property from our `ViewModelLocator` resource. The property
    then utilizes our `DependencyManager` to resolve the concrete implementation of
    the `IUserViewModel` interface and return it for us.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图这次在 XAML 中设置了它自己的 `DataContext` 属性，使用绑定路径从我们的 `ViewModelLocator` 资源到 `UserViewModel`
    属性。然后，该属性利用我们的 `DependencyManager` 来解析 `IUserViewModel` 接口的具体实现，并将其返回给我们。
- en: There are other benefits to using this pattern as well though. One problem often
    faced by WPF developers is that the Visual Studio WPF Designer cannot resolve
    the interfaces that are used to back their concrete implementations, nor can it
    access the application data sources during design time. The result of this is
    that the designer does not typically display data items that cannot be resolved.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式还有其他好处。WPF 开发者经常遇到的一个问题是，Visual Studio WPF 设计器无法解析用于支持其具体实现的接口，在设计时也无法访问应用程序的数据源。结果是，设计器通常不会显示无法解析的数据项。
- en: 'One thing that we can do with our `ViewModelLocator` resource is to provide
    mock View Models that have dummy data returned from their properties that we can
    use to help visualize our Views as we construct them. To achieve this, we can
    make use of the `IsInDesignMode` Attached Property from the `DesignerProperties`
    .NET class:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用我们的 `ViewModelLocator` 资源做的一件事是提供具有从其属性返回的占位数据的模拟视图模型，我们可以使用这些数据来帮助我们可视化我们构建的视图。为了实现这一点，我们可以利用来自
    `DesignerProperties` .NET 类的 `IsInDesignMode` 附加属性：
- en: '[PRE92]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `DependencyObject` object here is required by the Attached Property and,
    in fact, is the object that is being checked. As all objects supplied here would
    return the same value, we are free to use a new one each time. If we are concerned
    that this property will be called more frequently than the garbage collector,
    we could opt to use a single member instead, just for this purpose:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DependencyObject` 对象是由附加属性所必需的，实际上，它就是被检查的对象。由于所有提供在这里的对象都会返回相同的值，我们可以自由地每次使用一个新的对象。如果我们担心这个属性会被垃圾回收器调用得更频繁，我们可以选择只为此目的使用一个单一成员：
- en: '[PRE93]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'However, if we need a `DependencyObject` object just for this purpose, then
    we could simplify things further by extending our `ViewModelLocator` class from
    the `DependencyObject` class and use itself as the required parameter. Of course,
    this would mean that our class would inherit unwanted properties, so some might
    prefer to avoid doing this. Let''s see how we could use this property to provide
    the WPF Designer with mock data at design time:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只是为了这个目的需要一个`DependencyObject`对象，那么我们可以通过从`DependencyObject`类扩展我们的`ViewModelLocator`类并使用它本身作为所需的参数来进一步简化事情。当然，这意味着我们的类将继承不需要的属性，所以有些人可能更喜欢避免这样做。让我们看看我们如何可以使用这个属性在设计时为WPF设计器提供模拟数据：
- en: '[PRE94]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If you look at our `UserViewModel` property, you'll see the value that we return
    is now dependent upon the value of the `IsDesignTime` property. If we are in design
    time, for example, when the View file is open in the WPF Designer, then the `MockUserViewModel`
    class will be returned. At runtime, however, the concrete implementation of our
    `IUserViewModel` interface that we registered with the `DependencyManager` will
    be returned instead.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看我们的`UserViewModel`属性，你会看到我们返回的值现在取决于`IsDesignTime`属性的值。例如，如果我们处于设计时，例如当视图文件在WPF设计器中打开时，则将返回`MockUserViewModel`类。然而，在运行时，将返回我们注册到`DependencyManager`的`IUserViewModel`接口的具体实现。
- en: The `MockUserViewModel` class will typically hardcode some mock data and return
    it from its properties when requested. In this manner, the WPF Designer will be
    able to visualize the data for the developers or designers while they build the
    Views.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockUserViewModel`类通常会在其属性中硬编码一些模拟数据，并在请求时返回这些数据。以这种方式，WPF设计器将能够在开发者或设计师构建视图时可视化数据。'
- en: 'However, each View will require a new property in our locator class and we''ll
    need to copy this conditional operator statement from the preceding code for each.
    As always in OOP, there is a further abstraction that we could make to hide that
    implementation away from the developers that will use our framework. We could
    create a generic base class for our View Model Locator:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个视图将需要在我们的定位器类中有一个新属性，并且我们需要为每个属性复制从前面的代码中获取的此条件运算符语句。正如在OOP中始终所做的那样，我们可以进一步抽象化以隐藏实现，从而让将使用我们的框架的开发者不必关心。我们可以为我们的ViewModel定位器创建一个泛型基类：
- en: '[PRE95]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: We start by declaring an abstract class that takes a generic type parameter,
    which represents the interface type of the View Model that we are trying to locate.
    Once again, note the generic type constraint declared on the generic type parameter
    that specifies that the type used must be a class. This is now required because
    this class calls the `Resolve` method of the `DependencyManager` class and that
    has the same constraint declared upon it.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个抽象类，它接受一个泛型类型参数，该参数表示我们正在尝试定位的ViewModel的接口类型。再次注意，在泛型类型参数上声明的泛型类型约束，指定使用的类型必须是一个类。这是现在所必需的，因为此类调用`DependencyManager`类的`Resolve`方法，并且在该方法上声明了相同的约束。
- en: We have two internal members of the relevant type of View Model interface that
    back the properties with the same names. There's one for our runtime View Model
    and one for our design time View Model. The third View Model property of the same
    type is the one that we will data-bind to from Views and it uses our `IsDesignTime`
    property to determine which View Model to return.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个与ViewModel接口相关联的内部成员，它们支持具有相同名称的属性。有一个是为我们的运行时ViewModel准备的，还有一个是为我们的设计时ViewModel准备的。同类型的第三个ViewModel属性是我们将从视图绑定到的那一个，它使用我们的`IsDesignTime`属性来确定返回哪个ViewModel。
- en: 'A nice touch in this class is that it does a lot of the connection work for
    the developers. They don''t need to concern themselves with the implementation
    of the `IsDesignTime` property, and this base class will even attempt to automatically
    resolve the concrete View Model dependency for the runtime View Model property.
    Therefore, the developer need only declare the following code for each View Model
    to take advantage of this functionality:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中的一个很好的特性是它为开发者做了很多连接工作。他们不需要关心`IsDesignTime`属性的实现，并且这个基类甚至会尝试自动解决运行时ViewModel属性的实体ViewModel依赖。因此，开发者只需为每个ViewModel声明以下代码即可利用此功能：
- en: '[PRE96]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'It could be set up in the UI with very little difference to our original locator
    version:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以以与我们原始定位器版本几乎相同的方式在UI中设置：
- en: '[PRE97]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Note that although this should work automatically in newer versions of Visual
    Studio, you may need to provide a helping hand to the WPF Designer in older versions.
    The `mc:Ignorable` attribute specifies which XAML namespace prefixes encountered
    in a markup file may be ignored by an XAML processor and the `d` XAML namespace
    is used by the Designer, so we can specify a `DataContext` location to it directly
    at design time:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管这应该在Visual Studio的新版本中自动工作，但你可能需要在旧版本中为WPF设计器提供帮助。`mc:Ignorable`属性指定了在标记文件中遇到的哪些XAML命名空间前缀可以被XAML处理器忽略，而`d`XAML命名空间由设计器使用，因此我们可以在设计时直接指定`DataContext`位置：
- en: '[PRE98]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: While there is a clear benefit to this arrangement, as always, we have to weigh
    up whether the cost of any such abstractions will be worth the benefits. For some,
    the cost of extracting an interface, declaring a mock version of it to use at
    design time, and creating a View Model Locator for each View Model will definitely
    be worth the benefit of designing Views that visualize their data.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种安排有明显的优势，但像往常一样，我们必须权衡任何此类抽象的成本是否值得其带来的好处。对于一些人来说，提取接口、声明一个用于设计时的模拟版本，并为每个视图模型创建一个视图模型定位器的成本肯定值得设计可视化其数据的视图的好处。
- en: For others, it simply won't be worth it. Each time we add a level of abstraction,
    we have more work to achieve to arrive at the same end goal. We need to decide
    whether each abstraction is viable in our own situations and build our application
    frameworks accordingly.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他人来说，这可能根本不值得。每次我们添加一个抽象层，我们就需要做更多的工作才能达到相同的目标。我们需要决定每个抽象在我们自己的情况下是否可行，并据此构建我们的应用程序框架。
- en: Summary
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've now investigated the benefit of having an application framework and started
    constructing our own. We've discovered a variety of different ways to encapsulate
    our required functionality into our framework and know which situations to use
    each in. After exploring a number of manager classes, we have also begun to expose
    functionality from external sources, but without being tied to them.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经调查了拥有应用程序框架的好处，并开始构建我们自己的框架。我们发现了很多种不同的方法来将所需的功能封装到我们的框架中，并且知道在什么情况下使用哪一种。在探索了多个管理类之后，我们也开始从外部来源公开功能，但不会与它们绑定。
- en: We've managed to maintain and improve the Separation of Concerns that our application
    requires and should now be able to detach the various application components and
    run them independently of each other. We are also able to provide our View designers
    with mock data at design time, while maintaining loose coupling at runtime.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设法维护和改进了应用程序所需的关注点分离，现在应该能够将各种应用程序组件分离出来，并独立于彼此运行。我们还能在设计时为我们的视图设计者提供模拟数据，同时在运行时保持松散耦合。
- en: In the next chapter, we will thoroughly examine the essential topic of data
    binding, one of the very few requirements of the MVVM pattern. We'll comprehensively
    cover the wide variety of binding syntax, both long and short hand notation, discover
    why bindings fail to work at certain times, and get a better understanding of
    how to display our data exactly the way we want.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将彻底研究数据绑定这一基本主题，它是MVVM模式极少数要求之一。我们将全面覆盖各种绑定语法，包括长手和短手表示法，发现为什么在某些时候绑定无法工作，并更好地理解如何以我们想要的方式显示我们的数据。
