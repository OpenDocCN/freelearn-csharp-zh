<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Worker Services Using .NET Core</h1>
                </header>
            
            <article>
                
<p>The latest version of .NET Core includes a simple and convenient way to implement background processes. Moreover, starting from version 3.0, it is possible to create new projects using an out-of-the-box template for worker services. .NET worker services are suitable for multiple use cases. Furthermore, the increasing adoption of cloud technologies and distributed systems <span>also </span>involves event-driven communication between services, which requires the implementation of background processes. This chapter walks through some of the concepts and use cases of the worker services tools provided by ASP.NET Core. We will also have a look at how to integrate the worker service capabilities of ASP.NET Core to consume the <kbd>ItemSoldOut</kbd> event queue implemented in the previous chapter.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li style="font-weight: 400">Introduction to worker services</li>
<li>Implementing a worker service using .NET Core</li>
<li>Deploying and running a worker on Docker</li>
<li>Extending the background services class</li>
</ul>
<p>By the end of this chapter, you will be able to implement <span>a worker service</span> and deploy it using Docker container technology.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing worker services</h1>
                </header>
            
            <article>
                
<p>.NET Core worker services can be really useful every time we need to perform a repetitive or background-running operation. In more detail, <span>they can be used in the application layer to enable </span>asynchronous operations and handle the events of an event-based architecture. <span>If every time you need to publish or listen for a message, you need to refresh data based on a schedule, or your application needs to queue a background work item, then you should probably use a worker service. Furthermore, with worker services, it is possible to run multiple background tasks on the same server without consuming a lot of resources.</span></p>
<p><span>The foundation of worker services in .NET Core is the </span><kbd>IHostedService</kbd><span> interface. The</span><span> out-of-the-box worker service template can be used as a guideline to start implementing our worker service project. More importantly, the <kbd>IHostedService</kbd> interface is implemented by a <kbd>BackgroundService</kbd> class, which is the base class we should extend to implement our worker service.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the worker services life cycle</h1>
                </header>
            
            <article>
                
<p>.NET Core uses the definition of the <kbd>BackgroundService</kbd> class to identify a worker service. The <kbd>BackgroundService</kbd> class exposes three methods that represent the life cycle stages of the worker service:</p>
<pre><span>namespace </span><span>Microsoft</span>.<span>Extensions</span>.<span>Hosting<br/></span>{<br/>    <span>public abstract class </span><span>BackgroundService </span>:<strong> <span>IHostedService</span>, </strong><span><strong>IDisposable</strong><br/></span><span>    </span>{<br/>        public virtual Task <strong>StartAsync</strong>(CancellationToken <br/>            cancellationToken);<br/><br/>        <span>protected abstract </span><span>Task </span><strong><span>ExecuteAsync</span></strong>(<span>CancellationToken <br/>            </span>stoppingToken);<br/>        <br/>        <span>public virtual async </span><span>Task </span><strong><span>StopAsync</span></strong>(<span>CancellationToken <br/>            </span>cancellationToken);<br/>    }<br/>}</pre>
<p>The preceding code is the abstract implementation of the <kbd>BackgroundService</kbd> class. The class implements both the <kbd>IHostedService</kbd> and <kbd>IDisposable</kbd> interfaces, and it exposes the following methods:</p>
<ul>
<li>The <kbd>StartAsync</kbd> method represents the first stage of the life cycle of the worker. This method is called when the host is ready to run the worker service. It accepts a <kbd>CancellationToken</kbd> type parameter, which can be used to cancel the running task.</li>
<li>The <kbd>ExecuteAsync</kbd> method contains the core implementation of the <kbd>BackgroundService</kbd> class. This method is called once the <kbd>IHostedService</kbd> starts, and it returns a <kbd>Task</kbd> type that represents the status of the <kbd>Task</kbd>.</li>
<li>The <kbd>StopAsync</kbd> method is called when the hosted <span>application </span>is stopped gracefully.</li>
</ul>
<p>This section provided an overview of the worker service life cycle methods. In the next section, we will see the hosting models available for the worker services in .NET Core. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hosting models</h1>
                </header>
            
            <article>
                
<p>The .NET Core worker template is nothing more than a common .NET Core app. Furthermore, we can run the <span>worker template </span>as a common console application. Besides, the worker template also provides the hosting APIs to run the worker as an always-running process. In the case of Windows, it is possible to run the worker using Windows services technology. In the case of Linux, the worker runs using <kbd>systemd</kbd>.</p>
<p>Furthermore, .NET Core provides two different NuGet packages to specify the host behavior of the worker: the <kbd>Microsoft.Extensions.Hosting.WindowsServices</kbd> package and the <span><kbd>Microsoft.Extensions.Hosting.Systemd</kbd> package, both available on NuGet.</span></p>
<p>The <span><kbd>Microsoft.Extensions.Hosting.WindowsServices</kbd> package provides an extension method called </span><kbd>UseWindowsService()</kbd>, which can be applied after the initialization of the host in the <kbd>Main</kbd> method of the <kbd>Program</kbd> class. The <kbd>UseWindowsService()</kbd> method sets <span><kbd>WindowsServiceLifetime</kbd> and uses the <em>Windows event log</em> as the default logging output. </span></p>
<p>If we choose to host our worker as a <kbd>systemd</kbd> service, we need to use the <kbd>Microsoft.Extensions.Hosting.Systemd</kbd> NuGet package. This package provides the <kbd>UseSystemd()</kbd> method, which can be applied in the same way as <kbd>UseWindowsService()</kbd>; in this case, our worker service will use the <kbd>SystemdLifetime</kbd> class, and it configures the logging to be compliant with the <kbd>systemd</kbd> format.</p>
<div class="packt_infobox">It is important to note that both the <span><kbd>UseWindowsService()</kbd> and <kbd>UseSystemd()</kbd> methods are executed only if the worker service is running respectively</span> as a Windows service an<span>d a</span> <kbd>systemd</kbd> service.<span> </span></div>
<p>Once we have discovered the different ways to host the worker service, we can proceed by applying these concepts to the concrete of a health-check process. Besides, we will also see how to run the worker on a Docker container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a health-checking worker</h1>
                </header>
            
            <article>
                
<p>The following section focuses on the implementation of a worker service. The use case we will cover is a health-checking worker of a generic web service. Furthermore, let's suppose that we want to check the health status of one of our web services regularly. This kind of check is usually performed at the end of the deployment pipeline, or once a service is deployed, to verify that the web service is up and running. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project structure overview</h1>
                </header>
            
            <article>
                
<p>This section gives you an overview of the worker template project provided out of the box by the .NET Core templating system. We will use this type of project to implement a health-check worker. First of all, let's start by creating a new project using the following CLI command:</p>
<pre><strong>dotnet new worker -n HealthCheckWorker</strong></pre>
<p>This command creates a new folder called<span> </span><kbd>HealthCheckWorker</kbd> and it creates all of the files needed by a basic worker service project. Let's have a look at the files created by the template<span> </span><kbd>dotnet new worker</kbd><span> </span>command executed previously.</p>
<p>Secondly, we can run the <kbd>tree</kbd> CLI command <span>(available both on macOS X and Windows)</span>, which shows the folder structure of the project previously created:</p>
<pre>.<br/>├── Program.cs<br/>├── Properties<br/>│   └── launchSettings.json<br/>├── Worker.cs<br/>├── HealthCheckWorker.csproj<br/>├── appsettings.Development.json<br/>├── appsettings.json<br/>├── bin<br/>│   └── Debug<br/>│       └── netcoreapp3.0<br/>└── obj<br/>  ├── Debug<br/>      └── netcoreapp3.0</pre>
<p class="mce-root">The<span> </span><kbd>Program.cs</kbd> file is the entry point of our worker service. As the <kbd>webapi</kbd> template, the worker template uses the<span> </span><kbd>Program.cs</kbd><span> </span>file to initialize and retrieve a new<span> </span><kbd>IHostBuilder</kbd><span> </span>instance by calling the <kbd>Host.CreateDefaultBuilder</kbd> and <kbd>ConfigureServices</kbd><span> </span>methods. The<span> </span><kbd>Main</kbd><span> </span>static method in the<span> </span><kbd>Program.cs</kbd><span> </span>file initializes a list of workers using the<span> </span><kbd>AddHostedService</kbd><span> </span>extension method:</p>
<pre><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>DependencyInjection</span>;<br/><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>Hosting</span>;<br/><br/><span>namespace </span><span>HealthCheckWorker<br/></span>{<br/>    <span>public class </span><span>Program</span><span><br/></span><span> </span><span>   </span>{<br/>        <span>public static void </span><span>Main</span>(<span>string</span>[] args)<br/>        {<br/>            <span>CreateHostBuilder</span>(args).<span>Build</span>().<span>Run</span>();<br/>        }<br/><br/>        <span>public static </span><span>IHostBuilder </span><span>CreateHostBuilder</span>(<span>string</span>[] args) =&gt;<br/>            <span>Host</span>.<span>CreateDefaultBuilder</span>(args)<br/>                .<span>ConfigureServices</span>((hostContext, services) =&gt;<br/>                {<br/>                    <strong>services.<span>AddHostedService</span>&lt;<span>Worker</span>&gt;();</strong><br/>                });<br/>    }<br/>}</pre>
<p>As previously mentioned, the preceding snippet of code uses <kbd>AddHostedService</kbd><span> </span>to initialize the<span> </span><kbd>Worker</kbd><span> </span>class created as a part of the default worker template. It is necessary to notice that, under the hood, <kbd>AddHostedService</kbd><span> </span>initializes the class with a<span> </span><kbd>Singleton</kbd><span> </span>life cycle. Therefore, we will have one instance of the worker for the whole execution time of the worker service. In the next section, we will go deep into the life cycle execution of a worker.</p>
<div class="packt_infobox">Another major characteristic that distinguishes a worker project from any other .NET Core project is the use of the<span> </span><kbd>Microsoft.NET.Sdk.Worker</kbd><span> </span>SDK. Furthermore, we should also notice that the<span> </span><kbd>*.csproj</kbd><span> </span>file refers to only one additional NuGet package that provides the hosting extension methods used by the<span> </span><kbd>Program</kbd><span> </span>class and the<span> </span><kbd>Main</kbd><span> </span>method:<span> </span><kbd>Microsoft.Extensions.Hosting</kbd>.</div>
<p>The next step is to create a new class that represents the configurations of the <kbd>HealthCheckWorker</kbd> project:</p>
<pre><span>namespace </span><span>HealthCheckWorker<br/></span>{<br/>    <span>public class </span><span>HealthCheckSettings<br/></span><span>    </span>{<br/>        <span>public string </span><span>Url </span>{ <span>get</span>; <span>set</span>; }<br/>        <span>public int </span><span>IntervalMs </span>{ <span>get</span>; <span>set</span>; }<br/>    }<br/>}</pre>
<p><kbd>HealthCheckSettings</kbd> will contain two attributes: the <kbd>Url</kbd> and <kbd>IntervalMs</kbd> attributes. The first attribute contains the HTTP URL of the health check address, specified in <kbd>appsettings.json</kbd><em>. </em>The <kbd>IntervalMs</kbd> attribute represents the frequency life cycle (in milliseconds) of the worker. </p>
<p>Furthermore, it is possible to use the configuration system of .NET Core to bind our configuration object at the execution of the <kbd>Main</kbd> method of the <kbd>Program.cs</kbd> file, using the following approach:</p>
<pre><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>DependencyInjection</span>;<br/><span>using </span><span>Microsoft</span>.<span>Extensions</span>.<span>Hosting</span>;<br/><br/><span>namespace </span><span>HealthCheckWorker<br/></span>{<br/>    <span>public class </span><span>Program<br/></span><span>    </span>{<br/>        <span>public static void </span><span>Main</span>(<span>string</span>[] args)<br/>        {<br/>            <span>CreateHostBuilder</span>(args).<span>Build</span>().<span>Run</span>();<br/>        }<br/><br/>        <span>public static </span><span>IHostBuilder </span><span>CreateHostBuilder</span>(<span>string</span>[] args) =&gt;<br/>            <span>Host</span>.<span>CreateDefaultBuilder</span>(args)<br/>                <strong>.<span>ConfigureServices</span>((hostContext, services) =&gt;</strong><br/><strong>                {</strong><br/><strong>                    <span>var </span>healthCheckSettings = hostContext</strong><br/><strong>                        .<span>Configuration<br/></span><span>                        </span>.<span>GetSection</span>(<span>"HealthCheckSettings"</span>)</strong><strong><br/>      <br/>                    services.<span>Configure</span>&lt;<span>HealthCheckSettings</span>&gt;<br/>                        (healthCheckSettings);</strong><br/><strong>                    services.<span>AddHostedService</span>&lt;<span>Worker</span>&gt;();</strong><br/><strong>                });</strong><br/>    }<br/>}</pre>
<p>The preceding code uses <kbd>hostContext</kbd> to retrieve the <kbd>Configuration</kbd> instance provided by .NET Core. By default, <kbd>hostContext</kbd> will be populated with the settings structure written in the <kbd>appsettings.json</kbd> file. Moreover, it is possible to use the <kbd>GetSection</kbd> method to retrieve the specific configuration section from our <kbd>appsettings.json</kbd> file and bind it to the <kbd>HealthCheckSettings</kbd> type.</p>
<p>After that, we can proceed with the concrete implementation of the <kbd>Worker</kbd> class. Furthermore, we are now able to inject the <kbd>HealthCheckSettings</kbd> type instance using the built-in dependency injection of .NET Core. The settings are injected using the <kbd>IOption</kbd> interface:</p>
<pre><span>public class </span><span>Worker </span>: <span>BackgroundService<br/></span><span>    </span>{<br/>        <span>private readonly </span><span>ILogger</span>&lt;<span>Worker</span>&gt; <span>_logger</span>;<br/>      <strong>  <span>private readonly </span><span>HealthCheckSettings </span><span>_settings</span>;</strong><br/>        <strong><span>private </span><span>HttpClient </span><span>_client</span>;</strong><br/><br/>        <span>public </span><span>Worker</span>(<span>ILogger</span>&lt;<span>Worker</span>&gt; logger, <br/><strong><span>        IOptions</span>&lt;<span>HealthCheckSettings</span>&gt; options</strong>)<br/>        {<br/>            <span>_logger </span>= logger;<br/>            <strong><span>_settings </span>= options.<span>Value</span>;</strong><br/>        }<br/>...</pre>
<p>The preceding code defines the attributes of the <kbd>Worker</kbd> class. As mentioned, the class implements an <kbd>_settings</kbd> attribute of the <kbd>HealthCheckSettings</kbd> <span>type</span><span> </span><span>initialized using the constructor injection technique. Moreover, we can also see an</span> <kbd>HttpClient</kbd> <span>attribute, which will be initialized by the</span> <kbd>StartAsync</kbd> <span>method exposed by the</span> <kbd>BackgroundService</kbd> <span>class, and it is used in the</span> <kbd>ExecuteAsync</kbd> <span>method:</span></p>
<pre><span>public class </span><span>Worker </span>: <span>BackgroundService<br/></span><span>{</span><br/>    ...<br/><br/><strong>    <span>public override </span><span>Task </span><span>StartAsync</span>(<span>CancellationToken </span>cancellationToken)</strong><br/><strong>    {</strong><br/><strong>        <span>_client </span>= <span>new </span><span>HttpClient</span>();</strong><br/><strong>        <span>return base</span>.<span>StartAsync</span>(cancellationToken);</strong><br/><strong>    }</strong><br/><br/><strong>    <span>protected override async </span><span>Task </span><span>ExecuteAsync</span>(<span>CancellationToken <br/></span>    stoppingToken)</strong><br/><strong>    {</strong><br/><strong>        <span>while </span>(!stoppingToken.<span>IsCancellationRequested</span>)</strong><br/><strong>        {</strong><br/><strong>            <span>var </span>result = <span>await </span><span>_client</span>.<span>GetAsync</span>(<span>_settings</span>.<span>Url</span>);</strong><br/><br/><strong>            <span>if </span>(result.<span>IsSuccessStatusCode</span>)</strong><br/><strong>                <span>_logger</span>.<span>LogInformation</span>(<span>$</span><span>"The web service is up. <br/>                HTTP {</span>result.<span>StatusCode</span><span>}"</span>);</strong><br/><strong>            <br/>            <span>await </span><span>Task</span>.<span>Delay</span>(<span>_settings</span>.<span>IntervalMs</span>, stoppingToken);</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/><br/>    ...<br/>}</pre>
<p>After the initialization of the client, the <kbd>ExecuteAsync</kbd> method implements a <kbd>while</kbd> loop that will continue until the <kbd>stoppingToken</kbd> requests the cancellation of the process. The core part of the loop uses the <kbd>GetAsync</kbd> method of <kbd>HttpClient</kbd> to check whether the health check route returns an HTTP status message. Finally, the code calls <kbd>Task.Delay</kbd> with the <kbd>IntervalMs</kbd> property populated with the <kbd>_settings</kbd> instance. </p>
<p><span>As the last step</span>, the <kbd>Worker</kbd> class overrides the <kbd>StopAsync</kbd> method exposed by the <kbd>BackgroundService</kbd> class:</p>
<pre><span>public class </span><span>Worker </span>: <span>BackgroundService<br/></span><span>{</span><br/>    ...<br/><br/><strong>    <span>public override </span><span>Task </span><span>StopAsync</span>(<span>CancellationToken </span>cancellationToken)</strong><br/><strong>    {</strong><br/><strong>        <span>_client</span>.<span>Dispose</span>();</strong><br/><strong>        <span>return base</span>.<span>StopAsync</span>(cancellationToken);</strong><br/><strong>    }</strong><br/><br/><span>}</span></pre>
<p>The <kbd>StopAsync</kbd> method executes the <kbd>HttpClient</kbd> instance disposition by calling the <kbd>Dispose()</kbd> method, and it calls <kbd>base.StopAsync(cancellationToken)</kbd> of the base <kbd>BackgroundService</kbd> class. </p>
<div class="packt_infobox">We should notice that the <kbd>StartAsync</kbd> and <kbd>StopAsync</kbd> methods always call the parent methods using the <kbd>base</kbd> keyword. Furthermore, in our case, we need to hold the behavior of the base <kbd>BackgroundService</kbd> class.</div>
<p>The next part of this chapter will be focused on the execution of the worker on a Docker container. We will see how to configure the <kbd>Dockerfile</kbd>, and deploy and run the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running a worker service on Docker</h1>
                </header>
            
            <article>
                
<p>This section is focused on the deployment step of the .NET worker template. We will proceed by running our service on a Docker Linux image. As we have already seen in <a href="d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml">Chapter 12</a>, <em>The Containerization of Services</em>, we will use Docker to run the application in a container.</p>
<p>Let's start by configuring the <kbd>Dockerfile</kbd> in the project folder:</p>
<pre>FROM mcr.microsoft.com/dotnet/core/runtime:3.0 AS base<br/>WORKDIR /app<br/><br/># Step 1 - Building the project<br/>FROM mcr.microsoft.com/dotnet/core/sdk:3.0 AS build<br/>WORKDIR /src<br/>COPY ["HealthCheckWorker.csproj", "./"]<br/>RUN dotnet restore "./HealthCheckWorker.csproj"<br/>COPY . .<br/>WORKDIR "/src/."<br/>RUN dotnet build "HealthCheckWorker.csproj" -c Release -o /app/build<br/><br/># Step 2 - Publish the project<br/>FROM build AS publish<br/>RUN dotnet publish "HealthCheckWorker.csproj" -c Release -o /app/publish<br/><br/># Step 3 - Run the project<br/>FROM base AS final<br/>WORKDIR /app<br/>COPY --from=publish /app/publish .<br/>ENTRYPOINT ["dotnet", "HealthCheckWorker.dll"]</pre>
<p>The preceding code describes the container build and deployment process for our .NET Core worker application. The <kbd>Dockerfile</kbd> instructions can be grouped into five steps:</p>
<ol>
<li>The first step executes the build of the project using the <kbd>dotnet/core/sdk</kbd> Docker image:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li><span>First of all, it sets the working directory as </span><kbd>/src</kbd><span> and copies the files in the project folder.</span></li>
<li>Secondly, it executes the <kbd>dotnet restore</kbd> <span>and</span> <kbd>dotnet build</kbd> <span>commands.</span></li>
</ul>
</li>
</ul>
<ol start="2">
<li>The second step runs the <kbd>dotnet publish</kbd> command using the <kbd>Release</kbd> configuration in the <kbd>/app/publish</kbd> folder.</li>
<li>The third step uses the <kbd>dotnet/core/runtime</kbd> Docker image to run the result of the previously executed <kbd>dotnet publish</kbd> using the <kbd>dotnet</kbd> CLI command.</li>
<li>It is possible to build the Docker image using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker build --rm -f "Dockerfile" -t healthcheckworker:latest</strong> </pre>
<ol start="5">
<li>Furthermore, we can run the previously built image using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker run --rm -d healthcheckworker:latest</strong></pre>
<p>The preceding command runs the Docker container and, consequently, the worker service process. The worker service will perform an HTTP <kbd>GET</kbd> request to the URL configured in the <kbd>appsettings.json</kbd> file of the project by applying throttling, also specified in the <kbd>appsettings.json</kbd> file.</p>
<div class="packt_infobox">The previously mentioned <kbd>Dockerfile</kbd> uses a multi-stage build approach and some other techniques to build the Docker image used to run the project. These concepts, and more, are described in detail in <span class="cdp-organizer-chapter-number"><a href="d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml">Chapter 12</a>,</span><span> <em>The </em></span><span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label"><em>Containerization of Services</em>.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming the sold-out event</h1>
                </header>
            
            <article>
                
<p>The sold-out event we implemented in <a href="8f70e186-50f1-4d55-99e6-026c73d5bb96.xhtml">Chapter 13</a>, <em>Service Ecosystem Patterns,</em> provides the information on the items that are not available in the catalog. Furthermore, we can consume this event through the use of the <kbd>BackgroundService</kbd> type capabilities we described in this chapter. The cart service will implement a sold-out handler that will handle and remove the item IDs <span>that are not available </span>from the Redis instance. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a sold-out handler</h1>
                </header>
            
            <article>
                
<p>Let's start by creating a handler that<span> </span>manages<span> </span>the sold-out condition of a product in the cart service. First of all, we should proceed by adding the <kbd>RabbitMQ.Client</kbd><span> </span>package to the<span> </span><kbd>Cart.Domain</kbd><span> </span>project by executing the following command:</p>
<pre><strong>dotnet add ./src/Cart.Domain package RabbitMQ.Client</strong></pre>
<p>We can continue by defining a class<span> </span>that<span> </span>represents the sold-out event that's used by the cart service in a new project that will contain all of the events. Therefore, we will proceed by creating a new<span> </span><kbd>ItemSoldOutEvent</kbd><span> </span>type, which represents a sold-out event:</p>
<pre>using MediatR;<br/><br/>namespace Cart.Domain.Events<br/>{<br/>    public class ItemSoldOutEvent : IRequest&lt;Unit&gt;<br/>    {<br/>        public string Id { get; set; }<br/>    }<br/>}</pre>
<p>The <kbd>ItemSoldOutEvent</kbd> type contains a reference<span> </span><span>to <kbd>Id</kbd> of the item that's sold out</span>. The type will be used to deserialize the content of the queue into a strongly typed instance and send a message through the MediatR instance. As we did for the configurations of the catalog service, we will also need an analog class that represents the RabbitMQ configurations in the <kbd>Cart.Infrastructure</kbd> project:</p>
<pre><span>namespace </span><span>Cart</span><span>.</span><span>Infrastructure</span><span>.</span><span>Configurations<br/></span><span>{</span><span><br/></span><span>    </span><span>public class </span><span>EventBusSettings<br/></span><span>    </span><span>{<br/></span><span>        </span><span>public string </span><span>HostName </span><span>{ </span><span>get</span><span>; </span><span>set</span><span>; }<br/></span><span>        </span><span>public string </span><span>User </span><span>{ </span><span>get</span><span>; </span><span>set</span><span>; }<br/></span><span>        </span><span>public string </span><span>Password </span><span>{ </span><span>get</span><span>; </span><span>set</span><span>; }<br/></span><span>        </span><span>public string </span><span>EventQueue </span><span>{ </span><span>get</span><span>; </span><span>set</span><span>; }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The </span><kbd>EventBusSettings</kbd><span> type defined previously describes</span> <kbd>HostName</kbd><span> of the RabbitMQ instance,</span> <kbd>User</kbd><span> and</span> <kbd>Password</kbd><span> of the user, and the </span><kbd>EventQueue</kbd><span> name to use to push messages. </span>Furthermore, we can proceed by defining the mediator handler for consuming the <kbd>ItemSoldOutEvent</kbd> events by defining a new class in the<span> </span><kbd>Cart.Domain</kbd> project:</p>
<pre><span>using </span><span>System</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Linq</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Threading</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Threading</span><span>.</span><span>Tasks</span><span>;<br/></span><span>using </span><span>Cart</span><span>.</span><span>Domain</span><span>.</span><span>Entities</span><span>;<br/></span><span>using </span><span>Cart</span><span>.</span><span>Domain</span><span>.</span><span>Events</span><span>;<br/></span><span>using </span><span>Cart</span><span>.</span><span>Domain</span><span>.</span><span>Repositories</span><span>;<br/></span><span>using </span><span>MediatR</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Cart</span><span>.</span><span>Domain</span><span>.</span><span>Handlers</span><span>.</span><span>Cart<br/></span><span>{<br/></span><span>    </span><span>public class </span><span>ItemSoldOutEventHandler </span>: <br/>        <span>IRequestHandler</span><span>&lt;</span><span>ItemSoldOutEvent</span><span>&gt;<br/></span><span>    {<br/></span><span>        </span><span>private readonly </span><span>ICartRepository </span><span>_cartRepository</span><span>;<br/></span><span><br/></span><span>        </span><span>public </span><span>ItemSoldOutEventHandler</span><span>(</span><span>ICartRepository </span><span>cartRepository)<br/></span><span>        {<br/></span><span>            </span><span>_cartRepository</span> <span>= cartRepository;<br/></span><span>        }<br/></span><span>        <br/></span><span>        </span><span>public async </span><span>Task</span><span>&lt;</span><span>Unit</span><span>&gt; </span><span>Handle</span><span>(</span><span>ItemSoldOutEvent </span><span>@event, <br/>            </span><span>CancellationToken </span><span>cancellationToken)<br/></span><span>        {<br/></span><span>            </span><span>var </span><span>cartIds = </span><span>_cartRepository</span><span>.</span><span>GetCarts</span><span>().</span><span>ToList</span><span>();<br/></span><span><br/></span><span>            </span><span>var </span><span>tasks = cartIds.</span><span>Select</span><span>(</span><span>async </span><span>x </span>=&gt;<br/>            <span>{<br/></span><span>                </span><span>var </span><span>cart = </span><span>await </span><span>_cartRepository</span><span>.</span><span>GetAsync</span><span>(</span><span>new </span><span>Guid</span><span>(x));<br/></span><span>                </span><span>await </span><span>RemoveItemsInCart</span><span>(@event.</span><span>Id</span><span>, cart);<br/></span><span>            });<br/></span><span><br/></span><span>            </span><span>await </span><span>Task</span><span>.</span><span>WhenAll</span><span>(tasks);<br/></span><span>            <br/></span><span>            </span><span>return </span><span>Unit</span><span>.</span><span>Value</span><span>;<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>private async </span><span>Task </span><span>RemoveItemsInCart</span><span>(</span><span>string </span><span>itemToRemove, <br/>            </span><span>CartSession </span><span>cartSessionSession)<br/></span><span>        {<br/></span><span>            </span><span>if </span><span>(</span><span>string</span><span>.</span><span>IsNullOrEmpty</span><span>(itemToRemove)) </span><span>return</span><span>;<br/></span><span><br/></span><span>            </span><span>var </span><span>toDelete = cartSessionSession</span>?<span>.</span><span>Items</span>?<span>.</span><span>Where</span><span>(x </span>=&gt; <br/>                <span>x.</span><span>CartItemId</span><span>.</span><span>ToString</span><span>() ==           <br/>                     itemToRemove).</span><span>ToList</span><span>();<br/></span><span><br/></span><span>            </span><span>if </span><span>(toDelete == </span><span>null </span><span>|| toDelete.</span><span>Count </span><span>== </span><span>0</span><span>) </span><span>return</span><span>;<br/></span><span><br/></span><span>            </span><span>foreach </span><span>(</span><span>var </span><span>item </span><span>in </span><span>toDelete) <br/>                cartSessionSession.</span><span>Items</span>?<span>.</span><span>Remove</span><span>(item);<br/></span><span><br/></span><span>            </span><span>await </span><span>_cartRepository</span><span>.</span><span>AddOrUpdateAsync</span><span>(cartSessionSession);<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The previous <kbd>ItemSoldOutEventHandler</kbd> class implements the <kbd>IRequestHandler&lt;T&gt;</kbd> interface that's provided by the MediatR package. This interface contains the <kbd>Handle</kbd> method, which is the main entry point of the handler. A new <kbd>ItemSoldOutEventHandler</kbd> instance will be<span><span> executed</span></span> when an event of the <kbd>ItemSoldOutEvent</kbd> type is received by the cart service. <span><kbd>ItemSoldOutEventHandler</kbd> depends on <kbd>ICartRepository</kbd>. Furthermore, the <kbd>RemoveItemsInCart</kbd> method retrieves all of the carts stored in our repository, and it removes the sold-out items every time it receives a message of the <kbd>ItemSoldOutEvent</kbd></span><span> </span><span>type</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the sold-out process</h1>
                </header>
            
            <article>
                
<p>It is possible to check the<span> </span>sold-out process by testing<span> </span><kbd>ItemSoldOutHandler</kbd>. The handler will be tested with the same approach we saw for the other handlers:</p>
<pre><span>using </span><span>System</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Linq</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Threading</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Threading</span><span>.</span><span>Tasks</span><span>;<br/></span><span>using </span><span>Cart</span><span>.</span><span>Domain</span><span>.</span><span>Events</span><span>;<br/></span><span>using </span><span>Cart</span><span>.</span><span>Domain</span><span>.</span><span>Handlers</span><span>.</span><span>Cart</span><span>;<br/></span><span>using </span><span>Cart</span><span>.</span><span>Fixtures</span><span>;<br/></span><span>using </span><span>Shouldly</span><span>;<br/></span><span>using </span><span>Xunit</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Cart</span><span>.</span><span>Domain</span><span>.</span><span>Tests</span><span>.</span><span>Handlers</span><span>.</span><span>Events<br/></span><span>{<br/></span><span>    </span><span>public class </span><span>ItemSoldOutEventHandlerTests </span>: <span>IClassFixture</span><span>&lt;</span><span>CartContextFactory</span><span>&gt;<br/></span><span>    {<br/></span><span>        </span><span>private readonly </span><span>CartContextFactory </span><span>_contextFactory</span><span>;<br/></span><span><br/></span><span>        </span><span>public </span><span>ItemSoldOutEventHandlerTests</span><span>(</span><span>CartContextFactory <br/>            </span><span>cartContextFactory)<br/></span><span>        {<br/></span><span>            </span><span>_contextFactory </span><span>= cartContextFactory;<br/></span><span>        }<br/></span><span><br/></span><span>        [</span><span>Fact</span><span>]<br/></span><span>        </span><span>public async </span><span>Task </span><span>should_not_remove_records_when<em>soldout<br/>            </em>message_contains_not_existing_id</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>var </span><span>repository = </span><span>_contextFactory</span><span>.</span><span>GetCartRepository</span><span>();<br/></span><span>            </span><span>var </span><span>itemSoldOutEventHandler = </span><span>new <br/>                </span><span>ItemSoldOutEventHandler</span><span>(repository);<br/></span><span>            </span><span>var </span><span>found = </span><span>false</span><span>;<br/></span><span><br/></span><span>            </span><span>await </span><span>itemSoldOutEventHandler.</span><span>Handle</span><span>(</span><span>new </span><span>ItemSoldOutEvent </span><span>{ <br/>                </span><span>Id </span><span>= </span><span>Guid</span><span>.</span><span>NewGuid</span><span>().</span><span>ToString</span><span>() }, </span><span><br/>                   CancellationToken</span><span>.</span><span>None</span><span>);<br/></span><span><br/></span><span>            </span><span>var </span><span>cartsIds = repository.</span><span>GetCarts</span><span>();<br/></span><span><br/></span><span>            </span><span>foreach </span><span>(</span><span>var </span><span>cartId </span><span>in </span><span>cartsIds)<br/></span><span>            {<br/></span><span>                </span><span>var </span><span>cart = </span><span>await </span><span>repository.</span><span>GetAsync</span><span>(</span><span>new </span><span>Guid</span><span>(cartId));<br/></span><span>                found = cart.</span><span>Items</span><span>.</span><span>Any</span><span>(i </span>=&gt; <span>i.</span><span>CartItemId</span><span>.</span><span>ToString</span><span>() == <br/>                    </span><span>"be05537d-5e80-45c1-bd8c-<br/>                     aa21c0f1251e"</span><span>);<br/></span><span>            }<br/></span><span><br/></span><span>            found.</span><span>ShouldBeTrue</span><span>();<br/></span><span>        }<br/><br/></span><span>        ...</span><span><br/></span><span>    }<br/></span><span>}</span></pre>
<p>The <span><kbd>ItemSoldOutEventHandlerTests</kbd> class uses the <kbd>CartContextFactory</kbd> class to initialize a new repository in each test method using the <kbd>_contextFactory.GetCartRepository();</kbd> method. Furthermore, the </span><span><kbd>should_not_remove_records_when_soldout_message_contains_not_existing_id</kbd> </span><span>test method checks that nothing breaks if the <kbd>ItemSoldOutEvent</kbd> instance has a non-existent ID. On the other hand, the <kbd>should_remove_records_when_soldout_messages_contains_existing_ids</kbd> test method checks that <kbd>ItemSoldOutEventHandler</kbd> deletes the item in the basket when the <kbd>ItemSoldOutEvent</kbd> instance contains an existing ID:</span></p>
<pre>...<br/>        [Fact]<br/>        public async Task should_remove_records_when<em>soldout<br/>            </em>messages_contains_existing_ids()<br/>        {<br/>            var itemSoldOutId = "be05537d-5e80-45c1-bd8c-aa21c0f1251e";<br/>            var repository = _contextFactory.GetCartRepository();<br/>            var itemSoldOutEventHandler = new <br/>                ItemSoldOutEventHandler(repository);<br/>            var found = false;<br/><br/>            await itemSoldOutEventHandler.Handle(new ItemSoldOutEvent { <br/>              Id = itemSoldOutId }, <br/>                CancellationToken.None);<br/><br/>            foreach (var cartId in repository.GetCarts())<br/>            {<br/>                var cart = await repository.GetAsync(new Guid(cartId));<br/>                found = cart.Items.Any(i =&gt; i.CartItemId.ToString() == <br/>                    itemSoldOutId);<br/>            }<br/><br/>            found.ShouldBeFalse();<br/>        }<br/>    }<br/>}</pre>
<p><span>The second test method provides an existing item ID and verifies the handle method by checking whether the process has effectively removed the items. </span>Now that we have verified the behavior of<span> </span><span><kbd>ItemSoldOutHandler</kbd>, we can proceed by configuring and registering the event bus instance.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the background service</h1>
                </header>
            
            <article>
                
<p>Now that we have defined<span> </span>the<span> </span>event bus abstraction, we can proceed by creating a new <kbd>BackgroundService</kbd> type that will use the <kbd>IMediator</kbd> interface to dispatch the sold-out messages. This book uses RabbitMQ because it is open source and easy to configure but keep in mind that there are tons of products and technologies related to this topic. <span>Before continuing with the implementation o</span>f the background service,<span> </span><span>it is necessary to add some packages to the</span><span> </span><kbd>Cart.Infrastructure</kbd><span> </span><span>project:</span></p>
<pre><strong>dotnet add package RabbitMQ.Client</strong></pre>
<p>Furthermore, we can proceed by creating a new class that extends the <kbd>BackgroundService</kbd> type:</p>
<pre>using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Cart.Domain.Events;<br/>using Cart.Infrastructure.Configurations;<br/>using MediatR;<br/>using Microsoft.Extensions.Hosting;<br/>using Microsoft.Extensions.Logging;<br/>using Microsoft.Extensions.Options;<br/>using Newtonsoft.Json;<br/>using RabbitMQ.Client;<br/>using RabbitMQ.Client.Events;<br/><br/>namespace Cart.Infrastructure.BackgroundServices<br/>{<br/>    public class ItemSoldOutBackgroundService : BackgroundService<br/>    {<br/>        private readonly IMediator _mediator;<br/>        private readonly ILogger&lt;ItemSoldOutBackgroundService&gt; _logger;<br/>        private readonly EventBusSettings _options;<br/>        private readonly IModel _channel;<br/><br/>        public ItemSoldOutBackgroundService( IMediator mediator,<br/>            EventBusSettings options, ConnectionFactory factory, <br/>                ILogger&lt;ItemSoldOutBackgroundService&gt; logger)<br/>        {<br/>            _options = options;<br/>            _logger = logger;<br/>            _mediator = mediator;<br/><br/>            try<br/>            {<br/>              <strong>  var connection = factory.CreateConnection();</strong><br/><strong>                _channel = connection.CreateModel();</strong><br/>            }<br/>            catch (Exception e)<br/>            {<br/>                _logger.LogWarning("Unable to initialize the event bus: <br/>                    {message}", e.Message);<br/>            }<br/>        }<br/><br/>        ...<br/>    }<br/>}</pre>
<p>The preceding snippet defines the <kbd>ItemSoldOutBackgroundService</kbd> type. The class extends the <kbd>BackgroundService</kbd> base class exposed by the <kbd>Microsoft.Extensions.Hosting</kbd> <span>namespace. The constructor injects the <kbd>IMediator</kbd> interface to dispatch the collected events to the <kbd>ItemSoldOutEventHandler</kbd> type. Furthermore, it also defines the attribute of the <kbd>IModel</kbd> </span><span>type </span><span>that will be populated by the <kbd>ConnectionFactory</kbd> type injected in the constructor. The <kbd>_channel</kbd> attribute will be used by the </span><kbd>ExecuteAsync</kbd> <span>method provided by the</span> <kbd>BackgroundService</kbd> <span>class to dispatch the events. Let's proceed by overriding the</span> <kbd>ExecuteAsync</kbd> <span>method:</span></p>
<pre><span>using </span><span>MediatR</span><span>;<br/></span><span>using </span><span>Microsoft</span><span>.</span><span>Extensions</span><span>.</span><span>Hosting</span><span>;</span><span><br/></span><span>using </span><span>Newtonsoft</span><span>.</span><span>Json</span><span>;<br/></span><span>using </span><span>RabbitMQ</span><span>.</span><span>Client</span><span>;<br/></span><span>using </span><span>RabbitMQ</span><span>.</span><span>Client</span><span>.</span><span>Events</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Cart</span><span>.</span><span>Infrastructure</span><span>.</span><span>BackgroundServices<br/></span><span>{<br/></span><span>    </span><span>public class </span><span>ItemSoldOutBackgroundService </span>: <span>BackgroundService<br/></span><span>    </span><span>{<br/></span><span>         ...<br/></span><span><br/></span><span>        </span><span>protected override </span><span>Task </span><span>ExecuteAsync</span><span>(</span><span>CancellationToken <br/>            </span><span>stoppingToken)<br/></span><span>        {<br/></span><span>            stoppingToken.</span><span>ThrowIfCancellationRequested</span><span>();<br/></span><span><br/></span><span>            </span><span>var </span><span>consumer = </span><span>new </span><span>EventingBasicConsumer</span><span>(</span><span>_channel</span><span>);<br/>     <br/></span><span>            consumer.</span><span>Received </span><span>+= </span><span>async </span><span>(ch, ea) </span>=&gt;<br/>            <span>{<br/></span><span>                </span><span>var </span><span>content = </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>Encoding</span><span>.</span><span>UTF8</span><span>.<br/>                    </span><span>GetString</span><span>(ea.</span><span>Body</span><span>);<br/></span><span>                </span><span>var </span><span>@event = </span><span>JsonConvert</span><span>.</span><span>DeserializeObject<br/>                    </span><span>&lt;</span><span>ItemSoldOutEvent</span><span>&gt;(content);<br/></span><span><br/></span><span>                </span><span>await </span><span>_mediator</span><span>.</span><span>Send</span><span>(@event, stoppingToken);<br/></span><span>                </span><span>_channel</span><span>.</span><span>BasicAck</span><span>(ea.</span><span>DeliveryTag</span><span>, </span><span>false</span><span>);<br/></span><span>            };<br/></span><span><br/></span><span>            </span><span>try<br/></span><span>            </span><span>{<br/>                consumer.Model.QueueDeclare(_settings.EventQueue, true, <br/>                    false); </span><span>                                        <br/></span><span>                _channel</span><span>.</span><span>BasicConsume</span><span>(</span><span>_options</span><span>.</span><span>EventQueue</span><span>, </span><span>false</span><span>, <br/>                    consumer);<br/></span><span>            }<br/></span><span>            </span><span>catch </span><span>(</span><span>Exception </span><span>e)<br/></span><span>            {<br/></span><span>                </span><span>_logger</span><span>.</span><span>LogWarning</span><span>(</span><span>"Unable to consume the event bus: <br/>                    {message}"</span><span>, e.</span><span>Message</span><span>);<br/></span><span>            }<br/></span><span><br/></span><span>            </span><span>return </span><span>Task</span><span>.</span><span>CompletedTask</span><span>;<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The preceding snippet uses the <kbd>_channel</kbd> attribute to initialize a new <kbd>EventingBasicConsumer</kbd> instance. For each received message, it deserializes the <kbd>Body</kbd> attribute into an <kbd>ItemSoldOutEvent</kbd> type and it sends the event to the <kbd>IMediator</kbd> instance using the <kbd>Send</kbd> method. Finally, it activates the consuming process by using the <kbd>EventQueue</kbd> name provided by the <kbd>EventBusSettings</kbd> type. Also, in this case, the consumption process is wrapped using a try-catch to isolate the process in the event of failure.</p>
<p>Before we can use RabbitMQ, it is necessary to configure the client so that we connect to the right event bus instance. Let's start by creating a new extension method in the<span> </span><kbd>Cart.Infrastructure</kbd><span> </span>project, which can be found under the<span> </span><kbd>Extensions</kbd><span> </span>folder:</p>
<pre><span>using </span><span>Cart</span><span>.</span><span>Infrastructure</span><span>.</span><span>Configurations</span><span>;<br/></span><span>using </span><span>Microsoft</span><span>.</span><span>Extensions</span><span>.</span><span>Configuration</span><span>;<br/></span><span>using </span><span>Microsoft</span><span>.</span><span>Extensions</span><span>.</span><span>DependencyInjection</span><span>;<br/></span><span>using </span><span>RabbitMQ</span><span>.</span><span>Client</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Cart</span><span>.</span><span>Infrastructure</span><span>.</span><span>Extensions<br/></span><span>{<br/></span><span>    </span><span>public static class </span><span>EventsExtensions<br/></span><span>    </span><span>{<br/></span><span>        </span><span>public static </span><span>IServiceCollection </span><span>AddEventBus</span><span>(</span><span>this <br/>            </span><span>IServiceCollection </span><span>services, </span><span>IConfiguration    <br/></span><span>         configuration)<br/></span><span>        {<br/></span><span>            </span><span>var </span><span>config = </span><span>new </span><span>EventBusSettings</span><span>();<br/></span><span>            configuration.</span><span>Bind</span><span>(</span><span>"EventBus"</span><span>, config);<br/></span><span>            services.</span><span>AddSingleton</span><span>(config);<br/></span><span><br/></span><span>            </span><span>ConnectionFactory </span><span>factory = </span><span>new </span><span>ConnectionFactory<br/></span><span>            </span><span>{<br/></span><span>                </span><span>HostName </span><span>= config.</span><span>HostName</span><span>,<br/></span><span>                </span><span>UserName </span><span>= config.</span><span>User</span><span>,<br/></span><span>                </span><span>Password </span><span>= config.</span><span>Password<br/></span><span>            </span><span>};<br/></span><span><br/></span><span>            services.</span><span>AddSingleton</span><span>(factory);<br/></span><span><br/></span><span>            </span><span>return </span><span>services;<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The previous definition<span> </span>implements<span> </span>an extension method bound with the<span> </span><kbd>IServiceCollection</kbd> interface, which is provided by the dependency injection system of ASP.NET Core. It is used in the<span> </span><kbd>Startup</kbd><span> </span>class to connect<span> </span>to RabbitMQ.<em> </em>The<span> </span><kbd>AddEventBus</kbd><span> </span>method initializes the<span> </span><kbd>ConnectionFactory</kbd><span> </span>class by passing the parameter of RabbitMQ. </p>
<p>Finally, we can proceed by activating the background service by adding the following extension methods to the <kbd>ConfigureServices</kbd> method of the <kbd>Startup</kbd> class:</p>
<pre><span>using </span><span>System</span><span>;<br/></span><span>...<br/><br/></span><span>namespace </span><span>Cart</span><span>.</span><span>API<br/></span><span>{<br/></span><span>    </span><span>public class </span><span>Startup<br/></span><span>    </span><span>{<br/></span><span>     </span><span><br/></span><span>        </span><span>public void </span><span>ConfigureServices</span><span>(</span><span>IServiceCollection </span><span>services)<br/></span><span>        {</span><span><br/></span><strong><span>            services<br/></span><span>                   ...</span><span><br/></span><span>                .</span><span>AddEventBus</span><span>(</span><span>Configuration</span><span>)<br/></span><span>                .</span><span>AddHostedService</span><span>&lt;</span><span>ItemSoldOutBackgroundService</span><span>&gt;();</span></strong><span><br/></span><span>        }<br/><br/>        ...</span><span><br/></span><span>    }<br/></span><span>}</span></pre>
<p>The <kbd>AddEventBus</kbd> method adds all of the dependencies needed by the consumption process of the sold-out events to the dependency injection. Also, the <kbd>AddHostedService</kbd> method registers <kbd>ItemSoldOutBackgroundService</kbd> as the <kbd>IHostedService</kbd> type. Finally, to use the event bus, we can proceed by defining the connection information in the <kbd>appsettings.json</kbd> file of the <kbd>Cart.API</kbd> project, as follows:</p>
<pre><span>{<br/></span><span>...<br/></span><span>  </span><span>"EventBus"</span><span>: {<br/></span><span>    </span><span>"HostName"</span><span>: </span><span>"catalog_esb"</span><span>,<br/></span><span>    </span><span>"User"</span><span>: </span><span>"guest"</span><span>,<br/></span><span>    </span><span>"Password"</span><span>: </span><span>"guest"</span><span>,<br/></span><span>    </span><span>"EventQueue"</span><span>: </span><span>"ItemSoldOut"<br/></span><span>  </span><span>}<br/></span><span>}<br/></span></pre>
<p>The connection parameters point to the <kbd>catalog_esb</kbd> instance defined in the <kbd>docker-compose.yml</kbd> file defined in the catalog service. Furthermore, the <span><kbd>ItemSoldOutBackgroundService</kbd> class will process the message in the <kbd>ItemSoldOut</kbd> queue and trigger the removal of the items.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter described how you can use the .NET Core worker template to implement a continuously running task. .NET Core workers are really useful in distributed systems to perform all of the asynchronous and event-based computations without an increase in the <span>load of the server.</span> </p>
<p>The integration with Windows services and <kbd>systemd</kbd> <span>also </span>provides an efficient way to deploy and to run the worker. This chapter has given you an overview of the .NET Core worker service hosting models, and it showed how to set up and implement a worker service using .NET Core and how to run it on Docker. Finally, we saw how to integrate the <kbd>BackgroundService</kbd> class capabilities with the previously implemented item sold-out message integration.</p>
<p>The next chapter will cover some of the common security practices provided and implemented by .NET Core.</p>


            </article>

            
        </section>
    </body></html>