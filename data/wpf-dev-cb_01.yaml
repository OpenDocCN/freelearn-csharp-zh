- en: WPF Fundamentals
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 基础
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Installing WPF Workload with Visual Studio 2017
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2017 安装 WPF 工作负载
- en: Creating WPF applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 WPF 应用程序
- en: Creating and navigating from one window to another
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个窗口创建和导航到另一个窗口
- en: Creating and navigating from one page to another
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和导航到另一页
- en: Creating a dialog box
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对话框
- en: Creating ownership between windows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建窗口之间的所有权
- en: Creating a single instance application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单实例应用程序
- en: Passing arguments to WPF applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 WPF 应用程序传递参数
- en: Handling unhandled exceptions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理未处理的异常
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The **Windows Presentation Foundation** (**WPF**) provides developers with a
    unified programming model to build dynamic, data-driven desktop applications for
    Windows. It was first released in 2006 along with .NET 3.0\. It is part of the
    .NET Framework itself.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 展示基础**（**WPF**）为开发者提供了一个统一的编程模型，用于构建动态、数据驱动的 Windows 桌面应用程序。它首次于
    2006 年与 .NET 3.0 一起发布。它是 .NET 框架本身的一部分。'
- en: WPF is a graphical subsystem, for rendering rich **user interfaces** (UIs),
    and is a resolution-independent framework that uses a vector-based rendering engine
    in the **Extensible Application Markup Language** (**XAML**) to create stunning
    user interfaces. It supports a broad set of features that includes application
    models, controls, layouts, graphics, resources, security, and more.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 是一个图形子系统，用于渲染丰富的 **用户界面**（UI），是一个基于矢量的渲染引擎，在 **可扩展应用程序标记语言**（**XAML**）中创建令人惊叹的用户界面。它支持广泛的功能，包括应用程序模型、控件、布局、图形、资源、安全性等。
- en: The runtime libraries for it to execute have been included with Windows since
    Windows Vista and Windows Server 2008\. If you are using Windows XP with SP2/SP3
    and Windows Server 2003, you can optionally install the necessary libraries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用于其执行的运行时库自 Windows Vista 和 Windows Server 2008 以来已包含在 Windows 中。如果你使用的是带有 SP2/SP3
    的 Windows XP 或 Windows Server 2003，你可以选择安装必要的库。
- en: To begin learning the different recipes of WPF, you should have a clear understanding
    of the basic foundations. In this chapter, we will start with the architecture
    and syntaxes, and will guide you in creating a building block.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始学习 WPF 的不同食谱，你应该对基本原理有一个清晰的理解。在本章中，我们将从架构和语法开始，并指导你创建构建块。
- en: The WPF Architecture
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WPF 架构
- en: WPF uses a layered architecture that includes managed, unmanaged, and the core
    APIs in five different layers called **Presentation Framework**, **Presentation
    Core**, **Common Language Runtime**, **Media Integration Library**, and **OS Core**.
    The programming model is exposed through the managed code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 使用分层架构，包括托管、非托管和五个不同层中的核心 API，这些层被称为 **展示框架**、**展示核心**、**公共语言运行时**、**媒体集成库**和
    **OS 核心层**。编程模型通过托管代码公开。
- en: 'In the following diagram, you can see a clear picture of the architecture:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，你可以看到架构的清晰图示：
- en: '![](img/79d3ee57-66b2-4bf9-a826-f951c2d85758.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79d3ee57-66b2-4bf9-a826-f951c2d85758.png)'
- en: Presentation Framework
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展示框架
- en: The **Presentation Framework**, which is part of `presentationframework.dll`,
    provides the basic required components (such as controls, layouts, graphics, media,
    styles, templates, animations, and more) to start building the UIs of your WPF
    applications. It is part of the managed layer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**展示框架**，是 `presentationframework.dll` 的一部分，为你提供了开始构建 WPF 应用程序 UI 所需的基本组件（如控件、布局、图形、媒体、样式、模板、动画等）。它是托管层的一部分。'
- en: Presentation Core
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展示核心
- en: The **Presentation Core** layer, part of `presentationcore.dll`, provides you
    with the wrapper around the **Media Integration Library** (**MIL**). It present
    you with the public interfaces to access the MIL Core and the Visual System to
    develop the Visual Tree. It contains visual elements and rendering instructions
    to build applications for Windows using the XAML tools. This is also part of the
    managed code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**展示核心**层，是 `presentationcore.dll` 的一部分，为你提供了对 **媒体集成库**（**MIL**）的包装。它为你提供了访问
    MIL 核心和视觉系统的公共接口，以开发视觉树。它包含视觉元素和渲染指令，用于使用 XAML 工具构建 Windows 应用程序。这也是托管代码的一部分。'
- en: Common Language Runtime
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共语言运行时
- en: '**Common Language Runtime**, commonly known as the **CLR** and part of the
    managed layer, provides you with several features to build robust applications
    covering **common type system** (**CTS**), error handling, memory management,
    and more.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共语言运行时**，通常称为 **CLR**，是托管层的一部分，为你提供了构建健壮应用程序的几个功能，包括 **公共类型系统**（**CTS**）、错误处理、内存管理等。'
- en: Media Integration Library
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒体集成库
- en: The **Media Integration Library (MIL)**, which resides in `milcore.dll`, is
    part of the unmanaged layer used to display all graphics rendered through the
    DirectX engine. It provides you with basic support for 2D and 3D surfaces, and
    allows you to access the unmanaged components to enable tight integrations with
    DirectX. It also enables you to gain performance while rendering instructions
    from the Visual System to the **Common Language Runtime** (**CLR**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**媒体集成库（MIL**），位于`milcore.dll`中，是用于通过DirectX引擎渲染的所有图形显示的未管理层的一部分。它为您提供了对2D和3D表面的基本支持，并允许您访问未管理组件以实现与DirectX的紧密集成。它还允许您在从视觉系统到**公共语言运行时（CLR**）渲染指令时获得性能。'
- en: OS Core
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作系统核心
- en: Just after the MIL, the next layer is the **OS Core**, which provides you with
    access to the low-level APIs to handle the core components of the operating system.
    This layer includes Kernel, User32, DirectX, GDI, and device drivers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在MIL之后，下一层是**操作系统核心**，它为您提供了访问操作系统核心组件的低级API的权限。这一层包括内核、User32、DirectX、GDI和设备驱动程序。
- en: Types of WPF applications
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WPF应用程序类型
- en: 'Though WPF is mainly used for desktop applications, you can also create web-based
    applications. Thus, WPF applications can be of two types:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WPF主要用于桌面应用程序，但您也可以创建基于网络的程序。因此，WPF应用程序可以分为两种类型：
- en: Desktop-based executables (EXE)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于桌面的可执行文件（EXE）
- en: Web-based applications (XBAP)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于网络的程序（XBAP）
- en: The desktop applications are the normal `.exe` executables, which you normally
    run on any of your Windows-based systems, whereas the web-based applications are
    the `.xbap` files that can be deployed in web servers and can run inside any supported
    browser. The .NET Framework is mandatory to run any of these application types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序是常规的 `.exe` 可执行文件，您通常在任一基于 Windows 的系统上运行它们，而基于网络的程序是可以在 Web 服务器上部署的 `.xbap`
    文件，并且可以在任何支持的浏览器中运行。运行这些应用程序类型都需要 .NET Framework。
- en: When you run a WPF application, it starts in two threads. The UI thread uses
    the `System.Threading.DispatcherObject` to create the messaging system and that
    maintains the UI operations queue. Just like the Win32 message pumping, it performs
    the UI operation based on the priority set for it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行一个WPF应用程序时，它将在两个线程中启动。UI线程使用`System.Threading.DispatcherObject`来创建消息系统，并维护UI操作队列。就像Win32消息泵一样，它根据设置的优先级执行UI操作。
- en: The other thread is the background thread, which is used to handle the rendering
    engine being managed by WPF. It picks up a copy of the visual tree and performs
    actions to show the visual components in the Direct3D surface. Then it calls the
    UI elements to determine the size and arranges the child elements by their parents.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个线程是后台线程，用于处理由WPF管理的渲染引擎。它获取视觉树的副本，并执行操作以在Direct3D表面上显示视觉组件。然后它调用UI元素来确定大小并按其父元素排列子元素。
- en: The XAML overview
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XAML 概述
- en: '**XAML** stands for **Extensible Application Markup Language**. It is an XML-based
    markup language that is used to declaratively create the UI of any XAML-based
    application, such as **Windows Platform Foundation** (**WPF**), **Universal Windows
    Platform** (**UWP**), and **Xamarin.Forms**. You can create visible UI elements
    in a declarative XAML syntax to design the rich UI and then write the code behind
    to perform a runtime logic.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**XAML**代表**可扩展应用程序标记语言**。它是一种基于XML的标记语言，用于声明性地创建任何基于XAML的应用程序的UI，例如**Windows平台基金会（WPF**）、**通用Windows平台（UWP**）和**Xamarin.Forms**。您可以使用声明性的XAML语法创建可见的UI元素来设计丰富的UI，然后编写后台代码以执行运行时逻辑。'
- en: Microsoft recently introduced **XAML Standards**, which is a specification that
    defines a standard XAML vocabulary, which will allow the supported frameworks
    to share common XAML-based UI definitions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微软最近推出了**XAML标准**，这是一个定义标准XAML词汇的规范，它将允许支持的框架共享基于XAML的UI定义。
- en: 'You can learn more about this specification by visiting GitHub here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问GitHub上的此处了解更多关于此规范的信息：
- en: '[http://aka.ms/xamlstandard.](http://aka.ms/xamlstandard)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://aka.ms/xamlstandard.](http://aka.ms/xamlstandard)'
- en: Though it is not mandatory to use the XAML markup to create a UI, it has been
    widely accepted as the smart option for the creation of the entire application's
    UI, as it makes things easier to create. You can create the UI by writing C# or
    VB.NET code too, but that makes it more difficult and tougher to maintain. Also,
    that makes it difficult for the designers to work independently.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 XAML 标记来创建 UI 不是强制性的，但它已被广泛接受为创建整个应用程序 UI 的智能选项，因为它使创建变得更容易。你也可以通过编写 C#
    或 VB.NET 代码来创建 UI，但这会使创建更困难，也更难以维护。此外，这也使得设计师难以独立工作。
- en: Designing an application UI using XAML is as easy as writing an XML node with
    a few optional attributes. Attributes are used to set additional styles, behaviors,
    and properties. To create a simple button in the UI, you can just write `<Button
    />` in your XAML file. Similarly, you can just write `<TextBox />` to create a
    user-input box.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 XAML 设计应用程序 UI 与编写带有几个可选属性的 XML 节点一样简单。属性用于设置额外的样式、行为和属性。要在 UI 中创建一个简单的按钮，你只需在
    XAML 文件中写下 `<Button />`。同样，你也可以只写 `<TextBox />` 来创建一个用户输入框。
- en: 'Additionally, you can add more details to the controls. For example, to add
    a label to a button, use its `Content` property, and to set its dimension, use
    the `Height` and `Width` property, as shown in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以向控件添加更多详细信息。例如，要向按钮添加标签，使用其 `Content` 属性，并设置其尺寸，使用 `Height` 和 `Width`
    属性，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In general, when you add XAML pages to your WPF application project, it compiles
    along with the project and produces a binary file in what is known as **Binary
    Application Markup Language** (**BAML**). The final output of the project (that
    is, the assembly file) contains this BAML file as a resource. When the application
    loads into the memory, the BAML is then parsed at runtime.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你将 XAML 页面添加到你的 WPF 应用程序项目中时，它将与项目一起编译，并产生一个名为 **二进制应用程序标记语言**（**BAML**）的二进制文件。项目的最终输出（即，程序集文件）包含这个
    BAML 文件作为资源。当应用程序加载到内存中时，BAML 将在运行时被解析。
- en: You can also load an XAML into memory and directly render it on the UI. But,
    in this case, if it has any XAML syntax errors, it will throw those in runtime.
    If you compare the performance with the first process, the latter is slower, as
    it renders the entire XAML syntax onto UI.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 XAML 加载到内存中，并直接在 UI 上渲染它。但是，在这种情况下，如果它有任何 XAML 语法错误，它将在运行时抛出这些错误。如果你将性能与第一个过程进行比较，后者较慢，因为它将整个
    XAML 语法渲染到 UI 上。
- en: 'Here''s a flow diagram, that demonstrates the ways to load and render/parse
    the XAML UI:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个流程图，展示了加载和渲染/解析 XAML UI 的方法：
- en: '![](img/e089d867-7137-472b-b1af-a5f5274b31eb.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e089d867-7137-472b-b1af-a5f5274b31eb.png)'
- en: XAML syntax terminologies
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XAML 语法术语
- en: XAML uses some syntax terminologies to define an element in the UI and create
    the instance of it. Before you start working on it, you must understand the different
    terminologies that it offers. Let's have a look at a few of them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: XAML 使用一些语法术语来定义 UI 中的元素并创建其实例。在你开始工作之前，你必须了解它提供的不同术语。让我们看看其中的一些。
- en: Object element syntax
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象元素语法
- en: Each instance of a type is defined using proper XAML syntax to create an object
    element in the UI. Each of these object elements starts with a left angular bracket
    (`<`) and defines the name of the element. You can optionally prefix the namespace
    when it is defined outside the default scope. You can use a self-closing angular
    bracket (`/>`) or a right angular bracket (`>`) to close the object element definition.
    If the object element does not have any child elements, the self-closing angular
    bracket is used. For example, (`<Button Content="Click Here" />`) uses a self-closing
    angular bracket. If you write the same with a child element, it closes with an
    end tag (`<Button>Click Here</Button>,`) as shown.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型的实例都使用适当的 XAML 语法来在 UI 中创建一个对象元素。这些对象元素以一个左尖括号 (`<`) 开头，并定义了元素的名称。当它定义在默认作用域之外时，你可以选择性地添加命名空间前缀。你可以使用一个自闭合的尖括号
    (`/>`) 或一个右尖括号 (`>`) 来关闭对象元素的定义。如果一个对象元素没有子元素，则使用自闭合的尖括号。例如，（`<Button Content="点击这里"
    />`）使用自闭合的尖括号。如果你写入带有子元素的内容，它将使用结束标签关闭（`<Button>点击这里</Button>`），如下所示。
- en: When you define the object element in an XAML page, the instruction to create
    the instance of the element gets generated and it creates the instance by calling
    the constructor of the element when you load it in memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 XAML 页面上定义对象元素时，创建元素实例的指令被生成，并在你将其加载到内存中时通过调用元素的构造函数来创建其实例。
- en: Property Attribute syntax
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性属性语法
- en: 'You can define one or more properties to an element. These are done by writing
    an attribute called **Property Attribute syntax** to the element. It starts with
    the name of the property and an assignment operator (`=`), followed by the value
    within quotes. The following example demonstrates how easy it is to define a button
    element to have a label as its content, and how to set its dimension in UI:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义一个或多个属性到元素。这些是通过将一个名为 **属性属性语法** 的属性写入元素来完成的。它以属性名称和一个赋值运算符（`=`）开头，后跟引号内的值。以下示例演示了定义按钮元素具有标签作为其内容是多么容易，以及如何在
    UI 中设置其尺寸：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Property Element syntax
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性元素语法
- en: This is another type of XAML syntax that allows you to define the property as
    an element. This is often used when you cannot assign the value of the property
    within quotes. If we take the previous example, the text `Click Here` can be assigned
    to the button content easily. But, when you have another element or a composite
    property value, you cannot write those within the quotes. For this, XAML introduces
    **Property Element syntax** to help you to define the property value easily.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种 XAML 语法，允许您将属性定义为元素。这通常用于您无法在引号内分配属性值的情况。如果我们以之前的例子为例，文本 `Click Here` 可以轻松地分配给按钮内容。但是，当您有另一个元素或组合属性值时，您不能将其写入引号内。为此，XAML
    引入了 **属性元素语法** 以帮助您轻松定义属性值。
- en: 'It starts with `<element.PropertyName>` and ends with `</element.PropertyName>`.
    The following example demonstrates how to assign a color to a button background
    with a `SolidColorBrush` object:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它以 `<element.PropertyName>` 开头，以 `</element.PropertyName>` 结尾。以下示例演示了如何使用 `SolidColorBrush`
    对象为按钮背景分配颜色：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Content syntax
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容语法
- en: 'This is another type of XAML syntax that is used to set the content of a UI
    element. It can be set as the value of child elements. The following example demonstrates
    how to set the text content property of a `Border` control to hold a `Button`
    control as its `child` element:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种另一种类型的 XAML 语法，用于设置 UI 元素的内容。它可以设置为子元素的值。以下示例演示了如何将 `Border` 控件的文本内容属性设置为包含
    `Button` 控件作为其 `子` 元素：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While using **Content syntax**, you should remember the following points:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 **Content 语法** 时，您应该记住以下要点：
- en: The value of a `Content` property must be contiguous
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content` 属性的值必须是连续的'
- en: You cannot define an XAML `Content` property twice within a single instance
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能在单个实例中两次定义 XAML `Content` 属性
- en: 'Thus, the following is invalid as it will throw XAML error:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是不合法的，因为它将抛出 XAML 错误：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Collection syntax
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合语法
- en: 'When you need to define a collection of elements to the parent root, the **Collection
    syntax** is used to make it easy to read. For example, to add elements inside
    `StackPanel`, we use its `Children` property, as shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要将一组元素定义到父根元素时，使用 **集合语法** 可以使其易于阅读。例如，要在 `StackPanel` 内添加元素，我们使用其 `Children`
    属性，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can be also written as follows, and the parser knows how to create and
    assign the elements to `StackPanel`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以写成如下，解析器知道如何创建和将元素分配给 `StackPanel`：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Event Attribute syntax
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件属性语法
- en: When you add a button, you need to associate an event listener to it, to perform
    some operation. The same is applicable for adding other controls and UI layouts.
    The XAML allows you to use the **Event Attribute syntax** to define events for
    a specific XAML object element.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加按钮时，需要将其与事件监听器关联，以执行某些操作。对于添加其他控件和 UI 布局也是如此。XAML 允许您使用 **事件属性语法** 为特定的
    XAML 对象元素定义事件。
- en: 'The syntax looks like a property attribute, but it is used to associate the
    event listener to the element. The following example demonstrates how to assign
    the click event to a button control:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 语法看起来像属性属性，但它用于将事件监听器关联到元素。以下示例演示了如何将点击事件分配给按钮控件：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The associated event gets generated from the code behind the XAML page, where
    you can perform the real action. Here is the code snippet for the event implementation
    of the preceding button-click event:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关联的事件由 XAML 页面的代码后端生成，您可以在其中执行实际操作。以下是前面按钮点击事件实现代码片段：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Installing WPF Workload with Visual Studio 2017
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2017 安装 WPF 工作负载
- en: As we have learned the basic concepts of WPF Architecture and XAML syntax, we
    can start to learn different recipes to build applications for Windows using the
    XAML tools for WPF. But, before that, let's install the required workload/components
    for **Visual Studio 2017**. If you are using prior versions of Visual Studio,
    this step will be different.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学习了 WPF 架构和 XAML 语法的基本概念，我们可以开始学习不同的菜谱，使用 WPF 的 XAML 工具构建 Windows 应用程序。但在那之前，让我们安装
    **Visual Studio 2017** 所需的工作负载/组件。如果您使用的是 Visual Studio 的早期版本，这一步骤将有所不同。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To install the required components for building WPF applications, run the Visual
    Studio 2017 installer. If you don't have the installer, you can go to [https://www.visualstudio.com/downloads](https://www.visualstudio.com/downloads)
    and download the correct edition. Let's download the Visual Studio Community 2017
    edition as it is a fully featured IDE and available free for students, open source,
    and individual developers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装构建 WPF 应用程序所需的组件，请运行 Visual Studio 2017 安装程序。如果您没有安装程序，您可以去 [https://www.visualstudio.com/downloads](https://www.visualstudio.com/downloads)
    下载正确的版本。让我们下载 Visual Studio Community 2017 版本，因为它是一个功能齐全的 IDE，并且对学生、开源和个人开发者免费提供。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once you have downloaded the Visual Studio 2017 installer, follow these steps
    to install the correct workload:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 Visual Studio 2017 安装程序后，请按照以下步骤安装正确的 workload：
- en: Once you have run the installer, it will show you the following screen. Click
    on Continue:![](img/df98e9b4-7568-43ff-9e5d-9ab4b9b34ede.png)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装程序后，它将显示以下屏幕。点击继续：![](img/df98e9b4-7568-43ff-9e5d-9ab4b9b34ede.png)
- en: Wait for a few minutes to let the installer prepare itself for the installation
    process. A progress bar will show you the status of the current progress:![](img/aabbe4d6-cfef-4ad4-a917-a481a46528a6.png)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几分钟，让安装程序为安装过程做好准备。一个进度条将显示当前进度的状态：![](img/aabbe4d6-cfef-4ad4-a917-a481a46528a6.png)
- en: 'Then the following screen will pop up, where it will ask you to select the
    **workloads** or **components** that you want to install:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后会出现以下屏幕，其中将要求您选择要安装的 **workloads** 或 **components**：
- en: '![](img/7d567681-2ef1-48f9-b9b0-474a1dc85336.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d567681-2ef1-48f9-b9b0-474a1dc85336.png)'
- en: To build WPF applications targeting .NET Framework, select the .NET desktop
    development workload, as shown in the preceding screenshot.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建针对 .NET Framework 的 WPF 应用程序，请选择前面的截图所示的 .NET 桌面开发 workload。
- en: Click on the Install button to continue with the installation.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击安装按钮继续安装。
- en: 'The following screen will be displayed, showing the status of the installation.
    It will take some time, based on your internet bandwidth, as it''s going to download
    the required components, based on your selection, from the Microsoft servers and
    install them one by one:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下屏幕将显示，显示安装状态。根据您的网络带宽，这将花费一些时间，因为它将根据您的选择从 Microsoft 服务器下载所需的组件，并逐个安装：
- en: '![](img/72f4e0b5-14ac-450c-bd6e-7b1e85ef1fa9.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72f4e0b5-14ac-450c-bd6e-7b1e85ef1fa9.png)'
- en: Once the installation has completed, you may have to restart your system for
    the changes to take effect. In this case, a popup will appear on the screen, asking
    you to reboot your PC.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，您可能需要重新启动系统以使更改生效。在这种情况下，屏幕上会出现一个弹出窗口，要求您重新启动您的电脑。
- en: Once you have installed the **.NET desktop development component** and restarted
    your system, you are good to go with building your first WPF application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 **.NET 桌面开发组件**并重新启动系统后，你就可以开始构建你的第一个 WPF 应用程序了。
- en: Creating WPF applications
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 WPF 应用程序
- en: The WPF development platform supports a broad set of features that includes
    UI controls, layouts, resources, graphics, data binding, application model, and
    more. Before using each of those features, you need to create the WPF project
    using Visual Studio.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 开发平台支持一系列广泛的功能，包括 UI 控件、布局、资源、图形、数据绑定、应用程序模型等。在使用这些功能之前，您需要使用 Visual Studio
    创建 WPF 项目。
- en: The goal of this recipe is to create a WPF project and learn the basic project
    structure and components. Let's start building our first WPF application using
    the **XAML tools**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的目标是创建一个 WPF 项目，并学习基本的项目结构和组件。让我们开始使用 **XAML 工具**构建我们的第一个 WPF 应用程序。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with the WPF application development, you must have Visual Studio
    running on your system with the required components already installed on it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 WPF 应用程序开发，您必须在系统上运行 Visual Studio，并且已经安装了所需的组件。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create your first WPF application:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建您的第一个WPF应用程序：
- en: Inside your Visual Studio IDE, navigate to the File | New | Project... menu
    as shown in the following screenshot:![](img/a1106eca-997b-4c7c-b6eb-b1697f25d9b6.png)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Visual Studio IDE中，导航到文件 | 新建 | 项目...菜单，如图以下截图所示：![图片](img/a1106eca-997b-4c7c-b6eb-b1697f25d9b6.png)
- en: This will open the New Project dialog on the screen. You can alternatively open
    it by pressing the keyboard shortcut *Ctrl* + *Shift* + *N*.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在屏幕上打开新建项目对话框。您也可以通过按键盘快捷键*Ctrl* + *Shift* + *N*来打开它。
- en: 'In the New Project dialog, navigate to Installed | Templates | Visual C# |
    Windows Classic Desktop, as shown in the left-hand side of the following screenshot:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新建项目对话框中，导航到已安装 | 模板 | Visual C# | Windows经典桌面，如图以下截图的左侧所示：
- en: '![](img/2064791d-46e8-4210-a9ad-8a325e3ca000.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2064791d-46e8-4210-a9ad-8a325e3ca000.png)'
- en: In the right-hand side panel, first select the .NET Framework that you want
    your application to target. We have selected .NET Framework 4.7 here.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧面板中，首先选择您希望应用程序针对的.NET Framework版本。我们在这里选择了.NET Framework 4.7。
- en: Then select WPF App (.NET Framework), from the available list of templates.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从可用的模板列表中选择WPF App (.NET Framework)。
- en: Give a name (in our case, it is `CH01.HelloWPFDemo`) to the project.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给项目起一个名字（在我们的例子中是`CH01.HelloWPFDemo`）。
- en: Optionally, select the location of the project, where you want to create it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，选择项目位置，您希望创建它的位置。
- en: Optionally, you can also provide a different name for the Solution.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，您也可以为解决方案提供不同的名称。
- en: When you are ready, click on the OK button to let Visual Studio create the project
    based on the template that you have selected.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您准备好时，单击“确定”按钮，让Visual Studio根据您选择的模板创建项目。
- en: 'Once the project has been created, Visual Studio will open the Solution Explorer,
    which lists the project with all the default files created on it. The project
    structure will look like the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，Visual Studio将打开解决方案资源管理器，其中列出了项目及其上创建的所有默认文件。项目结构将类似于以下截图：
- en: '![](img/a9daf5cb-7bf7-41cb-adfd-3775cd1def9a.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9daf5cb-7bf7-41cb-adfd-3775cd1def9a.png)'
- en: There's more...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Each WPF application project created by Visual Studio using the default template
    consists of the following files:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio默认模板创建的每个WPF应用程序项目都包含以下文件：
- en: '`App.config`: This is the configuration file of your WPF application. By default,
    it contains the following lines that describe the supported runtime version for
    the application to run. This contains exactly the same runtime version that we
    selected during the project creation:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.config`：这是您的WPF应用程序的配置文件。默认情况下，它包含以下行，描述了应用程序运行所支持的运行时版本。这包含我们在项目创建期间选择的完全相同的运行时版本：'
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `config` file can also contain application settings and other configuration
    settings that you want to use/refer in your application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`文件还可以包含应用程序设置和其他您想要在应用程序中使用/引用的配置设置。'
- en: '`App.xaml`: Visual Studio automatically creates the `App.xaml` file when you
    create a WPF project. It is the declarative starting point of your application.
    The root element of this file is the `Application` instance, which defines application
    specific properties and events:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.xaml`：当您创建WPF项目时，Visual Studio会自动创建`App.xaml`文件。它是应用程序的声明性起点。此文件的根元素是`Application`实例，它定义了应用程序特定的属性和事件：'
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The instance of the `Application` class defines the `Window` or a `Page` that's
    going to be the startup UI, and is registered with the `StartupUri` property.
    In the preceding code, (`StartupUri="MainWindow.xaml"`) states that the `MainWindow.xaml`
    page will get loaded, once you run the application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`类的实例定义了`Window`或`Page`，它将成为启动UI，并通过`StartupUri`属性进行注册。在前面代码中，（`StartupUri="MainWindow.xaml"`）表示当您运行应用程序时，将加载`MainWindow.xaml`页面。'
- en: The application instance can also hold global/application-level resources (such
    as, Style, Template, and Converter) that can be used globally throughout the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序实例还可以持有全局/应用程序级别的资源（如，样式、模板和转换器），这些资源可以在整个应用程序中全局使用。
- en: '`App.xaml.cs`: This is the code-behind class file of the `App.xaml` and extends
    the `Application` class of the framework to write application-specific code. You
    can use this file to subscribe to the events such as `Startup`, `UnhandledException`
    to perform common operations:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.xaml.cs`：这是`App.xaml`的后台代码类文件，它扩展了框架的`Application`类以编写应用程序特定的代码。您可以使用此文件订阅事件，如`Startup`、`UnhandledException`以执行常见操作：'
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This class is often used to manipulate command-line parameters and load different
    XAML pages based on that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此类通常用于操作命令行参数并根据这些参数加载不同的XAML页面。
- en: '`MainWindow.xaml`: This is the default UI page that Visual Studio generates
    on creation of the WPF project. It is the page that gets registered as the `StartupUri`
    in `App.xaml`. The root element of this page is `Window` and it contains a `Grid`
    layout by default. Here is the default code snippet:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainWindow.xaml`：这是Visual Studio在创建WPF项目时生成的默认UI页面。它是注册为`App.xaml`中的`StartupUri`的页面。此页面的根元素是`Window`，默认包含一个`Grid`布局。以下是默认代码片段：'
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `x:Class` attribute defines the associated partial class where the UI logic
    is being written. You can modify this XAML to provide a fresh look to your application
    start page. Various UI controls and layouts are going to be covered in the later
    chapters of this book.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`x:Class`属性定义了包含UI逻辑的关联部分类。您可以修改此XAML以提供应用程序启动页的新外观。本书的后续章节将涵盖各种UI控件和布局。'
- en: '`MainWindow.xaml.cs`: This is the code-behind class of `MainWindow.xaml` and
    contains the logic related to UI operations. In general, developers write implementations
    of various UI operations in this class.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainWindow.xaml.cs`：这是`MainWindow.xaml`的后台代码类，包含与UI操作相关的逻辑。通常，开发者在类中编写各种UI操作的实现。'
- en: Whenever you add any UI elements to an XAML page, the control gets registered
    internally in a partial class file that has `.g.i.cs` as the extension. For example,
    if you add a control in the `MainWindow.xaml` file, it gets registered in the
    `MainWindow.g.i.cs` residing in the `obj` folder. If you open the file, you can
    observe the entire loading process inside the `InitializeComponent()` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您向XAML页面添加任何UI元素时，该控件都会在具有`.g.i.cs`扩展名的部分类文件中内部注册。例如，如果您在`MainWindow.xaml`文件中添加一个控件，它将注册在`obj`文件夹中的`MainWindow.g.i.cs`中。如果您打开该文件，您可以在`InitializeComponent()`方法中观察到整个加载过程。
- en: Creating and navigating from one window to another
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并从一个窗口导航到另一个窗口
- en: In WPF standalone applications, a window is used to host the UI elements to
    enable users to interact with the UI and data. The base class `Window` provides
    all the APIs to create and interact with the Window UI.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF独立应用程序中，窗口用于托管UI元素，使用户能够与UI和数据交互。基类`Window`提供了创建和与窗口UI交互的所有API。
- en: 'In WPF applications, the generic window layout is divided into multiple parts.
    Here is a screenshot of a basic window, containing its various parts:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF应用程序中，通用的窗口布局被分为多个部分。以下是基本窗口的截图，包含其各个部分：
- en: '![](img/78804e0a-8aa1-4b2d-b929-32561fbe99b3.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78804e0a-8aa1-4b2d-b929-32561fbe99b3.png)'
- en: 'The various parts of the window are as mentioned here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的各个部分如下所述：
- en: 'The outer part of the window is a **Border**, which you can utilize to enable
    the resizing option:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口的外部部分是一个**Border**，您可以利用它来启用调整大小选项：
- en: The outer border can contain a **resizing grip**, which enables you to resize
    the window diagonally
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部边框可以包含一个**调整大小把手**，使您能够以对角线方式调整窗口大小
- en: 'The window contains a **Title bar** at the top, which consists of the following
    parts:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口顶部有一个**标题栏**，它由以下部分组成：
- en: An **Icon** to provide a unique brand to your application window
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标**，为您的应用程序窗口提供独特的品牌'
- en: A **Title**, showing the identifiable name of the window
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**，显示窗口的可识别名称'
- en: A small panel, containing Minimize, Maximise/Restore, and Close buttons
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含最小化、最大化/还原和关闭按钮的小面板
- en: A **System menu** with menu items to allow users to perform Minimize, Maximize/
    Restore, Move, Size, and Close operations on the window
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统菜单**，包含允许用户在窗口上执行最小化、最大化/还原、移动、大小和关闭操作的菜单项'
- en: A **client area** for the developers to add application/window specific layouts
    and controls
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以在此处添加应用程序/窗口特定的布局和控制**客户端区域**
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this recipe, open your Visual Studio instance and create
    a WPF project called `CH01.WindowDemo` based on the WPF App (.NET Framework) template.
    Once the project has been created, it will have files called `MainWindow.xaml`
    and `MainWindow.xaml.cs`, along with the other default files.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始此食谱，请打开您的Visual Studio实例，并根据WPF App (.NET Framework)模板创建一个名为`CH01.WindowDemo`的WPF项目。一旦创建项目，它将包含名为`MainWindow.xaml`和`MainWindow.xaml.cs`的文件，以及其他默认文件。
- en: Let's get started with creating a new window in the same project and invoke
    a button to open the new window from the `MainWindow`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在同一项目中创建一个新的窗口，并从`MainWindow`中调用按钮以打开新窗口。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a new window, follow these simple steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新窗口，请按照以下简单步骤操作：
- en: Open the Solution Explorer and right-click on the project node.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“解决方案资源管理器”，在项目节点上右键单击。
- en: 'From the right-click context menu, navigate to Add | Window... as shown in
    the following screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右键单击上下文菜单中，导航到“添加 | 窗口...”，如下面的截图所示：
- en: '![](img/1edc768d-36bf-49fe-9967-818a9965c09c.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/1edc768d-36bf-49fe-9967-818a9965c09c.png)'
- en: 'The following Add New Item dialog will appear on the screen:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 屏幕上会出现以下“添加新项”对话框：
- en: '![](img/129ef68e-7943-4432-aa94-0f3555af8073.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理](img/129ef68e-7943-4432-aa94-0f3555af8073.png)'
- en: Make sure that the selected template is Window (WPF). Give it a name, `SecondWindow.xaml`,
    and click the Add button.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选中的模板是“窗口（WPF）”。给它起个名字，`SecondWindow.xaml`，然后点击“添加”按钮。
- en: This will create the `SecondWindow.xaml` file and its associated code-behind
    file `SecondWindow.xaml.cs` in the project directory.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在项目目录中创建 `SecondWindow.xaml` 文件及其关联的后台代码文件 `SecondWindow.xaml.cs`。
- en: 'Open the XAML file (`SecondWindow.xaml`) and replace the entire contents with
    the following XAML code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 XAML 文件（`SecondWindow.xaml`）并将全部内容替换为以下 XAML 代码：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now open the `MainWindow.xaml` file to add a button into it. Replace the entire
    `<Grid> </Grid>` block, with the following XAML code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `MainWindow.xaml` 文件，向其中添加一个按钮。将整个 `<Grid> </Grid>` 块替换为以下 XAML 代码：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we need to add the implementation for the button-click event. Simply open
    the `MainWindow.xaml.cs` file and add the following lines of code inside the class
    definition:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加按钮点击事件的实现。只需打开 `MainWindow.xaml.cs` 文件，并在类定义内添加以下代码行：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, when you run the application, you will see that the MainWindow opens on
    the screen, containing a button labeled Open Second Window. Clicking on this button
    opens the second window on the screen that has text content of Second Window Instance.
    Here's the screenshot for your reference:![](img/0b21988b-467a-4790-b633-95d1ed00471b.png)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序时，你会在屏幕上看到 MainWindow 打开，其中包含一个标签为“打开第二个窗口”的按钮。点击此按钮将在屏幕上打开第二个窗口，其文本内容为“第二个窗口实例”。以下是供您参考的截图！![截图](img/0b21988b-467a-4790-b633-95d1ed00471b.png)
- en: Please note that if you click the button again, it will create another instance
    of the second window because it's modeless.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你再次点击按钮，因为它是无模式的，它将创建第二个窗口的另一个实例。
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you create the instance of the `Window` class, it will not become visible
    to the user. It only becomes visible when you call the `Show()` method, which
    returns the handle to the originated caller without waiting for the window to
    close.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建 `Window` 类的实例时，它不会对用户可见。它只有在调用 `Show()` 方法时才会可见，该方法返回原始调用者的句柄，而不等待窗口关闭。
- en: When you call the `Show()` method, it basically creates a modeless window, and
    hence you can interact with other windows within the same application when the
    same is already open. The `Window` class also exposes a method called `ShowDialog()`,
    which creates a model window and prevent users from interacting with other windows
    of the application. We will discuss the more later in this chapter, in the *Creating
    a dialog box* section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `Show()` 方法时，它基本上创建了一个无模式窗口，因此当同一个窗口已经打开时，你可以在同一应用程序中与其他窗口进行交互。`Window`
    类还公开了一个名为 `ShowDialog()` 的方法，它创建了一个模式窗口，并阻止用户与应用程序的其他窗口交互。我们将在本章的“创建对话框”部分中进一步讨论。
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Window` class provides you with a bunch of properties, methods, and events
    to customize the look of the window, and perform specific operations or to be
    notified of the current context. To ask the client area to support transparency,
    set the `AllowsTransparency` property of the window to `true`. This is often useful
    when you want to create a custom-shaped window or a skinned theme.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window` 类为你提供了一组属性、方法和事件，以自定义窗口的外观，执行特定操作或通知当前上下文。要使客户端区域支持透明度，请将窗口的 `AllowsTransparency`
    属性设置为 `true`。这在你想创建一个自定义形状的窗口或皮肤主题时非常有用。'
- en: You can change the default icon of the window by setting the `Icon` property
    and enable/disable the window resizing by setting the `ResizeMode` property. You
    can also set the window title, startup location, window state, window style, and
    taskbar visibility by settings the `Title`, `WindowStartupLocation`, `WindowState`,
    `WindowStyle`, and `ShowInTaskbar` properties, respectively.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过设置 `Icon` 属性来更改窗口的默认图标，并通过设置 `ResizeMode` 属性来启用/禁用窗口大小调整。你还可以通过设置 `Title`、`WindowStartupLocation`、`WindowState`、`WindowStyle`
    和 `ShowInTaskbar` 属性来设置窗口标题、启动位置、窗口状态、窗口样式和任务栏可见性。
- en: Not only these but you can bring the window to the foreground by calling its
    `Activate()` method and close the window by calling the `Close()` method available
    in the `Window` class. Sometimes, when you want to hide the window instead of
    quitting it completely, you can utilize the `Hide()` method to make the window
    hidden and bring it back again by calling the `Show()` method on the same instance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这些，你还可以通过调用其`Activate()`方法将窗口带到前台，通过调用`Window`类中可用的`Close()`方法关闭窗口。有时，当你想隐藏窗口而不是完全退出时，你可以利用`Hide()`方法使窗口隐藏，并通过在相同实例上调用`Show()`方法将其再次显示出来。
- en: The class also exposes some events to notify you of the current contextual information.
    You can use the `Activated`, `Deactivated`, `Closing`, `Closed`, and `StateChanged`,
    events in your code to get such notifications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还公开了一些事件来通知你当前上下文信息。你可以在你的代码中使用`Activated`、`Deactivated`、`Closing`、`Closed`和`StateChanged`事件来获取此类通知。
- en: Creating and navigating from one page to another
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和导航到另一个页面
- en: The WPF application supports a browser style navigation mechanism, which can
    be used in both standalone applications as well as in XBAP applications. To implement
    it, WPF provides the `Page` class to encapsulate the `Page` content that can be
    navigated to and hosted by the browser, a `NavigationWindow` and/or a `Frame`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: WPF应用程序支持浏览器风格的导航机制，它既可以用在独立应用程序中，也可以用在XBAP应用程序中。为了实现它，WPF提供了`Page`类来封装可以由浏览器导航和托管的`Page`内容，以及`NavigationWindow`和/或`Frame`。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this recipe to build an application that supports navigations
    mechanisms from one WPF page to another, open the Visual Studio IDE and create
    a project based on the WPF App (.NET Framework) template. Give it a name (in our
    case, it's `CH01.PageDemo`).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建支持从WPF页面到另一个页面导航机制的应用程序，请打开Visual Studio IDE，并基于WPF App (.NET Framework)模板创建一个项目。给它起个名字（在我们的例子中，它是`CH01.PageDemo`）。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once you have created your project based on the WPF App (.NET Framework) template,
    follow these steps to add pages to your project and integrate them with the `NavigationService`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你根据WPF App (.NET Framework)模板创建了项目，请按照以下步骤将页面添加到项目中，并与`NavigationService`集成：
- en: Right-click on the project node where you want to create the pages.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击要创建页面的项目节点。
- en: As shown in this screenshot, navigate to Add | Page... from the context menu:![](img/7ccaf015-ab4e-4c0c-9afa-572ee435ff62.png)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如此截图所示，从上下文菜单中导航到添加 | 页面...：![图片](img/7ccaf015-ab4e-4c0c-9afa-572ee435ff62.png)
- en: 'This will open the following Add New Item dialog window, where the item titled
    Page (WPF) is already selected. Give it a name, `Page1.xaml` and click Add. It
    will create the `Page1.xaml` and the associated code-behind file `Page1.xaml.cs`
    in your project:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开以下“添加新项目”对话框窗口，其中已选中标题为“页面（WPF）”的项目。给它起个名字，`Page1.xaml`，然后点击添加。它将在你的项目中创建`Page1.xaml`和相关代码后文件`Page1.xaml.cs`：
- en: '![](img/3a6477c0-0641-4e4b-9095-c52b1df97720.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a6477c0-0641-4e4b-9095-c52b1df97720.png)'
- en: Now follow the same steps, 1 to 3, to create another page `Page2.xaml`, which
    will add both the XAML and associated C# code-behind file into the project.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按照相同的步骤，1到3，创建另一个页面`Page2.xaml`，这将把XAML和相关C#代码后文件添加到项目中。
- en: 'Open the `Page1.xaml` file and replace the `Grid` with the following XAML:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Page1.xaml`文件，将`Grid`替换为以下XAML：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the associated code-behind file (`Page1.xaml.cs`), add the following button-click
    event handler:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相关的代码后文件（`Page1.xaml.cs`）中，添加以下按钮点击事件处理器：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similarly, add the following XAML into the `Page2.xaml` page, replacing the
    existing `Grid`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，将以下XAML添加到`Page2.xaml`页面中，替换现有的`Grid`：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following button-click event handler into the `Page2.xaml.cs` file:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下按钮点击事件处理器添加到`Page2.xaml.cs`文件中：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now open the `MainWindow.xaml` file and replace the XAML content with the following:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`MainWindow.xaml`文件，将XAML内容替换为以下内容：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now open the `MainWindow.xaml.cs` file and change its base class to `NavigationWindow`,
    instead of `Window`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`MainWindow.xaml.cs`文件，将其基类更改为`NavigationWindow`，而不是`Window`。
- en: 'Run the application, which will open the following screen containing Page 1:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，它将打开以下包含第1页的屏幕：
- en: '![](img/04c79e6b-840a-4609-a733-20da461b8e87.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04c79e6b-840a-4609-a733-20da461b8e87.png)'
- en: 'Clicking on the Next button will navigate you to Page 2, as shown here, which
    contains the activated navigational button automatically provided by the WPF Framework:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮将导航到第2页，如这里所示，它包含由WPF框架自动提供的激活导航按钮：
- en: '![](img/eef15e0f-7da4-4351-887f-fb4bbcfa1ef1.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eef15e0f-7da4-4351-887f-fb4bbcfa1ef1.png)'
- en: Now, if you click on the Previous button or the back button in the navigation
    panel, it will navigate you to Page 1.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你点击导航面板中的“上一步”按钮或后退按钮，它将导航你到页面1。
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `NavigationWindow`, which is defined in the `MainWindow.xaml` page, provides
    the basic mechanism to support the content navigation. The `Source` attribute
    (`Source="Page1.xaml"`), defined as `URI`, asks `NavigationWindow` to load the
    mentioned page (`Page1.xaml`) by default.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml`页面中定义的`NavigationWindow`提供了支持内容导航的基本机制。`Source`属性（`Source="Page1.xaml"`），定义为`URI`，要求`NavigationWindow`默认加载所提到的页面（`Page1.xaml`）。
- en: When you click on the Next button of `Page1`, the `NavigationService.Navigate`
    method executes, passing the `URI` of the page that you want to load next. The
    navigation buttons automatically activate based on the history of the navigation
    that you performed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击`Page1`的“下一步”按钮时，`NavigationService.Navigate`方法会被执行，传递你想要加载的下一页的`URI`。导航按钮会根据你执行的历史导航自动激活。
- en: In `Page2`, when you click on the Previous button, it first checks whether the
    `NavigationService` has an immediate history item to navigate you to a previous
    page. If it finds a previous page, it then automatically navigates you to the
    desired page by calling the `NavigationService.GoBack()` method call. In this
    case, you don't have to pass the `URI` of the page.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Page2`中，当你点击“上一步”按钮时，它首先检查`NavigationService`是否有立即的历史条目可以导航到你之前的一页。如果找到前一页，它将通过调用`NavigationService.GoBack()`方法自动将你导航到所需的页面。在这种情况下，你不需要传递页面的`URI`。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`NavigationService` offers a variety of properties, methods, and events to
    perform navigation mechanisms on your page content. `CanGoBack()` and `CanGoForward()`
    return a `Boolean` value indicating whether there is at least one entry in the
    back and forward navigation history, respectively. The method `GoBack()` navigates
    you to the most recent entry from back navigation history, whereas the `GoForward()`
    method navigates you to the forward navigation history, if there''s one available.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigationService`提供了各种属性、方法和事件，用于在页面内容上执行导航机制。`CanGoBack()`和`CanGoForward()`返回一个`Boolean`值，分别指示后退和前进导航历史中是否至少有一个条目。`GoBack()`方法将你导航到后退导航历史中最新的条目，而`GoForward()`方法（如果可用）将你导航到前进导航历史。'
- en: To refresh the current content, you can call the `Refresh()` method. The `StopLoading()`
    method stops the current execution from downloading/loading the content part of
    the current navigation context. You can also programmatically add or remove an
    entry from the navigation history. The `AddBackEntry` method takes a parameter
    for the `CustomContentState` object to add the entry into the back-navigation
    history. The `RemoveBackEntry()` method removes the most recent entry from the
    back-navigation history.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要刷新当前内容，你可以调用`Refresh()`方法。`StopLoading()`方法停止当前执行从当前导航上下文的内容部分下载/加载。你也可以通过编程方式添加或从导航历史中删除条目。`AddBackEntry`方法接受一个参数`CustomContentState`对象，将条目添加到后退导航历史中。`RemoveBackEntry()`方法从后退导航历史中删除最近的条目。
- en: Events such as `Navigating`, `Navigated`, `NavigationFailed`, `NavigationStopped`,
    `NavigationProgress`, and `LoadCompleted` are there to notify you of the various
    statuses of the current navigation process. Use them wisely, based on your requirements.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 存在诸如`Navigating`、`Navigated`、`NavigationFailed`、`NavigationStopped`、`NavigationProgress`和`LoadCompleted`等事件，用于通知你当前导航过程的各个状态。根据你的需求明智地使用它们。
- en: Creating a dialog box
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对话框
- en: A dialog box is also a kind of window, and is generally used to get some inputs
    from the user or to show a message to the user. It uses a model window to prevent
    users from interacting with other windows of the same application when it is already
    open. In this recipe, we will learn how to create a model dialog and use the common
    dialog boxes that the framework provides.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框也是一种窗口，通常用于从用户那里获取输入或向用户显示消息。它使用模型窗口来防止用户在对话框已打开时与其他相同应用程序的窗口交互。在本教程中，我们将学习如何创建模型对话框并使用框架提供的常用对话框。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with building and using dialog boxes in a WPF application, open
    your Visual Studio IDE and create a new WPF project, calling it `CH01.DialogBoxDemo`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要在WPF应用程序中开始构建和使用对话框，打开你的Visual Studio IDE并创建一个新的WPF项目，命名为`CH01.DialogBoxDemo`。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create the dialog window and invoke it from the `MainWindow`
    to show a message to the user:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建对话框窗口，并从 `MainWindow` 中调用它以向用户显示消息：
- en: Open the Solution Explorer and right-click on the project node.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器，在项目节点上右键单击。
- en: From the context menu, select Add | Window... to open the Add New Item dialog.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上下文菜单中选择添加 | 窗口... 以打开添加新项目对话框。
- en: Making sure that the Window (WPF) template is selected, give it the name `MessageDialog`,
    and click Add to continue. This will create `MessageDialog.xaml` and `MessageDialog.xaml.cs`
    files in the project.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择了窗口（WPF）模板，将其命名为 `MessageDialog`，然后点击添加以继续。这将创建项目中的 `MessageDialog.xaml`
    和 `MessageDialog.xaml.cs` 文件。
- en: 'Open the `MessageDialog.xaml` file and replace the entire XAML content with
    the following:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MessageDialog.xaml` 文件，并用以下内容替换整个 XAML：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open the `MessageDialog.xaml.cs` file, and add the following event implementations
    for the OK button and Cancel button:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MessageDialog.xaml.cs` 文件，并为确定按钮和取消按钮添加以下事件实现：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now open the `MainWindow.xaml` page and replace the `Grid` with the following
    XAML content:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `MainWindow.xaml` 页面，并用以下 XAML 内容替换 `Grid`：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Go to the code-behind file, `MainWindow.xaml.cs`, and add the button event
    implementation as shared in the following code section:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往代码后置文件，`MainWindow.xaml.cs`，并添加以下按钮事件实现，如以下代码段所示：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now run the application. The visible window will have a button labeled Show
    Message. Click on it to invoke the message dialog window that we have created:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用程序。可见的窗口将有一个标有显示消息的按钮。点击它以调用我们创建的消息对话框窗口：
- en: '![](img/fb4d328a-8a14-47ba-9975-c8609110c90e.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb4d328a-8a14-47ba-9975-c8609110c90e.png)'
- en: Click on the Cancel button, which will add You clicked 'Cancel' button text
    into the list present in the MainWindow.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击取消按钮，这将把“你点击了'取消'按钮”文本添加到 MainWindow 中的列表中。
- en: Launch the message window again and click on the OK button. This will add You
    clicked 'OK' button in the list.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次启动消息窗口并点击确定按钮。这将把“你点击了'确定'按钮”添加到列表中。
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When you call the `ShowDialog()` method of the `Window` instance, it opens it
    as a model dialog and waits until the user provides an input to it. In this case,
    the user input is the interaction with the OK and Cancel button. When you click
    the OK button, the associated event handler assigns `true` to the `DialogResult`
    property and returns to the caller. Similarly, the Cancel button event handler,
    assigns `false` to the `DialogResult` property and returns.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `Window` 实例的 `ShowDialog()` 方法时，它将以模式对话框的形式打开，并等待用户提供输入。在这种情况下，用户输入是与确定和取消按钮的交互。当你点击确定按钮时，相关的事件处理器将
    `true` 赋值给 `DialogResult` 属性并返回给调用者。同样，取消按钮的事件处理器将 `false` 赋值给 `DialogResult`
    属性并返回。
- en: Based on the return value of the `ShowDialog()` method, which actually returns
    the value of `DialogResult`, you can decide whether the user clicked the OK or
    Cancel button.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 根据返回的 `ShowDialog()` 方法值，实际上返回的是 `DialogResult` 的值，你可以决定用户是否点击了确定或取消按钮。
- en: 'The dialog window has been customized by setting the following properties to
    the `Window` instance:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将以下属性设置为 `Window` 实例，已自定义对话框窗口：
- en: The `ShowInTaskbar` property has been set to `False` to prevent the window from
    being visible in the Taskbar.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShowInTaskbar` 属性已被设置为 `False` 以防止窗口在任务栏中可见。'
- en: The `WindowStyle` property has been set to `SingleBorderWindow` to add a thin
    border to the window, removing the minimize and maximize buttons from the title
    bar.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WindowStyle` 属性已被设置为 `SingleBorderWindow` 以向窗口添加细边框，从标题栏中移除最小化和最大化按钮。'
- en: The `Topmost` property has been set to `True` to keep it always visible on top
    of other windows. This is optional, but good to have.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Topmost` 属性已被设置为 `True` 以保持它始终位于其他窗口之上。这是可选的，但很好。'
- en: The `ResizeMode` property has been set to `NoResize` to prevent the user from
    resizing the dialog window.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResizeMode` 属性已被设置为 `NoResize` 以防止用户调整对话框窗口的大小。'
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The operating system provides some reusable dialog boxes, which provide a user
    experience consistent with the version of the operating system in which the application
    is running. The experience also stays consistent across all applications to provide
    a unique interface for performing common operations such as opening files, saving
    files, printing files, color selection, and more.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提供了一些可重用的对话框，这些对话框提供了与应用程序运行的操作系统的版本一致的用户体验。这种体验在所有应用程序中保持一致，以提供执行常见操作（如打开文件、保存文件、打印文件、颜色选择等）的独特界面。
- en: WPF provides these reusable, common dialog boxes as managed wrapper classes,
    encapsulating the core implementation. This reduces the extra effort creating
    and managing the common operations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: WPF提供这些可重用的常见对话框作为托管包装类，封装了核心实现。这减少了创建和管理常见操作所需的额外努力。
- en: Using the open file dialog
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用打开文件对话框
- en: To open files in your WPF application, you can use the managed wrapper class
    `OpenFileDialog`, which is present under the `Microsoft.Win32` namespace. You
    just have to create the instance and call the `ShowDialog()` method by optionally
    setting a few properties for UI customization.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的WPF应用程序中打开文件，您可以使用位于`Microsoft.Win32`命名空间下的托管包装类`OpenFileDialog`。您只需创建实例并通过可选设置一些属性进行UI自定义来调用`ShowDialog()`方法。
- en: 'A basic open file dialog looks like the following screenshot, providing you
    with an option to select one or more files to open:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的打开文件对话框看起来如下截图所示，为您提供选择一个或多个文件打开的选项：
- en: '![](img/0bf6052c-16a3-499a-a562-ce0bde65f88c.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bf6052c-16a3-499a-a562-ce0bde65f88c.png)'
- en: 'The following code snippet demonstrates how to initiate the open file dialog
    by optionally filling the file-extension filter:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何通过可选填充文件扩展名过滤器来启动打开文件对话框：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `dialogResult` returned by the `ShowDialog()` method tells us whether the
    operation was performed successfully. Based on that, you can call the instance
    of the file dialog to get more details about the selected file.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowDialog()`方法返回的`dialogResult`告诉我们操作是否成功执行。基于此，您可以调用文件对话框的实例以获取有关所选文件的更多详细信息。'
- en: Using the save file dialog
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用保存文件对话框
- en: Along with the `OpenFileDialog` interface, the `Microsoft.Win32` namespace also
    provides the `SaveFileDialog` managed wrapper to perform file saving operations
    from your WPF application. Similar to the open file dialog, you need to create
    the instance of it by optionally filling its various properties to finally call
    the `ShowDialog()` method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`OpenFileDialog`接口外，`Microsoft.Win32`命名空间还提供了`SaveFileDialog`托管包装类，以从您的WPF应用程序执行文件保存操作。与打开文件对话框类似，您需要创建其实例，并通过可选填充其各种属性来最终调用`ShowDialog()`方法。
- en: 'The save file dialog looks like the following screenshot, where you can provide
    a name to save as a file:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件对话框看起来如下截图所示，您可以为要保存的文件提供名称：
- en: '![](img/590ebada-3593-4c26-b9d0-5c4bfbbb352f.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/590ebada-3593-4c26-b9d0-5c4bfbbb352f.png)'
- en: 'Optionally, you can set the extension filter, default file name, and other
    properties before launching the dialog window, as shown in the following code
    snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以在启动对话框窗口之前设置扩展名过滤器、默认文件名和其他属性，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Based on the `dialogResult` returned by the `ShowDialog()` call you can decide
    whether the save was successful and retrieve more information about the saved
    file from the file dialog instance.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`ShowDialog()`调用返回的`dialogResult`，您可以决定保存操作是否成功，并从文件对话框实例中检索有关保存文件的更多信息。
- en: Using the print dialog
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用打印对话框
- en: 'The managed wrapper `PrintDialog` is also present in the `Microsoft.Win32`
    namespace, and provides you with the interface to call the operating system''s
    printer properties and perform the `print` operation. The dialog gives you the
    option to Select Printer, configure the printing preferences, and select the page
    range and other parameters, as shown in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 托管包装`PrintDialog`也存在于`Microsoft.Win32`命名空间中，并为您提供调用操作系统的打印机属性和执行`打印`操作的接口。对话框为您提供选择打印机、配置打印首选项以及选择页面范围和其他参数的选项，如下面的截图所示：
- en: '![](img/ae68185b-389b-473c-ab48-eb8688efdd55.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae68185b-389b-473c-ab48-eb8688efdd55.png)'
- en: To invoke the same, just create the instance of the `PrintDialog` and call its
    `ShowDialog()` method. You can optionally set page range, printable area, and
    other properties. If the `dialogResult` returned by the `ShowDialog()` method
    is set to `true`, it confirms that the printing job has been queued up successfully,
    and based on that you can perform the next set of actions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用相同的操作，只需创建`PrintDialog`的实例并调用其`ShowDialog()`方法。您可以可选地设置页面范围、可打印区域和其他属性。如果`ShowDialog()`方法返回的`dialogResult`设置为`true`，则确认打印作业已成功排队，基于此您可以执行下一组操作。
- en: 'Here''s the code snippet for your reference:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是供您参考的代码片段：
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Other common dialogs
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常见对话框
- en: WPF also provides some other common dialog boxes to perform the selection of
    various formatting options, such as font, font style, font size, text effects,
    and color. You can use the `FontDialog` and `ColorDialog`, present under the `System.Windows.Forms`
    namespace, to add support for the font and color selections, respectively.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: WPF还提供了一些其他常见的对话框，用于执行各种格式选项的选择，如字体、字体样式、字体大小、文本效果和颜色。你可以使用位于`System.Windows.Forms`命名空间下的`FontDialog`和`ColorDialog`，分别添加对字体和颜色选择的支持。
- en: 'Here''s the screenshot presenting the font selector and color selector dialogs:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是展示字体选择器和颜色选择器对话框的截图：
- en: '![](img/2b7bdd04-367f-4027-a237-8ad0cd93323c.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b7bdd04-367f-4027-a237-8ad0cd93323c.png)'
- en: Creating ownership between windows
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建窗口之间的所有权
- en: In the WPF application, the window objects that you create are independent of
    each other by default. But, sometimes, you may want to create an owner-owned relationship
    between them. For example, the toolbox window that you generally see in your Visual
    Studio IDE and/or in a Photoshop application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF应用程序中，你创建的窗口对象默认情况下是相互独立的。但是，有时你可能想要在它们之间创建所有者-所有者关系。例如，你通常在Visual Studio
    IDE和/或Photoshop应用程序中看到的工具箱窗口。
- en: When you set an owner of a window, it acts according to the owner instance.
    For example, if you minimize or close the owner window, the other window under
    the owner-owned relationship automatically minimizes or closes according to its
    owner.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置一个窗口的所有者时，它将根据所有者实例的行为。例如，如果你最小化或关闭所有者窗口，属于所有者关系的其他窗口将自动根据其所有者进行最小化或关闭。
- en: Let's begin creating this recipe to have an owner-owned relationship between
    two windows.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建这个菜谱，以便在两个窗口之间建立所有者-所有者关系。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this recipe, open your Visual Studio IDE and create a new
    WPF project called `CH01.OwnershipDemo`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个菜谱，打开你的Visual Studio IDE并创建一个新的名为`CH01.OwnershipDemo`的WPF项目。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to create a `ToolBox` window and assign its ownership
    to the `MainWindow`, so that it can act according to its owner:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建一个`ToolBox`窗口并将其所有者属性分配给`MainWindow`，以便它可以根据其所有者进行操作：
- en: Right-click on the project node and select Add | Window... from the context
    menu. The Add New Item dialog will be shown on the screen.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目节点，从上下文菜单中选择“添加 | 窗口...”。将在屏幕上显示“添加新项”对话框。
- en: Select Window (WPF) from the available list, give it the name `ToolBox`, and
    click Add to continue. This will add `ToolBox.xaml` and `ToolBox.xaml.cs` into
    your project.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用列表中选择“窗口（WPF）”，将其命名为“ToolBox”，然后单击“添加”继续。这将把“ToolBox.xaml”和“ToolBox.xaml.cs”添加到你的项目中。
- en: 'Open the `ToolBox.xaml` file and replace its content with the following XAML
    code:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ToolBox.xaml`文件，并用以下XAML代码替换其内容：
- en: '[PRE28]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now open the `App.xaml` page and remove the property attribute `StartupUri`,
    defined as (`StartupUri="MainWindow.xaml"`) from it.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`App.xaml`页面，并从其中移除属性属性`StartupUri`，定义为（`StartupUri="MainWindow.xaml"`）。
- en: 'Go to its code-behind file `App.xaml.cs` and override the `OnStartup` event.
    We need to modify the implementation according to our needs. Replace the entire
    `OnStartup` event handler with the following code block:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往其代码后文件`App.xaml.cs`并重写`OnStartup`事件。我们需要根据我们的需求修改实现。用以下代码块替换整个`OnStartup`事件处理器：
- en: '[PRE29]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run the application to see the relationship between the two windows. The windows
    will look like the following screenshot:![](img/c5c3dddc-e526-4c17-89b2-f6468f098c25.png)
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序以查看两个窗口之间的关系。窗口将看起来像以下截图所示：![图片](img/c5c3dddc-e526-4c17-89b2-f6468f098c25.png)
- en: Drag the ToolBox window and you can see that you are able to move it outside
    the MainWindow. Now perform some operations, such as minimizing and closing, on
    the MainWindow, and you will see that the ToolBox window also acts according to
    its owner.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动工具箱窗口，你可以看到你能够将其移动到MainWindow之外。现在对MainWindow执行一些操作，例如最小化和关闭，你将看到工具箱窗口也会根据其所有者进行操作。
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By default, the owner of every `Window` object is set to null, and thus each
    window is independent of the other. But, when you set its owner, it follows the
    owner-owned relationship and acts with the owner window.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个`窗口`对象的所有者设置为null，因此每个窗口都是相互独立的。但是，当你设置其所有者时，它将遵循所有者-所有者关系并与所有者窗口一起操作。
- en: '`Window` ownership is not a feature of WPF, but a capability of the Win32 user
    API and, accessible from a WPF application.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`窗口`所有权不是WPF的功能，而是Win32用户API的能力，并且可以从WPF应用程序中访问。'
- en: There's more...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Make sure you display the owner window first, before setting it as the owner
    of some other window, otherwise the system will throw an `InvalidOperationException`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在将其设置为其他窗口的所有者之前，首先显示所有者窗口，否则系统将抛出`InvalidOperationException`：
- en: '![](img/946e35e3-37e8-4a98-ba6a-2fe2977d54b2.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/946e35e3-37e8-4a98-ba6a-2fe2977d54b2.png)'
- en: 'Some points to note about window ownership:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 关于窗口所有权的注意事项：
- en: The window that has an ownership relationship with another window always appears
    on top of that owner
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他窗口有所有权关系的窗口始终出现在所有者窗口之上。
- en: You can drag the window outside the owner window
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将窗口拖到所有者窗口之外。
- en: When you minimize or close the owner, the other window, which is related to
    it, will follow the owner and minimize or close respectively
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你最小化或关闭所有者时，与之相关的其他窗口将分别跟随所有者最小化或关闭。
- en: By default, the window in a relationship gets displayed in the taskbar, but
    when you minimize the owner, it gets removed from the taskbar
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，相关联的窗口会显示在任务栏中，但当你最小化所有者时，它会被从任务栏中移除。
- en: When you want to break the relationship, just set the `Owner` property to `null`
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想断开关系时，只需将`Owner`属性设置为`null`。
- en: Creating a single instance application
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单实例应用程序
- en: When you build applications for Windows, there are many reasons why you would
    want to restrict users from launching multiple instances of your application.
    Some common examples are installers, uninstallers, update utilities, media applications,
    utility tools, and so on.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为Windows构建应用程序时，有许多原因会让你想要限制用户启动你的应用程序的多个实例。一些常见的例子是安装程序、卸载程序、更新工具、媒体应用程序、实用工具等。
- en: In a normal application, when you launch the app, it creates a Windows process,
    and allocates its own memory space and resources. But, when you don't want to
    create multiple instances of the process for a single application that is already
    running, you want to silently quit the new instance and bring the running process
    into the foreground.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个普通的应用程序中，当你启动应用程序时，它会创建一个Windows进程，并为其分配自己的内存空间和资源。但是，当你不希望为已经运行的单个应用程序创建多个进程实例时，你希望静默退出新实例并将运行中的进程带到前台。
- en: In this recipe, we will learn how to achieve this using **Mutex** (**Mutual
    Exclusion**) and unmanaged code.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用**Mutex**（**互斥**）和非托管代码来实现这一点。
- en: Getting ready
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this, open your Visual Studio instance and create a new
    project based on the WPF application template. During the project creation, give
    it the name `CH01.SingleInstanceDemo`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请打开您的Visual Studio实例，并基于WPF应用程序模板创建一个新项目。在项目创建过程中，将其命名为`CH01.SingleInstanceDemo`。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once the WPF project has been created, follow these steps to create a single
    instance of the WPF application:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了WPF项目，请按照以下步骤创建WPF应用程序的单实例：
- en: Run the application by pressing the *CTRL* + *F5* key combination. This will
    launch one instance of the application.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*CTRL* + *F5*键组合运行应用程序。这将启动应用程序的一个实例。
- en: Press *CTRL* + *F5* multiple times to launch multiple instances of the application.
    Now it's time to make the application a single instance application:![](img/123dcc2f-914c-4092-9c51-29ff7ccf41dd.png)
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按多次*CTRL* + *F5*以启动多个应用程序实例。现在，是时候将应用程序变成单实例应用程序了！![图片](img/123dcc2f-914c-4092-9c51-29ff7ccf41dd.png)
- en: Close all the running processes and then follow the next steps to implement
    the single instance behavior.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭所有正在运行的过程，然后按照以下步骤实现单实例行为。
- en: 'Open the `MainWindow.xaml` and add the window title to `Single Instance Demo`.
    Here you can find the entire XAML code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`并添加窗口标题到`Single Instance Demo`。在这里你可以找到整个XAML代码：
- en: '[PRE30]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Open the `App.xaml.cs` file and override the base implementation of the `OnStartup`
    method.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.xaml.cs`文件并重写`OnStartup`方法的基本实现。
- en: 'Change the code of the `OnStartup` method so that it looks like the following
    code:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`OnStartup`方法的代码，使其看起来像以下代码：
- en: '[PRE31]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Add the `System.Threading` namespace declaration, so that the Mutex can be discoverable.
    The Mutex resides in the aforesaid namespace.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`System.Threading`命名空间声明，以便Mutex可以被发现。Mutex位于上述命名空间中。
- en: Now compile the project to make sure that there are no compiler errors.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译项目以确保没有编译错误。
- en: Press *CTRL* + *F5*, which will run the first instance of the application.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*CTRL* + *F5*，这将运行应用程序的第一个实例。
- en: Now return to the Visual Studio, without closing the application, and then hit
    *CTRL* + *F5*. This time, instead of launching the application UI, an Application
    instance is already running! message will pop up on the screen. Clicking OK will
    close the message.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在返回Visual Studio，不关闭应用程序，然后按*CTRL* + *F5*。这次，不是启动应用程序UI，屏幕上会弹出“一个应用程序实例已经在运行！”的消息。点击OK将关闭消息。
- en: Press *CTRL* + *F5* again. Observe that no second instance of the UI is visible
    on the screen.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按*CTRL* + *F5*。观察屏幕上没有第二个UI实例可见。
- en: How it works...
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It's a trick to handle the application to have only a single instance. The **Mutex**
    (**Mutual Exclusion**) object is used to define the instance with a unique name.
    Here we called it `SingleInstanceDemo`. The Boolean `out` parameter returns whether
    the current calling thread has been granted the initial ownership of the `mutex`
    object.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个处理应用程序以使其只有一个实例的技巧。**互斥锁（Mutex）**（**互斥**）对象用于定义具有唯一名称的实例。在这里我们称之为`SingleInstanceDemo`。布尔`out`参数返回当前调用线程是否被授予`mutex`对象的初始所有权。
- en: A **Mutex** object is a synchronization object, which is generally used to synchronize
    access to a shared resource, so that only one thread can access that resource
    at a single point in time.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**互斥锁（Mutex）**对象是一个同步对象，通常用于同步对共享资源的访问，以确保只有一个线程可以在某个时间点访问该资源。'
- en: For the first instance of the application, it will be granted as the initial
    ownership. When the second instance runs, the calling thread will not get the
    initial ownership because the `mutex` object with the same name, `SingleInstanceDemo,`
    already exists and is running.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序的第一个实例，它将被授予初始所有权。当第二个实例运行时，调用线程将不会获得初始所有权，因为具有相同名称的`mutex`对象`SingleInstanceDemo`已经存在并且正在运行。
- en: So, the Boolean value of `isNewInstance` will be `false` and the message box
    will get displayed on the screen. The second instance of the application is still
    running at that moment and calls the `Shutdown()` method when you click on the
    OK button to close the message box.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`isNewInstance`的布尔值将是`false`，消息框将显示在屏幕上。此时应用程序的第二个实例仍在运行，当您点击OK按钮关闭消息框时，它将调用`Shutdown()`方法。
- en: Thus, the second instance will be removed from the process list. The first instance
    will continue running on the system.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第二个实例将从进程列表中移除。第一个实例将继续在系统上运行。
- en: There's more...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There could be a scenario where the application is running in a background process
    and the user tries to relaunch the application. In such a scenario, instead of
    showing a message to the user, you may want to activate the already running application
    and show its UI.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一种情况，应用程序在后台进程中运行，而用户尝试重新启动应用程序。在这种情况下，您可能希望激活已运行的程序并显示其UI，而不是向用户显示消息。
- en: 'You can do this by changing a bit of the existing code and integrating an unmanaged
    code call. To do so, open the `App.xaml.cs` file once again and follow these steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过稍微修改现有代码并集成未管理代码调用来做到这一点。为此，再次打开`App.xaml.cs`文件，并按照以下步骤操作：
- en: 'Add the following `using namespace` into the file: `System.Runtime.InteropServices`.'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中添加以下`using namespace`：`System.Runtime.InteropServices`。
- en: 'Then, you need to add the following unmanaged code declaration from the `user32.dll`
    to the `App.xaml.cs` file:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要将以下未管理代码声明从`user32.dll`添加到`App.xaml.cs`文件中：
- en: '[PRE32]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following method to activate the already running window, provided that
    the title of the window is static. In our case, it is Single Instance Demo, modified
    in the `MainWindow.xaml` page:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以激活已运行的窗口，前提是窗口标题是静态的。在我们的例子中，它是Single Instance Demo，在`MainWindow.xaml`页面中进行了修改：
- en: '[PRE33]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, instead of calling the `MessageBox`, call the `ActivateWindow()` method
    in the `OnStartup`. Here, you can find this new code:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您不需要调用`MessageBox`，而是在`OnStartup`中调用`ActivateWindow()`方法。在这里，您可以找到以下新代码：
- en: '[PRE34]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now run the application. It will launch the `MainWindow` titled Single Instance
    Demo on the screen.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序。它将在屏幕上启动标题为Single Instance Demo的`MainWindow`。
- en: Return to Visual Studio. This will put the application window in the background.
    Now run the application once again by pressing the keyboard shortcut *CTRL* +
    *F5*. This time, instead of running a different instance to show the UI, it will
    activate the existing window and push the running application to foreground.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Visual Studio。这将使应用程序窗口进入后台。现在通过按键盘快捷键*CTRL* + *F5*再次运行应用程序。这次，它不会运行不同的实例来显示UI，而是激活现有窗口并将运行的应用程序推向前台。
- en: It's not mandatory that the application window must always have a static title.
    In such cases, it will become more complex to handle said scenario.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序窗口不一定要始终具有静态标题。在这种情况下，处理该场景将变得更加复杂。
- en: Passing arguments to WPF applications
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 WPF 应用程序传递参数
- en: The command-line arguments are used to take optional parameters or values from
    the user, while launching the application. These are generally used to perform
    specific commands on the application from the outside.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数用于在启动应用程序时从用户那里获取可选参数或值。这些通常用于从外部执行特定命令。
- en: In this recipe, we will learn how to pass command-line arguments to a WPF application.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何向 WPF 应用程序传递命令行参数。
- en: Getting ready
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open the Visual Studio IDE and create a WPF application project
    called `CH01.CommandLineArgumentDemo`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开 Visual Studio IDE 并创建一个名为 `CH01.CommandLineArgumentDemo` 的 WPF 应用程序项目。
- en: How to do it...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now follow these steps to let the application support command line arguments
    and perform actions based on those:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下步骤让应用程序支持命令行参数并根据这些参数执行操作：
- en: 'Open the `MainWindow.xaml` to add a `TextBlock` into the `Grid` panel. Replace
    the entire XAML content with the following lines:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 并将 `TextBlock` 添加到 `Grid` 面板中。将整个 XAML 内容替换为以下行：
- en: '[PRE35]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create a new window in the project by right-clicking on the project node and
    then following the context menu path Add | Window... to open the Add New Item
    dialog window. Give it the name `OtherWindow` and click the Add button. This will
    add `OtherWindow.xaml` and `OtherWindow.xaml.cs` into the project.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目节点上右键单击并遵循上下文菜单路径添加 | 窗口...来在项目中创建一个新窗口。将其命名为 `OtherWindow` 并单击添加按钮。这将
    `OtherWindow.xaml` 和 `OtherWindow.xaml.cs` 添加到项目中。
- en: 'Now open the `OtherWindow.xaml` and change its UI to have different text. Let''s
    replace the entire XAML code with the following lines:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `OtherWindow.xaml` 并更改其 UI 以显示不同的文本。让我们将整个 XAML 代码替换为以下行：
- en: '[PRE36]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now open the `App.xaml` and remove the `StartupUri="MainWindow.xaml"`. This
    has been done to control the launch of the proper window, based on the argument
    passed to the application.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `App.xaml` 并移除 `StartupUri="MainWindow.xaml"`。这样做是为了根据传递给应用程序的参数来控制正确窗口的启动。
- en: 'Open the `App.xaml.cs` and override its `OnStartup` method to retrieve the
    arguments passed to it and open the desired window based on that. Let''s add the
    following code implementation for the `OnStartup` method:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.xaml.cs` 并重写其 `OnStartup` 方法以检索传递给它的参数并根据这些参数打开所需的窗口。让我们为 `OnStartup`
    方法添加以下代码实现：
- en: '[PRE37]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now build the project. Navigate to the `bin\Debug` folder and launch a Command
    Window in that location. Alternatively, you can launch a **Command Window** (**cmd.exe**)
    and navigate to the `bin\Debug` path, where your application is available.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建项目。导航到 `bin\Debug` 文件夹并在该位置启动一个命令窗口。或者，您可以在 `bin\Debug` 路径启动一个 **命令窗口**（**cmd.exe**）并导航到您的应用程序所在路径。
- en: 'In the console window, enter the name of the application without passing any
    arguments to it, as shown in the following command:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台窗口中，不传递任何参数输入应用程序名称，如下所示：
- en: '[PRE38]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will launch the `MainWindow` of our application, with this screen:![](img/cecf1ff2-aec9-4e33-a6a8-0d42e35dab66.png)
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将启动我们的应用程序的 `MainWindow`，如下所示：![图片](img/cecf1ff2-aec9-4e33-a6a8-0d42e35dab66.png)
- en: 'Close the application window and, from the console window, enter the application
    name by specifying the `/other` argument to it, as shown in the following command:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭应用程序窗口，并在控制台窗口中输入应用程序名称，指定 `/other` 参数，如下所示：
- en: '[PRE39]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will launch the `OtherWindow` of the application, instead of the `MainWindow`:![](img/e63f0383-54d3-44f1-a74e-e8e1df7189f7.png)
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将启动应用程序的 `OtherWindow` 而不是 `MainWindow`：![图片](img/e63f0383-54d3-44f1-a74e-e8e1df7189f7.png)
- en: How it works...
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `OnStartup(StartupEventArgs e)` method signature contains `StartupEventArgs`
    as a method parameter. It contains a property, `Args`, that returns a string array
    of the command line arguments that were passed to the application. If no command
    line arguments were passed, the string array will have zero items in it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnStartup(StartupEventArgs e)` 方法签名包含 `StartupEventArgs` 作为方法参数。它包含一个属性 `Args`，该属性返回一个字符串数组，表示传递给应用程序的命令行参数。如果没有传递命令行参数，则字符串数组中将没有项。'
- en: Now, by checking the condition, we launch the desired window that we want to
    show to the user. You can also take arguments such that the application launches
    in normal mode, maximized mode, or minimized. You can also use it to open the
    application as hidden, in some specific cases.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过检查条件，我们启动用户想要显示的窗口。您还可以传递参数，使应用程序以正常模式、最大化模式或最小化模式启动。在某些特定情况下，您还可以使用它以隐藏方式打开应用程序。
- en: There's more...
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we have seen how to launch the WPF application from the command line by passing
    the arguments, let's learn how to do this from Visual Studio itself to launch
    it in debug mode.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过传递参数从命令行启动 WPF 应用程序，现在让我们学习如何从 Visual Studio 本身启动它以调试模式运行。
- en: 'To pass a command line argument to your WPF application from Visual Studio
    in debug mode, right-click on the project node and click Properties from the context
    menu entry. This will open the project properties. Now navigate to the Debug tab.
    Please refer to the following screenshot:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要在调试模式下从 Visual Studio 将命令行参数传递给您的 WPF 应用程序，请右键单击项目节点，并从上下文菜单中单击“属性”。这将打开项目属性。现在导航到“调试”选项卡。请参考以下截图：
- en: '![](img/00535898-8b9a-4217-b475-a210524c2ed3.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00535898-8b9a-4217-b475-a210524c2ed3.png)'
- en: Under Start options, enter `/other` as the command line arguments. Now run the
    application in debug mode by pressing *F5*. You will see that the `OtherWindow`
    opens on the screen. To launch the `MainWindow`, just remove the `/other` argument
    from the project properties mentioned earlier and run the application again. This
    time you will see that the `MainWindow` opens instead of the `OtherWindow`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在“启动选项”下，输入 `/other` 作为命令行参数。现在按 *F5* 键以调试模式运行应用程序。你会看到屏幕上打开了 `OtherWindow`。要启动
    `MainWindow`，只需从前面提到的项目属性中移除 `/other` 参数，再次运行应用程序。这次你会看到打开的是 `MainWindow` 而不是
    `OtherWindow`。
- en: Handling unhandled exceptions
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理未处理的异常
- en: Exception handling is a vital part of software development. When an exception
    occurs at runtime, due to any error in the code, we handle those with a `try {}
    catch {}` block. The `try {}` block contains the code where the exception occurred;
    the `catch {}` block knows how to handle that, based on the type of the exception.
    After the exception has been handled, the normal execution of the program continues
    without affecting the application.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是软件开发的重要组成部分。当运行时发生异常，由于代码中的任何错误，我们使用 `try {} catch {}` 块来处理这些异常。`try {}`
    块包含发生异常的代码；`catch {}` 块知道如何根据异常类型来处理它。在异常被处理后，程序的正常执行继续，不会影响应用程序。
- en: Though, in most of the cases we handle, there could be cases that may go unnoticed
    and come into the picture at runtime. Such an unhandled exception crashes the
    application. In this recipe, we will learn how to catch the unhandled exceptions
    in the WPF application and close the application properly.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数情况下我们都会处理，但仍可能存在一些可能被忽视并在运行时出现的异常。这种未处理的异常会导致应用程序崩溃。在本教程中，我们将学习如何在 WPF
    应用程序中捕获未处理的异常并正确关闭应用程序。
- en: Getting ready
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open the Visual Studio IDE. Now create a new project, based
    on the WPF Application template, and call it `CH01.UnhandledExceptionDemo`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请打开 Visual Studio IDE。现在创建一个新的项目，基于 WPF 应用程序模板，并将其命名为 `CH01.UnhandledExceptionDemo`。
- en: How to do it...
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s start the demonstration by following these steps:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始演示：
- en: 'Open the `MainWindow.xaml` page, and add two radio buttons and one button on
    it. The first radio button will cause an exception handled in a `try {} catch
    {}` block, whereas the second radio button will throw an exception that will go
    unhandled. Add the following code into your `MainWindow.xaml`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 页面，并在其上添加两个单选按钮和一个按钮。第一个单选按钮将在 `try {} catch {}` 块中处理异常，而第二个单选按钮将抛出一个未处理的异常。将以下代码添加到您的
    `MainWindow.xaml` 中：
- en: '[PRE40]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Open the `MainWindow.xaml.cs` file to add the button-click event handler. Add
    the following code block inside the class:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml.cs` 文件，添加按钮点击事件处理程序。在类内部添加以下代码块：
- en: '[PRE41]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Go to the `App.xaml.cs` file and override the `OnStartup` method to have the
    application level `DispatcherUnhandledException` event registered as shown in
    the following code:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.xaml.cs` 文件，并重写 `OnStartup` 方法，以便将应用程序级别的 `DispatcherUnhandledException`
    事件注册，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the `DispatcherUnhandledException` event handler into the `App.xaml.cs`
    and handle the exception as shown in the following code, but with an empty code
    block:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DispatcherUnhandledException` 事件处理程序添加到 `App.xaml.cs` 中，并按以下代码处理异常，但使用一个空的代码块：
- en: '[PRE43]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's build and run the application. You will see the following UI on the screen:![](img/1a8986f3-82a1-4168-b4d7-f20b6f322d48.png)
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建并运行应用程序。你将在屏幕上看到以下UI![图片](img/1a8986f3-82a1-4168-b4d7-f20b6f322d48.png)
- en: 'It will have two radio selectors and one button in the application window.
    When the first radio button is checked and you click on the Throw Exception button,
    it will generate an exception in a `try {}` block, which will then immediately
    be handled by the associated `catch {}` block without crashing the application.
    The following message box will be shown on the UI:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序窗口中将有两个单选选择器和一个按钮。当第一个单选按钮被选中并且你点击“抛出异常”按钮时，它将在`try {}`块中生成一个异常，然后立即被相关的`catch
    {}`块处理，而不会导致应用程序崩溃。以下消息框将在UI上显示：
- en: '![](img/d36f20f5-4b66-4c7a-9b4f-df06339b82db.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d36f20f5-4b66-4c7a-9b4f-df06339b82db.png)'
- en: 'For the second radio button, when checked, if you click on the Throw Exception
    button, the exception will go unhandled and will be caught in the `App.xaml.cs`
    file, under the `OnUnhandledException` event, and the application will crash:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个单选按钮，当被选中时，如果你点击“抛出异常”按钮，异常将不会被处理，并在`App.xaml.cs`文件中的`OnUnhandledException`事件中被捕获，应用程序将崩溃：
- en: '![](img/d16691e7-85f5-4a47-ba53-f69e8fac5521.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d16691e7-85f5-4a47-ba53-f69e8fac5521.png)'
- en: 'Open the `App.xaml.cs` once again and modify the `OnUnhandledException` event
    implementation, as follows, to handle the thrown exception:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开`App.xaml.cs`并修改`OnUnhandledException`事件实现，如下所示，以处理抛出的异常：
- en: '[PRE44]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now run the application once again, check the second radio button and click
    on the button. You will notice that the application will not crash this time.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次运行应用程序，选中第二个单选按钮并点击按钮。你会注意到这次应用程序不会崩溃。
- en: Click the Throw Exception button multiple times. The application will continue
    as-is, without causing any crash of the UI.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次点击“抛出异常”按钮。应用程序将继续按原样运行，而不会导致UI崩溃。
- en: How it works...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you handle this kind of uncaught/unhandled exception by specifying `e.Handled
    = true`, your application will not crash and will continue running. The best part
    of catching an unhandled exception is logging the unknown/unhandled errors, so
    that you can investigate the root cause behind these exceptions and fix them in
    future builds.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过指定`e.Handled = true`来处理这种未捕获/未处理的异常时，你的应用程序将不会崩溃并继续运行。捕获未处理异常的最好部分是记录未知/未处理的错误，这样你就可以调查这些异常背后的根本原因，并在未来的构建中修复它们。
- en: When there's a critical error, you can restart the application programmatically
    from this block.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现关键错误时，你可以从这个块中以编程方式重新启动应用程序。
- en: There's more...
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can also use the `AppDomain.CurrentDomain.UnhandledException` event handler
    to catch any unhandled exceptions, but you won't be able to handle it in a way
    to continue running the application. When used, you can log the error and terminate/restart
    the application.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`AppDomain.CurrentDomain.UnhandledException`事件处理程序来捕获任何未处理的异常，但你将无法以继续运行应用程序的方式处理它。当使用时，你可以记录错误并终止/重新启动应用程序。
- en: Unhandled exceptions handled in the `DispatcherUnhandledException` event, by
    specifying `e.Handled = true` will not route to the `AppDomain.CurrentDomain.UnhandledException`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DispatcherUnhandledException`事件中通过指定`e.Handled = true`处理的未处理异常不会路由到`AppDomain.CurrentDomain.UnhandledException`。
