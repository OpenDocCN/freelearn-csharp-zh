- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Applying Service-Oriented Architectures with .NET
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET应用服务导向架构
- en: The term **Service-Oriented Architecture** (**SOA**) refers to a modular architecture
    where interaction between system components is achieved through communication.
    This approach has evolved for years and is now the basis of all communication
    between systems over the Internet. SOA allows applications from different organizations
    to exchange data and transactions automatically. Besides that, it allows organizations
    to offer services on the Internet. For instance, in a banking application, SOA
    can allow separate services for account management, transaction processing, and
    customer support to communicate seamlessly. More than that, it can enable suppliers
    to access customer support directly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务导向架构**（**SOA**）这个术语指的是一种模块化架构，其中系统组件之间的交互是通过通信实现的。这种方法已经发展多年，现在已成为互联网上所有系统间通信的基础。SOA允许来自不同组织的应用程序自动交换数据和事务。除此之外，它还允许组织在互联网上提供服务。例如，在银行应用程序中，SOA可以允许账户管理、交易处理和客户支持等独立服务无缝通信。更重要的是，它还可以使供应商直接访问客户支持。'
- en: Moreover, as we discussed in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*, communication-based interaction solves the binary
    compatibility and version mismatch problems that inevitably appear in complex
    systems made up of modules that share the same address space. Moreover, with SOA
    and its pattern of communication, you do not need to deploy different copies of
    the same component in the various systems/subsystems that use it – each component
    only needs to be deployed in one place, even if they are written in different
    programming languages, simplifying the overall cycle of **Continuous Integration/Continuous
    Delivery** (**CI/CD**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在第11章中讨论的，*将微服务架构应用于企业应用程序*，基于通信的交互解决了由共享相同地址空间的模块组成的复杂系统中不可避免出现的二进制兼容性和版本不匹配问题。此外，使用SOA及其通信模式，你不需要在所有使用它的各种系统/子系统中部署同一组件的不同副本——每个组件只需在一个地方部署即可，即使它们是用不同的编程语言编写的，这也简化了**持续集成/持续交付**（**CI/CD**）的整体周期。
- en: If a newer version conforms to the communication interface that is declared
    to the clients, no incompatibilities can occur. For instance, if you have a backend
    service that calculates tax based on a specific rule and the entry of selling
    data, if the specific rule changes, but the selling data doesn’t, you will be
    able to update the service without changing the application in the clients. On
    the other hand, with DLLs/packages, when the same interface is maintained, incompatibilities
    may arise because of possible version mismatches in terms of the dependencies
    of other DLLs/packages that the library module might have in common with its clients.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新的版本符合客户端声明的外部通信接口，则不会出现不兼容性。例如，如果你有一个后端服务，该服务根据特定的规则和销售数据的输入来计算税费，如果特定的规则发生变化，但销售数据没有变化，你将能够更新服务而无需更改客户端中的应用程序。另一方面，使用DLLs/包时，即使保持相同的接口，由于库模块可能与其客户端共有的其他DLLs/包的依赖项可能存在版本不匹配，因此可能会出现不兼容性。
- en: 'Organizing clusters/networks of cooperating services was discussed in *Chapter
    11*, *Applying a Microservice Architecture to Your Enterprise Application*. In
    this chapter, we will focus on the two main communication interfaces used all
    over the world. More specifically, we will discuss the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章*将微服务架构应用于企业应用程序*中讨论了组织协作服务的集群/网络。在本章中，我们将重点关注全球范围内使用的两个主要通信接口。更具体地说，我们将讨论以下主题：
- en: Understanding the principles of the SOA approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SOA方法的原则
- en: SOAP and REST web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP和REST Web服务
- en: How does .NET 8 deal with SOA?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 8如何处理SOA？
- en: By the end of this chapter, you will know how to publicly expose data from an
    application through an ASP.NET Core service.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何通过ASP.NET Core服务公开暴露应用程序中的数据。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the Visual Studio 2022 free Community edition or better
    with all the database tools installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装所有数据库工具的Visual Studio 2022免费社区版或更高版本。
- en: All the concepts in this chapter will be clarified with practical examples based
    on the WWTravelClub book use case, located in *Chapter 21, Case Study*. You will
    find the code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有概念都将通过基于WWTravelClub书籍用例的实用示例进行阐明，该用例位于*第21章，案例研究*。您可以在[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)找到本章的代码。
- en: Understanding the principles of the SOA approach
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SOA方法的原则
- en: 'Like classes in an object-oriented architecture, services are implementations
    of interfaces that, in turn, come from a system’s functional specifications. Therefore,
    the first step in *service* design is the definition of its *abstract interface*.
    During this initial stage, you might have two approaches:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像面向对象架构中的类一样，服务是实现接口的实现，而这些接口又来自系统的功能规范。因此，*服务*设计的第一步是定义其*抽象接口*。在这个初始阶段，您可能会有两种方法：
- en: Define all the service operations as interface methods that operate on the types
    of your favorite language (C#, Java, C++, JavaScript, and so on) and decide which
    operations to implement with synchronous communication and which ones to implement
    with asynchronous communication.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有服务操作定义为操作您喜欢的语言（C#、Java、C++、JavaScript等）类型的接口方法，并决定哪些操作使用同步通信实现，哪些操作使用异步通信实现。
- en: Create the contract first in an interoperable format. In this approach, you
    can use definition files using patterns like OpenAPI, Protobuf, WSDL, and AsyncAPI
    without touching the programming language with which the services will be developed,
    using some tools to help.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先以互操作格式创建合同。在这种方法中，您可以使用定义文件，例如OpenAPI、Protobuf、WSDL和AsyncAPI的模式，而不必接触将用于开发服务的编程语言，使用一些工具来帮助。
- en: The interfaces that are defined in this initial stage will not necessarily be
    used in the actual service implementation and are just useful design tools. Once
    we have decided on the architecture of the services, these interfaces are usually
    redefined so that we can adapt them to the peculiarity of the architecture.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始阶段定义的接口不一定会在实际的服务实现中使用，它们只是有用的设计工具。一旦我们决定了服务的架构，这些接口通常会被重新定义，以便我们可以根据架构的特定性来调整它们。
- en: It is worth pointing out that SOA messages must keep the same kind of semantics
    as method calls/answers. Besides, SOA follows stateless development; that is,
    the reaction to a message must not depend on any previously received messages
    because the server does not save information from prior requests, which means
    the messages must be independent of each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，SOA消息必须保持与方法调用/响应相同的语义。此外，SOA遵循无状态开发；也就是说，对消息的反应必须不依赖于任何之前收到的消息，因为服务器不会保存先前请求的信息，这意味着消息必须相互独立。
- en: For instance, if the purpose of messages is to create a new database entry,
    this semantic must not change with the context of other messages, and the way
    the database entry is created must depend on the content of the current message
    and not on other previously received messages. Consequently, a client cannot create
    sessions and cannot log in to a service, perform some operations, and then log
    out. An authentication token must be repeated in each message.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果消息的目的是创建一个新的数据库条目，这种语义必须不因其他消息的上下文而改变，并且数据库条目的创建方式必须依赖于当前消息的内容，而不是其他之前收到的消息。因此，客户端不能创建会话，也不能登录到服务，执行一些操作，然后注销。必须在每条消息中重复使用身份验证令牌。
- en: The reasons for this constraint are modularity, testability, and maintainability.
    In fact, a session-based service would be very hard to test and modify due to
    the interactions that are *hidden* in the session data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约束的原因是模块化、可测试性和可维护性。事实上，由于会话数据中隐藏的交互，基于会话的服务将非常难以测试和修改。
- en: Once you have decided on the interface that is going to be implemented by a
    service, you must decide which communication stack/SOA to adopt. The communication
    stack must be part of some official or *de facto* standard to ensure the interoperability
    of the service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定了一个服务将要实现的服务接口，您必须决定采用哪种通信堆栈/SOA。通信堆栈必须是某些官方或*事实上的*标准的一部分，以确保服务的互操作性。
- en: 'Interoperability is the main constraint prescribed by SOA: services must offer
    a communication interface that does not depend on a specific library used, implementation
    language, or deployment platform.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 互操作性是SOA规定的最主要约束：服务必须提供一个不依赖于特定库、实现语言或部署平台的通信接口。
- en: Considering you have decided on the communication stack/architecture, you need
    to adapt your previous interfaces to the peculiarities of the architecture (see
    the *REST web services* subsection of this chapter for more details). Then, you
    must translate these interfaces into the chosen communication language. This means
    that you must map all the programming language types into types that are available
    in the chosen communication language.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你已经决定了通信栈/架构，你需要将之前的接口适应架构的特定性（有关更多详细信息，请参阅本章的*REST Web服务*小节）。然后，你必须将这些接口转换为所选的通信语言。这意味着你必须将所有编程语言类型映射到所选通信语言中可用的类型。
- en: The actual translation of data is usually performed automatically by the SOA
    libraries that are used by your development environment. However, some configuration
    might be needed, and, in any case, we must be aware of how our programming language
    types are transformed before each communication. For instance, some numeric types
    might be transformed into types with less precision or with different ranges of
    values. In .NET 8, for instance, you should be aware that floating-point numeric
    types vary between **float** (~6-9 digits), **double** (~15-17 digits), and **decimal**
    (~28-29 digits). You may consider the alternative of using string variables to
    reduce the risk of imprecision while transferring numeric types.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的实际翻译通常由开发环境使用的SOA库自动执行。然而，可能需要一些配置，在任何情况下，我们必须了解在每次通信之前我们的编程语言类型是如何转换的。例如，某些数值类型可能被转换为精度较低或具有不同值范围的类型。例如，在.NET
    8中，你应该意识到浮点数值类型之间有所不同：**float** (~6-9位数字)，**double** (~15-17位数字)和**decimal** (~28-29位数字)。你可以考虑使用字符串变量作为替代方案，以降低在传输数值类型时的精度风险。
- en: The interoperability constraint can be interpreted in a lighter form in the
    case of microservices that are not accessible outside of their clusters since
    they need to communicate with other microservices that belong to the same cluster.
    In this case, this means that the communication stack might be platform-specific
    so that it can increase performance, but it must be standard to avoid compatibility
    problems with other microservices that might be added to the cluster as the application
    evolves.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无法访问其集群之外的微服务，互操作性约束可以以较轻的形式解释，因为这些微服务需要与其他属于同一集群的微服务进行通信。在这种情况下，这意味着通信栈可能是平台特定的，以便提高性能，但它必须是标准的，以避免与其他微服务兼容性问题，这些微服务可能会随着应用程序的发展而添加到集群中。
- en: We have spoken of the *communication stack* and not of the *communication protocol*
    because SOA communication standards usually define the format of the message’s
    content and provide different possibilities for the specific protocol that is
    used to embed those messages. For instance, REST services usually run over HTTP/HTTPS
    based on JSON messages, while the SOAP protocol just defines an XML-based format
    for the various kinds of messages, but SOAP messages can be conveyed by various
    protocols. Usually, the most common protocol that is used for SOAP is also HTTP,
    but you may decide to jump to the HTTP level and send SOAP messages directly over
    TCP/IP for better performance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的是*通信栈*而不是*通信协议*，因为SOA通信标准通常定义消息内容的格式，并为嵌入这些消息的特定协议提供不同的可能性。例如，REST服务通常基于JSON消息在HTTP/HTTPS上运行，而SOAP协议仅定义了基于XML的各种消息格式，但SOAP消息可以通过各种协议传递。通常，用于SOAP的最常见协议也是HTTP，但你可能决定跳到HTTP级别，并通过TCP/IP直接发送SOAP消息以获得更好的性能。
- en: 'The choice of communication stack you should adopt depends on several factors,
    as described below. When it comes to accessing data, maybe the communication stack
    will be mandatory and decided by the provider, but you should also be concerned
    about these factors when providing a service:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该采用的通信栈的选择取决于以下描述的几个因素。当涉及到访问数据时，通信栈可能是强制性的，由提供商决定，但你在提供服务时也应关注这些因素：
- en: '**Compatibility constraints**: If your service must be publicly available on
    the Internet to business clients, then you must conform to the most common choices,
    which means using SOAP over either HTTP or REST services. The most common choices
    are different if your clients are not business clients but **Internet of Things**
    (**IoT**) clients. Also, within IoT, the protocols that are used in different
    application areas can be different. For instance, marine vehicle status data is
    typically exchanged with *Signal K*. Although this protocol is too specific and
    is presented here just as an example, as a software architect, you must understand
    that you may face this kind of standard in a specific area.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性约束**：如果你的服务必须向商业客户公开在互联网上，那么你必须遵守最常见的选择，这意味着使用基于HTTP或REST服务的SOAP。如果您的客户不是商业客户而是**物联网**（**IoT**）客户，那么最常见的选择可能会有所不同。在物联网内部，不同应用领域使用的协议也可能不同。例如，海洋车辆状态数据通常使用*Signal
    K*进行交换。尽管这个协议过于具体，这里仅作为示例，但作为一名软件架构师，你必须理解你可能会在特定领域遇到这种标准。'
- en: '**Development/deployment platform**: Not all communication stacks are available
    on all development frameworks and on all deployment platforms, but luckily, all
    the most common communication stacks that are used in public business services,
    such as SOAP- and JSON-based REST communication, are available on all the main
    development/deployment platforms.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发/部署平台**：并非所有通信堆栈都可在所有开发框架和所有部署平台上使用，但幸运的是，所有在公共商业服务中使用的最常见通信堆栈，如基于SOAP和JSON的REST通信，都可在所有主要开发/部署平台上使用。'
- en: '**Performance**: If your system is not exposed to the outside world and is
    a private part of your microservice cluster, performance considerations have a
    higher priority. In this scenario, gRPC, which we will discuss soon in this chapter,
    can be noted as a good option.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：如果您的系统没有暴露给外界，而是您微服务集群的私有部分，那么性能考虑的优先级更高。在这种情况下，我们将在本章稍后讨论的gRPC可以被视为一个好的选择。'
- en: '**Availability of tools and knowledge in your team**: Knowing about the availability
    of tools in your team/organization is important when it comes to choosing between
    acceptable communication stacks.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队/组织中工具和知识的可用性**：在考虑选择可接受的通信堆栈时，了解您的团队/组织中工具的可用性很重要。'
- en: However, this kind of constraint always has less priority than compatibility
    constraints since it makes no sense to conceive a system that is easy to implement
    for your team but that almost nobody can use.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这种类型的约束总是比兼容性约束的优先级低，因为设计一个对您的团队来说容易实现但对几乎没有人有用的系统是没有意义的。
- en: '**Flexibility versus available features**: Some communication solutions, while
    less complete, offer a higher degree of flexibility, while other solutions, though
    more complete, offer less flexibility. The need for flexibility started a movement
    from SOAP-based services to more flexible REST services in the last few years.
    This point will be discussed in more detail when we describe SOAP and REST services
    in the remainder of this section.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性与可用功能**：一些通信解决方案虽然不够完整，但提供了更高的灵活性，而其他解决方案虽然更完整，但提供的灵活性较低。对灵活性的需求在过去的几年中引发了一场从基于SOAP的服务到更灵活的REST服务的运动。当我们在本节剩余部分描述SOAP和REST服务时，这一点将更详细地讨论。'
- en: '**Service description**: When services must be exposed on the Internet, client
    applications need a publicly available description of the service specifications
    to design their communication clients. Some communication stacks include languages
    and conventions to describe service specifications. Formal service specifications
    that are exposed this way can be processed so that they automatically create communication
    clients. SOAP goes further and allows service discoverability by means of a public
    XML-based directory containing information about the tasks each web service can
    carry out.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务描述**：当服务必须在互联网上公开时，客户端应用程序需要公开的服务规范描述来设计它们的通信客户端。一些通信堆栈包括用于描述服务规范的编程语言和约定。以这种方式公开的形式化服务规范可以被处理，以便自动创建通信客户端。SOAP更进一步，通过包含有关每个Web服务可以执行的任务信息的公共XML目录，允许服务可发现性。'
- en: 'Once you have chosen the communication stack you wish to use, you must use
    the tools that are available in your development environment to implement the
    service in a way that conforms to the chosen communication stack. Sometimes, communication
    stack compliance is automatically ensured by the development tools, but sometimes,
    it may require some development effort. For instance, in the .NET world, the compliance
    of SOAP services is automatically ensured by development tools if you use WCF,
    while the compliance of REST services falls under the developer’s responsibility,
    although you have, since .NET 5, automatic support for the OpenAPI standard using
    Swagger. Some of the fundamental features of SOA solutions are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您选择了希望使用的通信栈，您就必须使用开发环境中可用的工具以符合所选通信栈的方式实现服务。有时，开发工具会自动确保通信栈的合规性，但有时可能需要一些开发工作。例如，在
    .NET 世界中，如果您使用 WCF，开发工具会自动确保 SOAP 服务的合规性，而 REST 服务的合规性则落在开发者的责任之下，尽管从 .NET 5 开始，Swagger
    提供了对 OpenAPI 标准的自动支持。以下是一些 SOA 解决方案的基本功能：
- en: '**Authentication**: Allows the client to authenticate to access service operations.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：允许客户端进行身份验证以访问服务操作。'
- en: '**Authorization**: Handles the client’s permissions.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：处理客户端的权限。'
- en: '**Security**: This is how communication is kept safe, that is, how to prevent
    unauthorized systems from reading and/or modifying the content of the communication.
    Typically, encryption prevents both unauthorized modifications and reading, while
    electronic signature algorithms prevent just modifications.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：这是如何保持通信安全，即如何防止未经授权的系统读取和/或修改通信内容。通常，加密可以防止未经授权的修改和读取，而电子签名算法可以防止仅修改。'
- en: '**Exceptions**: Returns exceptions to the client.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常**：向客户端返回异常。'
- en: '**Message reliability**: Ensures that messages reliably reach their destination
    in case of possible infrastructure faults.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息可靠性**：确保在可能的基础设施故障的情况下，消息可靠地到达其目的地。'
- en: 'Though sometimes desirable, the following features are not always necessary:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时是可取的，但以下功能并不总是必要的：
- en: '**Distributed transactions**: The capability to handle distributed transactions,
    thus undoing all the changes you have made whenever the distributed transactions
    fail or are aborted.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事务**：处理分布式事务的能力，因此当分布式事务失败或被中止时，可以撤销您所做的所有更改。'
- en: '**Support for the Publisher/Subscriber pattern**: If and how events and notifications
    are supported.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持发布/订阅模式**：是否以及如何支持事件和通知。'
- en: '**Addressing**: If and how references to other services and/or methods are
    supported.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寻址**：是否以及如何支持对其他服务和/或方法的引用。'
- en: '**Routing**: If and how messages can be routed through a network of services.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：是否以及如何将消息通过服务网络进行路由。'
- en: The remainder of this section will describe SOAP services a bit. However, the
    focus will be REST services since today they are the *de facto* standard for business
    services that are exposed outside of their clusters/servers. For performance reasons,
    microservices use other protocols, discussed in *Chapter 11*, *Applying a Microservice
    Architecture to Your Enterprise Application*, *Chapter 14*, *Implementing Microservices
    with .NET*. For inter-cluster communication, **Advanced Message Queuing Protocol**
    (**AMQP**) is used, and links are given in the *Further reading* section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的剩余部分将简要描述 SOAP 服务。然而，重点将是 REST 服务，因为今天它们是公开其集群/服务器之外的商业服务的*事实标准*。出于性能原因，微服务使用其他协议，这些协议在*第
    11 章*、*将微服务架构应用于您的企业应用*、*第 14 章*、*使用 .NET 实现微服务*中进行了讨论。对于集群间通信，使用**高级消息队列协议**（**AMQP**），并在*进一步阅读*部分提供了链接。
- en: SOAP web services
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP 网络服务
- en: The **Simple Object Access Protocol** (**SOAP**) allows both one-way messages
    and request/reply messages. Communication can be both synchronous and asynchronous,
    as explained in *Chapter 1, Understanding the Importance of Software Architecture*,
    and *Chapter 2, Non-Functional Requirements*, but if the underlying protocol is
    synchronous, such as in the case of HTTP, the sender receives an acknowledgment
    saying that the message was received (but not necessarily processed). When asynchronous
    communication is used, the sender must listen for incoming communications. Often,
    asynchronous communication is implemented with the Publisher/Subscriber pattern,
    which we described in *Chapter 6*, *Design Patterns and .NET 8 Implementation*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单对象访问协议**（**SOAP**）允许单向消息和请求/回复消息。通信可以是同步的，也可以是异步的，如第1章“理解软件架构的重要性”和第2章“非功能性需求”中所述，但如果底层协议是同步的，例如在HTTP的情况下，发送者会收到一个确认消息，表明消息已被接收（但不一定已处理）。当使用异步通信时，发送者必须监听传入的通信。通常，异步通信使用发布/订阅模式实现，我们在第6章“设计模式和.NET
    8实现”中描述了该模式。'
- en: Messages are represented as XML documents called **envelopes**. Each envelope
    contains `header`, `body`, and `fault` elements. The `body` is where the actual
    content of the message is placed. The `fault` element contains possible errors,
    so it is the way exceptions are exchanged when communication occurs. Finally,
    the `header` contains any auxiliary information that enriches the protocol but
    does not contain domain data. For example, the `header` may contain an authentication
    token and/or a signature if the message is signed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 消息表示为称为**信封**的XML文档。每个信封包含`header`（头部）、`body`（主体）和`fault`（错误）元素。`body`是放置实际消息内容的地方。`fault`元素包含可能的错误，因此它是通信发生时交换异常的方式。最后，`header`包含任何丰富协议但不包含域数据的辅助信息。例如，`header`可能包含一个身份验证令牌和/或签名，如果消息被签名的话。
- en: You can find the default namespace for the SOAP envelope at [https://www.w3.org/2003/05/soap-envelope/](https://www.w3.org/2003/05/soap-envelope/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.w3.org/2003/05/soap-envelope/](https://www.w3.org/2003/05/soap-envelope/)找到SOAP信封的默认命名空间。
- en: The underlying protocol that is used to send the XML envelopes is usually HTTP,
    since this is the protocol of the Internet, but the SOAP specification allows
    any protocol, so we can use TCP/IP or SMTP directly. As a matter of fact, the
    more diffused underlying protocol is HTTP, so if you do not have a good reason
    to choose another protocol, you should use HTTP to maximize the interoperability
    of the service.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 用于发送XML信封的底层协议通常是HTTP，因为这是互联网的协议，但SOAP规范允许使用任何协议，因此我们可以直接使用TCP/IP或SMTP。事实上，更广泛使用的底层协议是HTTP，所以如果没有充分的理由选择其他协议，应该使用HTTP以最大化服务的互操作性。
- en: SOAP specifications
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOAP规范
- en: 'SOAP specifications contain the basics of message exchange, while other auxiliary
    features are described in separate specification documents called `WS-` `*` and
    are usually handled by adding extra information in the SOAP header. `WS-*` specifications
    handle all the fundamental and desirable features of SOA we listed previously.
    We have some of them below:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP规范包含消息交换的基本内容，而其他辅助功能则在单独的规范文档中描述，称为`WS-` `*`，通常通过在SOAP头部添加额外信息来处理。`WS-*`规范处理我们之前列出的SOA的基本和期望功能。以下是一些例子：
- en: '| **WS-*** | **Main objective** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **WS-*** | **主要目标** |'
- en: '| `WS-Security` | Takes care of security, including authentication, authorization,
    and encryption/signatures |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `WS-Security` | 负责安全，包括身份验证、授权和加密/签名 |'
- en: '| `WS-Eventing` / `WS-Notification` | Two alternative ways of implementing
    the Publisher/Subscriber pattern |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `WS-Eventing` / `WS-Notification` | 两种实现发布/订阅模式的替代方法 |'
- en: '| `WS-ReliableMessaging` | Concerned with the reliable delivery of messages
    in case of possible faults |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `WS-ReliableMessaging` | 关注在可能出现故障的情况下消息的可靠传递 |'
- en: '| `WS-Transaction` | Concerned with distributed transactions |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `WS-Transaction` | 关注分布式事务 |'
- en: 'Table 15.1: Summary of Key WS-* Specifications and Their Main Objectives in
    SOAP-Based SOA'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1：关键WS-*规范及其在基于SOAP的SOA中的主要目标总结
- en: The preceding `WS- *` specifications are in no way exhaustive but are the more
    relevant and supported features. In fact, actual implementations in various environments
    (such as Java and .NET) furnish the more relevant `WS- *` services, but no implementation
    supports all the `WS- *` specifications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `WS-*` 规范并不全面，但它们是更相关和支持的功能。实际上，在各个环境（如 Java 和 .NET）中的实际实现提供了更相关的 `WS-*`
    服务，但没有一种实现支持所有 `WS-*` 规范。
- en: All the XML documents/document parts involved in the SOAP protocol are formally
    defined in XSD documents, like in the example below, which are special XML documents
    whose content provides a description of XML structures.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参与 SOAP 协议的 XML 文档/文档部分都在 XSD 文档中正式定义，如下例所示，这些是特殊的 XML 文档，其内容提供了 XML 结构的描述。
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, all your custom data structures (classes and interfaces in an object-oriented
    language) must be translated into XSD if they are going to be part of a SOAP envelope.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您的自定义数据结构（面向对象语言中的类和接口）要成为 SOAP 封装的一部分，它们必须被转换为 XSD。
- en: Each XSD specification has an associated `namespace` that identifies the specification
    and a physical location where it can be found. Both the namespace and the physical
    location are URIs. The location URI does not need to be publicly accessible if
    the web service is accessible just from within an intranet.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 XSD 规范都有一个相关的 `namespace`，用于标识规范及其物理位置，该位置可以找到。命名空间和物理位置都是 URI。如果 Web 服务仅从内部网络访问，则位置
    URI 不需要公开可访问。
- en: The whole definition of a service is an XSD specification that may contain references
    to other namespaces, that is, to other XSD documents. Simply put, all the messages
    via SOAP communication must be defined in an XSD specification. Then, a server
    and a client can communicate if they refer to the same XSD specifications. This
    means, for instance, that you need to create a new XSD specification each time
    you add another field to a message. After that, you need to update all the XSD
    files that reference the old message definition to the new message definition
    by creating a new version of them. In turn, these modifications require the creation
    of other versions for other XSD files, and so on. Therefore, simple modifications
    that maintain compatibility with the previous behavior (clients could simply ignore
    the field that was added) may cause an exponential chain of version changes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 服务整体定义是一个 XSD 规范，可能包含对其他命名空间的引用，即对其他 XSD 文档的引用。简单来说，所有通过 SOAP 通信的消息都必须在 XSD
    规范中定义。然后，如果服务器和客户端引用相同的 XSD 规范，它们就可以进行通信。这意味着，例如，每次向消息添加另一个字段时，都需要创建一个新的 XSD 规范。之后，需要通过创建新版本来更新所有引用旧消息定义的
    XSD 文件，以指向新消息定义。反过来，这些修改需要为其他 XSD 文件创建其他版本，依此类推。因此，保持与先前行为兼容的简单修改（客户端可以简单地忽略添加的字段）可能导致版本变化的指数级链式反应。
- en: Difficulties associated with the standard
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与标准相关的问题
- en: In the last few years, the difficulty in handling modifications, along with
    the complexity of handling the configuration of all the `WS- *` specifications
    and performance problems, caused a gradual move toward the simpler REST services
    that we will describe in the upcoming sections. This move started with services
    that were called from JavaScript due to the difficulty of implementing complete
    SOAP clients that were able to run efficiently in a web browser. Moreover, the
    complex SOAP machinery was oversized for the simple needs of the typical clients
    running in a browser and may have caused a complete waste of development time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，处理修改的难度，以及处理所有 `WS-*` 规范的配置复杂性和性能问题，导致逐渐转向我们将在后续章节中描述的更简单的 REST 服务。这种转变始于由于实现能够在浏览器中高效运行的完整
    SOAP 客户端的困难，而调用 JavaScript 中的服务。此外，复杂的 SOAP 机制对于在浏览器中运行的典型客户端的简单需求来说过大，可能导致了开发时间的完全浪费。
- en: For this reason, services aimed at non-JavaScript clients started a massive
    move toward REST services, and nowadays, the preferred choice is REST services,
    with SOAP being used either for compatibility with legacy systems or when features
    that are not supported by REST services are needed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，针对非 JavaScript 客户端的服务开始大规模转向 REST 服务，如今，首选的选择是 REST 服务，SOAP 仅用于与遗留系统兼容或当需要
    REST 服务不支持的功能时。
- en: Today, we can consider REST services that transfer data with JSON, the most-used
    approach all over the world. Security aspects, design patterns for enabling transactional
    support, performance, and even documentation have improved all over the years,
    so this is certainly the best alternative for applying SOAs nowadays. Let’s have
    a look at REST web services in the next topic.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们可以考虑使用JSON进行数据传输的REST服务，这是全球最常用的方法。安全性、支持事务的设计模式、性能以及甚至文档等方面在过去的几年里都有所改进，因此这无疑是现在应用SOA的最佳选择。让我们在下一个主题中看看REST网络服务。
- en: REST web services
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST网络服务
- en: REST services were initially conceived to avoid the complex machinery of SOAP
    in simple cases, such as calls to a service from the JavaScript code of a web
    page. Then, they gradually became the preferred choice for complex systems. REST
    services use HTTP to exchange data in JSON or, less commonly, in XML format. Simply
    put, they replace the SOAP body with the HTTP body, the SOAP header with the HTTP
    header, and the HTTP response code replaces the fault element and furnishes further
    auxiliary information on the operation that was performed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务最初是为了避免在简单情况下（例如从网页的JavaScript代码调用服务）使用SOAP的复杂机制而设计的。然后，它们逐渐成为复杂系统的首选选择。REST服务使用HTTP以JSON或较少情况下以XML格式交换数据。简单来说，它们用HTTP体替换SOAP体，用HTTP头替换SOAP头，用HTTP响应代码替换错误元素，并提供了关于所执行操作的其他辅助信息。
- en: 'The main reason for the success of REST services is that HTTP already offers
    most of the SOAP features natively, which means we can avoid building a SOAP level
    on top of HTTP. Moreover, the whole HTTP machinery is simpler than SOAP: simpler
    to program, simpler to configure, and simpler to implement efficiently.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务成功的主要原因在于HTTP已经提供了SOAP的大部分功能，这意味着我们可以避免在HTTP之上构建SOAP层。此外，整个HTTP机制比SOAP简单：编程更简单，配置更简单，实现效率更高。
- en: Moreover, REST services impose fewer constraints on the clients. Type compatibility
    between servers and clients conforms to the more flexible JavaScript type compatibility
    model because JSON is a subset of JavaScript. Moreover, when XML is used in place
    of JSON, it maintains the same JavaScript type compatibility rules. No XML namespaces
    need to be specified.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，REST服务对客户端的约束较少。服务器和客户端之间的类型兼容性符合更灵活的JavaScript类型兼容性模型，因为JSON是JavaScript的一个子集。此外，当使用XML代替JSON时，它保持相同的JavaScript类型兼容性规则。不需要指定XML命名空间。
- en: When using JSON and XML, if the server adds some more fields to the response
    while keeping the same semantics of all the other fields compatible with the previous
    client, they can simply ignore the new fields. Accordingly, changes that are made
    to a REST service definition only need to be propagated to previous clients in
    the case of breaking changes that cause actual incompatible behavior in the server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JSON和XML时，如果服务器在保持所有其他字段与先前客户端兼容的相同语义的同时添加了一些更多字段，它们可以简单地忽略这些新字段。相应地，对REST服务定义所做的更改只需在导致服务器实际不兼容行为的破坏性更改的情况下传播给先前客户端。
- en: Moreover, it is likely that changes will be self-limited and won’t result in
    an exponential chain of changes because type compatibility does not require the
    reference to a specific type to be defined in a unique shared place and simply
    requires that the shape of types is compatible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，变化很可能是自我限制的，不会导致指数级的变化链，因为类型兼容性不需要在唯一共享的位置定义特定类型的引用，只需确保类型形状兼容即可。
- en: Service type compatibility rules
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务类型兼容性规则
- en: 'Let’s clarify the REST service type compatibility rules with an example. Imagine
    that several services use a `Person` object that contains `Name`, `Surname`, and
    `Address` string fields. This object is served by **S1**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来明确REST服务类型兼容性规则。想象一下，几个服务使用一个包含`Name`、`Surname`和`Address`字符串字段的`Person`对象。这个对象由**S1**提供服务：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Type compatibility is ensured if the service and client refer to different
    copies of the preceding definition. It is also acceptable for the client to use
    a definition with fewer fields since it can simply ignore all the other fields:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务和客户端引用的是先前定义的不同副本，则类型兼容性得到保证。客户端使用具有较少字段的定义也是可以接受的，因为它可以简单地忽略所有其他字段：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can only use a definition with fewer fields within your “own” code. Attempting
    to send information back to the server without the expected fields may cause problems.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在“自己的”代码中使用具有较少字段的定义。尝试在没有预期字段的情况下将信息发送回服务器可能会导致问题。
- en: 'Now, imagine the scenario where you have an **S2** service that takes `Person`
    objects from **S1** and adds them to the responses it returns on some of its methods.
    Suppose the **S1** service that handles the `Person` object replaces the `Address`
    string with a complex object:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下这样的场景：你有一个**S2**服务，它从**S1**服务中获取`Person`对象并将它们添加到其某些方法返回的响应中。假设处理`Person`对象的**S1**服务将`Address`字符串替换为一个复杂对象：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After the breaking change, the **S2** service will have to adapt its communication
    client that calls the **S1** service to the new format. Then, it can convert the
    new `Person` format into the older one before using `Person` objects in its responses.
    This way, the **S2** service avoids propagating the breaking change of **S1**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在破坏性变更之后，**S2**服务将不得不调整其调用**S1**服务的通信客户端，以适应新的格式。然后，它可以将新的`Person`格式转换为旧格式，在响应中使用`Person`对象之前。这样，**S2**服务就可以避免传播**S1**的破坏性变更。
- en: In general, basing type compatibility on the object shape (tree of nested properties)
    instead of a reference to the same formal type definition increases flexibility
    and modifiability. The price we pay for this increased flexibility is that type
    compatibility cannot be computed automatically by comparing the formal definition
    of server and client interfaces. In fact, in the absence of a univocal specification,
    each time a new version of the service is released, the developer must verify
    that the semantics of all the fields that the client and server have in common
    remain unchanged from the previous version.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基于对象形状（嵌套属性的树）而不是对同一正式类型定义的引用来建立类型兼容性，可以增加灵活性和可修改性。我们为此增加的灵活性所付出的代价是，类型兼容性不能通过比较服务器和客户端接口的正式定义来自动计算。事实上，在没有统一规范的情况下，每次发布服务的新版本时，开发者都必须验证客户端和服务器共有的所有字段的语义与上一个版本保持不变。
- en: The basic idea behind REST services is to give up the severity checks and complex
    protocols for greater flexibility and simplicity, while SOAP does exactly the
    opposite.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务背后的基本思想是放弃严格的检查和复杂的协议，以获得更大的灵活性和简单性，而SOAP则恰恰相反。
- en: REST and native HTTP features
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST和原生HTTP功能
- en: The REST services manifesto states that REST uses native HTTP features to implement
    all the required service features. So, for instance, authentication will be performed
    directly with the HTTP `Authorization` field, encryption will be achieved with
    HTTPS, exceptions will be handled with an HTTP error status code, and routing
    and reliable messaging will be handled by the machinery the HTTP protocol relies
    on. Addressing is achieved by using URLs to refer to services, their methods,
    and other resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务宣言指出，REST使用原生HTTP功能来实现所有所需的服务功能。例如，认证将通过HTTP的`Authorization`字段直接执行，加密将通过HTTPS实现，异常将通过HTTP错误状态码处理，而路由和可靠消息传递将由HTTP协议依赖的机制处理。通过使用URL来引用服务、其方法和其他资源来实现寻址。
- en: There is no native support for asynchronous communication since HTTP is a synchronous
    protocol. There is also no native support for the Publisher/Subscriber pattern,
    but two services can interact with the Publisher/Subscriber pattern by each exposing
    an endpoint to the other. More specifically, the first service exposes a subscription
    endpoint, while the second one exposes an endpoint where it receives its notifications,
    which are authorized through a common secret that is exchanged during the subscription.
    This pattern is quite common. GitHub also allows us to send repository events
    to our REST services.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP是同步协议，因此没有原生对异步通信的支持。也没有原生对发布者/订阅者模式的支持，但两个服务可以通过各自向对方暴露端点来交互使用发布者/订阅者模式。更具体地说，第一个服务暴露一个订阅端点，而第二个服务暴露一个接收其通知的端点，这些通知通过在订阅期间交换的通用密钥进行授权。这种模式相当常见。GitHub还允许我们将仓库事件发送到我们的REST服务。
- en: REST services offer no easy options when it comes to implementing distributed
    transactions, since HTTP is stateless. However, approaches like the SAGA pattern,
    described in *Chapter 14, Implementing Microservices with .NET*, and event sourcing,
    described in *Chapter 7, Understanding the Different Domains in Software Solutions*,
    helped a lot in the last years to solve this difficulty. Besides, luckily, most
    application areas do not need the strong form of consistency that is ensured by
    distributed transactions. For them, lighter forms of consistency, such as *eventual
    consistency*, are enough and are preferred for performance reasons. Please refer
    to *Chapter 12*, *Choosing Your Data Storage in the Cloud*, for a discussion on
    the various types of consistencies.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: REST 服务在实现分布式事务时没有提供简单的选项，因为 HTTP 是无状态的。然而，像在 *第 14 章，使用 .NET 实现微服务* 中描述的 SAGA
    模式，以及在 *第 7 章，理解软件解决方案中的不同领域* 中描述的事件溯源，在过去几年中极大地帮助解决了这个难题。此外，幸运的是，大多数应用领域不需要分布式事务确保的强一致性形式。对于它们，更轻量级的一致性形式，如
    *最终一致性*，就足够了，并且出于性能原因更受欢迎。请参阅 *第 12 章*，*在云中选择您的数据存储*，以了解各种一致性类型的讨论。
- en: 'The REST manifesto not only prescribes the usage of the predefined solutions
    that are already available in HTTP but also the usage of a web-like semantic.
    In general, service operations can be conceived as CRUD operations, but not limited
    to them on resources that are identified by URLs (the same resource may be identified
    by several URLs). In fact, REST is an acronym for **Representational State Transfer**,
    meaning that each URL is the representation of some sort of entity. As a best
    practice, each kind of service request needs to adopt the appropriate HTTP verb
    and return the status code as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: REST 宣言不仅规定了使用 HTTP 中已可用的预定义解决方案，还规定了使用类似网络的语义。一般来说，服务操作可以被视为 CRUD 操作，但不仅限于它们在由
    URL 标识的资源上（同一资源可能由多个 URL 标识）。实际上，REST 是 **Representational State Transfer** 的缩写，意味着每个
    URL 都是某种实体的表示。作为最佳实践，每种类型的服务请求都需要采用适当的 HTTP 动词，并按以下方式返回状态码：
- en: '`GET` (read operation): The URL represents the resource that is returned by
    the read operation. Thus, `GET` operations mimic pointer dereferencing. In the
    case of a successful operation, a 200 (OK) status code is returned.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` (读取操作): URL 表示由读取操作返回的资源。因此，`GET` 操作模拟指针解引用。在操作成功的情况下，返回 200 (OK) 状态码。'
- en: '`POST` (creation operation): The JSON/XML object that is contained in the request
    body is added as a new resource to the object represented by the operation URL.
    If the new resource is successfully created immediately, a 201 (created) status
    code is returned, along with a response object that depends on the operation and
    an indication as to where the created resource can be retrieved from. The response
    object should contain the most specific URL that identifies the created resource.
    If creation is deferred to a later time, a 202 (accepted) status code is returned.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` (创建操作): 请求体中包含的 JSON/XML 对象作为新资源添加到由操作 URL 表示的对象中。如果新资源立即成功创建，则返回 201
    (已创建) 状态码，以及一个依赖于操作和指示从何处检索创建的资源响应对象。响应对象应包含标识创建资源的最具体 URL。如果创建被延迟到以后的时间，则返回 202
    (已接受) 状态码。'
- en: '`PUT` (edit operation): The JSON/XML object contained in the request body replaces
    the object referenced by the request URL. In the case of a successful operation,
    a 200 (OK) status code is returned. This operation is idempotent, meaning that
    repeating the same request twice causes the same modification. 204 (No Content)
    is also a possible return value.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` (编辑操作): 请求体中包含的 JSON/XML 对象替换了由请求 URL 引用的对象。在操作成功的情况下，返回 200 (OK) 状态码。此操作是幂等的，意味着重复相同的请求两次会导致相同的修改。204
    (无内容) 也是一个可能的返回值。'
- en: '`PATCH`: The JSON/XML object contained in the request body contains instructions
    on how to modify the object referenced by the request URL. This operation is not
    idempotent since the modification may be an increment of a numeric field. In the
    case of a successful operation, a 200 (OK) status code is returned.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`: 请求体中包含的 JSON/XML 对象包含如何修改由请求 URL 引用的对象的说明。由于修改可能是一个数值字段的增量，此操作不是幂等的。在操作成功的情况下，返回
    200 (OK) 状态码。'
- en: '`DELETE`: The resource referenced by the request URL is removed. In the case
    of a successful operation, a 200 (OK) status code is returned.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 删除由请求 URL 引用的资源。在操作成功的情况下，返回 200 (OK) 状态码。'
- en: 'If the resource has been moved from the request URL to another URL, a redirect
    code is returned:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源已从请求URL移动到另一个URL，则返回重定向代码：
- en: '`301` (moved permanently), plus the new URL where we can find the resource'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`301`（永久移动），以及我们可以找到资源的新的URL'
- en: '`307` (moved temporarily), plus the new URL where we can find the resource'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`307`（临时移动），以及我们可以找到资源的新的URL'
- en: 'If the operation fails, a status code that depends on the kind of failure is
    returned. Some examples of failure codes are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作失败，则返回一个依赖于失败类型的状态码。以下是一些失败代码的示例：
- en: '`400` (bad request): The request that was sent to the server is ill formed.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400`（请求错误）：发送到服务器的请求格式不正确。'
- en: '`404` (not found): When the request URL does not refer to any known object.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`（未找到）：当请求URL不指向任何已知对象时。'
- en: '`405` (method not allowed): When the request verb is not supported by the resource
    referenced by the URL.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`405`（方法不允许）：当请求动词不受URL引用的资源支持时。'
- en: '`401` (unauthorized): The operation requires authentication, but the client
    has not furnished any valid authorization header.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401`（未授权）：操作需要身份验证，但客户端未提供任何有效的授权头。'
- en: '`403` (forbidden): The client is correctly authenticated but has no right to
    perform the operation.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403`（禁止）：客户端正确认证，但没有权利执行操作。'
- en: '`409` (conflict): The operation failed due to some conflict with the current
    state of the server.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`409`（冲突）：由于与服务器当前状态存在冲突，操作失败。'
- en: '`412` (precondition failed): The operation failed due to some precondition
    desired.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`412`（先决条件失败）：由于某些先决条件未满足，操作失败。'
- en: '`422` (unprocessable content): The request was well formatted, but there are
    semantic errors in it.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`422`（不可处理的内容）：请求格式良好，但其中存在语义错误。'
- en: The preceding list of status codes is not exhaustive. A reference to an exhaustive
    list will be provided in the *Further reading* section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述状态码列表并不完整。在*进一步阅读*部分将提供完整的列表。
- en: It is fundamental to point out that `POST`/`PUT`/`PATCH`/`DELETE` operations
    may have – and usually have – side effects on other resources. Otherwise, it would
    be impossible to code operations that act simultaneously on several resources.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，`POST`/`PUT`/`PATCH`/`DELETE`操作可能——并且通常——对其他资源有副作用。否则，将无法编码同时作用于多个资源的操作。
- en: In other words, the HTTP verb must conform with the operation that is performed
    on the resource and referenced by the request URL, but the operation might affect
    other resources. The same operation might be performed with a different HTTP verb
    on one of the other involved resources. It is the developer’s responsibility to
    choose which way to perform the same operation to implement it in the service
    interface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，HTTP动词必须符合由请求URL引用并执行的操作，但该操作可能影响其他资源。相同的操作可能使用不同的HTTP动词在涉及的其他资源上执行。选择以哪种方式执行相同的操作以在服务接口中实现它是开发者的责任。
- en: Thanks to the side effects of HTTP verbs, REST services can encode all these
    operations as CRUD operations on resources represented by URLs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP动词的副作用，REST服务可以将所有这些操作编码为对由URL表示的资源进行的CRUD操作。
- en: Often, moving an existing service to REST requires us to split the various inputs
    between the request URL and the request body. More specifically, we extract the
    input fields that univocally define one of the objects involved in the method’s
    execution and use them to create a URL that univocally identifies that object.
    Then, we decide on which HTTP verb to use based on the operation that is performed
    on the selected object. Finally, we place the remainder of the input in the request
    body.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将现有服务迁移到REST需要我们在请求URL和请求体之间分割各种输入。更具体地说，我们提取那些唯一定义方法执行中涉及的某个对象的输入字段，并使用它们来创建一个唯一标识该对象的URL。然后，我们根据对所选对象执行的操作来决定使用哪个HTTP动词。最后，我们将输入的其余部分放在请求体中。
- en: If our services were designed with an object-oriented architecture focused on
    the business domain objects (such as DDD, as described in *Chapter 7, Understanding
    the Different Domains in Software Solutions*), the REST translation of all the
    service methods should be quite immediate since services should already be organized
    around domain resources. Otherwise, moving to REST might require some service
    interface redefinitions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务是以面向对象架构设计的，该架构专注于业务域对象（例如，如*第7章，理解软件解决方案中的不同域*中描述的DDD），那么所有服务方法的REST转换应该相当直接，因为服务应该已经围绕域资源组织。否则，迁移到REST可能需要重新定义一些服务接口。
- en: The adoption of full REST semantics has the advantage that services can be extended
    with or without small modifications being made to the preexisting operation definitions.
    In fact, extensions should mainly manifest as additional properties of some objects
    and as additional resource URLs with some associated operations. Therefore, preexisting
    clients can simply ignore them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 采用完整的REST语义具有这样的优势：服务可以在不修改现有操作定义的情况下进行扩展，也可以在修改现有操作定义的情况下进行扩展。实际上，扩展应主要表现为某些对象的新属性以及一些相关操作的新资源URL。因此，现有的客户端可以简单地忽略它们。
- en: Example of methods in the REST language
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST语言中方法的示例
- en: Now, let us learn how methods can be expressed in the REST language with a simple
    example of an intra-bank money transfer. We will present here two approaches.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个简单的银行内部转账示例来学习如何在REST语言中表达方法。我们将在这里介绍两种方法。
- en: 'In the first one, a bank account can be represented by a URL as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，一个银行账户可以如下通过URL表示：
- en: '`https://mybank.com/accounts/{bank account number}`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://mybank.com/accounts/{银行账户号}`'
- en: If we imagine a bank transfer we may represent it as a `PATCH` request, whose
    body contains an object with properties representing the amount of money, time
    of transfer, description, and the account receiving the money.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想象一个银行转账，我们可以将其表示为一个`PATCH`请求，其体包含一个对象，该对象具有表示金额、转账时间、描述以及接收资金的账户的属性。
- en: The operation modifies the account mentioned in the URL but also the receiving
    account as a *side effect*. If the account doesn’t have enough money, a `409`
    (conflict) status code is returned, along with an object with all the error details
    (an error description, the available funds, and so on).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作修改了URL中提到的账户以及接收账户作为*副作用*。如果账户没有足够的钱，则返回`409`（冲突）状态码，以及包含所有错误详情的对象（错误描述、可用资金等）。
- en: 'However, since all the bank operations are recorded in the account statement,
    the creation and addition of a new transfer object for a *bank account operations*
    collection associated with the bank account is a better way to represent the transfer.
    In this second approach, the URL might be something like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于所有银行操作都记录在账户报表中，因此为与银行账户关联的“银行账户操作”集合创建和添加一个新的转账对象来表示转账是一种更好的方式。在这种第二种方法中，URL可能如下所示：
- en: '`https://mybank.com/accounts/{bank account number}/transactions`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://mybank.com/accounts/{银行账户号}/transactions`'
- en: Here, the HTTP verb is `POST` since we are creating a new object. The body content
    is the same, and a `422` status code is returned if there is a lack of funds.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于我们正在创建一个新的对象，所以HTTP动词是`POST`。正文内容相同，如果资金不足，则返回`422`状态码。
- en: Both representations of the transfer cause the same changes in the database.
    Moreover, once the inputs are extracted from the different URLs and from the possibly
    different request bodies, the subsequent processing is the same. In both cases,
    we have the same inputs and the same processing – it is just the exterior appearance
    of the two requests that are different.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 两种传输表示都会在数据库中引起相同的变化。此外，一旦从不同的URL和可能不同的请求体中提取了输入，后续的处理就是相同的。在两种情况下，我们都有相同的输入和相同的处理——只是两个请求的外部表现不同。
- en: 'However, the introduction of the virtual *transactions* collection allows us
    to extend the service with several more *transaction* collection-specific methods.
    It is worth pointing out that the *transaction* collection does not need to relate
    to a database table or any physical object: it lives in the world of URLs and
    creates a convenient way for us to model the transfer.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚拟*交易*集合的引入使我们能够通过几个更多*交易*集合特定的方法来扩展服务。值得注意的是，*交易*集合不需要与数据库表或任何物理对象相关联：它存在于URL的世界中，为我们提供了一个方便的方式来模拟转账。
- en: The increased usage of REST services leads to a description of REST service
    interfaces to be created like the ones developed for SOAP. This standard is called
    **OpenAPI**. We will talk about this in the following subsection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务的使用增加导致需要创建REST服务接口的描述，就像为SOAP开发的那些一样。这个标准被称为**OpenAPI**。我们将在下一个子节中讨论这个问题。
- en: The OpenAPI standard
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenAPI标准
- en: OpenAPI is a specification that is used worldwide for describing the REST APIs.
    The OpenAPI Initiative was founded in November 2015, as an open-source project
    under the Linux Foundation, with the help of companies like SmartBear, Google,
    IBM, and Microsoft. The specification is currently versioned as 3.1\. The whole
    service is described by a JSON or YAML endpoint, that is, an endpoint that describes
    the service with a JSON object. This JSON object has a general section that applies
    to the whole service and contains the general features of the service, such as
    its version and description, as well as shared definitions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI是一个用于描述REST API的全球性规范。OpenAPI倡议成立于2015年11月，作为一个在Linux基金会下的开源项目，由SmartBear、Google、IBM和Microsoft等公司支持。该规范目前版本为3.1。整个服务通过一个JSON或YAML端点进行描述，即一个使用JSON对象描述服务的端点。这个JSON对象有一个通用部分，适用于整个服务，并包含服务的一般特性，如其版本和描述，以及共享定义。
- en: You can find OpenAPI Specification examples at [https://github.com/OAI/OpenAPI-Specification/](https://github.com/OAI/OpenAPI-Specification/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/OAI/OpenAPI-Specification/](https://github.com/OAI/OpenAPI-Specification/)找到OpenAPI规范示例。
- en: Then, each service endpoint has a specific section that describes the endpoint
    URL or URL format (in case some inputs are included in the URL), all its inputs,
    all the possible output types and status codes, and all the authorization protocols.
    Each endpoint-specific section can reference the definitions contained in the
    general section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个服务端点都有一个特定部分，描述端点URL或URL格式（如果URL中包含一些输入），所有输入，所有可能的输出类型和状态码，以及所有授权协议。每个端点特定部分可以引用通用部分中包含的定义。
- en: A complete description of the OpenAPI syntax is out of the scope of this book,
    but you will find visual editors on the Internet that can help you clarify the
    specification mentioned before. A great example is provided by SmartBear, one
    of the companies that founded the initiative, and it is called Swagger Editor.
    In the beta version of the online tool, you can load an example using OpenAPI
    version 3.1.0\. This helps companies to create API contracts even before deciding
    the programming language of the API.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中不包含OpenAPI语法的完整描述，但您可以在互联网上找到可视化编辑器，这些编辑器可以帮助您澄清之前提到的规范。SmartBear公司提供了一个很好的例子，该公司是这项倡议的发起者之一，它被称为Swagger
    Editor。在在线工具的测试版中，您可以使用OpenAPI 3.1.0版本加载一个示例。这有助于公司在决定API的编程语言之前就创建API合同。
- en: Various development frameworks automatically generate OpenAPI documentation
    by processing the REST API code, and further information is provided by the developer,
    so your team does not need to have in-depth knowledge of OpenAPI syntax. An example
    of this is the `Swashbuckle.AspNetCore` NuGet package that we will present in
    this chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的开发框架通过处理REST API代码自动生成OpenAPI文档，并且开发者提供了更多信息，因此您的团队不需要深入了解OpenAPI语法。本章节中我们将介绍的`Swashbuckle.AspNetCore`
    NuGet包就是一个例子。
- en: The *How does .NET 8 deal with SOA?* section explains how we can automatically
    generate OpenAPI documentation in ASP.NET Core REST API projects, while the use
    case presented in *Chapter 21, Case Study,* will provide a practical example of
    its usage.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: “.NET 8如何处理SOA？”这一节解释了如何在ASP.NET Core REST API项目中自动生成OpenAPI文档，而*第21章，案例研究*中提出的用例将提供一个其实际应用的例子。
- en: We will end this subsection by talking about how to handle authentication and
    authorization in REST services.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论如何在REST服务中处理认证和授权来结束本小节。
- en: REST service authorization and authentication
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST服务授权和认证
- en: 'Since REST services are stateless, when authentication is required, the client
    must send an authentication token in every single request. That token is usually
    placed in the HTTP authorization header, but this depends on the type of authentication
    protocol you are using. The simplest way to authenticate is through the explicit
    transmission of a shared secret. This can be done with the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST服务是无状态的，当需要认证时，客户端必须在每个请求中发送一个认证令牌。该令牌通常放置在HTTP授权头部，但这取决于您所使用的认证协议类型。最简单的认证方式是通过显式传输共享密钥。这可以通过以下代码实现：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The shared secret is called an API key. Since, at the time of writing, there
    is no standard on how to send it, API keys can also be sent in other headers,
    as shown in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 共享密钥被称为API密钥。由于在撰写本文时，尚无关于如何发送它的标准，因此API密钥也可以通过其他头部发送，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is worth mentioning that API-key-based authentication needs HTTPS to stop
    shared secrets from being stolen. API keys are very simple to use, but they do
    not convey information about user authorizations, so they can be adopted when
    the operations allowed by the client are quite standard, and there are no complex
    authorization patterns. Moreover, when exchanged in requests, API keys are susceptible
    to being attacked on the server or client side. A common pattern to mitigate this
    is to create a “service account” user and restrict their authorizations to just
    those needed and use the API keys from that specific account when interacting
    with the API.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，基于API密钥的认证需要HTTPS来防止共享密钥被盗。API密钥非常易于使用，但它们不传达有关用户授权的信息，因此当客户端允许的操作相当标准且没有复杂的授权模式时，可以采用它们。此外，当在请求中交换时，API密钥容易受到服务器或客户端端的攻击。一种常见的缓解方法是创建一个“服务帐户”用户，并限制其授权仅限于所需权限，并在与API交互时使用该特定帐户的API密钥。
- en: If you need a more sophisticated authentication service, you may consider using
    the OAuth 2.0 protocol. For instance, when you implement “Sign in with [Some specific
    social media],” you are probably using this protocol. Of course, to use it, you
    have to define an authentication service provider.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个更复杂的认证服务，您可以考虑使用OAuth 2.0协议。例如，当您实现“使用[某些特定的社交媒体]登录”时，您可能正在使用此协议。当然，为了使用它，您必须定义一个认证服务提供商。
- en: Safer techniques use shared secrets that are valid for a long period of time,
    just by the user logging in. Then, the login returns a short-life token that is
    used as a shared secret in all the subsequent requests. When the short-lived secret
    is going to expire, it can be renewed with a call to a renew endpoint.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 更安全的技巧使用有效的长期共享密钥，只需用户登录即可。然后，登录返回一个短期令牌，该令牌在所有后续请求中用作共享密钥。当短期密钥即将到期时，可以通过调用续订端点来更新它。
- en: The whole logic is completely decoupled from the short-life token-based authorization
    logic. The login is usually based on login endpoints that receive long-term credentials
    and return short-life tokens. Login credentials are either usual username-password
    pairs that are passed as input to the login method or other kinds of authorization
    tokens that are converted into short-life tokens that are served by the login
    endpoint. Login can also be achieved with various authentication protocols based
    on X.509 certificates.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 整个逻辑与基于短期令牌的授权逻辑完全解耦。登录通常基于接收长期凭证并返回短期令牌的登录端点。登录凭证可以是作为登录方法输入的常规用户名-密码对，也可以是其他类型的授权令牌，这些令牌被转换为由登录端点提供的短期令牌。登录还可以通过基于X.509证书的各种认证协议实现。
- en: The most widespread short-life token type is the so-called bearer token. Each
    bearer token encodes information about how long it lasts and a list of assertions,
    called claims, that can be used for authorization purposes. Bearer tokens are
    returned by either login operations or renewal operations. Their characteristic
    feature is that they are not tied to the client that receives them or to any other
    specific client, but they identify the client, which can simply use them in its
    invocations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的短期令牌类型是所谓的持证人令牌。每个持证人令牌都编码了有关其持续时间的详细信息以及一系列称为声明的断言列表，这些声明可用于授权目的。持证人令牌由登录操作或续订操作返回。它们的特征是它们不与接收它们的客户端或任何其他特定客户端绑定，而是识别客户端，该客户端可以简单地在其调用中使用它们。
- en: No matter how a client gets a bearer token, this is all a client needs to be
    granted, including all the rights implied by its claims. It is enough to transfer
    a bearer token to another client to empower that client with all the rights implied
    by all the bearer token claims since no proof of identity is required by bearer-token-based
    authorization.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 无论客户端如何获得持证人令牌，这都是客户端需要获得的所有内容，包括其声明中隐含的所有权利。只需将持证人令牌转移到另一个客户端，就可以赋予该客户端由所有持证人令牌声明隐含的所有权利，因为基于持证人令牌的授权不需要身份证明。
- en: Therefore, once a client gets a bearer token, it can delegate some operations
    to third parties by transferring its bearer token to them. Typically, when a bearer
    token must be used for delegation, during the login phase, the client specifies
    the claims to include to restrict what operations can be authorized by the token.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦客户端获得持证人令牌，它就可以通过将其持证人令牌转移到第三方来委托一些操作。通常，当必须使用持证人令牌进行委托时，在登录阶段，客户端指定要包含的声明以限制令牌可以授权的操作。
- en: 'Compared to API key authentication, bearer-token-based authentication is disciplined
    by standards. They must use the following `Authorization` header:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与API密钥认证相比，基于令牌的认证受到标准的约束。它们必须使用以下`Authorization`头：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Bearer tokens can be implemented in several ways. REST services typically use
    JWTs that are strings with a Base64 URL encoding of JSON objects. More specifically,
    JWT creation starts with a JSON header, as well as a JSON payload. The JSON header
    specifies the kind of token and how it is signed, while the payload consists of
    a JSON object that contains all the claims as property/value pairs. The following
    is an example header:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 携带令牌可以以多种方式实现。REST服务通常使用JWT，这些JWT是具有Base64 URL编码的JSON对象的字符串。更具体地说，JWT的创建从JSON头开始，以及一个JSON有效载荷。JSON头指定了令牌的类型及其签名方式，而有效载荷由一个包含所有声明作为属性/值对的JSON对象组成。以下是一个示例头：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is an example payload:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例有效载荷：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, the header and payload are Base64 URL-encoded, and the corresponding
    string is concatenated as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将头和有效载荷进行Base64 URL编码，并按以下方式连接相应的字符串：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding string is then signed with the algorithm specified in the header,
    which, in our example, is `RSA +SHA256`, and the signature string is concatenated
    with the original string as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用头中指定的算法对前面的字符串进行签名，在我们的例子中是`RSA + SHA256`，然后将签名字符串按以下方式与原始字符串连接：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code is the final bearer token string. A symmetric signature can
    be used instead of RSA, but, in this case, both the JWT issuer and all the services
    using it for authorization must share a common secret, while, with RSA, the private
    key of the JWT issuer does not need to be shared with anyone, since the signature
    can be verified with just the issuer public key.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是最终的令牌字符串。可以使用对称签名代替RSA，但在此情况下，JWT发行者和所有使用它进行授权的服务必须共享一个共同的秘密，而使用RSA时，JWT发行者的私钥不需要与任何人共享，因为可以使用发行者的公钥来验证签名。
- en: 'Some payload properties are standard, such as the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有效载荷属性是标准的，如下所示：
- en: '`iss`: Issuer of the JWT.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`：JWT的发行者。'
- en: '`aud`: The audience, that is, the services and/or operations that can use the
    token for authorization. If a service does not see its identifier within this
    list, it should reject the token.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aud`：受众，即可以使用令牌进行授权的服务和/或操作。如果一个服务没有在这个列表中看到其标识符，它应该拒绝该令牌。'
- en: '`sub`: A string that identifies the *principal* (that is, the user) to which
    the JWT was issued.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub`：一个字符串，用于标识JWT发行的*主体*（即用户）。'
- en: '`iat`, `exp`, and `nbf`: These are for the time the JWT was issued, its expiration
    time, and, if set, the time after which the token is valid, respectively. All
    the times are expressed as seconds from midnight UTC on January 1, 1970\. Here,
    all the days are considered as having exactly 86,400 seconds in them.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`、`exp`和`nbf`：这些分别代表JWT的发行时间、过期时间以及如果设置了，则代表令牌有效的起始时间。所有时间都是以1970年1月1日午夜UTC为起点的秒数表示。在这里，所有天都被认为是包含86,400秒。'
- en: Other claims may be defined as public if we represent them with a unique URI;
    otherwise, they are considered private to the issuer and to the services known
    to the issuer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用唯一的URI来表示其他声明，那么这些声明可以定义为公开的；否则，它们被认为是发行者及其已知服务的私有信息。
- en: API versioning
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API版本控制
- en: Considering a natural scenario where the number of APIs will increase in your
    application, and, more than that, the business logic will obviously evolve, as
    a software architect, you must decide how you are going to version the APIs, guaranteeing
    the compatibility between your services and the clients that consume these services.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这样一个自然场景，即你的应用程序中API的数量将会增加，而且，更重要的是，业务逻辑显然会演变，作为一个软件架构师，你必须决定你将如何对API进行版本控制，以确保你的服务和消费这些服务的客户端之间的兼容性。
- en: 'It is important to mention that there are several versioning options for doing
    so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，为此有几种版本控制选项：
- en: '**URI**: It consists of defining the version of the API in its URI, for example,
    `https://wwtravelclub.com/v1/trips`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URI**：它包括在URI中定义API的版本，例如，`https://wwtravelclub.com/v1/trips`。'
- en: '**Parameter**: You can define a parameter in the request that defines the version,
    for instance, `https://wwtravelclub.com/trips?version=2`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：你可以在请求中定义一个参数来定义版本，例如，`https://wwtravelclub.com/trips?version=2`。'
- en: '**Media type**: In this case, the desired version of the API will be presented
    in the HTTP `Accept` header.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体类型**：在这种情况下，所需的API版本将通过HTTP `Accept`头呈现。'
- en: '**Custom request header**: Like the media type versioning technique, but in
    this case the HTTP header will be customized by you.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义请求头**：类似于媒体类型版本控制技术，但在此情况下，HTTP 头将由您自定义。'
- en: The first two alternatives are the most commonly used, but the important point
    here is that you must consider crucial the implementation of a versioning technique.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方案是最常用的，但这里的重要一点是，你必须认为版本控制技术的实现至关重要。
- en: How does .NET 8 deal with SOA?
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 8 如何处理 SOA？
- en: WCF technology has not been ported to .NET 5+ and there are no plans to perform
    a complete port of it. Part of the source code was donated, and an open-source
    project started out of it. You can find information about this project at [https://github.com/CoreWCF/CoreWCF](https://github.com/CoreWCF/CoreWCF).
    Instead, Microsoft is investing in gRPC, Google’s open-source technology. Besides,
    .NET 8 has excellent support for REST services through ASP.NET Core.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: WCF 技术尚未移植到 .NET 5+，并且没有计划进行完整的移植。部分源代码已被捐赠，并由此启动了一个开源项目。您可以在 [https://github.com/CoreWCF/CoreWCF](https://github.com/CoreWCF/CoreWCF)
    找到关于此项目的更多信息。相反，微软正在投资于 Google 的开源技术 gRPC。此外，.NET 8 通过 ASP.NET Core 对 REST 服务提供了出色的支持。
- en: There is a tool developed by Microsoft to help you with the migration of WCF
    applications to the latest .NET. You can find it at [https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/](https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 微软开发了一个工具来帮助您将 WCF 应用程序迁移到最新的 .NET。您可以在 [https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/](https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/)
    找到它。
- en: 'The main reasons behind the decision to abandon WCF are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃 WCF 的主要原因是以下几方面：
- en: As we have already discussed, SOAP technology has been overtaken by REST technology
    in most application areas.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，在大多数应用领域，SOAP 技术已被 REST 技术取代。
- en: WCF technology is strictly tied to Windows, so it would be very expensive to
    reimplement all its features from scratch in .NET 5+. Since support for full .NET
    will continue, users who need WCF can still rely on it.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WCF 技术与 Windows 紧密相关，因此从头开始重新实现其所有功能在 .NET 5+ 中将非常昂贵。由于对全 .NET 的支持将继续，需要 WCF
    的用户仍然可以依赖它。
- en: As a general strategy, with .NET 5+, Microsoft prefers investing in open-source
    technologies that can be shared with other competitors. That is why, instead of
    investing in WCF, Microsoft provided a gRPC implementation starting from .NET
    Core 3.0.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种一般策略，从 .NET 5+ 开始，微软更倾向于投资于可以与其他竞争对手共享的开源技术。这就是为什么微软没有投资于 WCF，而是从 .NET Core
    3.0 开始提供了 gRPC 实现。
- en: The next subsections will cover the support provided inside Visual Studio for
    each technology we have mentioned.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将涵盖 Visual Studio 为我们提到的每种技术提供的支持。
- en: SOAP client support
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOAP 客户端支持
- en: In WCF, service specifications are defined through .NET interfaces, and the
    actual service code is supplied in classes that implement those interfaces. Endpoints,
    underlying protocols (HTTP and TCP/IP), and any other features are defined in
    a configuration file. In turn, the configuration file can be edited with an easy-to-use
    configuration tool. Therefore, the developer is responsible for providing just
    the service behavior as a standard .NET class and for configuring all the service
    features in a declarative way. This way, the service configuration is completely
    decoupled from the actual service behavior, and each service can be reconfigured
    so that it can be adapted to a different environment without the need to modify
    its code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WCF 中，服务规范是通过 .NET 接口定义的，实际的服务代码是在实现这些接口的类中提供的。端点、底层协议（HTTP 和 TCP/IP）以及任何其他功能都在一个配置文件中定义。反过来，配置文件可以使用一个易于使用的配置工具进行编辑。因此，开发者只需提供作为标准
    .NET 类的服务行为，并以声明性方式配置所有服务功能。这样，服务配置与实际服务行为完全解耦，每个服务都可以重新配置，以便能够适应不同的环境，而无需修改其代码。
- en: While .NET 8 does not support SOAP technology for creating new services, it
    does support the usage of SOAP clients when there are many SOAP services as legacy.
    More specifically, it is quite easy to create a SOAP service proxy for an existing
    SOAP service in Visual Studio (please refer to *Chapter 6*, *Design Patterns and
    .NET 8 Implementation*, for a discussion of what a proxy is and of the Proxy pattern).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然.NET 8不支持SOAP技术来创建新服务，但它支持在存在许多SOAP服务作为遗留技术的情况下使用SOAP客户端。更具体地说，在Visual Studio中为现有的SOAP服务创建SOAP服务代理非常简单（请参阅*第6章*，*设计模式和.NET
    8实现*，以讨论代理是什么以及代理模式）。
- en: In the case of services, a proxy is a class that implements the service interface
    and whose methods perform their jobs by calling the analogous methods of the remote
    service.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务的情况下，代理是一个实现服务接口的类，其方法通过调用远程服务的类似方法来完成其工作。
- en: To create a service proxy, right-click **Dependencies** in your project in **Solution
    Explorer**, and then select **Add connected service**. Then, in the form that
    appears, select **Microsoft WCF Service Reference Provider**. There, you can specify
    the URL of the service (where the WSDL service description is contained), the
    namespace where you wish to add the proxy class, and much more. At the end of
    the wizard, Visual Studio automatically adds all the necessary NuGet packages
    and scaffolds the proxy class. This is enough to create an instance of this class
    and to call its methods so that we can interact with the remote SOAP service.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务代理，在**解决方案资源管理器**中右键单击项目中的**依赖项**，然后选择**添加连接的服务**。然后，在出现的表单中，选择**Microsoft
    WCF服务引用提供程序**。在那里，您可以指定服务的URL（其中包含WSDL服务描述），您希望添加代理类的命名空间，以及更多。在向导结束时，Visual Studio自动添加所有必要的NuGet包并构建代理类。这足以创建此类的一个实例并调用其方法，以便我们可以与远程SOAP服务交互。
- en: There are also third parties, such as NuGet packages, that provide limited support
    for SOAP services, but currently, they aren’t very useful since such limited support
    does not include features that aren’t available in REST services.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些第三方工具，例如NuGet包，为SOAP服务提供有限的支持，但当前它们并不非常实用，因为这种有限的支持不包括REST服务中不可用的功能。
- en: gRPC support
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC支持
- en: The .NET SDK supports the gRPC project template, which scaffolds both a gRPC
    server and a gRPC client. gRPC implements a remote procedure call pattern that
    offers both synchronous and asynchronous calls, reducing the traffic of messages
    between the client and server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: .NET SDK 支持gRPC项目模板，该模板可以构建一个gRPC服务器和一个gRPC客户端。gRPC实现了一种远程过程调用模式，提供同步和异步调用，从而减少了客户端和服务器之间消息的流量。
- en: Using gRPC is super easy since Visual Studio’s gRPC project template scaffolds
    everything so that the gRPC service and its clients are working. The developer
    just needs to define the application-specific C# service interface and a class
    that implements it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gRPC非常简单，因为Visual Studio的gRPC项目模板自动构建了一切，使得gRPC服务和其客户端可以正常工作。开发者只需定义特定于应用程序的C#服务接口及其实现类。
- en: For configuring it, services are defined through interfaces written in a Protobuf
    file, and their code is provided in C# classes that implement those interfaces,
    while clients interact with those services through proxies that implement the
    same service interfaces.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置，服务是通过Protobuf文件中编写的接口定义的，并且它们的代码由实现这些接口的C#类提供，而客户端通过实现相同服务接口的代理与这些服务交互。
- en: gRPC is a good option for internal communications within a microservices cluster.
    Since there are gRPC libraries for all the main languages and development frameworks,
    it can be used in Kubernetes-based clusters. Besides, gRPC is more efficient than
    the REST services protocol due to its more compact representation of data and
    its being easier to use since everything to do with the protocol is taken care
    of by the development framework.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是微服务集群内部通信的良好选择。由于所有主要语言和开发框架都有gRPC库，因此它可以在基于Kubernetes的集群中使用。此外，由于gRPC具有更紧凑的数据表示方式，并且由于其使用起来更简单，因为与协议相关的一切都由开发框架处理，因此gRPC比REST服务协议更高效。
- en: For this reason, we have added a brand-new chapter dedicated to discussing this
    implementation, *Chapter 14*, *Implementing Microservices with .NET*, and you
    can check details about the technology at [https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0](https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们新增了一章专门讨论这种实现，即第14章“使用.NET实现微服务”，您可以在[https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0](https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0)查看有关技术的详细信息。
- en: The remainder of the section is dedicated to .NET support for REST services
    from both the server and client sides.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余部分将致力于介绍.NET对REST服务的服务器和客户端支持。
- en: A short introduction to ASP.NET Core
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core 简介简述
- en: ASP.NET Core applications are .NET applications based on the *Host* concept
    we described in the *Using generic hosts* subsection of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core应用程序是基于我们在第11章“将微服务架构应用于您的企业应用程序”的“使用通用宿主”子节中描述的**Host**概念的.NET应用程序。
- en: 'Using C# 12 and .NET 8, the template for creating ASP.NET Core apps has changed
    a bit. The main purpose is to simplify how we set it up. The `Program.cs` file
    of each ASP.NET application now creates a host, builds it, and runs it without
    needing the `Startup` class anymore, as we can see in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C# 12和.NET 8，创建ASP.NET Core应用程序的模板有所改变。主要目的是简化我们的设置方式。每个ASP.NET应用程序的`Program.cs`文件现在创建一个宿主，构建它，并运行它，不再需要`Startup`类，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Environment` is taken from the `ASPNETCORE_ENVIRONMENT` environment variable.
    In turn, it is defined in the `Properties\launchSettings.json` file when the application
    runs in Visual Studio over **Solution Explorer**. In this file, you can define
    several environments that can be selected with the dropdown next to Visual Studio’s
    run button, **IIS Express**. By default, the **IIS Express** setting sets `ASPNETCORE_ENVIRONMENT`
    to `Development`. The following is a typical `launchSettings.json` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Environment`变量来自`ASPNETCORE_ENVIRONMENT`环境变量。反过来，当应用程序在Visual Studio的**解决方案资源管理器**中运行时，它定义在`Properties\launchSettings.json`文件中。在这个文件中，你可以定义几个环境，可以通过Visual
    Studio运行按钮旁边的下拉菜单选择，**IIS Express**。默认情况下，**IIS Express**设置将`ASPNETCORE_ENVIRONMENT`设置为`Development`。以下是一个典型的`launchSettings.json`文件：'
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The value to use for `ASPNETCORE_ENVIRONMENT` when the application is published
    can be added to the published XML file after it has been created by Visual Studio.
    This value is `<EnvironmentName>Staging</EnvironmentName>`. It can also be specified
    in your Visual Studio ASP.NET Core project file (`.csproj`):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序发布时，用于`ASPNETCORE_ENVIRONMENT`的值可以在Visual Studio创建后添加到发布的XML文件中。此值为`<EnvironmentName>Staging</EnvironmentName>`。它也可以在您的Visual
    Studio ASP.NET Core项目文件（`.csproj`）中指定：
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each middleware in the pipeline is defined by an `app.Use<something>` method,
    which often accepts some options. Each of them processes the requests and then
    either forwards the modified request to the next one in the pipeline or returns
    an HTTP response. When an HTTP response is returned, it is processed by all the
    previous ones in reverse order.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的每个中间件都由一个`app.Use<something>`方法定义，它通常接受一些选项。每个都会处理请求，然后将修改后的请求转发到管道中的下一个，或者返回一个HTTP响应。当返回HTTP响应时，它将按相反顺序处理所有之前的中间件。
- en: Modules are inserted in the pipeline in the order they are defined by the `app.Use<something>`
    method calls. The preceding code adds an error page if `ASPNETCORE_ENVIRONMENT`
    is `Development`. A complete description of the ASP.NET Core pipeline will be
    given in the *Understanding the presentation layers of web applications* section
    of *Chapter 17*, *Presenting ASP.NET Core*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 模块按照`app.Use<something>`方法定义的顺序插入到管道中。前面的代码在`ASPNETCORE_ENVIRONMENT`为`Development`时添加一个错误页面。关于ASP.NET
    Core管道的完整描述将在第17章“理解Web应用程序的表现层”部分中给出。
- en: In the next subsection, we will explain how the MVC framework lets you implement
    REST services.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将解释MVC框架如何让您实现REST服务。
- en: Implementing REST services with ASP.NET Core
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 实现REST服务
- en: Today, we can guarantee that the use of MVC and a web API is consolidated. In
    the MVC framework, HTTP requests are processed by classes called controllers.
    Each request is mapped to the call of a controller public method. The selected
    controller and controller methods depend on the shape of the request path, and
    they are defined by routing rules, which, for the REST API, are usually provided
    through attributes associated with both the `Controller` class and its methods.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们可以保证 MVC 和 Web API 的使用已经得到巩固。在 MVC 框架中，HTTP 请求由称为控制器的类处理。每个请求都映射到控制器公共方法的调用。所选控制器及其控制器方法取决于请求路径的形状，它们由路由规则定义，对于
    REST API，这些规则通常通过与 `Controller` 类及其方法关联的属性提供。
- en: ASP.NET Core 6 has introduced minimal APIs to simplify the mechanism of implementing
    APIs with C#. You can find a good explanation of it at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 6 引入了最小 API 以简化使用 C# 实现 API 的机制。您可以在[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis)找到关于它的良好解释。
- en: '`Controller` methods that process HTTP requests are called action methods.
    When the controller and action methods are selected, the MVC framework creates
    a controller instance to serve the request. All the parameters of the controller
    constructors are resolved with dependency injection.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求的 `Controller` 方法称为操作方法。当控制器和操作方法被选中时，MVC 框架创建一个控制器实例来处理请求。控制器构造函数的所有参数都通过依赖注入解决。
- en: Please refer to the *Using generic hosts* subsection of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*, for a description
    of how to use dependency injection with a .NET host and to the *Dependency injection
    pattern* subsection of *Chapter 6*, *Design Patterns and .NET 8 Implementation*,
    for a general discussion of dependency injection.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅第 11 章，*将微服务架构应用于您的企业应用程序*中的*使用通用宿主*子节，了解如何使用 .NET 宿主进行依赖注入的描述，以及第 6 章，*设计模式和
    .NET 8 实现*中的*依赖注入模式*子节，了解依赖注入的一般讨论。
- en: 'The following is a typical REST API controller and its controller method definitions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个典型的 REST API 控制器及其控制器方法定义：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `[ApiController]` attribute declares that the controller is a REST API controller.
    `[Route("api/[controller]")]` declares that the controller must be selected on
    paths that start with `api/<controller name>`. The controller’s name is the name
    of the controller class without the `Controller` postfix. This is preferred over
    hardcoding a controller name to save time on refactoring. Thus, in this case,
    we have `api/values`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ApiController]` 属性声明该控制器是一个 REST API 控制器。`[Route("api/[controller]")]` 声明控制器必须在以
    `api/<controller name>` 开头的路径上被选中。控制器的名称是控制器类名称，不带 `Controller` 后缀。这比硬编码控制器名称更节省重构时间。因此，在这种情况下，我们有
    `api/values`。'
- en: '`[HttpGet("{id}")]` declares that the method must be invoked on GET requests
    of the `api/values/<id>` type, where `id` must be a number that’s passed as an
    argument to the method invocation. This can be done with `Get(int id)`. There
    is also an `Http<verb>` attribute for each HTTP verb: `HttpPost` and `HttpPatch`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`[HttpGet("{id}")]` 声明该方法必须在 `api/values/<id>` 类型的 GET 请求上被调用，其中 `id` 必须是一个作为方法调用参数传递的数字。这可以通过
    `Get(int id)` 实现。对于每个 HTTP 动词，也存在一个 `Http<verb>` 属性：`HttpPost` 和 `HttpPatch`。'
- en: 'We may also have another method defined like so:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义另一个方法，如下所示：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method is invoked on `GET` requests of the `api/values` type, that is,
    on `GET` requests without `id` after the controller’s name.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在 `api/values` 类型的 `GET` 请求上被调用，即在没有控制器名称后跟 `id` 的 `GET` 请求上。
- en: Several action methods can have the same name, but only one should be compatible
    with each request path; otherwise, an exception is thrown. In other words, routing
    rules and `Http<verb>` attributes must univocally define which controller and
    which of its action methods to select for each request.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 几个操作方法可以具有相同的名称，但每个请求路径只能有一个与之兼容；否则，会抛出异常。换句话说，路由规则和 `Http<verb>` 属性必须唯一地定义每个请求应选择哪个控制器及其哪个操作方法。
- en: By default, parameters are passed to the action methods of API controllers according
    to the following rules.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数根据以下规则传递给 API 控制器的操作方法。
- en: Simple types (`integers`, `floats`, and `DateTimes`) are taken from the request
    path if routing rules specify them as parameters, as in the case of the previous
    example’s `[HttpGet("{id}")]` attribute. If they are not found in the routing
    rules, the ASP.NET Core framework looks for query string parameters with the same
    name. Thus, for instance, if we replace `[HttpGet("{id}")]` with `[HttpGet]`,
    the ASP.NET Core framework will look for something like `api/values?id=<id type>`
    or `api/values/{id}`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 简单类型（`整数`、`浮点数`和 `DateTimes`）如果路由规则指定它们为参数，则从请求路径中获取，例如上一个示例的 `[HttpGet("{id}")]`
    属性。如果它们在路由规则中找不到，ASP.NET Core 框架将寻找具有相同名称的查询字符串参数。因此，如果我们用 `[HttpGet("{id}")]`
    替换 `[HttpGet]`，ASP.NET Core 框架将寻找类似 `api/values?id=<id type>` 或 `api/values/{id}`
    的内容。
- en: Complex types are extracted from the request body by formatters. The right formatter
    is chosen according to the value of the request’s `Content-Type` header. If no
    `Content-Type` header is specified, the JSON formatter is taken. The JSON formatter
    tries to parse the request body as a JSON object and then tries to transform this
    JSON object into an instance of the .NET complex type. If either the JSON extraction
    or the subsequent conversion fails, an exception is thrown. As described in *Chapter
    2, Non-Functional Requirements*, be careful with exceptions since their computational
    costs are much higher than a normal code flow.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂类型通过格式化程序从请求体中提取。根据请求的 `Content-Type` 头部的值选择正确的格式化程序。如果没有指定 `Content-Type`
    头部，则使用 JSON 格式化程序。JSON 格式化程序尝试将请求体解析为 JSON 对象，然后尝试将此 JSON 对象转换为 .NET 复杂类型的实例。如果
    JSON 提取或后续转换失败，则抛出异常。如 *第 2 章，非功能性需求* 中所述，由于异常的计算成本远高于正常代码流，因此请小心处理异常。
- en: If an exception is inevitable, consider using the recommendations for logging
    described in *Chapter 4, Best Practices in Coding C# 12*. By default, just the
    JSON input formatter is supported, but you can also add an XML formatter that
    can be used when `Content-Type` specifies XML content.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不可避免地出现异常，请考虑使用 *第 4 章，C# 编码最佳实践 12* 中描述的日志记录建议。默认情况下，仅支持 JSON 输入格式化程序，但您也可以添加一个
    XML 格式化程序，当 `Content-Type` 指定 XML 内容时可以使用。
- en: 'You can customize the source that is used to fill an action method parameter
    by prefixing the parameter with an adequate attribute. The following code shows
    some examples of this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在参数前加上适当的属性来自定义用于填充动作方法参数的源。以下代码显示了此示例的一些示例：
- en: '[PRE16]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The return type of an action method can be an `IActionResult` interface, a
    type that implements that interface, or a DTO directly. In turn, `IActionResult`
    has just the following method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 动作方法的返回类型可以是 `IActionResult` 接口、实现该接口的类型或 DTO。反过来，`IActionResult` 只有以下方法：
- en: '[PRE17]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method is called by the MVC framework at the right time to create the actual
    response and response headers. The `ActionContext` object, when passed to the
    method, contains the whole context of the HTTP request, which includes a request
    object with all the necessary information about the original HTTP requests (headers,
    body, and cookies), as well as a response object that collects all the pieces
    of the response that is being built.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法由 MVC 框架在正确的时间调用以创建实际的响应和响应头。当传递给方法时，`ActionContext` 对象包含整个 HTTP 请求的上下文，其中包括一个包含有关原始
    HTTP 请求（头部、主体和 Cookie）所有必要信息的请求对象，以及一个收集正在构建的响应所有片段的响应对象。
- en: 'You do not have to create an implementation of `IActionResult` manually since
    `ControllerBase` already has methods to create `IActionResult` implementations
    so that all the necessary HTTP responses are generated. Some of these methods
    are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必手动创建 `IActionResult` 的实现，因为 `ControllerBase` 已经有创建 `IActionResult` 实现的方法，以便生成所有必要的
    HTTP 响应。以下是一些这些方法：
- en: '`OK`: This returns a 200 status code, as well as an optional result object.
    It is used as either `return OK()` or `return OK(myResult)`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OK`：这返回一个 200 状态码，以及一个可选的结果对象。它用作 `return OK()` 或 `return OK(myResult)`。'
- en: '`BadRequest`: This returns a 400 status code, as well as an optional response
    object.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BadRequest`：这返回一个 400 状态码，以及一个可选的响应对象。'
- en: '`Created(string uri, object o)`: This returns a 201 status code, as well as
    a result object and the URI of the created resource.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Created(string uri, object o)`: 这返回一个 201 状态码，以及一个结果对象和创建资源的 URI。'
- en: '`Accepted`: This returns a 202 status result, as well as an optional result
    object and resource URI.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accepted`：这返回一个 202 状态结果，以及一个可选的结果对象和资源 URI。'
- en: '`Unauthorized`: This returns a 401 status result, as well as an optional result
    object.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unauthorized`：这返回一个401状态结果，以及一个可选的结果对象。'
- en: '`Forbid`: This returns a 403 status result, as well as an optional list of
    failed permissions.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Forbid`：这返回一个403状态结果，以及一个可选的失败权限列表。'
- en: '`StatusCode(int statusCode, object o = null)`: This returns a custom status
    code, as well as an optional result object.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StatusCode(int statusCode, object o = null)`：这返回一个自定义状态码，以及一个可选的结果对象。'
- en: An action method can return a result object directly with `return myObject`.
    This is equivalent to returning `OK(myObject)`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 动作方法可以直接使用`return myObject`返回结果对象。这相当于返回`OK(myObject)`。
- en: When all the result paths return a result object of the same type, say, `MyType`,
    the action method can be declared as returning `ActionResult<MyType>`. You may
    also return responses like `NotFound`, but for sure, you will get a better type
    of check with this approach.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有结果路径返回相同类型的对象，例如`MyType`，动作方法可以声明为返回`ActionResult<MyType>`。你也可以返回类似`NotFound`的响应，但无疑，这种方法可以得到更好的类型检查。
- en: By default, result objects are serialized in JSON in the response body. However,
    if an XML formatter has been added to the ASP.NET Core framework processing pipeline,
    as shown previously, the way the result is serialized depends on the `Accept`
    header of the HTTP request. More specifically, if the client explicitly requires
    XML format with the `Accept` header, the object will be serialized in XML; otherwise,
    it will be serialized in JSON.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，结果对象在响应体中以JSON格式序列化。然而，如果已将XML格式化程序添加到ASP.NET Core框架处理管道中，如前所述，结果的序列化方式取决于HTTP请求的`Accept`头。更具体地说，如果客户端明确要求使用`Accept`头以XML格式，对象将以XML格式序列化；否则，将以JSON格式序列化。
- en: 'Complex objects that are passed as input to action methods can be validated
    with validation attributes as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将作为输入传递给动作方法的复杂对象可以使用以下验证属性进行验证：
- en: '[PRE18]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the controller has been decorated with the `[ApiController]` attribute and
    if validation fails, the ASP.NET Core framework automatically creates a `BadRequest`
    response containing a dictionary with all the validation errors detected, without
    executing the action method. Therefore, you do not need to add further code to
    handle validation errors.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制器已用`[ApiController]`属性装饰，并且验证失败，ASP.NET Core框架会自动创建一个包含所有检测到的验证错误的`BadRequest`响应，而不执行动作方法。因此，你不需要添加额外的代码来处理验证错误。
- en: 'Action methods can also be declared as `async` methods, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 动作方法也可以声明为`async`方法，如下所示：
- en: '[PRE19]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Practical examples of controllers/action methods will be shown in *Use case
    – exposing WWTravelClub packages,* presented in *Chapter 21, Case Study*. In the
    next subsection, we will explain how to handle authorization and authentication
    with JWTs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的控制器/动作方法示例将在*用例 - 暴露WWTravelClub包*中展示，该用例在*第21章，案例研究*中介绍。在下一个小节中，我们将解释如何使用JWT处理授权和身份验证。
- en: ASP.NET Core service authorization
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASP.NET Core服务授权
- en: When using a JWT, authorizations are based on the claims contained in the JWT.
    All the token claims in any action method can be accessed through the `User.Claims`
    controller property. Since `User.Claims` is an `IEnumerable<Claim>`, it can be
    processed with LINQ to verify complex conditions on claims.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JWT时，授权基于JWT中包含的声明。任何动作方法中的所有令牌声明都可以通过`User.Claims`控制器属性访问。由于`User.Claims`是`IEnumerable<Claim>`，它可以使用LINQ进行处理，以验证声明上的复杂条件。
- en: 'If authorization is based on *role* claims, you can simply use the `User.IsInRole`
    function, as shown in the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基于*角色*声明进行授权，你可以简单地使用`User.IsInRole`函数，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, permissions are not usually checked from within action methods and
    are automatically checked by the MVC framework according to authorization attributes
    that decorate either the whole controller or a single action method. If an action
    method or the whole controller is decorated with `[Authorize]`, then access to
    the action method is possible only if the request has a valid authentication token,
    which means we don’t have to perform a check on the token claims. It is also possible
    to check whether the token contains a set of roles using the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常不会在动作方法内部检查权限，而是由MVC框架根据装饰整个控制器或单个动作方法的授权属性自动检查。如果动作方法或整个控制器被`[Authorize]`装饰，则只有当请求具有有效的身份验证令牌时，才能访问动作方法，这意味着我们不需要对令牌声明进行检查。也可以使用以下代码检查令牌是否包含一组角色：
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'More complex conditions on claims require that authorization policies be defined
    while building the app in `Program.cs`, as shown in the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的声明条件，需要在构建应用程序时在 `Program.cs` 中定义授权策略，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After that, you can decorate the action methods or controllers with `[Authorize(Policy
    = "Father")]`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以对动作方法或控制器使用 `[Authorize(Policy = "Father")]` 装饰器。
- en: 'Before using JWT-based authorization, you must configure it in `Program.cs`.
    First, you must add the middleware that processes authentication tokens in ASP.NET
    Core, as shown here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用基于 JWT 的授权之前，您必须在 `Program.cs` 中进行配置。首先，您必须添加处理 ASP.NET Core 中身份验证令牌的中间件，如下所示：
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, you must configure the authentication services. There, you define the
    authentication options that will be injected through dependency injection into
    the authentication middleware:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须配置身份验证服务。在那里，您定义将通过依赖注入注入到身份验证中间件的身份验证选项：
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code provides a name to the authentication scheme, that is, a
    default name. Then, it specifies JWT authentication options. Usually, we require
    that the authentication middleware verifies that the JWT is not expired (`ValidateLifetime
    = true`), that it has the right issuer and audience (see the *REST service authorization
    and authentication* section of this chapter), and that its signature is valid.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为身份验证方案提供了一个名称，即默认名称。然后，它指定 JWT 身份验证选项。通常，我们要求身份验证中间件验证 JWT 是否未过期（`ValidateLifetime
    = true`），它是否有正确的发行者和受众（参见本章的 *REST 服务授权和身份验证* 部分），以及其签名是否有效。
- en: The preceding example uses a symmetric signing key generated from a string.
    This means that the same key is used to sign and verify the signature. This is
    an acceptable choice if JWTs are created by the same website that uses them, but
    it is not an acceptable choice if there is a unique JWT issuer that controls access
    to several web API sites.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用从字符串生成的对称签名密钥。这意味着相同的密钥用于签名和验证签名。如果 JWT 由使用它们的同一网站创建，这是一个可接受的选择，但如果有一个独特的
    JWT 发行者控制对多个 Web API 站点的访问，则这不是一个可接受的选择。
- en: Here, we should use an asymmetric key (typically, an `RsaSecurityKey`), so JWT
    verification requires just the knowledge of the public key associated with the
    actual private signing key. IdentityServer 4 can be used to quickly create a website
    that works as an authentication server. It emits a JWT with the usual username/password
    credentials or converts other authentication tokens. If you use an authentication
    server such as IdentityServer 4, you do not need to specify the `IssuerSigningKey`
    option since the authorization middleware is able to retrieve the required public
    key from the authorization server automatically.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该使用非对称密钥（通常是 `RsaSecurityKey`），因此 JWT 验证只需要知道与实际私有签名密钥关联的公钥。可以使用 IdentityServer
    4 快速创建一个作为身份验证服务器的网站。它可以使用常规的用户名/密码凭据发出 JWT 或转换其他身份验证令牌。如果您使用像 IdentityServer
    4 这样的身份验证服务器，则不需要指定 `IssuerSigningKey` 选项，因为授权中间件能够自动从授权服务器检索所需的公钥。
- en: 'It is enough to provide the authentication server URL, as shown here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 只需提供身份验证服务器 URL 即可，如下所示：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On the other hand, if you decide to emit a JWT in your web API’s site, you
    can define a `Login` action method that accepts an object with a username and
    password and that, while relying on database information, builds the JWT with
    code similar to the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您决定在您的 Web API 站点发出 JWT，您可以定义一个 `Login` 动作方法，该方法接受一个包含用户名和密码的对象，并且依赖于数据库信息，使用类似于以下代码的方式构建
    JWT：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, `JwtSecurityTokenHandler().WriteToken(token)` generates the actual token
    string from the token properties contained in the `JwtSecurityToken` instance.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`JwtSecurityTokenHandler().WriteToken(token)` 从包含在 `JwtSecurityToken` 实例中的令牌属性生成实际的令牌字符串。
- en: In the next subsection, we will learn how to empower our web API with an OpenAPI
    documentation endpoint so that proxy classes for communicating with our services
    can be generated automatically.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将学习如何通过 OpenAPI 文档端点增强我们的 Web API，以便可以自动生成与我们的服务通信的代理类。
- en: ASP.NET Core support for OpenAPI
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASP.NET Core 对 OpenAPI 的支持
- en: Most of the information that is needed to fill in an OpenAPI JSON document can
    be extracted from web API controllers through reflection, that is, input types
    and sources (path, request body, and header) and endpoint paths (these can be
    extracted from routing rules). Returned output types and status codes, in general,
    cannot be easily computed since they can be generated dynamically.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 填写 OpenAPI JSON 文档所需的大部分信息可以通过反射从 Web API 控制器中提取，即输入类型和来源（路径、请求体和头部）以及端点路径（这些可以从路由规则中提取）。返回输出类型和状态码通常难以计算，因为它们可以动态生成。
- en: 'Therefore, the MVC framework provides the `ProducesResponseType` attribute
    so that we can declare a possible return type – a status code pair. It is enough
    to decorate each action method with as many `ProducesResponseType` attributes
    as there are possible types, that is, possible status code pairs, as shown in
    the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，MVC 框架提供了 `ProducesResponseType` 属性，以便我们可以声明可能的返回类型——状态码对。只需用尽可能多的 `ProducesResponseType`
    属性装饰每个操作方法，即可能的类型，也就是可能的状态码对，如下所示：
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If no object is returned along a path, we can just declare the status code
    as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径上没有返回任何对象，我们只需声明状态码如下：
- en: '[PRE28]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can also specify just the status code when all the paths return the same
    type and when that type is specified in the action method return type as `ActionResult<CommonReturnType>`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在所有路径返回相同类型且该类型已在操作方法返回类型中指定为 `ActionResult<CommonReturnType>` 时，仅指定状态码。
- en: 'Once all the action methods have been documented, to generate any actual documentation
    for the JSON endpoints, we must install the `Swashbuckle.AspNetCore` NuGet package
    and place some code in the `Program.cs` file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有操作方法都已记录，要生成 JSON 端点的任何实际文档，我们必须安装 `Swashbuckle.AspNetCore` NuGet 包并在 `Program.cs`
    文件中放置一些代码：
- en: In .NET 5+, you can automatically include it by leaving **OpenAPI support**
    checked when creating a project.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 5+ 中，您可以通过在创建项目时勾选 **OpenAPI 支持** 来自动包含它。
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first argument of the `SwaggerDoc` method is the documentation endpoint
    name. By default, the documentation endpoint is accessible through the `<webroot>//swagger/<endpoint
    name>/swagger.json` path, but this can be changed in several ways. The rest of
    the information contained in the `Info` class is self-explanatory.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwaggerDoc` 方法的第一个参数是文档端点名称。默认情况下，文档端点可通过 `<webroot>//swagger/<endpoint name>/swagger.json`
    路径访问，但可以通过多种方式更改。`Info` 类中包含的其他信息是自解释的。'
- en: We can add several `SwaggerDoc` calls to define several documentation endpoints.
    However, by default, all the documentation endpoints will contain the same documentation,
    which includes a description of all the REST services included in the project.
    This default can be changed by calling the `c.DocInclusionPredicate(Func<string,
    ApiDescription> predicate)` method from within `services.AddSwaggerGen(c => {...})`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加多个 `SwaggerDoc` 调用来定义多个文档端点。然而，默认情况下，所有文档端点都将包含相同的文档，其中包括项目中包含的所有 REST
    服务的描述。此默认值可以通过在 `services.AddSwaggerGen(c => {...})` 中调用 `c.DocInclusionPredicate(Func<string,
    ApiDescription> predicate)` 方法来更改。
- en: '`DocInclusionPredicate` must be passed a function that receives a JSON document
    name and an action method description and must return `true` if the documentation
    of the action must be included in that JSON document.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocInclusionPredicate` 必须传递一个函数，该函数接收一个 JSON 文档名称和一个操作方法描述，并且如果操作方法的文档必须包含在该
    JSON 文档中，则必须返回 `true`。'
- en: 'To declare that your REST APIs need a JWT, you must add the following code
    within `services.AddSwaggerGen(c => {...})`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明您的 REST API 需要JWT，您必须在 `services.AddSwaggerGen(c => {...})` 内部添加以下代码：
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can enrich the JSON documentation endpoint with information that has been
    extracted from triple-slash comments, which are usually added to generate automatic
    code documentation. The following code shows some examples of this. The following
    snippet shows how we can add a method description and parameter information:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从三斜杠注释中提取信息来丰富 JSON 文档端点，这些注释通常用于生成自动代码文档。以下代码展示了这一点的示例。以下代码片段展示了我们如何添加方法描述和参数信息：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following snippet shows how we can add parameter descriptions and return
    type descriptions for each HTTP status code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何为每个 HTTP 状态码添加参数描述和返回类型描述：
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To enable extraction from triple-slash comments, we must enable code documentation
    creation by adding the following code to our project file (`.csproj`):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用从三斜杠注释中提取，我们必须通过将以下代码添加到我们的项目文件（`.csproj`）中来启用代码文档创建：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we must enable code documentation processing from within `services.AddSwaggerGen(c
    => {...})` by adding the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在 `services.AddSwaggerGen(c => {...})` 内启用代码文档处理，通过添加以下代码：
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once our documentation endpoints are ready, we can add some more middleware
    that is contained in the same `Swashbuckle.AspNetCore` NuGet package to generate
    a friendly user interface that we can test our REST API on:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的文档端点准备就绪，我们可以添加一些包含在同一个 `Swashbuckle.AspNetCore` NuGet 包中的中间件，以生成一个友好的用户界面，我们可以在其上测试我们的
    REST API：
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you have several documentation endpoints, you need to add a `SwaggerEndpoint`
    call for each of them. We will use this interface to test the REST API defined
    in the book use case, presented in *Chapter 21, Case Study*. There you will also
    find out how to use Postman, an API platform for building and using APIs.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有多个文档端点，你需要为每个端点添加一个 `SwaggerEndpoint` 调用。我们将使用此接口来测试书中用例中定义的 REST API，该用例在
    *第 21 章，案例研究* 中介绍。在那里你还将了解到如何使用 Postman，一个用于构建和使用的 API 平台。
- en: 'Once you have a working JSON documentation endpoint, you can automatically
    generate the C# or TypeScript code of a proxy class, presented in *Chapter 6,
    Design Patterns and .NET 8 Implementation*, with one of the following methods:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了工作的 JSON 文档端点，你可以使用以下方法之一自动生成代理类的 C# 或 TypeScript 代码，该代理类在 *第 6 章，设计模式和
    .NET 8 实现* 中介绍：
- en: The NSwagStudio Windows program, which is available at [https://github.com/RicoSuter/NSwag/wiki/NSwagStudio](https://github.com/RicoSuter/NSwag/wiki/NSwagStudio).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在 [https://github.com/RicoSuter/NSwag/wiki/NSwagStudio](https://github.com/RicoSuter/NSwag/wiki/NSwagStudio)
    找到的 NSwagStudio Windows 程序。
- en: The `NSwag.CodeGeneration.CSharp` or `NSwag.CodeGeneration.TypeScript`NuGet
    packages if you want to customize code generation.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要自定义代码生成，可以使用 `NSwag.CodeGeneration.CSharp` 或 `NSwag.CodeGeneration.TypeScript`
    NuGet 包。
- en: The `NSwag.MSBuild` NuGet package if you want to tie code generation to Visual
    Studio build operations. The documentation for this can be found at [https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild](https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild).
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将代码生成与 Visual Studio 构建操作关联起来，可以使用 `NSwag.MSBuild` NuGet 包。有关此包的文档可以在 [https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild](https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild)
    找到。
- en: In the next subsection, you will learn how to invoke a REST API from another
    REST API or from a .NET client.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，你将学习如何从一个 REST API 或从 .NET 客户端调用 REST API。
- en: .NET HTTP clients
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET HTTP 客户端
- en: 'The `HttpClient` class in the `System.Net.Http` namespace is a .NET Standard
    2.0 built-in HTTP client class. While it could be used directly whenever we need
    to interact with a REST service, there are some problems in creating and releasing
    `HttpClient` instances repeatedly, as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Net.Http` 命名空间中的 `HttpClient` 类是一个 .NET Standard 2.0 内置的 HTTP 客户端类。虽然它可以直接在任何需要与
    REST 服务交互时使用，但反复创建和释放 `HttpClient` 实例存在一些问题，如下所述：'
- en: Their creation is expensive.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的创建成本很高。
- en: When an `HttpClient` is released, for instance, in a using statement, the underlying
    connection is not closed immediately but at the first garbage collection session.
    Therefore, repeated creation and release operations quickly exhaust the maximum
    number of connections the operating system can handle.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `HttpClient` 被释放时，例如在 using 语句中，底层的连接不会立即关闭，而是在第一次垃圾回收会话时关闭。因此，重复的创建和释放操作会迅速耗尽操作系统可以处理的连接最大数量。
- en: Therefore, either a single `HttpClient` instance is reused, such as a Singleton,
    or `HttpClient` instances are somehow pooled. Starting from the 2.1 version of
    .NET Core, the `HttpClientFactory` class was introduced to pool HTTP clients.
    More specifically, whenever a new `HttpClient` instance is required for an `HttpClientFactory`
    object, a new `HttpClient` is created. However, the underlying `HttpClientMessageHandler`
    instances, which are expensive to create, are pooled until their maximum lifetime
    expires.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以重用单个 `HttpClient` 实例，例如 Singleton，或者以某种方式池化 `HttpClient` 实例。从 .NET Core
    2.1 版本开始，引入了 `HttpClientFactory` 类来池化 HTTP 客户端。更具体地说，每当需要为 `HttpClientFactory`
    对象创建新的 `HttpClient` 实例时，就会创建一个新的 `HttpClient`。然而，底层的 `HttpClientMessageHandler`
    实例，创建成本较高，会被池化直到其最大生命周期到期。
- en: '`HttpClientMessageHandler` instances must have a finite duration since they
    cache DNS resolution information that may change over time. The default lifetime
    of `HttpClientMessageHandler` is 2 minutes, but it can be redefined by the developer.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClientMessageHandler` 实例必须有一个有限的生命周期，因为它们缓存了可能随时间变化的 DNS 解析信息。`HttpClientMessageHandler`
    的默认生命周期为 2 分钟，但可以被开发者重新定义。'
- en: Using `HttpClientFactory` allows us to automatically pipeline all the HTTP operations
    with other operations. For instance, we can add a Polly retry strategy to handle
    all the failures of all our HTTP operations automatically. For an introduction
    to Polly, please refer to the *Resilient task execution* subsection of *Chapter
    5*, *Implementing Code Reusability in C# 12*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HttpClientFactory`允许我们自动将所有HTTP操作与其他操作进行管道化。例如，我们可以添加Polly重试策略来自动处理所有HTTP操作的所有失败。有关Polly的介绍，请参阅第5章的*实现C#
    12中的代码重用*的*弹性任务执行*子节。
- en: 'The simplest way to exploit the advantages offered by the `HttpClientFactory`
    class is to add the `Microsoft.Extensions.Http` NuGet package and then follow
    these steps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 利用`HttpClientFactory`类提供的优势的最简单方法是添加`Microsoft.Extensions.Http` NuGet包，然后按照以下步骤操作：
- en: Define a proxy class, say, `MyProxy`, to interact with the desired REST service.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个代理类，例如`MyProxy`，以与所需的REST服务交互。
- en: Let `MyProxy` accept an `HttpClient` instance in its constructor.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`MyProxy`在其构造函数中接受一个`HttpClient`实例。
- en: Use the `HttpClient` that was injected into the constructor to implement all
    the necessary operations.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用构造函数中注入的`HttpClient`来实现所有必要的操作。
- en: Declare your proxy in the services configuration method of your host, which,
    in the case of an ASP.NET Core application, is in the `Program.cs` class. In the
    simplest case, the declaration is something similar to `builder.Services.AddHttpClient<MyProxy>()`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在宿主的服务配置方法中声明你的代理，在ASP.NET Core应用程序的情况下，这个方法位于`Program.cs`类中。在最简单的情况下，声明类似于`builder.Services.AddHttpClient<MyProxy>()`。
- en: This will automatically add `MyProxy` to the services that are available for
    dependency injection, so you can easily inject it, for instance, in your controller’s
    constructors. Moreover, each time an instance of `MyProxy` is created, an `HttpClient`
    is returned by an `HttpClientFactory` and is automatically injected into its constructor.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`MyProxy`将自动添加到可用于依赖注入的服务中，因此你可以轻松地在控制器构造函数中注入它。此外，每次创建`MyProxy`的实例时，`HttpClientFactory`都会返回一个`HttpClient`实例，并将其自动注入到其构造函数中。
- en: 'In the constructors of the classes that need to interact with a REST service,
    we may also need an interface instead of a specific proxy implementation with
    a declaration of the type:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要与REST服务交互的类构造函数中，我们可能也需要一个接口，而不是具有类型声明的特定代理实现：
- en: '[PRE37]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This way, each client that is passed to the proxy is preconfigured so that it
    requires a JSON response and must work with a specific service. Once the base
    address has been defined, each HTTP request needs to specify the relative path
    of the service method to call.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个传递给代理的客户端都会预先配置，以便它需要一个JSON响应，并且必须与特定服务一起工作。一旦定义了基本地址，每个HTTP请求都需要指定要调用的服务方法的相对路径。
- en: 'The following code shows how to perform a `POST` to a service. This requires
    an extra package, `System.Net.Http.Json`, because of the usage of `PostAsJsonAsync`.
    Here, we are stating that the `HttpClient` that was injected into the proxy constructor
    has been stored in the `webClient` private field:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何向服务执行`POST`操作。这需要额外的包`System.Net.Http.Json`，因为使用了`PostAsJsonAsync`。在这里，我们声明注入到代理构造函数中的`HttpClient`已经被存储在`webClient`私有字段中：
- en: '[PRE38]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you use Polly, you do not need to intercept and handle communication errors
    since this job is performed by Polly. First, you need to verify the status code
    to decide what to do next. Then, you can parse the JSON string contained in the
    response body to get a .NET instance of a type that, in general, depends on the
    status code. The code to perform the parsing is based on the `System.Text.Json`
    NuGet package’s `JsonSerializer` class and is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Polly，你不需要拦截和处理通信错误，因为这个任务由Polly执行。首先，你需要验证状态码以决定下一步要做什么。然后，你可以解析响应体中包含的JSON字符串，以获取一个.NET类型的实例，这通常取决于状态码。执行解析的代码基于`System.Text.Json`
    NuGet包的`JsonSerializer`类，如下所示：
- en: '[PRE39]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Performing a `GET` request is similar, but instead of calling `PostAsJsonAsync`,
    you need to call `GetAsync`, as shown here. The use of other HTTP verbs is completely
    analogous:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`GET`请求类似，但需要调用`GetAsync`而不是`PostAsJsonAsync`，如下所示。其他HTTP动词的使用完全类似：
- en: '[PRE40]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see from this section, accessing HTTP APIs is quite simple and requires
    the implementation of some .NET 6 libraries. Since the beginning of .NET Core,
    Microsoft has been working a lot on improving the performance and simplicity of
    this part of the framework. It is up to you to keep yourself updated on the documentation
    and facilities they keep implementing.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本节中看到的那样，访问 HTTP API 非常简单，需要实现一些 .NET 6 库。自 .NET Core 以来，Microsoft 一直在努力改进框架的这一部分的性能和简单性。您需要确保自己了解他们持续实施的文档和设施。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced SOA, its design principles, and its constraints.
    Among them, interoperability is worth remembering.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 SOA、其设计原则和其约束。其中，互操作性值得记住。
- en: Then, we focused on well-established standards for business applications that
    achieve the interoperability that is needed for publicly exposed services. Therefore,
    SOAP and REST services were discussed in detail, along with the transition from
    SOAP services to REST services that has taken place in most application areas
    in the last few years. Then, REST service principles, authentication/authorization,
    and documentation were described in greater detail.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们关注了适用于业务应用的标准，这些标准实现了公开服务所需的互操作性。因此，详细讨论了 SOAP 和 REST 服务，以及在过去几年中大多数应用领域发生的从
    SOAP 服务到 REST 服务的转变。然后，更详细地描述了 REST 服务原则、认证/授权和文档。
- en: Finally, we looked at the tools that are available in .NET 8 that we can use
    to implement and interact with services. We looked at a variety of frameworks
    for intra-cluster communication, such as .NET remoting and gRPC, and tools for
    SOAP- and REST-based public services.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了 .NET 8 中可用的工具，我们可以使用这些工具来实现和交互服务。我们探讨了用于集群内通信的各种框架，如 .NET 远程过程调用和 gRPC，以及基于
    SOAP 和 REST 的公共服务的工具。
- en: Here, we mainly focused on REST services. Their ASP.NET Core implementations
    were described in detail, along with the techniques we can use to authenticate/authorize
    them and their documentation. We also focused on how to implement efficient .NET
    proxies so that we can interact with REST services.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们主要关注 REST 服务。它们的 ASP.NET Core 实现被详细描述，包括我们可以用来认证/授权它们的技巧以及它们的文档。我们还关注了如何实现高效的
    .NET 代理，以便我们可以与 REST 服务交互。
- en: In the next chapter, we will learn how to use .NET 8 to implement microservices
    with ASP.NET Core.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 .NET 8 实现 ASP.NET Core 微服务。
- en: Questions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can services use cookie-based sessions?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务可以使用基于 cookie 的会话吗？
- en: Is it good practice to implement a service with a custom communication protocol?
    Why or why not?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个具有自定义通信协议的服务是否是好的实践？为什么或为什么不？
- en: Can a `POST` request to a REST service cause a deletion?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 REST 服务发送的 `POST` 请求会导致删除吗？
- en: How many dot-separated parts are contained in a JWT bearer token?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT 持有者令牌中包含多少个点分隔的部分？
- en: By default, where are the complex type parameters of a REST service’s action
    methods taken from?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，REST 服务操作方法的复杂类型参数是从哪里获取的？
- en: How is a controller declared as a REST service?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何声明控制器作为 REST 服务？
- en: What are the main documentation attributes of ASP.NET Core services?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core 服务的最主要文档属性是什么？
- en: How are ASP.NET Core REST service routing rules declared?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core REST 服务路由规则是如何声明的？
- en: How should a proxy be declared so that we can take advantage of .NET `HttpClientFactory`
    class features?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何声明代理，以便我们可以利用 .NET `HttpClientFactory` 类的功能？
- en: Further reading
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'This chapter mainly focused on the more commonly used REST service. If you
    are interested in SOAP services, a good place to start is the Wikipedia page regarding
    SOAP specifications: [https://en.wikipedia.org/wiki/List_of_web_service_specifications](https://en.wikipedia.org/wiki/List_of_web_service_specifications).
    On the other hand, if you are interested in the Microsoft .NET WCF technology
    for implementing SOAP services, you can refer to WCF’s official documentation
    here: [https://docs.microsoft.com/en-us/dotnet/framework/wcf/](https://docs.microsoft.com/en-us/dotnet/framework/wcf/).'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章主要关注更常用的 REST 服务。如果您对 SOAP 服务感兴趣，可以从关于 SOAP 规范的维基百科页面开始了解：[https://en.wikipedia.org/wiki/List_of_web_service_specifications](https://en.wikipedia.org/wiki/List_of_web_service_specifications)。另一方面，如果您对实现
    SOAP 服务的 Microsoft .NET WCF 技术感兴趣，可以在此处参考 WCF 的官方文档：[https://docs.microsoft.com/en-us/dotnet/framework/wcf/](https://docs.microsoft.com/en-us/dotnet/framework/wcf/).
- en: 'This chapter mentioned the AMQP protocol as an option for intra-cluster communication
    without describing it. Detailed information on this protocol is available on AMQP’s
    official site: [https://www.amqp.org/](https://www.amqp.org/).'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章提到了 AMQP 协议作为集群内部通信的选项，但没有对其进行描述。关于此协议的详细信息可在 AMQP 的官方网站找到：[https://www.amqp.org/](https://www.amqp.org/).
- en: 'More information on gRPC is available on Google gRPC’s official site: [https://grpc.io/](https://grpc.io/).
    More information on the Visual Studio gRPC project template can be found here:
    [https://docs.microsoft.com/en-US/aspnet/core/grpc/](https://docs.microsoft.com/en-US/aspnet/core/grpc/).
    You may also want to check out gRPC-Web at [https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/).'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 gRPC 的更多信息可在 Google gRPC 的官方网站找到：[https://grpc.io/](https://grpc.io/). 关于
    Visual Studio gRPC 项目模板的更多信息请在此处查看：[https://docs.microsoft.com/en-US/aspnet/core/grpc/](https://docs.microsoft.com/en-US/aspnet/core/grpc/).
    您还可以查看 gRPC-Web，详情请访问：[https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/).
- en: 'More details on ASP.NET Core services are available in the official documentation:
    [https://docs.microsoft.com/en-US/aspnet/core/web-api/](https://docs.microsoft.com/en-US/aspnet/core/web-api/).
    More information on the .NET HTTP client is available here: [https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests](https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests).'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 ASP.NET Core 服务的更多详细信息可在官方文档中找到：[https://docs.microsoft.com/en-US/aspnet/core/web-api/](https://docs.microsoft.com/en-US/aspnet/core/web-api/).
    关于 .NET HTTP 客户端的更多信息请在此处查看：[https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests](https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests).
- en: Minimal APIs are described at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小 API 的描述可在 [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis)
    找到。
- en: 'More information on JWT authentication is available here: [https://jwt.io/](https://jwt.io/).
    If you would like to generate JWTs with IdentityServer, you may refer to its official
    documentation page: [https://docs.duendesoftware.com/identityserver/v7](https://docs.duendesoftware.com/identityserver/v7).'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 JWT 验证的更多信息请在此处查看：[https://jwt.io/](https://jwt.io/). 如果您想使用 IdentityServer
    生成 JWT，可以参考其官方文档页面：[https://docs.duendesoftware.com/identityserver/v7](https://docs.duendesoftware.com/identityserver/v7).
- en: 'More information on OpenAPI is available at [https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/),
    while more information on Swashbuckle can be found on its GitHub repository page:
    [https://github.com/domaindrivendev/Swashbuckle](https://github.com/domaindrivendev/Swashbuckle).'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 OpenAPI 的更多信息可在 [https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/)
    找到，而关于 Swashbuckle 的更多信息可在其 GitHub 仓库页面找到：[https://github.com/domaindrivendev/Swashbuckle](https://github.com/domaindrivendev/Swashbuckle).
- en: Leave a review!
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论来帮助像您这样的读者。扫描下面的二维码以获取 20% 的折扣码。
- en: '![](img/Leave_a_review_QR.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Leave_a_review_QR.png)'
- en: '**Limited Offer*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠**'
