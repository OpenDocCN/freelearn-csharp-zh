<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-77">
    <a id="_idTextAnchor105">
    </a>
    
     6
    
   </h1>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor106">
    </a>
    
     Parameter Binding
    
   </h1>
   <p>
    
     Context is a critical aspect of any API.
    
    
     The client has their own understanding of how data is structured, as does the server.
    
    
     For example, as the client, you will view API documentation that tells you to format a request payload in JSON format.
    
    
     You therefore create the JSON payload as per the
    
    
     
      API requirements.
     
    
   </p>
   <p>
    
     When the API receives your payload, it is not guaranteed that the object you transmitted will remain as JSON (especially in an ASP.NET API), and a mechanism will often be in place to bind the JSON object to a strongly typed .NET object that the API can manipulate more easily within its
    
    
     
      own context.
     
    
   </p>
   <p>
    
     Let us take another example.
    
    
     You (still as the client) make a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request for all logs corresponding to a
    
    <em class="italic">
     
      job
     
    </em>
    
     with a particular ID.
    
    
     However, you want to restrict the number of logs returned to 100, which the API allows you to do.
    
    
     According to the API documentation, you can do this by including the job ID in the route, and an option in the query string specifying how many logs you wish
    
    
     
      to return.
     
    
   </p>
   <p>
    
     When receiving this request from you as the client, the API will need to know where to look to retrieve these parameters, so that they can be used in the context of the request handler.
    
    
     This type of transformation of data between client and server during requests is known as
    
    <strong class="bold">
     
      parameter binding
     
    </strong>
    
     , and we
    
    <a id="_idIndexMarker178">
    </a>
    
     are going to explore it in detail in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     In this chapter, we will explore
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Parameter
     
     
      
       binding sources
      
     
    </li>
    <li>
     
      
       Binding precedence
      
     
    </li>
    <li>
     
      Creating custom
     
     
      
       parameter bindings
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-79">
    <a id="_idTextAnchor107">
    </a>
    
     Parameter binding sources
    
   </h1>
   <p>
    
     Out of the box, ASP.NET supports
    
    <a id="_idIndexMarker179">
    </a>
    
     several different parameter binding types.
    
    
     Each binding type has a source from which it can bind.
    
    
     Additionally, each binding source is situated in a different location within the request, with various ways in which they can be bound to data structures in
    
    
     
      the API.
     
    
   </p>
   <p>
    
     Let’s start with one of the most common binding sources, the
    
    
     
      route value.
     
    
   </p>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor108">
    </a>
    
     Route values
    
   </h2>
   <p>
    
     A
    
    <strong class="bold">
     
      route value
     
    </strong>
    
     is
    
    <a id="_idIndexMarker180">
    </a>
    
     simply a
    
    <a id="_idIndexMarker181">
    </a>
    
     section of an API route.
    
    
     Look at a typical route and imagine it is split into sections delimited by each occurrence of the
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     character.
    
    
     Each of these resulting sections is a value within
    
    
     
      the route.
     
    
   </p>
   <p>
    
     Take this example:
    
    <strong class="source-inline">
     
      /todoitems/2
     
    </strong>
    
     .
    
    
     It would be split into two route value sections:
    
    <strong class="source-inline">
     
      todoitems
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       2
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In this context,
    
    <strong class="source-inline">
     
      2
     
    </strong>
    
     is the route value we are interested in, because it is the ID of a
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     entity.
    
    
     So, how can we access this within
    
    
     
      an endpoint?
     
    
   </p>
   <pre class="source-code">
app.MapGet("/todoitems/{id}", (int id) =&gt;
{
    TodoItem item = GetById(id);
    if(item != null)
    {
        return Results.Ok(item);
    }
    return Results.NotFound();
});</pre>
   <p>
    
     In this code, we can see that the incoming route has been modified to add a value surrounded by curly braces.
    
    
     This
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     value is a placeholder for an integer value that will be passed in its place from the
    
    
     
      client’s perspective.
     
    
   </p>
   <p>
    
     In the parameter of the lambda expression that follows the route, we declare that we are passing in an integer parameter, called
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     .
    
    
     We can do this thanks to ASP.NET’s routing module, which detects the route value placeholder and parses out the actual value, converting it to the data type needed for the lambda expression, which in this case is
    
    
     
      an integer.
     
    
   </p>
   <p>
    
     On the client’s side, the requested route might look like
    
    
     
      this:
     
    
    
     <strong class="source-inline">
      
       https://myTodoAPI/todoitems/2
      
     </strong>
    
   </p>
   <p>
    
     It is important to remember that in this example, if an item with an
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     value of
    
    <strong class="source-inline">
     
      2
     
    </strong>
    
     does not exist, the binding will not match, and the endpoint won’t hit at all, instead returning
    
    <strong class="source-inline">
     
      404
     
    </strong>
    
     <strong class="source-inline">
      
       NOT FOUND
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     By declaring a route parameter in the endpoint, the
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     value of
    
    <strong class="source-inline">
     
      2
     
    </strong>
    
     found at the end of this route will be automatically detected and bound to the integer parameter declared in the lambda expression, allowing it to be used within
    
    
     
      the request.
     
    
   </p>
   <p>
    
     Route values do not have to be automatically bound to the lambda expression parameters.
    
    
     They can be manually accessed within the request by passing an
    
    <strong class="source-inline">
     
      HttpRequest
     
    </strong>
    
     object as the parameter instead.
    
    
     On
    
    <strong class="source-inline">
     
      HttpRequest
     
    </strong>
    
     , there is a
    
    <strong class="source-inline">
     
      RouteValues
     
    </strong>
    
     collection that will be populated with the values you need
    
    
     
      for binding.
     
    
   </p>
   <p>
    
     This is useful if you have multiple types of parameter bindings and you want to make the request more readable.
    
    
     Here’s an example that passes in an
    
    <strong class="source-inline">
     
      HttpRequest
     
    </strong>
    
     parameter.
    
    
     This does not require any change on the client side, as it is already present.
    
    
     By adding it as a
    
    <a id="_idIndexMarker182">
    </a>
    
     parameter, we
    
    <a id="_idIndexMarker183">
    </a>
    
     are allowing the endpoint to
    
    
     
      access it:
     
    
   </p>
   <pre class="source-code">
app.MapGet(
    "/todoitems/{id}",
    (HttpRequest request) =&gt;
{
    if(int.TryParse(
        request.RouteValues["id"].ToString(),
        out var id) == false)
    {
        return Results.BadRequest(
            "Could not convert id to integer");
    }
    TodoItem item = GetById(id);
    return Results.Ok(item);
});</pre>
   <p>
    
     When
    
    <a id="_idIndexMarker184">
    </a>
    
     making requests to an API, there are times when you need to be more granular
    
    <a id="_idIndexMarker185">
    </a>
    
     about the state or the conditions of a query you’re making.
    
    
     In these
    
    <a id="_idIndexMarker186">
    </a>
    
     situations, query strings can be added to the endpoint URL.
    
    
     This allows you to pass more specific parameters to
    
    
     
      the API.
     
    
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor109">
    </a>
    
     Query strings
    
   </h2>
   <p>
    
     In the case of route values, they
    
    <a id="_idIndexMarker187">
    </a>
    
     are often a direct route to data.
    
    
     Requesting something by an ID using a route value, on its own, produced a predictable result.
    
    
     However, data comes in many different forms, meaning that we often need to specify specific conditions that will transform the data we are retrieving in the required shape.
    
    <strong class="bold">
     
      Query strings
     
    </strong>
    
     allow us
    
    <a id="_idIndexMarker188">
    </a>
    
     to achieve this.
    
    
     They sit at the end of a route, and they have their own notation that defines them, starting with a
    
    <strong class="source-inline">
     
      ?
     
    </strong>
    
     
      character.
     
    
   </p>
   <p class="callout-heading">
    
     Checking for the presence of query string parameters
    
   </p>
   <p class="callout">
    
     The benefit of checking for the query strings before using them only if they exist is that we can make query string parameters optional (more on that in the next section).
    
    
     Otherwise, our code would assume that the client is always going to send query string values, therefore making them mandatory parameters for the endpoint.
    
    
     This is fine when intended, but in the examples shown in this chapter, the aim is to ensure that the client has the choice to either filter the data or not, using query
    
    
     
      string values.
     
    
   </p>
   <p>
    
     As we can see in this route,
    
    <strong class="source-inline">
     
      https://myTodoAPI/todoitems?pastDue=true&amp;priority=1
     
    </strong>
    
     , the query string starts at the end of the route values with a
    
    <strong class="source-inline">
     
      ?
     
    </strong>
    
     character.
    
    
     After this, a collection of key-value pairs
    
    
     
      is specified.
     
    
   </p>
   <p>
    
     The purpose
    
    <a id="_idIndexMarker189">
    </a>
    
     of the query string in the route is to pass a series
    
    <a id="_idIndexMarker190">
    </a>
    
     of variables into the API, which can be used to filter the data that will be returned.
    
    
     In this case, the client is requesting any
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     that is past its due date, but also has a priority with a value
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       1
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-82">
    <a id="_idTextAnchor110">
    </a>
    
     Optional query string parameters
    
   </h2>
   <p>
    
     You can make it so that a
    
    <a id="_idIndexMarker191">
    </a>
    
     parameter passed in is
    
    <a id="_idIndexMarker192">
    </a>
    
     optional.
    
    
     It’s very simple; you just make the query string parameter you added to the endpoint nullable by affixing a
    
    <strong class="source-inline">
     
      ?
     
    </strong>
    
     character to it.
    
    
     Then, in the body of your endpoint, you can check for the existence of an optional value.
    
    
     If the optional value is not null, you can
    
    
     
      use it.
     
    
   </p>
   <p>
    
     Here’s an example of an optional parameter used on an endpoint that fetches a todo item by ID.
    
    
     It allows the client to specify that the assignee must be a certain value.
    
    
     If the assignee value is not null and does not match the assignee value on the item, you can send a different response, such as
    
    <strong class="source-inline">
     
      404
     
    </strong>
    
     <strong class="source-inline">
      
       NOT FOUND
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
  app.MapGet(
      "/todoitems/{id}",
      (int id, string? assignee) =&gt;
  {
      var index = TodoItems.FindIndex(x =&gt; x.Id == id);
      if (index == -1)
      {
          return Results.NotFound();
      }
      var todoItem = TodoItems[index];
      if (assignee != null)
      {
          if(todoItem.Assignee != assignee)
          {
              return Results.NotFound();
          }
      }
      return Results.Ok(ToDoItems[index]);
  });</pre>
   <p>
    
     On the server side, the query
    
    <a id="_idIndexMarker193">
    </a>
    
     string parameters are
    
    <a id="_idIndexMarker194">
    </a>
    
     bound as per the following example.
    
    
     In this example, we are also checking for the existence of certain query string key-value pairs and building the relevant query for the data based on the specified query string values,
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       IQueryable
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
app.MapGet("/todoItems", (HttpRequest request) =&gt;
{
    bool pastDue = false;
    int priority = 0;
    var todoItemsQuery = ToDoItems.AsQueryable();
    if (request.Query.ContainsKey("pastDue"))
    {
        var parsedDueDate = bool.TryParse(
            request.Query["pastDue"],
            out pastDue
        );
        if (parsedDueDate) {
            todoItemsQuery = todoItemsQuery.Where(
                x =&gt; x.DueDate &lt;= DateTime.Now
            );
        }
    }
    if (request.Query.ContainsKey("priority"))
    {
        var parsedPriority = int.TryParse(
            request.Query["priority"],
            out priority
        );
        if (parsedPriority) {
            todoItemsQuery = todoItemsQuery.Where(
                x =&gt; x.Priority == priority
            );
        }
    }
    var result = todoItemsQuery.ToList();
    return Results.Ok(result);
});</pre>
   <p>
    
     We’ve spent most
    
    <a id="_idIndexMarker195">
    </a>
    
     of our time so far passing
    
    <a id="_idIndexMarker196">
    </a>
    
     parameters within the URLs of our requests.
    
    
     Let us explore parameters that exist outside of this, starting
    
    
     
      with headers.
     
    
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor111">
    </a>
    
     Headers
    
   </h2>
   <p>
    <strong class="bold">
     
      Headers
     
    </strong>
    
     are a classic
    
    <a id="_idIndexMarker197">
    </a>
    
     component of general API architecture, providing important metadata about the
    
    <a id="_idIndexMarker198">
    </a>
    
     request.
    
    
     They are like query strings in the sense that they are defined by a key-value structure, but the syntax used when applying
    
    
     
      them differs.
     
    
   </p>
   <p>
    
     Like query strings and route values, they can also be accessed from an
    
    
     <strong class="source-inline">
      
       HttpRequest
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/todoItems", (HttpRequest request) =&gt;
{
    var customHeader = request.Headers["SomeCustomHeader"];
    var result = todoItemsQuery.ToList();
    return Results.Ok(result);
});</pre>
   <p>
    
     Another critical parameter type that exists outside of the URL is the request body, sometimes referred to as the
    
    <em class="italic">
     
      payload.
     
    </em>
    
     ASP.NET has a clever feature that allows the payload’s contents to be automatically converted into a strongly typed object defined in the project.
    
    
     The feature is known
    
    <a id="_idIndexMarker199">
    </a>
    
     as
    
    
     <strong class="bold">
      
       object binding
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor112">
    </a>
    
     Strongly typed object binding
    
   </h2>
   <p>
    
     When representing objects
    
    <a id="_idIndexMarker200">
    </a>
    
     in a request payload, it is extremely common for that object to be
    
    <a id="_idIndexMarker201">
    </a>
    
     structured as JSON when the
    
    <a id="_idIndexMarker202">
    </a>
    
     client creates the request.
    
    
     ASP.NET provides a convenient way of automatically binding incoming JSON parameters to a strongly typed object so that it can be easily used when handling
    
    
     
      the request.
     
    
   </p>
   <p>
    
     We have seen examples of this already in previous chapters, where we send a JSON payload representing a
    
    
     <strong class="source-inline">
      
       TodoItem
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     If the JSON object can be parsed, ASP.NET allows you to implicitly declare that the request parameter is an object of type
    
    <em class="italic">
     
      x
     
    </em>
    
     –
    
    <em class="italic">
     
      x
     
    </em>
    
     in our example being a
    
    
     <strong class="source-inline">
      
       TodoItem
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     To use implicit binding in this manner, simply declare a parameter of the type you wish to receive as a parameter in your endpoint, as shown in the following example, where we receive a new
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     to be created via a
    
    
     <strong class="source-inline">
      
       POST
      
     </strong>
    
    
     
      method:
     
    
   </p>
   <pre class="source-code">
app.MapPost("/todoitems", (TodoItem item) =&gt;
{
    var validationContext = new ValidationContext(item);
    var validationResults = new List&lt;ValidationResult&gt;();
    var isValid = Validator.TryValidateObject(
        item, validationContext, validationResults, true);
    if (isValid)
    {
        TodoItems.Add(item);
        return Results.Created();
    }
    return Results.BadRequest(validationResults);
});</pre>
   <p>
    
     Object binding is
    
    <a id="_idIndexMarker203">
    </a>
    
     initiated thanks to the client sending a data structure represented by a string, within the body of the request.
    
    
     This is often the result of a developer formatting the payload after the data was gathered, before
    
    <a id="_idIndexMarker204">
    </a>
    
     sending it to the API.
    
    
     However, if the data was gathered
    
    <a id="_idIndexMarker205">
    </a>
    
     by a user, who could be entering the data in the
    
    <strong class="bold">
     
      Graphical User Interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GUI
     
    </strong>
    
     ) via a form, the process can be streamlined further, thanks to
    
    
     
      form values.
     
    
   </p>
   <h2 id="_idParaDest-85">
    <a id="_idTextAnchor113">
    </a>
    
     Form values
    
   </h2>
   <p>
    
     API endpoints take in data and
    
    <a id="_idIndexMarker206">
    </a>
    
     do something with it.
    
    
     What better use case can there be for data submission than a form?
    
    
     Minimal APIs support the receipt
    
    <a id="_idIndexMarker207">
    </a>
    
     of
    
    <strong class="bold">
     
      form values
     
    </strong>
    
     , making them a suitable option for handling submissions from forms within
    
    
     
      a GUI.
     
    
   </p>
   <p>
    
     Like the previous parameter examples, form values can be retrieved from their own dedicated member within an
    
    <strong class="source-inline">
     
      HttpRequest
     
    </strong>
    
     object, where they also exist in a key-value structure within an
    
    <strong class="source-inline">
     
      IFormCollection
     
    </strong>
    
     collection.
    
    
     The following code shows the retrieval of form values
    
    <a id="_idIndexMarker208">
    </a>
    
     within a
    
    
     <strong class="source-inline">
      
       PATCH
      
     </strong>
    
    
     
      request:
     
    
   </p>
   <pre class="source-code">
app.MapPatch(
    "/updateTodoItemDueDate",
    async (HttpRequest request) =&gt;
{
    var formData = await request.ReadFormAsync();
    var id = int.Parse(formData["Id"]);
    var newDueDate =
        DateTime.Parse(formData["newDueDate"]);
    var index = TodoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    TodoItems[index].DueDate = newDueDate;
    return Results.NoContent();
});</pre>
   <p>
    
     So far, we’ve made
    
    <a id="_idIndexMarker209">
    </a>
    
     some good progress exploring the various types of parameters that can be bound to API endpoints.
    
    
     In each of the previous examples, a lot is assumed about how these parameters should be bound.
    
    
     The location of the parameters, whether they be in the URL as query strings or in the request body, is
    
    <em class="italic">
     
      implicit
     
    </em>
    
     ; it does not require definition, instead occurring automatically.
    
    
     Inversely, there will be times when we will need to be
    
    <em class="italic">
     
      explicit
     
    </em>
    
     about how parameters are bound.
    
    
     This explicit binding can be achieved
    
    <a id="_idIndexMarker210">
    </a>
    
     
      with
     
    
    
     <strong class="bold">
      
       attributes
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-86">
    <a id="_idTextAnchor114">
    </a>
    
     Explicit binding with attributes
    
   </h2>
   <p>
    
     All the previous
    
    <a id="_idIndexMarker211">
    </a>
    
     examples have something in common – they are
    
    <a id="_idIndexMarker212">
    </a>
    
     accessible using keys from collections that exist within an
    
    
     <strong class="source-inline">
      
       HttpRequest
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     There is another way of binding these parameter types without needing to inject
    
    <strong class="source-inline">
     
      HttpRequest
     
    </strong>
    
     or its parent,
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     –
    
    
     
      attributes.
     
    
   </p>
   <p>
    
     The benefit of this is that we can make the code more readable and arguably improve the structure of the request, because the parameters can be bound from within the parentheses of the endpoint’s lambda expression, leaving the expression body dedicated exclusively to handling the request.
    
    
     As shown in the previous examples, we are using the parentheses to receive parameters but then performing explicit binding in the body, as well as executing handling logic, which can be
    
    
     
      somewhat messy.
     
    
   </p>
   <p>
    
     Parameter binding with attributes is simpler because you are explicitly stating that you have a parameter that should be bound from a specific location in
    
    
     
      the request.
     
    
   </p>
   <p>
    
     Let us take query strings as an example.
    
    
     In the code block in the
    
    <em class="italic">
     
      Query strings
     
    </em>
    
     section, we were accessing query strings from within the endpoint body by index on
    
    <strong class="source-inline">
     
      IQueryCollection
     
    </strong>
    
     within the
    
    
     <strong class="source-inline">
      
       HttpRequest
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     The following code block demonstrates how this endpoint can be refactored to obtain query string values using attributes, reducing the amount of code and making it easier
    
    
     
      to read:
     
    
   </p>
   <pre class="source-code">
app.MapGet(
    "/todoItems",
    ([FromQuery(Name = "pastDue")] bool pastDue,
     [FromQuery(Name = "priority")] int priority  ) =&gt;
{
    var todoItemsQuery = ToDoItems.AsQueryable();
    if (pastDue)
    {
        todoItemsQuery = todoItemsQuery.Where(
            x =&gt; x.DueDate &lt;= DateTime.Now
        );
    }
    if (priority &gt; 0)
    {
        todoItemsQuery = todoItemsQuery.Where(
            x =&gt; x.Priority == priority
        );
    }
    var result = todoItemsQuery.ToList();
    return Results.Ok(result);
});</pre>
   <p>
    
     If you were to change the
    
    <strong class="source-inline">
     
      [FromQuery]
     
    </strong>
    
     attributes in this code slightly by removing the argument, for example, to
    
    <strong class="source-inline">
     
      Name = "priority"
     
    </strong>
    
     , the API would still match the query values, assuming that the name was specified in the
    
    
     
      query string.
     
    
   </p>
   <p>
    
     All the parameter binding
    
    <a id="_idIndexMarker213">
    </a>
    
     methods demonstrated previously in this
    
    <a id="_idIndexMarker214">
    </a>
    
     chapter can be extracted in this way – by specifying in an attribute where the parameter should be bound from and then providing an object with the appropriate data type in which it can
    
    
     
      be bound.
     
    
   </p>
   <p>
    
     Let us update another of our previous
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     examples by checking the headers in this manner.
    
    
     For the purposes of demonstration, let us assume that when a client posts a new
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , they can indicate whether another process should be triggered in the background by using a
    
    
     
      custom header.
     
    
   </p>
   <p>
    
     The header can be explicitly bound using an attribute, as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
app.MapPost(
    "/todoitems",
    (TodoItem item,
      [FromHeader(Name ="TriggerBackgroundTask")]
      bool triggerBackgroundTaskHeader ) =&gt;
{
    if ( triggerBackgroundTaskHeader)
    {
        // do something else in the background
    }
    ToDoItems.Add(item);
    return Results.Created();
});</pre>
   <p>
    
     We’re ready to step into more advanced territory now, in which we can explore parameters that have been
    
    <em class="italic">
     
      injected
     
    </em>
    
     from a catalog of previously
    
    
     
      registered
     
    
    
     <strong class="bold">
      
       services
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-87">
    <a id="_idTextAnchor115">
    </a>
    
     Binding parameters through dependency injection
    
   </h2>
   <p>
    
     Parameters can be bound to an endpoint that
    
    <a id="_idIndexMarker215">
    </a>
    
     was not necessarily sent by the client.
    
    
     One example of this is dependencies.
    
    
     Where an API has dependencies registered for injection, they can be explicitly bound as parameters.
    
    
     Let us explore an example of this by rewriting the
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request example from the first code block in the
    
    <em class="italic">
     
      Explicit binding with
     
    </em>
    
     <em class="italic">
      
       attributes
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     First, as you can see in the code on GitHub, we’ve created a service
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       TodoItemService
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
public class TodoItemService
{
    List&lt;TodoItem&gt; todoItems = new List&lt;TodoItem&gt;();
    public TodoItem GetById(int id)
    {
        return todoItems.FirstOrDefault(x =&gt; x.Id == id);
    }
    public List&lt;TodoItem&gt; GetTodoItems(
        bool pastDue, int priority)
    {
        var todoItemsQuery = todoItems.AsQueryable();
        if (pastDue)
        {
            todoItemsQuery = todoItemsQuery.Where(
                x =&gt; x.DueDate &lt;= DateTime.Now
            );
        }
        if (priority &gt; 0)
        {
            todoItemsQuery = todoItemsQuery.Where(
                x =&gt; x.Priority == priority);
        }
        return todoItemsQuery.ToList();
    }
}</pre>
   <p>
    
     This service has been
    
    <a id="_idIndexMarker216">
    </a>
    
     registered for dependency injection as a singleton service
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
builder.Services.AddSingleton&lt;TodoItemService&gt;();</pre>
   <p>
    
     This means that we can
    
    <a id="_idIndexMarker217">
    </a>
    
     now access this service from within an endpoint using the
    
    <strong class="source-inline">
     
      [
     
    </strong>
    
     <strong class="source-inline">
      
       FromServices]
      
     </strong>
    
    
     
      attribute:
     
    
   </p>
   <pre class="source-code">
app.MapGet(
    "/todoItems",
    ([FromQuery(Name = "pastDue")] bool pastDue,
     [FromQuery(Name = "priority")] int priority,
     [FromServices] TodoService todoItemService) =&gt;
{
    var todoItemsQuery =
        todoItemService.TodoItems.AsQueryable();
    if (pastDue)
    {
        todoItemsQuery = todoItemsQuery.Where(
            x =&gt; x.DueDate &lt;= DateTime.Now
        );
    }
    if (priority &gt; 0)
    {
        todoItemsQuery = todoItemsQuery.Where(
            x =&gt; x.Priority == priority
        );
    }
    var result =
        todoItemService.GetTodoItems(todoItemsQuery);
    return Results.Ok(result);
});</pre>
   <p>
    
     In this code, binding a service registered for dependency injection is demonstrated using a
    
    <strong class="source-inline">
     
      [FromService]
     
    </strong>
    
     attribute.
    
    
     This
    
    <a id="_idIndexMarker218">
    </a>
    
     allows API endpoints to leverage reusable
    
    
     
      components easily.
     
    
   </p>
   <p>
    
     So far, we have looked at examples of various parameter types and how they are bound to API endpoints.
    
    
     Hopefully, it is clear that ASP.NET is taking care of the heavy lifting when it comes to resolving these parameters before binding.
    
    
     It is also important to understand the order in which this resolution of parameters happens.
    
    
     This is known as
    
    
     <strong class="bold">
      
       binding precedence
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-88">
    <a id="_idTextAnchor116">
    </a>
    
     Binding precedence
    
   </h1>
   <p>
    
     ASP.NET has its own defined
    
    <a id="_idIndexMarker219">
    </a>
    
     order in which it will bind parameters, known as its
    
    <strong class="bold">
     
      order of precedence
     
    </strong>
    
     .
    
    
     Using this
    
    <a id="_idIndexMarker220">
    </a>
    
     order keeps resolution consistent and ensures that ASP.NET is resolving in a predictable way, starting with the most specific parameters to
    
    
     
      the least.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     outlines the official order ASP.NET uses, which is useful to know as a developer, as it can help you anticipate any potential binding issues depending on the parameters
    
    
     
      in use.
     
    
   </p>
   <div><div><img alt="Figure 6.1: ASP.NET order of precedence for parameter binding" src="img/B20968_06_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.1: ASP.NET order of precedence for parameter binding
    
   </p>
   <p>
    
     Let us look
    
    <a id="_idIndexMarker221">
    </a>
    
     at a working example of how we can create custom binding logic, giving us more control over the way binding is executed on
    
    
     
      incoming parameters.
     
    
   </p>
   <h1 id="_idParaDest-89">
    <a id="_idTextAnchor117">
    </a>
    
     Creating custom binding logic
    
   </h1>
   <p>
    
     In this example, we are going
    
    <a id="_idIndexMarker222">
    </a>
    
     to change the way we bind an incoming
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , adding
    
    <a id="_idIndexMarker223">
    </a>
    
     validation logic that will occur at the point
    
    
     
      of binding.
     
    
   </p>
   <p>
    
     To implement this kind of custom binding, we need to implement a function within
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     .
    
    
     This function is static and is
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       BindAsync()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      BindAsync()
     
    </strong>
    
     allows us to interrupt the binding process for an object and apply our own logic.
    
    
     Let us start by adding
    
    <strong class="source-inline">
     
      BindAsync()
     
    </strong>
    
     to the
    
    
     <strong class="source-inline">
      
       TodoItem
      
     </strong>
    
    
     
      class.
     
    
   </p>
   <p>
    
     In
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     , add the following static function below the
    
    
     
      property definitions:
     
    
   </p>
   <pre class="source-code">
public static async ValueTask&lt;TodoItem&gt; BindAsync(
    HttpContext context, ParameterInfo parameter)
{
}</pre>
   <p>
    
     Next, we need to add a
    
    <strong class="source-inline">
     
      try/catch
     
    </strong>
    
     block so that we can perform JSON validation logic, catching any errors in the process.
    
    
     We are expecting to see exceptions of type
    
    <strong class="source-inline">
     
      JsonException
     
    </strong>
    
     if the validation fails, so we will explicitly catch this exception type in our
    
    
     <strong class="source-inline">
      
       try/catch
      
     </strong>
    
    
     
      block:
     
    
   </p>
   <pre class="source-code">
public static async ValueTask&lt;TodoItem&gt; BindAsync(
    HttpContext context, ParameterInfo parameter)
{
    try
    {
    }
    catch (JsonException)
    {
}
}</pre>
   <p>
    
     Now, we can start by accessing the body of the request and deserializing the raw JSON to a
    
    <strong class="source-inline">
     
      TodoItem
     
    </strong>
    
     instance.
    
    
     We will add options to ensure case is not factored into validation, and then check to see whether deserialization was successful.
    
    
     If it was not, the incoming parameter
    
    <a id="_idIndexMarker224">
    </a>
    
     cannot be bound and the request is invalid, so we will return a
    
    <strong class="source-inline">
     
      400 Bad Request
     
    </strong>
    
     response.
    
    
     Update the
    
    <strong class="source-inline">
     
      try
     
    </strong>
    
     block with this code,
    
    
     
      shown
     
    
    
     <a id="_idIndexMarker225">
     </a>
    
    
     
      here:
     
    
   </p>
   <pre class="source-code">
var requestBody = await new StreamReader(
    context.Request.Body
).ReadToEndAsync();
var todoItem = JsonSerializer.Deserialize&lt;TodoItem&gt;(
    requestBody,
    new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    }
);
if (todoItem == null)
{
    context.Response.StatusCode = 400;
    await context.Response.WriteAsync("Invalid JSON");
    return new TodoItem();
}</pre>
   <p>
    
     At this point, we have now checked the validity of the JSON to be bound.
    
    
     In
    
    <a href="B20968_05.xhtml#_idTextAnchor094">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     , we explored an example of validation middleware for verifying that objects were created according to specific rules.
    
    
     We used
    
    <strong class="source-inline">
     
      ValidationContext
     
    </strong>
    
     along with the static type,
    
    <strong class="source-inline">
     
      Validator
     
    </strong>
    
     , to return a list of
    
    <strong class="source-inline">
     
      ValidationResult
     
    </strong>
    
     , which would determine the validity of
    
    
     
      the model.
     
    
   </p>
   <p>
    
     We can use this
    
    <a id="_idIndexMarker226">
    </a>
    
     same logic in
    
    <strong class="source-inline">
     
      BindAsync()
     
    </strong>
    
     to implement validation of the object as part of the parameter
    
    
     
      binding process.
     
    
   </p>
   <p>
    
     Add this logic to the
    
    <strong class="source-inline">
     
      try
     
    </strong>
    
     block to
    
    <a id="_idIndexMarker227">
    </a>
    
     complete the custom
    
    
     
      binding logic:
     
    
   </p>
   <pre class="source-code">
var validationResults = new List&lt;ValidationResult&gt;();
var validationContext = new ValidationContext(
    todoItem,
    serviceProvider: null,
    items: null
);
if (!Validator.TryValidateObject(
    todoItem,
    validationContext,
    validationResults,
    validateAllProperties: true
))
{
    context.Response.StatusCode = 400;
    var errorMessages = string.Join(
        "; ",
        validationResults.Select(x =&gt; x.ErrorMessage)
    );
    await context.Response.WriteAsync(errorMessages);
    return new TodoItem();
}
return todoItem;</pre>
   <p>
    
     Finally, we
    
    <a id="_idIndexMarker228">
    </a>
    
     need to add the following basic logic to the
    
    <strong class="source-inline">
     
      catch
     
    </strong>
    
     block to handle any exceptions
    
    <a id="_idIndexMarker229">
    </a>
    
     of type
    
    <strong class="source-inline">
     
      JsonException
     
    </strong>
    
     that
    
    
     
      are caught:
     
    
   </p>
   <pre class="source-code">
  context.Response.StatusCode = 400;
  await context.Response.WriteAsync("Invalid JSON");
  return new TodoItem();</pre>
   <p>
    
     Refer to this chapter’s code in the accompanying GitHub repository to see the finished
    
    
     
      class:
     
    
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     
      
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      
     
    </a>
   </p>
   <p>
    
     Custom parameter binding is a good example of ASP.NET’s flexible feature set.
    
    
     Minimal APIs may be labeled as such but that doesn’t mean they restrict custom configurations.
    
    
     Let us review what we have covered in
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-90">
    <a id="_idTextAnchor118">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     The binding of parameters is a fairly broad subject, and we have certainly covered the bulk of it in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     We started by looking at how the different parameter types are bound, from route values and query strings right up to headers and the automatic binding provided for strongly
    
    
     
      typed objects.
     
    
   </p>
   <p>
    
     We then explored some alternative binding methods for these parameter types in the form of explicit attribute binding and the order of binding precedence, before looking at how dependency injection can be leveraged within requests to add parameters that may not have been received from
    
    
     
      the client.
     
    
   </p>
   <p>
    
     Finally, we worked through an example of custom parameter binding, adding custom validation to the binding logic of the
    
    
     <strong class="source-inline">
      
       TodoItem
      
     </strong>
    
    
     
      model.
     
    
   </p>
   <p>
    
     This chapter is not the last we have seen of dependency injection in minimal APIs.
    
    
     In the next chapter, we will explore the topic in
    
    
     
      more detail.
     
    
   </p>
  </div>
 </body></html>