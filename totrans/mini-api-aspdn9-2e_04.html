<html><head></head><body>
  <div id="_idContainer039">
   <h1 class="chapter-number" id="_idParaDest-53">
    <a id="_idTextAnchor081">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     4
    </span>
   </h1>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor082">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Handling HTTP Methods and Routing
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In
    </span>
    <a href="B20968_02.xhtml#_idTextAnchor033">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.4.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.5.1">
     , we discussed ways that you can define endpoints and use routing within a minimal API.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     That was from a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      high level.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     However, in this chapter, we will discuss in more detail how routes and endpoints can be configured for the handling of incoming requests.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     We will go into more detail about how you can use route parameters to be more specific about the required parameters received by each endpoint, and we will also explore examples of request validation, wherein we ensure that the request is properly formed, issuing the relevant response
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      as necessary.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     Finally, no API can be deemed reliable if its endpoints do not adequately recover from receiving invalid data so we will also explore ways in which validation errors can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      handled gracefully.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     To gain a better understanding of these topics, we will use an example application for managing tasks.
    </span>
    <span class="koboSpan" id="kobo.11.2">
     The application is part of a productivity suite, which has an API for managing to-do lists and projects.
    </span>
    <span class="koboSpan" id="kobo.11.3">
     By building elements of this API, you will gain a more in-depth understanding of how requests are received by minimal APIs and how they
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      are handled.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.13.1">
     In summary, this chapter will cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       Handling requests
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      Defining endpoints in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       Todo API
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      Managing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       route parameters
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      Request validation and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       error handling
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-55">
    <a id="_idTextAnchor083">
    </a>
    <span class="koboSpan" id="kobo.22.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.23.1">
     The code for this chapter is available in the GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.24.1">
      at:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.26.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     You can of course follow along and write the code yourself as you read the chapter if you have Visual Studio 2022 / Visual Studio Code installed with .
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      NET 9.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-56">
    <a id="_idTextAnchor084">
    </a>
    <span class="koboSpan" id="kobo.29.1">
     Handling requests
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.30.1">
     To handle incoming
    </span>
    <a id="_idIndexMarker088">
    </a>
    <span class="koboSpan" id="kobo.31.1">
     requests, we first need a set of minimal API endpoints for those requests to be sent to.
    </span>
    <span class="koboSpan" id="kobo.31.2">
     Let’s recap what we explored in
    </span>
    <a href="B20968_02.xhtml#_idTextAnchor033">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.32.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.33.1">
     , around creating minimal API endpoints with varying HTTP methods (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.34.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.35.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.36.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.37.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.38.1">
      PUT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.39.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.40.1">
      DELETE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.41.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.42.1">
      PATCH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.43.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.43.2">
     We can refresh our memories by creating some static
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.44.1">
      mock
     </span>
    </em>
    <span class="koboSpan" id="kobo.45.1">
     data that will represent the task entities our API is handling.
    </span>
    <span class="koboSpan" id="kobo.45.2">
     Then, we can define some simple endpoints that manipulate or query
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      that data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     Let’s create the mock data first.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     We’ll do this by creating a simple
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.48.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.49.1">
     class, and a static list for instances of this class to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      reside in:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.51.1">
public class TodoItem
{
    public int Id { get; set; }
    public DateTime StartDate { get; set; }
    public DateTime DueDate { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public string Assignee { get; set; }
    public int Priority { get; set; }
    public bool IsComplete { get; set; }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.53.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.54.1">
     class can stay quite simple for the time being.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     It can be expanded upon later with more specific properties as we understand our needs further.
    </span>
    <span class="koboSpan" id="kobo.54.3">
     The same approach can be taken with the next piece of code, which for now will be a list of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.55.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.56.1">
     , simply called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.57.1">
      ToDoItems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.58.1">
     .
    </span>
    <span class="koboSpan" id="kobo.58.2">
     In this list, we store instances of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.59.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.60.1">
     to be handled by endpoints
    </span>
    <a id="_idIndexMarker089">
    </a>
    <span class="koboSpan" id="kobo.61.1">
     during requests.
    </span>
    <span class="koboSpan" id="kobo.61.2">
     Let’s place this list
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.62.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.63.1">
       Program.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.65.1">
List&lt;TodoItem&gt; ToDoItems = new List&lt;TodoItem&gt;();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.66.1">
     Now that we have our temporary data storage solution in the form of a list, we can focus on creating endpoints for handling requests and managing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.67.1">
      todo items.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-57">
    <a id="_idTextAnchor085">
    </a>
    <span class="koboSpan" id="kobo.68.1">
     Defining endpoints in the Todo API
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.69.1">
     It’s advisable to start as simple as
    </span>
    <a id="_idIndexMarker090">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     possible in creating a minimal API.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     After all, the
    </span>
    <a id="_idIndexMarker091">
    </a>
    <span class="koboSpan" id="kobo.71.1">
     name
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.72.1">
      minimal API
     </span>
    </em>
    <span class="koboSpan" id="kobo.73.1">
     connotes simplicity.
    </span>
    <span class="koboSpan" id="kobo.73.2">
     This isn’t just simplicity for simplicity’s sake though.
    </span>
    <span class="koboSpan" id="kobo.73.3">
     For now, our API only needs to cover one area: todo items.
    </span>
    <span class="koboSpan" id="kobo.73.4">
     Sure, the scope might expand further in the future, and minimal APIs can still be crafted in such a way that they are expandable and therefore somewhat future-proofed, but until more requirements become apparent (for example, assigning to-do items to users, adding to-do items to specific projects, etc.), the aim is minimalism.
    </span>
    <span class="koboSpan" id="kobo.73.5">
     With this in mind, we will, for now, keep our endpoints
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.74.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.75.1">
       Program.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     We should now ask ourselves a simple question:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.78.1">
      What do I want to do in
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.79.1">
       this API?
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.80.1">
     By this, I mean the actions that the API will need to facilitate.
    </span>
    <span class="koboSpan" id="kobo.80.2">
     For example, fetching todo items, updating todo items, deleting todo items, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.81.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     In understanding the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.83.1">
      verbs
     </span>
    </em>
    <span class="koboSpan" id="kobo.84.1">
     that are part of the actions of your API, we can identify the required HTTP methods.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     Consider the basic actions required for todo items.
    </span>
    <span class="koboSpan" id="kobo.84.3">
     We will certainly want to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.85.1">
      retrieve
     </span>
    </em>
    <span class="koboSpan" id="kobo.86.1">
     todo items.
    </span>
    <span class="koboSpan" id="kobo.86.2">
     That will require an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.87.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.88.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.88.2">
     Moreover, we will also want to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.89.1">
      create
     </span>
    </em>
    <span class="koboSpan" id="kobo.90.1">
     a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.91.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.92.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.92.2">
     This will require an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.93.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.94.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.94.2">
     Let’s start with the first example, retrieving some todo items, and then build up
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.95.1">
      from there.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-58">
    <a id="_idTextAnchor086">
    </a>
    <span class="koboSpan" id="kobo.96.1">
     Getting todo items
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.97.1">
     If you’ve read through
    </span>
    <a href="B20968_02.xhtml#_idTextAnchor033">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.98.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.99.1">
     , you
    </span>
    <a id="_idIndexMarker092">
    </a>
    <span class="koboSpan" id="kobo.100.1">
     will have already seen examples of how an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.101.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.102.1">
     method can be created as an endpoint in minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     For this project, we will first create an endpoint that simply retrieves the contents of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.103.1">
      List&lt;TodoItem&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     , which we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.105.1">
      created previously.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.106.1">
     To achieve this, we need to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.107.1">
      map
     </span>
    </em>
    <span class="koboSpan" id="kobo.108.1">
     an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.109.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.110.1">
     method onto the instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.111.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     on which our minimal API is running.
    </span>
    <span class="koboSpan" id="kobo.112.2">
     There are several functions within
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     that achieve this.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     Each of them is prefixed with the word
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.115.1">
      Map
     </span>
    </strong>
    <span class="koboSpan" id="kobo.116.1">
     and followed by the relevant method verb.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     In this example, we’ll
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      use
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.118.1">
       MapGet()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.119.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.120.1">
app.MapGet("/todoitems", () =&gt;
{
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.121.1">
     In this code, an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.122.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.123.1">
     method has been mapped to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.124.1">
      /todoitems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.125.1">
     route, meaning that should a user request the API’s base URL, followed by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.126.1">
      /todoitems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.127.1">
     , this endpoint would
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.128.1">
      be reached.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.129.1">
     For example, if our URL is hosted at
    </span>
    <a href="https://example.org/reallysimpletodoapi">
     <span class="koboSpan" id="kobo.130.1">
      https://example.org/reallysimpletodoapi
     </span>
    </a>
    <span class="koboSpan" id="kobo.131.1">
     , accessing
    </span>
    <a href="https://example.org/reallysimpletodoapi/todoitems">
     <span class="koboSpan" id="kobo.132.1">
      https://example.org/reallysimpletodoapi/todoitems
     </span>
    </a>
    <span class="koboSpan" id="kobo.133.1">
     will reach
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      this endpoint.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.135.1">
     Now we can get to the handling of the request, which happens in the function body.
    </span>
    <span class="koboSpan" id="kobo.135.2">
     Notice that the endpoint we’ve created has a lambda expression after the route definition.
    </span>
    <span class="koboSpan" id="kobo.135.3">
     The expression body is currently empty.
    </span>
    <span class="koboSpan" id="kobo.135.4">
     It is within this expression body that we will handle the request by retrieving the requested data and responding to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.136.1">
      the client.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.137.1">
     In this case, because we are simply returning the contents of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.138.1">
      ToDoItems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.139.1">
     list, the data is readily available, but how do we get that data back to the client?
    </span>
    <span class="koboSpan" id="kobo.139.2">
     ASP.NET provides us with a helper object in the form of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.140.1">
      IResult
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     , whose
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.142.1">
      Results
     </span>
    </strong>
    <span class="koboSpan" id="kobo.143.1">
     object exposes various methods for responding to requests.
    </span>
    <span class="koboSpan" id="kobo.143.2">
     This takes care of the fundamental aspects of returning a response, such as the status code, response body, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.144.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.145.1">
     For this simple HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     method, we can return an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      200 OK
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     response along with the requested data by simply returning the result of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      Results.OK(ToDoItems)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     .
    </span>
    <span class="koboSpan" id="kobo.151.2">
     This function generates the relevant status code and takes an argument of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      object
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     , representing the data that should be returned to the client.
    </span>
    <span class="koboSpan" id="kobo.153.2">
     Once added, the endpoint should look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.154.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.155.1">
app.MapGet("/todoitems", () =&gt;
{
    return Results.Ok(ToDoItems);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.156.1">
     So far, the focus has been on
    </span>
    <a id="_idIndexMarker093">
    </a>
    <span class="koboSpan" id="kobo.157.1">
     routing requests into the API for the purposes of retrieving data.
    </span>
    <span class="koboSpan" id="kobo.157.2">
     We will also need to create new data in the system; so, let us turn our attention to the creation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.158.1">
      todo items.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor087">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     Creating Todo items
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.160.1">
     Let’s now look at
    </span>
    <a id="_idIndexMarker094">
    </a>
    <span class="koboSpan" id="kobo.161.1">
     another critical operation for APIs: creating an entity.
    </span>
    <span class="koboSpan" id="kobo.161.2">
     To create a new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     , we would use an HTTP
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.164.1">
       POST
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.165.1">
      method.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.166.1">
     The mapping of an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.167.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     method is similar to the code we’ve just written for mapping a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.169.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.170.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.170.2">
     Once again, we use a method prefixed with the word
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.171.1">
      Map
     </span>
    </strong>
    <span class="koboSpan" id="kobo.172.1">
     .
    </span>
    <span class="koboSpan" id="kobo.172.2">
     This method is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.173.1">
      MapPost()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     .
    </span>
    <span class="koboSpan" id="kobo.174.2">
     However, there is a slight difference in the syntax compared to our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.175.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.176.1">
     method, as we now need to receive a data structure.
    </span>
    <span class="koboSpan" id="kobo.176.2">
     In the case of creating a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.177.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.178.1">
     , we will require the client to send an object of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.179.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     , represented in JSON format on the client-side.
    </span>
    <span class="koboSpan" id="kobo.180.2">
     ASP.NET will then take care of parsing the JSON into a strongly typed instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.181.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.182.1">
     , which we can use whilst handling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.183.1">
      the request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.184.1">
     To allow the method to receive an object as part of the incoming request, we can take the parentheses at the beginning of the lambda expression within the endpoint’s body and add the object to it.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     For example, notice how the previous endpoint we created, which retrieves a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.185.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     , has these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      empty parentheses:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.188.1">
app.MapGet("/todoitems", () =&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.189.1">
     The handling of our minimal API endpoints is represented by a lambda expression.
    </span>
    <span class="koboSpan" id="kobo.189.2">
     Lambda expressions open with an input in the form of parameters, which are passed in through these empty parentheses, as shown in the following code.
    </span>
    <span class="koboSpan" id="kobo.189.3">
     This means that for our HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.190.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.191.1">
     endpoint, we can add a parameter of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      MapPost()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     method we are adding,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      like so:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.197.1">
app.MapPost("/todoitems", (TodoItem item) =&gt;
{
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     Now, we have an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.199.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.200.1">
     endpoint, sitting on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.201.1">
      /todoitems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.202.1">
     route, just like our HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.203.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     endpoint.
    </span>
    <span class="koboSpan" id="kobo.204.2">
     The difference is that not only does it respond to a different HTTP verb, but it also requires the client to send a JSON payload mirroring the structure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.205.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.206.1">
       TodoItem
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.208.1">
     We don’t yet have anything inside the lambda expression within the endpoint, meaning that nothing will happen when a client sends a request.
    </span>
    <span class="koboSpan" id="kobo.208.2">
     Let’s finally handle the request by adding the
    </span>
    <a id="_idIndexMarker095">
    </a>
    <span class="koboSpan" id="kobo.209.1">
     incoming
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.210.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.211.1">
     to the list and then returning the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      relevant response:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.213.1">
app.MapPost("/todoitems", (TodoItem item) =&gt;
{
    ToDoItems.Add(item);
    return Results.Created();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.214.1">
     Just like in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.215.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.216.1">
     example, we are using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.217.1">
      Results
     </span>
    </strong>
    <span class="koboSpan" id="kobo.218.1">
     to form a response and send it back to the client.
    </span>
    <span class="koboSpan" id="kobo.218.2">
     However, we have opted for a slightly different response in this case.
    </span>
    <span class="koboSpan" id="kobo.218.3">
     As the request is intended to create an entity, it is appropriate to return an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.219.1">
      HTTP 201 CREATED
     </span>
    </strong>
    <span class="koboSpan" id="kobo.220.1">
     status code on successful creation, hence the use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.221.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.222.1">
       Results.Created();
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.223.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor088">
    </a>
    <span class="koboSpan" id="kobo.224.1">
     Updating existing Todo items
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.225.1">
     When it comes to
    </span>
    <a id="_idIndexMarker096">
    </a>
    <span class="koboSpan" id="kobo.226.1">
     updating a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.227.1">
      Todoitem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     , we have a couple of HTTP methods at our disposal.
    </span>
    <span class="koboSpan" id="kobo.228.2">
     Let’s start with an HTTP
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.229.1">
       PUT
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      method.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.231.1">
     An HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.232.1">
      PUT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.233.1">
     requires the client to send a full copy of the entity being updated.
    </span>
    <span class="koboSpan" id="kobo.233.2">
     It will then replace the entity with the copy.
    </span>
    <span class="koboSpan" id="kobo.233.3">
     It is a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.234.1">
      full update
     </span>
    </em>
    <span class="koboSpan" id="kobo.235.1">
     .
    </span>
    <span class="koboSpan" id="kobo.235.2">
     Therefore, we need to create an endpoint that receives a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.236.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.237.1">
     as part of the request, before finding the relevant item in our list and then replacing it with the incoming
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.238.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.239.1">
     .
    </span>
    <span class="koboSpan" id="kobo.239.2">
     First, we’ll create an empty
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.240.1">
      PUT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.241.1">
     endpoint sitting on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.242.1">
      /todoitems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.243.1">
     route that expects the item as an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.244.1">
      object parameter:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.245.1">
app.MapPut("/todoitems", (TodoItem item) =&gt;
{
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.246.1">
     Next, the request
    </span>
    <a id="_idIndexMarker097">
    </a>
    <span class="koboSpan" id="kobo.247.1">
     should be handled by finding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.248.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     that we intend to update.
    </span>
    <span class="koboSpan" id="kobo.249.2">
     We can do this using a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.250.1">
      Language Integrated Query
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.252.1">
      LINQ
     </span>
    </strong>
    <span class="koboSpan" id="kobo.253.1">
     ) query
    </span>
    <a id="_idIndexMarker098">
    </a>
    <span class="koboSpan" id="kobo.254.1">
     to find the item by its unique ID,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.256.1">
       FindIndex();
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.257.1">
      .
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.258.1">
     LINQ queries
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.259.1">
     A LINQ query with lambda expressions in C# lets you easily search and manipulate data in collections such as lists.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     You start by defining your data source, then use methods such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.260.1">
      Where
     </span>
    </strong>
    <span class="koboSpan" id="kobo.261.1">
     to filter the data and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.262.1">
      Select
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     ” to choose what you want from the data.
    </span>
    <span class="koboSpan" id="kobo.263.2">
     Each method takes a lambda expression, which is a simple function that defines your criteria.
    </span>
    <span class="koboSpan" id="kobo.263.3">
     In our example, we’re using a LINQ query to find the index of an item in a list that shares the same ID as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.264.1">
      given item.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.265.1">
     Once found,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.266.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     can be replaced with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.268.1">
      incoming item:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.269.1">
app.MapPut("/todoitems", (TodoItem item) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == item.Id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems[index] = item;
    return Results.NoContent();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.270.1">
     Notice how we did not return
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.271.1">
      Results.OK
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     again in this example.
    </span>
    <span class="koboSpan" id="kobo.272.2">
     Because we’re simply updating a resource, the client is not expecting content to be returned; so, we indicate success by returning an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.273.1">
      HTTP 204 NO CONTENT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     status code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.275.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.276.1">
       Results.NoContent();
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.277.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.278.1">
     Updating
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.279.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.280.1">
     via HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.281.1">
      PATCH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.282.1">
     is handled slightly differently.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     Unlike
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.283.1">
      PUT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.284.1">
     , we handle the request by once again finding the relevant item, but this time, we only change specific properties of the item, as dictated by the request parameters.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     This is usually used in scenarios where you want to create an endpoint on a route that is for a specific update.
    </span>
    <span class="koboSpan" id="kobo.284.3">
     So, in this case, we will no longer create the endpoint on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.285.1">
      /todoitems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     route.
    </span>
    <span class="koboSpan" id="kobo.286.2">
     Instead, we
    </span>
    <a id="_idIndexMarker099">
    </a>
    <span class="koboSpan" id="kobo.287.1">
     will be specific about what we want to change by mapping the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.288.1">
      PATCH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.289.1">
     method to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.290.1">
      /updateTodoItemDueDate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.291.1">
     route.
    </span>
    <span class="koboSpan" id="kobo.291.2">
     In this example, we are creating an endpoint intended for a single purpose – to change the due date on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      target
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.293.1">
       TodoItem
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.294.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.295.1">
app.MapPatch("/updateTodoItemDueDate/{id}",
    (int id, DateTime newDueDate) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems[index].DueDate = newDueDate;
    return Results.NoContent();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.296.1">
     The code looks like the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.297.1">
      PUT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.298.1">
     method we created, but you can see that the parameters are quite different.
    </span>
    <span class="koboSpan" id="kobo.298.2">
     Instead of requiring the full
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.299.1">
      ToDoItems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.300.1">
     object to be sent in by the client, we instead ask for two parameters, an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.301.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.302.1">
     parameter (to find the target item by ID) and a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.303.1">
      DateTime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.304.1">
     parameter containing the new due date.
    </span>
    <span class="koboSpan" id="kobo.304.2">
     It is then possible to find the target item with another
    </span>
    <a id="_idIndexMarker100">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     LINQ query, and then only update its
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.306.1">
       DueDate
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.307.1">
      property.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.308.1">
     So far, we’ve handled scenarios wherein we need to get all items, create an item, and update items.
    </span>
    <span class="koboSpan" id="kobo.308.2">
     We will next look at scenarios in which we intend to get single items and delete items.
    </span>
    <span class="koboSpan" id="kobo.308.3">
     However, to do this, we first need to explore the concept of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.309.1">
      route parameters.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-61">
    <a id="_idTextAnchor089">
    </a>
    <span class="koboSpan" id="kobo.310.1">
     Managing route parameters
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.311.1">
      Route parameters
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     give us
    </span>
    <a id="_idIndexMarker101">
    </a>
    <span class="koboSpan" id="kobo.313.1">
     the ability to capture values from the URL of an API endpoint.
    </span>
    <span class="koboSpan" id="kobo.313.2">
     This is useful in many scenarios where we need to target specific entities, such as when requesting a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.314.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.315.1">
     by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.316.1">
      its ID.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     Route parameters are quite simple to add, and work using curly braces to define the parameters to be captured from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.318.1">
      the URL.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.319.1">
     Let’s use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.320.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     request
    </span>
    <a id="_idIndexMarker102">
    </a>
    <span class="koboSpan" id="kobo.322.1">
     as an example.
    </span>
    <span class="koboSpan" id="kobo.322.2">
     In this request, the client requests a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.323.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.324.1">
     with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.325.1">
      the ID:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.326.1">
app.MapGet("/todoitems/{id}", (int id) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    return Results.Ok(ToDoItems[index]);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.327.1">
     Like the generic
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.328.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.329.1">
     request we created to fetch all todo items, this endpoint is sitting on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.330.1">
      /todoitems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.331.1">
     route.
    </span>
    <span class="koboSpan" id="kobo.331.2">
     However, it has an extra section appended to this route in the URL.
    </span>
    <span class="koboSpan" id="kobo.331.3">
     The client is expected to also add an ID value as an extra URL section.
    </span>
    <span class="koboSpan" id="kobo.331.4">
     This is shown by the presence of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.332.1">
      {id}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.333.1">
     in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.334.1">
      the route.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.335.1">
     This use of parameters within curly braces is how ASP.NET handles dynamic content in the route URL.
    </span>
    <span class="koboSpan" id="kobo.335.2">
     Using a form of templating, it can replace the section of the URL where we added
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.336.1">
      {id}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     with the value specified by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      the client.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.339.1">
     Another example of this can be seen in an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      DELETE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     endpoint.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     Again, when deleting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.342.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.343.1">
     , we want to delete a specific item so we will once again need to pass in an ID for the target to be deleted.
    </span>
    <span class="koboSpan" id="kobo.343.2">
     Let’s write the code for this in which we will map a new HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.344.1">
      DELETE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.345.1">
     method to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.346.1">
      /todoitems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.347.1">
     route.
    </span>
    <span class="koboSpan" id="kobo.347.2">
     On the route, we’ll add a route parameter to pass
    </span>
    <a id="_idIndexMarker103">
    </a>
    <span class="koboSpan" id="kobo.348.1">
     the ID for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.349.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.350.1">
     to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.351.1">
      be deleted:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.352.1">
app.MapDelete("/todoitems/{id}", (int id) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems.RemoveAt(index);
    return Results.NoContent();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.353.1">
     On receiving a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.354.1">
      DELETE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.355.1">
     request on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.356.1">
      /todoitems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.357.1">
     route, if an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.358.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.359.1">
     has been appended to the URL, it will be stripped out and used within the request as a parameter.
    </span>
    <span class="koboSpan" id="kobo.359.2">
     The subject of parameter data type is an important one.
    </span>
    <span class="koboSpan" id="kobo.359.3">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.360.1">
      DELETE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.361.1">
     example, we passed an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.362.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.363.1">
     as an ID parameter because that is the data type used on the ID property of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.364.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.365.1">
     class (
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.366.1">
      our model).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.367.1">
     What if someone sends a different data type as the parameter, such as a string?
    </span>
    <span class="koboSpan" id="kobo.367.2">
     We would need to handle this of course, but we shouldn’t have to ensure that the incoming ID is an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.368.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     within the code.
    </span>
    <span class="koboSpan" id="kobo.369.2">
     There is a better way of ensuring that the request only hits the route if the parameters being sent are of the
    </span>
    <a id="_idIndexMarker104">
    </a>
    <span class="koboSpan" id="kobo.370.1">
     correct data type:
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.371.1">
      route
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.372.1">
       parameter constraints
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.373.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     Adding a constraint to a route parameter makes it so that the incoming parameter must be formed in a particular way for the route to be found and the request received.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     In our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.375.1">
      DELETE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.376.1">
     endpoint, we can use a parameter constraint to dictate that the parameter must be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.377.1">
      an integer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.378.1">
     Adding a constraint to the
    </span>
    <a id="_idIndexMarker105">
    </a>
    <span class="koboSpan" id="kobo.379.1">
     parameter is very simple.
    </span>
    <span class="koboSpan" id="kobo.379.2">
     We just append a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.380.1">
      :
     </span>
    </strong>
    <span class="koboSpan" id="kobo.381.1">
     character to the parameter, followed by the constraint.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     Let’s add a constraint to our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.382.1">
      DELETE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     endpoint to ensure the route is only used when the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.384.1">
      id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.385.1">
     parameter is of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.386.1">
      type
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.387.1">
       int
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.389.1">
app.MapDelete("/todoitems/{id:int}", (int id) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems.RemoveAt(index);
    return Results.NoContent();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.390.1">
     Now that we have the constraint in place, if a request was received that could not be treated as an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.391.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.392.1">
     , the API would return a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      404 NOT FOUND
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     response.
    </span>
    <span class="koboSpan" id="kobo.394.2">
     It does this because the constraint stops ASP.NET from attempting to use the parameter as an ID, because it has already evaluated the data type thanks to the constraint.
    </span>
    <span class="koboSpan" id="kobo.394.3">
     The result is that no other suitable route is found.
    </span>
    <span class="koboSpan" id="kobo.394.4">
     (Unless there is a route on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      /todoitems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.396.1">
     URL that can receive a string and is also an HTTP
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.397.1">
       DELETE
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.398.1">
      method.)
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.399.1">
     Parameter constraints are not limited to data types.
    </span>
    <span class="koboSpan" id="kobo.399.2">
     Parameters can be constrained by string length, numerical ranges, regex patterns; the list
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      goes on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.401.1">
     Let’s constrain the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.402.1">
      DELETE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.403.1">
     range even further by adding a range constraint.
    </span>
    <span class="koboSpan" id="kobo.403.2">
     We’ll make it so that the route can only delete the first 100 IDs.
    </span>
    <span class="koboSpan" id="kobo.403.3">
     We can add multiple constraints to a single route
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.404.1">
      like so:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.405.1">
app.MapDelete("/todoitems/{id:int:range(1,100)}",
    (int id) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems.RemoveAt(index);
    return Results.NoContent();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.406.1">
     By chaining another
    </span>
    <a id="_idIndexMarker106">
    </a>
    <span class="koboSpan" id="kobo.407.1">
     constraint onto the existing one, we have now enforced that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.408.1">
      Id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     parameter must be an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.410.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.411.1">
     and that its value must be between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.412.1">
      1
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.413.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.414.1">
       100
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.415.1">
      .
     </span>
    </span>
   </p>
   <p>
    <em class="italic">
     <span class="koboSpan" id="kobo.416.1">
      Table 4.1
     </span>
    </em>
    <span class="koboSpan" id="kobo.417.1">
     shows some
    </span>
    <a id="_idIndexMarker107">
    </a>
    <span class="koboSpan" id="kobo.418.1">
     other
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.419.1">
      constraint examples:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-1">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.420.1">
           Constraint Type
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.421.1">
           Route Example
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.422.1">
           Constraint Detail
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.423.1">
          Length
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.424.1">
          /
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.425.1">
           users/{username:length(3,20)}
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.426.1">
         The username string must be between three and twenty
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.427.1">
          characters long
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.428.1">
          Length
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.429.1">
          /
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.430.1">
           users/{username:length(8)}
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.431.1">
         The username string must be exactly eight
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.432.1">
          characters long
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.433.1">
          Min Length
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.434.1">
          /
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.435.1">
           users/{username:minlength(5)}
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.436.1">
         The username string must be at least five
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.437.1">
          characters long
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.438.1">
          Max Length
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.439.1">
          /
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.440.1">
           users/{username:maxlength(30)}
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.441.1">
         The username string must be no more than thirty
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.442.1">
          characters long
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.443.1">
         Regular
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.444.1">
          Expression
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.445.1">
          /
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.446.1">
           addNewCreditCard/{cardNumber:regex(^3[47][0-9]{{13}}$)}
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.447.1">
         The credit card number must conform to the pattern of an American Express
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.448.1">
          card number
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.449.1">
     Table 4.1: Examples of parameter constraints in minimal APIs
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.450.1">
     Now that we are more
    </span>
    <a id="_idIndexMarker108">
    </a>
    <span class="koboSpan" id="kobo.451.1">
     focused on how parameters are passed into our requests, we can focus our attention on the request body, in which we do the main handling of the request.
    </span>
    <span class="koboSpan" id="kobo.451.2">
     A major part of handling any request is validation.
    </span>
    <span class="koboSpan" id="kobo.451.3">
     Minimal APIs, like any other API, will receive data within requests, which must suit the conditions needed to handle the request.
    </span>
    <span class="koboSpan" id="kobo.451.4">
     Let’s look at some validation techniques we can use to manage the request flow and handle any errors that may arise as a result of any violations of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.452.1">
      validation rules.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-62">
    <a id="_idTextAnchor090">
    </a>
    <span class="koboSpan" id="kobo.453.1">
     Request validation and error handling
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.454.1">
     There are several different methods of validation at our disposal.
    </span>
    <span class="koboSpan" id="kobo.454.2">
     We’re going to look at two of them in this section:
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.455.1">
      manual validation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.456.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.457.1">
      data annotation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.458.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.459.1">
      model
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.460.1">
       binding validation
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.461.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-63">
    <a id="_idTextAnchor091">
    </a>
    <span class="koboSpan" id="kobo.462.1">
     Manual validation
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.463.1">
     This kind of validation is the
    </span>
    <a id="_idIndexMarker109">
    </a>
    <span class="koboSpan" id="kobo.464.1">
     simplest, as you are writing code inside the route handler (the body of the lambda expression within an endpoint) that validates the request and decides on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.465.1">
      appropriate response.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.466.1">
     We’ve already applied manual validation in some parts of the todo items API.
    </span>
    <span class="koboSpan" id="kobo.466.2">
     For example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.467.1">
      PATCH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     method we created to update the due date on items first checks for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      Todo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     item with the target ID.
    </span>
    <span class="koboSpan" id="kobo.470.2">
     It
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.471.1">
      could
     </span>
    </em>
    <span class="koboSpan" id="kobo.472.1">
     just assume that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.473.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.474.1">
     exists in the list, but instead, we check first to see if it exists and then return a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.475.1">
      404 NOT FOUND
     </span>
    </strong>
    <span class="koboSpan" id="kobo.476.1">
     status code if this is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.477.1">
      the case:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.478.1">
app.MapPatch("/updateTodoItemDueDate/{id}",
    (int id, DateTime newDueDate) =&gt;
{
    var index = ToDoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    ToDoItems[index].DueDate = newDueDate;
    return Results.NoContent();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.479.1">
     By adding this
    </span>
    <a id="_idIndexMarker110">
    </a>
    <span class="koboSpan" id="kobo.480.1">
     manual check, we are actively validating and handling an exceptional scenario.
    </span>
    <span class="koboSpan" id="kobo.480.2">
     Having validation in an API endpoint is not just best practice, it is critical.
    </span>
    <span class="koboSpan" id="kobo.480.3">
     Manual validation is the most basic form of validation.
    </span>
    <span class="koboSpan" id="kobo.480.4">
     The problem is it relies on the intuition of a human; the developer writing the code.
    </span>
    <span class="koboSpan" id="kobo.480.5">
     This is a subject of some debate because a lot of validation methods have gaps, but relying solely on manual validation can result in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.481.1">
      fragile APIs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.482.1">
     To mitigate this, we can also adopt a more standardized framework for validation, one provided by ASP.NET: validation with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      data annotations.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-64">
    <a id="_idTextAnchor092">
    </a>
    <span class="koboSpan" id="kobo.484.1">
     Validation with data annotations and model binding
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.485.1">
     As
    </span>
    <a id="_idIndexMarker111">
    </a>
    <span class="koboSpan" id="kobo.486.1">
     demonstrated by the simple API example we’ve built in this chapter, models are an important aspect of minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.486.2">
     They allow us to
    </span>
    <a id="_idIndexMarker112">
    </a>
    <span class="koboSpan" id="kobo.487.1">
     represent the entities that incoming requests retrieve, move, and transform.
    </span>
    <span class="koboSpan" id="kobo.487.2">
     In the todo items API, we created a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.488.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.489.1">
     class as a model, and then stored the entities
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.490.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.491.1">
       List&lt;TodoItem&gt;
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.492.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.493.1">
     It is possible to validate a request’s data by the way it binds to specific models.
    </span>
    <span class="koboSpan" id="kobo.493.2">
     For example, in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.494.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     model, it is reasonable to expect that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.496.1">
      Title
     </span>
    </strong>
    <span class="koboSpan" id="kobo.497.1">
     field should be populated when
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.498.1">
      TodoItem
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.499.1">
      is created.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.500.1">
     We can specify a field’s requirements by annotating it with an attribute.
    </span>
    <span class="koboSpan" id="kobo.500.2">
     Attributes are handy pieces of metadata that allow us to apply constraints to code.
    </span>
    <span class="koboSpan" id="kobo.500.3">
     One of the most common uses of attributes in this case is the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.501.1">
      [
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.502.1">
       Required]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.503.1">
      attribute.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.504.1">
     The attributes we need are part of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.505.1">
       System.ComponentModel.DataAnnotations
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.506.1">
      namespace.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.507.1">
     Required namespace for validation
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.508.1">
     As in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.509.1">
      Todo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.510.1">
     class,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.511.1">
      System.ComponentModel.DataAnnotations
     </span>
    </strong>
    <span class="koboSpan" id="kobo.512.1">
     must also be added to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.513.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.514.1">
     for validation to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.515.1">
      be performed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     Add this
    </span>
    <a id="_idIndexMarker113">
    </a>
    <span class="koboSpan" id="kobo.517.1">
     namespace to the top of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.518.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.519.1">
     class, followed
    </span>
    <a id="_idIndexMarker114">
    </a>
    <span class="koboSpan" id="kobo.520.1">
     by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.521.1">
      [Required]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.522.1">
     attribute above the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.523.1">
       Title
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.524.1">
      field:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.525.1">
using System.ComponentModel.DataAnnotations;
namespace TodoApi
{
    public class TodoItem
    {
        public int Id { get; set; }
        public DateTime StartDate { get; set; }
        public DateTime DueDate { get; set; }
        [Required]
        public string Title { get; set; }
        public string Description { get; set; }
        public string Assignee { get; set; }
        public int Priority { get; set; }
        public bool IsComplete { get; set; }
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.526.1">
     Adding a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.527.1">
      [Required]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.528.1">
     attribute is not enough on its own to trigger validation.
    </span>
    <span class="koboSpan" id="kobo.528.2">
     We still need to invoke validation within our requests.
    </span>
    <span class="koboSpan" id="kobo.528.3">
     However, we can do this once within the request, and then all items requiring validation will be validated, according to the attributes we applied.
    </span>
    <span class="koboSpan" id="kobo.528.4">
     Here’s how we can
    </span>
    <a id="_idIndexMarker115">
    </a>
    <span class="koboSpan" id="kobo.529.1">
     invoke validation of our model from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.530.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     request we
    </span>
    <a id="_idIndexMarker116">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.532.1">
      created earlier:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.533.1">
app.MapPost("/todoitems", (TodoItem item) =&gt;
{
    var validationResults = new List&lt;ValidationResult&gt;();
    var validationContext = new ValidationContext(item);
    bool isValid = Validator.TryValidateObject(
        item, validationContext, validationResults, true);
    if (!isValid)
    {
        return Results.BadRequest(validationResults);
    }
    ToDoItems.Add(item);
    return Results.Created();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.534.1">
     In this example, we have initialized a new collection, a list of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.535.1">
      ValidationResult
     </span>
    </strong>
    <span class="koboSpan" id="kobo.536.1">
     .
    </span>
    <span class="koboSpan" id="kobo.536.2">
     This will contain information about the success or failure of validation.
    </span>
    <span class="koboSpan" id="kobo.536.3">
     We will return this collection to the client if
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.537.1">
      validation fails.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.538.1">
     We also create a new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.539.1">
      ValidationContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.540.1">
     , passing in the item that is to be validated.
    </span>
    <span class="koboSpan" id="kobo.540.2">
     Because we want to validate the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.541.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.542.1">
     instance that is sent as a payload, we pass this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.543.1">
      into
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.544.1">
       ValidationContext
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.545.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.546.1">
     We can then invoke validation by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.547.1">
      Validator.TryValidateObject()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.548.1">
     , passing in the item as the validation target, the context we created that will be validated against, and the collection into which results will be saved, followed by a Boolean value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.549.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.550.1">
     , to state that all properties should
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      be validated.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     Now, when a
    </span>
    <a id="_idIndexMarker117">
    </a>
    <span class="koboSpan" id="kobo.553.1">
     request is sent that omits a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.554.1">
      Title
     </span>
    </strong>
    <span class="koboSpan" id="kobo.555.1">
     field from the
    </span>
    <a id="_idIndexMarker118">
    </a>
    <span class="koboSpan" id="kobo.556.1">
     payload, the following error JSON is automatically generated and sent back to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.557.1">
      the client:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.558.1">
[
    {
        "memberNames": [
            "Title"
        ],
        "errorMessage": "The Title field is required."
</span><span class="koboSpan" id="kobo.558.2">    }
]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.559.1">
     This validation and error handling all happen automatically, thanks to the use of attributes and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.560.1">
      built-in validator.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.561.1">
     The error message shown is automatically generated because of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.562.1">
      [Required]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.563.1">
     attribute.
    </span>
    <span class="koboSpan" id="kobo.563.2">
     This can be overridden by adding a parameter to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.564.1">
      the attribute.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.565.1">
     Here is the updated code on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.566.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.567.1">
     model, with a custom
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.568.1">
      error message:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.569.1">
    public class TodoItem
    {
        public int Id { get; set; }
        public DateTime StartDate { get; set; }
        public DateTime DueDate { get; set; }
        [Required(ErrorMessage =
            "You need to add a title my dude!")]
        public string Title { get; set; }
        public string Description { get; set; }
        public string Assignee { get; set; }
        public int Priority { get; set; }
        public bool IsComplete { get; set; }
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.570.1">
     Now, we can see the custom error message in the generated error
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.571.1">
      response JSON:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.572.1">
[
    {
        "memberNames": [
            "Title"
        ],
        "errorMessage": "You need to add a title my dude!"
</span><span class="koboSpan" id="kobo.572.2">    }
]</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.573.1">
      [Required]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.574.1">
     is
    </span>
    <a id="_idIndexMarker119">
    </a>
    <span class="koboSpan" id="kobo.575.1">
     just one of many validation attributes that
    </span>
    <a id="_idIndexMarker120">
    </a>
    <span class="koboSpan" id="kobo.576.1">
     data annotations have to offer.
    </span>
    <span class="koboSpan" id="kobo.576.2">
     There are many other constraints you can add.
    </span>
    <span class="koboSpan" id="kobo.576.3">
     Some examples of these include
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.577.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.578.1">
       [EmailAddress]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.579.1">
      : This ensures the value conforms to the format of an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.580.1">
       email address.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.581.1">
       [AllowedValues]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.582.1">
      : This forces the use of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.583.1">
       specific values.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.584.1">
       [DeniedValues]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.585.1">
      : This is the opposite of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.586.1">
       [AllowedValues]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.587.1">
      , denying the use of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.588.1">
       specific values.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.589.1">
       [StringLength(x)]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.590.1">
      : This requires that a string value be of a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.591.1">
       certain length.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.592.1">
       [CreditCard]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.593.1">
      : The annotated value must be a valid credit
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.594.1">
       card format.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.595.1">
     These are just a few of the many attributes that can be used to validate incoming responses, returning appropriate errors
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.596.1">
      as needed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.597.1">
     Managing
    </span>
    <a id="_idIndexMarker121">
    </a>
    <span class="koboSpan" id="kobo.598.1">
     HTTP methods and handling requests are critical
    </span>
    <a id="_idIndexMarker122">
    </a>
    <span class="koboSpan" id="kobo.599.1">
     aspects of minimal APIs, as it is in any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.600.1">
      API implementation.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.601.1">
     Validation with filters
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.602.1">
     You can also apply more
    </span>
    <a id="_idIndexMarker123">
    </a>
    <span class="koboSpan" id="kobo.603.1">
     specific validation rules with filters.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.604.1">
      IEndpointFilter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.605.1">
     is an interface that can be implemented to perform validation of the incoming request information before it hits the logic within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.606.1">
      an endpoint.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.607.1">
     There is a handy extension method,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.608.1">
      AddEndPointFilter&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.609.1">
     , which allows you to attach a class implementing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.610.1">
      IEndpointFilter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.611.1">
     to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.612.1">
      an endpoint.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.613.1">
     Let’s explore an example of this against a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.614.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.615.1">
     endpoint on our todo API.
    </span>
    <span class="koboSpan" id="kobo.615.2">
     We’ll create a rule where a todo item cannot be assigned to anyone named
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.616.1">
      Joe Bloggs:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.617.1">
      Create a class that implements
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.618.1">
       IEndpointFilter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.619.1">
      .
     </span>
     <span class="koboSpan" id="kobo.619.2">
      This class will be required to define a function called
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.620.1">
       Invoke
      </span>
     </strong>
     <span class="koboSpan" id="kobo.621.1">
      , returning
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.622.1">
       ValueTask&lt;object?&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.623.1">
      .
     </span>
     <span class="koboSpan" id="kobo.623.2">
      The function takes
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.624.1">
       EndPointFilterInvocationContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.625.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.626.1">
       EndpointFilterDelegate
      </span>
     </strong>
     <span class="koboSpan" id="kobo.627.1">
      as parameters in order to carry out the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.628.1">
       validation logic:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.629.1">
public class CreateTodoFilter : IEndpointFilter
{
    public async ValueTask&lt;object?&gt; InvokeAsync(
        EndpointFilterInvocationContext context,
        EndpointFilterDelegate next)
    {
    }
}</span></pre>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.630.1">
       EndPointFilterInvocationContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.631.1">
      will contain the incoming
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.632.1">
       TodoItem
      </span>
     </strong>
     <span class="koboSpan" id="kobo.633.1">
      , as it represents the context of the endpoint we are validating.
     </span>
     <span class="koboSpan" id="kobo.633.2">
      Inside
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.634.1">
       InvokeAsync
      </span>
     </strong>
     <span class="koboSpan" id="kobo.635.1">
      , define logic to gain access to the incoming
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.636.1">
       TodoItem
      </span>
     </strong>
     <span class="koboSpan" id="kobo.637.1">
      from the endpoint’s context and then validate that we are not attempting to assign it to Joe Bloggs.
     </span>
     <span class="koboSpan" id="kobo.637.2">
      If we are, return the appropriate response so that
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.638.1">
       validation
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker124">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.639.1">
       fails:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.640.1">
  var todoItem = context.GetArgument&lt;TodoItem&gt;(0);
  if(todoItem.Assignee == "Joe Bloggs")
  {
      return Results.Problem(
          "Joe Bloggs cannot be assigned a todoitem");
  }</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.641.1">
      Finally, for validation that passes, we want to pass the flow of execution back to the original endpoint (or any other chained logic attached to it, a bit like we do for a middleware pipeline).
     </span>
     <span class="koboSpan" id="kobo.641.2">
      Do this by returning a call to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.642.1">
       EndpointFilterDelegate
      </span>
     </strong>
     <span class="koboSpan" id="kobo.643.1">
      , which we received as a parameter, passing in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.644.1">
       endpoint context:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.645.1">
return await next(context);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.646.1">
      Finally, add the filter validation to the endpoint
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.647.1">
       as shown:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.648.1">
      app.MapPost("/todoitems", (TodoItem item) =&gt;
      {
          ToDoItems.Add(item);
          return Results.Created();
      }).AddEndpointFilter&lt;CreateTodoFilter&gt;();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.649.1">
      Alternatively, if you want to define the endpoint filter inline, you can do so by passing in an
     </span>
     <a id="_idIndexMarker125">
     </a>
     <span class="koboSpan" id="kobo.650.1">
      anonymous function instead of a type
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.651.1">
       after
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.652.1">
        AddEndpointFilter
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.653.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.654.1">
    app.MapPost("/todoitems", (TodoItem item) =&gt;
    {
        ToDoItems.Add(item);
        return Results.Created();
    }).AddEndpointFilter(async (context, next) =&gt;
    {
        var toDoItem =
            context.GetArgument&lt;TodoItem&gt;(0);
        if (toDoItem.Assignee == "Joe Bloggs")
        {
            return Results.Problem(
                "Joe Bloggs cannot be assigned todo
                items");
        }
        return await next(context);
    });</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.655.1">
     Now that you’ve gained some insight into the various ways we can achieve validation for different API endpoints, let’s recap the things we’ve learned in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.656.1">
      this chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-65">
    <a id="_idTextAnchor093">
    </a>
    <span class="koboSpan" id="kobo.657.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.658.1">
     In this chapter, we took a high-level view of HTTP methods and how they are handled.
    </span>
    <span class="koboSpan" id="kobo.658.2">
     We explored in further detail the way in which requests can be routed, allowing essential parameters to be lifted out of route definitions with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.659.1">
      routing parameters.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.660.1">
     We also delved into the basics of validation, firstly by placing constraints on our API routes to ensure that the data received is formatted in an appropriate manner.
    </span>
    <span class="koboSpan" id="kobo.660.2">
     Following this, we learned how to handle validation in different ways, including manual validation, and the use of data annotations in models to invoke validation in a centralized fashion within the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.661.1">
      endpoint body.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.662.1">
     Throughout the chapter, we saw examples of how errors can be captured through validation techniques, and how informative error responses should be handed back to clients to inform their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.663.1">
      debugging strategies.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.664.1">
     By now, you should be capable of putting together a basic yet functional minimal API project.
    </span>
    <span class="koboSpan" id="kobo.664.2">
     In the next chapter, we will learn how to introduce custom functionalities to our application pipelines in the form
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.665.1">
      of middleware.
     </span>
    </span>
   </p>
  </div>
 </body></html>