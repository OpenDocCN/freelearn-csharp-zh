<html><head></head><body>
<div id="_idContainer069">
<h1 class="chapter-number" id="_idParaDest-187"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-188"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.2.1">Microservice Container Hosting</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Once we have completed a fair amount of development, our next major concern is </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">hosting</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">Hosting comes with its own set of problems because there are many options, and the pros and cons of these options are relative to the application’s architecture and overall needs.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Typical hosting options for a web application would be a simple server and a singular point of entry to that server via an IP address or domain name. </span><span class="koboSpan" id="kobo.6.2">Now, we are building a microservices application where we pride ourselves on the fact that we can promote loose coupling and have all the parts of our application act autonomously and without direct dependency on each other. </span><span class="koboSpan" id="kobo.6.3">The challenge now becomes how we cater to a potentially heterogeneous application. </span><span class="koboSpan" id="kobo.6.4">Each service is autonomous and might have varied hosting and database requirements. </span><span class="koboSpan" id="kobo.6.5">We would then need to consider creating specific hosting environments for each technology, which can lead to massive cost implications.</span></p>
<p><span class="koboSpan" id="kobo.7.1">This is where we can take advantage of container hosting technologies and minimize the cost overheads of having several server machines. </span><span class="koboSpan" id="kobo.7.2">We can use containers as scaled-down imitations of the minimum hosting requirements for each technology and database that is being used in the microservices architecture, and we can configure endpoints by which each container can be accessed.</span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we will review how containers work, how they can benefit us, and why they are an essential tool for efficiently hosting a microservices application.</span></p>
<p><span class="koboSpan" id="kobo.9.1">We will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Understand the use of Docker and containers</span></li>
<li><span class="koboSpan" id="kobo.11.1">Learn how to use Dockerfiles and commands</span></li>
<li><span class="koboSpan" id="kobo.12.1">Learn how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">docker-compose</span></strong><span class="koboSpan" id="kobo.14.1"> and orchestrate Docker images</span></li>
<li><span class="koboSpan" id="kobo.15.1">Learn how to deploy a microservices application in containers and to a container registry</span></li>
</ul>
<h1 id="_idParaDest-189"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.16.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.17.1">Code references used in this chapter can be found in the project repository, which is hosted on GitHub at this URL: </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch13"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch13</span></a><span class="koboSpan" id="kobo.19.1">.</span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.20.1">Using containers in microservices development</span></h1>
<p><span class="koboSpan" id="kobo.21.1">Containers are</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.22.1"> all the rage in the development</span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.23.1"> space. </span><span class="koboSpan" id="kobo.23.2">They present us with a lightweight application hosting option that allows us to deploy our applications in a clean and repeatable manner. </span><span class="koboSpan" id="kobo.23.3">They are not new, but their use in more commercial and accessible spaces has been made far more popular in recent years. </span><span class="koboSpan" id="kobo.23.4">What, however, is a container, and why should we care about how it works? </span><span class="koboSpan" id="kobo.23.5">Let us review that next.</span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.24.1">What can containers do for me?</span></h2>
<p><span class="koboSpan" id="kobo.25.1">Traditionally </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.26.1">speaking, whenever we have applications that have specific requirements for environments and software, we would resort to using servers to facilitate the requirements. </span><span class="koboSpan" id="kobo.26.2">The problem with servers and servers per application is that they come with costs. </span><span class="koboSpan" id="kobo.26.3">A server machine is generally not cheap, and then we must also factor in licensing and energy costs when new machines are introduced. </span><span class="koboSpan" id="kobo.26.4">Also, consider that if a machine goes down, we will need to reconfigure that machine to the original environmental specifications and reprovision several aspects of the original deployment.</span></p>
<p><span class="koboSpan" id="kobo.27.1">At this point, we begin to think about virtualization. </span><span class="koboSpan" id="kobo.27.2">This means that we now use </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">virtual machines</span></strong><span class="koboSpan" id="kobo.29.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.30.1">VMs</span></strong><span class="koboSpan" id="kobo.31.1">) for</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.32.1"> new servers and reuse the old infrastructure. </span><span class="koboSpan" id="kobo.32.2">This will go a long way in reducing the physical infrastructure requirements and costs and allow us to scale a bot more easily. </span><span class="koboSpan" id="kobo.32.3">We can also use snapshots of the machines to keep a quick recovery plan up our sleeves in times of failure. </span><span class="koboSpan" id="kobo.32.4">There are several virtualization solutions on the market, including popular ones such as </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">VMware, VirtualBox, and Microsoft Hyper-V</span></strong><span class="koboSpan" id="kobo.34.1">.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.35.1">Figure 13.1</span></em><span class="koboSpan" id="kobo.36.1"> shows a server with several VMs:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.37.1"><img alt="Figure 13.1 – One machine is required to support multiple VMs on top of a hypervisor" src="image/Figure_13.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.38.1">Figure 13.1 – One machine is required to support multiple VMs on top of a hypervisor</span></p>
<p><span class="koboSpan" id="kobo.39.1">This visualization approach seems like the silver bullet we need, except we have found more problems with</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.40.1"> this solution, which are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.41.1">We will still need to factor in that we need very powerful machines to be able to handle multiple VMs</span></li>
<li><span class="koboSpan" id="kobo.42.1">We will still have the manual maintenance tasks required to keep our environments and operating systems up to date and secure</span></li>
<li><span class="koboSpan" id="kobo.43.1">We must remember that there are several situations where we attempt to provision the same environment on different installations and encounter unforeseen differences each time</span></li>
<li><span class="koboSpan" id="kobo.44.1">We cannot always rely on the machine environment to remain consistent with each instance</span></li>
</ul>
<p><span class="koboSpan" id="kobo.45.1">Now, this brings us to the most recent solution to this problem, which is containers. </span><span class="koboSpan" id="kobo.45.2">Containers build on the concept given to us VMs and allow us to downsize the overall space and resource requirements that an application might need. </span><span class="koboSpan" id="kobo.45.3">The use of containers to host our applications is</span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.46.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">containerization</span></strong><span class="koboSpan" id="kobo.48.1">—this is an approach in modern software development that allows us to package an application and all its dependencies and create a repeatable, testable, and reliable package called an </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">image</span></strong><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">This</span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.51.1"> image can then be deployed directly to several places in a consistent way.</span></p>
<p><span class="koboSpan" id="kobo.52.1">This consistency is very important in how we distinguish the benefits of containers from VMs. </span><span class="koboSpan" id="kobo.52.2">We just reviewed that we cannot always be sure that each </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">operating system</span></strong><span class="koboSpan" id="kobo.54.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.55.1">OS</span></strong><span class="koboSpan" id="kobo.56.1">) instance</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.57.1"> of a server or VM will be the same. </span><span class="koboSpan" id="kobo.57.2">Containers strip away many of the variables that we contend with during deployments and provide an environment that is specifically tuned for the application that needs to be deployed.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.58.1">Figure 13.2</span></em><span class="koboSpan" id="kobo.59.1"> shows a server with several containers and apps:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.60.1"><img alt="Figure 13.2 – One machine can host several container apps and make better use of its resources" src="image/Figure_13.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 13.2 – One machine can host several container apps and make better use of its resources</span></p>
<p><span class="koboSpan" id="kobo.62.1">Another benefit, as </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.63.1">seen in </span><em class="italic"><span class="koboSpan" id="kobo.64.1">Figure 13.2</span></em><span class="koboSpan" id="kobo.65.1">, is that we can now maximize the resource usage of a physical server since we no longer need to provide a set amount of RAM, CPU, and storage for entire instances of operating systems.</span></p>
<p><span class="koboSpan" id="kobo.66.1">Containers also provide isolation from each other on a shared operating system, so we do not need to worry about heterogenous requirements across containers. </span><span class="koboSpan" id="kobo.66.2">In simpler terms, it will be acceptable to run one container in a Linux environment alongside one that needs a Windows-based environment. </span><span class="koboSpan" id="kobo.66.3">Using containers will make our applications more scalable and reliable. </span><span class="koboSpan" id="kobo.66.4">We can easily provision new instances of containers as needed and run multiple identical instances.</span></p>
<p><span class="koboSpan" id="kobo.67.1">There is a major security risk in using VMs that need to communicate with each other. </span><span class="koboSpan" id="kobo.67.2">They generate metadata files that contain very sensitive information about the data being exchanged and how it is exchanged. </span><span class="koboSpan" id="kobo.67.3">With this information, an attacker could seek to replay operations and insert malicious information into the mix. </span><span class="koboSpan" id="kobo.67.4">Containers do not transfer this risk and will support inter-container communication in a far more secure manner.</span></p>
<p><span class="koboSpan" id="kobo.68.1">Containers are not new, but they are becoming more and more popular for hosting isolated operations in consumer applications and improving efficiency for applications deployed to less powerful machines. </span><span class="koboSpan" id="kobo.68.2">To use containers, we need a container hosting solution such as</span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.69.1"> Docker. </span><span class="koboSpan" id="kobo.69.2">We will review how we can get started with Docker and containers next.</span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.70.1">Understanding Docker</span></h2>
<p><span class="koboSpan" id="kobo.71.1">Before we dive into Docker</span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.72.1"> and how it works, it is noteworthy that Docker is not the only application that handles containerization. </span><span class="koboSpan" id="kobo.72.2">There are several alternatives that follow the </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.73.1">same </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">Open Container Initiative</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">OCI</span></strong><span class="koboSpan" id="kobo.77.1">) standards and allow us to containerize our applications. </span><span class="koboSpan" id="kobo.77.2">Docker, however, revolutionized and propelled containerization into mainstream access and exposure. </span><span class="koboSpan" id="kobo.77.3">It is a free (for development and open source) application that is available cross-platform and allows us to version control our containers and generally manage several container instances</span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.78.1"> through </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.79.1">either a </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">user interface</span></strong><span class="koboSpan" id="kobo.81.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">UI</span></strong><span class="koboSpan" id="kobo.83.1">) or a </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">command-line interface</span></strong><span class="koboSpan" id="kobo.85.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.86.1">CLI</span></strong><span class="koboSpan" id="kobo.87.1">).</span></p>
<p><span class="koboSpan" id="kobo.88.1">Docker’s engine has a client-server implementation style, where both client and server run on the same hardware. </span><span class="koboSpan" id="kobo.88.2">The client is a CLI, and it interacts with the server via a REST API to send instructions and execute functions. </span><span class="koboSpan" id="kobo.88.3">The Docker server is a background job, or daemon, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">dockerd</span></strong><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">It is responsible for tracking the life cycle of our containers. </span><span class="koboSpan" id="kobo.90.3">We also have objects that need to be created and configured to support deployments. </span><span class="koboSpan" id="kobo.90.4">These objects can be networks, storage volumes, and plugins, to name a few. </span><span class="koboSpan" id="kobo.90.5">We create these objects on a case-by-case basis and deploy them as needed.</span></p>
<p><span class="koboSpan" id="kobo.91.1">So, let’s recap a bit. </span><span class="koboSpan" id="kobo.91.2">A container is a self-contained space that is prepared to host one application at a time. </span><span class="koboSpan" id="kobo.91.3">The definition of a container’s environment and dependencies is called an image. </span><span class="koboSpan" id="kobo.91.4">This image is a consistent blueprint for what the environment needs to look like. </span><span class="koboSpan" id="kobo.91.5">Images exist for several third-party applications as well, and this makes it easy for us to spin up an instance. </span><span class="koboSpan" id="kobo.91.6">It is good to have a central repository for images, and Docker provides </span><em class="italic"><span class="koboSpan" id="kobo.92.1">Docker Hub</span></em><span class="koboSpan" id="kobo.93.1"> for this reason.</span></p>
<p><span class="koboSpan" id="kobo.94.1">Docker Hub is a container registry that stores and distributes container images. </span><span class="koboSpan" id="kobo.94.2">We can use it to host our own images, and there is a public space for generally available and shared images for industry-leading applications. </span><span class="koboSpan" id="kobo.94.3">Note—Docker Hub is not the only registry. </span><span class="koboSpan" id="kobo.94.4">There are alternatives such as </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.95.1">Microsoft </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">Azure Container Registry</span></strong><span class="koboSpan" id="kobo.97.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.98.1">ACR</span></strong><span class="koboSpan" id="kobo.99.1">), which allows us to integrate with other Azure services more seamlessly.</span></p>
<p><span class="koboSpan" id="kobo.100.1">We have mentioned</span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.101.1"> container images a few times now. </span><span class="koboSpan" id="kobo.101.2">Let us discuss them a bit more in the next section.</span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.102.1">Understanding container images</span></h2>
<p><span class="koboSpan" id="kobo.103.1">A container image, as </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.104.1">mentioned before, is a blueprint for the contents of a container. </span><span class="koboSpan" id="kobo.104.2">It is a portable package that materializes as an in-memory instance of a container. </span><span class="koboSpan" id="kobo.104.3">A key feature is that images are immutable. </span><span class="koboSpan" id="kobo.104.4">Once we have defined the image, it cannot be changed. </span><span class="koboSpan" id="kobo.104.5">Each container that is based on the image, or a specific version of that image, will be the same. </span><span class="koboSpan" id="kobo.104.6">This helps us to guarantee that the environment that worked in development and staging will be present in production. </span><span class="koboSpan" id="kobo.104.7">No longer will we need the </span><em class="italic"><span class="koboSpan" id="kobo.105.1">it worked on my machine</span></em><span class="koboSpan" id="kobo.106.1"> excuse during deployments.</span></p>
<p><span class="koboSpan" id="kobo.107.1">A base image is an image that acts as a foundation for other images. </span><span class="koboSpan" id="kobo.107.2">It starts off using Docker’s scratch image, which is an empty container image that does not create a filesystem layer. </span><span class="koboSpan" id="kobo.107.3">This means that the image assumes that the application we will be running will run directly from the operating system’s kernel.</span></p>
<p><span class="koboSpan" id="kobo.108.1">A parent image is a container image that is a foundational image for other images. </span><span class="koboSpan" id="kobo.108.2">It is usually based on an operating system and will host an application that is designed to run on that operating system. </span><span class="koboSpan" id="kobo.108.3">For instance, we might need a Redis cache instance on our machine. </span><span class="koboSpan" id="kobo.108.4">This Redis cache image will be based on Linux. </span><span class="koboSpan" id="kobo.108.5">That is the parent image.</span></p>
<p><span class="koboSpan" id="kobo.109.1">In both cases, the images are reusable, but base images allow us to have more control over the final image. </span><span class="koboSpan" id="kobo.109.2">We can always add to the image, but we cannot subtract, since images are immutable.</span></p>
<p><span class="koboSpan" id="kobo.110.1">Docker Hub is a reliable and secure registry of popular and in-demand container images that can easily be pulled onto your machine. </span><span class="koboSpan" id="kobo.110.2">The Docker CLI provides a direct connection to Docker Hub, and with a few commands, we can pull images to the host machine from which it was executed.</span></p>
<p><span class="koboSpan" id="kobo.111.1">If we were to set up a Redis cache container, we could do so with a few simple steps. </span><span class="koboSpan" id="kobo.111.2">First, we should install Docker on our device, which you can get from </span><a href="https://www.docker.com"><span class="koboSpan" id="kobo.112.1">www.docker.com</span></a><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">Once it is installed, we can proceed to run the following command in our CLI:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.114.1">
docker pull redis</span></pre>
<p><span class="koboSpan" id="kobo.115.1">This will pull the latest Redis cache application image from the Docker Hub registry and create a container on your machine. </span><span class="koboSpan" id="kobo.115.2">Now that we have the image, we can create a container based on the image with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">docker run</span></strong><span class="koboSpan" id="kobo.117.1"> command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.118.1">
docker run --name my-redis-container -d redis</span></pre>
<p><span class="koboSpan" id="kobo.119.1">Now, we have an instance of Redis cache running on the host machine, and we can connect using any Redis cache management tool. </span><span class="koboSpan" id="kobo.119.2">When we no longer need this container to be running, we can simply use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">docker stop</span></strong><span class="koboSpan" id="kobo.121.1"> command, like this:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.122.1">
docker stop my-redis-container</span></pre>
<p><span class="koboSpan" id="kobo.123.1">Now, this is an example of how we can quickly create an optimized environment for a third-party application, but a major part of why we use Docker is the fact that we can provide containers</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.124.1"> for our own applications. </span><span class="koboSpan" id="kobo.124.2">Before we explore how this is done, we should seek to appreciate the pros and cons of using containers. </span><span class="koboSpan" id="kobo.124.3">We will look at these next.</span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.125.1">Pros and cons of containers</span></h2>
<p><span class="koboSpan" id="kobo.126.1">The benefits of </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.127.1">using </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.128.1">containerization in our applications are clear. </span><span class="koboSpan" id="kobo.128.2">We can take advantage of managing our hosting environments, consistency in how we deliver software, more efficient use of system resources, and software portability.</span></p>
<p><span class="koboSpan" id="kobo.129.1">Recall that containers will only require the exact resources needed for the hosted application to run. </span><span class="koboSpan" id="kobo.129.2">This means that we can rest assured that we are not overextending or over-provisioning resources to accommodate a container. </span><span class="koboSpan" id="kobo.129.3">We can also benefit from how easy it is to spin up new containers as needed. </span><span class="koboSpan" id="kobo.129.4">If we were using VMs, then each application might require an entire machine instance. </span><span class="koboSpan" id="kobo.129.5">Containers have a much smaller footprint and require far less to host a new application.</span></p>
<p><span class="koboSpan" id="kobo.130.1">Amidst all these advantages, we need to be aware of the possible drawbacks of using this hosting and deployment method. </span><span class="koboSpan" id="kobo.130.2">Containers will share a single operating system and this shared reliance means that we now have a single point of failure or attack. </span><span class="koboSpan" id="kobo.130.3">This can be concerning for security teams. </span><span class="koboSpan" id="kobo.130.4">Monitoring our applications also becomes a bit more difficult since we have less to work with. </span><span class="koboSpan" id="kobo.130.5">Containers generally provide log information to give us insight into the health of the application, but we are not always aware of the additional resources and plugins that are at work, and this makes a total monitoring operation a bit more difficult.</span></p>
<p><span class="koboSpan" id="kobo.131.1">Should we proceed to use containerization in our applications, we need to be familiar with how we author images for the sole purpose of hosting our application. </span><span class="koboSpan" id="kobo.131.2">In this case, we need to know and understand how to use a base image and deploy our own application to a</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.132.1"> new </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.133.1">container. </span><span class="koboSpan" id="kobo.133.2">For this, we need a Dockerfile, and we will review how we can create one next.</span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.134.1">Authoring a Dockerfile</span></h1>
<p><span class="koboSpan" id="kobo.135.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.137.1"> is a text</span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.138.1"> file that outlines how a Docker image should be built. </span><span class="koboSpan" id="kobo.138.2">The</span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.139.1"> language used is </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">Yet Another Markup Language</span></strong><span class="koboSpan" id="kobo.141.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.142.1">YAML</span></strong><span class="koboSpan" id="kobo.143.1">), which is a popular markup language used for configuration files. </span><span class="koboSpan" id="kobo.143.2">This file usually contains the following elements:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.144.1">A base or parent image to base the new image on</span></li>
<li><span class="koboSpan" id="kobo.145.1">Commands to update the operating system and additional software and plugins as needed</span></li>
<li><span class="koboSpan" id="kobo.146.1">Compiled application assets to be included in the image</span></li>
<li><span class="koboSpan" id="kobo.147.1">Additional container image assets for storage and networking needs</span></li>
<li><span class="koboSpan" id="kobo.148.1">A command to run the application when the container launches</span></li>
</ul>
<p><span class="koboSpan" id="kobo.149.1">In our case, we are building a microservices-based application with several web services. </span><span class="koboSpan" id="kobo.149.2">This means that we need to author Dockerfiles per web service. </span><span class="koboSpan" id="kobo.149.3">Since all our services are ASP.NET Core based, we can use the following example of a Dockerfile as a base example for our appointment web service and others.</span></p>
<p><span class="koboSpan" id="kobo.150.1">To add a Dockerfile to our project, we can use </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">Visual Studio</span></strong><span class="koboSpan" id="kobo.152.1"> and simply right-click our project in </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.154.1">, go to </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">Add</span></strong><span class="koboSpan" id="kobo.156.1">, and then click </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">Docker Support…</span></strong><span class="koboSpan" id="kobo.158.1">.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.159.1">Figure 13.3</span></em><span class="koboSpan" id="kobo.160.1"> shows the </span><strong class="bold"><span class="koboSpan" id="kobo.161.1">Docker Support…</span></strong><span class="koboSpan" id="kobo.162.1"> option:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.163.1"><img alt="Figure 13.3 – Adding Docker Support in Visual Studio 2022" src="image/Figure_13.3_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.164.1">Figure 13.3 – Adding Docker Support in Visual Studio 2022</span></p>
<p><span class="koboSpan" id="kobo.165.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.167.1">, you </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.168.1">can install the official Docker extension provided by Microsoft. </span><span class="koboSpan" id="kobo.168.2">Once this extension is installed, you can then add Dockerfiles to your workspace by selecting the </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">Docker: Add Docker Files to Workspace</span></strong><span class="koboSpan" id="kobo.170.1"> command from the command palette. </span><span class="koboSpan" id="kobo.170.2">It will then seek to confirm the type of application runtime that we wish to support with our container and confirm if we need </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">docker-compose</span></strong><span class="koboSpan" id="kobo.172.1"> support. </span><span class="koboSpan" id="kobo.172.2">Once we complete selecting our options, it will proceed to generate our files.</span></p>
<p><span class="koboSpan" id="kobo.173.1">Both paths will produce two new files in the target project. </span><span class="koboSpan" id="kobo.173.2">We get a Dockerfile and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">.dockerignore</span></strong><span class="koboSpan" id="kobo.175.1"> file. </span><span class="koboSpan" id="kobo.175.2">In the case of the appointments booking service project, if we complete the preceding steps, we end up with a Dockerfile that looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443
FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build
WORKDIR /src
COPY ["HealthCare.Appointments.Api/HealthCare.Appointments.Api.c
  sproj", "HealthCare.Appointments.Api/"]
COPY ["HealthCare.SharedAssets/HealthCare.SharedAssets.csproj",
  "HealthCare.SharedAssets/"]
RUN dotnet restore "HealthCare.Appointments.Api
  /HealthCare.Appointments.Api.csproj"
COPY . </span><span class="koboSpan" id="kobo.176.2">.
</span><span class="koboSpan" id="kobo.176.3">WORKDIR "/src/HealthCare.Appointments.Api"
RUN dotnet build "HealthCare.Appointments.Api.csproj" -c
  Release -o /app/build
FROM build AS publish
RUN dotnet publish "HealthCare.Appointments.Api.csproj" -c
  Release -o /app/publish /p:UseAppHost=false
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
</span><span class="koboSpan" id="kobo.176.4">ENTRYPOINT ["dotnet", "HealthCare.Appointments.Api.dll"]</span></pre>
<p><span class="koboSpan" id="kobo.177.1">This Dockerfile has instructions that will create an image for the target service and build the container. </span><span class="koboSpan" id="kobo.177.2">The instructions execute the following actions:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.178.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">mcr.microsoft.com/dotnet/aspnet:6.0</span></strong><span class="koboSpan" id="kobo.180.1"> image as the base from which we will derive the rest of our new image.</span></li>
<li><span class="koboSpan" id="kobo.181.1">Define which ports we wish to expose from our container, which are the standard web traffic ports for HTTP (</span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">80</span></strong><span class="koboSpan" id="kobo.183.1">) and HTTPS (</span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">443</span></strong><span class="koboSpan" id="kobo.185.1">).</span></li>
<li><span class="koboSpan" id="kobo.186.1">Define our own content in the image by copying the contents of key files and directories that we need for the app.</span></li>
<li><span class="koboSpan" id="kobo.187.1">Perform </span><em class="italic"><span class="koboSpan" id="kobo.188.1">build</span></em><span class="koboSpan" id="kobo.189.1">, </span><em class="italic"><span class="koboSpan" id="kobo.190.1">restore</span></em><span class="koboSpan" id="kobo.191.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.192.1">publish</span></em><span class="koboSpan" id="kobo.193.1"> operations to generate binaries, and after the publish operation, run and copy the files from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">publish</span></strong><span class="koboSpan" id="kobo.195.1"> directory to the container space.</span></li>
<li><span class="koboSpan" id="kobo.196.1">Define </span><em class="italic"><span class="koboSpan" id="kobo.197.1">ENTRYPOINT</span></em><span class="koboSpan" id="kobo.198.1"> as the executing binary for the project that will launch our application.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.199.1">We also get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">.dockerignore</span></strong><span class="koboSpan" id="kobo.201.1"> file that outlines files and directories that should not be included in the</span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.202.1"> container when it is created. </span><span class="koboSpan" id="kobo.202.2">Its contents look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
**/.classpath
**/.dockerignore
**/.env
**/.git
**/.gitignore
**/.project
**/.settings
**/.toolstarget
**/.vs
**/.vscode
**/*.*proj.user
**/*.dbmdl
**/*.jfm
**/azds.yaml
**/bin
**/charts
**/docker-compose*
**/Dockerfile*
**/node_modules
**/npm-debug.log
**/obj
**/secrets.dev.yaml
**/values.dev.yaml
LICENSE
README.md</span></pre>
<p><span class="koboSpan" id="kobo.204.1">This file is simple to understand, and modifying it is not generally required. </span><span class="koboSpan" id="kobo.204.2">It is simply outlining the different areas of the project file composition that it doesn’t deem necessary to transport</span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.205.1"> to the container once the application is built and deployed.</span></p>
<p><span class="koboSpan" id="kobo.206.1">Our Dockerfile is a starting point for our own container that will house the target web service. </span><span class="koboSpan" id="kobo.206.2">Just to recap on how containers are built, we start off with a </span><em class="italic"><span class="koboSpan" id="kobo.207.1">registry</span></em><span class="koboSpan" id="kobo.208.1">, and this registry contains </span><em class="italic"><span class="koboSpan" id="kobo.209.1">images</span></em><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">In this set of images, we have base images, which are a starting point for all subsequent images. </span><span class="koboSpan" id="kobo.210.3">In this case, our first line refers to a base image from which we wish to derive our web service container. </span><span class="koboSpan" id="kobo.210.4">Note that the origin and base images of the base image that we ended up using are not visible through this process. </span><span class="koboSpan" id="kobo.210.5">The truth is, we don’t know the hierarchy behind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">mcr.microsoft.com/dotnet/aspnet:6.0</span></strong><span class="koboSpan" id="kobo.212.1"> base image, nor the hierarchy of those images. </span><span class="koboSpan" id="kobo.212.2">This approach helps us to make use of the various images that have contributed to our current base image, without needing to make direct references to them or bloat our file with references. </span><span class="koboSpan" id="kobo.212.3">We are simply making our own derivative henceforth. </span><span class="koboSpan" id="kobo.212.4">This ties in with the goal of keeping our container images small.</span></p>
<p><span class="koboSpan" id="kobo.213.1">Now, let us explore how we can use this Dockerfile going forward.</span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.214.1">Launching a containerized application</span></h2>
<p><span class="koboSpan" id="kobo.215.1">Now that we</span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.216.1"> have done this process for one of </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.217.1">our services, we can easily repeat it for the others. </span><span class="koboSpan" id="kobo.217.2">By doing this, we will have completely and successfully containerized each of our web services and, by extension, our microservices application. </span><span class="koboSpan" id="kobo.217.3">It is noteworthy as well that Visual Studio and Visual Studio Code will always generate the best Dockerfile to suit the project type that you are working with. </span><span class="koboSpan" id="kobo.217.4">We can now also enjoy the new launch feature that gets introduced where we can launch our new containerized web service in a Docker container and still retain real-time analytics and debugging features as if it were running in a normal debugging setting.</span></p>
<p><span class="koboSpan" id="kobo.218.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.220.1">, we can look under the project folder, inspect the folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">Properties</span></strong><span class="koboSpan" id="kobo.222.1">, and open the file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">launchSettings.json</span></strong><span class="koboSpan" id="kobo.224.1">. </span><span class="koboSpan" id="kobo.224.2">This is a JSON configuration file that comes as standard in every ASP.NET Core project, and unless you have a specific reason to, you wouldn’t normally open or modify this file. </span><span class="koboSpan" id="kobo.224.3">It was, however, modified and given a new launch profile, which informs </span><em class="italic"><span class="koboSpan" id="kobo.225.1">Visual Studio</span></em><span class="koboSpan" id="kobo.226.1"> that there is a new way to launch this application for debugging. </span><span class="koboSpan" id="kobo.226.2">The file now looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
  "profiles": {
    "HealthCare.Appointments.Api": {
    // Unchanged Content
    },
    "IIS Express": {
     // Unchanged Content
      }
    },
    "Docker": {
      "commandName": "Docker",
      "launchBrowser": true,
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}
         /swagger",
      "publishAllPorts": true,
      "useSSL": true
    }
  },</span></pre>
<p><span class="koboSpan" id="kobo.228.1">This new </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Docker</span></strong><span class="koboSpan" id="kobo.230.1"> section was created during our introduction of the Dockerfile, and it now allows us to select </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">Docker</span></strong><span class="koboSpan" id="kobo.232.1"> as a launch option from Visual Studio. </span><span class="koboSpan" id="kobo.232.2">This will proceed to execute the instructions outlined in the Dockerfile where it will create a new image based on the base Microsoft image, build, restore, and publish our web project, and then move the files to a freshly created container and execute the application.</span></p>
<p><span class="koboSpan" id="kobo.233.1">The only major difference that we will see in this experience is that the UIs in Visual Studio or Visual Studio Code will show more information regarding the containers, such as their health, version, ports, environment variables, logs, and even the filesystem that the container is using.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.234.1">Figure 13.4</span></em><span class="koboSpan" id="kobo.235.1"> shows</span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.236.1"> the Visual Studio UI while </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.237.1">using Docker for debugging:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.238.1"><img alt="Figure 13.4 – We see Visual Studio in debug mode while containers are in use; it shows us information about the container during runtime" src="image/Figure_13.4_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.239.1">Figure 13.4 – We see Visual Studio in debug mode while containers are in use; it shows us information about the container during runtime</span></p>
<p><span class="koboSpan" id="kobo.240.1">While we are debugging with our Docker containers, you may notice the containers in Docker’s </span><strong class="bold"><span class="koboSpan" id="kobo.241.1">graphical UI</span></strong><span class="koboSpan" id="kobo.242.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.243.1">GUI</span></strong><span class="koboSpan" id="kobo.244.1">), and</span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.245.1"> they show which ports are available for HTTP traffic. </span><span class="koboSpan" id="kobo.245.2">We will use these ports to handle the configured port mapping accordingly. </span><span class="koboSpan" id="kobo.245.3">If you want to see the running containers using the CLI, you can run this command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.246.1">
docker ps -a</span></pre>
<p><span class="koboSpan" id="kobo.247.1">This will produce a list of containers, showing their names, ports, and status. </span><span class="koboSpan" id="kobo.247.2">Docker has several commands that help us to automate our container operations, such as the following:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">docker run</span></strong><span class="koboSpan" id="kobo.249.1"> starts or creates a container. </span><span class="koboSpan" id="kobo.249.2">It takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">-d</span></strong><span class="koboSpan" id="kobo.251.1"> parameter, which is the name of the container to be started.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">docker pause</span></strong><span class="koboSpan" id="kobo.253.1"> will pause a running container and suspend all services and activities.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">docker unpause</span></strong><span class="koboSpan" id="kobo.255.1"> does the opposite of </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">docker pause</span></strong><span class="koboSpan" id="kobo.257.1">.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">docker restart</span></strong><span class="koboSpan" id="kobo.259.1"> encapsulates the stop and start commands and will reboot a container.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">docker stop</span></strong><span class="koboSpan" id="kobo.261.1"> sends a termination signal to a container and the processes running in the container.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">docker rm</span></strong><span class="koboSpan" id="kobo.263.1"> removes a container and all data associated with the container.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.264.1">The amazing thing to note here is that using containers has made our application extremely portable and deployable. </span><span class="koboSpan" id="kobo.264.2">Now, we do not need to make special configurations on a server and risk one server behaving differently from the other. </span><span class="koboSpan" id="kobo.264.3">We can more easily deploy the same environment through the container on any machine, and we can always </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.265.1">expect the same outcome.</span></p>
<p><span class="koboSpan" id="kobo.266.1">As of .NET 7, we can containerize our applications without needing a Dockerfile. </span><span class="koboSpan" id="kobo.266.2">We will review the steps that can be completed next.</span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.267.1">Using native .NET container support</span></h2>
<p><span class="koboSpan" id="kobo.268.1">With .NET 7, we</span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.269.1"> have native support for </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.270.1">containerization. </span><span class="koboSpan" id="kobo.270.2">This means that we can use .NET packages to add container support to our application and then publish our app directly to a container, all without needing Docker.</span></p>
<p><span class="koboSpan" id="kobo.271.1">Container support is made available through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">Microsoft.NET.Build.Containers</span></strong><span class="koboSpan" id="kobo.273.1"> package. </span><span class="koboSpan" id="kobo.273.2">We can add this package using the following command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.274.1">
Install-package Microsoft.NET.Build.Containers</span></pre>
<p><span class="koboSpan" id="kobo.275.1">Now that we have our package added, we can publish our application to a container and then use Docker to run the published application. </span><span class="koboSpan" id="kobo.275.2">Using the CLI, we can run the following commands:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.276.1">
dotnet publish --os linux --arch x64 -c Release -
  p:PublishProfile=DefaultContainer
docker run -it --rm -p 5010:80 healthcare-patients-
  api:1.0.0</span></pre>
<p><span class="koboSpan" id="kobo.277.1">Now, our self-hosted container will run and listen for traffic on the configured </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">5010</span></strong><span class="koboSpan" id="kobo.279.1"> port.</span></p>
<p><span class="koboSpan" id="kobo.280.1">Now we see that we have several ways that can lead to us containerizing our applications, we do this for all our other services. </span><span class="koboSpan" id="kobo.280.2">This, however, brings a new challenge where we might need to launch our containerized web services in a specific order, or with default values and settings. </span><span class="koboSpan" id="kobo.280.3">For this, we need an orchestrator. </span><span class="koboSpan" id="kobo.280.4">We have mentioned orchestrators before in the form of Kubernetes, which is an industry-leading metaphorical glove for Docker images (the metaphorical hand) to fit in.</span></p>
<p><span class="koboSpan" id="kobo.281.1">Before we get to </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.282.1">Kubernetes, though, Docker</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.283.1"> provides an orchestration engine that is defined by instructions outlined in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">docker-compose</span></strong><span class="koboSpan" id="kobo.285.1"> file. </span><span class="koboSpan" id="kobo.285.2">We will explore how this works in the next section.</span></p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.286.1">Understanding docker-compose and images</span></h1>
<p><span class="koboSpan" id="kobo.287.1">Before we</span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.288.1"> explore </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">docker-compose</span></strong><span class="koboSpan" id="kobo.290.1"> and how</span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.291.1"> it compiles our images, we need to understand the concept of orchestration and why we need it. </span><span class="koboSpan" id="kobo.291.2">Container orchestration is an automated approach to launching containers and related services. </span><span class="koboSpan" id="kobo.291.3">In context, when we have a containerized application, we might end up with several containers between our application that has been containerized and third-party applications that we are using as containers.</span></p>
<p><span class="koboSpan" id="kobo.292.1">In the context of our microservices application where we have several individual services, each one is containerized. </span><span class="koboSpan" id="kobo.292.2">We might also end up using a containerized cache server, and other supporting services such as email and logging applications. </span><span class="koboSpan" id="kobo.292.3">We now need a way to organize our list of containers and launch them in a particular order, such that the supporting applications are available before the dependent service containers are launched.</span></p>
<p><span class="koboSpan" id="kobo.293.1">This requirement introduces a considerable amount of complexity and can make a manual effort very difficult. </span><span class="koboSpan" id="kobo.293.2">Using container orchestration, we can make this operation manageable for development and operations. </span><span class="koboSpan" id="kobo.293.3">We now have a declarative way of defining the work that needs to be done and the order in which our containers should be launched and with which dependencies. </span><span class="koboSpan" id="kobo.293.4">We will now have the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.294.1">Simplified operations</span></strong><span class="koboSpan" id="kobo.295.1">: To reiterate, container orchestration vastly simplifies the recurring effort of launching containers in a specific order and with specific configurations.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.296.1">Resiliency</span></strong><span class="koboSpan" id="kobo.297.1">: Can be used to carry out our specific operations based on container health, system load, or scaling needs. </span><span class="koboSpan" id="kobo.297.2">Orchestration will manage our instances as needed and automate actions that should be taken in the best interest of the application’s stability.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.298.1">Security</span></strong><span class="koboSpan" id="kobo.299.1">: This automated approach helps us to reduce the chance of human error and ensure security in our application.</span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">docker-compose</span></strong><span class="koboSpan" id="kobo.301.1"> is the simplest form of orchestration that we can employ. </span><span class="koboSpan" id="kobo.301.2">Alternatives </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.302.1">include </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.303.1">Kubernetes and Docker Swarm, which are industry-leading options in the container orchestration space.</span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">docker-compose</span></strong><span class="koboSpan" id="kobo.305.1"> is a tool that helps us to define multi-container applications. </span><span class="koboSpan" id="kobo.305.2">We can define a YAML file and define the containers that need to be launched, and their dependencies, and then we can launch the application with a single command. </span><span class="koboSpan" id="kobo.305.3">The major advantage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">docker-compose</span></strong><span class="koboSpan" id="kobo.307.1"> is that we can define everything about our application’s stack in a file and have this defined at the root of our application’s folder.</span></p>
<p><span class="koboSpan" id="kobo.308.1">Another advantage here is that if our project is version controlled, we can easily allow for the evolution of this file through outside contributions, or we can share our containers and the launch steps for our application easily with others.</span></p>
<p><span class="koboSpan" id="kobo.309.1">Now, let us review the steps to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">docker-compose</span></strong><span class="koboSpan" id="kobo.311.1"> support to our microservices application.</span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.312.1">Adding docker-compose to a project</span></h2>
<p><span class="koboSpan" id="kobo.313.1">Adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">docker-compose</span></strong><span class="koboSpan" id="kobo.315.1"> support</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.316.1"> to our ASP.NET Core microservices application is easy. </span><span class="koboSpan" id="kobo.316.2">In Visual Studio, we can simply right-click one of our service projects, go to </span><strong class="bold"><span class="koboSpan" id="kobo.317.1">Add</span></strong><span class="koboSpan" id="kobo.318.1">, and select </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">Container Orchestrator Support…</span></strong><span class="koboSpan" id="kobo.320.1">. </span><span class="koboSpan" id="kobo.320.2">This launches a window where we can confirm that we prefer </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">Docker Compose</span></strong><span class="koboSpan" id="kobo.322.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">OK</span></strong><span class="koboSpan" id="kobo.324.1">. </span><span class="koboSpan" id="kobo.324.2">We can select either </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">Windows</span></strong><span class="koboSpan" id="kobo.326.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.327.1">Linux</span></strong><span class="koboSpan" id="kobo.328.1"> as the target OS. </span><span class="koboSpan" id="kobo.328.2">Either OS option works since ASP.NET Core is cross-platform.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.329.1">Figure 13.5</span></em><span class="koboSpan" id="kobo.330.1"> shows the </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Container Orchestrator Support…</span></strong><span class="koboSpan" id="kobo.332.1"> option:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.333.1"><img alt="Figure 13.5 – Adding container orchestrator support using Visual Studio 2022" src="image/Figure_13.5_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.334.1">Figure 13.5 – Adding container orchestrator support using Visual Studio 2022</span></p>
<p><span class="koboSpan" id="kobo.335.1">This introduces a new project to our solution where we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">.dockerignore</span></strong><span class="koboSpan" id="kobo.337.1"> file and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.339.1"> file. </span><span class="koboSpan" id="kobo.339.2">If we inspect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.341.1"> file, we will see that we have a version number and at least one service defined:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
version: '3.4'
services:
  healthcare.patients.api:
    image: ${DOCKER_REGISTRY-}healthcarepatientsapi
    build:
      context: .
</span><span class="koboSpan" id="kobo.342.2">      dockerfile: HealthCare.Patients.Api/Dockerfile</span></pre>
<p><span class="koboSpan" id="kobo.343.1">Under the definition of our service, we define the containers that we wish to launch and state the name of the image and the Dockerfile that will be a reference point for the image definition. </span><span class="koboSpan" id="kobo.343.2">Following similar steps for the other services, Visual Studio will automatically append additional services to the file accordingly. </span><span class="koboSpan" id="kobo.343.3">If we proceed to do this with the additional</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.344.1"> services, we will end up with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">docker-compose</span></strong><span class="koboSpan" id="kobo.346.1"> file like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
version: '3.4'
services:
  healthcare.patients.api:
    image: ${DOCKER_REGISTRY-}healthcarepatientsapi
    build:
      context: .
</span><span class="koboSpan" id="kobo.347.2">      dockerfile: HealthCare.Patients.Api/Dockerfile
  healthcare.auth:
    image: ${DOCKER_REGISTRY-}healthcareauth
    build:
      context: .
</span><span class="koboSpan" id="kobo.347.3">      dockerfile: HealthCare.Auth/Dockerfile
  healthcare.appointments.api:
    image: ${DOCKER_REGISTRY-}healthcareappointmentsapi
    build:
      context: .
</span><span class="koboSpan" id="kobo.347.4">      dockerfile: HealthCare.Appointments.Api/Dockerfile
  healthcare.apigateway:
    image: ${DOCKER_REGISTRY-}healthcareapigateway
    build:
      context: .
</span><span class="koboSpan" id="kobo.347.5">      dockerfile: HealthCare.ApiGateway/Dockerfile</span></pre>
<p><span class="koboSpan" id="kobo.348.1">Now, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">docker-compose</span></strong><span class="koboSpan" id="kobo.350.1"> file that has a record of each container that needs to be launched in our microservices application. </span><span class="koboSpan" id="kobo.350.2">This file can now be extended to include additional </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.351.1">containers as required by the entire application. </span><span class="koboSpan" id="kobo.351.2">If we need a Redis cache instance, we can add a command to this </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">docker-compose</span></strong><span class="koboSpan" id="kobo.353.1"> file to launch a container for Redis. </span><span class="koboSpan" id="kobo.353.2">This is what it would look like:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.354.1">
services:
  redis:
    image: "redis:alpine"
… Other services …</span></pre>
<p><span class="koboSpan" id="kobo.355.1">This addition to the file will simply spin up a Redis cache container using the defined base image. </span><span class="koboSpan" id="kobo.355.2">Note that the Redis cache image composition can be extended to use storage volumes, and we can pass specific configuration files to our image and indicate that we wish to persist the container’s information in a data volume. </span><span class="koboSpan" id="kobo.355.3">When we restart this image, the data from the last run will still be available.</span></p>
<p><span class="koboSpan" id="kobo.356.1">We might also want to indicate that some containers should be available before others are started. </span><span class="koboSpan" id="kobo.356.2">This could come in handy if a container has a dependency on the Redis cache container or even on another service. </span><span class="koboSpan" id="kobo.356.3">For this, we can add another node called </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">depends_on</span></strong><span class="koboSpan" id="kobo.358.1">, which will allow us to indicate the name of the container that should be launched before we attempt to launch the other. </span><span class="koboSpan" id="kobo.358.2">For example, our appointments service communicates with our patients service from time to time. </span><span class="koboSpan" id="kobo.358.3">It would be prudent of us to make sure that the patients service is launched before we attempt to launch the appointments service. </span><span class="koboSpan" id="kobo.358.4">We can modify the appointment container orchestration to look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.359.1">
healthcare.appointments.api:
    image: ${DOCKER_REGISTRY-}healthcareappointmentsapi
    depends_on:
      - healthcare.patients.api
    build:
      context: .
</span><span class="koboSpan" id="kobo.359.2">      dockerfile: HealthCare.Appointments.Api/Dockerfile</span></pre>
<p><span class="koboSpan" id="kobo.360.1">It is possible for us</span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.361.1"> to provide more specific configurations for each image and even provide more specific configurations for our image, without needing to directly repeat the Dockerfile execution. </span><span class="koboSpan" id="kobo.361.2">This is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">docker-compose.override.yml</span></strong><span class="koboSpan" id="kobo.363.1"> file comes into play. </span><span class="koboSpan" id="kobo.363.2">It is a nested child item that can be found under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.365.1"> file, and its contents look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
version: '3.4'
services:
  healthcare.patients.api:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=https://+:443;http://+:80
    ports:
      - "80"
      - "443"
    volumes:
      - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/
      usersecrets:ro
      - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro
... </span><span class="koboSpan" id="kobo.366.2">Other overrides...</span></pre>
<p><span class="koboSpan" id="kobo.367.1">Here, we see that our API’s container will be launched with specific environment variables and will have preset ports and volumes. </span><span class="koboSpan" id="kobo.367.2">This file can be removed if you prefer to have more explicit control over your containers, but you need to make sure that the relevant values are configured in the Dockerfile.</span></p>
<p><span class="koboSpan" id="kobo.368.1">To revisit our </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Backend for Frontend</span></strong><span class="koboSpan" id="kobo.370.1"> pattern from a previous chapter, we outlined that we could provision multiple gateway projects and provide specific configurations for each instance. </span><span class="koboSpan" id="kobo.370.2">Now that we have containerization, we can remove the need for additional code projects and reuse the same project while using different configurations for each one. </span><span class="koboSpan" id="kobo.370.3">Let us add the following lines to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.372.1"> file </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.373.1">and create two separate containers based on the same gateway image:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
  mobileshoppingapigw:
    image: ${DOCKER_REGISTRY-}healthcareapigateway
    build:
      context: .
</span><span class="koboSpan" id="kobo.374.2">      dockerfile: HealthCare.ApiGateway/Dockerfile
  webshoppingapigw:
    image: ${DOCKER_REGISTRY-}healthcareapigateway
    build:
      context: .
</span><span class="koboSpan" id="kobo.374.3">      dockerfile: HealthCare.ApiGateway/Dockerfile</span></pre>
<p><span class="koboSpan" id="kobo.375.1">Now that we have defined two new containers based on the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">ApiGateway</span></strong><span class="koboSpan" id="kobo.377.1"> image definition, we can add to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">docker-override.yml</span></strong><span class="koboSpan" id="kobo.379.1"> file and specify the sources of the specific configuration files that should be used in either case:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
  mobilegatewaygw:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - IdentityUrl=IDENTITY_URL
    volumes:
      - ./HealthCare.ApiGateway/mobile:/app/configuration
  webhealthcaregw:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - IdentityUrl=IDENTITY_URL
    volumes:
      - ./HealthCare.ApiGateway/web:/app/configuration</span></pre>
<p><span class="koboSpan" id="kobo.381.1">We can specify the volume sources as the paths to the configuration files, but we also took the opportunity to define environment variable values relative to configurations that may vary or need to be set when the container is being created.</span></p>
<p><span class="koboSpan" id="kobo.382.1">In general, we will</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.383.1"> also want to consider the need for other dependencies such as a database server, message bus provider (such as RabbitMQ), supporting web services and utilities, and so on. </span><span class="koboSpan" id="kobo.383.2">All the components of your microservices application can be containerized, and the containers can make direct reference to each other as needed. </span><span class="koboSpan" id="kobo.383.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.385.1"> file allows us to outline all these containers and their variables as needed, and we can easily plug in the values accordingly. </span><span class="koboSpan" id="kobo.385.2">With a few lines, we can get started, but there are many more avenues to explore and master.</span></p>
<p><span class="koboSpan" id="kobo.386.1">Now, we can comfortably launch our entire microservices application and all the components with one click or command. </span><span class="koboSpan" id="kobo.386.2">If using Visual Studio, the button to start with debugging would traditionally have cited the name of one service at a time, or we would need to enable multiple projects to be run at debugging. </span><span class="koboSpan" id="kobo.386.3">Now, the presence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.388.1"> file overrides the need to be that specific and gives us the ability to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">compose</span></strong><span class="koboSpan" id="kobo.390.1"> command and initialize all our containers in one go. </span><span class="koboSpan" id="kobo.390.2">Using the CLI, we can simply run </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">docker-compose up</span></strong><span class="koboSpan" id="kobo.392.1">.</span></p>
<p><span class="koboSpan" id="kobo.393.1">Now, we have a fully containerized application, and we can simply adjust the parameters used to launch our containers and remain agile and scalable in how we handle our application hosting and deployments. </span><span class="koboSpan" id="kobo.393.2">It also makes it easier to share our applications with our development team and have the members run our applications with only Docker installed as a dependency.</span></p>
<p><span class="koboSpan" id="kobo.394.1">We have also seen that there are base images that allow us to extend and create our own images. </span><span class="koboSpan" id="kobo.394.2">There will come a time when we have a particular application or our own version of an </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.395.1">application that we wish to preserve and reshare beyond just our project. </span><span class="koboSpan" id="kobo.395.2">We can publish our container images to a central repository. </span><span class="koboSpan" id="kobo.395.3">We will review this concept next.</span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.396.1">Publishing containers to a container registry</span></h1>
<p><span class="koboSpan" id="kobo.397.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.398.1">container registry</span></strong><span class="koboSpan" id="kobo.399.1"> is a </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.400.1">centralized </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.401.1">repository that stores several containers. </span><span class="koboSpan" id="kobo.401.2">It allows for remote access to these containers and comes in handy for general development and deployment needs when we need a consistent source for a container image for some applications. </span><span class="koboSpan" id="kobo.401.3">Container registries are generally connected directly to platforms such as Docker and Kubernetes.</span></p>
<p><span class="koboSpan" id="kobo.402.1">Registries can save developers time and effort in creating and delivering cloud-native solutions. </span><span class="koboSpan" id="kobo.402.2">Recall that a container image contains files and components that make up an application. </span><span class="koboSpan" id="kobo.402.3">By maintaining a registry, we can maximize our agile development efforts and deliver incremental image updates efficiently, and with the registry, we can store them in a central area for the team.</span></p>
<p><span class="koboSpan" id="kobo.403.1">A container registry can be private or public. </span><span class="koboSpan" id="kobo.403.2">We will discuss our options next.</span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.404.1">Public versus private container registries</span></h2>
<p><span class="koboSpan" id="kobo.405.1">A registry can</span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.406.1"> be public or private. </span><span class="koboSpan" id="kobo.406.2">Public repositories are generally used by developers or teams of developers who either want to provision a registry as quickly as possible or want to publicly share containers that they have developed. </span><span class="koboSpan" id="kobo.406.3">These images are then used as base images by others and are sometimes tweaked. </span><span class="koboSpan" id="kobo.406.4">This is a great way to contribute to the open source collection of container images. </span><span class="koboSpan" id="kobo.406.5">Docker Hub is the largest public repository and community for containers and is the default source of our container images when we do a </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">docker pull</span></strong><span class="koboSpan" id="kobo.408.1"> command.</span></p>
<p><span class="koboSpan" id="kobo.409.1">Private repositories provide a more secure and private way to host and maintain enterprise containers. </span><span class="koboSpan" id="kobo.409.2">These types of registries can be remote through established registries</span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.410.1"> such</span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.411.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.412.1">Google Container Registry</span></strong><span class="koboSpan" id="kobo.413.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.414.1">GCR</span></strong><span class="koboSpan" id="kobo.415.1">), Microsoft </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.416.1">ACR, or</span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.417.1"> Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">Elastic Container Registry</span></strong><span class="koboSpan" id="kobo.419.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.420.1">ECR</span></strong><span class="koboSpan" id="kobo.421.1">).</span></p>
<p><span class="koboSpan" id="kobo.422.1">When using a private container registry, we have more control over security and configuration, but we also take on more management responsibilities for access control and compliance within your organization. </span><span class="koboSpan" id="kobo.422.2">We need to maintain the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.423.1">Support for </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.424.1">several authentication options within our organization</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.425.1">Role-based access control</span></strong><span class="koboSpan" id="kobo.426.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.427.1">RBAC</span></strong><span class="koboSpan" id="kobo.428.1">) for</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.429.1"> images</span></li>
<li><span class="koboSpan" id="kobo.430.1">Image versioning and maintenance against vulnerabilities</span></li>
<li><span class="koboSpan" id="kobo.431.1">User activity auditing and logging</span></li>
</ul>
<p><span class="koboSpan" id="kobo.432.1">We can properly control who is able to upload images through more strict controls and measures and prevent unauthorized access and contributions to the registry.</span></p>
<p><span class="koboSpan" id="kobo.433.1">Recall that a container registry can be hosted locally. </span><span class="koboSpan" id="kobo.433.2">This means that we can stage a local instance of Docker Hub on a server and add configurations that are specific to our organization’s needs and policies. </span><span class="koboSpan" id="kobo.433.3">We can also leverage cloud-hosted container registry </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.434.1">services. </span><span class="koboSpan" id="kobo.434.2">The advantage of using cloud-hosted solutions is that we can reduce the infrastructural consideration that comes with setting up a local server as well as taking advantage of a fully managed and geo-replicated solution.</span></p>
<p><span class="koboSpan" id="kobo.435.1">Let us review how we can create a customized version of an image and upload it to a registry.</span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.436.1">Creating and uploading custom images</span></h2>
<p><span class="koboSpan" id="kobo.437.1">We have</span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.438.1"> already</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.439.1"> created several images to support our application. </span><span class="koboSpan" id="kobo.439.2">There are times when we might need a particular application to be deployed in a consistent and repeatable manner, and we don’t want to risk recreating the Dockerfile or </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.441.1"> file.</span></p>
<p><span class="koboSpan" id="kobo.442.1">In this case, we can pull a copy of the base image, add our own configurations and variables to it, and then push the image back to the registry with a new and unique name. </span><span class="koboSpan" id="kobo.442.2">Now, other team members—or even you in a future project—can pull this new image at will and leverage the preset environment as needed. </span><span class="koboSpan" id="kobo.442.3">For this exercise, we need to have an account on Docker Hub.</span></p>
<p><span class="koboSpan" id="kobo.443.1">Let us use an example of a SQL Server image. </span><span class="koboSpan" id="kobo.443.2">If we needed to create an image that has a default database as a starting point, then we could do this in a few steps. </span><span class="koboSpan" id="kobo.443.3">First, we pull the base image from Docker Hub with this command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.444.1">
docker pull mcr.microsoft.com/mssql/server</span></pre>
<p><span class="koboSpan" id="kobo.445.1">SQL Server images tend to be large, so this may take a while to download. </span><span class="koboSpan" id="kobo.445.2">Once downloaded, however, we can execute this command to run the container:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.446.1">
docker run -e "ACCEPT_EULA=Y" -e
  "MSSQL_SA_PASSWORD=AStrongP@ssword1" -p 1434:1433 -d
    mcr.microsoft.com/mssql/server</span></pre>
<p><span class="koboSpan" id="kobo.447.1">The first command is like what we have seen before, where we pull the image to our local machine. </span><span class="koboSpan" id="kobo.447.2">We then run the image and create an instance of SQL Server based on the latest</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.448.1"> image</span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.449.1"> version and make it available through port </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">1434</span></strong><span class="koboSpan" id="kobo.451.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">1433</span></strong><span class="koboSpan" id="kobo.453.1"> is the default port for SQL Server, so we can use a different port to avoid conflicts with other SQL instances that might be present. </span><span class="koboSpan" id="kobo.453.2">We also set default </span><em class="italic"><span class="koboSpan" id="kobo.454.1">sa</span></em><span class="koboSpan" id="kobo.455.1"> user credentials and accept the terms of use agreements.</span></p>
<p><span class="koboSpan" id="kobo.456.1">Now that we have the instance of SQL Server up and running from our image, we can connect using</span><a id="_idIndexMarker712"/> <strong class="bold"><span class="koboSpan" id="kobo.457.1">SQL Server Management Studio</span></strong><span class="koboSpan" id="kobo.458.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.459.1">SSMS</span></strong><span class="koboSpan" id="kobo.460.1">) or Microsoft Azure Studio and then run a script. </span><span class="koboSpan" id="kobo.460.2">We will keep it simple and create a database and a table:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.461.1">
CREATE DATABASE PatientsDb
GO
USE PatientsDb
CREATE TABLE Patients(
    Id int primary key identity,
    FirstName varchar(50),
    LastName varchar(50),
    DateofBirth datetime
)</span></pre>
<p><span class="koboSpan" id="kobo.462.1">Now that we have the updated database, let us commit the updated image to a registry. </span><span class="koboSpan" id="kobo.462.2">We can use the Docker UI to see the name of the running container for SQL Server or use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">docker ps</span></strong><span class="koboSpan" id="kobo.464.1"> command, which will list all the running containers. </span><span class="koboSpan" id="kobo.464.2">We then run this </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">docker commit</span></strong><span class="koboSpan" id="kobo.466.1"> command using the name of the running SQL Server container:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.467.1">
docker commit -m "Added Patients Database" -a "Your Name"
  adoring_boyd Username/NewImageName:latest</span></pre>
<p><span class="koboSpan" id="kobo.468.1">This creates a local copy of the image based on the current state of the container. </span><span class="koboSpan" id="kobo.468.2">We add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">commit</span></strong><span class="koboSpan" id="kobo.470.1"> message so that we can keep track of the change that was made and also add an author tag, state the name of the container on which we need to base the image, and then add our Docker Hub username and the new image’s name. </span><span class="koboSpan" id="kobo.470.2">Now, we can use the Docker UI and click the </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">Images</span></strong><span class="koboSpan" id="kobo.472.1"> option and see our new image created and ready for usage for future projects. </span><span class="koboSpan" id="kobo.472.2">We can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">docker images</span></strong><span class="koboSpan" id="kobo.474.1"> command to list all the images that are currently on the system. </span><span class="koboSpan" id="kobo.474.2">You will now see the original SQL Server image as </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.475.1">well </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.476.1">as our recently committed image.</span></p>
<p><span class="koboSpan" id="kobo.477.1">Now, we have successfully published our own image to our own local registry. </span><span class="koboSpan" id="kobo.477.2">If we want to make this image accessible on Docker Hub, we need to use the </span><strong class="bold"><span class="koboSpan" id="kobo.478.1">Push to Hub</span></strong><span class="koboSpan" id="kobo.479.1"> option that is available to us in the Docker UI. </span><span class="koboSpan" id="kobo.479.2">Alternatively, we can run the following command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.480.1">
docker push Username/NewImageName</span></pre>
<p><span class="koboSpan" id="kobo.481.1">Going forward, if we needed to add this database image to our orchestration, we could modify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.483.1"> file like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
  patients_sql_db:
    image: Username/NewImageName
    restart: always
    ports:
      1434:1433</span></pre>
<p><span class="koboSpan" id="kobo.485.1">Now, we will always launch a SQL Server instance with this base database.</span></p>
<p><span class="koboSpan" id="kobo.486.1">We have not only containerized our application, but we have configured orchestration and created</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.487.1"> our</span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.488.1"> very own custom image. </span><span class="koboSpan" id="kobo.488.2">Let us review all that we have learned in this chapter.</span></p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.489.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.490.1">In this chapter, we have reviewed the pros and cons of containerization. </span><span class="koboSpan" id="kobo.490.2">We saw where containers help us to downsize some of the resource requirements that our applications have and created a portable version of these applications for development and deployment use.</span></p>
<p><span class="koboSpan" id="kobo.491.1">Docker is an industry-leading containerization software that has a growing community of contributors. </span><span class="koboSpan" id="kobo.491.2">Docker can be installed on a machine and then used to manage images and containers as needed. </span><span class="koboSpan" id="kobo.491.3">We will also have access to Docker Hub, which is a popular repository for publicly accessible images.</span></p>
<p><span class="koboSpan" id="kobo.492.1">When we integrate Docker into our ASP.NET Core application, we open a new dimension to what it means to build and host our own applications. </span><span class="koboSpan" id="kobo.492.2">We can now guarantee that our services will behave in a more consistent manner regardless of the machine they are deployed on. </span><span class="koboSpan" id="kobo.492.3">This is because we will have created containers to host our services, and these containers will be optimized to the needs of the service and will never change unless we adjust their definitions.</span></p>
<p><span class="koboSpan" id="kobo.493.1">We also looked at container orchestration, which is where we can outline the containers that we need in one setting and launch them at once, or in a particular order according to the dependencies. </span><span class="koboSpan" id="kobo.493.2">This is perfect for our microservices application, which comprises several services and dependencies and would be tedious to launch individually.</span></p>
<p><span class="koboSpan" id="kobo.494.1">Finally, we reviewed how to create our own image and host it on a local container registry. </span><span class="koboSpan" id="kobo.494.2">We could then publish the custom image to a public registry, Docker Hub, and have it accessible to all. </span><span class="koboSpan" id="kobo.494.3">Now, we can create specific containers with versions of our applications that we need to share with our teams, and we can better control the container versions that are distributed and used.</span></p>
<p><span class="koboSpan" id="kobo.495.1">In the next chapter, we will review a major cross-cutting concern in application development, which is log aggregation in microservices.</span></p>
</div>
</body></html>