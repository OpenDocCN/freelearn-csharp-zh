<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Patterns - Dependency Injection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In </span><a href="d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml" target="_blank"><span class="koboSpan" id="kobo.3.1">Chapter 7</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">Interception</span></em><span class="koboSpan" id="kobo.6.1">, we completed our journey in exploring the pillars of </span><strong><span class="koboSpan" id="kobo.7.1">Dependency Injection</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong><span class="koboSpan" id="kobo.9.1">DI</span></strong><span class="koboSpan" id="kobo.10.1">). </span><span class="koboSpan" id="kobo.10.2">Now, it's time to learn the principles behind Dependency Injection and explore how to apply different techniques to implement those principles to acquire a loosely coupled architecture. </span><span class="koboSpan" id="kobo.10.3">There are different techniques to implement DI, but if you are not choosing an appropriate one while you code, you will become a troublemaker for the project.</span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will discuss different techniques, also known as </span><strong><span class="koboSpan" id="kobo.12.1">Patterns of Dependency Injection</span></strong><span class="koboSpan" id="kobo.13.1"> with proper illustrations. </span><span class="koboSpan" id="kobo.13.2">I will shed light on use cases, and pros and the cons so that it will be easy for you to visualize the problems which you currently see in your application. </span><span class="koboSpan" id="kobo.13.3">That will eventually persuade you to adapt to these patterns in your app resulting in a better architecture.</span></p>
<p><span class="koboSpan" id="kobo.14.1">Constructor Injection is the most important one among all these patterns. </span><span class="koboSpan" id="kobo.14.2">However, as developers, we should understand every available pattern. </span><span class="koboSpan" id="kobo.14.3">It's always recommended to use the best fit pattern for a particular scenario by analyzing the frequency and cases of using the dependency.</span></p>
<p><span class="koboSpan" id="kobo.15.1">While most of these patterns address some specific context, always remember Constructor Injection is the simplest and can be opted without any confusion.</span></p>
<p><span class="koboSpan" id="kobo.16.1">The following topics would be covered in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Dependency Inversion Principle</span></li>
<li><span class="koboSpan" id="kobo.18.1">Inversion of Control</span></li>
<li><span class="koboSpan" id="kobo.19.1">DI patterns</span></li>
<li><span class="koboSpan" id="kobo.20.1">The proper way to implement patterns</span></li>
<li><span class="koboSpan" id="kobo.21.1">The pros and cons of each pattern</span></li>
<li><span class="koboSpan" id="kobo.22.1">Adoption and examples in .NET Core 2.0</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dependency Inversion Principle</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The SOLID principles have a D in it, which is called the </span><strong><span class="koboSpan" id="kobo.3.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">DIP</span></strong><span class="koboSpan" id="kobo.6.1">). </span><span class="koboSpan" id="kobo.6.2">The following statement is by Robert C. </span><span class="koboSpan" id="kobo.6.3">Martin on DIP:</span></p>
<div class="packt_quote"><span class="koboSpan" id="kobo.7.1">"High-level modules should not depend on low-level modules. </span><span class="koboSpan" id="kobo.7.2">Both should depend on abstractions."</span></div>
<p><span class="koboSpan" id="kobo.8.1">You can consider a High-level Module as a Business Module of one application comprising the complex logic of the application, and a Low-level Module as the classes that actually perform the basic or primary functions such as writing to disks, interaction with the database, and so on, with the commands received from the Business Module.</span></p>
<p><span class="koboSpan" id="kobo.9.1">When objects of a High-level Module interact with objects of a Low-level Module, they generate a coupling. </span><span class="koboSpan" id="kobo.9.2">This happens because you have to refer to the classes of Low-level Modules in order to access them for instantiation. </span><span class="koboSpan" id="kobo.9.3">However, the DIP does not recommend this. </span><span class="koboSpan" id="kobo.9.4">The principle encourages us to reduce the coupling so that the modules live isolated. </span><span class="koboSpan" id="kobo.9.5">It also explains how this can be done through abstractions. </span><span class="koboSpan" id="kobo.9.6">Both should commit themselves to abstractions instead of directly depending on each other. </span><span class="koboSpan" id="kobo.9.7">Let's understand this point with an example.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Consider one class called </span><kbd><span class="koboSpan" id="kobo.11.1">FeedbackService</span></kbd><span class="koboSpan" id="kobo.12.1"> that is saving one </span><kbd><span class="koboSpan" id="kobo.13.1">Feedback</span></kbd><span class="koboSpan" id="kobo.14.1"> details in the database:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">    public class FeedbackService : IFeedbackService</span><br/><span class="koboSpan" id="kobo.16.1">    {</span><br/><span class="koboSpan" id="kobo.17.1">      private INotifier notifier;</span><br/><strong><span class="koboSpan" id="kobo.18.1">      public void SaveFeedback(Feedback feedback, NotifyType notify)</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">      {</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">        SaveFeedbackToDb(feedback);</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">        SendNotification(feedback, notify);</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">      }</span></strong><br/><span class="koboSpan" id="kobo.23.1">      private void SendNotification(Feedback feedback, NotifyType notify)</span><br/><span class="koboSpan" id="kobo.24.1">      {</span><br/><span class="koboSpan" id="kobo.25.1">        if (notify == NotifyType.Email)</span><br/><span class="koboSpan" id="kobo.26.1">        {</span><br/><span class="koboSpan" id="kobo.27.1">            notifier = </span><strong><span class="koboSpan" id="kobo.28.1">new EmailNotifier();</span></strong><br/><span class="koboSpan" id="kobo.29.1">        }</span><br/><span class="koboSpan" id="kobo.30.1">        else if (notify == NotifyType.Sms)</span><br/><span class="koboSpan" id="kobo.31.1">        {</span><br/><span class="koboSpan" id="kobo.32.1">            notifier = </span><strong><span class="koboSpan" id="kobo.33.1">new SmsNotifier();</span></strong><br/><span class="koboSpan" id="kobo.34.1">        }</span><br/><span class="koboSpan" id="kobo.35.1">        else if (notify == NotifyType.Voice)</span><br/><span class="koboSpan" id="kobo.36.1">        {</span><br/><span class="koboSpan" id="kobo.37.1">            notifier = </span><strong><span class="koboSpan" id="kobo.38.1">new VoiceNotifier();</span></strong><br/><span class="koboSpan" id="kobo.39.1">        }</span><br/><span class="koboSpan" id="kobo.40.1">        else</span><br/><span class="koboSpan" id="kobo.41.1">        {</span><br/><span class="koboSpan" id="kobo.42.1">            throw new ArgumentException("No matched notify type </span><br/><span class="koboSpan" id="kobo.43.1">              found.", notify.ToString());</span><br/><span class="koboSpan" id="kobo.44.1">        }</span><br/><span class="koboSpan" id="kobo.45.1">        notifier.SendNotification(feedback);</span><br/><span class="koboSpan" id="kobo.46.1">      }</span><br/><span class="koboSpan" id="kobo.47.1">      private int SaveFeedbackToDb(Feedback feedback)</span><br/><span class="koboSpan" id="kobo.48.1">      {</span><br/><span class="koboSpan" id="kobo.49.1">        // Save details in db.</span><br/><span class="koboSpan" id="kobo.50.1">        Console.WriteLine("Db Saving Started.");</span><br/><span class="koboSpan" id="kobo.51.1">        return 1;</span><br/><span class="koboSpan" id="kobo.52.1">      }</span><br/><span class="koboSpan" id="kobo.53.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.54.1">The principal method here is </span><kbd><span class="koboSpan" id="kobo.55.1">SaveFeedback</span></kbd><span class="koboSpan" id="kobo.56.1">, which not only saves the feedback but also sends a notification. </span><span class="koboSpan" id="kobo.56.2">It takes the </span><kbd><span class="koboSpan" id="kobo.57.1">Feedback</span></kbd><span class="koboSpan" id="kobo.58.1"> object and notifies type as parameters. </span><span class="koboSpan" id="kobo.58.2">When feedback is saved, usually one notification is sent to the customer and admin.</span></p>
<p><kbd><span class="koboSpan" id="kobo.59.1">FeedbackService</span></kbd><span class="koboSpan" id="kobo.60.1"> implements an interface which can be coded like the following:</span></p>
<pre><span class="koboSpan" id="kobo.61.1">    public interface IFeedbackService</span><br/><span class="koboSpan" id="kobo.62.1">    {</span><br/><span class="koboSpan" id="kobo.63.1">      void SaveFeedback(Feedback feedback, NotifyType notify);</span><br/><span class="koboSpan" id="kobo.64.1">    }</span></pre>
<p><kbd><span class="koboSpan" id="kobo.65.1">INotifier</span></kbd><span class="koboSpan" id="kobo.66.1"> is an interface which is implemented by all the notifier types. </span><span class="koboSpan" id="kobo.66.2">Have a look at the following code:</span></p>
<pre><span class="koboSpan" id="kobo.67.1">    public interface INotifier</span><br/><span class="koboSpan" id="kobo.68.1">    {</span><br/><span class="koboSpan" id="kobo.69.1">      void SendNotification(Feedback feedback);</span><br/><span class="koboSpan" id="kobo.70.1">    }</span><br/><span class="koboSpan" id="kobo.71.1">    public class EmailNotifier : INotifier</span><br/><span class="koboSpan" id="kobo.72.1">    {</span><br/><span class="koboSpan" id="kobo.73.1">      public void SendNotification(Feedback feedback)</span><br/><span class="koboSpan" id="kobo.74.1">      {</span><br/><span class="koboSpan" id="kobo.75.1">        Console.WriteLine("Email Notification starts!");</span><br/><span class="koboSpan" id="kobo.76.1">      }</span><br/><span class="koboSpan" id="kobo.77.1">    }</span><br/><span class="koboSpan" id="kobo.78.1">    public class SmsNotifier : INotifier</span><br/><span class="koboSpan" id="kobo.79.1">    {</span><br/><span class="koboSpan" id="kobo.80.1">      public void SendNotification(Feedback feedback)</span><br/><span class="koboSpan" id="kobo.81.1">      {</span><br/><span class="koboSpan" id="kobo.82.1">        Console.WriteLine("Sms Notification starts!");</span><br/><span class="koboSpan" id="kobo.83.1">      }</span><br/><span class="koboSpan" id="kobo.84.1">    }</span><br/><span class="koboSpan" id="kobo.85.1">    public class VoiceNotifier : INotifier</span><br/><span class="koboSpan" id="kobo.86.1">    {</span><br/><span class="koboSpan" id="kobo.87.1">      public void SendNotification(Feedback feedback)</span><br/><span class="koboSpan" id="kobo.88.1">      {</span><br/><span class="koboSpan" id="kobo.89.1">        Console.WriteLine("Voice Notification starts!");</span><br/><span class="koboSpan" id="kobo.90.1">      }</span><br/><span class="koboSpan" id="kobo.91.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.92.1">Note that I have not defined the body of the methods since </span><span><span class="koboSpan" id="kobo.93.1">they are here in the book for illustration. </span><span class="koboSpan" id="kobo.93.2">You can write logic and implement yours.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Problems</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The approach seems correct, but it is not recommended and does not respect software design principles which are described as follows:</span></p>
<p><span class="koboSpan" id="kobo.3.1">Clearly, we are violating the Single Responsibility Principle with this approach. </span><kbd><span class="koboSpan" id="kobo.4.1">FeedbackService</span></kbd><span class="koboSpan" id="kobo.5.1"> is taking the responsibility to save a feedback as well as sending notifications after success.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Tight coupling exists with the concrete classes </span><kbd><span class="koboSpan" id="kobo.7.1">Feedback</span></kbd><span class="koboSpan" id="kobo.8.1"> and other </span><kbd><span class="koboSpan" id="kobo.9.1">Notifier</span></kbd><span class="koboSpan" id="kobo.10.1"> classes such as </span><kbd><span class="koboSpan" id="kobo.11.1">EmailNotifier</span></kbd><span class="koboSpan" id="kobo.12.1">, </span><kbd><span class="koboSpan" id="kobo.13.1">SmsNotifier</span></kbd><span class="koboSpan" id="kobo.14.1">, and </span><kbd><span class="koboSpan" id="kobo.15.1">VoiceNotifier</span></kbd><span class="koboSpan" id="kobo.16.1">.</span></p>
<p><span class="koboSpan" id="kobo.17.1">Our most popular, the </span><kbd><span class="koboSpan" id="kobo.18.1">new</span></kbd><span class="koboSpan" id="kobo.19.1"> keyword is used inside the </span><kbd><span class="koboSpan" id="kobo.20.1">SendNotification</span></kbd><span class="koboSpan" id="kobo.21.1"> of the </span><kbd><span class="koboSpan" id="kobo.22.1">FeedbackService</span></kbd><span class="koboSpan" id="kobo.23.1"> class to decide which </span><kbd><span class="koboSpan" id="kobo.24.1">Notifier</span></kbd><span class="koboSpan" id="kobo.25.1"> instance to create according to the input </span><kbd><span class="koboSpan" id="kobo.26.1">notify</span></kbd><span class="koboSpan" id="kobo.27.1"> of type </span><kbd><span class="koboSpan" id="kobo.28.1">enum</span></kbd><span class="koboSpan" id="kobo.29.1">, which can be defined as follows:</span></p>
<pre><span class="koboSpan" id="kobo.30.1">    public enum NotifyType</span><br/><span class="koboSpan" id="kobo.31.1">    {</span><br/><span class="koboSpan" id="kobo.32.1">      Email = 1,</span><br/><span class="koboSpan" id="kobo.33.1">      Sms = 2,</span><br/><span class="koboSpan" id="kobo.34.1">      Voice = 3</span><br/><span class="koboSpan" id="kobo.35.1">    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Solution</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The solution should address all the issues with the preceding approach, so that the resulting architecture becomes loosely coupled. </span><span class="koboSpan" id="kobo.2.2">Let's get started.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.3.1">The first thing is to separate the responsibilities from the </span><kbd><span class="koboSpan" id="kobo.4.1">FeedbackService</span></kbd><span class="koboSpan" id="kobo.5.1"> class. </span><span class="koboSpan" id="kobo.5.2">This can be easily be done by transferring the </span><kbd><span class="koboSpan" id="kobo.6.1">SendNotification</span></kbd><span class="koboSpan" id="kobo.7.1"> responsibility to the notifier instead of having it inside the class.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.8.1">So, we can inject the </span><kbd><span class="koboSpan" id="kobo.9.1">INotifier</span></kbd><span class="koboSpan" id="kobo.10.1"> type dependency inside the constructor. </span><span class="koboSpan" id="kobo.10.2">Thus, we can do </span><kbd><span class="koboSpan" id="kobo.11.1">_notifier.SendNotification()</span></kbd><span class="koboSpan" id="kobo.12.1"> to send an injected type notification. </span><span class="koboSpan" id="kobo.12.2">Also, we changed the signature of </span><kbd><span class="koboSpan" id="kobo.13.1">SaveFeedback</span></kbd><span class="koboSpan" id="kobo.14.1">, which now accepts the </span><kbd><span class="koboSpan" id="kobo.15.1">IFeedback</span></kbd><span class="koboSpan" id="kobo.16.1"> type parameter.</span></p>
<p class="mce-root"><kbd><span class="koboSpan" id="kobo.17.1">FeedbackService</span></kbd><span class="koboSpan" id="kobo.18.1"> can be rewritten as follows:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">    public class FeedbackService : IFeedbackService</span><br/><span class="koboSpan" id="kobo.20.1">    {</span><br/><span class="koboSpan" id="kobo.21.1">      private readonly INotifier _notifier;</span><br/><span class="koboSpan" id="kobo.22.1">      public FeedbackService(</span><strong><span class="koboSpan" id="kobo.23.1">INotifier notifier</span></strong><span class="koboSpan" id="kobo.24.1">)</span><br/><span class="koboSpan" id="kobo.25.1">      {</span><br/><span class="koboSpan" id="kobo.26.1">        _notifier = notifier;</span><br/><span class="koboSpan" id="kobo.27.1">      }</span><br/><br/><span class="koboSpan" id="kobo.28.1">      public void SaveFeedback(</span><strong><span class="koboSpan" id="kobo.29.1">IFeedback feedback</span></strong><span class="koboSpan" id="kobo.30.1">)</span><br/><span class="koboSpan" id="kobo.31.1">      {</span><br/><span class="koboSpan" id="kobo.32.1">        SaveFeedbackToDb(feedback);</span><br/><br/><span class="koboSpan" id="kobo.33.1">        _notifier.SendNotification(feedback);</span><br/><span class="koboSpan" id="kobo.34.1">      }</span><br/><span class="koboSpan" id="kobo.35.1">      private int SaveFeedbackToDb(IFeedback feedback)</span><br/><span class="koboSpan" id="kobo.36.1">      {</span><br/><span class="koboSpan" id="kobo.37.1">        throw new NotImplementedException();</span><br/><span class="koboSpan" id="kobo.38.1">      }</span><br/><span class="koboSpan" id="kobo.39.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.40.1">Now the </span><kbd><span class="koboSpan" id="kobo.41.1">Service</span></kbd><span class="koboSpan" id="kobo.42.1"> does not depend upon the concrete implementations, and we eliminated the </span><kbd><span class="koboSpan" id="kobo.43.1">if...else...if</span></kbd><span class="koboSpan" id="kobo.44.1"> clumsy codes from the class to decide which notification to send. </span><span class="koboSpan" id="kobo.44.2">The decision of notification type is now with the composer of the </span><kbd><span class="koboSpan" id="kobo.45.1">Service</span></kbd><span class="koboSpan" id="kobo.46.1"> class instance. </span><span class="koboSpan" id="kobo.46.2">That can be done inside the Composition Root, something like the following:</span></p>
<pre><span class="koboSpan" id="kobo.47.1">    var feedbackService = new FeedbackService(new SmsNotifier());</span><br/><span class="koboSpan" id="kobo.48.1">    feedbackService.SaveFeedback(new Feedback());</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Inversion of Control (IoC)</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">Inversion of Control</span></strong><span class="koboSpan" id="kobo.3.1"> (</span><strong><span class="koboSpan" id="kobo.4.1">IoC</span></strong><span class="koboSpan" id="kobo.5.1">) is a Software Design Pattern which supports the </span><strong><span class="koboSpan" id="kobo.6.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong><span class="koboSpan" id="kobo.8.1">DIP</span></strong><span class="koboSpan" id="kobo.9.1">). </span><span class="koboSpan" id="kobo.9.2">There is a lot of confusion between these two terms, but if you closely observe, the names will clarify the doubts themselves.</span></p>
<p><span class="koboSpan" id="kobo.10.1">The DIP is a principle or set of rules kind of theory. </span><span class="koboSpan" id="kobo.10.2">On the other hand, Inversion of Control is a pattern of well-defined steps we can follow to make our code DIP friendly. </span><span class="koboSpan" id="kobo.10.3">You have already experienced the steps of IoC, haven't you? </span></p>
<p><span class="koboSpan" id="kobo.11.1">Notice the steps we followed to take away the control of object creations from the </span><kbd><span class="koboSpan" id="kobo.12.1">FeedbackService</span></kbd><span class="koboSpan" id="kobo.13.1"> class to an external location, which can be considered as a Composition Root. </span><span class="koboSpan" id="kobo.13.2">We did the following to be precise:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.14.1">Introduce interfaces for the concrete dependency: </span><kbd><span class="koboSpan" id="kobo.15.1">INotifier</span></kbd><span class="koboSpan" id="kobo.16.1"> and </span><kbd><span class="koboSpan" id="kobo.17.1">IFeedback</span></kbd><span class="koboSpan" id="kobo.18.1">.</span></li>
<li><span class="koboSpan" id="kobo.19.1">Update concrete dependencies to implement from interface: </span><kbd><span class="koboSpan" id="kobo.20.1">EmailNotifier</span></kbd><span class="koboSpan" id="kobo.21.1">, </span><kbd><span class="koboSpan" id="kobo.22.1">SmsNotifier</span></kbd><span class="koboSpan" id="kobo.23.1">, and </span><kbd><span class="koboSpan" id="kobo.24.1">VoiceNotifier</span></kbd><span class="koboSpan" id="kobo.25.1">.</span></li>
<li><span class="koboSpan" id="kobo.26.1">Provide dependency to the constructor and store in a </span><kbd><span class="koboSpan" id="kobo.27.1">private readonly </span></kbd><span class="koboSpan" id="kobo.28.1">member:</span></li>
</ol>
<pre><span class="koboSpan" id="kobo.29.1">        public FeedbackService(INotifier notifier)</span><br/><span class="koboSpan" id="kobo.30.1">        {</span><br/><span class="koboSpan" id="kobo.31.1">          _notifier = notifier;</span><br/><span class="koboSpan" id="kobo.32.1">        }</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.33.1">With the private member, we can call the method of the dependency class directly:  </span><kbd><span class="koboSpan" id="kobo.34.1">_notifier.SendNotification(feedback);</span></kbd><span class="koboSpan" id="kobo.35.1"> </span></li>
<li><span class="koboSpan" id="kobo.36.1">Instantiate </span><kbd><span class="koboSpan" id="kobo.37.1">Service</span></kbd><span class="koboSpan" id="kobo.38.1"> with dependency in the Composition Root:</span><br/>
<kbd><span class="koboSpan" id="kobo.39.1">var feedbackService = new FeedbackService(new SmsNotifier());</span></kbd><span class="koboSpan" id="kobo.40.1">.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.41.1">So, someone else is now trying to manage the object creation and lifetime. </span><span class="koboSpan" id="kobo.41.2">Before we executed those steps, the class itself was instantiating all its dependencies inside it using the </span><kbd><span class="koboSpan" id="kobo.42.1">new</span></kbd><span class="koboSpan" id="kobo.43.1"> keyword. </span><span class="koboSpan" id="kobo.43.2">Therefore, we inverted the controls, and flow of management of objects is done in reverse through someone else, isn't it! </span><span class="koboSpan" id="kobo.43.3">That's it, this is what IoC is trying to express.</span></p>
<p><span><span class="koboSpan" id="kobo.44.1">The last step involves injecting the dependency object into the constructor of </span><kbd><span class="koboSpan" id="kobo.45.1">Service</span></kbd><span class="koboSpan" id="kobo.46.1">, and the pattern is known a</span></span><span class="koboSpan" id="kobo.47.1">s the </span><strong><span class="koboSpan" id="kobo.48.1">Constructor Injection Pattern</span></strong><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">L</span><span><span class="koboSpan" id="kobo.50.1">et's explore this pattern with other important ones in the next section.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">The following is the diagram representing the DIP and non-DIP implementations. </span><span class="koboSpan" id="kobo.51.2">Notice the arrows. </span><span class="koboSpan" id="kobo.51.3">In non-DIP, dependencies are managed by the class itself so, arrows pointing to concrete class objects, whereas, in DIP, an arrow is coming into the class, as the dependency objects are sent by someone else:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.52.1"><img height="240" width="428" src="assets/c6784d17-712d-41e5-a556-ff8a8142d1a6.png"/></span></div>
<div class="packt_infobox"><span class="koboSpan" id="kobo.53.1">When a class manages all its dependencies itself, it is regarded as a </span><strong><span class="koboSpan" id="kobo.54.1">Control Freak</span></strong><span class="koboSpan" id="kobo.55.1">, which is an anti-pattern. </span><span class="koboSpan" id="kobo.55.2">We will discuss more about this anti-pattern in the next chapter.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Patterns</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">The following are the four important patterns by which we can implement Dependency Injection:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Constructor Injection Pattern</span></li>
<li><span class="koboSpan" id="kobo.4.1">Property Injection Pattern</span></li>
<li><span class="koboSpan" id="kobo.5.1">Method Injection Pattern</span></li>
<li><span class="koboSpan" id="kobo.6.1">Ambient Context</span></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">Let's explore one by one with illustrations, the advantages, and disadvantages.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Constructor Injection pattern</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As the name suggests, Injection will take the help of the constructor. </span><span class="koboSpan" id="kobo.2.2">In other words, the constructor is the target of injection. </span><span class="koboSpan" id="kobo.2.3">Injection is performed by supplying the dependency to the constructor as an argument. </span><span class="koboSpan" id="kobo.2.4">This is the most common technique to inject dependencies into classes.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The client calls the constructor to create the object and during the instantiation, the dependency gets injected, which is depicted as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1"><img height="176" width="276" src="assets/923d38e0-dcca-4797-a364-e90566508b8b.png"/></span></div>
<p><span class="koboSpan" id="kobo.5.1">For example, a company, initially, was set up with only one department called Engineering. </span><span class="koboSpan" id="kobo.5.2">Let's design the </span><kbd><span class="koboSpan" id="kobo.6.1">Employee</span></kbd><span class="koboSpan" id="kobo.7.1"> class for this company as follows:</span></p>
<pre><span class="koboSpan" id="kobo.8.1">    public class Employee
    {
        public int EmployeeId;
        public string EmployeeName;
        public Department EmployeeDept;

        public Employee(int id, string name)
        {
           EmployeeId = id;
           EmployeeName = name;
           EmployeeDept = new Engineering();
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.9.1">We have a constructor which takes </span><kbd><span class="koboSpan" id="kobo.10.1">id</span></kbd><span class="koboSpan" id="kobo.11.1"> and </span><kbd><span class="koboSpan" id="kobo.12.1">name</span></kbd><span class="koboSpan" id="kobo.13.1"> as parameters and initialises an </span><kbd><span class="koboSpan" id="kobo.14.1">Employee</span></kbd><span class="koboSpan" id="kobo.15.1"> object. </span><span class="koboSpan" id="kobo.15.2">As I told you, the company started only with Engineering as a department, so it's obvious that we assign </span><kbd><span class="koboSpan" id="kobo.16.1">EmployeeDept</span></kbd><span class="koboSpan" id="kobo.17.1"> with a new object of the </span><kbd><span class="koboSpan" id="kobo.18.1">Engineering</span></kbd><span class="koboSpan" id="kobo.19.1"> class. </span><kbd><span class="koboSpan" id="kobo.20.1">Engineering</span></kbd><span class="koboSpan" id="kobo.21.1"> and </span><kbd><span class="koboSpan" id="kobo.22.1">Department</span></kbd><span class="koboSpan" id="kobo.23.1"> classes would look something as follows:</span></p>
<pre><span class="koboSpan" id="kobo.24.1">    public class Department
    {
      public int DeptId { get; set; }
      public string DeptName { get; set; }
    }
    public class Engineering : Department {  }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The problem</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Can you foresee a complex issue in this design? </span><span class="koboSpan" id="kobo.2.2">What if the company grows and builds another department like marketing? </span><span class="koboSpan" id="kobo.2.3">How would we incorporate this new department into the </span><kbd><span class="koboSpan" id="kobo.3.1">Employee</span></kbd><span class="koboSpan" id="kobo.4.1"> class? </span><span class="koboSpan" id="kobo.4.2">How to say a particular employee belongs to the marketing department?</span></p>
<p><span class="koboSpan" id="kobo.5.1">Unfortunately, there is no way to do this here, as the </span><kbd><span class="koboSpan" id="kobo.6.1">Employee</span></kbd><span class="koboSpan" id="kobo.7.1"> class is tightly coupled with the </span><kbd><span class="koboSpan" id="kobo.8.1">Engineering</span></kbd><span class="koboSpan" id="kobo.9.1"> class. </span><span class="koboSpan" id="kobo.9.2">This not only leads to a bad design, but developers also face hurdles for unit testing.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The solution</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So, what is the solution? </span><span class="koboSpan" id="kobo.2.2">We just need a </span><kbd><span class="koboSpan" id="kobo.3.1">Department</span></kbd><span class="koboSpan" id="kobo.4.1"> object when we instantiate with </span><kbd><span class="koboSpan" id="kobo.5.1">Employee</span></kbd><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">How about providing the required type of </span><kbd><span class="koboSpan" id="kobo.7.1">Department</span></kbd><span class="koboSpan" id="kobo.8.1"> (engineering/marketing) reference directly to the </span><kbd><span class="koboSpan" id="kobo.9.1">Employee</span></kbd><span class="koboSpan" id="kobo.10.1"> class?</span></p>
<p><span class="koboSpan" id="kobo.11.1">That's super easy. </span><span class="koboSpan" id="kobo.11.2">Let's have a look at the modification.</span></p>
<ol>
<li><span class="koboSpan" id="kobo.12.1">First, design an interface </span><kbd><span class="koboSpan" id="kobo.13.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.14.1"> which can be implemented by the </span><kbd><span class="koboSpan" id="kobo.15.1">Department</span></kbd><span class="koboSpan" id="kobo.16.1"> class:</span></li>
</ol>
<pre><span class="koboSpan" id="kobo.17.1">        public interface IDepartment
        {
          int DeptId { get; set; }
          string DeptName { get; set; }
        }
        public class Department : IDepartment
        {
          public int DeptId { get; set; }
          public string DeptName { get; set; }
        }</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.18.1">Instead of having a property of </span><kbd><span class="koboSpan" id="kobo.19.1">Department</span></kbd><span class="koboSpan" id="kobo.20.1"> type, now we will have that of type </span><kbd><span class="koboSpan" id="kobo.21.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">Basically, we can now allow different types of departments with this technique. </span><span class="koboSpan" id="kobo.22.3">We will see this in action in a while. </span><span class="koboSpan" id="kobo.22.4">Also, see how this property is initialized inside the constructor using the param </span><kbd><span class="koboSpan" id="kobo.23.1">dept</span></kbd><span class="koboSpan" id="kobo.24.1"> of type </span><kbd><span class="koboSpan" id="kobo.25.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.26.1">.</span></li>
</ol>
<pre><span class="koboSpan" id="kobo.27.1">        public class Employee
        {
          public int EmployeeId;
          public string EmployeeName;
          public IDepartment EmployeeDept;

          public Employee(int id, string name, IDepartment dept)
          {
            EmployeeId = id;
            EmployeeName = name;
            EmployeeDept = dept;
          }
        }</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.28.1">Now have a look at the classes for different departments. </span><span class="koboSpan" id="kobo.28.2">They inherit from </span><kbd><span class="koboSpan" id="kobo.29.1">Department</span></kbd><span class="koboSpan" id="kobo.30.1">, thereby implementing </span><kbd><span class="koboSpan" id="kobo.31.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.32.1">:</span></li>
</ol>
<pre><span class="koboSpan" id="kobo.33.1">       public class Engineering : Department
       {
         public Engineering()
         {
           DeptName = "Engineering";
         }
       }
       public class Marketing: Department
       {
         public Marketing()
         {
            DeptName = "Marketing";
         }
       }</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.34.1">Creating employees with a different department is easy now. </span><span class="koboSpan" id="kobo.34.2">If we create such objects inside the </span><kbd><span class="koboSpan" id="kobo.35.1">main</span></kbd><span class="koboSpan" id="kobo.36.1"> method, we can do the following:</span></li>
</ol>
<pre><span class="koboSpan" id="kobo.37.1">        static void Main(string[] args)
        {
          var engineering = new Engineering();
          Employee emp = new Employee(1, "Sasmita Tripathy",</span><br/>            <strong><span class="koboSpan" id="kobo.38.1">new Engineering()</span></strong><span class="koboSpan" id="kobo.39.1">);
          var marketing = new Marketing();
          Employee emp1 = new Employee(2, "Ganeswar Tripathy",</span><br/>            <strong><span class="koboSpan" id="kobo.40.1">new Marketing()</span></strong><span class="koboSpan" id="kobo.41.1">);
          Console.WriteLine("Emp Name: " + emp.EmployeeName + ",</span><br/><span class="koboSpan" id="kobo.42.1">            Department: " + emp.EmployeeDept.DeptName);
          Console.WriteLine();
          Console.WriteLine("Emp Name: " + emp1.EmployeeName + ",</span><br/><span class="koboSpan" id="kobo.43.1">            Department: " + emp1.EmployeeDept.DeptName);
          Console.ReadLine();
        }</span></pre>
<p><span class="koboSpan" id="kobo.44.1">You can see how a particular </span><kbd><span class="koboSpan" id="kobo.45.1">Department</span></kbd><span class="koboSpan" id="kobo.46.1"> object is passed to the </span><kbd><span class="koboSpan" id="kobo.47.1">Employee</span></kbd><span class="koboSpan" id="kobo.48.1"> constructor to create different employees who belong to different departments. </span><span class="koboSpan" id="kobo.48.2">That is the injection we did. </span><span class="koboSpan" id="kobo.48.3">We injected objects of type </span><kbd><span class="koboSpan" id="kobo.49.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.50.1"> (</span><kbd><span class="koboSpan" id="kobo.51.1">Engineering</span></kbd><span class="koboSpan" id="kobo.52.1"> and </span><kbd><span class="koboSpan" id="kobo.53.1">Marketing</span></kbd><span class="koboSpan" id="kobo.54.1">) into the </span><kbd><span class="koboSpan" id="kobo.55.1">Employee</span></kbd><span class="koboSpan" id="kobo.56.1"> constructor.</span></p>
<p><span class="koboSpan" id="kobo.57.1">The following is the output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.58.1"><img height="138" width="529" src="assets/192956cf-7f83-4a52-95ee-0a24461d5e0d.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Curveball</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You must be thinking everything in the preceding was perfect. </span><span class="koboSpan" id="kobo.2.2">But it is not. </span><span class="koboSpan" id="kobo.2.3">Let's analyze it:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">     var engineering = new Engineering();
     Employee emp = new Employee(1, "Sasmita Tripathy", </span><br/><span class="koboSpan" id="kobo.4.1">       new Engineering());
     emp.EmployeeDept = new Marketing();</span></pre>
<p><span class="koboSpan" id="kobo.5.1">You can see I created an object with employee department as </span><kbd><span class="koboSpan" id="kobo.6.1">Engineering</span></kbd><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">Then in the next line, we can easily change the department by assigning a </span><kbd><span class="koboSpan" id="kobo.8.1">Marketing</span></kbd><span class="koboSpan" id="kobo.9.1"> object to it. </span><span class="koboSpan" id="kobo.9.2">This should be completely avoided.</span></p>
<p><span class="koboSpan" id="kobo.10.1">To do that, the field must be marked as </span><kbd><span class="koboSpan" id="kobo.11.1">private</span></kbd><span class="koboSpan" id="kobo.12.1"> and </span><kbd><span class="koboSpan" id="kobo.13.1">readonly</span></kbd><span class="koboSpan" id="kobo.14.1">.</span></p>
<pre><span class="koboSpan" id="kobo.15.1">    private readonly IDepartment EmployeeDept;</span></pre>
<p><span class="koboSpan" id="kobo.16.1">It's not strictly recommended, but we should definitely follow this so that developers can't unnecessary hijack the actual values.</span></p>
<p><span class="koboSpan" id="kobo.17.1">Secondly, the constructor does not handle the case where the dependent instance is received as </span><kbd><span class="koboSpan" id="kobo.18.1">null</span></kbd><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">The constructor can be altered as follows:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">    public Employee(int id, string name, IDepartment dept)
    {   
        EmployeeDept = dept ?? </span><span class="koboSpan" id="kobo.20.2">throw new ArgumentNullException();
        EmployeeId = id;
        EmployeeName = name;
   }</span></pre>
<p><span class="koboSpan" id="kobo.21.1">Now here is the important thing, the constructor not only does the job of pushing the dependent instance to a </span><kbd><span class="koboSpan" id="kobo.22.1">private</span></kbd><span class="koboSpan" id="kobo.23.1"> property, but also inserts values to other member variables such as </span><kbd><span class="koboSpan" id="kobo.24.1">EmployeeId</span></kbd><span class="koboSpan" id="kobo.25.1"> and </span><kbd><span class="koboSpan" id="kobo.26.1">EmployeeName</span></kbd><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">This is against the Single Responsibility Principle. </span><span class="koboSpan" id="kobo.27.3">Therefore, we should have the constructor only handling the dependency thing and nothing else:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">    public Employee(IDepartment dept)
    {   
        EmployeeDept = dept ?? </span><span class="koboSpan" id="kobo.28.2">throw new ArgumentNullException();
    }</span></pre>
<p><span class="koboSpan" id="kobo.29.1">Also, writing like this would guarantee that when an object is created, it will contain the dependency within it. </span><span class="koboSpan" id="kobo.29.2">At the same time, this will be valued only if the class is fully dependent on the dependency henceforth.</span></p>
<p><span class="koboSpan" id="kobo.30.1">Let me summarise the points quickly as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.31.1">The class which is dependent must expose a </span><kbd><span class="koboSpan" id="kobo.32.1">public</span></kbd><span class="koboSpan" id="kobo.33.1"> constructor where the dependency can be injected</span></li>
<li><span class="koboSpan" id="kobo.34.1">If more than one dependency is required, then we can add more arguments to the constructor</span></li>
<li><span class="koboSpan" id="kobo.35.1">The dependent class should mark the member variable as </span><kbd><span class="koboSpan" id="kobo.36.1">private readonly</span></kbd><span class="koboSpan" id="kobo.37.1"> where dependency instance will be assigned</span></li>
<li><span class="koboSpan" id="kobo.38.1">The dependent class constructor should only do the job of managing the dependency and nothing else</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Injecting with .NET Core 2.0</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We saw every example previously, where we initialised using the </span><kbd><span class="koboSpan" id="kobo.3.1">new</span></kbd><span class="koboSpan" id="kobo.4.1"> keyword. </span><span class="koboSpan" id="kobo.4.2">However, we should use the .NET Core 2.0 way of resolving the dependency:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    static void Main(string[] args)
    {
       var serviceProvider = new ServiceCollection()
       .AddTransient&lt;IDepartment, Engineering&gt;()
       .AddTransient&lt;Employee&gt;()
       .BuildServiceProvider();

       var emp = serviceProvider.GetService&lt;Employee&gt;();
       emp.EmployeeId = 1;
       emp.EmployeeName = "Sasmita Tripathy";

       var emp1 = serviceProvider.GetService&lt;Employee&gt;();
       emp1.EmployeeId = 2;
       emp1.EmployeeName = "Ganeswar Tripathy";
        
       Console.WriteLine("Emp Name: " + emp.EmployeeName + ",</span><br/><span class="koboSpan" id="kobo.6.1">          Department: " + emp.GetEmployeeDepartment());
       Console.WriteLine();
       Console.WriteLine("Emp Name: " + emp1.EmployeeName + ",</span><br/><span class="koboSpan" id="kobo.7.1">          Department: " + emp1.GetEmployeeDepartment());

        Console.ReadLine();
}</span></pre>
<p><span class="koboSpan" id="kobo.8.1">We use the </span><kbd><span class="koboSpan" id="kobo.9.1">ServiceCollection</span></kbd><span class="koboSpan" id="kobo.10.1"> object to register the interfaces with the type we expect when it is resolved. </span><span class="koboSpan" id="kobo.10.2">When we do </span><kbd><span class="koboSpan" id="kobo.11.1">serviceProvider.GetService();</span></kbd><span class="koboSpan" id="kobo.12.1">, it returns an employee object with the department as </span><kbd><span class="koboSpan" id="kobo.13.1">Engineering</span></kbd><span class="koboSpan" id="kobo.14.1"> since we registered </span><kbd><span class="koboSpan" id="kobo.15.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.16.1"> as </span><kbd><span class="koboSpan" id="kobo.17.1">Engineering</span></kbd><span class="koboSpan" id="kobo.18.1"> in the collection.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Implementation inside ASP.NET Core 2.0</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's have a closer look at ASP.NET Core 2.0 internal codes for </span><kbd><span class="koboSpan" id="kobo.3.1">ControllerActivatorProvider.cs</span></kbd><span class="koboSpan" id="kobo.4.1"> inside </span><kbd><span class="koboSpan" id="kobo.5.1">Microsoft.AspNetCore.Mvc.Core</span></kbd> <kbd><span class="koboSpan" id="kobo.6.1">Controllers</span></kbd><span class="koboSpan" id="kobo.7.1"> to understand how Constructor Injection is implemented.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">ControllerActivatorProvider.cs</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">I will show a screenshot of the class where the constructor is written:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="419" width="557" src="assets/91b877ef-c090-4344-a6c7-592199f1c23f.png"/></span></div>
<p class="mce-root"><kbd><span class="koboSpan" id="kobo.4.1">IControllerActivator</span></kbd><span class="koboSpan" id="kobo.5.1"> is the dependency which is injected into the constructor of this class. </span><span class="koboSpan" id="kobo.5.2">Then, it is using the instance to do some operation inside the class. </span><span class="koboSpan" id="kobo.5.3">We can easily find more of such kind of examples in .NET Core 2.0.</span></p>
<p><span class="koboSpan" id="kobo.6.1">To see how this dependency is resolved, we can check the method </span><kbd><span><span class="koboSpan" id="kobo.7.1">AddMvcCoreServices</span></span></kbd><span class="koboSpan" id="kobo.8.1"> of the </span><kbd><span class="koboSpan" id="kobo.9.1">MvcCoreServiceCollectionExtensions.cs</span></kbd><span class="koboSpan" id="kobo.10.1"> class inside the </span><kbd><span class="koboSpan" id="kobo.11.1">Microsoft.AspNetCore.Mvc.Core</span></kbd> <kbd><span class="koboSpan" id="kobo.12.1">DependencyInjection</span></kbd><span class="koboSpan" id="kobo.13.1">:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img height="207" width="607" src="assets/84f0c2b9-30ec-40f1-8bbc-5edd42b9bdd4.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Importance of the Constructor Injection pattern</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As the injection is tied to the constructor, this means whenever you try to instantiate a particular class, we are 100% sure that the dependency is shipped or tied with the object created. </span><span class="koboSpan" id="kobo.2.2">The guarantee of having the dependency is ensured by the Guard Clause, which verifies the dependency as not </span><kbd><span class="koboSpan" id="kobo.3.1">null</span></kbd><span class="koboSpan" id="kobo.4.1"> before assigning that to the </span><kbd><span class="koboSpan" id="kobo.5.1">private readonly</span></kbd><span class="koboSpan" id="kobo.6.1"> data member. </span><span class="koboSpan" id="kobo.6.2">Otherwise, the construction of class throws an exception.</span></p>
<p><span class="koboSpan" id="kobo.7.1">There is no possibility of having one object of such class without injecting the dependency. </span><span class="koboSpan" id="kobo.7.2">Thus, the state of the object is always valid with no discrepancies. </span><span class="koboSpan" id="kobo.7.3">Unit testing with mocks becomes easy with this approach. </span><span class="koboSpan" id="kobo.7.4">Let's have a look at the pros and cons too.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Advantages of the Constructor Injection pattern</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">This is the most preferable way of respecting the concept of DI. </span><span class="koboSpan" id="kobo.2.2">Most DI containers target the constructors. </span></span><span class="koboSpan" id="kobo.3.1">It is also the most common and more widely used pattern for DI. </span><span class="koboSpan" id="kobo.3.2">The injected component can be used anywhere in the class because when you create the object, the injected dependency comes into the class automatically and stays in some variable. </span></p>
<p><span class="koboSpan" id="kobo.4.1">Developers prefer this technique when classes require some external dependency to initiate all other operations. </span><span class="koboSpan" id="kobo.4.2">As a constructor is involved, an object becomes ready with the dependent object once it is instantiated.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Disadvantages of the Constructor Injection pattern</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This is not so easy to implement when the class contains many constructors. </span><span class="koboSpan" id="kobo.2.2">Moreover, when the number of dependencies increases for a class, updating the constructor each time is not a feasible task.</span></p>
<p><span class="koboSpan" id="kobo.3.1">When you have a number of arguments for a constructor by adding the dependency ones with the existing ones, the class will look messy.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Property Injection pattern</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this technique, instead of asking the constructor to support the injection, we will directly inject to the property of the class. </span><span class="koboSpan" id="kobo.2.2">Let's get started.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The following diagram depicts one property </span><kbd><span class="koboSpan" id="kobo.4.1">EmployeeDept</span></kbd><span class="koboSpan" id="kobo.5.1">, which can be injected directly with an </span><kbd><span class="koboSpan" id="kobo.6.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.7.1"> implementation:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img height="156" width="390" src="assets/f37e69e5-b4e1-40e3-8395-a2b7c24b106b.png"/></span></div>
<p><span class="koboSpan" id="kobo.9.1">The </span><kbd><span class="koboSpan" id="kobo.10.1">Employee</span></kbd><span class="koboSpan" id="kobo.11.1"> class without the constructor argument for </span><kbd><span class="koboSpan" id="kobo.12.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.13.1"> and a new setter property will look something like the following:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    public class Employee
    {
      public int EmployeeId;
      public string EmployeeName;

      </span><strong><span class="koboSpan" id="kobo.15.1">private IDepartment _employeeDept;</span></strong>
      <strong><span class="koboSpan" id="kobo.16.1">public IDepartment EmployeeDept
      {
        set
        {
          this._employeeDept = value;
        }
      }</span></strong><span class="koboSpan" id="kobo.17.1">

      public Employee(int id, string name)
      {
         EmployeeId = id;
         EmployeeName = name;
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.18.1">We just removed the </span><kbd><span class="koboSpan" id="kobo.19.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.20.1"> argument from the constructor because we are going to directly assign an </span><kbd><span class="koboSpan" id="kobo.21.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.22.1"> type object to the property </span><kbd><span class="koboSpan" id="kobo.23.1">EmployeeDept</span></kbd><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">This can be done while creating the </span><kbd><span class="koboSpan" id="kobo.25.1">Employee</span></kbd><span class="koboSpan" id="kobo.26.1"> object as follows:</span></p>
<pre><span class="koboSpan" id="kobo.27.1">    static void Main(string[] args)
    {
      Employee emp = new Employee(1, "Sasmita Tripathy")
      {
</span><strong><span class="koboSpan" id="kobo.28.1">        EmployeeDept = new Engineering()</span></strong><span class="koboSpan" id="kobo.29.1">
      };
        
      Employee emp1 = new Employee(2, "Ganeswar Tripathy")
      {
</span><strong><span class="koboSpan" id="kobo.30.1">         EmployeeDept = new Marketing()</span></strong><span class="koboSpan" id="kobo.31.1">
      };
      Console.WriteLine("Emp Name: " + emp.EmployeeName + ",</span><br/><span class="koboSpan" id="kobo.32.1">         Department: " + emp.EmployeeDept.DeptName);
      Console.WriteLine();
      Console.WriteLine("Emp Name: " + emp1.EmployeeName + ",</span><br/><span class="koboSpan" id="kobo.33.1">         Department: " + emp1.EmployeeDept.DeptName);
      Console.ReadLine();
    }</span></pre>
<p><span class="koboSpan" id="kobo.34.1">Thus, by doing </span><kbd><span class="koboSpan" id="kobo.35.1">emp.EmployeeDept = new Engineering();</span></kbd><span class="koboSpan" id="kobo.36.1">, we are directly pushing the </span><kbd><span class="koboSpan" id="kobo.37.1">Engineering</span></kbd><span class="koboSpan" id="kobo.38.1"> object into the property </span><kbd><span class="koboSpan" id="kobo.39.1">EmployeeDept</span></kbd><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">The same thing is done for </span><kbd><span class="koboSpan" id="kobo.41.1">emp1</span></kbd><span class="koboSpan" id="kobo.42.1"> too.</span></p>
<p><span class="koboSpan" id="kobo.43.1">However, this code won't compile. </span><span class="koboSpan" id="kobo.43.2">We are missing something important here. </span><span class="koboSpan" id="kobo.43.3">Consider the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.44.1"><img src="assets/dbb64f95-24c4-4dc0-bb7b-b52175be846e.png"/></span></div>
<p><span class="koboSpan" id="kobo.45.1">The error is totally self-explanatory. </span><span class="koboSpan" id="kobo.45.2">We forgot to include the Getter block as we wanted to print the department name. </span><span class="koboSpan" id="kobo.45.3">Consider the following code snippet:</span></p>
<pre><span class="koboSpan" id="kobo.46.1">    private IDepartment _employeeDept;
    public IDepartment EmployeeDept
    {
      get {
            return this._employeeDept;
      }
      set
      {
            this._employeeDept = value;
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.47.1">Now, we are good. </span><span class="koboSpan" id="kobo.47.2">When you run it, you will see the same output as we got in the case of Constructor Injection.</span></p>
<p><span class="koboSpan" id="kobo.48.1">Property Injection is preferred when there is an optional dependency required for the class. </span><span class="koboSpan" id="kobo.48.2">What that means is, if you don't supply the value, the class won't mind as it can run without this dependency. </span><span class="koboSpan" id="kobo.48.3">If the developer forgets to assign the dependency, it should not affect the flow of the app.</span></p>
<p><span class="koboSpan" id="kobo.49.1">For instance, in our example, if you don't do anything with the property </span><kbd><span class="koboSpan" id="kobo.50.1">EmployeeDept</span></kbd><span class="koboSpan" id="kobo.51.1">, the class will behave as usual as long as you are not reading the property. </span><span class="koboSpan" id="kobo.51.2">In the next section, I will tell you how to beautify the code because the code is not yet perfect.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Curveball</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The problems with the approach which we have taken can be any one of the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">If you don't assign anything to the property (as we developers forget sometimes being lazy), the output won't return you anything when you print.</span></li>
<li><span class="koboSpan" id="kobo.4.1">You can assign null to the property as simply as </span><kbd><span class="koboSpan" id="kobo.5.1">emp.EmployeeDept = null;</span></kbd><span class="koboSpan" id="kobo.6.1">.</span></li>
<li><span class="koboSpan" id="kobo.7.1">Once you assign a dependency to a property, you can easily assign another dependency easily, which might be a problem. </span><span class="koboSpan" id="kobo.7.2">This might happen accidentally, however, it will create side effects for the whole system at some point in time. </span><span class="koboSpan" id="kobo.7.3">Imagine a situation where you initialized the property with engineering and then changed that to marketing, which is wrong.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.8.1">To handle all these situations, we should introduce more protection to the property. </span><span class="koboSpan" id="kobo.8.2">Let's do this:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">    private IDepartment _employeeDept;
    public IDepartment EmployeeDept
    {
      get
      {
          if (this._employeeDept == null)
          this.EmployeeDept = new Engineering();
             return this._employeeDept;
      }
      set
      {
        if (value == null)
           throw new ArgumentNullException("value");
        if (this._employeeDept != null)
           throw new InvalidOperationException();

         this._employeeDept = value;
       }
     }</span></pre>
<p><span class="koboSpan" id="kobo.10.1">Inside the setter, we check for </span><kbd><span class="koboSpan" id="kobo.11.1">null</span></kbd><span class="koboSpan" id="kobo.12.1"> and throw an exception. </span><span class="koboSpan" id="kobo.12.2">Then, we again investigate whether it is already there and throw an </span><kbd><span class="koboSpan" id="kobo.13.1">InvalidOperationException</span></kbd><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">Likewise, in the Getter, we are assigning a default value as engineering when passed </span><kbd><span class="koboSpan" id="kobo.15.1">null</span></kbd><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">Thus, we guarded our property for all such difficult situations, as previously discussed.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.17.1">Property Injection is not supported by the .NET Core built-in DI or IoC Container out of the box. </span><span class="koboSpan" id="kobo.17.2">Also, there is no such plan to bring this into the default container as of now. </span><span class="koboSpan" id="kobo.17.3">You have to use an external container such as Autofac to support this feature.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Advantages of the Property Injection Pattern</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We can see the following advantages of having a Setter Injection Pattern:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">It does not require adding a new constructor or modifying an existing constructor.</span></li>
<li><span class="koboSpan" id="kobo.4.1">This pattern comes in handy if the class has multiple dependencies of different types. </span><span class="koboSpan" id="kobo.4.2">Suppose there is a class which will use different types of logging such as logging, to text or logging to the database at the same time in different conditions, then having two setter properties where we can simply inject the required logger to do our task.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Disadvantages of the Property Injection Pattern</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Setters are not easy to identify in a particular design to inject some external dependency. </span><span class="koboSpan" id="kobo.2.2">Still, they are preferred in some situations. </span><span class="koboSpan" id="kobo.2.3">However, we should be careful while using the property which is injected because that might be </span><kbd><span class="koboSpan" id="kobo.3.1">null</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">There should be an extra check for </span><kbd><span class="koboSpan" id="kobo.5.1">null</span></kbd><span class="koboSpan" id="kobo.6.1">, everywhere where you want to use it. </span><span class="koboSpan" id="kobo.6.2">As we already discussed, protection must be provided to the property to avoid the inconsistent behavior.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Property Injection is considered as bad practice in most of the cases because it hides the dependencies. </span><span class="koboSpan" id="kobo.7.2">When the class is instantiated, there is no guarantee that the dependency object will be available for the class to do any operation, unlike Constructor Injection, where the dependency makes its way through during instantiation itself.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Method Injection Pattern</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">As the name suggests, we will inject the dependency into a method like we did in the case of the constructor. </span><span class="koboSpan" id="kobo.2.2">This comes in handy when we want different types of dependency in different methods of a class.</span></span></p>
<p><span class="koboSpan" id="kobo.3.1">Look at the following diagram, which tells us about the </span><kbd><span class="koboSpan" id="kobo.4.1">AssignDepartment(IDepartment)</span></kbd><span class="koboSpan" id="kobo.5.1"> method taking </span><kbd><span class="koboSpan" id="kobo.6.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.7.1"> as a dependency inside the </span><kbd><span class="koboSpan" id="kobo.8.1">Employee</span></kbd><span class="koboSpan" id="kobo.9.1"> class: </span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.10.1">&gt;</span><span class="koboSpan" id="kobo.11.1"><img height="217" width="321" src="assets/c4d5974f-df2b-4a27-b678-d84fa27f333f.png"/></span></div>
<p><span class="koboSpan" id="kobo.12.1">The client can create an object of the </span><kbd><span class="koboSpan" id="kobo.13.1">Employee</span></kbd><span class="koboSpan" id="kobo.14.1"> class and then fire </span><kbd><span class="koboSpan" id="kobo.15.1">AssignDepartment</span></kbd><span class="koboSpan" id="kobo.16.1"> with the appropriate implementation of </span><kbd><span class="koboSpan" id="kobo.17.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.18.1">, so that dependency is provided.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Let's see how the </span><kbd><span class="koboSpan" id="kobo.20.1">Employee</span></kbd><span class="koboSpan" id="kobo.21.1"> class can be coded:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">    public class Employee
    {
        public int EmployeeId;
        public string EmployeeName;
        public IDepartment EmployeeDept;
        </span><br/><span class="koboSpan" id="kobo.23.1">        // Default Constructor added for .NET Core 2.0 DI.</span><br/><span class="koboSpan" id="kobo.24.1">        // So that it can automatically create the instance.</span><br/><span class="koboSpan" id="kobo.25.1">        public Employee() { }
        </span><br/><span class="koboSpan" id="kobo.26.1">        public Employee(int id, string name)
        {
          EmployeeId = id;
          EmployeeName = name;
        }

        </span><strong><span class="koboSpan" id="kobo.27.1">public void AssignDepartment(IDepartment dept)
        {
           EmployeeDept = dept;
           // Other business logic if required.
        </span><span class="koboSpan" id="kobo.27.2">}</span></strong><span class="koboSpan" id="kobo.28.1">
     }</span></pre>
<p><span class="koboSpan" id="kobo.29.1">In this particular scenario, we have a method </span><kbd><span class="koboSpan" id="kobo.30.1">AssignDepartment</span></kbd><span class="koboSpan" id="kobo.31.1">, which takes one </span><kbd><span class="koboSpan" id="kobo.32.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.33.1"> type argument and then assigns that to the property. </span><span class="koboSpan" id="kobo.33.2">An </span><kbd><span class="koboSpan" id="kobo.34.1">Employee</span></kbd><span class="koboSpan" id="kobo.35.1"> object can be created accordingly. </span><span class="koboSpan" id="kobo.35.2">Consider the following code snippet:</span></p>
<pre><span class="koboSpan" id="kobo.36.1">    Employee emp = new Employee(1, "Sasmita Tripathy");
    emp.AssignDepartment(new Engineering());

    Employee emp1 = new Employee(2, "Ganeswar Tripathy");
    emp1.AssignDepartment(new Marketing());</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.37.1">It also produces the same output as what we have already seen.</span></p>
<p><span class="koboSpan" id="kobo.38.1">This pattern is useful when we require some dependency, only for some particular operation in a method and not for the whole class. </span><span class="koboSpan" id="kobo.38.2">Sometimes, the situation demands a small change which might be an edge case. </span><span class="koboSpan" id="kobo.38.3">To accommodate a small change, the simplest way would be to create a method and do whatever you want inside that (using dependencies passed in as arguments) instead of touching the constructors or properties.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Curveball</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the case of Method Injection, by convention, we should also take care of null check to ensure that the dependency is available before using it:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">    public void AssignDepartment(IDepartment dept)
    {
      EmployeeDept = dept ?? </span><span class="koboSpan" id="kobo.3.2">throw new ArgumentNullException("value");
      // Other business logic if required.
    </span><span class="koboSpan" id="kobo.3.3">}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Injecting with .NET Core 2.0</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we did in previous patterns, we will get the instance using the </span><kbd><span class="koboSpan" id="kobo.3.1">GetService</span></kbd><span class="koboSpan" id="kobo.4.1"> method and then call the required method by injecting the dependency:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    Employee emp = serviceProvider.GetService&lt;Employee&gt;();
    emp.EmployeeId = 1;
    emp.EmployeeName = "Sasmita Tripathy";
    emp.AssignDepartment(</span><strong><span class="koboSpan" id="kobo.6.1">serviceProvider.GetService&lt;IDepartment&gt;()</span></strong><span class="koboSpan" id="kobo.7.1">);

    Employee emp1 = serviceProvider.GetService&lt;Employee&gt;();
    emp1.AssignDepartment(</span><strong><span class="koboSpan" id="kobo.8.1">serviceProvider.GetService&lt;IDepartment&gt;()</span></strong><span class="koboSpan" id="kobo.9.1">);
    emp1.EmployeeId = 2;
    emp1.EmployeeName = "Ganeswar Tripathy";</span></pre>
<p><span class="koboSpan" id="kobo.10.1">The next thing you will see is the following as the output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.11.1"><img src="assets/055312b3-271d-43f1-8df4-7710be1f7737.png"/></span></div>
<p><span class="koboSpan" id="kobo.12.1">This happened because we have a constructor which is taking </span><kbd><span class="koboSpan" id="kobo.13.1">integer</span></kbd><span class="koboSpan" id="kobo.14.1"> and </span><kbd><span class="koboSpan" id="kobo.15.1">string</span></kbd><span class="koboSpan" id="kobo.16.1"> params. </span><span class="koboSpan" id="kobo.16.2">The provider is not aware of the process to resolve them, therefore, it throws an exception. </span><span class="koboSpan" id="kobo.16.3">The solution is to provide a default constructor, as the service provider is looking for it.</span></p>
<pre><span class="koboSpan" id="kobo.17.1">    public Employee() {  }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Implementation inside .NET Core 2.0</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We can get many instances of Method Injection Pattern usage inside the .NET Core 2.0. </span><span class="koboSpan" id="kobo.2.2">One of them is inside the simplest and frequently used class </span><kbd><span class="koboSpan" id="kobo.3.1">MvcServiceCollectionExtensions.cs</span></kbd><span class="koboSpan" id="kobo.4.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">MvcServiceCollectionExtensions.cs</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">MvcServiceCollectionExtensions.cs</span></kbd><span class="koboSpan" id="kobo.4.1"> class contains the method </span><kbd><span class="koboSpan" id="kobo.5.1">AddMvcCore</span></kbd><span class="koboSpan" id="kobo.6.1">, which is an example of Method Injection. </span><span class="koboSpan" id="kobo.6.2">The following screenshot shows the method at a glance:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img src="assets/9ee3d342-6b6d-4060-8b90-980db41fb1f6.png"/></span></div>
<p><kbd><span class="koboSpan" id="kobo.8.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.9.1"> is injected into the </span><kbd><span class="koboSpan" id="kobo.10.1">AddMvcCore</span></kbd><span class="koboSpan" id="kobo.11.1"> method. </span><span class="koboSpan" id="kobo.11.2">After it has been verified as not </span><kbd><span class="koboSpan" id="kobo.12.1">null</span></kbd><span class="koboSpan" id="kobo.13.1">, the service collection is processed further. </span><span class="koboSpan" id="kobo.13.2">I am only showing a screenshot of the relevant codes to understand the concept. </span><span class="koboSpan" id="kobo.13.3">You can definitely find such examples in other classes.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.14.1">The </span><strong><span class="koboSpan" id="kobo.15.1">Interface Injection Pattern</span></strong><span class="koboSpan" id="kobo.16.1"> is something which we have already discussed in other patterns, where we injected the implementations such as  </span><kbd><span class="koboSpan" id="kobo.17.1">IDepartment</span></kbd><span class="koboSpan" id="kobo.18.1"> which is an interface, into the constructor, property or a method. </span><span class="koboSpan" id="kobo.18.2">It's recommended to inject the implementation instead of the concrete class to avoid tight coupling. </span><span class="koboSpan" id="kobo.18.3">Interface injection allows us to achieve loose coupling along with abstraction.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Ambient context</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Ambient is an adjective meaning completely surrounding or encompassing. </span><span class="koboSpan" id="kobo.2.2">This means when we say Ambient context, it denotes some context, which would pertain its existence and behavior in the background or surrounding.</span></p>
<p><span class="koboSpan" id="kobo.3.1">When many classes require the same dependency, we should follow some technique to make it available to every such client.</span></p>
<p><span class="koboSpan" id="kobo.4.1">The patterns we discussed are not appropriate for such a scenario. </span><span class="koboSpan" id="kobo.4.2">If you try to make this possible using Constructor Injection, for example, you would end up adding a constructor for every class, having the same dependency injected to it.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Sounds more like a Cross-cutting Concern, doesn't it? </span><span class="koboSpan" id="kobo.5.2">To achieve this, we can simply add a static accessor for the dependency. </span><span class="koboSpan" id="kobo.5.3">This will make sure that the dependency is reachable to all the clients demanding it.</span></p>
<p><span class="koboSpan" id="kobo.6.1">The concept can be visualized in the following diagram: </span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img height="231" width="470" src="assets/e94dcddc-982d-4c55-8bbb-3f7a0f95a6ff.png"/></span></div>
<p><span class="koboSpan" id="kobo.8.1">Let's consider an example to get a better understanding of the implementation. </span><span class="koboSpan" id="kobo.8.2">An abstract class </span><kbd><span class="koboSpan" id="kobo.9.1">DepartmentProvider</span></kbd><span class="koboSpan" id="kobo.10.1"> can be designed to provide a static accessor called </span><kbd><span class="koboSpan" id="kobo.11.1">Current</span></kbd><span class="koboSpan" id="kobo.12.1">:</span></p>
<pre><span class="koboSpan" id="kobo.13.1">    abstract class DepartmentProvider
    {
      private static DepartmentProvider current;
      public static DepartmentProvider Current
      {
        get
        {
           return current;
        }
        set
        {
           current = value;
        }
      }
      public virtual Department Department { get; }
    }</span></pre>
<p><span class="koboSpan" id="kobo.14.1">We marked the class as </span><kbd><span class="koboSpan" id="kobo.15.1">abstract</span></kbd><span class="koboSpan" id="kobo.16.1"> and there is a </span><kbd><span class="koboSpan" id="kobo.17.1">virtual</span></kbd><span class="koboSpan" id="kobo.18.1"> property called </span><kbd><span class="koboSpan" id="kobo.19.1">Department</span></kbd><span class="koboSpan" id="kobo.20.1">, which will be accessed by any class requiring that.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Let's see how we can use the </span><kbd><span class="koboSpan" id="kobo.22.1">Current</span></kbd><span class="koboSpan" id="kobo.23.1"> property. </span><span class="koboSpan" id="kobo.23.2">The following code uses the class </span><kbd><span class="koboSpan" id="kobo.24.1">MarketingProvider</span></kbd><span class="koboSpan" id="kobo.25.1"> instance which is a derived class of  </span><kbd><span class="koboSpan" id="kobo.26.1">DepartmentProvider</span></kbd><span class="koboSpan" id="kobo.27.1">:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">    static void Main(string[] args)
    {
      var serviceProvider = new ServiceCollection()
      .AddTransient&lt;IDepartment, Engineering&gt;()
      .AddTransient&lt;Employee&gt;()
</span><strong><span class="koboSpan" id="kobo.29.1">      .AddTransient&lt;MarketingProvider&gt;()</span></strong><span class="koboSpan" id="kobo.30.1">
      .BuildServiceProvider();</span><br/><span class="koboSpan" id="kobo.31.1">                        
       // Set the Current value by resolving with </span><br/><span class="koboSpan" id="kobo.32.1">          MarketingProvider.
       </span><strong><span class="koboSpan" id="kobo.33.1">DepartmentProvider.Current = serviceProvider.GetService</span><br/><span class="koboSpan" id="kobo.34.1">          &lt;MarketingProvider&gt;();</span></strong><span class="koboSpan" id="kobo.35.1">

       Employee emp = serviceProvider.GetService&lt;Employee&gt;();
       emp.EmployeeId = 1;
       emp.EmployeeName = "Sasmita Tripathy";
       emp.EmployeeDept = DepartmentProvider.Current.Department;

       Employee emp1 = serviceProvider.GetService&lt;Employee&gt;();
       emp1.EmployeeId = 2;
       emp1.EmployeeName = "Ganeswar Tripathy";
       emp1.EmployeeDept = DepartmentProvider.Current.Department;

       Console.WriteLine("Emp Name: " + emp.EmployeeName + ", </span><br/><span class="koboSpan" id="kobo.36.1">         Department: " + emp.EmployeeDept.DeptName); // Marketing
       Console.WriteLine();
       Console.WriteLine("Emp Name: " + emp1.EmployeeName + ",</span><br/><span class="koboSpan" id="kobo.37.1">         Department: " + emp1.EmployeeDept.DeptName); // Marketing
       Console.ReadLine();
    }</span></pre>
<p><span class="koboSpan" id="kobo.38.1">See how we can register </span><kbd><span class="koboSpan" id="kobo.39.1">MarketingProvider</span></kbd><span class="koboSpan" id="kobo.40.1"> using the built-in DI container. </span><span class="koboSpan" id="kobo.40.2">Then we assigned that to the </span><kbd><span class="koboSpan" id="kobo.41.1">Current</span></kbd><span class="koboSpan" id="kobo.42.1"> property by which we are able to get the value as marketing when we read </span><kbd><span class="koboSpan" id="kobo.43.1">DepartmentProvider.Current.Department</span></kbd><span class="koboSpan" id="kobo.44.1">. </span><kbd><span class="koboSpan" id="kobo.45.1">MarketingProvider</span></kbd><span class="koboSpan" id="kobo.46.1"> is a child class of </span><kbd><span class="koboSpan" id="kobo.47.1">DepartmentProvider</span></kbd><span class="koboSpan" id="kobo.48.1">, which returns a </span><kbd><span class="koboSpan" id="kobo.49.1">Marketing</span></kbd><span class="koboSpan" id="kobo.50.1"> object. </span><span class="koboSpan" id="kobo.50.2">Refer to the following code:</span></p>
<pre><span class="koboSpan" id="kobo.51.1">    class MarketingProvider : DepartmentProvider
    {
      public override Department Department
      {
         get { return new Marketing(); }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.52.1">So, we made a conclusion here. </span><span class="koboSpan" id="kobo.52.2">We can use the </span><kbd><span class="koboSpan" id="kobo.53.1">static</span></kbd><span class="koboSpan" id="kobo.54.1"> property wherever we need inside the app and the value will be the same, unless you set it differently in-between.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Curveball</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A following are a few important points to remember while implementing an Ambient Context:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">This should be used only if it is really necessary. </span><span class="koboSpan" id="kobo.3.2">Constructor Injection or Property Injection should be the first choice before deciding to use Ambient Context. </span><span class="koboSpan" id="kobo.3.3">If you can't decide, just choose other DI patterns.</span></li>
<li><span class="koboSpan" id="kobo.4.1">The Service Locator anti-pattern is quite similar to this pattern in the way it provides the dependency. </span><span class="koboSpan" id="kobo.4.2">However, there is a difference and that is Ambient Context supplies a single dependency, whereas Service Locator is responsible for providing </span><span><span class="koboSpan" id="kobo.5.1">all requested</span></span><span class="koboSpan" id="kobo.6.1"> dependencies. </span><span class="koboSpan" id="kobo.6.2">We will discuss more on Service Locator in </span><a href="58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml" target="_blank"><span class="koboSpan" id="kobo.7.1">Chapter 9</span></a><span class="koboSpan" id="kobo.8.1">, </span><em><span class="koboSpan" id="kobo.9.1">Anti-Patterns and Misconceptions on Dependency Injection</span></em><span class="koboSpan" id="kobo.10.1">.</span></li>
<li><span class="koboSpan" id="kobo.11.1">If you don't correctly implement Ambient Context, it will have side effects. </span><span class="koboSpan" id="kobo.11.2">Suppose you initiate using one context or provider and during the process, you change it due to some reason. </span><span class="koboSpan" id="kobo.11.3">Now, when you read the value, it will provide you with the changed value instead of the first one because of static. </span><span class="koboSpan" id="kobo.11.4">That means you need to be very careful while implementing this.</span></li>
<li><span class="koboSpan" id="kobo.12.1">With the implementation we discussed, you can easily set </span><kbd><span class="koboSpan" id="kobo.13.1">null</span></kbd><span class="koboSpan" id="kobo.14.1"> to the </span><kbd><span class="koboSpan" id="kobo.15.1">Current</span></kbd><span class="koboSpan" id="kobo.16.1"> property </span><kbd><span class="koboSpan" id="kobo.17.1">DepartmentProvider.Current = null;</span></kbd><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">Therefore, we have to protect it by using a guard clause.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">The following code represents a simple guard clause inside getter and setter blocks:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">    abstract class DepartmentProvider
    {
      private static DepartmentProvider current;
      public static DepartmentProvider Current
      {
        get
        {
</span><strong><span class="koboSpan" id="kobo.21.1">          if (current == null)
          current = new DefaultDepartmentProvider();</span></strong><span class="koboSpan" id="kobo.22.1">
          return current;
        }
        set
        {
</span><strong><span class="koboSpan" id="kobo.23.1">           current = value ?? </span><span class="koboSpan" id="kobo.23.2">new DefaultDepartmentProvider();</span></strong><span class="koboSpan" id="kobo.24.1">
        }
      }
      public virtual Department Department { get; }
    }</span></pre>
<p><span class="koboSpan" id="kobo.25.1">We did a null check both in getter and setter and used a backup provider called </span><kbd><span class="koboSpan" id="kobo.26.1">DefaultDepartmentProvider</span></kbd><span class="koboSpan" id="kobo.27.1"> to overcome the situation of mishandling the context.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Implementation inside .NET Core 2.0</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">corefx</span></kbd><span class="koboSpan" id="kobo.4.1"> library has a  </span><span><kbd><span class="koboSpan" id="kobo.5.1">CurrentPrincipal</span></kbd> <kbd><span class="koboSpan" id="kobo.6.1">static</span></kbd><span class="koboSpan" id="kobo.7.1"> property inside the partial class</span></span> <kbd><span class="koboSpan" id="kobo.8.1">Thread</span></kbd><span><span class="koboSpan" id="kobo.9.1"> under  </span><kbd><span class="koboSpan" id="kobo.10.1">System.Threading</span></kbd><span class="koboSpan" id="kobo.11.1"> namespace.</span></span></p>
<pre><span class="koboSpan" id="kobo.12.1">    public static IPrincipal CurrentPrincipal
    {
      get
      {
         return CurrentThread._principal;
      }
      set
      {
         CurrentThread._principal = value;
      }
    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.13.1">The usage can be seen in a method </span><kbd><span class="koboSpan" id="kobo.14.1">Demand()</span></kbd><span class="koboSpan" id="kobo.15.1"> of the class </span><span><kbd><span class="koboSpan" id="kobo.16.1">PrincipalPermission</span></kbd><span class="koboSpan" id="kobo.17.1"> under the namespace </span><kbd><span class="koboSpan" id="kobo.18.1">System.Security.Permissions</span></kbd><span class="koboSpan" id="kobo.19.1">:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.20.1"><img height="149" width="483" src="assets/18fdc3f9-c8d6-4b42-81ca-435b2c7dc3ff.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The advantages of the Ambient Context</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Ambient Context is definitely a savior when an app demands the same dependency multiple times during the app execution. </span><span class="koboSpan" id="kobo.2.2">It's very hard to realise the fact that while we write codes for injecting dependencies, there are many such instances of asking the same dependency repeatedly within the app. </span><span class="koboSpan" id="kobo.2.3">This is the time where we should take the help of the Ambient Context Pattern, and with just a simple </span><kbd><span class="koboSpan" id="kobo.3.1">static</span></kbd><span class="koboSpan" id="kobo.4.1"> accessor, we will be able to get the dependency. </span><span class="koboSpan" id="kobo.4.2">This not only reduces code but also imposes the DRY principle.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The disadvantages of the Ambient Context</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Ambient Context is not easy to implement and needs careful attention while using it. </span><span class="koboSpan" id="kobo.2.2">By just looking at a class, we can't tell whether it implements the Ambient Context Pattern or not. </span><span class="koboSpan" id="kobo.2.3">If the context changes in between execution, the outcome will be different, resulting in side effects.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">While implementing DI, we should definitely learn the techniques associated with it. </span><span class="koboSpan" id="kobo.2.2">These techniques, otherwise called DI patterns, play a vital role in the application architecture. </span><span class="koboSpan" id="kobo.2.3">So, deciding which pattern to use when is the most important factor in the case of injecting dependencies.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Constructor Injection is the most widely used, is easy, and should always be your first choice. </span><span class="koboSpan" id="kobo.3.2">However, there are scenarios where you might opt for another pattern.</span></p>
<p><span class="koboSpan" id="kobo.4.1">When you see there are multiple dependencies required for different operations of a class, choose the Method Injection Pattern as it allows you the flexibility to inject dependency as you require.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Another beautiful design case reveals itself while you land on a situation where you need certain dependency at many places in your app. </span><span class="koboSpan" id="kobo.5.2">It looks like a Cross-Cutting Concern, however, you expect a certain return type, which is the dependency. </span><span class="koboSpan" id="kobo.5.3">For that, you need to use Ambient Context and can't rely on interceptors. </span><span class="koboSpan" id="kobo.5.4">This is because you need the returned dependency to do some operation in your class.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Property Injection is something which allows you to inject optional dependency. </span><span class="koboSpan" id="kobo.6.2">This means it relies upon a Local Default for sure, otherwise, we might end up in an exception while requesting it.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In </span><a href="58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml" target="_blank"><span class="koboSpan" id="kobo.8.1">Chapter 9</span></a><span class="koboSpan" id="kobo.9.1">, </span><em><span class="koboSpan" id="kobo.10.1">Anti-Patterns and Misconceptions on Dependency Injection</span></em><span class="koboSpan" id="kobo.11.1">, we will explore bad practices while implementing DI, which are denoted as anti-patterns.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>