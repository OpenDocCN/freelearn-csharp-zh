- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Completing the Adventure Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B18347_08.xhtml#_idTextAnchor151), we started by creating a
    flexible health system that can be added to any object to give it health, take
    damage, and heal. The system is extensible, meaning the things that can deal with
    damage and apply healing can be anything without the need to modify the `HealthSystem`
    class because we used interfaces to implement the behavior (not concrete class
    types). With objects now able to take damage, we continued by updating `Player`
    and enemy objects to use health – so, we have the semblance of a real game in
    the making.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by creating a wave spawner that instantiates new enemies on a fixed
    time interval and integrates with the existing patrol behavior. This allows us
    to add more complex enemy behavior, which adds new challenges to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we further explored composition by refactoring some of our reusable
    components to explore a different approach to destroying the heal pickup object.
    The importance of good programming practices and interfaces to build flexible
    and extensible systems was highlighted through examples.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll complete the adventure game by creating a simple quest
    system for collecting key pieces in the level that are required for solving an
    entryway security puzzle lock on the habitat station located on the planet’s surface.
    We will also introduce a new global event system for keeping our code loosely
    coupled. The event system will efficiently manage communication between various
    quest system components throughout the code base, so we’ll tackle that first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an event system in C# to tie things together loosely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a quest system for a collecting keys mission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving the key puzzle and winning the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to create a quest system that is
    integrated across different classes while being loosely coupled (that is, reducing
    dependency by not having external (concrete) class references) and scalable via
    the use of a new reusable global event system we’ll also create. You’ll also be
    able to integrate and customize a puzzle system for your use.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along in this chapter while using the same artwork that was created
    for the project in this book, download the assets from the GitHub link provided
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop. Alternatively, you’ll need a graphics program that can
    export layered Photoshop PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and
    Affinity Photo).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an event system in C# to tie things together loosely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We won’t need a UML diagram here as the design is quite simple. We’ll use a
    `Dictionary` collection (a special kind of C# collection) to hold the name of
    an event that we’ll assign the event’s callback handlers. The added callback handlers
    will all be invoked when the event is triggered. Although I say this is simple,
    I didn’t introduce it earlier because a few programming concepts still needed
    to be covered first.
  prefs: []
  type: TYPE_NORMAL
- en: The new event system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since a UML diagram won’t illustrate the functionality of `EventSystem` very
    well in this case, I’ve decided to create the following diagram as an introduction
    to the implementation (see *Figure 9**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – EventSystem diagram](img/B18347_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – EventSystem diagram
  prefs: []
  type: TYPE_NORMAL
- en: Before looking at the following code, do a quick mental exercise to see if you
    can visualize what the code should look like from this diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Given this diagram, here is the class template that makes up the basis for our
    new event system, minus some details we haven’t covered yet; is it similar to
    what you anticipated seeing?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You didn’t necessarily know what the `Dictionary` declaration would be – we
    haven’t covered it yet – but you at least knew that we needed a declaration for
    it, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a few additional things to unpack here and introduce some new C# items,
    including `Dictionary`, `Delegate`, and generic types (as you’ve probably noticed,
    `<T>` and `T` sprinkled throughout the code):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dictionary<string, Delegate>`: A C# `Dictionary` is a collection type that
    contains a list of `List`, a collection type that contains a single list of a
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s put this into some game development terms… a C# `Dictionary` is kind of
    like a magic bag where you can store lots of items and find anything you want,
    so long as it has a unique name. You can keep track of all the cool stuff your
    player will need on their adventure, keeping your game organized and awesome!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`string` type, which indicates the key type for the item in the dictionary.
    We’ll set the key to identify the specific event by name, and the event handler
    methods will be *added* *to it*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delegate` type and is the value being stored for the specific key item. We’ll
    set the value to a delegate type, such as `UnityAction`, that can have method
    handlers added to it (note that here, `delegate` is the base type for `UnityAction`).
    The event can be triggered later by the event’s name, invoking all the assigned
    event handler methods. Simples!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dictionary`, we can assign a new empty dictionary by specifying just the `new`
    keyword. This is new for C# in Unity 2022.2 since previously, you’d have to specifically
    restate `Dictionary` and the types for *key* and *value* again here – but you’d
    still have to do this for serialized variables assignable in the **Inspector**
    view!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary (C#)
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionary** represents a collection of keys and values. It has similar properties
    and methods compared to a **List** collection type. For additional reading, go
    to [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0).'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddListener()`: We’ll call this method when we add an event to `EventSystem`.
    The method signature has the following parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<T>`: In C#, there is a programming concept called `T` represents *any type*
    as a generic type parameter. This allows you to define a method, class, parameter,
    or something else that can work with any type specified by the calling code, such
    as `string`, `int`, `float`, `Vector3`, `GameObject`, and so on. This allows reuse
    across different parts of the code without the need to use specific types and
    repeat the same code to support those types. It may sound a bit complicated this
    early on, but I hope it is understandable through the preceding example.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our use case for a generic type is to implement an event delegate that can pass
    in any type as an argument. This will become clearer as we work through the rest
    of `EventSystem`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eventName`: A `string` type that uniquely identifies the event that’s been
    *registered* with `EventSystem`. It’s how we add additional listeners to a specific
    event and how we know what event to trigger.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listener`: `UnityAction<T>`, which is the event delegate. `UnityAction` should
    be familiar since it was first introduced in [*Chapter 3*](B18347_03.xhtml#_idTextAnchor058),
    as an event listener that was used to update the UI. The difference here is that
    we are adding a generic parameter of the `T` type, which means the handler method
    can pass a single argument of any type when invoked.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveListener()`: This is used when removing an event from `EventSystem`.
    The method signature is the same as that for `AddListener()`, so we don’t need
    to repeat ourselves here. However, there will be one glaringly obvious difference:
    we’ll be removing a method handler instead of adding one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TriggerEvent()`: We’ll call this method when we want to invoke the specific
    event for which method handlers were added as listeners (via `AddListeners()`,
    of course). The method signature has the following parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eventName`: Again, this is the event name string we’ll specify for invoking
    the method handlers (that is, the added listeners).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T arg`: The parameter value we’ll pass into the invoked methods that will
    be handled so that they can receive and process any required data. Again, being
    a generic type, `T`, we’ll be able to pass in an argument of any type (nice, right?).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding code, I said *event name*, but we won’t do something as silly
    as using string literals for the event names throughout the code base. Instead,
    let’s create an `EventConstants` class that we’ll use for the event names. This
    would be similar to how we added a `Tags` class when referencing tags assigned
    to our objects in the game through code (for example, `Player`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define our first event name constant by creating the following `EventConstants`
    class, saved in the `Assets/Scripts/Systems` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The event name will be the *constant* (figuratively and literally) that loosely
    ties things together, so we don’t require concrete class references between classes
    that would observe and respond to events. Now, we can independently test our classes
    – via `Player` doesn’t need to specify a reference to `UIManager`, `Enemy`, and
    so on. We can also move a class to a new project without worrying about bringing
    in unnecessary classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve learned about the event system template, as well as how we’ll
    specify events, let’s dig into the specifics of the implemented methods: `AddListener()`,
    `RemoveListener()`, and `TriggerEvent()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Event management methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let’s look at the `AddListener()` method. To recap, `AddListener()`
    is responsible for adding an event to the dictionary of events if it doesn’t already
    exist (that is, registering the event) and adding the listener to the event’s
    handler method `delegate`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ContainsKey()`: The very first thing we’ll need to do when adding an event
    to our dictionary of events is to see if we’ve already registered one of the same
    event names (pretty logical, right?). A C# `Dictionary` provides several methods
    here – similar to a C# `List` in many ways – for achieving this base functionality
    that we can leverage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifically, we use `ContainsKey()` and pass in `eventName`. This will return
    a Boolean value of `true` if the key already exists in the dictionary and `false`
    if not, so we can use an `if` statement to evaluate and take the proper action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Add()`: Working with the result returned from `ContainsKey()`, we’ll go ahead
    and add the event – using the event name as the key – to the dictionary using
    the `Add()` method (again, similar to C# `List`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that for the value parameter – as in `Add(key, value)` – we’re specifying
    `null` for the delegate. That’s simply because we’ll assign the listener to the
    delegate in the following line, where it doesn’t matter whether this event was
    just added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_events[eventName]`: We can get the value for a specific event from the `_events`
    dictionary by simply specifying the key in square braces (this is similar to how
    we’d return the value of an array by specifying the index (`int`) in square braces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(UnityAction<T>)`: Placing a type in parenthesis before another type is called
    casting in C#. Since `_events[eventName]` is a `Delegate` type, and `UnityAction`
    has delegate as its base type, we can operate on the event dictionary value as
    `UnityAction` via a type conversion by casting it (an explicit conversion). Here,
    again, `<T>` indicates we will use a generic for a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting (C#)
  prefs: []
  type: TYPE_NORMAL
- en: C# is a strongly typed language (or statically typed) at compile time, so once
    a variable is declared, it cannot be declared again as a different type. To overcome
    this, should you need to copy a value into a variable of another type, C# provides
    various type conversion operations, and casting is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some additional reading: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions).'
  prefs: []
  type: TYPE_NORMAL
- en: '`+ listener`: `UnityAction` allows you to add additional listeners; using the
    `+` (add) operator will enable us to do just that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that just the `+` operator is the correct syntax to add a listener to a
    delegate that may be `null` or already has listeners, unlike previously, all the
    way back in [*Chapter 3*](B18347_03.xhtml#_idTextAnchor058), where we used the
    `+=` operator to add an event handler method when subscribing to events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s look at the opposite. For `RemoveListener()`, we want to remove
    an event listener when it’s no longer needed – especially when an object is destroyed
    – so that we don’t try invoking an invalid handler method reference. This is generally
    just good practice – for some listener types, not doing so can cause memory leaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We don’t need to break down the code here again because it’s essentially the
    same as `AddListener()`. The primary differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to add the event in case it doesn’t exist; we only care if it
    does exist so that we can remove a listening handler method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In place of the `+` operator, we use the `-` operator to remove the specified
    listener handler method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, we have the `TriggerEvent()` method. The naming of these methods has
    been self-explanatory so far, so it should be no surprise what’s next. However,
    we are doing something different here to retrieve the dictionary’s value for the
    `eventName` key that’s been provided to invoke the added handler methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how things work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_events.TryGetValue()`: You may find this syntax familiar since we’ve already
    used `TryGetComponent()` a few times. Very simply, we try to get the value for
    the specified `eventName` key, and if it exists, we return the value as an `out`
    parameter called `del`. The `if` evaluation will short-circuit if it’s not found,
    so `Invoke()` will only be called if a value is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(del as UnityAction<T>)`: We introduce the `as` operator keyword here. Similar
    to how we used `()` to cast to another type, we can also use `as` for type conversion.
    Specifically, `as` is a good choice when working with a nullable type, which we
    want to do here because we’re also using the null-conditional operator (`?.`)
    so that we won’t erroneously try and call `Invoke()` on a null delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The as operator (C#)
  prefs: []
  type: TYPE_NORMAL
- en: The **as** operator converts objects to a different type but returns **null**
    if the conversion fails instead of throwing an exception like other type conversion
    techniques would.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some additional reading: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator).'
  prefs: []
  type: TYPE_NORMAL
- en: '`Invoke(arg)`: This is how we tie back into the generic parameter specified
    by `T` in the `UnityAction<T>` declaration for our listener delegate. The last
    part, bringing it full circle, will be the method signature for the handler method
    receiving the argument. This should all make sense when we get to the *Creating
    a quest system for a collecting keys mission* section, when we put the event system
    through its paces. Promise!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, so that we don’t overlook an essential detail for how we will access the
    event system from our classes that need to work with events, let’s make the event
    system a Singleton – an actual Singleton!
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing a Singleton instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `EventSystem` will be a **Singleton** instance so that it can be accessed
    from anywhere in our code. Still, we haven’t implemented a full Singleton pattern
    yet where only a single instance is guaranteed to exist. We’ll sort this out by
    enforcing the pattern and destroying any want-to-be duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw a rudimentary implementation back in [*Chapter 3*](B18347_03.xhtml#_idTextAnchor058),
    where we just set the instance to a static variable without even attempting to
    seek and destroy additional instances being introduced (bad us). Here we go. Add
    the following `Instance` public static variable declaration and the new `Awake()`
    method code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The magic happens in the `Awake()` method, where we previously just did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can now check if our static `Instance` has been assigned yet; if not, assign
    it. However, if `Instance` was already assigned, a want-to-be duplicate will be
    added to our **Scene Hierarchy**. Let’s destroy it right away!
  prefs: []
  type: TYPE_NORMAL
- en: Our `EventManager` will need to hang around all the time to respond to registering
    and triggering events at any time, and from any class, throughout the life of
    our game, so we’ll need a way to keep it persistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the coding process feels like a game: find something, destroy that,
    keep this. So, if you’re not having fun, you’re doing something wrong!'
  prefs: []
  type: TYPE_NORMAL
- en: EventSystem | Complete code
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the complete code for the **EventSystem** class and all the event-related
    code in this chapter, visit this book’s GitHub repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/).'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity provides a way to keep particular objects persistent, no matter the current
    scene, survive loading new scenes, and more, and that is by using `DontDestroyOnLoad`.
    Simply calling it and passing the `GameObject` object you want to persist as the
    target parameter is all that’s needed. In our case, in `Awake()`, we’re passing
    in `gameObject`, which represents the current object the component (script) is
    attached to.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**DontDestroyOnLoad**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Systems GameObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects specified as `DontDestroyOnLoad` must be in the root of the `EventSystem`
    component. I would place this at the very top of the scene hierarchy to maintain
    some visible order of dependency for things – it’s entirely up to you how you
    choose to organize things here. Also, remember that you can add empty objects
    with the sole purpose of having organizational headers (don’t forget to set the
    tag to `EditorOnly`), as seen in the `Systems` object referenced in *Figure 9**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Systems root GameObject](img/B18347_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Systems root GameObject
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a global event system that allows
    our classes to remain loosely coupled because we don’t require type references
    of one class in another to respond to triggered actions. If the `EventSystem`
    component’s usage is still unclear, don’t fret – in the next section, we’ll cover
    an example straight away by creating a simple quest system based on it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a quest system for a collecting keys mission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our super decoupled global event system, we’ll immediately
    put it to good use. Referring again to our GDD, we know that the player, at some
    point, has to collect some key pieces to solve a puzzle so that they can advance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **What is the secondary game mechanic for the** **adventure game?** | The
    player will search the environment for hidden parts of a key. The pieces will
    need to be combined correctly as input to gain access to the entryway of the habitat
    station. |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 – GDD quest reference
  prefs: []
  type: TYPE_NORMAL
- en: A typical game system that can support “collecting a certain number of items”
    is a quest system. A possibly more simplified approach, but also a system-based
    approach to solving this problem, could be a basic inventory system. A quest system,
    however, will offer additional opportunities to provide a more complete example
    – especially for implementing the event system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a quick look at what the player will be searching for during their
    quest and interacting with to regain entry to the habitat station constructed
    on the planet. The Kryk’zylx technology is a mystery to us, but suffice it to
    say, they like a good challenge when securing their bases. Both the key pieces
    that the evil plant entity has scattered and the entryway security puzzle lock
    with the missing pieces can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Keys and security puzzle art](img/B18347_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Keys and security puzzle art
  prefs: []
  type: TYPE_NORMAL
- en: Our mission now is to code the quest system and flesh out the game mechanics
    required to implement it. So, let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: The quest system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ll provide the code template for a `QuestSystem` class, similar to how the
    event system was introduced. However, I’ll give the full implementation this time
    because you’ll find it shares a similar design to `EventSystem`. I also won’t
    provide a diagram this time. I’m going to save it as a challenge for you to create
    one on your own at the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new script named `QuestSystem` in the `Assets/Scripts/Systems` folder
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Okay, no, you’re not experiencing déjà vu. The basic concept for the `QuestSystem`
    code is a similar pattern to `EventSystem`. At its core, there’s also a C# `Dictionary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dictionary<string, bool>`: The declaration for the `_quests` dictionary will
    hold a `string` key to identify the quest’s name (similar to the event name),
    and the value for the entry will be of the `bool` type as an indication of whether
    the quest has been completed (that is, `true` equals completed).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StartQuest()`: Starting a quest means adding it to the dictionary if it’s
    not already added. Quests will be identified by a unique `questName` that’s passed
    in as the only argument. Simple. As. That.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompleteQuest()`: As stated earlier, we’re going to use the `_quest` value
    as the quest completion indicator, so if the specified quest exists in the dictionary,
    then we’ll assign `true` for its value (`bool` has a default value of `false`,
    which is why we didn’t need to assign this anywhere).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll be repeating ourselves a bit here again with how `QuestSystem` will be
    accessed when required since we’ll be using a Singleton pattern again. Primarily,
    however, we will decouple references to `QuestSystem` whenever possible by going
    through the global event system (that is, no tightly coupled objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following declarations for the public static `Instance` property and
    the *Singleton management code* to the `Awake()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the Singleton pattern solves a big problem for obtaining references to
    our core systems, but it also comes with some disadvantages compared to more complex
    patterns (for example, service locator patterns). We’re going to address one of
    these shortcomings now before proceeding further.
  prefs: []
  type: TYPE_NORMAL
- en: We have a potential problem with our systems because we require the `EventSystem`
    instance to be available to every other system when the game starts – being the
    core system loosely coupling everything together and playing nice. With that being
    the case, we must ensure it gets initialized first.
  prefs: []
  type: TYPE_NORMAL
- en: Script Execution Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To set the execution order for which script event functions are run (for example,
    the `Awake()` message event), Unity provides a **Script Execution Order** assignment
    in **Project Settings**. Quite simply, you can set a lower-ordered number for
    scripts you want to be initialized first and specifically before others that would
    rely on it being initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Script Execution Order settings: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: For our usage here, we require `EventSystem` to be run before `QuestSystem`.
  prefs: []
  type: TYPE_NORMAL
- en: Open **Edit** | **Project Settings…** | **Script** **Execution Order**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If they’re not already in the list, add these two scripts to the list using
    the little plus (**+**) button at the bottom right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click and drag them into the position indicated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Script Execution Order in Project Settings](img/B18347_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Script Execution Order in Project Settings
  prefs: []
  type: TYPE_NORMAL
- en: Click **Apply** when you’re finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: Unity also provides a code solution for specifying the execution order of scripts
    using an attribute. The attribute is **[DefaultExecutionOrder(int)]**, and you
    can decorate the class declaration and set the order value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, adding this attribute to the **QuestSystem** class declaration
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And speaking of execution, make sure to add the `QuestSystem` component to the
    `EventSystem`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, what’s a quest system without any quests?!
  prefs: []
  type: TYPE_NORMAL
- en: The quest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your mission, should you choose to accept it, will be to find and collect the
    missing pieces that are required to solve the habitat entryway security puzzle
    lock. The quest object representing the actual quest with its requirements is
    arguably the essential part of any quest system. As you saw in the *Script Execution
    Order* section, keeping a list of the active quests is quite simple – we add a
    quest to a list and set a variable to `true` when it’s completed. Easy-peasy.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the quest system we’ll cover will be the quest code. Before
    we even get started, however, we will ensure that any quest we define will have
    a unique identifier that is easily assignable (even in the **Inspector** view).
  prefs: []
  type: TYPE_NORMAL
- en: Name consistency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem we’ll need to solve now is how to guarantee consistency for quest
    names without using magic strings, reference the quest names from different parts
    of the code, and have them selectable in the **Inspector** view.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to use `enum` when the simple `enum` similarly now, but instead of
    states for an FSM, we’re going to use it for unique quest name identifiers; again,
    as a reminder, we’re not going to rely on string literals! This is similar to
    how we’ve used string constants before (for example, event names and tags), but
    being an `enum` type over a constant means we have some added benefit, including
    when it comes to selecting from a list of available quests in the **Inspector**
    view!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new script named *QuestNames* in the `Assets/Scripts/Quests` folder.
    Replace all of the default script template code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is where we’ll define any new quest we add to the game. We’ve populated
    the `CollectKeysQuest` name and given it a unique ID of `10` (this is any arbitrary
    number that’s not already being used) – be sure to follow this pattern, assigning
    the name and ID, when adding additional quest names.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll see how the quest names will be declared and referenced as we proceed
    with our coding mission to complete this quest system!
  prefs: []
  type: TYPE_NORMAL
- en: Quest base class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yup, that’s right, another base class means we will use more OOP design here!
    And since we covered this already in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041),
    it’s barely an inconvenience for you to bang this out, right? Our specific quests
    will then derive from the new quest base class we’ll write next, providing a template
    for consistency in implementing quests.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already defined the quest names. A quest name will need to be a part of
    every quest, so let’s start by setting up the base class for our quests with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new script named `QuestBase` in the `Assets/Scripts/Quests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that the `QuestBase` class is declared as `public
    abstract class`. This means we won’t be able to use this class directly – we cannot
    add an abstract class to a `GameObject` object in the `QuestBase` (that is, this
    is only the *base template*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we can see the declaration for `QuestName`, which uses the `QuestNames`
    `enum` type we previously wrote. We have encapsulated a `private _questName` variable
    and decorated it with the `[SerializeField]` attribute so that it can be assigned
    in the `enum` type draws in the **Inspector** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The Quest Name Inspector view assignment dropdown](img/B18347_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The Quest Name Inspector view assignment dropdown
  prefs: []
  type: TYPE_NORMAL
- en: The `_questName` value is made available to other classes via the `public QuestName`
    property – the expression body (`=>`) declares the property as a getter only (as
    in, you won’t be able to assign a value).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. Still, this was a bit of a review since nothing we’ve covered
    here is new. The same goes for the first two methods we’ll declare for the `QuestBase`
    abstract class. We’ll use `virtual` methods for both `StartQuest()` and `QuestCompleted()`
    because the inheriting class may need to override the provided base functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The code may be self-explanatory at this point, but it always helps to explain.
    Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public virtual void StartQuest()`: This method has a `public` accessor because
    it is intended to be called from an external class to trigger the start of the
    quest. We call the quest system’s `StartQuest()` method (via its Singleton instance)
    and pass the unique quest identifier (that is, the `enum`-based quest name) to
    add it to the active quests `Dictionary` for later reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `virtual` in the method signature in case the inheriting class would
    need to do more than start the quest.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`protected virtual QuestCompleted()`: This method has a `protected` accessor,
    so it can only be called within the class and by derived classes – not an external
    class because the logic to determine quest completion should be evaluated on the
    specific quest’s requirements and not some external factors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, we use `virtual` in the method signature in case the inheriting class
    would need to do something else (such as implementing different logic or behavior
    for different types of quests, such as side quests). For now, we’re simply logging
    a message to the console that the quest was completed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now for the fun part! We’ll be leaning on the event system to implement the
    following function: listening for when the quest has been completed. This is why
    we didn’t declare the `QuestCompleted()` method as `public` – `QuestCompleted()`
    is the handler method that’s passed into the event system as the listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are just a few points in need of explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnEnable()`, `OnDisable()`: We add and remove the event system listeners for
    the base class, respectively. `AddListeners()` and `RemoveListeners()` can be
    overridden in the inheriting class if additional listeners need to be added for
    the specific quest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddListeners()`: Here, we add a listener to the event system for quest completion.
    We’ll use a string argument to pass the quest’s name as the parameter to the handler
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveListeners()`: We just need to remove the listener added in `AddListeners()`
    – remember, removing event listeners is always good practice!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that even though it doesn’t make sense that simply removing a listener
    would require an argument for passing a parameter, we still need it because the
    delegate definition must match the method signature of the handler method that
    was added as the listener.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As the last step, add the string constant for `EventConstants.OnQuestCompleted`
    to the `EventConstants` script. Or, in your IDE, *OnQuestCompleted* should have
    that red squiggly line indicating the definition was not found. Go ahead and use
    your IDE’s refactoring tools to generate the variable (but ensure it is consistent
    with the other event name constants).
  prefs: []
  type: TYPE_NORMAL
- en: With that, `QuestBase` has been completed! Now, prepare to make a specific quest
    class derived from the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Collect keys quest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We call the missing security puzzle key pieces that need to be collected *keys*,
    and three will be required to complete our quest. These are simple requirements
    for a simple quest, but we still need a way to not only explicitly declare the
    requirement but evaluate and communicate completion, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by creating a new script called `CollectKeysQuest` in the `Assets/Scripts/Quests`
    folder and inherit from `QuestBase` instead of `MonoBehaviour`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We also declare the number of keys required to be collected to complete this
    quest. `_numKeysRequired` will be `private` so that no other class has access
    to it, but we’ll use the `[SerializeField]` attribute to set this value in the
    `3`).
  prefs: []
  type: TYPE_NORMAL
- en: '`_keysCollected` will keep track of the number of keys the player has collected
    (`private` – it’s no one else’s business), and we’ll increment that value via
    the event system (so handy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, it is a familiar pattern, but let’s clarify it still:'
  prefs: []
  type: TYPE_NORMAL
- en: '`override AddListeners()`: For this specific quest, we need to listen for when
    the player has collected a key. Using the event system, we don’t need to know
    anything about the `Player` object or even the script implemented to collect the
    key; we observe that a key was collected and handled with the `KeyCollected()`
    method. We use the `override` keyword here because we need more functionality
    than the base class alone provides:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base.AddListeners()`: Speaking of what the base class provides, we still need
    it! We can still ensure the base class methods that are overridden by using the
    `base` keyword – for accessing base class members within the derived class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override RemoveListeners()`: You got it – maintaining good practice removing
    what listeners were added:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base.RemoveListeners()`: The same as for `base.AddListeners()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyCollected()`: I promise we won’t have a breadcrumb trail of UNDONE tokens
    to follow again! But, for now, we’ll just increment the `_keysCollected` variable
    when the `OnKeyCollected` event is triggered:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool arg0`: Our `EventSystem` requires us to pass an argument with the handler
    event. We don’t need to pass any parameters for the key collected event, but we
    must still declare something! A bool value being the smallest type, I feel, is
    the least evil we can do here.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventConstants.OnKeyCollected`: Be sure to add it to `EventCostants` to resolve
    the missing definition error.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Excellent – we have a quest! Now, if only we could be given the quest! We don’t
    have snarky NPCs in our game standing on street corners, just giving out quests
    to any weary traveler passing through, so we’ll leverage some reusable components
    we already have to trigger the start of our quest.
  prefs: []
  type: TYPE_NORMAL
- en: Quest giver GameObject
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We don’t need a new script for giving the quest to the player; we just need
    to start *Collect Keys Quest*. We can easily do that by creating a trigger volume
    in the environment, using our ever-so-useful and reusable `TriggerEvent` component,
    and simply calling the publicly declared `StartQuest()` method on a `CollectKeysQuest`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what it’ll look like in the **Scene** view and **Inspector** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Quest giver object in the scene](img/B18347_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Quest giver object in the scene
  prefs: []
  type: TYPE_NORMAL
- en: Have a go at constructing the object and components that make up the *quest
    giver* object and place it in the level near where the player starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you manage to assemble it successfully? Let’s review the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new GameObject in the scene and name it `Quest Giver – Keys Quest`,
    then position it in the level near where the player starts (refer to *Figure 9**.6*
    for an example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*A*) Add the `CollectKeysQuest` script to the new object. *Collect Keys Quest*
    should be selected in the **Quest Name** dropdown since it’s our only quest, and
    set the number of keys required to three.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*B*) Add a `BoxCollider2D` component next (use the `true` because we don’t
    want the player to interact with this GameObject physically; we only want to use
    it as a trigger volume. Adjust the collider’s size to guarantee the player will
    collide with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*C*) Add a `TriggeredEvent` component and wire up the methods that are called
    when `OnTriggered()` is invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the little plus (`CollectKeysQuest` component to the first event field
    and select the `CollectKeysQuest.StartQuest()` method from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `BoxCollider2D` to the second event field, select `BoxCollider2D.enabled`
    from the dropdown, and leave the checkbox unticked (that is, set `false`; this
    will disable the collider and prevent triggering *start the quest* additional
    times).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure only the player can trigger the quest start by ticking off `IsTriggeredByPlayer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the final step, save the `Prefab` object in the `Assets/Prefabs` folder (by
    dragging it from the hierarchy into the **Project** window). That way, we can
    quickly drop a quest giver into the level later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quest accepted! You wouldn’t start a quest that was impossible to complete,
    would you? Now, let’s see how we complete *Collect* *Keys Quest*.
  prefs: []
  type: TYPE_NORMAL
- en: Quest completion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve defined a specific quest, we’ve given the quest to the player, and now
    we must progress on the quest to complete it. Progress is made when we collect
    keys in the game level (you know, kind of like the collection game we completed
    as the first project in this book).
  prefs: []
  type: TYPE_NORMAL
- en: In the `CollectKeysQuest` class, as you know, the `KeyCollected()` method is
    called when the `OnKeyCollected` event is triggered. We left it at only incrementing
    the variable, keeping track of the number of keys collected. Let’s finish it up
    by evaluating whether the quest requirements have been satisfied to complete the
    quest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the `KeyCollected` method by adding the `if` block, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A very simple `if` statement checks whether the incremented `_keysCollected`
    variable is greater than or equal to (`>=`) the number of keys required to complete
    the quest, as defined by the `_numKeysRequired` variable (set in the `then` we’ll
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `CompleteQuest()` on the `QuestSystem` Singleton instance and pass in the
    quest name as the parameter. We need to use `ToString()` on the `QuestName` variable
    because it is an `enum` value, and internally, it is stored as an `int` type;
    we need a `string` type as the argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigger the `OnQuestCompleted` event via the `EventSystem` Singleton instance
    and, again, pass in `QuestName` as a parameter. This is also a `string` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *UNDONE token quest* is complete. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Quest event constants added
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add some event name constants to support what we just added for
    the quest system and *Collect Keys Quest*. As a recap, here’s what the `EventConstants`
    script should look like now. I have added some comments for some quick organization
    to keep things tidy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our quest system has come together nicely, but we’re still missing one final
    bit of functionality, and that is being able to know whether or not a quest that
    was started (that is, added to the `_quests` dictionary) has been completed (that
    is, the requirements of the quest mission have been satisfied, and `CompleteQuest()`
    was called).
  prefs: []
  type: TYPE_NORMAL
- en: Quest status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To know the quest’s status, go ahead and add the following `IsQuestComplete()`
    method to the `QuestSystem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You should recognize a familiar pattern here with `TryGetValue()` (as a method
    available in `Dictionary`) – we’ve covered a similar pattern with `TryGetComponent()`
    several times. `TryGetValue()` will return `true` if the value exists in the `_quests`
    dictionary. Then, set the returned value to the `out` variable, `status`, for
    immediate consumption by the following `if` block code. This is extremely convenient,
    and, as I’ve espoused, I’m a big fan of this pattern (even going so far as to
    replicate this pattern in my code).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll continue with short-circuiting the method by immediately returning the
    quest’s `status` from the `TryGetValue()` call. Otherwise, we return `false`,
    indicating a default condition of the quest not being complete due to it not even
    existing in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can query the status of a specific quest from our `QuestSystem`
    Singleton instance, we can create a reusable component to use in our game to respond
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Quest completed component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll need something to check for quest completion when the player gets to the
    habitat entryway. This will allow us to show the security puzzle lock if the quest
    has been completed or provide some other action if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new script named `QuestHasCompleted` in the `Assets/Scripts/Quests`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t anything we haven’t seen before. The `QuestName` field will allow
    us to specify which quest we want to know the completion status for in the `UnityEvent`
    fields will enable us to set actions for complete and incomplete statuses. Simples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how an object based on this new component will look in the **Inspector**
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Puzzle trigger object setup](img/B18347_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Puzzle trigger object setup
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create this *puzzle trigger* object now and wire it up so that when the
    player enters the trigger volume, and if *Collect Keys Quest* has been completed,
    it will disable `PlayerInput` (ensuring the player can no longer move) and show
    **Puzzle** (solving the entryway security puzzle lock is the player’s goal for
    this level).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we construct a *Has the quest been* *completed?* object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty GameObject in the `Puzzle Trigger` because we want to show
    the puzzle when the player reaches the habitat entryway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*A*) Add a `QuestHasCompleted` component and select **Collect Keys Quest**
    from the dropdown of available quest names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the following events for `OnQuestComplete()` (click the plus (`PlayerInput.enabled`
    from the dropdown, and leave the checkbox unticked. Disabling `PlayerInput` in
    this way will mean no input will be processed to enact with the player – we don’t
    want the player character to move any longer because it would now be time to solve
    the puzzle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following assignment is for our future selves; we’ll use a reference to
    the **Key Puzzle** object and make it active (display it) so that the player can
    work on solving it – **Key Puzzle** will be added in the last section of this
    chapter, so we’ll revisit this assignment then.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*B*) Add a `TriggeredEvent` component and assign the `QuestHasCompleted` component
    to the `OnTriggered` event, then select `QuestHasCompleted.CheckQuestComplete()`
    from the dropdown. Ensure **IsTriggeredByPlayer** is ticked.*   Don’t forget to
    add a `BoxCollider2D` component and set `true`; the size will be adjusted accordingly
    concerning the habitat entryway so that the player will interact with it when
    reaching it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For placement, if you haven’t taken the liberty of adding the habitat entryway
    to your level yet, now’s the time! We haven’t explored every nuance of your level
    design while bringing everything together – naturally, you’ve been doing your
    level design homework:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the habitat entryway sprite *entryway* from the `Assets/Sprites/Object
    Elements` folder into the environment and use the `Background` **Sorting Layer**.
    You can organize it in the **Scene Hierarchy** using what we previously established
    as the **Level (Default)** | **In** **Back** structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the **Puzzle Trigger** object at the entryway and set the collider size
    accordingly (refer to *Figure 9**.7* for an example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we saw in the preceding code and description, the `QuestHasCompleted` component
    has an event that is triggered when we check the status for both complete and
    incomplete quest statuses. We already populated the `OnQuestComplete()` event
    but also have an `OnQuestIncomplete()` event. We won’t be assigning any function
    here for now, but imagine that we could display a dialog to our player stating
    that the quest’s requirements haven’t been met for them to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge | Quest system diagram
  prefs: []
  type: TYPE_NORMAL
- en: Create a basic object reference diagram for the quest system while using the
    event system diagram in *Figure 9**.1* as a reference. Don’t be so concerned with
    the shapes you choose to represent each part, but do be consistent and use the
    same shape for the same object type. If you want to challenge yourself further,
    create a UML diagram!
  prefs: []
  type: TYPE_NORMAL
- en: Everything is in place for us to fully execute a quest’s life cycle. Now, we
    need to collect those pesky key pieces!
  prefs: []
  type: TYPE_NORMAL
- en: Collecting keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve tackled player collectible items a few different ways now, so collectible
    key items will be a familiar concept. The only difference is that we will now
    rely on `EventSystem` to trigger a *key collected* event. As we already know,
    the `CollectKeysQuest` quest is listening for `OnKeyCollected` being invoked,
    so this is where we’ll implement triggering it.
  prefs: []
  type: TYPE_NORMAL
- en: As you could probably also guess, we’re going to use a `Prefab` object for the
    puzzle piece keys (via **Prefab Variant**). So, that will require a component
    to implement the key collection behavior.
  prefs: []
  type: TYPE_NORMAL
- en: KeyItem component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let’s prepare the artwork we’ll use to make the collectible key pieces.
    For a visual reference, here’s what we’ll be working with for creating the key
    pieces and a placeholder security puzzle lock on the habitat entryway door (if
    it makes you nervous, try disregarding the encroaching plant entity’s vines):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Key variants and entryway security puzzle lock](img/B18347_09_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Key variants and entryway security puzzle lock
  prefs: []
  type: TYPE_NORMAL
- en: Art assets
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along while using the same artwork that was created for this project,
    download the assets from this book’s GitHub repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the art assets for the security puzzle lock, the puzzle placeholder
    image, and the individual key pieces into `Assets/Sprites/Puzzle`. For the provided
    key pieces artwork, I’ve set the following properties for the desired size and
    placement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`500`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X` and `Y` values so that the pivot is located in the center of the art:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Key pieces art – import settings](img/B18347_09_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Key pieces art – import settings
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s write the code for the collectible key item so that we’ll be ready
    to assemble the Prefabs for each key piece.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new script named `KeyItem` in the `Assets/Scripts` folder with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, yes – there is where we specifically trigger the `OnKeyCollected` event!
  prefs: []
  type: TYPE_NORMAL
- en: This script for collecting items may be even more straightforward than the ones
    that came before it. We use `OnTriggerEnter2D()` to detect when the player enters
    the trigger volume. Does this mean we need a collider component as a sibling on
    the GameObject to which we attach the `KeyItem` script? Yes, that’s right – we
    need a `Collider2D` object with `CircleCollider2D`, keeping it nice and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that we’re comparing the tag of the collision object – using our
    `Tags.Player` constant – to ensure that only the player interacts with the trigger
    volume.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s give the event system `TriggerEvent()` call some additional attention
    because our event system requires a second parameter to be passed in as an event
    argument. We have to pass in *something*.
  prefs: []
  type: TYPE_NORMAL
- en: As explained when the handler method was introduced, a bool value is the smallest
    data type in C# (1 byte); we’ll pass in `false` as the type’s value – we can also
    take the liberty of this meaning, “*True or false, will I pass an argument value
    for this event? False.*” We don’t even need to specify the `bool` type – as in
    `TriggerEvent<bool>()` – because the type can be inferred from the argument’s
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we’ll destroy the key piece object because we collected it and no longer
    need it in the level. We’re just using `Destroy(gameObject)` directly here for
    brevity. Still, for consistency, if you’d like, you should be able to hook up
    the reusable `Destroyer` component for yourself by now (challenge accepted?).
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to construct the collectible key item Prefab!
  prefs: []
  type: TYPE_NORMAL
- en: KeyItem Prefab and variants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating Prefabs for reusable items in our project is second nature by now.
    Let’s breeze through the steps to create a new collectible key item **Prefab**;
    then, we’ll make **variants** that have all three key pieces and their individual
    artwork:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `key1` Sprite (which we previously imported) from the `Assets/Sprites/Puzzle`
    folder in the **Project** window into the **Scene Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click it to focus on it in the `(0, 0, 0)` if not, **Reset** the **Transform**
    option in the **Inspector** view so that it is – we don’t want any offsets being
    saved in the Prefab).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `key1` to simply `key` (while selected at the top of the **Inspector**
    view, click it a second time, or use the *F2*/*Enter* key) – this will make sense
    later when we create the additional key variants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it and select `Key1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `CircleCollider2D` sibling component to the `Key1` object and enable **Is
    Trigger**. Set the **Radius** value so that its hitbox is slightly larger than
    the puzzle piece Sprite (refer to *Figure 9**.10*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `KeyItem` script to the parent `Key1` object – there’s nothing to configure;
    all the behavior is handled in code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `Key1` from the `Assets/Prefabs` folder in the **Project** window to make
    it a Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to create the additional key piece Prefabs as Prefab variants, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `Key1` in the **Hierarchy** and press *Ctrl*/*Cmd* + *D* twice to make
    two duplicates of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the duplicates `Key2` and `Key3`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Key2`, on the child key object, change the `SpriteRenderer` `key2`. Then,
    do the same for `Key3`, and set the `key3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `Key2` from the `Assets/Prefabs` folder. Then, in the `Key1` Prefab but
    override the `Key3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip | Prefab Edit Mode | Variants
  prefs: []
  type: TYPE_NORMAL
- en: Note that when opening **Prefab Variant** in **Prefab Edit Mode**, all overrides
    are indicated by a blue indicator along the left edge of the **Inspector** view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key Prefabs and variants we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – KeyItem pieces Prefabs](img/B18347_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – KeyItem pieces Prefabs
  prefs: []
  type: TYPE_NORMAL
- en: The player can now collect the key pieces to complete the quest, but how should
    we place them in the level? First things first, delete the `Key1`, `Key2`, and
    `Key3` objects from the scene; we’re going to spawn them in.
  prefs: []
  type: TYPE_NORMAL
- en: QuestSystem | Complete code
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the complete code for the **QuestSystem** class and all the quest-related
    code in this chapter, visit this book’s GitHub repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/).'
  prefs: []
  type: TYPE_NORMAL
- en: Key instantiator – Randomness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s explore an easy way to implement some basic random instantiation of objects
    so that the game is different every time it’s played – addressing replayability
    is good for player engagement!
  prefs: []
  type: TYPE_NORMAL
- en: Randomness in game design
  prefs: []
  type: TYPE_NORMAL
- en: You’ll come across the topic of randomness in games in your game development
    journey – and not just for card games! The role of randomness in game design is
    appropriate for this entire chapter – heck, this entire book! So, keeping that
    in mind, this will be one of the most basic examples of how you can add randomness
    to a simple mechanic with effective results. In the level design, we will instantiate
    the three keys at random locations identified by a larger number of spawn points.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the code will be to take an array of `KeyItem` (objects) (that
    is, the key pieces) and an array of `Transform` (positions) (that is, points placed
    throughout the level) as input and then output (that is, instantiate) the objects
    in order at the next randomly selected spawn point (being sure not to reuse any
    of the spawn points).
  prefs: []
  type: TYPE_NORMAL
- en: Did you visualize what the code could look like? Let’s see. Let’s walk through
    creating the code for each part.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new script named `KeyInstantiator` in the `Assets/Scripts`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll declare the arrays that hold the key objects and the spawn points first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declared two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KeyItem[] _keyPrefabs`: This has been serialized so that it can be assigned
    in the `KeyItem` instead of a more generic `GameObject` because of the following
    reasons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We only want Prefabs that include the `KeyItem` component to be assignable to
    the array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While referencing an item in the collection, we will consume the item as the
    `KeyItem` type and avoid making a `GetComponent<KeyItem>()` call.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Transform[] _spawnPoints`; This has been serialized so that it can be assigned
    in the **Inspector** view; we’ll assign the GameObjects that are placed throughout
    the level where key pieces can potentially spawn. With game design in mind, be
    sure to place more than three in a level so that we’re not just randomizing what
    key piece appears at the same three positions – your limit will be the design
    or your level (and I’d be sure to place one of them where you happen to have several
    infected robots patrolling).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array (C#)
  prefs: []
  type: TYPE_NORMAL
- en: An array is a type that’s declared with opposing square braces (**[]**) and
    represents a collection of items of that type. Items in the array are addressed
    by their index value, which starts at zero (for example, **_spawnPoints[0]** is
    the first **Transform** stored in the collection).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some additional reading: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add a `List` type to work with the currently available spawn points
    from the `_spawnPoints` array. Why are we doing this? We already have an `array`
    type, and now a `List` type? Yes. Arrays in C# are not easy to work with if we
    want to resize them (that is, remove an item), but a `List` type is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the following `List` type and add the `Start()` method with the spawn
    points assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared a `List` type and initialized it in `Start()` with the `_spawnPoints`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<Transform> _availablePoints`: This is the `private` member variable because
    we’ll just work with the points inside the class. We’ll use this to determine
    the points available to instantiate a key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Start()`: We’ll scatter the key pieces throughout the level when the game
    starts… so we’ll use the `MonoBehaviour`-provided Unity message event `Start()`
    for that, yeah.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now comes the fun part – random position instantiation! Add the following `foreach`
    loop to the `Start()` method’s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let’s do a breakdown of this final section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`foreach (var item in _keyPrefabs)`: We’re using `foreach` to iterate the available
    `KeyItem` Prefabs assigned in the **Inspector** view (all three of our key Prefab/variant
    pieces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Random.Range(0, _availablePoints.Count)`: A bit of magic? No, this is Unity’s
    `int` values, however, like in our use case; otherwise, it’s inclusive of the
    second number when using `float` values). We don’t want to use the `Count` value
    because array indexes are zero-based (so we’d have to specify `Count -` `1` otherwise):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we obtain `_availablePoints.Count` every iteration. That’s because,
    only two lines below, we’re removing the randomly selected point from `List` by
    the `randomIndex` value that’s returned, so it’s not used again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Random.Range()**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '`Instantiate()`: We spawn the current `item` in the array into the scene at
    the randomly selected spawn point position, `randomIndex`, with zero rotation
    (that is, `Quaternion.Identity`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveAt(ramdomIndex)`: A C# `List` type provides a remove method that not
    only deletes an item from the collection but also resizes it. Hence, the `Count`
    property reflects the number of items that remain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sounds like a lot when breaking it down like this, but it’s a short and sweet
    random placement script.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is, of course, setting the instantiator up in our scene so that
    the key pieces can be placed in the game level.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiator scene object setup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s what we’ll do to set up the new `KeyInstantiator` script on an object
    in our scene so that our keys are randomly spawned for the player to find:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `KeyInstantiator` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Assets/Prefabs` folder in the **Project** window to the **KeyPrefabs**
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, after placing – more than three! – GameObjects in the level that represent
    the possible spawn position of a key piece, select them in the **Hierarchy** and
    drag them to the **SpawnPoints** field in the **Inspector** view (don’t forget
    that you can lock the **Inspector** window so that it doesn’t change when you’re
    selecting the objects you want to assign).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 9**.11* shows the result of the preceding steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Key instantiator object setup](img/B18347_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Key instantiator object setup
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the pink diamonds in the preceding figure. I’ve assigned
    a pink diamond icon (assignable at the top of the **Inspector** view) to the key
    spawn point objects so that they are easy to find in the **Scene** view while
    I’m working on the level design. I’ve also grouped the key spawn points under
    a parent **Key Spawn Points** object in the **Hierarchy**.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we now have key pieces randomly placed in our level when the game
    starts. Next, we’ll sort out a drawing issue before moving on to solving the key
    puzzle!
  prefs: []
  type: TYPE_NORMAL
- en: Instantiated Sprite drawing order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The key pieces will be instantiated on the `Default` `0` for the default values.
    Because we’ve set up our environment with *default objects* originating “in the
    center of the depth layers,” we can be confident that the instantiated pieces
    will not be obstructed. This can be compensated for when instantiated if needed,
    but this can simply be avoided if we take some care in the environment layout.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a quest system, make new quests with
    unique properties and requirements for completion, assign a quest to the player,
    and query a quest’s status to advance the gameplay. We also saw how to utilize
    the event system to build other systems on top of its foundation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll integrate a sliding puzzle as the habitat entryway’s
    security lock system, where solving it wins the game.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the key puzzle and winning the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could spend a whole lot of time here designing a novel puzzle for the security
    lock system. Still, that falls outside the scope of this book and would not provide
    the learning opportunity I want to cover – that is, using third-party assets in
    your game. This isn’t to say that you shouldn’t strive to introduce a new and
    original idea in your game – any way you can differentiate your game and offer
    players a remarkable and unique experience is time well spent!
  prefs: []
  type: TYPE_NORMAL
- en: We will use the well-known sliding tile puzzle for the habitat entryway’s security
    puzzle lock.
  prefs: []
  type: TYPE_NORMAL
- en: Sliding tile puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve only briefly mentioned the **Unity Asset Store**, but I want to bring some
    well-deserved attention to it now. The Unity Asset Store contains a wealth of
    assets that both Unity and third parties provide. You can find just about anything
    you would need for your games, including pre-made systems, frameworks, characters,
    animations, 2D and 3D art assets, music and sound effects, VFX, and more, in almost
    every genre and style you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: However, integrating solutions and assets from varying vendors isn’t always
    trivial. This section will be dedicated to both the value of leveraging existing
    pre-made assets and identifying some issues you may need to work through to have
    them functioning in your project. You may be thinking that I’ve alluded to a level
    of quality for third-party assets that indicates they are not good – while that
    may be true in some rare cases (buyer beware, as usual), issues can arise that
    have nothing to do with the asset and all to do with the changes and advances
    in technologies that comes with newer Unity version releases. Rather than continuing
    in abstract terms, let’s move forward with the specific example I’ll provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, here is the sliding tile puzzle we’ll create with the tiles
    already scrambled (refer to *Figure 9**.3* for the unscrambled version):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Sliding puzzle scrambled tiles](img/B18347_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Sliding puzzle scrambled tiles
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, we’re going to leverage an existing asset from the
    Unity Asset Store to rapidly incorporate a sliding puzzle feature that will include
    everything necessary to slice an image into tiles, scramble the tiles, respond
    to user input for sliding the tiles, and calculate when the puzzle has been solved.
    If we had to develop on our own, all of these requirements would take significantly
    more time to create, code, debug, and test. Unity Asset Store assets generally
    come with the benefit of dozens of developers (or hundreds in some cases) using
    the assets in their projects and reporting back bugs and discrepancies to the
    asset developer for further improvement – and you directly benefit from others’
    efforts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, we’ll be using a free asset called **Sliding Tile Puzzle
    Game** by Hyper Luminal Games ([https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798](https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Sliding Tile Puzzle Game](img/B18347_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Sliding Tile Puzzle Game
  prefs: []
  type: TYPE_NORMAL
- en: Several steps will be required to use the asset in our Unity 2022 project due
    to changes in the **Unity Scripting API**, in addition to changes required to
    support **Universal RP** (**URP**), the *render pipeline* we’ve based the project
    on, since the time the asset was released (way back in 2016, for Unity 5).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by obtaining the asset and importing it into the project.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the sliding tile puzzle asset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After going through the process of purchasing an asset or clicking **Add to
    My Assets**, you have the option of using the **Open in Unity** button from within
    the Unity Asset Store. Alternatively, you may open the **Package Manager** window
    in the Unity Editor, select **My Assets** from the **Packages** dropdown, find
    the asset in the list, click **Download**, and then click **Import**.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, most assets are designed to be imported into your existing
    project. Still, some assets are provided as *complete projects* and, therefore,
    cannot be imported directly into your project. The sliding tile puzzle asset requires
    an additional step to import into your project because it is provided as a complete
    project, and it’s best not to overwrite any of your current project settings!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through the steps; this won’t take long:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Importing the sliding tile puzzle asset from the **Asset Store** page or **Package
    Manager** will produce the following **Importing a complete project** warning
    dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The Importing complete project dialog](img/B18347_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – The Importing complete project dialog
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Switch Project** button to create a temporary project the asset
    will be imported into. Unity will automatically generate a temporary project name.
    We’ll delete this project when we’re finished extracting the asset from it, so
    don’t worry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When Unity has opened and everything has finished importing, the `Assets/HyperLuminal`
    folder (found in the **Project** window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `SlidingTilePuzzle` folder and select **Export Package…**.
    This will open an **Exporting package** dialog, where you can change what’s included
    in the export. We want everything, so click the **Export…** button in the bottom-right
    corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the file save window opens, enter `SlidingTilePuzzle` for the `.unitypackage`
    filename and pick an easily accessible folder; we will be importing from that
    same folder shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Close Unity. You will be prompted with a **Keep Project?** dialog. You can
    safely click the **Forget** button since we no longer need it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that even though you confirmed forgetting it, you may still see an erroneous
    project show up in Unity Hub that represents this temporary project. If so, remove
    it and delete the project folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, back in our game’s project, let’s import the saved `.unitypackage` file
    by going to `SlidingTilePuzzle.unitypackage` from the location we saved it in
    earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The Import Unity Package dialog](img/B18347_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The Import Unity Package dialog
  prefs: []
  type: TYPE_NORMAL
- en: All the items should be marked as **New** unless we’ve previously imported the
    package. Go ahead and click **Import** so that we can continue integrating the
    sliding puzzle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip | Project organization
  prefs: []
  type: TYPE_NORMAL
- en: Asset vendors make their own choices on the location of their assets in the
    project folder structure, so importing many third-party assets can get a bit messy
    and unorganized. To maintain some level of sanity in your project files, I suggest
    placing all third-party assets under this **Assets/Third** **Party** folder.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in *Figure 9**.15*, you can see *SlidingTilePuzzle*, which we will
    import to the **Assets/HyperLuminal** folder. Please create a new **Assets/Third
    Party** folder and move the **HyperLuminal** folder as a child of it. Mischief
    managed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s update the asset so that it works with our Unity 2022 project requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the puzzle tile shader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first order of business is to update from the built-in legacy renderer to
    the URP renderer. In Unity 5, we only had the built-in renderer, so it makes sense
    that we’d need to convert items related to the render for this asset.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to open the `SlidingTilePuzzle` example scene in the `Assets/Third
    Party/HyperLuminal/SlidingTilePuzzle/Scenes` folder and enter **Play Mode** now,
    you’d get a giant pink square. Pink (or magenta) is the color Unity uses to represent
    a material or shader error – unless you’ve specifically made an object this color,
    seeing it in your **Scene** or **Game** view is generally not good.
  prefs: []
  type: TYPE_NORMAL
- en: 'The asset takes a Prefab approach for the type of sliding puzzle you want to
    make and provides Prefabs for `3x3`, `4x4`, and `5x5` sliding puzzles – we will
    make a 3x3 sliding puzzle and work with that specific `3x3` Prefab. Follow these
    steps to update the renderer-specific issues:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs` folder, duplicate
    the `SlidingTile_3by3` Prefab and rename it `SlidingTile_3by3_URP`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `SlidingTile_3by3_URP` to enter **Prefab** **Edit Mode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `ST_Puzzle Display` component and change the *Puzzle Shader* from `Mobile/Unlit`
    to `Packages/Universal RP/Shaders/2D/Sprite-Unlit-Default` – you must drag this
    shader in from the `Packages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have one more update to make for the renderer issues, and that’s on the
    puzzle tile itself, but first, we need a new **Universal RP Sprite** material.
    Follow these steps to update the asset:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new *material* named `PuzzleTile 1` in the `Assets/Materials` folder
    and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Shader** drop-down menu at the top of the **Inspector** view, select
    the **Universal Render** **Pipeline/2D/Sprite-Unlit-Default** shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs` folder, we
    also have the `SlideTile` Prefab. Duplicate it and rename it `SlideTile_URP`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `SlideTile_URP` to enter **Prefab** **Edit Mode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `MeshRenderer` component and change `Element 0` to `PuzzleTile 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the rendering issues of the `Sliding Tile Puzzle` asset have been updated,
    we are ready to work within our **Lit 2D (****URP)** scenes!
  prefs: []
  type: TYPE_NORMAL
- en: We only have one more issue with updating, and that’s for the interactivity
    – that is, being able to slide the tiles from player input.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the input system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new input system is called new because… well, it’s new. Unity 5 only had
    the legacy `InputManager` system; of course, since we’re using the new input system
    in our project, we need to make some changes to support it. All the updates for
    the renderer were done in the editor, but now, we’ll have to change some code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the `ST_PuzzleTile` script in the `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts`
    folder and open it in your IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new `using` statement at the top of the script. We’ll need this `UnityEngine`
    namespace to support the code changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `IPointerClickHandler` interface to the class definition to support
    the new input system’s `pointer` `click` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of the script, replace `void OnMouseDown()` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script and return to the Unity Editor; you’re done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, you can no longer test the sliding puzzle using the vendor’s
    `SlidingTilePuzzle` example scene as-is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the updates and the final update requirements for every scene you want
    to use the sliding puzzle in, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene (**File** | **New Scene** or *Ctrl*/*Cmd* + *N*) and select
    the **Lit 2D (URP)** new scene template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `PhysicsRaycaster` component to **Main Camera**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `UI Event System` to the scene. Ensure you update the `StandaloneInputModule`
    component for the new input system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `SlidingTile_3by3_URP` Prefab to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **Play Mode**. Test. Enjoy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And that completes all the updates required to modernize *Sliding Tile Puzzle*
    for the URP render and the new input system. Not too bad.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see, the Unity Asset Store is a great resource with many talented
    asset publishers. It can help to save you (a lot of) time building game prototypes
    quickly, polishing your games, and creating vertical slices early (for seeking
    a publisher or investors in your project).
  prefs: []
  type: TYPE_NORMAL
- en: We will, however, need one additional change to integrate the sliding puzzle
    into our gameplay. And that is adding an event for when the security puzzle lock
    has been solved so that we can trigger an appropriate action – a logical one at
    this point would be granting the player access to the habitat station. Open sesame!
  prefs: []
  type: TYPE_NORMAL
- en: Adding an event for completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We won’t be covering any new ground with this task. We’ve added events in several
    different ways already. Our choice this time will be a `UnityEvent` event so that
    we can set the triggered handlers in the **Inspector** view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `ST_PuzzleDisplay` script in the `Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts`
    folder and open it in your IDE. Then, modify the script with the following additions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `using` statement at the top of the script as required for declaring
    our event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `public` `UnityEvent` event to be triggered when the puzzle is completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `CheckForComplete()` method by adding the `OnPuzzleComplete` invocation
    line within the `if(Complete)` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have a convenient way to respond to the entryway security puzzle lock
    being solved/completed.
  prefs: []
  type: TYPE_NORMAL
- en: When we set up the `QuestHasCompleted` component on the habitat entryway, we
    left unfinished business for our future selves. We are now our future selves,
    so we can complete the `OnQuestComplete` event assignment and show our security
    puzzle lock to the player.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new puzzle prefab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yup, that’s right – we’ll need another Prefab for the sliding puzzle lock. We’ll
    set that up now so that it’s shown to the player – with our image – when all three
    keys have been collected and they reach the habitat entryway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create the new Prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `SlidingTile_3by3_URP` Prefab into the `0,` `0, 0`)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it and select `Key Puzzle Lock` – you’ll end up with the actual
    puzzle as the child (yes, this is our standard approach to Prefab structure, if
    you still weren’t sure).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `key_puzzle1-complete_512` image in the `Assets/Sprites/Puzzle` folder
    (this is one of the images we imported in the previous *KeyItem component* section)
    and change its import settings in the `512`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `ST_PuzzleDisplay` component and assign the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Puzzle* *Image*: `key_puzzle1-complete_512`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Puzzle Scale*: `0.7`, `0.7`, `0.7`:![Figure 9.16 – Sliding puzzle configuration](img/B18347_09_16.jpg)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.16 – Sliding puzzle configuration
  prefs: []
  type: TYPE_NORMAL
- en: Now, disable the `SlidingTile_3by3_URP` object. Yes, you heard that right; we’re
    going to disable the object with the `ST_PuzzleDisplay` component on it because
    we only want the puzzle to show and do its trick when it’s triggered by the player
    reaching the habitat entryway with all three keys collected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Assets/Prefabs` folder to create the puzzle lock Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have our customized security puzzle lock ready to go! The final setup
    ensures it shows in place when required at the habitat entryway location.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the puzzle lock to the entryway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already set up our **Puzzle Trigger** at the location of the habitat entryway.
    Now, let’s add the security puzzle lock to its location so that it shows and is
    interactable in place at the entryway door. With everything already set up and
    ready to go, it’s a simple two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Position the **Key Puzzle Lock** Prefab in the level nearby, slightly above,
    or right at the habitat entryway door. You can reference *Figure 9**.12* for where
    I placed it: at the door and just above the player character’s head.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Show the sliding puzzle from the `QuestHasCompleted` component’s `OnQuestComplete()`
    event by doing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new entry for `OnQuestComplete()` as an additional action to `PlayerInput.enabled`
    by clicking the little plus (`SlidingTile_3by3_URP` child object of `GameObject`
    | `SetActive(bool)` from the function dropdown, and tick the checkbox to pass
    `true`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it! You can now fully test the quest life cycle, collect three keys scattered
    throughout the level to complete the quest, trigger an event for a completed quest,
    and solve an in-game sliding puzzle. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: All that remains is what we need to do when beating the entryway puzzle lock
    – that is, winning.
  prefs: []
  type: TYPE_NORMAL
- en: Winning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the security puzzle lock is solved, we gain entry to the habitat station.
    The `OnPuzzleComplete()` `UnityEvent` event we just added to the `Sliding Tile
    Puzzle Game` code gets triggered, so this is our opportunity to do something for
    a win state.
  prefs: []
  type: TYPE_NORMAL
- en: My game design plan, and plan for this book’s projects, is to continue gameplay
    within the habitat station interior in [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187),
    where things will start having more depth. I don’t mean that figuratively; the
    project the next chapter introduces will be a 3D **first-person shooter** (**FPS**)
    game. For now, we’ll implement a nice cinematic fade to black and *To be continued…*.
    But how do we solve the problem of implementing a fade-out and on-screen text
    sequence without figuring out a bunch of synchronized linear timing code? Let’s
    see.
  prefs: []
  type: TYPE_NORMAL
- en: Timeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Timeline** is not a new feature in Unity 2022\. It’s been around since Unity
    2017, but I feel it’s an underrated core feature that doesn’t get nearly the attention
    it deserves for game developers. For cinematic content creators, however, it was
    a game changer since Timeline allows the easy creation of linear sequences affecting
    almost any object in the scene.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Timeline is based on two elements that work in tandem: a **Timeline** file-based
    asset and a **Playable Director** component. An important thing to note is that
    a Timeline instance is scene-based.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Timeline: [https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will leverage the pure power of Timeline’s simplicity to affect a set of
    objects linearly to knock out this ending fade-out. Let’s start by creating our
    Timeline instance:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a location in our project to store Timeline assets. Create a new
    folder called `Assets/Timelines`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Staying within the `Ending Timeline` by right-clicking and choosing **Create**
    | **Timeline**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now open the **Timeline** window by double-clicking the **Ending Timeline**
    asset in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re not used to working in a timescale of **Frames**, use the gear icon
    in the top-right corner of the **Timeline** window to select **Seconds** (as seen
    in *Figure 9**.17*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish the Timeline creation by dragging the **Ending Timeline** asset into
    the **Scene Hierarchy** to make the scene-based instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll use just two UI widgets to achieve the fade-out effect and title while
    following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Canvas` component to the root of the `Image` component to fill the screen.
    We don’t need an image per se; just the default **Background** sprite will do
    nicely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click `RectTransform`: `400`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TextMeshPro – Text (UI)`: `To` `be continued…`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, we’ll bring these UI widgets into Timeline to set up the sequence.
    Follow these steps to add the widgets and define their respective sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that **Ending Timeline** is viewable in the **Timeline** window. If the
    **Timeline** window is not open, you can open it from **Window** | **Sequencing**
    | **Timeline**, then click on the **Endling Timeline** instance in the hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag `Image` `0` (transparent) to `255` (opaque) over 1.5 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the red *Start recording* circle button on the `000000`) with `0` to set
    the first keyframe.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scrub `255` to set the second keyframe.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop recording.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Text (TMP)** into the **Track List** section of the **Timeline** window
    and select **Add Activation Track** when prompted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the text to show a heartbeat after the fade has completed, so drag the
    **Active** clip to the right in the timeline to 1.8 seconds. The GameObject for
    the **Text (TMP)** binding will only be active within the range of the clip in
    the timeline and deactivated outside of it. We’re done with the text. Easy-peasy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To preview the results of the timeline sequence in the **Game** view, click
    the **Play** button or press the spacebar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Timeline ending fade out title](img/B18347_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Timeline ending fade out title
  prefs: []
  type: TYPE_NORMAL
- en: If you enter `PlayableDirector` component was added to the Timeline instance
    when we dragged it into the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `PlayableDirector` component values in the **Inspector** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayOnAwake` = `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WrapMode` = `Hold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also want to ensure the UI widgets don’t have a visible state at design
    time in the editor. That way, they are not shown until we trigger the Timeline
    to play. Make the following changes to the UI widget values in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: For the UI `Image` `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the UI **Text (TMP)** object, deactivate the object (untick the checkbox
    at the top of the **Inspector** view).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we already recorded the color values and active state in the Timeline,
    we can safely set these values in the scene without affecting their sequenced
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do now is to activate our ending sequence when the sliding
    puzzle is complete. Find the `SlidingTile_3by3_URP` object in the hierarchy and,
    on the `ST_PuzzleDisplay` component, add an action to `OnPuzzleComplete: Runtime
    Only`, `PlayableDirector.Play()`.'
  prefs: []
  type: TYPE_NORMAL
- en: To be continued – or end of Act I, whichever you decide. Either way, this was
    just the equivalent of a tip-of-the-iceberg introduction to Timeline – it is an
    extremely powerful cutscenes, cinematics, and gameplay or audio sequences tool!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to bring a third-party asset in from the Unity
    Asset Store, resolved to update the asset for use in Unity 2022, and extended
    the vendor-provided code with our own to trigger an event. You also received an
    introduction to Unity’s Timeline feature and created a simple but effective cinematic
    fade to black.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create an efficient and convenient global
    event system to build out a quest system with components made in a flexible, scalable,
    and more maintainable way than with directly coupled classes. You also learned
    how to create a specific quest with unique requirements needing to be met before
    setting the quest state as completed while also learning how to introduce randomness
    for collecting required items.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by learning how to import a third-party sliding puzzle asset from
    the Unity Asset Store and upgrade it for compatibility with Unity 2022 and the
    URP renderer while also extending upon the code to integrate it into our game
    code. We finished solving the security puzzle lock and winning the game with a
    cinematic Timeline sequence for fading to black.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll create a 3D FPS to continue the 2D adventure game
    directly. We will pick up right where we left off and enter the interior habitat
    environment, where we will learn about gray boxing to flesh out a playable 3D-level
    design with **ProBuilder** rapidly. We’ll also leverage another asset from the
    Unity Asset Store – but this time one provided directly by Unity – for our FPS
    character controller. We’ll also look at code reuse by converting some of our
    existing 2D components for use in 3D.
  prefs: []
  type: TYPE_NORMAL
