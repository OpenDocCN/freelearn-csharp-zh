<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-216"><a id="_idTextAnchor226"/>9</h1>
<h1 id="_idParaDest-217"><a id="_idTextAnchor227"/>Building an Appointment Booking App with Entity Framework and Relational DB</h1>
<p>In the previous chapter, we outlined the technical specifications and design decisions for building an appointment booking system for a barber’s salon called Heads Up Barbers. This chapter is a continuation of <a href="B18370_08_RN.xhtml#_idTextAnchor209"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing an Appointment Booking App</em>, so I strongly advise you to be familiar with what was covered in that chapter first.</p>
<p>This chapter will implement the requirements in TDD style and will use <strong class="bold">Entity Framework</strong> (<strong class="bold">EF</strong>) and SQL Server. The implementation will be applicable to other <strong class="bold">Relational Database Management Systems</strong> (<strong class="bold">RDBMSs</strong>) such as Oracle DB, MySQL, PostgreSQL, and others.</p>
<p>If you are a fan of relational DBs or you are using one at work, then this chapter is for you, whereas if you are using a document database, then you might want to skip this chapter and go to the next one. Both chapters, <a href="B18370_09.xhtml#_idTextAnchor226"><em class="italic">Chapter 9</em></a> and <a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a>, have the same outcome, but they use different types of backend databases.</p>
<p>I assume you are familiar with EF and how it is wired and used. However, if you are not, then I encourage you to familiarize yourself with it first.</p>
<p>In this chapter, we will cover:</p>
<ul>
<li>Planning the code and the project structure</li>
<li>Implementing the WebApis with TDD</li>
<li>Answering frequently asked questions</li>
</ul>
<p>By the end of the chapter, you will have experienced the implementation of an end-to-end app using TDD with mocks and fakes. Also, you will witness the analysis process that precedes writing unit tests.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor228"/>Technical requirements</h2>
<p>The code for this chapter can be found in the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch09">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch09</a></p>
<p>To run the project, you will need to have a flavor of SQL Server installed. This can be, Azure SQL, SQL Server Express LocalDB or any other SQL Server flavor.</p>
<p>The implementation doesn’t use any advanced SQL Server features, so feel free to use any. I have tested the application with SQL Server Express LocalDB. You can find more about it here:</p>
<p><a href="https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb">https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb</a></p>
<p>You can also use any other RDBMS, but you will have to change the DB provider in the code to use the specific .NET DB provider.</p>
<p>To run the project, you have to modify the connection string to your specific DB instance in <code>Uqs.AppointmentBooking.WebApi/AppSettings.json</code>. Currently, it is set to:</p>
<pre class="source-code">"ConnectionStrings": {
  "AppointmentBooking": "Data 
    Source=(localdb)\\ProjectModels;Initial     
    Catalog=AppointmentBooking;Integrated Security=True;…"
},</pre>
<p>The connection string is pointing to <code>LocalMachine</code> and will connect to a database called <code>AppointmentBooking</code>.</p>
<p>If you decided to use an alternative RDBMS, then you will have to install the relevant NuGet packages in <code>Uqs.AppointmentBooking.WebApi</code> and change the following code in <code>Program.cs</code> of the same project to your specific RDBMS:</p>
<pre class="source-code">builder.Services
    .AddDbContext&lt;ApplicationContext&gt;(options =&gt;
    options.UseSqlServer(
        builder.Configuration
          .GetConnectionString("AppointmentBooking")
    ));</pre>
<p>The previous DB configuration steps are optional. You can implement the requirements for this chapter without using a DB, but you won’t be able to run the project and interact with it in the browser.</p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor229"/>Planning your code and project structure</h1>
<p>In <a href="B18370_08_RN.xhtml#_idTextAnchor209"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing an Appointment Booking App</em>, we planned our <a id="_idIndexMarker675"/>domain and analyzed what we needed to do. The <a id="_idIndexMarker676"/>project architecture will follow the classical three-tier applications of the client application (the website), business logic (the web APIs), and database (SQL Server). Let’s translate this into VS solutions and projects.</p>
<p>In this section, we will create the solution, create the projects, and wire up the components.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor230"/>Analyzing the project’s structure</h2>
<p>Ask a group <a id="_idIndexMarker677"/>of senior developers to come up with a project structure, and you will end up with multiple structures! In this section, we will discuss a way of organizing your project structure that I have developed over the years.</p>
<p>Given that we are first going to build a website for the user and later a mobile app (not covered in this book), it makes sense to isolate the business logic to a WebApi project that can be shared by both the website and the mobile app. So, we will build a website project based on Blazor WebAssembly called <code>Uqs.AppointmentBooking.Website</code>.</p>
<p>The domain logic will be exposed as APIs, so we will create an ASP.NET API project for the APIs called <code>Uqs.AppointmentBooking.WebApi</code>. </p>
<p>The previous two projects need to exchange data in an agreed structure called <code>Uqs.AppointmentBooking.Contracts</code>. This project will be referenced by both the website and the WebApi projects.</p>
<p>The WebApi project<a id="_idIndexMarker680"/> translates web requests into something we can understand in C#. In technical terms, this will manage the HTTP communication layer with RESTful-style APIs. So, the WebApi project will not contain business logic. The business logic will be in our domain project. We will create a domain project called <code>Uqs.AppointmentBooking.Domain</code>.</p>
<p>Your business logic will live in two places – the UI and the domain layer. The UI business logic will manage UI functionalities such as toggling dropdowns, blocking calendar days, responding to drag and drop, and disabling/enabling buttons, among others. This logic will live in the website project. The language used in writing the code depends on the UI framework in use, such as Angular, React, and Blazor. Usually, you do not implement the features of the UI project using TDD, but you can use unit tests. In our implementation, we will have little code in the UI layer, so we will not be doing any UI unit tests.  </p>
<p>The<a id="_idIndexMarker681"/> sophisticated business logic will live in the domain layer, and we will be writing it following the concepts of TDD. So, we shall create a project that will hold our domain unit tests and call it <code>Uqs.AppointmentBooking.Domain.Tests.Unit</code>.</p>
<p>To put these projects into perspective and map them to our 3-tier architecture, we can have the following diagram:</p>
<div><div><img alt="Figure 9.1 – The relationship between the projects and the application design " height="577" src="img/Figure_9.1_B18370.jpg" width="1212"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The relationship between the projects and the application design</p>
<p>The <a id="_idIndexMarker682"/>previous diagram shows the functionality that each project provides to form the 3-tier application. Let’s start by creating the VS solution structure.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor231"/>Creating projects and configuring dependencies</h2>
<p>This is the <a id="_idIndexMarker683"/>unavoidable boring part, creating the solution and projects and linking them together. In the following section, we will take the command-line approach rather than the UI approach.</p>
<p class="callout-heading">Note</p>
<p class="callout">I have added a text file called <code>create-projects.bat</code> to the project source control that contains all the command lines, so you don’t have to manually write them. You can copy and paste this file to your desired directory and then, from your command line, execute the file.</p>
<p>The following is a list of the commands required to create your VS solution and its projects:</p>
<ul>
<li>From your OS console, navigate to the directory where you want to create your new solution and execute the following to create the solution file:<pre><strong class="bold">md UqsAppointmentBooking</strong>
<strong class="bold">cd UqsAppointmentBooking</strong>
<strong class="bold">dotnet new sln</strong></pre></li>
<li>Execute this to create the projects and notice that we are using a different template for each project:<pre><strong class="bold">dotnet new blazorwasm -n Uqs.AppointmentBooking.Website</strong>
<strong class="bold">dotnet new webapi -n Uqs.AppointmentBooking.WebApi</strong>
<strong class="bold">dotnet new classlib -n Uqs.AppointmentBooking.Contract</strong>
<strong class="bold">dotnet new classlib -n Uqs.AppointmentBooking.Domain</strong>
<strong class="bold">dotnet new xunit -n </strong>
<strong class="bold">  Uqs.AppointmentBooking.Domain.Tests.Unit</strong></pre></li>
<li>Add the projects to the solution:<pre><strong class="bold">dotnet sln add Uqs.AppointmentBooking.Website</strong>
<strong class="bold">dotnet sln add Uqs.AppointmentBooking.WebApi</strong>
<strong class="bold">dotnet sln add Uqs.AppointmentBooking.Contract</strong>
<strong class="bold">dotnet sln add Uqs.AppointmentBooking.Domain</strong>
<strong class="bold">dotnet sln add Uqs.AppointmentBooking.Domain.Tests.Unit</strong></pre></li>
<li>Now let’s <a id="_idIndexMarker684"/>set up <a id="_idIndexMarker685"/>dependencies between the projects:<pre><strong class="bold">dotnet add Uqs.AppointmentBooking.Website reference</strong>
<strong class="bold">  Uqs.AppointmentBooking.Contract</strong>
<strong class="bold">dotnet add Uqs.AppointmentBooking.WebApi reference</strong>
<strong class="bold">  Uqs.AppointmentBooking.Contract</strong>
<strong class="bold">dotnet add Uqs.AppointmentBooking.Domain reference</strong>
<strong class="bold">  Uqs.AppointmentBooking.Contract</strong>
<strong class="bold">dotnet add Uqs.AppointmentBooking.WebApi reference</strong>
<strong class="bold">  Uqs.AppointmentBooking.Domain</strong>
<strong class="bold">dotnet add Uqs.AppointmentBooking.Domain.Tests.Unit </strong>
<strong class="bold">  reference Uqs.AppointmentBooking.Domain</strong></pre></li>
</ul>
<p>And the last bit is adding the required NuGet packages to the project. The domain project will communicate with the SQL Server database using EF. The <code>Microsoft.EntityFrameworkCore.SqlServer</code> package allows the required libraries to connect the project to SQL Server. To add this library to the <code>Domain</code> project, use the following:</p>
<pre><strong class="bold">dotnet add Uqs.AppointmentBooking.Domain package </strong>
<strong class="bold">    Microsoft.EntityFrameworkCore.SqlServer</strong></pre>
<ul>
<li>The unit testing project will require <em class="italic">NSubstitute</em> for mocking, so let’s add its NuGet:<pre><strong class="bold">dotnet add Uqs.AppointmentBooking.Domain.Tests.Unit </strong>
<strong class="bold">    package NSubstitute</strong></pre></li>
<li>We will be using a fake to test double EF. This fake will create an in-memory database that will make our testing easier to write. We will discuss this in more detail later in this chapter, but for now, let’s add this fake library:<pre><strong class="bold">dotnet add Uqs.AppointmentBooking.Domain.Tests.Unit</strong>
<strong class="bold">    package Microsoft.EntityFrameworkCore.InMemory</strong></pre></li>
</ul>
<p>For visual inspection, you can <a id="_idIndexMarker686"/>open the solution file with VS, and it should look as such:</p>
<div><div><img alt="Figure 9.2 – A view of VS solution explorer " height="614" src="img/Figure_9.2_B18370.jpg" width="1010"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – A view of VS solution explorer</p>
<p>At this <a id="_idIndexMarker687"/>stage, your solution structure should look similar.</p>
<p>Now that the project structure is in place, we will modify the code.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor232"/>Setting up the domain project</h2>
<p>From the domain <a id="_idIndexMarker688"/>analysis in <a href="B18370_08_RN.xhtml#_idTextAnchor209"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing an Appointment Booking App</em>, we have created a list of the domain objects. I will not go through them again; I will just create and add them to the <code>Domain</code> project under <code>DomainObjects</code>:</p>
<div><div><img alt="Figure 9.3 – Added domain objects " height="484" src="img/Figure_9.3_B18370.jpg" width="807"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Added domain objects</p>
<p>These are just data structures with no business logic. Here is the source code of one of them, the <code>Customer</code> domain object:</p>
<pre class="source-code">namespace Uqs.AppointmentBooking.Domain.DomainObjects;
public class Customer
{
    public int Id { get; set; }
    public string? FirstName { get; set; }
    public string? LastName { get; set; }
}</pre>
<p>You can view<a id="_idIndexMarker689"/> the rest of the files in the chapter’s GitHub repo online.</p>
<p>Next is wiring up the focus of this chapter, EF.</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor233"/>Wiring up Entity Framework</h2>
<p>We are going to use<a id="_idIndexMarker690"/> EF to store each domain object in a database table that bears the same name but in the plural, as this is the default behavior of EF. So, the <code>Customer</code> domain object will have a <em class="italic">Customers</em> table equivalent in the DB.</p>
<p>We will not be customizing much in EF as our intention in this chapter is to focus on TDD, as doing the little setups here and there are only chores and you can find them in the companion code. </p>
<p>Under the <code>Domain</code> project, I <a id="_idIndexMarker691"/>have added a directory called <code>Database</code> to contain our EF-related classes. We will need two classes, the <code>ApplicationContext</code> class and the <code>SeedData</code> class:</p>
<div><div><img alt="Figure 9.4 – Added EF files " height="312" src="img/Figure_9.4_B18370.jpg" width="814"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Added EF files</p>
<p>In the next section, we will discuss their role.</p>
<h3>Adding the context class</h3>
<p>With EF, you add a context <a id="_idIndexMarker692"/>class to reference all your domain objects. I called my context class <code>ApplicationContext</code>, and I followed basic EF practices. Here is my class:</p>
<pre class="source-code">public class ApplicationContext : DbContext
{
    public ApplicationContext(
      DbContextOptions&lt;ApplicationContext&gt; options) :      
      base(options){}
    public DbSet&lt;Appointment&gt;? Appointments { get; set; }
    public DbSet&lt;Customer&gt;? Customers { get; set; }
    public DbSet&lt;Employee&gt;? Employees { get; set; }
    public DbSet&lt;Service&gt;? Services { get; set; }
    public DbSet&lt;Shift&gt;? Shifts { get; set; }
}</pre>
<p>This is the most basic setup of EF with no customization, with every property mapped to a database table name.</p>
<p>From this <a id="_idIndexMarker693"/>point onward, we will use <code>ApplicationContext</code> to execute operations on the DB.</p>
<p>Let’s continue with our process and set up EF within WebApi.</p>
<h3>Wiring up EF with the WebApi project</h3>
<p>The<a id="_idIndexMarker694"/> WebApi will wire EF to the right DB provider, which, in<a id="_idIndexMarker695"/> this case, is SQL Server, and will pass the connection string to EF at runtime.</p>
<p>So, the first step is to add the connection string to the WebApi’s <code>AppSettings.js</code>:</p>
<pre class="source-code">"ConnectionStrings": {
  "AppointmentBooking": "Data   
    Source=(localdb)\\ProjectModels;Initial    
    Catalog=AppointmentBooking;(…)"
},</pre>
<p>Obviously, the connection string may vary based on your DB location and setup.</p>
<p class="callout-heading">Note</p>
<p class="callout">In this chapter, I am not concerned with setting multiple environments, but you may want to create multiple <code>AppSettings</code> for different environments and change the connection string accordingly. </p>
<p>The next step is to wire up the WebApi with EF and provide it with the connection string. This should be done in <code>Program.cs</code>, preferably directly after the first line, <code>var CreateBuilder(args)</code>:</p>
<pre class="source-code">var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext&lt;ApplicationContext&gt;(o =&gt;   
  o.UseSqlServer(builder.Configuration.GetConnectionString
    ("AppointmentBooking")));</pre>
<p>This is what <a id="_idIndexMarker696"/>we need for wiring up EF. However, for<a id="_idIndexMarker697"/> development purposes, we might need some test data to fill the pages with some meaningful data. We shall do this next.</p>
<h3>Adding seed data</h3>
<p>Newly created DBs have empty<a id="_idIndexMarker698"/> tables, and the <code>seed</code> class is meant to pre-populate the tables with sample data.</p>
<p>I will not list the code here as it is outside the scope of the chapter, but you can look at the code in the <code>Domain</code> project in <code>Database/SeedData.cs</code>.</p>
<p>We’ve just finished the setup for the WebApi project, which is going to be consumed by the website, so let’s create the website next.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor234"/>Setting up the website project</h2>
<p>Phase one of this <a id="_idIndexMarker699"/>implementation includes creating a website to access the APIs to provide a UI for the user, which we did previously in this chapter by command line. However, website implementation is outside the scope of this chapter and the book in general, as it is not related to TDD, so I will not be going through the code.</p>
<p>Though, we are interested in one aspect – what does the website require from the web apis? We will need to understand this in order to build the required functionality in <code>WebApis</code> the TDD way.</p>
<p>We will answer this question bit by bit in the next section of this chapter.</p>
<p>In this section, we covered the setup and configuration aspect of the project, and we have not done anything that is affected by TDD. You may have noticed that I referred you to the companion source code on multiple occasions; otherwise, we would have no place left for the core of this chapter, the TDD part, which we will do next.</p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor235"/>Implementing the WebApis with TDD</h1>
<p>To build<a id="_idIndexMarker700"/> the WebApi project, we are going to look at<a id="_idIndexMarker701"/> each requirement from <a href="B18370_08_RN.xhtml#_idTextAnchor209"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing an Appointment Booking App</em>, and provide the implementation that satisfies it using TDD style.</p>
<p>The requirements are all stated in terms of the Website and its functionality, and they do not dictate how to build our APIs. The Website will have to call the WebApis for any business logic as it has no access to the DB and deals with UI-related business logic only.</p>
<p>This chapter is dedicated to <a id="_idIndexMarker702"/>EF for a good reason as we want you to appreciate <em class="italic">fakes</em>, which <a id="_idIndexMarker703"/>are not as popular as <em class="italic">mocks</em>, both from the test doubles family. Also, it will be a typical example of a .NET solution of an ASP.NET Core and a relational DB implementation.</p>
<p>In this section, we will cover working in TDD mode, taking into consideration our persistence provider, EF.</p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor236"/>Using the EF in-memory provider</h2>
<p>To make our<a id="_idIndexMarker704"/> life easier when unit<a id="_idIndexMarker705"/> testing the system, we want to abstract the database in an elegant way. When I say elegant, I mean less code and more readability.</p>
<p>However, the challenge we face when testing a system that has a DB is that we do not want to hit the real DB in our unit tests as this would defeat the whole purpose of unit testing and make it a sort of integration or Sintegration testing. Instead, we use test doubles to abstract it. A fake is <a id="_idIndexMarker706"/>a test double that replaces a component during unit testing with an equivalent component more suitable for testing purposes, we will be employing a fake to replace our DB for unit testing purposes.</p>
<p>EF has a provider that accesses SQL server, which is what we want to use in production during the system run, but in unit testing, we can’t do this. Lucky for us, EF has what is called an in-memory provider, which can build and destroy an in-memory database during each unit test run. </p>
<p>Building and destroying an in-memory DB during unit testing is cheap compared to doing the same for a physical DB, not to mention the cost and the possibility of random errors that are generated from trying to create and delete a real database so often (with each single unit test execution). As you might have already figured out, the EF in-memory provider acts as a fake.</p>
<p>During <a id="_idIndexMarker707"/>runtime, we use the SQL<a id="_idIndexMarker708"/> Server provider, and during unit testing, we use the in-memory provider, and we accomplish this switch via dependency injection:</p>
<div><div><img alt="Figure 9.5 – Runtime and test times with respect to EF providers " height="667" src="img/Figure_9.5_B18370.jpg" width="1200"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Runtime and test times with respect to EF providers</p>
<p>The previous diagram illustrates injecting different providers in different project stages. The unit testing stage will use the EF in-memory provider and in the production run stage, the proper production provider, EF SQL Server Provider, will be used.</p>
<h3>Configuring the in-memory provider</h3>
<p>To get the <a id="_idIndexMarker709"/>advantage of the in-memory provider, I have created a file in the unit tests project called <code>ApplicationContextFake.cs</code>, and here is the code:</p>
<pre class="source-code">public class ApplicationContextFake : ApplicationContext
{
    public ApplicationContextFake() : base(new 
        DbContextOptionsBuilder&lt;ApplicationContext&gt;()
        .UseInMemoryDatabase(databaseName:
        $"AppointmentBookingTest-{Guid.NewGuid()}")
        .Options) {}
}</pre>
<p>Note that we are inheriting the main EF object, <code>ApplicationContext</code>, and we configured the option to make it in-memory. <code>ApplicationContextFake</code> is meant to be injected whenever <code>ApplicationContext</code> is required in our unit tests.</p>
<p>We are <a id="_idIndexMarker710"/>creating a unique database name, <code>AppointmentBookingTest-{Guid.NewGuid()}</code>, by appending a GUID every time we instantiate the fake. The reason for this is that we don’t want the in-memory provider to have the same database name to avoid caching any data in between unit test calls.</p>
<p>From this point onward, every time we need to inject <code>ApplicationContext</code> in our unit tests, we will inject <code>ApplicationContextFake</code> instead.</p>
<h3>Adding sample test data using the builder pattern</h3>
<p>Every test <a id="_idIndexMarker711"/>that we are going to implement will have a state. For example, we might have a single free barber or a group of barbers with different schedules, so creating sample data for each test might be a mess if we are not careful. There is a clever way to organize our sample data for testing. </p>
<p>We can do this in a pattern called the builder pattern (not to be confused with the GoF Builder design pattern). The builder pattern will allow us to <em class="italic">mix and match</em> sample data in a clean and readable way. I have added a file called <code>ApplicationContextFakeBuilder.cs</code> to contain the sample state data with the builder pattern. I have included a part of this class here for brevity but you can see the full class in the companion source code:</p>
<pre class="source-code">public class ApplicationContextFakeBuilder
{
    private readonly ApplicationContextFake _ctx = new();
    private EntityEntry&lt;Employee&gt; _tomEmp;
    private EntityEntry&lt;Employee&gt; _janeEmp;
    …
    private EntityEntry&lt;Customer&gt; _paulCust;
    private EntityEntry&lt;Service&gt; _mensCut;
    private EntityEntry&lt;Appointment&gt; _aptPaulWithTom;
    …
    public ApplicationContextFakeBuilder <strong class="bold">With</strong>SingleEmpTom()
    {
        _tomEmp = _ctx.Add(new Employee { 
            Name = "Thomas Fringe" });
        return this;
    }
    …
    public ApplicationContextFake Build()
    {
        _ctx.SaveChanges();
        return _ctx;
    }
}</pre>
<p>This <a id="_idIndexMarker712"/>class will prepare in-memory sample data. The unit tests that will use this class will call different methods on it to set the right data state. What is interesting in this class is the following:</p>
<ul>
<li>Using the <code>With</code> convention to indicate that we are adding sample data. You will see examples of how the <code>With</code> methods are used later on.</li>
<li>The <code>With</code> methods return <code>this</code>, which at first instance looks weird. The idea here is to implement a coding convention called chaining so that you can write code like this: <code>_ctxBldr.WithSingleService(30).WithSingleEmpTom()</code>.</li>
<li>The <code>Build()</code> method will save everything to the persisting media (the memory, in this case) and return the context.</li>
</ul>
<p>The Builder <a id="_idIndexMarker713"/>pattern is heavily used when trying to set the state of a certain component. Feel free to look at the companion code for the full code. <a href="B18370_06.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>, <em class="italic">The FIRSTHAND Guidelines of TDD</em>, has another example of a build class; you might want to have a look at it to strengthen your understanding.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor237"/>Implementing the first story</h2>
<p>The first story in our <a id="_idIndexMarker714"/>requirement is very easy. The <a id="_idIndexMarker715"/>website is going to display all the available services that we have. Since the website will request this data from the WebApi through a RESTful API call, the domain layer will have a service that will return this list. Let’s assume this would be the UI output:</p>
<div><div><img alt="Figure 9.6 – A UI of the requirements of Story 1 " height="608" src="img/Figure_9.6_B18370.jpg" width="607"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – A UI of the requirements of Story 1</p>
<p>The UI layer, hosted in the browser, will need to issue a RESTful call to the WebApi, which can look as follows:</p>
<pre>GET https://webapidomain/services</pre>
<p>This UI will require a few data properties that should be returned by this API. So, the fetched JSON can look like an array of this:</p>
<pre class="source-code">{    
    "ServiceId": 2,
    "Name": "Men - Clipper &amp; Scissor Cut",
    "Duration": 30,
    "Price": 23.0
}</pre>
<p>You can see where each part is used on the page, but maybe <code>ServiceId</code> is not very clear. It will be used to construct the URL of the <code>select</code> hyperlink. So, we can now design the contract type that will render this JSON, which could look like this:</p>
<pre class="source-code">namespace Uqs.AppointmentBooking.Contract;
public record Service(int ServiceId, string Name, 
    int Duration, float Price);</pre>
<p>This <code>record</code> contract will <a id="_idIndexMarker716"/>render the previous<a id="_idIndexMarker717"/> JSON code. And the full returned array contract could look like this:</p>
<pre class="source-code">namespace Uqs.AppointmentBooking.Contract;
public record AvailableServices(Service[] Services);</pre>
<p>You can find these contract types and all the other contracts in the <code>Contract</code> project.</p>
<h3>Adding the first unit test via TDD</h3>
<p>Thinking along the lines<a id="_idIndexMarker718"/> of DDD, we will have a domain service called <code>ServicesService</code>, which will handle retrieving all the available services. So, let’s look at the structure of this service. We will create it in the <code>Domain</code> project under <code>Services</code>. Here is the code:</p>
<pre class="source-code">public class ServicesService
{
}</pre>
<p>There is nothing special here. I have just helped VS understand that when I type <code>ServicesService</code>, it should guide me to this class.</p>
<p class="callout-heading">Note</p>
<p class="callout">I have added the previous <code>ServicesService</code> class manually. Some TDD practitioners like to code-generate this file while they are writing their unit test rather than writing it first. Any method is fine as long as you are more productive. I chose to create the file first because sometimes VS creates this file in a different directory from where I intend it to.</p>
<p>I will<a id="_idIndexMarker719"/> create my unit tests class, which is called <code>ServicesServiceTests</code>, with the following code:</p>
<pre class="source-code">public class ServicesServiceTests : IDisposable
{
    private readonly ApplicationContextFakeBuilder _ctxBldr
        = new();
    private ServicesService? _sut;
    public void Dispose()
    {
        _ctxBldr.Dispose();
    }
}</pre>
<p>I have added <code>ApplicationContextFakeBuilder</code> immediately because I know that I am going to be dealing with sample data in my unit tests.</p>
<p>Now, I<a id="_idIndexMarker720"/> need to think of what I need from my service and build a unit test accordingly. The straightforward way to start is to pick the easiest scenario. If we have no barber service, then no service is returned:</p>
<pre class="source-code">[Fact]
public async Task
GetActiveServices_NoServiceInTheSystem_NoServices()
{
    // Arrange
    var ctx = _ctxBldr.Build();
    _sut = new ServicesService(ctx);
    // Act
    var actual = await _sut.GetActiveServices();
    // Assert
    Assert.True(!actual.Any());
}</pre>
<p>I have decided in the test that there will be a method named <code>GetActiveServices</code>, and when this method is called, it will return a collection of active services. At this stage, the code doesn’t compile; as such, a method doesn’t exist. We have got our TDD’s fail! </p>
<p>Now, we can instruct VS to generate this method, and then we can write the implementation:</p>
<pre class="source-code">public class ServicesService
{
    private readonly ApplicationContext _context;
    public ServicesService(ApplicationContext context)
    {
        _context = context;
    }
    public async Task&lt;IEnumerable&lt;Service&gt;&gt; 
        GetActiveServices()
          =&gt; await _context.Services!.ToArrayAsync();
}</pre>
<p>This is<a id="_idIndexMarker721"/> getting, through EF, all the available services, and since we did not store any service in the sample data, none will return.</p>
<p>If you run the test again, it will pass. This is our TDD’s test pass. There is no need for the refactor stage, as this is a simple implementation. Congratulations, you have finished your first test!</p>
<p class="callout-heading">Note</p>
<p class="callout">This test is simple, and it seems like a waste of time. However, this is a valid test case, and it also helps us create our domain class and inject the right dependencies. Starting with a simple test helps to progress in steady steps.</p>
<h3>Adding the second unit test via TDD</h3>
<p>The second<a id="_idIndexMarker722"/> feature that we need to add is the ability to get the active services only, not the ones that are no longer active, as they are no longer provided by the barber. So, let’s start with this unit test:</p>
<pre class="source-code">[Fact]
public async Task 
  GetActiveServices_TwoActiveOneInactiveService_TwoServices()
{
    // Arrange
    var ctx = _ctxBldr
        .WithSingleService(true)
        .WithSingleService(true)
        .WithSingleService(false)
        .Build();
    _sut = new ServicesService(ctx);
    var expected = 2;
    // Act
    var actual = await _sut.GetActiveServices();
    // Assert
    Assert.Equal(expected, actual.Count());
}</pre>
<p>Our <code>Arrange</code> will <a id="_idIndexMarker723"/>add three services – two active and one inactive. It is interesting to see the code of <code>WithSingleService</code>:</p>
<pre class="source-code">public ApplicationContextFakeBuilder WithSingleService
    (bool isActive)
{
    _context.Add(new Service{ IsActive = isActive });
    return this;
}</pre>
<p>If we run the test, of course, it will fail, as we have not added any filtration functionality to our service. Let’s go ahead and add filtration to the service:</p>
<pre class="source-code">public async Task&lt;IEnumerable&lt;Service&gt;&gt; GetActiveServices()
    =&gt; await _context.Services!<strong class="bold">.Where(x =&gt; x.IsActive)</strong>
                               .ToArrayAsync();</pre>
<p>We have added a <code>Where</code> LINQ statement, which will do the trick. Run the tests again, and this test shall pass.</p>
<p>This was an <a id="_idIndexMarker724"/>easy requirement. In fact, all the stories are straightforward except story number 5. We will not list the other stories here because they are similar, but you can find them in the companion source code. Instead, we will focus on story number 5 as its complexity matches real-life production code and reveals the main benefit of TDD.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor238"/>Implementing the fifth story (time management)</h2>
<p>This story is about a <a id="_idIndexMarker725"/>time management system. It tries to manage barbers’ time fairly, taking rest time into consideration. If you take a moment to think about this story, it is a complex one <a id="_idIndexMarker726"/>with many edge cases.</p>
<p>This story reveals the power of TDD as it will help you find a starting point and adds little incremental steps to build the requirement. When you finish, you will notice that you have automatically documented the story in the unit tests. </p>
<p>In the next sections, we will find a way to start from the easier-to-implement scenarios and climb up to more sophisticated test scenarios.</p>
<h3>Checking for records</h3>
<p>One gentle way to start our <a id="_idIndexMarker727"/>implementation that will make us think of the signature of the method is checking the parameters.</p>
<p>Logically, to determine an employee’s availability, we need to know who this employee is by using <code>employeeId</code> and the length of time required. The length can be acquired from the<a id="_idIndexMarker728"/> service by <code>serviceId</code>. A logical name for the method can be <code>GetAvailableSlotsForEmployee</code>. Our first unit test is this:</p>
<pre class="source-code">[Fact]
public async Task 
  GetAvailableSlotsForEmployee_ServiceIdNoFound_
    ArgumentException()
{
    // Arrange
    var ctx = _contextBuilder
        .Build();
    _sut = new SlotsService(ctx, _nowService, _settings);
    // Act
    var exception = await 
        Assert.ThrowsAsync&lt;ArgumentException&gt;(
        () =&gt; _sut.GetAvailableSlotsForEmployee(-1));
    // Assert
    Assert.IsType&lt;ArgumentException&gt;(exception);
}</pre>
<p>It doesn’t compile; it is a fail. So, create the method in <code>SlotsService</code>:</p>
<pre class="source-code">public async Task&lt;Slots&gt; GetAvailableSlotsForEmployee(
    int serviceId)
{
    var service = await _context.Services!
        .SingleOrDefaultAsync(x =&gt; x.Id == serviceId);
    if (service is null)
    {
        throw new ArgumentException("Record not found",
        nameof(serviceId));
    }
    return null;
}</pre>
<p>Now that <a id="_idIndexMarker729"/>you have the implementation in place, run the tests again, and they will pass. You can do the same for <code>employeeId</code> and do what we did for <code>serviceId</code>.</p>
<h3>Starting with the simplest scenario</h3>
<p>Let’s add the simplest <a id="_idIndexMarker730"/>possible business logic to start with. Let’s assume that the system has one employee called Tom. Tom has no shifts available in the system. Also, the system has one service only:</p>
<pre class="source-code">[Fact]
public async Task GetAvailableSlotsForEmployee_
  NoShiftsForTomAndNoAppointmentsInSystem_NoSlots()
{
    // Arrange
    var appointmentFrom = 
        new DateTime(2022, 10, 3, 7, 0, 0);
    _nowService.Now.Returns(appointmentFrom);
    var ctx = _contextBuilder
        .WithSingleService(30)
        .WithSingleEmployeeTom()
        .Build();
    _sut = new SlotsService(ctx, _nowService, _settings);
    var tom = context.Employees!.Single();
    var mensCut30Min = context.Services!.Single();
    // Act
    var slots = await 
        _sut.GetAvailableSlotsForEmployee(
        mensCut30Min.Id, tom.Id);
    // Assert
    var times = slots.DaysSlots.SelectMany(x =&gt; x.Times);
    Assert.Empty(times);
}</pre>
<p>This will fail, as <a id="_idIndexMarker731"/>we have <code>null</code> returned by the method, whatever the input is. We need to continue adding bits of code to the solution. We can start with the following code:</p>
<pre class="source-code">…
var shifts = _context.Shifts!.Where(
    x =&gt; x.EmployeeId == employeeId);
if (!shifts.Any())
{
    return new Slots(Array.Empty&lt;DaySlots&gt;());
}
return null;</pre>
<p>The previous code<a id="_idIndexMarker732"/> is exactly what is required to pass the test. The test is green now.</p>
<h3>Elevating scenarios’ complexity</h3>
<p>The rest of the<a id="_idIndexMarker733"/> unit tests follow the same way of elevating test scenario complexity slightly. Here are other scenarios you might want to add:</p>
<pre class="source-code">[Theory]
[InlineData(5, 0)]
[InlineData(25, 0)]
[InlineData(30, 1, "2022-10-03 09:00:00")]
[InlineData(35, 2, "2022-10-03 09:00:00", 
  "2022-10-03 09:05:00")]
public async Task GetAvailableSlotsForEmployee_
OneShiftAndNoExistingAppointments_VaryingSlots(
    int serviceDuration, int totalSlots, 
      params string[] expectedTimes)
{
…</pre>
<p>The previous test is, in fact, multiple tests (because we are using <code>Theory</code>) with each <code>InlineData</code> elevating complexity. As usual, do the red then green to let it pass before adding another suite of tests:</p>
<pre class="source-code">public async Task GetAvailableSlotsForEmployee_
  OneShiftWithVaryingAppointments_VaryingSlots(
    string appointmentStartStr, string appointmentEndStr, 
    int totalSlots, params string[] expectedTimes)
{
…</pre>
<p>This is also a test with multiple <code>InlineData</code>. Obviously, we cannot fit all the code here, so please have a look in <code>SlotsServiceTests.cs</code> for the complete unit tests.</p>
<p>As you start adding more test cases, whether by using <code>Theory</code> with <code>InlineData</code> or using <code>Fact</code>, you will notice that the code complexity in the implementation is going up. This is all right! But, do you feel the readability is suffering? Then it is time to refactor. </p>
<p>Now you have the advantage of unit tests protecting the code from being broken. Refactoring when the method is doing what you want it to do is part of the Red-Green-Refactor mantra. In fact, if you look at <code>SlotsService.cs</code>, I did refactor to improve readability by creating multiple private methods.</p>
<p>This story is<a id="_idIndexMarker734"/> complex, I will give you that. I could have picked an easier example, and everybody would be happy, but real-life code has ups and downs and varies in complexity, so I wanted to include one sophisticated scenario following the pragmatism theme of the book.</p>
<p>After this section, you might have some questions. I hope I am able to answer some of them below.</p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor239"/>Answering frequently asked questions</h1>
<p>Now that we have written the <a id="_idIndexMarker735"/>unit tests and the associated implementation, let me explain the process.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor240"/>Are these unit tests enough?</h2>
<p>The answer to this question depends on your target coverage and your confidence that all cases are covered. Sometimes, adding more unit tests increases the future maintenance overhead, so with experience, you would strike the right balance.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor241"/>Why didn’t we unit test the controllers?</h2>
<p>The controllers should not contain business logic. We pushed all the logic to the services, then tested the services. What is left in the controllers is minimal code concerned with mapping different types to each other. Have a look at the controllers in <code>Uqs.AppointmentBooking.WebApi/Controllers</code> to see what I mean.</p>
<p>Unit tests<a id="_idIndexMarker736"/> excel in testing business logic or areas where there are conditions and branching. The controllers in the coding style that we chose do not have that.</p>
<p>The controllers should be tested but through a different type of test.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor242"/>Did we test the system enough?</h2>
<p>No, we didn’t! We did the unit tests part. We have not tested the controllers or the boot of the system (the content of <code>Program.cs</code>) and other small bits of the code.</p>
<p>We did not test them via unit tests as they are not business logic. However, they need testing, but unit tests are not the best testing type to check for the quality of these areas. You can cover these areas by other types of testing such as integration, Sintegration, and system tests.</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor243"/>We omitted testing some areas, how can we achieve high coverage?</h2>
<p>Some areas of the code are not unit tested, such as <code>Program.cs</code> and the controllers. If you are aiming for high code coverage, such as 90%, you might not achieve it via unit testing alone, as there is a good amount of code that went here, in this chapter.</p>
<p>Achieving coverage by unit tests alone is unfair as you need additional testing types to achieve more coverage, or the developers would start cheating by adding meaningless tests to boost coverage. These tests do more harm than good as they will create a maintenance overhead.</p>
<p>Coverage calculation should include other types of tests, rather than relying on units alone. If this is the case, 90% is a realistic target and can lead to a high-quality product.</p>
<p>Sometimes it is hard to configure a coverage meter tool to measure the sum of multiple test types, so in this case, it makes sense to lower your coding coverage target to maybe 80% or so.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor244"/>Summary</h1>
<p>We have seen implementing realistic stories by setting up the system with EF and SQL Server, then building it a bit at a time by incrementally adding unit tests and increasing the complexity with every additional unit test.</p>
<p>We have seen a realistic fake test double and a concrete builder to construct our sample data. </p>
<p>We had to select multiple important scenarios to encourage you to examine the full source code, otherwise, the pages will be filled with code.</p>
<p>If you have read and understood the code, then I assure you that this is the peak of the complexity, as other chapters should be easier to read and follow. So congratulations, you have made it through the hard part of this book! I trust you can now go ahead and start your TDD-based project with EF and a relational DB.</p>
<p>Hopefully, this chapter has given you a guide to starting your new EF and SQL Server-based project. The next chapter does the same implementation but focuses on document DB and has different patterns than this one.</p>
</div>
</div>
</body></html>