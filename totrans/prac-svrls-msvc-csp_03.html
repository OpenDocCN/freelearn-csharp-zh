<html><head></head><body>
<div id="_idContainer088">
<h1 class="chapterNumber"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 class="chapterTitle" id="_idParaDest-52"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.2.1">Setup and Theory: Docker and Onion Architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">This chapter discusses two important building blocks of modern microservices architectures, which will be used in most of the bookâ€™s examples, as follows:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Docker Containers</span></strong><span class="koboSpan" id="kobo.5.1">: Docker containers</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.6.1"> are a virtualization tool that enables your microservices to run on a wide range of hardware platforms, preventing compatibility issues.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.7.1">The Onion Architecture</span></strong><span class="koboSpan" id="kobo.8.1">: The Onion Architecture</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.9.1"> confines dependencies from both the </span><strong class="keyWord"><span class="koboSpan" id="kobo.10.1">user interface</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.12.1">UI</span></strong><span class="koboSpan" id="kobo.13.1">) and from the deployment platform in drivers so that the </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.14.1">software modules that encode the whole business knowledge are completely independent of the chosen UI, tools, and runtime environment. </span><span class="koboSpan" id="kobo.14.2">Moreover, in order to optimize the interaction between domain experts and developers, all domain entities are implemented as classes in the following way:</span><ol class="numberedList level-2" style="list-style-type: decimal;">
<li class="numberedList level-2" value="1"><span class="koboSpan" id="kobo.15.1">Each entity interacts with the remainder of the code only through methods that represent the behavior of all actual domain entities.</span></li>
<li class="numberedList level-2"><span class="koboSpan" id="kobo.16.1">Names of entities and entity members are taken from the vocabulary of the application domain. </span><span class="koboSpan" id="kobo.16.2">The purpose is to build up a common language between developers and users called </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.17.1">the </span><strong class="keyWord"><span class="koboSpan" id="kobo.18.1">ubiquitous language</span></strong><span class="koboSpan" id="kobo.19.1">.</span></li>
</ol>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.20.1">While Docker containers are roughly tied to microservice performance optimization, the Onion Architecture is not specific for microservices. </span><span class="koboSpan" id="kobo.20.2">However, the Onion Architecture described here was designed specifically for use with microservices, as it makes wide use of some of the microservice-specific patterns we described in </span><a href="Chapter_2.xhtml#_idTextAnchor038"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 2</span></em></a><em class="italic"><span class="koboSpan" id="kobo.22.1">, Demystifying Microservices Applications</span></em><span class="koboSpan" id="kobo.23.1">, such as publisher-subscriber events, to maximize the independence of software modules and to ensure separation between update and query software modules.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.24.1">In this chapter, we will introduce a Visual Studio solution template based on the Onion Architecture along with code snippets that we will use throughout the remainder of the book for implementing any kind of microservice. </span><span class="koboSpan" id="kobo.24.2">We will discuss both the theory behind it and its pros.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.25.1">More specifically, this chapter covers the followi</span><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.26.1">ng:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">The Onion Architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.28.1">A solution template based on the Onion Architect</span><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.29.1">ure</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.30.1">Containers and Docker</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.31.1">By the end of the chapter, you should be able to create an application based on the Onion Architecture and work with Docker containers, which are the building blocks of complex microservices applications.</span></p>
<h1 class="heading-1" id="_idParaDest-53"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.32.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.33.1">This chapter requires the following:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.34.1">At a minimum, the Visual Studio 2022 free </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Community edition</span></em><span class="koboSpan" id="kobo.36.1">.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.37.1">Docker Desktop</span></strong><span class="koboSpan" id="kobo.38.1"> for Windows (</span><a href="https://www.docker.com/products/docker-desktop"><span class="url"><span class="koboSpan" id="kobo.39.1">https://www.docker.com/products/docker-desktop</span></span></a><span class="koboSpan" id="kobo.40.1">)</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.41.1">Docker Desktop</span></strong><span class="koboSpan" id="kobo.42.1">, in turn, requires </span><strong class="keyWord"><span class="koboSpan" id="kobo.43.1">Windows Subsystem for Linux (WSL)</span></strong><span class="koboSpan" id="kobo.44.1">, which can be installed by following these steps:</span><ol class="numberedList level-2" style="list-style-type: decimal;">
<li class="numberedList level-2" value="1"><span class="koboSpan" id="kobo.45.1">Type </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.46.1">powershell</span></code><span class="koboSpan" id="kobo.47.1"> in the Windows 10/11 search bar.</span></li>
<li class="numberedList level-2"><span class="koboSpan" id="kobo.48.1">When Windows PowerShell is proposed as a search result, click on </span><strong class="screenText"><span class="koboSpan" id="kobo.49.1">Run as an administrator</span></strong><span class="koboSpan" id="kobo.50.1">.</span></li>
<li class="numberedList level-2"><span class="koboSpan" id="kobo.51.1">In the Windows PowerShell administrative console that appears, run the </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.52.1">wsl --install</span></code><span class="koboSpan" id="kobo.53.1"> command.</span></li>
</ol>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.54.1">You can find the sample code for this chapter at </span><a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp"><span class="url"><span class="koboSpan" id="kobo.55.1">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</span></span></a><span class="koboSpan" id="kobo.56.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-54"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.57.1">The Onion Architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.58.1">The Onion Architecture makes a clear </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.59.1">distinction between domain-specific code and the technical code that handles the UI, storage interaction, and hardware resources. </span><span class="koboSpan" id="kobo.59.2">This keeps the domain-specific code completely independent of technical tools, such as the operating system, web technology, database, and database interaction tools.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.60.1">The whole </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.61.1">application is organized into layers, with the outermost layer having the sole purpose of providing all the necessary infrastructure (i.e., drivers), UI, and test suites, as shown in the following figur</span><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.62.1">e:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.63.1"><img alt="Figure 3.1: Basic Onion Architecture" src="../Images/B31916_03_1.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.64.1">Figure 3.1: Basic Onion Architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.65.1">In turn, the application-specific code is organized into several more nested layers. </span><span class="koboSpan" id="kobo.65.2">All layers must satisfy the following constraint:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.66.1"> Each layer may reference only inner layers. </span><span class="koboSpan" id="kobo.66.2">The way this constraint is implemented depends on the underlying language and stack. </span><span class="koboSpan" id="kobo.66.3">For instance, layers can be implemented as packages, namespaces, or libraries. </span><span class="koboSpan" id="kobo.66.4">We will implement layers with .NET library projects that can be easily turned into NuGet packages, too.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.67.1">So, for instance, in the preceding figure, the outermost layer may reference all application-specific libraries, plus all libraries that implement all the required drivers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.68.1">The application-specific code references the functionalities implemented in the outermost layerâ€™s drivers through interfaces, while the outermost layer has the main function of providing a dependency injection engine that couples each of these interfaces with a driver that implements it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.69.1">...
</span><span class="koboSpan" id="kobo.69.2">builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.70.1">Services</span></span><span class="koboSpan" id="kobo.71.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.72.1">AddScoped</span></span><span class="koboSpan" id="kobo.73.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.74.1">IMyFunctionalityInterface1</span></span><span class="koboSpan" id="kobo.75.1">, </span><span class="hljs-title"><span class="koboSpan" id="kobo.76.1">MyFunctionalityImplementation1</span></span><span class="koboSpan" id="kobo.77.1">&gt;();
builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.78.1">Services</span></span><span class="koboSpan" id="kobo.79.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.80.1">AddScoped</span></span><span class="koboSpan" id="kobo.81.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.82.1">IMyFunctionalityInterface2</span></span><span class="koboSpan" id="kobo.83.1">, </span><span class="hljs-title"><span class="koboSpan" id="kobo.84.1">MyFunctionalityImplementation2</span></span><span class="koboSpan" id="kobo.85.1">&gt;();
...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.86.1">The application-specific </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.87.1">layer, in turn, is composed of at least two main layers: a layer that contains all domain entity definitions, called</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.88.1"> the </span><strong class="keyWord"><span class="koboSpan" id="kobo.89.1">Domain layer</span></strong><span class="koboSpan" id="kobo.90.1">, and a layer that contains the definition of all application operations, called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.91.1">Application Services</span></strong><span class="koboSpan" id="kobo.92.1"> layer, as</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.93.1"> shown in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.94.1"><img alt="Figure 3.2: Complete Onion Architecture" src="../Images/B31916_03_2.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.95.1">Figure 3.2: Complete Onion Architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.96.1">If needed, the Application Services layer can be split into more sublayers, and more layers can be placed between the Application Services and Domain layers, but this is rarely done.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.97.1">The Domain layer is often split into two</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.98.1"> sublayers: </span><strong class="keyWord"><span class="koboSpan" id="kobo.99.1">the Model layer,</span></strong><span class="koboSpan" id="kobo.100.1"> which contains the actual domain entity definitions, and the </span><strong class="keyWord"><span class="koboSpan" id="kobo.101.1">Domain Services</span></strong><span class="koboSpan" id="kobo.102.1"> layer, which contains </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.103.1">further business rules.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.104.1">Throughout this book, we will use just the Application Services and Domain layers. </span><span class="koboSpan" id="kobo.104.2">We will discuss each of them in a separate subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-55"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.105.1">The Domain layer</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.106.1">The Domain layer contains the</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.107.1"> class representation of each domain entity with its behavior encoded in the public method of such classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.108.1">Moreover, domain entities can be modified just with methods that represent actual domain operations. </span><span class="koboSpan" id="kobo.108.2">Thus, for instance, we canâ€™t directly access and modify all fields of a purchase order; we are limited to manipulating it just through methods that represent actual domain operations, such as adding or deleting an item, applying a discount, or modifying the delivery date.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.109.1">The names of all public methods and properties must be</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.110.1"> built with the actual language used by the domain experts, the previously mentioned </span><strong class="keyWord"><span class="koboSpan" id="kobo.111.1">ubiquitous language</span></strong><span class="koboSpan" id="kobo.112.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.113.1">All the preceding constraints have the purpose of optimizing communication between developers and experts. </span><span class="koboSpan" id="kobo.113.2">In this way, domain experts and developers can discuss the public interface of the entity since it uses the same vocabulary and actual domain operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.114.1">The following is a part of a hy</span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.115.1">pothetical </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">PurchaseOrde</span></code><span class="koboSpan" id="kobo.117.1">r entity:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.118.1">  public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.119.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.120.1">PurchaseOrder</span></span><span class="koboSpan" id="kobo.121.1">
    {
      â€¦
      #region private members
      private </span><span class="hljs-title"><span class="koboSpan" id="kobo.122.1">IList</span></span><span class="koboSpan" id="kobo.123.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.124.1">PurchaseOrderItem</span></span><span class="koboSpan" id="kobo.125.1">&gt; items;
      private </span><span class="hljs-title"><span class="koboSpan" id="kobo.126.1">DateTime</span></span><span class="koboSpan" id="kobo.127.1"> _deliveryTime;
      #endregion
      public </span><span class="hljs-title"><span class="koboSpan" id="kobo.128.1">PurchaseOrder</span></span><span class="koboSpan" id="kobo.129.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.130.1">DateTime</span></span><span class="koboSpan" id="kobo.131.1"> creationTime, </span><span class="hljs-title"><span class="koboSpan" id="kobo.132.1">DateTime</span></span><span class="koboSpan" id="kobo.133.1"> deliveryTime)
        {
          </span><span class="hljs-title"><span class="koboSpan" id="kobo.134.1">CreationTime</span></span><span class="koboSpan" id="kobo.135.1"> = creationTime;
          _deliveryTime = deliveryTime;
          items=</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.136.1">new</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.137.1">List</span></span><span class="koboSpan" id="kobo.138.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.139.1">PurchaseOrderItem</span></span><span class="koboSpan" id="kobo.140.1">&gt;();
        }
      public </span><span class="hljs-title"><span class="koboSpan" id="kobo.141.1">DateTime</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.142.1">CreationTime</span></span><span class="koboSpan" id="kobo.143.1"> {get; init;}
      public </span><span class="hljs-title"><span class="koboSpan" id="kobo.144.1">DateTime</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.145.1">DeliveryTime</span></span><span class="koboSpan" id="kobo.146.1"> =&gt; _deliveryTime;
      public </span><span class="hljs-title"><span class="koboSpan" id="kobo.147.1">IEnumerable</span></span><span class="koboSpan" id="kobo.148.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.149.1">PurchaseOrderItem</span></span><span class="koboSpan" id="kobo.150.1">&gt; </span><span class="hljs-params"><span class="koboSpan" id="kobo.151.1">Items</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.152.1"> =&gt;</span></span><span class="koboSpan" id="kobo.153.1"> items;
      public bool </span><span class="hljs-title"><span class="koboSpan" id="kobo.154.1">DelayDelyveryTime</span></span><span class="koboSpan" id="kobo.155.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.156.1">DateTime</span></span><span class="koboSpan" id="kobo.157.1"> newDeliveryTime)
        {
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.158.1">if</span></span><span class="koboSpan" id="kobo.159.1">(_deliveryTime&lt; newDeliveryTime)
            {
              _deliveryTime = newDeliveryTime;
              </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.160.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.161.1">true</span></span><span class="koboSpan" id="kobo.162.1">;
            }
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.163.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.164.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.165.1">false</span></span><span class="koboSpan" id="kobo.166.1">;
        }
      public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.167.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.168.1">AddItem</span></span><span class="koboSpan" id="kobo.169.1"> (</span><span class="hljs-title"><span class="koboSpan" id="kobo.170.1">PurchaseOrderItem</span></span><span class="koboSpan" id="kobo.171.1"> x)
        { items.</span><span class="hljs-title"><span class="koboSpan" id="kobo.172.1">Add</span></span><span class="koboSpan" id="kobo.173.1">(x); }
      public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.174.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.175.1">RemoveItem</span></span><span class="koboSpan" id="kobo.176.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.177.1">PurchaseOrderItem</span></span><span class="koboSpan" id="kobo.178.1"> x)
        { items.</span><span class="hljs-title"><span class="koboSpan" id="kobo.179.1">Remove</span></span><span class="koboSpan" id="kobo.180.1">(x); }
       â€¦
  }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.181.1">Once taken </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.182.1">from the constructor, </span><code class="inlineCode"><span class="koboSpan" id="kobo.183.1">CreationTime</span></code><span class="koboSpan" id="kobo.184.1"> cannot be modified anymore, so it is implemented as a {</span><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">get; init;}</span></code><span class="koboSpan" id="kobo.186.1"> property. </span><span class="koboSpan" id="kobo.186.2">The list of all items can be modified through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">AddItem</span></code><span class="koboSpan" id="kobo.188.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">RemoveItem</span></code><span class="koboSpan" id="kobo.190.1"> methods, which are understandable by all domain experts. </span><span class="koboSpan" id="kobo.190.2">Finally, we can delay the delivery date but we canâ€™t anticipate it. </span><span class="koboSpan" id="kobo.190.3">This automatically encodes a domain business rule by enforcing the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">DelayDeliveryTime</span></code><span class="koboSpan" id="kobo.192.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.193.1">We can improve the </span><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">PurchaseOrde</span></code><span class="koboSpan" id="kobo.195.1">r entity by adding a </span><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">PurchaseTotal</span></code> <strong class="keyWord"><span class="koboSpan" id="kobo.197.1">get property</span></strong><span class="koboSpan" id="kobo.198.1"> that returns the total amount of the purchase, and by adding an </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">ApplyDiscount</span></code><span class="koboSpan" id="kobo.200.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.201.1">Summing up, we can state the following rule:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.202.1"> Domain entity states can only be changed through methods that encode actual domain operations and that automatically enforce all business rules.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.203.1">These entities differ a lot from the</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.204.1"> usual </span><strong class="keyWord"><span class="koboSpan" id="kobo.205.1">Entity Framework Core</span></strong><span class="koboSpan" id="kobo.206.1"> entities we are used to for the following reasons:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.207.1">Entity Framework Core entities are record-like classes with no methods. </span><span class="koboSpan" id="kobo.207.2">That is, they are just a set of property-value pairs.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.208.1">Each Entity Framework Core entity corresponds to a single object related somehow to other entities, while domain entities are often trees of nested objects. </span><span class="koboSpan" id="kobo.208.2">That is why domain entities are usually </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.209.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.210.1">aggregates</span></strong><span class="koboSpan" id="kobo.211.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.212.1">Thus, for instance, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">PurchaseOrder</span></code><span class="koboSpan" id="kobo.214.1"> aggregate contains a main</span><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.215.1"> entity and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.216.1">PurchaseOrderItem</span></code><span class="koboSpan" id="kobo.217.1"> collection. </span><span class="koboSpan" id="kobo.217.2">It is worth pointing out that </span><code class="inlineCode"><span class="koboSpan" id="kobo.218.1">PurchaseOrderItem</span></code><span class="koboSpan" id="kobo.219.1"> cannot be considered a separate domain entity since there are no domain operations that involve a single </span><code class="inlineCode"><span class="koboSpan" id="kobo.220.1">PurchaseOrderItem</span></code><span class="koboSpan" id="kobo.221.1">, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">PurchaseOrderItem</span></code><span class="koboSpan" id="kobo.223.1"> can be manipulated just as a part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.224.1">PurchaseOrder</span></code><span class="koboSpan" id="kobo.225.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.226.1">A similar phenomenon doesnâ€™t occur with flat Entity Framework entities, as they lack the concept of domain operations. </span><span class="koboSpan" id="kobo.226.2">We may conclude the following:</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.227.1"> Domain operations on domain entities can force them to merge with dependent entities, thus becoming a complex tree of objects </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.228.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.229.1">aggregates</span></strong><span class="koboSpan" id="kobo.230.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.231.1">For the </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.232.1">remainder of this book, we will refer to domain entities as aggregates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.233.1">So far, we have given entities a strong application domain semantic together with the concept of aggregation. </span><span class="koboSpan" id="kobo.233.2">These aggregates differ a lot from database tuples and also from their object representation provided by ORMS such as Entity Framework Core, so we have a mismatch between aggregates and the structures used to persist them. </span><span class="koboSpan" id="kobo.233.3">This mismatch could be solved in several ways, but all solutions must conform to </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.234.1">the </span><strong class="keyWord"><span class="koboSpan" id="kobo.235.1">persistence ignorance</span></strong><span class="koboSpan" id="kobo.236.1"> principle:</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.237.1"> Aggregates must not be impacted by how they might be persisted. </span><span class="koboSpan" id="kobo.237.2">They must be completely decoupled from the persistence code, and the persistence technique must not impose any constraint on the aggregate design.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.238.1">We now observe another phenomenon: entities without an identity!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.239.1">Two purchase orders with exactly the same dates and items remain two different entities; in fact, they must have a different delivery for each of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.240.1">However, what happens with two addresses containing exactly the same fields? </span><span class="koboSpan" id="kobo.240.2">If we consider the semantics of an address, can we say they are two different entities?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.241.1">Each address denotes a place, and if two addresses have the same fields, they denote exactly the same place. </span><span class="koboSpan" id="kobo.241.2">Thus, addresses are just like numbers: even though we may replicate them several times, each copy always denotes the same abstract entity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.242.1">Therefore, we may conclude that addresses with the same fields are indistinguishable. </span><span class="koboSpan" id="kobo.242.2">Relational databases use principal keys to verify when two tuples reference the same abstract entity, so we may conclude that the principal key of an address should be the set of all its fields.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.243.1">In the theory of domain entities, objects similar to addresses are called value objects, and their in-memory representation must not contain explicit principal keys. </span><span class="koboSpan" id="kobo.243.2">An equality operator applied to two instances of them must return </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.244.1">true</span></code><span class="koboSpan" id="kobo.245.1"> if and only if all their fields are equal. </span><span class="koboSpan" id="kobo.245.2">Moreover, they must be immutable â€“ that is, once created, t</span><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.246.1">heir properties cannot be changed, so the only way to modify a value object is to create a new object with some property value changed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.247.1">In C#, value objects are easily represented </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.248.1">with </span><strong class="keyWord"><span class="koboSpan" id="kobo.249.1">records</span></strong><span class="koboSpan" id="kobo.250.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.251.1">public record </span><span class="hljs-title"><span class="koboSpan" id="kobo.252.1">Address</span></span><span class="koboSpan" id="kobo.253.1">
{
  public string </span><span class="hljs-title"><span class="koboSpan" id="kobo.254.1">Country</span></span><span class="koboSpan" id="kobo.255.1"> {get; init;}
  public string </span><span class="hljs-title"><span class="koboSpan" id="kobo.256.1">Town</span></span><span class="koboSpan" id="kobo.257.1"> {get; init;}
  public string </span><span class="hljs-title"><span class="koboSpan" id="kobo.258.1">Street</span></span><span class="koboSpan" id="kobo.259.1"> {get; init;}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.260.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">init</span></code><span class="koboSpan" id="kobo.262.1"> keyword is</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.263.1"> what makes record-type properties immutable since it means they can only be</span></p>
<p class="normal"><span class="koboSpan" id="kobo.264.1">initialized. </span><span class="koboSpan" id="kobo.264.2">A modified copy of a record can be created as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.265.1">var</span></span><span class="koboSpan" id="kobo.266.1"> modifiedAddress = myAddress </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.267.1">with</span></span><span class="koboSpan" id="kobo.268.1"> {</span><span class="hljs-title"><span class="koboSpan" id="kobo.269.1">Street</span></span><span class="koboSpan" id="kobo.270.1"> = </span><span class="hljs-string"><span class="koboSpan" id="kobo.271.1">"new street"</span></span><span class="koboSpan" id="kobo.272.1">};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.273.1">If we pass all the properties in the constructor instead of using initializers, the preceding definition can be simplified as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.274.1">public record </span><span class="hljs-title"><span class="koboSpan" id="kobo.275.1">Address</span></span><span class="koboSpan" id="kobo.276.1">(string </span><span class="hljs-title"><span class="koboSpan" id="kobo.277.1">Country</span></span><span class="koboSpan" id="kobo.278.1">, string </span><span class="hljs-title"><span class="koboSpan" id="kobo.279.1">Town</span></span><span class="koboSpan" id="kobo.280.1">, string </span><span class="hljs-title"><span class="koboSpan" id="kobo.281.1">Street</span></span><span class="koboSpan" id="kobo.282.1">) ;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.283.1">Typical value objects include costs (represented as a number and a currency symbol), locations (represented as longitude and latitude), addresses, and contact information.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.284.1">In practice, value objects can be represented in databases with the usual tuple with a principal key (for instance, an autoincremented integer). </span><span class="koboSpan" id="kobo.284.2">Then, a new copy of each tuple can be created differently for each occurrence of the same address. </span><span class="koboSpan" id="kobo.284.3">It is also possible to enforce a unique database copy by defining complex composite keys.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.285.1"> Since aggregates and value objects differ a lot from the entities used by all main ORMs such as Entity Framework, when we use ORMS to interact with databases, we must translate ORM entities into aggregates and value objects, and vice versa, each time we exchange data with an ORM.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.286.1">According to general Onion </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.287.1">Architecture rules, the Domain layer interacts with the actual implementation provided by an ORM through an interface. </span><span class="koboSpan" id="kobo.287.2">This is usually done with the so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.288.1">repository pattern</span></strong><span class="koboSpan" id="kobo.289.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.290.1"> According to the repository pattern, a storage service must be provided through one separate interface for each aggregate.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.291.1">This means the Domain layer must contain a different interface for each aggregate, which takes care of retrieving, saving, and deleting the whole aggregate. </span><span class="koboSpan" id="kobo.291.2">The repository pattern helps keep the code modular and easy to search and update since we know we must have one and only one repository interface for each aggregate, so we can organize the whole aggregate-related code in a single folder.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.292.1">The actual implementation of each repository is contained in the Infrastructure layer of the Onion Architecture in a kind of database (or persistence) driver, together with various other drivers that virtualize the interaction with the infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.293.1">Each aggregate repository interface contains methods that return aggregates, delete aggregates, and make any other kind of persistency-related operations on aggregates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.294.1">In complex applications, it is best practice to split the Domain layer into a Model layer, which contains just aggregates, and an outer Domain Services layer, which contains the repository interfaces and the definition of domain operations that canâ€™t be implemented as aggregate methods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">In particular, </span><strong class="keyWord"><span class="koboSpan" id="kobo.296.1">Domain Services</span></strong><span class="koboSpan" id="kobo.297.1"> interfaces </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.298.1">handle the tuples used to encode the results </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.299.1">returned by query microservices. </span><span class="koboSpan" id="kobo.299.2">These tuples are not aggregates but a mix of data taken from different data tables, so they conform to a completely different design pattern. </span><span class="koboSpan" id="kobo.299.3">They are returned as record-like objects with no methods and just properties that correspond to the database tuples fields. </span><span class="koboSpan" id="kobo.299.4">Further </span><strong class="keyWord"><span class="koboSpan" id="kobo.300.1">Domain Services</span></strong><span class="koboSpan" id="kobo.301.1"> interfaces are implemented in the persistence driver of the infrastructure layer, too.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.302.1">Handling queries and </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.303.1">modifications separately and with different design patterns is known as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.304.1">Command Query Responsibility Segregation (CQRS</span></strong><span class="koboSpan" id="kobo.305.1">) pattern.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.306.1"> Since, the microservices described in this book are quite simple, in our code examples, we will not split the domain layer into the model and domain services layers. </span><span class="koboSpan" id="kobo.306.2">Therefore, the repository and other domain services interfaces will be mixed with aggregates in the same Visual Studio project. </span><span class="koboSpan" id="kobo.306.3">However, when implementing more complex applications, you should use the division of the domain layer into the model and domain services layers.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.307.1">Letâ€™s look at some examples of a repository interface. </span><span class="koboSpan" id="kobo.307.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">PurchaseOrder</span></code><span class="koboSpan" id="kobo.309.1"> aggregate might have an associated repository interface that looks as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.310.1">    public interface </span><span class="hljs-title"><span class="koboSpan" id="kobo.311.1">IPurchaseOrderRepository</span></span><span class="koboSpan" id="kobo.312.1">
    {
      </span><span class="hljs-title"><span class="koboSpan" id="kobo.313.1">PurchaseOrder</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.314.1">New</span></span><span class="koboSpan" id="kobo.315.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.316.1">DateTime</span></span><span class="koboSpan" id="kobo.317.1"> creationTime, </span><span class="hljs-title"><span class="koboSpan" id="kobo.318.1">DateTime</span></span><span class="koboSpan" id="kobo.319.1"> deliveryTime);
      </span><span class="hljs-title"><span class="koboSpan" id="kobo.320.1">Task</span></span><span class="koboSpan" id="kobo.321.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.322.1">PurchaseOrder</span></span><span class="koboSpan" id="kobo.323.1">&gt; </span><span class="hljs-title"><span class="koboSpan" id="kobo.324.1">GetAsync</span></span><span class="koboSpan" id="kobo.325.1">(long id);
      </span><span class="hljs-title"><span class="koboSpan" id="kobo.326.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.327.1">DeleteAsync</span></span><span class="koboSpan" id="kobo.328.1">(long id);
      </span><span class="hljs-title"><span class="koboSpan" id="kobo.329.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.330.1">DeleteAsync</span></span><span class="koboSpan" id="kobo.331.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.332.1">PurchaseOrder</span></span><span class="koboSpan" id="kobo.333.1"> order);
      </span><span class="hljs-title"><span class="koboSpan" id="kobo.334.1">Task</span></span><span class="koboSpan" id="kobo.335.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.336.1">IEnumerable</span></span><span class="koboSpan" id="kobo.337.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.338.1">OrderBasicInfoDTO</span></span><span class="koboSpan" id="kobo.339.1">&gt;&gt; </span><span class="hljs-title"><span class="koboSpan" id="kobo.340.1">GetMany</span></span><span class="koboSpan" id="kobo.341.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.342.1">DateTime</span></span><span class="koboSpan" id="kobo.343.1">? </span><span class="koboSpan" id="kobo.343.2">startPeriod,
            </span><span class="hljs-title"><span class="koboSpan" id="kobo.344.1">DateTime</span></span><span class="koboSpan" id="kobo.345.1">? </span><span class="koboSpan" id="kobo.345.2">endPeriod, int? </span><span class="koboSpan" id="kobo.345.3">customerId
            );
         ...
    </span><span class="koboSpan" id="kobo.345.4">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.346.1">There is no update method since updates are implemented by directly calling the aggregate methods. </span><span class="koboSpan" id="kobo.346.2">The last method in the code shown returns a collection of record-like DTOs called </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">OrderBasicInfoDTO</span></code><span class="koboSpan" id="kobo.348.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.349.1"> It is worth pointing out that there are no repository interfaces associated with value objects since value objects are handled just as primitive types, such as integers, decimals, or strings.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.350.1">Several changes to different aggregates can be dealt with in a transactional way thanks to the </span><strong class="keyWord"><span class="koboSpan" id="kobo.351.1">Unit Of Work</span></strong><span class="koboSpan" id="kobo.352.1"> pattern, which will be</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.353.1"> described later on in the </span><em class="italic"><span class="koboSpan" id="kobo.354.1">Command</span></em><span class="koboSpan" id="kobo.355.1"> subsection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.356.1">More details on how Entity Framework Core supports the implementation of repository interfaces and on how domain objects are tied and translated back and forth to Entity Framework Core en</span><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.357.1">tities will be given in the</span><em class="italic"><span class="koboSpan" id="kobo.358.1"> A solution template based on the Onion Architecture </span></em><span class="koboSpan" id="kobo.359.1">section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.360.1">Having understood the in-memory representation of domain objects, we can move on to the way a microservices-oriented Onion Architecture represents all business transactions/operations.</span></p>
<h2 class="heading-2" id="_idParaDest-56"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.361.1">Application services</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.362.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.363.1">Microservices organization </span></em><span class="koboSpan" id="kobo.364.1">subsection of</span><em class="italic"> </em><a href="Chapter_2.xhtml#_idTextAnchor038"><em class="italic"><span class="koboSpan" id="kobo.365.1">Chapter 2</span></em></a><em class="italic"><span class="koboSpan" id="kobo.366.1">, Demystifying Microservices Applications</span></em><span class="koboSpan" id="kobo.367.1">, we saw that microservices architectures </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.368.1">often </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.369.1">use the </span><strong class="keyWord"><span class="koboSpan" id="kobo.370.1">CQRS</span></strong><span class="koboSpan" id="kobo.371.1"> pattern, which is where some microservices specialize in queries and others specialize in updates. </span><span class="koboSpan" id="kobo.371.2">That is the strong version of the CQRS pattern, but there is also a weaker version that simply requires that queries and updates be organized into different modules, possibly belonging to the same microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.372.1">While it is not always convenient to apply CQRS in its stronger form, its weaker form is a must when implementing microservices, as updates involve aggregates while queries involve just record-like DTOs, so they require completely different types of processing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.373.1">Accordingly, the operations defined in the application services layer of a microservice are split into two different types: </span><strong class="keyWord"><span class="koboSpan" id="kobo.374.1">queries </span></strong><span class="koboSpan" id="kobo.375.1">and </span><strong class="keyWord"><span class="koboSpan" id="kobo.376.1">commands</span></strong><span class="koboSpan" id="kobo.377.1">. </span><span class="koboSpan" id="kobo.377.2">As we will see, the execution of commands can trigger events, so together with commands and queries, application services must also handle so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.378.1">domain events</span></strong><span class="koboSpan" id="kobo.379.1">. </span><span class="koboSpan" id="kobo.379.2">We will discuss all these different operations in the dedicated subsections that follow.</span></p>
<h3 class="heading-3" id="_idParaDest-57"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.380.1">Queries</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.381.1">A query object represents one </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.382.1">or several similar queries, so it usually has one or several methods that take some inputs and return the query results. </span><span class="koboSpan" id="kobo.382.2">Most query methods just call a single repository method that implements the needed query, but in some cases, they may execute several repository methods and then they may somehow merge their results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.383.1">During system testing, actual query implementations must be replaced by fake implementations, so, usually, each query has an associated interface that is coupled with the actual implementation in the dependency injection engine. </span><span class="koboSpan" id="kobo.383.2">This way, the UI may just require the interface in some constructor, thus enabling testing with a fake implementation of the query.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.384.1">The following is a possible definition</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.385.1"> of a query that returns all purchase orders emitted after a given date, together with its associated interface:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.386.1">public interface </span><span class="hljs-title"><span class="koboSpan" id="kobo.387.1">IPurchaseOrderByStartDateQuery</span></span><span class="koboSpan" id="kobo.388.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.389.1">IQuery</span></span><span class="koboSpan" id="kobo.390.1">
{
  </span><span class="hljs-title"><span class="koboSpan" id="kobo.391.1">Task</span></span><span class="koboSpan" id="kobo.392.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.393.1">IEnumerable</span></span><span class="koboSpan" id="kobo.394.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.395.1">OrderBasicInfoDTO</span></span><span class="koboSpan" id="kobo.396.1">&gt;&gt; </span><span class="hljs-title"><span class="koboSpan" id="kobo.397.1">Execute</span></span><span class="koboSpan" id="kobo.398.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.399.1">DateTime</span></span><span class="koboSpan" id="kobo.400.1"> startDate);
}
public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.401.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.402.1">PurchaseOrderByStartDateQuery</span></span><span class="koboSpan" id="kobo.403.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.404.1">IPurchaseOrderRepository</span></span><span class="koboSpan" id="kobo.405.1"> repo):
  </span><span class="hljs-title"><span class="koboSpan" id="kobo.406.1">IPurchaseOrderByStartDateQuery</span></span><span class="koboSpan" id="kobo.407.1">
{
  public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.408.1">async</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.409.1">Task</span></span><span class="koboSpan" id="kobo.410.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.411.1">IEnumerable</span></span><span class="koboSpan" id="kobo.412.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.413.1">OrderBasicInfoDTO</span></span><span class="koboSpan" id="kobo.414.1">&gt;&gt; </span><span class="hljs-title"><span class="koboSpan" id="kobo.415.1">Execute</span></span><span class="koboSpan" id="kobo.416.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.417.1">DateTime</span></span><span class="koboSpan" id="kobo.418.1"> startDate)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.419.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.420.1">await</span></span><span class="koboSpan" id="kobo.421.1"> repo.</span><span class="hljs-title"><span class="koboSpan" id="kobo.422.1">GetMany</span></span><span class="koboSpan" id="kobo.423.1">(startDate, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.424.1">null</span></span><span class="koboSpan" id="kobo.425.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.426.1">null</span></span><span class="koboSpan" id="kobo.427.1">);
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.428.1">The interface inherits from an empty interface whose unique purpose is to mark both the interface and its implementation as queries. </span><span class="koboSpan" id="kobo.428.2">This way, all queries and their associated implementation can be automatically found with the help of reflection and added to the dependency injection engine. </span><span class="koboSpan" id="kobo.428.3">We will provide the code that discovers all queries in the </span><em class="italic"><span class="koboSpan" id="kobo.429.1">A solution template based on the Onion Architecture </span></em><span class="koboSpan" id="kobo.430.1">section together with a complete solution template.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.431.1">As mentioned, the implementation just calls a repository method and passes it adequate parameters. </span><span class="koboSpan" id="kobo.431.2">An implementation of the repository is passed in the principal constructor of the class by the same dependency injection engine that will inject the query itself in the constructor of a presentation layer object (a controller, in the case of an ASP.NET Core website).</span></p>
<h3 class="heading-3" id="_idParaDest-58"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.432.1">Commands</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.433.1">Commands work in a slightly </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.434.1">different way because, for better code readability, each command represents a single application operation. </span><span class="koboSpan" id="kobo.434.2">For this reason, each command instance represents both the abstract operation and its input. </span><span class="koboSpan" id="kobo.434.3">The actual operation implementation is contained in a command handler object. </span><span class="koboSpan" id="kobo.434.4">The following is the code of a hypothetical command that applies a discount to a purchase order:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.435.1">public record </span><span class="hljs-title"><span class="koboSpan" id="kobo.436.1">ApplyDiscountCommand</span></span><span class="koboSpan" id="kobo.437.1">(decimal discount, long orderId): </span><span class="hljs-title"><span class="koboSpan" id="kobo.438.1">ICommand</span></span><span class="koboSpan" id="kobo.439.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.440.1">Commands </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.441.1">must be immutable; thatâ€™s why we implanted them as records. </span><span class="koboSpan" id="kobo.441.2">In fact, the only operation allowed on them is their execution. </span><span class="koboSpan" id="kobo.441.3">Similar to queries, commands also implement an empty interface that marks them as commands (in this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">ICommand</span></code><span class="koboSpan" id="kobo.443.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.444.1">Command handlers are implementations of the following interface:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.445.1">    public interface </span><span class="hljs-title"><span class="koboSpan" id="kobo.446.1">ICommandHandler</span></span><span class="koboSpan" id="kobo.447.1"> {}
    public interface </span><span class="hljs-title"><span class="koboSpan" id="kobo.448.1">ICommandHandler</span></span><span class="koboSpan" id="kobo.449.1">&lt;T&gt;: </span><span class="hljs-title"><span class="koboSpan" id="kobo.450.1">ICommandHandler</span></span><span class="koboSpan" id="kobo.451.1">
        where </span><span class="hljs-attr"><span class="koboSpan" id="kobo.452.1">T</span></span><span class="koboSpan" id="kobo.453.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.454.1">ICommand</span></span><span class="koboSpan" id="kobo.455.1">
    {
      </span><span class="hljs-title"><span class="koboSpan" id="kobo.456.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.457.1">HandleAsync</span></span><span class="koboSpan" id="kobo.458.1">(T command);
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.459.1">As you can, see all command handlers implement the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">HandleAsync</span></code><span class="koboSpan" id="kobo.461.1"> method that accepts the command as its single input. </span><span class="koboSpan" id="kobo.461.2">Thus, for instance, the handler associated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">ApplyDiscountCommand</span></code><span class="koboSpan" id="kobo.463.1"> is something like the following class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.464.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.465.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.466.1">ApplyDiscountCommandHandler</span></span><span class="koboSpan" id="kobo.467.1">(
</span><span class="hljs-title"><span class="koboSpan" id="kobo.468.1">IPackageRepository</span></span><span class="koboSpan" id="kobo.469.1"> repo):</span><span class="hljs-title"><span class="koboSpan" id="kobo.470.1">ICommandHandler</span></span><span class="koboSpan" id="kobo.471.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.472.1">ApplyDiscountCommand</span></span><span class="koboSpan" id="kobo.473.1">&gt;
  {
    public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.474.1">async</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.475.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.476.1">HandleAsync</span></span><span class="koboSpan" id="kobo.477.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.478.1">ApplyDiscountCommand</span></span><span class="koboSpan" id="kobo.479.1"> command)
      {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.480.1">var</span></span><span class="koboSpan" id="kobo.481.1"> purchaseOrder = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">await</span></span><span class="koboSpan" id="kobo.483.1"> repo.</span><span class="hljs-title"><span class="koboSpan" id="kobo.484.1">GetAsync</span></span><span class="koboSpan" id="kobo.485.1">(command.</span><span class="hljs-property"><span class="koboSpan" id="kobo.486.1">OrderId</span></span><span class="koboSpan" id="kobo.487.1">);
</span><span class="hljs-keyword"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.488.1">//call adequate aggregate methods to apply the required update</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.489.1">//possibly modify other aggregates by getting them with other</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.490.1">        //injected repositories</span></span><span class="koboSpan" id="kobo.491.1">
        ...
      </span><span class="koboSpan" id="kobo.491.2">}
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.492.1">All handlers must be added to the dependency injection engine, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.493.1">builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.494.1">Services</span></span><span class="koboSpan" id="kobo.495.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.496.1">AddScoped</span></span><span class="koboSpan" id="kobo.497.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.498.1">ICommandHandler</span></span><span class="koboSpan" id="kobo.499.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.500.1">ApplyDiscountCommand</span></span><span class="koboSpan" id="kobo.501.1">&gt;,
 </span><span class="hljs-title"><span class="koboSpan" id="kobo.502.1">ApplyDiscountCommandHandler</span></span><span class="koboSpan" id="kobo.503.1">&gt;();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.504.1">This can be done automatically by scanning the application services assembly with reflection. </span><span class="koboSpan" id="kobo.504.2">We will provide the code that discovers all command handlers in the </span><em class="italic"><span class="koboSpan" id="kobo.505.1">A solution template based on the Onion Architecture </span></em><span class="koboSpan" id="kobo.506.1">section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.507.1">Each command handler gets or creates aggregates, modifies them by calling their methods, and then executes a save instruction to persist all modifications in the underlying storage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.508.1">The save operation must be implemented in the storage driver (for instance, Entity Framework Core), so, as usual for all Onion Architecture driversâ€™ operations, it is mediated by an interface. </span><span class="koboSpan" id="kobo.508.2">The inter</span><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.509.1">face that performs the save operations and other transaction-related operations is usually called </span><strong class="keyWord"><span class="koboSpan" id="kobo.510.1">IUnitOfWork</span></strong><span class="koboSpan" id="kobo.511.1">. </span><span class="koboSpan" id="kobo.511.2">A possible definition of this interface is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.512.1">public interface </span><span class="hljs-title"><span class="koboSpan" id="kobo.513.1">IUnitOfWork</span></span><span class="koboSpan" id="kobo.514.1">
  {
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.515.1">Task</span></span><span class="koboSpan" id="kobo.516.1">&lt;bool&gt; </span><span class="hljs-title"><span class="koboSpan" id="kobo.517.1">SaveEntitiesAsync</span></span><span class="koboSpan" id="kobo.518.1">();
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.519.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.520.1">StartAsync</span></span><span class="koboSpan" id="kobo.521.1">();
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.522.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.523.1">CommitAsync</span></span><span class="koboSpan" id="kobo.524.1">();
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.525.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.526.1">RollbackAsync</span></span><span class="koboSpan" id="kobo.527.1">(</span><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.528.1">);
  }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.529.1">Letâ€™s break this down:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.530.1">SaveEntitiesAsync</span></code><span class="koboSpan" id="kobo.531.1"> saves all updaters performed so far in a single transaction. </span><span class="koboSpan" id="kobo.531.2">It returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.532.1">true</span></code><span class="koboSpan" id="kobo.533.1"> if the storage engine actually changed after the save operation, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.534.1">false</span></code><span class="koboSpan" id="kobo.535.1"> otherwise.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.536.1">StartAsync</span></code><span class="koboSpan" id="kobo.537.1"> starts a transaction.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.538.1">CommitAsync</span></code><span class="koboSpan" id="kobo.539.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.540.1">RollbackAsync</span></code><span class="koboSpan" id="kobo.541.1"> respectively commit and rol</span><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.542.1">l back an opened transaction.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.543.1">All methods that</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.544.1"> explicitly control the start and end of a transaction are useful for enclosing both a get operation and the final </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">SaveEntitiesAsync</span></code><span class="koboSpan" id="kobo.546.1"> save in the same transaction, as in the following simplified flight reservation snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.547.1">await</span></span><span class="koboSpan" id="kobo.548.1"> unitOfWork.</span><span class="hljs-title"><span class="koboSpan" id="kobo.549.1">StartAsync</span></span><span class="koboSpan" id="kobo.550.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.551.1">var</span></span><span class="koboSpan" id="kobo.552.1"> flight = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.553.1">await</span></span><span class="koboSpan" id="kobo.554.1"> repo.</span><span class="hljs-title"><span class="koboSpan" id="kobo.555.1">GetFlightAsync</span></span><span class="koboSpan" id="kobo.556.1">(flightId);
flight.</span><span class="hljs-property"><span class="koboSpan" id="kobo.557.1">Seats</span></span><span class="koboSpan" id="kobo.558.1">--;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.559.1">if</span></span><span class="koboSpan" id="kobo.560.1">(flight.</span><span class="hljs-property"><span class="koboSpan" id="kobo.561.1">Seats</span></span><span class="koboSpan" id="kobo.562.1"> &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.563.1">0</span></span><span class="koboSpan" id="kobo.564.1">)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.565.1">await</span></span><span class="koboSpan" id="kobo.566.1"> unitOfWork.</span><span class="hljs-title"><span class="koboSpan" id="kobo.567.1">RollBackAsync</span></span><span class="koboSpan" id="kobo.568.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.569.1">return</span></span><span class="koboSpan" id="kobo.570.1">;
}
...
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.571.1">await</span></span><span class="koboSpan" id="kobo.572.1"> unitOfWork.</span><span class="hljs-title"><span class="koboSpan" id="kobo.573.1">SaveEntitiesAsync</span></span><span class="koboSpan" id="kobo.574.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.575.1">await</span></span><span class="koboSpan" id="kobo.576.1"> unitOfWork.</span><span class="hljs-title"><span class="koboSpan" id="kobo.577.1">CommitAsync</span></span><span class="koboSpan" id="kobo.578.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.579.1">If there are no more available seats, the transaction is aborted, but if there are available seats, we are sure that no other passenger can take the available seat because both the query and the update are performed in the same transaction, thus preventing interference from other reservation operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.580.1">Of course, the preceding code works if the transaction has an adequate isolation level and if the database supports that isolation level. </span><span class="koboSpan" id="kobo.580.2">We can use a high enough isolation level for all operations in our</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.581.1"> microservice; otherwise, we are forced to pass the isolation level as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.582.1">StartAsync</span></code><span class="koboSpan" id="kobo.583.1"> argument.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.584.1">Now, we are ready to explain why domain events are needed, and how they are handled.</span></p>
<h3 class="heading-3" id="_idParaDest-59"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.585.1">Domain events</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.586.1">We may define </span><strong class="keyWord"><span class="koboSpan" id="kobo.587.1">domain events</span></strong><span class="koboSpan" id="kobo.588.1"> as</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.589.1"> follows:</span></p>
<div class="note">
<p class="normal"> <strong class="keyWord"><span class="koboSpan" id="kobo.590.1">Domain events</span></strong><span class="koboSpan" id="kobo.591.1"> are events </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.592.1">originating from something happening in the microservice domain and are handled within the boundaries of the microservice itself. </span><span class="koboSpan" id="kobo.592.2">This means they involve communications based on the publisher-subscriber pattern between two chunks of code of the same microservice.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.593.1">Therefore, they must not be confused with the events involved in the communications between different microservices, which are </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.594.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.595.1">integration events</span></strong><span class="koboSpan" id="kobo.596.1"> to distinguish them from domain events.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.597.1">Why use events inside the boundaries of a microservice? </span><span class="koboSpan" id="kobo.597.2">The reason is always the same: to ensure a better decoupling between parts. </span><span class="koboSpan" id="kobo.597.3">Here, the parts involved are aggregates. </span><span class="koboSpan" id="kobo.597.4">The code of each aggregate must be completely independent of other aggregates to ensure modularity and modifiability, so relations between aggregates are either mediated by command handlers or by some publisher-subscriber pattern.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.598.1">Accordingly, if the interaction between two aggregates is somehow decided by the code of a command handler, the same command handler might take care of processing the data of both of them and then somehow update them. </span><span class="koboSpan" id="kobo.598.2">However, if the interaction is tied to the processing within an aggregate method, we are forced to use events because we canâ€™t make an aggregate aware of all the other aggregates that need to be informed about some of its data changes. </span><span class="koboSpan" id="kobo.598.3">Summing up, we may state the following principle:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.599.1"> Domain events are triggered just inside aggregate methods because other kinds of interactions are better handled by command handlersâ€™ code.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.600.1">Another important principle is the following:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.601.1"> Events triggered inside an aggregate method must not interfere with the ongoing method processing because these might undermine the contract between the aggregate and the command handlers that manipulate it.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.602.1">Accordingly, each aggregate stores all events inside of it in an events list, and then the command handler decides when to execute these handlers. </span><span class="koboSpan" id="kobo.602.2">Typically, all events of all aggregates processed by a command handler are executed just before the handler saves all changes by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.603.1">unitOfWork.SaveEntitiesAsync()</span></code><span class="koboSpan" id="kobo.604.1">. </span><span class="koboSpan" id="kobo.604.2">However, this is not a general rule.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.605.1">Events are handled in a similar way to commands, the only difference being that each command has just one associated handler, while each event may have several subscriptions attached to it. </span><span class="koboSpan" id="kobo.605.2">Luckily, this difficulty can be easily handled with some advanced features of the .NET dependency injection engine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.606.1">More specifically, events are classes marked with the empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.607.1">IEventNotification</span></code><span class="koboSpan" id="kobo.608.1"> interface, while event handlers are an implementation of the following interface:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.609.1">public interface </span><span class="hljs-title"><span class="koboSpan" id="kobo.610.1">IEventHandler</span></span><span class="koboSpan" id="kobo.611.1">
{
}
public interface </span><span class="hljs-title"><span class="koboSpan" id="kobo.612.1">IEventHandler</span></span><span class="koboSpan" id="kobo.613.1">&lt;T&gt;: </span><span class="hljs-title"><span class="koboSpan" id="kobo.614.1">IEventHandler</span></span><span class="koboSpan" id="kobo.615.1">
    where </span><span class="hljs-attr"><span class="koboSpan" id="kobo.616.1">T</span></span><span class="koboSpan" id="kobo.617.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.618.1">IEventNotification</span></span><span class="koboSpan" id="kobo.619.1">
  {
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.620.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.621.1">HandleAsync</span></span><span class="koboSpan" id="kobo.622.1">(T ev);
  }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.623.1">All data structures </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.624.1">involved are completely analogous to the ones needed to handle commands. </span><span class="koboSpan" id="kobo.624.2">However, now we must add some enhancements to associate each event with all its handlers. </span><span class="koboSpan" id="kobo.624.3">The following generic class does the trick:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.625.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.626.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.627.1">EventTrigger</span></span><span class="koboSpan" id="kobo.628.1">&lt;T&gt;
        where </span><span class="hljs-attr"><span class="koboSpan" id="kobo.629.1">T</span></span><span class="koboSpan" id="kobo.630.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.631.1">IEventNotification</span></span><span class="koboSpan" id="kobo.632.1">
  {
    private readonly </span><span class="hljs-title"><span class="koboSpan" id="kobo.633.1">IEnumerable</span></span><span class="koboSpan" id="kobo.634.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.635.1">IEventHandler</span></span><span class="koboSpan" id="kobo.636.1">&lt;T&gt;&gt; _handlers;
    public </span><span class="hljs-title"><span class="koboSpan" id="kobo.637.1">EventTrigger</span></span><span class="koboSpan" id="kobo.638.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.639.1">IEnumerable</span></span><span class="koboSpan" id="kobo.640.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.641.1">IEventHandler</span></span><span class="koboSpan" id="kobo.642.1">&lt;T&gt;&gt; handlers)
      {
        _handlers = handlers;
      }
      public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.643.1">async</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.644.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.645.1">Trigger</span></span><span class="koboSpan" id="kobo.646.1">(T ev)
      {
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.647.1">foreach</span></span><span class="koboSpan" id="kobo.648.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.649.1">var</span></span><span class="koboSpan" id="kobo.650.1"> handler </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.651.1">in</span></span><span class="koboSpan" id="kobo.652.1"> _handlers)
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.653.1">await</span></span><span class="koboSpan" id="kobo.654.1"> handler.</span><span class="hljs-title"><span class="koboSpan" id="kobo.655.1">HandleAsync</span></span><span class="koboSpan" id="kobo.656.1">(ev);
      }
  }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.657.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.658.1">IEventNotification</span></code><span class="koboSpan" id="kobo.659.1"> is an empty interface used just to mark a class as representing an event.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.660.1">If we add the preceding generic class to the dependency injection engine with </span><code class="inlineCode"><span class="koboSpan" id="kobo.661.1">service.AddScoped(typeof(EventTrigge&lt;&gt;))</span></code><span class="koboSpan" id="kobo.662.1">, then whenever we require a specific instance of this class (say, for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">MyEvent</span></code><span class="koboSpan" id="kobo.664.1"> event generic argument), the dependency injection engine will automatically retrieve all </span><code class="inlineCode"><span class="koboSpan" id="kobo.665.1">IEventHandler&lt;MyEvent&gt;</span></code><span class="koboSpan" id="kobo.666.1"> implementations and will pass it in the constructor of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.667.1">EventTrigger&lt;MyEvent&gt;</span></code><span class="koboSpan" id="kobo.668.1"> instance being returned. </span><span class="koboSpan" id="kobo.668.2">After that, we may launch all subscribed handlers with something like the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.669.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.670.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.671.1">MyCommandHandler</span></span><span class="koboSpan" id="kobo.672.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.673.1">EventTrigger</span></span><span class="koboSpan" id="kobo.674.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.675.1">MyEvent</span></span><span class="koboSpan" id="kobo.676.1">&gt; myEventHandlers): â€¦
{
  public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.677.1">async</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.678.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.679.1">HandleAsync</span></span><span class="koboSpan" id="kobo.680.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.681.1">MytCommand</span></span><span class="koboSpan" id="kobo.682.1"> command)
  {
    â€¦
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.683.1">await</span></span><span class="koboSpan" id="kobo.684.1"> myEventHandlers.</span><span class="hljs-title"><span class="koboSpan" id="kobo.685.1">Trigger</span></span><span class="koboSpan" id="kobo.686.1">(myEvent)
    â€¦
   }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.687.1">It is worth pointing </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.688.1">out that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.689.1">IEventNotification</span></code><span class="koboSpan" id="kobo.690.1"> interface must be defined in the domain layer since it must use aggregates, while all other interfaces and classes connected to events are defined in the application services DLL.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.691.1">As an example of an event, letâ€™s consider a purchase order aggregate of an e-commerce application. </span><span class="koboSpan" id="kobo.691.2">When the purchase order is finalized by calling its </span><code class="inlineCode"><span class="koboSpan" id="kobo.692.1">Finalize</span></code><span class="koboSpan" id="kobo.693.1"> method, if the purchase is greater than a given threshold, then an event must be created for adding some scores to the user profiles that the user can spend to get discounts on further purchases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.694.1">The following</span><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.695.1"> figure exemplifies what happens:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.696.1"><img alt="Figure 3.3: Domain event example" src="../Images/B31916_03_3.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.697.1">Figure 3.3: Domain event example</span></p>
<p class="normal"><span class="koboSpan" id="kobo.698.1">As in the case of </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.699.1">command handlers, all event handlers defined in the application services DLL can be automatically discovered and added to the dependency injection engine through reflection. </span><span class="koboSpan" id="kobo.699.2">We will show how to do it in the next section, which will propose a general .NET solution template for the Onion Architecture.</span></p>
<h1 class="heading-1" id="_idParaDest-60"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.700.1">A solution template based on the Onion Architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.701.1">In this section, we describe a solution template</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.702.1"> based on the Onion Architecture that we will use throughout the remainder of the book, which you can find in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.703.1">ch03</span></code><span class="koboSpan" id="kobo.704.1"> folder of the bookâ€™s GitHub repository (</span><a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp"><span class="url"><span class="koboSpan" id="kobo.705.1">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</span></span></a><span class="koboSpan" id="kobo.706.1">). </span><span class="koboSpan" id="kobo.706.2">This template shows how to put into practice what you have learned about the Onion Architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.707.1">The solution contains two .NET library projects, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.708.1">ApplicationServices</span></code><span class="koboSpan" id="kobo.709.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.710.1">DomainLayer</span></code><span class="koboSpan" id="kobo.711.1">, which implement, respectively, the application services and domai</span><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.712.1">n layers of an Onion Architecture:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.713.1"><img alt="Figure 3.4: Solution template based on the Onion Architecture" src="../Images/B31916_03_4.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.714.1">Figure 3.4: Solution template based on the Onion Architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.715.1">As prescribed by the Onion Architecture, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.716.1">ApplicationServices</span></code><span class="koboSpan" id="kobo.717.1"> project has a reference to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">DomainLayer</span></code><span class="koboSpan" id="kobo.719.1"> architecture project.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.720.1">In </span><code class="inlineCode"><span class="koboSpan" id="kobo.721.1">ApplicationServices</span></code><span class="koboSpan" id="kobo.722.1">, we added the following folders:</span></p>
<ul>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.723.1">Queries</span></code><span class="koboSpan" id="kobo.724.1"> to place all queries and query interfaces</span></li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.725.1">Commands</span></code><span class="koboSpan" id="kobo.726.1"> to place all command classes</span></li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.727.1">CommandHandlers</span></code><span class="koboSpan" id="kobo.728.1"> to place all command handlers</span></li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.729.1">EventHandlers</span></code><span class="koboSpan" id="kobo.730.1"> to place all event handlers</span></li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.731.1">Tools</span></code><span class="koboSpan" id="kobo.732.1">, which contains all Onion Architecture-related interfaces used by the application services we described in the previous section</span></li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.733.1">Extensions</span></code><span class="koboSpan" id="kobo.734.1">, which contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.735.1">HandlersDIExtensions.AddApplicationServices()</span></code><span class="koboSpan" id="kobo.736.1"> extension method that adds all queries, event handlers, and command handlers defined in the project to the dependency injection engine</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.737.1">All the preceding folders can be organized into subfolders to increase the code readability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.738.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.739.1">DomainLayer</span></code><span class="koboSpan" id="kobo.740.1"> project, we added the following folders:</span></p>
<ul>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.741.1">Models</span></code><span class="koboSpan" id="kobo.742.1"> to place all aggregates and value objects</span></li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.743.1">Events</span></code><span class="koboSpan" id="kobo.744.1"> to place all events that may be raised by the aggregates</span></li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.745.1">Tools</span></code><span class="koboSpan" id="kobo.746.1">, which contains all Onion Architecture-related interfaces used by the domain we described in the previous section, and some further utility classes</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.747.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">Extensions</span></code><span class="koboSpan" id="kobo.749.1"> folder of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">ApplicationServices</span></code><span class="koboSpan" id="kobo.751.1"> project contains just one file:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.752.1"><img alt="Figure 3.5: ApplicationServices extensions" src="../Images/B31916_03_5.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.753.1">Figure 3.5: ApplicationServices extensions</span></p>
<p class="normal"><span class="koboSpan" id="kobo.754.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">HandlersDIExtensions</span></code><span class="koboSpan" id="kobo.756.1"> static class contains two overloads of an extension method, which adds all queries, command</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.757.1"> handlers, event handlers, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.758.1">EventMediator</span></code><span class="koboSpan" id="kobo.759.1"> class to the dependency injection engine:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.760.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.761.1">static</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.762.1">IServiceCollection</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.763.1">AddApplicationServices</span></span><span class="koboSpan" id="kobo.764.1">
  (</span><span class="hljs-variable"><span class="koboSpan" id="kobo.765.1">this</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.766.1">IServiceCollection</span></span><span class="koboSpan" id="kobo.767.1"> services, </span><span class="hljs-title"><span class="koboSpan" id="kobo.768.1">Assembly</span></span><span class="koboSpan" id="kobo.769.1"> assembly)
{
  </span><span class="hljs-title"><span class="koboSpan" id="kobo.770.1">AddAllQueries</span></span><span class="koboSpan" id="kobo.771.1">(services, assembly);
  </span><span class="hljs-title"><span class="koboSpan" id="kobo.772.1">AddAllCommandHandlers</span></span><span class="koboSpan" id="kobo.773.1">(services, assembly);
  </span><span class="hljs-title"><span class="koboSpan" id="kobo.774.1">AddAllEventHandlers</span></span><span class="koboSpan" id="kobo.775.1">(services, assembly);
  services.</span><span class="hljs-property"><span class="koboSpan" id="kobo.776.1">AddScoped</span></span><span class="koboSpan" id="kobo.777.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.778.1">EventMediator</span></span><span class="koboSpan" id="kobo.779.1">&gt;();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.780.1">return</span></span><span class="koboSpan" id="kobo.781.1"> services;
}
public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.782.1">static</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.783.1">IServiceCollection</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.784.1">AddApplicationServices</span></span><span class="koboSpan" id="kobo.785.1">
  (</span><span class="hljs-variable"><span class="koboSpan" id="kobo.786.1">this</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.787.1">IServiceCollection</span></span><span class="koboSpan" id="kobo.788.1"> services)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.789.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.790.1">AddApplicationServices</span></span><span class="koboSpan" id="kobo.791.1">(services,
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.792.1">typeof</span></span><span class="koboSpan" id="kobo.793.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.794.1">HandlersDIExtensions</span></span><span class="koboSpan" id="kobo.795.1">).</span><span class="hljs-property"><span class="koboSpan" id="kobo.796.1">Assembly</span></span><span class="koboSpan" id="kobo.797.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.798.1">It uses three different private methods that scan the assembly with reflection, looking respectively for queries, command handlers, and event handlers. </span><span class="koboSpan" id="kobo.798.2">The full code is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.799.1">ch03</span></code><span class="koboSpan" id="kobo.800.1"> folder of the GitHub repository associated with the book. </span><span class="koboSpan" id="kobo.800.2">Here, we analyze just </span><code class="inlineCode"><span class="koboSpan" id="kobo.801.1">AddAllCommandHandlers</span></code><span class="koboSpan" id="kobo.802.1"> to show the basic ideas exploited by all three methods:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.803.1">private </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.804.1">static</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.805.1">IServiceCollection</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.806.1">AddAllCommandHandlers</span></span><span class="koboSpan" id="kobo.807.1">
  (</span><span class="hljs-variable"><span class="koboSpan" id="kobo.808.1">this</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.809.1">IServiceCollection</span></span><span class="koboSpan" id="kobo.810.1"> services, </span><span class="hljs-title"><span class="koboSpan" id="kobo.811.1">Assembly</span></span><span class="koboSpan" id="kobo.812.1"> assembly)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.813.1">var</span></span><span class="koboSpan" id="kobo.814.1"> handlers = assembly.</span><span class="hljs-title"><span class="koboSpan" id="kobo.815.1">GetTypes</span></span><span class="koboSpan" id="kobo.816.1">()
    .</span><span class="hljs-title"><span class="koboSpan" id="kobo.817.1">Where</span></span><span class="koboSpan" id="kobo.818.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.819.1">x</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.820.1"> =&gt;</span></span><span class="koboSpan" id="kobo.821.1"> !x.</span><span class="hljs-property"><span class="koboSpan" id="kobo.822.1">IsAbstract</span></span><span class="koboSpan" id="kobo.823.1"> &amp;&amp; x.</span><span class="hljs-property"><span class="koboSpan" id="kobo.824.1">IsClass</span></span><span class="koboSpan" id="kobo.825.1">
      &amp;&amp; </span><span class="hljs-title"><span class="koboSpan" id="kobo.826.1">typeof</span></span><span class="koboSpan" id="kobo.827.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.828.1">ICommandHandler</span></span><span class="koboSpan" id="kobo.829.1">).</span><span class="hljs-title"><span class="koboSpan" id="kobo.830.1">IsAssignableFrom</span></span><span class="koboSpan" id="kobo.831.1">(x));
  â€¦
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.832.1">First of all, we collect all </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.833.1">nonabstract classes that implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.834.1">ICommandHandler</span></code><span class="koboSpan" id="kobo.835.1"> empty interface. </span><span class="koboSpan" id="kobo.835.2">This interface was specifically added to all command handlers to retrieve all of them with reflection. </span><span class="koboSpan" id="kobo.835.3">Then, for each of them, we retrieve the </span><code class="inlineCode"><span class="koboSpan" id="kobo.836.1">ICommandHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.837.1"> that it implements:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title"><span class="koboSpan" id="kobo.838.1">foreach</span></span><span class="koboSpan" id="kobo.839.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.840.1">var</span></span><span class="koboSpan" id="kobo.841.1"> handler </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.842.1">in</span></span><span class="koboSpan" id="kobo.843.1"> handlers)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.844.1">var</span></span><span class="koboSpan" id="kobo.845.1"> handlerInterface = handler.</span><span class="hljs-title"><span class="koboSpan" id="kobo.846.1">GetInterfaces</span></span><span class="koboSpan" id="kobo.847.1">()
    .</span><span class="hljs-title"><span class="koboSpan" id="kobo.848.1">Where</span></span><span class="koboSpan" id="kobo.849.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.850.1">i</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.851.1"> =&gt;</span></span><span class="koboSpan" id="kobo.852.1"> i.</span><span class="hljs-property"><span class="koboSpan" id="kobo.853.1">IsGenericType</span></span><span class="koboSpan" id="kobo.854.1"> &amp;&amp;</span><span class="hljs-title"><span class="koboSpan" id="kobo.855.1">typeof</span></span><span class="koboSpan" id="kobo.856.1">(
      </span><span class="hljs-title"><span class="koboSpan" id="kobo.857.1">ICommandHandler</span></span><span class="koboSpan" id="kobo.858.1">).</span><span class="hljs-title"><span class="koboSpan" id="kobo.859.1">IsAssignableFrom</span></span><span class="koboSpan" id="kobo.860.1">(i))
    .</span><span class="hljs-title"><span class="koboSpan" id="kobo.861.1">SingleOrDefault</span></span><span class="koboSpan" id="kobo.862.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.863.1">Finally, if we find such an interface, we add the pair to the dependency injection engine:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title"><span class="koboSpan" id="kobo.864.1">foreach</span></span><span class="koboSpan" id="kobo.865.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.866.1">var</span></span><span class="koboSpan" id="kobo.867.1"> handler </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.868.1">in</span></span><span class="koboSpan" id="kobo.869.1"> handlers)
{
  â€¦
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.870.1">if</span></span><span class="koboSpan" id="kobo.871.1"> (handlerInterface != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.872.1">null</span></span><span class="koboSpan" id="kobo.873.1">)
  {
    services.</span><span class="hljs-title"><span class="koboSpan" id="kobo.874.1">AddScoped</span></span><span class="koboSpan" id="kobo.875.1">(handlerInterface, handler);
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.876.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.877.1">Tools</span></code><span class="koboSpan" id="kobo.878.1"> folder of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.879.1">ApplicationServices</span></code><span class="koboSpan" id="kobo.880.1"> project contains the files shown here:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.881.1"><img alt="Figure 3.6: ApplicationServices tools" src="../Images/B31916_03_6.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.882.1">Figure 3.6: ApplicationServices tools</span></p>
<p class="normal"><span class="koboSpan" id="kobo.883.1">We already analyzed all interfaces and classes contained in the preceding </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.884.1">Tools</span></code><span class="koboSpan" id="kobo.885.1"> folder, except </span><code class="inlineCode"><span class="koboSpan" id="kobo.886.1">EventMediator</span></code><span class="koboSpan" id="kobo.887.1"> in the previous section. </span><span class="koboSpan" id="kobo.887.2">Letâ€™s recall them:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.888.1">IQuery</span></code><span class="koboSpan" id="kobo.889.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.890.1">ICommand</span></code><span class="koboSpan" id="kobo.891.1"> are empty interfaces that mark, respectively, queries and commands</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.892.1">ICommandHandler&lt;T&gt; </span></code><span class="koboSpan" id="kobo.893.1">and</span><code class="inlineCode"><span class="koboSpan" id="kobo.894.1"> IEventHandler&lt;T&gt; </span></code><span class="koboSpan" id="kobo.895.1">are the interfaces that must be implemented, respectively, by</span><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.896.1"> command handlers and event handlers</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.897.1">EventTrigger&lt;T&gt; </span></code><span class="koboSpan" id="kobo.898.1">is the class that does the magic of collecting all event handlers associated with the same event, </span><code class="inlineCode"><span class="koboSpan" id="kobo.899.1">T</span></code></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.900.1">EventMediator</span></code><span class="koboSpan" id="kobo.901.1"> is a utility </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.902.1">class that solves a practical problem. </span><span class="koboSpan" id="kobo.902.2">A command handler that needs to trigger all event handlers associated with an event, </span><code class="inlineCode"><span class="koboSpan" id="kobo.903.1">T</span></code><span class="koboSpan" id="kobo.904.1">, must inject </span><code class="inlineCode"><span class="koboSpan" id="kobo.905.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.906.1"> in its constructor. </span><span class="koboSpan" id="kobo.906.2">However, the point is that a command discovers that it needs to trigger the </span><code class="inlineCode"><span class="koboSpan" id="kobo.907.1">T</span></code><span class="koboSpan" id="kobo.908.1"> event just when it finds the </span><code class="inlineCode"><span class="koboSpan" id="kobo.909.1">T</span></code><span class="koboSpan" id="kobo.910.1"> event in the event lists of an aggregate, so it should inject all possible </span><code class="inlineCode"><span class="koboSpan" id="kobo.911.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.912.1"> in its constructor.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.913.1">To overcome this problem, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">EventMediator</span></code><span class="koboSpan" id="kobo.915.1"> class uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.916.1">IServiceProvide</span></code><span class="koboSpan" id="kobo.917.1">r to require the event handlers associated with a list of events it is passed in its </span><code class="inlineCode"><span class="koboSpan" id="kobo.918.1">TriggerEvents(IEnumerable&lt;IEventNotification&gt; events)</span></code><span class="koboSpan" id="kobo.919.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.920.1">Accordingly, it is enough to inject </span><code class="inlineCode"><span class="koboSpan" id="kobo.921.1">EventMediator</span></code><span class="koboSpan" id="kobo.922.1"> in the constructor of each command handler so that whenever it finds a nonempty event list, </span><code class="inlineCode"><span class="koboSpan" id="kobo.923.1">L</span></code><span class="koboSpan" id="kobo.924.1">, in an aggregate, it can simply call the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.925.1">await</span><a id="_idTextAnchor090"/></span><span class="koboSpan" id="kobo.926.1"> eventMediator.</span><span class="hljs-title"><span class="koboSpan" id="kobo.927.1">TriggerEvents</span></span><span class="koboSpan" id="kobo.928.1">(L);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.929.1">Once </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">EventMediator</span></code><span class="koboSpan" id="kobo.931.1"> receives the preceding call, it scans the event list to discover all the events contained in it, then for each of them, it requires the corresponding </span><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.933.1"> to get all associated event handlers, and finally, it executes all retrieved handlers, passing them the corresponding events.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.934.1">To perform its job, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.935.1">EventMediator</span></code><span class="koboSpan" id="kobo.936.1"> class requires </span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">IServiceProvider</span></code><span class="koboSpan" id="kobo.938.1"> in its constructor:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.939.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.940.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.941.1">EventMediator</span></span><span class="koboSpan" id="kobo.942.1">
{
  readonly </span><span class="hljs-title"><span class="koboSpan" id="kobo.943.1">IServiceProvider</span></span><span class="koboSpan" id="kobo.944.1"> services;
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.945.1">EventMediator</span></span><span class="koboSpan" id="kobo.946.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.947.1">IServiceProvider</span></span><span class="koboSpan" id="kobo.948.1"> services)
  {
    </span><span class="hljs-variable"><span class="koboSpan" id="kobo.949.1">this</span></span><span class="koboSpan" id="kobo.950.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.951.1">services</span></span><span class="koboSpan" id="kobo.952.1"> = services;
  }
  ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.953.1">Then, it uses this service provider to require each needed </span><code class="inlineCode"><span class="koboSpan" id="kobo.954.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.955.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.956.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.957.1">async</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.958.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.959.1">TriggerEvents</span></span><span class="koboSpan" id="kobo.960.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.961.1">IEnumerable</span></span><span class="koboSpan" id="kobo.962.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.963.1">IEventNotification</span></span><span class="koboSpan" id="kobo.964.1">&gt; events)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.965.1">if</span></span><span class="koboSpan" id="kobo.966.1"> (events == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.967.1">null</span></span><span class="koboSpan" id="kobo.968.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.969.1">return</span></span><span class="koboSpan" id="kobo.970.1">;
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.971.1">foreach</span></span><span class="koboSpan" id="kobo.972.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.973.1">var</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.974.1"> ev </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.975.1">in</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.976.1"> events</span></span><span class="koboSpan" id="kobo.977.1">)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.978.1">var</span></span><span class="koboSpan" id="kobo.979.1"> triggerType = </span><span class="hljs-title"><span class="koboSpan" id="kobo.980.1">typeof</span></span><span class="koboSpan" id="kobo.981.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.982.1">EventTrigger</span></span><span class="koboSpan" id="kobo.983.1">&lt;&gt;).</span><span class="hljs-title"><span class="koboSpan" id="kobo.984.1">MakeGenericType</span></span><span class="koboSpan" id="kobo.985.1">(
        ev.</span><span class="hljs-title"><span class="koboSpan" id="kobo.986.1">GetType</span></span><span class="koboSpan" id="kobo.987.1">());
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.988.1">var</span></span><span class="koboSpan" id="kobo.989.1"> trigger = services.</span><span class="hljs-title"><span class="koboSpan" id="kobo.990.1">GetService</span></span><span class="koboSpan" id="kobo.991.1">(triggerType);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.992.1">Finally, it invokes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.993.1">EventTrigger&lt;T&gt;.Trigger</span></code><span class="koboSpan" id="kobo.994.1"> methods with reflection:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.995.1">var</span></span><span class="koboSpan" id="kobo.996.1"> task = (</span><span class="hljs-title"><span class="koboSpan" id="kobo.997.1">Task</span></span><span class="koboSpan" id="kobo.998.1">)triggerType.</span><span class="hljs-title"><span class="koboSpan" id="kobo.999.1">GetMethod</span></span><span class="koboSpan" id="kobo.1000.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1001.1">nameof</span></span><span class="koboSpan" id="kobo.1002.1">(
  </span><span class="hljs-title"><span class="koboSpan" id="kobo.1003.1">EventTrigger</span></span><span class="koboSpan" id="kobo.1004.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1005.1">IEventNotification</span></span><span class="koboSpan" id="kobo.1006.1">&gt;.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1007.1">Trigger</span></span><span class="koboSpan" id="kobo.1008.1">))
  .</span><span class="hljs-title"><span class="koboSpan" id="kobo.1009.1">Invoke</span></span><span class="koboSpan" id="kobo.1010.1">(trigger, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1011.1">new</span></span><span class="koboSpan" id="kobo.1012.1"> object[] { ev });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1013.1">await</span></span><span class="koboSpan" id="kobo.1014.1"> task.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1015.1">ConfigureAwait</span></span><span class="koboSpan" id="kobo.1016.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1017.1">false</span></span><span class="koboSpan" id="kobo.1018.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1019.1">The</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.1020.1"> following is the full code of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1021.1">EventMediator</span></code><span class="koboSpan" id="kobo.1022.1"> class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1023.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1024.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1025.1">EventMediator</span></span><span class="koboSpan" id="kobo.1026.1">
{
  readonly </span><span class="hljs-title"><span class="koboSpan" id="kobo.1027.1">IServiceProvider</span></span><span class="koboSpan" id="kobo.1028.1"> services;
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1029.1">EventMediator</span></span><span class="koboSpan" id="kobo.1030.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1031.1">IServiceProvider</span></span><span class="koboSpan" id="kobo.1032.1"> services)
  {
    </span><span class="hljs-variable"><span class="koboSpan" id="kobo.1033.1">this</span></span><span class="koboSpan" id="kobo.1034.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1035.1">services</span></span><span class="koboSpan" id="kobo.1036.1"> = services;
  }
  public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1037.1">async</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1038.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1039.1">TriggerEvents</span></span><span class="koboSpan" id="kobo.1040.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1041.1">IEnumerable</span></span><span class="koboSpan" id="kobo.1042.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1043.1">IEventNotification</span></span><span class="koboSpan" id="kobo.1044.1">&gt; events)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1045.1">if</span></span><span class="koboSpan" id="kobo.1046.1"> (events == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1047.1">null</span></span><span class="koboSpan" id="kobo.1048.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1049.1">return</span></span><span class="koboSpan" id="kobo.1050.1">;
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.1051.1">foreach</span></span><span class="koboSpan" id="kobo.1052.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1053.1">var</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1054.1"> ev </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1055.1">in</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1056.1"> events</span></span><span class="koboSpan" id="kobo.1057.1">)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1058.1">var</span></span><span class="koboSpan" id="kobo.1059.1"> triggerType = </span><span class="hljs-title"><span class="koboSpan" id="kobo.1060.1">typeof</span></span><span class="koboSpan" id="kobo.1061.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1062.1">EventTrigger</span></span><span class="koboSpan" id="kobo.1063.1">&lt;&gt;).</span><span class="hljs-title"><span class="koboSpan" id="kobo.1064.1">MakeGenericType</span></span><span class="koboSpan" id="kobo.1065.1">(
        ev.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1066.1">GetType</span></span><span class="koboSpan" id="kobo.1067.1">());
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1068.1">var</span></span><span class="koboSpan" id="kobo.1069.1"> trigger = services.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1070.1">GetService</span></span><span class="koboSpan" id="kobo.1071.1">(triggerType);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1072.1">var</span></span><span class="koboSpan" id="kobo.1073.1"> task = (</span><span class="hljs-title"><span class="koboSpan" id="kobo.1074.1">Task</span></span><span class="koboSpan" id="kobo.1075.1">)triggerType.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1076.1">GetMethod</span></span><span class="koboSpan" id="kobo.1077.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1078.1">nameof</span></span><span class="koboSpan" id="kobo.1079.1">(
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.1080.1">EventTrigger</span></span><span class="koboSpan" id="kobo.1081.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1082.1">IEventNotification</span></span><span class="koboSpan" id="kobo.1083.1">&gt;.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1084.1">Trigger</span></span><span class="koboSpan" id="kobo.1085.1">))
        .</span><span class="hljs-title"><span class="koboSpan" id="kobo.1086.1">Invoke</span></span><span class="koboSpan" id="kobo.1087.1">(trigger, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1088.1">new</span></span><span class="koboSpan" id="kobo.1089.1"> object[] { ev });
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1090.1">await</span></span><span class="koboSpan" id="kobo.1091.1"> task;
    }
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1092.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1093.1">Tools</span></code><span class="koboSpan" id="kobo.1094.1"> folder of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1095.1">DomainLayer</span></code><span class="koboSpan" id="kobo.1096.1"> project contains the following files:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1097.1"><img alt="Figure 3.7: DomainLayer tools" src="../Images/B31916_03_7.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1098.1">Figure 3.7: DomainLayer tools</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1099.1">IEventNotification</span></code><span class="koboSpan" id="kobo.1100.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1101.1">IRepository</span></code><span class="koboSpan" id="kobo.1102.1"> are empty interfaces that mark, respectively, events and repository interfaces. </span><span class="koboSpan" id="kobo.1102.2">We</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.1103.1"> already discussed them in the previous section. </span><span class="koboSpan" id="kobo.1103.2">We also already discussed </span><code class="inlineCode"><span class="koboSpan" id="kobo.1104.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.1105.1">, which is the interface needed by command handlers to persist changes and handle transactions.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1106.1">Entity&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1107.1"> is a class that all aggregates must inherit from:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1108.1">public abstract </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1109.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1110.1">Entity</span></span><span class="koboSpan" id="kobo.1111.1">&lt;K&gt;
    where </span><span class="hljs-attr"><span class="koboSpan" id="kobo.1112.1">K</span></span><span class="koboSpan" id="kobo.1113.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.1114.1">IEquatable</span></span><span class="koboSpan" id="kobo.1115.1">&lt;K&gt;
{
  public virtual K </span><span class="hljs-title"><span class="koboSpan" id="kobo.1116.1">Id</span></span><span class="koboSpan" id="kobo.1117.1"> {get; protected set; } = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1118.1">default</span></span><span class="koboSpan" id="kobo.1119.1">!;
  public bool </span><span class="hljs-title"><span class="koboSpan" id="kobo.1120.1">IsTransient</span></span><span class="koboSpan" id="kobo.1121.1">()
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1122.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1123.1">Object</span></span><span class="koboSpan" id="kobo.1124.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1125.1">Equals</span></span><span class="koboSpan" id="kobo.1126.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1127.1">Id</span></span><span class="koboSpan" id="kobo.1128.1">, </span><span class="hljs-title"><span class="koboSpan" id="kobo.1129.1">default</span></span><span class="koboSpan" id="kobo.1130.1">(K));
  }
  &gt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1131.1">Domain</span></span><span class="koboSpan" id="kobo.1132.1"> events handling region
  &gt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1133.1">Override</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1134.1">Equal</span></span><span class="koboSpan" id="kobo.1135.1"> region
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1136.1">The preceding class contains two minimized code regions. </span><span class="koboSpan" id="kobo.1136.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1137.1">K</span></code><span class="koboSpan" id="kobo.1138.1"> generic parameter is the type of the aggregateâ€™s </span><code class="inlineCode"><span class="koboSpan" id="kobo.1139.1">Id</span></code><span class="koboSpan" id="kobo.1140.1"> principal key.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1141.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1142.1">IsTransient()</span></code><span class="koboSpan" id="kobo.1143.1"> method returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1144.1">true</span></code><span class="koboSpan" id="kobo.1145.1"> if the aggregate has not been assigned a principal key yet.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1146.1">Override Equal region</span></code><span class="koboSpan" id="kobo.1147.1"> contains the code that overrides the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1148.1">Equal</span></code><span class="koboSpan" id="kobo.1149.1"> method and defines equality and inequality operators. </span><span class="koboSpan" id="kobo.1149.2">The redefined </span><code class="inlineCode"><span class="koboSpan" id="kobo.1150.1">Equal</span></code><span class="koboSpan" id="kobo.1151.1"> method considers equal two instances if and only if they have the same principal key.</span></p>
<p class="normal"><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.1152.1">Domain events handling region</span></code><span class="koboSpan" id="kobo.1153.1"> handles the list of events triggered during all calls to the aggregate methods. </span><span class="koboSpan" id="kobo.1153.2">The exploded code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1154.1">#region domain events handling
public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1155.1">List</span></span><span class="koboSpan" id="kobo.1156.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1157.1">IEventNotification</span></span><span class="koboSpan" id="kobo.1158.1">&gt; </span><span class="hljs-title"><span class="koboSpan" id="kobo.1159.1">DomainEvents</span></span><span class="koboSpan" id="kobo.1160.1"> { get; private set; } = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1161.1">null</span></span><span class="koboSpan" id="kobo.1162.1">!;
public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1163.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1164.1">AddDomainEvent</span></span><span class="koboSpan" id="kobo.1165.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1166.1">IEventNotification</span></span><span class="koboSpan" id="kobo.1167.1"> evt)
{
  </span><span class="hljs-title"><span class="koboSpan" id="kobo.1168.1">DomainEvents</span></span><span class="koboSpan" id="kobo.1169.1"> ??= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1170.1">new</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1171.1">List</span></span><span class="koboSpan" id="kobo.1172.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1173.1">IEventNotification</span></span><span class="koboSpan" id="kobo.1174.1">&gt;();
  </span><span class="hljs-title"><span class="koboSpan" id="kobo.1175.1">DomainEvents</span></span><span class="koboSpan" id="kobo.1176.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1177.1">Add</span></span><span class="koboSpan" id="kobo.1178.1">(evt);
}
public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1179.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1180.1">RemoveDomainEvent</span></span><span class="koboSpan" id="kobo.1181.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1182.1">IEventNotification</span></span><span class="koboSpan" id="kobo.1183.1"> evt)
{
  </span><span class="hljs-title"><span class="koboSpan" id="kobo.1184.1">DomainEvents</span></span><span class="koboSpan" id="kobo.1185.1">?.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1186.1">Remove</span></span><span class="koboSpan" id="kobo.1187.1">(evt);
}
#endregion
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1188.1">We donâ€™t need an </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.1189.1">abstract class for value objects because, as discussed in the previous section, the .NET </span><code class="inlineCode"><span class="koboSpan" id="kobo.1190.1">record</span></code><span class="koboSpan" id="kobo.1191.1"> type perfectly represents all value type features.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1192.1">Before discussing in more detail how to connect the two library projects of the template with the actual storage drivers and with an actual UI, we need to understand how to handle the mismatch between aggregates and record-like ORM classes. </span><span class="koboSpan" id="kobo.1192.2">We will do this in the dedicated subsection that follows.</span></p>
<h2 class="heading-2" id="_idParaDest-61"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.1193.1">Matching aggregates and ORM entities</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1194.1">There are several techniques to match</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.1195.1"> ORM entities and aggregates. </span><span class="koboSpan" id="kobo.1195.2">The simplest one consists of implementing the aggregates with the ORM entities themselves. </span><span class="koboSpan" id="kobo.1195.3">The main difficulty with this approach is that aggregates do not expose the properties that must match the database fields as public properties. </span><span class="koboSpan" id="kobo.1195.4">However, since they usually expose them as private fields, we may try to use these private fields for the database field mapping if the chosen ORM supports mapping with private properties.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1196.1">Entity Framework Core supports the mapping with private fields, but if we are looking for complete independence from the database driver, we canâ€™t rely on this peculiarity of Entity Framework Core. </span><span class="koboSpan" id="kobo.1196.2">Moreover, this approach forces us to define the ORM entities in the domain layer since they are also aggregates. </span><span class="koboSpan" id="kobo.1196.3">This means that we canâ€™t decorate the class member with ORM-specific attributes and that we need to worry about how the class will be used by the ORM while defining each aggregate, thus undermining independence from a specific storage driver.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1197.1">A better approach is the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1198.1">state object</span></strong><span class="koboSpan" id="kobo.1199.1"> approach:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1200.1">We associate each aggregate with an interface that stores the state of the aggregate in its properties. </span><span class="koboSpan" id="kobo.1200.2">This way, instead of using private backing fields, the aggregate uses the properties of this interface.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1201.1">The state interface is passed in the constructor of the aggregate and then stored in a private </span><code class="inlineCode"><span class="koboSpan" id="kobo.1202.1">readonly</span></code><span class="koboSpan" id="kobo.1203.1"> property.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1204.1">The ORM entity associated with the aggregate implements this interface. </span><span class="koboSpan" id="kobo.1204.2">This way, the database driver adapts to the aggregates and not vice versa, thus achieving the required independence of the Domain layer from the database driver.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1205.1">When the domain layer requires either a new fresh aggregate or an aggregate already stored in the database through a repository interface method, the database implementation of the repository method creates or retrieves the corresponding ORM entity and then creates a new aggregate, passing this ORM entity in its constructor as a state object.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1206.1">When the aggregates are modified, all their modifications are reflected on their state objects, which, being ORM entities, are tracked by the ORM. </span><span class="koboSpan" id="kobo.1206.2">Therefore, when we instruct the ORM to save all changes, all aggregatesâ€™ changes are automatically passed to the underlying database because these changes are stored in tracked objects.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1207.1">The following figure</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.1208.1"> shows the preceding flow:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1209.1"><img alt="Figure 3.8: Aggregates lifecycle" src="../Images/B31916_03_8.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1210.1">Figure 3.8: Aggregates lifecycle</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1211.1">Letâ€™s try to modify our previous </span><code class="inlineCode"><span class="koboSpan" id="kobo.1212.1">PurchaseOrder</span></code><span class="koboSpan" id="kobo.1213.1"> aggregate by using the following state interface:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1214.1">public interface </span><span class="hljs-title"><span class="koboSpan" id="kobo.1215.1">IPurchaseOrderState</span></span><span class="koboSpan" id="kobo.1216.1">
{
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1217.1">DateTime</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1218.1">CreationTime</span></span><span class="koboSpan" id="kobo.1219.1"> { get; set; }
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1220.1">DateTime</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1221.1">DeliveryTime</span></span><span class="koboSpan" id="kobo.1222.1"> { get; set; }
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1223.1">ICollection</span></span><span class="koboSpan" id="kobo.1224.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1225.1">PurchaseOrderItem</span></span><span class="koboSpan" id="kobo.1226.1">&gt; </span><span class="hljs-title"><span class="koboSpan" id="kobo.1227.1">Items</span></span><span class="koboSpan" id="kobo.1228.1"> { get; set; }
  â€¦
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1229.1">Modifications </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.1230.1">are straightforward and do not increase the complexity of the code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1231.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1232.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1233.1">PurchaseOrder</span></span><span class="koboSpan" id="kobo.1234.1">
{
  private readonly </span><span class="hljs-title"><span class="koboSpan" id="kobo.1235.1">IPurchaseOrderState</span></span><span class="koboSpan" id="kobo.1236.1"> _state;
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1237.1">PurchaseOrder</span></span><span class="koboSpan" id="kobo.1238.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1239.1">IPurchaseOrderState</span></span><span class="koboSpan" id="kobo.1240.1"> state)
  {
    _state = state;
  }
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1241.1">DateTime</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1242.1">CreationTime</span></span><span class="koboSpan" id="kobo.1243.1"> =&gt; _state.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1244.1">CreationTime</span></span><span class="koboSpan" id="kobo.1245.1">;
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1246.1">DateTime</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1247.1">DeliveryTime</span></span><span class="koboSpan" id="kobo.1248.1"> =&gt; _state.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1249.1">DeliveryTime</span></span><span class="koboSpan" id="kobo.1250.1">;
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1251.1">IEnumerable</span></span><span class="koboSpan" id="kobo.1252.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1253.1">PurchaseOrderItem</span></span><span class="koboSpan" id="kobo.1254.1">&gt; </span><span class="hljs-params"><span class="koboSpan" id="kobo.1255.1">Items</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1256.1"> =&gt;</span></span><span class="koboSpan" id="kobo.1257.1"> _state.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1258.1">Items</span></span><span class="koboSpan" id="kobo.1259.1">;
  public bool </span><span class="hljs-title"><span class="koboSpan" id="kobo.1260.1">DelayDelyveryTime</span></span><span class="koboSpan" id="kobo.1261.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1262.1">DateTime</span></span><span class="koboSpan" id="kobo.1263.1"> newDeliveryTime)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1264.1">if</span></span><span class="koboSpan" id="kobo.1265.1">(_state.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1266.1">DeliveryTime</span></span><span class="koboSpan" id="kobo.1267.1"> &lt; newDeliveryTime)
    {
      _state.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1268.1">DeliveryTime</span></span><span class="koboSpan" id="kobo.1269.1"> = newDeliveryTime;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1270.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1271.1">true</span></span><span class="koboSpan" id="kobo.1272.1">;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1273.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1274.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1275.1">false</span></span><span class="koboSpan" id="kobo.1276.1">;
    }
    public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1277.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1278.1">AddItem</span></span><span class="koboSpan" id="kobo.1279.1"> (</span><span class="hljs-title"><span class="koboSpan" id="kobo.1280.1">PurchaseOrderItem</span></span><span class="koboSpan" id="kobo.1281.1"> x)
    { _state.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1282.1">Items</span></span><span class="koboSpan" id="kobo.1283.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1284.1">Add</span></span><span class="koboSpan" id="kobo.1285.1">(x); }
    public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1286.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1287.1">RemoveItem</span></span><span class="koboSpan" id="kobo.1288.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1289.1">PurchaseOrderItem</span></span><span class="koboSpan" id="kobo.1290.1"> x)
    { _state.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1291.1">Items</span></span><span class="koboSpan" id="kobo.1292.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1293.1">Remove</span></span><span class="koboSpan" id="kobo.1294.1">(x); }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1295.1">Now, we are ready to understand how to connect the two projects of our template with an actual database driver and an actual UI.</span></p>
<h2 class="heading-2" id="_idParaDest-62"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.1296.1">A complete solution based on the Onion Architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1297.1">The </span><em class="italic"><span class="koboSpan" id="kobo.1298.1">ch03</span></em><span class="koboSpan" id="kobo.1299.1"> folder of the bookâ€™s GitHub repository (</span><a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp"><span class="url"><span class="koboSpan" id="kobo.1300.1">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</span></span></a><span class="koboSpan" id="kobo.1301.1">) contains </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.1302.1">a complete solution, which, together with the application services and domain layer libraries, also features a database driver based on Entity Framework Core and a presentation layer based on an ASP.NET Core Web API project.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1303.1">The purpose of this project is to show how to use the general Onion Architecture template described in this section in an actual solution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1304.1">The following figure shows the complete solution:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1305.1"><img alt="Figure 3.9: A complete solution based on the Onion Architecture" src="../Images/B31916_03_9.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1306.1">Figure 3.9: A complete solution based on the Onion Architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1307.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1308.1">DBDrive</span></code><span class="koboSpan" id="kobo.1309.1">r project is a .NET library project where we added a dependency on the following Nuget packages:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1310.1">Microsoft.EntityFrameworkCore.SqlServer</span></code><span class="koboSpan" id="kobo.1311.1">: This package loads both Entity Framework Core and its SQL Server provider</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1312.1">Microsoft.EntityFrameworkCore.Tools</span></code><span class="koboSpan" id="kobo.1313.1">: This package provides all tools for scaffolding and handling database migrations</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1314.1"> Since the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1315.1">DBDriver</span></code><span class="koboSpan" id="kobo.1316.1"> project must provide a storage driver, it also has a dependency on the domain library project.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1317.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1318.1">WebApi</span></code><span class="koboSpan" id="kobo.1319.1"> project is </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.1320.1">an ASP.NET Core Web API project. </span><span class="koboSpan" id="kobo.1320.2">It works as the outermost layer of the Onion Architecture.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1321.1">The outermost layer of the Onion Architecture (in our example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1322.1">WebApi</span></code><span class="koboSpan" id="kobo.1323.1">) must have a dependency on the application services directory and all driversâ€™ projects (in our example, just </span><code class="inlineCode"><span class="koboSpan" id="kobo.1324.1">DBDrive</span></code><span class="koboSpan" id="kobo.1325.1">r).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1326.1">We added some folders and classes to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1327.1">DBDriver</span></code><span class="koboSpan" id="kobo.1328.1"> project that should be used in all drivers based on Entity Framework Core. </span><span class="koboSpan" id="kobo.1328.2">The following figure shows the project structure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1329.1"><img alt="Figure 3.10: DBDriver project structure" src="../Images/B31916_03_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1330.1">Figure 3.10: DBDriver project structure</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1331.1">Here is the description of all the folders:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1332.1">Entities</span></code><span class="koboSpan" id="kobo.1333.1">: Put all your Entity Framework Core entities here, possibly organized in subfolders.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1334.1">Repositories</span></code><span class="koboSpan" id="kobo.1335.1">: Put all repository implementations here, possibly organized in subfolders.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1336.1">MainDbContext</span></code><span class="koboSpan" id="kobo.1337.1">: This is the skeleton of the project Entity Framework DB context, which also contains the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1338.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.1339.1"> interface.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1340.1">Extensions</span></code><span class="koboSpan" id="kobo.1341.1">: This folder contains two extension classes. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1342.1">RepositoryExtensions</span></code><span class="koboSpan" id="kobo.1343.1"> just provides the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1344.1">AddAllRepositories</span></code><span class="koboSpan" id="kobo.1345.1"> extension method, which discovers all repository implementations and adds them to the dependency injection engine. </span><span class="koboSpan" id="kobo.1345.2">Its code is similar to one of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1346.1">AddAllCommandHandlers</span></code><span class="koboSpan" id="kobo.1347.1"> extension methods that we described in the previous subsection, so we will not describe it here. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1348.1">DBExtension</span></code><span class="koboSpan" id="kobo.1349.1"> contains just the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1350.1">AddDbDriver</span></code><span class="koboSpan" id="kobo.1351.1"> extension method, which adds all implementations provided by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1352.1">DBDriver</span></code><span class="koboSpan" id="kobo.1353.1"> to the dependency injection engine.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1354.1">The implementation</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.1355.1"> of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1356.1">AddDbDriver</span></code><span class="koboSpan" id="kobo.1357.1"> extension method is straightforward:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1358.1">public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1359.1">static</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1360.1">IServiceCollection</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1361.1">AddDbDriver</span></span><span class="koboSpan" id="kobo.1362.1">(
  </span><span class="hljs-variable"><span class="koboSpan" id="kobo.1363.1">this</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1364.1">IServiceCollection</span></span><span class="koboSpan" id="kobo.1365.1"> services,
  string connectionString)
{
  services.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1366.1">AddDbContext</span></span><span class="koboSpan" id="kobo.1367.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.1368.1">IUnitOfWork</span></span><span class="koboSpan" id="kobo.1369.1">, </span><span class="hljs-title"><span class="koboSpan" id="kobo.1370.1">MainDbContext</span></span><span class="koboSpan" id="kobo.1371.1">&gt;(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1372.1">options</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1373.1"> =&gt;</span></span><span class="koboSpan" id="kobo.1374.1">
    options.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1375.1">UseSqlServer</span></span><span class="koboSpan" id="kobo.1376.1">(connectionString,
      </span><span class="hljs-params"><span class="koboSpan" id="kobo.1377.1">b</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1378.1"> =&gt;</span></span><span class="koboSpan" id="kobo.1379.1"> b.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1380.1">MigrationsAssembly</span></span><span class="koboSpan" id="kobo.1381.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1382.1">"DBDriver"</span></span><span class="koboSpan" id="kobo.1383.1">)));
  services.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1384.1">AddAllRepositories</span></span><span class="koboSpan" id="kobo.1385.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1386.1">typeof</span></span><span class="koboSpan" id="kobo.1387.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1388.1">DBExtensions</span></span><span class="koboSpan" id="kobo.1389.1">).</span><span class="hljs-property"><span class="koboSpan" id="kobo.1390.1">Assembly</span></span><span class="koboSpan" id="kobo.1391.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1392.1">return</span></span><span class="koboSpan" id="kobo.1393.1"> services;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1394.1">It accepts the database connection string as its only input and adds the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1395.1">MainDbContext</span></code><span class="koboSpan" id="kobo.1396.1"> Entity Framework context as implementation for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1397.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.1398.1"> interface with the usual </span><code class="inlineCode"><span class="koboSpan" id="kobo.1399.1">AddDbContext </span></code><span class="koboSpan" id="kobo.1400.1">Entity Framework Core extension method. </span><span class="koboSpan" id="kobo.1400.2">Then, it calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1401.1">AddAllRepositories</span></code><span class="koboSpan" id="kobo.1402.1"> method to add all repository implementations provided by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">DBDriver</span></code><span class="koboSpan" id="kobo.1404.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1405.1">Here is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1406.1">MainDbContext</span></code><span class="koboSpan" id="kobo.1407.1"> class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1408.1">internal </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1409.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1410.1">MainDbContext</span></span><span class="koboSpan" id="kobo.1411.1"> : </span><span class="hljs-title"><span class="koboSpan" id="kobo.1412.1">DbContext</span></span><span class="koboSpan" id="kobo.1413.1">, </span><span class="hljs-title"><span class="koboSpan" id="kobo.1414.1">IUnitOfWork</span></span><span class="koboSpan" id="kobo.1415.1">
{
  public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1416.1">MainDbContext</span></span><span class="koboSpan" id="kobo.1417.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1418.1">DbContextOptions</span></span><span class="koboSpan" id="kobo.1419.1"> options)
    : </span><span class="hljs-title"><span class="koboSpan" id="kobo.1420.1">base</span></span><span class="koboSpan" id="kobo.1421.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1422.1">options</span></span><span class="koboSpan" id="kobo.1423.1">)
    {
    }
  protected override </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1424.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1425.1">OnModelCreating</span></span><span class="koboSpan" id="kobo.1426.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1427.1">ModelBuilder</span></span><span class="koboSpan" id="kobo.1428.1"> builder)
   {
  }
  region </span><span class="hljs-title"><span class="koboSpan" id="kobo.1429.1">IUnitOfWork</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1430.1">Implementation</span></span><span class="koboSpan" id="kobo.1431.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1432.1">The class is defined as internal since it must not be visible outside of the database driver. </span><span class="koboSpan" id="kobo.1432.2">All entity configurations must be placed inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1433.1">OnModelCreating</span></code><span class="koboSpan" id="kobo.1434.1"> method as usual.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1435.1">The implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1436.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.1437.1"> is minimized. </span><span class="koboSpan" id="kobo.1437.2">The exploded code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1438.1">#region </span><span class="hljs-title"><span class="koboSpan" id="kobo.1439.1">IUnitOfWork</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1440.1">Implementation</span></span><span class="koboSpan" id="kobo.1441.1">
public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1442.1">async</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1443.1">Task</span></span><span class="koboSpan" id="kobo.1444.1">&lt;bool&gt; </span><span class="hljs-title"><span class="koboSpan" id="kobo.1445.1">SaveEntitiesAsync</span></span><span class="koboSpan" id="kobo.1446.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1447.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1448.1">await</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1449.1">SaveChangesAsync</span></span><span class="koboSpan" id="kobo.1450.1">() &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1451.1">0</span></span><span class="koboSpan" id="kobo.1452.1">; ;
}
public </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1453.1">async</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1454.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1455.1">StartAsync</span></span><span class="koboSpan" id="kobo.1456.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1457.1">await</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1458.1">Database</span></span><span class="koboSpan" id="kobo.1459.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1460.1">BeginTransactionAsync</span></span><span class="koboSpan" id="kobo.1461.1">();
}
public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1462.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1463.1">CommitAsync</span></span><span class="koboSpan" id="kobo.1464.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1465.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1466.1">Database</span></span><span class="koboSpan" id="kobo.1467.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1468.1">CommitTransactionAsync</span></span><span class="koboSpan" id="kobo.1469.1">();
}
public </span><span class="hljs-title"><span class="koboSpan" id="kobo.1470.1">Task</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1471.1">RollbackAsync</span></span><span class="koboSpan" id="kobo.1472.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1473.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1474.1">Database</span></span><span class="koboSpan" id="kobo.1475.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1476.1">RollbackTransactionAsync</span></span><span class="koboSpan" id="kobo.1477.1">();
}
#endregion
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1478.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1479.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.1480.1"> implementation is straightforward since it consists of a one-to-one coupling with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1481.1">DBContext</span></code><span class="koboSpan" id="kobo.1482.1"> methods.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.1483.1"> Since we expose just </span><code class="inlineCode"><span class="koboSpan" id="kobo.1484.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.1485.1"> in the dependency injection engine, all repositories that need </span><code class="inlineCode"><span class="koboSpan" id="kobo.1486.1">MainDbContext</span></code><span class="koboSpan" id="kobo.1487.1"> for their job must require </span><code class="inlineCode"><span class="koboSpan" id="kobo.1488.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.1489.1"> in their constructors, and then they must cast it to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1490.1">MainDbContext</span></code><span class="koboSpan" id="kobo.1491.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1492.1">Having</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.1493.1"> discussed what we need to know about </span><code class="inlineCode"><span class="koboSpan" id="kobo.1494.1">DBDriver</span></code><span class="koboSpan" id="kobo.1495.1">, letâ€™s move to the Web API project.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1496.1"> Connecting the outermost project of an Onion Architecture is easy. </span><span class="koboSpan" id="kobo.1496.2">We just need to call the extension method exposed by the application services, which injects all application services implementations in the dependency injection engine, and we need to call the extension methods of all drivers.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1497.1">In our case, we need to add just two calls to </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.1498.1">Program.cs</span></code><span class="koboSpan" id="kobo.1499.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1500.1">..
</span><span class="koboSpan" id="kobo.1500.2">builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1501.1">Services</span></span><span class="koboSpan" id="kobo.1502.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1503.1">AddControllers</span></span><span class="koboSpan" id="kobo.1504.1">();
builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1505.1">Services</span></span><span class="koboSpan" id="kobo.1506.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1507.1">AddEndpointsApiExplorer</span></span><span class="koboSpan" id="kobo.1508.1">();
builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1509.1">Services</span></span><span class="koboSpan" id="kobo.1510.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1511.1">AddSwaggerGen</span></span><span class="koboSpan" id="kobo.1512.1">();
builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1513.1">Services</span></span><span class="koboSpan" id="kobo.1514.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1515.1">AddApplicationServices</span></span><span class="koboSpan" id="kobo.1516.1">();
builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1517.1">Services</span></span><span class="koboSpan" id="kobo.1518.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1519.1">AddDbDriver</span></span><span class="koboSpan" id="kobo.1520.1">(
  builder.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1521.1">Configuration</span></span><span class="koboSpan" id="kobo.1522.1">?.</span><span class="hljs-title"><span class="koboSpan" id="kobo.1523.1">GetConnectionString</span></span><span class="koboSpan" id="kobo.1524.1">(
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1525.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1526.1">DefaultConnection"</span></span><span class="koboSpan" id="kobo.1527.1">) ?? </span><span class="koboSpan" id="kobo.1527.2">string.</span><span class="hljs-property"><span class="koboSpan" id="kobo.1528.1">Empty</span></span><span class="koboSpan" id="kobo.1529.1">);
..
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1530.1">At this point, in </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.1531.1">the case of the ASP.NET Core project, all that remains is to acquire the command handlers for the commands that we need in the constructors of our controllers. </span><span class="koboSpan" id="kobo.1531.2">After that, each action method must just use the input that it received to build adequate commands, and then it must invoke the handler associated with each command.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1532.1">The short description of how to handle the outermost layer of an Onion Architecture completes our short introduction to this architecture, but we will find examples throughout the remainder of the book since we will use them for most of our code examples.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1533.1">Letâ€™s move on to another important building block of microservices architecture: containers!</span></p>
<h1 class="heading-1" id="_idParaDest-63"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.1534.1">Containers and Docker</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1535.1">Weâ€™ve already discussed the advantages of having microservices</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.1536.1"> that donâ€™t depend on the environment where they run; microservices can be moved from busy nodes to idle nodes without constraints, thus achieving a better load balance and, consequently, better usage of the available hardware.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1537.1">However, if we need to mix legacy software with newer modules or if we would like to use the best stack for each module, with the ability to mix several development stack implementations, we are faced with the problem that each different stack has different hardware/software prerequisites. </span><span class="koboSpan" id="kobo.1537.2">In these cases, the independence of each microservice from the hosting environment can be restored by deploying each microservice, together with all its dependencies, on a private virtual machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1538.1">However, starting a virtual machine with its private copy of the operating system takes a lot of time, and microservices must be started and stopped quickly to reduce load-balancing and fault recovery costs. </span><span class="koboSpan" id="kobo.1538.2">Luckily, microservices can rely on a lighter form of virtualization technology: containers. </span><span class="koboSpan" id="kobo.1538.3">Containers provide</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.1539.1"> a lightweight and efficient form of virtualization. </span><span class="koboSpan" id="kobo.1539.2">Unlike traditional virtual machines that virtualize an entire machine, including the operating system, containers virtualize at the operating systemâ€™s filesystem level, sitting on top of the host operating system kernel. </span><span class="koboSpan" id="kobo.1539.3">They use the operating system of the host machine (kernel, DLLs, and drivers) and use the operating systemâ€™s native features to isolate processes and resources, creating an isolated environment for the images they run.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1540.1">The following figure shows how</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.1541.1"> containers work:</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.1542.1"><img alt="Figure 3.11: Container basic principles" src="../Images/B31916_03_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1543.1">Figure 3.11: Container basic principles</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1544.1">Containers are run by the containersâ€™ runtime </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.1545.1">from </span><strong class="keyWord"><span class="koboSpan" id="kobo.1546.1">images</span></strong><span class="koboSpan" id="kobo.1547.1"> that encode their content. </span><span class="koboSpan" id="kobo.1547.2">The same image can create several identical containers. </span><span class="koboSpan" id="kobo.1547.3">Images are stored in </span><strong class="keyWord"><span class="koboSpan" id="kobo.1548.1">image registries</span></strong><span class="koboSpan" id="kobo.1549.1"> that identify </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.1550.1">them through both an image name and an image version. </span><span class="koboSpan" id="kobo.1550.2">In turn, images are created by commands in a text file that specify both the containerâ€™s content and properties.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1551.1">More specifically, names are URLs whose domain part is the registry domain, and the path part is composed of a namespace that includes related images and a repository name. </span><span class="koboSpan" id="kobo.1551.2">The version is attached to this URL with a colon and is called </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.1552.1">tag</span></code><span class="koboSpan" id="kobo.1553.1"> since it can be any string. </span><span class="koboSpan" id="kobo.1553.2">Summing up, the name and version are encoded as shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1554.1">&lt;registry domain&gt;/&lt;namespace&gt;/&lt;repository name&gt;:&lt;tag&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1555.1">Thus, for instance, the ASP.NET CORE 9.0 runtime Docker imageâ€™s full URL is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1556.1">mcr.microsoft.com/dotnet/aspnet:9.0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1557.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1558.1">mcr.microsoft.com</span></code><span class="koboSpan" id="kobo.1559.1"> is the registry domain, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1560.1">dotnet</span></code><span class="koboSpan" id="kobo.1561.1"> is the namespace, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1562.1">asp.net</span></code><span class="koboSpan" id="kobo.1563.1"> is the repository name, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1564.1">9.0</span></code><span class="koboSpan" id="kobo.1565.1"> is the tag.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1566.1">Any runtime that needs to create containers downloads its image from a registry, possibly providing credentials, and then uses the downloaded images to create the containers. </span><span class="koboSpan" id="kobo.1566.2">The following figure shows the whole process of container creation:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1567.1"><img alt="Figure 3.12: Containers/images lifecycle" src="../Images/B31916_03_12.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1568.1">Figure 3.12: Containers/images lifecycle</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1569.1">In the remainder of the </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.1570.1">book, we will use Docker containers as a de facto standard. </span><span class="koboSpan" id="kobo.1570.2">Each Docker image is generated by specifying changes to apply to another preexisting image with </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.1571.1">the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1572.1">Docker containers description language</span></strong><span class="koboSpan" id="kobo.1573.1">. </span><span class="koboSpan" id="kobo.1573.2">The </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.1574.1">instructions for creating a Docker image are contained in a file that must be named </span><strong class="keyWord"><span class="koboSpan" id="kobo.1575.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.1576.1"> (without any file extension).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1577.1">Each </span><strong class="keyWord"><span class="koboSpan" id="kobo.1578.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.1579.1"> usually starts with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1580.1">FROM</span></code><span class="koboSpan" id="kobo.1581.1"> instruction that specifies the preexisting image to modify, as shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1582.1">FROM mcr.microsoft.com/dotnet/aspnet:9.0
...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1583.1">The tag with the ASP.NET CORE version to use is specified after the image URL, preceded by a colon, as shown in the preceding code. </span><span class="koboSpan" id="kobo.1583.2">Images taken from private repositories must be specified with their complete URL, which starts with the domain of the registry. </span><span class="koboSpan" id="kobo.1583.3">Images without their complete URL are allowed only when they are hosted on the Docker free public registry, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1584.1">hub.docker.com/r/</span></code><span class="koboSpan" id="kobo.1585.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1586.1">The following figure shows the hierarchical organization</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.1587.1"> of Docker images:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1588.1"><img alt="Figure 3.13: Hierarchy of images and containers" src="../Images/B31916_03_13.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1589.1">Figure 3.13: Hierarchy of images and containers</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1590.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1591.1">FROM</span></code><span class="koboSpan" id="kobo.1592.1"> statement specifies</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.1593.1"> the environment you are in, called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1594.1">build stage</span></strong><span class="koboSpan" id="kobo.1595.1">. </span><span class="koboSpan" id="kobo.1595.2">After </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.1596.1">that, you can deal with the image as if it were a filesystem by copying files from your </span><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.1597.1">computer into it and by executing shell commands:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1598.1"><img alt="Figure 3.14: Building the image" src="../Images/B31916_03_14.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1599.1">Figure 3.14: Building the image</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1600.1"> In all copy operations, you can use relative paths on your computer. </span><span class="koboSpan" id="kobo.1600.2">They are assumed to be relative to the directory that contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1601.1">Dockerfile</span></code><span class="koboSpan" id="kobo.1602.1"> file.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1603.1">Here are the main </span><code class="inlineCode"><span class="koboSpan" id="kobo.1604.1">Dockerfile</span></code><span class="koboSpan" id="kobo.1605.1"> commands:</span></p>
<ul>
<li class="snippet-con"><span class="koboSpan" id="kobo.1606.1">WORKDIR &lt;path in the image file system&gt;</span><p class="normal-one"><span class="koboSpan" id="kobo.1607.1">This </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.1608.1">instruction defines the current directory in the image filesystem. </span><span class="koboSpan" id="kobo.1608.2">If the directory doesnâ€™t exist, it is created. </span><span class="koboSpan" id="kobo.1608.3">After that, you can use relative paths also in the image filesystem.</span></p>
</li>
<li class="snippet-con"><span class="koboSpan" id="kobo.1609.1">COPY &lt;path in your computer&gt; &lt;path in the image&gt;</span><p class="normal-one"><span class="koboSpan" id="kobo.1610.1">Copy one or more files into the image filesystem. </span><span class="koboSpan" id="kobo.1610.2">If the source path denotes a folder, the whole folder is recursively copied; otherwise, a single file is copied. </span><span class="koboSpan" id="kobo.1610.3">In any case, the directory or file copied takes the name specified in the image path.</span></p>
</li>
<li class="snippet-con"><span class="koboSpan" id="kobo.1611.1">Copy &lt;path1&gt; &lt;path2&gt; â€¦ ./ (or [&lt;path1&gt;, &lt;path2&gt;, â€¦, ./]</span><p class="normal-one"><span class="koboSpan" id="kobo.1612.1">The content specified by all source paths is copied into the imageâ€™s current directory. </span><span class="koboSpan" id="kobo.1612.2">Source file names are not changed.</span></p>
</li>
<li class="snippet-con"><span class="koboSpan" id="kobo.1613.1">Copy â€“-from=&lt;image name or url&gt;:&lt;version&gt; â€¦</span><p class="normal-one"><span class="koboSpan" id="kobo.1614.1">This works like the previous copy commands but files are taken from the image specified by the name/URL after </span><code class="inlineCode"><span class="koboSpan" id="kobo.1615.1">from=</span></code><span class="koboSpan" id="kobo.1616.1">. </span><span class="koboSpan" id="kobo.1616.2">A name can be specified instead of a URL only if the image is contained in your computer or the Docker public repository. </span><span class="koboSpan" id="kobo.1616.3">If no version is specified, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1617.1">latest</span></code><span class="koboSpan" id="kobo.1618.1"> is assumed as the default version name.</span></p>
</li>
<li class="snippet-con"><span class="koboSpan" id="kobo.1619.1">RUN &lt;command&gt; &lt;arg1&gt; &lt;arg2&gt; ...</span><p class="normal-one"><span class="koboSpan" id="kobo.1620.1">This executes the specified shell command with the specified arguments in the current directory of the image.</span></p>
</li>
<li class="snippet-con"><span class="koboSpan" id="kobo.1621.1">CMD [&lt;command&gt;, &lt;arg1&gt;, &lt;arg2&gt;, ...]
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.1622.1">ENTRYPOINT [&lt;command&gt;, &lt;arg1&gt;, &lt;arg2&gt;, ...]
</span></code></pre>
<p class="normal-one"><span class="koboSpan" id="kobo.1623.1">This specifies what happens when the container is executed. </span><span class="koboSpan" id="kobo.1623.2">More specifically, it declares both the command and arguments to run when the container is executed.</span></p>
</li>
<li class="snippet-con"><span class="koboSpan" id="kobo.1624.1">EXPOSE &lt;port1&gt; &lt;port2&gt;</span><p class="normal-one"><span class="koboSpan" id="kobo.1625.1">This declares all ports supported by the container. </span><span class="koboSpan" id="kobo.1625.2">Network traffic should be redirected into the container only through the ports declared here, but traffic directed to other ports is not </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.1626.1">blocked.</span></p>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1627.1">A Dockerfile can also build intermediary images as a step to define the final image. </span><span class="koboSpan" id="kobo.1627.2">For instance, an image containing the whole .NET SDK can be created with the only purpose of compiling a .NET solution. </span><span class="koboSpan" id="kobo.1627.3">Then, the final binaries will be copied with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1628.1">Copy â€“-from=â€¦</span></code><span class="koboSpan" id="kobo.1629.1"> instruction in the final image, which contains just the .NET runtime. </span><span class="koboSpan" id="kobo.1629.2">We will analyze this possibility in more detail when discussing Visual Studio support for Docker.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1630.1">Letâ€™s move on to a very simple example to familiarize ourselves with both Dockerfile instructions and the shell commands that manipulate Docker images and containers.</span></p>
<h2 class="heading-2" id="_idParaDest-64"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.1631.1">Docker Desktop: a simple example</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1632.1">In order to operate with Docker on a</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.1633.1"> client computer, you need to install </span><strong class="keyWord"><span class="koboSpan" id="kobo.1634.1">Doker Desktop</span></strong><span class="koboSpan" id="kobo.1635.1">. </span><span class="koboSpan" id="kobo.1635.2">Please refer to the instructions in the </span><em class="italic"><span class="koboSpan" id="kobo.1636.1">Technical requirements</span></em><span class="koboSpan" id="kobo.1637.1"> section for its installation. </span><span class="koboSpan" id="kobo.1637.2">As described in the </span><em class="italic"><span class="koboSpan" id="kobo.1638.1">Technical requirements</span></em><span class="koboSpan" id="kobo.1639.1"> section, all examples suppose a Windows machine with WSL installed and Docker Desktop configured for Linux containers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1640.1">Once you have installed Docker Desktop, you will have the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1641.1">The Docker runtime, so </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.1642.1">you can instantiate containers from images, and run them on your computer.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1643.1">A Docker client, so you can </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.1644.1">compile Dockerfiles into images, and execute other Docker-related shell commands.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1645.1">A Docker local registry. </span><span class="koboSpan" id="kobo.1645.2">All images </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.1646.1">compiled on your computer will be placed here. </span><span class="koboSpan" id="kobo.1646.2">From here, you can move them to other registries. </span><span class="koboSpan" id="kobo.1646.3">Moreover, before creating containers on your machine, you need to download their images here.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1647.1">In order to show the power of Docker, we will start with a simple Java example. </span><span class="koboSpan" id="kobo.1647.2">You will see that you donâ€™t need either the Java runtime or Java SDK to compile and run a simple Java program because everything needed is downloaded into the image being built.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1648.1">Letâ€™s start by creating a folder in which to place all the files needed to build the image. </span><span class="koboSpan" id="kobo.1648.2">Letâ€™s call it </span><code class="inlineCode"><span class="koboSpan" id="kobo.1649.1">SimpleExample</span></code><span class="koboSpan" id="kobo.1650.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1651.1">In this folder, place a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1652.1">Hello.java</span></code><span class="koboSpan" id="kobo.1653.1"> file containing the following simple code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1654.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1655.1">Hello</span></span><span class="koboSpan" id="kobo.1656.1">{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1657.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1658.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1659.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1660.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1661.1">(String[] args)</span></span><span class="koboSpan" id="kobo.1662.1">{
    System.out.println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1663.1">"This program runs in a  Docker container"</span></span><span class="koboSpan" id="kobo.1664.1">);
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1665.1">Now, in the same folder, we need just a</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.1666.1"> Dockerfile </span><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.1667.1">with the following content:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1668.1">FROM eclipse-temurin:11
COPY . </span><span class="koboSpan" id="kobo.1668.2">/var/www/java
WORKDIR /var/www/java
RUN javac Hello.java
CMD ["java", "Hello"]
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1669.1">eclipse-temurin</span></code><span class="koboSpan" id="kobo.1670.1"> is a Java SDK. </span><span class="koboSpan" id="kobo.1670.2">This will enable us both to compile and execute Java code in our image and our containers. </span><span class="koboSpan" id="kobo.1670.3">Then, the code copies everything in our folder into the newly created </span><code class="inlineCode"><span class="koboSpan" id="kobo.1671.1">/var/www/java</span></code><span class="koboSpan" id="kobo.1672.1"> path in the image being built. </span><span class="koboSpan" id="kobo.1672.2">Please remember that relative paths on the source are evaluated with respect to the position of the Dockerfile.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1673.1">Finally, we move to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1674.1">var/www/java</span></code><span class="koboSpan" id="kobo.1675.1"> folder and run the Java compiler, which will create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1676.1">.jar</span></code><span class="koboSpan" id="kobo.1677.1"> file in the same folder. </span><span class="koboSpan" id="kobo.1677.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1678.1">CMD</span></code><span class="koboSpan" id="kobo.1679.1"> instruction specifies invoking the Java command on the previously created </span><code class="inlineCode"><span class="koboSpan" id="kobo.1680.1">.jar</span></code><span class="koboSpan" id="kobo.1681.1"> file when a container based on this image will be executed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1682.1">Now, we need a Linux shell opened in our </span><code class="inlineCode"><span class="koboSpan" id="kobo.1683.1">SimpleExample</span></code><span class="koboSpan" id="kobo.1684.1"> folder to execute Docker commands. </span><span class="koboSpan" id="kobo.1684.2">Right-click on the image of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1685.1">SimpleExample</span></code><span class="koboSpan" id="kobo.1686.1"> folder by simultaneously pressing the </span><em class="italic"><span class="koboSpan" id="kobo.1687.1">shift</span></em><span class="koboSpan" id="kobo.1688.1"> key, and choose the option to open a Linux shell from the menu that appears.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1689.1">As a first step, we need to </span><em class="italic"><span class="koboSpan" id="kobo.1690.1">build</span></em><span class="koboSpan" id="kobo.1691.1"> our </span><code class="inlineCode"><span class="koboSpan" id="kobo.1692.1">Dockerfile</span></code><span class="koboSpan" id="kobo.1693.1"> instructions to create an image. </span><span class="koboSpan" id="kobo.1693.2">This is done with the </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.1694.1">build</span></code><span class="koboSpan" id="kobo.1695.1"> command, as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1696.1">docker build ./ -t simpleexample
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1697.1">The first argument specifies the location of the Dockerfile, while the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1698.1">-t</span></code><span class="koboSpan" id="kobo.1699.1"> option specifies a tag (an image URL) to attach to the image, in our case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1700.1">simpleexample</span></code><span class="koboSpan" id="kobo.1701.1">. </span><span class="koboSpan" id="kobo.1701.2">Since the image will be placed in our local Docker Desktop registry, it is enough to specify the repository part of the URL, but if you have several local</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.1702.1"> images, you can also add a namespace to better classify your images. </span><span class="koboSpan" id="kobo.1702.2">Usually, at this stage, no version tag is added, and Docker assumes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1703.1">latest</span></code><span class="koboSpan" id="kobo.1704.1"> default tag.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1705.1"> Remember: all image names must be lowercase!</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1706.1">The compilation might take a few seconds. </span><span class="koboSpan" id="kobo.1706.2">If you look at the console while it is compiling, you can see that other images are recursively downloaded, because each image is built upon other images, and so on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1707.1">Now, issue the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1708.1">docker images</span></code><span class="koboSpan" id="kobo.1709.1"> command to se</span><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.1710.1">e all images defined on your local registry. </span><span class="koboSpan" id="kobo.1710.2">You should see </span><code class="inlineCode"><span class="koboSpan" id="kobo.1711.1">simpleexample</span></code><span class="koboSpan" id="kobo.1712.1"> among them. </span><span class="koboSpan" id="kobo.1712.2">Images are also listed in the UI that appears when you double-click on the Docker Desktop icon on your desktop.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1713.1">Now, letâ€™s create a container based on the newly created images. </span><span class="koboSpan" id="kobo.1713.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1714.1">run</span></code><span class="koboSpan" id="kobo.1715.1"> command creates a container based on a given image and immediately executes it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1716.1">docker run --name myfirstcontainer simpleexample
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1717.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1718.1">--name</span></code><span class="koboSpan" id="kobo.1719.1"> option specifies a name for the container while the other argument is the name of the image we want to use to create the container. </span><span class="koboSpan" id="kobo.1719.2">The container prints the string we put in our Java class and then exits quickly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1720.1">Letâ€™s list all executing containers with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1721.1">docker ps</span></code><span class="koboSpan" id="kobo.1722.1">. </span><span class="koboSpan" id="kobo.1722.2">No container has been listed since our container finished its execution. </span><span class="koboSpan" id="kobo.1722.3">However, we can see also all non-running containers with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1723.1">--all</span></code><span class="koboSpan" id="kobo.1724.1"> option:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1725.1">docker ps --all
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1726.1">Letâ€™s re-execute our container. </span><span class="koboSpan" id="kobo.1726.2">If we re-execute the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1727.1">run</span></code><span class="koboSpan" id="kobo.1728.1"> command, we will create another container, so the right way to re-execute a sleeping container is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1729.1">docker restart myfirstcontainer
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1730.1">However, in this case, no </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.1731.1">string is printed on the console because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1732.1">restart</span></code><span class="koboSpan" id="kobo.1733.1"> runs the container into another process. </span><span class="koboSpan" id="kobo.1733.2">You might find this strange but it is not, because containers usually run a never-ending loop that might block your shell.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1734.1">Neverending containers can be stopped with something like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1735.1">docker stop myfirstcontainer
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1736.1">When you have finished with your container, you can remove it with the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1737.1">docker rm myfirstcontainer
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1738.1">Now, you can remove also the image used to create the container with the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1739.1">docker rmi simpleexample
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1740.1">You have learned a lot of useful Docker shell commands. </span><span class="koboSpan" id="kobo.1740.2">The next section is dedicated to the description of some more advanced useful commands.</span></p>
<h2 class="heading-2" id="_idParaDest-65"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.1741.1">A few more Docker commands and options</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1742.1">During </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.1743.1">microservice operations, Docker containers are moved from one hardware node to another to balance the load. </span><span class="koboSpan" id="kobo.1743.2">Unfortunately, when a container is removed to create it elsewhere, all files saved in its filesystem are lost. </span><span class="koboSpan" id="kobo.1743.3">For this reason, some portions of the containerâ€™s filesystem are mapped to external storage, typically provided by network disk units.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1744.1">This is possible because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1745.1">run</span></code><span class="koboSpan" id="kobo.1746.1"> command has the option to map a directory in the host machine (say, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1747.1">S</span></code><span class="koboSpan" id="kobo.1748.1">) to a directory in the containerâ€™s internal storage space (say, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1749.1">D</span></code><span class="koboSpan" id="kobo.1750.1">) so that files written to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1751.1">D</span></code><span class="koboSpan" id="kobo.1752.1"> are actually saved in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1753.1">S</span></code><span class="koboSpan" id="kobo.1754.1">, and remain safe also after the container has been removed. </span><span class="koboSpan" id="kobo.1754.2">This operation is </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.1755.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1756.1">bind mount</span></strong><span class="koboSpan" id="kobo.1757.1">, and the option to add it to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1758.1">run</span></code><span class="koboSpan" id="kobo.1759.1"> command is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1760.1">docker run -v &lt;host machine path&gt;:&lt;container path&gt; ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1761.1">Another option allows the mapping of each port exposed by the container to an actual port on the host computer:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1762.1">docker run -p &lt;host machine port&gt;:&lt;container port&gt; ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1763.1">This option can be repeated several times to map more than one port. </span><span class="koboSpan" id="kobo.1763.2">Without this option, it would be impossible to redirect network traffic inside the container.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1764.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1765.1">-e</span></code><span class="koboSpan" id="kobo.1766.1"> option passes operating system environment variables to the container. </span><span class="koboSpan" id="kobo.1766.2">The code running in the container can easily ask the values of these variables to the operating system, so they are the preferred way to configure an application:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1767.1">docker run -e mayvariable1=mayvalue1  -e mayvariable2=mayvalue2. </span><span class="koboSpan" id="kobo.1767.2">..
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1768.1">Another useful option of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1769.1">run</span></code><span class="koboSpan" id="kobo.1770.1"> command is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1771.1">-d</span></code><span class="koboSpan" id="kobo.1772.1"> option (</span><em class="italic"><span class="koboSpan" id="kobo.1773.1">d</span></em><span class="koboSpan" id="kobo.1774.1"> stands for </span><em class="italic"><span class="koboSpan" id="kobo.1775.1">detached</span></em><span class="koboSpan" id="kobo.1776.1">):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1777.1">docker run -d ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1778.1">When this option is provided, the container is launched detached from the current shell prompt, that is, in a different process. </span><span class="koboSpan" id="kobo.1778.2">This way, a container that hosts a never-ending program, such as a web server, doesnâ€™t block the shell prompt.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1779.1">Each image can be attached to an indefinite number of tags that can be used as alternative names:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1780.1">docker tag &lt;image name&gt; &lt;tag&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1781.1">Tagging is the </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.1782.1">first step for pushing a local image into a public registry. </span><span class="koboSpan" id="kobo.1782.2">Suppose we have an image called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1783.1">myimage</span></code><span class="koboSpan" id="kobo.1784.1"> that we would like to push to a private registry we have on Azure, say, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1785.1">myregistry.azurecr.io/</span></code><span class="koboSpan" id="kobo.1786.1">. </span><span class="koboSpan" id="kobo.1786.2">Suppose we would like to place thi</span><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.1787.1">s image in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1788.1">mypath/mymage</span></code><span class="koboSpan" id="kobo.1789.1"> path of this registry, that is, to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1790.1">myregistry.azurecr.io/mypath/mymage</span></code><span class="koboSpan" id="kobo.1791.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1792.1">As a first step, we tag our image with its final URL:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1793.1">docker tag myimage myregistry.azurecr.io/mypath/mymage
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1794.1">Then, it is enough to execute a </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.1795.1">push</span></code><span class="koboSpan" id="kobo.1796.1"> operation that uses the new tag attached to the image:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1797.1">docker push myregistry.azurecr.io/mypath/mymage:&lt;version&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1798.1">Pulling public registry images to our local registry instead is straightforward:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1799.1">docker pull myregistry.azurecr.io/mypath/myotherimage:&lt;version&gt;
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1800.1"> Before interacting with a registry that requires a login, we must perform a login operation. </span><span class="koboSpan" id="kobo.1800.2">Each registry has its own login procedure.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1801.1">The simplest way to log in to an Azure registry is by using the Azure CLI. </span><span class="koboSpan" id="kobo.1801.2">You can download its installer here: </span><a href="https://aka.ms/installazurecliwindows"><span class="url"><span class="koboSpan" id="kobo.1802.1">https://aka.ms/installazurecliwindows</span></span></a><span class="koboSpan" id="kobo.1803.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1804.1">As a first step, log in to your Azure account with the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1805.1">az login
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1806.1">This command</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.1807.1"> should start your default browser and should drive you through the manual login procedure in your Azure account. </span><span class="koboSpan" id="kobo.1807.2">Once logged in to your Azure account, you can log in to your private registry by typing the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1808.1">az acr login --name &lt;registryname&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1809.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1810.1">&lt;registryname&gt;</span></code><span class="koboSpan" id="kobo.1811.1"> is the unique name of your Azure registry, not its complete URL. </span><span class="koboSpan" id="kobo.1811.2">After logging in, you can freely work with your Azure registry.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1812.1">Visual Studio has native support for Docker. </span><span class="koboSpan" id="kobo.1812.2">Letâ€™s analyze all the possibilities offered by this support.</span></p>
<h2 class="heading-2" id="_idParaDest-66"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.1813.1">Visual Studio support for Docker</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1814.1">Visual Studio support</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.1815.1"> for Docker can be enabled by simply selecting the </span><strong class="screenText"><span class="koboSpan" id="kobo.1816.1">Enable container support</span></strong><span class="koboSpan" id="kobo.1817.1"> checkbox in the appropriate Visual Studio project options. </span><span class="koboSpan" id="kobo.1817.2">Letâ€™s </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.1818.1">experiment with an ASP.NET Core MVC project. </span><span class="koboSpan" id="kobo.1818.2">After the project selection and after having chosen the project name, say, </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.1819.1">DockerTest</span></code><span class="koboSpan" id="kobo.1820.1">, you should arrive at the following option page:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1821.1"><img alt="Figure 3.15: Enabling Docker support" src="../Images/B31916_03_15.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1822.1">Figure 3.15: Enabling Docker support</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1823.1">Please check the </span><strong class="screenText"><span class="koboSpan" id="kobo.1824.1">Enable container support</span></strong><span class="koboSpan" id="kobo.1825.1"> checkbox.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1826.1">If you forgot to enable Docker support here, you can always right-click on the project icon in Visual Studio Solution Explorer and then select </span><strong class="screenText"><span class="koboSpan" id="kobo.1827.1">Add </span></strong><span class="koboSpan" id="kobo.1828.1">-&gt;</span><strong class="screenText"><span class="koboSpan" id="kobo.1829.1"> Docker support</span></strong><span class="koboSpan" id="kobo.1830.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1831.1">The project contains a Dockerfile:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1832.1"><img alt="Figure 3.16: Visual Studio Dockerfile" src="../Images/B31916_03_16.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1833.1">Figure 3.16: Visual Studio Dockerfile</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1834.1">Click on the Dockerfile; it should contain the definition of four images. </span><span class="koboSpan" id="kobo.1834.2">In fact, the final image is built in four stages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1835.1">The first stage defines the .NET runtime and the ports used by the application in the final image:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1836.1">FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 8080
EXPOSE 8081
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1837.1">The name </span><code class="inlineCode"><span class="koboSpan" id="kobo.1838.1">base</span></code><span class="koboSpan" id="kobo.1839.1"> after </span><code class="inlineCode"><span class="koboSpan" id="kobo.1840.1">AS</span></code><span class="koboSpan" id="kobo.1841.1"> will </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.1842.1">be called by other </span><code class="inlineCode"><span class="koboSpan" id="kobo.1843.1">FROM</span></code><span class="koboSpan" id="kobo.1844.1"> instructions in the same file. </span><span class="koboSpan" id="kobo.1844.2">The</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.1845.1"> second stage performs the project build by using the </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.1846.1">dotnet</span></code><span class="koboSpan" id="kobo.1847.1"> SDK:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1848.1">FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["DockerTest/DockerTest.csproj", "DockerTest/"]
RUN dotnet restore "./DockerTest/DockerTest.csproj"
COPY . </span><span class="koboSpan" id="kobo.1848.2">.
</span><span class="koboSpan" id="kobo.1848.3">WORKDIR "/src/DockerTest"
RUN dotnet build "./DockerTest.csproj" -c $BUILD_CONFIGURATION -o /app/build
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1849.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1850.1">ARG</span></code><span class="koboSpan" id="kobo.1851.1"> instruction defines a variable that can be recalled as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1852.1">$BUILD_CONFIGURATION</span></code><span class="koboSpan" id="kobo.1853.1"> in other instructions. </span><span class="koboSpan" id="kobo.1853.2">Here, it is used to define the chosen configuration for the build. </span><span class="koboSpan" id="kobo.1853.3">You can replace its value with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1854.1">Debug</span></code><span class="koboSpan" id="kobo.1855.1"> to compile in Debug mode.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1856.1">The first </span><code class="inlineCode"><span class="koboSpan" id="kobo.1857.1">Copy</span></code><span class="koboSpan" id="kobo.1858.1"> instruction just copies the project file in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1859.1">/src/DockerTest</span></code><span class="koboSpan" id="kobo.1860.1"> directory of the image. </span><span class="koboSpan" id="kobo.1860.2">Then, Nuget packages are restored and all source files are copied from the directory containing the Dockerfile to the current image directory, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1861.1">/src</span></code><span class="koboSpan" id="kobo.1862.1">. </span><span class="koboSpan" id="kobo.1862.2">Finally, we move into </span><code class="inlineCode"><span class="koboSpan" id="kobo.1863.1">/src/DockerTest</span></code><span class="koboSpan" id="kobo.1864.1"> and perform a build. </span><span class="koboSpan" id="kobo.1864.2">The build output files are placed in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1865.1">/app/build</span></code><span class="koboSpan" id="kobo.1866.1"> directory in the image.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1867.1">The third stage is built on top of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1868.1">build</span></code><span class="koboSpan" id="kobo.1869.1"> image and simply publishes the project files in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1870.1">/app/publish</span></code><span class="koboSpan" id="kobo.1871.1"> folder:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1872.1">FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./DockerTest.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1873.1">We could have</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.1874.1"> merged stages 2 and 3 into a single stage but it is convenient </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.1875.1">to split stages into smaller stages because intermediary images are cached, so in subsequent builds, when the image input does not change, cached images are used instead of recomputing them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1876.1">Finally, the fourth and last stage is built on top of the first stage since it just needs the .NET runtime, and simply copies the published files from the image created in the third stage:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1877.1">FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
</span><span class="koboSpan" id="kobo.1877.2">ENTRYPOINT ["dotnet", "DockerTest.dll"]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1878.1">Now, place a breakpoint in the </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.1879.1">Index</span></code><span class="koboSpan" id="kobo.1880.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1881.1">HomeController.cs</span></code><span class="koboSpan" id="kobo.1882.1"> file and run the solution. </span><span class="koboSpan" id="kobo.1882.2">Visual Studio automatically builds the Dockerfile and runs the image.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1883.1">The breakpoint will be hit since Visual Studio is able to perform debugging inside the container images!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1884.1">While the application is running, for each container, Visual Studio shows logs, environment variables, bind mounts, and other information:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1885.1"><img alt="Figure 3.17: Visual Studio Containers console" src="../Images/B31916_03_17.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1886.1">Figure 3.17: Visual Studio Containers console</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.1887.1"> You can get also an interactive shell inside each container where you can explore the containerâ€™s filesystem, execute shell commands, and perform diagnostics and performance measurement operations, by simply opening a Linux shell and issuing the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1888.1">docker exec -it &lt;container-name-or-id&gt; /bin/bash
</span></code></pre>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1889.1">In our case, letâ€™s list all running containers with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1890.1">docker ps</span></code><span class="koboSpan" id="kobo.1891.1"> to get our container ID:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1892.1">CONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS          PORTS                                              NAMES
f6ca4537e060   dockertest   "dotnet --roll-forwaâ€¦"   17 minutes ago   Up 17 minutes   0.0.0.0:49154-&gt;8080/tcp, 0.0.0.0:49153-&gt;8081/tcp   DockerTest
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1893.1">Then, run</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.1894.1"> the</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.1895.1"> following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1896.1">docker exec -it DockerTest /bin/bash
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1897.1">Now, you are in the container filesystem! </span><span class="koboSpan" id="kobo.1897.2">Letâ€™s try some shell commands, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1898.1">Is</span></code><span class="koboSpan" id="kobo.1899.1">, for instance. </span><span class="koboSpan" id="kobo.1899.2">When you have finished with the container, it is enough to run </span><code class="inlineCode"><span class="koboSpan" id="kobo.1900.1">exit</span></code><span class="koboSpan" id="kobo.1901.1"> to return to your host computer console.</span></p>
<h1 class="heading-1" id="_idParaDest-67"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.1902.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1903.1">This chapter described two important building blocks of microservices architectures: the Onion Architecture and Docker containers. </span><span class="koboSpan" id="kobo.1903.2">The chapter described the basic principles of the Onion Architecture and how both the Application Services and Domain layers are organized. </span><span class="koboSpan" id="kobo.1903.3">More specifically, we described commands, queries, events, and their handlers together with aggregates and value objects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1904.1">Moreover, you learned how to use the preceding concepts in a Visual Studio solution thanks to the Visual Studio solution templates provided.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1905.1">The chapter explained the importance of containers, how to build a Dockerfile, and how to use Docker shell commands in practice. </span><span class="koboSpan" id="kobo.1905.2">Finally, the chapter described Visual Studio support for Docker.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1906.1">The next chapter focuses on Azure functions and their main triggers.</span></p>
<h1 class="heading-1" id="_idParaDest-68"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.1907.1">Questions</span></h1>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1908.1">Is it true that the Domain layer project must have a reference to the database driver project?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.1909.1">No, it is false. </span><span class="koboSpan" id="kobo.1909.2">References to drivers must be added to the infrastructure layer.</span></p>
<ol>
<li class="numberedList" value="2"><span class="koboSpan" id="kobo.1910.1">Which solution projects are among the application services references?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.1911.1">Only those projects that are part of the Domain Layer.</span></p>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.1912.1">Which solution projects are among the references of the outermost layer project of an Onion Architecture?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.1913.1">Application Services, Db Drivers, and all infrastructure drivers.</span></p>
<ol>
<li class="numberedList" value="4"><span class="koboSpan" id="kobo.1914.1">Is it true that an aggregate always corresponds to a unique database table?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.1915.1">No, it is false.</span></p>
<ol>
<li class="numberedList" value="5"><span class="koboSpan" id="kobo.1916.1">Why are domain events needed?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.1917.1">They are needed to decouple the code of different aggregates.</span></p>
<ol>
<li class="numberedList" value="6"><span class="koboSpan" id="kobo.1918.1">What is the purpose of the </span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.1919.1">WORKDIR</span></code><span class="koboSpan" id="kobo.1920.1"> Dockerfile instruction?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.1921.1">To set the image current directory.</span></p>
<ol>
<li class="numberedList" value="7"><span class="koboSpan" id="kobo.1922.1">How is it possible to pass environment variables to a container?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.1923.1">Through the -e options of the docker run command.</span></p>
<ol>
<li class="numberedList" value="8"><span class="koboSpan" id="kobo.1924.1">What is the right way to persist the storage of Docker containers?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.1925.1">Volume binds is the way to persist the storage of Docker containers.</span></p>
<h1 class="heading-1" id="_idParaDest-69"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.1926.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1927.1">More on queries, commands, and the domain layer can be found here: </span><a href="https://udidahan.com/2009/12/09/clarified-cqrs/"><span class="url"><span class="koboSpan" id="kobo.1928.1">https://udidahan.com/2009/12/09/clarified-cqrs/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1929.1">More information on Docker can be found on Dockerâ€™s official website: </span><a href="https://docs.docker.com/"><span class="url"><span class="koboSpan" id="kobo.1930.1">https://docs.docker.com/</span></span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-70"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.1931.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1932.1">Join our communityâ€™s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/PSMCSharp"><span class="url"><span class="koboSpan" id="kobo.1933.1">https://packt.link/PSMCSharp</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1934.1"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="../Images/B31916_Discord-QR-Code.png"/></span></p>
</div>
</body></html>