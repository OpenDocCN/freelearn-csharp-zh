- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Conclusion
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: As you saw while reading the book, there are many data structures with many
    configuration variants. Thus, **choosing a proper data structure is not an easy
    task**, which could have a significant impact on the performance of the developed
    solution. Even the topics mentioned in this book form quite a long list of described
    data structures. For this reason, it is a good idea to classify them in some way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在阅读本书时所看到的，有许多具有许多配置变体的数据结构。因此，**选择合适的数据结构并不是一件容易的事情**，这可能会对开发解决方案的性能产生重大影响。即使是本书中提到的主题也形成了一个相当长的数据结构描述列表。因此，以某种方式对它们进行分类是一个好主意。
- en: Within this chapter, the described data structures are grouped into linear and
    non-linear categories. Each element in a **linear data structure** can be logically
    adjacent to the following or the previous element. In the case of a **nonlinear
    data structure**, a single element can be logically adjacent to numerous others,
    not necessarily only one or two.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，描述的数据结构被分为线性和非线性类别。在**线性数据结构**中，每个元素可以逻辑上与下一个或前一个元素相邻。在**非线性数据结构**的情况下，单个元素可以逻辑上与许多其他元素相邻，而不仅仅是单个或两个。
- en: As it is the last chapter of the book, we will also summarize all of the gathered
    knowledge. Each data structure will be presented with a brief description, and
    some of them will be also shown with illustrations to help you remember this information.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的最后一章，我们也将总结所有收集到的知识。每个数据结构都将提供一个简要的描述，其中一些还将通过插图展示，以帮助您记住这些信息。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Classification
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类
- en: Arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Stacks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Queues
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Dictionaries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Sets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Trees
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树
- en: Graphs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图
- en: The last word
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一词
- en: Classification
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类
- en: I will start with a classification of the data structures shown already in the
    book. The classification divides all structures into linear and non-linear ones.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从对本书中展示的数据结构的分类开始。这个分类将所有结构分为线性和非线性。
- en: A **linear data structure** means that **each element can be logically adjacent
    to the following or the previous element**. There are several data structures
    that follow this rule, such as arrays, lists, stacks, and queues. Of course, you
    should also take care of various subtypes of the mentioned data structures, such
    as four variants of a linked list, which is a subtype of a list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性数据结构**意味着**每个元素可以逻辑上与下一个或前一个元素相邻**。有几个数据结构遵循这个规则，例如数组、列表、栈和队列。当然，你也应该注意所提到数据结构的各种子类型，例如链表的四种变体，它是列表的子类型。'
- en: A **non-linear data structure** indicates that **a single element can be logically
    adjacent to numerous others, not necessarily only one or two**. They can be freely
    distributed throughout the memory. Of course, graph-based data structures, including
    trees, are included in this group. Trees include binary trees, tries, and heaps,
    while a binary search tree is a subtype of a binary tree. In a similar way, you
    can describe the relationships of other data structures presented and explained
    in this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**非线性数据结构**表示**单个元素可以逻辑上与许多其他元素相邻，而不仅仅是单个或两个**。它们可以在内存中自由分布。当然，包括树在内的基于图的数据结构也包含在这个类别中。树包括二叉树、Trie树和堆，而二叉搜索树是二叉树的子类型。以类似的方式，你可以描述本书中展示和解释的其他数据结构之间的关系。'
- en: 'The mentioned classification is presented in the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了所提到的分类：
- en: '![Figure 10.1 – Classification of data structures into linear and non-linear
    ones](img/B18069_10_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 将数据结构分类为线性和非线性](img/B18069_10_01.jpg)'
- en: Figure 10.1 – Classification of data structures into linear and non-linear ones
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 将数据结构分类为线性和非线性
- en: Do you remember all of the data structures shown in the book? Due to the high
    number of described topics, it is a good idea to take a look at the following
    data structures once again. The associated algorithms will be mentioned, as well.
    The remaining part of this chapter is a brief summary with information about some
    real-world applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得书中展示的所有数据结构吗？由于描述的主题数量众多，重新审视以下数据结构是一个好主意。同时也会提到相关的算法。本章剩余部分是对一些实际应用的简要总结。
- en: Arrays
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Let’s start with an `int`, `string`, or a user-defined class. The important
    assumption is that the number of elements in an array cannot be changed after
    initialization. Moreover, arrays belong to **random access data structures**.
    This means that you can use indices to get access to the first, the middle, the
    *n*-th, or the last element from the array.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `int`、`string`或用户定义的类开始。重要的假设是数组的元素数量在初始化后不能改变。此外，数组属于**随机访问数据结构**。这意味着你可以使用索引来访问数组的第一个、中间的、第
    *n* 个或最后一个元素。
- en: 'You can benefit from a few variants of arrays – namely, **single-dimensional**,
    **multi-dimensional**, and **jagged arrays**, also referred to as an **array of
    arrays**. All of these variants are shown in the following illustration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从数组的几种变体中受益——即**单维**、**多维**和**锯齿形数组**，也称为**数组数组**。所有这些变体都在下面的插图中有展示：
- en: '![Figure 10.2 – Variants of arrays](img/B18069_10_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 数组的变体](img/B18069_10_02.jpg)'
- en: Figure 10.2 – Variants of arrays
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 数组的变体
- en: There are a lot of applications for arrays and, as a developer, you have probably
    already used this data structure many times. In this book, you saw how you can
    use it to store various data, such as the **names of months**, the **multiplication
    table**, or even a **map of a game**. In the last case, you created a two-dimensional
    array with the same size as a map, where each element specified a certain type
    of terrain, such as grass.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有很多应用，作为一个开发者，你可能已经多次使用这种数据结构了。在这本书中，你看到了如何使用它来存储各种数据，例如**月份名称**、**乘法表**，甚至**游戏地图**。在后一种情况下，你创建了一个与地图大小相同的二维数组，其中每个元素指定了某种地形类型，例如草地。
- en: There are many algorithms that perform operations on arrays. However, one of
    the most common tasks is sorting an array to arrange its elements in the correct
    order, either ascending or descending. This book focuses on seven algorithms,
    namely **selection sort**, **insertion sort**, **bubble sort**, **merge sort**,
    **Shell sort**, **quicksort**, and **heap sort**. Each of them was described and
    presented in the illustration, as well as written in the C# code, together with
    a detailed explanation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多算法在数组上执行操作。然而，最常见的任务之一是将数组排序，以正确地排列其元素，无论是升序还是降序。这本书重点介绍了七个算法，即**选择排序**、**插入排序**、**冒泡排序**、**归并排序**、**希尔排序**、**快速排序**和**堆排序**。每个算法都在插图和
    C# 代码中进行了描述和展示，并附有详细的解释。
- en: Lists
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: The next group of data structures are `ArrayList`), as well as its generic (`List`)
    and sorted (`SortedList`) variants. The latter can be understood as a collection
    of key-value pairs, always sorted by keys.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组数据结构是 `ArrayList`及其泛型（`List`）和排序（`SortedList`）变体。后者可以理解为键值对的集合，始终按键排序。
- en: There are a few other variants of lists, including a `LinkedList`). You can
    quite easily extend it to behave as any circular linked list, either as a circular
    singly or circular doubly linked list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还有一些其他变体，包括`LinkedList`。你可以相当容易地扩展它以表现得像任何循环链表，无论是循环单链表还是循环双链表。
- en: 'Various variants of lists are shown in the following illustration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的插图显示了列表的多种变体：
- en: '![Figure 10.3 – Variants of lists](img/B18069_10_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 列表的变体](img/B18069_10_03.jpg)'
- en: Figure 10.3 – Variants of lists
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 列表的变体
- en: There are a lot of applications for the lists to solve diverse problems in various
    kinds of applications. In this book, you saw how to utilize the list to store
    some floating-point values and calculate the average value, how to use this data
    structure to create a simple **database of people**, and how to develop an automatically
    sorted **address book**. Moreover, you prepared an exemplary application that
    allows a user to **read the book** by changing the pages, as well as a game, in
    which the user **spins the wheel** with random power. The wheel rotates slower
    and slower until it stops. Then, the user can spin it again, from the previous
    stop position, which illustrates a circular linked list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表在解决各种应用中的各种问题时有很多应用。在这本书中，你看到了如何利用列表存储一些浮点值并计算平均值，如何使用这种数据结构创建一个简单的**人员数据库**，以及如何开发一个自动排序的**地址簿**。此外，你还准备了一个示例应用，允许用户通过改变页面来**阅读书籍**，以及一个游戏，用户可以通过随机力量**旋转轮盘**。轮盘旋转得越来越慢，直到停止。然后，用户可以再次旋转它，从上一个停止位置开始，这说明了循环链表。
- en: Stacks
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: '[*Chapter 5*](B18069_05.xhtml#_idTextAnchor165), *Stacks and Queues*, focused
    on stacks and queues. Now, let’s recap a `Stack` class is available, as well.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](B18069_05.xhtml#_idTextAnchor165) *栈和队列* 专注于栈和队列。现在，让我们回顾一下，`Stack`
    类也是可用的。'
- en: 'The illustration of a stack is shown as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的示意图如下所示：
- en: '![Figure 10.4 – Illustration of a stack](img/B18069_10_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 栈的示意图](img/B18069_10_04.jpg)'
- en: Figure 10.4 – Illustration of a stack
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 栈的示意图
- en: A stack has many real-world applications. One of the mentioned examples is related
    to a **pile of many plates**, each placed on top of the other. You can only add
    a new plate at the top of the pile, and you can only get a plate from the top
    of the pile. You cannot remove the seventh plate without taking the previous six
    from the top, and you cannot add a plate to the middle of the pile. You also saw
    how to use a stack to **reverse a word** and how to apply it to solve the mathematical
    game **Tower of Hanoi**. That’s not all, because applications of stacks are much
    broader, such as for calculating mathematical expressions provided in the **reverse**
    **Polish notation**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 栈在现实世界中也有许多应用。其中一个例子是关于**许多盘子堆叠**的，每个盘子都放在另一个盘子的上面。你只能在新盘子堆的顶部添加一个新的盘子，你只能从盘子堆的顶部取出一个盘子。你不能在不取走顶部前六个盘子的情况下取出第七个盘子，也不能在盘子堆的中间添加一个盘子。你还看到了如何使用栈来**反转一个单词**以及如何将其应用于解决数学游戏**汉诺塔**。但这还不是全部，因为栈的应用范围更广，例如用于计算**逆波兰表示法**中提供的数学表达式。
- en: Queues
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Another leading subject of [*Chapter 5*](B18069_05.xhtml#_idTextAnchor165),
    *Stacks and Queues*, was a `Queue` class is available for you, as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](B18069_05.xhtml#_idTextAnchor165)的另一个主要主题是 *栈和队列*，其中也为你提供了一个 `Queue`
    类。'
- en: 'The illustration of a queue is shown as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的示意图如下所示：
- en: '![Figure 10.5 – Illustration of a queue](img/B18069_10_05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 队列的示意图](img/B18069_10_05.jpg)'
- en: Figure 10.5 – Illustration of a queue
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 队列的示意图
- en: It is also possible to use a **priority queue**, which extends the concept of
    a queue by setting the priority for each element. Thus, the dequeue operation
    returns the element with the highest priority, which was added earliest to the
    queue. When all elements with the highest priority are dequeued, the priority
    queue handles elements with the next highest priority and dequeues such elements
    from those added earliest.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用**优先队列**，它通过为每个元素设置优先级来扩展队列的概念。因此，出队操作返回的是优先级最高的元素，这是最早添加到队列中的。当所有具有最高优先级的元素都被出队后，优先队列处理具有下一个最高优先级的元素，并从最早添加的元素中出队这些元素。
- en: Another variant of a queue is a **circular queue**, also called a **ring buffer**,
    which was also presented and explained in the book. Here, a queue forms a circle,
    internally uses an array, and the maximum number of elements that can be placed
    inside the queue is limited. You specify indices for front and rear elements in
    this case.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的另一种变体是**循环队列**，也称为**环形缓冲区**，这在书中也被介绍和解释了。在这里，队列形成一个圆圈，内部使用数组，可以放置在队列中的最大元素数量是有限的。在这种情况下，你指定前导元素和尾元素的下标。
- en: There are many real-world applications of a queue. For example, a queue can
    be used to represent a **line of people** waiting in a shop at a checkout. New
    people stand at the end of the line, and the next person is taken to the checkout
    from the beginning of the line. You are not allowed to choose a person from the
    middle and serve them. Moreover, you saw a few examples of the solution of a **call
    center**, where there are many clients and one consultant, many clients and many
    consultants, or many clients (with different plans, either standard or priority
    support) and only one consultant, who answers the waiting calls. Another group
    of queue applications was shown while presenting **graph-based algorithms**. A
    queue was used in the **breadth-first search** algorithm for traversing a graph
    or for searching for a given value in a graph. A priority queue was applied in
    **Dijkstra’s algorithm** for searching the shortest path in a graph.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 队列在现实世界中有很多应用。例如，队列可以用来表示在结账处等待的**人群队列**。新来的人站在队伍的末尾，下一个被带到结账处的人是从队伍的起始位置取出的。不允许从队伍中间选择一个人并为他们服务。此外，你还看到了一些**呼叫中心**解决方案的例子，其中有许多客户和一个顾问，或者许多客户和许多顾问，或者许多客户（具有不同的计划，无论是标准支持还是优先支持）以及只有一个顾问，他回答等待的电话。在介绍**基于图的算法**时还展示了另一组队列应用。在**广度优先搜索**算法中使用了队列来遍历图或搜索图中的给定值。在**迪杰斯特拉算法**中应用了优先队列来搜索图中的最短路径。
- en: Dictionaries
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: The topic of [*Chapter 6*](B18069_06.xhtml#_idTextAnchor195), *Dictionaries
    and Sets*, was related to dictionaries and sets. First, let’s recap a **dictionary**,
    which allows **mapping keys to values and performing fast lookups**. A dictionary
    uses a hash function and can be understood as a collection of pairs, each consisting
    of a key and a value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B18069_06.xhtml#_idTextAnchor195)，“字典和集合”这一主题与字典和集合相关。首先，让我们回顾一下**字典**，它允许**将键映射到值并执行快速查找**。字典使用哈希函数，可以理解为包含一对对的集合，每对由一个键和一个值组成。'
- en: There are two built-in versions of a dictionary – non-generic (`Hashtable`)
    and generic (`Dictionary`). The sorted variant of a dictionary (`SortedDictionary`)
    is available, as well. All of them were described in detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 字典有两种内置版本——非泛型（`Hashtable`）和泛型（`Dictionary`）。还有字典的排序版本（`SortedDictionary`）。所有这些都在详细描述中。
- en: 'The mechanism of a hash table is presented in the following illustration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了哈希表的机制：
- en: '![Figure 10.6 – Illustration of mapping keys to particular values](img/B18069_10_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 将键映射到特定值的示意图](img/B18069_10_06.jpg)'
- en: Figure 10.6 – Illustration of mapping keys to particular values
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 将键映射到特定值的示意图
- en: Due to the great performance of the hash table, such a data structure is frequently
    used in many real-world applications, such as for **associative arrays**, **database
    indices**, or **cache systems**. Within this book, you saw how to create a **phone
    book** to store entries where a person’s name is a key and a phone number is a
    value. Among other examples, you developed an application that helps employees
    of shops **find the location** of where a product should be placed, and you applied
    the sorted dictionary to create a simple **encyclopedia**, where a user can add
    entries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希表的高性能，这种数据结构在许多实际应用中经常被使用，例如用于**关联数组**、**数据库索引**或**缓存系统**。在本书中，你看到了如何创建一个**电话簿**来存储条目，其中一个人的名字是键，电话号码是值。在其他例子中，你开发了一个帮助商店员工**找到产品放置位置**的应用程序，并且你应用了排序字典来创建一个简单的**百科全书**，用户可以添加条目。
- en: Sets
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Another data structure from [*Chapter 6*](B18069_06.xhtml#_idTextAnchor195),
    *Dictionaries and Sets*, is a **set**, which is a **collection of distinct objects
    without duplicated elements and without any particular order**. Therefore, you
    can only get to know whether a given element is in the set or not. The sets are
    strictly connected with mathematical models and operations, such as **union**,
    **intersection**, **subtraction**, and **symmetric difference**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个来自[*第 6 章*](B18069_06.xhtml#_idTextAnchor195)，“字典和集合”的数据结构是**集合**，它是一个**没有重复元素且没有特定顺序的独立对象的集合**。因此，你只能知道给定元素是否在集合中。集合与数学模型和操作（如**并集**、**交集**、**差集**和**对称差集**）紧密相关。
- en: 'The exemplary sets, storing data of various types, are shown as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，示例集合存储了各种类型的数据：
- en: '![Figure 10.7 – Illustration of sets with integer and string values](img/B18069_10_07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 整数和字符串值集合的示意图](img/B18069_10_07.jpg)'
- en: Figure 10.7 – Illustration of sets with integer and string values
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 整数和字符串值集合的示意图
- en: While developing applications in the C# language, you can benefit from high-performance
    set-related operations provided by the `HashSet` class. As an example, you saw
    how to create a system that handles **one-time promotional coupons** and allows
    you to check whether the scanned one was already used. Another example was the
    **reporting service** for the system of a SPA center with four swimming pools.
    By using sets, you calculated statistics, such as the number of visitors to a
    pool, the most popular pool, and the number of people who visited at least one
    pool.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 C# 语言的应用程序时，你可以从 `HashSet` 类提供的高性能集合相关操作中受益。例如，你看到了如何创建一个处理**一次性促销优惠券**的系统，并允许你检查扫描的优惠券是否已被使用。另一个例子是SPA中心四个游泳池系统的**报告服务**。通过使用集合，你可以计算统计数据，例如游泳池的访问人数、最受欢迎的游泳池以及至少访问过一次游泳池的人数。
- en: Trees
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: The next topic is about **trees**, which were the subject of [*Chapter 7*](B18069_07.xhtml#_idTextAnchor233),
    *Variants of Trees*. A tree consists of **nodes** with one **root**. The root
    contains no **parent** node, while all other nodes do. Moreover, each node can
    have any number of **child nodes**. The child nodes of the same parent can be
    called **siblings**, while a node without children is called a **leaf**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题是关于**树**的，这是[第7章](B18069_07.xhtml#_idTextAnchor233)“树的变体”的主题。树由具有一个**根**的**节点**组成。根节点没有**父**节点，而所有其他节点都有。此外，每个节点可以有任意数量的**子节点**。同一父节点的子节点可以称为**兄弟节点**，而没有子节点的节点称为**叶节点**。
- en: 'An exemplary tree is shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个示例树：
- en: '![Figure 10.8 – Illustration of a tree](img/B18069_10_08.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 树的示意图](img/B18069_10_08.jpg)'
- en: Figure 10.8 – Illustration of a tree
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 树的示意图
- en: A tree is a data structure that is great for the representation of various data,
    such as the **structure of a company**, divided into a few departments, where
    each has its own structure. You also saw an example where a tree was used to arrange
    a **simple quiz** consisting of a few questions and answers, which are shown depending
    on the previously taken decisions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种非常适合表示各种数据的数据结构，例如，一个公司**结构**，分为几个部门，每个部门都有自己的结构。你也看到了一个例子，其中使用树来安排一个**简单测验**，由几个问题和答案组成，这些问题和答案根据之前做出的决策显示出来。
- en: 'Generally speaking, each node in a tree can contain any number of children.
    However, in the case of **binary trees**, a node cannot contain more than two
    children – that is, it can contain no child nodes, or only one or two. However,
    there are no rules about relationships between the nodes. The exemplary binary
    trees are shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，树中的每个节点可以包含任意数量的子节点。然而，在**二叉树**的情况下，一个节点不能包含超过两个子节点——也就是说，它可以没有子节点，或者只有一个或两个。然而，节点之间的关系没有规则。这里展示了示例二叉树：
- en: '![Figure 10.9 – Illustration of a binary tree and a binary search tree](img/B18069_10_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 二叉树和二叉搜索树的示意图](img/B18069_10_09.jpg)'
- en: Figure 10.9 – Illustration of a binary tree and a binary search tree
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 二叉树和二叉搜索树的示意图
- en: If you want to use a **binary search tree** (**BST**), the next rule is introduced.
    It states that, for any node, the values of all nodes in its left subtree must
    be smaller than its value, and that the values of all nodes in its right subtree
    must be greater than its value. The exemplary BST is presented on the right-hand
    side of the preceding illustration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用**二叉搜索树**（BST），接下来介绍的一条规则是：对于任何节点，其左子树中所有节点的值必须小于其值，而其右子树中所有节点的值必须大于其值。上一个图例的右侧展示了示例二叉搜索树。
- en: Another group of trees is called **self-balancing trees**, which keep a tree
    balanced all the time while adding and removing nodes. Their application is very
    important because it allows you to form the correctly arranged tree, which has
    a positive impact on performance. There are several variants of self-balancing
    trees, but **AVL trees** and **red-black trees** (**RBTs**) are some of the most
    popular.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类树被称为**自平衡树**，在添加和删除节点的同时始终保持树的平衡。它们的应用非常重要，因为它允许你形成正确排列的树，这对性能有积极影响。自平衡树有多种变体，但**AVL树**和**红黑树**（RBTs）是最受欢迎的一些。
- en: 'One of the tree applications is related to processing strings, such as for
    `a` to `z`). When you go from the root to each node, you receive a string, which
    is either a saved word or its substring, as presented in the following illustration:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 树的一个应用与处理字符串有关，例如`a`到`z`）。当你从根节点走到每个节点时，你会得到一个字符串，它要么是一个已保存的单词，要么是其子串，如下面的图例所示：
- en: '![Figure 10.10 – Illustration of a trie](img/B18069_10_10.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – trie的示意图](img/B18069_10_10.jpg)'
- en: Figure 10.10 – Illustration of a trie
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – trie的示意图
- en: 'A **heap** is another subtype of a tree and exists in many variants, including
    a **binary heap**. It contains two versions – namely, **min-heap** and **max-heap**.
    For each of them, the additional property must be satisfied. For the min-heap,
    the value of each node must be greater than or equal to the value of its parent
    node. Thus, the root node contains the smallest value. For the max-heap, the value
    of each node must be less than or equal to the value of its parent node. Therefore,
    the root node always contains the largest value. The exemplary binary heaps are
    shown as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**是树的另一种子类型，存在许多变体，包括**二叉堆**。它包含两个版本——即**最小堆**和**最大堆**。对于每一个，都必须满足额外的属性。对于最小堆，每个节点的值必须大于或等于其父节点的值。因此，根节点包含最小的值。对于最大堆，每个节点的值必须小于或等于其父节点的值。因此，根节点总是包含最大的值。以下是最小二叉堆的示例：'
- en: '![Figure 10.11 – Illustration of a min-heap and max-heap](img/B18069_10_11.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 最小堆和最大堆的示意图](img/B18069_10_11.jpg)'
- en: Figure 10.11 – Illustration of a min-heap and max-heap
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 最小堆和最大堆的示意图
- en: A heap is a convenient data structure for implementing a **priority queue**.
    Another interesting application is the sorting algorithm, named **heap sort**,
    which was presented and explained in the chapter regarding arrays and sorting.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是实现**优先队列**的方便数据结构。另一个有趣的应用是排序算法，名为**堆排序**，这在关于数组和排序的章节中进行了介绍和解释。
- en: Graphs
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: '[*Chapter 8*](B18069_08.xhtml#_idTextAnchor296), *Exploring Graphs*, was related
    to **graphs** – a very popular data structure with a broad range of applications.
    As a reminder, a graph is a data structure that consists of **nodes** and **edges**.
    Each edge connects two nodes. There are a few variants of edges in a graph, such
    as undirected and directed, as well as unweighted and weighted. A graph can be
    represented as an adjacency list or as an adjacency matrix.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第 8 章*](B18069_08.xhtml#_idTextAnchor296)，*探索图*，与**图**相关——这是一个应用范围广泛且非常受欢迎的数据结构。提醒一下，图是一种由**节点**和**边**组成的数据结构。每条边连接两个节点。图中边的变体有几种，如无向和有向，以及无权和有权。图可以用邻接表或邻接矩阵来表示。'
- en: All of these topics were described in the book, together with the problem of
    graph **traversal** with breadth-first search and depth-first search algorithms,
    finding the **minimum spanning tree** with Kruskal’s and Prim’s algorithms, **node
    coloring**, and **finding the shortest path** in a graph with Dijkstra’s algorithm.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些主题都在书中进行了描述，包括使用广度优先搜索和深度优先搜索算法进行图**遍历**的问题，使用克鲁斯卡尔和普里姆算法找到**最小生成树**，**节点着色**，以及使用迪杰斯特拉算法在图中找到**最短路径**。
- en: 'The exemplary graphs are shown in the following illustration:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的图示如下所示：
- en: '![Figure 10.12 – Illustration of graphs](img/B18069_10_12.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 图的示意图](img/B18069_10_12.jpg)'
- en: Figure 10.12 – Illustration of graphs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 图的示意图
- en: A graph data structure is commonly used in various applications. It is also
    a great way to represent diverse data, such as the **structure of friends** available
    on a social media site. Here, the nodes can represent contacts, while edges represent
    relationships between people. Thus, you can easily check whether two contacts
    know each other or how many people should be involved to arrange a meeting between
    two particular people.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据结构在多种应用中都很常见。它也是一种表示各种数据的好方法，例如社交媒体网站上可用的**朋友结构**。在这里，节点可以代表联系人，而边代表人与人之间的关系。因此，你可以轻松地检查两个联系人是否认识彼此，或者需要多少人参与安排两个特定人之间的会议。
- en: Another common application of graphs involves the problem of **finding a path**.
    As an example, you can use a graph to find a path between two points in the city,
    taking into account the distance or time necessary for driving. You can use a
    graph to represent a map of a city, where nodes are intersections and edges represent
    roads. You can assign weights to edges to indicate the necessary distance or time
    for driving a given road.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图的另一个常见应用涉及**寻找路径**的问题。例如，你可以使用图来找到城市中两点之间的路径，考虑到驾驶所需的距离或时间。你可以使用图来表示城市的地图，其中节点是交叉口，边代表道路。你可以给边分配权重，以表示驾驶给定道路所需的距离或时间。
- en: There are many other applications related to graphs. For instance, the minimum
    spanning tree can be used to create a **plan of connections between buildings**
    to supply all of them with a telecommunication cable at the smallest cost. The
    node coloring problem was used in the book for **coloring voivodeships** on a
    map of Poland according to the rule that two voivodeships that have common borders
    cannot have the same color. Another shown example involves Dijkstra’s algorithm
    for finding **the shortest path in a game map**, taking into account various obstacles.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与图相关的应用还有很多。例如，最小生成树可以用来创建**建筑物之间的连接计划**，以最小的成本为所有建筑物提供电信电缆。在书中使用了节点着色问题来**为波兰地图上的省进行着色**，根据规则，两个有共同边界的省份不能有相同的颜色。另一个展示的例子涉及迪杰斯特拉算法在**游戏地图中寻找最短路径**，考虑到各种障碍。
- en: The last word
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的话
- en: You just reached the end of the last chapter of the book. First, the classification
    of data structures was presented, taking into account linear and non-linear data
    structures. In the first group, you can find arrays, lists, stacks, and queues,
    while the second group involves graphs and their subtypes, including trees and
    heaps. In the following part of this chapter, the diversity of applications of
    various data structures was taken into account. You saw a short summary of each
    described data structure, as well as information about some problems that can
    be solved with the use of a particular data structure, such as a queue or a graph.
    To make the content easier to understand, as well as to remind you of the various
    topics from the previous chapters, the summary was equipped with brief descriptions
    and illustrations of data structures.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经到达了这本书的最后一章的结尾。首先，介绍了数据结构的分类，考虑了线性和非线性数据结构。在第一组中，您可以找到数组、列表、栈和队列，而第二组包括图及其子类型，包括树和堆。在这一章的后续部分，考虑了各种数据结构的多样性应用。您看到了每种描述的数据结构的简要总结，以及使用特定数据结构（如队列或图）可以解决的问题的信息。为了使内容更容易理解，以及提醒您之前章节中的各种主题，总结配备了数据结构的简要描述和插图。
- en: In the introduction to this book, I invited you to start your adventure with
    data structures and algorithms. While reading the following chapters, writing
    hundreds of lines of code, and debugging, you had a chance to familiarize yourself
    with various data structures, starting with arrays and lists, through stacks,
    queues, dictionaries, and sets, and ending with trees and graphs. I hope that
    this book is only the first step in your long, challenging, and successful adventure
    with data structures and algorithms.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的引言中，我邀请您开始您的数据结构和算法冒险之旅。在阅读以下章节、编写数百行代码和调试的过程中，您有机会熟悉各种数据结构，从数组、列表开始，经过栈、队列、字典和集合，最后到树和图。我希望这本书只是您在数据结构和算法领域漫长、充满挑战和成功的冒险的第一步。
- en: I would like to thank you for reading this book. If you have any questions or
    problems regarding the described content, please do not hesitate to contact me
    directly using the contact information shown at [https://marcin.com](https://marcin.com).
    While visiting my website, you can also find answers to many questions that you
    can ask during your development career. Please also tell me what topics are missing
    from this book that you want to learn about for the next edition of this book
    or from another of my books. I really hope that you will benefit from the presented
    content. I would like to wish you all the best in your career as a software developer,
    and I hope that you have many successful projects! I will be very happy if you
    let me know about your great projects, especially if they are inspired by the
    content of this book. Good luck and keep in touch!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我想感谢您阅读这本书。如果您对描述的内容有任何问题或问题，请直接使用显示在[https://marcin.com](https://marcin.com)的联系方式与我联系。在访问我的网站时，您还可以找到许多您在开发生涯中可以提出的问题的答案。请告诉我，您想从这本书的下一版或我的其他书中学习哪些缺失的主题。我真心希望您能从展示的内容中受益。我衷心祝愿您在软件开发者的职业生涯中一切顺利，并希望您有许多成功的项目！如果您让我知道您的大项目，特别是如果它们受到了这本书内容的启发，我将非常高兴。祝您好运，保持联系！
