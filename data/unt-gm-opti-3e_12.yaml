- en: The Data-Oriented Technology Stack
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据导向技术堆栈
- en: 'In recent years, we have seen a big push toward multithreading programming.
    The reason is obvious: while we have reached a technological limit on how fast
    a single core can go, we have discovered how to efficiently put thousands of cores
    into our hardware and run each piece of code in parallel to obtain a massive performance
    boost.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，我们看到了向多线程编程的大幅推进。原因很明显：虽然我们在单个核心的速度上已经达到了技术极限，但我们已经发现了如何有效地将数千个核心放入我们的硬件中，并使每段代码并行运行以获得巨大的性能提升。
- en: However, moving from single-thread programming to multithreading programming
    is not straightforward. Not every algorithm can easily be split into pieces and,
    even if it can, there are several details you need to take into account so as
    to avoid strange and unpredictable behaviors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从单线程编程转向多线程编程并不简单。并非每个算法都可以轻易地分割成片段，即使可以，你还需要注意几个细节，以避免奇怪和不可预测的行为。
- en: When the first version of Unity was released, back in 2005, massive multithreading
    was almost a futuristic scenario. However, fourteen years are the equivalent of
    a geological era in game development, and a game engine needs to adapt itself
    to stay on track with cutting-edge technology.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当Unity的第一个版本在2005年发布时，大规模多线程几乎是一个未来场景。然而，十四年对于游戏开发来说相当于一个地质时代，游戏引擎需要适应自己以跟上尖端技术的步伐。
- en: Unity is currently going through a massive effort to adapt its core design into
    a world dominated by massive multithreading. This effort takes the name of the **Data-Oriented
    Technology Stack** (**DOTS**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Unity目前正在努力将其核心设计适应一个由大规模多线程主导的世界。这项努力被称为**数据导向技术堆栈**（**DOTS**）。
- en: 'In this chapter, we will explore the components of DOTS:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨DOTS的组件：
- en: The Job System
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务系统
- en: The **Entity Component System** (**ECS**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体组件系统**（**ECS**）'
- en: The Burst Compiler
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Burst编译器
- en: The DOTS stack in Unity is exceptionally experimental and, while public, all
    its components are still in an early preview state, meaning that their use should
    be avoided for serious projects. They also change very fast. The official tutorial
    on ECS on [https://learn.unity.com](https://learn.unity.com) is now unusable because
    it is out of date. I will not be surprised if even this chapter, some months from
    now, were to contain many deprecated functions and procedures. Do not worry; I
    will provide a link at the end for where to obtain fresh news on DOTS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的DOTS堆栈非常实验性，尽管它是公开的，但所有组件仍处于早期预览状态，这意味着它们的使用应避免用于重要项目。它们也变化非常快。官方关于ECS的教程在[https://learn.unity.com](https://learn.unity.com)上现在已不可用，因为它已经过时。如果几个月后，这一章节包含许多已弃用的函数和过程，我也不会感到惊讶。不要担心；我将在文末提供获取DOTS最新消息的链接。
- en: The problem of multithreading
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程的问题
- en: Video games have great multithreading potential. In theory, every `GameObject`
    can be seen as a separate entity with its own life cycle and its own computation
    path. This would instantaneously increase your game performance with a lot of
    `GameObject` instances. Suppose that processing all the updates in the `GameObject` takes
    1 ms. If you could have one thousand similar `GameObject` instances, that would
    take a full second but, if you can assign each update to a separate core, all
    the updates could run in parallel, and your total computation time would be exactly
    1 ms. That represents a 100,000% speed boost!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏具有巨大的多线程潜力。从理论上讲，每个`GameObject`都可以被视为一个独立的实体，拥有自己的生命周期和计算路径。这将通过大量的`GameObject`实例瞬间提高你的游戏性能。假设处理所有`GameObject`的更新需要1毫秒。如果你能有一千个类似的`GameObject`实例，那将需要整整一秒，但如果你能将每个更新分配给一个单独的核心，所有更新都可以并行运行，你的总计算时间将正好是1毫秒。这代表着100,000%的速度提升！
- en: Unfortunately, it is not so easy. As we said before, you cannot just assign
    a piece of code to a core and expect that everything keeps working. A big problem
    with writing multithreaded code is the risk of race conditions, deadlock, and
    bugs that are notoriously difficult to reproduce and debug.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不容易。正如我们之前所说，你不能只是将一段代码分配给一个核心并期望一切都能正常工作。编写多线程代码的一个大问题是存在竞争条件、死锁以及难以重现和调试的bug的风险。
- en: Race conditions are where two or more calculations are racing toward completion,
    but the actual outcome depends on the order in which they finish. Imagine one
    thread trying to add three to a number, whereas another thread multiplies it by
    four. The result will be different, depending on which operation happens first. Deadlock is
    a problem where two or more threads are competing for shared resources, where
    each requires the full resource collection to complete its task, but each has
    reserved a separate small portion of resources and refuses to relinquish control
    of them to another thread, in which case, none of the threads can get any work
    done because neither has the complete set it needs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件是指两个或多个计算在向完成的方向竞争，但实际结果取决于它们完成的顺序。想象一个线程试图将一个数字加三，而另一个线程将其乘以四。结果将取决于哪个操作先发生。死锁是一个问题，其中两个或多个线程正在竞争共享资源，每个线程都需要完整的资源集合来完成其任务，但每个线程都保留了一小部分资源，并且拒绝将其控制权交给另一个线程，在这种情况下，没有任何线程可以完成任何工作，因为它们都没有需要的完整集合。
- en: For this reason, traditionally, Unity APIs are not thread-safe, meaning that
    they cannot be invoked by different threads running in parallel. As a consequence,
    almost all Unity code runs in the main thread, and that includes every `GameObject`
    and `MonoBehaviour` (and that's why if you block a single update, you may end
    up freezing the entire Unity Editor).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，传统上，Unity API不是线程安全的，这意味着它们不能被并行运行的多个线程调用。因此，几乎所有的Unity代码都在主线程中运行，包括每个`GameObject`和`MonoBehaviour`（这就是为什么如果你阻塞单个更新，你可能会冻结整个Unity编辑器）。
- en: Because multithreading is a complex topic, we will go over an example step by
    step.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为多线程是一个复杂的话题，我们将一步一步地通过一个例子来讲解。
- en: A small example
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个小例子
- en: 'Imagine you want to have thousands of similar items in your scene. This is
    not a strange request; there may be many valid reasons for that: you may wish
    to render thousands of ships in a gigantic galactic battle, or you may want to
    animate thousands of units for a **Real-Time Strategy** (**RTS**) game, or you
    may want to handle a massive number of particles.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在场景中有成千上万的类似物品。这不是一个奇怪的要求；可能有许多合理的理由：你可能希望在巨大的星际战斗中渲染成千上万的飞船，或者你可能想要为**实时策略**（**RTS**）游戏动画化成千上万的单位，或者你可能想要处理大量的粒子。
- en: 'For simplicity, in our demo, we want a scene with 10,000 spinning cubes. So
    let''s begin:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，在我们的演示中，我们想要一个有10,000个旋转立方体的场景。所以，让我们开始吧：
- en: 'Each cube will have a single `MonoBehaviour` instance that executes a very
    simple rotation cube:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个立方体将有一个单独的`MonoBehaviour`实例，它执行一个非常简单的旋转立方体操作：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The script is self-explanatory: we have a public variable, `rotationSpeed`,
    storing the rotation speed of the cube. Then, in `Update`, we simply rotate the
    cube.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是自我解释的：我们有一个公共变量`rotationSpeed`，用于存储立方体的旋转速度。然后，在`Update`方法中，我们简单地旋转立方体。
- en: 'Now, we do not want to insert 10,000 cubes into the scene manually. So, we
    will create a **game manager** that will do the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们不想手动将10,000个立方体插入场景。所以，我们将创建一个**游戏管理器**，它将执行以下操作：
- en: Spawn 10,000 cubes in the scene
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中生成10,000个立方体
- en: Set a random rotation speed for each one of them
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个立方体设置随机的旋转速度
- en: 'So, we create an empty `GameObject`, and we attach to it a game manager script,
    as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们创建一个空的`GameObject`，并将其附加到一个游戏管理脚本，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The script simply takes a `cubePrefab` and spawns a certain number of them into
    a *width x height* rectangle of space. The exciting part is the `SpawnCubes` function.
    The function starts with `position` in the origin and starts spawning cubes until
    we reach the opposite corner. This is a pretty standard script.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本简单地取一个`cubePrefab`，并在一个*宽 x 高*的矩形空间中生成一定数量的它们。令人兴奋的部分是`SpawnCubes`函数。该函数从原点开始，生成立方体，直到我们达到对角线。这是一个相当标准的脚本。
- en: 'Now we can run it, and we should see something like this:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以运行它了，我们应该能看到类似这样的结果：
- en: '![](img/70a260fc-2726-40fb-a7b6-88cda2e42076.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70a260fc-2726-40fb-a7b6-88cda2e42076.png)'
- en: As you can see, the frame rate is not optimal. Looking at the stats in the top-right
    corner, you can see that the game is running at ~22 FPS.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，帧率并不理想。查看右上角的统计数据，你可以看到游戏正在以大约22 FPS的速度运行。
- en: Note that these values are taken from my non-optimal machine. You may find different
    values. If your computer is so fast that the demo is running perfectly, try to
    increase the number of cubes to 20,000 or more.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些值是从我的非最优机器上获取的。你可能会得到不同的值。如果你的电脑非常快，演示运行得非常完美，尝试将立方体的数量增加到20,000个或更多。
- en: 'This FPS value is not optimal. However, we can open the Profiler window (Window
    | Analysis | Profiler) and try to understand how the application behaves:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个FPS值不是最优的。然而，我们可以打开Profiler窗口（窗口 | 分析 | Profiler），并尝试了解应用程序的行为：
- en: '![](img/b96698e0-3ea7-40dc-8506-e629cae0ed29.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b96698e0-3ea7-40dc-8506-e629cae0ed29.png)'
- en: 'The image is clear: we are allocating almost 1 GB of RAM and spending 45 ms
    per frame, 10 ms of which are used just for the scripts. That''s wrong. The update
    script is straightforward: we are just rotating a cube by a few degrees each frame.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图像很清晰：我们几乎分配了1 GB的RAM，并且每帧花费45毫秒，其中10毫秒仅用于脚本。这是错误的。更新脚本很简单：我们只是在每一帧旋转一个立方体几度。
- en: We should do better. And we will.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做得更好。我们会的。
- en: The Unity Job System
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity工作系统
- en: 'The big block in the DOTS that can provide us with a huge performance-enhancing
    feature is the **C# Job System**. Like all the other DOTS components, the feature
    is still in active development, but has been made public since Unity 2019.1, so
    it would be wise to start becoming familiar with it sooner rather than later,
    as it will introduce considerable changes to how Unity developers will be writing
    high-performance code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DOTS中可以为我们提供巨大性能提升功能的大块是**C#工作系统**。像所有其他DOTS组件一样，这个功能仍在积极开发中，但自Unity 2019.1以来已经公开，因此尽早熟悉它而不是晚些时候是明智的，因为它将对Unity开发者编写高性能代码的方式带来重大变化：
- en: '![](img/5b1ed060-e78b-4f34-9e21-7905b738bc6c.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b1ed060-e78b-4f34-9e21-7905b738bc6c.png)'
- en: As we will see, the difference in the quality of a game that uses this system
    versus one that doesn't might become very noticeable, which may cause some fragmentation
    within the Unity development community. It is in our best interests to understand
    and exploit the benefits of the new Job System so that our application will have
    the greatest potential for success.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，使用此系统与不使用此系统的游戏质量差异可能会非常明显，这可能会在Unity开发社区中引起一些碎片化。了解并利用新工作系统的优势，以便我们的应用程序具有最大的成功潜力，这是我们的最佳利益所在。
- en: The idea of the C# Job System is to be able to create simple tasks that run
    in background threads to offload work from the main thread. The C# Job System
    will be ideal for tasks that are embarrassingly parallel, such as having hundreds
    of thousands of simple AI agents operating in a scene simultaneously and any problem
    that can be boiled down to thousands of small, independent operations. Of course,
    it can also be used for typical multithreading behavior as well, where we perform
    a number of calculations in the background that are not needed immediately. The
    Job System also introduces some compiler technology improvements to get an even
    greater performance boost than just moving the tasks to separate threads.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C#工作系统的想法是能够创建简单的任务，这些任务在后台线程上运行，以从主线程卸载工作。C#工作系统非常适合那些明显可以并行处理的任务，例如在场景中同时操作数十万个简单的AI代理，以及任何可以归结为数千个小而独立的操作的任何问题。当然，它也可以用于典型的多线程行为，我们在后台执行一些不需要立即进行的计算。工作系统还引入了一些编译器技术改进，以获得比仅仅将任务移动到单独的线程更大的性能提升。
- en: A basic job
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本工作
- en: 'In essence, a job is just a function running on a separate thread:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，一个工作就是一个在单独线程上运行的功能：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every job is a struct extending the `IJobinterface` interface. The struct contains
    any data we want for the job to use and a function named `Execute` for the operation
    we want to execute in the job. The previous example, for instance, just adds a
    certain number to the first element of an array.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作都是一个扩展`IJobinterface`接口的结构体。结构体包含我们希望工作使用的任何数据，以及一个名为`Execute`的函数，用于在作业中执行的操作。例如，上一个示例只是将一定数量的值加到数组的第一个元素上。
- en: Because, as we said before, multithreading is a very tricky business, Unity
    offers some limitations in terms of the way in which you can pass and receive
    data to a job (or a set of jobs). The primary constraint is that the `Execute`
    function does not accept any argument and cannot return any value. All the data
    that the job needs must be copied in the struct, and the result must be written
    in the struct as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，正如我们之前所说的，多线程是一个非常棘手的事情，Unity在你可以传递和接收数据到工作（或一组工作）的方式上提供了一些限制。主要约束是`Execute`函数不接受任何参数，也不能返回任何值。工作所需的所有数据都必须复制到结构体中，结果也必须写入结构体。
- en: 'The fact that we need to copy stuff into the struct seems a significant limitation:
    you cannot pass a reference to a `MonoBehaviour` instance or a reference to `List`.
    Luckily, Unity offers a way to access shared memory in a job using a set of thread-safe
    wrappers using native containers.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将内容复制到结构体中的事实似乎是一个重大的限制：你不能传递一个`MonoBehaviour`实例的引用或`List`的引用。幸运的是，Unity提供了一种使用一组线程安全的包装器通过原生容器访问作业共享内存的方法。
- en: 'The native containers include the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 原生容器包括以下内容：
- en: '`NativeArray`: A simple collection of data (the thread-safe equivalent of base
    C# arrays)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NativeArray`: 数据的简单集合（线程安全的C#数组的等价物）'
- en: '`NativeList`: Similar to `NativeArray`, but resizable (the thread-safe equivalent
    of `List`)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NativeList`: 与`NativeArray`类似，但可调整大小（线程安全的`List`的等价物）'
- en: '`NativeHashMap`: The thread-safe version of `HashMap`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NativeHashMap`: `HashMap`的线程安全版本'
- en: '`NativeMultiHashMap`: Similar to `NativeHashMap`, but with multiple values
    per key'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NativeMultiHashMap`: 与`NativeHashMap`类似，但每个键可以有多个值'
- en: '`NativeQueue`: A thread-safe version of a **First In, First Out** (**FIFO**)
    queue'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NativeQueue`: 一个线程安全的**先进先出**（**FIFO**）队列'
- en: So, in our job, we use a one-sized `NativeArray` variable to store input and
    output data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的工作中，我们使用一个固定大小的`NativeArray`变量来存储输入和输出数据。
- en: 'Now, we want to run the job. To do that, we need to use `MonoBehaviour` to
    initialize and run it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要运行这个任务。为了做到这一点，我们需要使用`MonoBehaviour`来初始化和运行它：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `Start`, we first create an empty `NativeArray`. The first argument of `NativeArrayconstructor`
    is the size; the second argument is `Allocator`. There are actually three allocators:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start`方法中，我们首先创建一个空的`NativeArray`。`NativeArray`构造函数的第一个参数是大小；第二个参数是`Allocator`。实际上有三个分配器：
- en: '`Allocator.Temp`: This is the fastest one, but its life span must be under
    a frame. In fact, Unity forces you to call `Dispose` on such an array before the
    function returns. For this reason, we cannot use `Allocator.Temp` for native containers
    passed as an argument to jobs. Jobs are not guaranteed to complete in the same
    frame in which they start.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Allocator.Temp`: 这是三者中最快的，但它的生命周期必须在一个帧之内。实际上，Unity强制你在函数返回之前调用`Dispose`来处理这样的数组。因此，我们不能将`Allocator.Temp`用于作为作业参数传递的原生容器。作业不保证在它们开始启动的同一帧内完成。'
- en: '`Allocator.TempJob`: This is slower than `Allocator.Temp` and its lifetime
    is restricted to under four frames. This is the perfect type of `Allocator` for
    passing data to simple jobs that run and return quickly, such as the one in our
    example.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Allocator.TempJob`: 这比`Allocator.Temp`慢，其生命周期限制在四个帧以下。这是传递给简单作业的完美类型的`Allocator`，这些作业运行并快速返回，例如我们例子中的那种。'
- en: '`Allocator.Persistent`: This is the slower of the three, but its lifetime is
    unbounded. This is the type of `Allocator` where you want to store persistent
    data or data that jobs need to access for an extended period.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Allocator.Persistent`: 这是三者中最慢的，但它的生命周期是无限的。这是你想要存储持久数据或作业需要长时间访问的数据的`Allocator`类型。'
- en: After that, we create a new `SimpleJob` instance, passing `number` and `data`
    to it. Then, we schedule and run the job with the `Schedule` function. This will
    return a `jobHandle` instance, which we can use to control the job execution.
    Finally, we wait for the job to be completed and then print the result. Everything
    looks like standard C# code, but the job runs in a separate thread!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建一个新的`SimpleJob`实例，将`number`和`data`传递给它。然后，我们使用`Schedule`函数安排和运行作业。这将返回一个`jobHandle`实例，我们可以用它来控制作业执行。最后，我们等待作业完成，然后打印结果。一切看起来都像是标准的C#代码，但作业是在一个单独的线程中运行的！
- en: Remember to be nice C# citizens and always dispose of native containers manually!
    You do not want to pollute your memory in the same way that you do not want to
    pollute our world.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要做一个好的C#公民，并且总是手动处理原生容器！你不想以污染内存的方式污染我们的世界，就像你不想以污染我们的世界的方式污染我们的世界一样。
- en: At this point, if you attach `SimpleJobRunner` to an empty object, you should
    see the result printed in the debug console. Everything is effected in a multithreading
    style.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你将`SimpleJobRunner`附加到一个空对象上，你应该在调试控制台中看到打印的结果。所有操作都是以多线程的方式进行的。
- en: A more complex example
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更复杂的例子
- en: Spawning a job just to sum two numbers is definitely not an example of optimal
    programming. Unity created jobs to run thousands of them to lift hard work into
    the multithreading domain.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了求和两个数字就启动一个作业绝对不是最优编程的例子。Unity创建作业是为了运行数千个，将繁重的工作提升到多线程领域。
- en: 'Therefore, we will now modify our previous spinning cubes example so that the
    actual spinning is performed by jobs. The first thing we want to do is to create
    our job, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在将修改我们之前的旋转立方体示例，以便实际的旋转由任务执行。我们首先想要做的是创建我们的任务，如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This job is a bit more complicated, but do not worry. First, it extends `IJobParallelForTransform`;
    this is a specialized job interface for running parallel transformations of `GameObject`
    instances. You can do the same by extending `IJob`, but, because this is a very
    common use case, Unity wrote most of the code for us. As you can see, the main
    difference is the fact that `Execute` now has two parameters. In our demo, we
    want to run the same job on every one of our 10,000 cubes. In this case, the parameters
    are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务稍微复杂一些，但不用担心。首先，它扩展了 `IJobParallelForTransform`；这是一个用于运行 `GameObject` 实例并行变换的专用任务接口。你也可以通过扩展
    `IJob` 来实现同样的功能，但由于这是一个非常常见的用例，Unity 为我们编写了大部分代码。正如你所见，主要区别在于 `Execute` 现在有两个参数。在我们的演示中，我们想在我们的
    10,000 个立方体中的每一个上运行相同的任务。在这种情况下，参数如下：
- en: '`index` represents the `index`^(th) cube in our scene'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index` 代表场景中的 `index`^(th) 立方体'
- en: '`transform` is a reference to the `Transform` of the `index`^(th) cube'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transform` 是对 `index`^(th) 立方体 `Transform` 的引用'
- en: 'Our job takes two inputs:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务接受两个输入：
- en: '`speeds`: It is an array containing all the random speeds for every cube. Remember,
    we cannot get a reference to some data of a specific `GameObject`, so we need
    to write all the speeds into shared memory. Note that the field is `[ReadOnly]`; we
    do not want the *i*^(*th*) cube to be able to change the speed of another cube.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speeds`: 它是一个包含每个立方体所有随机速度的数组。记住，我们无法获取特定 `GameObject` 的某些数据的引用，因此我们需要将所有速度写入共享内存。请注意，字段是
    `[ReadOnly]`；我们不希望 *i*^(*th*) 立方体能够改变另一个立方体的速度。'
- en: '`deltaTime`: Because a job is completely disconnected from the Unity engine,
    it cannot access `Time` and other thread-unsafe parts of Unity. Therefore, we
    need to pass `deltaTime` ourselves.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deltaTime`: 由于任务完全与 Unity 引擎解耦，它无法访问 `Time` 和其他线程不安全的 Unity 部分。因此，我们需要自己传递
    `deltaTime`。'
- en: The `Execute` function is straightforward; we just rotate the cube.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Execute` 函数很简单；我们只是旋转立方体。'
- en: 'Now, we need to call these jobs on every cube, and we need to use a game manager
    for this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在每个立方体上调用这些任务，并且我们需要使用游戏管理器来完成这个任务：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We start by defining the underlying data as in the classic example. The first
    attributes are the same; the interesting ones are the final three:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义与经典示例相同的基本数据。前几个属性是相同的；有趣的是最后三个：
- en: '`transformAccessArray` is the array in which we will store `transform` instance
    references of all of our cubes. That''s how our job can access them.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transformAccessArray` 是我们将存储所有立方体 `transform` 实例引用的数组。这就是我们的任务如何访问它们的方式。'
- en: '`jobHandle` is the handle we will use to query the Job System for the state
    of the job.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobHandle` 是我们将用于查询任务系统任务状态的句柄。'
- en: '`speeds` is the list of random speeds as described before:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speeds` 是之前描述的随机速度列表：'
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `Start`, we just initialize all the native containers, and then we spawn
    the cubes. Note that we use the `Allocator.Persistent` allocator because we want
    to initialize the speed on `Start` and then use the same list for the application''s
    entire lifetime:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Start` 方法中，我们只是初始化所有原生容器，然后生成立方体。请注意，我们使用 `Allocator.Persistent` 分配器，因为我们想在
    `Start` 时初始化速度，然后在应用程序的整个生命周期中使用相同的列表：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `SpawnCubes` function is very similar to the previous one. However, there
    are two crucial lines that differ:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpawnCubes` 函数与之前的非常相似。然而，有两行关键代码不同：'
- en: After we instantiate a cube, we add its `transform` to `transformAccessArray`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们实例化一个立方体后，我们将它的 `transform` 添加到 `transformAccessArray`。
- en: Instead of setting the random speed in the `Rotator` `MonoBehaviour` of the
    cube, we set it in the speeds array. In fact, we should not have the `Rotator`
    component in the Prefab!
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是在立方体的 `Rotator` `MonoBehaviour` 中设置随机速度，而是在速度数组中设置。实际上，我们不应该在 Prefab 中有
    `Rotator` 组件！
- en: 'Now, every frame, we need to run the job in parallel on every cube:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每一帧，我们都需要在所有立方体上并行运行任务：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use the same pattern as before. We check whether the previous jobs are now
    complete, we instantiate a new job, we set the data, and then we schedule the
    job over the entire **`transformAccessArray`**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与之前相同的模式。我们检查之前的任务是否已经完成，实例化一个新的任务，设置数据，然后在整个 **`transformAccessArray`**
    上调度任务。
- en: 'If everything is correct, we can run the game and see the same scene as before.
    Now, however, we can enjoy ~35 FPS:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们可以运行游戏并看到与之前相同的场景。现在，然而，我们可以享受 ~35 FPS：
- en: '![](img/21eab8f0-53da-45f9-bee2-62e2c9deb98d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21eab8f0-53da-45f9-bee2-62e2c9deb98d.png)'
- en: Looking at Profiler, we can see that, now, the time used by scripts (the lower
    blue one) is almost invisible. It dropped from 10 ms to 1 ms. That's a 90% improvement!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Profiler，我们可以看到，现在脚本（下方的蓝色部分）所用的时间几乎看不见。它从10毫秒下降到1毫秒。这是一个90%的改进！
- en: However, we still have a problem. Our scene is filled by 10,000 `GameObject` instances,
    10,000 `Transforms`, 10,000 `MeshRenderers`, and another 10,000 copies of different
    components. `MonoBehaviour` and `GameObject` are heavy data structures, and they
    are consuming a sensible amount of memory and CPU cycles.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然有一个问题。我们的场景被10,000个`GameObject`实例、10,000个`Transforms`、10,000个`MeshRenderers`和另外10,000个不同组件的副本所填满。`MonoBehaviour`和`GameObject`是重量级的数据结构，它们消耗了相当数量的内存和CPU周期。
- en: Can we do better? Yes, we can.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做得更好吗？是的，我们可以。
- en: The new ECS
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的ECS
- en: 'The ECS is a brave and ambitious attempt to redesign the core foundation of
    Unity''s design: the `GameObject`-`MonoBehaviour` paradigm. As you can imagine,
    changing the base design pattern of every object in the game is not an easy task.
    So you may ask: Why?'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ECS是一个勇敢而雄心勃勃的尝试，重新设计Unity设计核心基础：`GameObject`-`MonoBehaviour`范式。正如你可以想象的那样，改变游戏中每个对象的基本设计模式不是一件容易的任务。所以你可能想知道：为什么？
- en: 'There are several reasons for that. Let''s look at some of them objectively:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因。让我们客观地看看其中的一些：
- en: First, as we said before, `GameObject` and `MonoBehaviour` are heavy objects;
    they carry a lot of internal code and data structures. The overhead introduced
    by `GameObject` instances and `MonoBehaviour` is large enough to limit the number
    of objects  you can have on the screen more than the resources needed to render
    them. That's not a good thing for an abstraction model.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，正如我们之前所说的，`GameObject`和`MonoBehaviour`是重量级对象；它们携带大量的内部代码和数据结构。`GameObject`实例和`MonoBehaviour`引入的开销足以限制屏幕上可以拥有的对象数量，这比渲染它们所需的资源还要多。这对抽象模型来说不是一件好事。
- en: 'Second, `MonoBehaviour` instances are scattered in memory. This means that
    `GameObject` needs to look around in memory to retrieve all the `MonoBehaviour`
    instances it is connected to, and that the system relies on references. This has
    two problems: it makes caches very inefficient and, more important, it is a problem
    when we want to use `GameObject` instances in a massive multithreading application,
    for instance, by using jobs (we have seen that jobs cannot use references safely).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，`MonoBehaviour`实例散布在内存中。这意味着`GameObject`需要在内存中搜索以检索它连接的所有`MonoBehaviour`实例，并且系统依赖于引用。这有两个问题：它使缓存非常低效，更重要的是，当我们在大规模多线程应用程序中使用`GameObject`实例时，例如通过使用作业（我们已经看到作业不能安全地使用引用），这是一个问题。
- en: 'Last, but not least, `MonoBehaviour` instances have a problem from a code design
    point of view: they store both data and behavior. This is not a huge problem.
    After all, a lot of amazing games have been shipped using this paradigm. However,
    it is common in software architecture to separate the data (often called the **model**)
    and the algorithm that uses the data (often called the** controller***). *'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，从代码设计角度来看，`MonoBehaviour`实例存在一个问题：它们存储数据和行为。这并不是一个大问题。毕竟，许多令人惊叹的游戏都是使用这种范式发布的。然而，在软件架构中，通常将数据（通常称为**模型**）与使用数据的算法（通常称为**控制器**）分开。*
- en: 'The ECS, on the other hand, goes in the direction of separating the data from
    the behavior. It is based on three different components:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，ECS朝着将数据与行为分离的方向发展。它基于三个不同的组件：
- en: An **entity** is just defined by its set of components. There is literally zero
    abstraction here.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**仅仅由其组件集定义。这里实际上没有抽象。'
- en: A **component** is purely data. A `Health` component contains only the life
    points; a `Shield` component contains only the number of shields; a `Rotation`
    component contains only the object orientation, and so on.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**纯粹是数据。`Health`组件只包含生命值；`Shield`组件只包含护盾数量；`Rotation`组件只包含对象方向，等等。'
- en: A **system** defines the behavior of entities. A system applies a specific behavior
    to every entity containing a particular set of components. For instance, `MoveAndRotateEnemy`
    may apply translation and rotation to every entity with the `Rotation`, `Translation`,
    and `Enemy` components.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**定义了实体的行为。系统将特定的行为应用于包含特定组件集的每个实体。例如，`MoveAndRotateEnemy`可能将平移和旋转应用于具有`Rotation`、`Translation`和`Enemy`组件的每个实体。'
- en: Everything is now in its own place.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都各就各位。
- en: Mixing ECS and jobs
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合ECS和作业
- en: 'It is time to apply ECS to our 10,000 spinning cubes. Before we start, we need
    to install the packages:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将ECS应用到我们10,000个旋转的立方体上了。在我们开始之前，我们需要安装以下包：
- en: Open Window | Package Manager. Click on Advanced and make sure that Show preview
    packages is enabled.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开窗口 | 包管理器。点击高级并确保已启用“显示预览包”。
- en: 'Then, from the list, install the Entities package and the Hybrid Renderer package:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从列表中安装“实体”包和“混合渲染器”包：
- en: '![](img/fa81e2ff-4471-4b32-8ea7-ab842a4d82a0.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa81e2ff-4471-4b32-8ea7-ab842a4d82a0.png)'
- en: 'As mentioned previously, ECS is changing rapidly. We tested the code in this
    book with version 0.1.1-preview. If you, as a future reader, have a more recent
    version, there is a big chance that there will be some incompatibility. In that
    case, I encourage you to compare the code with the latest examples of ECS contained
    in this official repository: [https://github.com/Unity-Technologies/EntityComponentSystemSamples](https://github.com/Unity-Technologies/EntityComponentSystemSamples).
    I apologize for my lack of forecasting ability.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ECS正在快速发展。我们在这本书中测试了0.1.1-preview版本的代码。如果你作为未来的读者，有一个更近的版本，有很大可能会出现一些不兼容性。在这种情况下，我鼓励你将代码与这个官方仓库中包含的最新ECS示例进行比较：[https://github.com/Unity-Technologies/EntityComponentSystemSamples](https://github.com/Unity-Technologies/EntityComponentSystemSamples)。我为我的预测能力不足表示歉意。
- en: 'Now we are ready to write the first component. Our cube needs to spin, so we
    need to have a certain `RotationSpeed`. That will be the name of our component:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写第一个组件。我们的立方体需要旋转，因此我们需要一个特定的`RotationSpeed`。这将是我们的组件名称：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See how simple that is. As we have said before, a component is just data. The
    rotation speed is represented by a single float; therefore, we just need to store
    a simple float.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来多么简单。正如我们之前所说，组件只是数据。旋转速度由一个单精度浮点数表示；因此，我们只需要存储一个简单的浮点数。
- en: 'You may ask: how do I attach this component to an entity? Can I still use the
    inspector to set the values? How about all the goodies I love in Unity? Sadly,
    components cannot be attached to `GameObject` (after all, `GameObject` is not
    part of the ECS). Entities do not show up in the scene editor and components do
    not appear in the inspector.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：我如何将这个组件附加到实体上？我还能使用检查器来设置值吗？关于我在Unity中喜欢的一切好东西呢？遗憾的是，组件不能附加到`GameObject`（毕竟，`GameObject`不是ECS的一部分）。实体不会出现在场景编辑器中，组件也不会出现在检查器中。
- en: Fortunately, there is a solution if we want to keep some functionality of the
    Editor, such as, for instance, defining a Prefab that we can spawn 10,000 times.
    Mixing the `GameObject`-`MonoBehaviour` paradigm with ECS is called **hybrid ECS**
    and is the perfect way to keep the best of both worlds.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果我们想保留编辑器的一些功能，比如定义一个可以生成10,000次的预制体，那么有一个解决方案。将`GameObject`-`MonoBehaviour`范式与ECS混合称为**混合ECS**，这是保持两者最佳之处的完美方式。
- en: 'To enable it for our component, we need to write an `IConvertGameObjectToEntity` implementation. `IConvertGameObjectToEntity`
    is a piece of code that automatically converts a standard `MonoBehaviour` to the
    correspondent component:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的组件启用，我们需要编写一个`IConvertGameObjectToEntity`实现。`IConvertGameObjectToEntity`是一段代码，它自动将标准的`MonoBehaviour`转换为相应的组件：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, `RotationSpeedAuthoring` is an `IConvertGameObjectToEntity` implementation
    and a `MonoBehaviour` (so that we can attach it to a `GameObject`). The core of
    the conversion lies in the `Convert` function. The signature is confusing; it
    changed a lot in the past, and it will probably change again in the future. What
    is important is the content: the function takes the data of the `MonoBehaviour`,
    adds it to a new component (in our case, `RotationSpeed`), applies some processing
    (in our case, we convert degrees per second into radians per second), and finally
    attaches the component to the entity.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`RotationSpeedAuthoring`是一个`IConvertGameObjectToEntity`实现和一个`MonoBehaviour`（这样我们就可以将其附加到一个`GameObject`上）。转换的核心在于`Convert`函数。签名可能有些令人困惑；它过去改变了很多，将来可能还会再次改变。重要的是内容：该函数接受`MonoBehaviour`的数据，将其添加到一个新的组件（在我们的案例中是`RotationSpeed`），应用一些处理（在我们的案例中，我们将每秒度转换为每秒弧度），并最终将组件附加到实体上。
- en: We now create `cubePrefab` as before and add the `RotationSpeedAuthoring` `MonoBehaviour`
    to it and, at runtime, `GameObject` will be converted to an entity.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在创建`cubePrefab`，就像之前一样，并将`RotationSpeedAuthoring` `MonoBehaviour`添加到其中，在运行时，`GameObject`将被转换为实体。
- en: 'Now that we have everything we need, we just need to write our game controller:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的，我们只需要编写我们的游戏控制器：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a pretty standard game manager, but let''s go over the exciting parts.
    First, we have a new attribute: `entityManager`. This is just a reference to the
    primary entity manager. An entity manager, as the name suggests, is a data structure
    where you can perform basic operations on entities, such as checking whether an
    entity is still alive, or creating and editing entities.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当标准的游戏管理器，但让我们来看看激动人心的部分。首先，我们有一个新的属性：`entityManager`。这只是一个对主要实体管理器的引用。正如其名所示，实体管理器是一个数据结构，你可以对实体执行基本操作，例如检查实体是否仍然存活，或创建和编辑实体。
- en: You do not need to create an entity manager. Unity will provide one for you.
    As you can see in `Start`, you just need to reference the main global one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要创建实体管理器。Unity 会为你提供一个。正如你在 `Start` 中看到的，你只需要引用主要的全局一个。
- en: 'It is now time to spawn the cubes. The first interesting line is this one:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候生成立方体了。第一行有趣的代码是这一行：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this one, we take the Prefab we built, and we convert it to an entity.
    Every `MonoBehaviour` in the Prefab gets converted into a component and, sometimes,
    more than one. We already know that `RotationSpeedAuthoring` gets converted into
    `RotationSpeed`, but Unity provides conversions for many standard `MonoBehaviour`
    subclasses, such as the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类，我们将我们构建的预制体转换为实体。预制体中的每个 `MonoBehaviour` 都会被转换为组件，有时甚至更多。我们已经知道 `RotationSpeedAuthoring`
    被转换为 `RotationSpeed`，但 Unity 为许多标准的 `MonoBehaviour` 子类提供了转换，如下所示：
- en: Each `Transform` is converted into `Translation`, `Rotation`, and `Scale` components
    (and some less common ones, such as `NonLocalScale`)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `Transform` 转换为 `Translation`、`Rotation` 和 `Scale` 组件（以及一些不太常见的，例如 `NonLocalScale`）
- en: Each `MeshRenderer` is converted into the `RenderMesh` component
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `MeshRenderer` 转换为 `RenderMesh` 组件
- en: 'Now, for each cube position, we need to instantiate a new entity. This is similar
    to how we instantiate a `GameObject`, but we invoke `Instantiate` on `entityManager`,
    as shown in the following code block:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于每个立方体位置，我们需要实例化一个新的实体。这与我们实例化 `GameObject` 的方式类似，但我们调用 `entityManager`
    上的 `Instantiate`，如下面的代码块所示：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then, we set the `Translation` and `RotationSpeed` components on the entity.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在实体上设置 `Translation` 和 `RotationSpeed` 组件。
- en: 'The first is to set the cube position to the computed position, and the latter
    to set the random rotation speed. Note that the component uses radian per second,
    so we need to convert the value:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是将立方体的位置设置为计算出的位置，后者设置为随机旋转速度。请注意，该组件使用每秒弧度，因此我们需要转换该值：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, we have the components, and we have a way to instantiate the
    entities. We are still missing a system to actually move the cubes. We want to
    build a system that takes every entity with `RotationSpeed` and a `Rotation` component
    and make them spin. Not only this, but we also want to use C# jobs so that all
    10,000 cubes spin in parallel. This is a typical pattern and, therefore, Unity
    has a class for us.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了组件，并且我们有了一种实例化实体的方法。我们仍然缺少一个实际移动立方体的系统。我们想要构建一个系统，该系统针对具有 `RotationSpeed`
    和 `Rotation` 组件的每个实体，使它们旋转。不仅如此，我们还想使用 C# 作业，以便所有 10,000 个立方体并行旋转。这是一个典型的模式，因此
    Unity 为我们提供了一个类。
- en: 'However, we first need to write our job:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们首先需要编写我们的工作：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is similar to the previous job, but with a number of differences. First,
    we extend `IJobForEachinstead` of `IJobParallelForTransform` because entities
    have no `Transforms`. You may note that we pass two type parameters to the `IJobForEach`
    interface. These are the types of components we want to use in our job, namely, `Rotation`
    and `RotationSpeed`. We may put any number of components in there; the important
    thing is that we add the same component, in the same order, as the parameters
    of `Execute`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个工作类似，但有一些不同。首先，我们扩展了 `IJobForEachinstead` 而不是 `IJobParallelForTransform`，因为实体没有
    `Transforms`。你可能注意到我们向 `IJobForEach` 接口传递了两个类型参数。这些是我们想在作业中使用的组件类型，即 `Rotation`
    和 `RotationSpeed`。我们可以放入任意数量的组件；重要的是我们以与 `Execute` 参数相同的顺序添加相同的组件。
- en: For example, if we extend `IJobForEach<Rotation, RotationSpeed>`, then `Execute`
    will take as parameters a reference to a `Rotation` and a `RotationSpeed` component.
    However, if we extend `IJobForEach<Scale>`, then `Execute` will only take as a
    parameter a reference to a `Scale` component; and so on. This acts as a filter
    over all the entities and makes sure that this job is applied only on entities
    containing `Rotation` and `RotationSpeed` components.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们扩展`IJobForEach<Rotation, RotationSpeed>`，那么`Execute`将接受一个`Rotation`和`RotationSpeed`组件的引用作为参数。然而，如果我们扩展`IJobForEach<Scale>`，那么`Execute`将只接受一个`Scale`组件的引用；等等。这就像对所有实体进行过滤，确保这个作业只应用于包含`Rotation`和`RotationSpeed`组件的实体。
- en: 'Finally, you may note that we are using some strange types for rotation: `quaterion`,
    with a lower case *q*. This is because Unity developed some new types for vectors
    and quatrains in the ECS that have the advantage of being more optimized for jobs
    and components.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能注意到我们正在使用一些奇怪的旋转类型：`quaterion`，小写字母*q*。这是因为Unity在ECS中为向量和四元数开发了一些新的类型，这些类型在作业和组件方面具有更优化的优势。
- en: There are a lot of them but, as usual, they are a work in progress. To find
    up-to-date info on them, check the documentation of the `Unity.Mathematics` module
    here: [https://docs.unity3d.com/Packages/com.unity.mathematics@1.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.mathematics@1.0/manual/index.html)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多这样的组件，但像往常一样，它们仍在开发中。要获取它们的最新信息，请查看`Unity.Mathematics`模块的文档：[https://docs.unity3d.com/Packages/com.unity.mathematics@1.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.mathematics@1.0/manual/index.html)
- en: 'Now that we have a job, we need to create a component system that takes advantage
    of it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了作业，我们需要创建一个利用它的组件系统：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`JobComponentSystem` is a class designed to build a system that can run using
    C# jobs.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobComponentSystem`是一个用于构建可以使用C#作业运行的系统的类。'
- en: 'We start by defining a new class called `RotationSystem`, which extends the
    `JobComponentSystem` class. Inside this class, we override the `OnUpdate` (note:
    `OnUpdate`, not `Update`) method, inside which we just create a new `RotatorJob`
    job and schedule it.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的类，称为`RotationSystem`，它扩展了`JobComponentSystem`类。在这个类中，我们重写了`OnUpdate`（注意：`OnUpdate`，而不是`Update`）方法，在这个方法中，我们只是创建一个新的`RotatorJob`作业并安排它。
- en: 'Now, we just need to attach the `ECSJobManager` to an empty `GameObject` and
    run the application and see all the cubes spinning as normal. With these changes,
    we finally reach more than 100 FPS! Let''s look at Profiler:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将`ECSJobManager`附加到一个空的`GameObject`上，运行应用程序，就可以看到所有立方体像往常一样旋转。随着这些更改，我们最终达到了超过100
    FPS！让我们看看Profiler：
- en: '![](img/3e92b1f4-8470-461a-90a9-4d2c5d97188c.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e92b1f4-8470-461a-90a9-4d2c5d97188c.png)'
- en: The time is so fast that we can see the small spikes of v-sync. Every frame
    takes less than 10 ms; this is less than the time we spend only on scripts using
    the classical non-DOTS approach! That's an incredible speeding up, and the application
    contains less than half the memory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 时间过得如此之快，以至于我们可以看到v-sync的小峰值。每一帧都少于10毫秒；这比我们仅使用经典非DOTS方法在脚本上花费的时间还要少！这是一个令人难以置信的加速，而且应用程序的内存不到一半。
- en: But guess what. We can still do better.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但是猜猜看。我们仍然可以做得更好。
- en: The burst compiler
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爆发式编译器
- en: The last component of the DOTS is the burst compiler. The burst compiler is
    a compiler that can compile a subset of C# into optimized native code. The main
    goal of Burst is to compile jobs so that they can be as fast and lightweight as
    possible.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: DOTS的最后一个组件是爆发式编译器。爆发式编译器是一个可以将C#的子集编译成优化原生代码的编译器。Burst的主要目标是编译作业，使它们尽可能快和轻量。
- en: 'The cool thing is that using the burst compiler is extremely easy. First, you
    need to install the Burst package from Window | Package Manager. Then, the only
    thing you need to change is to add the `[BurstCompile]` decorator on top of the
    job definitions as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好玩的是，使用爆发式编译器非常简单。首先，你需要从Window | 包管理器安装Burst包。然后，你需要更改的唯一一件事是在作业定义的顶部添加`[BurstCompile]`装饰器，如下所示：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's it! Now the job is compiled with Burst, and this will squeeze a bit more
    performance from our application. Our demo is straightforward, and the Burst compilation
    effect is limited—on my machine, I can reach 110 FPS, but for more complex jobs,
    the impact is more significant.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在作业是用Burst编译的，这将从我们的应用程序中挤出更多性能。我们的演示很简单，Burst编译的效果有限——在我的机器上，我可以达到110
    FPS，但对于更复杂的作业，影响更为显著。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The DOTS is the peak of Unity's effort to push Unity into the future of gaming.
    I firmly believe that in the future, DOTS will be a core component of any optimization
    effort, and this chapter will definitely grow into several ones while DOTS becomes
    more stable and is supported by the community.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: DOTS 是 Unity 推动Unity进入游戏未来之巅的努力的巅峰。我坚信，在未来，DOTS 将成为任何优化工作的核心组件，并且随着DOTS变得更加稳定并得到社区的支撑，这一章节肯定会发展成为几个章节。
- en: Unfortunately, at this stage, C# jobs and ECS are still very unstable, their
    APIs are changing rapidly and, therefore, I do not advise using them in big, important,
    commercial games. However, I believe it is important to start experimenting with
    them so as to be ready for when their time comes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在这个阶段，C# 作业和 ECS 仍然非常不稳定，它们的 API 正在迅速变化，因此，我不建议在大型、重要、商业游戏中使用它们。然而，我认为开始尝试它们是很重要的，以便为它们到来做好准备。
- en: This chapter merely scratches the surface of the DOTS. There are many more details,
    configurations, and optimizations that can be implemented both in jobs and ECS.
    For more information, the main Unity Hub for DOTS ([https://unity.com/dots](https://unity.com/dots))
    is your best friend.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只是对 DOTS 的表面进行了探讨。还有很多更多的细节、配置和优化可以在作业和 ECS 中实现。更多信息，Unity DOTS 的主要中心([https://unity.com/dots](https://unity.com/dots))是你的最佳朋友。
- en: This chapter effectively concludes all of the techniques we can bestow that
    explicitly aim to improve application performance. However, optimizing your workflow
    is also enormously beneficial. As mentioned previously, the one constant cost
    of performance optimization work is development time. However, if you can speed
    up our development working, saving some time during the more tedious parts of
    the job, then hopefully, you can save yourself enough time to actually implement
    as many optimization techniques we've talked about through this entire book as
    you can. There are a lot of neat little nuances to the Unity Engine that aren't
    well known or clearly documented, and that only become apparent through experience
    with the engine or by involving ourselves in its community. As such, the next
    chapter will be full of hints and tips for improving how to manage your project
    and scenes more effectively and how to make the most of the Unity Editor.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有效地总结了我们可以赋予的所有旨在明确提高应用程序性能的技术。然而，优化你的工作流程也是非常有益的。正如之前提到的，性能优化工作的一个恒定成本是开发时间。但是，如果你能加快我们的开发工作，在工作的更繁琐部分节省一些时间，那么，希望你能节省足够的时间来实际实施我们在这整本书中讨论的尽可能多的优化技术。Unity
    引擎中有很多小而巧妙的细节，这些细节并不为人所知或没有明确记录，只有通过使用引擎或参与其社区才能显现出来。因此，下一章将充满关于如何更有效地管理你的项目和场景以及如何充分利用
    Unity 编辑器的提示和技巧。
