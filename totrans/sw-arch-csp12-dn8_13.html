<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer237">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 class="chapterTitle" id="_idParaDest-265"><span class="koboSpan" id="kobo.2.1">Interacting with Data in C# – Entity Framework Core</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">As we mentioned in </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 7</span></em><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.7.1">, software systems are organized into layers that communicate with each other through interfaces and classes that don’t depend on how the peculiarities of each layer are implemented. </span><span class="koboSpan" id="kobo.7.2">When the software is a business/enterprise system, it usually contains at least three layers: the data layer, the business layer, and the presentation layer, if the software is based on a classical layer architecture (see the </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Classic layers architecture</span></em><span class="koboSpan" id="kobo.9.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 7</span></em><span class="koboSpan" id="kobo.11.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.12.1">If, instead, the application is based on an onion architecture, an outermost layer contains presentation logic, drivers, and testing logic, then there is an application layer, and finally, a domain layer (see the </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Onion architecture</span></em><span class="koboSpan" id="kobo.14.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 7</span></em><span class="koboSpan" id="kobo.16.1">). </span><span class="koboSpan" id="kobo.16.2">While, in the onion architecture, layers are defined in a slightly different way, the functionalities of the three layers of the onion architecture are basically the same as the ones of the three layers of the classical layer architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.17.1">However, notwithstanding the differences among all possible architectural choices, experience has proved that the main functionalities needed to handle data efficaciously are quite standard.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.18.1">More specifically, in all architectures described in </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Chapter 7</span></em><em class="italic"><span class="koboSpan" id="kobo.20.1">, </span></em><span class="koboSpan" id="kobo.21.1">data-processing layers have the main purpose of mapping data from a data storage subsystem into objects and vice versa.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.22.1">In the case of the classical data layer, these objects are plain objects with no methods, while in the case of the domain layer, they are rich objects whose methods implement the application’s domain logic. </span><span class="koboSpan" id="kobo.22.2">Data layers, instead, implement the application’s domain logic within repository classes that are associated with their plain objects (see the </span><em class="italic"><span class="koboSpan" id="kobo.23.1">The Repository and Unit of Work patterns</span></em><span class="koboSpan" id="kobo.24.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Chapter 7</span></em><span class="koboSpan" id="kobo.26.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.27.1">This led to the conception of general-purpose frameworks for implementing data layers in a substantially declarative way. </span><span class="koboSpan" id="kobo.27.2">These tools are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.28.1">Object-Relational Mapping </span></strong><span class="koboSpan" id="kobo.29.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.30.1">ORM</span></strong><span class="koboSpan" id="kobo.31.1">) tools since they are data storage subsystems based on relational databases. </span><span class="koboSpan" id="kobo.31.2">However, they also work well with modern non-relational storage classified as NoSQL databases (such as MongoDB and Azure Cosmos DB) since their data model is closer to the target object model than a purely relational model.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.32.1">ORMs improve and simplify the whole development process since they factor out and take away the burden of mapping data into objects and vice versa, so developers can focus just on the peculiarity of the business domain.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.33.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.34.1">Understanding ORM basics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.35.1">Configuring Entity Framework Core</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.36.1">Entity Framework Core migrations</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.37.1">Compiled models</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.38.1">Querying and updating data with Entity Framework Core</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.39.1">Deploying your data layer</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.40.1">Understanding Entity Framework Core advanced features</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.41.1">This chapter describes ORMs and how to configure them, and then focuses on Entity Framework Core, the ORM included in .NET 8.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.42.1">Before delving into ORM basics, let’s look at the technical requirements needed to follow the practical examples in this chapter.</span></p>
<h1 class="heading-1" id="_idParaDest-266"><span class="koboSpan" id="kobo.43.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.44.1">This chapter requires the free Visual Studio 2022 Community Edition or better with all the database tools installed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.45.1">All the concepts in this chapter will be clarified with practical examples. </span><span class="koboSpan" id="kobo.45.2">You will find the code for this chapter at </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.46.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.47.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-267"><span class="koboSpan" id="kobo.48.1">Understanding ORM basics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.49.1">ORMs map </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.50.1">relational DB tables into in-memory collections of objects where object properties correspond to DB table columns. </span><span class="koboSpan" id="kobo.50.2">Types from C#, such as Booleans, numeric types, and strings, have corresponding DB types. </span><span class="koboSpan" id="kobo.50.3">If GUIDs are not available in the mapped DB, then types such as GUIDs are mapped to their equivalent string representations. </span><span class="koboSpan" id="kobo.50.4">All date and time types are mapped either to C# </span><code class="inlineCode"><span class="koboSpan" id="kobo.51.1">DateTime</span></code><span class="koboSpan" id="kobo.52.1"> when the date/time contains no time zone information, to </span><code class="inlineCode"><span class="koboSpan" id="kobo.53.1">DateTimeOffset</span></code><span class="koboSpan" id="kobo.54.1"> when the date/time also contains explicit time zone information, to </span><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">DateOnly</span></code><span class="koboSpan" id="kobo.56.1"> when the type contains just date information, or to </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">TimeOnly</span></code><span class="koboSpan" id="kobo.58.1"> when the type contains just time information. </span><span class="koboSpan" id="kobo.58.2">Any DB time duration is mapped to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">TimeSpan</span></code><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">Finally, single characters should not be mapped at all to DB fields.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.61.1">Since the string properties of most object-oriented languages have no length limits associated with them (while DB string fields usually have length limits), the DB limits are taken into account in the DB mapping configuration. </span><span class="koboSpan" id="kobo.61.2">In general, when the mapping between DB types and object-oriented language types needs options to be specified, these options are declared in the mapping configuration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.62.1">The way the whole configuration is defined depends on the specific ORM. </span><span class="koboSpan" id="kobo.62.2">Entity Framework Core offers three options:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.63.1">Data annotations (property attributes)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.64.1">Name conventions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.65.1">A fluent configuration interface based on configuration objects and methods</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.66.1">While the fluent interface can be used to specify any configuration option, the data annotations and name conventions can be used for a smaller subset of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.67.1">Personally, I prefer using the fluent interface for most settings. </span><span class="koboSpan" id="kobo.67.2">I use name conventions only for specifying the principal key with an ID property name since I find that relying on name conventions for more complex settings is very dangerous. </span><span class="koboSpan" id="kobo.67.3">In fact, there are no compilation-time checks on name conventions, so a re-engineering operation might erroneously change or destroy some ORM settings.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.68.1">I use data annotations mainly for specifying constraints on the possible values of properties, such as the maximum length of a value or the fact that a property is obligatory and can’t be null. </span><span class="koboSpan" id="kobo.68.2">In fact, these constraints restrict the type specified in each property, so placing them next to the properties they are applied to increases the code’s readability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.69.1">All other </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.70.1">settings are better grouped and organized by using the fluent interface in order to increase code readability and maintainability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.71.1">Each ORM adapts to a specific DB type (Oracle, MySQL, SQL Server, and so on) with DB-specific adapters </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.72.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.73.1">providers</span></strong><span class="koboSpan" id="kobo.74.1"> or </span><strong class="keyWord"><span class="koboSpan" id="kobo.75.1">connectors</span></strong><span class="koboSpan" id="kobo.76.1">. </span><span class="koboSpan" id="kobo.76.2">Entity Framework Core has providers</span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.77.1"> for most of the available DB engines.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.78.1">A complete list of</span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.79.1"> providers can be found at </span><a href="https://docs.microsoft.com/en-US/ef/core/providers/"><span class="url"><span class="koboSpan" id="kobo.80.1">https://docs.microsoft.com/en-US/ef/core/providers/</span></span></a><span class="koboSpan" id="kobo.81.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.82.1">Adapters are necessary for the differences in DB types, for the way transactions are handled, and for all other features that are not standardized by the SQL language.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.83.1">Relationships among tables are represented with object pointers. </span><span class="koboSpan" id="kobo.83.2">For instance, in a one-to-many relationship, the class that’s mapped to the </span><em class="italic"><span class="koboSpan" id="kobo.84.1">one</span></em><span class="koboSpan" id="kobo.85.1"> side of the relationship contains a collection that is populated with the related objects on the </span><em class="italic"><span class="koboSpan" id="kobo.86.1">many</span></em><span class="koboSpan" id="kobo.87.1"> side of the relationship. </span><span class="koboSpan" id="kobo.87.2">On the other hand, the class mapped to the </span><em class="italic"><span class="koboSpan" id="kobo.88.1">many</span></em><span class="koboSpan" id="kobo.89.1"> side of the relationship has a simple property that is populated with a uniquely related object on the </span><em class="italic"><span class="koboSpan" id="kobo.90.1">one</span></em><span class="koboSpan" id="kobo.91.1"> side of the relationship.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.92.1">While, in the case of a one-to-one relationship, both classes have a property populated with the companion object, in the case of many-to-many relationships, both classes contain a collection that is populated with the related objects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.93.1">The whole database (or just a part of it) is represented by an in-memory cache class that contains a collection for each mapped DB table. </span><span class="koboSpan" id="kobo.93.2">First, the query and update operations are performed on an instance of an in-memory cache class, and then this instance is synchronized with the database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.94.1">The in-memory cache class that’s used by Entity Framework Core is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">DbContext</span></code><span class="koboSpan" id="kobo.96.1"> and it also contains the mapping configuration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.97.1">Developers can customize the </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">DbContext</span></code><span class="koboSpan" id="kobo.99.1"> class furnished by Entity Framework Core by inheriting from it and by adding their database-mapping instructions inside overridden methods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.100.1">Summing up, </span><code class="inlineCode"><span class="koboSpan" id="kobo.101.1">DbContext</span></code><span class="koboSpan" id="kobo.102.1"> subclass instances contain partial snapshots of the DB that are synchronized with the database to get/update the actual data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.103.1">DB queries are performed with a query language made of method calls on the collections of the in-memory cache class. </span><span class="koboSpan" id="kobo.103.2">The actual SQL is created and executed during the synchronization stage. </span><span class="koboSpan" id="kobo.103.3">For instance, Entity Framework Core performs </span><strong class="keyWord"><span class="koboSpan" id="kobo.104.1">Language Integrated Query</span></strong><span class="koboSpan" id="kobo.105.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.106.1">LINQ</span></strong><span class="koboSpan" id="kobo.107.1">) queries</span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.108.1"> on the collections mapped to the DB tables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.109.1">In general, LINQ queries </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.110.1">produce </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">IEnumerable</span></code><span class="koboSpan" id="kobo.112.1"> instances, that is, collections whose elements are not computed when the is created at the end of the query, but when you actually attempt to retrieve the collection elements from the. </span><span class="koboSpan" id="kobo.112.2">This is called lazy evaluation or deferred execution. </span><span class="koboSpan" id="kobo.112.3">It works as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.113.1">LINQ queries that start from a mapped collection of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.114.1">DbContext</span></code><span class="koboSpan" id="kobo.115.1"> create a specific subtype of </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">IEnumerable</span></code><span class="koboSpan" id="kobo.117.1"> called </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">IQueryable</span></code><span class="koboSpan" id="kobo.119.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.120.1">An </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">IQueryable</span></code><span class="koboSpan" id="kobo.122.1"> contains all the information that’s needed to issue a query to the database, but the actual SQL is produced and executed when the first element of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">IQueryable</span></code><span class="koboSpan" id="kobo.124.1"> is retrieved.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.125.1">Typically, each Entity Framework query ends with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">ToListAsync</span></code><span class="koboSpan" id="kobo.127.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.128.1">ToArrayAsync</span></code><span class="koboSpan" id="kobo.129.1"> operation that transforms the </span><code class="inlineCode"><span class="koboSpan" id="kobo.130.1">IQueryable</span></code><span class="koboSpan" id="kobo.131.1"> into a list or array, thereby causing the actual execution of the query on the database.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.132.1">If the query is expected to return just a single element or no element at all, we typically execute a </span><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">SingleOrDefaultAsync</span></code><span class="koboSpan" id="kobo.134.1"> operation that returns a single element, if any, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">null</span></code><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">This operation may be used also when several results are expected but we need just one. </span><span class="koboSpan" id="kobo.136.3">In this case, we might also use </span><code class="inlineCode"><span class="koboSpan" id="kobo.137.1">LastOrDefaultAsync</span></code><span class="koboSpan" id="kobo.138.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.139.1">If we need just to count the total results, for instance, for adequately organizing paging information, we can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">CountAsync()</span></code><span class="koboSpan" id="kobo.141.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.142.1">Also, updates, deletions, and the addition of new entities to a DB table are performed by mimicking these operations on a </span><code class="inlineCode"><span class="koboSpan" id="kobo.143.1">DbContext</span></code><span class="koboSpan" id="kobo.144.1"> collection property that represents the database table. </span><span class="koboSpan" id="kobo.144.2">However, entities may only be updated or deleted this way after they have been loaded in that memory collection by means of a query. </span><span class="koboSpan" id="kobo.144.3">Typically, an update query requires the in-memory representation of the entity to be modified as needed, while a delete query requires the in-memory representation of the entity to be removed from its in-memory mapped collection. </span><span class="koboSpan" id="kobo.144.4">In Entity Framework Core, the removal operation is performed by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.145.1">Remove(entity)</span></code><span class="koboSpan" id="kobo.146.1"> method of the collection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.147.1">The addition of a new entity has no further requirements. </span><span class="koboSpan" id="kobo.147.2">It is enough to add the new entity to the in-memory collection. </span><span class="koboSpan" id="kobo.147.3">Updates, deletions, and additions that are performed on various in-memory collections are actually passed to the database with an explicit call to a DB synchronization method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.148.1">For instance, Entity Framework Core passes all the changes that are performed on a </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">DbContext</span></code><span class="koboSpan" id="kobo.150.1"> instance to the database when you call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.151.1">DbContext.SaveChangesAsync()</span></code><span class="koboSpan" id="kobo.152.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.153.1">Changes</span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.154.1"> that are passed to the database during a synchronization operation are executed in a single transaction. </span><span class="koboSpan" id="kobo.154.2">Moreover, for ORMs, such as Entity Framework Core, that have an explicit representation of transactions, if a synchronization operation is executed in the scope of a transaction then it uses that transaction instead of creating a new transaction.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.155.1">The remaining sections in this chapter explain how to use Entity Framework Core, along with some example code based on this book’s WWTravelClub use case.</span></p>
<h1 class="heading-1" id="_idParaDest-268"><span class="koboSpan" id="kobo.156.1">Configuring Entity Framework Core</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.157.1">Since, as </span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.158.1">detailed in </span><em class="italic"><span class="koboSpan" id="kobo.159.1">Chapter 7, Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.160.1">, database handling is confined within a dedicated application layer, it is good practice to define your Entity Framework Core (</span><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">DbContext</span></code><span class="koboSpan" id="kobo.162.1">) in a separate library. </span><span class="koboSpan" id="kobo.162.2">Accordingly, we need to define a .NET class library project.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.163.1">We have two different kinds of library projects: </span><strong class="keyWord"><span class="koboSpan" id="kobo.164.1">.NET Standard</span></strong><span class="koboSpan" id="kobo.165.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.166.1">.NET Core</span></strong><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">Please refer to</span><em class="italic"><span class="koboSpan" id="kobo.168.1"> Chapter 5, Implementing Code Reusability in C# 12,</span></em><span class="koboSpan" id="kobo.169.1"> for a discussion on the various kinds of libraries.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.170.1">While .NET libraries </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.171.1">are tied to a specific .NET Core version, .NET Standard 2.0 libraries have a wide range of applications since they work with any .NET </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.172.1">version greater than 2.0 and also with the old .NET Framework 4.7 and above.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.173.1">Since our library is not a general-purpose library (it’s just a component of a specific .NET 8 application), instead of choosing a .NET Standard library project, we can simply choose a .NET 8 library. </span><span class="koboSpan" id="kobo.173.2">Our .NET 8 library project can be created and prepared as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.174.1">Open Visual Studio, click </span><strong class="screenText"><span class="koboSpan" id="kobo.175.1">Create new project</span></strong><span class="koboSpan" id="kobo.176.1"> and then select </span><strong class="screenText"><span class="koboSpan" id="kobo.177.1">Class Library</span></strong><span class="koboSpan" id="kobo.178.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.179.1">Name the new project </span><code class="inlineCode"><span class="koboSpan" id="kobo.180.1">WWTravelClubDB</span></code><span class="koboSpan" id="kobo.181.1"> and accept the same name for the whole Visual Studio solution.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.182.1">In the window that follows, choose .NET 8 as the target framework.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.183.1">We must install all Entity Framework Core-related dependencies. </span><span class="koboSpan" id="kobo.183.2">The simplest way to have all the necessary dependencies installed is to add the NuGet package for the provider of the database engine we are going to use – in our case, SQL Server – as we mentioned in </span><em class="italic"><span class="koboSpan" id="kobo.184.1">Chapter 10</span></em><span class="koboSpan" id="kobo.185.1">, </span><em class="italic"><span class="koboSpan" id="kobo.186.1">Deciding on the Best Cloud-Based Solution</span></em><span class="koboSpan" id="kobo.187.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.188.1">In fact, any </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.189.1">provider will install all the required packages since it has all of them as dependencies. </span><span class="koboSpan" id="kobo.189.2">So, let’s add the latest stable version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">Microsoft.EntityFrameworkCore.SqlServer</span></code><span class="koboSpan" id="kobo.191.1">. </span><span class="koboSpan" id="kobo.191.2">If you plan to use several database engines, you can also add other providers since they can work side by side. </span><span class="koboSpan" id="kobo.191.3">Later in this chapter, we will install other NuGet packages that contain tools that we need to process our Entity Framework Core configuration.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.192.1">Let’s rename the default </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">Class1</span></code><span class="koboSpan" id="kobo.194.1"> class to </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">MainDbContext</span></code><span class="koboSpan" id="kobo.196.1">. </span><span class="koboSpan" id="kobo.196.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">Class1</span></code><span class="koboSpan" id="kobo.198.1"> class is automatically added to the class library. </span><span class="koboSpan" id="kobo.198.2">Now, let’s replace its content with the following code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.199.1">using</span></span><span class="koboSpan" id="kobo.200.1"> System;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.201.1">using</span></span><span class="koboSpan" id="kobo.202.1"> Microsoft.EntityFrameworkCore;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.203.1">namespace</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.204.1">WWTravelClubDB</span></span><span class="koboSpan" id="kobo.205.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.206.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.207.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.208.1">MainDbContext</span></span><span class="koboSpan" id="kobo.209.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.210.1">DbContext</span></span><span class="koboSpan" id="kobo.211.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.212.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.213.1">MainDbContext</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.214.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.215.1">DbContextOptions options</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.216.1">)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.217.1">            : </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.218.1">base</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.219.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.220.1">options</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.221.1">)</span></span><span class="koboSpan" id="kobo.222.1">
        {
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.223.1">protected</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.224.1">override</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.225.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.226.1">OnModelCreating</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.227.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.228.1">ModelBuilder</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.229.1">        builder</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.230.1">)</span></span><span class="koboSpan" id="kobo.231.1">
        {
        }
    }
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.232.1">We inherit from </span><code class="inlineCode"><span class="koboSpan" id="kobo.233.1">DbContext</span></code><span class="koboSpan" id="kobo.234.1">, and we pass a </span><code class="inlineCode"><span class="koboSpan" id="kobo.235.1">DbContextOptions</span></code><span class="koboSpan" id="kobo.236.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.237.1">DbContext</span></code><span class="koboSpan" id="kobo.238.1"> constructor. </span><code class="inlineCode"><span class="koboSpan" id="kobo.239.1">DbContextOptions</span></code><span class="koboSpan" id="kobo.240.1"> contains creation options, such as the database connection string, which depends on the target DB engine.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.241.1">All the collections that have been mapped to database tables will be added as properties of </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">MainDbContext</span></code><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">The mapping configuration will be defined inside of the overridden </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">OnModelCreating</span></code><span class="koboSpan" id="kobo.245.1"> method with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">ModelBuilder</span></code><span class="koboSpan" id="kobo.247.1"> object passed as a parameter.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.248.1">The next step </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.249.1">is the creation of all the classes that represent the tables. </span><span class="koboSpan" id="kobo.249.2">These are called entities. </span><span class="koboSpan" id="kobo.249.3">We need an entity class for each DB table we want to map. </span><span class="koboSpan" id="kobo.249.4">Let’s create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">Models</span></code><span class="koboSpan" id="kobo.251.1"> folder in the project root for all of them. </span><span class="koboSpan" id="kobo.251.2">The next subsection explains how to define all the required entities.</span></p>
<h2 class="heading-2" id="_idParaDest-269"><span class="koboSpan" id="kobo.252.1">Defining DB entities</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.253.1">DB design, like the whole application design, is organized in iterations (see </span><em class="italic"><span class="koboSpan" id="kobo.254.1">Chapter 1, Understanding the Importance of Software Architecture</span></em><span class="koboSpan" id="kobo.255.1">). </span><span class="koboSpan" id="kobo.255.2">Let’s suppose that, in the first iteration, we need a prototype with two database tables: one for all the travel packages and another one for all the locations referenced by the packages. </span><span class="koboSpan" id="kobo.255.3">Each package covers just one location, while a single location may be covered by several packages, so the two tables are connected by a one-to-many relationship.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.256.1">So, let’s start with the location database table. </span><span class="koboSpan" id="kobo.256.2">As we mentioned at the end of the previous section, we need an entity class to represent the rows of this table. </span><span class="koboSpan" id="kobo.256.3">Let’s call the entity class </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">Destination</span></code><span class="koboSpan" id="kobo.258.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.259.1">namespace</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.260.1">WWTravelClubDB.Models</span></span><span class="koboSpan" id="kobo.261.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.262.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.263.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.264.1">Destination</span></span><span class="koboSpan" id="kobo.265.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.266.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.267.1">int</span></span><span class="koboSpan" id="kobo.268.1"> Id { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.269.1">get</span></span><span class="koboSpan" id="kobo.270.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.271.1">set</span></span><span class="koboSpan" id="kobo.272.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.273.1">public</span></span><span class="koboSpan" id="kobo.274.1"> required </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.275.1">string</span></span><span class="koboSpan" id="kobo.276.1"> Name { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.277.1">get</span></span><span class="koboSpan" id="kobo.278.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.279.1">set</span></span><span class="koboSpan" id="kobo.280.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.281.1">public</span></span><span class="koboSpan" id="kobo.282.1"> required </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.283.1">string</span></span><span class="koboSpan" id="kobo.284.1"> Country { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.285.1">get</span></span><span class="koboSpan" id="kobo.286.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.287.1">set</span></span><span class="koboSpan" id="kobo.288.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.289.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.290.1">string</span></span><span class="koboSpan" id="kobo.291.1">? </span><span class="koboSpan" id="kobo.291.2">Description { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.292.1">get</span></span><span class="koboSpan" id="kobo.293.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.294.1">set</span></span><span class="koboSpan" id="kobo.295.1">; }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.296.1">In the code above, all the DB fields must be represented by read/write C# properties. </span><span class="koboSpan" id="kobo.296.2">Since both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">Name</span></code><span class="koboSpan" id="kobo.298.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">Country</span></code><span class="koboSpan" id="kobo.300.1"> properties are obligatory but we are not going to define a constructor, we added the </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">required</span></code><span class="koboSpan" id="kobo.302.1"> keyword to instruct the compiler to signal an error whenever an instance is created without initializing them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.303.1">Suppose that each destination is something like a town or a region that can be defined by just its name and the country it is in and that all the relevant information is contained in its </span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">Description</span></code><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">In future iterations, we will probably add several more fields. </span><code class="inlineCode"><span class="koboSpan" id="kobo.306.1">Id</span></code><span class="koboSpan" id="kobo.307.1"> is an auto-generated key.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.308.1">However, now, we</span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.309.1"> need to add information about how all the fields are mapped to DB fields. </span><span class="koboSpan" id="kobo.309.2">In Entity Framework Core, all the primitive types are mapped automatically to DB types by the DB engine-specific provider that’s used (in our case, the SQL Server provider).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.310.1">Our only preoccupations are as follows:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.311.1">Length limits on the string</span></strong><span class="koboSpan" id="kobo.312.1">: They can be taken into account by applying adequate </span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">MaxLength</span></code><span class="koboSpan" id="kobo.314.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">MinLength</span></code><span class="koboSpan" id="kobo.316.1"> attributes to each string property. </span><span class="koboSpan" id="kobo.316.2">All the attributes that are useful for the entity’s configuration are contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">System.ComponentModel.DataAnnotations</span></code><span class="koboSpan" id="kobo.318.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.319.1">System.ComponentModel.DataAnnotations.Schema</span></code><span class="koboSpan" id="kobo.320.1"> namespaces. </span><span class="koboSpan" id="kobo.320.2">Therefore, it’s good practice to add both of them to all the entity definitions.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.321.1">Specifying which fields are obligatory and which ones are optional</span></strong><span class="koboSpan" id="kobo.322.1">: If the project is not using the new </span><strong class="keyWord"><span class="koboSpan" id="kobo.323.1">Nullable Reference Type</span></strong><span class="koboSpan" id="kobo.324.1"> feature, by default, all the reference types (such as all the strings) are assumed to be optional, while all the value types (numbers and GUIDs, for instance) are assumed to be obligatory. </span><span class="koboSpan" id="kobo.324.2">If we want a reference type to be obligatory, then we must decorate it with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">Required</span></code><span class="koboSpan" id="kobo.326.1"> attribute. </span><span class="koboSpan" id="kobo.326.2">On the other hand, if we want a </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">T</span></code><span class="koboSpan" id="kobo.328.1"> type property to be optional, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">T</span></code><span class="koboSpan" id="kobo.330.1"> is a value type, or the Nullable Reference Type feature is on, then we must replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">T</span></code><span class="koboSpan" id="kobo.332.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">T?</span></code><span class="koboSpan" id="kobo.334.1">. </span><span class="koboSpan" id="kobo.334.2">As a default, .NET 8 projects have the new Nullable Reference Type feature set.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.335.1">Specifying which property represents the primary key</span></strong><span class="koboSpan" id="kobo.336.1">: The key may be specified by decorating a property with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.337.1">Key</span></code><span class="koboSpan" id="kobo.338.1"> attribute. </span><span class="koboSpan" id="kobo.338.2">However, if no </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">Key</span></code><span class="koboSpan" id="kobo.340.1"> attribute is found, a property named </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">Id</span></code><span class="koboSpan" id="kobo.342.1"> (if there is one) is taken as the primary key. </span><span class="koboSpan" id="kobo.342.2">In our case, there is no need for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">Key</span></code><span class="koboSpan" id="kobo.344.1"> attribute.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.345.1">Since each destination is on </span><em class="italic"><span class="koboSpan" id="kobo.346.1">one</span></em><span class="koboSpan" id="kobo.347.1"> side of a one-to-many relationship, it must contain a collection of the related package entities; otherwise, it will be difficult to refer to the related entities in the clauses of our LINQ queries. </span><span class="koboSpan" id="kobo.347.2">This collection will have a fundamental role in our LINQ queries and will be populated by Entity Framework Core. </span><span class="koboSpan" id="kobo.347.3">However, as we will see later in this chapter, it must be ignored in most of the database update operations. </span><span class="koboSpan" id="kobo.347.4">Therefore, the best option to avoid compiler warnings is to assign them the null-forgiving fake default value: </span><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">null!</span></code><span class="koboSpan" id="kobo.349.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.350.1">Putting everything together, the final version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">Destination</span></code><span class="koboSpan" id="kobo.352.1"> class is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.353.1">using</span></span><span class="koboSpan" id="kobo.354.1"> System.Collections.Generic;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.355.1">using</span></span><span class="koboSpan" id="kobo.356.1"> System.ComponentModel.DataAnnotations;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.357.1">using</span></span><span class="koboSpan" id="kobo.358.1"> System.ComponentModel.DataAnnotations.Schema;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.359.1">namespace</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.360.1">WWTravelClubDB.Models</span></span><span class="koboSpan" id="kobo.361.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.362.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.363.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.364.1">Destination</span></span><span class="koboSpan" id="kobo.365.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.366.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.367.1">int</span></span><span class="koboSpan" id="kobo.368.1"> Id { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.369.1">get</span></span><span class="koboSpan" id="kobo.370.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.371.1">set</span></span><span class="koboSpan" id="kobo.372.1">; }
        [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.373.1">MaxLength(128)</span></span><span class="koboSpan" id="kobo.374.1">]
        Public required </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.375.1">string</span></span><span class="koboSpan" id="kobo.376.1"> Name { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.377.1">get</span></span><span class="koboSpan" id="kobo.378.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.379.1">set</span></span><span class="koboSpan" id="kobo.380.1">; }
        [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.381.1">MaxLength(128)</span></span><span class="koboSpan" id="kobo.382.1">]
        Public required </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.383.1">string</span></span><span class="koboSpan" id="kobo.384.1"> Country { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.385.1">get</span></span><span class="koboSpan" id="kobo.386.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.387.1">set</span></span><span class="koboSpan" id="kobo.388.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.389.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.390.1">string</span></span><span class="koboSpan" id="kobo.391.1">? </span><span class="koboSpan" id="kobo.391.2">Description { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.392.1">get</span></span><span class="koboSpan" id="kobo.393.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.394.1">set</span></span><span class="koboSpan" id="kobo.395.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.396.1">public</span></span><span class="koboSpan" id="kobo.397.1"> ICollection&lt;Package&gt; Packages { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.398.1">get</span></span><span class="koboSpan" id="kobo.399.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.400.1">set</span></span><span class="koboSpan" id="kobo.401.1">; } = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.402.1">null</span></span><span class="koboSpan" id="kobo.403.1">!
    </span><span class="koboSpan" id="kobo.403.2">}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.404.1">Since</span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.405.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.406.1">Description</span></code><span class="koboSpan" id="kobo.407.1"> property has no length limits, it will be implemented with a SQL Server </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">nvarchar(MAX)</span></code><span class="koboSpan" id="kobo.409.1"> field of indefinite length. </span><span class="koboSpan" id="kobo.409.2">We can write the code for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">Package</span></code><span class="koboSpan" id="kobo.411.1"> class in a similar way:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.412.1">using</span></span><span class="koboSpan" id="kobo.413.1"> System;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.414.1">using</span></span><span class="koboSpan" id="kobo.415.1"> System.ComponentModel.DataAnnotations;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.416.1">using</span></span><span class="koboSpan" id="kobo.417.1"> System.ComponentModel.DataAnnotations.Schema;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.418.1">namespace</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.419.1">WWTravelClubDB.Models</span></span><span class="koboSpan" id="kobo.420.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.421.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.422.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.423.1">Package</span></span><span class="koboSpan" id="kobo.424.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.425.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.426.1">int</span></span><span class="koboSpan" id="kobo.427.1"> Id { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.428.1">get</span></span><span class="koboSpan" id="kobo.429.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.430.1">set</span></span><span class="koboSpan" id="kobo.431.1">; }
        [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.432.1">MaxLength(128)</span></span><span class="koboSpan" id="kobo.433.1">]
        Public required </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.434.1">string</span></span><span class="koboSpan" id="kobo.435.1"> Name { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.436.1">get</span></span><span class="koboSpan" id="kobo.437.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.438.1">set</span></span><span class="koboSpan" id="kobo.439.1">; }
        [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.440.1">MaxLength(128)</span></span><span class="koboSpan" id="kobo.441.1">]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.442.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.443.1">string</span></span><span class="koboSpan" id="kobo.444.1">? </span><span class="koboSpan" id="kobo.444.2">Description { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.445.1">get</span></span><span class="koboSpan" id="kobo.446.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.447.1">set</span></span><span class="koboSpan" id="kobo.448.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.449.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.450.1">decimal</span></span><span class="koboSpan" id="kobo.451.1"> Price { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.452.1">get</span></span><span class="koboSpan" id="kobo.453.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.454.1">set</span></span><span class="koboSpan" id="kobo.455.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.456.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.457.1">int</span></span><span class="koboSpan" id="kobo.458.1"> DurationInDays { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.459.1">get</span></span><span class="koboSpan" id="kobo.460.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.461.1">set</span></span><span class="koboSpan" id="kobo.462.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.463.1">public</span></span><span class="koboSpan" id="kobo.464.1"> DateTime? </span><span class="koboSpan" id="kobo.464.2">StartValidityDate { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.465.1">get</span></span><span class="koboSpan" id="kobo.466.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.467.1">set</span></span><span class="koboSpan" id="kobo.468.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.469.1">public</span></span><span class="koboSpan" id="kobo.470.1"> DateTime? </span><span class="koboSpan" id="kobo.470.2">EndValidityDate { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.471.1">get</span></span><span class="koboSpan" id="kobo.472.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.473.1">set</span></span><span class="koboSpan" id="kobo.474.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">public</span></span><span class="koboSpan" id="kobo.476.1"> Destination MyDestination { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.477.1">get</span></span><span class="koboSpan" id="kobo.478.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.479.1">set</span></span><span class="koboSpan" id="kobo.480.1">; } = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.481.1">null</span></span><span class="koboSpan" id="kobo.482.1">!
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.483.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.484.1">int</span></span><span class="koboSpan" id="kobo.485.1"> DestinationId { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.486.1">get</span></span><span class="koboSpan" id="kobo.487.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.488.1">set</span></span><span class="koboSpan" id="kobo.489.1">; }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.490.1">Each package has a duration in days, as well as optional start and stop dates in which the package offer is valid. </span><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">MyDestination</span></code><span class="koboSpan" id="kobo.492.1"> connects packages with their destinations in the many-to-one relationship that they have with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.493.1">Destination</span></code><span class="koboSpan" id="kobo.494.1"> entity, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">DestinationId</span></code><span class="koboSpan" id="kobo.496.1"> is the external key of the same relation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.497.1">While it is </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.498.1">not obligatory to specify the external key, it is good practice to do so since this is the only way to specify some properties of the relationship. </span><span class="koboSpan" id="kobo.498.2">For instance, in our case, since </span><code class="inlineCode"><span class="koboSpan" id="kobo.499.1">DestinationId</span></code><span class="koboSpan" id="kobo.500.1"> is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.501.1">int</span></code><span class="koboSpan" id="kobo.502.1"> (not nullable type), it is obligatory. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.503.1">Therefore, the relationship here is one-to-many and not (0, 1)-to-many. </span><span class="koboSpan" id="kobo.503.2">Defining </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">DestinationId</span></code><span class="koboSpan" id="kobo.505.1"> as </span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">int?</span></code><span class="koboSpan" id="kobo.507.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">int</span></code><span class="koboSpan" id="kobo.509.1"> would turn the one-to-many relationship into a (0, 1)-to-many relationship. </span><span class="koboSpan" id="kobo.509.2">Moreover, as we will see later in this chapter, having an explicit representation of the foreign key simplifies the update operations a lot, and some queries.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.510.1">In the next section, we will explain how to define the in-memory collection that represents the database tables.</span></p>
<h2 class="heading-2" id="_idParaDest-270"><span class="koboSpan" id="kobo.511.1">Defining the mapped collections</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.512.1">Once we have</span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.513.1"> defined all the entities that are object-oriented representations of the database rows, we need to define the in-memory collections that represent the database tables themselves. </span><span class="koboSpan" id="kobo.513.2">As we mentioned in the </span><em class="italic"><span class="koboSpan" id="kobo.514.1">Understanding ORM basics </span></em><span class="koboSpan" id="kobo.515.1">section, all the database operations are mapped to the operations on these collections (the </span><em class="italic"><span class="koboSpan" id="kobo.516.1">Querying and updating data with Entity Framework Core</span></em><span class="koboSpan" id="kobo.517.1"> section of this chapter explains how). </span><span class="koboSpan" id="kobo.517.2">It is enough to add a </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">DbSet&lt;T&gt;</span></code><span class="koboSpan" id="kobo.519.1"> collection property to our </span><code class="inlineCode"><span class="koboSpan" id="kobo.520.1">DbContext</span></code><span class="koboSpan" id="kobo.521.1"> for each entity, </span><code class="inlineCode"><span class="koboSpan" id="kobo.522.1">T</span></code><span class="koboSpan" id="kobo.523.1">. </span><span class="koboSpan" id="kobo.523.2">Usually, the name of each of these properties is obtained by pluralizing the entity name. </span><span class="koboSpan" id="kobo.523.3">Thus, we need to add the following two properties to our </span><code class="inlineCode"><span class="koboSpan" id="kobo.524.1">MainDbContext</span></code><span class="koboSpan" id="kobo.525.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.526.1">public</span></span><span class="koboSpan" id="kobo.527.1"> DbSet&lt;Package&gt; Packages { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.528.1">get</span></span><span class="koboSpan" id="kobo.529.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.530.1">set</span></span><span class="koboSpan" id="kobo.531.1">; }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.532.1">public</span></span><span class="koboSpan" id="kobo.533.1"> DbSet&lt;Destination&gt; Destinations { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.534.1">get</span></span><span class="koboSpan" id="kobo.535.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.536.1">set</span></span><span class="koboSpan" id="kobo.537.1">; }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.538.1">Up until now, we’ve translated database stuff into properties, classes, and data annotations. </span><span class="koboSpan" id="kobo.538.2">However, Entity Framework needs further information to interact with a database. </span><span class="koboSpan" id="kobo.538.3">The next subsection explains how to provide it.</span></p>
<h2 class="heading-2" id="_idParaDest-271"><span class="koboSpan" id="kobo.539.1">Completing the mapping configuration</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.540.1">The mapping configuration</span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.541.1"> information that we couldn’t specify in the entity definitions must be added with configuration code based on a fluent interface. </span><span class="koboSpan" id="kobo.541.2">The simplest way to add this configuration information is to add it using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.542.1">OnModelCreating DbContext</span></code><span class="koboSpan" id="kobo.543.1"> method. </span><span class="koboSpan" id="kobo.543.2">Each piece of configuration information relative to an entity, </span><code class="inlineCode"><span class="koboSpan" id="kobo.544.1">T</span></code><span class="koboSpan" id="kobo.545.1">, starts with </span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">builder.Entity&lt;T&gt;()</span></code><span class="koboSpan" id="kobo.547.1"> and continues with a call to a method that specifies that kind of constraint. </span><span class="koboSpan" id="kobo.547.2">Further nested calls specify further properties of the constraint. </span><span class="koboSpan" id="kobo.547.3">For instance, our one-to-many relationship may be configured as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.548.1">builder.Entity&lt;Destination&gt;()
    .HasMany(m =&gt; m.Packages)
    .WithOne(m =&gt; m.MyDestination)
    .HasForeignKey(m =&gt; m.DestinationId)
    .OnDelete(DeleteBehavior.Cascade);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.549.1">The two sides </span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.550.1">of the relationship are specified through the navigation properties that we added to our entities. </span><code class="inlineCode"><span class="koboSpan" id="kobo.551.1">HasForeignKey</span></code><span class="koboSpan" id="kobo.552.1"> specifies the external key. </span><span class="koboSpan" id="kobo.552.2">Finally, </span><code class="inlineCode"><span class="koboSpan" id="kobo.553.1">OnDelete</span></code><span class="koboSpan" id="kobo.554.1"> specifies what to do with packages when a destination is deleted. </span><span class="koboSpan" id="kobo.554.2">In our case, it performs a cascade delete of all the packages related to that destination.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.555.1">The same configuration can be defined by starting from the other side of the relationship, that is, starting with </span><code class="inlineCode"><span class="koboSpan" id="kobo.556.1">builder.Entity&lt;Package&gt;()</span></code><span class="koboSpan" id="kobo.557.1">. </span><span class="koboSpan" id="kobo.557.2">Clearly, the developer must choose just one of the options:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.558.1">builder.Entity&lt;Package&gt;()
    .HasOne(m =&gt; m.MyDestination)
    .WithMany(m =&gt; m.Packages)
    .HasForeignKey(m =&gt; m.DestinationId)
    .OnDelete(DeleteBehavior.Cascade);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.559.1">The only difference is that the previous statement’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.560.1">HasMany-WithOne</span></code><span class="koboSpan" id="kobo.561.1"> methods are replaced by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">HasOne-WithMany</span></code><span class="koboSpan" id="kobo.563.1"> methods since we started from the other side of the relationship. </span><span class="koboSpan" id="kobo.563.2">Here, we can also choose the precision with which each decimal property is represented in its mapped database field. </span><span class="koboSpan" id="kobo.563.3">As a default, decimals are represented by 18 digits and 2 decimals. </span><span class="koboSpan" id="kobo.563.4">You can change this setting for each property with something like:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.564.1">...
</span><span class="koboSpan" id="kobo.564.2">.Property(m =&gt; m.Price)
        .HasPrecision(</span><span class="hljs-number"><span class="koboSpan" id="kobo.565.1">10</span></span><span class="koboSpan" id="kobo.566.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.567.1">3</span></span><span class="koboSpan" id="kobo.568.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.569.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.570.1">ModelBuilder builder</span></code><span class="koboSpan" id="kobo.571.1"> object allows us to specify database indexes with something such as the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.572.1">builder.Entity&lt;T&gt;()
   .HasIndex(m =&gt; m.PropertyName);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.573.1">Multi-property indexes are defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.574.1">builder.Entity&lt;T&gt;()
    .HasIndex(</span><span class="hljs-string"><span class="koboSpan" id="kobo.575.1">"propertyName1"</span></span><span class="koboSpan" id="kobo.576.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.577.1">"propertyName2"</span></span><span class="koboSpan" id="kobo.578.1">, ...);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.579.1">Starting from </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.580.1">version 5, indexes can also be defined with attributes applied to the class. </span><span class="koboSpan" id="kobo.580.2">The following is the case of a single property index:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.581.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.582.1">Index(nameof(Property), IsUnique = true)</span></span><span class="koboSpan" id="kobo.583.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.584.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.585.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.586.1">MyClass</span></span><span class="koboSpan" id="kobo.587.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.588.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.589.1">int</span></span><span class="koboSpan" id="kobo.590.1"> Id { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.591.1">get</span></span><span class="koboSpan" id="kobo.592.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.593.1">set</span></span><span class="koboSpan" id="kobo.594.1">; }
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.595.1">MaxLength(128)</span></span><span class="koboSpan" id="kobo.596.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.597.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.598.1">string</span></span><span class="koboSpan" id="kobo.599.1"> Property { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">get</span></span><span class="koboSpan" id="kobo.601.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.602.1">set</span></span><span class="koboSpan" id="kobo.603.1">; }
}
   
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.604.1">The following is the case of a multi-property index:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.605.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.606.1">Index(nameof(Property1), nameof(Property2), IsUnique = false)</span></span><span class="koboSpan" id="kobo.607.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.608.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.609.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.610.1">MyComplexIndexClass</span></span><span class="koboSpan" id="kobo.611.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.612.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.613.1">int</span></span><span class="koboSpan" id="kobo.614.1"> Id { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.615.1">get</span></span><span class="koboSpan" id="kobo.616.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.617.1">set</span></span><span class="koboSpan" id="kobo.618.1">; }
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.619.1">MaxLength(64)</span></span><span class="koboSpan" id="kobo.620.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.621.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.622.1">string</span></span><span class="koboSpan" id="kobo.623.1"> Property1 { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.624.1">get</span></span><span class="koboSpan" id="kobo.625.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.626.1">set</span></span><span class="koboSpan" id="kobo.627.1">; }
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.628.1">MaxLength(64)</span></span><span class="koboSpan" id="kobo.629.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.630.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.631.1">string</span></span><span class="koboSpan" id="kobo.632.1"> Property2 { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.633.1">get</span></span><span class="koboSpan" id="kobo.634.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.635.1">set</span></span><span class="koboSpan" id="kobo.636.1">; }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.637.1">Configuration options that are specific to an entity can also be grouped into separate configuration classes, one for each entity:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.638.1">internal</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.639.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.640.1">DestinationConfiguration</span></span><span class="koboSpan" id="kobo.641.1"> :
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.642.1">IEntityTypeConfiguration</span></span><span class="koboSpan" id="kobo.643.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.644.1">Destination</span></span><span class="koboSpan" id="kobo.645.1">&gt;
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.646.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.647.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.648.1">Configure</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.649.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.650.1">EntityTypeBuilder&lt;Destination&gt; builder</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.651.1">)</span></span><span class="koboSpan" id="kobo.652.1">
    {
        builder
            .HasIndex(m =&gt; m.Country);
        builder
            .HasIndex(m =&gt; m.Name);
       ...
    </span><span class="koboSpan" id="kobo.652.2">}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.653.1">Each of</span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.654.1"> these classes must implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.655.1">IEntityTypeConfiguration&lt;&gt;</span></code><span class="koboSpan" id="kobo.656.1"> interface, whose unique method is </span><code class="inlineCode"><span class="koboSpan" id="kobo.657.1">Configure</span></code><span class="koboSpan" id="kobo.658.1">. </span><span class="koboSpan" id="kobo.658.2">Then, the configuration class can be declared with a class-level attribute:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.659.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.660.1">EntityTypeConfiguration(typeof(DestinationConfiguration))</span></span><span class="koboSpan" id="kobo.661.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.662.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.663.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.664.1">Destination</span></span><span class="koboSpan" id="kobo.665.1">
{
  ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.666.1">The configuration class can also be recalled from within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.667.1">OnModelCreating</span></code><span class="koboSpan" id="kobo.668.1"> method of the context class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.669.1">new</span></span><span class="koboSpan" id="kobo.670.1"> DestinationConfiguration()
         .Configure(builder.Entity&lt;Destination&gt;());
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.671.1">It is also possible to add all configuration information defined in the assembly with:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.672.1">builder.ApplyConfigurationsFromAssembly(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.673.1">typeof</span></span><span class="koboSpan" id="kobo.674.1">(MainDbContext).Assembly);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.675.1">If we add all the necessary configuration information, then our </span><code class="inlineCode"><span class="koboSpan" id="kobo.676.1">OnModelCreating</span></code><span class="koboSpan" id="kobo.677.1"> method will look as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.678.1">protected</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.679.1">override</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.680.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.681.1">OnModelCreating</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.682.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.683.1">ModelBuilder builder</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.684.1">)</span></span><span class="koboSpan" id="kobo.685.1">
{
    builder.Entity&lt;Destination&gt;()
        .HasMany(m =&gt; m.Packages)
        .WithOne(m =&gt; m.MyDestination)
        .HasForeignKey(m =&gt; m.DestinationId)
        .OnDelete(DeleteBehavior.Cascade);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.686.1">new</span></span><span class="koboSpan" id="kobo.687.1"> DestinationConfiguration()
                .Configure(builder.Entity&lt;Destination&gt;());
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.688.1">new</span></span><span class="koboSpan" id="kobo.689.1"> PackageConfiguration()
                .Configure(builder.Entity&lt;Package&gt;());
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.690.1">Together with the two configuration classes:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.691.1">using</span></span><span class="koboSpan" id="kobo.692.1"> Microsoft.EntityFrameworkCore;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.693.1">using</span></span><span class="koboSpan" id="kobo.694.1"> Microsoft.EntityFrameworkCore.Metadata.Builders;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.695.1">namespace</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.696.1">WWTravelClubDB.Models</span></span><span class="koboSpan" id="kobo.697.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.698.1">internal</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.699.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.700.1">DestinationConfiguration</span></span><span class="koboSpan" id="kobo.701.1"> :
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.702.1">IEntityTypeConfiguration</span></span><span class="koboSpan" id="kobo.703.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.704.1">Destination</span></span><span class="koboSpan" id="kobo.705.1">&gt;
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.706.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.707.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.708.1">Configure</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.709.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.710.1">EntityTypeBuilder&lt;Destination&gt; builder</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.711.1">)</span></span><span class="koboSpan" id="kobo.712.1">
        {
            builder
               .HasIndex(m =&gt; m.Country);
            builder
                .HasIndex(m =&gt; m.Name);
        }
    }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.713.1">using</span></span><span class="koboSpan" id="kobo.714.1"> Microsoft.EntityFrameworkCore;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.715.1">using</span></span><span class="koboSpan" id="kobo.716.1"> Microsoft.EntityFrameworkCore.Metadata.Builders;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.717.1">namespace</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.718.1">WWTravelClubDB.Models</span></span><span class="koboSpan" id="kobo.719.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.720.1">internal</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.721.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.722.1">PackageConfiguration</span></span><span class="koboSpan" id="kobo.723.1"> : </span><span class="hljs-title"><span class="koboSpan" id="kobo.724.1">IEntityTypeConfiguration</span></span><span class="koboSpan" id="kobo.725.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.726.1">Package</span></span><span class="koboSpan" id="kobo.727.1">&gt;
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.728.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.729.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.730.1">Configure</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.731.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.732.1">EntityTypeBuilder&lt;Package&gt; builder</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.733.1">)</span></span><span class="koboSpan" id="kobo.734.1">
        {
            builder
                .HasIndex(m =&gt; m.Name);
            builder
                .HasIndex(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.735.1">nameof</span></span><span class="koboSpan" id="kobo.736.1">(Package.StartValidityDate),
                 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.737.1">nameof</span></span><span class="koboSpan" id="kobo.738.1">(Package.EndValidityDate));
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.739.1">I prefer to </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.740.1">define just general configuration and relationships in the context class. </span><span class="koboSpan" id="kobo.740.2">It is also convenient to use data annotation just for restricting property values (maximum and minimum length, required fields, and so on). </span><span class="koboSpan" id="kobo.740.3">This way, entities don’t depend on the specific ORM used and can be exported outside of the data layer, if needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.741.1">The best place for other entity-specific configurations is the configuration class. </span><span class="koboSpan" id="kobo.741.2">I also avoid using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">EntityTypeConfiguration</span></code><span class="koboSpan" id="kobo.743.1"> attribute and call entity configuration classes from within the context class since this attribute ties the entity to a specific ORM.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.744.1">The previous example shows a one-to-many relationship, but Entity Framework Core 8 also supports many-to-many relationship:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.745.1">modelBuilder
  .Entity&lt;Teacher&gt;()
  .HasMany(e =&gt; e.Classrooms)
  .WithMany(e =&gt; e.Teachers)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.746.1">In the </span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.747.1">preceding case, the join entity and the database join table are created automatically, but you can also specify an existing entity as the join entity. </span><span class="koboSpan" id="kobo.747.2">In the previous example, the join entity might be the course that the teacher teaches in each classroom:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.748.1">modelBuilder
  .Entity&lt;Teacher&gt;()
  .HasMany(e =&gt; e.Classrooms)
  .WithMany(e =&gt; e.Teachers)
      .UsingEntity&lt;Course&gt;(
           b =&gt; b.HasOne(e =&gt; e.Teacher).WithMany()
           .HasForeignKey(e =&gt; e.TeacherId),
           b =&gt; b.HasOne(e =&gt; e.Classroom).WithMany()
           .HasForeignKey(e =&gt; e.ClassroomId));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.749.1">Once you’ve configured Entity Framework Core, we can use all the configuration information we have to create the actual database and put all the tools we need in place in order to update the database’s structure as the application evolves. </span><span class="koboSpan" id="kobo.749.2">The next section explains how.</span></p>
<h1 class="heading-1" id="_idParaDest-272"><span class="koboSpan" id="kobo.750.1">Entity Framework Core migrations</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.751.1">Now that we’ve configured </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.752.1">Entity Framework and defined our application-specific </span><code class="inlineCode"><span class="koboSpan" id="kobo.753.1">DbContext</span></code><span class="koboSpan" id="kobo.754.1"> subclass, we can use the Entity Framework Core design tools to generate the physical database and create the database structure snapshot that’s needed by Entity Framework Core to interact with the database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.755.1">Entity Framework Core design tools must be installed in each project that needs them as NuGet packages. </span><span class="koboSpan" id="kobo.755.2">There are two equivalent options:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.756.1">Tools that work in any operating system console</span></strong><span class="koboSpan" id="kobo.757.1">: These are available through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.758.1">Microsoft.EntityFrameworkCore.Design</span></code><span class="koboSpan" id="kobo.759.1"> NuGet package. </span><span class="koboSpan" id="kobo.759.2">All Entity Framework Core commands are in </span><code class="inlineCode"><span class="koboSpan" id="kobo.760.1">dotnet ef .....</span></code><span class="koboSpan" id="kobo.761.1"> format since they are contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">ef</span></code><span class="koboSpan" id="kobo.763.1"> command line’s .NET Core application.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.764.1">Tools that are specific to the Visual Studio Package Manager Console</span></strong><span class="koboSpan" id="kobo.765.1">: These are contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">Microsoft.EntityFrameworkCore.Tools</span></code><span class="koboSpan" id="kobo.767.1"> NuGet package. </span><span class="koboSpan" id="kobo.767.2">They don’t need the </span><code class="inlineCode"><span class="koboSpan" id="kobo.768.1">dotnet ef</span></code><span class="koboSpan" id="kobo.769.1"> prefix since they can only be launched from</span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.770.1"> the </span><strong class="keyWord"><span class="koboSpan" id="kobo.771.1">Package Manager Console</span></strong><span class="koboSpan" id="kobo.772.1"> inside Visual Studio.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.773.1">Entity Framework Core’s </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.774.1">design tools are used within the design/update procedure. </span><span class="koboSpan" id="kobo.774.2">This procedure is as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.775.1">We modify </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">DbContext</span></code><span class="koboSpan" id="kobo.777.1"> and the entities’ definitions as needed.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.778.1">We launch the design tools to ask Entity Framework Core to detect and process all the changes we made.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.779.1">Once launched, the design tools update the database structure snapshot and generate a new </span><em class="italic"><span class="koboSpan" id="kobo.780.1">migration</span></em><span class="koboSpan" id="kobo.781.1">, that is, a file containing all the instructions we need in order to modify the physical database to reflect all the changes we made.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.782.1">We launch another tool to update the database with the newly created migration.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.783.1">We test the newly configured DB layer, and if new changes are necessary, we go back to </span><em class="italic"><span class="koboSpan" id="kobo.784.1">step 1</span></em><span class="koboSpan" id="kobo.785.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.786.1">When the data layer is ready, it is deployed in staging or production, where all the migrations are applied once more to the actual staging/production database.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.787.1">This is repeated several times in the various software project iterations and during the lifetime of the application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.788.1">If we operate on an already existing database, we need to configure </span><code class="inlineCode"><span class="koboSpan" id="kobo.789.1">DbContext</span></code><span class="koboSpan" id="kobo.790.1"> and its models to reflect the existing structure of all the tables we want to map. </span><span class="koboSpan" id="kobo.790.2">This can be done automatically with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.791.1">Scaffold-DbContext</span></code><span class="koboSpan" id="kobo.792.1"> command (see </span><a href="https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/?tabs=vs"><span class="url"><span class="koboSpan" id="kobo.793.1">https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/?tabs=vs</span></span></a><span class="koboSpan" id="kobo.794.1"> for more details).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.795.1">All classes generated by .NET are partial classes, so the user can enrich them with further methods without modifying the scaffolded classes by adding the new methods to partial classes with the same names.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.796.1">Then, if we want to start using migration instead of continuing with direct database changes, we can call the design tools with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.797.1">IgnoreChanges</span></code><span class="koboSpan" id="kobo.798.1"> option so that they generate an empty migration. </span><span class="koboSpan" id="kobo.798.2">Also, this empty migration must be passed to the physical database so that it can synchronize a database structure version associated with the physical database with the version that’s been recorded in the database snapshot. </span><span class="koboSpan" id="kobo.798.3">This version is important because it determines which migrations must be applied to a database and which ones have already been applied.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.799.1">However, developers may also choose to continue manually modifying the database and repeating the scaffold operation after each change.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.800.1">The whole design process needs a test/design database, and if we operate on an existing database, the structure of this test/design database must reflect the actual database – at least in terms of the tables we want to map. </span><span class="koboSpan" id="kobo.800.2">To enable design tools so that we can interact </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.801.1">with the database, we must define the </span><code class="inlineCode"><span class="koboSpan" id="kobo.802.1">DbContextOptions</span></code><span class="koboSpan" id="kobo.803.1"> options that they pass to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.804.1">DbContext</span></code><span class="koboSpan" id="kobo.805.1"> constructor. </span><span class="koboSpan" id="kobo.805.2">These options are important at design time since they contain the connection string of the test/design database. </span><span class="koboSpan" id="kobo.805.3">The design tools can be informed about our </span><code class="inlineCode"><span class="koboSpan" id="kobo.806.1">DbContextOptions</span></code><span class="koboSpan" id="kobo.807.1"> options if we create a class that implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.808.1">IDesignTimeDbContextFactory&lt;T&gt;</span></code><span class="koboSpan" id="kobo.809.1"> interface, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.810.1">T</span></code><span class="koboSpan" id="kobo.811.1"> is our </span><code class="inlineCode"><span class="koboSpan" id="kobo.812.1">DbContext</span></code><span class="koboSpan" id="kobo.813.1"> subclass:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.814.1">using</span></span><span class="koboSpan" id="kobo.815.1"> Microsoft.EntityFrameworkCore;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.816.1">using</span></span><span class="koboSpan" id="kobo.817.1"> Microsoft.EntityFrameworkCore.Design;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.818.1">namespace</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.819.1">WWTravelClubDB</span></span><span class="koboSpan" id="kobo.820.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.821.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.822.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.823.1">LibraryDesignTimeDbContextFactory</span></span><span class="koboSpan" id="kobo.824.1">
        : </span><span class="hljs-title"><span class="koboSpan" id="kobo.825.1">IDesignTimeDbContextFactory</span></span><span class="koboSpan" id="kobo.826.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.827.1">MainDbContext</span></span><span class="koboSpan" id="kobo.828.1">&gt;
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.829.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.830.1">const</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.831.1">string</span></span><span class="koboSpan" id="kobo.832.1"> connectionString =
            </span><span class="hljs-string"><span class="koboSpan" id="kobo.833.1">@"Server=(localdb)\mssqllocaldb;Database=wwtravelclub;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.834.1">                Trusted_Connection=True;MultipleActiveResultSets=true"</span></span><span class="koboSpan" id="kobo.835.1">;
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.836.1">public</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.837.1"> MainDbContext </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.838.1">CreateDbContext</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.839.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.840.1">params</span></span><span class="hljs-params"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.841.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.842.1">[] args</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.843.1">)</span></span><span class="koboSpan" id="kobo.844.1">
        {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.845.1">var</span></span><span class="koboSpan" id="kobo.846.1"> builder = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.847.1">new</span></span><span class="koboSpan" id="kobo.848.1"> DbContextOptionsBuilder&lt;MainDbContext&gt;();
           
            builder.UseSqlServer(connectionString);
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.849.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.850.1">new</span></span><span class="koboSpan" id="kobo.851.1"> MainDbContext(builder.Options);
        }
    }
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.852.1">connectionString</span></code><span class="koboSpan" id="kobo.853.1"> will be used by Entity Framework to create a new database in the local SQL Server instance that’s been installed in the development machine and connects with Windows credentials. </span><span class="koboSpan" id="kobo.853.2">You are free to change it to reflect your needs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.854.1">Now, we are ready to create our first migration! </span><span class="koboSpan" id="kobo.854.2">Let’s get started:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.855.1">Let’s go to the </span><strong class="screenText"><span class="koboSpan" id="kobo.856.1">Package Manager Console</span></strong><span class="koboSpan" id="kobo.857.1"> and ensure that </span><strong class="screenText"><span class="koboSpan" id="kobo.858.1">WWTravelClubDB</span></strong><span class="koboSpan" id="kobo.859.1"> is selected as our default project.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.860.1">Now, type </span><code class="inlineCode"><span class="koboSpan" id="kobo.861.1">Add-Migration initial</span></code><span class="koboSpan" id="kobo.862.1"> and press </span><em class="italic"><span class="koboSpan" id="kobo.863.1">Enter</span></em><span class="koboSpan" id="kobo.864.1"> to issue this command. </span><span class="koboSpan" id="kobo.864.2">Verify </span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.865.1">that you added the </span><code class="inlineCode"><span class="koboSpan" id="kobo.866.1">Microsoft.EntityFrameworkCore.Tools</span></code><span class="koboSpan" id="kobo.867.1"> NuGet package before issuing this command; otherwise, you might get an “unrecognized command” error:
    </span><figure class="mediaobject"><span class="koboSpan" id="kobo.868.1"><img alt="Graphical user interface, text, application  Description automatically generated" src="../Images/B19820_13_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.869.1">Figure 13.1: Adding the first migration</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.870.1">initial</span></code><span class="koboSpan" id="kobo.871.1"> is the name we gave our first migration. </span><span class="koboSpan" id="kobo.871.2">So, in general, the command is </span><code class="inlineCode"><span class="koboSpan" id="kobo.872.1">Add-Migration &lt;migration name&gt;</span></code><span class="koboSpan" id="kobo.873.1">. </span><span class="koboSpan" id="kobo.873.2">When we operate on an existing database, we must add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.874.1">-IgnoreChanges</span></code><span class="koboSpan" id="kobo.875.1"> option to the first migration (and just to that) so that an empty migration is created. </span><span class="koboSpan" id="kobo.875.2">References to the whole set of commands can be found in the </span><em class="italic"><span class="koboSpan" id="kobo.876.1">Further reading</span></em><span class="koboSpan" id="kobo.877.1"> section.</span></p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.878.1">If, after having created the migration but before having applied the migration to the database, we realize we made some errors, we can undo our action with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.879.1">Remove-Migration</span></code><span class="koboSpan" id="kobo.880.1"> command. </span><span class="koboSpan" id="kobo.880.2">If the migration has already been applied to the database, the simplest way to correct our error is to make all the necessary changes to the code and then apply another migration.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.881.1">As soon as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.882.1">Add-Migration</span></code><span class="koboSpan" id="kobo.883.1"> command is executed, a new folder appears in our project:</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.884.1"><img alt="" role="presentation" src="../Images/B19820_13_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.885.1">Figure 13.2: Files created by the Add-Migration command</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.886.1">20210924143018_initial.cs</span></code><span class="koboSpan" id="kobo.887.1"> is our migration expressed in an easy-to-understand language.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.888.1">You may review the code to verify that everything is okay. </span><span class="koboSpan" id="kobo.888.2">You may also modify the migration content (only if you are enough of an expert to do it reliably) or simply undo the migration with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.889.1">in</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.890.1">Remove-Migration Remove-Migration</span></code><span class="koboSpan" id="kobo.891.1"> command, which is the advised way to proceed when we discover errors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.892.1">Each </span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.893.1">migration contains an </span><code class="inlineCode"><span class="koboSpan" id="kobo.894.1">Up</span></code><span class="koboSpan" id="kobo.895.1"> method and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.896.1">Down</span></code><span class="koboSpan" id="kobo.897.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.898.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.899.1">Up</span></code><span class="koboSpan" id="kobo.900.1"> method implies the migration, while the </span><code class="inlineCode"><span class="koboSpan" id="kobo.901.1">Down</span></code><span class="koboSpan" id="kobo.902.1"> method undoes its changes. </span><span class="koboSpan" id="kobo.902.2">Accordingly, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.903.1">Down</span></code><span class="koboSpan" id="kobo.904.1"> method contains the reverse actions of all the actions included in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.905.1">Up</span></code><span class="koboSpan" id="kobo.906.1"> method in reverse order.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.907.1">20210924143018_initial.Designer.cs</span></code><span class="koboSpan" id="kobo.908.1"> is the Visual Studio designer code, which you must not modify, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.909.1">MainDbContextModelSnapshot.cs</span></code><span class="koboSpan" id="kobo.910.1"> is the overall database structure snapshot. </span><span class="koboSpan" id="kobo.910.2">If you add further migrations, new migration files and their designer counterparts will appear, and the unique </span><code class="inlineCode"><span class="koboSpan" id="kobo.911.1">MainDbContextModelSnapshot.cs</span></code><span class="koboSpan" id="kobo.912.1"> database structure snapshot will be updated to reflect the database’s overall structure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.913.1">The same command can be issued in an operating system console by typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">dotnet ef migrations add initial</span></code><span class="koboSpan" id="kobo.915.1">. </span><span class="koboSpan" id="kobo.915.2">This command must be issued from within the project’s root folder (not from within the solution’s root folder).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.916.1">However, if </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">Microsoft.EntityFrameworkCore.Design</span></code><span class="koboSpan" id="kobo.918.1"> is installed globally with </span><code class="inlineCode"><span class="koboSpan" id="kobo.919.1">dotnet tool install --global dotnet-ef</span></code><span class="koboSpan" id="kobo.920.1">, then we can use it in a project after adding it to that project by typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.921.1">dotnet add package –-project &lt;project path&gt; Microsoft.EntityFrameworkCore.Design</span></code><span class="koboSpan" id="kobo.922.1">. </span><span class="koboSpan" id="kobo.922.2">In this case, commands can be issued from any folder by specifying the </span><code class="inlineCode"><span class="koboSpan" id="kobo.923.1">--project &lt;project path&gt;</span></code><span class="koboSpan" id="kobo.924.1"> option.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.925.1">Migrations can be applied to the database by typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">Update-Database</span></code><span class="koboSpan" id="kobo.927.1"> in the Package Manager Console. </span><span class="koboSpan" id="kobo.927.2">The equivalent console command is </span><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">dotnet ef database update</span></code><span class="koboSpan" id="kobo.929.1">. </span><span class="koboSpan" id="kobo.929.2">Let’s try using this command to create the physical database!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.930.1">The next subsection </span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.931.1">explains how to create database stuff that Entity Framework is unable to create automatically. </span><span class="koboSpan" id="kobo.931.2">After that, in the next section, we will use Entity Framework’s configuration and the database we generated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">dotnet ef database update</span></code><span class="koboSpan" id="kobo.933.1"> to create, query, and update data.</span></p>
<h2 class="heading-2" id="_idParaDest-273"><span class="koboSpan" id="kobo.934.1">Understanding stored procedures and direct SQL commands</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.935.1">Some database</span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.936.1"> structures, like, for instance, stored procedures, can’t be generated automatically by the Entity Framework Core commands and declarations we described previously. </span><span class="koboSpan" id="kobo.936.2">Stored procedures such as generic SQL strings can be included manually in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">Up</span></code><span class="koboSpan" id="kobo.938.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.939.1">Down</span></code><span class="koboSpan" id="kobo.940.1"> methods through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.941.1">migrationBuilder.Sql("&lt;sql command&gt;")</span></code><span class="koboSpan" id="kobo.942.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.943.1">The safest way to do this </span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.944.1">is by adding a migration without performing any configuration changes so that the migration is empty when it’s created. </span><span class="koboSpan" id="kobo.944.2">Then, we can add the necessary SQL commands to the empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.945.1">Up</span></code><span class="koboSpan" id="kobo.946.1"> method of this migration and their converse commands in the empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.947.1">Down</span></code><span class="koboSpan" id="kobo.948.1"> method. </span><span class="koboSpan" id="kobo.948.2">It is good practice to put all the SQL strings in the properties of resource files (</span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">.resx</span></code><span class="koboSpan" id="kobo.950.1"> files).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.951.1">Stored procedures should replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.952.1">Entity</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.953.1">Framework</span></code><span class="koboSpan" id="kobo.954.1"> commands in the following circumstances:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.955.1">When we need to perform manual SQL optimizations to increase the performance of some operations.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.956.1">When </span><code class="inlineCode"><span class="koboSpan" id="kobo.957.1">Entity</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.958.1">Framework</span></code><span class="koboSpan" id="kobo.959.1"> doesn’t support the SQL operation, we need to perform. </span><span class="koboSpan" id="kobo.959.2">A typical example is the increment or decrement of a numeric field that occurs in all booking operations (air travel, hotels, and so on). </span><span class="koboSpan" id="kobo.959.3">Actually, we might replace the increment/decrement operation with a database read, an in-memory increment/decrement, and finally, a database update, all enclosed in the same transaction scope. </span><span class="koboSpan" id="kobo.959.4">However, this might be overkill for performance.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.960.1">Before starting to interact with our database, we can perform a further optional step: model optimizations.</span></p>
<h1 class="heading-1" id="_idParaDest-274"><span class="koboSpan" id="kobo.961.1">Compiled models</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.962.1">Starting </span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.963.1">from version 6, Entity Framework Core introduced the possibility to create precompiled data structures that improve Entity Framework Core’s performance by about 10 times in the case of models with hundreds of entities (see the reference in the </span><em class="italic"><span class="koboSpan" id="kobo.964.1">Further reading</span></em><span class="koboSpan" id="kobo.965.1"> section for more details). </span><span class="koboSpan" id="kobo.965.2">This step is accomplished by generating some code that, once compiled together with the data layer project, creates data structures that our context classes can use to improve performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.966.1">The usage of pre-compilation is advised just after you verify the system experiences slow-downs and also on very simple queries. </span><span class="koboSpan" id="kobo.966.2">In other words, it is better to start without pre-compilation and then possibly add it in case of slow-downs caused by the EF infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.967.1">Code is generated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.968.1">Optimize-DbContext</span></code><span class="koboSpan" id="kobo.969.1"> command provided by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.970.1">Microsoft.EntityFrameworkCore.Tool</span></code><span class="koboSpan" id="kobo.971.1"> NuGet package that we already installed. </span><span class="koboSpan" id="kobo.971.2">The command accepts the folder name to place the code and the namespace to place all classes. </span><span class="koboSpan" id="kobo.971.3">In our case, let’s choose the </span><code class="inlineCode"><span class="koboSpan" id="kobo.972.1">Optimization</span></code><span class="koboSpan" id="kobo.973.1"> folder and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.974.1">WWTravelClubDB.Optimization</span></code><span class="koboSpan" id="kobo.975.1"> namespace:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.976.1">Optimize-DbContext -Context MainDBContext -OutputDir Optimization -Namespace WWTravelClubDB.Optimization
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.977.1">Here, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">–Context</span></code><span class="koboSpan" id="kobo.979.1"> parameter must be passed the name of our context class. </span><span class="koboSpan" id="kobo.979.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">Optimization</span></code><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.981.1">folder is automatically created and filled with classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.982.1">The optimization code depends on the ORM configuration, so the </span><code class="inlineCode"><span class="koboSpan" id="kobo.983.1">Optimize-DbContext</span></code><span class="koboSpan" id="kobo.984.1"> command must be repeated each time a new migration is created.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.985.1">Optimizations are enabled by passing the root of our optimization model as an option when an instance of the context class is created. </span><span class="koboSpan" id="kobo.985.2">Let’s open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.986.1">LibraryDesignTimeDbContextFactory.cs</span></code><span class="koboSpan" id="kobo.987.1"> file and add the line below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.988.1">builder.UseSqlServer(connectionString);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.989.1">//Line to add. </span><span class="koboSpan" id="kobo.989.2">Add it after that the optimization model has been created</span></span><span class="koboSpan" id="kobo.990.1">
builder.UseModel(Optimization.MainDbContextModel.Instance);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.991.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.992.1">new</span></span><span class="koboSpan" id="kobo.993.1"> MainDbContext(builder.Options);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.994.1">Now, you are ready to interact with the database through Entity Framework Core.</span></p>
<h1 class="heading-1" id="_idParaDest-275"><span class="koboSpan" id="kobo.995.1">Querying and updating data with Entity Framework Core</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.996.1">To test our DB layer, we</span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.997.1"> need to add a console project </span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.998.1">based on the same .NET Core version as our library to the solution. </span><span class="koboSpan" id="kobo.998.2">Let’s get started:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.999.1">Let’s call the new console project </span><code class="inlineCode"><span class="koboSpan" id="kobo.1000.1">WWTravelClubDBTest</span></code><span class="koboSpan" id="kobo.1001.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1002.1">Now, we need to add our data layer as a dependency of the console project by right-clicking on the </span><strong class="screenText"><span class="koboSpan" id="kobo.1003.1">Dependencies</span></strong><span class="koboSpan" id="kobo.1004.1"> node of the console project and selecting </span><strong class="screenText"><span class="koboSpan" id="kobo.1005.1">Add Project Reference</span></strong><span class="koboSpan" id="kobo.1006.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1007.1">Remove the content of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1008.1">Program.cs</span></code><span class="koboSpan" id="kobo.1009.1"> file and start by writing the following:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1010.1">Console.WriteLine(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1011.1">"program start: populate database, press a key to continue"</span></span><span class="koboSpan" id="kobo.1012.1">);
Console.ReadKey();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1013.1">Then, add the following namespaces at the top of the file:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1014.1">using</span></span><span class="koboSpan" id="kobo.1015.1"> WWTravelClubDB;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1016.1">using</span></span><span class="koboSpan" id="kobo.1017.1"> WWTravelClubDB.Models;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1018.1">using</span></span><span class="koboSpan" id="kobo.1019.1"> Microsoft.EntityFrameworkCore;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1020.1">using</span></span><span class="koboSpan" id="kobo.1021.1"> WWTravelClubDBTest;
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1022.1">Now that we have finished preparing our test project, we can experiment with queries and data updates. </span><span class="koboSpan" id="kobo.1022.2">Let’s start by creating some database objects, that is, some destinations and packages. </span><span class="koboSpan" id="kobo.1022.3">Follow these steps to do so:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1023.1">First, we must create an instance of our </span><code class="inlineCode"><span class="koboSpan" id="kobo.1024.1">DbContext</span></code><span class="koboSpan" id="kobo.1025.1"> subclass with an appropriate connection string. </span><span class="koboSpan" id="kobo.1025.2">We can use the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.1026.1">LibraryDesignTimeDbContextFactory</span></code><span class="koboSpan" id="kobo.1027.1"> class that’s used by the design tools to get it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1028.1">var</span></span><span class="koboSpan" id="kobo.1029.1"> context = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1030.1">new</span></span><span class="koboSpan" id="kobo.1031.1"> LibraryDesignTimeDbContextFactory()
.CreateDbContext();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1032.1">New rows can be created by simply adding class instances to the mapped collections of our </span><code class="inlineCode"><span class="koboSpan" id="kobo.1033.1">DbContext</span></code><span class="koboSpan" id="kobo.1034.1"> subclass. </span><span class="koboSpan" id="kobo.1034.2">If a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1035.1">Destination</span></code><span class="koboSpan" id="kobo.1036.1"> instance has packages associated with it, we can simply add them to its </span><code class="inlineCode"><span class="koboSpan" id="kobo.1037.1">Packages</span></code><span class="koboSpan" id="kobo.1038.1"> property:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1039.1">var</span></span><span class="koboSpan" id="kobo.1040.1"> firstDestination= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1041.1">new</span></span><span class="koboSpan" id="kobo.1042.1"> Destination
{
    Name = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1043.1">"Florence"</span></span><span class="koboSpan" id="kobo.1044.1">,
    Country = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1045.1">"Italy"</span></span><span class="koboSpan" id="kobo.1046.1">,
    Packages = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1047.1">new</span></span><span class="koboSpan" id="kobo.1048.1"> List&lt;Package&gt;()
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1049.1">new</span></span><span class="koboSpan" id="kobo.1050.1"> Package
        {
            Name = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1051.1">"Summer in Florence"</span></span><span class="koboSpan" id="kobo.1052.1">,
            StartValidityDate = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1053.1">new</span></span><span class="koboSpan" id="kobo.1054.1"> DateTime(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1055.1">2019</span></span><span class="koboSpan" id="kobo.1056.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1057.1">6</span></span><span class="koboSpan" id="kobo.1058.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1059.1">1</span></span><span class="koboSpan" id="kobo.1060.1">),
            EndValidityDate = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1061.1">new</span></span><span class="koboSpan" id="kobo.1062.1"> DateTime(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1063.1">2019</span></span><span class="koboSpan" id="kobo.1064.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1065.1">10</span></span><span class="koboSpan" id="kobo.1066.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1067.1">1</span></span><span class="koboSpan" id="kobo.1068.1">),
            DurationInDays=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1069.1">7</span></span><span class="koboSpan" id="kobo.1070.1">,
            Price=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1071.1">1000</span></span><span class="koboSpan" id="kobo.1072.1">
        },
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1073.1">new</span></span><span class="koboSpan" id="kobo.1074.1"> Package
        {
            Name = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1075.1">"Winter in Florence"</span></span><span class="koboSpan" id="kobo.1076.1">,
            StartValidityDate = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1077.1">new</span></span><span class="koboSpan" id="kobo.1078.1"> DateTime(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1079.1">2019</span></span><span class="koboSpan" id="kobo.1080.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1081.1">12</span></span><span class="koboSpan" id="kobo.1082.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1083.1">1</span></span><span class="koboSpan" id="kobo.1084.1">),
            EndValidityDate = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1085.1">new</span></span><span class="koboSpan" id="kobo.1086.1"> DateTime(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1087.1">2020</span></span><span class="koboSpan" id="kobo.1088.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1089.1">2</span></span><span class="koboSpan" id="kobo.1090.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1091.1">1</span></span><span class="koboSpan" id="kobo.1092.1">),
            DurationInDays=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1093.1">7</span></span><span class="koboSpan" id="kobo.1094.1">,
            Price=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1095.1">500</span></span><span class="koboSpan" id="kobo.1096.1">
        }
    }
};
context.Destinations.Add(firstDestination);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1097.1">await</span></span><span class="koboSpan" id="kobo.1098.1"> context.SaveChangesAsync();
Console.WriteLine(
 </span><span class="hljs-string"><span class="koboSpan" id="kobo.1099.1">$"DB populated: first destination id is </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1100.1">{firstDestination.Id}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1101.1">"</span></span><span class="koboSpan" id="kobo.1102.1">);
Console.ReadKey();
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1103.1">There is no </span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.1104.1">need to specify primary keys since they are auto-generated and will be filled in by the database. </span><span class="koboSpan" id="kobo.1104.2">In fact, after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1105.1">SaveChangesAsync()</span></code><span class="koboSpan" id="kobo.1106.1"> operation synchronizes our context with the actual DB, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1107.1">firstDestination.Id</span></code><span class="koboSpan" id="kobo.1108.1"> property has a non-zero value. </span><span class="koboSpan" id="kobo.1108.2">The same is true for the primary keys of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1109.1">Package</span></code><span class="koboSpan" id="kobo.1110.1">. </span><span class="koboSpan" id="kobo.1110.2">Key auto-generation is the default behavior for all integer types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1111.1">When we declare</span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.1112.1"> that an entity (in our case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1113.1">Package</span></code><span class="koboSpan" id="kobo.1114.1">) is a child of another entity (in our case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1115.1">Destination</span></code><span class="koboSpan" id="kobo.1116.1">) by inserting it in a parent entity collection (in our case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1117.1">Packages</span></code><span class="koboSpan" id="kobo.1118.1"> collection), there is no need to explicitly set its external key (in our case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1119.1">DestinationId</span></code><span class="koboSpan" id="kobo.1120.1">) since it is inferred automatically by Entity Framework Core. </span><span class="koboSpan" id="kobo.1120.2">Once created and synchronized with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1121.1">firstDestination</span></code><span class="koboSpan" id="kobo.1122.1"> database, we can add further packages in two different ways:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1123.1">Create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1124.1">Package</span></code><span class="koboSpan" id="kobo.1125.1"> class instance, set its </span><code class="inlineCode"><span class="koboSpan" id="kobo.1126.1">DestinationId</span></code><span class="koboSpan" id="kobo.1127.1"> external key to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1128.1">firstDestination.Id</span></code><span class="koboSpan" id="kobo.1129.1">, and add it to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1130.1">context.Packages</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1131.1">Create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1132.1">Package</span></code><span class="koboSpan" id="kobo.1133.1"> class instance, with no need to set its external key, and then add it to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1134.1">Packages</span></code><span class="koboSpan" id="kobo.1135.1"> collection of its parent </span><code class="inlineCode"><span class="koboSpan" id="kobo.1136.1">Destination</span></code><span class="koboSpan" id="kobo.1137.1"> instance</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1138.1">The latter approach should be preferred when the two entities do not belong to the same aggregate since, in this case, the whole aggregate must be loaded in memory before operating on it to be sure all business rules are correctly applied and to prevent incoherences caused by simultaneous operations on different parts of the same aggregates (see the </span><em class="italic"><span class="koboSpan" id="kobo.1139.1">Aggregates</span></em><span class="koboSpan" id="kobo.1140.1"> subsection of </span><em class="italic"><span class="koboSpan" id="kobo.1141.1">Chapter 7, Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.1142.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1143.1">Moreover, the</span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.1144.1"> latter option is the only possibility when a child entity (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1145.1">Package</span></code><span class="koboSpan" id="kobo.1146.1">) is added with its parent entity (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1147.1">Destination</span></code><span class="koboSpan" id="kobo.1148.1">) and the parent entity has an auto-generated principal key since, in this case, the external key isn’t available at the time we perform the additions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1149.1">In most of</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.1150.1"> the other circumstances, the former option is simpler since the second option requires the parent </span><code class="inlineCode"><span class="koboSpan" id="kobo.1151.1">Destination</span></code><span class="koboSpan" id="kobo.1152.1"> entity to be loaded in memory, along with its </span><code class="inlineCode"><span class="koboSpan" id="kobo.1153.1">Packages</span></code><span class="koboSpan" id="kobo.1154.1"> collection, that is, together with all the packages associated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1155.1">Destination</span></code><span class="koboSpan" id="kobo.1156.1"> object (by default, connected entities aren’t loaded by queries).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1157.1">Now, let’s say we want to modify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1158.1">Florence</span></code><span class="koboSpan" id="kobo.1159.1"> destination and give a 10% increment to all </span><code class="inlineCode"><span class="koboSpan" id="kobo.1160.1">Florence</span></code><span class="koboSpan" id="kobo.1161.1"> package prices. </span><span class="koboSpan" id="kobo.1161.2">How do we proceed? </span><span class="koboSpan" id="kobo.1161.3">Follow these steps to find out how:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1162.1">First, comment out all previous instructions for populating the database while keeping the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1163.1">DbContext</span></code><span class="koboSpan" id="kobo.1164.1"> creation instruction:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1165.1">Console.WriteLine(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1166.1">"program start: populate database, press a key to continue"</span></span><span class="koboSpan" id="kobo.1167.1">);
Console.ReadKey();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1168.1">var</span></span><span class="koboSpan" id="kobo.1169.1"> context = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1170.1">new</span></span><span class="koboSpan" id="kobo.1171.1"> LibraryDesignTimeDbContextFactory()
    .CreateDbContext();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1172.1">//var firstDestination = new Destination</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1173.1">//{</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1174.1">//    Name = "Florence",</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1175.1">//    Country = "Italy",</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1176.1">//    Packages = new List&lt;Package&gt;()</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1177.1">//    {</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1178.1">//        new Package</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1179.1">//        {</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1180.1">//            Name = "Summer in Florence",</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1181.1">//            StartValidityDate = new DateTime(2019, 6, 1),</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1182.1">//            EndValidityDate = new DateTime(2019, 10, 1),</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1183.1">//            DurationInDays=7,</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1184.1">//            Price=1000</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1185.1">//        },</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1186.1">//        new Package</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1187.1">//        {</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1188.1">//            Name = "Winter in Florence",</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1189.1">//            StartValidityDate = new DateTime(2019, 12, 1),</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1190.1">//            EndValidityDate = new DateTime(2020, 2, 1),</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1191.1">//            DurationInDays=7,</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1192.1">//            Price=500</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1193.1">//        }</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1194.1">//    }</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1195.1">//};</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1196.1">//context.Destinations.Add(firstDestination);</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1197.1">//await context.SaveChangesAsync();</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1198.1">//Console.WriteLine(</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1199.1">//    $"DB populated: first destination id is {firstDestination.Id}");</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1200.1">//Console.ReadKey();</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1201.1">Then, we </span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.1202.1">need to load the entity into memory with a query, modify it, and call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1203.1">await SaveChangesAsync()</span></code><span class="koboSpan" id="kobo.1204.1"> to synchronize our changes with the database.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1205.1">If we want to</span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.1206.1"> modify, say, just its description, a query such as the following is enough:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1207.1">var</span></span><span class="koboSpan" id="kobo.1208.1"> toModify = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1209.1">await</span></span><span class="koboSpan" id="kobo.1210.1"> context.Destinations
    .Where(m =&gt; m.Name == </span><span class="hljs-string"><span class="koboSpan" id="kobo.1211.1">"Florence"</span></span><span class="koboSpan" id="kobo.1212.1">).FirstOrDefaultAsync();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1213.1">We need to load all the related destination packages that are not loaded by default. </span><span class="koboSpan" id="kobo.1213.2">This can be done with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1214.1">Include</span></code><span class="koboSpan" id="kobo.1215.1"> clause, as follows:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1216.1">var</span></span><span class="koboSpan" id="kobo.1217.1"> toModify = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1218.1">await</span></span><span class="koboSpan" id="kobo.1219.1"> context.Destinations
    .Where(m =&gt; m.Name == </span><span class="hljs-string"><span class="koboSpan" id="kobo.1220.1">"Florence"</span></span><span class="koboSpan" id="kobo.1221.1">)
    .Include(m =&gt; m.Packages)
    .FirstOrDefaultAsync();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1222.1">After that, we can modify the description and package prices, as follows:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1223.1">toModify.Description =
  </span><span class="hljs-string"><span class="koboSpan" id="kobo.1224.1">"Florence is a famous historical Italian town"</span></span><span class="koboSpan" id="kobo.1225.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1226.1">foreach</span></span><span class="koboSpan" id="kobo.1227.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1228.1">var</span></span><span class="koboSpan" id="kobo.1229.1"> package </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1230.1">in</span></span><span class="koboSpan" id="kobo.1231.1"> toModify.Packages)
   package.Price = package.Price * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1232.1">1.1</span></span><span class="koboSpan" id="kobo.1233.1">m;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1234.1">await</span></span><span class="koboSpan" id="kobo.1235.1"> context.SaveChangesAsync();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1236.1">var</span></span><span class="koboSpan" id="kobo.1237.1"> verifyChanges= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1238.1">await</span></span><span class="koboSpan" id="kobo.1239.1"> context.Destinations
    .Where(m =&gt; m.Name == </span><span class="hljs-string"><span class="koboSpan" id="kobo.1240.1">"Florence"</span></span><span class="koboSpan" id="kobo.1241.1">)
    .FirstOrDefaultAsync();
Console.WriteLine(
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1242.1">$"New Florence description: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1243.1">{verifyChanges.Description}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1244.1">"</span></span><span class="koboSpan" id="kobo.1245.1">);
Console.ReadKey();
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1246.1">If entities included </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.1247.1">with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1248.1">Include</span></code><span class="koboSpan" id="kobo.1249.1"> method</span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.1250.1"> themselves contain a nested collection we would like to include, we can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1251.1">ThenInclude</span></code><span class="koboSpan" id="kobo.1252.1">, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1253.1">.Include(m =&gt; m.NestedCollection)
.ThenInclude(m =&gt; m.NestedNestedCollection)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1254.1">Since Entity Framework always tries to translate each LINQ into a single SQL query, sometimes the resulting query might be too complex and slow. </span><span class="koboSpan" id="kobo.1254.2">In such cases, starting from version 5, we can give Entity Framework the permission to split the LINQ query into several SQL queries, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1255.1">.AsSplitQuery().Include(m =&gt; m.NestedCollection)
.ThenInclude(m =&gt; m.NestedNestedCollection)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1256.1">Performance issues can be addressed by inspecting the SQL generated by a LINQ query with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1257.1">ToQueryString</span></code><span class="koboSpan" id="kobo.1258.1"> method:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1259.1">var</span></span><span class="koboSpan" id="kobo.1260.1"> mySQL = myLinQQuery.ToQueryString ();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1261.1">Starting from version 5, the included nested collection can also be filtered with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1262.1">Where</span></code><span class="koboSpan" id="kobo.1263.1">, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1264.1">.Include(m =&gt; m.Packages.Where(l-&gt; l.Price &lt; x))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1265.1">So far, we’ve performed queries whose unique purpose is to update the retrieved entities. </span><span class="koboSpan" id="kobo.1265.2">Next, we will explain how to retrieve information that will be shown to the user and/or used by complex business operations.</span></p>
<h2 class="heading-2" id="_idParaDest-276"><span class="koboSpan" id="kobo.1266.1">Returning data to the presentation layer</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1267.1">To keep the</span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.1268.1"> layers separated and to adapt queries to the data that’s actually needed by each </span><em class="italic"><span class="koboSpan" id="kobo.1269.1">use case</span></em><span class="koboSpan" id="kobo.1270.1">, DB entities aren’t sent as they are to the presentation layer. </span><span class="koboSpan" id="kobo.1270.2">Instead, the data is projected into smaller classes that contain the information that’s needed by the </span><em class="italic"><span class="koboSpan" id="kobo.1271.1">use case</span></em><span class="koboSpan" id="kobo.1272.1">. </span><span class="koboSpan" id="kobo.1272.2">These are implemented by the presentation layer’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.1273.1">caller</span></code><span class="koboSpan" id="kobo.1274.1"> method. </span><span class="koboSpan" id="kobo.1274.2">Objects that move data from one layer to another are </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.1275.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1276.1">Data Transfer Objects</span></strong><span class="koboSpan" id="kobo.1277.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1278.1">DTOs</span></strong><span class="koboSpan" id="kobo.1279.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1280.1">As an </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.1281.1">example, let’s create a DTO containing the summary information that is worth showing when returning a list of packages to the user (we suppose that, if needed, the user can get more details by clicking the package they are interested in):</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1282.1">Let’s add a DTO to our </span><code class="inlineCode"><span class="koboSpan" id="kobo.1283.1">WWTravelClubDBTest</span></code><span class="koboSpan" id="kobo.1284.1"> project that contains all the information that needs to be shown in a list of packages:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1285.1">namespace</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1286.1">WWTravelClubDBTest</span></span><span class="koboSpan" id="kobo.1287.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1288.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1289.1">record</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1290.1">PackagesListDTO</span></span><span class="koboSpan" id="kobo.1291.1">
   {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1292.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1293.1">int</span></span><span class="koboSpan" id="kobo.1294.1"> Id { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1295.1">get</span></span><span class="koboSpan" id="kobo.1296.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1297.1">init</span></span><span class="koboSpan" id="kobo.1298.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1299.1">public</span></span><span class="koboSpan" id="kobo.1300.1"> required </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1301.1">string</span></span><span class="koboSpan" id="kobo.1302.1"> Name { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1303.1">get</span></span><span class="koboSpan" id="kobo.1304.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1305.1">init</span></span><span class="koboSpan" id="kobo.1306.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1307.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1308.1">decimal</span></span><span class="koboSpan" id="kobo.1309.1"> Price { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1310.1">get</span></span><span class="koboSpan" id="kobo.1311.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1312.1">init</span></span><span class="koboSpan" id="kobo.1313.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1314.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1315.1">int</span></span><span class="koboSpan" id="kobo.1316.1"> DurationInDays { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1317.1">get</span></span><span class="koboSpan" id="kobo.1318.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1319.1">init</span></span><span class="koboSpan" id="kobo.1320.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1321.1">public</span></span><span class="koboSpan" id="kobo.1322.1"> DateTime? </span><span class="koboSpan" id="kobo.1322.2">StartValidityDate { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1323.1">get</span></span><span class="koboSpan" id="kobo.1324.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1325.1">init</span></span><span class="koboSpan" id="kobo.1326.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1327.1">public</span></span><span class="koboSpan" id="kobo.1328.1"> DateTime? </span><span class="koboSpan" id="kobo.1328.2">EndValidityDate { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1329.1">get</span></span><span class="koboSpan" id="kobo.1330.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1331.1">init</span></span><span class="koboSpan" id="kobo.1332.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1333.1">public</span></span><span class="koboSpan" id="kobo.1334.1"> required </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1335.1">string</span></span><span class="koboSpan" id="kobo.1336.1"> DestinationName { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1337.1">get</span></span><span class="koboSpan" id="kobo.1338.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1339.1">init</span></span><span class="koboSpan" id="kobo.1340.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1341.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1342.1">int</span></span><span class="koboSpan" id="kobo.1343.1"> DestinationId { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1344.1">get</span></span><span class="koboSpan" id="kobo.1345.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1346.1">init</span></span><span class="koboSpan" id="kobo.1347.1">; }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1348.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1349.1">override</span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1350.1">string</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1351.1">ToString</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1352.1">()</span></span><span class="koboSpan" id="kobo.1353.1">
        {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1354.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1355.1">string</span></span><span class="koboSpan" id="kobo.1356.1">.Format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1357.1">"{0}. </span><span class="koboSpan" id="kobo.1357.2">{1} days in {2}, price: {3}"</span></span><span class="koboSpan" id="kobo.1358.1">,
                Name, DurationInDays, DestinationName, Price);
        }
    }
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1359.1">We don’t need to load entities in memory and then copy their data into the DTO, but database data can be projected directly into the DTO, thanks to the LINQ</span><code class="inlineCode"><span class="koboSpan" id="kobo.1360.1"> Select</span></code><span class="koboSpan" id="kobo.1361.1"> clause. </span><span class="koboSpan" id="kobo.1361.2">This minimizes how much data is exchanged with the database.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1362.1">As an example, we can populate our DTOs with a query that checks all the packages that are available around August 10:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1363.1">var</span></span><span class="koboSpan" id="kobo.1364.1"> period = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1365.1">new</span></span><span class="koboSpan" id="kobo.1366.1"> DateTime(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1367.1">2019</span></span><span class="koboSpan" id="kobo.1368.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1369.1">8</span></span><span class="koboSpan" id="kobo.1370.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1371.1">10</span></span><span class="koboSpan" id="kobo.1372.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1373.1">var</span></span><span class="koboSpan" id="kobo.1374.1"> list = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1375.1">await</span></span><span class="koboSpan" id="kobo.1376.1"> context.Packages
    .Where(m =&gt; period &gt;= m.StartValidityDate
    &amp;&amp; period &lt;= m.EndValidityDate)
    .Select(m =&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1377.1">new</span></span><span class="koboSpan" id="kobo.1378.1"> PackagesListDTO
    {
        StartValidityDate=m.StartValidityDate,
        EndValidityDate=m.EndValidityDate,
        Name=m.Name,
        DurationInDays=m.DurationInDays,
        Id=m.Id,
        Price=m.Price,
        DestinationName=m.MyDestination.Name,
        DestinationId = m.DestinationId
    })
    .ToListAsync();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1379.1">foreach</span></span><span class="koboSpan" id="kobo.1380.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1381.1">var</span></span><span class="koboSpan" id="kobo.1382.1"> result </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1383.1">in</span></span><span class="koboSpan" id="kobo.1384.1"> list)
    Console.WriteLine(result.ToString());
Console.ReadKey();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1385.1">In</span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.1386.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1387.1">Select</span></code><span class="koboSpan" id="kobo.1388.1"> clause, we can also navigate to any related entities to get the data we need. </span><span class="koboSpan" id="kobo.1388.2">For instance, the preceding query navigates to the related </span><code class="inlineCode"><span class="koboSpan" id="kobo.1389.1">Destination</span></code><span class="koboSpan" id="kobo.1390.1"> entity to get the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1391.1">Package</span></code><span class="koboSpan" id="kobo.1392.1"> destination name.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1393.1">The programs stop at each </span><code class="inlineCode"><span class="koboSpan" id="kobo.1394.1">Console.ReadKey()</span></code><span class="koboSpan" id="kobo.1395.1"> method, waiting for you to hit any key. </span><span class="koboSpan" id="kobo.1395.2">This way, you have time to analyze the output that’s produced by all the code snippets that we added to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1396.1">Main</span></code><span class="koboSpan" id="kobo.1397.1"> method.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1398.1">Now, right-click on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1399.1">WWTravelClubDBTest</span></code><span class="koboSpan" id="kobo.1400.1"> project in Solution Explorer and set it as the start project. </span><span class="koboSpan" id="kobo.1400.2">Then, run the solution.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1401.1">Now, we will learn how to handle operations that can’t be efficaciously mapped to the immediate operations in the in-memory collections that represent the database tables.</span></p>
<h2 class="heading-2" id="_idParaDest-277"><span class="koboSpan" id="kobo.1402.1">Issuing direct SQL commands</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1403.1">Not all </span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.1404.1">database operations can be executed efficiently by querying the database with LINQ and updating in-memory entities. </span><span class="koboSpan" id="kobo.1404.2">For instance, counter increments can be performed more efficiently with a single SQL instruction. </span><span class="koboSpan" id="kobo.1404.3">Moreover, some operations can be executed with acceptable performance if we define adequate stored procedures/SQL commands. </span><span class="koboSpan" id="kobo.1404.4">In these cases, we are forced to either issue direct SQL commands to the database or call database-stored procedures from our Entity Framework code. </span><span class="koboSpan" id="kobo.1404.5">There are two possibilities: SQL statements that perform database operations but do not return entities, and SQL statements that do return entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1405.1">SQL commands that don’t return entities can be executed with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1406.1">DbContext</span></code><span class="koboSpan" id="kobo.1407.1"> method as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1408.1">Task&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1409.1">int</span></span><span class="koboSpan" id="kobo.1410.1">&gt; DbContext.Database.ExecuteSqlRawAsync(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1411.1">string</span></span><span class="koboSpan" id="kobo.1412.1"> sql, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1413.1">params</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1414.1">object</span></span><span class="koboSpan" id="kobo.1415.1">[] parameters)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1416.1">Parameters </span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.1417.1">can be referenced in the string as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1418.1">{0}, {1}, ..., {n}</span></code><span class="koboSpan" id="kobo.1419.1">. </span><span class="koboSpan" id="kobo.1419.2">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.1420.1">{m}</span></code><span class="koboSpan" id="kobo.1421.1"> is filled with the object contained at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1422.1">m</span></code><span class="koboSpan" id="kobo.1423.1"> index of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1424.1">parameters</span></code><span class="koboSpan" id="kobo.1425.1"> array, which is converted from a .NET type into the corresponding SQL type. </span><span class="koboSpan" id="kobo.1425.2">The method returns the number of affected rows.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1426.1">SQL commands that return collections of entities must be issued through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1427.1">FromSqlRaw</span></code><span class="koboSpan" id="kobo.1428.1"> method of the mapped collection associated with those entities:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1429.1">context.&lt;mapped collection&gt;.FromSqlRaw(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1430.1">string</span></span><span class="koboSpan" id="kobo.1431.1"> sql, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1432.1">params</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1433.1">object</span></span><span class="koboSpan" id="kobo.1434.1">[] parameters)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1435.1">Thus, for instance, a command that returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1436.1">Package</span></code><span class="koboSpan" id="kobo.1437.1"> instances would look something like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1438.1">var</span></span><span class="koboSpan" id="kobo.1439.1"> results = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1440.1">await</span></span><span class="koboSpan" id="kobo.1441.1"> context.Packages.FromSqlRaw(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1442.1">"&lt;some sql&gt;"</span></span><span class="koboSpan" id="kobo.1443.1">, par1, par2, ...).ToListAsync();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1444.1">SQL strings and parameters work like this in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1445.1">ExecuteSqlRaw</span></code><span class="koboSpan" id="kobo.1446.1"> method. </span><span class="koboSpan" id="kobo.1446.2">The following is a simple example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1447.1">var</span></span><span class="koboSpan" id="kobo.1448.1"> allPackages = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1449.1">await</span></span><span class="koboSpan" id="kobo.1450.1"> context.Packages.FromSqlRaw(
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1451.1">"SELECT * FROM Products WHERE Name = {0}"</span></span><span class="koboSpan" id="kobo.1452.1">,
    myPackageName).ToListAsync();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1453.1">We can also use string interpolation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1454.1">var</span></span><span class="koboSpan" id="kobo.1455.1"> allPackages = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1456.1">await</span></span><span class="koboSpan" id="kobo.1457.1"> context.Packages.FromSqlRaw(
  </span><span class="hljs-string"><span class="koboSpan" id="kobo.1458.1">$"SELECT * FROM Products WHERE Name = </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1459.1">{myPackageName}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1460.1">"</span></span><span class="koboSpan" id="kobo.1461.1">).ToListAsync();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1462.1">In case the objects to be returned by the SQL query are not mapped objects represented by a collection added to the DB context, like </span><code class="inlineCode"><span class="koboSpan" id="kobo.1463.1">context.Packages</span></code><span class="koboSpan" id="kobo.1464.1">, we can use a new method added in .NET 7:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1465.1">IQueryable&lt;TResult&gt; DbContext.Database.SqlQueryRaw&lt;TResult&gt; (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1466.1">string</span></span><span class="koboSpan" id="kobo.1467.1"> sql, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1468.1">params</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1469.1">object</span></span><span class="koboSpan" id="kobo.1470.1">[] parameters)
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1471.1">SqlQueryRaw</span></code><span class="koboSpan" id="kobo.1472.1"> is a</span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.1473.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1474.1">Database</span></code><span class="koboSpan" id="kobo.1475.1"> property of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1476.1">DbContext</span></code><span class="koboSpan" id="kobo.1477.1"> object, and it accepts the class of the objects to return as a generic parameter (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1478.1">TResult</span></code><span class="koboSpan" id="kobo.1479.1">). </span><span class="koboSpan" id="kobo.1479.2">However, in this case, Entity Framework Core is able to transform the SQL tuples returned by the database into objects only if the column names in the tuples are equal to the property names in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1480.1">TResult</span></code><span class="koboSpan" id="kobo.1481.1">. </span><span class="koboSpan" id="kobo.1481.2">Name mismatches in some properties can be overcome by decorating these properties with the names of the columns they must be mapped from with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1482.1">[Column("&lt;column name")]</span></code><span class="koboSpan" id="kobo.1483.1"> attribute. </span><span class="koboSpan" id="kobo.1483.2">This is also possible using fluent API configuration: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1484.1">.HasColumnName(&lt;column name")</span></code><span class="koboSpan" id="kobo.1485.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1486.1">It is good practice to put all the SQL strings in resource files and encapsulate all the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1487.1">ExecuteSqlRawAsync</span></code><span class="koboSpan" id="kobo.1488.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1489.1">FromSqlRaw</span></code><span class="koboSpan" id="kobo.1490.1"> calls inside the public methods that you defined in your </span><code class="inlineCode"><span class="koboSpan" id="kobo.1491.1">DbContext</span></code><span class="koboSpan" id="kobo.1492.1"> subclasses, in order to keep the dependence from a specific database inside of your Entity Framework Core-based data layer.</span></p>
<h2 class="heading-2" id="_idParaDest-278"><span class="koboSpan" id="kobo.1493.1">Handling transactions</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1494.1">All the </span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.1495.1">changes that are made to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1496.1">DbContext</span></code><span class="koboSpan" id="kobo.1497.1"> instance are passed in a single transaction at the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.1498.1">SaveChangesAsync</span></code><span class="koboSpan" id="kobo.1499.1"> call. </span><span class="koboSpan" id="kobo.1499.2">However, sometimes, it is necessary to include queries and updates in the same transaction. </span><span class="koboSpan" id="kobo.1499.3">In these cases, we must handle the transaction explicitly. </span><span class="koboSpan" id="kobo.1499.4">Several Entity Framework Core commands can be included in a transaction if we put them inside a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1500.1">using</span></code><span class="koboSpan" id="kobo.1501.1"> block associated with a transaction object:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1502.1">using</span></span><span class="koboSpan" id="kobo.1503.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1504.1">var</span></span><span class="koboSpan" id="kobo.1505.1"> dbContextTransaction = context.Database.BeginTransaction())
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1506.1">try</span></span><span class="koboSpan" id="kobo.1507.1">{
   ...
   </span><span class="koboSpan" id="kobo.1507.2">...
   </span><span class="koboSpan" id="kobo.1507.3">dbContextTransaction.Commit();
 }
 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1508.1">catch</span></span><span class="koboSpan" id="kobo.1509.1">
 {
   dbContextTransaction.Rollback();
 }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1510.1">In the preceding code, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1511.1">context</span></code><span class="koboSpan" id="kobo.1512.1"> is an instance of our </span><code class="inlineCode"><span class="koboSpan" id="kobo.1513.1">DbContext</span></code><span class="koboSpan" id="kobo.1514.1"> subclass. </span><span class="koboSpan" id="kobo.1514.2">Inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1515.1">using</span></code><span class="koboSpan" id="kobo.1516.1"> block, the transaction can be aborted and committed by calling its </span><code class="inlineCode"><span class="koboSpan" id="kobo.1517.1">Rollback</span></code><span class="koboSpan" id="kobo.1518.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1519.1">Commit</span></code><span class="koboSpan" id="kobo.1520.1"> methods. </span><span class="koboSpan" id="kobo.1520.2">Any </span><code class="inlineCode"><span class="koboSpan" id="kobo.1521.1">SaveChanges</span></code><span class="koboSpan" id="kobo.1522.1"> calls that are included in the transaction block use the transaction they are already in, instead of creating new ones.</span></p>
<h1 class="heading-1" id="_idParaDest-279"><span class="koboSpan" id="kobo.1523.1">Deploying your data layer</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1524.1">When</span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.1525.1"> your database layer is deployed in production or in staging, usually, an empty database already exists, so you must apply all the migrations in order to create all the database objects. </span><span class="koboSpan" id="kobo.1525.2">This can be done by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.1526.1">context.Database.Migrate()</span></code><span class="koboSpan" id="kobo.1527.1">. </span><span class="koboSpan" id="kobo.1527.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1528.1">Migrate</span></code><span class="koboSpan" id="kobo.1529.1"> method applies the migrations that haven’t been applied to the databases yet, so it may be called safely several times during the application’s lifetime.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1530.1">context</span></code><span class="koboSpan" id="kobo.1531.1"> is an instance of our </span><code class="inlineCode"><span class="koboSpan" id="kobo.1532.1">DbContext</span></code><span class="koboSpan" id="kobo.1533.1"> class that must be passed through a connection string with enough privileges to create tables and perform all the operations included in our migrations. </span><span class="koboSpan" id="kobo.1533.2">Thus, typically, this connection string is different from the string we will use during normal application operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1534.1">During the deployment of a web application on Azure, we are given the opportunity to check migrations with a connection string we provide. </span><span class="koboSpan" id="kobo.1534.2">We can also check migrations manually by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1535.1">context.Database.Migrate()</span></code><span class="koboSpan" id="kobo.1536.1"> method when the application starts. </span><span class="koboSpan" id="kobo.1536.2">This will be discussed in detail in </span><em class="italic"><span class="koboSpan" id="kobo.1537.1">Chapter 18</span></em><span class="koboSpan" id="kobo.1538.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1539.1">Implementing Frontend Microservices with ASP.NET Core</span></em><span class="koboSpan" id="kobo.1540.1">, which is dedicated to frontend applications based on ASP.NET Core MVC.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1541.1">In some production environments, it is not possible to apply migrations during the application deployment because the person in charge of the deployment doesn’t have enough privileges to create a new database and/or to create and modify tables. </span><span class="koboSpan" id="kobo.1541.2">In this case, we must transform migrations into SQL commands and pass them to the database administrator who, after having verified they will not damage the existing database and data, applies them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1542.1">We can transform all migrations in a given interval into SQL with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1543.1">Script-Migration</span></code><span class="koboSpan" id="kobo.1544.1"> command (see </span><a href="https://learn.microsoft.com/en-us/ef/core/cli/powershell"><span class="url"><span class="koboSpan" id="kobo.1545.1">https://learn.microsoft.com/en-us/ef/core/cli/powershell</span></span></a><span class="koboSpan" id="kobo.1546.1">):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1547.1">Script-Migration -From &lt;initial migration&gt; -To &lt;final migration&gt; -Output &lt;name of output file&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1548.1">For desktop applications, we can apply migrations during the installation of the application and its subsequent updates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1549.1">At the first application installation and/or in subsequent application updates, we may need to populate some tables with initial data. </span><span class="koboSpan" id="kobo.1549.2">For web applications, this operation can be performed at application startup, while for desktop applications, this operation can be included in the installation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1550.1">Database tables</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.1551.1"> can be populated with Entity Framework Core commands. </span><span class="koboSpan" id="kobo.1551.2">First, though, we need to verify whether the table is empty in order to avoid adding the same table rows several times. </span><span class="koboSpan" id="kobo.1551.3">This can be done with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1552.1">Any()</span></code><span class="koboSpan" id="kobo.1553.1"> LINQ method, as shown in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1554.1">if</span></span><span class="koboSpan" id="kobo.1555.1">(!context.Destinations.Any())
{
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1556.1">//populate here the Destinations table</span></span><span class="koboSpan" id="kobo.1557.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1558.1">Let’s take a look at a few advanced features that Entity Framework Core has to share.</span></p>
<h1 class="heading-1" id="_idParaDest-280"><span class="koboSpan" id="kobo.1559.1">How data and domain layers communicate with other layers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1560.1">As discussed in </span><em class="italic"><span class="koboSpan" id="kobo.1561.1">Chapter 7, Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.1562.1">, classical layer architectures use plain objects and repositories to communicate with the other layers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1563.1">Therefore, the </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.1564.1">entities that define Entity Framework Core configuration themselves can be used as they are to communicate with other layers, since they are just record-like lists of public properties, as prescribed for plain objects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1565.1">The case </span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.1566.1">of domain layers and onion architectures is slightly more complex, since, in this case, the domain layer communicates with the application layer through rich objects whose methods represent application domain rules. </span><span class="koboSpan" id="kobo.1566.2">Accordingly, in general, the remainder of the application can’t access all domain layer objects’ properties but is forced to modify them through their own methods, in order to enforce domain rules.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1567.1">In other words, Entity Framework entities are record-like lists of public properties with almost no methods, while DDD entities should have methods that encode domain logic, more sophisticated validation logic, and read-only properties. </span><span class="koboSpan" id="kobo.1567.2">While further validation logic and methods can be added without breaking Entity Framework’s operations, adding read-only properties that must not be mapped to database properties can create problems that must be handled adequately. </span><span class="koboSpan" id="kobo.1567.3">Preventing properties from being mapped to the database is quite easy–all we need to do is decorate them with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1568.1">NotMapped</span></code><span class="koboSpan" id="kobo.1569.1"> attribute or, using the fluent API, as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1570.1">.Ignore(e =&gt; e.PropertyName).</span></code></p>
<p class="normal"><span class="koboSpan" id="kobo.1571.1">The issues that </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.1572.1">read-only properties </span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.1573.1">have are a little bit more complex and can be solved in three fundamental ways:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1574.1">Map Entity Framework entities to different classes</span></strong><span class="koboSpan" id="kobo.1575.1">: Define the DDD entities as different classes and copy data to/from them when entities are returned/passed to repository methods. </span><span class="koboSpan" id="kobo.1575.2">This is the easiest solution, but it requires that you write some code so that you can convert the entities between the two formats. </span><span class="koboSpan" id="kobo.1575.3">DDD entities are defined in the domain layer, while the Entity Framework entities continue to be defined in the data layer. </span><span class="koboSpan" id="kobo.1575.4">This is the cleaner solution, but it causes a non-trivial overhead in both code writing and maintenance. </span><span class="koboSpan" id="kobo.1575.5">I recommend it when you have complex aggregates with several complex methods.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1576.1">Map table fields to private properties</span></strong><span class="koboSpan" id="kobo.1577.1">: Let Entity Framework Core map fields to private class fields so that you can decide how to expose them to properties by writing custom getters and/or setters. </span><span class="koboSpan" id="kobo.1577.2">It is sufficient to give either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1578.1">_&lt;property name&gt;</span></code><span class="koboSpan" id="kobo.1579.1"> name or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1580.1">_&lt;property name in camel case&gt;</span></code><span class="koboSpan" id="kobo.1581.1"> name to these private fields, and Entity Framework will use them instead of their associated properties. </span><span class="koboSpan" id="kobo.1581.2">In this case, DDD entities defined in the domain layer are also used as data layer entities. </span><span class="koboSpan" id="kobo.1581.3">The main disadvantage of this approach is that we can’t use data annotations to configure each property because DDD entities can’t depend on how the underlying data layer is implemented.
    </span><p class="normal"><span class="koboSpan" id="kobo.1582.1">Therefore, we must configure all database mapping in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1583.1">OnModelCreating</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1584.1">DbContext</span></code><span class="koboSpan" id="kobo.1585.1"> method, or in configuration classes associated with each entity (see </span><em class="italic"><span class="koboSpan" id="kobo.1586.1">Chapter 13</span></em><span class="koboSpan" id="kobo.1587.1">,</span><em class="italic"><span class="koboSpan" id="kobo.1588.1"> Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.1589.1">). </span><span class="koboSpan" id="kobo.1589.2">Both options look less readable than data annotations to me, so I don’t like this technique, but other professionals use it.</span></p></li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1590.1">Hide Entity Framework entities behind interfaces</span></strong><span class="koboSpan" id="kobo.1591.1">: Hide each Entity Framework entity with all its public properties behind an interface that, when needed, only exposes property getters. </span><span class="koboSpan" id="kobo.1591.2">Entities are defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1592.1">internal</span></code><span class="koboSpan" id="kobo.1593.1"> so outer layers can access them just through the interfaces they implement. </span><span class="koboSpan" id="kobo.1593.2">This way, we can force the usage of methods that implement business logic rules to modify entity properties. </span><span class="koboSpan" id="kobo.1593.3">Also, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1594.1">DbContext</span></code><span class="koboSpan" id="kobo.1595.1"> is defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1596.1">internal</span></code><span class="koboSpan" id="kobo.1597.1">, so it can be accessed through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1598.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.1599.1"> interface that it implements from the outer levels. </span><span class="koboSpan" id="kobo.1599.2">Interfaces can be defined in a different library for better decoupling from the outer layers. </span><span class="koboSpan" id="kobo.1599.3">In terms of the onion architecture, the library that defines all interfaces is the next layer in from the Entity Framework layer. </span><span class="koboSpan" id="kobo.1599.4">As usual, interfaces are coupled with their implementations in the dependency injection engine. </span><span class="koboSpan" id="kobo.1599.5">This is the solution I prefer when there are several simple entities.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1600.1">Let’s </span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.1601.1">suppose that we would like to define a DDD interface called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1602.1">IDestination</span></code><span class="koboSpan" id="kobo.1603.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1604.1">Destination</span></code><span class="koboSpan" id="kobo.1605.1"> entity, and suppose we would like to expose the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1606.1">Id</span></code><span class="koboSpan" id="kobo.1607.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1608.1">Name</span></code><span class="koboSpan" id="kobo.1609.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1610.1">Country</span></code><span class="koboSpan" id="kobo.1611.1"> properties as read-only since, once a </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.1612.1">destination is created, it can’t be modified anymore. </span><span class="koboSpan" id="kobo.1612.2">Here, it is sufficient to let </span><code class="inlineCode"><span class="koboSpan" id="kobo.1613.1">Destination</span></code><span class="koboSpan" id="kobo.1614.1"> implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.1615.1">IDestination</span></code><span class="koboSpan" id="kobo.1616.1"> and to define </span><code class="inlineCode"><span class="koboSpan" id="kobo.1617.1">Id</span></code><span class="koboSpan" id="kobo.1618.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1619.1">Name</span></code><span class="koboSpan" id="kobo.1620.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1621.1">Country</span></code><span class="koboSpan" id="kobo.1622.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1623.1">Description</span></code><span class="koboSpan" id="kobo.1624.1"> as read-only in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1625.1">IDestination</span></code><span class="koboSpan" id="kobo.1626.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1627.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1628.1">interface</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1629.1">IDestination</span></span><span class="koboSpan" id="kobo.1630.1">
{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1631.1">int</span></span><span class="koboSpan" id="kobo.1632.1"> Id { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1633.1">get</span></span><span class="koboSpan" id="kobo.1634.1">; }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1635.1">string</span></span><span class="koboSpan" id="kobo.1636.1"> Name { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1637.1">get</span></span><span class="koboSpan" id="kobo.1638.1">; }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1639.1">string</span></span><span class="koboSpan" id="kobo.1640.1"> Country { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1641.1">get</span></span><span class="koboSpan" id="kobo.1642.1">; }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1643.1">string</span></span><span class="koboSpan" id="kobo.1644.1"> Description { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1645.1">get</span></span><span class="koboSpan" id="kobo.1646.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1647.1">set</span></span><span class="koboSpan" id="kobo.1648.1">; }
    ...
</span><span class="koboSpan" id="kobo.1648.2">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1649.1">Another difference between DDD with onion architectures and a classical data layer is that, in classical data layers, all operations and queries on data are exposed as repository methods, while in domain layers, repository methods just encode creations, deletions, and queries, while modification operations are performed by methods of the rich domain layer classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1650.1">A complete example of domain layer implementation is described in </span><em class="italic"><span class="koboSpan" id="kobo.1651.1">Chapter 18</span></em><span class="koboSpan" id="kobo.1652.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1653.1">Implementing Frontend Microservices with ASP.NET Core</span></em><span class="koboSpan" id="kobo.1654.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-281"><span class="koboSpan" id="kobo.1655.1">Understanding Entity Framework Core advanced features</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1656.1">An </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.1657.1">interesting Entity Framework advanced feature that is worth mentioning is global filters, which were introduced at the end of 2017. </span><span class="koboSpan" id="kobo.1657.2">They enable techniques such as soft delete and multi-tenant tables that are shared by several users, where each user just </span><em class="italic"><span class="koboSpan" id="kobo.1658.1">sees</span></em><span class="koboSpan" id="kobo.1659.1"> its records.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1660.1">Global filters are defined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1661.1">modelBuilder</span></code><span class="koboSpan" id="kobo.1662.1"> object, which is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1663.1">DbContext</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1664.1">OnModelCreating</span></code><span class="koboSpan" id="kobo.1665.1"> method. </span><span class="koboSpan" id="kobo.1665.2">The syntax for this method is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1666.1">modelBuilder.Entity&lt;MyEntity&gt;().HasQueryFilter(m =&gt; &lt;define filter condition here&gt;);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1667.1">For instance, if we add an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1668.1">IsDeleted</span></code><span class="koboSpan" id="kobo.1669.1"> property to our </span><code class="inlineCode"><span class="koboSpan" id="kobo.1670.1">Package</span></code><span class="koboSpan" id="kobo.1671.1"> class, we may soft delete a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1672.1">Package</span></code><span class="koboSpan" id="kobo.1673.1"> without removing it from the database by defining the following filter:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1674.1">modelBuilder.Entity&lt;Package&gt;().HasQueryFilter(m =&gt; !m.IsDeleted);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1675.1">However, filters contain </span><code class="inlineCode"><span class="koboSpan" id="kobo.1676.1">DbContext</span></code><span class="koboSpan" id="kobo.1677.1"> properties. </span><span class="koboSpan" id="kobo.1677.2">Thus, for instance, if we add a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1678.1">CurrentUserID</span></code><span class="koboSpan" id="kobo.1679.1"> property to our </span><code class="inlineCode"><span class="koboSpan" id="kobo.1680.1">DbContext</span></code><span class="koboSpan" id="kobo.1681.1"> subclass (whose value is set as soon as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1682.1">DbContext</span></code><span class="koboSpan" id="kobo.1683.1"> instance is created), then we can add a filter like the following one to all the entities that refer to a user ID:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1684.1">modelBuilder.Entity&lt;Document&gt;().HasQueryFilter(m =&gt; m.UserId == CurrentUserId);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1685.1">With the preceding filter in place, the currently logged-in user can only access the documents they own (the ones that have their </span><code class="inlineCode"><span class="koboSpan" id="kobo.1686.1">UserId</span></code><span class="koboSpan" id="kobo.1687.1">). </span><span class="koboSpan" id="kobo.1687.2">Similar techniques are very useful in the implementation of multi-tenant applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1688.1">Another interesting feature that is worth mentioning is mapping entities to un-updatable database queries, which was introduced in version 5.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1689.1">When you define an entity, you can define explicitly either the name of the mapped database table or the name of a mapped updatable view:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1690.1"> modelBuilder.Entity&lt;MyEntity1&gt;().ToTable(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1691.1">"MyTable"</span></span><span class="koboSpan" id="kobo.1692.1">);
 modelBuilder.Entity&lt;MyEntity2&gt;().ToView(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1693.1">"MyView"</span></span><span class="koboSpan" id="kobo.1694.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1695.1">When an entity is mapped to a view, no table is generated by database migration, so the database view must be defined manually by the developer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1696.1">If the view we would like to map our entity in is not updatable, LINQ cannot use it to pass updates to the database. </span><span class="koboSpan" id="kobo.1696.2">In this case, we can map the same entity simultaneously to a view and a table:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1697.1">modelBuilder.Entity&lt;MyEntity&gt;().ToTable(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1698.1">"MyTable"</span></span><span class="koboSpan" id="kobo.1699.1">).ToView(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1700.1">"MyView"</span></span><span class="koboSpan" id="kobo.1701.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1702.1">Entity Framework </span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.1703.1">will use the view for the queries and the table for the updates. </span><span class="koboSpan" id="kobo.1703.2">This is useful when we create a newer version of a database table but we want to also take data from the old version of the table in all queries. </span><span class="koboSpan" id="kobo.1703.3">In this case, we may define a view that takes data from both the old and the new tables but passes all updates only on the new table.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1704.1">The option to set property defaults is also interesting. </span><span class="koboSpan" id="kobo.1704.2">This can be done by specifying an override for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1705.1">ConfigureConventions</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1706.1">DbContext</span></code><span class="koboSpan" id="kobo.1707.1"> method. </span><span class="koboSpan" id="kobo.1707.2">For instance, we can set a default precision for all decimal properties:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1708.1">protected</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1709.1">override</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1710.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1711.1">ConfigureConventions</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1712.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1713.1">    ModelConfigurationBuilder configurationBuilder</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1714.1">)</span></span><span class="koboSpan" id="kobo.1715.1">
{
      configurationBuilder.Properties&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1716.1">decimal</span></span><span class="koboSpan" id="kobo.1717.1">&gt;()
          .HavePrecision(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1718.1">10</span></span><span class="koboSpan" id="kobo.1719.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1720.1">3</span></span><span class="koboSpan" id="kobo.1721.1">);
          ...
</span><span class="koboSpan" id="kobo.1721.2">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1722.1">Specifying a default maximum length for all string properties is also useful:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1723.1">protected</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1724.1">override</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1725.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1726.1">ConfigureConventions</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1727.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1728.1">    ModelConfigurationBuilder configurationBuilder</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1729.1">)</span></span><span class="koboSpan" id="kobo.1730.1">
{
      configurationBuilder.Properties&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1731.1">decimal</span></span><span class="koboSpan" id="kobo.1732.1">&gt;()
          .HavePrecision(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1733.1">10</span></span><span class="koboSpan" id="kobo.1734.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1735.1">3</span></span><span class="koboSpan" id="kobo.1736.1">);
      configurationBuilder.Properties&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1737.1">string</span></span><span class="koboSpan" id="kobo.1738.1">&gt;()
          .HaveMaxLength(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1739.1">128</span></span><span class="koboSpan" id="kobo.1740.1">);
       ...
</span><span class="koboSpan" id="kobo.1740.2">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1741.1">Another interesting feature that was gradually introduced in the last versions of Entity Framework Core is the mapping of JSON database columns. </span><span class="koboSpan" id="kobo.1741.2">In particular, JSON data contained in a single JSON column can be queried, and the JSON objects mapped to .NET types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1742.1">Suppose that an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1743.1">Author</span></code><span class="koboSpan" id="kobo.1744.1"> class that must be mapped to a database table has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1745.1">Contact</span></code><span class="koboSpan" id="kobo.1746.1"> property containing a complex object, and suppose we would like to store this object in a database JSON column of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1747.1">Author</span></code><span class="koboSpan" id="kobo.1748.1"> table. </span><span class="koboSpan" id="kobo.1748.2">We can do it with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1749.1">OwnsOne</span></code><span class="koboSpan" id="kobo.1750.1"> configuration method, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1751.1">modelBuilder.Entity&lt;Author&gt;().OwnsOne(
            author =&gt; author.Contact, ownedNavigationBuilder =&gt;
            {
                ownedNavigationBuilder.ToJson();
            });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1752.1">After this </span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.1753.1">configuration, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1754.1">contact</span></code><span class="koboSpan" id="kobo.1755.1"> object can be queried as a standard navigation property:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1756.1"> context.Authors
  .Where(m =&gt; m.Contact.Email == searchEmail).FirstOrDefaultAsync();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1757.1">We can recursively also map sub-objects contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1758.1">contact</span></code><span class="koboSpan" id="kobo.1759.1"> object, such as a collection of addresses, but in this case, we must use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1760.1">OwnsMany</span></code><span class="koboSpan" id="kobo.1761.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1762.1">modelBuilder.Entity&lt;Author&gt;().OwnsOne(
            author =&gt; author.Contact, ownedNavigationBuilder =&gt;
            {
                ownedNavigationBuilder.ToJson();
		  ownedNavigationBuilder.OwnsMany(
			contactDetails =&gt; contactDetails.Addresses);
            });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1763.1">After that, the nested Addresses JSON collection can also be queried with the usual LINQ syntax:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1764.1">context.Authors
  .Where(m =&gt; m.Contact.Addresses.Any()).FirstOrDefaultAsync();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1765.1">The above query returns all authors with a nonempty addresses list.</span></p>
<h1 class="heading-1" id="_idParaDest-282"><span class="koboSpan" id="kobo.1766.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1767.1">In this chapter, we looked at the essentials of ORM basics and why they are so useful. </span><span class="koboSpan" id="kobo.1767.2">Then, we described Entity Framework Core. </span><span class="koboSpan" id="kobo.1767.3">In particular, we discussed how to configure database mappings with class annotations and other declarations and commands that are included in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1768.1">DbContext</span></code><span class="koboSpan" id="kobo.1769.1"> subclasses, and in configuration classes associated with each entity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1770.1">Then, we discussed how to create data structures for improving ORM performance and how to automatically create and update the physical database with the help of migrations, as well as how to query and pass updates to the database through Entity Framework Core. </span><span class="koboSpan" id="kobo.1770.2">Finally, we learned how to pass direct SQL commands and transactions through Entity Framework Core, as well as how to deploy a data layer based on Entity Framework Core.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1771.1">This chapter also reviewed some advanced features that were introduced in the latest Entity Framework Core releases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1772.1">In the next chapter, we move on to microservices orchestrators and will learn how to deploy and manage microservices on Kubernetes.</span></p>
<h1 class="heading-1" id="_idParaDest-283"><span class="koboSpan" id="kobo.1773.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1774.1">How does Entity Framework Core adapt to several different database engines?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1775.1">How are primary keys declared in Entity Framework Core?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1776.1">How is a string field’s length declared in Entity Framework Core?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1777.1">How are indexes declared in Entity Framework Core?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1778.1">How are relations declared in Entity Framework Core?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1779.1">What are the two important migration commands?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1780.1">By default, are related entities loaded by LINQ queries?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1781.1">Is it possible to return database data in a class instance that isn’t a database entity? </span><span class="koboSpan" id="kobo.1781.2">If yes, how?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1782.1">How are migrations applied in production and staging?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-284"><span class="koboSpan" id="kobo.1783.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1784.1">More details about migration commands can be found at </span><a href="https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index"><span class="url"><span class="koboSpan" id="kobo.1785.1">https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index</span></span></a><span class="koboSpan" id="kobo.1786.1"> and the other links contained there</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1787.1">More details about Entity Framework Core compiled models can be found in the official Microsoft documentation: </span><a href="https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/whatsnew#compiled-models"><span class="url"><span class="koboSpan" id="kobo.1788.1">https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/whatsnew#compiled-models</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1789.1">More details about Entity Framework Core can be found in the official Microsoft documentation: </span><a href="https://docs.microsoft.com/en-us/ef/core/"><span class="url"><span class="koboSpan" id="kobo.1790.1">https://docs.microsoft.com/en-us/ef/core/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1791.1">An exhaustive set of examples of complex LINQ queries can be found here: </span><a href="https://learn.microsoft.com/en-us/samples/dotnet/try-samples/101-linq-samples/ "><span class="url"><span class="koboSpan" id="kobo.1792.1">https://learn.microsoft.com/en-us/samples/dotnet/try-samples/101-linq-samples/</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1793.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1794.1">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8"><span class="url"><span class="koboSpan" id="kobo.1795.1">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1796.1"><img alt="" role="presentation" src="../Images/QR_Code175081751210902046.png"/></span></p>
</div>
</body></html>