<html><head></head><body>
		<div><p><a id="_idTextAnchor045"/></p>
			<h1 id="_idParaDest-51"><em class="italic"><a id="_idTextAnchor046"/>Chapter 3</em>: Developing UI with the Unity UI System</h1>
			<p>The UI is very important for a game, and Unity offers three different UI solutions for game developers. They are the <strong class="bold">Immediate Mode Graphical User Interface </strong>(<strong class="bold">IMGUI)</strong>, the <strong class="bold">Unity UI</strong> (<strong class="bold">uGUI</strong>) package, and the <strong class="bold">UI Toolkit</strong>. IMGUI is a relatively old UI solution in Unity and it is not recommended for building a runtime UI. The UI Toolkit is the latest UI solution; however, it is still missing some features you can find in the uGUI package and IMGUI. The uGUI package is a mature UI solution in Unity that is widely used in the game industry. Therefore, this chapter will introduce how to use uGUI to develop the UI of your game.</p>
			<p>We will cover the following key topics in this chapter:</p>
			<ul>
				<li>C# scripts and common UI elements in Unity</li>
				<li>C# scripts and the UI Event System in Unity</li>
				<li>The <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) pattern and the UI</li>
				<li>Performance tips to increase performance of the UI</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor047"/>C# scripts and common UI components in Unity</h1>
			<p>uGUI has<a id="_idIndexMarker248"/> been provided as a built-in package in the Unity Editor since Unity 2019; therefore, we can see the content of the uGUI package directly in the <strong class="bold">Project</strong> window, which also<a id="_idIndexMarker249"/> includes the C# source code.</p>
			<div><div><img src="img/Figure_3.1_B17146.jpg" alt="Figure 3.1 – The uGUI package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The uGUI package</p>
			<p>As we mentioned in the <a id="_idIndexMarker250"/>previous chapter, the Unity development workflow is primarily built around the structure of components. uGUI is no exception. It is a <code>GameObject</code> with a set of components.</p>
			<p>As shown in <em class="italic">Figure 3.1</em>, we can find the C# source code<a id="_idIndexMarker252"/> of many commonly used UI elements, such as <strong class="bold">Text</strong>, <strong class="bold">Slider</strong>, and <strong class="bold">Toggle</strong>. However, some UI components are implemented using C++ code inside the engine, such as <strong class="bold">Canvas</strong>, and the code of such components cannot be viewed from within the Unity Editor.</p>
			<p>In this section, we <a id="_idIndexMarker253"/>will introduce the commonly used UI components in Unity. We can divide these components into the following four categories, according to their functions:</p>
			<ul>
				<li><code>Canvas</code></li>
				<li><code>Image and Raw Image</code></li>
				<li><code>Text</code></li>
				<li><code>Selectable UI components</code></li>
			</ul>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor048"/>Canvas</h2>
			<p><strong class="bold">Canvas</strong> is the <a id="_idIndexMarker254"/>most <a id="_idIndexMarker255"/>basic and important UI component of uGUI. To understand how to use uGUI correctly and efficiently, it is essential to understand <strong class="bold">Canvas</strong> first.</p>
			<p><strong class="bold">Canvas</strong> is the component used to render UI elements in uGUI. All UI elements should be located inside the area of a canvas, which is very simple to create in a scene.</p>
			<div><div><img src="img/Figure_3.2_B17146.jpg" alt="Figure 3.2 – Creating a canvas from the Hierarchy window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Creating a canvas from the Hierarchy window</p>
			<p>As shown in <em class="italic">Figure 3.2</em>, you <a id="_idIndexMarker256"/>can create a new canvas as follows:</p>
			<ol>
				<li>Right-click in the <strong class="bold">Hierarchy</strong> window to open the menu.</li>
				<li>Select <strong class="bold">UI</strong> | <strong class="bold">Canvas</strong>. </li>
			</ol>
			<p>In addition to creating a new <strong class="bold">Canvas</strong> object from the <strong class="bold">Hierarchy</strong> window, we can also create a new <strong class="bold">Canvas</strong> object by clicking <strong class="bold">GameObject</strong> | <strong class="bold">UI</strong> | <strong class="bold">Canvas</strong>.</p>
			<div><div><img src="img/Figure_3.3_B17146.jpg" alt="Figure 3.3 – Creating a canvas from the GameObject menu&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Creating a canvas from the GameObject menu</p>
			<p>As you<a id="_idIndexMarker257"/> can see in <em class="italic">Figure 3.2</em> and <em class="italic">Figure 3.3</em>, we can also create other different UI elements from these menus, such as <strong class="bold">Text</strong>, <strong class="bold">Button</strong>, <strong class="bold">Image</strong>, and <strong class="bold">Slider</strong>. Since all UI elements are the children of <strong class="bold">Canvas</strong>, if you want to create a new UI element directly and there is no canvas, a new <strong class="bold">Canvas</strong> object will be created automatically. The new UI element will be a child object of the <strong class="bold">Canvas</strong> object parent.</p>
			<div><div><img src="img/Figure_3.4_B17146.jpg" alt="Figure 3.4 – A Canvas object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – A Canvas object</p>
			<p>Once a <strong class="bold">Canvas</strong> object <a id="_idIndexMarker258"/>is created, we can see that there is not only a <strong class="bold">Canvas </strong>component attached to this GameObject but also <strong class="bold">Rect Transform</strong>, <strong class="bold">Canvas Scaler</strong>, and <strong class="bold">Graphic Raycaster</strong> components. As mentioned previously, <strong class="bold">Canvas</strong> is the component used to render UI elements, so all UI components must be children of Canvas; otherwise, they will not be rendered by Unity.</p>
			<p>We will explore them separately in order.</p>
			<h3>The Canvas component</h3>
			<p>If you <a id="_idIndexMarker259"/>select the <strong class="bold">Canvas</strong> object in the scene, you may be surprised to find that its position is strange. By default, it is not in the field of view of <strong class="bold">Main Camera</strong>. </p>
			<div><div><img src="img/Figure_3.5_B17146.jpg" alt="Figure 3.5 – A Canvas object with the Screen Space - Overlay render mode in the scene&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – A Canvas object with the Screen Space - Overlay render mode in the scene</p>
			<p>This is because the <strong class="bold">Canvas</strong> component attached to this GameObject provides three different <strong class="bold">render modes</strong>, as<a id="_idIndexMarker260"/> follows:</p>
			<ul>
				<li><strong class="bold">Screen Space - Overlay</strong></li>
				<li><strong class="bold">Screen Space - Camera</strong></li>
				<li><strong class="bold">World Space</strong></li>
			</ul>
			<div><div><img src="img/Figure_3.6_B17146.jpg" alt="Figure 3.6 – Render modes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Render modes</p>
			<p>The <strong class="bold">Screen Space - Overlay</strong> render mode<a id="_idIndexMarker261"/> places UI elements on the screen that are rendered on top of the scene. Therefore, the cameras located in the scene used to render the game scene will not affect the rendering of the UI. This is the default render mode provided by the <strong class="bold">Canvas</strong> component.</p>
			<p>As the <a id="_idIndexMarker262"/>name implies, the <strong class="bold">Screen Space - Camera</strong> render <a id="_idIndexMarker263"/>mode is somewhat similar to the previous one. However, as can be seen from the name, the second render mode will be affected by the camera. </p>
			<div><div><img src="img/Figure_3.7_B17146.jpg" alt="Figure 3.7 – The Screen Space - Camera render mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – The Screen Space - Camera render mode</p>
			<p>As you can see in <em class="italic">Figure 3.7</em>, if the <strong class="bold">Screen Space - Camera</strong> render mode is selected, we need to specify a camera for this canvas and set a distance between them. Furthermore, if we still select this canvas in the scene, we will find that it has been moved into the field of view of this particular camera.</p>
			<div><div><img src="img/Figure_3.8_B17146.jpg" alt="Figure 3.8 – A Canvas object with the Screen Space - Camera render mode in the scene&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – A Canvas object with the Screen Space - Camera render mode in the scene</p>
			<p>In this case, the<a id="_idIndexMarker264"/> UI elements are rendered by this camera, which <a id="_idIndexMarker265"/>means that the camera settings affect the appearance of the UI. This is different from the <strong class="bold">Screen Space - Overlay</strong> render mode.</p>
			<p><em class="italic">Figure 3.9</em> shows that when the <strong class="bold">Field of View</strong> value of this camera is changed from 100 to 30, the game scene and the UI have changed:</p>
			<div><div><img src="img/Figure_3.9_B17146.jpg" alt="Figure 3.9 – The field of view (FoV) of the camera is 100 in the upper half and 30 in the lower half&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – The field of view (FoV) of the camera is 100 in the upper half and 30 in the lower half</p>
			<p>The last <a id="_idIndexMarker266"/>render mode is <strong class="bold">World Space</strong>. In this mode, the <a id="_idIndexMarker267"/>canvas will work like any other GameObject in the scene. The biggest difference between this mode and the <strong class="bold">Screen Space - Camera</strong> render mode is that we can manually adjust the size, position, and even rotation angle of the canvas, just like a normal GameObject.</p>
			<p>As shown in <em class="italic">Figure 3.10</em>, we can use the <strong class="bold">Rect Transform</strong> component of this <strong class="bold">Canvas</strong> object to <a id="_idIndexMarker268"/>adjust its <strong class="bold">Width</strong> and <strong class="bold">Rotation</strong> values:</p>
			<div><div><img src="img/Figure_3.10_B17146.jpg" alt="Figure 3.10 – The World Space render mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – The World Space render mode</p>
			<p><em class="italic">Figure 3.11</em> shows the <strong class="bold">Canvas</strong> object<a id="_idIndexMarker269"/> in the scene after manually setting the <strong class="bold">Width</strong> and <strong class="bold">Rotation</strong> values:</p>
			<div><div><img src="img/Figure_3.11_B17146.jpg" alt="Figure 3.11 – A Canvas object with the World Space render mode in the scene&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – A Canvas object with the World Space render mode in the scene</p>
			<p>Here, we <a id="_idIndexMarker270"/>use the <strong class="bold">RectTransform</strong> component<a id="_idIndexMarker271"/> to set the size of the canvas. Every UI object will contain a <strong class="bold">RectTransform</strong> component, just like every normal GameObject will contain a Transform component. Next, we will explore the <strong class="bold">RectTransform</strong> component.</p>
			<h3>The Rect Transform component</h3>
			<p>The <strong class="bold">Rect Transform</strong> component <a id="_idIndexMarker272"/>is similar to the regular <strong class="bold">Transform</strong> component. The biggest difference is that the former is used for UI elements instead of regular GameObjects. When a new UI element object is created, the <strong class="bold">Rect Transform</strong> component will be automatically attached to it. </p>
			<p>Looking at this component, you can see some properties that can be seen on the <strong class="bold">Transform</strong> component, such as <strong class="bold">Position</strong>, <strong class="bold">Rotation</strong>, and <strong class="bold">Scale</strong>. There are also some unique properties.</p>
			<div><div><img src="img/Figure_3.12_B17146.jpg" alt="Figure 3.12 – A Rect Transform component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – A Rect Transform component</p>
			<p>These unique<a id="_idIndexMarker273"/> ones are <strong class="bold">Anchor</strong> and <strong class="bold">Pivot</strong>. We will discuss these in turn.</p>
			<h4>Anchors</h4>
			<p>The<a id="_idIndexMarker274"/> anchors are numerical values indicating the position of the four corners of the area as seen from the <code>AnchorMin.x</code> and <code>AnchorMin.y</code>, and the upper right is represented by <code>AnchorMax.x</code> and <code>AnchorMax.y</code>. By default, the lower left is 0.5 and 0.5, and the upper right is also 0.5 and 0.5, centered relative to the parent, as shown in <em class="italic">Figure 3.12</em>.</p>
			<p>We can directly modify the value of anchors – for example, we can change the lower-left corner from 0.5 and 0.5 to 0 and 0, so that the lower-left corner of the parent and child are the same. Then, we change the upper-right corner from 0.5 and 0.5 to 0.5 and 1, which means that the position of the upper-right corner of the child is half of the <em class="italic">x</em> axis position of the upper-right corner of the parent. The result is shown in <em class="italic">Figure 3.13</em>:</p>
			<div><div><img src="img/Figure_3.13_B17146.jpg" alt="Figure 3.13 – Modifying the anchors&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Modifying the anchors</p>
			<p>Anchors are<a id="_idIndexMarker275"/> very useful when developing the UI in Unity. For example, if you want to display the UI at the top of the screen, such as a title, you need to specify the distance from the top of the parent. If you want to display the UI at the bottom of the screen, such as a footer, you need to specify the distance from the bottom of the parent. </p>
			<p>In order to make it easier for developers to use anchors, Unity provides<a id="_idIndexMarker276"/> some anchor presets, as shown in <em class="italic">Figure 3.14</em>:</p>
			<div><div><img src="img/Figure_3.14_B17146.jpg" alt="Figure 3.14 – Anchor Presets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Anchor Presets</p>
			<h4>Pivot</h4>
			<p>The <strong class="bold">Pivot</strong> point<a id="_idIndexMarker277"/> is the origin of this rectangle area. The value of the <strong class="bold">Pivot</strong> point is specified in normalized values between 0 and 1. When the UI element is scaled or rotated, it will scale or rotate around that point: </p>
			<div><div><img src="img/Figure_3.15_B17146.jpg" alt="Figure 3.15 – Rotate 45 degrees along the z axis around the center and &#13;&#10;45 degrees along the z axis around the upper-right corner&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Rotate 45 degrees along the <em class="italic">z</em> axis around the center and 45 degrees along the <em class="italic">z</em> axis around the upper-right corner</p>
			<p><em class="italic">Figure 3.15</em> shows a 45-degree rotation along the <em class="italic">z</em> axis around the center, which has a <strong class="bold">Pivot</strong> point value<a id="_idIndexMarker278"/> of 0.5 and 0.5, and a 45-degree rotation along the <em class="italic">z</em> axis around the upper-right corner, which has a <strong class="bold">Pivot</strong> point value of 1 and 1.</p>
			<h3>The Canvas Scaler component</h3>
			<p>Along<a id="_idIndexMarker279"/> with the <strong class="bold">Canvas</strong> component, a <strong class="bold">Canvas Scaler</strong> component is also created automatically. The <strong class="bold">Canvas Scaler</strong> component is used to control the overall scale and pixel density of UI elements inside a canvas. By using <strong class="bold">Canvas Scaler</strong>, we can implement a resolution-independent UI layout:</p>
			<div><div><img src="img/Figure_3.16_B17146.jpg" alt="Figure 3.16 – The Canvas Scaler component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – The Canvas Scaler component</p>
			<p>There are three <strong class="bold">UI Scale Mode</strong> types<a id="_idIndexMarker280"/> provided by a <strong class="bold">Canvas Scaler</strong> component: </p>
			<ul>
				<li><strong class="bold">Constant Pixel Size</strong></li>
				<li><strong class="bold">Scale With Screen Size</strong></li>
				<li><strong class="bold">Constant Physical Size</strong></li>
			</ul>
			<p>If the canvas render mode is <strong class="bold">ScreenSpace - Overlay</strong> or <strong class="bold">ScreenSpace - Camera</strong>, then we can set the UI Scale Mode. On the other hand, if the canvas render mode is <strong class="bold">World Space</strong>, the UI Scale Mode cannot be modified. Next, we will introduce these three different modes.</p>
			<p><strong class="bold">Constant Pixel Size</strong> is the<a id="_idIndexMarker281"/> default UI Scale Mode. In this mode, the size of the UI elements will retain the same size in pixels regardless of screen size.</p>
			<div><div><img src="img/Figure_3.17_B17146.jpg" alt="Figure 3.17 – The Hello World UI text displayed in different screen sizes &#13;&#10;(1920 x 1080 in the upper half and 3840 x 2160 in the lower half)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.17 – The Hello World UI text displayed in different screen sizes (1920 x 1080 in the upper half and 3840 x 2160 in the lower half)</p>
			<p>As shown in <em class="italic">Figure 3.17</em>, a <strong class="bold">Hello World</strong> UI text will retain its own size in pixels. When the screen resolution is relatively low (<em class="italic">1920 x 1080</em>), the text will be displayed larger. When at a higher screen resolution (<em class="italic">3840 x 2160</em>), the text will be displayed smaller.</p>
			<p>If you want to keep <a id="_idIndexMarker282"/>the UI elements displayed consistently under different screen resolutions, the <strong class="bold">Scale With Screen Size</strong> mode is an ideal option.</p>
			<div><div><img src="img/Figure_3.18_B17146.jpg" alt="Figure 3.18 – The Scale With Screen Size mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – The Scale With Screen Size mode</p>
			<p>If <strong class="bold">UI Scale Mode</strong> is set<a id="_idIndexMarker283"/> to <strong class="bold">Scale With Screen Size</strong>, the position and size of the UI elements will be specified according to the value of pixels in the <strong class="bold">Reference Resolution</strong> properties, as shown in <em class="italic">Figure 3.18</em>.</p>
			<p>If the current screen resolution is greater than the reference resolution, the canvas will be scaled to fit the screen resolution. Conversely, if the current screen resolution is less than the reference resolution, the canvas will shrink to fit the screen resolution.</p>
			<p>If the screen resolution ratio is the same as the reference resolution ratio, it is very easy to scale and shrink the UI elements. But when the screen resolution ratio is different from the reference resolution ratio, scaling the canvas will distort it. In order to avoid this situation, the resolution of the canvas will also depend on the setting of <strong class="bold">Screen Match Mode</strong>, which you can also see in <em class="italic">Figure 3.18</em>. By default, the <strong class="bold">Screen Match Mode</strong> setting is <strong class="bold">Match Width or Height</strong>, which allows you to scale the canvas area with the width or height as the reference, or a value in between.</p>
			<p>When <strong class="bold">UI Scale Mode</strong> is <a id="_idIndexMarker284"/>set to <strong class="bold">Constant Physical Size</strong>, the position and size of UI elements are specified in physical units such as <em class="italic">millimeters</em> and <em class="italic">inches</em>.</p>
			<div><div><img src="img/Figure_3.19_B17146.jpg" alt="Figure 3.19 – The Constant Physical Size mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – The Constant Physical Size mode</p>
			<p>In addition to the <strong class="bold">Canvas Scaler</strong> component, another component is also automatically created, which we will take a look at next.</p>
			<h3>The Graphic Raycaster component</h3>
			<p>As the name<a id="_idIndexMarker285"/> suggests, the <strong class="bold">Graphic Raycaster</strong> component is used to perform raycasting against a list of UI elements within a canvas to determine which of the UI elements has been hit. So it can translate the player's input into UI events. It should be noted that there needs to be an <strong class="bold">Event System</strong> component in the scene for <strong class="bold">Graphic Raycaster</strong> to work properly. About the <strong class="bold">Event System</strong> component, we will introduce it later in the section "<em class="italic">C# scripts and the UI Event System in Unity</em>".</p>
			<p>This is useful when you need to determine whether the cursor is over UI elements in the scene, such as UI text or UI images. For example, say you want the player to be able to drag and drop a UI image into your game to change its position, then you have to know whether the player's cursor is over the UI image and get data about the cursor movement when the drag occurs. In this case, you need to create a script that implements the <code>IPointerDownHandler</code> and <code>IDragHandler</code> interfaces defined in the <code>UnityEngine.EventSystems</code> namespace, meaning that you can get events when the player clicks and drags the image, as shown here:</p>
			<pre>using UnityEngine;
<strong class="bold">using UnityEngine.EventSystems;</strong>
public class DragAndDropExample : MonoBehaviour,
  <strong class="bold">IPointerDownHandler</strong>, <strong class="bold">IDragHandler</strong>
{
    private RectTransform _rectTransform;
    public void OnPointerDown(<strong class="bold">PointerEventData</strong> eventData)
    {
        Debug.Log("This UI image is clicked!!!");
        _rectTransform = GetComponent&lt;RectTransform&gt;();
    }
    public void OnDrag(<strong class="bold">PointerEventData</strong> eventData)
    {
        Debug.Log("This UI image is being dragged!!!");
        
            if (RectTransformUtility
             .ScreenPointToWorldPointInRectangle
             (_rectTransform, eventData.position,
             eventData.pressEventCamera, 
             out var cursorPos))
            {
                  _rectTransform.position = cursorPos;
            }
    }
}</pre>
			<p>Let's break <a id="_idIndexMarker286"/>down the code as follows:</p>
			<ul>
				<li>We add the <code>UnityEngine.EventSystems</code> namespace with the <code>using</code> keyword to get events related to clicking and dragging UI elements.</li>
				<li>The <code>DragAndDropExample</code> class implements the two interfaces, namely, <code>IPointerDownHandler</code> and <code>IDragHandler</code>. <ul><li>Specifically, we implement the <code>OnPointerDown</code> method in the <code>IPointerDownHandler</code> interface, which will be called when the UI element is clicked.</li><li>And we implemented the <code>OnDrag</code> method in the <code>IDragHandler</code> interface. When a drag occurs, this method will be called every time the cursor is moved.</li></ul></li>
				<li>In the<a id="_idIndexMarker287"/> implementation of the <code>OnPointerDown</code> method, which takes <code>PointerEventData</code> as an argument, gets an instance of the <code>RectTransform</code> component, and assigns it to the <code>_rectTransform</code> field.</li>
				<li>In the implementation of the <code>OnDrag</code> method, which also takes <code>PointerEventData</code> as an argument, gets the cursor position, and modifies the <code>position</code> property of the <code>_rectTransform</code> field to move the UI element.</li>
			</ul>
			<p>In order for this script to work, you need to attach the script to the UI element in the scene that you want to drag and drop.</p>
			<div><div><img src="img/Figure_3.20_B17146.jpg" alt="Figure 3.20 – Dragging and dropping a UI image &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.20 – Dragging and dropping a UI image </p>
			<p><em class="italic">Figure 3.20</em> shows <a id="_idIndexMarker288"/>the UI image drag and drop interaction based on the <strong class="bold">Graphic Raycaster</strong> component.</p>
			<p>The components described previously are automatically created when a <strong class="bold">Canvas</strong> object is created. Next, we will introduce other UI elements.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor049"/>Image</h2>
			<p>Displaying images is <a id="_idIndexMarker289"/>an important function of the UI. There are two types of components provided by uGUI that display images – the <strong class="bold">Image</strong> component and the <strong class="bold">Raw Image</strong> component. </p>
			<p>We will now explain these features and how to use them properly.</p>
			<h3>The Image component</h3>
			<p>You can use<a id="_idIndexMarker290"/> the <strong class="bold">Image</strong> component to display an image on your UI.</p>
			<div><div><img src="img/Figure_3.21_B17146.jpg" alt="Figure 3.21 – Creating a new image&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.21 – Creating a new image</p>
			<p>As shown<a id="_idIndexMarker291"/> in <em class="italic">Figure 3.21</em>, you can create a new image as follows:</p>
			<ol>
				<li value="1">Right-click in the <strong class="bold">Hierarchy</strong> window to open the menu.</li>
				<li>Select <strong class="bold">UI</strong> &gt; <strong class="bold">Image</strong>.</li>
			</ol>
			<p>If you want to create a <a id="_idIndexMarker292"/>background image for your game UI, you can also select <strong class="bold">UI</strong> &gt; <strong class="bold">Panel</strong>. The panel is nothing but an image. </p>
			<div><div><img src="img/Figure_3.22_B17146.jpg" alt="Figure 3.22 – The Image component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.22 – The Image component</p>
			<p>In this case, we<a id="_idIndexMarker293"/> create a panel as the background. As you can see in <em class="italic">Figure 3.22</em>, here we specify a texture called <strong class="bold">SF Background</strong> as the source image of this <strong class="bold">Image</strong> component. It should be noted that the texture used by the <strong class="bold">Image</strong> component must be set to the Sprite type when imported into Unity.</p>
			<div><div><img src="img/Figure_3.23_B17146.jpg" alt="Figure 3.23 – Texture Import Settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.23 – Texture Import Settings</p>
			<p><strong class="bold">Texture Type</strong> can <a id="_idIndexMarker294"/>be set in the texture's <strong class="bold">Import Settings</strong> panel, as shown in <em class="italic">Figure 3.23</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Sprites<a id="_idIndexMarker295"/> are 2D graphic objects used for the UI and other elements of 2D gameplay.</p>
			<p>The advantage<a id="_idIndexMarker296"/> of using sprites as an image source is that the corners will not be stretched or distorted when resizing the sprites.</p>
			<div><div><img src="img/Figure_3.24_B17146.jpg" alt="Figure 3.24 – The Sprite Editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.24 – The Sprite Editor</p>
			<p>This is because <strong class="bold">Sprite Editor</strong> in Unity provides the<a id="_idIndexMarker297"/> option of <strong class="bold">9-slicing</strong> the<a id="_idIndexMarker298"/> image, which divides the image into nine regions. As shown in <em class="italic">Figure 3.24</em>, in this case, when the image is resized, the corners of the image will remain the same. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">9-slicing is a common technique in UI implementation. The main advantage of using 9-slicing is that it can handle the stretching of the image very well. Once an image is stretched, there will be problems such as distortion and blurring, but some parts of the image can be stretched. For example, a UI background frame, the middle part of which is usually a solid color, can be stretched, but the four corners of the image may have some special patterns that cannot be stretched. At this time, we can use the 9-slicing technique to divide the whole image into nine grids, and each of the four corners is in a grid. Then, we can only stretch and enlarge the middle part of the image and keep the four corners as they are.</p>
			<p>Therefore, in most cases, using the <strong class="bold">Image</strong> component to display UI images is the preferred choice.</p>
			<h3>The Raw Image component</h3>
			<p>The <strong class="bold">Raw Image</strong> component<a id="_idIndexMarker299"/> is another component used to<a id="_idIndexMarker300"/> display images on the game UI.</p>
			<div><div><img src="img/Figure_3.25_B17146.jpg" alt="Figure 3.25 – Creating a new raw image&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.25 – Creating a new raw image</p>
			<p>As shown in <em class="italic">Figure 3.25</em>, you can create a new image, as follows:</p>
			<ol>
				<li value="1">Right-click in the <strong class="bold">Hierarchy</strong> window to open the menu. </li>
				<li>Select <strong class="bold">UI</strong> &gt; <strong class="bold">Raw Image</strong>.</li>
			</ol>
			<p>The difference between the <strong class="bold">Raw Image</strong> component and the <strong class="bold">Image</strong> component is that the source of an <strong class="bold">Image</strong> component must be a <strong class="bold">Sprite</strong> type. Conversely, <strong class="bold">Raw Image</strong> accepts any texture. Also, the function of the <strong class="bold">Raw Image</strong> component is simpler than an <strong class="bold">Image</strong> component, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.26_B17146.jpg" alt="Figure 3.26 – A Raw Image component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.26 – A Raw Image component</p>
			<p>The following code<a id="_idIndexMarker301"/> snippet shows how to modify the image displayed by the <strong class="bold">Image</strong> and <strong class="bold">Raw Image</strong> components:</p>
			<pre>using UnityEngine;
using UnityEngine.UI;
public class ImageAndRawImage : MonoBehaviour
{
[SerializeField] 
private Image _image;
[SerializeField] 
private Sprite _sprite;
[SerializeField] 
private RawImage _rawImage;
[SerializeField] 
private Texture _texture;
    void Start()
    {
        _image.sprite = _sprite;
        _rawImage.texture = _texture;
    }
}</pre>
			<p>It should be <a id="_idIndexMarker302"/>noted that in order to be able to access UI-related classes in the code, we need to use the <code>UnityEngine.UI</code> namespace.</p>
			<p>Another important part of the UI is <strong class="bold">text</strong>. Next, let's explore the two components provided by uGUI to display text.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor050"/>Text</h2>
			<p>The simplest way to display <a id="_idIndexMarker303"/>characters in uGUI is to use the <strong class="bold">Text</strong> component. However, it is also troublesome to adjust the spacing between characters and express decorations with <strong class="bold">Text</strong> alone. <strong class="bold">TextMeshPro</strong> is <a id="_idIndexMarker304"/>another option, which provides gorgeous character expression. In this section, we will explore the <strong class="bold">Text</strong> and <strong class="bold">TextMeshPro</strong> components in turn.</p>
			<h3>The Text component</h3>
			<p>The <strong class="bold">Text</strong> component <a id="_idIndexMarker305"/>is a component commonly used to display UI text since the early days of uGUI. Creating <a id="_idIndexMarker306"/>text for the game UI is very simple; just follow these step:</p>
			<ol>
				<li value="1">Right-click in the <strong class="bold">Hierarchy</strong> window to open the menu. </li>
				<li>Select <strong class="bold">UI</strong> &gt; <strong class="bold">Text</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_3.27_B17146.jpg" alt="Figure 3.27 – Creating text&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.27 – Creating text</p>
			<p>A <strong class="bold">Text</strong> object will<a id="_idIndexMarker307"/> be created in the canvas; we can find it in the <strong class="bold">Scene</strong> view of the Unity Editor, as shown in <em class="italic">Figure 3.28</em>:</p>
			<p class="figure-caption">   </p>
			<div><div><img src="img/Figure_3.28_B17146.jpg" alt="Figure 3.28 – Text in the Scene view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.28 – Text in the Scene view</p>
			<p>You can see that the<a id="_idIndexMarker308"/> text content is in a white frame, which represents the <strong class="bold">Rect Transform</strong> component attached to this <strong class="bold">Text</strong> object and identifies its size. If changing the font size causes the text content to exceed this white frame, the text content cannot be displayed. Therefore, remember to consider the <strong class="bold">Rect Transform</strong> component of <strong class="bold">Text</strong> when changing the font size.</p>
			<p>In addition to changing the font size, you can also change the font used or enable <strong class="bold">Rich Text</strong>. </p>
			<div><div><img src="img/Figure_3.29_B17146.jpg" alt="Figure 3.29 – The Text component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.29 – The Text component</p>
			<p>As you can<a id="_idIndexMarker309"/> see in <em class="italic">Figure 3.29</em>, if the <code>&lt;b&gt;&lt;/b&gt;, &lt;i&gt;&lt;/i&gt;,</code> and <code>&lt;color&gt;&lt;/color&gt;</code>, within the text to provide style changes to the text.</p>
			<p>However, the function provided by the <strong class="bold">Text</strong> component is relatively simple. When the <strong class="bold">Text</strong> component changes, the polygon used to display the text needs to be recalculated, resulting in graphic reconstruction, which can cause potential performance problems, and when displayed in high resolution, the text rendered by this component looks very blurry. Therefore, after the original <strong class="bold">Text</strong> component, Unity also provides another text solution for the UI. Next, we will introduce the <strong class="bold">TextMesh Pro</strong> component.</p>
			<h3>The TextMeshPro component</h3>
			<p><strong class="bold">TextMeshPro</strong> (<strong class="bold">TMP</strong>) is the ultimate<a id="_idIndexMarker310"/> text solution for the UI provided by Unity. It is a powerful mechanism for text rendering that can be used to replace the <strong class="bold">Text</strong> component. <strong class="bold">TextMesh Pro</strong> has been designed to take advantage <a id="_idIndexMarker311"/>of <strong class="bold">Signed Distance Field</strong> (<strong class="bold">SDF</strong>) rendering, allowing it to render text beautifully at any resolution. You can also create custom shaders for <strong class="bold">TextMesh Pro</strong> to get effects such as outlines and soft shadows.</p>
			<p>It should be noted that it is not included in the default <code>Unity UI</code> package, but is included in the <code>TextMeshPro</code> package. So if you can't find <strong class="bold">TextMesh Pro</strong> when creating UI text, then you should first check whether this package has been added to your project.</p>
			<div><div><img src="img/Figure_3.30_B17146.jpg" alt="Figure 3.30 – Creating a TextMeshPro object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.30 – Creating a TextMeshPro object</p>
			<p>Creating <strong class="bold">TextMeshPro</strong> text <a id="_idIndexMarker312"/>for the game UI is very simple; just follow these steps:</p>
			<ol>
				<li value="1">Right-click in the <strong class="bold">Hierarchy</strong> window to open the menu.</li>
				<li>Select <strong class="bold">UI</strong> &gt; <strong class="bold">Text</strong> &gt; <strong class="bold">TextMeshPro</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_3.31_B17146.jpg" alt="Figure 3.31 – The TextMeshPro component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.31 – The TextMeshPro component</p>
			<p>As shown<a id="_idIndexMarker313"/> in <em class="italic">Figure 3.31</em>, the text rendered by <strong class="bold">TextMeshPro</strong> is sharper than that rendered by the <strong class="bold">Text</strong> component. </p>
			<p>In addition to rendering the text sharper, <strong class="bold">TextMeshPro</strong> also provides improved control over text format and layout. As shown in <em class="italic">Figure 3.32</em>, you can directly change the style of the text through the editor. There are several common styles to choose from, such as <em class="italic">bold</em> and italics. Similarly, you can also use tags to modify the text style, just like the <strong class="bold">Text</strong> component, and features such as <strong class="bold">Spacing Options</strong>, <strong class="bold">Alignment</strong>, and <strong class="bold">Wrapping</strong>, can be used to control the text layout. </p>
			<p>In addition, you can also achieve more rendering effects, such as clicking the outline option of the shader to add outline effects to the text.</p>
			<div><div><img src="img/Figure_3.32_B17146.jpg" alt="Figure 3.32 – The TextMeshPro component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.32 – The TextMeshPro component</p>
			<p>Using TextMesh Pro to implement your UI text is a good choice.</p>
			<h2 id="_idParaDest-56">Selectable UI <a id="_idTextAnchor051"/>components</h2>
			<p>You can<a id="_idIndexMarker314"/> use <a id="_idIndexMarker315"/>selectable components in uGUI to handle interactions. These components include <strong class="bold">Button</strong>, <strong class="bold">Toggle</strong>, <strong class="bold">Slider</strong>, <strong class="bold">Dropdown</strong>, <strong class="bold">Input Field</strong>, and <strong class="bold">Scrollbar</strong>. In this section, we will mainly discuss the most commonly used component, namely, the <strong class="bold">Button</strong> component.</p>
			<h3>Button</h3>
			<p>Creating<a id="_idIndexMarker316"/> a <strong class="bold">Button</strong> element <a id="_idIndexMarker317"/>for the game UI is very simple; just follow these steps:</p>
			<ol>
				<li value="1">Right-click in the <strong class="bold">Hierarchy</strong> window to open the menu.</li>
				<li>Select <strong class="bold">UI</strong> &gt; <strong class="bold">Button - TextMeshPro</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_3.33_B17146.jpg" alt="Figure 3.33 – Creating a Button object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.33 – Creating a Button object</p>
			<p>As shown<a id="_idIndexMarker318"/> in <em class="italic">Figure 3.33</em>, there are two options to create<a id="_idIndexMarker319"/> a button in the menu, namely, <strong class="bold">Button</strong> and <strong class="bold">Button -TextMeshPro</strong>. Here, we select <strong class="bold">Button -TextMeshPro</strong> so that the text content on the button is rendered by <strong class="bold">TextMeshPro</strong>. </p>
			<div><div><img src="img/Figure_3.34_B17146.jpg" alt="Figure 3.34 – An Image component and a Button component are attached to the button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.34 – An Image component and a Button component are attached to the button</p>
			<p>Once a <a id="_idIndexMarker320"/>default<a id="_idIndexMarker321"/> button object is created, this object includes not only a <strong class="bold">Button</strong> component but also an <strong class="bold">Image</strong> component. This is because the <strong class="bold">Button</strong> component only provides the function of interacting with the user; it does not provide the function of graphic display. Therefore, the image of the button needs an <strong class="bold">Image</strong> component to display.</p>
			<h4>Selected states</h4>
			<p>The <code>Selectable</code> class, namely, <code>Normal</code>, <code>Highlighted</code>, <code>Pressed</code>, <code>Selected</code>, and <code>Disabled</code>, which are defined by an enumeration named <code>Selectable.SelectionState</code>. Therefore, as shown in <em class="italic">Figure 3.34</em>, there are five different colors in the <strong class="bold">Transition</strong> section corresponding to these five different selected states, which means that when the user interacts with this button, this button will provide different feedback according to the different states. </p>
			<h4>onClick</h4>
			<p>The important role <a id="_idIndexMarker323"/>of a button is to receive user clicks and trigger corresponding events. In Unity, it is very easy to set up button <code>onClick</code> events. You can either manually set up button <code>onClick</code> events in the editor or set button <code>onClick</code> events programmatically.</p>
			<p>In order to set up a new event to the button in the editor, we can click the <strong class="bold">+</strong> button at the bottom of the <strong class="bold">On Click ()</strong> section, as shown in <em class="italic">Figure 3.35</em>. This will create a new action.</p>
			<div><div><img src="img/Figure_3.35_B17146.jpg" alt="Figure 3.35 – Setting up a new onClick event in the editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.35 – Setting up a new onClick event in the editor</p>
			<p>We can also programmatically set the button <code>onClick</code> event; the following code shows how to do this:</p>
			<pre>using UnityEngine;
using <strong class="bold">UnityEngine.UI</strong>;
public class ButtonClickExample : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        var button = GetComponent&lt;Button&gt;();
        button.<strong class="bold">onClick.AddListener</strong>(() =&gt;
        {
            Debug.Log(You have clicked the button!);
        });
    }
}</pre>
			<p>In this <a id="_idIndexMarker324"/>section, we learned about commonly used UI components and got an understanding of uGUI, the UI solution provided by Unity. Next, we will explore the UI Event System in Unity. If there is no event system in the scene, UI elements such as buttons cannot interact with players, so it's an important topic.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor052"/>C# scripts and the UI Event System in Unity</h1>
			<p><strong class="bold">EventSystem</strong> is a <a id="_idIndexMarker325"/>mechanism for sending events to objects in a game that supports keyboards, mice, screen touches, and so on. EventSystem consists of multiple modules for sending events. If there is no <strong class="bold">EventSystem</strong> object in the scene, then, when creating a canvas, an <strong class="bold">EventSystem</strong> object will be automatically created along with it.</p>
			<div><div><img src="img/Figure_3.36_B17146.jpg" alt="Figure 3.36 – EventSystem&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.36 – EventSystem</p>
			<p>As<a id="_idIndexMarker326"/> shown in <em class="italic">Figure 3.36</em>, the <strong class="bold">Inspector</strong> window of the <strong class="bold">EventSystem</strong> object exposes very few functionalities. This is because EventSystem is designed as a manager for<a id="_idIndexMarker327"/> cooperation between<a id="_idIndexMarker328"/> various <strong class="bold">input modules</strong>. </p>
			<p>It should be noted that there can be, at most, one <strong class="bold">EventSystem</strong> object in a scene. If there are multiple <strong class="bold">EventSystem</strong> objects in the scene, a warning message will be displayed, as shown in <em class="italic">Figure 3.37</em>:</p>
			<div><div><img src="img/Figure_3.37_B17146.jpg" alt="Figure 3.37 – A warning message when there are multiple EventSystem objects&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.37 – A warning message when there are multiple EventSystem objects</p>
			<p>When the <a id="_idIndexMarker329"/>game is running, <strong class="bold">EventSystem</strong> will look for the <strong class="bold">InputModule</strong> component attached to the same GameObject. This is because <strong class="bold">InputModule</strong> is the class responsible for the main logic of <strong class="bold">EventSystem</strong>. We can also find the Input Module used in this case, as shown in <em class="italic">Figure 3.36</em>, namely, <strong class="bold">Standalone Input Module</strong>. Next, we will introduce Input Modules.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor053"/>Input Modules</h2>
			<p>Unity provides<a id="_idIndexMarker330"/> two built-in Input Modules, namely, the <strong class="bold">Standalone Input Module</strong> and the <strong class="bold">Touch Input Module</strong>. In the past, the Standalone Input Module <a id="_idIndexMarker331"/>was used <a id="_idIndexMarker332"/>for keyboards, mice, and game controllers, and the Touch Input Module<a id="_idIndexMarker333"/> was for touch panels<a id="_idIndexMarker334"/> such as smartphones. Nowadays, the Standalone Input Module is compatible with all platforms and the Touch Input Module has been deprecated, so you can treat the Input Module as the Standalone Input Module. </p>
			<p>The purpose of the Input Module is to map hardware-specific inputs (such as touches, joysticks, mice, and game controllers) to events sent through the messaging system. </p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor054"/>The new Input System package</h2>
			<p>In addition <a id="_idIndexMarker335"/>to this default built-in Input Module, Unity also provides a new, more powerful, flexible, and configurable <strong class="bold">Input System</strong> package.</p>
			<div><div><img src="img/Figure_3.38_B17146.jpg" alt="Figure 3.38 – The Input System package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.38 – The Input System package</p>
			<p>If you want <a id="_idIndexMarker336"/>to use the new input system, then you need to install the package from the Package Manager window, as shown in <em class="italic">Figure 3.38</em>. Moreover, a newly created <strong class="bold">EventSystem</strong> component will still use the legacy <strong class="bold">Standalone Input Module</strong> component by default, so you need to manually replace it with the new <strong class="bold">InputSystemUIInputModule</strong> component, as shown in <em class="italic">Figure 3.39</em>:</p>
			<div><div><img src="img/Figure_3.39_B17146.jpg" alt="Figure 3.39 – Replace with InputSystemUIInputModule&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.39 – Replace with InputSystemUIInputModule</p>
			<p>By reading this section, we learned that in order to ensure that the game UI can correctly respond to player input, an <strong class="bold">EventSystem</strong> component and an Input Module are necessary. Next, let's move on to discussing how to create UI in Unity using the Model-View-ViewModel (MVVM) pattern.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor055"/>The Model-View-ViewModel (MVVM) pattern and the UI</h1>
			<p>A common <a id="_idIndexMarker337"/>challenge in Unity development is to find elegant ways to decouple components from each other, especially when developing the <a id="_idIndexMarker338"/>UI because it involves UI logic and UI rendering. <strong class="bold">Model–View–ViewModel</strong> (<strong class="bold">MVVM</strong>) is a software architectural pattern that helps developers separate the <strong class="bold">ViewModel</strong>, which is the UI logic, from the <strong class="bold">View</strong>, which is the UI graphics. In this section, we will explore how to implement an MVVM pattern in Unity.</p>
			<div><div><img src="img/Figure_3.40_B17146.jpg" alt="Figure 3.40 – MVVM&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.40 – MVVM</p>
			<p>As its name suggests, MVVM consists of three parts:</p>
			<ul>
				<li><code>Database</code>, or <code>PlayerPrefs</code>, which stores player preferences in Unity, and so on.</li>
				<li><code>MonoBehaviour</code> and is attached to the UI object. Its main role is to manage UI elements and trigger UI events, but it does not implement any concrete UI logic itself.</li>
				<li><code>MonoBehaviour</code>. It does not need to consider what the UI looks like; it only needs to implement concrete logic.</li>
			</ul>
			<p>We can see that there are three parts in MVVM, so how should they be connected? Generally, we use two ways to connect them:</p>
			<ul>
				<li><code>ViewModel</code> and <code>View</code>. Elements bound to data will automatically reflect every data change. By using data binding, a <code>ViewModel</code> can modify the value of the UI control in the View. </li>
				<li><strong class="bold">Event-driven programming</strong>: This <a id="_idIndexMarker343"/>method is used to raise events from the View triggered by user actions, which are then processed by the ViewModel. </li>
			</ul>
			<p>There are some mature MVVM framework implementations for Unity, such as the <strong class="bold">Loxodon Framework</strong>, which<a id="_idIndexMarker344"/> is a lightweight <a id="_idIndexMarker345"/>MVVM framework built specifically to target Unity. You can find its repository on GitHub (<a href="https://github.com/vovgou/loxodon-framework">https://github.com/vovgou/loxodon-framework</a>) or add it to your project via Unity Asset Store directly.</p>
			<div><div><img src="img/Figure_3.41_B17146.jpg" alt="Figure 3.41 – Loxodon Framework&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.41 – Loxodon Framework</p>
			<p>Since our next example <a id="_idIndexMarker346"/>will use this framework, I recommend that you import this framework into your project first. After importing this framework, you should find it in the <code>Assets</code> folder of your project. </p>
			<div><div><img src="img/Figure_3.42_B17146.jpg" alt="Figure 3.42 – The LoxodonFramework folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.42 – The LoxodonFramework folder</p>
			<p>Now, let's perform the following steps to implement a sample MVVM UI via <strong class="bold">LoxodonFramework</strong> in Unity: </p>
			<ol>
				<li value="1">First, let's set <a id="_idIndexMarker347"/>up <code>LoxodonFramework</code> in our game scene. We need to create a new canvas and add the <strong class="bold">GlobalWindowManager</strong> component to this canvas, as shown in <em class="italic">Figure 3.43</em>. A <strong class="bold">GlobalWindowManager</strong> component is a container that is used to manage views.</li>
			</ol>
			<div><div><img src="img/Figure_3.43_B17146.jpg" alt="Figure 3.43 – The GlobalWindowManager component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.43 – The GlobalWindowManager component</p>
			<ol>
				<li value="2">Next, we need to define a view. As we mentioned earlier, a view represents UI elements in Unity. As you can see from the following code, this view is relatively simple, containing only a button UI element and a text UI element, and this <code>SampleView</code> class inherits from the <code>Window</code> class in the Loxodon Framework. In the following code, you can also find the <code>BindingSet</code> class, which is used to bind and connect properties of <code>ViewModel</code> and <code>View</code>:<pre>using UnityEngine;
using UnityEngine.UI;
using Loxodon.Framework.Views;
using Loxodon.Framework.Binding;
using Loxodon.Framework.Binding.Builder;
using Loxodon.Framework.ViewModels;
using TMPro;
public class SampleView : <code>Window</code>
{
    [SerializeField]
    private <code>Button _submitButton;</code>
    [SerializeField]
    private <code>TextMeshProUGUI _message;</code>
    private SampleViewModel _viewModel;
    protected override void OnCreate(IBundle bundle)
    {
        _viewModel = new SampleViewModel();
        <code>BindingSet&lt;SampleView, SampleViewModel&gt;</code>
<code>          </code>bindingSet =
          this.CreateBindingSet(_viewModel);
        bindingSet.<code>Bind</code>(_message).For(v =&gt;
          v.<code>text</code>).To(vm =&gt; vm.<code>Message</code>).OneWay();
        bindingSet.<code>Bind</code>(_submitButton).For(v =&gt;
          v.<code>onClick</code>).To(vm =&gt; vm.<code>Submit</code>);
        bindingSet.Build();
    }
}</pre></li>
			</ol>
			<p>Let's break down this example:</p>
			<ul>
				<li>The two <code>_submitButton</code> and <code>_message</code> fields of this <code>SampleView</code> class refer to a <code>Button</code> component and a <code>TextMeshProUGUI</code> component, respectively.</li>
				<li>In the <code>OnCreate</code> method, we first create a <code>BindingSet</code> instance to bind <code>SampleView</code> to its corresponding <code>ViewModel</code> class – that is, <code>SampleViewModel</code>. We will introduce how to create the <code>SampleViewModel</code> class later.</li>
				<li>Then, we <a id="_idIndexMarker348"/>bind the <code>text</code> property of the <code>_message</code> field in <code>SampleView</code> to the <code>Message</code> property in <code>SampleViewModel</code> by calling the <code>Bind</code> method of <code>BindingSet</code>. You can see in the code that we use <code>OneWay</code> binding here, which means that only the view model can modify the value of the UI element in the view.</li>
				<li>We also bind the <code>onClick</code> event of the <code>_submitButton</code> field in <code>SampleView</code> to the <code>Submit</code> method in <code>SampleViewModel</code>. Finally, we call the <code>Build</code> method of <code>BindingSet</code> to build the binding.</li>
			</ul>
			<ol>
				<li value="3">At the same time, we also need to create these required UI elements in the Unity scene, as shown in the following figure. Let's call it <strong class="bold">SampleUI</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_3.44_B17146.jpg" alt="Figure 3.44 – Setting up the UI elements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.44 – Setting up the UI elements</p>
			<ol>
				<li value="4">Then, let's create a new folder called <code>Resources</code> and create a prefab for this sample UI by dragging it from the <strong class="bold">Hierarchy</strong> window to the <strong class="bold">Resources</strong> folder, as <a id="_idIndexMarker349"/>shown in the following screenshot. So far, we have created UI elements and a <strong class="bold">View</strong> component that represent UI elements in the MVVM architecture. <strong class="bold">SampleUI</strong> can be removed from the scene because we will load its prefab and create the UI at runtime. </li>
			</ol>
			<p class="figure-caption">                  </p>
			<div><div><img src="img/Figure_3.45_B17146.jpg" alt="Figure 3.45 – The SampleUI prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.45 – The SampleUI prefab</p>
			<ol>
				<li value="5">We<a id="_idIndexMarker350"/> also need a <code>SampleViewModel</code> class, which implements concrete logic. The <code>SampleViewModel</code> class inherits from the <code>ViewModelBase</code> class in the Loxodon framework, and the logic is implemented in the <code>Submit</code> method, which modifies the <code>Message</code> property. In the view we created earlier, we bound the button's <code>onClick</code> event to the <code>Submit</code> method in the <code>SampleViewModel</code> class, and we also bound the view's <code>text</code> property of the Text UI element to the <code>Message</code> property of <code>SampleViewModel</code>. Therefore, after the <code>Submit</code> method modifies the <code>Message</code> property, the modified message content will be displayed on the UI:<pre>using Loxodon.Framework.ViewModels;
public class SampleViewModel : <strong class="bold">ViewModelBase</strong>
{
    private string _message;
    private int _count;
    public SampleViewModel() { }
    <strong class="bold">public string Message</strong>
    {
        get { return _message; }
        set =&gt; Set&lt;string&gt;(ref _message, value,
          Message);
    }
    <strong class="bold">public void Submit()</strong>
    {
        _count++;
        Message = $The number of times the button is
          clicked: {_count};
    }
}</pre></li>
				<li>Finally, start up <a id="_idIndexMarker351"/>code is needed to register services and create the UI. The following start up code supports loading the prefab of <code>ApplicationContext</code> class in the following code; we use it to store data and services that can be accessed by other classes in the Loxodon Framework. Then, the code registers the <code>IUIViewLocator</code> service to load the UI prefab and create the UI elements:<pre>public class Startup : MonoBehaviour
{
    private <code>container.Register&lt;IUIViewLocator&gt;</code>(new
          ResourcesViewLocator ());
        var bundle = new
          BindingServiceBundle
          (_context.GetContainer());
        bundle.Start();
    }
    private IEnumerator Start()
    {
        // Create a window container
        var winContainer =
          WindowContainer.Create(MAIN);
        yield return null;
        IUIViewLocator locator =
          _context.GetService&lt;IUIViewLocator&gt;();
        <strong class="bold">var sampleView =</strong>
<strong class="bold">          locator.LoadWindow&lt;SampleView&gt;(winContainer,</strong>
<strong class="bold">          SampleUI);</strong>
<strong class="bold">        sampleView.Create();</strong>
        ITransition transition =
          sampleView.Show().OnStateChanged((w, state)
          =&gt;
        {
        });
        yield return transition.WaitForDone();
    }
}</pre></li>
				<li>Let's run<a id="_idIndexMarker352"/> the game. As you can see in the following screenshot, we create a view that displays the message text at the top and a <code>SampleViewModel</code> class to update the message information, and the view will also update the UI text to display the latest information through data binding.</li>
			</ol>
			<div><div><img src="img/Figure_3.46_B17146.jpg" alt="Figure 3.46 – The sample UI with MVVM &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.46 – The sample UI with MVVM </p>
			<p>This <a id="_idIndexMarker353"/>way, the UI graphics and UI logic are separated. UI designers and programmers can work at the same time without relying on each other, thereby improving the efficiency of UI development in Unity. </p>
			<p>In this section, we discussed how to use MVVM to implement the UI in Unity. Next, we will learn what we must pay attention to when implementing the UI in Unity – that is, optimizing UI performance.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor056"/>Performance tips to increase performance of the UI</h1>
			<p>The UI is an <a id="_idIndexMarker354"/>important part of a game, so if you do not implement it properly, it may cause potential performance issues. In this section, we will discuss the best practices for implementing the game UI in Unity to optimize the performance problems caused by the UI.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor057"/>The Unity Profiler</h2>
			<p>The first best practice tip<a id="_idIndexMarker355"/> is to be good at using the Unity <strong class="bold">Profiler</strong>. The <a id="_idIndexMarker356"/>Profiler is a tool that you can use to get performance data about your game, including <strong class="bold">CPU Usage</strong>, <strong class="bold">GPU Usage</strong>, <strong class="bold">Rendering</strong>, <strong class="bold">Memory,</strong> <strong class="bold">UI</strong>, and <strong class="bold">UI Details</strong>. In order to view performance data about the UI, perform the<a id="_idIndexMarker357"/> following steps:</p>
			<ol>
				<li value="1">Click <strong class="bold">Window</strong> &gt; <strong class="bold">Analysis</strong> &gt; <strong class="bold">Profiler</strong> to open the <strong class="bold">Profiler</strong> window. </li>
				<li>Click the <strong class="bold">UI</strong> or <strong class="bold">UI Details</strong> module area in the <strong class="bold">Profiler</strong> window to view performance data related to the UI, such as the CPU time consumed by <strong class="bold">Layout</strong> and <strong class="bold">Render</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_3.47_B17146.jpg" alt="Figure 3.47 – The UI area in the Profiler window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.47 – The UI area in the Profiler window</p>
			<p>In addition to the <strong class="bold">UI</strong> and <strong class="bold">UI Details</strong> areas, the <strong class="bold">CPU Usage</strong> area in the <strong class="bold">Profiler</strong> window also provides performance information related to the UI. In the <strong class="bold">CPU Usage</strong> area, you can see the CPU time consumed by a specific marker, such as <strong class="bold">UGUI.Rendering.RenderOverlays</strong>, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.48_B17146.jpg" alt="Figure 3.48 – The CPU Usage area in the Profiler window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.48 – The CPU Usage area in the Profiler window</p>
			<p>This <a id="_idIndexMarker358"/>was just a<a id="_idIndexMarker359"/> brief introduction to the Profiler tool. In the following chapters, we will discuss the Unity Profiler in detail.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor058"/>Multiple canvases</h2>
			<p>The <a id="_idIndexMarker360"/>second-best practice tip is a very important aspect that needs to be considered when implementing the UI in Unity, especially when your game UI is very complex. If necessary, you may need to create multiple canvases to manage and display different UI elements. As we have mentioned before, a canvas generates meshes representing the UI elements placed on it and regenerates the meshes when the UI elements change. </p>
			<p>Suppose that you build the UI of the entire game in a single canvas with thousands of UI elements, and when one or more UI elements on the canvas change, all the meshes used to display the UI regenerate. This may be expensive, and you may experience CPU spikes that take a few milliseconds.</p>
			<p>Therefore, it is a good idea to create multiple different canvases to manage them, based on the update frequency of UI elements. For example, frequently updated dynamic UI elements such as progress bars and timers can be in one canvas, and infrequently updated static UI elements such as UI panels and background images can be in another. Of course, there is no magic bullet; you need to manage the canvas on a project-by-project basis.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor059"/>Use Sprite Atlas</h2>
			<p>As we<a id="_idIndexMarker361"/> introduced when discussing UI images, sprites are 2D graphic objects used for the UI and other elements of 2D gameplay. When importing a new texture into the Unity Editor, we can set the texture type of this texture <a id="_idIndexMarker362"/>to a sprite. So, your game project may contain a lot of sprite files. If so, many sprites are treated as separate individuals, and rendering performance may decrease. This is because Unity will<a id="_idIndexMarker363"/> issue a <strong class="bold">draw call</strong> for each sprite in the scene, and multiple draw calls may consume a lot of resources and negatively affect your game performance. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">A draw call is a call to the graphics API to draw objects (for example, to draw a triangle).</p>
			<p>As shown in the following screenshot, there are two draw calls to render <strong class="bold">Button1</strong> and <strong class="bold">Button2</strong> because these two buttons use two different textures:</p>
			<div><div><img src="img/Figure_3.49_B17146.jpg" alt="Figure 3.49 – Multiple draw calls&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.49 – Multiple draw calls</p>
			<p>So, it is a good idea to combine several textures or sprites into a combined texture. </p>
			<p>We can<a id="_idIndexMarker364"/> perform the following steps to use the <strong class="bold">Sprite Atlas</strong> provided <a id="_idIndexMarker365"/>by Unity to combine textures:</p>
			<ol>
				<li value="1">If the <strong class="bold">Sprite Atlas</strong> packing is disabled, enable it in <strong class="bold">Edit</strong> &gt; <strong class="bold">Project Settings</strong> &gt; <strong class="bold">Editor</strong> &gt; <strong class="bold">Sprite Packer</strong> &gt; <strong class="bold">Mode</strong>. </li>
				<li>Click <strong class="bold">Assets</strong> &gt; <strong class="bold">Create</strong> &gt; <strong class="bold">2D</strong> &gt; <strong class="bold">Sprite Atlas</strong> to create a Sprite Atlas asset. </li>
			</ol>
			<div><div><img src="img/Figure_3.50_B17146.jpg" alt="Figure 3.50 – Creating a Sprite Atlas&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.50 – Creating a Sprite Atlas</p>
			<ol>
				<li value="3">Under the <strong class="bold">Objects for Packing</strong> drop-down<a id="_idIndexMarker366"/> menu of the Sprite Atlas asset, select the <strong class="bold">+</strong> symbol to add textures or folders to the Sprite Atlas.</li>
			</ol>
			<p>However, we still need to be aware that although Sprite Atlas can effectively reduce the count of draw calls, improper use can easily lead to a waste of memory. When a sprite is active in an atlas, Unity loads all the sprites in the atlas to which the sprite belongs. If there are many sprites in an atlas, even if only one sprite is referenced in the scene, the whole atlas will be loaded, which will cause large memory consumption. In order to solve this problem, the sprites can be packaged into multiple smaller atlases according to their purpose. For example, the sprites used in the login panel can be packaged as a login panel atlas, while the sprites used in the game character panel are packaged as a character panel atlas.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor060"/>Summary</h1>
			<p>In this chapter, we started by introducing some of the most commonly used UI component classes of the uGUI solution, such as the <strong class="bold">Canvas</strong>, <strong class="bold">Rect Transform</strong>, and <strong class="bold">Image</strong> components. We then explained the Event System in Unity, the legacy Input Module, and the new more powerful Input System package provided by Unity.</p>
			<p>We also discussed how to decouple components from each other when developing the UI in Unity by using the MVVM architectural pattern. </p>
			<p>Finally, we explored some best practices for implementing the game UI in Unity to optimize the performance problems caused by the UI.</p>
			<p>In the next chapter, we will learn about the animation system in Unity and, at the same time, we will also introduce how to optimize animation performance in Unity.</p>
		</div>
	</body></html>