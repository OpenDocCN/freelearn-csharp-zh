<html><head></head><body>
		<div><h1 id="_idParaDest-352"><em class="italic"><a id="_idTextAnchor476"/>Chapter <a id="_idTextAnchor477"/>17</em>: Building Automated Tests</h1>
			<p>Building automated tests is an essential <code>GetRegistrationOrNull</code> practice to create maintainable software solutions and is a fast and repeatable way of validating the software. ABP Framework and the ABP startup solution template are designed with testability in mind. We've already seen an example of writing a simple integration test with ABP Framework in <a href="B17287_03_Epub_AM.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Step-By-Step Application Development</em>.</p>
			<p>In this chapter, you will understand the ABP test infrastructure and build unit and integration tests for your ABP-based solutions. You will learn about data seeding for tests, mocking the database, and testing different kinds of objects. You will also learn the basics of automated tests such as assertions, mocking and replacing services, and dealing with exceptions.</p>
			<p>Here is a list of the main topics covered in this chapter:</p>
			<ul>
				<li>Understanding the ABP test infrastructure</li>
				<li>Building unit tests</li>
				<li>Building integration tests</li>
			</ul>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor478"/>Technical requirements</h1>
			<p>If you want to follow the examples in this chapter, you need to have an IDE/editor that supports ASP.NET Core development.</p>
			<p>The examples in this chapter are mostly based on the EventHub solution I introduced in <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>. Please refer to that chapter to learn how to download the source code of the EventHub solution. </p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor479"/>Understanding the ABP test infrastructure</h1>
			<p>ABP's startup <a id="_idIndexMarker1092"/>solution template includes preconfigured test projects to build unit and integration tests for your solution. While you can write your tests without understanding the complete structure, I think it is worth exploring this so that you can understand how it works and customize it when you need it. We'll start by exploring the <code>test</code> projects.</p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor480"/>Exploring the test projects</h2>
			<p>The following <a id="_idIndexMarker1093"/>screenshot shows the <code>test</code> projects that get created when you create a new ABP solution:</p>
			<div><div><img src="img/Figure_17.01_B17287.jpg" alt="Figure 17.1 – Test projects in the ABP startup solution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.1 – Test projects in the ABP startup solution</p>
			<p>The preceding screenshot shows the <code>test</code> projects for a solution named <code>ProductManagement</code>, with <a id="_idIndexMarker1094"/>the MVC/Razor Pages UI and the <code>test</code> project list may be slightly different if you use a different UI or database provider, but the fundamental logic is the same. The following list explains the projects in general:</p>
			<ul>
				<li><code>ProductManagement.HttpApi.Client.ConsoleTestApp</code>: A very simple console application <a id="_idIndexMarker1095"/>to manually test the HTTP API endpoints of your application. So, this is not a part of our automated test infrastructure, and you can ignore it for this chapter.</li>
				<li><code>ProductManagement.TestBase</code>: A <a id="_idIndexMarker1096"/>project that is shared by the other test projects. It has references to the base test libraries and includes data seeding and some other base configuration code. It doesn't contain any test class normally.</li>
				<li><code>ProductManagement.EntityFrameworkCore.Tests</code>: You can build tests for EF Core <a id="_idIndexMarker1097"/>integration code in this project, such as your custom repositories. This project also configures a SQLite in-memory database for your tests.</li>
				<li><code>ProductManagement.Domain.Tests</code>: Use <a id="_idIndexMarker1098"/>this project to build tests for your domain layer.</li>
				<li><code>ProductManagement.Application.Tests</code>: Use <a id="_idIndexMarker1099"/>this project to build tests for your application layer.</li>
				<li><code>ProductManagement.Web.Tests</code>: Use <a id="_idIndexMarker1100"/>this project to build tests for your MVC/Razor Pages UI.</li>
			</ul>
			<p>The solution uses some libraries as the test infrastructure, as explained in the next section.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor481"/>Exploring the test libraries</h2>
			<p>The <code>ProductManagement.TestBase</code> project <a id="_idIndexMarker1101"/>has reference <a id="_idIndexMarker1102"/>to the following NuGet packages:</p>
			<ul>
				<li><code>xunit</code>: xUnit is one of the most popular test frameworks for .NET.</li>
				<li><code>Shouldly</code>: A library to write the assertion code in an easy and readable format.</li>
				<li><code>NSubstitute</code>: A library to mock objects in unit tests.</li>
				<li><code>Volo.Abp.TestBase</code>: ABP's package to easily create ABP-integrated test classes.</li>
			</ul>
			<p>We will see how to use the basics of these libraries in the <em class="italic">Building unit tests</em> and <em class="italic">Building integration tests</em> sections. Before starting to write our tests, let's see how we can run the tests.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor482"/>Running the tests</h2>
			<p>In this section, I will show two ways of running the tests. The first way is to use an IDE that supports <a id="_idIndexMarker1103"/>running test execution. I will use Visual Studio as an example. You can open the <strong class="bold">Test Explorer</strong> window from the <strong class="bold">Test</strong> | <strong class="bold">Test Explorer</strong> item on the main menu:</p>
			<div><div><img src="img/Figure_17.02_B17287.jpg" alt="Figure 17.2 – Test Explorer in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.2 – Test Explorer in Visual Studio</p>
			<p><code>ProductManagement</code> application built in <a href="B17287_03_Epub_AM.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Step-By-Step Application Development</em>, and the source code can be found at <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<p>Visual Studio runs the tests one by one by default, and thus it takes a long time to run all the tests. You can click the down arrow icon near the cog icon in <strong class="bold">Text Explorer</strong> and select the <strong class="bold">Run Tests In Parallel</strong> option (see <em class="italic">Figure 17.3</em>) to run the tests in parallel so that it takes significantly less time to run them all:</p>
			<div><div><img src="img/Figure_17.03_B17287.jpg" alt="Figure 17.3 – Running tests in parallel in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.3 – Running tests in parallel in Visual Studio</p>
			<p>ABP Framework <a id="_idIndexMarker1104"/>and the startup solution template have been designed to support running tests in parallel so that tests don't affect each other.</p>
			<p>An alternative way to run tests is to use the <code>dotnet test</code> command in the root directory of your solution. It automatically discovers and runs all the tests and reports the test result in the command-line terminal. This command exits with a <code>0</code> (success) return code if all the tests succeed; otherwise, if any test fails, it exits with a <code>1</code> return code. This command is <a id="_idIndexMarker1105"/>especially useful if you build a <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) pipeline where you automatically run the tests.</p>
			<p>You've learned the test structure of the ABP startup solution and have run the automated tests. Now, we can start to build our tests.</p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor483"/>Building unit tests</h1>
			<p>In this section, we will <a id="_idIndexMarker1106"/>see different types of unit tests. We will begin by testing a static class, then we will write tests for a class with no dependencies. We will continue with a class with dependent services and learn how to mock these dependencies to unit test that class. We will learn the basics of writing automated test code with examples.</p>
			<p>Let's begin with the simplest case—testing static classes.</p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor484"/>Testing static classes</h2>
			<p>A static class with <a id="_idIndexMarker1107"/>no state and external dependencies is the easiest class to test. <code>EventUrlHelper</code> is a <a id="_idIndexMarker1108"/>static class (in the <code>EventHub.Domain</code> project of the EventHub solution) and is used to convert an event's title to a proper URL part. The following test class (in the <code>EventHub.Domain.Tests</code> project of the EventHub solution) tests the <code>EventUrlHelper</code> class:</p>
			<pre>public class EventUrlHelper_Tests
{
    [Fact]
    public void Should_Convert_Title_To_Proper_Urls()
    {
        var url = EventUrlHelper.ConvertTitleToUrlPart(
                  "Introducing ABP Framework!");
        Assert.Equal("introducing-abp-framework", url);
    }
}</pre>
			<p>The first rule is that the test class should be <code>public</code>. Otherwise, you can't see it in <code>[Fact]</code> attribute is defined by the <code>xUnit</code> library. Any public method with the <code>[Fact]</code> attribute is considered a test case and is automatically discovered by <code>Should_Convert_Url_To_Kebab_Case</code>, and only test the functionality related to <code>kebab-case</code>.</p>
			<p>The test code in this example is very simple. We call the static <code>EventUrlHelper.ConvertTitleToUrlPart</code> method with a sample title value, then compare the result with the value we expect it to be. The <code>Assert</code> class is defined by <code>xUnit</code>, with many methods to define our expectations. The test case succeeds only if the given values are equal. Otherwise, we see a red icon for the test case in <strong class="bold">Test Explorer</strong> with an error message indicating what's wrong with the test.</p>
			<p>You can <a id="_idIndexMarker1109"/>right-click on a specific test in <strong class="bold">Test Explorer</strong> to run it and see the result, as depicted in the following screenshot:</p>
			<div><div><img src="img/Figure_17.04_B17287.jpg" alt="Figure 17.4 – Running a specific test in Test Explorer in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.4 – Running a specific test in Test Explorer in Visual Studio</p>
			<p>Another common <code>xUnit</code> attribute is <code>[Theory]</code>, which provides parameters to a test method and tests it for each parameter set. Assuming that we want to run the test with different event URLs, we can rewrite the test method, as shown in the following code block:</p>
			<pre>public class EventUrlHelper_Tests
{
    [Theory]
    [InlineData("Introducing ABP Framework!",
                "introducing-abp-framework")]
    [InlineData("Blazor: UI Messages", 
                "blazor-ui-messages")]
    [InlineData("What's new in .NET 6", 
                "whats-new-in-net-6")]
    public void Should_Convert_Title_To_Proper_Urls(
        string title, string url)
    {
        var result = 
            EventUrlHelper.ConvertTitleToUrlPart(title);
        result.ShouldBe(url);
    }
}</pre>
			<p><code>xUnit</code> runs this <a id="_idIndexMarker1110"/>test method for each <code>[InlineData]</code> set separately and passes the <code>title</code> and <code>url</code> parameters as the given data. If you look at <strong class="bold">Test Explorer</strong> again, you will see these three test cases there:</p>
			<div><div><img src="img/Figure_17.05_B17287.jpg" alt="Figure 17.5 – Using the [Theory] attribute for unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.5 – Using the [Theory] attribute for unit tests</p>
			<p>I also <a id="_idIndexMarker1111"/>used the <code>Shouldly</code> library for the assertion in this example. The <code>result.ShouldBe(url)</code> expression is simpler to write and read than the <code>Assert.Equal(url, result)</code> expression. The <code>Shouldly</code> library works with extension methods such as that, and I will use it in future examples.</p>
			<p>Testing static classes (with no state and external dependencies) was easy. We've also learned some <code>xUnit</code> and <code>Shouldly</code> features. The next section continues with testing simple classes without a service dependency.</p>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor485"/>Testing classes with no dependencies</h2>
			<p>Some <a id="_idIndexMarker1112"/>classes, such as entities, may have no dependency on other services. Testing these classes is relatively easy since we don't need to prepare the dependencies to make the class work properly.</p>
			<p>The following test method tests the <code>Event</code> class's constructor:</p>
			<pre>public class Event_Tests
{
    [Fact]
    public void Should_Create_A_Valid_Event()
    {
        new Event(
            Guid.NewGuid(),
            Guid.NewGuid(),
            "1a8j3v0d",
            "Introduction to the ABP Framework",
            DateTime.Now,
            DateTime.Now.AddHours(2),
            "In this event, we will introduce the ABP 
             Framework..."
        );
    }
}</pre>
			<p>In <a id="_idIndexMarker1113"/>this example, I've passed a valid list of parameters so that it doesn't throw an exception, and the test succeeds. The following example tests for an exception case:</p>
			<pre>[Fact]
public void 
    Should_Not_Allow_End_Time_Earlier_Than_Start_Time()
{
    var exception = Assert.Throws&lt;BusinessException&gt;(() =&gt;
    {
        new Event(
            Guid.NewGuid(),
            Guid.NewGuid(),
            "1a8j3v0d",
            "Introduction to the ABP Framework",
            DateTime.Now, // Start time
            DateTime.Now.AddDays(-2), // End time
            "In this event, we will introduce the ABP
             Framework..."
        );
    });
    exception.Code.ShouldBe(EventHubErrorCodes
        .EventEndTimeCantBeEarlierThanStartTime);
}</pre>
			<p>I intentionally <a id="_idIndexMarker1114"/>passed the end time as 2 days earlier than the start time. I am expecting the constructor to throw a <code>BusinessException</code> exception by using the <code>Assert.Throws&lt;T&gt;</code> method. If the code block inside the <code>Throws</code> method throws an exception of type <code>BusinessException</code>, then the test passes; otherwise, the test will fail. I am also checking the error code with the <code>ShouldBe</code> extension method.</p>
			<p>Let's write a method that tests another method of the <code>Event</code> class. The following example creates a valid <code>Event</code> object, then changes its start and end times, and finally checks whether the times were changed:</p>
			<pre>[Fact]
public void Should_Update_Event_Time()
{
    // ARRANGE
    var evnt = new Event(
        Guid.NewGuid(),
        Guid.NewGuid(),
        "1a8j3v0d",
        "Introduction to the ABP Framework",
        DateTime.Now,
        DateTime.Now.AddHours(2),
        "In this event, we will introduce the ABP
         Framework..."
    );
    var newStartTime = DateTime.Now.AddHours(1);
    var newEndTime = DateTime.Now.AddHours(2);
    //ACT
    evnt.SetTime(newStartTime, newEndTime);
    //ASSERT
    evnt.StartTime.ShouldBe(newStartTime);
    evnt.EndTime.ShouldBe(newEndTime);
    evnt.GetLocalEvents()
        .ShouldContain(x =&gt; x.EventData
                       is EventTimeChangingEventData);
}</pre>
			<p>This <a id="_idIndexMarker1115"/>example fully implements <a id="_idIndexMarker1116"/>the common <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>) test pattern, detailed as follows:</p>
			<ul>
				<li>The <em class="italic">Arrange</em> part prepares the objects we need to work on.</li>
				<li>The <em class="italic">Act</em> part executes the actual code we want to test.</li>
				<li>The <em class="italic">Assert</em> part checks whether the expectations are met.</li>
			</ul>
			<p>I suggest separating your test method's body with these comment lines to make what you are testing <a id="_idIndexMarker1117"/>and asserting explicit. In this example, we used the <code>SetTime</code> method of the <code>Event</code> class to change the event times. The <code>SetTime</code> method also publishes a local event, so I checked it too in the <em class="italic">Assert</em> part.</p>
			<p>As you see in the examples, if the class we want to test has no external dependencies, we can simply create an instance and execute the methods on it. In the next section, we will see how to deal with external dependencies.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor486"/>Testing classes with dependencies</h2>
			<p>Most services <a id="_idIndexMarker1118"/>have dependencies <a id="_idIndexMarker1119"/>on other services. We use the <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) system to take these dependencies into the service's constructor. The purpose of unit testing is to test a class as isolated from other classes because unit tests should generally have only one reason to fail. We should somehow exclude the dependencies while testing the target class. In this way, our test is affected by the changes in the target class but not affected by changes in other classes.</p>
			<p>Mocking is a <a id="_idIndexMarker1120"/>technique used in unit testing to replace a target class's dependencies with fake implementations so that the test isn't affected by the target class's dependencies.</p>
			<p>I will test the <code>IsPastEvent</code> method of the <code>EventRegistrationManager</code> class as an example. The <code>IsPastEvent</code> method gets an event. </p>
			<p><code>EventRegistrationManager</code> is a domain service and takes three external services in its constructor, as shown in the following simplified code block:</p>
			<pre>public class EventRegistrationManager : IDomainService
{
    ...
    public EventRegistrationManager(
        IEventRegistrationRepository 
            eventRegistrationRepository,
        IGuidGenerator guidGenerator,
        IClock clock)
    {
        _eventRegistrationRepository = 
            eventRegistrationRepository;
        _guidGenerator = guidGenerator;
        _clock = clock;
    }
    public bool IsPastEvent(Event @event)
    {
        return _clock.Now &gt; @event.EndTime;
    }
}</pre>
			<p>We should <a id="_idIndexMarker1121"/>pass instances of these three external services to be able to create an <code>EventRegistrationManager</code> object. The following code block shows how I've written a test method for the <code>IsPastEvent</code> method of that class:</p>
			<pre>public class EventRegistrationManager_UnitTests
{
    [Fact]
    public void IsPastEvent()
    {
        var clock = Substitute.For&lt;IClock&gt;();
        clock.Now.Returns(DateTime.Now);
        var registrationManager = new 
            EventRegistrationManager(null, null, clock
        );
        var evnt = new Event(
            Guid.NewGuid(),
            Guid.NewGuid(),
            "1a8j3v0d",
            "Introduction to the ABP Framework",
            DateTime.Now.AddDays(-10), // Start time
            DateTime.Now.AddDays(-9), // End time
            "In this event, we will introduce the ABP
             Framework..."
        );
        registrationManager.IsPastEvent(evnt)
            .ShouldBeTrue();
    }
}</pre>
			<p>The test <a id="_idIndexMarker1122"/>code starts by creating a fake <code>IClock</code> object using the <code>Substitute.For&lt;T&gt;</code> utility method of the <code>NSubstitute</code> library. The <code>clock.Now.Returns(DateTime.Now)</code> statement configures the fake object so that it returns <code>DateTime.Now</code> whenever the <code>clock.Now</code> property is called. We do that since the <code>IsPastEvent</code> method will call the <code>clock.Now</code> property. That means we should know the internal implementation details of the unit-tested method to test it properly.</p>
			<p>Since I know that the <code>IsPastEvent</code> method won't use the <code>IEventRegistrationRepository</code> and <code>IGuidGenerator</code> services, I can pass them as <code>null</code> in the constructor of the <code>EventRegistrationManager</code> class.</p>
			<p>Finally, I've called <a id="_idIndexMarker1123"/>the <code>IsPastEvent</code> method of the <code>EventRegistrationManager</code> class with an example event and checked the result.</p>
			<p>Let's see <a id="_idIndexMarker1124"/>a more complex example. This time, we <a id="_idIndexMarker1125"/>are testing the <code>RegisterAsync</code> method of the <code>EventRegistrationManager</code> class. The code is illustrated in the following snippet:</p>
			<pre>[Fact]
public async Task 
    Valid_Registrations_Should_Be_Inserted_To_Db()
{
    var evnt = new Event(/* some valid arguments */);
    var user = new IdentityUser(/* some valid arguments 
                                */);
    var repository =
        Substitute.For&lt;IEventRegistrationRepository&gt;();
    repository
        .ExistsAsync(evnt.Id, user.Id)
        .Returns(Task.FromResult(false));
    var clock = Substitute.For&lt;IClock&gt;();
    clock.Now.Returns(DateTime.Now);
    var guidGenerator = SimpleGuidGenerator.Instance;
    var registrationManager = new EventRegistrationManager(
        repository, guidGenerator, clock
    );
    await registrationManager.RegisterAsync(evnt, user);
    await repository
        .Received()
        .InsertAsync(
            Arg.Is&lt;EventRegistration&gt;(
            er =&gt; er.EventId == evnt.Id &amp;&amp; er.UserId == 
                user.Id)
    );
}</pre>
			<p>First, I've <a id="_idIndexMarker1126"/>created an <code>Event</code> object and an <code>IdentityUser</code> object because the <code>RegisterAsync</code> method gets these parameters. Then, I've mocked the <code>EventRegistrationManager</code> dependencies. Since the <code>RegisterAsync</code> method uses all the dependencies, I had to mock them all. See how I configured the fake repository to return <code>false</code> when the <code>ExistsAsync</code> method is called. The <code>RegisterAsync</code> method uses the <code>ExistsAsync</code> method to check whether there is already a registration with the same event and user.</p>
			<p>After executing the <code>RegisterAsync</code> method, I should somehow check whether the registration is complete. I can use the <code>Received</code> method of <code>NSubstitute</code> to check whether the repository's <code>InsertAsync</code> method is called with an <code>EventRegistration</code> object with the specified event <a id="_idIndexMarker1127"/>and <strong class="bold">user identifiers</strong> (<strong class="bold">UIDs</strong>).</p>
			<p>In this section, I've covered the basics of unit testing. Unit tests have two main advantages compared to integration tests, as outlined here:</p>
			<ul>
				<li>They run fast because only the tested class really works. All others are mocked and typically <a id="_idIndexMarker1128"/>have no execution cost.</li>
				<li>They make it easier to investigate problems. If a class doesn't work properly, only the tests working on that class fail, so you can easily find the problem's source.</li>
			</ul>
			<p>However, writing and maintaining unit tests is hard when your classes have dependencies. Unit tests also can't tell much about whether your class will properly work at runtime integrated with other services. That brings us to integration tests.</p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor487"/>Building integration tests</h1>
			<p>In this section, we will see how to build automated tests for your services as integrated into ABP <a id="_idIndexMarker1129"/>Framework and other infrastructure components. We will start by understanding ABP integration, how the database is used in integration tests, and how to create initial test data. Then, we will write example tests for repositories, domain, and application services. Let's start with ABP integration.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor488"/>Understanding ABP integration</h2>
			<p>ABP <a id="_idIndexMarker1130"/>provides the <code>Volo.Abp.TestBase</code> NuGet package, which includes the <code>AbpIntegratedTest&lt;TStartupModule&gt;</code> base class for our integration tests. We <a id="_idIndexMarker1131"/>can inherit from that class to write tests as completely integrated to ABP Framework. The following example shows the main parts of such a test class:</p>
			<pre>public class SampleTestClass
    : AbpIntegratedTest&lt;MyTestModule&gt;
{
    private IMyService _myService;
    public SampleTestClass()
    {
        _myService = GetRequiredService&lt;IMyService&gt;();
    }
    
    [Fact]
    public async Task TestMethod()
    {
        await _myService.DoItAsync();
    }
}</pre>
			<p>In this <a id="_idIndexMarker1132"/>example, I've inherited from the <code>AbpIntegratedTest&lt;MyTestModule&gt;</code> class, where <code>MyTestModule</code> is my startup module class. <code>MyTestModule</code> should depend on <code>AbpTestBaseModule</code>, as shown in the following example:</p>
			<pre>[DependsOn(typeof(AbpTestBaseModule))]
public class MyTestModule : AbpModule
{
}</pre>
			<p>In the <a id="_idIndexMarker1133"/>constructor of <code>SampleTestClass</code>, I've resolved an example service using the <code>GetRequiredService</code> method and assigned it to a class field. We could resolve a service from the DI system since all the infrastructure is available, just like at runtime. I don't need to care about the dependencies of the service. Finally, I called a method of the example service in my test method.</p>
			<p>While writing integration tests is that simple, test projects in the startup template have a little more. Check the <code>EventHubTestBaseModule</code> class (in the <code>EventHub.TestBase</code> project of the EventHub solution). You will see that it is disabling background jobs and authorization, seeding some test data, and doing other configurations.</p>
			<p>We've learned the basics of integrating with ABP in our test classes. In the next section, you will learn how to deal with the database in tests.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor489"/>Mocking the database</h2>
			<p>The database is one of the most fundamental aspects when you are building integration tests. Assume <a id="_idIndexMarker1134"/>that you are using SQL Server in your solution. Using a real SQL Server database has some fundamental problems; your tests affect each other since they will work on the same database. A test's change in the database may break subsequent tests. You may not run tests in parallel. Test execution speed will be slow since your application will communicate to SQL Server as an external process. No need to mention that SQL Server should be installed and available in your test environment.</p>
			<p>EF Core provides an in-memory database option, but it is very limited. For example, it has no transaction support and cannot execute SQL commands. So, I don't suggest using it at all.</p>
			<p>The ABP startup template has been configured to use SQLite in-memory database for EF Core (it also uses an in-memory database for MongoDB using the <code>Mongo2Go</code> library). SQLite is a real relational database management system and will be sufficient for most of the applications.</p>
			<p>Check the <code>EventHubEntityFrameworkCoreTestModule</code> class (in the <code>EventHub.EntityFrameworkCore.Tests</code> project of the EventHub solution) to see the SQLite setup. It creates a separate in-memory SQLite database for each test case, creates tables inside the database, and seeds the test data. In this way, every test method starts with the same initial state and doesn't affect other tests. We will see seeding the test data in the next section.</p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor490"/>Seeding the test data</h2>
			<p>Writing tests against an empty database is not so practical. Assume that you want to query <a id="_idIndexMarker1135"/>events in the database or want to test whether the event registration code works. You first need to insert some entities into the database. It can be tedious to prepare the database for each test. Instead, we can create some initial entities in the database that are available for each test.</p>
			<p>The ABP startup solution template uses ABP's data seeding system to fill some initial data into the database. See the <code>EventHubTestDataSeedContributor</code> class (in the <code>EventHub.TestBase</code> project of the EventHub solution). It creates some users, organizations, and events in the database, so we can directly write tests assuming that the initial data exists.</p>
			<p>We've talked about ABP's integration test infrastructure, mocking and seeding the database. Now, we can write some integration tests, starting from the repositories.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor491"/>Testing repositories</h2>
			<p>Let's see <a id="_idIndexMarker1136"/>the <code>EventRegistrationRepository_Tests</code> class (in the <code>EventHub.Domain.Tests</code> project of the EventHub solution) as an example:</p>
			<pre>public class EventRegistrationRepository_Tests
    : EventHubDomainTestBase
{
    private readonly IEventRegistrationRepository 
        _repository;
    private readonly EventHubTestData _testData;
    public EventRegistrationRepository_Tests()
    {
        _repository = GetRequiredService&lt;
                      IEventRegistrationRepository&gt;();
        _testData = GetRequiredService&lt;EventHubTestData&gt;();
    }
    // TODO: Test methods come here...
}</pre>
			<p>This class inherits the <code>EventHubDomainTestBase</code> class, which is indirectly inherited from the <code>AbpIntegratedTest&lt;T&gt;</code> class we've explored in the <em class="italic">Understanding the ABP integration</em> section. So, in the constructor, we could resolve the <code>IEventRegistrationRepository</code> and <code>EventHubTestData</code> services from the DI system. You can investigate the <code>EventHubTestData</code> class yourself (in the <code>EventHub.TestBase</code> project of the EventHub solution). It basically stores the <code>Id</code> values of the entities that are initially seeded into the database to reach them in the tests.</p>
			<p>Let's see the first test method of the <code>EventRegistrationRepository_Tests</code> class. Here it is:</p>
			<pre>[Fact]
public async Task
    Exists_Should_Return_False_If_Not_Registered()
{
    var exists = await _repository.ExistsAsync(
        _testData.AbpMicroservicesFutureEventId, 
        _testData.UserJohnId);
    exists.ShouldBeFalse();
}</pre>
			<p>This test <a id="_idIndexMarker1137"/>simply executes the <code>ExistsAsync</code> method and checks the result to be <code>false</code>. It should return <code>false</code> because we know the user <code>John</code> has not registered to the given event. We know that because we've written the initial data in the database (see the <em class="italic">Seeding the test data</em> section). Let's write another test, as follows:</p>
			<pre>[Fact]
public async Task Exists_Should_Return_True_If_Registered()
{
    await _repository.InsertAsync(
        new EventRegistration(
            Guid.NewGuid(),
            _testData.AbpMicroservicesFutureEventId,
            _testData.UserJohnId));
    
    var exists = await _repository.ExistsAsync(
        _testData.AbpMicroservicesFutureEventId, 
        _testData.UserJohnId);
    exists.ShouldBeTrue();
}</pre>
			<p>This time, we <a id="_idIndexMarker1138"/>are creating the registration record in the database, so we expect the same <code>ExistsAsync</code> call to return <code>true</code>. In this way, we can prepare the database for a particular test to get the expected result.</p>
			<p>ABP's <a id="_idIndexMarker1139"/>repositories provide the <code>GetQueryableAsync</code> method, so <a id="_idIndexMarker1140"/>we can directly use <code>queryable</code> in tests):</p>
			<pre>[Fact]
public async Task Test_Querying()
{
    var queryable = await _repository.GetQueryableAsync();
    var exists = await queryable.Where(
        x =&gt; x.EventId ==
             _testData.AbpMicroservicesFutureEventId &amp;&amp;
             x.UserId == _testData.UserJohnId
        ).FirstOrDefaultAsync();
    exists.ShouldBeNull();
}</pre>
			<p>This method queries the same registration using the <code>Where</code> and <code>FirstOrDefaultAsync</code> LINQ extension methods. If you try to run this test, you will see it throws an exception (of type <code>ObjectDisposedException</code>) because the <code>GetQueryableAsync</code> method requires <a id="_idIndexMarker1141"/>an active <code>WithUnitOfWorkAsync</code> method to <a id="_idIndexMarker1142"/>execute code in a UoW, so we can fix the test code as shown in the following code block:</p>
			<pre>[Fact]
public async Task Test_Querying_With_Uow()
{
    await WithUnitOfWorkAsync(async () =&gt;
    {
        var queryable = 
            await _repository.GetQueryableAsync();
        var exists = await queryable.Where(
            x =&gt; x.EventId ==
                 _testData.AbpMicroservicesFutureEventId &amp;&amp;
                 x.UserId == _testData.UserJohnId
        ).FirstOrDefaultAsync();
        exists.ShouldBeNull();
    });
}</pre>
			<p>You can <a id="_idIndexMarker1143"/>see the source code of the <code>WithUnitOfWorkAsync</code> method. It just uses <code>IUnitOfWorkManager</code> to create a UoW scope.</p>
			<p>We've created some test methods for repositories. You can test any service (that was registered to the DI system) in the same way. I will show some example tests for domain and application services in the next two sections.</p>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor492"/>Testing domain services</h2>
			<p>Testing domain <a id="_idIndexMarker1144"/>services is similar to testing repositories since you should also care about the UoW for domain services. The following code block shows an example test case from the <code>EventManager_Tests</code> class (in the <code>EventHub.Domain.Tests</code> project of the EventHub solution):</p>
			<pre>[Fact]
public async Task Should_Update_The_Event_Capacity()
{
    const int newCapacity = 42;
    await WithUnitOfWorkAsync(async () =&gt;
    {
        var @event = await _eventRepository.GetAsync(
            _testData.AbpMicroservicesFutureEventId);
        await _eventManager.SetCapacityAsync(
            @event,
            newCapacity
        );
    });
    
    var @event = await _eventRepository.GetAsync(
        _testData.AbpMicroservicesFutureEventId);
    @event.Capacity.ShouldBe(newCapacity);
}</pre>
			<p>The test's purpose is to increase the capacity of an event using the <code>EventManager</code> domain service and see whether it works. It uses the <code>WithUnitOfWorkAsync</code> method to call the <code>SetCapacityAsync</code> method because the <code>SetCapacityAsync</code> method internally executes the <code>CountAsync</code> LINQ extension method and requires an active UoW. If you don't want to check the domain service's internals in every case, I suggest always starting a UoW while using domain services or repositories in your tests. After the UoW, I've re-queried <a id="_idIndexMarker1145"/>the same event from the database to check whether the capacity has been updated.</p>
			<p>You can explore the <code>EventManager_Tests</code> class and other test classes inside the <code>EventHub.Domain.Tests</code> project for all details and more complex test cases. In the next section, I will show testing application services.</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor493"/>Testing application services</h2>
			<p>In this <a id="_idIndexMarker1146"/>section, we will examine one more test, written for the <code>EventRegistrationAppService</code> class (defined in the <code>EventHub.Application</code> project of the EventHub solution). <code>EventRegistrationAppService_Tests</code> (defined in the <code>EventHub.Application.Tests</code> project of the EventHub solution) is the test class that contains tests for that application service. You can explore the class inside the solution. Here, I will show it partially to explain how it works.</p>
			<p>Let's start with the test method for registering an event by the current user. You can see this here:</p>
			<pre>[Fact]
public async Task Should_Register_To_An_Event()
{
    Login(_testData.UserAdminId);
    await _eventRegistrationAppService.RegisterAsync(
        _testData.AbpMicroservicesFutureEventId
    );
    var registration = await GetRegistrationOrNull(
        _testData.AbpMicroservicesFutureEventId,
        _currentUser.GetId()
    );    
    registration.ShouldNotBeNull();
}</pre>
			<p>The first <a id="_idIndexMarker1147"/>line sets the current user to <a id="_idIndexMarker1148"/>the admin user, which is needed because the <code>EventRegistrationAppService.RegisterAsync</code> method works for the current user. Let's see how the <code>Login</code> method was implemented, as follows:</p>
			<pre>private void Login(Guid userId)
{
    _currentUser.Id.Returns(userId);
    _currentUser.IsAuthenticated.Returns(true);
}</pre>
			<p>It configures the <code>_currentUser</code> object to return the given <code>userId</code> value when we use its <code>Id</code> property. As you may guess, <code>_currentUser</code> is a mock (fake) object of type <code>ICurrentUser</code>. The mock object is configured in the <code>AfterAddApplication</code> method, as illustrated in the following code snippet:</p>
			<pre>protected override void AfterAddApplication(
    IServiceCollection services)
{
    _currentUser = Substitute.For&lt;ICurrentUser&gt;();
    services.AddSingleton(_currentUser);
}</pre>
			<p>This method overrides the <code>AfterAddApplication</code> method of the <code>AbpIntegratedTest&lt;T&gt;</code> base class. We can override this method to make a last touch to the DI configuration before the initialization phase completes. Here, I've created a mock object using the <code>NSubstitute</code> library and added the object as a singleton service (remember that the last registered class/object is used for a service). In this way, I can change its value, and all the services using <code>ICurrentUser</code> are affected.</p>
			<p>After <a id="_idIndexMarker1149"/>setting the current user, the test method calls the <code>EventRegistrationAppService.RegisterAsync</code> method as you normally <a id="_idIndexMarker1150"/>do. Finally, I checked the database to see whether a registration record was saved. The <code>GetRegistrationOrNull</code> method's implementation is shown in the following code block:</p>
			<pre>private async Task&lt;EventRegistration&gt;
    GetRegistrationOrNull(Guid eventId, Guid userId)
{
    return await WithUnitOfWorkAsync(async () =&gt;
    {
        return await _eventRegistrationRepository
           .FirstOrDefaultAsync(
                x =&gt; x.EventId == eventId &amp;&amp; x.UserId == 
                    userId
        );
    });
}</pre>
			<p>I've used <code>WithUnitOfWorkAsync</code> here again because the <code>FirstOrDefaultAsync</code> method requires an active UoW.</p>
			<p>As we've seen in the examples, writing integration tests is easy and mostly straightforward with ABP Framework. We rarely need to mock services and deal with the dependencies of the service we are targeting for the test.</p>
			<p>Integration tests run slower than unit tests, but they allow you to test the integration between components and additionally test database queries in a way you can't with unit tests. I suggest going balanced and pragmatic—build both unit and integration tests for your solutions.</p>
			<h1 id="_idParaDest-369"><a id="_idTextAnchor494"/>Summary</h1>
			<p>Preparing tests is an essential practice for building any kind of software solution. As we've seen in this chapter, ABP provides the fundamental infrastructure to help you write tests for your applications.</p>
			<p>We have explored unit and integration testing with ABP Framework with examples. I've selected examples from the EventHub solution. That solution also contains more complex tests, and I suggest you explore them.</p>
			<p>By now, you should be writing automated tests to cover your server-side code. You've seen how the ABP startup solution is structured and how the database was mocked. You've learned how to deal with exceptions, UoWs, data seeding, object mocking, and other common test patterns.</p>
			<p>This was the last chapter of the book. If you've read so far and followed the examples, you've learned the fundamentals, features, and best practices of using ABP Framework. You are more than ready to build your ABP based solutions to realize your software ideas.</p>
			<p>You can refer to this book on your development journey, and also check ABP Framework's documentation on <a href="https://docs.abp.io">https://docs.abp.io</a> whenever you need more details and up-to-date information.</p>
			<p>Lastly, feel free to create issues on ABP Framework's GitHub repository if you have any problem: <a href="https://github.com/abpframework/abp">https://github.com/abpframework/abp</a>. I will continue to be one of the active contributors of this great project and try to answer your questions.</p>
			<p>I am Halil İbrahim Kalkan, author of Mastering ABP Framework. I really hope you enjoyed reading this book and found it useful for increasing your productivity and efficiency in ABP Framework. </p>
			<p>It would really help me (and other potential readers!) if you could leave a review on Amazon sharing your thoughts on Mastering ABP Framework here. </p>
			<p>Go to the link below or scan the QR code to leave your review:</p>
			<p><a href="https://packt.link/r/1801079242">https://packt.link/r/1801079242</a></p>
			<div><div><img src="img/QR_Code.jpg" alt=""/>
				</div>
			</div>
			<p>Your review will help me to understand what’s worked well in this book, and what could be improved upon for future editions, so it really is appreciated.</p>
			<p>Best Wishes,</p>
			<div><div><img src="img/Author_signature.jpg" alt=""/>
				</div>
			</div>
			<div><div><img src="img/Author_photo.jpg" alt=""/>
				</div>
			</div>
			<p>Halil İbrahim Kalkan</p>
		</div>
		<div><p class="hidden">     </p>
		</div>
	</body></html>