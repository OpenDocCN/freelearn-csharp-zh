- en: Faster Physics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的物理
- en: Each of the performance-enhancing suggestions we've explored so far has been
    primarily centered on reducing resource costs and avoiding frame rate issues.
    However, at its most fundamental level, seeking peak performance means improving
    the user experience. This is because every frame rate hiccup, every crash, and
    every system requirement that is too costly for a given market ultimately detracts
    from the quality of the product. Physics engines are a unique category of subsystems
    whose behavior and consistency contributes a significant factor toward product
    quality. Spending the time to improve their behavior is often worth the cost.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所探讨的每一个性能提升建议都主要集中在降低资源成本和避免帧率问题。然而，在最根本的层面上，追求峰值性能意味着提升用户体验。这是因为每一个帧率波动、每一次崩溃以及对于特定市场来说过于昂贵的系统要求，最终都会降低产品的质量。物理引擎是一个独特的子系统类别，其行为和一致性对产品质量有着显著的影响。花时间改善它们的行为通常是值得的。
- en: If important collision events get missed, the game freezes while it calculates
    a complex physics event, or the player falls through the floor, these scenarios
    have an obvious and significant negative impact on the quality of gameplay. A
    few glitches are often bearable, but continuous problems will get in the way of
    gameplay. This often results in pulling the player out of the experience, and
    it's a coin-toss whether the user finds it inconvenient, obnoxious, or hilarious.
    Unless our game is explicitly targeting the Comedy Physics genre (games such as
    *QWOP* or *Goat Simulator*), these are situations we should strive to avoid.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重要的碰撞事件被遗漏，游戏在计算复杂的物理事件时会冻结，或者玩家会穿过地板，这些情况对游戏品质有明显的负面影响。一些小故障通常是可以忍受的，但持续的问题会妨碍游戏体验。这通常会导致玩家脱离游戏体验，而用户是否觉得不方便、讨厌或好笑则是一个未知数。除非我们的游戏明确针对喜剧物理类型（如*QWOP*或*Goat
    Simulator*），否则我们应该努力避免这些情况。
- en: Some games may not use physics at all, whereas others require the physics engine
    to handle a considerable number of tasks during gameplay, such as collision detection
    between hundreds of objects, trigger volumes to initiate cutscenes, raycasting
    for player attacks and UI behavior, gathering lists of objects in a given region,
    or even just using physics as eye candy with lots of physical particles flying
    around. Its importance also varies depending on the type of game being created.
    For example, it is essential in platformer and action games to tune the physics
    properly—how the player character reacts to input and how the world reacts to
    the player character are two of the most critical aspects that make the game feel
    responsive and fun, whereas accurate physics may be somewhat less important in
    **Massively Multiplayer Online** (**MMO**) games, which tend to have limited physics
    interaction.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有些游戏可能根本不使用物理引擎，而有些游戏在游戏过程中需要物理引擎处理大量的任务，例如数百个对象之间的碰撞检测、触发体积以启动过场动画、射线投射以进行玩家攻击和UI行为、收集特定区域内的对象列表，或者只是使用物理效果作为视觉糖果，让大量的物理粒子四处飞舞。其重要性也取决于所创建的游戏类型。例如，在平台游戏和动作游戏中，正确调整物理引擎至关重要——玩家角色对输入的反应以及世界对玩家角色的反应是使游戏感觉响应和有趣的最关键的两个方面，而在**大型多人在线**（**MMO**）游戏中，物理交互通常有限，精确的物理可能不那么重要。
- en: 'Therefore, in this chapter, we will cover ways to reduce CPU spikes, overhead,
    and memory consumption through Unity''s physics engine, but also include ways
    to alter physics behavior to improve, or at least maintain, gameplay quality while
    optimizing performance. In this chapter, we will cover the following areas:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将介绍通过Unity的物理引擎来减少CPU峰值、开销和内存消耗的方法，同时也会包括改变物理行为以提升或至少保持游戏品质，同时优化性能的方法。在本章中，我们将涵盖以下内容：
- en: 'Understanding how Unity''s physics engine works:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Unity的物理引擎如何工作：
- en: Timesteps and fixed updates
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间步长和固定更新
- en: Collider types
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞体类型
- en: Collisions
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞
- en: Raycasting
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射线投射
- en: Rigidbody active states
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rigidbody活跃状态
- en: 'Physics performance optimizations:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理性能优化：
- en: How to structure scenes for optimal physics behavior
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建场景以实现最佳的物理行为
- en: Using the most appropriate types for a collider
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最合适的类型进行碰撞体
- en: Optimizing the Collision Matrix
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化碰撞矩阵
- en: Improving physics consistency and avoiding error-prone behavior
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高物理一致性并避免易出错的行为
- en: Ragdolls and other joint-based objects
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布娃娃和其他基于关节的对象
- en: Understanding the physics engine
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解物理引擎
- en: 'Unity technically features two different physics engines: Nvidia''s PhysX for
    3D physics and the open source project Box2D for 2D physics. However, their implementations
    are highly abstracted, and from the perspective of the higher-level Unity API
    that we configure through the main Unity engine, both physics engine solutions
    operate in a functionally identical fashion.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在技术上具有两个不同的物理引擎：Nvidia的PhysX用于3D物理，开源项目Box2D用于2D物理。然而，它们的实现高度抽象，从我们通过主Unity引擎配置的高级Unity
    API的角度来看，这两种物理引擎解决方案以功能上相同的方式运行。
- en: In either case, the more we understand about Unity's physics engines, the more
    sense we can make of possible performance enhancements. So, first, we'll cover
    the theory about how Unity implements these systems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们对Unity的物理引擎了解得越多，我们就能更好地理解可能的性能提升。因此，首先，我们将介绍Unity实现这些系统的理论。
- en: Physics and time
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理和时间
- en: Physics engines generally operate under the assumption that time advances by
    fixed values, and both of Unity's physics engines operate in this manner. Each
    of these iterations is known as a **timestep**. The physics engine will only resolve
    each timestep using precise values of time, which is independent of how much time
    it took to render the previous frame. This is known in Unity as the **fixed update
    timestep**, and it is set to a value of 20 milliseconds by default (50 updates
    per second).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 物理引擎通常假设时间以固定值前进，Unity的两个物理引擎都以这种方式运行。每个迭代都称为**时间步长**。物理引擎将只使用精确的时间值解决每个时间步长，这与渲染前一帧所需的时间无关。在Unity中，这被称为**固定更新时间步长**，默认设置为20毫秒（每秒50次更新）。
- en: It can be challenging to generate consistent results for collisions and forces
    between two different computers if a physics engine uses a variable timestep due
    to differences in architecture (in how floating-point values are represented)
    as well as the latency between clients. Such physics engines tend to generate
    very inconsistent results between multiplayer clients or during recorded replays.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物理引擎使用可变时间步长，由于架构（在如何表示浮点值方面）的差异以及客户端之间的延迟，生成两个不同计算机之间碰撞和力的恒定结果可能会很具挑战性。这种物理引擎往往会在多人客户端之间或记录的重放期间产生非常不一致的结果。
- en: 'The following diagram shows an important snippet of the Unity order of execution
    diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了Unity执行顺序图的一个重要片段：
- en: '![](img/15c8dbf6-83b9-4918-be4f-c86059890645.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15c8dbf6-83b9-4918-be4f-c86059890645.png)'
- en: The full execution order diagram can be found at [http://docs.unity3d.com/Manual/ExecutionOrder.html](http://docs.unity3d.com/Manual/ExecutionOrder.html).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的执行顺序图可以在[http://docs.unity3d.com/Manual/ExecutionOrder.html](http://docs.unity3d.com/Manual/ExecutionOrder.html)找到。
- en: As we can see in the preceding diagram, fixed updates are processed just before
    the physics engine performs its update, and the two are inextricably linked. The
    process begins with determining whether enough time has passed to start the next
    fixed update. Once this is determined, the outcome will vary depending on how
    much time has passed since the last fixed update.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的图中可以看到的，固定更新是在物理引擎执行更新之前处理的，两者密不可分。这个过程从确定是否已经过去了足够的时间以启动下一个固定更新开始。一旦确定这一点，结果将取决于自上次固定更新以来过去的时间量。
- en: If enough time has passed, then the fixed update processes will invoke all `FixedUpdate()`
    callbacks defined across all active MonoBehaviours in the scene, followed by any
    coroutines tied to fixed updates (specifically those that `yield` to `WaitForFixedUpdate`).
    Note that there is no guarantee of execution order for methods invoked during
    either of these processes, so we should never write code under this assumption.
    Once these tasks are done, the physics engine can begin to process the current
    timestep and invoke any necessary trigger and collider callbacks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经过去了足够的时间，那么固定更新过程将调用场景中所有活动MonoBehaviours定义的所有`FixedUpdate()`回调，然后是任何与固定更新相关联的协程（特别是那些`yield`到`WaitForFixedUpdate`的协程）。请注意，在这两个过程中调用的方法执行顺序没有保证，所以我们绝对不应该基于这个假设编写代码。一旦这些任务完成，物理引擎就可以开始处理当前的时间步长并调用任何必要的触发器和碰撞器回调。
- en: Conversely, if too little time has passed since the last fixed update (that
    is, less than 20 milliseconds), then the current fixed update is skipped, and
    all of the tasks listed previously don't happen during the current iteration.
    At this point, input, gameplay logic, and rendering will be allowed to happen
    as normal. Once this activity is complete, Unity checks whether the next fixed
    update is required.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果自上次固定更新以来过去的时间太少（即少于20毫秒），则当前固定更新将被跳过，并且在前一迭代期间不会执行之前列出的所有任务。此时，输入、游戏逻辑和渲染将允许按正常方式发生。一旦这项活动完成，Unity将检查是否需要下一次固定更新。
- en: At high frame rates, rendering updates are likely to complete multiple times
    before the physics engine gets a chance to update itself. As a consequence, fixed
    updates and the physics engine get a higher priority over rendering while also
    forcing the physics simulation into a fixed frame rate.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在高帧率下，渲染更新可能会在物理引擎有机会更新自己之前完成多次。因此，固定更新和物理引擎比渲染具有更高的优先级，同时也迫使物理模拟进入固定帧率。
- en: To ensure that objects move smoothly between fixed updates, physics engines
    (including Unity's) interpolate the visible location of each object between where
    it was during the previous state and where it should be after resolving the current
    state based on how much time remains until the next fixed update. This interpolation
    ensures that objects appear to move smoothly even though their physical positions,
    velocities, and so on are being updated less frequently than the render frame
    rate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保物体在固定更新之间平滑移动，物理引擎（包括Unity的）将在物体在上一状态中的位置和根据剩余时间直到下一次固定更新后它应该所在的位置之间插值每个物体的可见位置。这种插值确保即使物体的物理位置、速度等更新频率低于渲染帧率，物体看起来仍然会平滑移动。
- en: The `FixedUpdate()` callback is a useful place to define any gameplay behavior
    that we want to be frame-rate independent. AI calculations are commonly resolved
    in fixed updates since they tend to be easier to work with if we assume a fixed
    update frequency.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`FixedUpdate()` 回调是一个定义我们希望帧率无关的游戏行为的实用地方。由于假设固定更新频率更容易处理，AI计算通常在固定更新中解决。'
- en: Maximum Allowed Timestep
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大允许时间步长
- en: It is important to note that if a lot of time has passed since the last fixed
    update (for example, the game froze momentarily), then fixed updates will continue
    to be calculated within the same fixed update loop until the physics engine has
    caught up with the current time. For example, if the previous frame took 100 ms
    to render (for example, a sudden CPU spike caused the main thread to block for
    a long time), then the physics engine will need to be updated five times. The
    `FixedUpdate()` method will, therefore, be called five times before `Update()`
    can be called again due to the default fixed update timestep of 20 ms. Of course,
    if there is a lot of physics activity to process during these five fixed updates,
    such that it takes more than 20 ms to resolve them all, then the physics engine
    will need to invoke a sixth update.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果自上次固定更新以来已经过去了很多时间（例如，游戏瞬间冻结），那么固定更新将继续在同一个固定更新循环中进行计算，直到物理引擎赶上当前时间。例如，如果前一帧渲染耗时100毫秒（例如，突然的CPU峰值导致主线程长时间阻塞），那么物理引擎需要更新五次。因此，`FixedUpdate()`
    方法将在再次调用 `Update()` 之前被调用五次，这是由于默认的固定更新时间步长为20毫秒。当然，如果在这五次固定更新期间有大量的物理活动需要处理，以至于处理它们需要超过20毫秒，那么物理引擎将需要调用第六次更新。
- en: Consequently, it's possible during moments of heavy physics activity that the
    physics engine takes more time to process a fixed update than the amount of time
    it is simulating. For example, if it took 30 ms to process a fixed update simulating
    20 ms of gameplay, then it has fallen behind, requiring it to handle more timesteps
    to try and keep up, but this could cause it to fall back even further, requiring
    it to process even more timesteps, and so on. In these situations, the physics
    engine is never able to escape the fixed update loop and allow another frame to
    render. This problem is often known as the **spiral of death**. However, to prevent
    the physics engine from locking up our game during these moments, there is a maximum
    amount of time that the physics engine is allowed to process each fixed update
    loop. This threshold is called the **Maximum Allowed Timestep**, and if the current
    batch of fixed updates takes too long to process, then it will simply stop and
    forgo further processing until the next render update completes. This design allows
    the Rendering Pipeline to at least render the current state and allow for user
    input and gameplay logic to make some decisions during rare moments where the
    physics engine has gone ballistic (pun intended).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在物理活动频繁的时刻，物理引擎处理固定更新所需的时间可能会超过它模拟的时间。例如，如果处理固定更新模拟了 20 毫秒的游戏时间需要了 30 毫秒，那么它就落后了，需要处理更多的时间步来尝试跟上，但这可能会导致它进一步落后，需要处理更多的时间步，依此类推。在这些情况下，物理引擎永远无法逃离固定更新循环并允许渲染另一帧。这个问题通常被称为
    **死亡螺旋**。然而，为了防止物理引擎在这些时刻锁定我们的游戏，物理引擎被允许处理每个固定更新循环的最大时间量。这个阈值被称为 **Maximum Allowed
    Timestep**，如果当前批次的固定更新处理时间过长，那么它将简单地停止，并放弃进一步的处理，直到下一次渲染更新完成。这种设计允许渲染管线至少渲染当前状态，并允许在物理引擎出现异常（故意为之）的罕见时刻，让用户输入和游戏逻辑做出一些决策。
- en: This setting can be accessed through Edit | Project Settings | Time | Maximum
    Allowed Timestep.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置可以通过 Edit | Project Settings | Time | Maximum Allowed Timestep 访问。
- en: Physics updates and runtime changes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理更新和运行时更改
- en: When the physics engine processes a given timestep, it must move any active
    `Rigidbody` objects (GameObjects with a `Rigidbody` component), detect any new
    collisions, and invoke the collision callbacks on the corresponding objects. The
    Unity documentation makes an explicit note that changes to `Rigidbody` objects
    should be handled within `FixedUpdate()` and other physics callbacks for precisely
    this reason. These methods are tightly coupled with the update frequency of the
    physics engine as opposed to other parts of the game loop, such as `Update()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理引擎处理一个给定的时间步长时，它必须移动任何活动的 `Rigidbody` 对象（具有 `Rigidbody` 组件的 GameObject），检测任何新的碰撞，并在相应的对象上调用碰撞回调。Unity
    文档明确指出，对 `Rigidbody` 对象的更改应在 `FixedUpdate()` 和其他物理回调中处理，正是出于这个原因。这些方法与物理引擎的更新频率紧密耦合，而不是与其他游戏循环的部分，如
    `Update()`。
- en: This means that callbacks such as `FixedUpdate()` and `OnTriggerEnter()` are
    safe places to make `Rigidbody` changes, whereas methods such as `Update()` and
    coroutines yielding on `WaitForSeconds` or `WaitForEndOfFrame` are not. Ignoring
    this advice could cause unexpected physics behavior, as multiple changes may be
    made to the same object before the physics engine is given a chance to catch and
    process all of them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着像 `FixedUpdate()` 和 `OnTriggerEnter()` 这样的回调是进行 `Rigidbody` 变更的安全地方，而像 `Update()`
    和在 `WaitForSeconds` 或 `WaitForEndOfFrame` 上产生协程的方法则不是。忽视这条建议可能会导致意外的物理行为，因为物理引擎有机会捕捉和处理所有更改之前，可能对同一对象进行多次更改。
- en: 'It''s particularly dangerous to apply forces or impulses to objects in `Update()`
    callbacks without taking into account the frequency of those calls. For instance,
    imagine applying a 10 Newton force in the `Update` function while the player holds
    down a key: the resultant velocity will be completely different between two different
    devices than if we did the same thing in a fixed update. In fact, we can''t rely
    on the number of `Update()` calls being consistent. However, doing so in a `FixedUpdate()`
    callback will be much more consistent. Therefore, we must ensure that all physics-related
    behavior is handled in the appropriate callbacks, or we will risk introducing
    some especially confusing gameplay bugs that are very hard to reproduce.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`回调中应用力或冲量，而不考虑这些调用的频率，尤其危险。例如，想象一下在玩家按住键的同时在`Update`函数中应用10牛顿的力：在两个不同的设备上，由于我们在固定更新中做了同样的事情，结果速度将完全不同。实际上，我们不能依赖于`Update()`调用的数量保持一致。然而，在`FixedUpdate()`回调中这样做将更加一致。因此，我们必须确保所有与物理相关的行为都在适当的回调中处理，否则我们可能会引入一些特别难以复现的游戏玩法错误。
- en: It logically follows that the more time we spend in any given fixed update iteration,
    the less time we have for the next gameplay and rendering pass. Most of the time
    this results in minor, unnoticeable background processing tasks, since the physics
    engine barely has any work to do, and the `FixedUpdate()` callbacks have a lot
    of time to complete their work. However, in some games, the physics engine could
    be performing a lot of calculations during each fixed update. This bottlenecking
    in physics processing time will affect our frame rate, causing it to plummet as
    the physics engine is tasked with greater and higher workloads. Essentially, the
    Rendering Pipeline will try to proceed as usual, but whenever it's time for a
    fixed update, in which the physics engine takes a long time to process, the Rendering
    Pipeline would have very little time to generate the current display before the
    frame is due, causing a sudden stutter. This is in addition to the visual effect
    of the physics engine stopping early because it hit Maximum Allowed Timestep.
    All of this together would generate an inferior user experience.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑上可以推断，我们在任何给定的固定更新迭代中花费的时间越多，我们用于下一轮游戏和渲染的时间就越少。大多数情况下，这会导致一些微不足道的、不易察觉的后台处理任务，因为物理引擎几乎没有工作要做，而`FixedUpdate()`回调有足够的时间来完成它们的工作。然而，在某些游戏中，物理引擎在每次固定更新期间可能会执行大量的计算。这种在物理处理时间上的瓶颈将影响我们的帧率，导致帧率随着物理引擎承担更大的工作负载而急剧下降。本质上，渲染管线将尝试按常规进行，但在需要固定更新时，物理引擎需要花费很长时间来处理，渲染管线将几乎没有时间在帧到期之前生成当前显示，导致突然的卡顿。这还加上物理引擎因为达到最大允许时间步长而提前停止的视觉效果。所有这些加在一起将产生一个较差的用户体验。
- en: Hence, to keep a smooth and consistent frame rate, we will need to free up as
    much time as we can for rendering by minimizing the amount of time the physics
    engine takes to process any given timestep. This applies in both the best-case
    scenario (nothing moving) and worst-case scenario (everything smashing into everything
    else at once). There are several time-related features and values we can tweak
    within the physics engine to avoid performance pitfalls such as these.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持流畅和一致的帧率，我们需要通过最小化物理引擎处理任何给定时间步所需的时间来尽可能多地释放渲染时间。这适用于最佳情况（没有移动）和最坏情况（所有东西同时撞击到其他东西）。我们可以在物理引擎中调整几个与时间相关的特性和值，以避免这些性能陷阱。
- en: Static colliders and dynamic colliders
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态碰撞体和动态碰撞体
- en: There is a rather extreme namespace conflict with the terms **static** and **dynamic** in
    Unity. When static is used, it usually means that the object or process under
    discussion is not moving, remains unchanged, or exists in only one location, whereas
    dynamic means the opposite—objects or processes that tend to move or change. However,
    it's important to remember that each of these is a separate topic, and usage of
    the terms static and dynamic means something different in each case. We have already
    introduced the Static sub flags for GameObjects, the dynamic batching and static
    batching systems, and the concepts of static classes, static variables, and static
    functions in the C# language. So, just to be extra-confusing, Unity also has the
    concept of static and dynamic colliders.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中关于**静态**和**动态**术语存在相当极端的命名空间冲突。当使用静态时，通常意味着正在讨论的对象或过程是不动的，保持不变，或者只存在于一个位置，而动态则相反——倾向于移动或改变的对象或过程。然而，重要的是要记住，这些都是独立的话题，静态和动态术语的用法在每个情况下都不同。我们已经介绍了GameObject的静态子标志、动态批处理和静态批处理系统，以及C#语言中的静态类、静态变量和静态函数的概念。所以，为了更加混乱，Unity还有静态和动态碰撞体的概念。
- en: Dynamic colliders mean GameObjects that contain both a `Collider` component
    (which could be one of several types) and a `Rigidbody` component. By attaching
    `Rigidbody` to the same object as a collider, the physics engine will treat that
    collider as the bounding volume of a physical object that must react to outside
    forces (such as gravity) and collisions with other Rigidbodies. If we collide
    one dynamic collider into another, they will both react based on Newton's laws
    of motion (or at least as best as a computer using floating-point arithmetic is
    capable of).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 动态碰撞体指的是包含一个`Collider`组件（可能是几种类型之一）和一个`Rigidbody`组件的GameObject。通过将`Rigidbody`附加到与碰撞体相同的对象上，物理引擎会将该碰撞体视为必须对外部力（如重力）和与其他刚体碰撞做出反应的物理对象的边界体积。如果我们让一个动态碰撞体与另一个碰撞体相撞，它们将根据牛顿运动定律（或者至少是计算机使用浮点运算所能达到的最佳程度）做出反应。
- en: We can also have colliders that do not have a `Rigidbody` component attached,
    and these are called static colliders. These effectively work as invisible barriers
    that dynamic colliders can collide into, but the static collider will not react
    in response. To think of it another way, imagine objects without a `Rigidbody` component
    as having infinite mass. No matter how hard you throw a rock into an object of
    infinite mass, it will never move, but you can still expect the rock to react
    like it just hit a solid wall. This makes static colliders ideal for world barriers
    and other obstacles that must not move.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以有不含`Rigidbody`组件的碰撞体，这些被称为静态碰撞体。它们实际上充当不可见的障碍物，动态碰撞体可以与之碰撞，但静态碰撞体不会做出反应。换一种方式来想，想象一下没有`Rigidbody`组件的对象具有无限质量。无论你多么用力地把石头扔向具有无限质量的对象，它都不会移动，但你仍然可以期待石头像刚刚撞到实墙一样做出反应。这使得静态碰撞体非常适合作为世界障碍物和其他必须不动的障碍物。
- en: The physics engine automatically separates dynamic and static colliders into
    two different data structures, each optimized to handle the types of collider
    present. This helps to simplify future processing tasks since, for example, there's
    no point in resolving collisions and impulses between two static colliders.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 物理引擎自动将动态和静态碰撞体分别放入两个不同的数据结构中，每个数据结构都针对现有碰撞体的类型进行了优化。这有助于简化未来的处理任务，因为例如，在两个静态碰撞体之间解决碰撞和冲量是没有意义的。
- en: Collision detection
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: 'There are three settings for collision detection in Unity, which can be configured
    in a `RigidBody` component''s Collision Detection property: Discrete, Continuous,
    and ContinuousDynamic.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中碰撞检测有三个设置，可以在`RigidBody`组件的碰撞检测属性中进行配置：离散、连续和连续动态。
- en: The Discrete setting enables Discrete Collision Detection, which effectively
    teleports objects a small distance every timestep based on their velocity and
    how much time has passed. Once all of the objects have been moved, it then performs
    a bounding volume check for any overlaps, treats them as collisions, and resolves
    them based on their physical properties and how they overlap. This method risks
    collisions being missed if small objects move too quickly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 离散设置启用离散碰撞检测，它基于物体的速度和经过的时间在每个时间步长将物体传送一小段距离。一旦所有物体都移动了，它就会执行边界体积检查，以查找任何重叠部分，将它们视为碰撞，并根据它们的物理属性和重叠方式解决它们。如果小物体移动得太快，这种方法可能会错过碰撞。
- en: 'The following diagram shows how Discrete Collision Detection works to catch
    two objects as they teleport from one location to the next:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了离散碰撞检测是如何在物体从一个位置瞬移到下一个位置时捕捉两个物体的：
- en: '![](img/fd505db6-74a1-4214-a3c8-9c070ca7d3e8.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd505db6-74a1-4214-a3c8-9c070ca7d3e8.png)'
- en: Either of the remaining settings will enable Continuous Collision Detection,
    which works by interpolating colliders from their starting and ending positions
    for the current timestep and checking for any collisions along the way. This reduces
    the risk of missed collisions and generates a more accurate simulation at the
    expense of a significantly higher CPU overhead compared to Discrete Collision
    Detection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的任一设置都将启用连续碰撞检测，它通过在当前时间步长内插值碰撞器从起始位置到结束位置，并检查沿途是否有任何碰撞。这减少了漏检碰撞的风险，并以比离散碰撞检测显著更高的
    CPU 开销为代价，生成更精确的模拟。
- en: The Continuous setting enables Continuous Collision Detection only between the
    given collider and static colliders. Collisions between the same collider and
    dynamic colliders will still make use of Discrete Collision Detection.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 连续设置仅允许在给定的碰撞器和静态碰撞器之间启用连续碰撞检测。相同碰撞器与动态碰撞器之间的碰撞仍然会使用离散碰撞检测。
- en: Meanwhile, the ContinuousDynamic setting enables Continuous Collision Detection
    between the collider and all static and dynamic colliders, making it the most
    expensive in terms of resources.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，ContinuousDynamic 设置允许碰撞器与所有静态和动态碰撞器之间启用连续碰撞检测，因此在资源消耗方面是最昂贵的。
- en: 'The following diagram shows how the Discrete Collision Detection and Continuous
    Collision Detection methods work for a pair of small, fast-moving objects:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了离散碰撞检测和连续碰撞检测方法是如何作用于一对小型、快速移动的物体的：
- en: '![](img/1de57846-1533-4fea-8ce1-93e3235da907.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1de57846-1533-4fea-8ce1-93e3235da907.png)'
- en: This is an extreme example for the sake of illustration. In the case of Discrete
    Collision Detection, we can observe that the objects are teleporting a distance
    around four times their size in a single timestep, which would typically only
    happen with very small objects with very high velocities, and is, hence, very
    rare if our game is running optimally. In the overwhelming majority of cases,
    the distances the objects travel in a single 20 ms timestep are much smaller relative
    to the size of the object, and so the collision is easily caught by Discrete Collision
    Detection methods.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个为了说明目的的极端例子。在离散碰撞检测的情况下，我们可以观察到物体在单个时间步长内移动的距离是其大小的四倍左右，这通常只会发生在非常小且速度非常高的物体上，因此，如果我们的游戏运行得最优，这种情况是非常罕见的。在绝大多数情况下，物体在单个
    20 毫秒时间步长内移动的距离相对于物体的大小来说要小得多，因此碰撞很容易被离散碰撞检测方法捕捉到。
- en: Collider types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞器类型
- en: 'There are four different types of 3D colliders in Unity. In order of the lowest
    performance cost to the greatest, they are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中有四种不同的 3D 碰撞器类型。按照性能成本从低到高的顺序，如下所示：
- en: Sphere
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球体
- en: Capsule
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶囊体
- en: Box
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形
- en: Mesh
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格
- en: The first three collider types are often called **primitives** and maintain
    precise shapes, although they can generally be scaled in different directions
    to meet specific needs. Mesh Colliders can, however, be customized to a particular
    shape depending on the assigned mesh. There are also three types of 2D Collider—Circle,
    Box, and Polygon—that are functionally similar to Sphere, Box, and Mesh Colliders,
    respectively. All of the following information is mostly transferable to the equivalent
    2D shape.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前三种碰撞类型通常被称为**原语**，并保持精确的形状，尽管它们通常可以沿不同方向缩放以满足特定需求。然而，网格碰撞器可以根据分配的网格定制为特定形状。还有三种类型的
    2D 碰撞器——圆形、矩形和多边形，它们的功能分别类似于球体、矩形和网格碰撞器。以下所有信息大多可以转移到等效的 2D 形状。
- en: Note that we can also generate cylindrical 3D objects in Unity, but this is
    only for its graphical representation. Auto-generated cylinder shapes use Capsule
    Colliders to represent their physical bounding volume, which may not create the
    expected physics behavior.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也可以在 Unity 中生成圆柱形 3D 对象，但这仅限于其图形表示。自动生成的圆柱形状使用胶囊体碰撞器来表示其物理边界体积，这可能会产生不符合预期的物理行为。
- en: 'Also, there are two varieties of Mesh Collider: **Convex** and **Concave**.
    The difference is that a Concave shape features at least one internal angle (an
    angle between two inside edges of the shape) of greater than 180 degrees. To illustrate
    this, the following diagram shows the difference between **Convex** and **Concave**
    shapes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，网格碰撞体有两种类型：**凸面**和**凹面**。区别在于凹面形状至少有一个大于180度的内部角度（形状两个内部边之间的角度）。为了说明这一点，以下图表显示了**凸面**和**凹面**形状之间的区别：
- en: '![](img/5c79077d-411e-41e8-adb2-68f957287e8a.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c79077d-411e-41e8-adb2-68f957287e8a.png)'
- en: An easy way to remember the difference between a Convex and Concave shape is
    that a Concave shape has at least one cave within it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆凸面和凹面形状之间区别的一个简单方法是，凹面形状在其内部至少有一个洞穴。
- en: Both Mesh Collider types use the same component (a `MeshCollider` component).
    The type of Mesh Collider that gets generated is toggled using the Convex checkbox.
    Enabling this option will allow the object to collide with all primitive shapes (Spheres,
    Boxes, and so on) as well as other Mesh Colliders with Convex enabled.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 两种网格碰撞体类型使用相同的组件（一个`MeshCollider`组件）。通过凸面复选框切换生成的网格碰撞体类型。启用此选项将允许对象与所有原始形状（球体、盒子等）以及其他启用了凸面的网格碰撞体发生碰撞。
- en: Also, if the Convex checkbox is enabled for a Mesh Collider with a Concave shape,
    then the physics engine will automatically simplify it, generating a collider
    with the nearest Convex shape it can.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果对于一个具有凹面形状的网格碰撞体启用了凸面复选框，那么物理引擎将自动简化它，生成一个具有最近凸面形状的碰撞体。
- en: In the preceding example, if we imported the Concave mesh on the right and enable
    the Convex checkbox, it would generate a collider shape closer to the Convex shape
    on the left. In either case, the physics engine will attempt to generate a collider
    that matches the shape of the attached mesh with an upper limit of 255 vertices.
    If the target mesh has more vertices than this, it will throw an error during
    mesh generation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果我们导入右侧的凹面网格并启用凸面复选框，它将生成一个更接近左侧凸面形状的碰撞体形状。在任何情况下，物理引擎都将尝试生成一个与附加网格形状匹配的碰撞体，其顶点数上限为255。如果目标网格的顶点数超过这个数，在网格生成过程中将抛出错误。
- en: '`Collider` components also contain the `IsTrigger` property, allowing them
    to be treated as nonphysical objects but still invoke physics events when other
    colliders enter or leave them. These are called **trigger volumes**. Normally,
    a collider''s `OnCollisionEnter()`, `OnCollisionStay()`, and `OnCollisionExit()`
    callbacks are called when another collider touches, keeps touching (each timestep),
    or stops touching it, respectively. However, when the collider is used as a trigger
    volume, the `OnTriggerEnter()`, `OnTriggerStay()`, and `OnTriggerExit()` callbacks
    will be used instead.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collider`组件还包含`IsTrigger`属性，允许它们被视为非物理对象，但在其他碰撞体进入或离开它们时仍然可以触发物理事件。这些被称为**触发体积**。通常，当另一个碰撞体接触、保持接触（每个时间步）或停止接触时，分别调用碰撞体的`OnCollisionEnter()`、`OnCollisionStay()`和`OnCollisionExit()`回调。然而，当碰撞体用作触发体积时，将使用`OnTriggerEnter()`、`OnTriggerStay()`和`OnTriggerExit()`回调。'
- en: Note that due to the complexity of resolving inter-object collisions, Concave
    Mesh Colliders cannot also be dynamic colliders. Concave shapes can only be used
    as static colliders or trigger volumes. If we attempt to add a `Rigidbody` component
    to a Concave Mesh Collider, Unity will ignore it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于解决物体间碰撞的复杂性，凹面网格碰撞体不能也是动态碰撞体。凹面形状只能用作静态碰撞体或触发体积。如果我们尝试向凹面网格碰撞体添加`Rigidbody`组件，Unity将忽略它。
- en: 'What if you *really* need a Concave Mesh Collider acting as a `Rigidbody` component?
    The solution is to divide the object into a composition of separate Convex Mesh
    Colliders: for instance, you may want to compose an L-shaped `Rigidbody` by combining
    two convex boxes. Unfortunately, because this is a delicate decision, there is
    no automatic way to do that, and you need to perform such decomposition by hand.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你**真正**需要一个作为`Rigidbody`组件使用的凹面网格碰撞体？解决方案是将对象分解为多个独立的凸面网格碰撞体的组合：例如，你可能想通过组合两个凸面盒子来创建一个L形的`Rigidbody`。不幸的是，因为这是一个微妙的决策，没有自动化的方法来做这件事，你需要手动进行这种分解。
- en: The Collision Matrix
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞矩阵
- en: The physics engine features a Collision Matrix that defines which objects are
    allowed to collide with which other objects. Objects that do not fit this matrix
    are automatically ignored by the physics engine when the time comes to resolve
    bounding volume overlaps and collisions. This saves on physics processing during
    collision detection stages and allows the objects to move through one another
    without any collisions taking place.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 物理引擎具有一个碰撞矩阵，它定义了哪些对象可以与哪些其他对象发生碰撞。当需要解决边界体积重叠和碰撞时，不符合此矩阵的对象将被物理引擎自动忽略。这有助于在碰撞检测阶段节省物理处理时间，并允许物体相互移动而不会发生任何碰撞。
- en: The Collision Matrix can be accessed through Edit | Project Settings | (Physics
    / Physics2D) | Layer Collision Matrix.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过“编辑 | 项目设置 | （物理 / 物理2D）| 层碰撞矩阵”访问碰撞矩阵。
- en: The Collision Matrix system works through Unity's Layer system. The matrix represents
    every possible Layer-to-Layer combination that might be possible, and enabling
    a checkbox means that colliders in both of those Layers will be checked during
    the collision detection phase. Note that there's no way to allow only one of the
    two objects to respond to the collision. If one Layer can collide with another,
    then they must both respond to the collision. However, static colliders are an
    exception since they aren't allowed to react physically to collisions (although
    they still receive the `OnCollision...()` callbacks).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞矩阵系统通过Unity的层系统工作。矩阵代表可能出现的每个层到层组合，勾选复选框意味着在碰撞检测阶段将检查这两个层中的碰撞体。请注意，没有方法可以仅允许两个对象中的一个响应碰撞。如果一个层可以与另一个层碰撞，那么它们都必须响应碰撞。然而，静态碰撞体是一个例外，因为它们不允许物理上对碰撞做出反应（尽管它们仍然会接收到`OnCollision...()`回调）。
- en: Note that we are limited to only 32 total Layers for our entire project (since
    the physics engine uses a 32-bit bitmask to determine inter-Layer collision opportunities),
    so we must organize our objects into sensible Layers that will extend throughout
    the entire lifetime of the project. If for whatever reason, 32 Layers are not
    enough for our project, then we might need to find cunning ways to reuse Layers
    or remove Layers that aren't necessary.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们整个项目只能使用32个总层（因为物理引擎使用32位掩码来确定层间碰撞机会），因此我们必须将对象组织成合理的层，这些层将贯穿整个项目的生命周期。如果出于任何原因，32个层不足以满足我们的项目需求，那么我们可能需要找到巧妙的方法来重复使用层或删除不必要的层。
- en: Rigidbody active and sleeping states
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Rigidbody`的活跃和休眠状态'
- en: Every modern physics engine shares a standard optimization technique, where
    by objects that have come to rest have their internal state changed from an active
    state to a sleeping state. While `Rigidbody` is in the sleeping state, little
    to no processor time will be spent during fixed updates to update the object until
    an external force or collision event has awoken it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个现代物理引擎都共享一个标准的优化技术，即静止的物体将它们的内部状态从活跃状态更改为休眠状态。当`Rigidbody`处于休眠状态时，在固定更新期间将不会花费处理器时间来更新对象，直到外力或碰撞事件将其唤醒。
- en: The value of measurement that is used to determine what at rest means tends
    to vary among different physics engines; it could be calculated using linear and
    rotational speed, kinetic energy, momentum, or some other physical properties
    of `Rigidbody`. Both of Unity's physics engines work by evaluating the object's
    mass-normalized kinetic energy, which essentially boils down to the magnitude
    of its velocity, squared.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用于确定静止状态值的测量值在不同物理引擎中往往有所不同；它可以使用线性速度、角速度、动能、动量或其他`Rigidbody`的物理属性来计算。Unity的两个物理引擎都是通过评估物体的质量归一化动能来工作的，这本质上等同于其速度大小的平方。
- en: If the object's velocity has not exceeded some threshold value after a short
    time, then the physics engine will assume that the object will no longer need
    to move again until it has undergone a new collision, or a new force has been
    applied to it. Until then, the sleeping object will maintain its current position.
    Setting the threshold value too low would mean objects are much less likely to
    go to sleep, so we will keep paying a small processing cost within the physics
    engine every fixed update, even though it is not doing anything important. Meanwhile,
    setting the threshold value too high would mean slow-moving objects will appear
    to jerk to a sudden stop once the physics engine decides that they need to go
    to sleep. The threshold value that controls the sleeping state can be modified
    under Edit | Project Settings | Physics | Sleep Threshold. We can also get a count
    of the total number of active `Rigidbody` objects from the Physics Area of the
    Profiler window.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物体在短时间内速度没有超过某个阈值，那么物理引擎将假设物体将不再需要移动，直到它经历了新的碰撞，或者对其施加了新的力。在此之前，休眠的物体将保持其当前位置。设置阈值过低意味着物体不太可能进入休眠状态，因此我们将在物理引擎的每次固定更新中持续支付少量的处理成本，即使它没有做任何重要的事情。同时，设置阈值过高意味着缓慢移动的物体在物理引擎决定它们需要进入休眠状态时，会突然停止。控制休眠状态的阈值可以在“编辑
    | 项目设置 | 物理 | 休眠阈值”下修改。我们还可以从Profiler窗口的物理区域获取活动`Rigidbody`对象的总数。
- en: Note that sleeping objects are not removed entirely from the simulation. If
    a moving `Rigidbody` approaches the sleeping object, then it must still perform
    checks to see whether nearby objects have collided with it, which would reawaken
    the sleeping object, reintroducing it to the simulation for processing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，休眠物体并没有完全从模拟中移除。如果一个移动的`Rigidbody`接近休眠物体，那么它仍然必须执行检查，以确定附近物体是否与之碰撞，这将重新唤醒休眠物体，将其重新引入模拟以进行处理。
- en: Ray and object casting
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射线和物体投射
- en: Another common feature of physics engines is the ability to cast a ray from
    one point to another and generate collision information with one or more of the
    objects in its path. This is known as **raycasting**. It is pretty common to implement
    several gameplay mechanics through raycasting, such as firing a gun. This is typically
    implemented by performing raycasts from the player to the target location and
    finding any viable targets in its path (even if it's just a wall).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个物理引擎的常见特性是能够从一个点到另一个点投射一条射线，并与其路径上的一个或多个物体生成碰撞信息。这被称为**射线投射**。通过射线投射实现几个游戏机制是很常见的，例如开枪。这通常是通过从玩家到目标位置执行射线投射，并找到其路径上的任何有效目标（即使只是一个墙壁）来实现的。
- en: We can also obtain a list of targets within a finite distance of a fixed point
    in space using a `Physics.OverlapSphere()` check. This is typically used to implement
    area-of-effect gameplay features, such as grenade or fireball explosions. We can
    even cast entire objects forward in space using `Physics.SphereCast()` and `Physics.CapsuleCast()`.
    These methods are often used to simulate wide laser beams, or if we want to see
    what would be in the path of a moving character.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Physics.OverlapSphere()`检查在空间中固定点有限距离内的目标列表。这通常用于实现区域效果游戏特性，例如手榴弹或火球爆炸。我们甚至可以使用`Physics.SphereCast()`和`Physics.CapsuleCast()`将整个物体向前投射。这些方法通常用于模拟宽激光束，或者如果我们想看看移动角色的路径上会有什么。
- en: Debugging physics
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试物理
- en: 'Physics bugs usually fall into two categories: an object pair collided/didn''t
    collide when it shouldn''t have/should have, or the objects collided but something
    unexpected happened after the fact. The former case is generally easier to debug;
    it is often either due to mistakes in the Collision Matrix, incorrect Layers used
    in raycasting, or object colliders being the wrong size or shape. The latter case
    is often much more challenging to resolve because of three big problems:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 物理错误通常分为两类：一个物体对在它不应该发生碰撞时发生了碰撞/没有发生碰撞，或者物体发生了碰撞，但在之后发生了意料之外的事情。前者通常更容易调试；这通常是由于碰撞矩阵中的错误、在光线投射中使用的不正确的层，或者物体碰撞器的尺寸或形状不正确。后者通常由于三个大问题而更具挑战性：
- en: Determining which collided objects caused the issue
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定哪些碰撞物体导致了问题
- en: Determining the conditions of the collision just before the resolution
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定碰撞解决前的碰撞条件
- en: Reproducing the collision
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新模拟碰撞
- en: Any of these three pieces of information would make resolution much easier,
    but they can all be difficult to obtain in some circumstances.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这三部分信息中的任何一部分都会使问题解决变得容易得多，但在某些情况下，它们都很难获得。
- en: The Profiler provides some measure of information in the Physics and Physics
    (2D) Areas (for 3D and 2D physics, respectively), which can be moderately useful.
    We can get a measure of how much CPU activity is being spent on all Rigidbodies
    and groups of Rigidbodies isolated to different types such as dynamic colliders,
    static colliders, kinematic objects, trigger volumes, constraints (used to simulate
    hinges and other connected physics objects), and contacts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器在物理和物理（二维）区域（分别对应3D和2D物理）提供了一些信息量，这可以是有一定帮助的。我们可以了解所有刚体和不同类型（如动态碰撞体、静态碰撞体、运动学对象、触发体积、约束（用于模拟铰链和其他连接的物理对象）和接触）的刚体组在CPU活动上花费了多少时间。
- en: The Physics 2D Area contains a little more information such as the number of
    sleeping and active Rigidbodies and how long processing the Timestep took. The
    Detailed Breakdown View provides even more information in both cases. This information
    helps us to keep an eye on the physics performance, but it doesn't tell us much
    about what went wrong in the event we find a bug in our physics behavior.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 物理二维区域包含一些额外的信息，例如休眠和活动刚体数量以及处理时间步长所需的时间。详细分解视图在这两种情况下都提供了更多信息。这些信息有助于我们关注物理性能，但如果我们发现物理行为中存在错误，它并不能告诉我们太多关于出错原因的信息。
- en: A tool that is better suited to the task of helping us to debug physics issues
    is the Physics Debugger, which can be opened via Window | Analysis | Physics Debugger.
    This tool can help us to filter out different types of colliders from the Scene
    window to give us a better idea of which objects collide with one another. Of
    course, this does not help too much in determining the conditions of the problem
    and reproducing issues.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更适合帮助我们调试物理问题的工具是物理调试器，可以通过“窗口”|“分析”|“物理调试器”打开。这个工具可以帮助我们从场景窗口中过滤出不同类型的碰撞体，从而更好地了解哪些对象相互碰撞。当然，这并不能太多地帮助我们确定问题的条件并重现问题。
- en: Note that settings in the Physics Debugger do not affect object visibility in
    the Game window.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，物理调试器中的设置不会影响游戏窗口中的对象可见性。
- en: Unfortunately, there isn't much secret advice to be given for the remaining
    problems. Catching information about collisions before or when they happen involves
    typically a lot of targeted breakpoints in an `OnCollisionEnter()` or `OnTriggerEnter()`
    callback to catch the problem in the act and using step-through debugging until
    the source of the issue becomes apparent. As a last resort, we can add `Debug.Log()`
    statements to log important information just before the problem occurs, although
    this can be a frustrating exercise because we sometimes don't know what information
    we need to log or which objects to log from, and so we end up adding logs to everything.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，对于剩余的问题，没有太多秘密建议可以提供。在碰撞发生之前或发生时捕捉有关碰撞的信息通常需要在`OnCollisionEnter()`或`OnTriggerEnter()`回调中设置许多目标断点，以捕捉问题发生时的状态，并使用单步调试直到问题的根源变得明显。作为最后的手段，我们可以在问题发生之前添加`Debug.Log()`语句来记录重要信息，尽管这可能是一项令人沮丧的练习，因为我们有时不知道需要记录哪些信息，或者从哪些对象中记录，因此我们最终将日志添加到所有内容中。
- en: Another frequent source of headaches is trying to reproduce physics problems.
    Reproducing collisions is always a challenge due to the non-deterministic nature
    between user input (typically handled in `Update()`) and physics behavior (processed
    in `FixedUpdate()`). Even though physics timesteps occur with relative regularity,
    the simulation will have different timings on each `Update()` between one session
    and the next, so also, if we recorded user input timings and automatically replayed
    the scene, trying to apply the recorded inputs at the moments they were applied
    isn't going to be precisely the same every time, and so we may not get the same
    result.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的头痛来源是尝试重现物理问题。由于用户输入（通常在`Update()`中处理）和物理行为（在`FixedUpdate()`中处理）之间的非确定性，重现碰撞始终是一个挑战。尽管物理时间步长发生相对规律，但模拟在每个`Update()`会话之间会有不同的时间，因此，如果我们记录了用户输入时间并自动回放场景，试图在输入应用的时刻应用记录的输入并不总是完全相同，因此我们可能不会得到相同的结果。
- en: Moving user input handling to `FixedUpdate()` is possible, and helpful if user
    input controls `Rigidbody` behavior such as applying forces in different directions
    while the player holds down certain keys. However, this will tend to lead to input
    latency or *lag*, since it will be anywhere from 0 to 20 ms (based on the fixed
    update timestep frequency) before the physics engine can respond to the key being
    pressed. Instantaneous inputs, such as jumping or activating an ability, are always
    best handled in `Update()` to avoid
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户输入处理移动到`FixedUpdate()`是可能的，如果用户输入控制`Rigidbody`行为，例如在玩家按下某些键的同时施加不同方向的力，这将是很有帮助的。然而，这往往会引起输入延迟或*滞后*，因为物理引擎对按键响应需要从0到20毫秒（基于固定更新时间步频率）的时间。瞬间的输入，如跳跃或激活能力，始终最好在`Update()`中处理，以避免
- en: missing keystrokes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的按键。
- en: Helper functions such as `Input.GetKeyDown()` would only return `true` for the
    frame the player presses the given key and will return `false` during the next
    `Update()`. If we tried to read a key-down event during `FixedUpdate()`, we would
    never know that the user pressed the key, unless a physics timestep just happens
    to occur between these two frames. This can be worked around with an input buffering/tracking
    system, but this is certainly more trouble than its worth if we're implementing
    it merely to replicate a physics bug.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数，如`Input.GetKeyDown()`，仅在玩家按下指定键的帧返回`true`，在下一个`Update()`期间返回`false`。如果我们试图在`FixedUpdate()`期间读取键按下事件，除非恰好在这两个帧之间发生物理时间步，否则我们永远不会知道用户是否按下了键。这可以通过输入缓冲/跟踪系统来解决，但如果仅仅是为了复制物理错误而实现它，这无疑是一个麻烦大于其价值的事情。
- en: Ultimately, experience and persistence are the only right ways to debug most
    physics problems. The more knowledge we have with the physics engine, the more
    intuition we will have to find the source of the problem, but unfortunately they
    almost always take a lot of time to resolve due to their limited reproducibility
    and sometimes nebulous behavior, and so we should expect physics issues to take
    longer than most logic bugs to fix and plan extra time before it can be resolved.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，经验和坚持是解决大多数物理问题的唯一正确途径。我们对物理引擎了解得越多，找到问题根源的直觉就越强，但遗憾的是，由于它们的可重复性有限，有时行为模糊不清，解决这些问题几乎总是需要花费大量时间，因此我们应该预期物理问题修复所需的时间会比大多数逻辑错误修复的时间更长，并在解决问题之前预留额外的时间。
- en: Now that we have an understanding of the majority of features of the Unity physics engine,
    we can cover several optimization techniques to improve our game's physics performance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Unity物理引擎的大多数功能，我们可以介绍一些优化技术来提高我们游戏中的物理性能。
- en: Physics performance optimizations
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理性能优化
- en: In this section, we will go over several techniques, optimizations, tricks,
    and settings that will allow your game to extract every drop of physics performance
    from your game. This includes how to set up your scene, learn when to use static
    colliders, how to configure the Collision Matrix, when to use triggers instead
    of Rigidbodies, and much more. Let's go over all of these, one by one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍几种技术、优化、技巧和设置，这些可以帮助您的游戏从游戏中提取每一滴物理性能。这包括如何设置场景、何时使用静态碰撞器、如何配置碰撞矩阵、何时使用触发器而不是刚体，以及更多。让我们逐一介绍所有这些内容。
- en: Scene setup
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: Firstly, there are several best practices we can apply to our scenes to improve
    the consistency of the physics simulation. Note that several of these techniques
    will not necessarily improve CPU or memory usage, but they will result in a reduced
    likelihood of instability from the physics engine.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以应用一些最佳实践来提高我们场景中物理模拟的一致性。请注意，这些技术中的几个不一定能提高CPU或内存使用，但它们将降低物理引擎不稳定性的可能性。
- en: Scaling
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放
- en: We should try to keep all physics object scales in the world as close to `(1,1,1)`
    as we possibly can. By default, Unity assumes that we are trying to simulate gameplay
    equivalent to being on the surface of the Earth. The force of gravity at the surface
    of the Earth is 9.81 meters-per-second squared, and hence the default gravity
    value is set to `-9.81` to match. One unit in Unity's world space is equivalent
    to 1 meter, and the negative sign means that it will pull the object downward.
    Our object sizes should reflect our effective world scale since scaling them too
    large will cause gravity to appear to move the objects much more slowly than we
    would expect. If all of our objects are scaled five times too big, then gravity
    will appear to be five times weaker. The converse is also true; scaling objects
    too small will make them look to fall too quickly and will not seem realistic.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽量将世界中的所有物理对象比例保持得尽可能接近 `(1,1,1)`。默认情况下，Unity 假设我们正在尝试模拟与地球表面相似的游戏玩法。地球表面的重力是每秒9.81米，因此默认的重力值设置为
    `-9.81` 以匹配。Unity 世界空间中的一个单位相当于1米，负号表示它将拉动对象向下。我们的对象大小应该反映我们的有效世界比例，因为如果它们太大，重力看起来会移动对象比我们预期的要慢得多。如果我们的所有对象都放大了五倍，那么重力看起来会弱五倍。相反的情况也是真实的；对象缩放得太小会使它们看起来下落得太快，并且看起来不真实。
- en: We can tweak the world's implied scale by modifying the strength of gravity
    under Edit | Project Settings | Physics / Physics 2D | Gravity. However, note
    that any floating-point arithmetic will be more accurate with values closer to
    `0`, so if we have some objects that have scale values far above `(1,1,1)`, even
    if they match the implied world scale, then we could still observe erratic physics
    behavior. So, early in the project, we should import and scale our most common
    physics objects around a scale value of `(1,1,1)` and then adjust the value of
    gravity to match. This will give us a reference point to work with as we introduce
    new objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改“编辑 | 项目设置 | 物理 / 2D物理 | 重力”下的重力强度来调整世界的隐含比例。然而，请注意，任何浮点运算在值接近 `0` 时将更加准确，因此如果我们有一些比例值远高于
    `(1,1,1)` 的对象，即使它们与隐含的世界比例相匹配，我们仍然可能会观察到不规则的物理行为。因此，在项目早期，我们应该将最常用的物理对象导入并围绕比例值
    `(1,1,1)` 进行缩放，然后调整重力值以匹配。这将为我们引入新对象时提供一个参考点。
- en: Positioning
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位
- en: Similarly, keeping all objects close to `(0,0,0)` in the world-space position
    will result in better floating-point accuracy, improving the consistency of the
    simulation. Space simulator and free-running games try to simulate incredibly
    large spaces and typically use a trick of either secretly teleporting the player
    back toward the center of the world or fixing their position there, in which case,
    either volumes of space are compartmentalized so that physics calculations are
    always calculated with values close to `0`, or everything else is moved to simulate
    travel, and the player's motion is only an illusion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，将所有对象在世界的空间位置上保持接近 `(0,0,0)` 将导致更好的浮点精度，从而提高模拟的一致性。空间模拟器和自由运行的游戏试图模拟极其巨大的空间，通常使用一种秘密将玩家传送到世界中心的技巧，或者固定他们的位置，在这种情况下，要么将空间体积分成几个部分，以便物理计算始终使用接近
    `0` 的值，要么将其他所有东西移动以模拟旅行，而玩家的运动只是一个幻觉。
- en: Most games are not at risk of introducing floating-point inaccuracy, since most
    game levels tend to last around 10 to 30 minutes, which doesn't give the player
    much time to travel absurdly long distances, but if we're working with exceptionally
    large scenes or asynchronously loading scenes throughout the course of the entire
    game to the point that the player travels tens of thousands of meters, then we
    may start to notice some strange physics behavior the further they go.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏不会引入浮点不准确性，因为大多数游戏关卡通常持续大约 10 到 30 分钟，这不会给玩家太多时间进行荒谬的长距离旅行，但如果我们正在处理特别大的场景，或者在整个游戏过程中异步加载场景，以至于玩家旅行了数万米，那么我们可能会开始注意到一些奇怪的物理行为，随着他们走得更远。
- en: So, unless we're already far too deep into our project so that changing and
    retesting everything at a late stage would be too much hassle, we should try to
    keep all of our physics objects close to `(0,0,0)`. Plus, this is good practice
    for our project workflow, as it makes it much quicker to find objects and tweak
    things in our game world.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非我们已经非常深入到我们的项目中，以至于在后期阶段更改和重新测试一切会变得过于麻烦，我们应该尽量将所有物理对象保持接近 `(0,0,0)`。此外，这对于我们的项目工作流程来说也是良好的实践，因为它使得在游戏世界中查找对象和调整事物变得更快。
- en: Mass
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 质量
- en: Mass is stored as a floating-point value under a `Rigidbody` component's mass
    property, and documentation on its usage has changed a fair amount over the years
    due to updates in its physics engine. Since late Unity 5, we are essentially free
    to choose whatever we want the `1.0` value to represent and then scale other
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 质量作为浮点值存储在`Rigidbody`组件的质量属性下，由于其物理引擎的更新，关于其使用的文档在多年中发生了相当大的变化。自Unity 5后期以来，我们基本上可以自由选择`1.0`值代表什么，然后按比例调整其他值。
- en: values appropriately.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 适当地分配值。
- en: Traditionally, a mass value of `1.0` is used to represent a mass of 1 kilogram,
    but we could decide that a human being has a mass of `1.0` (~80 kilograms), in
    which case, a car would be given a mass value of `15.0` (~1,200 kilograms), and
    physics collisions will resolve similarly to what we expect. The most important
    part is the relative difference in mass, which allows collisions between these
    objects to look believable without stressing the engine too much. Floating-point
    precision is also a concern, so we don't want to use large mass values that are
    too ridiculous.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，质量值为`1.0`用来表示1千克的质量，但我们可以决定一个人类的质量为`1.0`（约80千克），在这种情况下，汽车的质量值将为`15.0`（约1,200千克），物理碰撞将类似于我们预期的结果。最重要的是相对质量差异，这允许这些对象之间的碰撞看起来逼真，而不会过度压力引擎。浮点精度也是一个考虑因素，因此我们不想使用过于荒谬的大质量值。
- en: Note that if we intend to use Wheel Colliders, their design assumes that a mass
    of `1.0` represents 1 kilogram, so we should assign our mass values appropriately.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们打算使用轮式碰撞体，它们的设计假设质量为`1.0`代表1千克，因此我们应该适当地分配我们的质量值。
- en: Ideally, we would maintain mass values around `1.0` and ensure a maximum relative
    mass-ratio of around `100`. If two objects collide with a mass ratio much higher
    than this, then large momentum differences can turn into sudden, immense velocity
    changes from the impulse, resulting in some unstable physics and potential loss
    of floating-point precision. Object pairs that have a significant scale difference
    should probably be culled with the Collision Matrix to avoid problems (more on
    this shortly).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该保持质量值在`1.0`左右，并确保最大相对质量比大约为`100`。如果两个物体的质量比远高于这个值，那么大的动量差异可能会因为冲量而突然转变为巨大的速度变化，导致一些不稳定的物理现象和潜在的浮点精度损失。具有显著比例差异的对象对可能需要通过碰撞矩阵进行剔除以避免问题（关于这一点稍后还会讨论）。
- en: Improper mass ratios are the most common cause of physics instability and erratic
    behavior in Unity. This is particularly true when using joints for objects such
    as ragdolls.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不恰当的质量比是Unity中物理不稳定性和异常行为最常见的原因。这在使用关节连接如布娃娃等对象时尤其如此。
- en: Note that the force of gravity at the center of the Earth affects all objects
    equally, regardless of their mass, so it does not matter if we consider a mass
    property value of `1.0` to be the mass of a rubber ball or the mass of a warship.
    There's no need to adjust the force of gravity to compensate. What does matter,
    however, is the amount of air resistance the given object undergoes while falling
    (which is why a parachute falls slowly). So, to maintain realistic behavior, we
    may need to customize the drag property for such objects or customize the force
    of gravity on a per-object basis. For example, we could disable the Use Gravity
    checkbox and apply our custom gravitational force during fixed updates.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，地球中心的引力对所有物体的影响是相同的，无论其质量如何，因此我们是否将质量属性值`1.0`视为橡皮球的重量或战舰的重量并不重要。没有必要调整引力来补偿。然而，重要的是，给定物体在下落过程中所经历的空气阻力（这就是为什么降落伞会缓慢下落）。因此，为了保持逼真的行为，我们可能需要为这类对象自定义阻力属性或根据每个对象自定义引力。例如，我们可以禁用“使用重力”复选框，并在固定更新期间应用我们的自定义引力。
- en: Using static colliders appropriately
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适当地使用静态碰撞体
- en: As mentioned previously, the physics engine automatically generates two separate
    data structures to contain static colliders separately from dynamic colliders.
    Unfortunately, if new objects are introduced into the static collider data structure
    at runtime, then it must be regenerated, similar to calling `StaticBatchingUtility.Combine()`
    for static batching. This is likely to cause a significant CPU spike. This makes
    it vital that we avoid instantiating new static colliders during gameplay.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，物理引擎会自动生成两个独立的数据结构来分别存储静态碰撞体和动态碰撞体。不幸的是，如果在运行时向静态碰撞体数据结构中引入新对象，那么它必须被重新生成，类似于调用`StaticBatchingUtility.Combine()`进行静态批处理。这很可能会导致CPU使用率显著上升。因此，在游戏过程中避免实例化新的静态碰撞体变得至关重要。
- en: Also, merely moving, rotating, or scaling static colliders triggers this regeneration
    process and should be avoided. If we have colliders that we wish to move around
    without physically reacting to other objects colliding with them, then we should
    attach `Rigidbody` to make it a dynamic collider and enable the Kinematic flag. This
    flag prevents the object from reacting to external impulses from inter-object
    collisions, similar to static colliders, except the object can still be moved
    through its `transform` component or through forces applied to its `Rigidbody` component
    (preferably during fixed updates). Since a kinematic object won't respond to other
    objects hitting it, it will tend to push other dynamic colliders out of its way
    as it moves.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，仅仅移动、旋转或缩放静态碰撞体也会触发此再生过程，应避免这样做。如果我们希望移动碰撞体而无需物理上对其与其他对象的碰撞做出反应，则应附加 `Rigidbody`
    以使其成为动态碰撞体并启用运动学标志。此标志防止对象对外部冲量做出反应，类似于静态碰撞体，但对象仍然可以通过其 `transform` 组件或通过施加到其
    `Rigidbody` 组件上的力（最好在固定更新期间）进行移动。由于运动学对象不会对其他对象的撞击做出反应，因此它在移动时会倾向于将其他动态碰撞体推开。
- en: It's for this reason that player character objects are often made into Kinematic
    Colliders.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，玩家角色对象通常会被制作成运动学碰撞体。
- en: Using trigger volumes responsibly
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负责任地使用触发体积
- en: As mentioned previously, we can treat our physics objects as normal colliders
    or as trigger volumes. An important distinction between these two types is that
    the `OnCollider...()` callbacks provide a `Collision` object as a parameter to
    the callback, which contains useful information such as the exact location of
    collision (helpful to position a particle effect) and the contact normal (useful
    if we want to move the object after the collision manually). However, the `OnTrigger...()`
    callbacks do not provide this kind of information.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以将我们的物理对象视为普通碰撞体或触发体积。这两种类型之间的重要区别是，`OnCollider...()` 回调函数将一个 `Collision`
    对象作为参数传递给回调函数，其中包含有用的信息，例如碰撞的确切位置（有助于定位粒子效果）和接触法线（如果我们想在碰撞后手动移动对象，则很有用）。然而，`OnTrigger...()`
    回调函数不提供此类信息。
- en: As a result, we should not try to use trigger volumes for collision-reactive
    behavior since we won't have enough information to make the collision appear accurate.
    trigger volumes are best used for their intended purpose of tracking when an object
    enters/exits a specific area, such as dealing with damage while a player stays
    in a lava pit, triggering a cutscene when a player enters a building, and initiating
    asynchronous loading/unloading of a scene when the player approaches/moves far
    enough away from another major area.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不应该尝试使用触发体积来实现碰撞反应行为，因为我们不会有足够的信息来使碰撞看起来准确。触发体积最好用于其预期目的，即跟踪对象何时进入/离开特定区域，例如，当玩家停留在熔岩坑中处理伤害，当玩家进入建筑时触发一个场景，以及当玩家接近/远离另一个主要区域时启动/卸载场景。
- en: 'If the contact information is absolutely needed for a trigger volume collision,
    then common workarounds are to do any of the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果绝对需要接触信息来进行触发体积碰撞，则常见的解决方案包括以下任何一种：
- en: Generate a rough estimate for the contact point by halving the distance between
    the trigger volume and colliding objects' centers of mass (this assumes that they're
    of roughly equal size).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将触发体积和碰撞对象质心之间的距离减半来生成接触点的粗略估计（这假设它们的大小大致相等）。
- en: Perform a raycast upon collision from the center of the trigger volume to the
    center of mass of the colliding object (works best if both of the objects are
    spherical).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从触发体积的中心向碰撞对象的质心进行射线投射（如果两个对象都是球形的，效果最佳）。
- en: Create a non-trigger volume object, give it an infinitesimally small mass (so
    that its presence barely affects the colliding object), and immediately destroy
    it upon collision (since a collision with such a large mass differential will
    probably send this small object into orbit).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个非触发体积对象，给它一个无限小的质量（这样它的存在几乎不会影响碰撞对象），并在碰撞时立即销毁它（因为与如此大的质量差异的碰撞可能会将这个小物体送入轨道）。
- en: Of course, each of these approaches has its drawbacks—limited physical accuracy,
    extra CPU overhead during the collision, and/or additional scene setup (and rather
    hacky-looking collision code)—but they can be useful in a pinch.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每种方法都有其缺点——有限的物理准确性、碰撞期间的额外CPU开销和/或额外的场景设置（以及看起来相当奇怪的碰撞代码），但在紧急情况下它们可能很有用。
- en: Optimizing the Collision Matrix
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化碰撞矩阵
- en: As we know, the physics engine's Collision Matrix defines which objects assigned
    to specific Layers are allowed to collide with objects assigned to other Layers.
    To put it more succinctly, which object collision pairs are even considered viable
    by the physics engine. Every other object-Layer pair is simply ignored by the
    physics engine, which makes this an important avenue for minimizing physics engine
    workload since it reduces the number of bounding volume checks that must be performed
    every fixed update and how many collisions would ever need to be processed during
    the life cycle of the application (which would save on battery life for a mobile
    device).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，物理引擎的碰撞矩阵定义了分配给特定层的对象允许与分配给其他层的对象发生碰撞。更简洁地说，哪些对象碰撞对被物理引擎认为是可行的。其他所有对象-层对都被物理引擎简单地忽略，这使得这是一个减少物理引擎工作负载的重要途径，因为它减少了每个固定更新必须执行的边界体积检查的数量，以及在整个应用程序生命周期中需要处理的碰撞数量（这将为移动设备节省电池寿命）。
- en: Note that the Collision Matrix can be accessed through Edit | Project Settings
    | Physics (or Physics2D) | Layer Collision Matrix.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以通过“编辑”|“项目设置”|“物理”（或“物理2D”）|“层碰撞矩阵”访问碰撞矩阵。
- en: 'The following screenshot shows a standard Collision Matrix for an arcade shooter
    game:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了一个街机射击游戏的典型碰撞矩阵：
- en: '![](img/f38af74f-4ff1-4885-8259-2668226e75f4.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f38af74f-4ff1-4885-8259-2668226e75f4.png)'
- en: In the preceding example, we have objects flagged as Player, Enemies, Player
    Missiles, Enemy Missiles, and Powerups, and we have minimized the number of possible
    inter-object collisions for the physics engine to check.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们标记了对象为玩家、敌人、玩家导弹、敌人导弹和道具，并且我们已经最小化了物理引擎需要检查的可能对象间碰撞的数量。
- en: Starting with the first row of checkmarks labeled Player, we want the Player
    object to be able to collide with World objects, pick up Powerups, get hit by
    Enemy Missiles, and collide with Enemies. However, we do not want them to collide
    with their Player Missiles or themselves (although there would probably only be
    one object in this Layer, anyway). Hence, the enabled checkboxes in the Player
    row reflect these requirements. We only want Enemies to collide with World objects
    and Player Missiles, so these are checked in the Enemies row. Note that the Player-to-Enemies
    collision pair would have been handled already by the previous row; hence, there
    is no need for it to appear in the Enemies row. We also want both Player Missiles
    and Enemy Missiles to explode when they hit World objects, so these are marked,
    and finally we don't care about Powerups colliding with anything but the Player,
    nor do we want World objects to collide with other World objects, so no checkboxes
    are marked on the final two rows.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从标记为玩家的第一行勾选开始，我们希望玩家对象能够与世界对象发生碰撞，拾取道具，被敌人导弹击中，并与敌人发生碰撞。然而，我们不希望它们与自己的玩家导弹或自身发生碰撞（尽管在这个层中可能只有一个对象）。因此，玩家行中启用的复选框反映了这些要求。我们只想让敌人与世界对象和玩家导弹发生碰撞，所以在敌人行中勾选了这些。请注意，玩家到敌人的碰撞对已经在上一行中处理过了；因此，没有必要在敌人行中再次出现。我们还希望玩家导弹和敌人导弹在击中世界对象时爆炸，所以这些被标记了，最后我们不在乎道具与玩家以外的任何东西发生碰撞，也不希望世界对象与其他世界对象发生碰撞，所以在最后两行没有勾选复选框。
- en: At any given moment, we might have a single Player object, 2 Powerups, 7 Player
    Missiles, 10 Enemies, and 20 Enemy Missiles, which is 780 potential collision
    pairs (this is calculated as each of 40 different objects could collide with 39
    other ones, giving us 1,560 likely collision pairs, but then we divide the total
    by 2 to ignore duplicate pairs). By merely optimizing this matrix, we have reduced
    this to less than 100, for an almost 90% reduction in potential collision checks.
    Of course, the Unity physics engine efficiently culls away many of these object
    pairs if they are too far apart from one another. Hence, there is little to no
    chance that they could collide (this is calculated during a hidden process known
    as **Broadphase culling**), so the actual savings will probably never be this
    good, but it will free up some CPU cycles with next to no effort. Another significant
    benefit is that it simplifies our game logic coding; there's no need to figure
    out what's supposed to happen if Powerups and Enemy Missiles collide if we tell
    the physics engine to ignore collisions between them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时刻，我们可能只有一个玩家对象，2个增益道具，7个玩家导弹，10个敌人，和20个敌人导弹，这共有780个潜在的碰撞对（这是计算出来的，因为40个不同的对象中的每一个都可以与39个其他对象发生碰撞，从而产生1,560个可能的碰撞对，但然后我们将总数除以2以忽略重复的对）。仅仅优化这个矩阵，我们就将其减少到不到100，这意味着潜在的碰撞检查减少了近90%。当然，Unity物理引擎会有效地剔除掉很多这些对象对，如果它们彼此之间距离太远。因此，几乎没有机会它们会碰撞（这是在称为**粗略阶段剔除**的隐藏过程中计算的），所以实际节省的可能会好得多，但它几乎不需要任何努力就能释放一些CPU周期。另一个显著的好处是它简化了我们的游戏逻辑编码；如果我们告诉物理引擎忽略增益道具和敌人导弹之间的碰撞，我们就不需要弄清楚如果它们发生碰撞会发生什么。
- en: We should perform logical sanity checks like this for all potential Layer combinations
    in the Collision Matrix to see whether we're wasting precious time checking for
    inter-object collisions between object pairs that aren't necessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该对所有潜在的层组合在碰撞矩阵中进行逻辑合理性检查，以查看我们是否在浪费宝贵的时间检查那些不必要的对象对之间的对象间碰撞。
- en: Preferring discrete collision detection
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倾向于使用离散碰撞检测
- en: Discrete collision detection is relatively cheap since teleporting objects once
    and performing a single overlap check between nearby object pairs is a relatively
    trivial amount of work to perform in a single timestep. The amount of calculation
    required to perform continuous collision detection is significantly higher since
    it involves interpolating both objects between their starting and ending positions
    while analyzing for any slight bounding volume overlaps between these points as
    they might occur during the timestep.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 离散碰撞检测相对便宜，因为将对象传送一次并在单个时间步长内执行附近对象对之间的单个重叠检查是一项相对简单的工作。执行连续碰撞检测所需的计算量显著更高，因为它涉及到在分析这些点之间可能发生的任何轻微边界体积重叠的同时，对两个对象在起始位置和结束位置之间的插值。
- en: Consequently, the Continuous collision detection option is an order of magnitude
    more expensive than the Discrete detection method, whereas the ContinuousDynamic
    collision detection setting is an order of magnitude even more costly than Continuous. Having
    too many objects configured to use either of the continuous collision detection
    types will cause severe performance degradation in complex scenes. In both cases,
    the cost for collision detection grows exponentially with the number of objects
    that need to be compared during any given frame with a steep increase if the collider
    is dynamic instead of static.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，连续碰撞检测选项比离散检测方法贵一个数量级，而连续动态碰撞检测设置甚至比连续碰撞检测更昂贵。如果配置了太多对象使用任何一种连续碰撞检测类型，将会在复杂场景中导致严重的性能下降。在两种情况下，碰撞检测的成本都会随着任何给定帧中需要比较的对象数量呈指数增长，如果碰撞体是动态的而不是静态的，增长将更为陡峭。
- en: Ergo, we should favor the Discrete collision detection setting for the overwhelming
    majority of our objects, while using either of the continuous collision detection
    settings only in extreme circumstances. The Continuous setting should be used
    when important collisions are frequently missed with the more static parts of
    our game world. For instance, if we wish to be sure that the player characters
    never fall through the game world or never accidentally teleport through walls
    if they move too quickly, then we might want to apply continuous collision detection
    only for those objects. Finally, the ContinuousDynamic setting should only be
    used if the same situation applies, and we wish to catch collisions between pairs
    of very fast-moving dynamic colliders.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该为绝大多数对象优先选择离散碰撞检测设置，而仅在极端情况下使用任一连续碰撞检测设置。当游戏世界的静态部分频繁错过重要碰撞时，应使用连续设置。例如，如果我们希望确保玩家角色永远不会从游戏世界中掉落，或者如果他们移动得太快，永远不会意外地通过墙壁传送，那么我们可能只想为这些对象应用连续碰撞检测。最后，如果相同的情况适用，并且我们希望捕捉到非常快速移动的动态碰撞器之间的碰撞，则应仅使用ContinuousDynamic设置。
- en: Modifying the fixed update frequency
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改固定更新频率
- en: 'In some cases, Discrete collision detection might not work well enough on a
    large scale. Perhaps our entire game revolves around a lot of small physics objects,
    and discrete collision detection simply isn''t catching enough collisions to maintain
    product quality. However, applying one of the continuous collision detection settings
    to everything would be far too prohibitive on performance. In this case, there
    is one option we can try: we can customize the physics timestep to give the Discrete
    collision detection system a better chance of catching such collisions by modifying
    how frequently the engine checks for fixed updates.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，离散碰撞检测在大规模上可能工作得不够好。也许我们的整个游戏都围绕着大量的小型物理对象，而离散碰撞检测根本无法捕捉到足够的碰撞以维持产品质量。然而，将连续碰撞检测设置应用于所有内容将对性能产生极大的负面影响。在这种情况下，我们可以尝试一个选项：我们可以自定义物理时间步长，通过修改引擎检查固定更新的频率，给离散碰撞检测系统更好的机会捕捉到这种碰撞。
- en: As mentioned previously, fixed updates and physics timestep processing are strongly
    coupled; so, by modifying the frequency of fixed update checks, we not only change
    the rate that the physics engine will calculate and resolve the next callback,
    but we also change how frequently the `FixedUpdate()` callbacks and coroutines
    are being invoked. Consequently, changing this value can be risky if we're deep
    into our project and have a lot of behavior that depends on these callbacks since
    we will be changing a fundamental assumption about how often these methods are
    invoked.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，固定更新和物理时间步长处理紧密相关；因此，通过修改固定更新检查的频率，我们不仅改变了物理引擎计算和解决下一个回调的速率，还改变了`FixedUpdate()`回调和协程被调用的频率。因此，如果我们已经深入到项目中并且有很多依赖于这些回调的行为，那么更改此值可能会有风险，因为我们将会改变关于这些方法调用频率的基本假设。
- en: Altering the fixed update frequency can be accomplished using the Edit | Project
    Settings | Time | Fixed Timestep property in the Editor or through the `Time.fixedDeltaTime`
    property in script code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编辑器中的“编辑 | 项目设置 | 时间 | 固定时间步长”属性或通过脚本代码中的`Time.fixedDeltaTime`属性，可以更改固定的更新频率。
- en: Reducing this value (increasing the frequency) will force the physics engine
    to process more frequently, giving it a better chance of catching collisions with
    discrete collision detection. Naturally, this comes with an added CPU cost since
    we're invoking more `FixedUpdate()` callbacks and asking the physics engine to
    update more frequently, having it move objects and verify collisions more often.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 减少此值（增加频率）将迫使物理引擎更频繁地处理，从而有更好的机会通过离散碰撞检测捕捉到碰撞。当然，这会带来额外的CPU成本，因为我们正在调用更多的`FixedUpdate()`回调，并要求物理引擎更频繁地更新，使其更频繁地移动对象和验证碰撞。
- en: Conversely, increasing this value (decreasing the frequency) provides more time
    for the CPU to complete other tasks before it must handle physics processing again,
    or, looking at it from another perspective, it gives the physics engine more time
    to process the last timestep before it begins processing the next one. Unfortunately,
    lowering the fixed update frequency would necessarily reduce the maximum velocity
    at which objects can move before the physics engine can no longer capture collisions
    with discrete collision detection (depending on the objects' sizes). We might
    also start to see objects changing velocities in strange ways because it is essentially
    becoming a weaker approximation of real-world physics behavior.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，增加这个值（降低频率）为CPU提供了更多时间在再次处理物理处理之前完成其他任务，或者从另一个角度来看，它给了物理引擎更多时间在开始处理下一个时间步之前处理最后一个时间步。不幸的是，降低固定更新频率将不可避免地减少物体在物理引擎无法再通过离散碰撞检测捕获碰撞之前可以移动的最大速度（取决于物体的尺寸）。我们可能还会看到物体以奇怪的方式改变速度，因为这本质上是对现实世界物理行为的较弱近似。
- en: This makes it vital to perform a significant amount of testing each time the
    Fixed Timestep value is changed. Even with a complete understanding of how this
    value works, it is difficult to predict the overall outcome during gameplay and
    whether the result is passable for quality purposes. Hence, changes to this value
    should be made early in the project's life cycle and then made infrequently to
    get a sufficient amount of testing against as many physics situations as possible.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得每次更改固定时间步长值时进行大量测试变得至关重要。即使完全理解这个值的工作原理，也很难预测游戏过程中的整体结果以及结果是否在质量方面可以接受。因此，这个值的更改应该在项目的早期生命周期中进行，并且应该很少更改，以便尽可能多地针对尽可能多的物理情况进行测试。
- en: It might help to create a test scene that flings some of our high-velocity objects
    at one another to verify that the results are acceptable and run through this
    scene whenever Fixed Timestep changes are made. However, actual gameplay tends
    to be rather complicated, with many background tasks and unanticipated player
    behavior that causes additional work for the physics engine or gives it less time
    to process the current iteration. Actual gameplay conditions are impossible to
    replicate in a vacuum. Also, there's no substitute for the real thing, so the
    more testing we can accomplish against the current value of the Fixed Timestep,
    the more confident we can be that the changes meet acceptable quality standards.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个测试场景，让一些高速物体相互碰撞，以验证结果是否可接受，并在每次固定时间步长变化时运行这个场景可能会有所帮助。然而，实际的游戏玩法往往相当复杂，有许多后台任务和未预见的玩家行为，这会给物理引擎带来额外的工作，或者给它更少的时间来处理当前迭代。在真空中无法复制实际游戏玩法条件。此外，没有替代品可以替代真实的事物，因此，我们可以在当前固定时间步长的值上进行更多测试，这样我们就可以更有信心地认为这些变化符合可接受的质量标准。
- en: 'Take it from someone who''s in the career of developing software automation
    tools: automation of software testing is helpful in a lot of situations, but when
    it comes to real-time event- and user input-driven applications that synchronize
    with multiple hardware devices and complex subsystems such as physics engines
    and tend to change rapidly due to iterations on feedback, the support and maintenance
    costs of automated testing often becomes more effort than its worth, making manual
    testing the most sensible approach.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个从事软件开发自动化工具开发的人的经验来看：在许多情况下，软件测试的自动化是有帮助的，但当涉及到与多个硬件设备和复杂子系统（如物理引擎）同步的实时事件和用户输入驱动的应用程序时，这些子系统由于反馈的迭代而倾向于快速变化，自动化测试的支持和维护成本往往比其价值更大，这使得手动测试成为最合理的途径。
- en: We always have continuous collision detection as a last resort to offset some
    of the resulting instability we're observing. Unfortunately, even if the changes
    are targeted, it is more likely that this will cause further performance issues
    than we started with due to the overhead costs of continuous collision detection.
    It would be wise to profile our scene before and after enabling continuous collision
    detection to verify that the benefits are outweighing the costs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是将连续碰撞检测作为最后的手段来抵消我们观察到的某些结果不稳定。不幸的是，即使这些变化是针对特定目标的，由于连续碰撞检测的开销成本，这很可能会比我们开始时造成更多的性能问题。在启用连续碰撞检测之前和之后对场景进行性能分析，以验证收益是否超过了成本，这将是一个明智的做法。
- en: Adjusting the Maximum Allowed Timestep
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整最大允许时间步长
- en: If we're regularly exceeding the Maximum Allowed Timestep (which, as a reminder,
    determines how much time the physics engine has to resolve a timestep before it
    must exit early), then it will result in some pretty bizarre-looking physics behavior.
    Rigidbodies will appear to slow down or jerk to a stop since the physics engine
    needs to keep exiting timestep calculations early before it has fully resolved
    its entire time quota. In this case, it is a clear sign that we need to optimize
    our physics behavior from other angles. However, at the very least, we can be
    confident that the threshold will prevent the game from completely locking up
    from a spike in the middle of physics processing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们经常超过最大允许时间步长（提醒一下，这决定了物理引擎在必须提前退出之前可以解决多少时间步长），那么将会导致一些相当奇怪的物理行为。刚体看起来会减速或突然停止，因为物理引擎需要在完全解决整个时间配额之前，多次提前退出时间步计算。在这种情况下，这是一个明显的迹象，表明我们需要从其他角度优化我们的物理行为。然而，至少我们可以确信，这个阈值将防止游戏在物理处理过程中中间出现峰值时完全锁定。
- en: 'Reminder: this setting can be accessed through Edit | Project Settings | Time
    | Maximum Allowed Timestep.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：此设置可通过编辑 | 项目设置 | 时间 | 最大允许时间步长访问。
- en: The default setting is to consume a maximum of 0.333 seconds, which would manifest
    itself as a very noticeable drop in frame rate (a mere 3 FPS) if it were exceeded.
    If you ever feel the need to change this setting, then you obviously have some
    big problems with your physics workload, so it is recommended that you only tweak
    this value if you have exhausted all other approaches.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置是消耗最多0.333秒，如果超过这个值，将会表现为帧率明显下降（仅为3 FPS）。如果你觉得需要更改此设置，那么显然你的物理工作负载存在一些大问题，因此建议你只有在用尽所有其他方法后，才调整此值。
- en: Minimizing raycasting and bounding-volume checks
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化射线投射和边界体积检查
- en: All of the raycasting methods are incredibly useful, but they are relatively
    expensive, particularly `CapsuleCast()` and `SphereCast()`. We should avoid calling
    these methods regularly within the `Update()` callbacks or coroutines, saving
    them only for critical events in our script code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有射线投射方法都非常有用，但它们相对昂贵，尤其是`CapsuleCast()`和`SphereCast()`。我们应该避免在`Update()`回调或协程中定期调用这些方法，只为脚本代码中的关键事件保留它们。
- en: If we're making use of persistent line, ray, or area-of-effect collision areas
    in our scene (examples include security lasers, continuously burning fires, and
    beam weapons), and the object remains relatively stationary, then they would perhaps
    be better simulated using a simple trigger volume.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在场景中使用持久线、射线或区域碰撞区域（例如安全激光、持续燃烧的火焰和光束武器），并且对象相对静止，那么使用简单的触发体积模拟可能更好。
- en: 'If such replacements are not possible, and we truly need persistent casting
    checks using these methods, we should minimize the amount of processing each raycast
    makes by exploiting `LayerMasks`. This is particularly true if we''re making use
    of `Physics.RaycastAll()`. For example, a poorly optimized usage of this kind
    of raycasting would look as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种替换不可行，并且我们确实需要使用这些方法进行持久的投射检查，我们应该通过利用`LayerMasks`来最小化每个射线投射的处理量。这尤其适用于我们使用`Physics.RaycastAll()`的情况。例如，这种射线投射的糟糕优化可能如下所示：
- en: '[PRE0]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we're collecting raycast collision data for every
    object in the path of this ray, but we're only processing its effects on objects
    that hold a specific `EnemyComponent` instance. Consequently, we're asking the
    physics engine to complete much more work than is necessary.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们正在收集射线投射碰撞数据，针对这条射线路径上的每个对象，但我们只处理对具有特定`EnemyComponent`实例的对象的影响。因此，我们要求物理引擎完成比必要多得多的工作。
- en: 'A better approach will be to use a different overload of `RaycastAll()`, which
    accepts a `LayerMask` value as an argument. This will filter collisions for the
    ray in much the same way as the Collision Matrix so that it only tests against
    objects in the given Layer(s). The following code contains a subtle improvement
    by providing an additional `LayerMask` property; we would configure `LayerMask`
    through the Inspector window for this Component, and it will filter the list much
    faster and only contain `hits` for objects matching the mask:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用`RaycastAll()`的不同重载，它接受一个作为参数的`LayerMask`值。这将以与碰撞矩阵相同的方式过滤射线的碰撞，以便它只测试给定层（s）中的对象。以下代码通过提供额外的`LayerMask`属性进行细微的改进；我们将通过检查器窗口为此组件配置`LayerMask`，这将更快地过滤列表，并且只包含与掩码匹配的`hits`：
- en: '[PRE1]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This optimization doesn't work as well for the `Physics.RaycastHit()` function
    since that version only provides ray collision information for the first object
    the ray collides with, regardless of whether we're using `LayerMask` or not.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化对`Physics.RaycastHit()`函数的效果并不好，因为该版本只提供射线与第一个碰撞对象的碰撞信息，无论我们是否使用`LayerMask`。
- en: Note that because the `RaycastHit` and `Ray` classes are managed by the native
    memory space of the Unity engine, they don't result in memory allocations that
    draw the attention of the garbage collector. We will learn more about such activity
    in Chapter 8, *Masterful Memory Management*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`RaycastHit`和`Ray`类由Unity引擎的本地内存空间管理，它们不会导致垃圾收集器注意到的内存分配。我们将在第8章“精湛的内存管理”中了解更多关于此类活动的内容。
- en: Avoiding complex Mesh Colliders
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免复杂的网格碰撞体
- en: In order of collision detection efficiency, the various colliders are Spheres,
    Capsules, Boxes, Convex Mesh Colliders, and Concave Mesh Colliders, the last being
    far and away the most expensive. Collisions always involve pairs of objects, and
    the amount of work (math) needed to resolve the collision will depend on the complexity
    of both objects. Detecting collisions between two primitive objects can be reduced
    down to a relatively simple set of mathematical equations that are highly optimized.
    Performing comparisons against a pair of Convex Mesh Colliders is a much more
    complex equation, making them an order of magnitude more expensive than collisions
    between two primitives. Then, there are collisions between two Concave Mesh Colliders,
    which are so complex that they cannot be reduced down to a simple formula and
    require collision checks to be resolved between each pair of triangles across
    both meshes, easily making them orders of magnitude more expensive than collisions
    between other collider types. The amount of work involved scales similarly when
    we resolve collisions between shapes of different groups. For example, a collision
    between a primitive and Concave Mesh Collider would be slower than a collision
    between two primitives, but faster than a collision between two Concave Mesh Colliders.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照碰撞检测效率的顺序，各种碰撞体是球体、胶囊体、盒子、凸网格碰撞体和凹网格碰撞体，其中最后一种是成本最高的。碰撞总是涉及成对的物体，解决碰撞所需的工作（数学运算）将取决于两个物体的复杂性。检测两个原始物体的碰撞可以简化为一系列相对简单的数学方程，这些方程经过了高度优化。对一对凸网格碰撞体进行比较的方程要复杂得多，这使得它们比两个原始物体之间的碰撞贵一个数量级。然后，还有两个凹网格碰撞体之间的碰撞，它们如此复杂，以至于不能简化为简单的公式，需要在每个网格的每对三角形之间进行碰撞检查，这使得它们比其他碰撞体类型的碰撞贵许多数量级。当我们解决不同组形状之间的碰撞时，涉及的工作量以类似的方式缩放。例如，原始物体与凹网格碰撞体之间的碰撞会比两个原始物体之间的碰撞慢，但会比两个凹网格碰撞体之间的碰撞快。
- en: There is also the question of whether one—or both—of the objects involved in
    the collision is moving (one of the objects being a static collider is easier
    to process than both objects being dynamic colliders). There is also the matter
    of how many of these objects are within our scene since the total processing costs
    of collision detection will snowball if we're not careful with how many shapes
    we introduce into the simulation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题，即参与碰撞的物体中是否有一个或两个正在移动（如果一个物体是静态碰撞体，处理起来比两个都是动态碰撞体要容易）。还有一点是，场景中有多少这样的物体，因为如果我们不小心引入到模拟中的形状数量，碰撞检测的总处理成本将会激增。
- en: A great irony between representing physics and graphics in 3D applications is
    how difficult it is to handle spherical and cube objects between the two of them.
    The perfect spherical mesh would require an infinite number of polygons to be
    generated, making such an object impossible to represent graphically.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D应用程序中，表示物理和图形之间的一个巨大讽刺是如何难以在这两者之间处理球形和立方体对象。完美的球形网格需要生成无限数量的多边形，这使得这样的对象在图形上无法表示。
- en: However, handling collisions between two spheres in a physics engine is perhaps
    the most straightforward problem to solve for contact points and collisions (the
    contact point is always at the edge of either of the sphere's radius, and the
    contact normal is always the vector between their centers of mass). Conversely,
    a cube is one of the simplest objects to represent graphically (as little as 8
    vertices and 12 triangles) and yet takes significantly more mathematics and processing
    power to find contact points and resolve collisions for (and the mathematics to
    resolve it depends on whether the collision occurred between faces, edges, corners,
    or a mixed pairing). Anecdotally, this implies that the most efficient way of
    creating the largest number of objects would be to populate our world with cube
    objects that use spherical colliders. However, this would make absolutely no sense
    to a human observer, as they would witness cubes rolling around like balls.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在物理引擎中处理两个球体之间的碰撞可能是解决接触点和碰撞的最直接问题（接触点始终位于任一球体半径的边缘，接触法线始终是它们质心之间的向量）。相反，立方体是图形上表示最简单的对象之一（只需8个顶点和12个三角形），但要找到接触点和解决碰撞（解决这些碰撞的数学取决于碰撞是发生在面、边、角还是混合配对之间）需要显著更多的数学和计算能力。据观察，这表明创建最大数量对象的最有效方法可能是用使用球形碰撞器的立方体对象来填充我们的世界。然而，这对人类观察者来说完全没有意义，因为他们会看到立方体像球一样滚动。
- en: The previous anecdote serves as a reminder that the physical representation
    of an object does not necessarily need to match its graphical representation.
    This is beneficial, as a graphical mesh can often be condensed down into a much
    simpler shape, while still generating very similar physics behavior and simultaneously
    removing the need to use an overly complex Mesh Collider.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子提醒我们，一个对象的物理表示不一定需要与其图形表示相匹配。这是有益的，因为图形网格通常可以简化为更简单的形状，同时仍然产生非常相似的物理行为，并同时消除使用过于复杂的Mesh
    Collider的需求。
- en: This separation of representations between graphics and physics allows us to
    optimize the performance of one system without (necessarily) negatively affecting
    the other. So long as there are no noticeable repercussions on gameplay (or we're
    willing to make the sacrifice), then we are free to represent complex graphical
    objects with much simpler physics shapes without players noticing. Also, if the
    player never notices, then no harm is done.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在图形和物理之间分离表示的方法使我们能够在不（必然）负面影响另一个系统的情况下优化一个系统的性能。只要没有对游戏玩法产生明显的负面影响（或者我们愿意做出牺牲），我们就自由地用更简单的物理形状来表示复杂的图形对象，而玩家不会注意到。此外，如果玩家从未注意到，那么就不会造成任何伤害。
- en: 'So, we can solve this problem in one of the two ways: either by approximating
    the physics behavior of the complex shape using one (or more) of the standard
    primitives or by using a much simpler Mesh Collider.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过以下两种方式之一解决这个问题：要么通过使用一个（或多个）标准原语来近似复杂形状的物理行为，要么使用一个更简单的Mesh Collider。
- en: Using simpler primitives
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更简单的原语
- en: Most shapes can be approximated using one of the three primitive colliders.
    In fact, we do not need to represent the object using only a single collider.
    We are free to use several colliders if they serve our needs for creating a complex
    collision shape by attaching additional child GameObjects with their colliders.
    This is almost always less expensive than using a single Mesh Collider and should
    be preferred.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数形状都可以使用三种基本碰撞器之一来近似。实际上，我们不需要仅使用单个碰撞器来表示对象。如果它们有助于我们通过附加具有碰撞器的额外子GameObject来创建复杂的碰撞形状，我们可以自由地使用多个碰撞器。这几乎总是比使用单个Mesh
    Collider更经济，应该优先考虑。
- en: 'The following screenshot shows a handful of complex graphical objects represented
    by one or more simpler primitive collider shapes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了由一个或多个更简单的原语碰撞器形状表示的一组复杂图形对象：
- en: '![](img/9fb5fecd-178c-4e6a-8e2d-11539bc179ea.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fb5fecd-178c-4e6a-8e2d-11539bc179ea.png)'
- en: Using a Mesh Collider for any one of these objects would be significantly more
    expensive than the primitive colliders shown here due to the number of polygons
    they contain. It is worth exploring all opportunities to simplify our objects
    down using these primitives as much as we can, as they can provide significant
    performance gains.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些对象中的任何一个使用网格碰撞器，由于它们包含的多边形数量，其成本将显著高于这里显示的原始碰撞器。值得探索所有机会，尽可能使用这些原始形状简化我们的对象，因为它们可以提供显著的性能提升。
- en: For example, Concave Mesh Colliders are unique in that they can feature gaps
    or holes that allow other meshes to fall into or even through them, which introduces
    opportunities for the objects to fall through the world if such colliders are
    used for world collision areas. It is often better to place Box Colliders in strategic
    locations for this purpose.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，凹面网格碰撞器是独特的，因为它们可以具有间隙或孔洞，允许其他网格落入甚至穿过它们，这为物体通过使用此类碰撞器作为世界碰撞区域提供了机会。在这种情况下，通常将盒形碰撞器放置在战略位置会更好。
- en: Using simpler Mesh Colliders
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更简单的网格碰撞器
- en: Similarly, the mesh assigned to a Mesh Collider does not necessarily need to
    match the graphical representation of the same object (Unity simply picks it as
    the default). This allows us to assign a simpler mesh to the Mesh Collider's `mesh`
    property, which is different from the one we use for its graphical representation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，分配给网格碰撞器的网格不一定需要与同一对象的图形表示相匹配（Unity只是将其作为默认选择）。这允许我们将一个更简单的网格分配给网格碰撞器的`mesh`属性，这与我们用于其图形表示的网格不同。
- en: 'The following screenshot shows an example of a sophisticated graphical mesh
    that has been given a much more simplified mesh for its Mesh Collider:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个复杂的图形网格，其网格碰撞器已被赋予了一个更简化的网格：
- en: '![](img/88d9b137-df0a-4a4a-93bf-b0bed46c6bc4.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88d9b137-df0a-4a4a-93bf-b0bed46c6bc4.png)'
- en: Simplifying the rendered mesh into convex shapes with lower polygon counts in
    this way will significantly reduce the overhead needed to determine bounding volume
    overlaps with other colliders. Depending on how well the original object is estimated,
    there should be minimal noticeable gameplay differences, especially in the case
    of this ax, which we expect to be moving quickly as creatures swing it during
    attacks, making it unlikely that players will notice the difference between the
    two meshes as colliders. In fact, the simplified mesh is much less likely to be
    missed by discrete collision detection and is preferable for that reason.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式将渲染网格简化为具有较低多边形计数的凸形状将显著减少确定与其他碰撞器边界体积重叠所需的开销。根据原始对象估计的好坏，游戏体验上的差异应该是最小的，尤其是在这个斧头的情况下，我们预计它将在攻击时快速移动，使得玩家不太可能注意到两种网格作为碰撞器之间的差异。实际上，简化后的网格不太可能被离散碰撞检测忽略，因此出于这个原因更可取。
- en: Avoiding complex physics components
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免复杂的物理组件
- en: Certain special physics `Collider` components, such as `TerrainCollider`, `Cloth`,
    and `WheelCollider`, are orders of magnitude more expensive than all primitive
    colliders and even Mesh Colliders in some cases. We should not include such components
    in our Scenes unless they are absolutely necessary. For instance, if we have terrain
    objects in the distance that the player will never approach, there's little reason
    to include an attached `TerrainCollider` component.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 某些特殊的物理`Collider`组件，如`TerrainCollider`、`Cloth`和`WheelCollider`，在成本上比所有原始碰撞器甚至某些情况下的网格碰撞器高得多。除非绝对必要，否则我们不应在我们的场景中包含此类组件。例如，如果我们有玩家永远不会接近的远处的地形对象，那么包含附加的`TerrainCollider`组件就几乎没有理由。
- en: Games featuring `Cloth` components should consider instantiating different objects
    without them when running in lower-quality settings or simply animating cloth
    behavior (although it is totally understandable if the team has grown attached
    to and fallen in love with how the stuff moves around).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有`Cloth`组件的游戏在运行在低质量设置时应考虑实例化不带它们的对象，或者简单地动画化布料行为（尽管如果团队已经对布料移动的方式产生了感情并爱上了它，这是完全可以理解的）。
- en: Games using `WheelCollider` components should simply try to use fewer Wheel
    Colliders. Large vehicles, with more than four wheels, may be able to simulate
    similar behavior using only four wheels, while faking the graphical representation
    of additional wheels.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`WheelCollider`组件的游戏应尽量减少轮轴碰撞器的使用。大型车辆，如果拥有超过四个轮子，可能仅用四个轮子就能模拟出类似的行为，同时通过图形上模拟额外的轮子来欺骗视觉效果。
- en: Letting physics objects sleep
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让物理对象休眠
- en: The physics engine's sleep feature can pose several problems for our game. Firstly,
    some developers don't realize that many of their Rigidbodies are sleeping during
    most of the lifetime of their application. This tends to lead developers to assume
    that they can get away with (for example) doubling the number of Rigidbodies in
    their game, and the overall costs would simply double to match it. This is unlikely.
    The frequency of collisions and the total accumulated time of active objects is
    more likely to increase in an exponential fashion rather than a linear one. This
    leads to unexpected performance costs every time new physics objects are introduced
    into the simulation. We should keep this in mind when we decide to increase the
    physical complexity of our scenes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 物理引擎的休眠功能可能会给我们的游戏带来几个问题。首先，一些开发者没有意识到他们的大多数刚体在应用程序的大部分生命周期中都是处于休眠状态的。这往往导致开发者认为他们可以通过（例如）将游戏中的刚体数量加倍来逃避问题，整体成本也会简单地加倍以匹配。这不太可能。碰撞频率和活动对象的总累积时间更有可能呈指数增长而不是线性增长。每次向模拟中引入新的物理对象时，都会导致意外的性能成本。当我们决定增加场景的物理复杂性时，我们应该牢记这一点。
- en: Secondly, changing any properties on a `Rigidbody` component at runtime, such
    as mass, drag, and useGravity, will also reawaken an object. If we're regularly
    changing these values (such as a game where object sizes and masses change over
    time), then they will remain active for more extended periods than usual. This
    is also the case for applying forces, so if we're using a custom gravity solution
    (such as suggested in the mass section), we should try to avoid applying the gravitational
    force every fixed update; otherwise, the object will be unable to fall asleep.
    We could check its mass-normalized kinetic energy (just take the value of `velocity.sqrMagnitude`)
    and manually disable our custom gravity when we detect that it is very low.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，在运行时更改`Rigidbody`组件上的任何属性，例如质量、阻力和`useGravity`，也会唤醒一个对象。如果我们经常更改这些值（例如，对象大小和质量随时间变化的游戏），那么它们将比通常情况下保持更长时间的活动状态。应用力也是如此，因此如果我们使用自定义重力解决方案（例如在质量部分建议的），我们应该尽量避免在每次固定更新时应用重力；否则，对象将无法进入休眠状态。我们可以检查其质量归一化的动能（只需取`velocity.sqrMagnitude`的值）并在检测到它非常低时手动禁用我们的自定义重力。
- en: Thirdly, there is the danger of islands of sleeping physics objects being generated.
    Islands are created when a large number of Rigidbodies are touching one another
    and have gradually gone to sleep once the kinetic energy of the system has fallen
    low enough. However, because they're all still touching one another, as soon as
    one of these objects is awoken, it will start a chain reaction, awakening all
    other nearby Rigidbodies. Suddenly, we have a large spike in CPU usage because
    dozens of objects have re-entered the simulation. Even worse, because the objects
    are so close together, there will be many potential collision pairs that must
    keep being resolved until the objects fall asleep again.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，存在生成休眠物理对象孤岛的危险。当大量刚体相互接触并且系统动能降低到足够低时，孤岛就会形成。然而，由于它们仍然相互接触，一旦这些对象中的任何一个被唤醒，就会引发连锁反应，唤醒所有附近的刚体。突然之间，CPU使用量会急剧上升，因为数十个对象重新进入了模拟。更糟糕的是，由于对象非常接近，将会有许多潜在的碰撞对需要不断解决，直到对象再次进入休眠状态。
- en: Avoiding these situations is best done by reducing the complexity of our scenes,
    but if we find ourselves unable to do so, we could look for ways to detect that
    islands are forming, and then strategically destroy/despawn some of them to prevent
    too many large islands from being generated. However, performing regular distance
    comparisons between all of our Rigidbodies is not a cheap task to accomplish and
    could be costly. The physics engine already performs such checks itself, during
    Broadphase culling, but, unfortunately, Unity doesn't expose this data through
    the physics engine API. Any workarounds for this problem will be dependent on
    how the game is designed; for example, a game that requires the player to move
    lots of physics objects into an area (for example, a game that involves herding
    sheep into a pen) could choose to remove the sheep's collider as soon as the player
    moves it into position, locking the object to its final destination, easing the
    workload on the physics engine and preventing islands from becoming a problem.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这些情况的最佳做法是简化我们的场景复杂性，但如果发现自己无法做到这一点，我们可以寻找检测岛屿形成的方法，然后有策略地销毁/解散其中一些，以防止生成太多大型岛屿。然而，在所有刚体之间执行定期的距离比较并不是一项容易完成的任务，可能会很昂贵。物理引擎已经在广相剔除过程中自行执行此类检查，但不幸的是，Unity
    并没有通过物理引擎 API 提供这些数据。任何针对此问题的解决方案都将取决于游戏的设计；例如，需要玩家将许多物理对象移动到某个区域（例如，需要将羊群赶到围栏的游戏）的游戏可以选择在玩家将羊移动到位置后立即移除羊的碰撞器，将对象锁定在其最终目的地，减轻物理引擎的工作负担，防止岛屿成为问题。
- en: Sleeping objects can be a blessing and a curse. They can save us a lot of processing
    power, but if too many of them reawaken at the same time or our simulation is
    too busy to allow enough of them to fall asleep, then we could be incurring some
    unfortunate performance costs during gameplay. We should strive to limit these
    situations as much as possible by letting our objects enter the sleeping state
    as much as possible and avoiding grouping them in large clusters.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠对象可能既是祝福也是诅咒。它们可以为我们节省大量的处理能力，但如果太多对象同时苏醒，或者我们的模拟过于繁忙，无法让足够多的对象进入睡眠状态，那么在游戏过程中可能会产生一些不幸的性能成本。我们应该尽可能限制这些情况，让我们的对象尽可能进入睡眠状态，并避免将它们分组成大型集群。
- en: Note that the sleep threshold can be modified under Edit | Project Settings
    | Physics | Sleep Threshold.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以在“编辑”|“项目设置”|“物理”|“睡眠阈值”下修改睡眠阈值。
- en: Modifying the solver iteration count
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改求解器迭代次数
- en: Using joints, springs, and other ways to connect Rigidbodies are fairly complex
    simulations in physics engines. Owing to the codependent interactivity (internally
    represented as movement constraints) that occurs due to joining two objects together,
    the system must often make several attempts at solving the necessary mathematical
    equations. This multi-iteration approach is required to calculate an accurate
    result whenever there is a change in velocity to any single part of the object
    chain.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关节、弹簧和其他方式连接刚体在物理引擎中是相当复杂的模拟。由于将两个对象连接在一起而产生的相互依赖的交互性（内部表示为运动约束），系统必须经常尝试解决必要的数学方程。这种多迭代方法在对象链的任何部分发生速度变化时，都需要计算准确的结果。
- en: It, therefore, becomes a balancing act of limiting the maximum number of attempts
    the solver makes to resolve a particular situation versus how accurate a result
    we can get away with. We don't want the solver to spend too much time on a single
    collision because there are a lot of other tasks that the physics engine has to
    complete within the same iteration. However, we also don't want to reduce the
    maximum number of iterations too far, as it will only approximate what the final
    solution would have been, making its motion look much less believable than if
    it had been given more time to calculate the result.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这变成了一种权衡，即在求解器尝试解决特定情况的最大次数与我们可以接受的准确度之间进行权衡。我们不希望求解器在单个碰撞上花费太多时间，因为物理引擎在同一迭代中还有许多其他任务要完成。然而，我们也不希望将最大迭代次数减少太多，因为这只会近似最终解决方案，使其运动看起来远不如如果给它更多时间计算结果那样可信。
- en: The same solver also gets involved when resolving inter-object collisions and
    contacts. It can almost always determine the correct result for simple collisions
    with a single iteration, except for some very rare and complex collision situations
    with Mesh Colliders. It is mostly when attached objects will be affected through
    joints that the solver requires additional effort to integrate the final result.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决对象间碰撞和接触时，相同的求解器也会被涉及。它几乎总是可以通过单次迭代确定简单碰撞的正确结果，除了与网格碰撞器的一些非常罕见且复杂的碰撞情况。大多数情况下，当附加对象将通过关节受到影响时，求解器需要额外的努力来整合最终结果。
- en: The maximum number of iterations the solver is allowed to attempt is called
    the **solver iteration count**, which can be modified under Edit | Project Settings
    | Physics | Default Solver Iterations. In most cases, the default value of six
    iterations is perfectly acceptable. However, games that include very complex joint
    systems may wish to increase this count to suppress any erratic (or downright
    explosive) `CharacterJoint` behaviors, whereas some projects may be able to get
    away with reducing this count. Testing must be performed after changing this value
    to check whether the project still maintains the intended levels of quality. Note
    that this value is the default solver iteration count—the value that gets applied
    to any newly created Rigidbodies. We can change this value at runtime through
    the `Physics.defaultSolverIterations` property, but this still won't affect preexisting
    Rigidbodies. If necessary, we can modify their solver iteration count after they
    are constructed through the `Rigidbody.solverIterations` property.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 求解器允许尝试的最大迭代次数被称为**求解器迭代次数**，可以在“编辑 | 项目设置 | 物理 | 默认求解器迭代次数”下进行修改。在大多数情况下，默认的六次迭代值是完全可接受的。然而，包含非常复杂的关节系统的游戏可能希望增加此计数以抑制任何不规则的（或直接爆炸性的）`CharacterJoint`行为，而某些项目可能可以通过减少此计数来避免。更改此值后必须进行测试，以检查项目是否仍然保持预期的质量水平。请注意，此值是默认求解器迭代次数——应用于任何新创建的刚体的值。我们可以在运行时通过
    `Physics.defaultSolverIterations` 属性更改此值，但这仍然不会影响现有的刚体。如果需要，我们可以在它们构建后通过 `Rigidbody.solverIterations`
    属性修改它们的求解器迭代次数。
- en: If we find our game regularly runs into jarring, erratic, and physics-breaking
    situations with complex joint-based objects (such as ragdolls), then we should
    consider gradually increasing the solver iteration count until the problems are
    suppressed. These problems typically occur if our ragdolls absorb too much energy
    from colliding objects, and the solver is unable to iterate the solution down
    to something reasonable before it is asked to give up. At this point, one of the
    joints goes supernova, dragging the rest of them into orbit along with it. Unity
    has a separate setting for this problem, which can be found under Edit | Project
    Settings | Physics | Default Solver Velocity Iterations. Increasing this value
    will give the solver more opportunity to calculate a sensible velocity during
    joint-based object collisions and help to avoid the above scenario. Again, this
    is a default value; hence, it is only applied to newly created Rigidbodies. The
    value can be modified at runtime through the `Physics.defaultSolverVelocityIterations` property
    and can be customized on specific Rigidbodies through the `Rigidbody.solverVelocityIterations` property.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现在游戏中经常遇到由于复杂的基于关节的对象（例如布娃娃）而导致的令人不快的、不规则的、违反物理规律的情景，那么我们应该考虑逐渐增加求解器的迭代次数，直到这些问题被抑制。这些问题通常发生在我们的布娃娃从碰撞对象中吸收了过多的能量，而求解器在被迫放弃之前无法迭代出合理的解决方案。在这种情况下，其中一个关节会发生超新星爆炸，将其他关节也拖入轨道。Unity
    为此问题提供了一个单独的设置，可以在“编辑 | 项目设置 | 物理 | 默认求解器速度迭代次数”下找到。增加此值将给求解器更多的机会在基于关节的对象碰撞期间计算合理的速度，并有助于避免上述情况。再次强调，这是一个默认值；因此，它仅适用于新创建的刚体。此值可以通过
    `Physics.defaultSolverVelocityIterations` 属性在运行时修改，并且可以通过 `Rigidbody.solverVelocityIterations`
    属性在特定的刚体上自定义。
- en: In either case, increasing the number of iterations will consume more CPU resources
    during every fixed update where the joint objects remain active.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，增加迭代次数都会在关节对象保持活跃的每次固定更新期间消耗更多的CPU资源。
- en: Note that the Physics 2D settings for solver iterations are named Position Iterations
    and Velocity Iterations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Physics 2D 的求解器迭代设置被命名为“位置迭代”和“速度迭代”。
- en: Optimizing ragdolls
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化布娃娃
- en: Speaking of joint-based objects, ragdolls are incredibly popular features for
    a good reason; they're tons of fun! Ignoring the morbidity of flinging corpses
    around a game world for the moment, there's something about watching a complex
    chain of objects flail around and smash into things that hits a lot of fun psychological
    buttons. This makes it very tempting to allow many ragdolls to coexist within
    our scene at the same time, but as we quickly discover, this risks an enormous
    performance hit when too many ragdolls are in motion and/or collide with other
    objects due to the amount of iterations the solver would need to resolve them
    all. So, let's explore some ways to improve the performance of ragdolls.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 谈及基于关节的对象，ragdolls（布娃娃）因其独特的魅力而广受欢迎，这并非没有原因；它们非常有趣！暂且不提在游戏世界中抛掷尸体所带来的恐怖感，观看一个复杂物体链在周围挥舞并撞击其他物体，确实能触动许多人的乐趣心理。这使得我们非常想在我们的场景中同时让许多ragdolls共存，但很快我们发现，当太多的ragdolls处于运动状态或由于迭代求解器需要解决所有这些碰撞而与其他物体发生碰撞时，这会带来巨大的性能损失。因此，让我们探讨一些提高ragdolls性能的方法。
- en: Reducing joints and colliders
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少关节和碰撞体
- en: Unity provides a simple ragdoll-generation tool (the Ragdoll Wizard) under GameObject
    | 3D Object | Ragdoll…. This tool can be used to create ragdolls from a given
    object by selecting the appropriate child GameObjects to attach `Joint` and `Collider` components
    for any given body part or limb. This tool always creates 13 different colliders
    and associated joints (pelvis, chest, head, two colliders per arm, and three colliders
    per leg).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在GameObject | 3D Object | Ragdoll…下提供了一个简单的ragdoll生成工具（Ragdoll Wizard）。此工具可以通过选择适当的子GameObject来创建ragdoll，并为任何给定的身体部位或肢体附加`Joint`和`Collider`组件。此工具始终创建13个不同的碰撞体和相关的关节（骨盆、胸部、头部、每只手臂两个碰撞体，每条腿三个碰撞体）。
- en: Note that a bug causes the Ragdoll Wizard not to complain if nothing is assigned
    to Left Foot or Right Foot `transform` component references as it does for the
    rest of them, but Unity will throw `NullReferenceException` if we try to create
    the mesh without them assigned. Ensure that all 13 `transform` component references
    have been assigned when we try to create a ragdoll.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果左脚或右脚的`transform`组件引用没有分配，Ragdoll Wizard不会抱怨，但就像对其他组件一样，如果尝试创建没有分配的网格，Unity将会抛出`NullReferenceException`。确保在我们尝试创建ragdoll时，所有13个`transform`组件引用都已分配。
- en: However, it's possible to use only seven colliders (pelvis, chest, head, and
    one collider per limb) to greatly reduce the overhead cost at the expense of ragdoll
    realism. This can be achieved by deleting unwanted colliders and manually reassigning
    the character joint's `connectedBody` properties to the proper parent joints (connect
    the arm colliders to the chest, and connect the leg colliders to the pelvis).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅使用七个碰撞体（骨盆、胸部、头部和每条肢体一个碰撞体）就可以大大减少开销，尽管这会牺牲ragdoll的真实感。这可以通过删除不需要的碰撞体并手动重新分配角色关节的`connectedBody`属性到适当的父关节来实现（将手臂碰撞体连接到胸部，将腿部碰撞体连接到骨盆）。
- en: Note that we assign a mass value during ragdoll creation using the Ragdoll Wizard.
    This mass value is spread across the various joints as appropriate and, therefore,
    represents the total mass of the object. We should ensure that we don't apply
    a mass value too high or too low compared to other objects in our game to avoid
    potential instability.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在使用Ragdoll Wizard创建ragdoll时分配了一个质量值。这个质量值会根据适当的关节分布，因此代表了物体的总质量。我们应该确保我们不会将质量值设置得过高或过低，与其他游戏中的物体相比，以避免潜在的不稳定性。
- en: Avoiding inter-ragdoll collisions
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免ragdolls之间的碰撞
- en: The performance cost of ragdolls grows exponentially when they are allowed to
    collide with other ragdolls. In fact, any joint collision requires the solver
    to calculate the resultant velocity applied to all of the joints connected to
    it, and then each of the joints connected to the other ragdoll. That means, in
    practice, that both ragdolls must be resolved entirely multiple times. Moreover,
    it gets significantly more complicated if various parts of the ragdolls are likely
    to collide with one another during the same collision.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当允许ragdolls与其他ragdolls碰撞时，它们的性能成本会呈指数增长。实际上，任何关节碰撞都需要求解器计算施加到所有连接到它的关节上的结果速度，然后是连接到另一个ragdoll的每个关节。这意味着在实践中，两个ragdolls都必须完全解决多次。此外，如果ragdolls的各个部分在相同碰撞中可能相互碰撞，这会变得更加复杂。
- en: This is a tough task for the solver to handle, so we should avoid it. The best
    way to do this is to use the Collision Matrix. It is wise to assign all ragdolls
    to their own Layer and uncheck the corresponding checkbox in the Collision Matrix
    so that objects in the given Layer cannot collide with objects in the same Layer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于求解器来说是一个艰巨的任务，因此我们应该避免它。最好的办法是使用碰撞矩阵。明智的做法是将所有ragdolls分配到它们自己的层，并在碰撞矩阵中取消选中相应的复选框，这样给定层的对象就不能与同一层的对象发生碰撞。
- en: Replacing, deactivating, or removing inactive ragdolls
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换、停用或移除非活动ragdolls
- en: In some games, once a ragdoll has reached its final destination, we no longer
    need it to remain in the game world as an interactable object. We could then either
    deactivate, destroy, or replace the ragdoll with a more straightforward alternative when
    they are no longer needed (a good trick is to replace them with the simpler version
    that uses only seven joints as suggested earlier). Such simplifications are often
    implemented as a means of reducing overhead for weaker hardware/lower quality
    settings or as a compromise to allow more ragdolls to coexist in our scene. It
    could even be used dynamically if a particular number of ragdolls is already present.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些游戏中，一旦ragdoll到达其最终位置，我们就不再需要它作为可交互对象留在游戏世界中。然后，当它们不再需要时，我们可以停用、销毁或用更简单的方法替换ragdoll（一个很好的技巧是替换为之前建议的只使用七个关节的简单版本）。这种简化通常被用作降低硬件性能较弱/低质量设置的开销的手段，或者作为允许更多ragdolls共存于场景中的妥协。如果已经存在一定数量的ragdolls，这甚至可以动态使用。
- en: We would need some object to keep track of all of our ragdolls, being notified
    any time a ragdoll is created, keeping track of how many ragdolls currently exist,
    watching each of them until they fall asleep through `RigidBody.IsSleeping()`
    and then do something appropriate with them. The same object could also choose
    to instantiate simpler ragdoll variations if the scene already contains more ragdolls
    than is reasonable. This would be another good opportunity to make use of the
    messaging system we explored in Chapter 2, *Scripting Strategies*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个对象来跟踪所有的ragdolls，每当创建一个ragdoll时都会得到通知，跟踪当前存在的ragdolls数量，通过`RigidBody.IsSleeping()`监视它们直到它们进入休眠状态，然后对它们进行适当的处理。这个对象还可以选择实例化更简单的ragdoll变体，如果场景中已经包含比合理数量更多的ragdolls。这将是我们利用第2章中探讨的消息系统的好机会。
- en: Whichever approach we choose to improve the performance of our ragdolls will
    no doubt result in limiting ragdolls as a gameplay feature, either by instantiating
    fewer of them, giving them less complexity, or giving them a shorter lifetime,
    but these are reasonable compromises to make given the performance-saving opportunities.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择哪种方法来提高我们的ragdolls的表现，无疑都会导致将ragdolls作为游戏功能进行限制，无论是通过实例化更少的ragdolls、减少它们的复杂性，还是缩短它们的存活时间，但考虑到性能提升的机会，这些妥协是合理的。
- en: Knowing when to use physics
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知道何时使用物理引擎
- en: The most obvious method to improve the performance of a feature is to avoid
    using it as much as possible. For all movable objects in our game, we should take
    a moment to ask ourselves if getting the physics engine involved is even necessary.
    If not, we should look for opportunities to replace them with something simpler
    and less costly.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 提高一个功能性能的最明显方法就是尽可能避免使用它。对于我们游戏中的所有可移动对象，我们应该花点时间问问自己，是否真的需要物理引擎的介入。如果不是，我们应该寻找机会用更简单、成本更低的东西来替换它们。
- en: Perhaps we're using physics to detect whether the player fell into a kill-zone
    (water, lava, a death-plummet, and so on), but our game is simple enough that
    we only have kill-zones at a specific height. In this case, we could avoid physics
    colliders altogether and get away with only checking whether the player's *y*-position
    falls below a particular value.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们正在使用物理引擎来检测玩家是否掉入了死亡区域（水、熔岩、死亡悬崖等），但我们的游戏足够简单，我们只在特定高度有死亡区域。在这种情况下，我们可以完全避免使用物理碰撞器，只需检查玩家的*y*位置是否低于某个特定值即可。
- en: Consider the following example—we're trying to simulate a meteor shower, and
    our first instinct was to have many falling objects that move via physics Rigidbodies,
    detect collisions with the ground via colliders, and then generate an explosion
    at the point of impact. However, perhaps the ground is consistently flat, or we
    have access to the Terrain's heightmap for some rudimentary collision detection.
    In this case, object travel could be simplified by manually tweening the objects'
    `transform.position` over time to simulate the same traveling behavior without
    requiring any physics components. In both cases, we can reduce the physics overhead
    by simplifying the situation and pushing the work into the script code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例——我们试图模拟流星雨，我们的第一反应是让许多物体通过物理刚体移动，通过碰撞体检测地面碰撞，然后在碰撞点生成爆炸。然而，也许地面始终是平坦的，或者我们有访问地形高度图进行一些基本的碰撞检测。在这种情况下，可以通过手动在一段时间内缓动物体的
    `transform.position` 来简化物体旅行，以模拟相同的旅行行为，而不需要任何物理组件。在这两种情况下，我们可以通过简化情况并将工作推入脚本代码来减少物理开销。
- en: '**Tweening** is a common shorthand term for in-betweening, which is the act
    of interpolating variables from one value to another gradually over time. There
    are many useful (and free) tweening libraries available on the Unity Asset Store
    that can provide a lot of useful functionality. Although, be careful of potentially
    poor optimization in these libraries.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓动**是一个常见的简写术语，指的是在一段时间内逐渐从一个值插值到另一个值的行为。Unity Asset Store上有许多有用的（且免费的）缓动库，可以提供很多有用的功能。尽管如此，要注意这些库中可能存在的潜在的低优化。'
- en: The reverse is also possible. There might be occasions where we're performing
    a great deal of calculation through script code that could be handled through
    physics relatively simply. For example, we might have implemented an inventory
    system with many objects that can be picked up. When the player hits the pick
    up Object key, each of these objects might be compared against the player's position
    to figure out which object is the closest.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也是可能的。可能会有这样的情况，我们通过脚本代码执行大量的计算，而这些计算可以通过物理相对简单地处理。例如，我们可能实现了一个包含许多可拾取物体的库存系统。当玩家按下拾取物体键时，这些物体中的每一个都可能被与玩家的位置进行比较，以确定哪个物体是最接近的。
- en: We could consider replacing all of the script code with a single `Physics.OverlapSphere()`
    call to get nearby objects when the key is pressed, and then figure out the closest
    pickup object from the result (or, better yet, just automatically pick up all
    of them. Why make the player repeatedly click more than necessary?). This could
    greatly reduce the total number of objects that must be compared each time the
    key is pressed although comparisons should be made to ensure that this is the
    case.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑在按键时用单个 `Physics.OverlapSphere()` 调用来替换所有的脚本代码，以获取附近的物体，然后从结果中找出最近的拾取物体（或者，更好的是，自动拾取所有物体。为什么让玩家重复点击不必要的次数呢？）。这可以大大减少每次按键时必须比较的总物体数量，尽管应该进行比较以确保这一点。
- en: Ensure that you seek to remove unnecessary physics grunt work from your scenes
    or use physics to replace behavior that is costly when performed through script
    code. The opportunities are as wide and far-reaching as your own ingenuity. The
    ability to recognize opportunities like this takes experience but is a vital skill
    that will serve you well when saving performance in current and future game development
    projects.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你试图从场景中移除不必要的物理工作，或者使用物理来替换通过脚本代码执行时成本较高的行为。机会就像你的创造力一样广泛和深远。识别这种机会需要经验，但这是在当前和未来的游戏开发项目中节省性能的重要技能。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered numerous methods to improve our game's physics simulation both
    in terms of performance and consistency. The best technique when it comes to costly
    systems such as physics engines is simply avoidance. The less we need to use the
    system, the less we need to worry about it generating bottlenecks. In the worst-case
    scenario, we may need to reduce the scope of our game to condense physics activity
    down to only the essentials, but as we've learned, there are plenty of ways to
    reduce physics complexity without causing any noticeable gameplay effects.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了许多提高游戏物理模拟性能和一致性的方法。在涉及昂贵系统如物理引擎的情况下，最佳技术就是避免使用。我们越少使用系统，就越少担心它产生瓶颈。在最坏的情况下，我们可能需要缩小游戏范围，将物理活动仅限于必要部分，但正如我们所学的，有
    plenty of ways to reduce physics complexity without causing any noticeable gameplay
    effects.
- en: In the next chapter, we will immerse ourselves in Unity's Rendering Pipeline
    and discover how to maximize the graphical fidelity of our application, by making
    use of all of the CPU cycles we've freed up using the performance enhancements
    from earlier chapters.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入Unity的渲染管线，了解如何通过利用之前章节中性能提升所释放的所有CPU周期，来最大化应用程序的图形保真度。
