- en: Chapter 9. Using Asynchronous I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will review asynchronous I/O operations in detail. You
    will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with files asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an asynchronous HTTP server and client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a database asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a WCF service asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we already discussed how important it is to use asynchronous
    I/O operations properly. Why does it matter so much? To have a solid understanding,
    let's consider two kinds of applications.
  prefs: []
  type: TYPE_NORMAL
- en: When we run an application on a client, one of the most important things is
    to have a responsive user interface. This means that no matter what is happening
    with the application, all user interface elements, such as buttons and progress
    bars, keep running fast, and the user gets an immediate reaction from the application.
    This is not easy to achieve! If you try to open the Notepad text editor in Windows
    and try to load a text document that is several megabytes in size, the application
    window will be frozen for a significant amount of time because the whole text
    is being loaded from the disk first, and only then does the program start to process
    user input.
  prefs: []
  type: TYPE_NORMAL
- en: This is an extremely important issue, and in this situation, the only solution
    is to avoid blocking the UI thread at all costs. This in turn means that to prevent
    the blocking of the UI thread, every UI-related API must allow only asynchronous
    calls. This is the key reason behind redesigning APIs in the Windows 8 operating
    system by replacing almost every method with asynchronous analogs. But does it
    affect the performance if our application uses multiple threads to achieve this
    goal? Of course, it does! However, we could pay the price considering that we
    have only one user. It is good to have the application using all the power of
    the computer to be more effective, as all this power is intended for the single
    user who runs the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the second case, then. If we run the application on a server,
    we have a completely different situation. We have scalability as a top priority,
    which means that a single user should consume as little resource as possible.
    If we start to create many threads for each user, we simply cannot scale well.
    It is a very complex problem to balance our application resource consumption in
    an efficient way. For example, in ASP.NET, which is a web application platform
    from Microsoft, we use a pool of worker threads to serve client requests. This
    pool has a limited number of worker threads, and we have to minimize the use time
    for each worker thread to achieve scalability. This means that we have to return
    it to the pool as soon as possible so that it can serve another request. If we
    start an asynchronous operation that requires computation, we will have a very
    inefficient workflow. First, we take a worker thread from the thread pool to serve
    a client request. Then, we take another worker thread and start an asynchronous
    operation on it. Now, we have two worker threads serving our request, but we really
    need the first thread to be doing something useful! Unfortunately, the common
    situation is that we simply wait for the asynchronous operation to complete, and
    we consume two worker threads instead of one. In this scenario, asynchrony is
    actually worse than synchronous execution! We do not need to load all the CPU
    cores as we are already serving many clients and thus are using all the CPU computing
    power. We do not need to keep the first thread responsive as we have no user interface.
    Then, why should we use asynchrony in server applications?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we should use asynchrony when there is an asynchronous I/O
    operation. Today, modern computers usually have a hard disk drive that stores
    files and a network card that sends and receives data over the network. Both of
    these devices have their own microcomputers that manage I/O operations on a very
    low level and signal the operating system about the results. This is again quite
    a complicated topic; but to keep the concept clear, we could say that there is
    a way for programmers to start an I/O operation and provide the operating system
    with code to callback when the operation is completed. Between starting an I/O
    task and its completion, there is no CPU work involved; it is done in the corresponding
    disk and network controller microcomputers. This way of executing an I/O task
    is called an I/O thread; they are implemented using the .NET thread pool and in
    turn use an infrastructure from the operating system called I/O completion ports.
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET, as soon as an asynchronous I/O operation is started from a worker
    thread, it can be returned immediately to the thread pool! While the operation
    is going on, this thread can serve other clients. Finally, when the operation
    signals completion, the ASP.NET infrastructure gets a free worker thread from
    the thread pool (which could be different from the one that started the operation),
    and it finishes the operation.
  prefs: []
  type: TYPE_NORMAL
- en: All right; we now understand how important I/O threads are for server applications.
    Unfortunately, it is very hard to check whether any given API uses I/O threads
    under the hood. The only way (besides studying the source code) is simply to know
    which .NET Framework class library leverages I/O threads. In this chapter, we
    will see how to use some of those APIs. You will learn how to work with files
    asynchronously, how to use network I/O to create an HTTP server and call the **Windows
    Communication Foundation** (**WCF**) service, and how to work with an asynchronous
    API to query a database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important issue to consider is parallelism. For a number of reasons,
    an intensive parallel disk operation might have very poor performance. Be aware
    that parallel I/O operations are often very ineffective, and it might be reasonable
    to work with I/O sequentially, but in an asynchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks us through how to create a file and how to read and write
    data asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to work with files asynchronously, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, we create four files in different ways and fill them
    up with random data. In the first case, we use the `FileStream` class and its
    methods, converting an Asynchronous Programming Model API to a task; in the second
    case, we do the same, but we provide `FileOptions.Asynchronous` to the `FileStream`
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to use the `FileOptions.Asynchronous` option. If we omit
    this option, we can still work with the file in an asynchronous manner, but this
    is just an asynchronous delegate invocation on a thread pool! We use the I/O asynchrony
    with the `FileStream` class only if we provide this option (or bool `useAsync`
    in another constructor overload).
  prefs: []
  type: TYPE_NORMAL
- en: The third case uses some simplifying APIs, such as the `File.Create` method
    and the `StreamWriter` class. It still uses I/O threads, which we are able to
    check using the `stream.IsAsync` property. The last case illustrates that oversimplifying
    is also bad. Here, we do not leverage the I/O asynchrony by imitating it with
    the help of asynchronous delegate invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we perform parallel asynchronous reading from files, sum up their content,
    and then sum it with each other. Finally, we delete all the files. As there is
    no asynchronous delete file in any non-Windows store application, we simulate
    the asynchrony using the `Task.Run` factory method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an asynchronous HTTP server and client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to create a simple asynchronous HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how to create a simple asynchronous HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the `System.Net.Http` framework library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we implement a very simple web server using the `HttpListener` class.
    There is also a `TcpListener` class for the TCP socket I/O operations. We configure
    our listener to accept connections from any host to the local machine on port
    `1234`. Then, we start the listener in a separate worker thread so that we can
    control it from the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous I/O operation happens when we use the `GetContextAsync` method.
    Unfortunately, it does not accept `CancellationToken` for cancelation scenarios;
    so, when we want to stop the server, we just call the `_listener.Abort` method,
    which abandons the connection and stops the server.
  prefs: []
  type: TYPE_NORMAL
- en: To perform an asynchronous request on this server, we use the `HttpClient` class
    located in the `System.Net.Http` assembly and the same namespace. We use the `GetAsync`
    method to issue an asynchronous HTTP `GET` request. There are methods for other
    HTTP requests such as `POST`, `DELETE`, and `PUT` as well. `HttpClient` has many
    other options such as serializing and deserializing an object using different
    formats, such as XML and JSON, specifying a proxy server address, credentials,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, you can see that the server has been started up. In
    the server code, we use the `GetContextAsync` method to accept new client connections.
    This method returns when a new client connects, and we simply output a very basic
    HTML language with the current date and time to the response. Then, we request
    the server and print the response headers and content. You can also open your
    browser and browse to `http://localhost:1234/`. Here, you will see the same response
    displayed in the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a database asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks us through the process of creating a database, populating
    it with data, and reading data asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the process of creating a database, populating it with data,
    and reading data asynchronously, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This program works with software called SQL Server 2014 LocalDb. It is installed
    with Visual Studio 2015 and should work fine. However, in case of errors, you
    might want to repair this component from the installation wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with configuring paths to our database files. We place database files
    in the program-execution folder. There will be two files: one for the database
    itself and another for the transaction log file. We also configure two connection
    strings that define how we connect to our databases. The first one is to connect
    to the LocalDb engine to detach our database; if it already exists, delete and
    then recreate it. We leverage the I/O asynchrony while opening the connection
    and while executing the SQL commands using the `OpenAsync` and `ExecuteNonQueryAsync`
    methods, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: After this task is completed, we attach a newly created database. Here, we create
    a new table and insert some data in it. In addition to the previously mentioned
    methods, we use `ExecuteScalarAsync` to asynchronously get a scalar value from
    the database engine, and we use the `SqlDataReader.ReadAsync` method to read a
    data row from the database table asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: If we had a large table with large binary values in its rows in our database,
    then we would use the `CommandBehavior.SequentialAcess` enumeration to create
    the data reader and the `GetFieldValueAsync` method to get large field values
    from the reader asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a WCF service asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to create a WCF service, how to host it in a console
    application, how to make service metadata available to clients, and how to consume
    it in an asynchronous way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to work with a WCF service, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add references to the `System.ServiceModel` library. Right-click on the `References`
    folder in the project and select the **Add reference…** menu option. Add references
    to the `System.ServiceModel` library. You can use the search function in the reference
    manager dialog, as shown in the following screenshot:![How to do it...](img/B05292_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WCF is a framework that allows us to call remote services in different ways.
    One of them, which was very popular some time ago, was used to call remote services
    via HTTP using an XML-based protocol called the **Simple Object Access Protocol**
    (**SOAP)**. It is quite common when a server application calls another remote
    service, and this could be done using I/O threads as well.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2015 has rich support for WCF services; for example, you can add
    references to such services with the **Add Service Reference** menu option. You
    could do this with our service as well because we provide service metadata.
  prefs: []
  type: TYPE_NORMAL
- en: To create such a service, we need to use a `ServiceHost` class that will host
    our service. We describe what service we will be hosting by providing a service
    implementation type and the base URI by which the service will be addressed. Then,
    we configure the metadata endpoint and the service endpoint. Finally, we handle
    the `Faulted` event in case of errors and run the host service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Be aware that we need to have administrator privileges to run the service,
    since it uses HTTP bindings, which in turn use `http.sys` and thus require special
    permissions to be created. You can run Visual Studio under an administrator or
    run the following command in the elevated command prompt to add the necessary
    permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To consume this service, we create a client, and here is where the main trick
    happens. On the server side, we have a service with the usual synchronous method
    called `Greet`. This method is defined in the service contract, `IHelloWorldService`.
    However, if we want to leverage an asynchronous network I/O, we have to call this
    method asynchronously. We can do that by creating a new service contract with
    a matching namespace and service name, where we define both the synchronous and
    task-based asynchronous methods. In spite of the fact that we do not have an asynchronous
    method definition on the server side, we follow the naming convention, and the
    WCF infrastructure understands that we want to create an asynchronous proxy method.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when we create an `IHelloWorldServiceClient` proxy channel, and WCF
    correctly routes an asynchronous call to the server-side synchronous method, if
    you leave the application running, you can open the browser and access the service
    using its URL, that is, `http://localhost:1234/HelloWorld`. A service description
    will be opened, and you can browse to the XML metadata that allows us to add a
    service reference from Visual Studio 2012\. If you try to generate the reference,
    you will see slightly more complicated code, but it is autogenerated and easy
    to use.
  prefs: []
  type: TYPE_NORMAL
