- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing External Assets, APIs, and Pre-Built Components with C# in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 8*](B22017_08.xhtml#_idTextAnchor127), where we will delve
    into essential aspects of game development using C#. We will begin by exploring
    the integration of pre-built assets, a fundamental skill for enhancing game visuals
    and performance. Then, we will delve into the integration of rendering pipelines,
    which is crucial for optimizing game visuals and achieving better performance.
    After that, we will discuss the significance of backend services in game development,
    focusing on authentication logic as a prime example of their importance. Lastly,
    we will explore analytics APIs and their pivotal role in understanding player
    behavior and optimizing game performance. Throughout this chapter, I’ll demonstrate
    how to implement these key components into our game, empowering you to create
    immersive and engaging gaming experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging pre-built assets with C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating backend services with C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating analytics APIs with C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code files of this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2008](B22017_08.xhtml#_idTextAnchor127).'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging pre-built assets with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the vast world of game development, time is as valuable as the pixels on
    our screens. Every moment counts, and each bit of code shapes the worlds players
    will explore. This is where third-party assets come in handy—they are efficient
    tools that enhance creativity in the changing landscape of game design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine this: you’re a new game developer with a bright vision. You dream of
    vast landscapes, detailed character animations, and sounds that take players to
    faraway lands. However, the journey from idea to reality is full of challenges,
    and time is hard to come by.'
  prefs: []
  type: TYPE_NORMAL
- en: Third-party assets, often underappreciated in game development, play a crucial
    role. These readily available resources form the backbone of game creation, bringing
    virtual worlds to fruition. From grand landscapes to subtle environmental details,
    third-party assets simplify the complex task of asset creation, allowing us to
    focus on refining gameplay and improving player experiences.
  prefs: []
  type: TYPE_NORMAL
- en: '*But why are they so important?* Firstly, third-party assets offer a wealth
    of resources created by experts. Whether you need stunning environments, realistic
    characters, or chilling sound effects, the vast array of third-party assets has
    it all. These assets fuel creativity, sparking imagination and helping us turn
    ideas into reality quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the benefits go beyond convenience. By using pre-built assets,
    we can focus on the core of our games—the gameplay itself. Free from creating
    assets, they can craft immersive worlds, compelling stories, and unforgettable
    experiences that capture players’ hearts and endure over time.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore the utilization of pre-built assets available
    in Unity’s Package Manager, such as **URP**, which provides advanced rendering
    options. Let’s begin our exploration.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Render Pipeline (URP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll explore the **Universal Render Pipeline** (**URP**),
    a powerful tool that helps create stunning visuals and optimize performance in
    our Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: URP is a rendering solution provided by Unity Technologies. It’s designed to
    strike a balance between visual quality and performance, making it suitable for
    a wide range of platforms and devices, including mobile, consoles, and PCs.
  prefs: []
  type: TYPE_NORMAL
- en: URP offers a flexible and efficient rendering pipeline that allows for the creation
    of visually appealing games while ensuring smooth performance across different
    hardware configurations. Whether you’re creating a stylized indie game or a realistic
    AAA title, URP provides the tools and features needed to bring your vision to
    life.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between Unity’s render pipelines – URP versus HDRP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity offers two distinct rendering pipelines, URP and the **High-Definition
    Render Pipeline** (**HDRP**), each tailored to different needs and requirements
    in game development. Let’s explore the key differences between the two and the
    reasons why you might choose one over the other for your game.
  prefs: []
  type: TYPE_NORMAL
- en: In the following table, I’ve outlined a comparison between Unity’s render pipelines,
    highlighting key points to assist you in determining the most suitable pipeline
    for your project.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aspect** | **URP** | **HDRP** |'
  prefs: []
  type: TYPE_TB
- en: '| Graphics Fidelity | URP is designed for optimized rendering performance while
    maintaining a balance between visual quality and efficiency. It supports features
    such as real-time lighting, shadows, and post-processing effects. | HDRP aims
    to deliver high-quality visuals and graphical fidelity, especially for high-end
    platforms such as PCs and consoles. It offers advanced rendering features such
    as physically based rendering and volumetric lighting. |'
  prefs: []
  type: TYPE_TB
- en: '| Platform Compatibility | URP is optimized for cross-platform development,
    making it suitable for a diverse range of devices and platforms, including mobile
    devices, consoles, and PCs. | HDRP is tailored for high-end platforms and may
    require more powerful hardware to achieve optimal performance. It may not be as
    suitable for mobile devices or lower-end PCs due to its higher demands |'
  prefs: []
  type: TYPE_TB
- en: '| Art Style and Visual Direction | URP is versatile and accommodates a wide
    range of art styles and visual directions, including stylized, cartoonish, or
    realistic art styles. It allows for visually appealing results across different
    genres and themes. | HDRP is well suited for projects aiming for photorealistic
    graphics and immersive visual experiences. It offers advanced rendering features
    and high-fidelity effects enhancing realism and immersion. |'
  prefs: []
  type: TYPE_TB
- en: '| Development Time and Resources | URP provides a balance between visual quality
    and development efficiency with a streamlined workflow and easier setup. It is
    accessible to developers with limited resources or time constraints. | HDRP offers
    advanced features and graphical capabilities, but it may require additional development
    time and resources to fully leverage its potential. It needs careful optimization
    and tuning for desired performance. |'
  prefs: []
  type: TYPE_TB
- en: In summary, the choice between URP and HDRP depends on various factors, including
    your project’s target platforms, desired graphical fidelity, art style, and available
    development resources. If you prioritize performance, cross-platform compatibility,
    and a balance between visual quality and efficiency, URP may be the preferable
    option. On the other hand, if your project demands high-end visuals, photorealism,
    and advanced graphical effects, HDRP may be the better choice, provided you have
    the necessary resources and hardware to support it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood the contrast between the two distinct rendering
    pipelines in Unity, let’s proceed to install URP.
  prefs: []
  type: TYPE_NORMAL
- en: Installing URP into our project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Before upgrading to a custom render pipeline, it’s essential to back up your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already chosen the URP package for our project. However, if it hasn’t
    been configured in your project yet, you can simply access **Package Manager**
    and select the **Universal RP** option, as you can see in *Figure 8**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Installing the URP package](img/B22017_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Installing the URP package
  prefs: []
  type: TYPE_NORMAL
- en: When you click on **Install**, Unity will install the package and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are migrating from the built-in pipeline to URP or High-Definition RP,
    there are specific instructions to adhere to. You’ll need to adjust all materials
    to utilize the new shaders provided by these packages. However, given that our
    game has been utilizing these packages from the outset, imported files such as
    model materials will already be configured to use the shaders provided by those
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since migrating from the built-in is not our primary objective, I won’t delve
    into upgrading to URP. You can explore additional possibilities by referring to
    the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using URP version 13.1 or newer, there is a built-in converter available.
    Please refer to this page for more information on how to utilize this converter:
    **https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/features/rp-converter.html**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are using a URP version prior to 13.1, you need to refer to this link:
    **https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.0/manual/upgrading-your-shaders.html**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next subsection, we will discover the power of Unity’s URP, a versatile
    package offering optimized rendering, custom shaders, and enhanced lighting for
    creating visually stunning projects across multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring URP in Unity – features and functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The URP package in Unity provides developers with a range of features and functionalities
    to enhance the rendering capabilities of their projects. Here are some key aspects
    of the URP package and its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimized rendering pipeline**: URP offers an optimized rendering pipeline
    designed to balance performance and visual quality across various platforms and
    devices. It includes features such as deferred and forward rendering paths, allowing
    us to choose the rendering technique that best suits their project’s requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lightweight rendering**: URP is designed to be lightweight, making it suitable
    for projects targeting mobile devices, lower-end hardware, and performance-conscious
    applications. It optimizes rendering processes to achieve smooth performance while
    maintaining visual fidelity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shader graph integration**: URP seamlessly integrates with Unity’s Shader
    Graph tool, allowing us to create custom shaders and visual effects without writing
    code. Shader Graph empowers us to design complex materials, lighting effects,
    and post-processing effects through a node-based interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom rendering features**: URP provides support for custom rendering features
    through **Scriptable Render Pipeline** (**SRP**) extensions. We can extend and
    customize the rendering pipeline by implementing custom render passes, post-processing
    effects, and shader variants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced lighting system**: URP includes a flexible lighting system that
    supports real-time lighting, shadows, and reflections. It offers features such
    as per-object and per-pixel lighting, dynamic shadows, and light probes for realistic
    lighting effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post-processing effects**: URP includes built-in support for post-processing
    effects, allowing us to enhance the visual quality of their scenes. It provides
    a range of post-processing effects such as bloom, depth of field, color grading,
    and ambient occlusion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform compatibility**: URP is designed for cross-platform compatibility,
    enabling us to create games and applications for various platforms, including
    mobile devices, consoles, and PCs. It optimizes rendering performance across different
    hardware configurations and platform specifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the URP package in Unity provides us with a lightweight, flexible,
    and optimized rendering solution for creating visually stunning and performance-efficient
    projects. From lighting and shading to post-processing effects and custom rendering
    features, URP empowers us to bring their creative visions to life while ensuring
    optimal performance across different platforms and devices.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore more advanced topics, such as render callbacks and custom
    render features.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering visual modifications in Unity – advanced techniques with URP and C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Introducing advanced techniques in URP using C# can greatly modify the visual
    quality and performance of your Unity projects. Two key features that we can explore
    and discuss in this section are Custom Render Passes and Render Pipeline Callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom** **Render Passes**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom Render Passes allow you to inject custom rendering logic into the render
    pipeline, enabling you to implement specialized effects or optimizations beyond
    the built-in features of URP.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With Custom Render Passes, you have fine-grained control over the rendering
    process at various stages, such as before or after opaque rendering, before or
    after transparent rendering, or even in between specific render queues.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use Custom Render Passes to implement effects like outline rendering,
    screen-space effects, custom post-processing, or optimizations such as rendering
    additional buffers for custom shaders or computations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Render** **Pipeline Callbacks**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render Pipeline Callbacks provide a mechanism for hooking into specific events
    and stages within the render pipeline to execute custom C# code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Render Pipeline Callbacks, you can perform tasks such as modifying materials,
    adjusting rendering settings dynamically, or injecting custom rendering logic
    at specific points in the rendering process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Render Pipeline Callbacks can be used to implement advanced features such as
    dynamic material modifications based on game events, procedural generation of
    textures or geometry, or applying custom shader effects based on runtime conditions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s explore an example that demonstrates the application of these advanced
    techniques within our project.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration of implementing advanced techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a step-by-step guide, illustrated with examples, on how to utilize
    these advanced techniques to create and control the outline effect:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the renderer feature, ensure that your project is configured
    to use the URP renderer data in your **Quality and Graphics** settings within
    the **Project Settings**. Right-click in your **Project** tab and navigate to
    **Create | Rendering | URP Renderer Feature** to generate a new feature script.
    You can name it **OutlineEffect**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Creating an URP Renderer Feature script](img/B22017_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Creating an URP Renderer Feature script
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we open the **OutlineEffect** script and make modifications as outlined
    in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s break down the previous code to explain what each part does:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `OutlineEffect` class defines a custom renderer feature that adds an outline
    effect to objects in the scene by utilizing a custom render pass (`OutlineRenderPass`)
    with a list of outline materials. The `OutlineRenderPass` class implements the
    rendering logic for applying the outline effect to objects during the rendering
    process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, you can integrate the feature into your URP data scriptable object. You
    can customize the settings according to your game’s requirements. For our demonstration,
    I’ve retained the default settings, as depicted in *Figure 8**.3*:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Adding OutlineEffect Feature](img/B22017_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Adding OutlineEffect Feature
  prefs: []
  type: TYPE_NORMAL
- en: 'You can include additional features to achieve your desired visual effects.
    Furthermore, you can refer to Unity’s official documentation for further details
    using the following link: `https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@16.0/manual/index.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you will observe the disparity before and after applying
    the feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 –OutlineEffect feature effect](img/B22017_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 –OutlineEffect feature effect
  prefs: []
  type: TYPE_NORMAL
- en: Discover the significant impact and benefits of leveraging the render pass feature
    for optimizing rendering and enhancing visual effects.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of utilizing the render pass feature?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using render passes in conjunction with the URP offers several benefits for
    implementing an outline effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity and extensibility**: By utilizing render passes, you can modularize
    your rendering pipeline and separate specific rendering tasks into distinct passes.
    This makes your rendering pipeline more flexible and easier to maintain. You can
    add or remove passes as needed without affecting other parts of the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance optimization**: Render passes in URP allow you to control the
    order in which rendering tasks are executed. This enables you to optimize performance
    by efficiently batching and sorting objects, reducing overdraw, and minimizing
    unnecessary render calls. For the outline effect, you can ensure that only the
    necessary objects are rendered with the outline material, reducing the computational
    overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with URP’s rendering pipeline**: URP provides a streamlined rendering
    pipeline optimized for performance across various platforms. By integrating your
    custom rendering effects, such as the outline effect, into URP’s pipeline using
    render passes, you ensure compatibility and consistency with URP’s rendering features
    and optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency across platforms**: URP is designed to provide consistent rendering
    results across different platforms and devices, including desktop, mobile, and
    consoles. By leveraging URP’s features, you can ensure that your outline effect
    behaves predictably and performs optimally across a wide range of target platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shader graph integration**: URP seamlessly integrates with Unity’s Shader
    Graph tool, allowing you to create custom shaders visually without writing code.
    You can use Shader Graph to design the outline shader and easily incorporate it
    into your render pass, making the implementation process more accessible and intuitive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, while it’s possible to apply the outline effect directly without utilizing
    URP’s render pass feature, integrating it with URP offers advantages in terms
    of performance optimization, modularity, consistency, and compatibility with Unity’s
    rendering pipeline. It provides a more robust and flexible solution for implementing
    custom rendering effects in your Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: Game development benefits from pre-built assets and C# scripts, saving time
    and enhancing creativity. Unity’s URP optimizes visuals and performance. Understanding
    URP versus HDRP aids pipeline selection. URP setup involves package installation
    and configuration. URP features include lightweight rendering, Shader Graph integration,
    and advanced techniques such as Custom Render Passes. Render passes in URP offer
    modularity and performance optimization.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we’ll explore integrating backend services, understanding
    their significance in game development, and the reasons for their necessity. Additionally,
    I’ll illustrate their usage through an example featuring one of the available
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating backend services with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will understand how the integration of backend APIs with
    C# provides us with a potent tool to enrich our projects with robust functionalities.
    Through the utilization of these APIs, we can seamlessly link their Unity projects
    to external services, facilitating features such as user authentication, data
    storage, and leaderboards.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore backend services and understand their significance in games.
  prefs: []
  type: TYPE_NORMAL
- en: Backend services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backend services refer to the set of functionalities and infrastructure components
    that support the operation of software applications, including games, from the
    server-side perspective. In the context of game development, backend services
    encompass various features and capabilities designed to enhance gameplay experiences,
    manage player data, and facilitate online interactions. Here are some key aspects
    of backend services in game development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data storage**: Provides storage solutions for game-related data, including
    player profiles, game progress, achievements, inventory, and other persistent
    game state information. This data is typically stored in databases or cloud storage
    systems, ensuring reliability, scalability, and accessibility across different
    platforms and devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User authentication**: Offers authentication mechanisms to verify the identity
    of players and ensure secure access to game features and content. Authentication
    processes typically involve user registration, login, and session management,
    employing encryption and secure protocols to protect user credentials and prevent
    unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplayer functionality**: Enables the implementation of multiplayer features
    in games, allowing players to connect, interact, and compete with each other in
    real time. This includes functionalities such as matchmaking, lobby management,
    game session orchestration, and synchronization of player actions across networked
    environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time communication**: Facilitate real-time communication between game
    clients and servers, supporting features such as in-game chat, messaging, notifications,
    and real-time updates. These communication channels enable players to engage with
    each other, receive important game updates, and participate in collaborative or
    competitive gameplay experiences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics and insights**: Provides analytics tools and capabilities to track
    player behavior, monitor game performance, and gain insights into player engagement,
    retention, and monetization patterns. Analytics data helps us make informed decisions,
    optimize game mechanics, and tailor experiences to meet player preferences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live operations and content management**: Supports live operations and content
    management, allowing us to deploy updates, patches, and new content to games seamlessly.
    This includes features such as **content delivery networks** (**CDNs**), version
    control, A/B testing, and live event management, enabling dynamic and evolving
    gameplay experiences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, backend services form the foundation of modern game development,
    providing essential infrastructure and functionalities to support online multiplayer
    gaming, manage player data, analyze player behavior, and deliver engaging and
    immersive gameplay experiences across different platforms and devices.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction of backend service providers and their features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several backend service providers offer comprehensive solutions tailored to
    the needs of game developers, each with its own set of features and capabilities.
    Here are some available services, and these are the most commonly used options
    at the time of writing this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Firebase**: Developed by Google, Firebase offers a suite of backend services
    including real-time database, authentication, cloud storage, and hosting. It provides
    seamless integration with Unity, making it an ideal choice for us seeking a robust
    and scalable backend solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PlayFab**: PlayFab offers a comprehensive backend platform specifically designed
    for game developers. Its features include player authentication, data storage,
    in-game analytics, virtual currency management, and live operations tools. PlayFab’s
    flexible APIs and SDKs support easy integration with Unity, empowering us to build
    engaging multiplayer experiences and live service features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Web Services (AWS)**: AWS provides a wide range of cloud-based services
    including databases, authentication, content delivery, and analytics. With offerings
    such as Amazon DynamoDB, Amazon Cognito, and Amazon GameLift, AWS offers scalable
    solutions for game developers looking to build, deploy, and manage backend infrastructure
    with flexibility and reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll use PlayFab in this chapter and in the next section, we will implement
    it in our project accordingly. Let’s begin integrating PlayFab.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating PlayFab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this guide, I’ll walk you through the process of implementing PlayFab and
    setting it up in your project. Then, we’ll create a sample authentication logic
    to demonstrate its usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, you’ll need to download the PlayFab Unity package. I’ve utilized
    PlayFab SDK 2.188 for this purpose, which you can obtain from the following link:
    [https://github.com/PlayFab/UnitySDK/releases](https://github.com/PlayFab/UnitySDK/releases).
    Once you download it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In*Figure 8**.5*, as you can see, we’re extracting the PlayFab SDK into our
    project. Simply click **Import** to initiate the process of importing files and
    compiling them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Importing PlayFab SDK](img/B22017_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Importing PlayFab SDK
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for Unity to finish compiling, then navigate to **Assets** | **PlayFabSDK**
    | **Shared** | **Public** | **Resources**. From there, you can select the Scriptable
    Object **PlayFabSharedSettings** to configure it for your project. In *Figure
    8**.6*, you can observe the settings of PlayFab that we can configure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – PlayFab Shared Settings](img/B22017_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – PlayFab Shared Settings
  prefs: []
  type: TYPE_NORMAL
- en: For **Request Type**, you can select **Unity Web Request** or choose the option
    appropriate for your project. However, for our project, I will opt for **Unity**
    **Web Request**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will include the **Title ID** value, which you can obtain from your PlayFab
    game project dashboard. If you don’t have a project yet, you can create one and
    use its key in your project. *Figure 8**.7* shows where you can locate the ID
    needed for PlayFab settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – PlayFab title ID](img/B22017_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – PlayFab title ID
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, access the project to retrieve the secret key; to do that, click on the
    settings icon and select **Title settings**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.8 – PlayFab Title settings](img/B22017_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – PlayFab Title settings
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding step will open the settings tabs and from here, we can navigate
    to the **Secret Keys** tab to retrieve the secret key, as depicted in *Figure
    8**.9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 –  Title secret key](img/B22017_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Title secret key
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Show** to reveal the secret key. You can then copy it and paste it
    into the **Developer Secret Key** field in the PlayFab settings in our game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That’s it! You now have the PlayFab SDK integrated into your project. In the
    next steps, we will begin using it and learn through an example. While this example
    is just a sample, it will cover the full flow of using this package. There are
    numerous possibilities for utilizing this package, so feel free to explore their
    documentation for further insights: [https://learn.microsoft.com/en-us/gaming/playfab/](B22017_08.xhtml#_idTextAnchor138).'
  prefs: []
  type: TYPE_NORMAL
- en: Developing a sample login system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are various methods for user login in games, such as using email, guest
    accounts, and, for mobile platforms, utilizing Play services for Android and Game
    Center for iOS. PlayFab offers a variety of options to facilitate user login based
    on the game platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this system, we can establish a well-organized structure by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by creating an interface for the login method. In the following
    code block, you will find a login method along with callbacks for the login state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we can create a class for each login method. For guest login, we will
    utilize the device ID for authentication. In the following code block, we have
    implemented the **ILogin** interface with the **DeviceLogin** class and incorporated
    the logic for logging in with the device ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can follow these steps and create additional login logic, especially if
    you are targeting mobile platforms, as there will be alternative login methods
    specific to mobile devices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we can create a **LoginManager** class, which will be responsible for
    invoking the appropriate login method, as demonstrated in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next step, we will implement a **PlayfabManager** script to manage
    the login methods and handle user input, subsequently triggering appropriate actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `PlayFabManager`, you’ll discover methods to log in using email and device
    ID, along with callbacks indicating login status. Additionally, I’ve included
    an example of how to handle successful user logins by loading their data. This
    enables us to execute further logic based on the data stored in PlayFab.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That concludes this example, which may seem simple but encompasses the complete
    process of utilizing PlayFab. This package offers extensive capabilities, including
    leaderboard management, remote settings configuration, analytics, and matchmaking.
    As mentioned earlier, explore their documentation for further insights and possibilities:
    [https://learn.microsoft.com/en-us/gaming/playfab/](B22017_08.xhtml#_idTextAnchor138).'
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we have gained insight into the significance of backend services
    for our games. We successfully integrated PlayFab into our project and learned
    to develop a login system through this process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will delve into analytics APIs, their benefits in games,
    and the reasons behind their necessity in our game development endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating analytics APIs with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Analytics APIs are software interfaces that enable us to integrate analytics
    functionality into our applications, including games. These APIs allow us to collect,
    analyze, and interpret data related to user interactions, behaviors, and performance
    metrics within our games. Here are some key aspects of analytics APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data collection**: Analytics APIs facilitate the collection of various types
    of data generated by user interactions within the game. This includes information
    such as player actions, session durations, in-game purchases, progression milestones,
    and user demographics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event tracking**: We can use analytics APIs to track specific events or actions
    within the game, such as level completions, item acquisitions, quest achievements,
    and social interactions. By defining and tracking custom events, we can gain insights
    into how players engage with different aspects of the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance monitoring**: Analytics APIs provide tools for monitoring and
    analyzing the performance of the game, including metrics related to frame rates,
    loading times, network latency, and device specifications. This data helps us
    identify performance bottlenecks, optimize game performance, and ensure smooth
    gameplay experiences for players.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User behavior analysis**: Analytics APIs enable us to analyze user behavior
    patterns and trends, helping them understand how players navigate the game, which
    features they engage with the most, and what factors influence their retention
    and engagement. This information informs game design decisions and helps us tailor
    the game experience to better meet player expectations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retention and monetization analysis**: Analytics APIs allow us to track player
    retention rates over time and analyze factors that contribute to player churn.
    Additionally, we can analyze monetization metrics, such as revenue per user, conversion
    rates, and **average revenue per paying user** (**ARPPU**), to optimize monetization
    strategies and maximize revenue opportunities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time reporting and insights**: Analytics APIs provide real-time reporting
    and visualization tools that enable us to access actionable insights and make
    data-driven decisions. Interactive dashboards, charts, and reports allow us to
    monitor **key performance indicators** (**KPIs**), track progress toward goals,
    and identify opportunities for improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, analytics APIs empower us to gain valuable insights into player
    behavior, performance, and monetization, enabling them to optimize game design,
    enhance player experiences, and drive business success. By integrating analytics
    functionality into their games, we can make informed decisions and continuously
    improve the quality and performance of their games.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating GameAnalytics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GameAnalytics** is a popular package for Unity game development that provides
    analytics and insights into player behavior and game performance. It allows us
    to track various metrics, such as player progression, retention rates, in-game
    events, and monetization data, to optimize their games and improve player engagement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key features and capabilities of the GameAnalytics package for
    Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event tracking**: GameAnalytics enables us to track custom events within
    their games, such as level completions, item purchases, achievements unlocked,
    and tutorial progress. This data helps us understand how players interact with
    their games and identify areas for improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User analytics**: The package provides insights into user behavior and demographics,
    including active users, session lengths, retention rates, and user segmentation.
    We can analyze this data to tailor their games to specific player preferences
    and demographics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monetization tracking**: GameAnalytics allows us to track in-app purchases,
    advertising revenue, and other monetization metrics. By analyzing revenue data
    alongside player behavior, we can optimize their monetization strategies and maximize
    revenue generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time dashboards**: The package offers real-time dashboards and reporting
    tools that visualize game analytics data, making it easy for us to monitor game
    performance and make data-driven decisions. We can customize dashboards to focus
    on specific metrics and KPIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with Unity**: GameAnalytics provides a Unity SDK that seamlessly
    integrates with Unity projects, allowing for easy implementation and tracking
    of analytics events and metrics. The SDK supports both Unity Editor and runtime
    environments, enabling us to test and analyze their games throughout the development
    lifecycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform support**: GameAnalytics supports multiple platforms, including
    PC, mobile, console, and web, allowing us to track analytics data across various
    devices and platforms. This cross-platform support enables us to gain insights
    into player behavior across different environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, GameAnalytics is a valuable tool for gaining insights into player behavior,
    optimizing game performance, and maximizing revenue through data-driven decisions.
    Its user-friendly interface, robust feature set, and cross-platform support make
    it a popular choice among game developers worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the subsequent steps, we will integrate GameAnalytics and configure our
    initial event:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will utilize Version 7.8 of the GameAnalytics Unity SDK, which you can download
    using the following link: [https://download.gameanalytics.com/unity/7.8.0/GA_SDK_UNITY.unitypackage](B22017_08.xhtml#_idTextAnchor137).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After downloading the package, implement it into your project by clicking on
    **Import**, as illustrated in *Figure 8**.10*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Importing the GameAnalytics package](img/B22017_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Importing the GameAnalytics package
  prefs: []
  type: TYPE_NORMAL
- en: After waiting for Unity to compile the files, navigate to **Window | GameAnalytics
    | Select Settings**, as demonstrated in *Figure 8**.11*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Opening the GameAnalytics settings](img/B22017_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Opening the GameAnalytics settings
  prefs: []
  type: TYPE_NORMAL
- en: Following the preceding step will display the GameAnalytics settings. Then,
    you can log in with your account or sign up and create a project if you haven’t
    already done so, as illustrated in *Figure 8**.12.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – GameAnalytics settings](img/B22017_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – GameAnalytics settings
  prefs: []
  type: TYPE_NORMAL
- en: After successfully logging in and having a project in your GameAnalytics dashboard,
    you’ll find the option to link your project and implement it with the appropriate
    platform, be it Android, iOS, or Windows. For our game, I selected Windows as
    we are working on a PC game. In *Figure 8**.13*, you’ll see information related
    to the project, such as the game and organization, and the important elements,
    the game key and secret key, which are automatically added upon successful login.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Link our game with GameAnalytics](img/B22017_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Link our game with GameAnalytics
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to add the GameAnalytics game object to our scene. Remember,
    it’s a persistent game object, so there’s no need to implement it in all scenes.
    Simply add one game object.
  prefs: []
  type: TYPE_NORMAL
- en: You should navigate to **Window | GameAnalytics | Create GameAnalytics Object**,
    and the game object will be added to your scene, as shown in *Figure 8**.14*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Adding a GameAnalytics object to our scene](img/B22017_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Adding a GameAnalytics object to our scene
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to begin implementing events into our code, which will depend on
    what you need to track. Allow me to provide you with an example for clarification.
  prefs: []
  type: TYPE_NORMAL
- en: Example of GameAnalytics usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can now initialize GameAnalytics and start using events in your code, as
    demonstrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can add this in the `GameManager` script as an example, or if you have a
    script to handle the initialization of services in your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can utilize it as shown in the following code block. Don’t forget to include
    the `GameAnalyticsSDK` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And there are various types of events available for better data collection.
    For more detailed information, you can refer to the GameAnalytics documentation:
    [https://docs.gameanalytics.com/event-types](B22017_08.xhtml#_idTextAnchor136).'
  prefs: []
  type: TYPE_NORMAL
- en: You need to build the scene containing the GameAnalytics game object first to
    start sending events. It may take a few minutes before results start appearing
    on the website.
  prefs: []
  type: TYPE_NORMAL
- en: You can visit your game on the GameAnalytics website and then navigate to the
    real-time section to view the data, as depicted in *Figure 8**.15*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Real-time data from our game](img/B22017_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Real-time data from our game
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve integrated an analytics API, specifically GameAnalytics, into
    our project, we’ve successfully incorporated it and put it to use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve integrated any package, don’t spend too much time on its possibilities
    initially. Simply integrate it, check for errors, create a sample, and then explore
    its full potential gradually. Don’t complicate things unnecessarily at the outset.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating third-party assets is a valuable skill for any developer. Many
    successful games rely on external resources to save time and ensure top-notch
    quality that might be challenging to achieve independently.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into the integration of pre-built assets and APIs
    using C# in Unity, a pivotal aspect of game development. We began by exploring
    the utilization of pre-built assets to enhance game visuals and optimize performance,
    followed by the integration of rendering pipelines to achieve better visual fidelity.
    The discussion then shifted to the importance of backend services, highlighting
    the significance of authentication logic as an example of their utility in game
    development. Additionally, we explored analytics APIs and their role in understanding
    player behavior and optimizing game performance, demonstrating how to implement
    them effectively into our game projects.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead to [*Chapter 9*](B22017_09_split_000.xhtml#_idTextAnchor139),
    we will focus on optimizing game performance using Unity’s profiling tools. You’ll
    learn to leverage tools like the Profiler, Frame Debugger, and Memory Profiler
    to identify and address performance bottlenecks, optimize rendering, and manage
    memory usage. Through hands-on exercises and practical insights, you’ll gain mastery
    over optimization techniques to ensure your game runs smoothly and efficiently.
    Get ready to elevate your game’s performance in the upcoming chapter!
  prefs: []
  type: TYPE_NORMAL
