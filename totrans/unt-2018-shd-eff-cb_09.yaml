- en: Screen Effects with Unity Render Textures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity渲染纹理的屏幕效果
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下食谱：
- en: Setting up the screen effects script system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置屏幕效果脚本系统
- en: Using brightness, saturation, and contrast with screen effects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用亮度、饱和度和对比度与屏幕效果
- en: Using basic Photoshop-like Blend modes with screen effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类似Photoshop的基本混合模式与屏幕效果
- en: Using the Overlay Blend mode with screen effects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用叠加混合模式与屏幕效果
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most impressive aspects of learning to write shaders is the process
    of creating your own screen effects, also known as post effects. With these screen
    effects, we can create stunning real-time images with Bloom, Motion Blur, HDR
    effects, and so on. Most modern games on the market today make heavy use of these
    screen effects for their depth of field effects, Bloom effects, and even color
    correction effects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 学习编写着色器最令人印象深刻的一面是创建自己的屏幕效果的过程，也称为后期效果。有了这些屏幕效果，我们可以通过泛光、运动模糊、HDR效果等创建令人惊叹的实时图像。如今市场上大多数现代游戏都大量使用这些屏幕效果来实现景深效果、泛光效果，甚至色彩校正效果。
- en: In [Chapter 1](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08), *Post
    Processing Stack*, we discussed how to use this with Unity's built-in Post Processing
    Stack, but in this chapter, you will learn how to build up the script system yourself.
    This system will give you the control to create many kinds of screen effects.
    We will cover `RenderTexture`, what the depth buffer is, and how to create effects
    that give you Photoshop-like control over the final rendered image of your game.
    By utilizing screen effects for your games, you not only round out your shader
    writing knowledge, but you will also have the power to create your own incredible
    real-time renders with Unity from scratch.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08)“后期处理堆栈”中，我们讨论了如何使用Unity内置的后期处理堆栈，但在这章中，你将学习如何自己构建脚本系统。这个系统将赋予你创建许多种屏幕效果的控件。我们将涵盖`RenderTexture`、深度缓冲区是什么，以及如何创建能够让你对游戏最终渲染图像有类似Photoshop控制效果的方法。通过为你的游戏利用屏幕效果，你不仅完善了你的着色器编写知识，而且还将拥有从零开始使用Unity创建自己令人难以置信的实时渲染的能力。
- en: Setting up the screen effects script system
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置屏幕效果脚本系统
- en: The process of creating screen effects is one in which we grab a full-screen
    image (or texture), use a shader to process its pixels on the GPU, and then send
    it back to Unity's renderer to apply it to the whole rendered image of the game.
    This allows us to perform per-pixel operations on the rendered image of the game
    in real time, giving us a more global artistic control.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建屏幕效果的过程是我们抓取全屏图像（或纹理），使用着色器在GPU上处理其像素，然后将它发送回Unity的渲染器以应用于整个游戏的渲染图像。这使我们能够在实时中对游戏的渲染图像进行逐像素操作，从而给我们提供更全局的艺术控制。
- en: Imagine if you had to go through and adjust each material on each object in
    your game to just adjust the contrast of the final look of your game. While not
    impossible, this would take a bit of labor to perform. By utilizing a screen effect,
    we can adjust the screen's final look as a whole, thereby giving us more Photoshop-like
    control over our game's final appearance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你必须逐个调整游戏中每个对象的材质，仅仅调整游戏最终外观的对比度。虽然不是不可能，但这需要一些劳动来完成。通过利用屏幕效果，我们可以整体调整屏幕的最终外观，从而让我们对游戏最终外观有更多的类似Photoshop的控制。
- en: In order to get a screen effect system up and running, we have to set up a single
    script to act as the courier of the game's current rendered image, or what Unity
    calls the `RenderTexture`. By utilizing this script to pass the `RenderTexture`
    to a shader, we can create a flexible system for establishing screen effects.
    For our first screen effect, we are going to create a very simple grayscale effect
    and make our game look black and white. Let's take a look at how this is done.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让屏幕效果系统运行起来，我们必须设置一个单独的脚本来作为游戏当前渲染图像的使者，或者Unity所说的`RenderTexture`。通过利用这个脚本将`RenderTexture`传递给着色器，我们可以创建一个灵活的系统来建立屏幕效果。对于我们的第一个屏幕效果，我们将创建一个非常简单的灰度效果，使我们的游戏看起来是黑白的。让我们看看这是如何实现的。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to get our screen effects system up and running, we need to create
    a few assets for our current Unity project. By doing this, we will set ourselves
    up for the steps in the following sections:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的屏幕效果系统运行起来，我们需要为我们的当前Unity项目创建一些资产。通过这样做，我们将为以下章节中的步骤做好准备：
- en: In the current project, create a new scene to work in.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前项目中创建一个新的场景来工作。
- en: Create a simple sphere in the scene and assign it a new material (I called mine `RedMat`). This
    new material can be anything, but for our example, we will make a simple red material
    using the Standard Shader.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a new directional light and save the scene.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a new C# script and call it `TestRenderImage.cs`. For organization
    purposes, create a folder called `Scripts` from the Project tab to put it in.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With all of our assets ready, you should have a simple scene setup, which looks
    similar to the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make our grayscale screen effect work, we need a script and shader.
    So, we will complete these two new items here and fill them in with the appropriate
    code to produce our first screen effect. Our first task is to complete the C#
    script. This will get the whole system running. After this, we will complete the
    shader and see the results of our screen effect. Let''s complete our script and
    shader with the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `TestRenderImage.cs` C# script and begin by entering a few variables
    that we will need to store important objects and data. Enter the following code
    at the very top of the `TestRenderImage` class:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order for us to edit the screen effect in real time, when the Unity editor
    isn''t playing, we need to enter the following line of code just above the declaration
    of the `TestRenderImage` class:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As our screen effect is using a shader to perform the pixel operations on our
    screen image, we have to create a material to run the shader. Without this, we
    can''t access the properties of the shader. For this, we will create a C# property
    to check for a material, and create one if it doesn''t find one. Enter the following
    code just after the declaration of the variables from *step 1*:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now want to set up some checks in our script to see if the current target
    platform that we are building the Unity game on actually supports image effects.
    If it doesn''t find anything at the start of this script, then the script will
    disable itself:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To actually grab the rendered image from the Unity renderer, we need to make
    use of the following built-in function that Unity provides us, called `OnRenderImage()`.
    Enter the following code so that we can have access to the current `RenderTexture`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our screen effect has a variable called `grayScaleAmount` with which we can
    control how much grayscale we want for our final screen effect. So, in this case,
    we need to make the value go from `0` to `1`, where `0` is no grayscale effect
    and `1` is a full grayscale effect. We will perform this operation in the `Update()`
    function, which will be called every frame while the game is running:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we complete our script by doing a little bit of clean-up on objects
    we created when the script started:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, we can now apply this script to the camera, if it compiled without
    errors, in Unity. Let's apply the `TestRenderImage.cs` script to our main camera
    in our scene. You should see the `grayScaleAmount` value and a field for a shader,
    but the script throws an error to the console window. It says that it is missing
    an instance to an object and so won't process appropriately. If you recall from
    *step 4*, we are doing some checks to see whether we have a shader and if the
    current platform supports the shader. As we haven't given the screen effect script
    a shader to work with, then the `curShader` variable is just null, which throws
    an error. Let's continue with our screen effects system by completing the shader.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new shader called `ScreenGrayscale`. To begin our shader, we will
    populate our `Properties` with some variables so that we can send data to this
    shader:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our shader is now going to utilize pure CG shader code instead of utilizing
    Unity''s built-in Surface Shader code. This will make our screen effect more optimized
    as we need to work only with the pixels of the `RenderTexture.` So, we will delete
    everything inside of the `Pass` that was there before and create a new `Pass`
    block in our shader and fill it with some new `#pragma` statements that we haven''t
    seen before:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to access the data being sent to the shader from the Unity editor,
    we need to create the corresponding variables in our `CGPROGRAM`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, all we need to do is set up our pixel function, in this case called
    `frag()`. This is where the meat of the screen effect is. This function will process
    each pixel of the `RenderTexture` and return a new image to our `TestRenderImage.cs`
    script:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, change the `FallBack` line to the following:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The final shader should look as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the shader is complete, return to Unity and let it compile to see if any
    errors occurred. If not, assign the new shader to the `TestRenderImage.cs` script
    and change the value of the grayscale amount variable. You should see the game
    view go from a colored version of the game to a grayscale version of the game:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00183.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot demonstrates this Screen Effect:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: With this complete, we now have an easy way to test out new screen effect shaders
    without having to write our whole screen effect system over and over again. Let's
    dive in a little deeper and learn about what's going on with the `RenderTexture`
    and how it is processed throughout its existence.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get a screen effect up and running inside of Unity, we need to create a script
    and shader. The script drives the real-time update in the editor and is also responsible
    for capturing the `RenderTexture` from the main camera and passing it to the shader.
    Once the `RenderTexture` gets to the shader, we can use the shader to perform
    per-pixel operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the script, we perform a few checks to make sure that the current
    selected build platform actually supports screen effects and the shader itself.
    There are instances where a current platform will not support screen effects or
    the shader that we are using. So, the checks that we do in the `Start()` function
    ensure we don't get any errors if the platform doesn't support the screen system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the script passes these checks, we initiate the screen effects system
    by calling the built-in `OnRenderImage()` function. This function is responsible
    for grabbing the `renderTexture`, giving it to the shader using the `Graphics.Blit()`
    function, and returning the processed image to the Unity renderer. You can find
    more information on these two functions at the following URLs:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '`OnRenderImage`: [http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Graphics.Blit`:[http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html](http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the current `RenderTexture` reaches the shader, the shader takes it, processes
    it through the `frag()` function, and returns the final color for each pixel.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: You can see how powerful this becomes as it gives us Photoshop-like control
    over the final rendered image of our game. These screen effects work sequentially
    like Photoshop layers on top of what the camera sees. When you place these screen
    effects one after the other, they will be processed in that order. These are just
    the bare bones steps to get a screen effect working, but it is the core of how
    the screen effects system works.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our simple screen effect system up and running, let''s take
    a look at some of the other useful information we can obtain from Unity''s renderer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00185.gif)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'We can actually get the depth of everything in our current game by turning
    on Unity''s built-in Depth mode. Once this is turned on, we can use the depth
    information for a ton of different effects. Let''s take a look at how this is
    done:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Duplicate the sphere we created twice and create a plane underneath:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Create a new shader by duplicating the `ScreenGreyscale` code by selecting it
    and pressing *Ctrl *+ *D*. Once duplicated, rename the script to `SceneDepth`.
    Then double-click on this shader to open it in your script editor.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create the main texture (`_MainTex`) property and a property to control
    the power of the scene depth effect. Enter the following code in your shader:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need to create the corresponding variables in our `CGPROGRAM`. We are
    going to add one more variable called `_CameraDepthTexture`. This is a built-in
    variable that Unity has provided us with through the use of the `UnityCG.cginclude`
    file. It gives us the depth information from the camera:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will complete our depth shader by utilizing a couple of built-in functions
    that Unity provides us with, the `UNITY_SAMPLE_DEPTH()` and `linear01Depth()`
    functions. The first function actually gets the depth information from our `_CameraDepthTexture`
    and produces a single float value for each pixel. The `Linear01Depth()` function
    then makes sure that the values are within the `0`-`1` range by taking this final
    depth value to a power we can control, where the mid-value in the `0`-`1` range
    sits in the scene based off of the camera position:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With our shader complete, let's turn our attention to the Unity editor and create
    a new script to work with. Select our `TestRenderImage` script and duplicate it.
    Name this new script `RenderDepth` and open it up in your script editor.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the script to have the same class name as we renamed it to in the previous
    step (`RenderDepth`):'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to add the `depthPower` variable to the script so that we can let users
    change the value in the editor:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `OnRenderImage()` function then needs to be updated so that it is passing
    the right value to our shader:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To complete our depth screen effect, we need to tell Unity to turn on the depth
    rendering in the current camera. This is done by simply setting the main camera''s
    `depthTextureMode`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With all the code set up, save your script and shader and return to Unity to
    let them both compile. Afterward, select the Main Camera, right-click on the TextRenderImage
    component, and select Remove Component. Afterward, attach this new component to
    the object and drag and drop our new shader inside. If no errors are encountered,
    you should see a result similar to the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00187.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'Here''s an example of what we can get if we tweak the values even more:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00188.gif)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: Using brightness, saturation, and contrast with screen effects
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our screen effects system up and running, we can explore how
    to create more involved pixel operations to perform some of the more common screen
    effects found in games today.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Using a screen effect to adjust the overall final colors of your game is crucial
    in giving artists global control over the final look of the game. Techniques such
    as color adjustment sliders allow users to adjust the intensity of the reds, blues,
    and greens of the final rendered game. This concept is also used with techniques
    such as putting a certain tone of color over the whole screen, as seen in something
    like a sepia film effect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: For this particular recipe, we are going to cover some of the more core color
    adjustment operations we can perform on an image. These are brightness, saturation,
    and contrast. Learning how to code these color adjustments gives us a nice base
    from which we can learn the art of screen effects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to create a couple of new assets. We can utilize the same scene
    as our test scene, but we will need a new script and shader:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene by going to File | New Scene.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a couple of new objects to the scene, set up some different colored diffuse
    materials, and randomly assign them to the new objects in the scene. This will
    give us a good range of colors to test with our new screen effect:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00189.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have completed our scene setup and created our new script and shader,
    we can begin to fill in the code necessary to achieve the brightness, saturation,
    and contrast screen effects. We will be focusing on just the pixel operation and
    variable setup for our script and shader, since getting a screen effect system
    up and running is described in the *Setting up the screen effects script system*
    recipe in this chapter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader by duplicating the `ScreenGreyscale` code by selecting it
    from the Project tab under the `Chapter 9 `| `Shaders` folder and pressing *Ctrl*
    + *D*. Once duplicated, rename the script to `ScreenBSC`. Then double-click on
    this shader to open it in your script editor.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Editing the shader first makes more sense so that we know what kind of variables
    we will need for our C# script. Let''s begin by entering the appropriate properties
    for our brightness, saturation, and contrast effect. Remember that we need to
    keep the `_MainTex` property in our shader as this is the property that the `RenderTexture`
    targets when creating screen effects:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As usual, in order for us to access the data coming in from our properties
    in our `CGPROGRAM`, we need to create the corresponding variables in the `CGPROGRAM`,
    replacing the previous ones:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we need to create the operations that will perform the brightness, saturation,
    and contrast effects. Enter the following new function in our shader, just above
    the `frag()` function:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Don't worry if it doesn't make sense just yet; all the code will be explained
    in the *How it works* section of this recipe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we just need to update our `frag()` function to actually use the `ContrastSaturationBrightness()`
    function. This will process all the pixels of our `RenderTexture` and pass it
    back to our script:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the code entered in the shader, return to the Unity editor to let the
    new shader compile. If there are no errors, we can return to our code editor to
    work on our script. Let''s begin by creating a couple of new lines of code that
    will send the proper data to our shader:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Now that the shader is finished, let's work on the script needed to make the
    effect show up. From the Project tab, go to the `Chapter 9 `| `Scripts` folder.
    Once there, select the `TestRenderImage` script and duplicate it by pressing *Ctrl*
    + *D*. Rename the newly created script to `RenderBSC`. Once renamed, double-click
    on it to enter your IDE of choice.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To modify our script, we need to rename the class to match our filename, `RenderBSC`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Afterward, we need to add the proper variables that will drive the values of
    our screen effect. In this case, we will need a slider for brightness, a slider
    for saturation, and a slider for contrast:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With our variables set up, we now need to tell the script to send the values
    of the variables we created to the shader. We do this in the `OnRenderImage()`
    function:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好我们的变量后，我们现在需要告诉脚本将我们创建的变量的值发送到着色器。我们在`OnRenderImage()`函数中这样做：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, all we need to do is clamp the values of the variables within a range
    that is reasonable. These clamp values are entirely preferential, so you can use
    whichever values you see fit:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要将变量的值限制在合理的范围内。这些钳位值完全是主观的，所以你可以使用你认为合适的任何值：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the script completed and shader finished, we simply assign our script
    to our Main Camera and our shader to the script, and you should see the effects
    of brightness, saturation, and contrast by manipulating the property values:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本完成和着色器完成后，我们只需将我们的脚本分配给我们的主相机，将着色器分配给脚本，你应该会看到通过操作属性值实现的亮度、饱和度和对比度效果：
- en: '![](img/00190.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00190.jpeg)'
- en: 'The following screenshot shows a result you can achieve with this screen effect:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用此屏幕效果可以实现的结果：
- en: '![](img/00191.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00191.jpeg)'
- en: 'The following screenshot shows another example of what can be done by adjusting
    the colors of the render image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了通过调整渲染图像的颜色可以实现的另一个示例：
- en: '![](img/00192.gif)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00192.gif)'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since we now know how the basic screen effects system works, let's just cover
    the per-pixel operations we created in the `ContrastSaturationBrightness()` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了基本屏幕效果系统的工作原理，那么我们就来了解一下在`ContrastSaturationBrightness()`函数中创建的逐像素操作。
- en: The function starts by taking a few arguments. The first and most important
    is the current `RenderTexture`. The other arguments simply adjust the overall
    effect of the screen effect and are represented by sliders in the screen effect's Inspector
    tab. Once the function receives the `RenderTexture` and the adjustment values,
    it declares a few constant values that we use to modify and compare against the
    original `RenderTexture`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先接受几个参数。第一个也是最重要的参数是当前的`RenderTexture`。其他参数只是简单地调整屏幕效果的整体效果，并在屏幕效果的“检查器”标签页中以滑块的形式表示。一旦函数接收到`RenderTexture`和调整值，它就会声明一些常量值，我们使用这些值来修改并与原始的`RenderTexture`进行比较。
- en: The `luminanceCoeff` variable stores the values that will give us the overall
    brightness of the current image. These coefficients are based on the CIE color
    matching functions and are pretty standard throughout the industry. We can find
    the overall brightness of the image by getting the dot product of the current
    image dotted with these luminance coefficients. Once we have the brightness, we
    simply use a couple of `lerp` functions to blend the grayscale version of the
    brightness operation and the original image, multiplied by the brightness value
    being passed into the function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`luminanceCoeff`变量存储了将给我们提供当前图像整体亮度的值。这些系数基于CIE颜色匹配函数，并且在整个行业中相当标准化。我们可以通过获取当前图像与这些亮度系数的点积来找到图像的整体亮度。一旦我们有了亮度，我们只需使用几个`lerp`函数来混合亮度操作的灰度版本和原始图像，乘以传递给函数的亮度值。'
- en: Screen effects such as this are crucial to achieving high-quality graphics for
    your games as they let you tweak the final look of your game without you having
    to edit each material in your current game scene.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的屏幕效果对于实现你游戏中高质量的图形至关重要，因为它们让你可以调整游戏最终的外观，而无需编辑当前游戏场景中的每个材质。
- en: Using basic Photoshop-like Blend modes with screen effects
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本的Photoshop-like混合模式与屏幕效果
- en: The screen effects aren't just limited to adjusting the colors of a rendered
    image from our game. We can also use them to combine other images with our `RenderTexture`.
    This technique is no different than creating a new layer in Photoshop and choosing
    a Blend mode to blend two images together or, in our case, a texture with a `RenderTexture`.
    This becomes a very powerful technique as it gives the artists in a production
    environment a way to simulate their blending modes in the game rather than just
    in Photoshop.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕效果不仅限于调整我们游戏中渲染图像的颜色。我们还可以使用它们将其他图像与我们的`RenderTexture`结合。这种技术与在Photoshop中创建一个新图层并选择混合模式来混合两个图像或，在我们的情况下，一个纹理与`RenderTexture`没有区别。这成为了一种非常强大的技术，因为它为制作环境中的艺术家提供了一种在游戏中模拟他们的混合模式的方法，而不仅仅是Photoshop中。
- en: For this particular recipe, we are going to take a look at some of the more
    common blend modes, such as Multiply, Add, and Overlay. You will see how simple
    it is to have the power of Photoshop Blend modes in your game.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, we have to get our assets ready. So let''s follow the next few steps
    to get our screen effects system up and running for our new Blend mode screen
    effect:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We will need another texture to perform our Blend mode effect. In this recipe,
    we will use a grunge-type texture. This will make the effect very obvious when
    we are testing it out.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot is the grunge map used in the making of this effect.
    Finding a texture with enough detail and a nice range of grayscale values will
    make for a nice texture to test our new effect:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00193.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: The preceding texture is available in the example code for this book in `Chapter
    9 `| `Textures` folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first Blend mode that we will implement is the Multiply blend mode as seen
    in Photoshop. Let''s begin by modifying the code in our shader first:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader by duplicating the `ScreenGreyscale` code by selecting it
    from the Project tab under the `Chapter 9 `| `Shaders` folder and pressing *Ctrl *+
    *D.* Once duplicated, rename the script to `ScreenBlendMode`. Then, double-click
    on this shader to open it in your script editor.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to add some new properties so that we have a texture to blend with
    and a slider for an opacity value. Enter the following code in your new shader:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Enter the corresponding variables in our `CGPROGRAM` so that we can access
    the data from our `Properties` block, replacing the previously created variables:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We modify our `frag()` function so that it performs the multiply operation
    on our two textures:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Save the shader and return to the Unity editor to let the new shader code compile
    and check for errors. If no errors occurred, then we can move on to creating our
    script file.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the shader is finished, let's work on the script needed to make the
    effect show up. From the Project tab, go to the `Chapter 09 `| `Scripts` folder.
    Once there, select the `TestRenderImage` script and duplicate it by pressing *Ctrl*
    + *D*. Rename the newly created script to `RenderBlendMode`. Once renamed, double-click
    on it to enter your IDE of choice.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our first step in modifying our script is to rename the class to match our
    filename, `RenderBlendMode`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In our script file, we need to create the corresponding variables. We will
    need a texture so that we can assign one to the shader and a slider to adjust
    the final amount of the Blend mode we want to use:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then need to send our variable data to the shader through the `OnRenderImage()`
    function:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To complete the script, we simply fill in our `Update()` function so that we
    can clamp the value of the `blendOpacity` variable between a value of `0.0` and
    `1.0`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this complete, we assign the screen effect script to our Main Camera (remove
    the previous `Render BSC` script if it is attached) and add our screen effect
    shader to our script so that it has a shader to use for the per-pixel operations.
    In order for the effect to be fully functional, the script and shader look for
    a texture. You can assign any texture to the Texture field in the Inspector for
    the screen effect script. Once this texture is in place, you will see the effect
    of multiplying this texture over the game''s rendered screenshot:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00194.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot demonstrates the screen effect with a smaller `Blend
    Opacity` option:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00195.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: With our first blend mode set up, we can begin to add a couple of simpler blend
    modes to get a better understanding of how easy it is to add more effects and
    really fine-tune the final result in your game. However, first let's break down
    what is happening here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are starting to gain a ton of power and flexibility in our screen effects
    programming. I am sure that you are now starting to understand how much you can
    do with this simple system in Unity. We can literally replicate the effects of
    Photoshop layer blending modes in our game to give artists the flexibility they
    need to achieve high-quality graphics in a short amount of time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: With this particular recipe, we look at how to multiply two images together,
    add two images together, and perform a screen blending mode, using just a little
    bit of mathematics. When working with Blend modes, you have to think on a per-pixel
    level. For instance, when we are using the multiply blend mode, we literally take
    each pixel from the original `RenderTexture` and multiply it by each pixel of
    the Blend texture. The same goes for the add Blend mode. It is just a simple mathematical
    operation of adding each pixel from the source texture, or `RenderTexture`, to
    the Blend texture.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The screen Blend mode is definitely a bit more involved, but it is actually
    doing the same thing. It takes each image, `RenderTexture`, and Blend texture,
    inverts them, then multiplies them together, and inverts them again to achieve
    the final look. Just as Photoshop blends its textures together using blend modes,
    we can do the same with screen effects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue this recipe by adding a couple more blend modes to our screen
    effect:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'In the screen effect shader, let''s add the following code to our `frag()`
    function and change the value we are returning to our script. We will also need
    to comment out the multiply blend so that we don''t return that as well:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Save the shader file in your IDE of choice and `MonoDevelop` and return to
    the Unity editor to let the shader compile. If no errors occurred, you should
    see a result similar to the following screenshot:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00196.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'This is a simple add blending mode with a figure of `0.5` set for the `Blend
    Opacity`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00197.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: As you can see, this has the opposite effect of multiply because we are adding
    the two images together.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add one more blend mode called a screen blend. This one is
    a little bit more involved, from a mathematical standpoint, but still simple to
    implement. Enter the following code in the `frag()` function of our shader:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following screenshot demonstrates the results of using a screen type Blend
    mode to blend two images together in a screen effect:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00198.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a screenshot displaying the effect:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00199.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Using the Overlay Blend mode with screen effects
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our final recipe, we are going to take a look at another type of blend mode,
    the Overlay Blend mode. This blend mode actually makes use of some conditional
    statements that determine the final color of each pixel in each channel. So, the
    process of using this type of blend mode requires a bit more coding to work. Let's
    take a look at how this is done in the next few recipes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin our Overlay Screen effect, we will need to get the code of our shader
    up and running without errors. We can then modify our script file to feed the
    correct data to the shader:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader by duplicating the `ScreenGreyscale` code and selecting
    it from the Project tab under the `Chapter 9 `| `Shaders` folder and pressing
    *Ctrl* + *D*. Once duplicated, rename the script to `ScreenOverlay`. Then, double-click
    on this shader to open it in your script editor.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We first need to set up the properties in our `Properties` block. We will use
    the same properties from the previous few recipes in this chapter:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then need to create the corresponding variables in our `CGPROGRAM`, removing
    the previously created ones:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order for the Overlay Blend effect to work, we will have to process each
    pixel from each channel individually. To do this in a shader, we have to write
    a custom function that will take in a single channel, for instance, the red channel,
    and perform the overlay operation. Enter the following code in the shader just
    below the variable declarations:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We need to update our `frag()` function to process each channel of our textures
    in order to perform the blending:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the code completed in the shader, our effect should be working. Save the
    shader and return to the Unity editor to let the shader compile. Our script is
    already set up; select the Main Camera object. From the Project tab, drag and
    drop the ScreenOverlay shader onto the `Cur Shader` property from the Render Blend
    Mode component in the Inspector tab. Once the shader compiles, you should see
    a result similar to the following screenshot:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00200.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a screenshot using a Blend Opacity of `0.5`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00201.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our overlay blend mode is definitely a lot more involved, but if you really
    break down the function, you will notice that it is simply a multiply blend mode
    and screen blend mode. In this case, we are doing a conditional check to apply
    one or the other blend mode to a pixel.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的叠加混合模式确实更为复杂，但如果你真正分解其功能，你会发现它实际上只是一个乘法混合模式和屏幕混合模式。在这种情况下，我们进行条件检查，以将一个或另一个混合模式应用于像素。
- en: With this particular screen effect, when the overlay function receives a pixel,
    it checks to see whether it is less than `0.5`. If it is, then we apply a modified
    multiply blend mode to that pixel; if it's not, then we apply a modified screen
    blend mode to the pixel. We do this for each pixel for each channel, giving us
    the final RGB pixel values for our screen effect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的屏幕效果中，当叠加功能接收到一个像素时，它会检查该像素是否小于`0.5`。如果是，则对该像素应用修改后的乘法混合模式；如果不是，则对该像素应用修改后的屏幕混合模式。我们对每个通道的每个像素都这样做，从而得到屏幕效果的最终RGB像素值。
- en: As you can see, there are many things that can be done with screen effects.
    It really just depends on the platform and amount of memory you have allocated
    for screen effects. Usually, this is determined throughout the course of a game
    project, so have fun and get creative with your screen effects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可以使用屏幕效果做很多事情。这实际上完全取决于平台和分配给屏幕效果的内存量。通常，这会在游戏项目的整个过程中确定，所以尽情享受并发挥创意，制作出有趣的屏幕效果。
