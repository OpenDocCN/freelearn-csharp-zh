- en: Understanding Lighting Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解光照模型
- en: In the previous chapters, we introduced Surface Shaders and explained how we
    can change physical properties (such as Albedo and Specular) to simulate different
    materials. How does this really work? At the heart of every Surface Shader, there
    is its **lighting model**. It's the function that takes these properties and calculates
    the final shade of each pixel. Unity usually hides this from the developers because
    in order to write a lighting model, you have to understand how light reflects
    and refracts onto surfaces. This chapter will finally show you how lighting models
    work and give you the basics to create your own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了表面着色器，并解释了如何通过改变物理属性（如漫反射和镜面反射）来模拟不同的材料。这究竟是如何实现的？每个表面着色器的核心是其**光照模型**。这是一个函数，它接受这些属性并计算每个像素的最终颜色。Unity通常将这一点隐藏起来，因为要编写光照模型，你必须了解光线如何反射和折射到表面上。本章将最终向你展示光照模型是如何工作的，并为你提供创建自己光照模型的基础。
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下配方：
- en: Creating a custom diffuse lighting model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义的漫反射光照模型
- en: Creating a toon shader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建卡通着色器
- en: Creating a Phong Specular type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Phong镜面类型
- en: Creating a BlinnPhong Specular type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建BlinnPhong镜面类型
- en: Creating an Anisotropic Specular type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建各向异性镜面类型
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Simulating the way light works is a very challenging and resource-consuming
    task. For many years, video games have used very simple lighting models which,
    despite lacking realism, were very believable. Even if most 3D engines are now
    using physically-based renderers, it is worth exploring some simpler techniques.
    The ones presented in this chapter are reasonably realistic and widely adopted
    on devices with low resources such as mobile phones. Understanding these simple
    lighting models is also essential if you want to create your own.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟光线的工作方式是一项非常具有挑战性和资源消耗的任务。多年来，视频游戏一直使用非常简单的光照模型，尽管缺乏真实感，但它们非常可信。即使现在大多数3D引擎都使用基于物理的渲染器，探索一些更简单的技术也是值得的。本章中介绍的技术在资源有限的设备上（如手机）得到了广泛应用，并且理解这些简单的光照模型对于你想要创建自己的光照模型也是至关重要的。
- en: Creating a custom diffuse lighting model
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义的漫反射光照模型
- en: 'If you are familiar with Unity 4, you may know that the default shader it provided
    was based on a lighting model called **Lambertian reflectance**. This recipe will
    show you how it is possible to create a shader with a custom lighting model and
    explains the mathematicsinvolved and implementation. The following diagram shows
    the same geometry rendered with a Standard Shader (right) and a diffuse Lambert
    one (left):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Unity 4，你可能知道它提供的默认着色器是基于一个称为**朗伯反射**的光照模型。这个配方将向你展示如何创建具有自定义光照模型的着色器，并解释相关的数学和实现。以下图表显示了使用标准着色器（右侧）和漫反射朗伯着色器（左侧）渲染的相同几何体：
- en: '![](img/00078.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: Shaders based on Lambertian reflectance are classified as non-photorealistic;
    no object in the real world really looks like this. However, Lambert Shaders are
    still often used in low-poly games as they produce a neat contrast between the
    faces of complex geometries. The lighting model used to calculate the Lambertian
    reflectance is also very efficient, making it perfect for mobile games.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基于朗伯反射的着色器被归类为非真实感着色器；在现实世界中，没有任何物体真的看起来像这样。然而，朗伯着色器仍然经常在低多边形游戏中使用，因为它们能够在复杂几何体的表面之间产生清晰的对比。用于计算朗伯反射的光照模型也非常高效，使其非常适合移动游戏。
- en: Unity has already provided us with a lighting function that we can use for our
    shaders. It is called the Lambertian lighting model. It is one of the more basic
    and efficient forms of reflectance, which you can find in a lot of games even
    today. As it is already built in the Unity Surface Shader language, we thought
    it best to start with this first and build on it. You can also find an example
    in the Unity reference manual, but we will go into more depth and explain where
    the data is coming from and why it is working the way it is. This will help you
    get a nice grounding in setting up custom lighting models so that we can build
    on this knowledge in the future recipes in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Unity已经为我们提供了一个可以用于着色器的光照函数。它被称为朗伯光照模型。这是更基本和高效的反射形式之一，你甚至可以在今天很多游戏中找到它。因为它已经内置在Unity表面着色器语言中，我们认为最好从它开始，并在此基础上构建。你还可以在Unity参考手册中找到一个示例，但我们将更深入地探讨数据来源以及为什么它以这种方式工作。这将帮助你建立良好的基础，以便我们可以在本章后面的配方中构建这一知识。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start by carrying out the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先执行以下步骤：
- en: Create a new shader and give it a name (`SimpleLambert`).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的着色器并给它命名（`SimpleLambert`）。
- en: Create a new material, give it a name (`SimpleLambertMat`), and assign the new
    shader to its `shader` property.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质，给它命名（`SimpleLambertMat`），并将新着色器分配给其 `shader` 属性。
- en: Then, create a sphere object and place it roughly in the center of the scene
    and attach the new material to it.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个球体对象，并将其大致放置在场景的中心，并将新材质附加到它上面。
- en: Finally, let's create a directional light to cast some light on our object if
    one isn't created already.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个方向光，如果还没有创建的话，以便照亮我们的物体。
- en: 'When your assets have been set up in Unity, you should have a scene that resembles
    the following screenshot:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在 Unity 中设置好资产后，你应该有一个类似于以下截图的场景：
- en: '![](img/00079.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The Lambertian reflectance can be achieved with the following changes to the
    shader:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对着色器进行以下更改可以实现朗伯反射：
- en: 'Begin by replacing the shader''s `Properties` block with the following :'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先替换着色器的 `Properties` 块，如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since we are removing all of the other properties, remove the `_Glossiness`,
    `_Metallic`, and `_Color` declarations inside of the `SubShader` section.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在移除所有其他属性，请从 `SubShader` 部分中移除 `_Glossiness`、`_Metallic` 和 `_Color` 声明。
- en: 'Change the `#pragma` directive of the shader so that, instead of `Standard`,
    it uses our custom lighting model:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改着色器的 `#pragma` 指令，使其不再使用 `Standard`，而是使用我们自定义的光照模型：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you try to run the script now, it will complain that it doesn't know what
    the `SimpleLambert` lighting model is. We will need to create a function called
    `Lighting`  + the name that we gave here with instructions on how to light the
    object, which we will be writing later on in this recipe. In this case, it would
    be `LightingSimpleLambert`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试运行脚本，它将抱怨它不知道 `SimpleLambert` 光照模型是什么。我们需要创建一个名为 `Lighting` + 我们在这里给出的名称的函数，其中包含如何照亮物体的说明，我们将在本食谱的后面部分编写。在这种情况下，它将是
    `LightingSimpleLambert`。
- en: 'Use a very simple surface function, which just samples the texture according
    to its UV data:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个非常简单的表面函数，它只是根据其 UV 数据采样纹理：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a function called `LightingSimpleLambert()` that will contain the following
    code for the Lambertian reflectance:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `LightingSimpleLambert()` 的函数，该函数将包含以下代码以实现朗伯反射：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save your script and return to the Unity editor. You should notice that it
    looks somewhat different than what was there before:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回到 Unity 编辑器。你应该注意到它看起来与之前有些不同：
- en: '![](img/00080.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: 'The effect is even easier to see if we use the cylinders we used in the previous
    chapter, [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08), *Surface
    Shaders and Texture Mapping*:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用上一章[第3章](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08)，“表面着色器和纹理映射”中使用的圆柱体，效果甚至更容易看到：
- en: '![](img/00081.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As previously seen in [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08),
    *Creating Your First Shader*, the `#pragma` directive is used to specify which
    surface function to use. Choosing a different lighting model works in a similar
    fashion: `SimpleLambert` forces Cg to look for a function called `LightingSimpleLambert()`.
    Note the `Lighting` at the beginning, which is omitted in the directive.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在[第2章](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08)，“创建您的第一个着色器”中，`#pragma`
    指令用于指定要使用哪个表面函数。选择不同的光照模型以类似的方式工作：`SimpleLambert` 强制 Cg 寻找名为 `LightingSimpleLambert()`
    的函数。注意开头的 `Lighting`，在指令中省略了它。
- en: 'The `Lighting` function takes three parameters: the *surface output* (which
    contains the physical properties such as the albedo and transparency), the *direction*
    the light is coming from, and its *attenuation*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lighting` 函数接受三个参数：*表面输出*（其中包含物理属性，如反射率和透明度）、光线来的*方向*以及其*衰减*。'
- en: 'According to Lambertian reflectance, the amount of light a surface reflects
    depends on the angle between the incident light and surface normal. If you have
    played pool billiards, you are surely familiar with this concept; the direction
    of a ball depends on its incident angle against the wall. If you hit a wall at
    a 90 degree angle, the ball will come back at you; if you hit it with a very low
    angle, its direction will be mostly unchanged. The Lambertian model makes the
    same assumption; if the light hits a triangle at a 90 degree angle, all the light
    gets reflected back. The lower the angle, the less light is reflected back to
    you. This concept is shown in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据朗伯反射定律，一个表面反射的光量取决于入射光与表面法线之间的角度。如果你玩过台球，你一定熟悉这个概念；球的方向取决于其与墙壁的入射角度。如果你以90度角击打墙壁，球会反弹回来；如果你以非常低的角度击打它，其方向基本不会改变。朗伯模型做出了相同的假设；如果光线以90度角击中三角形，所有光线都会被反射回去。角度越低，反射回你的光线就越少。这一概念在以下图中展示：
- en: '![](img/00082.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00082.jpeg)'
- en: This simple concept has to be translated into a mathematical form. In vector
    algebra, the angle between two unit vectors can be calculated via an operator
    called **dot product**. When the dot product is equal to zero, two vectors are
    orthogonal, which means that they make a 90-degree angle. When it is equal to
    one (or minus one), they are parallel to each other. Cg has a function called
    `dot()`, which implements the dot product extremely efficiently.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单概念必须被转换成数学形式。在向量代数中，两个单位向量之间的角度可以通过一个称为**点积**的运算符来计算。当点积等于零时，两个向量是正交的，这意味着它们形成一个90度的角。当它等于一（或负一）时，它们是相互平行的。Cg有一个名为`dot()`的函数，它实现了点积的高效计算。
- en: 'The following diagram shows a light source (sun) shining on a complex surface.
    **L** indicates the light direction (called `lightDir` in the shader) and **N**
    is the normal to the surface. The light is reflected with the same angle that
    it hits the surface with:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了一个光源（太阳）照射在复杂表面上的情况。**L**表示光线方向（在着色器中称为`lightDir`）和**N**是表面的法线。光线以与击中表面的相同角度被反射：
- en: '![](img/00083.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00083.jpeg)'
- en: For more information on normals and what they mean mathematically check out: [https://en.wikipedia.org/wiki/Normal_(geometry)](https://en.wikipedia.org/wiki/Normal_(geometry))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于法线和它们在数学上的含义的信息，请查看：[https://en.wikipedia.org/wiki/Normal_(geometry)](https://en.wikipedia.org/wiki/Normal_(geometry))
- en: 'Lambertian reflectance simply uses the `NdotL` dot product as a multiplicative
    coefficient for the intensity of light:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 朗伯反射定律简单地将`NdotL`点积作为光强度的乘法系数：
- en: '![](img/00084.gif)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00084.gif)'
- en: When *N* and *L* are parallel, all the light is reflected back to the source,
    causing the geometry to appear brighter. The `_LightColor0` variable contains
    the color of the light that is calculated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当**N**和**L**平行时，所有光线都会反射回光源，导致几何体看起来更亮。`_LightColor0`变量包含计算出的光线颜色。
- en: Prior to Unity 5, the intensity of the lights was different. If you are using
    an old diffuse shader based on the Lambertian model, you may notice that `NdotL` is
    multiplied by two: `(NdotL * atten * 2)`, rather than `(NdotL * atten)`. If you
    are importing a custom shader from Unity 4, you will need to correct this manually.
    Legacy Shaders, however, have already been designed taking this aspect into account.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity 5之前，光线的强度是不同的。如果你使用基于朗伯模型的旧漫反射着色器，你可能注意到`NdotL`被乘以了两个：`(NdotL * atten
    * 2)`，而不是`(NdotL * atten)`。如果你从Unity 4导入自定义着色器，你需要手动进行修正。然而，遗留的着色器已经考虑到这一方面。
- en: When the dot product is negative, the light is coming from the opposite side
    of the triangle. This is not a problem for opaque geometries as triangles that
    are not facing the camera frontally are culled (discarded) and not rendered.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当点积为负时，光线来自三角形的对面。对于不透明几何体来说这不是问题，因为不是正对相机的前面的三角形会被裁剪（丢弃）并且不会被渲染。
- en: This basic Lambert is a great starting point when you are prototyping your shaders
    as you can get a lot accomplished in terms of writing the core functionality of
    the shader while not having to worry about the basic `Lighting` functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在原型化你的着色器时，这个基本朗伯模型是一个很好的起点，因为你可以在不担心基本`Lighting`函数的情况下，完成很多关于编写着色器核心功能的工作。
- en: Unity has provided us with a lighting model that has already taken the task
    of creating a Lambert lighting for you. If you look at the `UnityCG.cginc` file
    found in your Unity's installation directory under the `Data` folder, you will
    notice that you have Lambert and BlinnPhong lighting models available for you
    to use. The moment you compile your shader with `#pragma surface surf Lambert`,
    you are telling the shader to utilize Unity's implementation of the Lambert `Lighting`
    function in the `UnityCG.cginc` file so that you don't have to write that code
    over and over again. We will explore how the BlinnPhong model works later in this
    chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Unity已经为我们提供了一个光照模型，该模型已经为您完成了创建Lambert光照的任务。如果您查看位于Unity安装目录下`Data`文件夹中的`UnityCG.cginc`文件，您会注意到您有Lambert和BlinnPhong光照模型可供使用。当您使用`#pragma
    surface surf Lambert`编译着色器时，您正在告诉着色器使用Unity在`UnityCG.cginc`文件中实现的Lambert `Lighting`函数，这样您就无需反复编写该代码。我们将在本章后面探讨BlinnPhong模型的工作原理。
- en: Creating a toon shader
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建卡通着色器
- en: 'One of the most used effects in games is **toon shading**, which is also known
    as **celluloid** (**CEL**) shading. It is a non-photorealistic rendering technique
    that makes 3D models appear flat. Many games use it to give the illusion that
    the graphics are being hand-drawn rather than being 3D modeled. You can see, in
    the following diagram, a sphere rendered with a toon Shader (left) and a Standard
    Shader (right):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中使用最频繁的效果之一是**卡通着色**，也称为**赛璐珞**（**CEL**）着色。这是一种非真实感渲染技术，可以使3D模型看起来很平。许多游戏使用它来营造图形是手工绘制的错觉，而不是3D建模。您可以在以下图中看到使用卡通着色器（左）和标准着色器（右）渲染的球体：
- en: '![](img/00085.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: Achieving this effect using just surface functions is not impossible, but it
    would be extremely expensive and time consuming. The surface function, in fact,
    only works on the properties of the material, not its actual lighting condition.
    As toon shading requires us to change the way light reflects, we need to create
    our custom lighting model instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用表面函数来实现此效果并非不可能，但这将非常昂贵且耗时。实际上，表面函数仅在材质的属性上工作，而不是其实际的照明条件。由于卡通着色需要我们改变光线反射的方式，因此我们需要创建自己的自定义光照模型。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start this recipe by creating a shader and its material and importing
    a special texture, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个着色器及其材质并导入一个特殊纹理开始这个配方，如下所示：
- en: Start by creating a new shader; in this example, we will duplicate the one made
    in the previous recipe by selecting it in the Project tab and then hit *Ctrl *+ *D*.
    We will change the name of this new `shader` to `ToonShader`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的着色器；在这个例子中，我们将通过在项目选项卡中选择它并按*Ctrl *+ *D*来复制上一个配方中创建的着色器。我们将把这个新`着色器`的名字改为`ToonShader`。
- en: You can rename an object in the Project window by single-clicking on the name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在项目窗口中单击名称来重命名一个对象。
- en: Create a new material for the shader (`ToonShaderMat`) and attach it to a 3D
    model. Toon shading works best on curved surfaces.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为着色器（`ToonShaderMat`）创建一个新的材质，并将其附加到一个3D模型上。卡通着色在曲面上的效果最佳。
- en: 'This recipe requires an additional texture called a **ramp map**,which will
    be used to dictate when we want to use certain colors depending on the shade received:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此配方需要一个额外的纹理，称为**渐变图**，它将用于根据接收到的阴影来决定我们想要使用某些颜色的时间：
- en: '![](img/00086.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: 'This book has an example texture in `Chapter 4` | `Textures` folder. If you
    decide to import your own, it is important that you select your next texture and,
    from the Inspector tab, change the ramp map''s Wrap Mode to Clamp. If you want
    the edges between the colors to be sharp, the Filter Mode should also be set to
    Point:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书在`第4章` | `纹理`文件夹中提供了一个示例纹理。如果您决定导入自己的纹理，重要的是您要选择您的下一个纹理，并在检查器选项卡中，将渐变图的Wrap模式更改为Clamp。如果您想要颜色之间的边缘清晰，过滤器模式也应设置为Point：
- en: '![](img/00087.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: The example project included with this book already has this step completed
    in the `Assets `| `Chapter 4 `| `Texture `| `ToonRamp` file, but it is a good
    idea to verify that this is the case before moving forward.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带的项目示例已经完成了这一步，在`Assets `| `第4章 `| `纹理`| `ToonRamp`文件中，但在继续之前验证这一点是个好主意。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The toon aesthetic can be achieved with the following changes to the shader:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对着色器进行以下更改，可以实现卡通美学：
- en: 'Add a new property for a texture called `_RampTex`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一个名为`_RampTex`的纹理添加一个新属性：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add its relative variable in the `CGPROGRAM` section:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CGPROGRAM`部分添加其相关变量：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Change the `#pragma` directive so that it points to a function called `LightingToon()`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`#pragma`指令，使其指向名为`LightingToon()`的函数：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace the `LightingSimpleLambert` function with the following function instead:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LightingSimpleLambert`函数替换为以下函数：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save the script, open up the `ToonShaderMat`, and assign the `Ramp` property
    to your ramp map. If all goes well, you should see something like the following
    in your scene:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，打开`ToonShaderMat`，并将`Ramp`属性分配给你的渐变图。如果一切顺利，你应该能在场景中看到以下效果：
- en: '![](img/00088.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: This effect may be modified by the lighting in the scene. You can change the
    illumination of the scene by going to Window | Lighting | Settings and changing
    the Environment | Environment Lighting | Intensity Multiplier property to `0`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果可能会受到场景中光照的影响。你可以通过转到窗口 | 光照 | 设置，并更改环境 | 环境光照 | 强度乘数属性为`0`来改变场景的照明。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main characteristic of toon shading is the way the light is rendered; surfaces
    are not shaded uniformly. To achieve this effect, we need a ramp map. Its purpose
    is to remap the Lambertian light intensity `NdotL` to another value. Using a ramp
    map without a gradient, we can force the lighting to be rendered in steps. The
    following diagram shows how the ramp map is used to correct the light intensity:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 卡通着色的主要特征是光照的渲染方式；表面不是均匀着色。为了实现这种效果，我们需要一个渐变图。它的目的是将Lambertian光照强度`NdotL`重新映射到另一个值。使用没有渐变的渐变图，我们可以强制光照以步骤的形式渲染。以下图表显示了如何使用渐变图来校正光照强度：
- en: '![](img/00089.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: There's more...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many different ways whereby you can achieve a toon shading effect.
    Using different ramps can produce dramatic changes in the way your models look,
    so you should experiment in order to find the best one.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法可以实现卡通着色效果。使用不同的渐变图可以显著改变模型的外观，因此你应该进行实验以找到最佳方案。
- en: 'An alternative to ramp textures is to **snap** the light intensity `NdotL`
    so that it can only assume a certain number of values equidistantly sampled from
    `0` to `1`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与渐变纹理的替代方案是**固定**光照强度`NdotL`，使其只能假设从`0`到`1`等距采样的特定数值：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To snap a number we first multiply `NdotL` by the `_CelShadingLevels` variable, 
    round the result to an integer through the `floor` function, and then divides
    it back. This rounding is done by the `floor` function which will effectively
    remove the decimal point from a number. By doing this, the `cel` quantity is forced
    to assume one of the `_CelShadingLevels` equidistant values from `0` to `1`. This
    removes the need for a ramp texture and makes all the color steps of the same
    size. If you are going for this implementation, remember to add a property called
    `_CelShadingLevels` to your shader. You can find an example of this in the example
    code for this chapter. Try dragging the Levels property to see how it affects
    how the screenshot is shown:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数字固定，我们首先将`NdotL`乘以`_CelShadingLevels`变量，通过`floor`函数将结果四舍五入到整数，然后再除以它。这种舍入是通过`floor`函数完成的，它将有效地从数字中去除小数点。通过这样做，`cel`数量被迫采用从`0`到`1`的`_CelShadingLevels`等距值之一。这消除了对渐变纹理的需求，并使所有颜色步骤的大小相同。如果你正在寻求这种实现方式，请记住在你的着色器中添加一个名为`_CelShadingLevels`的属性。你可以在本章的示例代码中找到一个例子。尝试拖动级别属性，看看它如何影响截图的显示：
- en: '![](img/00090.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: Creating a Phong Specular type
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Phong高光类型
- en: The specularity of an object surface simply describes how shiny it is. These
    types of effects are often referred to as view-dependent effects in the shader
    world. This is because, in order to achieve a realistic Specular effect in your
    shaders, you need to include the direction of the camera or the user facing the
    object's surface. The most basic and performance-friendly Specular type is the
    Phong Specular effect. It is the calculation of the light direction reflecting
    off of the surface compared to the user's view direction. It is a very common
    Specular model used in many applications, from games to movies. While it isn't
    the most realistic in terms of accurately modeling the reflected Specular, it
    gives a great approximation of what is expected of shininess that performs well
    in most situations. Additionally, if your object is further away from the camera
    and there is no need for a very accurate Specular, this is a great way to provide
    a Specular effect to your shaders.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 物体表面的光泽度简单描述了它有多亮。这类效果在着色器世界中通常被称为视依赖效果。这是因为，为了在着色器中实现逼真的镜面反射效果，你需要包含相机或用户面对物体表面的方向。最基本的、性能友好的镜面反射类型是Phong镜面反射效果。它是计算光线从表面反射回来的方向与用户的视图方向相比的结果。它是在许多应用中非常常见的镜面反射模型，从游戏到电影。虽然它不是在准确模拟反射镜面方面最逼真的，但它提供了对预期光泽度的良好近似，在大多数情况下表现良好。此外，如果你的物体离相机更远，并且不需要非常精确的镜面反射，这是一种为着色器提供镜面反射效果的好方法。
- en: In this recipe, we will be covering how to implement the per-vertex version
    of the shader and also the per-pixel version using some new parameters in the
    Surface Shader's `Input` struct. We will see the difference and discuss when and
    why to use these two different implementations for different situations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将介绍如何实现着色器的逐顶点版本以及使用表面着色器`Input`结构中的新参数实现的逐像素版本。我们将看到这两种不同实现之间的差异，并讨论在不同情况下何时以及为什么使用这些不同的实现。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To start with this recipe, perform the following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个食谱，请执行以下步骤：
- en: Create a new shader (`Phong`), material(`PhongMat`), and a new scene with a
    sphere in it with a Plane underneath it (GameObject | 3D Objects | Plane).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的着色器（`Phong`）、材质（`PhongMat`），以及一个包含球体和其下方的平面（GameObject | 3D Objects |
    Plane）的新场景。
- en: 'Attach the shader to the material and the material to the object. To finish
    off your new scene, create a new directional light if one is not there already,
    so that you can see your Specular effect as you code it:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将着色器附加到材质上，并将材质附加到物体上。为了完成你的新场景，如果还没有，创建一个新的方向光，这样你就可以在编写代码时看到你的镜面反射效果：
- en: '![](img/00091.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a Phong lighting model:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建Phong光照模型：
- en: 'You might be seeing a pattern at this point, but we always like to start out
    with our most basic part of the shader writing process: the creation of properties.
    So, let''s remove all of the current properties with their definitions in the
    `SubShader` block and then add the following properties to the shader:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经看到了一个模式，但我们总是喜欢从着色器编写过程的最基本部分开始：属性的创建。因此，让我们从`SubShader`块中移除所有当前属性及其定义，然后添加以下属性到着色器中：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then have to make sure to add the corresponding variables to our `CGPROGRAM`
    block in our `SubShader{}` block:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保将相应的变量添加到我们的`SubShader{}`块中的`CGPROGRAM`块中：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have to add our custom lighting model so that we can compute our own
    Phong Specular. Don''t worry if it doesn''t make sense at this point; we will
    cover each line of code in the *How it works...* section of this recipe. Add the
    following code to the shader''s `SubShader{}` function:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须添加我们的自定义光照模型，以便我们可以计算自己的Phong镜面反射。如果现在还不理解，请不要担心；我们将在本食谱的*如何工作...*部分中逐行解释代码。将以下代码添加到着色器的`SubShader{}`函数中：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we have to tell the `CGPROGRAM` block that it needs to use our custom
    Lighting function instead of one of the built-in ones. We do this by changing
    the `#pragma` statement to the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须告诉`CGPROGRAM`块它需要使用我们的自定义光照函数而不是内置函数之一。我们通过将`#pragma`语句更改为以下内容来实现这一点：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, let''s update the `surf` function to the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们更新`surf`函数为以下内容：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot demonstrates the result of our custom Phong lighting
    model using our own custom reflection vector:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图展示了我们使用自定义反射向量的自定义Phong光照模型的结果：
- en: '![](img/00092.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.jpeg)'
- en: Try changing the Specular Power property and notice the effect that you see.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改光滑功率属性并注意你看到的效果。
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's break down the Lighting function by itself, as the rest of the shader
    should be pretty familiar to you at this point.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们单独分解照明函数，因为到目前为止，其余的着色器应该对你来说相当熟悉。
- en: In the previous recipes, we have used a Lighting function that provided only
    the light direction, `lightDir`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们使用了一个只提供光方向的照明函数，`lightDir`。
- en: Unity comes with a set of Lighting functions that you can use, including one
    that provides the view direction, `viewDir`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了一套你可以使用的照明函数，包括一个提供视方向的函数，`viewDir`。
- en: 'To figure out how to write your own custom lighting mode refer to the following
    table replacing NameYouChoose with the lighting function name you gave in the
    `#pragma` statement or go to [http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html](http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html) for
    more details:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何编写自己的自定义照明模式，请参考以下表格，将 NameYouChoose 替换为你在 `#pragma` 语句中给出的照明函数名称，或访问 [http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html](http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html)
    获取更多详细信息：
- en: '| **Not view-dependent** | `` `half4 LightingNameYouChoose` (`SurfaceOutput
    s`, `half3` `lightDir`, `half atten` ``); |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **非视依赖** | `` `half4 LightingNameYouChoose` (`SurfaceOutput s`, `half3` `lightDir`,
    `half atten` ``); |'
- en: '| **View-dependent** | `half4 LightingNameYouChoose (SurfaceOutput s, half3
    lightDir, half3 viewDir, half atten);` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **视依赖** | `half4 LightingNameYouChoose (SurfaceOutput s, half3 lightDir,
    half3 viewDir, half atten);` |'
- en: 'In our case, we are using a Specular shader, so we need to have the view-dependent
    `Lighting` function structure. We have to write the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用的是光滑着色器，因此我们需要有视依赖的 `Lighting` 函数结构。我们必须编写以下内容：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will tell the shader that we want to create our own view-dependent shader.
    Always make sure that your Lighting function name is the same in your `Lighting`
    function declaration and the `#pragma` statement, or Unity will not be able to
    find your lighting model.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉着色器我们想要创建自己的视依赖着色器。始终确保你的照明函数名称在 `Lighting` 函数声明和 `#pragma` 语句中相同，否则 Unity
    将无法找到你的照明模型。
- en: 'The components that play a role in the `Phong` model are described in the following
    image. We have the light direction **L** (coupled with its perfect reflection
    **R**) and normal direction **N**. They have all been encountered before in the
    Lambertian model, with the exception of **V**, which is the **view direction**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中描述了在 `Phong` 模型中起作用的分量。我们有线方向 **L**（与其完美的反射 **R** 相关联）和法线方向 **N**。它们在之前遇到的
    Lambertian 模型中都已经出现过，除了 **V**，它是**视方向**：
- en: '![](img/00093.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00093.jpeg)'
- en: 'The `Phong` model assumes that the final light intensity of a reflective surface
    is given by two components, its diffuse color, and Specular value, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phong` 模型假设反射表面的最终光强度由两个分量给出，其漫反射颜色和光滑值，如下所示：'
- en: '![](img/00094.gif)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.gif)'
- en: 'The diffuse component *D* remains unchanged from the Lambertian model:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射分量 *D* 从 Lambertian 模型保持不变：
- en: '![](img/00095.gif)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.gif)'
- en: 'The Specular component *S* is defined as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 光滑分量 *S* 定义如下：
- en: '![](img/00096.gif)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.gif)'
- en: 'Here, *p* is the Specular power defined as `_SpecPower` in the shader. The
    only unknown parameter is *R*, which is the reflection of *L* according to *N*.
    In vector algebra, this can be calculated as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*p* 是在着色器中定义为 `_SpecPower` 的光滑功率。唯一未知的参数是 *R*，它是根据 *N* 对 *L* 的反射。在向量代数中，这可以计算如下：
- en: '![](img/00097.gif)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.gif)'
- en: 'This is exactly what is calculated in the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是以下计算的内容：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This has the effect of bending the normal towards the light; as a vertex, normal
    is pointing away from the light, it is forced to look at the light. Refer to the
    following diagram for a more visual representation. The script that produces this
    debug effect is included in this book''s support page at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这会使法线向光源弯曲；作为一个顶点，法线是指向远离光源的，它被迫看向光源。请参考以下图表以获得更直观的表示。产生此调试效果的脚本包含在此书的支持页面上，[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)：
- en: '![](img/00098.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: 'The following diagram displays the final result of our Phong Specular calculation
    isolated in the shader:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们在着色器中进行的最终 Phong 光滑计算的最终结果：
- en: '![](img/00099.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.jpeg)'
- en: Creating a BlinnPhong Specular type
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 BlinnPhong 镜面类型
- en: '**Blinn** is another more efficient way of calculating and estimating specularity.
    It is done by getting the half vector from the view direction and light direction.
    It was brought into the world of Cg by Jim Blinn. He found that it was much more
    efficient to just get the half vector instead of calculating our own reflection
    vectors. It cut down on the code and processing time. If you actually look at
    the built-in BlinnPhong lighting model included in the `UnityCG.cginc` file, you
    will notice that it is using the half vector as well, hence it is named BlinnPhong.
    It is just a simpler version of the full Phong calculation.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blinn** 是另一种更高效的计算和估计镜面反射的方法。它是通过获取视图方向和光方向的半向量来实现的。这种方法是由 Jim Blinn 引入到
    Cg 领域的。他发现，直接获取半向量比计算我们自己的反射向量要高效得多。这减少了代码和处理的耗时。如果你实际查看 `UnityCG.cginc` 文件中包含的内置
    BlinnPhong 照明模型，你会发现它也在使用半向量，因此得名 BlinnPhong。它只是完整 Phong 计算的一个简化版本。'
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To start with this recipe, perform the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个配方，请执行以下步骤：
- en: 'This time, instead of creating a whole new scene, let''s just use the objects
    and scene that we have by using File | Save Scene As..., and create a new shader
    (BlinnPhong) and material (`BlinnPhongMat`):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们不是创建一个全新的场景，而是通过使用文件 | 保存场景为...，并创建一个新的着色器（BlinnPhong）和材质（`BlinnPhongMat`）来使用我们已有的对象和场景：
- en: '![](img/00100.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: Once you have a new shader, double-click on it to launch your IDE of choice
    so that you can start editing your shader.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有了一个新的着色器，双击它以启动你选择的 IDE，这样你就可以开始编辑你的着色器了。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps to create a BlinnPhong lighting model:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建 BlinnPhong 照明模型：
- en: 'First, let''s remove all of the current properties with their definitions in
    the `SubShader` block. Then we need to add our own properties to the `Properties`
    block so that we can control the look of the Specular highlight:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在 `SubShader` 块中删除所有当前属性及其定义。然后我们需要在 `Properties` 块中添加我们自己的属性，以便我们可以控制镜面高光的视觉效果：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we need to make sure that we have created the corresponding variables
    in our `CGPROGRAM` block so that we can access the data from our `Properties`
    block, in our subshader:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要确保我们在 `CGPROGRAM` 块中创建了相应的变量，以便我们可以从我们的 `Properties` 块中访问数据，在我们的子着色器中：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now it''s time to create our custom lighting model that will process our Diffuse
    and Specular calculations. The code is as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候创建我们自定义的照明模型，该模型将处理我们的漫反射和镜面计算。代码如下：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then update the `surf` function to the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后更新 `surf` 函数为以下内容：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To complete our shader, we will need to tell our CGPROGRAM block to use our
    custom lighting model rather than a built-in one by modifying the `#pragma` statement
    with the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的着色器，我们需要告诉我们的 CGPROGRAM 块使用我们自定义的照明模型而不是内置的一个，通过修改 `#pragma` 语句并使用以下代码：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following screenshot demonstrates the results of our BlinnPhong lighting
    model:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图展示了我们的 BlinnPhong 照明模型的结果：
- en: '![](img/00101.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The BlinnPhong Specular is almost exactly like the Phong Specular, except that
    it is more efficient because it uses less code to achieve almost the same effect.
    Before the introduction of physically-based rendering, this approach was the default
    choice for Specular reflection in Unity 4.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: BlinnPhong 镜面几乎与 Phong 镜面完全相同，只是它更高效，因为它使用更少的代码就能达到几乎相同的效果。在基于物理的渲染引入之前，这种方法是
    Unity 4 中镜面反射的默认选择。
- en: 'Calculating the reflection vector **R** is generally expensive. The BlinnPhong
    Specular replaces it with the half vector **H** between the view direction **V**
    and light direction **L**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 计算反射向量 **R** 通常很昂贵。BlinnPhong 镜面将其替换为视图方向 **V** 和光方向 **L** 之间的半向量 **H**：
- en: '![](img/00102.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: 'Instead of calculating our own reflection vector, we are simply going to get
    the vector halfway between the view direction and light direction, basically simulating
    the reflection vector. It has actually been found that this approach is more physically
    accurate than the last approach, but we thought it necessary to show you all the
    possibilities:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是计算我们自己的反射向量，而是简单地获取视图方向和光方向之间的向量，基本上模拟反射向量。实际上已经发现，这种方法比之前的方法在物理上更准确，但我们认为有必要向你展示所有可能性：
- en: '![](img/00103.gif)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.gif)'
- en: 'According to vector algebra, the half vector can be calculated as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据向量代数，半向量可以按以下方式计算：
- en: '![](img/00104.gif)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![img/00104.gif](img/00104.gif)'
- en: 'Here |V+L| is the length of the vector V+L. In Cg, we simply need to add the
    view direction and light direction together and then normalize the result to a
    unity vector:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 |V+L| 是向量 V+L 的长度。在 Cg 中，我们只需将视向和光向相加，然后将结果归一化到单位向量：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, we simply need to dot the vertex normal with this new half vector to get
    our main Specular value. After this, we just take it to a power of `_SpecPower`
    and multiply it by the Specular color variable. It's much lighter on the code
    and math, but still gives us a nice Specular highlight that will work for many
    real-time situations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需将顶点法线与这个新的半向量点积，以获得我们的主要镜面值。之后，我们只需将其乘以`_SpecPower`的幂，并乘以镜面颜色变量。这在代码和数学上要简单得多，但仍然给我们一个很好的镜面高光，适用于许多实时场景。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The light models seen in this chapter are extremely simple; no real material
    is perfectly matte or perfectly specular. Moreover, it is not uncommon for complex
    materials such as clothing, wood, and skin to require knowledge of how light scatters
    in the layers beneath the surface. Use the following table to recap the different
    lighting models encountered so far:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中看到的光模型非常简单；没有真实材料是完美哑光或完美镜面的。此外，对于如衣物、木材和皮肤等复杂材料，了解光线在表面下层的散射方式是常见的。使用以下表格来回顾迄今为止遇到的不同光照模型：
- en: '| **Technique** | **Type** | **Light Intensity (I)** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **技术** | **类型** | **光照强度 (I)** |'
- en: '| Lambertian | Diffuse | ![](img/00105.gif) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 拉姆伯特 | 漫反射 | ![img/00105.gif](img/00105.gif) |'
- en: '| `Phong` | Specular | ![](img/00106.gif)![](img/00107.gif) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `Phong` | 镜面 | ![img/00106.gif](img/00106.gif)![](img/00107.gif) |'
- en: '| BlinnPhong | Specular | ![](img/00108.gif)![](img/00109.gif) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| BlinnPhong | 镜面 | ![img/00108.gif](img/00108.gif)![](img/00109.gif) |'
- en: 'There are other interesting models such as the Oren-Nayar lighting model for
    rough surfaces: [https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model](https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他有趣的模型，例如用于粗糙表面的 Oren-Nayar 光照模型：[https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model](https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model).
- en: Creating an Anisotropic Specular type
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建各向异性镜面类型
- en: '**Anisotropic** is a type of Specular or reflection that simulates the directionality
    of grooves in a surface and modifies/stretches the Specular in the perpendicular
    direction. It is very useful when you want to simulate brushed metals, not a metal
    with a clear, smooth, and polished surface. Imagine the Specular that you see
    when you look at the data side of a CD or DVD or the way Specular is shaped at
    the bottom of a pot or pan. You will notice that if you carefully examine the
    surface, there is a direction to the grooves, usually in the way the metal was
    brushed. When you apply a Specular to this surface, you get a Specular stretched
    in the perpendicular direction.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**各向异性**是一种模拟表面凹槽方向性的镜面或反射类型，并在垂直方向上修改/拉伸镜面。当你想要模拟刷漆金属时，它非常有用，而不是那种表面清晰、光滑和抛光的金属。想象一下，当你看CD或DVD的数据面时看到的镜面，或者锅底或平底锅底部镜面的形状。你会注意到，如果你仔细检查表面，凹槽有一个方向，通常是金属刷的方向。当你将镜面应用于这个表面时，你会得到一个在垂直方向上拉伸的镜面。'
- en: 'This recipe will introduce you to the concept of augmenting your Specular highlights
    to achieve different types of brushed surfaces. In future recipes, we will look
    at the ways in which we can use the concepts of this recipe to achieve other effects,
    such as stretched reflections and hair, but here, you are going to learn the fundamentals
    of the technique first. We will be using this shader as a reference for our own
    custom Anisotropic Shader:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您介绍增强您的镜面高光以实现不同类型刷漆表面的概念。在未来的食谱中，我们将探讨如何使用本食谱中的概念来实现其他效果，例如拉伸反射和毛发，但在这里，你将首先学习这项技术的根本。我们将使用这个着色器作为我们自定义各向异性着色器的参考：
- en: '[http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader](http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader](http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader).'
- en: 'The following diagram shows examples of different types of Specular effects
    that you can achieve using Anisotropic Shaders in Unity:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用 Unity 中的各向异性着色器可以实现的多种不同镜面效果示例：
- en: '![](img/00110.gif)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![img/00110.gif](img/00110.gif)'
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start this recipe by creating a shader, its material, and some lights
    for our scene:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个着色器、其材质以及场景中的灯光开始这个食谱：
- en: Create a new scene with some objects and lights so that we can visually debug
    our shader. In this case, we will be using some capsules, a sphere, and a cylinder.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，其中包含一些对象和光源，以便我们可以直观地调试我们的着色器。在这种情况下，我们将使用一些胶囊、一个球体和一个圆柱体。
- en: 'Then create a new shader and material, and hook them up to your objects:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个新的着色器和材质，并将它们连接到您的对象上：
- en: '![](img/00111.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: Lastly, we will need some sort of normal map that will indicate the directionality
    of our Anisotropic Specular highlight.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一种类型的法线图，以指示我们的各向异性高光的方向性。
- en: 'The following screenshot shows the Anisotropy normal map we will be using for
    this recipe. It is available from this book''s support page at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support):'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将用于此菜谱的各向异性法线图。它可以从本书的支持页面[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)获取：
- en: '![](img/00112.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.jpeg)'
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create an Anisotropic effect, we need to make the following changes to the
    shader previously created:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建各向异性效果，我们需要对之前创建的着色器进行以下更改：
- en: 'We first need to remove the old properties and then add the properties that
    we are going to need for our shader. These will allow a lot of artistic control
    over the final appearance of the surface:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要删除旧属性，然后添加我们将需要用于着色器的属性。这些将允许对表面最终外观进行大量艺术控制：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We then need to make the connection between our `Properties` block and
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在`Properties`块和
- en: 'our `SubShader{}` block so that we can use the data being provided by the `Properties`
    block:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`SubShader{}`块，以便我们可以使用`Properties`块提供的数据：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can create our `Lighting` function that will produce the correct Anisotropic
    effect on our surface. We will use the following code for this:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的`Lighting`函数，该函数将在我们的表面上产生正确的各向异性效果。我们将使用以下代码来完成此操作：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In order to use this new `Lighting` function, we need to tell the subshader''s
    `#pragma` statement to look for it instead of using one of the built-in `Lighting`
    functions:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用这个新的`Lighting`函数，我们需要告诉子着色器的`#pragma`语句去寻找它，而不是使用内置的`Lighting`函数之一：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have also given the Anisotropic normal map its own UVs by declaring the
    following code in the `struct Input`. This isn''t entirely necessary as we could
    just use the UVs from the main texture, but this gives us independent control
    over the tiling of our brushed metal effect so that we can scale it to any size
    we want:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在`struct Input`中声明了以下代码，为各向异性法线图赋予了它自己的UV。这并不是完全必要的，因为我们可以直接使用主纹理的UV，但这样我们可以独立控制刷漆金属效果的重叠，以便我们可以将其缩放到任何大小：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need to add the `struct SurfaceAnisoOutput`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加`struct SurfaceAnisoOutput`：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we need to use the `surf()` function to pass the correct data to our
    `Lighting` function. Hence, we will get the per-pixel information from our Anisotropic
    normal map and set our Specular parameters as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要使用`surf()`函数将正确的数据传递给我们的`Lighting`函数。因此，我们将从我们的各向异性法线图中获取每像素信息，并将我们的高光参数设置如下：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Save your script and return to the Unity editor. Select the `AnisotropicMat`
    material and assign the Anisotropic Direction property to the texture we talked
    about in the *Getting ready* section of this recipe. Afterward, adjust the Anisotopic
    `Offset` property using the slider and notice the changes.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的脚本并返回到Unity编辑器。选择`AnisotropicMat`材质，并将各向异性方向属性分配给我们在本菜谱的“准备”部分中提到的纹理。之后，使用滑块调整各向异性`偏移`属性，并注意变化。
- en: 'The Anisotropic normal map allows us to give the surface direction and helps
    us disperse the Specular highlight around the surface. The following screenshot
    demonstrates the result of our Anisotropic Shader:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 各向异性法线图使我们能够给表面赋予方向，并帮助我们分散表面上的高光。以下截图展示了我们的各向异性着色器的结果：
- en: '![](img/00113.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpeg)'
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's break down this shader into its core components and explain why we are
    getting the effect. We will mostly be covering the custom Lighting function here,
    as the rest of the shader should be pretty self-explanatory at this point.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个着色器分解为其核心组件，并解释我们为什么会得到这种效果。我们在这里主要会涵盖自定义光照函数，因为到目前为止，着色器的其余部分应该相当容易理解。
- en: 'We first start by declaring our own `SurfaceAnisoOutput struct`. We need to
    do this in order to get the per-pixel information from the Anisotropic normal
    map, and the only way we can do this in a Surface Shader is to use a `tex2D()`
    function in the `surf()` function. The following code shows the custom surface
    output structure used in our shader:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明自己的`SurfaceAnisoOutput`结构体。我们需要这样做是为了从各向异性法线图中获取每个像素的信息，而在表面着色器中，我们唯一能够做到这一点的方法是在`surf()`函数中使用`tex2D()`函数。以下代码展示了我们在着色器中使用的自定义表面输出结构：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can use the `SurfaceAnisoOutput` struct as a way of interacting between the
    Lighting function and the surface function. In our case, we are storing the per-pixel
    texture information in the variable called `anisoTex` in our `surf()` function
    and then passing this data to the `SurfaceAnisoOutput` struct by storing it in
    the `AnisoDirection` variable. Once we have this, we can use the per-pixel information
    in the `Lighting` function using `s.AnisoDirection`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SurfaceAnisoOutput`结构体作为光照函数和表面函数之间交互的一种方式。在我们的情况下，我们在`surf()`函数中将每个像素的纹理信息存储在名为`anisoTex`的变量中，然后通过将数据存储在`AnisoDirection`变量中来将其传递给`SurfaceAnisoOutput`结构体。一旦我们有了这个，我们就可以使用`Lighting`函数中的`s.AnisoDirection`来使用每个像素的信息。
- en: 'With this data connection set up, we can move on to our actual lighting calculations.
    This begins by getting the usual out of the way, the half vector, so that we don''t
    have to do the full reflection calculation and diffuse lighting, which is the
    vertex normal dotted with the light vector or direction. This is done in Cg with
    the following lines:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这种数据连接后，我们可以继续进行实际的光照计算。这首先是通过获取通常的半向量来开始的，这样我们就不必进行完整的反射计算和漫反射光照，即顶点法线与光向量或方向的点乘。这是在Cg中使用以下行完成的：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we start the actual modification to the Specular to get the right look.
    We first dot the normalized sum of the vertex normal and per-pixel vectors from
    our Anisotropic normal map with the `halfVector` calculated in the previous step.
    This gives us a float value that gives a value of `1` as the surface normal, which
    is modified by the Anisotropic normal map as it becomes parallel with `halfVector`
    and `0` as it is perpendicular. Finally, we modify this value with a `sin()` function
    so that we can basically get a darker middle highlight and ultimately a ring effect
    based on `halfVector`. All the previously mentioned operations are summarized
    in the following two lines of Cg code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始对Specular进行实际修改以获得正确的视觉效果。我们首先将顶点法线与每个像素向量的归一化总和与上一步计算的`halfVector`进行点乘。这给我们一个浮点值，当表面法线与`halfVector`平行时，其值为`1`，而当它垂直时，其值为`0`。最后，我们使用`sin()`函数修改这个值，以便我们基本上可以得到一个较暗的中间高光，并最终基于`halfVector`得到一个环状效果。所有之前提到的操作都在以下两行Cg代码中总结：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we scale the effect of the `aniso` value by taking it to a power of
    `s.Gloss`, and then globally decrease its strength by multiplying it by `s.Specular`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将其提升到`s.Gloss`的幂来缩放`aniso`值的效果，然后通过乘以`s.Specular`来全局降低其强度：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This effect is great for creating more advanced metal type surfaces, especially
    the ones that are brushed and appear to have directionality to them. It also works
    well for hair or any sort of soft surface with directionality to it. The following
    screenshot shows the result of displaying the final Anisotropic lighting calculation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果非常适合创建更高级的金属类型表面，特别是那些刷过并且看起来有方向性的表面。它也适用于头发或任何有方向性的软表面。以下截图显示了显示最终各向异性光照计算的最终结果：
- en: '![](img/00114.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00114.jpeg)'
