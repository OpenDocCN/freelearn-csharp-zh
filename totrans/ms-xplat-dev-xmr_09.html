<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Reusable UI Patterns</h1></div></div></div><p>In this chapter, we will discuss strategies and patterns for reusing visual assets (that is, text and media resources) in cross platform projects. Furthermore, reusable assets will be iteratively explained from the localization perspective. Finally, some advanced software architectural topics about Model-View-Controller and Model-View-ViewModel patterns will be analyzed and demonstrated. This chapter is divided into the following sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Visual assets</li><li class="listitem" style="list-style-type: disc">Localization</li><li class="listitem" style="list-style-type: disc">Architectural patterns</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec55"/>Visual assets</h1></div></div></div><p>We can classify any resource included in the project at compile time and used by the user interface as a visual asset. Visual assets can vary from simple text elements to media items (for example images, animations, videos, and so on) to be used for creating the visual elements of the user interface. Each Xamarin target platform provides different mechanisms to store and dispatch t<a class="indexterm" id="id534"/>hese assets.</p><p>On Android and iOS, resources and their localized representations are kept in the designated <code class="literal">Resources</code> folder and substructures. On Windows Phone (both Silverlight and Windows Runtime), resources can be managed by using embedded resource files (that is, <code class="literal">resw</code> or <code class="literal">resx</code>).</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec112"/>Text resources</h2></div></div></div><p>Each Xamarin<a class="indexterm" id="id535"/> target platform uses various strategies to filter out static text<a class="indexterm" id="id536"/> resources, such as the content of a message dialog or a label, from the <strong>View</strong> implementation. Doing this helps developers separate human readable resources from code base, creating a project structure in line with the separation of concerns principle.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec36"/>Xamarin.Android</h3></div></div></div><p>On the Android platform, text resources can be stored in the <code class="literal">strings.xml</code> file and retrieved through code or used in declarative markups (that is, AXML files). The XML file containing the string<a class="indexterm" id="id537"/> resources can be found or created in the <code class="literal">Resources\values</code> directory. There is no relevance between the filenames and how the resources are retrieved later on.</p><p>The resource XML file has a simple format, where each string is defined as an XML node with an associated name as an attribute:</p><div><pre class="programlisting">&lt;resources&gt;
  &lt;string name="ApplicationName"&gt;Fibonnaci Calculator&lt;/string&gt;
  &lt;string name="SingleCalculation"&gt;Single Calculation&lt;/string&gt;
  &lt;string name="RangeCalculation"&gt;Range Calculation&lt;/string&gt;
  &lt;string name="GCCollect"&gt;GC Collect&lt;/string&gt;
&lt;/resources&gt;</pre></div><p>The string values can later be used in markup, and also in Android declarative attributes, using the <code class="literal">@string/&lt;ResourceName&gt;</code> notation:</p><div><pre class="programlisting">&lt;Button
    android:text="@string/SingleCalculation"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    local:MvxBind="Click NavigateToSingleCalculationCommand" /&gt;
&lt;Button
    android:text="@string/RangeCalculation"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    local:MvxBind="Click NavigateToRangeCalculationCommand" /&gt;</pre></div><p>In order to add an activity label for a view, the <code class="literal">ApplicationName</code> string can be included directly with the <code class="literal">@string</code> notation:</p><div><pre class="programlisting">[Activity(Label = "@string/ApplicationName")]</pre></div><p>On top of the classic string resources, a collection of string resources and quantity strings can also be included in the resource XML file(s). Quantity strings are resource strings with a definition for different countable references for various scenarios with the correct pluralization rule.</p><p>For instance, for an application with English as the default language, the plural quantity strings would look similar to the following (for example, a singular word for one, a plural form for others):</p><div><pre class="programlisting">&lt;plurals name="CalculationsCompleted"&gt;
  &lt;item quantity="one"&gt;%d calculation was completed.&lt;/item&gt;
  &lt;item quantity="other"&gt;%d calculations were completed.&lt;/item&gt;
&lt;/plurals&gt;</pre></div><p>Whereas for the Turkish language, it would look similar to the following (the same rule applies to all countable words):</p><div><pre class="programlisting">&lt;plurals name="CalculationsCompleted"&gt;
  &lt;item quantity="other"&gt;%d islem tamamlandi.&lt;/item&gt;
&lt;/plurals&gt;</pre></div><p>Examples of this usage can be extended to Slavic languages (for example Russian, Polish, and Czech), where languages have different use cases for a small number of items or for numbers<a class="indexterm" id="id538"/> ending with certain digits. Possible switch values for quantities are <code class="literal">zero</code>, <code class="literal">one</code>, <code class="literal">two</code>, <code class="literal">few</code>, <code class="literal">many</code>, and <code class="literal">other</code>. The application of these switches follows the rules defined for language plurals in the unicode common locale<a class="indexterm" id="id539"/> data repository (see <a class="ulink" href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html">http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html</a> for more information). For instance, English does not require a specific handling for few items or zero items, so any rule defined for these cases will be ignored by the runtime.</p><p>Once the resource XML file(s) are modified, you can see that the <code class="literal">Resource.Designer.cs</code> file is (re)generated with each compilation. This file contains the associated ID values for different types of resources and can be used for retrieving the resource items with the <code class="literal">Resources</code> utility class.</p><div><img alt="Xamarin.Android" src="img/B04693_09_01.jpg"/><div><p>Figure 1: Generated resource constants</p></div></div><p>Using the <code class="literal">Resources</code> utility, text resources can be retrieved in the following ways:</p><div><pre class="programlisting">// Getting a single text value
var singleStringValue = Resources.GetText(Resource.String.ApplicationName);
// Getting a string array
var stringArrayValue = Resources.GetTextArray(Resource.Array.MyStringArray);
// Getting a pluralized version for 2 items
var quantity = Resources.GetQuantityString(Resource.Plurals.CalculationsCompleted, 2, 2);</pre></div><p>Additionally, other <a class="indexterm" id="id540"/>primitive data types (for example, integers, Booleans, and so on), as well as units or <code class="literal">structs</code> used in style definitions (for example, dimension and color) can be included in resource XML files.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec37"/>Xamarin.iOS</h3></div></div></div><p>On the iOS platform, the simplest way to separate the text resources from the rest of the project would be to<a class="indexterm" id="id541"/> create <code class="literal">.strings</code> files (for example, <code class="literal">Localizable.strings</code>), which follow a simple JSON-like pattern with key/value pairs:</p><div><pre class="programlisting">"GCCollect" = "GC Collect";
"RangeCalculation" = "Range Calculation";
"SingleCalculation"= "Single Calculation";</pre></div><p>These string values, compiled into bundle resources, can, later on, be accessed using the <code class="literal">NSBundle.MainBundle.LocalizedString</code> method:</p><div><pre class="programlisting">var localizedString = NSBundle.MainBundle.LocalizedString ("RangeCalculation", "");</pre></div><p>Localized string values can be used as labels for UI controls, creating a loosely-coupled relationship between the static text content and the actual runtime components. This process is referred to as internationalization in the iOS ecosystem. Internationalized controls and elements can easily be localized for different languages. <code class="literal">Strings</code> files can be created in the <code class="literal">Resources</code> folder or can be placed in the <code class="literal">Base.lproj</code> folder inside the <code class="literal">Resources</code> directory, which constitutes the base localization project folder for iOS projects (the default/fallback resources).</p><p>For storyboards, the internationalization process can be a little more complicated. Each UI element in a storyboard is assigned a unique identifier called the <strong>Object ID</strong> in Xcode, while it is referred to as the<a class="indexterm" id="id542"/> <strong>Localization ID</strong> in Xamarin Storyboard Designer. In order to assign text content to a specific item on the storyboard, developers are required to create string files for each storyboard (for example, for a storyboard called <code class="literal">Main.storyboard</code>, you will need to create a <code class="literal">Main.strings</code> file) and use the localization ID of the specific control and the name of the text attribute:</p><div><pre class="programlisting">/* Class = "UIViewController"; title = "Single Calculation"; ObjectID = "138"; */
"138.title" = "Single Calculation";
/* Class = "UILabel"; text = "Ordinal"; ObjectID = "153"; */
"153.text" = "Ordinal";
/* Class = "UIButton"; normalTitle = "Calculate"; ObjectID = "156"; */
"156.normalTitle" = "Calculate";</pre></div><p>As one can see, the attribute names and casings are clearly different from the actual type properties of UI controls (for example, <code class="literal">text</code> for <code class="literal">UILabel</code>, <code class="literal">normalTitle</code> for <code class="literal">UIButton</code>). The iOS internationalization guidelines can provide details on the storyboard attributes.</p><p>Another way to <a class="indexterm" id="id543"/>create the base internationalization file for a storyboard is to use Xcode to generate the <code class="literal">string</code> file. In order to modify the Xamarin.iOS project with Xcode, the <strong>Open With</strong> context menu item can be used to select <strong>Xcode Interface Builder</strong> for a storyboard and the main project window to access the project properties.</p><div><img alt="Xamarin.iOS" src="img/B04693_09_02.jpg"/><div><p>Figure 2: Xcode Interface Builder</p></div></div><p>In the Xcode interface, the localization settings are located on the project settings page. If the base localization folder was created beforehand, the <strong>Base Localization</strong> option will already be checked in<a class="indexterm" id="id544"/> the project settings localization section.</p><div><img alt="Xamarin.iOS" src="img/B04693_09_03.jpg"/><div><p>Figure 3: Xcode project configuration</p></div></div><p>Any additional language selection generates a language specific <code class="literal">.lproj</code> folder and the <code class="literal">.strings</code> file for the targeted storyboards and strings files. Once the Xcode window is closed, these changes will be reflected in the Xamarin.iOS project structure.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec38"/>Windows Phone</h3></div></div></div><p>In Windows Phone (Silverlight) projects, resources are managed through traditional <code class="literal">resx</code> files (a legacy <a class="indexterm" id="id545"/>of the .NET framework). The default language resources are generated with the project template and stored in the <code class="literal">AppResources.resx</code> file, located under the <code class="literal">Resources</code> folder.</p><div><img alt="Windows Phone" src="img/B04693_09_04.jpg"/><div><p>Figure 4: Windows Phone resources</p></div></div><p>Additional types of content that can be embedded in the resources file are images, icons, audio, and other types of files. These files can be accessed through code and also in markup, using the generated <code class="literal">AppResources</code> class. Another generated class, <code class="literal">LocalizedStrings</code>, provides access to the resources stored in the embedded resource file(s):</p><div><pre class="programlisting">&lt;StackPanel&gt;
    &lt;Button x:Name="SingleCalculation"
            Content="{Binding LocalizedResources.SingleCalculation, Source={StaticResource LocalizedStrings}}"
            Style="{StaticResource NavigationButtons}"&gt;&lt;/Button&gt;
    &lt;Button x:Name="RangeCalculation"
            Content="{Binding LocalizedResources.RangeCalculation, Source={StaticResource LocalizedStrings}}"
            Style="{StaticResource NavigationButtons}"&gt;&lt;/Button&gt;
    &lt;Button x:Name="GCCollect"
            Content="{Binding LocalizedResources.GCCollect, Source={StaticResource LocalizedStrings}}"
            Style="{StaticResource NavigationButtons}"&gt;&lt;/Button&gt;
&lt;/StackPanel&gt;</pre></div><p>In Windows Phone 8.1 (that is, Windows Runtime) and Windows 10, the applications use a <code class="literal">resw</code> file (called <code class="literal">PRIResource</code>, referring to the compilation method). Even though the format of <code class="literal">resx</code> and <code class="literal">resw</code> files<a class="indexterm" id="id546"/> is identical, <code class="literal">resw</code> files can only contain primitive values (that is, string values or values that can be expressed as strings). Using <code class="literal">resw</code> files, developers can assign style or other attribute values directly to user controls using the <code class="literal">Uid</code> value of the controls, similar to the internationalization of storyboards on iOS.</p><div><img alt="Windows Phone" src="img/B04693_09_05.jpg"/><div><p>Figure 5: Windows Runtime PRI resources</p></div></div><p>In addition to the<a class="indexterm" id="id547"/> targeted resources, developers are still free to use simple resource strings. These resources can be accessed using the <code class="literal">ResourceLoader</code> class and the <code class="literal">GetString</code> method.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec113"/>Image resources</h2></div></div></div><p>Mobile application projects can contain media assets from external sources as well as the application bundle. In each target platform, media assets can be included in different ways.</p><p>While iOS <a class="indexterm" id="id548"/>and Windows Phone do not dictate a certain location in the project tree for media assets, in Android projects, developers are obliged to include image documents in the <code class="literal">drawable</code> folder of the <code class="literal">Resources</code> directory.</p><div><img alt="Image resources" src="img/B04693_09_06.jpg"/><div><p>Figure 6: Project structures</p></div></div><p>Similar to the text resource structure on the iOS platform, it is advisable to place language-neutral image elements (for the default language) in the <code class="literal">Base.lproj</code> location if you are planning to localize<a class="indexterm" id="id549"/> them in later iterations. Also, asset catalogs can be employed to simplify the management of images and their pixel-perfect alternatives for different resolutions (see the <em>Adaptive visual assets</em> section).</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec114"/>Adaptive visual assets</h2></div></div></div><p>Adaptive UI patterns for applications targeting Xamarin platforms force developers, at times, to include variations of media assets for different resolutions and pixel densities. Even though the image resources are <a class="indexterm" id="id550"/>scaled according to the aforementioned adaptive UI metrics, the scaled images do not always result in visually pleasing displays (for example, an image resized to double the original size, to have the same physical screen dimensions on different devices, does not appear as it should).</p><p>The Android platform uses the device compatibility configuration qualifiers for both image and text resource folders (that is, <code class="literal">drawables</code> and <code class="literal">values</code>), as well as other types of resources, such as layouts. In such projects, compatibility qualifiers are concatenated to the resource folder as a suffix (for example, the <code class="literal">drawables-xhdpi</code> folder can be used to provide images specific to extra high density device displays of approximately 320 dpi) and various default resources are added to this folder. Compatibility configuration not only deals with pixel density, but also provides selectors for mobile network related<a class="indexterm" id="id551"/> switches (that is, <strong>MCC</strong> (<strong>mobile country code</strong>) and<a class="indexterm" id="id552"/> <strong>MNC</strong> (<strong>mobile network code</strong>)), language, and region (see the <em>Localization</em> section), layout direction (that is, left to right or right to left), various screen size-related options, screen orientation, UI mode (related to the platform displaying the application—a car, desk, television, appliance, or watch), night mode (that is, day or night), input type-related configurations, and finally the platform API level/version.</p><p>On the iOS platform, image assets can be individually suffixed to provide different versions of the same image for different resolutions and device idioms (that is, iPhone, iPod, and iPad). Device idiom values (that is, device modifiers) are used with the tilde (<code class="literal">~</code>) character and can identify resources for iPhone and iPod using the <code class="literal">~iphone</code> suffix and resources for iPad using the <code class="literal">~ipad</code> suffix. The <code class="literal">@2x</code> suffix, which should appear before the device modifier, is used to identify high resolution image variants.</p><p>Before the introduction of Windows Phone 8.1, the Windows Phone operating system only supported four variations: WVGA (480 x 800, only used by WP 7.1), WXGA (768 x 1280), 720p (720 x 1280), and 1080p (1080 x 1920). The only way to differentiate between these resolutions was to use the <code class="literal">App.Current.Host.ScaleFactor</code> device configuration property (for example, a scale factor of 100 refers to WVGA and 150 refers to HD). Windows Store apps (including Windows Phone 8.1) provide an automated scaling mechanism similar to that of iOS and Android. On the Windows Phone 8.1 platform, each resource file and/or folder can be suffixed with various qualifiers to support multiple display scales, languages and regions, contrasts, and similar, to tailor a customized look and <a class="indexterm" id="id553"/>feel for different device configurations. If the qualifiers are applied to a specific file, each qualifier/value pair should be separated by an underscore and added between the filename and the extension (that is, <code class="literal">filename.qualifiername-value_otherqualifier-value.fileextension</code>). If the qualifiers are applied to complete folders, for each qualifier/value, a subfolder should be created (that is, <code class="literal">resourcefolder/qualifier-value/otherqualifier-value/</code>).</p><p>For instance, see the following project path:</p><div><pre class="programlisting">Images/en-US/config-designer/myImage.scale-140_layoutdir-LTR.png</pre></div><p>This can be accessed with the<code class="literal"> Images/myImage.png </code>resource path.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec115"/>Reusable assets</h2></div></div></div><p>Managing media assets in cross platform projects, especially if you are providing variations for different <a class="indexterm" id="id554"/>device configurations, can become quite a hurdle. In order to reuse these assets for multiple platforms, linked file references can be utilized (<strong>Add</strong> | <strong>Existing Item</strong> | <strong>Add as Link</strong>).</p><div><img alt="Reusable assets" src="img/B04693_09_07.jpg"/><div><p>Figure 7: Add resource as link</p></div></div><p>Using this strategy, image documents can be included in a common location for all platform-specific projects (for example, the common portable library), and only linked file references can be added to<a class="indexterm" id="id555"/> platform-specific projects.</p><p>This way, image documents are not copied to multiple locations, but only compiled into different platform-specific projects.</p><div><img alt="Reusable assets" src="img/B04693_09_08.jpg"/><div><p>Figure 8: Linked resources for normal and high definition in Windows Phone and Android projects</p></div></div><p>Text resources in a cross-platform project do not differ greatly between platforms, especially if the resources in question are simple string values, rather than targeted attributes for UI controls (for example, text content specified for a label or a button on a storyboard). Another observation is that most of the text resource values are handled as key/value pairs in <a class="indexterm" id="id556"/>XML format (for Windows Phone and Android) or with simple JavaScript-like notation (in iOS). Elaborating on these assumptions, we can create an automated process that evaluates a common resource file and creates/generates the resource strings for the target platforms.</p><p>Considering the fact that we will use either a shared project library or a portable class library that will contain the shared code for the platform specific projects, this common project would be the most appropriate location to store the common resource strings. We can use this project to create the common resource package in the <code class="literal">resx</code> format.</p><p>These embedded resource files, as previously mentioned, are simple XML files in which the string resources pairs are stored in <code class="literal">&lt;data&gt;</code> nodes with the <code class="literal">name</code> attribute as the key and the <code class="literal">&lt;value&gt;</code> text node as the value (the rest of the file contains the XSD schema and metadata values for code generation).</p><div><img alt="Reusable assets" src="img/B04693_09_09.jpg"/><div><p>Figure 9: Resx file XML structure</p></div></div><p>Android string resources have a similar structure with less complexity and different node names (that is, resource<a class="indexterm" id="id557"/> values are represented with <code class="literal">&lt;string&gt;</code> text nodes with the attribute <code class="literal">name</code>). Conversion between the two XML files is fairly simple with an XSL transformation in Visual Studio.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>XSL is an abbreviation for Extensible Stylesheet Language and is used for transforming XML documents from one format to another. XSLT files may utilize templates, XPath queries, and other XSL functions to process XML document content. More<a class="indexterm" id="id558"/> information can be found at <a class="ulink" href="http://www.w3schools.com/xsl/default.asp">http://www.w3schools.com/xsl/default.asp</a>.</p></div></div><p>To transform the resource file into the Android format, we will create an XSLT file in the same folder as the <code class="literal">AppResources.resx</code> file in the common project. In order to create the Android XML resource file, we need to select each <code class="literal">&lt;data&gt;</code> element from the <code class="literal">&lt;root&gt;</code> node and create <code class="literal">&lt;string&gt;</code> nodes with appropriate text content and attributes inside the <code class="literal">&lt;resources&gt;</code> root node:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet version="1.0" 
     exclude-result-prefixes="msxsl"&gt;
  &lt;xsl:output method="xml" indent="yes"/&gt;
  &lt;xsl:template match="/"&gt;
    &lt;resources&gt;
      &lt;xsl:for-each select="/root/data"&gt;
        &lt;string&gt;
          &lt;xsl:attribute name="name"&gt;
            &lt;xsl:value-of select="@name"/&gt;
          &lt;/xsl:attribute&gt;
          &lt;xsl:value-of select="value"/&gt;
        &lt;/string&gt;
      &lt;/xsl:for-each&gt;
    &lt;/resources&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div><p>Now, after this step, we can use the XML menu to debug the XSLT file using the <code class="literal">resx</code> file:</p><div><img alt="Reusable assets" src="img/B04693_09_10.jpg"/><div><p>Figure 10: XSL Transformation debug session in Visual Studio</p></div></div><p>After confirming that the transformation works as expected, we can now automate this process to regenerate the strings file every time the common project is rebuilt. For this automation, we can <a class="indexterm" id="id559"/>use a third-party XML transformation command line application and add the console command as a pre-build event command line argument using the project settings. Another option would be to use the out-of-box <code class="literal">MSBuild</code> task <code class="literal">XslTransformation</code> to add a <code class="literal">BeforeBuild</code> target.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>In order to add new build targets, the <code class="literal">csproj</code> file needs to be modified in Visual Studio. For this purpose, the common project first needs to be unloaded using <strong>Unload Project</strong> from the project context menu, and the project file can be edited using the <strong>Edit &lt;Project File Name&gt;</strong> option from the same context menu.</p></div></div><p>The <code class="literal">XslTransformation</code> task is a simple build task with three basic parameters for the XML file that needs to<a class="indexterm" id="id560"/> be transformed (that is, <code class="literal">XmlInputPath</code>), the XSL file to be used for the transformation (that is, <code class="literal">XslInputPath</code>), and finally the output path (that is, <code class="literal">OutputPaths</code>):</p><div><pre class="programlisting">&lt;Target Name="BeforeBuild"&gt;
  &lt;XslTransformation 
    XslInputPath="Resources\AndroidTransform.xslt" 
    XmlInputPaths="Resources\AppResources.resx" 
    OutputPaths="..\Xamarin.Master.Fibonacci.Android\Resources\values\strings.xml" /&gt;
&lt;/Target&gt;</pre></div><p>With this modification, every time the common project is built (with a default setup, the common project should be built before the Android project), the <code class="literal">strings.xml</code> file will be generated and placed into the values folder in the Android project.</p><p>The same transformation approach is applicable to the iOS localized <code class="literal">strings</code> files. In an iOS-specific transformation, the output should be set to text and the transformation style sheet should create the key/value pairs. In order to create the lines of text for each data element in the embedded resource file, the <code class="literal">concat</code> function can be utilized:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet version="1.0" 
   exclude-result-prefixes="msxsl"&gt;
  &lt;xsl:output method="text" encoding="utf-8" indent="no" omit-xml-declaration="no"/&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:for-each select="/root/data"&gt;
      &lt;xsl:value-of select="concat('&amp;quot;', @name, '&amp;quot; = &amp;quot;', value, '&amp;quot;;', '
')" /&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div><p>In this stylesheet, it is important to note that text elements (symbols), such as double quotes and carriage return (that is, line feed and end of line), are HTML encoded.</p><p>Once the transformation result is confirmed, we can add another <code class="literal">XslTransformation</code> task to the project file as a <code class="literal">BeforeBuild</code> target to create the localized <code class="literal">strings</code> file:</p><div><pre class="programlisting">&lt;XslTransformation 
  XslInputPath="Resources\IOSTransform.xslt" 
  XmlInputPaths="Resources\AppResources.resx" 
  OutputPaths="..\Xamarin.Master.Fibonacci.iOS\Resources\Base.lproj\Localizable.strings" /&gt;</pre></div><p>Using the same implementation, the translation values containing the <code class="literal">resx</code> files can be transformed and used to<a class="indexterm" id="id561"/> generate localized resources for the target platforms. In addition to XSL transformations, T4 templates can also be used to generate the text resource files. Since certain build tasks (including <code class="literal">XslTransformation</code>) are not yet supported by xBuild and Xamarin Studio, T4 templates can provide an alternative if your main development environment is Mac OS and main development IDE is Xamarin Studio. With T4 templates, it is also possible to iterate through each file in the common resources and generate matching localization files in platform-specific projects.</p><p>The next section will summarize the localization strategies on Xamarin target platforms.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec56"/>Localization</h1></div></div></div><p>Localization and globalization are the two fundamental concepts of mobile applications. In the previous sections, we discussed different ways of separating visual content from the rest of the <a class="indexterm" id="id562"/>application. This process, in essence, prepares the mobile application to be localized and is generally a part of the globalization phase. Globalized applications should function the same way, independent of the culture or locale they are being executed on. During localization, developers are supposed to create language-specific resources and integrate them into the globalized applications.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec116"/>Locale and culture</h2></div></div></div><p>Locale can be <a class="indexterm" id="id563"/>defined as the umbrella term that includes all regional configurations on a specific device (or a specific application in some cases). The locale not only represents the user interface language, but also the formats used to display dates, times, numbers, and currency values.</p><p>As part of the<a class="indexterm" id="id564"/> globalization effort, in Xamarin target platforms, developers first need to identify which languages are going to be supported as part of the localization effort. A mobile application, after it is published and installed by the user, should manifest the supported languages so that the user interface can be rendered either with the locale that is dictated by the operating system (if supported) or the default/fallback language of the application.</p><p>The supported languages manifest is a calculated value according to the resources provided (Android) or a pre-declared manifest or project entry (iOS and Windows Phone).</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec117"/>Windows Phone</h2></div></div></div><p>In Windows Phone Silverlight application projects, resources for different languages can be provided using<a class="indexterm" id="id565"/> resource packages according to the naming conventions. The provided packages should then be referenced in the <code class="literal">WMAppManifest.xml</code> file. The easiest way to include additional language support for a Windows Phone application is to use the project properties to identify the supported cultures.</p><div><img alt="Windows Phone" src="img/B04693_09_11.jpg"/><div><p>Figure 11: Project Properties for Windows Phone Silverlight application</p></div></div><p>Once the project configuration modifications are saved, Visual Studio automatically creates the associated <code class="literal">resx</code> files (for example, <code class="literal">AppResources.bs.resx</code> for Bosnian, <code class="literal">AppResources.tr-TR.resx</code> for Turkish) and updates the application manifest. The default language can be modified from the package manifest (that is, <code class="literal">package.appxmanifest</code>) or the application manifest (<code class="literal">WMAppManifest.xml</code>) designers.</p><p>Windows Store applications (that is, Windows Phone 8.1) are globalized using folders named after the supported languages containing the <code class="literal">resw</code> resource files. For instance, in order to create an application that targets the same cultures as the previous example, we would need to create a folder structure and culture-specific resource files similar to the following:</p><div><img alt="Windows Phone" src="img/B04693_09_12.jpg"/><div><p>Figure 12: Windows Store apps supported cultures and app bundle</p></div></div><p>Once the application package is created, you will notice that instead of a single application<a class="indexterm" id="id566"/> package, an application bundle is created and each supported culture has an associated store app package in the bundle.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>Application bundles are used in Windows Store applications to reduce the size of the application packages that users are going to download for specific CPU architecture (ARM, x86, or x64), display hardware (image and other media assets, optimized for different resolutions), or locale. The packaging strategy can be selected while creating application packages, but if bundling is declined, developers are required to create a different upload package for each CPU architecture they are planning to support with their applications.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec118"/>Xamarin.iOS</h2></div></div></div><p>As previously explained, for Xamarin.iOS, once the additional languages are selected for the project in the<a class="indexterm" id="id567"/> Xcode development environment, generated localization folders and files are automatically added to the Xamarin.iOS project. The generated storyboard string files initially contain the possible localizable fields and the assigned values from the storyboard. Other string bundle resource files are copied with the same values from the <code class="literal">Base.lproj</code> folder.</p><div><img alt="Xamarin.iOS" src="img/B04693_09_13.jpg"/><div><p>Figure 13: Localized Xamarin.iOS project</p></div></div><p>When using text resource files for localization, the <code class="literal">LocalizedString</code> function for the <code class="literal">MainBundle</code> property either returns the value that matches the current user language selection or the<a class="indexterm" id="id568"/> default value defined in the <code class="literal">Base.lproj</code> directory.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>When using Visual Studio for creating and editing the <code class="literal">strings</code> files, it is a good idea to map the <code class="literal">strings</code> extension to JavaScript editor using the <strong>Options</strong> dialog and the <strong>Text Editor</strong> | <strong>File Extension</strong> section.</p></div></div><p>In order to load a language-specific resource that does not match the current preferred language(s) configuration, you will need to use the localization bundle path and retrieve the localized resources using the same function on this bundle:</p><div><pre class="programlisting">var path = NSBundle.MainBundle.PathForResource("tr", "lproj");
NSBundle languageBundle = NSBundle.FromPath(path);
var localizedString = languageBundle.LocalizedString ("RangeCalculation", "");</pre></div><p>The native development language directory (that is, <code class="literal">Base.lproj</code>), as well as the language-specific folders, can also be used to store other types of bundle resources, such as image resources, storyboards, XIB files, or even language-specific <code class="literal">Info.plist</code> files. (The <code class="literal">InfoPlist.strings</code> file in a language directory can be used to override values from the application's <code class="literal">Info.plist</code> file, such as the application name.)</p><p>It is crucial to<a class="indexterm" id="id569"/> add the supported languages to the info manifest. For localization, there are two relevant keys. The first relevant item is the <em>Localization</em> native development region (that is, <code class="literal">CFBundleDevelopmentRegion</code>) and the second key is the <em>Localizations</em> (that is, <code class="literal">CFBundleLocalizations</code>). While the native development region defines the language associated with the <code class="literal">Base.lproj</code> location, the localizations entries provide information about the other supported localizations.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec119"/>Xamarin.Android</h2></div></div></div><p>Localization in <a class="indexterm" id="id570"/>Xamarin.Android projects, similar to the folder structure of Windows Phone 8.1 projects, is achieved using a specific folder structure with the language code suffixed into the localized resource items (for example, <code class="literal">drawable-tr</code> or <code class="literal">values-en</code>).</p><div><img alt="Xamarin.Android" src="img/B04693_09_14.jpg"/><div><p>Figure 14: Android localization folder structure</p></div></div><p>An appropriate resource is selected in the runtime using a simple elimination algorithm that selects the correct resource file according to the locale, display density, display size, touch support, and<a class="indexterm" id="id571"/> other criteria.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec120"/>Xamarin.Forms</h2></div></div></div><p>The Xamarin.Forms portable class library project template provides the ideal environment for<a class="indexterm" id="id572"/> text resource sharing. In this setup, with a process similar to Windows Phone Silverlight projects, <code class="literal">resx</code> files can be used to create resource bundles that can be used to localize the cross-platform views created with Xamarin.Forms framework.</p><div><img alt="Xamarin.Forms" src="img/B04693_09_15.jpg"/><div><p>Figure 15: Localized Xamarin.Forms resources</p></div></div><p>Once the embedded resource files and their translation counterparts are added to the common PCL project, the resource entries can be accessed using the generated static class. In order for the generated class to be accessible from the platform specific implementations, the <strong>Custom Tool</strong> property of the resource file must be set to <code class="literal">PublicResXFileCodeGenerator</code> and the <strong>Build Action</strong> property to <code class="literal">Embedded Resource</code>.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>With Xamarin Studio or Visual Studio, the file properties window can be used to set to the correct access modifier for the resource accessors. In Visual Studio, the resource editor can also be used to correct the access modifier of resource items (that is, select <strong>Access Modifier</strong> | <strong>Public</strong> using the resource designer).</p></div></div><p>In the Windows Phone runtime, the correct resource files are loaded according to the current thread culture, so the preceding implementation would automatically choose the appropriate embedded resource. However, supported languages should still be configured using the application manifest. In Xamarin.iOS, the correct resources are loaded according to the users' language preferences (not the current UI language) and supported languages should be included in the <code class="literal">Info.plist</code> file using the <code class="literal">CFLocalizations</code> entry. For the Android platform, UI<a class="indexterm" id="id573"/> language selection is taken as the identifier for the resources.</p><p>The following implementation would localize the tabbed page implementation from the previous chapter:</p><div><pre class="programlisting">var tabbedPage = new TabbedPage();

tabbedPage.Children.Add(new ContentPage
{
    Title = TextResources.TabItemRecent,
    Content = new StackLayout
    {
        // Omitted for clarity
    },
    Icon = "social.png"
});</pre></div><p>In the preceding example, the highlighted line of code sets the accessor properties to specific resource elements. When using XAML for the same implementation, we can resort to statically bound properties using the <code class="literal">TextResources</code> generated class:</p><div><pre class="programlisting">&lt;TabbedPage 
    
    
    x:Class="Xamarin.Master.TravelTrace.Views.MainTabView"
    &gt;
  &lt;ContentPage 
        Title="{x:Static resources:TextResources.TabItemRecent}" 
        Icon="social.png"&gt;</pre></div><p>It is important to include the CLR namespace containing the generated resource accessor.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec57"/>Architectural patterns</h1></div></div></div><p>The user interface<a class="indexterm" id="id574"/> of an application can be described as the packaging over the sum of all the moving parts underneath. As applications get more complex, the responsibilities of the user interface increase and it gets harder to package the product underneath. Leaving aside the static parts of the UI (that is, assets described in the previous sections of this chapter), it is the most volatile part of an application. In order to counteract the entropy that builds up throughout the application's lifetime, solve recurring problem patterns, and re-use modules, developers often utilize certain design patterns in their development efforts. Especially in cross-platform projects, the importance of these architectural design patterns have been proven to be irrefutable.</p><p>For demonstration purposes, let's use a simple form-submit scenario. In this implementation, the users will be greeted with a form they will have to fill in. Once all the required text fields are populated by the user, he/she will submit the content using the submit button. The <a class="indexterm" id="id575"/>data is then validated and stored. The user should then be informed about the submission with a read-only screen where he/she can see the submitted and stored data.</p><div><img alt="Architectural patterns" src="img/B04693_09_16.jpg"/><div><p>Figure 16: The classic <em>n</em>-tier scenario</p></div></div><p>In an <em>n</em>-tier implementation, the presentation tier would be responsible for visualizing the data and would hold an instance of the API façade. The API façade would implement the business logic to validate the information and submit it to the data tier instance. The data tier would be solely responsible for communicating with the persistence store (possibly through the service layer).</p><p>The event subscriptions (that is, text field changed or submit button clicked) would be implemented in the presentation layer. On successful submission, the presentation layer would pass on the current API object to a new presentation container and visualize the submitted data. Even though this approach provides a clear separation between the tiers, there are still strong ties between the layers in the hierarchy (that is, the presentation layer holds a strongly typed reference of the API and the API either reuses or creates a new instance of the data model). The application tier also creates an unnecessarily large and complex structure that should provide the required methods for all the containers and related scenarios in the presentation layer. The presentation layer still has the most responsibility in terms of event-driven implementation. If we transpose this implementation onto a Xamarin cross-platform project, we would be able to reuse the complete application tier and the data tier across platforms. However, it would still require quite a bit of re-implementation for the presentation layer for other platform projects, as this layer is responsible for using the API. Another downside of this pattern is the fact that, other than<a class="indexterm" id="id576"/> the façade, it isn't easy to unit test the implementation (that is, there are multiple event subscriptions on the presentation layer).</p><p><strong>MVP</strong> (<strong>model-view-presenter</strong>) <a class="indexterm" id="id577"/>and <strong>MVVM</strong> (<strong>model-view-viewmodel</strong>), both derivatives of <strong>MVC</strong> (<strong>model-view-controller</strong>), try to answer some of these issues for classic <em>n</em>-tier implementations. Both of these patterns inherently use a passive presentation layer and delegate the main<a class="indexterm" id="id578"/> responsibility to the supervising or mediating component; the main reason for this is the fact that unit testing the view is generally impractical, hence it should be devoid of logic as much as possible. The presenter communicates with the data tier actively and is responsible for how the view should be visualized. In this paradigm, the only way the view communicates with the mediator is through routed events (separation of concerns). It is also important to note that in these architectural implementations, the application is divided into self-sufficient triads (that is, model, view, and presenter) which make up different use-cases and views in the application. Façades are generally used only in the model component.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec121"/>MVC</h2></div></div></div><p>The MVC pattern<a class="indexterm" id="id579"/> was initially introduced into Smalltalk, and later on popularized with its (excessive) use in web applications and frameworks. In classic MVC<a class="indexterm" id="id580"/> implementation, the <strong>Model</strong> not only provides access to a<a class="indexterm" id="id581"/> data store but also implements any required business logic. The <strong>Model</strong> can be described as the core implementation of the problem domain, independent of the user interface.</p><p>The<a class="indexterm" id="id582"/> <strong>Controller</strong> generally represents the logic stripped out of the <strong>View</strong>; it can send commands to the <strong>Model</strong> as<a class="indexterm" id="id583"/> well as the <strong>View</strong>, and receive the routed events from the <strong>View</strong>. Changes in state (that is, in the <strong>Model</strong>), are reflected on the <strong>View</strong> with or without the intervention of the <strong>Controller</strong> (classic MVC allows active or implicit interactions between the <strong>Model</strong> and the <strong>View</strong>).</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec39"/>iOS app architecture</h3></div></div></div><p>In iOS applications, the<a class="indexterm" id="id584"/> main development language hitherto has been Objective-C. The Cocoa and Cocoa Touch frameworks used for Mac OS and iOS application development, respectively, were also developed mainly in Objective-C. Considering the strong ties between Objective-C and SmallTalk, it is no surprise the main development pattern adopted and enforced by the iOS development kit is MVC.</p><p>In the Cocoa <a class="indexterm" id="id585"/>version of MVC implementation, direct communication between the <strong>View</strong> and <strong>Model</strong> is completely abandoned (and prohibited) because of the technical requirements of the mobile application development environment, and in order to increase the reusability of model and view components. In this pattern, the <strong>Controller</strong> (also called the mediator at times) is given the main responsibility to control the flow of data between the <strong>View</strong> and the <strong>Model</strong>. From this aspect, Cocoa's implementation of MVC undeniably resembles the MVP pattern:</p><div><img alt="iOS app architecture" src="img/B04693_09_17.jpg"/><div><p>Figure 17: Cocoa MVC</p></div></div><p>In this implementation schema, developers are encouraged to decouple the components of the triad from each other and implement the communication between them only through the defined abstractions.</p><p>The separation between the <strong>View</strong> and the <strong>Controller</strong> is generally achieved with commands, outlets, and bindings. Commands provide actionable composites that can be passed from one layer to another, and outlets are extensions of certain UI elements so that the controller can subscribe to events and control how the UI is presented according to state.</p><p>When view elements are designed using XIBs or storyboards (that is, storyboards are used to generate the<a class="indexterm" id="id586"/> XIBs at compile time), the outlets are defined as access points for the <strong>View</strong>-<strong>Controller</strong>. <strong>View</strong>-<strong>Controllers</strong> do not have a direct dependency on the <strong>View</strong>, nor does the <strong>View</strong> have any knowledge of the <strong>Controller</strong>. This setup complies with the separation of concerns principle and provides a loosely coupled structure as advised.</p><p>If we were to implement the scenario from the previous example, we would be exposing two outlets for the text input fields in the submit form and an outlet for the submit button. These outlets would, in return, be used by the Controller assigned to the <strong>View</strong> for subscribing to <a class="indexterm" id="id587"/>certain events, to validate and submit the data. The <strong>View</strong>-<strong>Controller</strong> (that is, <strong>UIController</strong>) is also responsible for changing how the controls <a class="indexterm" id="id588"/>are displayed (for example, validation<a class="indexterm" id="id589"/> can change the color of the text input field) and communicating user actions such as the submission of data to the <strong>Model</strong>. Navigating to another view is also the responsibility of the <strong>Controller</strong> in this case.</p><div><img alt="iOS app architecture" src="img/B04693_09_18.jpg"/><div><p>Figure 18: MVC demonstration on an iOS form</p></div></div><p>Segue navigation between views is another possible navigation strategy when the Controller for the new <strong>View</strong> exists in the calling <strong>Controller</strong>, or the same UI controller is used for both of the views (that is, the same <strong>Controller</strong> could have been used for both submit and read-only views in the preceding example).</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec122"/>MVVM</h2></div></div></div><p><strong>MVVM</strong> (<strong>Model-View-ViewModel</strong>), a derivative<a class="indexterm" id="id590"/> of the MVP pattern, provides well-established boundaries <a class="indexterm" id="id591"/>between the UI, business logic, and data. After its emergence, it almost immediately became the main implementation pattern<a class="indexterm" id="id592"/> for <strong>WPF</strong> (<strong>Windows Presentation Foundation</strong>) applications. The data binding features provided by the WPF framework make up the foundation of this mediation pattern.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>Data binding is the terminology used to describe the mechanism which connects data visualization elements from the UI layer (that is, the controls) to other controls or data objects from other tiers. The synchronization between the two actors of the binding is maintained through various events (for example, the <code class="literal">INotifyPropertyChanged</code> interface is used to propagate value change events).</p></div></div><p>In this pattern, the<a class="indexterm" id="id593"/> ViewModel is the main actor, whose responsibility is to control the data flow between the <strong>View</strong> and the <strong>Model</strong>. The outlets, in this architecture, are exposed by the ViewModel and used by the View implementation (as opposed to the iOS MVC architecture). The ViewModel provides these outlets in the form of data elements that can be associated to attributes or states of the UI controls, and also as generic commands that can be used by the <strong>View</strong> controls to respond to user input.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec40"/>Windows Runtime</h3></div></div></div><p>Windows Phone applications, as well as Windows Store applications, natively support data binding for UI controls. This feature makes Windows Phone applications ideal candidates for this<a class="indexterm" id="id594"/> architecture. However, architectural elements should still be implemented by developers according to the requirements of specific projects. There are multiple (open-source or commercial) libraries that can be included as NuGet packages in development projects, including Prism (a cross-platform MVVM library, which was initially a pet project of the Microsoft patterns and practices team, but is now being maintained by the community) and MVVMCross (a cross-platform open source MVVM framework).</p><p>At the core of the MVVM pattern and data binding, we can locate the implementation of a bindable base class. A bindable base provides the implementation of the <code class="literal">INotifyPropertyChanged</code> interface and makes it easier to identify and implement the data elements that will take part in data binding. This interface is used to route value changed events from data items and their properties to UI elements.</p><p>A simple bindable base implementation would look similar to:</p><div><pre class="programlisting">public abstract class BindableBase : INotifyPropertyChanged
{
    protected virtual void SetProperty&lt;T&gt;(ref T property, T value, 
      [CallerMemberName] string propertyName = null)
    {
        if (Equals(property, value)) return;

        property = value;

        OnPropertyChanged(propertyName);
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        var handler = PropertyChanged;
        if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
    }
}</pre></div><p>The implementation<a class="indexterm" id="id595"/> of this class can be used with model data items so that any change can be reflected on the UI:</p><div><pre class="programlisting">public class ModelData : BindableBase
{
    private string m_Property1BackingField = string.Empty;

    public string Property1
    {
        get
        {
            return m_Property1BackingField;
        }
        set
        {
            SetProperty(ref m_Property1BackingField, value);
        }
    }
}</pre></div><p>Now the <code class="literal">ModelData</code> class can already be used as the ViewModel and its bindings provided to <code class="literal">Property1</code>:</p><div><pre class="programlisting">public MainPage()
{
    this.InitializeComponent();

    this.DataContext = new ModelData {Property1 = "Hello MVVM"};
}</pre></div><p>The data binding to an input control on the main page would look similar to this:</p><div><pre class="programlisting">&lt;TextBox Text="{Binding Property1, Mode=TwoWay}"&gt;</pre></div><p>In this binding scenario, we set the binding mode to <code class="literal">TwoWay</code>. This binding type means that any change on this property value, either on the ViewModel or on the user interface (that is, on user input), would be propagated to the UI element, or vice versa.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>Data bindings can be maintained using different modes. The <a class="indexterm" id="id596"/>
<strong>OneTime</strong> binding is used to<a class="indexterm" id="id597"/> update the target property using the source property when the data source changes. This type of binding is generally used by read-only controls. The<a class="indexterm" id="id598"/> <strong>OneWay</strong> binding is used only to update the target property when the source property value changes, whereas<a class="indexterm" id="id599"/> the <strong>TwoWay</strong> mode is for duplex synchronization. Finally, <strong>OneWayToSource</strong> is used only to<a class="indexterm" id="id600"/> update the source property if there are any changes on the target property.</p></div></div><p>Data bindings are not limited to values from and to ViewModel properties. Bindable properties of user controls can also be bridged in this pattern. Moreover, bindable properties of user controls include behavioral and style attributes (for example, the <code class="literal">IsEnabled</code> property of a <code class="literal">TextBox</code> user controls). Additional bindable properties can be provided to intrinsic or derived user controls using attached and/or dependency properties.</p><p>Command binding is another concept which provides a decoupled way to associate user action controls (for example, <code class="literal">Button</code>) with executable elements on the data context (that is, the ViewModel). In order for a user control to be bound to a command, the user control should implement a bindable command attribute and the ViewModel should provide an <code class="literal">ICommand</code> implementation of a specific action. The <code class="literal">ICommand</code> interface is a simple interface containing a <code class="literal">CanExecute</code> property, an associated <code class="literal">CanExecuteChanged</code> event (which is generally bound to the <code class="literal">IsEnabled</code> property of the user control), and the <code class="literal">Execute</code> method.</p><p>A simple command implementation that will validate the data model from the previous example and then execute would look similar to the following implementation (note that MVVM frameworks generally provide a generic <code class="literal">Command</code> class, which accepts delegates and/or lambdas for <code class="literal">Execute</code> and <code class="literal">CanExecute</code> methods):</p><div><pre class="programlisting">public class SubmitCommand : ICommand
{
    private readonly ModelData m_DataContext;

    public SubmitCommand(ModelData dataContext)
    {
        m_DataContext = dataContext;

        m_DataContext.PropertyChanged += (sender, args) =&gt;
        {
            if(args.PropertyName == "Property1" &amp;&amp; 
                CanExecuteChanged !=null) 
                CanExecuteChanged(this, null);
        };
    }

    public bool CanExecute(object parameter)
    {
        return m_DataContext.Property1.Length &gt; 5;
    }

    public void Execute(object parameter) {
        // TODO:
    }

    public event EventHandler CanExecuteChanged;
}</pre></div><p>With this<a class="indexterm" id="id601"/> implementation (either public or a nested class of the data model defined previously), we can initialize and expose the command when a new <code class="literal">ModelData</code> class is initialized:</p><div><pre class="programlisting">public ModelData()
{
    Submit = new SubmitCommand(this);
}

public ICommand Submit { get; set; }</pre></div><p>Finally, the binding for this command in XAML markup would look similar to:</p><div><pre class="programlisting">&lt;Button Content="Submit" Command="{Binding Submit}"&gt;&lt;/Button&gt;</pre></div><p>If we were to use the MVVM pattern to implement the previous form submission scenario, we can observe the implementation of both data and command bindings. We could implement a ViewModel class that is responsible for loading and submitting a bindable data item. The view would have the bindings to the ViewModel properties and commands, as well as bindings to the data item itself.</p><div><img alt="Windows Runtime" src="img/B04693_09_19.jpg"/><div><p>Figure 19: MVVM implementation of the form submission scenario</p></div></div><p>In this design, <code class="literal">SubmitCommand</code> is used both to submit the user input to the <strong>Model</strong> and to validate the form itself (using the <code class="literal">CanExecute</code> method). The <code class="literal">IsReadOnly</code> property of the ViewModel is<a class="indexterm" id="id602"/> bound to the <code class="literal">IsReadOnly</code> properties of the text fields and the <code class="literal">Visibility</code> property of the submit button (in read-only mode, instead of the submit button, the submitted label should be displayed), possibly with an <code class="literal">IValueConverter</code> (an interface used in two-way conversions between bound properties in data-binding scenarios).</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>Value converters implement the <code class="literal">IValueConverter</code> interface to apply custom logic to the binding process. They are generally used as adapters for the CLR type of the target property and the source property (for example, if the data model property type was a <code class="literal">string</code> defining a certain color, we would need to convert/parse this value to <code class="literal">SolidColorBrush</code> or similar to assign it to visual elements' properties).</p></div></div><p>Besides the loose coupling and modularity achieved by using MVVM, the pseudo-finite automaton provided by the ViewModel allows developers to easily recreate different data states used by the view and implement unit tests without much hassle.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec41"/>MVVM on Xamarin.iOS and Xamarin.Android</h3></div></div></div><p>In Xamarin projects, in order to create a uniform structure between the applications for different platforms and maximize code sharing, it is a widely accepted implementation principle to use the MVVM pattern solution-wide. Since data bindings and commanding pattern<a class="indexterm" id="id603"/> implementations are not natively supported on iOS and Android, using an MVVM framework that supports<a class="indexterm" id="id604"/> cross-platform development with Xamarin can be a solution.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>It is important to mention that iOS and Cocoa have the concept of key-value observing, and a binding-like implementation can be applied to some extent.</p></div></div><p>On Xamarin.iOS and Xamarin.Android, bindings are generally provided through the extensions to <code class="literal">UIViewController</code> (on iOS) and <code class="literal">Activities</code> (on Android). In iOS, this implementation strategy transforms the <strong>View</strong> and <strong>Controller</strong> from MVC architecture into mere <strong>View</strong> implementations, while the ViewModel, conceptually, replaces the <strong>Model</strong> implementation. Bindings to the ViewModel are initialized in the application lifecycle events of the <code class="literal">UIViewControllers</code> and <code class="literal">Activities</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec42"/>MVVM with Xamarin.Forms</h3></div></div></div><p>The data binding feature of Xamarin.Forms is an implementation/port of the WPF data bindings, so XAML bindings are supported for both data and commands. The main difference between <a class="indexterm" id="id605"/>Xamarin.Forms and Windows Runtime is that in Windows Store applications, binding context for a user control or a container is configured using the <code class="literal">DataContext</code> property, whereas in Xamarin.Forms, the <code class="literal">BindingContext</code> property is used for the same purpose. Xamarin.Forms additionally provides generic command implementation classes (namely, <code class="literal">Command</code> and <code class="literal">Command&lt;T&gt;</code>) which allow developers to expose commands without having to implement the <code class="literal">ICommand</code> interface in nested classes for the ViewModels.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec58"/>Summary</h1></div></div></div><p>In cross-platform projects, with or without Xamarin.Forms, it is advisable to maintain the View elements as thin and devoid of static and/or sharable elements as possible. As discussed in this chapter, each Xamarin target platform supports resource and asset management in particular ways. These methodologies can be expanded to share static resources between the platform-specific projects by using linked resources and/or using special build techniques.</p><p>Architectural patterns, imposed by the platform or otherwise, can also be employed either at the beginning of the project or as the project matures through iterations. MVC and MVVM, as well as MVP, patterns help reduce the sharable logic components on the View, creating a more loosely-coupled project structure (see quality identifiers in <a class="link" href="ch01.html" title="Chapter 1. Developing with Xamarin">Chapter 1</a>, <em>Developing with Xamarin</em>).</p><p>After having covered different aspects of the Xamarin framework and UI-related concepts, in the next part of the book, we will discuss <strong>Application Lifecycle Management</strong> (<strong>ALM</strong>)-related topics to create an efficient development pipeline for individuals or teams dealing with Xamarin projects.</p></div></body></html>