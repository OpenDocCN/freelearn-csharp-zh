- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Databases and Planning for Data-Rich Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we established a foundational SaaS application consisting
    of a straightforward database with a single table. This database was connected
    to an API, and we showcased secure multi-tenancy implementation using SQL Server,
    .NET, and Entity Framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve deeper into the intricacies of the database layer
    and its interactions with Entity Framework. As the bedrock of an entire application,
    the design choices made at the database level will influence every subsequent
    layer in the stack. We will explore how to construct and design resilient databases
    for data-intensive SaaS applications. You will acquire a variety of skills, such
    as normalization, indexing, performance optimization, as well as techniques to
    test and maintain the database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Once deployed, a database often represents the most demanding aspect of a system
    to keep current. The database is inherently stateful, and it is crucial to prevent
    data loss or corruption during updates. In addition to learning about database
    design and construction, we will examine several strategies to maintain and update
    the database, with an emphasis on the tools provided by Entity Framework.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The expertise you gain in this chapter is vital to create scalable and dependable
    SaaS applications. By mastering the methods discussed in this chapter, you will
    be capable of designing databases optimized for performance, scalability, and
    maintainability, thereby facilitating the development and maintenance of your
    SaaS applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The importance of data in a SaaS application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a database using SQL Server and Entity Framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the database and data-rich applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working in production, keeping your database up to date, and keeping your data
    safe
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data and a database are the foundations of a SaaS application. Let’s start by
    considering how important they are.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The importance of data in a SaaS application
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a SaaS application, a database serves as the foundation for the application.
    The database (or more accurately, the data contained within) is what drives the
    application and where the primary value for users lies. A SaaS application without
    data is just an empty shell!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: One of the key considerations when building a SaaS application is the type of
    data that the application will store and how it will be used. Will the application
    be storing large amounts of structured data, such as customer records or transaction
    histories? Or will it be storing unstructured data, such as the data underpinning
    a social media feed? The type of data will have a significant impact on the design
    and architecture of the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建SaaS应用程序时，一个关键的考虑因素是应用程序将存储的数据类型以及其使用方式。应用程序是否会存储大量结构化数据，例如客户记录或交易历史？或者它是否会存储非结构化数据，例如支撑社交媒体数据流的数据？数据类型将对应用程序的设计和架构产生重大影响。
- en: Another important consideration is how the data will be accessed and manipulated.
    Will the data be accessed by a large number of users simultaneously, or will it
    only be accessed by a few users at a time? Will the data be updated frequently,
    or will it be mostly static? These factors will influence the choice of database
    technology and the design of the data model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是数据如何被访问和操作。数据是否会被大量用户同时访问，或者只是由少数用户一次访问？数据是否会被频繁更新，或者主要是静态的？这些因素将影响数据库技术选择和数据模型设计。
- en: In a SaaS application, it is also important to consider how the data will be
    shared among different tenants. As we discussed in the previous chapter, the data
    for each tenant must be kept separate and secure, while still allowing for efficient
    access to and manipulation of the data that pertains to the current tenant. This
    requires careful planning and design of a data model and database schema.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在SaaS应用程序中，考虑数据如何在不同的租户之间共享也很重要。正如我们在上一章中讨论的，每个租户的数据必须保持独立和安全，同时仍然允许高效地访问和操作与当前租户相关的数据。这需要仔细规划和设计数据模型和数据库模式。
- en: It is also important to consider scalability. While a SaaS application may well
    start off with a small user base and thus a comparatively low number of reads/writes,
    this can change very quickly as the user base increases! It’s important to design
    a data model and schema in a way that allows the application to grow. Similarly,
    the amount of data that is transmitted over the internet must be managed. Bandwidth
    is not free nor unlimited, and in data-intensive applications, this can become
    a burden.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要考虑可扩展性。虽然SaaS应用程序可能一开始用户基础较小，因此读写次数相对较低，但随着用户基础的快速增长，这可能会迅速改变！设计数据模型和模式时，重要的是要确保应用程序可以扩展。同样，通过互联网传输的数据量也必须得到管理。带宽不是免费的，也不是无限的，在数据密集型应用程序中，这可能会成为一种负担。
- en: The importance of data is not limited to technical considerations. Data plays
    a crucial role in the user experience. The way that data is presented, organized,
    and accessed can significantly impact the usability of an application. While this
    is, of course, dependent on the user interface, the structure of the underlying
    data, and the ease and speed with which it can be queried, will be noticed at
    the frontend by end users.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的重要性不仅限于技术考虑。数据在用户体验中扮演着至关重要的角色。数据的表现方式、组织方式和访问方式可以显著影响应用程序的可用性。当然，这取决于用户界面、底层数据的结构和查询的便捷性和速度，这些都会在前端被最终用户注意到。
- en: For a company building an application and hosting a database, data can be a
    key source of revenue. Some SaaS applications monetize their data by selling access
    to information about consumer demographics and buying habits to businesses looking
    to target specific market demographics. This data is often collected and classified
    by machine learning algorithms, allowing for insights about the users and creators
    of the data. With this valuable information, businesses can create targeted marketing
    campaigns and improve their products and services to better meet the needs of
    their customers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建应用程序并托管数据库的公司来说，数据可以是一个关键的收入来源。一些SaaS应用程序通过向寻求针对特定市场细分市场的企业销售有关消费者人口统计和购买习惯的信息来货币化其数据。这些数据通常由机器学习算法收集和分类，从而可以深入了解数据的用户和创建者。有了这些宝贵的信息，企业可以创建有针对性的营销活动，并改进其产品和服务，更好地满足客户的需求。
- en: Data is important for a myriad of reasons, and so it should go without saying
    that maintaining data security and compliance is a crucial aspect of building
    a successful SaaS application. It is the responsibility of the SaaS provider to
    ensure that sensitive data, such as financial or personal information, is kept
    secure and compliant with relevant regulations. To achieve this, the SaaS provider
    may need to implement various security measures, such as encryption and access
    controls, to protect the data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对于众多原因来说都很重要，因此维护数据安全和合规性是构建成功的 SaaS 应用程序的一个关键方面。确保敏感数据，如财务或个人信息，得到安全保护并符合相关法规是
    SaaS 提供商的责任。为了实现这一点，SaaS 提供商可能需要实施各种安全措施，如加密和访问控制，以保护数据。
- en: Data and the database are absolutely critical parts of a SaaS application, and
    it’s important for SaaS developers to have a strong understanding of how to design,
    build, and maintain data-rich applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和数据库是 SaaS 应用程序中绝对关键的部分，对于 SaaS 开发人员来说，了解如何设计、构建和维护数据丰富的应用程序非常重要。
- en: Building a database
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建数据库
- en: In this section, we will focus on using SQL Server and Entity Framework to design
    and construct a database for your SaaS application. We will cover a range of topics,
    including choosing the right database technology, designing an efficient and scalable
    data model with Entity Framework, and implementing database security and compliance
    measures with SQL Server. By the end of this section, you will have a solid understanding
    of how to build a robust and reliable database for your SaaS application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点介绍使用 SQL Server 和 Entity Framework 设计和构建您的 SaaS 应用程序的数据库。我们将涵盖一系列主题，包括选择合适的数据库技术、使用
    Entity Framework 设计高效且可扩展的数据模型，以及使用 SQL Server 实施数据库安全性和合规性措施。在本节结束时，您将深入了解如何为您的
    SaaS 应用程序构建一个强大且可靠的数据库。
- en: Types of database
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库类型
- en: Because this is a book focused on making use of the Microsoft stack, I will
    focus on SQL Server as the underlying database platform, and I will use Entity
    Framework to interact with the database. SQL Server is a **relational database**,
    which is a type of database that stores data in the form of tables, with rows
    representing individual records and columns representing data attributes. It is
    a very structured way to store data, and the “shape” of the data must be known
    in advance and built into the application at design time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一本专注于利用 Microsoft 堆栈的书籍，所以我会重点关注 SQL Server 作为底层数据库平台，并使用 Entity Framework
    与数据库交互。SQL Server 是一种 **关系数据库**，它以表的形式存储数据，其中行代表单个记录，列代表数据属性。这是一种非常结构化的数据存储方式，数据的“形状”必须在设计时预先知道并构建到应用程序中。
- en: 'While we will focus on SQL Server and, therefore, relational data, it is worth
    briefly considering the alternatives, which are outside the scope of this book.
    Some of the following alternatives may be worth further investigation if you have
    a specific use case that may require something other than relational data:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将重点关注 SQL Server 以及因此关系数据，但简要考虑替代方案是有价值的，这些替代方案超出了本书的范围。如果您有特定的用例可能需要除关系数据之外的数据，以下的一些替代方案可能值得进一步研究：
- en: '**Document databases**: A document database is a type of database that stores
    data in the form of documents. In this context, a document is data that is typically
    made up of key-value pairs and is designed to be scalable and flexible. In a document
    database, the structure or shape of the data will not be set when the database
    is designed, making it a good choice to store and query large volumes of data
    with diverse structures.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档数据库**：文档数据库是一种以文档形式存储数据的数据库类型。在这个上下文中，文档是由键值对组成的数据，旨在可扩展和灵活。在文档数据库中，数据的结构或形状在数据库设计时不会被设定，这使得它成为存储和查询具有不同结构的大量数据的良好选择。'
- en: '**Graph databases**: These databases store data in the form of nodes (representing
    data entities) and edges (representing relationships between nodes). They are
    often used in applications that need to represent complex relationships between
    data entities, such as social networks or recommendation engines.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图数据库**：这些数据库以节点（表示数据实体）和边（表示节点之间的关系）的形式存储数据。它们通常用于需要表示数据实体之间复杂关系的应用程序中，例如社交网络或推荐引擎。'
- en: '**Key-value stores**: These databases store data in the form of key-value pairs,
    where the key is used to identify the data and the value is the data itself. They
    are often used for simple data storage and retrieval scenarios where the data
    does not need to be queried or indexed. This is similar to a document database
    but more limited in that it is only really suitable for simple use cases.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值存储**：这些数据库以键值对的形式存储数据，其中键用于标识数据，值是数据本身。它们通常用于简单的数据存储和检索场景，其中数据不需要查询或索引。这与文档数据库类似，但更有限，因为它仅真正适用于简单的用例。'
- en: '**In-memory databases**: These databases store data in memory, rather than
    on disk. They are often used for applications that require fast read and write
    access to data, such as online gaming or financial applications. Note that in-memory
    databases can also be used to help test databases. These are two separate use
    cases and should not be confused.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存数据库**：这些数据库将数据存储在内存中，而不是磁盘上。它们通常用于需要快速读写数据访问的应用程序，例如在线游戏或金融应用程序。请注意，内存数据库也可以用于帮助测试数据库。这两个用例是分开的，不应混淆。'
- en: '**Time-series databases**: These databases are designed specifically for storing
    and querying time-stamped data, such as sensor readings or financial transactions.
    They are often used in applications that need to analyze data over time.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间序列数据库**：这些数据库专门设计用于存储和查询带时间戳的数据，如传感器读数或金融交易。它们通常用于需要分析随时间变化数据的程序。'
- en: In this chapter, we will focus on SQL Server, which is a relational database.
    We will interact with the database using a tool that Microsoft developed specifically
    for this purpose – namely, Entity Framework.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于SQL Server，这是一个关系型数据库。我们将使用微软专门为此目的开发的工具与数据库进行交互——即实体框架（Entity Framework）。
- en: What is ACID?
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是ACID？
- en: 'When working with databases – and particularly relational databases – you will
    often come across the acronym **ACID**. This refers to the four properties of
    a database transaction – namely, atomicity, consistency, isolation, and durability:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数据库（尤其是关系型数据库）一起工作时，你经常会遇到**ACID**这个缩写。这指的是数据库事务的四个属性——即原子性、一致性、隔离性和持久性：
- en: '**Atomicity**: A transaction is treated as a single, indivisible unit of work,
    and either all its operations are completed or none of them are'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：事务被视为一个单一、不可分割的工作单元，要么所有操作都完成，要么一个都不完成'
- en: '**Consistency**: The transaction brings the database from one valid state to
    another, preserving database invariants and constraints'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：事务将数据库从一个有效状态转换到另一个有效状态，保持数据库的不变性和约束'
- en: '**Isolation**: The concurrent execution of transactions results in a system
    state that would be obtained if transactions were executed serially, in some order'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：事务的并发执行会导致一个系统状态，这个状态就像事务按某种顺序串行执行一样'
- en: '**Durability**: Once a transaction has been committed, its changes to the database
    persist and survive future system failures'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：一旦事务被提交，其对数据库的更改将持久存在并能够生存未来的系统故障'
- en: These properties are a set of properties that are guaranteed by a database management
    system to ensure the reliability and consistency of data stored in a database.
    ACID is most commonly associated with **relational database management systems**
    (**RDBMS**), such as Oracle, MySQL, PostgreSQL, and Microsoft SQL Server. However,
    some newer databases, such as NoSQL databases and NewSQL databases, may also provide
    ACID guarantees, although they may have different levels of consistency and durability.
    The level of ACID support depends on the specific database technology and how
    it is implemented and configured.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性是一组由数据库管理系统保证的属性，以确保数据库中存储数据的可靠性和一致性。ACID最常与**关系型数据库管理系统**（**RDBMS**）相关联，例如Oracle、MySQL、PostgreSQL和Microsoft
    SQL Server。然而，一些较新的数据库，如NoSQL数据库和新SQL数据库，也可能提供ACID保证，尽管它们可能具有不同的一致性和持久性级别。ACID支持的水平取决于特定的数据库技术以及它的实现和配置。
- en: ACID is generally associated with transactions in relational databases, and
    less commonly so in NoSQL or document databases. In this chapter, and indeed throughout
    this book, we will focus on SQL Server, a relational database that provides support
    for ACID transactions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ACID通常与关系型数据库中的事务相关联，而在NoSQL或文档数据库中则较少见。在本章中，实际上在整个书中，我们将专注于SQL Server，这是一个提供ACID事务支持的关系型数据库。
- en: Entity Framework
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体框架（Entity Framework）
- en: Entity Framework is an **object-relational mapping** (**ORM**) tool that allows
    developers to interact with a database using .NET objects. It simplifies the process
    of accessing and manipulating data by eliminating the need to write SQL queries
    and manually map data to objects. Entity Framework is well-suited for developers
    who are familiar with .NET and want to streamline their data access and manipulation
    tasks, which makes it an excellent choice for study in this .NET-focused book!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 是一个 **对象关系映射**（**ORM**）工具，它允许开发者使用 .NET 对象与数据库进行交互。它通过消除编写
    SQL 查询和手动将数据映射到对象的需求来简化访问和操作数据的过程。Entity Framework 对于熟悉 .NET 并希望简化数据访问和操作任务的开发者来说非常适合，这使得它成为本以
    .NET 为重点的书籍中学习的绝佳选择！
- en: While we will focus on SQL Server, one of the big benefits of using Entity Framework
    is its ability to generate database-agnostic code, allowing developers to change
    a database platform or support multiple database platforms without having to significantly
    rewrite their code. This feature is of particular interest when dealing with a
    multi-tenant SaaS application, where certain customers may mandate a specific
    database platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们会专注于 SQL Server，但使用 Entity Framework 的一大好处是它能够生成数据库无关的代码，这使得开发者能够在不显著重写代码的情况下更改数据库平台或支持多个数据库平台。当处理多租户
    SaaS 应用程序时，这一特性尤其有趣，因为某些客户可能要求使用特定的数据库平台。
- en: Entity Framework wraps up a lot of the complexities associated with writing
    code that interacts with a database. Concepts such as lazy loading, change tracking,
    and automatic migration of data and schema changes are handled out of the box.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 包含了与编写与数据库交互的代码相关的许多复杂性。例如，懒加载、更改跟踪以及数据模式和架构更改的自动迁移等概念都是开箱即用的。
- en: Unlike many other ORMs, Entity Framework supports several different approaches
    to interacting with a database, including the traditional database-first approach,
    the code-first approach, and the model-first approach. This gives developers the
    flexibility to choose the approach that best fits their needs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他 ORM 不同，Entity Framework 支持与数据库交互的几种不同方法，包括传统的数据库优先方法、代码优先方法和模型优先方法。这为开发者提供了选择最适合他们需求的方法的灵活性。
- en: Entity Framework is a powerful tool that can greatly enhance the productivity
    of experienced .NET developers by simplifying data access and manipulation tasks,
    and it is highly recommended when approaching a project that will be highly dependent
    on a data platform – such as a SaaS application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 是一个强大的工具，可以通过简化数据访问和操作任务来大大提高经验丰富的 .NET 开发者的生产力，并且在处理高度依赖于数据平台的项目（如
    SaaS 应用程序）时，它被高度推荐。
- en: It is out of the scope of this chapter to cover all of the possible ways to
    use Entity Framework, so I will focus on one – Code First.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的范围不包括所有可能的 Entity Framework 使用方式，因此我将专注于其中一种——代码优先。
- en: Code first with Entity Framework
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Entity Framework 的代码优先
- en: Code first with Entity Framework is a development approach that allows developers
    to create their .NET application’s data model using C# code, rather than designing
    a database using a UI such as SQL Server Management Studio, or through writing
    and maintaining SQL scripts. This approach is particularly useful for developers
    who prefer to work with code and want more control over their application’s data
    model. With code first, developers can define their data model using classes and
    properties in their code, and Entity Framework will handle the creation and management
    of the underlying database. This approach allows developers to focus on the data
    model and business logic of their application, without having to worry about the
    implementation details of the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Entity Framework 的代码优先是一种开发方法，它允许开发者使用 C# 代码创建他们的 .NET 应用程序的数据模型，而不是使用 SQL
    Server Management Studio 等用户界面来设计数据库，或者通过编写和维护 SQL 脚本来实现。这种方法对于喜欢使用代码并且希望对应用程序的数据模型有更多控制的开发者来说特别有用。使用代码优先，开发者可以使用代码中的类和属性来定义他们的数据模型，而
    Entity Framework 将处理底层数据库的创建和管理。这种方法允许开发者专注于应用程序的数据模型和业务逻辑，而无需担心数据库的实现细节。
- en: We saw this approach in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056). When
    the database was configured, we didn’t write a single line of SQL code – we wrote
    a C# class called `GoodHabits.cs` and defined the data structure in C# code. We
    then used two commands on the Entity Framework CLI that updated the database.
    In [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), we modified this file to facilitate
    multi-tenancy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures with Entity Framework
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Traditionally, it has been very common to use stored procedures when designing
    a database. While this is still a very valid and useful approach to database development,
    it is increasingly being seen as best practice to use an ORM such as Entity Framework
    to access and manipulate data in a database, rather than using stored procedures.
    There are a few reasons for this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework allows you to work with objects and entities in your code,
    rather than having to write raw SQL queries. This gives you a higher level of
    abstraction, which can make it easier to develop an application. With this approach,
    you can build your database in a familiar object-orientated way, which can make
    it easier to reason about and maintain. Entity Framework is able to interpret
    relationships between objects and create database relationships from C# code.
    If you create logic and then model it in a stored procedure, Entity Framework
    loses sight of that logic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Another huge benefit of using Entity Framework is that many database platforms
    are supported out of the box. However, logic in stored procedures is typically
    not transferrable between database platforms and would have to be built and maintained
    separately on a per-platform basis.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Entity Framework has a number of testing tools available to use. Using
    stored procedures and triggers will require specific testing infrastructure and
    techniques, and this may make it harder to test an application because logic is
    split between code and the database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain cases when using stored procedures or triggers may be beneficial.
    These include the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: When working with very large datasets, or in situations where performance is
    critical, it may be advantageous to execute logic directly against a database
    by way of a stored procedure
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases where data security is a concern, stored procedures can help to prevent
    unauthorized access to data by limiting the types of queries that can be run against
    a database.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases where you want to abstract the data access layer of your application
    from the underlying database schema, using stored procedures can help to decouple
    the two. This can be particularly useful in situations where a database schema
    may change frequently.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand your specific use case when deciding whether or
    not to make use of stored procedures in your database. For the demo application,
    we will continue to use Entity Framework to manipulate and access the database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Normalization
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Database normalization is the process of organizing a database in a way that
    reduces redundancy and improves data integrity. It involves dividing the database
    into smaller, more focused tables that are related to each other through relationships.
    The goal of normalization is to eliminate redundancy and ensure that each piece
    of data is stored in only one place in the database. Normalization is an important
    step in the database design process and can greatly improve the performance and
    reliability of a database.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework supports the process of normalizing a database in several ways.
    One of the main ways it does this is through the creation and modification of
    tables and relationships within the database. This allows developers to structure
    their data in a way that reduces redundancy and improves data integrity – a key
    goal of normalization. Entity Framework also includes support for the automatic
    migration of data changes. This means that when developers make changes to their
    data model, those changes are automatically reflected in the underlying database.
    This can be particularly useful when normalizing a database, as it allows developers
    to easily update the structure of their data without having to manually migrate
    data between tables.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Entity Framework’s LINQ query syntax allows developers to easily
    retrieve and manipulate data from a normalized database. It supports a wide range
    of operations, including filtering, sorting, and aggregation, making it easy to
    work with data from multiple tables. Finally, Entity Framework’s support for eager
    and lazy loading allows developers to optimize the performance of their application
    by only loading the data they need on demand, rather than loading all data upfront.
    This can be harder with a poorly normalized database. Overall, Entity Framework
    provides a number of tools and features to help developers normalize their databases
    and improve the performance and reliability of their applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: There are several normal forms that can be used to measure the degree of normalization
    in a database. The first three (called 1NF, 2NF, and 3NF) are used to address
    redundancy in a database and are generally considered to be good practice in most
    instances.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the first three, the additional normal forms are designed to address
    specific types of problems; however, these are less commonly used and are considered
    out of the scope of this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that achieving higher normal forms does not always constitute
    a better-designed database. It is generally better to design a database that is
    efficient and performant around a specific use case than to adhere blindly to
    the normalization rules. That said, achieving 3NF is usually a good starting point
    from which to work, and further normalization, or indeed denormalization, can
    follow from there.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Let’s illustrate this with an example. Let’s consider adding a user table to
    the `GoodHabit` example we developed in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the first normal form (1NF), all attributes in the database must
    be atomic. This means that each column in the database should contain a single
    value. We could design a user table that looked like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Poorly normalized data](img/B19343_Figure_4.1.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Poorly normalized data
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding table shows poorly normalized data. The **Name** column contains
    two pieces of information (first and last name), which may be useful to use separately.
    The **Habits** column contains a comma-separated list of data. This can be improved
    upon like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Data in the first normal form (1NF)](img/B19343_Figure_4.2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Data in the first normal form (1NF)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table shows the data in 1NF. Each attribute holds a single value.
    We now have a row in the database for each habit, but the users appear multiple
    times. If Dave decided that he would prefer to be called David, we would have
    to update the data in multiple places.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'To move this data into the second normal form, we need to break the data into
    two tables – one for the user, and one for the habit. We will need a third table
    to link the users to the habits they are going to work on:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Data in the second normal form (2NF)](img/B19343_Figure_4.3.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Data in the second normal form (2NF)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'This is much better, and we can start to see that this could be queried and
    updated in a very tidy way. There is one further improvement we could make though.
    The **Habit** table has a **Frequency** column that is indirectly dependent on
    the ID column. This is called a transitive dependency. In order to move this data
    to the third normal form, we must break this transitive dependency by adding a
    **Frequency** table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Data in the third normal form (3NF)](img/B19343_Figure_4.4.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Data in the third normal form (3NF)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The third normal form is sufficient at this stage, and we’ll take this no further.
    You can see that all of the data is separated into individual tables, and linked
    through foreign key constraints to the **UserHabit** table. This allows efficient
    querying and updating of the data in the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and performance optimization
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Indexing a database means creating a separate data structure that is used to
    improve the performance of certain types of queries. Indexes are typically created
    on specific columns within a table, allowing the database to quickly locate the
    rows that match given criteria. For example, if you have a large table of customer
    records and you frequently search for customers by their last name, you could
    create an index on the `last_name` column to improve the performance of those
    searches. Indexes can significantly improve the performance of certain types of
    queries, but they also have a cost in terms of storage space and maintenance.
    As a result, it is important to carefully consider which columns should be indexed
    and to balance the benefits of indexing with the costs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To do indexing with Entity Framework, developers can use a variety of tools
    and approaches. One way to do indexing is to use the Entity Framework Fluent API,
    which allows developers to define indexes on their entities using code. To create
    an index using the Fluent API, developers can use the `HasIndex` method and specify
    the properties that should be included in the index. Another option is to use
    Entity Framework Designer, a visual tool that allows developers to design their
    data model using a graphical interface. The Designer includes the ability to define
    indexes on entities by right-clicking on an entity and selecting **Add Index**.
    Finally, developers can use database migrations to create indexes on their entities
    by adding the appropriate code to their migration files.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Configuring indexes with Entity Framework is straightforward!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider the `GoodHabit` table that we developed in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056),
    we used the following C# code to define the structure of the table:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can add an index to the `Name` column by decorating the class with an attribute
    like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will instruct the database platform to create an index for the `Name`
    column. We could do the same for the `ID` column in the same way. You can create
    a composite index by setting the attribute as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you need to set the sort order of the indexes, you can use one of the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want to name your index, you can use the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is a great deal of flexibility provided by Entity Framework, and it is
    out of the scope of this book to cover all of it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: You can get more information about it at [https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations](https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We will now build out a database for the example application, being mindful
    of what we have just learned.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Designing a database schema using Entity Framework code first
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start designing a database, let’s stop and think about what our requirements
    are:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The database will store user information to identify individual users
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can add habits to the database to track their progress and achieve their
    goals
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can log progress for each habit and set reminders to perform it
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can set goals for their habits, such as running a certain number of miles
    or saving a certain amount of money
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database can support users in achieving their goals and improving their
    overall well-being by tracking and managing their habits
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows a diagram representing the database that we just
    configured. This shows the tables, columns, and relationships between the tables:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – A suggested database schema](img/B19343_Figure_4.5.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – A suggested database schema
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows a schema that can meet the requirements defined
    previously.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Creating the entity classes
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we are using Entity Framework code first, we will build this database by
    writing C# code. Create the entity classes with the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We already have the `Habit` entity, but we will update it with some additional
    properties. Copy the following code into `Habit.cs`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, `Goal.cs` should look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Progress.cs` should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Reminder.cs` should look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, `User.cs` should look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following lines of code into the `GoodHabitsDbContext` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can create the migration by running the following in the console:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The migrations will be automatically applied to the database when `HabitService`
    runs, so simply run the Habit service to push the changes to the database.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Using the Server Explorer to view the database, we can see that the schema has
    been successfully applied!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The schema applied to the database](img/B19343_Figure_4.6.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The schema applied to the database
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows that the schema has successfully migrated to the
    database.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Testing data-rich applications
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing the database layer of a SaaS application is an essential part of the
    development process. A database is a critical component of any application, as
    it stores and manages the data that an application relies on. Ensuring that the
    database is working correctly is crucial for the overall stability and performance
    of the application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: There are several challenges that you may encounter when testing the database
    layer of your application. One challenge is ensuring that the database schema
    is correct and that the data is stored and retrieved correctly. Another challenge
    is ensuring that the database is properly optimized for performance, particularly
    if you are dealing with large amounts of data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different techniques that you can use to test the database
    layer of your application. One common technique is to use unit tests to verify
    that individual database functions are working correctly. Another technique is
    to use integration tests to ensure that the database is working correctly in conjunction
    with the rest of the application. You may also want to use performance tests to
    ensure that the database is able to handle large amounts of data without experiencing
    any issues.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are a type of automated testing that is used to verify the behavior
    of individual units of code, such as individual functions or methods. In contrast
    to unit tests, integration tests focus on testing how different parts of an application
    work together as a system. Integration tests are used to ensure that different
    components of the application are able to communicate and interact with one another
    correctly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种自动化测试类型，用于验证单个代码单元的行为，例如单个函数或方法。与单元测试不同，集成测试关注于测试应用程序的不同部分作为一个系统如何协同工作。集成测试用于确保应用程序的不同组件能够正确地相互通信和交互。
- en: Upgrading a database
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级数据库
- en: Upgrading a database with Entity Framework involves making changes to the database
    schema and data to reflect changes in an application. This can include adding
    new tables or columns, modifying existing tables or columns, and migrating data
    from one format to another.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Entity Framework升级数据库涉及对数据库架构和数据进行更改，以反映应用程序中的更改。这可能包括添加新表或列、修改现有表或列，以及将数据从一种格式迁移到另一种格式。
- en: There are several approaches that you can take when upgrading a database with
    Entity Framework. One approach is to use the `DbMigrations` class to automatically
    generate and execute the necessary SQL commands to update the database schema.
    This can be convenient, as it allows you to make changes to the database using
    a high-level API, rather than having to write raw SQL commands. However, it can
    also be less flexible than some other approaches, as it relies on Entity Framework
    to generate the SQL commands, and that may not always produce optimal results.
    This is the approach that we will take in this chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Entity Framework升级数据库时，你可以采取几种方法。一种方法是用`DbMigrations`类自动生成和执行必要的SQL命令来更新数据库架构。这可能是方便的，因为它允许你使用高级API对数据库进行更改，而不是必须编写原始SQL命令。然而，它可能不如其他方法灵活，因为它依赖于Entity
    Framework生成SQL命令，而这可能并不总是产生最佳结果。这是我们本章将采用的方法。
- en: It is worth being aware of a popular alternative approach, which is to use Entity
    Framework’s `DbContext` class to manually execute SQL commands to update a database.
    This can be more flexible, as you have complete control over the SQL commands
    that are executed. However, it can also be more time-consuming and error-prone,
    as you have to write and debug the SQL commands yourself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有一个流行的替代方法，即使用Entity Framework的`DbContext`类手动执行SQL命令来更新数据库。这可以更加灵活，因为你可以完全控制执行的SQL命令。然而，这也可能更加耗时和容易出错，因为你必须自己编写和调试SQL命令。
- en: Finally, it is, of course, possible to update a database separately from Entity
    Framework using any preferred method, which most likely involves executing SQL
    scripts.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当然，你可以使用任何首选方法独立于Entity Framework更新数据库，这很可能涉及执行SQL脚本。
- en: I think that it is generally preferable to make use of the built-in migration
    tools and allow Entity Framework to do the heavy lifting for us.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为通常最好使用内置的迁移工具，并让Entity Framework为我们做繁重的工作。
- en: We saw this process in practice twice – when we created the initial migration
    in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056), and when we just updated the
    schema.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实践中看到了这个过程两次——当我们创建[*第二章*](B19343_02.xhtml#_idTextAnchor056)中的初始迁移时，以及当我们刚刚更新架构时。
- en: 'If you look at the `Migrations` folder in the `Database` project, you should
    see the following files:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看“数据库”项目中的“迁移”文件夹，你应该会看到以下文件：
- en: '![Figure 4.7 – The Migrations folder](img/B19343_Figure_4.7.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 迁移文件夹](img/B19343_Figure_4.7.jpg)'
- en: Figure 4.7 – The Migrations folder
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 迁移文件夹
- en: In the preceding figure, we can see the `.._InitialSetup.cs` file that contains
    our first pass, the `.._MultiTenant.cs` file that has the modifications that we
    made in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), and the `AdditionalEntities.cs`
    file that we added in this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到包含我们第一次尝试的`.._InitialSetup.cs`文件，包含我们在[*第三章*](B19343_03.xhtml#_idTextAnchor082)中做出的修改的`.._MultiTenant.cs`文件，以及我们在这章中添加的`AdditionalEntities.cs`文件。
- en: 'If you recall, in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056), we added
    the initial migration with the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在[*第二章*](B19343_02.xhtml#_idTextAnchor056)中，我们添加了以下初始迁移：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, when creating the second migration, we used this instead:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在创建第二个迁移时，我们使用了以下方法：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The reason for this is that the work we did in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082)
    to introduce the multi-tenancy has added parameters to the constructor, which
    are defined in the API project. Pointing the migration tool at the API project
    allows it to create migrations via the `HabitService` project.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: If you look into either of these generated classes, you will see two methods,
    named `Up` and `Down`. These methods allow the migration to be added to the database,
    or rolled back.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Applying the migrations
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because of how we have configured the databases for multi-tenancy in [*Chapter
    3*](B19343_03.xhtml#_idTextAnchor082), we do not need to manually update each
    database. However, should you find you need to manually update a database, you
    can use the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Issuing this command will instruct Entity Framework to look in the `Migrations`
    folder and compare the migrations that it finds there with the migrations that
    are present in the database. If there are any additional migrations that have
    not yet been applied to the database, Entity Framework will apply those migrations.
    Let’s take a closer look at the first one we created, called `initial`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code is auto-generated by the migration tool, but it’s perfectly acceptable
    to manually adjust the code here if there is a reason to. We can see two methods
    here. One is called `Up`, and the other `Down`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The `Up` method creates the table in the database, and the `Down` method drops
    the table. This is converted into SQL code, which is issued to the database engine
    when the `database update` command is issued.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: We learned that data is important in a SaaS application. This can be trying
    not only from a technical point of view but also from the point of view of a user,
    as well as the organization building the application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to a technical implementation with Entity Framework, demonstrating
    how to build a database in code using C#, and then automatically generate migrations
    and update the database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about testing strategies and maintaining a database in production.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build out the API layer and start to interact with
    the data structure we previously created. The application will start to take shape!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is Code-First?: [https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx](https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing with Entity Framework: [https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/](https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data-driven culture: [https://www.smartkarrot.com/resources/blog/data-driven-culture/](https://www.smartkarrot.com/resources/blog/data-driven-culture/)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database normalization: [https://www.sqlshack.com/what-is-database-normalization-in-sql-server/](https://www.sqlshack.com/what-is-database-normalization-in-sql-server/)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In what ways can a business monetize data that is present in a SaaS application?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 商业如何货币化SaaS应用程序中存在的数据？
- en: What are the ethical considerations around data monetization?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据货币化有哪些伦理考量？
- en: How are foreign key relationships represented in Entity Framework?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外键关系在Entity Framework中是如何表示的？
- en: What is the difference between a unit test and an integration test?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试和集成测试之间有什么区别？
- en: If I want to roll back migration in a live database, how do I ensure that no
    data is lost?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我想在实时数据库中回滚迁移，我如何确保不丢失任何数据？
