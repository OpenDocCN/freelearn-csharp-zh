- en: Communication Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've spent the first two chapters of this book discussing what makes networks
    hard to program for open communication and device agnosticism. These aspects of
    networks demand standardization, and in this chapter, we'll examine how standards
    provide a common language that the network software can communicate through. First,
    we'll learn about the governing body that defines those standards. We'll learn
    a bit about who they are and what objectives they sought to achieve. Once we understand
    who defined the common architecture of networks, we'll take a deep dive into the
    way they've organized and categorized each tier of the hierarchy of network layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The origin of the current standard for network architecture and a brief history
    of it, as well as some background on the organization that is responsible for
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How application code interacts with networked resources through the application
    layer and what communication standards are provided for that layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How data is communicated out to, or read from, the network on the transport
    layer of the network architecture standard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with [Chapter 1](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml), *Networks
    in a Nutshell,* this will be more of a conceptual examination of the standards
    defined for networks. There is no specific technology as such that is required
    for this book. We''ll be using the same technology for this chapter as we have
    in others: NET Core 2.1 SDK and either Visual Studio Code, or Visual Studio Community
    Edition to use as an IDE.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [Placeholder link]'
  prefs: []
  type: TYPE_NORMAL
- en: The Open Systems Interconnection network stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several steps in the process of sending or receiving a resource from
    a remote source over a network, and each of those steps has been deeply considered
    by the network engineers tasked with executing them. In this section, we'll look
    at whothose network engineers were, and howthey defined a general pattern for
    implementing each step in that process. This section will be all about the OSI,
    and how that specification defines the network stack of a given network device.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly is the Open Systems Interconnection?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to talk about communication protocols, we need to understand how each
    protocol fits into the larger picture of network connectivity, and to do that
    we need a common model for thinking about each step in the process. To that end,
    we have the OSI model for computer and telecommunication networks. This model
    seeks to organize the different steps of standardized communication to or from
    a given device into a tiered model of abstraction layers. Much like the logical
    topologies of a network, which we discussed in [Chapter 1](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml), *Networks
    in a Nutshell, *the OSI model exists on a purely conceptual and abstract level.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, it was defined in such a way as to be useful as a referencewhile
    remaining entirely agnostic as to how any of the tiers defined in the model are
    ultimately implemented at the physical level. In fact, many implementations of
    communications protocols or standards do notcleanly map to the OSI network model.
    However, the model is broadly considered the gold standard, and has been since
    it was formalized in 1984\. So, let's take a look at how that came to be.
  prefs: []
  type: TYPE_NORMAL
- en: The origins of the OSI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The need for a standardized model for network implementations became apparent
    almost as soon as networking became possible. To that end, back in the late 1970s,
    two different organizations for governing standardization in computing set out
    to define such a model. The first of these organizations was the **International
    Organization for Standardization** (**ISO**). The other organization that set
    out to solve the same problem, at roughly the same time, was the **International
    Telegraph and Telephone Consultative Committee** (**CCITT**, initialized from
    the French translation of the name).
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the shortened name for the International Organization for Standardization,
    ISO, is notan initialism of the name of the organization. Instead, since the name
    of the organization would be initialized differently in each language that it
    is recognized, the members chose to shorten the name to ISO. This is in reference
    of the Greek isos, which means equal, and speaks to the goal of the organization
    to bring about equal understanding.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that two organizations sought to define their own model at roughly
    the same time as one another isn't entirely surprising. The problem was faced
    by engineers across a wide array of disciplines, and the lack of standardization
    was quickly becoming a bottleneck to progress in those disciplines. What is surprising,
    however, is how similar the solutions were to one another. Like Leibniz and Newton
    independently inventing calculus, these organizations incidentally arrived at
    a common solution to their common problem. However, this happy coincidence helped
    to expedite the standardization process, since the similarity of their solutions
    served to validate both models as being highly likely to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: Given the success of both organization's efforts, it took only a handful of
    years before both models were merged into a single standard. Thus, in 1983, the Basic
    Reference Model for OSIwas born. Over time, the name has, of course, been shortened
    to the OSI model. By 1984, each organization had published this new shared model
    under their own official reference documents, canonizing the model, and its specific
    protocols, within the international community. So, let's take a look at what that
    model entails.
  prefs: []
  type: TYPE_NORMAL
- en: The Basic Reference Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Basic Reference Model was formalized by ISO as standard ISO-7498 (and as
    standard X.200 by the ITU, the successor to the CCITT). The model could be cleanly
    broken into two parts. The first part is the abstract Basic Reference Model for
    networking. The second is the list of protocols the organizations saw fit to standardize
    for use by systems that implement the reference model.
  prefs: []
  type: TYPE_NORMAL
- en: The reference model defines network communication streams, as implemented by
    a compliant device on a network, in a hierarchy of seven distinct conceptual tiers,
    or layers, organized in a stack. This stack is defined as far down as the transmission
    of raw bits over physical media, and all the way up to the high-level application
    software that might use any resource distributed over a network.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, as we describe these layers, when we say a layer is higherin
    the stack, we mean farther away from the hardware-level transmission of bits across
    a physical medium.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model defines a strict mechanism of unidirectional interaction between
    layers. According to this communication standard, a given layer can only ever
    communicate with the layer directly beneath it through an abstract interface exposed
    by that lower layer. This interface is known as the **service definition **of
    a layer, and it defines the valid operations by which a higher layer can interact
    with any lower layers. The interaction model between layers of the OSI network
    stack shows the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7612d6ab-b762-4d3b-8ac6-e5b1fba0a536.png)'
  prefs: []
  type: TYPE_IMG
- en: As data moves through the layers of the stack, each lower layer wraps the packet
    in its own series of headers and footers to be parsed by the recipient device.
    This contains information about what layer in the stack the data originated from,
    as well as how to parse it. The data packet that gets passed down, layer-to-layer,
    through the network stack, is known as a **Protocol Data Unit** (**PDU**).
  prefs: []
  type: TYPE_NORMAL
- en: While service definitions provide an interface for interaction from one layer
    to the layer beneath it, **protocols **provide standardized interaction for an
    entity at a given level in the network stack to interact directly with a corresponding
    component at the samelevel on a remote host. These protocols assume smooth interaction
    down the stack of the originating host, and then back up the stack on the remote
    host. Once it has bubbled up the stack to the target layer of the remote host,
    the protocol determines how the receiving entity should process the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can describe the entire process of data transmission through the OSI
    stack, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An entity on the originating host creates a data packet, known as a PDU, at
    a given layer in the network stack, **N**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The originating layer passes it down the stack by leveraging the service definitionof
    the layer immediately beneath it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lower layers receive the PDU, each wrapping it in a set of headers and footers,
    to be parsed by the corresponding layer on the remote host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the PDU has been wrapped in headers and footers by the bottom most layer
    of the stack, it is transmitted to the remote host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each layer of the stack on the remote host removes the headers and footers applied
    by the corresponding layer of the originating host, bubbling the PDU up through
    the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The PDU is received by layer **N**on the remote host. The receiving layer then
    parses the data of the PDU according to the specifications of a protocolfor layer **N***, *as
    specified by the originating host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And just like that, our data is transmitted, reliably, over the network. That
    is the complete, if abstract, process of using protocols to transmit data units
    through the service definitions of each layer in the network stack. I know, it's
    a lot to take in at once, but it will become slightly more clear as we build up
    the picture more completely. So, with that, let's look at what the individual
    layers of the stack are, why they're ordered the way they are, and what they're
    ultimately responsible for.
  prefs: []
  type: TYPE_NORMAL
- en: The layers of the network stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we examine each layer of the network stack and what it is ultimately responsible
    for, there are some key things to bear in mind. First, remember that the model
    is abstract at its core, and is only meant to serve as a reference. For this reason,
    there may be times where it's not obvious which layer a given responsibility or
    task belongs to. Second, bear in mind that as we discuss the responsibilities
    of each layer in the stack, we're speaking specifically about the responsibilities
    of that layer with respect to the successful transmission of data over the network*.*
    So, the responsibilities of the session layer in the context of the network stack
    are completely independent of, say, the management of a user session in the context
    of a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's useful to remember that the farther downthe stack we go, the closer
    we get to the physical transmission of data over a physical medium*. *We'll be
    numbering the layers in our stack in descending order, from top to bottom, so
    that the smaller the number, the closer we are to the signals on the wire. This
    will be helpful when considering why one layer is lower than another, and how
    its responsibilities are distinct from those of the layer above it. With all of
    this in mind, let's dive in, top to bottom, through the OSI network stack.
  prefs: []
  type: TYPE_NORMAL
- en: The Host/Media distinction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to understand about the network stack is that there are different
    levels of abstraction that you can view. The higher up, conceptually, that you
    look at network interactions, the fewer layers there are, and the easier it is
    to distinguish between the responsibilities of those layers. Meanwhile, when you
    build a model closer to its concrete implementation, you see the distinctions
    between more subtle roles and responsibilities of each entity in that model. We're
    going to be looking at the full, lower-level model provided by the OSI reference
    model, but I want to take a moment to consider the higher-level distinction between
    entities on a network, which breaks down into two fundamental layers.
  prefs: []
  type: TYPE_NORMAL
- en: The first of these layers is the Host layer. This encapsulates the four higher
    levels of the OSI stack and describes entities or responsibilities specific to
    a given host trying to communicate on a network. In the most basic context of
    two-way communication between two hosts on a network, each host is responsible
    entirely for its own implementation of the OSI layers that aggregate up under
    the Host layer (hence the name). Bundling application data, specifying encoding
    and reliability expectations, and the methods for sending out a PDU to a given
    target all fits, loosely, under the Host layer.
  prefs: []
  type: TYPE_NORMAL
- en: The second layer in the higher-level view of networks is the Media layer. These
    layers describe the physical implementation of the network components betweentwo
    hosts. This provides the expected functionality specified or requested by entities
    in the Host layers. Entities of this layer are typically implemented either on
    the hardware level, or in a low-level systems language such as C or C++. For this
    reason, entities of this layer will generally fall outside the scope of this book.
    However, C# provides abstractions that encapsulate and represent the functionality
    of entities in this layer, so it's important to understand how the layers that
    fall under the Media layer actually work on a basic level.
  prefs: []
  type: TYPE_NORMAL
- en: With that high-level distinction made, let's take a look at the full OSI model
    for networks, starting from the top.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The top most layer of the network stack is also the layer that most developers
    will interact with over the course of their careers. The application layer provides
    the highest-level interface for interaction with network communication. This is
    the layer that business application software uses to interact with the rest of
    the stack. There are a number of protocols leveraged by entities on the application
    layer, and we'll discuss them later in this chapter. For now though, it's only
    important to remember that the application layer serves as the access point between
    actual end user applications and the OSI network stack.
  prefs: []
  type: TYPE_NORMAL
- en: The presentation layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it may sound like a way of visuallyrepresenting the data, the presentation
    layer is actually a way of defining how the data is to be interpreted by any consumer
    that wants to look at it. This layer provides context for application-layer entities
    from different hosts to mutually interact with a PDU. Entities in the presentation
    layer are responsible for describing how data passed from the application layer
    should be interpreted on the other side of a given data transaction. It does the
    work of abstracting away the encoding or serialization of PDUs from the higher-level
    business logic of application layer entities.
  prefs: []
  type: TYPE_NORMAL
- en: The session layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entities on the session layer are responsible for establishing, maintaining,
    resuming, and terminating an active communication session between two hosts on
    a network. The entities at work on this layer provide communication mechanisms
    such as full-duplex interactions, half-duplex interactions, and simplex interactions,
    as specified by the constraints of the protocol used.
  prefs: []
  type: TYPE_NORMAL
- en: Full-duplex, half-duplex, and simplex communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a session is established between two hosts, there are a handful of ways
    that communication can happen over that session. The two most common are the full
    and half-duplex implementations. These simply describe a communication session
    that both connected parties can communicate over.
  prefs: []
  type: TYPE_NORMAL
- en: In a full-duplex session, both parties can communicate with one another simultaneously.
    The typical example for this kind of communication is a telephone call. On a phone
    call, both parties can talk and hear the other talking at the same time. The extent
    that someone can listen to what is being said to them while also speaking allows
    for much more efficient data transfer, and can facilitate reliable communication
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: A half-duplex system is one where both parties cancommunicate over the session,
    but only one party can communicate at a given time. A common example of this is
    a two-way radio or walkie-talkie. On these systems, engaging the microphone of
    one radio will lock the channel and prevent the other radio from transmitting
    until the first microphone has disengaged. This can allow more reliable communication
    over a limited bandwidth, since there is less opportunity for signal interference.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a simplex communication session is one where only a single party can
    actually transmit data. That is, there is a sender and a receiver. A common example
    of this is network television; there is a single broadcast source, with multiple
    receivers actually accepting the transmitted signal. This is uncommon in most
    modern communication networks, since the additional cost of implementing a duplex
    communication session is often trivially small in relation to a simplex connection.
    However, it should be noted that a duplex communication system is simply a system
    of two simplex connections with one connection going in each direction between
    the hosts.
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entities in the transport layer use protocols specifically designed for interacting
    with other hosts and the network entities in between. It might seem redundant
    given our description of the presentation and session layer; however, there's
    an important role to be played here. The presentation layer is concerned with
    character encoding, or the mapping from platform-specific data representations
    to platform-agnostic descriptions of that representation. The transport layer,
    though, looks at the full block of encoded data that was passed down by the presentation
    layer, and determines how to break it apart. It's responsible for cutting the
    data into segments of otherwise useless streams of binary. And, importantly, it
    breaks those segments up in such a way that they can be reassembled on the other
    side of the connection. The transport layer is also responsible for error detection
    and recovery, with different protocols providing different levels of reliability.
  prefs: []
  type: TYPE_NORMAL
- en: This layer is the lowest layer in the Host layers umbrella previously described.
    Determining what transport mechanism can and will be supported by a host remains
    the responsibility of that host. However, it is the lowest boundary of a given
    host's responsibility in successfully implementing network interaction. Everything
    below this layer falls into the Media layer, and is the responsibility of the
    engineers who support the network that the host has been deployed on.
  prefs: []
  type: TYPE_NORMAL
- en: The network layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entities on the network layer manage interactions over the network topology.
    They're responsible for address resolution and routing data to target hosts once
    an address has been resolved. They also handle message delivery based on constraints
    or the resource availability of the physical network. So, while the transport
    layer determines the interactions between host-level tiers of the network stack
    on either side of a connection, the network layer is responsible for applying
    the transport protocol across the chain of devices that form the route between
    two hosts. The distinction between adjacent layers can be subtle, and we'll discuss
    some of the responsibilities specific to the network layer later in this chapter.
    So, if the distinction between transport and network layers is unclear, trust
    that we'll (at least, attempt to) clarify that distinction later.
  prefs: []
  type: TYPE_NORMAL
- en: The data-link layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data-link layer falls very clearly into the Media layer''s grouping, as
    entities in this layer provide the actual transfer of data between nodes in a
    network. It''s responsible for error detection from the physical layer, and controls
    the flow of bits over physical media between nodes. So, for example, in a half-duplex
    communication setup, an entity in the data-link layer is responsible for restricting
    the transfer of data in one direction while data is being transferred in the other
    direction. Entities in this layer almost serve as the traffic lights directing
    traffic over the roads of a node-to-node connection. The data-link layer is broken
    down even further into two sub-layers by the **Institution of Electrical and Electronics
    Engineers** (**IEEE**) standard 802\. These two sub-layers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Medium Access-Control** (**MAC**) layer: This sub-layer controls who
    can transmit data throughthe data-layer entity, and how that data can be transmitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Logical Link Control** (**LLC**) layer: This sub-layer encapsulates the
    logical protocols of network interaction. It is essentially the interface that
    provides the entities links as a set of abstract protocol operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driving home how narrowly specific the data-link layer is in terms of its responsibilities
    on a network, its most common protocol is the **Point-to-Point Protocol** (**PPP**).
    This just highlights that entities of the data-link layer really are only concerned
    with facilitating the connection between two points.
  prefs: []
  type: TYPE_NORMAL
- en: The physical layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we've arrived at the bottom of the stack, with the simplest layer to
    understand. The physical layer encapsulates the entities that are responsible
    for transmitting raw, unstructured data from one node in the network to another.
    This is the layer responsible for sending electrical signals that correspond to
    the strings of bits in a data packet. It encapsulates the devices responsible
    for modulating voltage, timing signals, and timing the frequency of wireless transmitters
    and receivers. Entities on this layer are explicitly outside of the scope of this
    book, but are an interesting concern regardless.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we've seen how the OSI model organizes the responsibilities of transmitting
    data. Hopefully, by this point, it should be clear how each layer in the stack
    is intended to provide a reliable abstraction for the layer above it. However,
    the process of communicating with a remote host, in its entirety, may still seem
    a bit vague. So, let's consider a concrete example and address each of the concepts
    that we talked about as they arise through the process of data transmission.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's assume that an entity on layer 5 of our host (the session layer)
    wants to establish a session with an entity on **Layer 5** in a remote host. I
    haven't said so explicitly until now, but we can always assume that an entity
    on a given layer on one host only ever communicates directly with a corresponding
    entity on the samelayer in the remote host. So, for our example, an entity in
    layer 5 will communicate with a remote entity that also resides in layer 5.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with remote entities will always happen through a protocol*. *Given
    this, the first responsibility of any entity seeking to communicate with a remote
    host is to wrap the transmitted data in the headers and footers appropriate for
    that protocol. For our entity in the session layer, let's assume they are hoping
    to establish a session using the **Session Control Protocol** (**SCP**). This
    means that our local entity will produce the data necessary to establish a session,
    then wrap that data in SCP headers and footers, creating a well-formed PDU (hopefully,
    this makes it clear why the name describes this package). This ensures that the
    recipient host will be able to unwrap the data based on the information stored
    in the headers and footers of our PDU.
  prefs: []
  type: TYPE_NORMAL
- en: Since entities that reside on any layer abovethe physical layer cannot communicate directly
    with one another, we have to pass our PDU down the stack. In our example, we can
    reliably pass the PDU down to **Layer 4** by taking advantage of its service definition
    and trusting that the logical operations exposed through that definition are accurately
    implemented by all of the responsible entities below **Layer 5**. So, we don't
    need to know how **Layer 4** implements transport mechanisms. Instead, we simply askit
    to use the appropriate transport mechanism for this particular instance and trust
    that it will do so appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern of trusting that lower layers in the stack will correctly implement
    the operations being requested by higher layers in the stack continues all the
    way through to **Layer 1**. Over the course of this process, each layer in the
    stack will wrap the PDU in its own headers and footers. These standardized chunks
    of data give each intermediary layer on the receiving host enough information
    to know to pass the PDU up its own stack. By continuously wrapping the data in
    well-formed, well-understood chunks of binary data, each layer on the remote host
    can trust that the inner segment of data that is passed up the stack is exactly
    what should move up.
  prefs: []
  type: TYPE_NORMAL
- en: This process of wrapping the PDU in deeper and deeper layers of metadata continues
    down the stack until we reach **Layer 1**. **Layer 1** holds the physical connection
    from our host to the remote host. Once we've reached this level, we can step across
    the expanse of the network and start looking at how our PDU moves back upthe network
    stack until it reaches our target entity on **Layer 5**. Entities on each layer
    of the remote host will diligently remove and read the headers and footers applied
    by the corresponding layer of the originating host. The information in those wrappers
    will indicate that the PDU is destined for a layer abovethe current layer, and
    so entities will simply strip their headers and bubble the rest of the data upthe
    network stack.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data has reached layer 5 on the remote host, an entity on that layer
    will read the headers and footers of the PDU that were applied on **Layer 5**
    of the originating host. This metadata will indicate that layer 5 is, in fact,
    the target layer for this particular PDU. The metadata will also indicate what protocolshould
    be used to parse the data passed to the remote host. Using this information, the
    recipient host will have enough data to properly read the data in the PDU, and
    construct its own response PDU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that response is received by the originating host, a session will be established,
    and be open for use by any entities above the session layer in the originating
    or remote host. This whole process is captured in the following diagram of the
    full life cycle of data transmission through the OSI stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b4db4a2-00f7-451e-bdc4-58d7b8966e8e.png)'
  prefs: []
  type: TYPE_IMG
- en: With this diagram in mind, is easy to see how the standardization provided by
    the OSI model makes it easier for engineers to program software for networks.
    The clean separation of concerns and the explicit pattern for passing data through
    the stack allows for well-formed contracts, against which all interested parties
    can design and develop. Engineers programming entities on the application layer
    can ignore the details of transporting data. They simply pass down a well-formed
    PDU through the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this description clarifies how entities on specific layers expose
    their abstractions through a service definition, and how entities operating on
    the same layer of the network stack on different hosts reliably communicate through
    protocols. With this perspective in mind, let's take a closer look at the layers
    of this stack that we'll be programming for most frequently, as well as looking
    at some of the classes that C# provides to represent the entities of these layers.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned it before, but it bears repeating,  application layer is where the vastmajority
    of day-to-day network programming will take place. This is especially true within
    the .NET Core framework, since the libraries provided by that framework deliver
    a wide array of clean, easy-to-use abstractions for entities or responsibilities
    that must be programmed lower in the stack. So, first, let's see why we should
    be so concerned with the responsibilities of the application layer. We'll look
    at the kinds of responsibilities that are typically delegated to entities in the
    layer, and see how frequently those responsibilities overlap with the requirements
    faced by everyday .NET Core developers. Then, given the extensive range of use
    cases for entities in the application layer, we'll take a look at some of the
    common protocols used by entities at that tier of the stack. We'll seek to understand
    them on a fundamental level. We'll look at what classes and libraries we have
    available to us for each of those layers; however, after this chapter, my hope
    is that you'll have a deep enough understanding to be able to reconstruct those
    classes yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The most common layer in the stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This might feel redundant at this point, but it really is worth driving home
    that the application layer is where the vast majority of .NET developers are going
    to be doing their network programming. Since that accounts for most of you, we're
    going to keep talking about it. But *why *is the application layer so important?
  prefs: []
  type: TYPE_NORMAL
- en: The crux of it is that the application layer serves as the gateway to network
    activities for your business logic. This becomes very apparent as you explore
    how thoroughly .NET has hidden the implementation details of any of the responsibilities
    of lower levels of the network stack. Essentially, if there is something that
    you need to specify about how your application should behave anywhere below the
    stack, you'll be doing so througha .NET library class.
  prefs: []
  type: TYPE_NORMAL
- en: I really can't stress enough how important it is to understand how the protocols
    behave under the hood. Knowing how the libraries are implemented will leave you
    better equipped to actually use them in the future. It's like learning to drive
    a stick shift. If you only ever learn the steps you have to perform to change
    gears, you'll likely get rusty without consistent practice. Over time, you'll
    have forgotten enough to not be able to drive a manual transmission anymore. However,
    if you learn *how *the steps you take serve to allow your car to drive, you'll
    never forget the steps themselves. Even if it's been years since you last drove
    a stick shift, you'll be able to reconstruct the steps you need to execute based
    on your understanding of what those steps actually accomplish. By this same measure,
    understanding exactly whatthe .NET core libraries are doing for you will enable
    you to use them more efficiently and correctly. You'll find yourself looking up
    the documentation less frequently and be better able to find the methods or properties
    you need through IntelliSense. That said, let's look closely at some of the most
    common protocols in the most common network layer.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP – application to application communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the bread and butter of almost every .NET Core developer working
    today. HTTP is by far the most common and useful protocol for applications to
    interact over networks currently in use today. Why is that? Because HTTP is the
    protocol that almost every single web page on the internet is served up on by
    remote hosts, and requested by local clients. That alone is reason enough to call
    it the most common protocol in use. If you want more evidence, though, consider
    that most native mobile applications that serve up web-hosted data request this
    data from APIs that are exposed via HTTP. It almost feels ridiculous to have to
    make a case for the importance of understanding HTTP, since I'm certain there
    won't be a single person reading this book who *doesn't *have at least some experience
    with, or understanding of, HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: So, why bother covering it so thoroughly if most of my readers are assumed to
    have some basic understanding of it? The answer to that is twofold. First, it's
    because it is so common as a communication protocol! HTTP is so prevalent that
    it would be criminally negligent not to give it due consideration in a book purporting
    to teach network programming fundamentals. And the second reason is because, at
    least in my own personal experience, most developers, and even engineers who work
    with it daily, only have a passing or surface-level understanding of what the
    specification provides. My hope is that by the end of this book, anyone who has
    read it, cover to cover, can and will go forth and program software that leverages
    every aspect of their target networks confidently and competently. It wouldn't
    be possible to do that without a deep, thorough understanding of what HTTP is,
    why it was defined, and how it is used by thousands of applications every second
    of every day. With that in mind, let's take a look at the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: What is HTTP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As almost every reader of this book is likely to be shouting at its pages already,
    let's go on to HTTP**.** As should already be obvious, HTTP is a protocol implemented
    and leveraged by software that lives in the application layer of the OSI network
    stack. It's the primary mechanism of communication for applications exposed through
    the internet, and is designed for the transfer ofhypermediaover a network. Hypermedia
    typically refers to hypertext documentsthat contain multimedia information, as
    well as hyperlinksthat can be used to navigate to and load additional resources
    from other remote hosts.
  prefs: []
  type: TYPE_NORMAL
- en: The transfercomponent of HTTP is, fundamentally, a request/response protocol
    that assumes a client-server relationship between hosts in an active HTTP session.
    To understand how this is done, let's start with the notion of a client-server
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The client - server model in HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we've been referring to communication over a network
    as simply happening between originating and target hosts, as if the two were functionally
    identical, depending on which was sending a packet. In the client-server model,
    however, the two hosts actually perform distinct and specific duties, and so they
    are not conceptually interchangeable. A cliententity is one who requests, and
    is granted, use of the services or resources provided (or served) by the serverentity.
    Servers do not make active requests of clients, except when necessary to complete
    a service request already made by the client (for example, requesting additional
    login information from the client, when the client has initiated the transaction
    by requesting protected data). Likewise, clients are not expected to serve any
    specific resources to the server, except the information necessary for the server
    to sufficiently process and respond to a request.
  prefs: []
  type: TYPE_NORMAL
- en: Today, it's not uncommon for two applications to use HTTP to interact with one
    another in such a way that, depending on the interaction, either application could
    be considered the client or the server. For example, a desktop finance application
    might be responsible for storing local user data, while also using a remote API
    to access live data feeds about current interest rates on different kinds of loans.
    Now suppose the authors of that desktop application want to periodically access
    information about users of their software. In the case of a user logging onto
    their application to look up market rates for mortgages, the desktop application
    will request information from the remote API; so the desktop application is the
    client, while the API is the server. However, when the remote software decides
    to query instances of its desktop application for user data, the roles are reversed.
    The remote software will request the data from known hosts of the desktop application;
    the remote software is the client, requesting information from computers running
    the desktop applications, which are the servers in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, an application or host might be the clientof one remote host,
    while simultaneously operating as the serverfor a different remote host. Consider
    the case of an API that responds to requests by aggregating information from a
    number of other APIs. In the act of servicing requests by their downstream consumers,
    the application in question is very obviously a server. However, when the application
    requests information from other APIs upstream, it is acting as the client.
  prefs: []
  type: TYPE_NORMAL
- en: I bring these examples up to highlight the fact that the client-server relationship
    is mostly conceptual. The assignment of client or server roles to a given host
    is specific to a given interaction context. If that context changes, so too might
    the conceptual role of the hosts involved. It's important that we avoid confusion
    by only referring to clients and servers within the context of a specific interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Request/response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In describing the nature of the client-server relationship, we've also touched
    on the nature of the HTTP request/response protocol. This protocol, as a way of
    serving up information, is fairly intuitive to understand. When a client makes
    a request of a server (the request part of request/response), the server, assuming
    it meets the specifications of the protocol, is expected to respond with meaningful
    information about the success or failure of that request, as well as by providing
    the specific data initially requested.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the complete process of requesting information and receiving a meaningful
    response requires several intermediary round-trips between the client and server
    to establish initial connections, determine the ability of the server to service
    the request, and then submit the information necessary to initiate the request.
    This entire process, however, will be considered a single request/response session
    from the perspective of application-layer software. This leads us nicely onto
    the subject of just how those sessions are initially established in the first
    place.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've talked about the back and forth of the request/response communication
    patterns of HTTP, but we've neglected the context that allows that chatter to
    happen so seamlessly. This fluid interaction is facilitated by an underlying session
    established prior to satisfying the first request made by a client. Historically,
    this session has been provided by a **Transmission Control Protocol** (**TCP**)
    connection established against a specific port on the host server. This port can
    be specified in the URI when designating your target host, but typically will
    use default ports for HTTP, such as `80`, `8080`, or `443` (for HTTPS, which we'll
    cover later in this book). Once the connection is established, round trips of
    HTTP communication can proceed freely until the session is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that I specifically said that TCP is historicallyused
    for HTTP. This is because, for each of the current versions of HTTP (1.0, 1.1,
    and now HTTP/2), TCP has been the standard transport layer protocol supporting
    it. However, in the current proposed specification for HTTP/3, the protocol is
    being modified to take advantage of alternative transport protocols, including
    the **User Datagram Protocol** (**UDP**), or Google's experimental **Quick UDP
    Internet Connections** (**QUIC**) protocol. While there are trade-offs associated
    with these alternate transport protocols, the underlying sessions they provide
    are the same from our point of view. Each of these protocols serve to establish
    a connection with a listening host and facilitate the transmission of request
    and response messages. Next, let's take a look at some of the operations a client
    might request of a server, and how those operations are specified through the
    HTTP standard by way of request verbs.
  prefs: []
  type: TYPE_NORMAL
- en: Request methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a client wants to make a request of a server, it must specify the method
    by which the server will be expected to respond to the given request. These method
    specifications are typically called **HTTP verbs**, since most of them describe
    an actionto be taken by the server when processing a request sent by the client.
    The standard methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OPTIONS**: This returns the list of other HTTP methods supported by the server
    at the given URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TRACE**: This is a utility method that will simply echo the original request
    as received by the server. It is useful for identifying any modifications made
    to the request by entities on the network while the request is in transit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CONNECT**: CONNECT requests establish a transparent TCP/IP tunnel between
    the originating host and the remote host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GET**: This retrieves a copy of the resource specified by the URL to which
    the HTTP request was sent. By convention, GET requests will only ever retrieve
    the resource, with no side-effects on the state of the resources on the server
    (however, these conventions can be broken by poor programming practices, as we''ll
    see later in the book).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HEAD**: This method requests the same response as a GET request to a given
    URL, but without the body of the response. What is returned is only the response
    headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST**: The POST method transmits data in the body of the request, and requests
    that the server store the content of the request body as a new resource hosted
    by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT**: The PUT method is similar to the POST method in that the client is
    requesting that the server store the content of the request body. However, in
    the case of a PUT operation, if there is already content at the requested URL,
    this content is then modified and updated with the contents of the request body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PATCH**: The PATCH method will perform partialupdates of the resource at
    the requested URL, modifying it with the contents of the request body. A PATCH
    request will typically fail if there is no resource already on the server to be
    patched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE**: The DELETE method will permanently delete the resource at the specified
    URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server will not respond to a request method invoked against a given location
    unless the server has been configured to do so. This is because some of the methods
    defined by the HTTP standard can permanently impact the state of resources on
    that server, and so should only be invoked and processed when it is safe to irrevocably
    update that state. There are, however, a number of methods designated as safe,
    by convention. This simply means that they can be processed by a server without
    having any side-effects on the state of the resources on that server. HEAD, GET,
    OPTIONS, and TRACE are all conventionally designated as safe.
  prefs: []
  type: TYPE_NORMAL
- en: Status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even when an application has constructed a valid HTTP request object, and submits
    that request to a valid path on an active host, it's not uncommon for the server
    to fail to properly respond. For this reason, HTTP designates, as part of a response
    object, a status code to communicate the ability of the server to properly service
    the request. HTTP status codes are, by convention, 3-digit numeric codes returned
    as part of every response. The first digit indicates the general nature of the
    response, and the second and third digits will tell you the exact issue encountered.
    In this way, we can say that status codes are categorized by their first digits.
  prefs: []
  type: TYPE_NORMAL
- en: When you're writing software that responds to HTTP requests, it's important
    to send accurate status codes in response to different errors. HTTP is a standard
    that must be adhered to by developers in order to remain useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only five valid values for the first digit of an HTTP status code,
    and thus, five categories of responses; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1XX:** Informational status code. This indicates that the request was in
    fact received, and the processing of that request is continuing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2XX:** Success status code. This indicates that the request was successfully
    received and responded to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3XX:** Redirection. This indicates that the requesting host must send their
    request to a new location for it to be successfully processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4XX:** Client Error. An error that is produced by the actions of the client,
    such as sending a malformed request or attempting to access resources from the
    wrong location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5XX:** Server Error. There was a fault on the server preventing it from being
    able to fulfill a request. The client submitted the request correctly, but the
    server failed to satisfy it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status codes are returned by servers for every HTTP request made against the
    server, and so can be very useful for building resiliency into your client software.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP message format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Requests and responses in HTTP are always sent as plain text messages. Those
    plain text messages consist of a well-ordered, and well-structured, series of
    message segments that can be reliably parsed by the recipient. In requests, messages
    consist of three required message components and one optional component:'
  prefs: []
  type: TYPE_NORMAL
- en: The request line consists of the method, the path to the requested resource,
    and the specific protocol version that should be used to determine the validity
    of the rest of the message; for example, `GET /users/id/12 HTTP/1.1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A series of request headers and their values, for example, `Accept: application/json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) A request message body. This consists of content headers that provide
    metadata about the content type, as well as the content itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each segment is delineated by a `<CR>` carriage return character and an `<LF>`
    line feed character; these are special white-space characters whose specific **American
    Standard Code for Information Interchange** (**ASCII**) values allow them to reliably
    be used to indicate the breaks between segments in a message stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, an HTTP response consists of its own series of almost identically
    structured segments, each also delimited by the `<CR><LF>` characters. Just as
    with the request message, it contains three required segments and one optional
    message body segment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A status line consisting of the specific protocol, the HTTP status code, and
    the reason phrase associated with that status code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP/1.1 401 Bad Request`: A response containing the 401 client error status
    code (indicating that the client sent an improper request message for the resource
    that it was looking for).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP/2.0 201 Created`: A response indicating the 201 success status code,
    meaning that the desired resource has been created on the server.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Headers, as with the request message segment, providing metadata about how the
    response should be parsed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional message body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those simple segments fully define every valid HTTP message sent across the
    internet. This accounts for millions of requests per second, between millions
    or billions of devices. It's the simplicity of the message specification that
    makes that kind of scale possible.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remembering the proper character delimiters and order for segments in an HTTP
    message, anyone should be able to build a request from scratch. Thankfully though,
    you don't have to remember those details; .NET Core has you covered with the `System.Net.Http`
    namespace. We'll explore this namespace in much greater detail later in the book,
    but for now, just trust that any feature or detail you find yourself needing to
    leverage HTTP communication in your application is exposed through that namespace.
    This namespace exposes enum types for status codes and header values, and an `HttpMethod`
    class to specify your message verb. As a library, it's rich with out-of-the-box
    features while remaining flexible and extensible enough to be leveraged in any
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: FTP and SMTP – the rest of the application layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have developed a deep understanding of HTTP due to its prominence in
    the daily lives of network programmers, we must also take the time to mention
    and briefly look at some of the other common application-layer protocols in use
    today. In this section, we'll look at the **File Transfer Protocol** (**FTP**)
    and **SSH File Transfer Protocol** (**SFTP**), which allow for remote file copy
    operations and filesystem navigation; and the **Simple Mail Transfer Protocol**
    (**SMTP**), which is used for email transmission over networks.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, with each of these protocols operating on the application layer,
    it's not uncommon to see one protocol provide the functionality that has historically
    fallen under the domain of another protocol. For example, the data-agnostic nature
    of HTTP's plain-text message structure makes it trivially simple to use HTTP to
    transfer complete file data over an HTTP session. It's as simple as writing software
    on the server to transmit files through the message body of the response. For
    this reason, FTP, and to a lesser degree, SMTP, have fallen out of favor with
    network programmers in recent years, in favor of implementing their responsibilities
    in HTTP-aware software hosts. The protocols remain, however, and it will benefit
    us to consider what their flaws and advantages are.
  prefs: []
  type: TYPE_NORMAL
- en: FTP and SFTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP (and SFTP) leverages a client-server model similar to the one used by HTTP,
    but its connection specification is slightly more complicated than we saw before.
    Where HTTP sent messages over a single connection by way of a series of stateless
    request/response transactions, FTP maintains twoconnections between the client
    and server over the course of a stateful session. One connection establishes a
    stateful control pipeline that tracks the current state of the directory exposed
    by the FTP server and submits the commands necessary to execute the desired file
    transfers. The other connection is stateless, and facilitates the transfer of
    the raw file data between hosts. Establishing both of these connections for a
    single FTP session introduces the benefit of reliability at the cost of latency
    and complexity. Moreover, the limited nature of tasks that can be reliably executed
    through FTP as a communication protocol has only served to limit its popular use
    as time goes on. Thankfully though, as was the case with HTTP, much of the details
    of implementing an FTP server or client is taken care of by way of the `System.Net`
    namespace in .NET core, and we'll explore those tools later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: SMTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to FTP, the feature set supported by the SMTP is quite limited and narrowly
    tailored to performing a few specific tasks. However, the need to implement email
    servers is actually fairly common, and understanding the complexity of sending
    or receiving messages through SMTP remains a relevant and useful skill; certainly
    more so than with FTP these days. SMTP is a connection-oriented protocol for sendingmail
    messages to remote servers that are configured to receive them. It leverages a
    client-server model leveraging reliable sessions, over which a series of commands
    and data-transfer processes transmit email, unilaterally, from the client to the
    server. The back-and-forth of an SMTP session is actually quite a bit more complicated
    than we saw with HTTP and FTP, and that complexity is beyond the scope of this
    chapter. For now though, it's sufficient to say that any network programmer worth
    their salt will have a sound understanding of HTTP, FTP, and SMTP.
  prefs: []
  type: TYPE_NORMAL
- en: The Transport layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the application layer is the layer of the OSI model that the vast majority
    of .NET developers work with in their daily lives, it would be useless without
    sound, reliable protocol implementations on the transport layer. It's on this
    layer that the connections are made and the data is streamed. It's the lowest
    layer in the stack that an individual host is directly responsible for, and in
    the transport layer, TCP and UDP reign supreme. Each provide their own mechanisms
    for delivering streams of data to their destination, and each present their own
    trade-offs, to be considered when choosing a transport protocol for your network
    services. As with all of these protocols, we'll take a closer look at them later
    in this book, but for now let's learn what they are and why they came to be.
  prefs: []
  type: TYPE_NORMAL
- en: TCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developed in 1974 by engineers in the IEEE, the TCP is defined as a connection-based
    communication protocol that provides the reliable delivery of ordered packets.
    It's used to facilitate communication between hosts of all kinds from the internet,
    to SMTP clients and servers, **Secure Shell** (**SSH**) connections, FTP clients
    and servers, and HTTP. It is ubiquitous as the transport layer protocol of choice
    for almost all modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: The broad adoption of TCP as the transport layer supporting most application-layer
    requests is primarily due to the reliability of a TCP connection. By convention,
    entities that implement TCP are written to detect packet loss and the out-of-order
    delivery of data streams, to re-request lost data, and to reorder the out-of-order
    streams. This error correction is resolved priorto returning that data back up
    the stack to the application layer entities making use of the TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the obvious cost incurred by this error handling is latency and performance.
    Multiple round-trips to fetch, essentially, the same data two or three times can
    add substantial downtime to the client application. The reliability of TCP is
    ensured by leveraging a round-trip chain of request, acknowledgements of the receipt
    of a request, then another request, and so on. All the chatter incurred by this
    consistent back-and-forth makes TCP far from ideal for real-time applications,
    such as for gaming, video streaming, or video conferencing. Instead, where reliability
    or guaranteed ordering can be sacrificed in favor of performance, UDP or a similar
    protocol should be used as the transmission layer of choice.
  prefs: []
  type: TYPE_NORMAL
- en: UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the reliability of TCP is not strictly required for an application, then
    UDP begins to look like a very attractive option for its simplicity and performance.
    UDP is a simple, unreliable, and connectionless communication protocol for transmitting
    data over a network. Where TCP provided robust error handling through its pattern
    of repeated requests and acknowledgments, UDP has no handshaking or acknowledgment
    signals to indicate whether a packet was properly transmitted from host to host.
  prefs: []
  type: TYPE_NORMAL
- en: While UDP does not provide robust error-handling in the case of lost or unordered
    packets, it does, at the very least, provide error-checking on the packet level.
    It does so by using a checksum value stored in the header of the packet. The difference
    being that when an error is detected in a packet, the packet is simply dropped
    by the UDP entity, and no request is sent out to try to retrieve the packet again
    in a valid state.
  prefs: []
  type: TYPE_NORMAL
- en: This packet-delivery-oriented model of sending out individual packets without
    regard for their successful delivery also means that UDP data requests can be
    sent without any prior establishment of a connection between hosts. This lack
    of an initial round-trip greatly reduces overhead in software systems that need
    to make frequent, real-time connections between many hosts. In fact, this lack
    of an initial handshake is one of the primary distinguishing factors between connection
    and connectionless communication protocols, and that is a distinction that warrants
    elaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Connection versus connectionless communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of connectionless communication might seem like an oxymoron at first.
    How could two entities possibly communicate if they haven't connected first? How
    would one even know that the other exists to communicate with?
  prefs: []
  type: TYPE_NORMAL
- en: The underlying principle is that in a connection-based communication protocol,
    both hosts must first establish a line of communication before thetransmission
    of any application-specific data can begin. The handshake sequence in TCP is the
    most obvious example of this. There is a complete round-trip of sent/received
    messages that must succeed before the connection is considered established, and
    data can be transmitted between hosts. That established line of communication
    is the 'connection' in this context. It consumes time and bandwidth, but provides
    reliability and error correction, and in almost all cases, the value of the reliability
    and error correction is worth far more than the costs incurred.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, in connectionless communication, data could be transmitted, and the
    communication terminated, without even a singlecomplete round-trip from the client
    to the server, and back to the client again. The packet has sufficient information
    in its own headers to be properly routed to a listening host. Provided that host
    has no follow-up to the initial request, that communication will stop with only
    a one-way packet delivery. The low-latency of this transmission pattern could
    be a major benefit in certain application contexts.
  prefs: []
  type: TYPE_NORMAL
- en: There's still so much more to explore with both of these protocols, going forward,
    but that is the concern of a later chapter in this book. For now though, I hope
    this makes it clear why the transport layer and its protocols serve such a major
    role in designing and implementing high-performance and highly-reliable network
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned everything there is to know about the OSI network
    model. First, we learned about the governing bodies that defined the standard
    reference model, including when and why they set out to solve the problem of unified
    network modeling. Then, we took a close look at the model they defined, including
    looking at every layer in their stack, and what responsibilities entities in those
    layers assume. We learned about how protocolsdefine standardized communication
    patterns for entities operating on the same level in the network stack, but on
    separate hosts on a network. We saw how service definitionsallow entities to pass
    data through the network stack and deliver messages to remote entities.
  prefs: []
  type: TYPE_NORMAL
- en: We also took a close look at some of the most common communication protocols,
    which we'll be interacting with in the rest of this book. We started with the
    king of all network protocols, HTTP. We looked at how HTTP sessions are established
    to allow communication between clients and servers. We saw how HTTP operates through
    a series of requests and responses using well-defined verbsto specify the operations
    to be performed in servicing those requests. We looked at TCP and UDP, and how
    the transport layer serves as the bus through which all application-layer network
    interactions must travel. Finally, we looked at how the network layer facilitates
    this communication through the IP addressing system, and discrete packet transmission.
  prefs: []
  type: TYPE_NORMAL
- en: With this foundation in place, we're well positioned to take a close look at
    how data is broken down into discrete packets and transmitted over the network
    through data streams in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does OSI stand for, and what is the name of the organization that standardized
    it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the abstraction layer via which layers of the OSI network stack communicate
    with layers beneath them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many layers are in the OSI network stack, and what are they?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the standardization mechanism by which entities on the same
    layer of the network stack on different hosts communicate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does HTTP stand for? For which network layer is HTTP used as a communication
    protocol?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name all of the HTTP verbs that a request can be sent from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the primary differences between the TCP and UDP transport protocols?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information about the OSI Reference Model, see *Building Modern Networks*,
    by *Steven Noble, Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can refer to *Computer Networking: Beginner''s Guide for
    Mastering Computer Networking* *and the OSI Model* by *Ramon Nastase''s,* and *The
    OSI Model for Network Engineers: Improve Your Network Troubleshooting,* by *Al
    Rivas*. Both are available in e-book form on [amazon.com](http://amazon.com),
    and will provide a much more thorough examination of the OSI stack than I had
    time or space to cover in the context of this chapter.'
  prefs: []
  type: TYPE_NORMAL
