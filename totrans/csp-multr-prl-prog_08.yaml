- en: Chapter 8. Debugging Multithreaded Applications with Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreaded applications present their own set of challenges to develop as
    we have seen so far in this book, but they also have a unique set of challenges
    to debug. Visual Studio, starting with Visual Studio 2010, has developed additions
    to the debugger to assist with debugging tasks and the `Parallel` library.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio has had the **Threads** window in their debugger since 2003 to
    assist with debugging threads. However, starting with Visual Studio 2010, they
    have added the **Parallel Stacks** window, **Parallel Watch** window, and the
    **Tasks** window to aid in debugging applications using the **Task Parallel Library**
    (**TPL**). In this chapter, we will examine all of these windows and demonstrate
    how to step through a multithreaded and multitask application to find program
    flow issues and race/lock conditions.
  prefs: []
  type: TYPE_NORMAL
- en: A **race condition** is a type of error that occurs when multiple threads interfere
    with each other and is based on the timing and execution of the different threads.
    Because of this, the condition does not happen every time the application executes.
    It takes a certain timing of the execution of the different threads.
  prefs: []
  type: TYPE_NORMAL
- en: A race condition happens when two or more threads access a data variable and
    try to modify it at approximately the same time. Since the OS scheduler can switch
    between threads at any time, you cannot predict the order in which the threads
    will access the data. The result of the change in data is dependent on the OS
    scheduling algorithm. Both the threads are "racing" to access the data.
  prefs: []
  type: TYPE_NORMAL
- en: Problems can happen when one thread examines the contents of a variable and
    performs an action but another thread changes the contents of the same variable
    during the time the first thread examines it and then acts on it.
  prefs: []
  type: TYPE_NORMAL
- en: A **lock condition** occurs when two or more threads are waiting on a resource
    that is locked by another thread. So, if thread 1 is waiting on a resource locked
    by thread 2 and thread 2 is waiting on a resource locked by thread 1, then both
    threads will remain "hung" forever waiting on each other to free up a resource.
    This is a type of a lock condition called a **deadlock**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Threads** window in the debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **Tasks** window in the debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the **Parallel Stacks** and **Parallel Watch** windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stepping through an application with more than one thread and more than one
    task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting a deadlock condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considerations for debugging multithreaded applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several things to consider when debugging a parallel application.
    The first thing is probably the most obvious—there are multiple things happening
    at once. If you have an application with five threads, then all five threads can
    be executing at the same time depending on how many cores your machine has. If
    you step through a particular thread, the other threads are not just waiting on
    you unless there are breakpoints or they are waiting on a resource locked by the
    thread you are stepping through. You need to understand how your parallel application
    is designed and how it executes so you know what is happening in parallel—especially
    what is happening in threads other than the one you may by stepping through.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, debugging a concurrent application takes a lot of information. When
    using the debugger on a TPL application, you can have the **Local**, **Immediate**,
    **Threads**, **Task**, **Parallel Stack**, **Parallel Task**, **Process Explorer**,
    **Source Code**, and **Object Explorer** windows all open at the same time. This
    either takes a lot of screen real estate or requires constantly moving windows
    around to see the information that you need. I highly recommend doing this on
    a dual monitor setup. You can never have too much screen room when debugging a
    parallel application. There are few things more frustrating than not being able
    to easily see all the information you need as you step through an application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Threads window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Threads** window in the Visual Studio debugger allows you to view details
    of all of the threads in an application and work with them. You can view the stack
    of each thread. You can freeze or thaw a thread, and view all of the details concerning
    a thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start the debugger in an application and then go to **Debug** | **Windows**,
    you can select the **Threads** window. If you do this, you should see something
    like the following; this is the **Threads** window for the thread''s version of
    the `OldStarFinder` program we did in [Chapter 7](ch07.html "Chapter 7. Data Parallelism"),
    *Data Parallelism*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Threads window](img/8321EN_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at this window and examine it in detail. It contains the
    following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flag**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ID**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managed ID**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Category**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Affinity Mask**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Suspended Count**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process Name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process ID**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport Qualifier**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Flag** column allows you to designate a thread as one that you want to
    watch. If you right-click on a thread in this window, you can mark or unmark it
    as a flagged thread.
  prefs: []
  type: TYPE_NORMAL
- en: The **Active** column indicates which thread is the currently active thread.
    A yellow arrow designates the active thread in the debugger. It is also important
    to note that when stepping through a thread, other threads continue their operation
    unless a breakpoint is set. All of the threads do not block while you are stepping
    through a particular thread.
  prefs: []
  type: TYPE_NORMAL
- en: The **ID** column shows a thread's ID number in Windows, which is different
    from the .NET Managed ID.
  prefs: []
  type: TYPE_NORMAL
- en: The **Managed ID** column shows the managed ID number of a thread. A **managed
    thread** is different from a Windows thread. A managed thread, in this context,
    is a thread managed in .NET by the CLR and the threadpool. A managed thread can
    execute in one or more Windows threads. A .NET managed thread is created using
    the .NET `Threads` class. Also, remember when using `Tasks` that a task is not
    a thread.
  prefs: []
  type: TYPE_NORMAL
- en: The **Category** column displays the thread's classification as either the main
    thread, a user interface thread, a remote procedure handler thread, or a worker
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: The **Name** column displays the thread's **Name** property if it is set, or
    otherwise displays **<No Name>**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Location** column shows what method the thread is currently executing.
    By double-clicking on a row in this column, you can see the thread's full stack.
  prefs: []
  type: TYPE_NORMAL
- en: The **Priority** column shows the Windows priority for the thread.
  prefs: []
  type: TYPE_NORMAL
- en: The **Affinity Mask** column shows this mask for each thread. The affinity is
    a bitwise mask indicating which processors a thread is eligible to execute on.
    In our example, we have a four-processor system and all but one of the threads
    has a mask that ends with `1111`. These are the four bits representing our four
    processors. This indicates that these threads can execute on any of the processors.
    There are methods in the `Threads` class that allow you to programmatically set
    which processors a thread can run on if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: The **Suspended Count** column is a count manipulated by freezing and thawing
    threads. If you freeze a thread in managed code, then the thread will not run
    even if it is able to, and the suspended count will be `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The **Process Name** column displays the Windows process that the thread is
    associated with. Since we are running our application through the Visual Studio
    debugger, you will see that our threads have **OldStarsFinder.vshost.exe** as
    the process. You can also run the Task Manager in Windows and see this process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through all of the information the **Threads** window
    supplies, what are some of the functions you can do with it? You can show or hide
    columns in the display by clicking on the **Columns** dropdown in the header of
    this window; you can also do a Group By operation of the threads to group them
    for better management. We already saw how you can double-click on a row in the
    **Location** column and see a thread's call stack. You can also make any thread
    the **Active** thread by right-clicking on it and selecting **Switch To Thread**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's examine the **Tasks** window.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Tasks window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Tasks** window was added to the Visual Studio debugger in the 2010 version
    when the TPL was added to .NET in Version 4.0\. It is similar to the **Threads**
    window and shows information about each task in your application. Tasks are created
    using the `System.Threading.Tasks.Task` class or by using the `async` and `await`
    keywords. The `async` and `await` keywords were introduced in Version 4.5 of .NET
    and will be covered in [Chapter 11](ch11.html "Chapter 11. The Asynchronous Programming
    Model"), *The Asynchronous Programming Model*. Like the **Threads** window, it
    can be accessed from the debugger in Visual Studio by navigating to **Debug**
    | **Windows**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Tasks window](img/8321EN_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s examine the information and functions you can use the **Tasks** window
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flags**: This column shows the tasks that you have flagged or unflagged.
    By clicking on this column for a task, you can flag the threads in this task.
    You can flag several tasks and then sort or use the Group By function to show
    the flagged tasks at the top. You can also filter the **Parallel Stacks** window
    by flagged tasks so you only see the parallel stacks of the tasks you are interested
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Icons**: This column shows which is the current task present on the current
    thread. This is shown by a yellow arrow. A white arrow indicates that the current
    task is at a breakpoint in the debugger. A pause symbol indicates that a task
    has been frozen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ID**: This column is a Windows-generated identification number for a task.
    In our example, I have entered `8` into the **Number of bitmaps to divide into
    for processing** textbox and then set a breakpoint after the `Parallel.ForEach`
    loop. You can see that we have created eight tasks that are all running an anonymous
    method, and that it is initiated from the **Find Old Stars** button''s click event
    handler. Their IDs are numbers 1 through 8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status**: This column shows the task''s state, which can be any of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active**: The task is currently active on the stack'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deadlocked**: The task is currently deadlocked waiting on a resource'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waiting**: The task is currently waiting on CPU allocation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduled**: The task is scheduled to start executing when a thread in the
    threadpool is available'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Completed**: The task has completed its execution'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A task is considered in a deadlock state if its thread is in a lock condition
    with another thread in the application. A task is considered waiting if it is
    waiting on a lock to be freed or another task to complete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Location**: This column displays the call stack for that particular task.
    Unlike the **Threads** window, to see the whole call stack, you need to hover
    over this column instead of double-clicking on it. Also, if a task has not started
    but is scheduled, then this column will not be populated yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent**: This column displays the ID of the task that created it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread Assignment**: This column displays the thread ID and thread name of
    the thread the task is executing on. In our example, you can see we used a number
    to name the thread of our tasks in this line of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We pass in a random number between 1 and 1,000 as the second parameter of the
    `ThreadOldStarsFinder` method and then use the following line to set the thread
    name for the corresponding task:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**APPDomain**: This column shows the application domain the task is running
    inside. The **Process** column displays the Windows ID of the Windows process
    the task is executing inside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AsyncState**: This column, if using the `async` or `await` keywords to run
    a task from a method call, shows the async state of the task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When debugging TPL applications, this window is very helpful in getting an overview
    of all of the tasks your code has generated, which are active, and the call stack
    and thread information of each of them. Combining this with the **Threads** window
    will give you a good look at all of the entities running in your application and
    where they are in their execution.
  prefs: []
  type: TYPE_NORMAL
- en: The **Tasks** window is really only useful in debugging multithreaded applications
    if you are using the TPL. If you are using threads or the `BackgroundWorker` component,
    this window will not be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Parallel Stacks window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Parallel Stacks** window is very helpful in debugging parallel applications
    because it shows you task and thread information in a graphical view almost like
    a flowchart. It shows a lot of the same information as the **Threads** and **Tasks**
    windows but in a different format and it shows relationships between the threads
    and tasks, which is very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: The **Threads** and **Tasks** windows are a good tabular way to view all of
    the entities of your multithreaded application but they do not do a real good
    job of showing relationship and program flow information.
  prefs: []
  type: TYPE_NORMAL
- en: The **Parallel Stacks** information has a **Threads** view and a **Tasks** view.
    Each of these views can also be toggled to a **Method** view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the **Threads** view of our `OldStarsFinder` application after
    the `Parallel.ForEach` command executes and the bitmap is divided into eight sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Parallel Stacks window](img/8321EN_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the **Tasks** view of our `OldStarsFinder` application after
    the `Parallel.ForEach` command executes and the bitmap is divided into eight sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Parallel Stacks window](img/8321EN_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the **Threads** view toggled to the **Method** view of our
    `OldStarsFinder` application after the `Parallel.ForEach` command executes and
    the bitmap is divided into eight sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Parallel Stacks window](img/8321EN_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the **Tasks** view toggled to **Method** view
    of our `OldStarsFinder` application after the `Parallel.ForEach` command executes
    and the bitmap is divided into eight sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Parallel Stacks window](img/8321EN_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are several items to note about this window. First is the toolbar. It
    allows you to select either **Threads** or **Tasks** from the drop-down menu.
    It also allows you to show only flagged threads in the window. Next, it allows
    you to toggle to the **Method** view, and also to zoom in on an area.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Threads** and **Tasks** views, the call path of the current thread
    is highlighted in blue. That is why you can see more than one box highlighted.
    The arrows connected to the boxes show the call path of the task or thread, and
    each box in the diagram represents a call stack. Also, if you hover over a box's
    (also known as a node) header or a row in a node, you get a tooltip. The tooltip
    of the node header shows the thread ID and name of all the threads in the call
    path leading to this node. In the row or method tooltip, you'll see the stack
    of the method.
  prefs: []
  type: TYPE_NORMAL
- en: The yellow arrow in a node indicates the active frame of the currently active
    thread. Also, the method name in all the nodes of the active thread's current
    stack frame are styled in bold. If you right-click on a method row in a stack
    frame, you will get a menu that allows you to go to that task or thread, or to
    the source code.
  prefs: []
  type: TYPE_NORMAL
- en: The **Method** view we showed earlier shows all methods that either call or
    are called by the current method. The current method is shown in the middle with
    the methods that call it below and the methods it calls above. This is a nice
    way to get a current runtime view of the Visual Studio function, **Find All References**.
    It is not exactly the same but is similar.
  prefs: []
  type: TYPE_NORMAL
- en: The **Parallel Stacks** window is probably where you will spend most of your
    time in the debug mode except for actually stepping through the code. Typically,
    you will have the **Threads** and **Tasks** windows up for a tabular reference,
    the code up to set breakpoints and step through lines, and the **Parallel Stacks**
    window to follow all of the threads, tasks, and their relations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Parallel Watch window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Parallel Watch** window allows you to display the values of an expression
    that is held on multiple threads. You can see it running a parallel application
    and select **Parallel Watch** by navigating to **Window** | **Debug**. As you
    see in the following screenshot, the **Parallel Watch** window is empty until
    you add a watch statement. Each row shows a thread that has a method call that
    matches the method on the current stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the **<Add Watch>** bar, you can type in an expression to watch.
    This allows you to see the value of the same expression in multiple threads. You
    can show up to four **Parallel Watch** windows just like the regular **Watch**
    window if you would like to watch more than one expression. You can also filter
    the watch list by using the **Filter by Boolean Expression** box in the top-right
    corner of the window. If you type in an expression there, it will only show the
    threads in which that expression is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Parallel Watch window](img/8321EN_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Parallel Watch** window is really just the **Watch** window but it allows
    you to watch the same expression on all the threads in your application. Any C#
    expression is valid in this window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we took the previously used example and added a watch
    on a variable. We are watching the `Thread.Name` value of the thread each task
    is assigned. Here is the same window after we have completed the `Parallel.ForEach`
    command. You can see only one of the tasks has executed but the others are scheduled.
    The one that has started has executed the first line of its delegate, which is
    to set the thread name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Parallel Watch window](img/8321EN_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This window is a very good way in a `Parallel.For` or `Parallel.ForEach` loop
    that is executing the same delegate multiple times in multiple tasks to view the
    value of an expression in the delegate. It allows you to see the current value
    each task has at that moment of execution.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an entire application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have examined all of the windows that the Visual Studio debugger
    provides for debugging multithreaded applications let's go through a real example.
    We will use the `OldStarsFinder` application that uses tasks and the TPL that
    we finished in [Chapter 7](ch07.html "Chapter 7. Data Parallelism"), *Data Parallelism*.
    Remember that this application takes a user-entered number and then divides a
    large bitmap file by that number into an equal number of smaller bitmap files.
    Then, using a parallel `ForEach` loop, it processes each bitmap to try and find
    old stars in the image. It keeps a track of how many old stars are found. When
    it finishes, it reassembles the pieces and displays the large bitmap with each
    old star colored blue. It also displays the final number of old stars it found.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s open our `OldStarsFinder` application in Visual Studio and set
    some breakpoints to help us get started. Then perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a breakpoint on the line of code that contains the `Parallel.ForEach` command
    as shown here:![How to do it](img/8321EN_08_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's place a second break in the `ThreadOldStarsFinder` method that each
    of the parallel tasks are executing. We will place it early in the method where
    we set the thread name using the random number that we pass in from the `Parallel.ForEach`
    command:![How to do it](img/8321EN_08_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's start the application in the debugger and enter `6` in the textbox
    for how many bitmaps to divide the large image into:![How to do it](img/8321EN_08_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's click on the **Old Star Finder** button. We will see that the code
    enters the button's click event handler and comes to the first breakpoint that
    we set at the `Parallel.ForEach` command. The following screenshot shows how the
    debugger looks along with the **Thread**, **Tasks**, **Parallel Stacks**, and
    **Parallel Watch** windows:![How to do it](img/8321EN_08_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right before we step over the `Parallel.ForEach` command, you can see that
    there are no tasks yet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_08_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'You will also see that there are no extra threads for these tasks because we
    have not executed the parallel data loop yet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_08_14.jpg)![How to do it](img/8321EN_08_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'And looking at the **Parallel Stacks** window you only see the main thread
    of the application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_08_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, let's step over the `Parallel.ForEach` command and look at these same windows
    while we are at a breakpoint in the delegate:![How to do it](img/8321EN_08_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if you hover over the line in the **Parallel Stacks** window with the yellow
    arrow, you will see the line of code each thread is executing. This is using the
    **Threads** view of the **Parallel Stacks** window:![How to do it](img/8321EN_08_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's examine the same thing using the **Tasks** view of the **Parallel
    Stacks** window:![How to do it](img/8321EN_08_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, at the same time, let's examine our **Parallel Watch** window:![How to
    do it](img/8321EN_08_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's step over the current line in the `ThreadOldStarsFinder` delegate
    method and take another look at our windows:![How to do it](img/8321EN_08_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then start stepping through the delegate and notice what happens. Here is a
    view from our example:![How to do it](img/8321EN_08_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how the information changes in the windows as you start to step through
    the delegate of one task on one thread. You will notice all of the tasks are,
    or can be, on different lines after you step over one line in this one thread.
    Also, the **Parallel Watch** window will show different values of the expression
    as you step through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let the program run until it has completed the parallel loop and it is
    ready to reassemble the pieces.![How to do it](img/8321EN_08_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, we still have multiple threads running in our application but
    no tasks. This indicates that all of the tasks we created in the `Parallel.ForEach`
    loop have completed their delegate functions and the tasks are no longer on the
    threadpool. But the application still has threads it is using and some it needs
    to clean up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have seen how to open all of the various windows in the debugger for
    parallel debugging and stepped through our multithreaded TPL-based application.
    Let's talk about what just happened and what we saw.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can see from our previous example that before we enter the `Parallel.ForEach`
    command, there are no tasks shown in our **Tasks** window or **Parallel Stacks**
    window in the **Tasks** view; this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_08_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are no tasks yet because we have not created any. But the application
    has several threads already. There is one for the main thread and it is the one
    we have a breakpoint on, one to handle .NET system events, and one for the visual
    studio debugger our application is running inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch our **Parallel Stacks** window to **Threads** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_08_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, you can see that the yellow arrow is in the **Old Stars Finder** button's
    click event handler on line **139** right where our breakpoint is. The `prsOldStarsCount`
    variable is set to `0` because that is how we initialized it, and none of the
    versions of the delegate have run yet to update it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I have stepped through the delegate line twice to let two of the parallel
    tasks get started. Let''s look at the results so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_08_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that when we step over a line in one thread, the other threads continue
    to operate until the thread we step over completes and the control is returned
    back to the debugger. So, a lot of other things can happen while we execute one
    line in one thread. As we see here, we are currently in a task numbered **3**
    at line **49**. We can also see that task **1** is currently waiting on line **57**.
    We also notice in the **Parallel Watch** window that both tasks show the value
    of **369** in the variable, `prsOldStarsCount`. What does this tell us?
  prefs: []
  type: TYPE_NORMAL
- en: 'This tells us that while we are still on one of the first lines in the delegate
    method in task **3** and it has not begun any real processing yet, other tasks
    have already found **369** old stars. You''ll also notice that both tasks in the
    **Parallel Watch** window show the same value for `prsOldStarsCount`. This is
    because this is a global variable and all tasks are looking at and updating the
    same copy. Now, let''s step over one line of code in the task **3** delegate and
    see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_08_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are on line **49** in the task numbered **4** and the value of `prsOldStarsCount`
    is **605**. What just happened? We stepped over one line in task **3** and ended
    up in task **4** on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: Remember we have a breakpoint set in the delegate method of each of the six
    tasks that our `Parallel.ForEach` loop created. When you step over a line or continue
    in the debugger, it stops at the next break point that is encountered. Also, remember
    that when we step over a line, all of our threads and tasks can run during that
    time. So, when we stepped over the line in task **3**, the next breakpoint the
    debugger came to was that same line in task **4**. You can see several things
    from our window. Tasks **2**, **3**, and **4** are all on line **49** and haven't
    gotten to line **51** (the next executable line). This tells us that when we stepped
    over line **49** in task **3** the debugger encountered a break at line **49**
    in task **4** before the execution of line **49** in task **3** got completed.
    We also see that in the time it took to reach this next break point, our tasks
    have now counted **605** old stars, up from **369**. Since task **1** is the only
    task we see past line **49**, we can surmise that it is the one that has counted
    all of these stars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s step over this line and see what happens next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_08_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This time we moved to line **49** of task **2** and no more old stars have
    been counted. Let''s step over one more line and examine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_08_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have stopped on line **49** of task **5**. You can also see that both
    tasks **1** and **3** are now past line **49** and we have now counted **869**
    old stars. Let''s step over one more line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_08_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can see we have started all six tasks that we asked for in our `Parallel.ForEach`
    loop and are already up to **1331** old stars. But even with **1331** old stars
    already found, we have not moved past line **49** in three of our six tasks. Let's
    step over one more line. Since we have reached this breakpoint line in all six
    tasks, we should now step through the current task we are on, which is task **6**.
  prefs: []
  type: TYPE_NORMAL
- en: 'But as we do so, the other tasks can all run. That being said, the machine
    we are running on has four processing cores, so not all of them can get CPU time
    at once, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_08_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we now can start to step through the current task without stopping
    because the delegate that all of the tasks are running has no more breakpoints
    that can interfere. You can also see that in the time it took to execute this
    one line in task **6**, we have now counted **1686** old stars and moved a couple
    of lines in a few other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also note that when you see **[External code]** in the stack frame, this is
    referring to .NET code and not your own source code. You can set your debugger
    to show the stack of external code, but usually this provides you with too much
    information when you are mostly concerned with the flow and debugging of your
    own source code.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, keep stepping through and see what happens; then stop your application
    and redo the exercise. Each time you run the application in the debugger, you
    should see slightly different results because we have multiple threads running
    and competing for processing time. Each time you step through the code, different
    threads will get different amounts of CPU time depending on availability and other
    competing processes running on your machine. Remember your application and debugging
    is not the only thing running in your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have examined all of the functionality that Visual Studio
    provides multithreaded and parallel application developers to help them troubleshoot
    and debug their source code. We have examined the **Threads** window, **Tasks**
    window, **Parallel Tasks** window in **Threads** mode, the **Parallel Stacks**
    window in **Tasks** mode, and the **Parallel Stacks** window. We have also examined
    our `OldStarsFinder` application using these windows and then stepped through
    its execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have learned how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine all threads of your application as it runs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine all tasks your application creates using the TPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step through an application with multiple tasks and threads running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View the stack of any thread or task in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set watch expressions and view them across all the threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss some popular design patterns for parallel
    applications.
  prefs: []
  type: TYPE_NORMAL
