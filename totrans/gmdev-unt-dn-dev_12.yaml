- en: '*Chapter 9*: The Data-Oriented Technology Stack in Unity'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*: Unity中的面向数据的技术堆栈'
- en: The Unity engine is a very developer-friendly engine. When developing game logic,
    Unity's **GameObject-Components** architecture can help developers develop functions
    quickly, and adding a new behavior to a GameObject in Unity just requires attaching
    the corresponding component to it. However, with today's games becoming more complex,
    this approach, while very developer-friendly, especially to those familiar with
    traditional **Object-Oriented Programming** (**OOP**) models, is not ideal for
    game performance and project maintainability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Unity引擎是一个非常友好的开发者引擎。在开发游戏逻辑时，Unity的**GameObject-Components**架构可以帮助开发者快速开发功能，而在Unity中给GameObject添加新行为只需将其对应的组件附加到它上。然而，随着今天游戏变得越来越复杂，这种方法虽然对开发者非常友好，尤其是对熟悉传统**面向对象编程**（**OOP**）模型的人来说，但对于游戏性能和项目可维护性来说并不理想。
- en: Therefore, Unity introduced the **Data-Oriented Technology Stack** (**DOTS**)
    to allow developers to write game code using an alternative programming philosophy
    that is data-oriented rather than object-oriented. It also introduces multithreading
    capabilities to optimize the performance of the game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Unity引入了**面向数据的技术堆栈**（**DOTS**），允许开发者使用一种面向数据而非面向对象的替代编程哲学来编写游戏代码。它还引入了多线程功能以优化游戏性能。
- en: 'The following key topics will be part of our learning path in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下关键主题：
- en: DOTS overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOTS概述
- en: Multithreading and the C# Job System in Unity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity中的多线程和C#作业系统
- en: Working with ECS in Unity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中与ECS协作
- en: Using C# and the Burst compiler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#和Burst编译器
- en: By reading this chapter, you will learn what DOTS is and the difference between
    data-oriented design and traditional object-oriented design. You will also find
    out how to use Unity's **C# Job System** to implement multithreading to improve
    game performance, how to use Unity's **Entity Component System** (**ECS**) to
    write game logic code in a data-oriented way, and how to use the **Burst compiler**
    to optimize the generated native code for Unity games.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，你将了解DOTS是什么，以及面向数据设计与传统面向对象设计的区别。你还将了解到如何使用Unity的**C#作业系统**来实现多线程以提高游戏性能，如何使用Unity的**实体组件系统**（**ECS**）以面向数据的方式编写游戏逻辑代码，以及如何使用**Burst编译器**优化为Unity游戏生成的原生代码。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The example project for this chapter is already available on GitHub. You can
    find it here: [https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers/tree/main/Chapter9-DOTS](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers/tree/main/Chapter9-DOTS).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例项目已在GitHub上提供。你可以在这里找到它：[https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers/tree/main/Chapter9-DOTS](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers/tree/main/Chapter9-DOTS)。
- en: DOTS overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOTS概述
- en: DOTS is a new programming pattern in Unity and a topic that has been discussed
    a lot in the Unity developers community in recent years.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DOTS是Unity中的一种新编程模式，也是近年来在Unity开发者社区中讨论很多的话题。
- en: '![Figure 9.1 – The Megacity demo based on DOTS'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.1 – 基于DOTS的Megacity演示]'
- en: '](img/Figure_9.01_B17146.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_9.01_B17146.jpg]'
- en: Figure 9.1 – The Megacity demo based on DOTS
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.1 – 基于DOTS的Megacity演示]'
- en: If you have previous .NET programming experience, you will be familiar with
    the **Object-Oriented Programming** (**OOP**) pattern. OOP is widely adopted in
    the software industry, and developing games with Unity was no exception until
    Unity introduced DOTS. There's no doubt that OOP is an old habit for many programmers.
    Therefore, before discussing why Unity introduced DOTS, we will first talk about
    the problems that may be encountered when using OOP in Unity development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前有.NET编程经验，你会熟悉**面向对象编程**（**OOP**）模式。OOP在软件行业中得到了广泛应用，使用Unity开发游戏也不例外，直到Unity引入了DOTS。毫无疑问，OOP对于许多程序员来说是一个老习惯。因此，在讨论为什么Unity引入DOTS之前，我们首先会谈谈在使用OOP进行Unity开发时可能遇到的问题。
- en: Object-oriented design pattern versus DOTS
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象设计模式与DOTS
- en: 'First of all, let''s talk about the concepts of OOP. We can find some useful
    information on Wikipedia. These concepts include **object/class**, **inheritance**,
    **interface**, **information hiding**, and **polymorphism**. The following link
    provides detailed explanations: [https://en.wikipedia.org/wiki/Object-oriented_design](https://en.wikipedia.org/wiki/Object-oriented_design).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来谈谈面向对象编程（OOP）的概念。我们可以在维基百科上找到一些有用的信息。这些概念包括**对象/类**、**继承**、**接口**、**信息隐藏**和**多态**。以下链接提供了详细的解释：[https://en.wikipedia.org/wiki/Object-oriented_design](https://en.wikipedia.org/wiki/Object-oriented_design)。
- en: If we focus on the object/class and inheritance, we will find that these two
    concepts are the biggest difference between OOP and DOTS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们专注于对象/类和继承，我们会发现这两个概念是面向对象编程（OOP）和DOTS之间最大的区别。
- en: 'Let''s start with an **object/class**. In a traditional OOP pattern, a class
    is a tightly coupled set of data and behavior that acts on that data. Here, we
    have an example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**对象/类**的概念开始。在传统的面向对象编程模式中，一个类是一组紧密耦合的数据和行为，这些数据和行为作用于这些数据。这里有一个例子：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the code, we have a class called `Monster` and it has some
    data for its position, health, name, and whether or not it's dead. In addition,
    this class can also behave like a real object on its own data. Each `Monster`
    object can attack the target, move itself, or die.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在代码中所见，我们有一个名为 `Monster` 的类，它包含一些关于其位置、健康、名称以及是否死亡的数据。此外，这个类还可以独立于其数据表现出真实对象的行为。每个
    `Monster` 对象都可以攻击目标、移动自己或死亡。
- en: So far, everything is perfect; the objects in the program are like objects in
    the real world, as if they have a life of their own, which is also in line with
    human experience. Next, let's discuss the **inheritance** concept of OOP. We can
    extend the data and behavior of a class and reuse some of its code via inheritance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很完美；程序中的对象就像现实世界中的对象一样，仿佛它们有自己的生命，这也符合人类经验。接下来，让我们讨论面向对象编程（OOP）的**继承**概念。我们可以通过继承扩展类的数据和行为，并重用其中的一些代码。
- en: 'Suppose in this example we realize that not all monsters attack other monsters;
    some may attack humans. From a programming perspective, humans and monsters have
    a lot in common: position, health, and whether or not it''s dead. But some monsters
    may not be killed, and humans cannot fly to move. In real life, we have a superset
    of monsters and humans, namely, creatures. Let''s put the data that monsters and
    humans share in the `Creature` class so that they can both have this data, but
    we don''t have to type them again, as shown:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在这个例子中我们意识到并不是所有的怪物都会攻击其他怪物；有些可能会攻击人类。从编程的角度来看，人类和怪物有很多共同点：位置、健康以及是否死亡。但有些怪物可能不会被杀死，而人类不能飞来移动。在现实生活中，我们有一个怪物和人类的超集，即生物。让我们将怪物和人类共享的数据放在
    `Creature` 类中，这样它们都可以拥有这些数据，但我们不必再次输入，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Basically, if we keep going with this idea, we will end up with some complex
    class diagrams where you have a bunch of different creatures, such as monsters,
    humans, animals, and plants. We haven't even considered performance and we have
    already found that OOP can give us a lot of trouble.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果我们继续这个想法，最终会得到一些复杂的类图，其中包含各种不同的生物，例如怪物、人类、动物和植物。我们甚至还没有考虑性能问题，就已经发现面向对象编程（OOP）会给我们带来很多麻烦。
- en: Now, let's see how OOP also misuses the hardware. With the development of technology,
    processor hardware is getting faster and faster, but a point that is often overlooked
    is that if the data cannot be submitted from memory to the processor fast enough,
    then no matter how fast the processor is, it will not work as fast as expected.
    **Cache**, which is located closer to the processor core, is smaller, faster memory.
    When the processor issues a memory access request, it will first check whether
    there is data in the cache. If it exists (this is also called a cache hit), the
    data is returned directly without accessing the main memory; if it does not exist,
    the corresponding data in the main memory must be loaded into the cache first
    and then returned to the processor. CPUs typically use a hierarchy with multiple
    cache levels; for example, in a two-level cache system, the **L1 cache** is close
    to the processor side, and the **L2 cache** is close to the memory side.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看面向对象编程（OOP）如何滥用硬件。随着技术的发展，处理器硬件变得越来越快，但常常被忽视的一点是，如果数据不能足够快地从内存提交到处理器，那么无论处理器有多快，它都不会像预期的那样工作得那么快。**缓存**，位于处理器核心附近，是一种更小、更快的内存。当处理器发出内存访问请求时，它首先会检查缓存中是否有数据。如果存在（这被称为缓存命中），数据将直接返回，无需访问主内存；如果不存在，必须首先将主内存中的相应数据加载到缓存中，然后再返回给处理器。CPU
    通常使用具有多个缓存级别的层次结构；例如，在两级缓存系统中，**L1 缓存**靠近处理器端，而 **L2 缓存**靠近内存端。
- en: CPU caches are designed around several assumptions. The reason why the caches
    are effective is mainly that the access to the memory when the program runs is
    characterized by locality. This locality includes both **spatial locality** and
    **temporal locality**. That is, the pieces of data we need to perform a series
    of related operations may be very close to each other in memory, or the data we
    just used for an operation may soon be used again for another operation. Taking
    advantage of this locality, caches can achieve extremely high hit rates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 缓存的设计基于几个假设。缓存之所以有效，主要是因为程序运行时对内存的访问具有局部性。这种局部性包括**空间局部性**和**时间局部性**。也就是说，我们需要执行一系列相关操作的数据片段可能在内存中非常接近，或者我们刚刚用于一个操作的数据可能很快就会用于另一个操作。利用这种局部性，缓存可以实现极高的命中率。
- en: However, OOP often misuses the hardware. Let's still use the `Monster` class
    as an example. Assuming a `Monster` object will occupy 56 bytes of memory, we
    iterate over a list of monsters and call their `Move()` function to change the
    monster's position property.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，面向对象编程（OOP）常常滥用硬件。我们仍然以 `Monster` 类为例。假设一个 `Monster` 对象将占用 56 字节内存，我们遍历怪物列表并调用它们的
    `Move()` 函数来改变怪物的位置属性。
- en: 'The pseudocode is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code actually modifies a set of Vector3 data every frame, but how is this
    data allocated in memory? The following diagram shows how monster objects are
    allocated in memory when a 64-byte cache line is split up into 8-byte chunks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上每帧都会修改一组 Vector3 数据，但这段数据在内存中的分配方式是怎样的？以下图表显示了当 64 字节缓存行被分割成 8 字节块时，怪物对象在内存中的分配情况：
- en: '![Figure 9.2 – The data layout in memory (OOP)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – 内存中的数据布局（OOP）'
- en: '](img/Figure_9.02_B17146.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B17146.jpg)'
- en: Figure 9.2 – The data layout in memory (OOP)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 内存中的数据布局（OOP）
- en: From the diagram, we can see that the position data that will be modified at
    every frame is discontinuous in memory, which means that our game cannot effectively
    use high-speed memory, that is, the caches.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中我们可以看出，每帧将要修改的位置数据在内存中是不连续的，这意味着我们的游戏无法有效地使用高速内存，即缓存。
- en: Now, let's look at the new programming pattern in Unity, DOTS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Unity 中的新编程模式，DOTS。
- en: Unlike OOP, DOTS' philosophy is to design for data rather than objects, focusing
    on prioritizing and organizing data to make its memory access as efficient as
    possible. Let's still use the `Monster` class as an example to see how its data
    is allocated in memory when using DOTS.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象编程（OOP）不同，DOTS 的哲学是针对数据而不是对象进行设计，重点是优先组织和优化数据，使其内存访问尽可能高效。让我们仍然以 `Monster`
    类为例，看看在使用 DOTS 时其数据在内存中的分配情况。
- en: '![Figure 9.3 – The data layout in memory (DOTS)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 内存中的数据布局（DOTS）'
- en: '](img/Figure_9.03_B17146.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B17146.jpg)'
- en: Figure 9.3 – The data layout in memory (DOTS)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 内存中的数据布局（DOTS）
- en: Do you remember? When moving a monster, we actually only need 12 bytes of position
    data for the monster, so the code only needs to load and process the position
    data of all the monsters to move them. Using DOTS allows us to pack all of this
    position data into an array and allocate memory more efficiently, as shown in
    the previous figure. Placing data in a contiguous array in memory improves data
    locality, which results in extremely high hit rates for caches, which improves
    code performance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您还记得吗？当移动一个怪物时，我们实际上只需要12个字节的怪物位置数据，因此代码只需要加载和处理所有怪物的位置数据来移动它们。使用DOTS允许我们将所有这些位置数据打包到一个数组中，并更有效地分配内存，如图中所示。在内存中将数据放置在连续的数组中提高了数据局部性，这导致缓存命中率极高，从而提高了代码性能。
- en: 'So, how does Unity''s DOTS make developers'' code run more efficiently? Well,
    DOTS in Unity is not just a change of programming paradigm from object-oriented
    to data-oriented; it actually includes a series of new technology modules, namely
    the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Unity的DOTS是如何使开发者的代码运行得更高效的？嗯，Unity中的DOTS不仅仅是将编程范式从面向对象转换为面向数据；它实际上包括一系列新的技术模块，即以下内容：
- en: The C# Job System
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#作业系统
- en: ECS
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECS
- en: The Burst compiler
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Burst编译器
- en: Each of them consists of one or more Unity packages. We can install the corresponding
    functions through Unity's Package Manager. Next, we will briefly introduce these
    three modules, respectively.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都包含一个或多个Unity包。我们可以通过Unity的包管理器安装相应的功能。接下来，我们将简要介绍这三个模块，分别。
- en: C# Job System
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 作业系统
- en: By using the C# Job System, we can write efficient asynchronous code in Unity
    that takes full advantage of the hardware.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用C#作业系统，我们可以在Unity中编写高效的异步代码，充分利用硬件。
- en: '![Figure 9.4 – Tech demo using the C# Job System'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 使用C#作业系统的技术演示'
- en: '](img/Figure_9.04_B17146.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.04_B17146.jpg)'
- en: Figure 9.4 – Tech demo using the C# Job System
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 使用C#作业系统的技术演示
- en: 'The preceding figure shows a demo project developed using Unity''s C# Job System,
    showing thousands of "soldiers" attacking the enemy in the scene. You can find
    this project on GitHub: [https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation](https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了使用Unity的C#作业系统开发的演示项目，展示了场景中成千上万的“士兵”攻击敌人。您可以在GitHub上找到这个项目：[https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation](https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation)。
- en: We will discuss the C# Job System in detail in the *Multithreaded and C# Job
    System in Unity* section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*Unity中的多线程和C#作业系统*部分详细讨论C#作业系统。
- en: ECS
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ECS
- en: The full name of **ECS** is **Entity Component System**. It is the core part
    of DOTS in Unity and is built around using data-oriented design, which is very
    different from the object-oriented design you may be used to.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECS**的全称是**实体组件系统**。它是Unity中DOTS的核心部分，围绕使用面向数据的设计构建，这与您可能习惯的面向对象设计非常不同。'
- en: '![Figure 9.5 – The Megacity demo'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 – 大都市演示'
- en: '](img/Figure_9.05_B17146.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.05_B17146.jpg)'
- en: Figure 9.5 – The Megacity demo
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 大都市演示
- en: 'The preceding figure shows Unity''s impressive tech demo using ECS called **Megacity**,
    which developers can download here: [https://unity.com/megacity](https://unity.com/megacity).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了Unity使用ECS的令人印象深刻的演示项目，名为**Megacity**，开发者可以在此处下载：[https://unity.com/megacity](https://unity.com/megacity)。
- en: '![Figure 9.6 – Megacity download page'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 大都市下载页面'
- en: '](img/Figure_9.06_B17146.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.06_B17146.jpg)'
- en: Figure 9.6 – Megacity download page
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 大都市下载页面
- en: We'll cover ECS in detail in the *Working with ECS in Unity* section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*在Unity中使用ECS*部分详细介绍ECS。
- en: The Burst compiler
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Burst编译器
- en: The Burst compiler in Unity is an advanced compiler technology. Unity projects
    made with DOTS can use Burst technology to improve their runtime performance.
    Burst works on a subset of C# called **High-Performance C#** (**HPC#**) and applies
    advanced optimization methods under the LLVM compiler framework to generate efficient
    binaries, which achieves efficient use of device energy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的Burst编译器是一种高级编译技术。使用DOTS制作的Unity项目可以使用Burst技术来提高它们的运行时性能。Burst在C#的一个子集上工作，称为**高性能C#**（**HPC#**），并在LLVM编译器框架下应用高级优化方法来生成高效的二进制文件，从而实现设备能量的高效利用。
- en: We will introduce how to use it in your project in a later section, *Using C#
    and the Burst compiler*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的部分介绍如何在您的项目中使用它，*使用C#和Burst编译器*。
- en: This section introduces DOTS-related knowledge, such as what technology modules
    DOTS contains, how its design philosophy differs from traditional OOP, and what
    problems it solves. However, DOTS is not a replacement for OOP; it just provides
    another efficient programming pattern for game developers in Unity. For example,
    you can still use the C# Job System to implement multithreaded programming in
    the traditional Unity GameObject-Components style, rather than maintaining thread
    pools yourself. Well, next, let's explore how to implement efficient multithreaded
    programming in Unity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了与DOTS相关的知识，例如DOTS包含哪些技术模块，其设计理念与传统面向对象编程（OOP）有何不同，以及它解决了哪些问题。然而，DOTS并不是OOP的替代品；它只是为Unity中的游戏开发者提供了一种另一种高效的编程模式。例如，你仍然可以使用C#
    Job System以传统的Unity GameObject-Components风格实现多线程编程，而不是自己维护线程池。好吧，接下来，让我们探索如何在Unity中实现高效的多线程编程。
- en: Multithreading and the C# Job System in Unity
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity中的多线程和C# Job System
- en: Asynchronous programming is very common when developing .NET projects. But unlike
    what many people who are familiar with .NET development think, Unity's support
    for asynchronous programming was not friendly at first.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发.NET项目时，异步编程非常常见。但与许多熟悉.NET开发的开发者所想的不同，Unity对异步编程的支持最初并不友好。
- en: Coroutines
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程
- en: Before Unity 2017, if a game developer wanted to handle asynchronous operations,
    a common scenario was waiting for a network response. The ideal solution was to
    use **coroutines** in Unity.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity 2017之前，如果游戏开发者想要处理异步操作，一个常见的场景是等待网络响应。理想的解决方案是在Unity中使用**协程**。
- en: 'We can start a coroutine in Unity as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Unity中如下启动协程：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see in the code, we use the `StartCoroutine` function to start a
    coroutine, and inside the coroutine, we can pause the execution by using `yield`
    statements. However, coroutines are still inherently single-threaded, just spread-out
    tasks across multiple frames, rather than multithreaded.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，我们使用`StartCoroutine`函数启动协程，并在协程内部使用`yield`语句暂停执行。然而，协程本质上仍然是单线程的，只是将任务分散到多个帧中，而不是多线程。
- en: async/await
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: async/await
- en: 'Unity introduced the `async/await` operator in Unity 2017, allowing game developers
    to use `async/await` in their games to write asynchronous code, but it''s still
    not like a normal .NET/C# program. This is because the Unity engine manages these
    threads by itself, and most of the logic runs on Unity''s main thread, which includes
    not only the C# code as scripts but also the engine''s C++ code. We can use the
    **Unity Profiler** tool to view the CPU timeline. As shown in the following screenshot,
    the Unity engine runs scripts in the main thread by default:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在2017年引入了`async/await`运算符，允许游戏开发者在其游戏中使用`async/await`编写异步代码，但它仍然不像一个正常的.NET/C#程序。这是因为Unity引擎自行管理这些线程，大部分逻辑都在Unity的主线程上运行，包括作为脚本的C#代码以及引擎的C++代码。我们可以使用**Unity
    Profiler**工具来查看CPU时间线。如下面的截图所示，Unity引擎默认在主线程上运行脚本：
- en: '![Figure 9.7 – The Timeline of CPU'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.7 – CPU时间线](img/Figure_9.07_B17146.jpg)'
- en: '](img/Figure_9.07_B17146.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.07 – CPU时间线](img/Figure_9.07_B17146.jpg)'
- en: Figure 9.7 – The Timeline of CPU
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – CPU时间线
- en: There are 50 GameObjects in this scene, and each of them is attached with a
    **MainThreadExample** script. You can see that the **Update** functions in these
    50 scripts are executed one by one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中有50个GameObject，每个都附加了一个**MainThreadExample**脚本。你可以看到，这50个脚本中的**Update**函数是依次执行的。
- en: You can multithread different types of tasks; for example, doing some Vector3
    math in a separate thread is no problem. But as long as the task needs to access
    the transform or GameObject outside Unity's main thread, the program will throw
    an exception.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对不同类型的任务进行多线程处理；例如，在单独的线程中执行一些Vector3数学运算是没有问题的。但是，只要任务需要访问Unity主线程之外的transform或GameObject，程序就会抛出异常。
- en: 'Let''s look at an example. The purpose of the following code is to change the
    scale of the GameObject and use `async/await` to perform the operation in another
    thread:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。以下代码的目的是改变GameObject的缩放，并使用`async/await`在另一个线程中执行操作：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Attach this script to a GameObject in the scene, then click the **Play** button
    in the Unity editor to run the script. The result of the operation is that the
    scale of the GameObject has not changed, and a **UnityException: get_transform
    can only be called from the main thread** exception is thrown, as shown in the
    following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '将此脚本附加到场景中的 GameObject 上，然后在 Unity 编辑器中点击**播放**按钮来运行脚本。操作的结果是 GameObject 的缩放没有改变，并抛出了**UnityException:
    get_transform 只能从主线程调用**异常，如下面的截图所示：'
- en: '![Figure 9.8 – Exception'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8 – 异常'
- en: '](img/Figure_9.08_B17146.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.08_B17146.jpg)'
- en: Figure 9.8 – Exception
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 异常
- en: So, you should take care of this and not access transforms or GameObjects from
    threads other than Unity's main thread.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该注意这一点，不要从 Unity 的主线程以外的线程访问变换或 GameObject。
- en: 'As we mentioned earlier, we can do math in a separate thread. So, in order
    to make the previous code work correctly, we can just calculate the scale value
    in different threads, access the `Transform` component, and modify the `localScale`
    property of it in Unity''s main thread:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们可以在单独的线程中进行数学运算。因此，为了使之前的代码正确运行，我们可以在不同的线程中计算缩放值，访问 `Transform`
    组件，并在 Unity 的主线程中修改其 `localScale` 属性：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This time, everything is going well and if we view the Unity Profiler again,
    we can find the timeline of these threads in the **Scripting Threads** section,
    as shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，一切都很顺利，如果我们再次查看 Unity Profiler，我们可以在**脚本线程**部分找到这些线程的时间线，如下面的截图所示：
- en: '![Figure 9.9 – Scripting threads'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 脚本线程'
- en: '](img/Figure_9.09_B17146.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.09_B17146.jpg)'
- en: Figure 9.9 – Scripting threads
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 脚本线程
- en: 'However, as a developer, there are still many challenges with writing thread-safe
    and efficient code even in C#, such as the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为一名开发者，即使在 C# 中编写线程安全和高效的代码也仍然存在许多挑战，如下所示：
- en: Thread-safe code is hard to write.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写线程安全代码很难。
- en: Race conditions, where the result of a computation depends on the order in which
    two or more threads are scheduled.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞态条件，其中计算的输出取决于两个或多个线程被调度的顺序。
- en: Inefficient context switching; is time-consuming when switching threads.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不高效的上下文切换；切换线程时耗时。
- en: The C# Job System in Unity is a solution that focuses on solving these challenges
    so that we can enjoy the benefits of multithreading to develop games. Next, let's
    explore how to use the C# Job System in our Unity projects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的 C# 作业系统是一个专注于解决这些挑战的解决方案，以便我们可以享受多线程带来的好处。接下来，让我们探索如何在我们的 Unity 项目中使用
    C# 作业系统。
- en: Working with the C# Job System
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 C# 作业系统一起工作
- en: The **Job System** was originally the internal thread management system of the
    Unity engine, but with the growth of developers' demands for multithreaded programming
    in Unity, Unity introduced the C# Job System, which allows developers to write
    multithreaded parallel processing code painlessly in C# scripts to improve games'
    performance. Game developers do not need to implement complex thread pools themselves
    to keep each thread running properly. The C# Job System is integrated with Unity's
    native Job System, and C# script code and Unity engine's C++ code share threads.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**作业系统**最初是 Unity 引擎的内部线程管理系统，但随着开发者对 Unity 中多线程编程需求的增长，Unity 引入了 C# 作业系统，这使得开发者能够在
    C# 脚本中轻松地编写多线程并行处理代码，以提高游戏性能。游戏开发者不需要自己实现复杂的线程池来确保每个线程正常运行。C# 作业系统与 Unity 的原生作业系统集成，C#
    脚本代码和 Unity 引擎的 C++ 代码共享线程。'
- en: This form of cooperation allows game developers to write code in the way required
    by the Job System; the Unity engine handles multithreading for game developers
    and developers no longer have to worry about problems that may be encountered
    when writing multithreaded code, because the C# Job System will not create any
    managed threads, but instead use Unity's worker threads on multiple cores, giving
    them tasks, which are called **jobs** in Unity.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种合作形式允许游戏开发者以作业系统所需的方式编写代码；Unity 引擎为游戏开发者处理多线程，开发者不再需要担心编写多线程代码时可能遇到的问题，因为
    C# 作业系统不会创建任何托管线程，而是使用 Unity 的多核工作线程，给它们分配任务，这些任务在 Unity 中被称为**作业**。
- en: Installing the Jobs package
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Jobs 包
- en: 'In order to install and enable the **Job System** in your project, you need
    to install the **Jobs** package first, as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在项目中安装和启用**作业系统**，您首先需要安装**Jobs**包，如下面的截图所示：
- en: '![Figure 9.10 – The Jobs package'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – Jobs 包'
- en: '](img/Figure_9.10_B17146.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_B17146.jpg)'
- en: Figure 9.10 – The Jobs package
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 作业包
- en: 'However, the **Jobs** package is currently still in the preview state, as shown
    in the preceding screenshot, and the Unity Package Manager does not display packages
    in the preview state by default. So, if you can''t find the **Jobs** package,
    then you need to follow these steps to allow showing the package in the preview
    state:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**作业**包目前仍然处于预览状态，如前面的屏幕截图所示，Unity 包管理器默认不显示预览状态的包。因此，如果您找不到**作业**包，则需要按照以下步骤操作以允许显示预览状态的包：
- en: 'Open the **Project Settings** window by clicking the **Edit** | **Project Settings…**
    item in the Unity editor toolbar, as shown in the following screenshot:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击 Unity 编辑器工具栏中的**编辑** | **项目设置…**项打开**项目设置**窗口，如图以下屏幕截图所示：
- en: '![Figure 9.11 – Opening the Project Settings window'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – 打开项目设置窗口'
- en: '](img/Figure_9.11_B17146.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.11_B17146.jpg)'
- en: Figure 9.11 – Opening the Project Settings window
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 打开项目设置窗口
- en: Next, click the **Package Manager** item in the category list on the left to
    open the **Package Manager** settings panel.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击左侧分类列表中的**包管理器**项以打开**包管理器**设置面板。
- en: '![Figure 9.12 – Opening the Package Manager settings'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – 打开包管理器设置'
- en: '](img/Figure_9.12_B17146.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.12_B17146.jpg)'
- en: Figure 9.12 – Opening the Package Manager settings
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 打开包管理器设置
- en: In the following screenshot, you can see that the **Enable Preview Packages**
    option is not selected by default. Let's check it to enable preview packages in
    the Unity Package Manager.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到**启用预览包**选项默认未选中。让我们检查它以在 Unity 包管理器中启用预览包。
- en: '![Figure 9.13 – Enable Preview Packages'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.13 – 启用预览包'
- en: '](img/Figure_9.13_B17146.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.13_B17146.jpg)'
- en: Figure 9.13 – Enable Preview Packages
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 启用预览包
- en: Once done, you should be able to find the **Jobs** package and install it into
    your project.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您应该能够找到**作业**包并将其安装到您的项目中。
- en: Next, let's look at an example to understand how to use the Job System to improve
    the performance of a game.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过一个示例来了解如何使用作业系统来提高游戏性能。
- en: How to use the C# Job System
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用 C# 作业系统
- en: In this example, we will first use Unity's traditional way, that is, the GameObject+Components
    way, to create 10,000 cartoon cars in a game scene, with each car containing a
    Movement component to move it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将首先使用 Unity 的传统方式，即 GameObject+Components 方式，在游戏场景中创建 10,000 个卡通汽车，每个汽车包含一个用于移动的组件。
- en: '![Figure 9.14 – The car models'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.14 – 汽车模型'
- en: '](img/Figure_9.14_B17146.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.14_B17146.jpg)'
- en: Figure 9.14 – The car models
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 汽车模型
- en: 'The car models used in this example are from the Unity Asset Store, and you
    can download them here: [https://assetstore.unity.com/packages/3d/vehicles/land/mobile-toon-cars-free-99857](https://assetstore.unity.com/packages/3d/vehicles/land/mobile-toon-cars-free-99857).
    Then, take the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中使用的汽车模型来自 Unity 资产商店，您可以从这里下载它们：[https://assetstore.unity.com/packages/3d/vehicles/land/mobile-toon-cars-free-99857](https://assetstore.unity.com/packages/3d/vehicles/land/mobile-toon-cars-free-99857)。然后，按照以下步骤操作：
- en: 'Let''s create our first C# script, named `CarSpawner`, to generate the cars
    in the scene. In this script, we can create 10,000 new car instances from the
    car prefab by pressing the spacebar. As you can see in the following code, inside
    the `Update` method, we use the `Input.GetKeyDown(KeyCode.Space)` method to check
    whether the spacebar is pressed. If the spacebar is pressed, the `CreateCars`
    method is called to create new car instances:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个 C# 脚本，命名为`CarSpawner`，以在场景中生成汽车。在这个脚本中，我们可以通过按空格键从汽车预制体创建 10,000
    个新的汽车实例。正如您在以下代码中可以看到的，在`Update`方法内部，我们使用`Input.GetKeyDown(KeyCode.Space)`方法来检查是否按下了空格键。如果按下了空格键，则调用`CreateCars`方法来创建新的汽车实例：
- en: '[PRE6]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we also need another script that will be attached to each of the car
    objects to move them. As you can see, this `Movement` script is relatively simple;
    it moves the GameObject forward:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还需要另一个脚本，该脚本将附加到每个汽车对象上以移动它们。如您所见，这个`Movement`脚本相对简单；它将 GameObject 向前移动：
- en: '[PRE7]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, attach this `Movement` script to the car prefab.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此`Movement`脚本附加到汽车预制体上。
- en: '![Figure 9.15 – The car Prefab'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.15 – 汽车预制体'
- en: '](img/Figure_9.15_B17146.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.15_B17146.jpg)'
- en: Figure 9.15 – The car Prefab
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 汽车预制体
- en: 'Click the **Play** button in the Unity editor to run the example and press
    the spacebar to generate 10,000 cars in the scene. As shown in the following screenshot,
    when there are 10,000 cars in the scene, the value of **Frames per Second** (**FPS**)
    is around **12**:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中点击**播放**按钮运行示例，并按空格键在场景中生成 10,000 辆车。如图所示，当场景中有 10,000 辆车时，**每秒帧数**（**FPS**）的值大约为
    **12**：
- en: '![Figure 9.16 – The FPS'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.16 – FPS]'
- en: '](img/Figure_9.16_B17146.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.16_B17146.jpg)'
- en: Figure 9.16 – The FPS
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – FPS
- en: We can view the CPU usage timeline of this example. Press *Ctrl* + *7* or click
    the `Movement.Update` for these 10,000 cars happens on the main thread while the
    job workers are idle.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以查看此示例的 CPU 使用时间线。按 *Ctrl* + *7* 或点击 `Movement.Update`，以查看这 10,000 辆车的移动操作是在主线程上执行，而作业工作者处于空闲状态。
- en: '![Figure 9.17 – The Timeline of CPU'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.17 – CPU 时间线]'
- en: '](img/Figure_9.17_B17146.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.17_B17146.jpg)'
- en: Figure 9.17 – The Timeline of CPU
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – CPU 时间线
- en: Obviously, when we see all the logic being executed on the main thread, as game
    developers we definitely want to be able to have some operations running on other
    threads. However, before we start writing some real code, we should cover a little
    bit about how to write jobified code in Unity.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当我们看到所有逻辑都在主线程上执行时，作为游戏开发者，我们肯定希望能够在其他线程上运行一些操作。然而，在我们开始编写实际代码之前，我们应该稍微了解一下如何在
    Unity 中编写 job 化代码。
- en: 'In Unity''s Job System, each job can be seen as a method call. When writing
    a new job, you must follow these points:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 的 Job 系统中，每个作业都可以看作是一个方法调用。当编写一个新的作业时，你必须遵循以下这些要点：
- en: In order to ensure that the data is distributed contiguously in memory, and
    to reduce **Garbage Collection** (**GC**) pressure, a job must be a value type,
    which means it must be a struct, never a class.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保数据在内存中连续分布，并减少 **垃圾回收**（**GC**）压力，作业必须是一个值类型，这意味着它必须是一个结构体，而不是一个类。
- en: A new job struct needs to implement the `IJob` interface. There are many variants
    of the `IJob` interface, such as `IJobParallelFor`, `IJobParallelForBatch`, and
    `IJobParallelForTransform`. When implementing these interfaces, we need to implement
    the `Execute` method. It is worth noting that the parameters required by the `Execute`
    method are different when implementing different variants of the `IJob` interface,
    which allows us to handle different scenarios. For example, a new `job` implementing
    the `IJobParallelForTransform` interface can access transform data, such as position,
    rotation, and scale data, in parallel.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的作业结构需要实现 `IJob` 接口。`IJob` 接口有许多变体，例如 `IJobParallelFor`、`IJobParallelForBatch`
    和 `IJobParallelForTransform`。在实现这些接口时，我们需要实现 `Execute` 方法。值得注意的是，实现不同的 `IJob`
    接口变体时，`Execute` 方法所需的参数不同，这使我们能够处理不同的场景。例如，一个实现 `IJobParallelForTransform` 接口的新
    `job` 可以并行访问转换数据，例如位置、旋转和缩放数据。
- en: 'The following code is for a sample job that implements the `IJobParallelFor`
    interface:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个实现 `IJobParallelFor` 接口的示例作业的代码：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have created a new job, but how do we make it work? Well, we have to schedule
    it. Usually, scheduling a job is very simple. The following code demonstrates
    how to schedule it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个新的作业，但如何让它工作呢？嗯，我们必须安排它。通常，安排作业非常简单。以下代码演示了如何安排它：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ve covered some basics on how to create a new job and how to make it work.
    Now, let''s use the Job System to rewrite the `Movement` script to distribute
    the operation of moving the cars to different threads to run:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些关于如何创建新作业以及如何让它工作的基础知识。现在，让我们使用 Job 系统重写 `Movement` 脚本来将移动车辆的操作分配到不同的线程上运行：
- en: 'First of all, let''s create a job that moves cars. You can find the new `MotionJob`
    script below. `MotionJob` is a struct rather than a class and implements the `IJobParallelForTransform`
    interface, so this job can access the position data and modify it:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个移动车辆的作业。您可以在下面的新 `MotionJob` 脚本中找到它。`MotionJob` 是一个结构体而不是类，并实现了 `IJobParallelForTransform`
    接口，因此这个作业可以访问位置数据并对其进行修改：
- en: '[PRE10]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need another script called `JobsManager` to create the job, provide
    it with transform data (specifically in the script, we use the `TransformAccessArray`
    struct to provide this data), and schedule it. Also, this script is similar to
    the previous `CarSpawner` script. It checks whether the spacebar is pressed and
    creates 10,000 cars in the game scene if the spacebar is pressed. First, let''s
    see how to create and schedule a job on Unity''s Job worker thread. In the `Update`
    method, we create a new `MotionJob` object and pass data to it, such as `deltaTime`,
    `speed`, and `direction` to create a new job, then we call `_motionJob.Schedule`
    to distribute the job to different threads:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要另一个名为 `JobsManager` 的脚本，用于创建作业，为其提供转换数据（具体来说，在脚本中，我们使用 `TransformAccessArray`
    结构来提供这些数据），并安排它。此外，此脚本与之前的 `CarSpawner` 脚本类似。它检查空格键是否被按下，如果按下空格键，则在游戏场景中创建 10,000
    辆车。首先，让我们看看如何在 Unity 的 Job 工作线程上创建和安排一个作业。在 `Update` 方法中，我们创建一个新的 `MotionJob`
    对象，并向它传递数据，例如 `deltaTime`、`speed` 和 `direction` 以创建一个新的作业，然后我们调用 `_motionJob.Schedule`
    将作业分配到不同的线程：
- en: '[PRE11]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, let''s see how to create cars in the code. Since we only need the position
    data for these cars this time, in the `CreateCars` method, we add the car''s transform
    data to `TransformAccessArray` so that the job we just created can access `TransformAccessArray`
    to get that transform data. The `CreateCars` method is as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在代码中创建车辆。由于这次我们只需要这些车辆的位置数据，在 `CreateCars` 方法中，我们将汽车的转换数据添加到 `TransformAccessArray`
    中，以便我们刚刚创建的作业可以访问 `TransformAccessArray` 以获取这些转换数据。`CreateCars` 方法如下：
- en: '[PRE12]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This time, we no longer need to attach the Movement component to each car instance
    at runtime to move the car, so we need to remove the **Movement** component that
    was previously attached to the car prefab.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们不再需要在运行时将移动组件附加到每辆车的实例上来移动车辆，因此我们需要移除之前附加到汽车预制体上的 **移动** 组件。
- en: '![Figure 9.18 – Removing the Movement component'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.18 – 移除移动组件'
- en: '](img/Figure_9.18_B17146.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.18_B17146.jpg)'
- en: Figure 9.18 – Removing the Movement component
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 移除移动组件
- en: 'Click the **Play** button in the Unity editor to run the example and press
    the spacebar to generate 10,000 cars in the scene. As shown in the following screenshot,
    when there are 10,000 cars in the scene, this time the value of FPS is around
    **19**. In a scene with 10,000 cars in motion, the game''s frame rate nearly doubled:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中点击 **播放** 按钮来运行示例，并按空格键在场景中生成 10,000 辆车。如图所示，当场景中有 10,000 辆车时，这次帧率值约为
    **19**。在一个有 10,000 辆车移动的场景中，游戏的帧率几乎翻倍：
- en: '![Figure 9.19 – The FPS'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.19 – 帧率'
- en: '](img/Figure_9.19_B17146.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.19_B17146.jpg)'
- en: Figure 9.19 – The FPS
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 帧率
- en: Let's press *Ctrl* + *7* or click the **Window** | **Analysis** | **Profiler**
    item in the Unity editor toolbar to open the **Profiler** window to view the CPU
    usage timeline this time. Here, we can see that **MotionJob** is spread over multiple
    Job worker threads in Unity, instead of running on the main thread.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按 *Ctrl* + *7* 或在 Unity 编辑器的工具栏中点击 **窗口** | **分析** | **性能分析器** 项来打开 **性能分析器**
    窗口，查看这次 CPU 使用的时间线。在这里，我们可以看到 **MotionJob** 在 Unity 中分布在多个 Job 工作线程上，而不是在主线程上运行。
- en: '![Figure 9.20 – Running on Job worker threads'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.20 – 在 Job 工作线程上运行'
- en: '](img/Figure_9.20_B17146.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.20_B17146.jpg)'
- en: Figure 9.20 – Running on Job worker threads
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – 在 Job 工作线程上运行
- en: Through this example, we saw how to use the Job System in Unity to improve the
    running performance of the game.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例，我们看到了如何使用 Unity 中的 Job 系统来提高游戏的运行性能。
- en: In this section, we discussed topics related to using asynchronous programming
    in Unity. Next, we will discuss another important topic in DOTS – namely, ECS.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了与在 Unity 中使用异步编程相关的话题。接下来，我们将讨论 DOTS 中的另一个重要话题——即，ECS。
- en: Working with ECS in Unity
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Unity 中使用 ECS
- en: Unity has always been centered around the concept of components; for example,
    we can add a Movement component to a GameObject so that the object can move. We
    can also add a Light component to the GameObject to make it emit light. We also
    add the AudioSource component, which can make the GameObject emit sound. In this
    case, the GameObject is a container to which game developers can attach different
    components to provide different behaviors. We can call this architecture a **GameObject-Components**
    relationship. In this architecture, we use the traditional OOP programming paradigm
    to write components, coupling data and behavior together. In the previous section,
    *Object-oriented design pattern versus DOTS*, we also discussed the impact of
    OOP on game performance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Unity始终围绕组件的概念展开；例如，我们可以向GameObject添加一个Movement组件，使对象可以移动。我们还可以向GameObject添加一个Light组件，使其发出光线。我们还可以添加AudioSource组件，使GameObject可以发出声音。在这种情况下，GameObject是一个容器，游戏开发者可以将其附加不同的组件以提供不同的行为。我们可以称这种架构为**GameObject-Components**关系。在这个架构中，我们使用传统的OOP编程范式来编写组件，将数据和行为耦合在一起。在上一节*面向对象设计模式与DOTS*中，我们也讨论了OOP对游戏性能的影响。
- en: So, to address these issues, Unity introduced ECS, which allows developers to
    write data-oriented code in Unity. In ECS, data and behavior are separated, which
    can greatly improve memory usage efficiency and thus improve performance.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这些问题，Unity引入了ECS，允许开发者在Unity中编写面向数据的代码。在ECS中，数据和行为是分离的，这可以大大提高内存使用效率，从而提高性能。
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The so-called **behavior** here, specifically, is **methods**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所说的所谓**行为**，具体来说，是**方法**。
- en: 'As its name suggests, ECS consists of three parts, namely the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，ECS由三部分组成，即以下内容：
- en: Entity
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity
- en: Component
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Component
- en: System
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: System
- en: We will introduce them respectively in the following sections.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下各节中分别介绍它们。
- en: Entity
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Entity
- en: When using ECS, we talk more about entities, not GameObjects. You might think
    that there is not much difference between an entity and a GameObject, because
    you might think of an entity as a container for components, just like a GameObject.
    However, this is not the case. An entity is just an integer ID. It is neither
    an object nor a container. Its function is to associate the data of its components
    together.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ECS时，我们更多地谈论实体，而不是GameObject。你可能会认为实体和GameObject之间没有太大区别，因为你可能会将实体视为组件的容器，就像GameObject一样。然而，情况并非如此。实体只是一个整数ID。它既不是对象，也不是容器。它的功能是将其组件的数据关联起来。
- en: EntityManager and World
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EntityManager和World
- en: If you want to create new entities in your own C# code, Unity provides the `EntityManager`
    class to manage entities, which you can use to create entities, update entities,
    and destroy entities. ECS uses the `World` class to organize entities, and only
    one `EntityManager` instance can exist in a `World`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的C#代码中创建新的实体，Unity提供了`EntityManager`类来管理实体，你可以使用它来创建实体、更新实体和销毁实体。ECS使用`World`类来组织实体，并且在一个`World`中只能存在一个`EntityManager`实例。
- en: 'When we click the `World` by default, so we can get the `EntityManager` that
    exists in the default `World` with the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们默认点击`World`时，因此我们可以通过以下代码获取默认`World`中存在的`EntityManager`：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Archetypes
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Archetypes
- en: 'ECS combines all entities with the same set of components in memory. ECS refers
    to this type of component set as an `EntityManager` to create an Archetype that
    holds a set of components:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ECS将内存中具有相同组件集的所有实体组合在一起。ECS将这种类型的组件集称为`EntityManager`，以创建一个包含一组组件的Archetype：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: NativeArray
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NativeArray
- en: Undoubtedly, we also need an array to hold the newly created entities. But in
    ECS, we will use a different container than a traditional array in .NET programming,
    namely, `NativeArray`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，我们还需要一个数组来存储新创建的实体。但在ECS中，我们将使用与.NET编程中的传统数组不同的容器，即`NativeArray`。
- en: '`NativeArray` provides a C# wrapper for accessing native memory so that game
    developers can share data directly between managed and native memory. Therefore,
    operations on `NativeArray` do not generate GC of managed memory like common arrays
    in .NET and require elements to be value types, that is, structs. The following
    pseudocode shows how to create a new `NativeArray` and create new entities:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`NativeArray`提供了一个C#包装器，用于访问原生内存，以便游戏开发者可以直接在托管和原生内存之间共享数据。因此，对`NativeArray`的操作不会像.NET中的常见数组那样生成GC的托管内存，并且需要元素是值类型，即结构体。以下伪代码显示了如何创建一个新的`NativeArray`并创建新的实体：'
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Component
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Component
- en: In ECS, there are also components, but the component in ECS is a different concept
    from the Movement "component" mentioned when talking about the GameObject-Components
    relationship previously. Before ECS was introduced, we usually thought of `MonoBehaviour`
    attached to GameObjects as components. `MonoBehaviour` contains data and behavior.
    ECS is different because entities and components do not have any behavioral logic;
    they only contain data, and logical operations will be handled by the system in
    ECS.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECS中，也存在组件，但ECS中的组件与之前在谈论GameObject-Components关系时提到的Movement "组件"是不同的概念。在ECS引入之前，我们通常将附加到GameObject上的`MonoBehaviour`视为组件。`MonoBehaviour`包含数据和行为。ECS的不同之处在于实体和组件没有任何行为逻辑；它们只包含数据，逻辑操作将由ECS中的系统处理。
- en: 'A component must be a struct rather than a class and needs to implement one
    of the following interfaces:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件必须是一个结构体而不是一个类，并且需要实现以下接口之一：
- en: '`IComponentData`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IComponentData`'
- en: '`ISharedComponentData`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISharedComponentData`'
- en: '`IBufferElementData`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IBufferElementData`'
- en: '`ISystemStateComponentData`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISystemStateComponentData`'
- en: '`ISharedSystemStateComponentData`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISharedSystemStateComponentData`'
- en: 'The `IComponentData` interface is commonly used. The following uses it as an
    example to show how to create a new component in ECS:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`IComponentData`接口是常用的。以下使用它作为示例来展示如何在ECS中创建一个新的组件：'
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you try to add this `SampleComponent` to a GameObject in the scene, you
    will find that you can''t because it doesn''t inherit from the `MonoBehaviour`
    class. But you can add the `[GenerateAuthoringComponent]` attribute to your component
    to mark it as an authoring component, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试将此`SampleComponent`添加到场景中的GameObject，您会发现您不能这样做，因为它没有继承自`MonoBehaviour`类。但是，您可以将`[GenerateAuthoringComponent]`属性添加到您的组件中，将其标记为作者组件，如下所示：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An authoring component can be added to a GameObject even if it does not inherit
    from MonoBehaviour.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不继承自MonoBehaviour，作者组件也可以添加到GameObject中。
- en: System
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统
- en: We already know that when using ECS, data and behavior are decoupled. In ECS,
    all logic is handled by **systems**, which takes a group of entities and performs
    the requested behavior based on the data contained in the grouped entities. As
    we already know, using ECS can make our code access memory efficiently, and in
    fact, systems in ECS can also be combined with the C# Job System to efficiently
    utilize multithreading and further improve game performance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，在使用ECS时，数据和行为是解耦的。在ECS中，所有逻辑都由**系统**处理，它接受一组实体并根据分组实体中包含的数据执行请求的行为。正如我们所知，使用ECS可以使我们的代码高效地访问内存，实际上，ECS中的系统还可以与C#
    Job System结合使用，以有效地利用多线程并进一步提高游戏性能。
- en: 'We can create a new system in ECS. The following code is an example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在ECS中创建一个新的系统。以下代码是一个示例：
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, this new `SampleSystem` inherits the `SystemBase` class, and
    there is a `ScheduleParallel` Lambda function`Entites.ForEach` loop in `OnUpdate`
    for scheduling work to Unity's Job worker threads using the C# Job System.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这个新的`SampleSystem`继承自`SystemBase`类，在`OnUpdate`中有一个`ScheduleParallel`
    Lambda函数`Entites.ForEach`循环用于使用C# Job System调度工作到Unity的Job工作线程。
- en: Through these brief introductions, I believe you have a general understanding
    of ECS. Next, let's install ECS in our project.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简要介绍，我相信您已经对ECS有一个大致的了解。接下来，让我们在我们的项目中安装ECS。
- en: Installing the Entities and Hybrid Renderer packages
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Entities和Hybrid Renderer包
- en: 'In order to install and enable ECS in your project, you need to install the
    **Entities** package first, as shown in the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的项目中安装和启用ECS，您首先需要安装**Entities**包，如下面的截图所示：
- en: '![Figure 9.21 – The Entities package'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.21 – Entities包'
- en: '](img/Figure_9.21_B17146.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.21_B17146.jpg]'
- en: Figure 9.21 – The Entities package
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 – Entities包
- en: 'As shown in the preceding screenshot, the **Entities** package is also in the
    preview state. Although we checked the **Enable Preview Packages** option in the
    previous subsection, the Package Manager still does not display this package.
    This is because starting from Unity 2020.1, this package is no longer hosted on
    Unity Registry, but hosted on GitHub, so we need to follow these steps to install
    it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，**Entities**包也处于预览状态。尽管我们在前面的子节中检查了**启用预览包**选项，但包管理器仍然没有显示此包。这是因为从Unity
    2020.1开始，此包不再托管在Unity Registry上，而是托管在GitHub上，因此我们需要遵循以下步骤来安装它：
- en: 'The Package Manager window can be opened by clicking the **Window** | **Package
    Manager** item in the Unity editor toolbar, as shown in the following screenshot:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过点击Unity编辑器工具栏中的**窗口** | **包管理器**项来打开包管理器窗口，如下截图所示：
- en: '![Figure 9.22 – Opening the Package Manager window'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.22 – 打开包管理器窗口'
- en: '](img/Figure_9.22_B17146.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.22_B17146.jpg)'
- en: Figure 9.22 – Opening the Package Manager window
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 – 打开包管理器窗口
- en: Click the **+** button in the upper-left corner to add packages from other sources.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的**+**按钮以添加来自其他来源的包。
- en: '![Figure 9.23 – Adding packages from other sources'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.23 – 从其他来源添加包'
- en: '](img/Figure_9.23_B17146.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.23_B17146.jpg)'
- en: Figure 9.23 – Adding packages from other sources
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23 – 从其他来源添加包
- en: Click `com.unity.entities`, so we enter it and click the **Add** button.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`com.unity.entities`，然后进入并点击**添加**按钮。
- en: '![Figure 9.24 – Adding the Entities package'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.24 – 添加Entities包'
- en: '](img/Figure_9.24_B17146.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.24_B17146.jpg)'
- en: Figure 9.24 – Adding the Entities package
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 – 添加Entities包
- en: Then, wait for the package installation to complete.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，等待包安装完成。
- en: '![Figure 9.25 – Installing a Git package'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.25 – 安装Git包'
- en: '](img/Figure_9.25_B17146.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.25_B17146.jpg)'
- en: Figure 9.25 – Installing a Git package
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 – 安装Git包
- en: Once done, you should be able to find the **Entities** package installed in
    your project.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该能在你的项目中找到已安装的**Entities**包。
- en: Sometimes we also need another package, the **Hybrid Renderer** package. This
    package helps us render ECS entities.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们还需要另一个包，即**混合渲染器**包。此包帮助我们渲染ECS实体。
- en: The process of installing the `com.unity.rendering.hybrid`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`com.unity.rendering.hybrid`的过程。
- en: '![Figure 9.26 – Installing the Hybrid Renderer package'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.26 – 安装混合渲染器包'
- en: '](img/Figure_9.26_B17146.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.26_B17146.jpg)'
- en: Figure 9.26 – Installing the Hybrid Renderer package
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26 – 安装混合渲染器包
- en: Wait for the package installation to complete, and then you'll find it's installed
    in your project.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 等待包安装完成，然后你会在项目中找到它已安装。
- en: '![Figure 9.27 – The Hybrid Renderer package'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.27 – 混合渲染器包'
- en: '](img/Figure_9.27_B17146.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.27_B17146.jpg)'
- en: Figure 9.27 – The Hybrid Renderer package
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27 – 混合渲染器包
- en: Next, we will use the previous example to understand how to use ECS to further
    improve the performance of a game based on the use of the C# Job System.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用之前的例子来了解如何使用ECS结合C# Job System的使用来进一步提高基于C# Job System的游戏性能。
- en: How to use ECS
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用ECS
- en: In this example, we will create a new component, entities, and a new system
    and use the C# Job System to distribute work to Unity's Job worker threads. Let's
    get started!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个新的组件，实体，以及一个新的系统，并使用C# Job System将工作分配给Unity的Job工作线程。让我们开始吧！
- en: 'First, we will create a component script just for the data. In this case, it''s
    the speed of cars:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为数据创建一个组件脚本。在这种情况下，是汽车的速度：
- en: '[PRE19]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we also need a normal script called `CarsManager` to access the `EntityManager`
    object in `World` to create archetypes and entities. Here, we''ll add some premade
    components from ECS to these entities, such as `Translation`, which contains only
    entity location data, and `RenderMesh`, which contains entity graphics attribute
    data:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还需要一个名为`CarsManager`的正常脚本，以访问`World`中的`EntityManager`对象来创建原型和实体。在这里，我们将向这些实体添加一些ECS预制的组件，例如`Translation`，它只包含实体位置数据，以及`RenderMesh`，它包含实体图形属性数据：
- en: '[PRE20]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then, attach this **CarsManager** script to a GameObject in the scene and assign
    the appropriate properties, such as the car's mesh, and speed values.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此**CarsManager**脚本附加到场景中的GameObject上，并分配适当的属性，例如汽车的网格和速度值。
- en: '![Figure 9.28 – The CarsManager object'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.28 – CarsManager对象'
- en: '](img/Figure_9.28_B17146.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.28_B17146.jpg)'
- en: Figure 9.28 – The CarsManager object
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28 – CarsManager对象
- en: 'At this point, we have set up the components and entities. The next thing to
    do is to create the system. The system is also where the game logic is handled.
    In this example, we''ll use the system to move these cars. As you can see in the
    following code, instead of searching for components in the traditional `Update`
    method and then operating on each instance at runtime, with ECS, we just statically
    declare that we need to process all entities with `Translation` and `CarSpeed`
    components attached. To find all of these entities, we just need to find the archetypes
    that match a specific "components set," which is done by the system:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了组件和实体。接下来要做的就是创建系统。系统也是处理游戏逻辑的地方。在这个例子中，我们将使用系统来移动这些汽车。正如您在下面的代码中所看到的，与在传统的
    `Update` 方法中搜索组件然后在每个实例上运行时操作相比，使用 ECS，我们只需静态声明我们需要处理所有带有 `Translation` 和 `CarSpeed`
    组件的实体。要找到所有这些实体，我们只需找到匹配特定“组件集”的原型，这是由系统完成的：
- en: '[PRE21]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Click the **Play** button in the Unity editor to run the example. As shown
    in the following screenshot, when there are 10,000 cars in the scene, this time
    the value of FPS is around **260**! In this scene with 10,000 moving cars, using
    ECS increased the game''s frame rate by nearly 30 times compared to the original
    traditional implementation:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中点击**播放**按钮来运行示例。如图所示，当场景中有 10,000 辆汽车时，这次 FPS 的值约为 **260**！在这个有
    10,000 辆移动汽车的场景中，使用 ECS 相比于原始的传统实现，将游戏的帧率提高了近 30 倍：
- en: '![Figure 9.29 – Using ECS to improve game performance'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.29 – 使用 ECS 提高游戏性能'
- en: '](img/Figure_9.29_B17146.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.29_B17146.jpg)'
- en: Figure 9.29 – Using ECS to improve game performance
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.29 – 使用 ECS 提高游戏性能
- en: If we look at the **Hierarchy** panel of this game scene, we won't see any car
    objects in the list. This is because when using ECS, traditional GameObjects and
    traditional components are not created, but entities and components from ECS are
    used to organize data.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看这个游戏场景的**层次结构**面板，我们不会在列表中看到任何汽车对象。这是因为当使用 ECS 时，不会创建传统的 GameObject 和传统组件，而是使用
    ECS 的实体和组件来组织数据。
- en: '![Figure 9.30 – No GameObjects are created'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.30 – 没有创建任何 GameObject](img/Figure_9.30_B17146.jpg)'
- en: '](img/Figure_9.30_B17146.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.30_B17146.jpg)'
- en: Figure 9.30 – No GameObjects are created
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.30 – 没有创建任何 GameObject
- en: In order to see the entities, components, and system used in the scene, we can
    use the **Entity Debugger** to view this information. By clicking the **Window**
    | **Analysis** | **Entity Debugger** item from the toolbar in the Unity editor,
    we can open the **Entity Debugger** window.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看场景中使用的实体、组件和系统，我们可以使用**实体调试器**来查看这些信息。通过从 Unity 编辑器的工具栏中点击**窗口** | **分析**
    | **实体调试器**项，我们可以打开**实体调试器**窗口。
- en: '![Figure 9.31 – Opening the Entity Debugger window'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.31 – 打开实体调试器窗口'
- en: '](img/Figure_9.31_B17146.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.31_B17146.jpg)'
- en: Figure 9.31 – Opening the Entity Debugger window
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.31 – 打开实体调试器窗口
- en: 'We can see a list of entities as well as a list of systems in the Entity Debugger
    window. As shown in the following screenshot, there are 10,002 entities, including
    10,000 car entities:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实体调试器窗口中，我们可以看到实体列表以及系统列表。如图所示，有 10,002 个实体，包括 10,000 个汽车实体：
- en: '![Figure 9.32 – The Entity Debugger'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.32 – 实体调试器'
- en: '](img/Figure_9.32_B17146.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.32_B17146.jpg)'
- en: Figure 9.32 – The Entity Debugger
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.32 – 实体调试器
- en: If we select an entity in the entity list, the **Inspector** window for that
    entity will open, showing all components of this entity and data for those components.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在实体列表中选择一个实体，该实体的**检查器**窗口将打开，显示该实体的所有组件及其数据。
- en: '![Figure 9.33 – Inspector window for an entity'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.33 – 实体检查器窗口](img/Figure_9.33_B17146.jpg)'
- en: '](img/Figure_9.33_B17146.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.33_B17146.jpg)'
- en: Figure 9.33 – Inspector window for an entity
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.33 – 实体检查器窗口
- en: 'Finally, let''s view the CPU usage timeline in the **Profiler** window. If
    you forget how to open this window, just press *Ctrl* + *7* or click **Window**
    | **Analysis** | **Profiler** in the Unity Editor toolbar. Here, we can see that
    the ECS work is distributed to multiple Job worker threads by the C# Job System
    as we expected:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在**性能分析器**窗口中查看 CPU 使用情况的时间线。如果您忘记了如何打开此窗口，只需按 *Ctrl* + *7* 或在 Unity 编辑器工具栏中点击**窗口**
    | **分析** | **性能分析器**。在这里，我们可以看到，正如我们预期的那样，C# 作业系统将 ECS 工作分配到多个作业工作线程：
- en: '![Figure 9.34 – ECS and Job System'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.34 – ECS 和作业系统'
- en: '](img/Figure_9.34_B17146.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.34_B17146.jpg)'
- en: Figure 9.34 – ECS and Job System
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.34 – ECS 和作业系统
- en: Through the preceding steps, we changed the traditional GameObject-Components-style
    development method in Unity to the development method using ECS, adopting the
    data-oriented design method and using the C# Job System, making full use of multithreaded
    programming, and improving the running efficiency of the game.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的步骤，我们将 Unity 中的传统 GameObject-Components 风格开发方法更改为使用 ECS 的开发方法，采用面向数据的设计方法，并使用
    C# Job 系统，充分利用多线程编程，从而提高游戏的运行效率。
- en: Next, let's discuss another technology in DOTS, the Burst compiler.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论 DOTS 中的另一项技术，即 Burst 编译器。
- en: Using C# and the Burst compiler
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 和 Burst 编译器
- en: The **Burst compiler** in Unity is an advanced compiler technology that can
    be used to convert a subset of .NET code into highly optimized native code for
    Unity games. It should be noted that it is not a general-purpose compiler, but
    a compiler designed for Unity to make Unity games run faster.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的 **Burst 编译器** 是一种高级编译技术，可以将 .NET 代码的一个子集转换为针对 Unity 游戏高度优化的本地代码。需要注意的是，它不是一个通用编译器，而是一个为
    Unity 设计的编译器，旨在使 Unity 游戏运行得更快。
- en: Burst works on a subset of C# called HPC#, so let's explore this subset of C#
    next.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Burst 在 C# 的一个子集 HPC# 上工作，因此让我们接下来探索这个 C# 子集。
- en: High-Performance C# (HPC#)
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高性能 C# (HPC#)
- en: HPC# is a subset of C#. The standard C# language uses the concepts of "objects
    on the heap" and uses the garbage collector to reclaim unused memory automatically.
    So, as developers, we cannot control how the data is allocated in memory. On the
    other hand, HPC# doesn't support reference types, namely, classes, to avoid allocation
    in the heap and disable the garbage collector. In addition to these, some functions,
    such as `try-catch-finally`, are not supported in HPC# as well.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: HPC# 是 C# 的一个子集。标准 C# 语言使用“堆上的对象”的概念，并使用垃圾回收器自动回收未使用的内存。因此，作为开发者，我们无法控制数据在内存中的分配方式。另一方面，HPC#
    不支持引用类型，即类，以避免在堆上进行分配并禁用垃圾回收器。此外，一些函数，如 `try-catch-finally`，在 HPC# 中也不受支持。
- en: 'To summarize, we can use the following types in HPC#:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以在 HPC# 中使用以下类型：
- en: Value types, such as int, float, bool, and char, enum types, and struct types
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型，如 int、float、bool 和 char，枚举类型和结构体类型
- en: '`NativeArray` in Unity'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 中的 `NativeArray`
- en: Enabling the Burst compiler
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用 Burst 编译器
- en: 'The Burst compiler is usually used with the C# Job System in Unity to optimize
    the code of a job. As we know, a job is a value type struct, so it is suitable
    for use with the Burst compiler. Enabling it in a job is very simple: just add
    the `[BurstCompile]` attribute to the job struct, as shown in the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Burst 编译器通常与 Unity 中的 C# Job 系统一起使用以优化作业的代码。正如我们所知，作业是一个值类型结构体，因此它非常适合与 Burst
    编译器一起使用。在作业中启用它非常简单：只需将 `[BurstCompile]` 属性添加到作业结构体中，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you also want to enable the Burst compiler in the Unity editor, you can find
    the settings for it at **Jobs** | **Burst** in the toolbar.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您也想在 Unity 编辑器中启用 Burst 编译器，您可以在工具栏中的 **作业** | **Burst** 找到相应的设置。
- en: '![Figure 9.35 – Settings of Burst'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.35 – Settings of Burst](img/Figure_9.35_B17146.jpg)'
- en: '](img/Figure_9.35_B17146.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.35 – Settings of Burst](img/Figure_9.35_B17146.jpg)'
- en: Figure 9.35 – Settings of Burst
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.35 – Burst 设置
- en: By reading this section, you should know what the Burst compiler and HPC# are.
    You should also know that the Burst compiler is often used with the C# Job System
    in Unity and how to enable it in job code to generate more efficient native binary
    code.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本节，您应该了解 Burst 编译器和 HPC# 是什么。您还应该知道 Burst 编译器通常与 Unity 中的 C# Job 系统一起使用，以及如何在作业代码中启用它以生成更高效的本地二进制代码。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter first introduced what data-oriented design is and the difference
    between data-oriented design and traditional object-oriented design. Then, we
    explored DOTS in Unity and the three technology modules that make it up, namely,
    the C# Job System, ECS, and the Burst compiler.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍了数据导向设计是什么，以及数据导向设计与传统面向对象设计的区别。然后，我们探讨了 Unity 中的 DOTS 以及构成它的三个技术模块，即
    C# Job 系统、ECS 和 Burst 编译器。
- en: After that, we discussed in detail how to implement asynchronous programming
    in Unity and used an example to demonstrate how to use Unity's C# Job System to
    implement multithreading to improve game performance.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们详细讨论了如何在 Unity 中实现异步编程，并使用示例演示了如何使用 Unity 的 C# Job 系统实现多线程以提高游戏性能。
- en: We also introduced the concept of ECS, discussed the difference between ECS
    and the traditional GameObject-Components architecture in Unity, and demonstrated
    how to use ECS and the C# Job System to further improve game performance.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了ECS的概念，讨论了ECS与Unity中传统的GameObject-Components架构之间的区别，并演示了如何使用ECS和C# Job系统来进一步提高游戏性能。
- en: Finally, we explored what the Burst compiler and HPC# are and how to enable
    them to generate highly optimized native code for your Unity games.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了Burst编译器和HPC#是什么，以及如何使它们为您的Unity游戏生成高度优化的本地代码。
- en: By reading this chapter, you should now understand how to work with DOTS correctly
    in Unity. In the next chapter, we will discuss topics related to assets management
    and serialization In Unity.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，您现在应该已经理解了如何在Unity中正确地使用DOTS。在下一章中，我们将讨论与Unity中的资源管理和序列化相关的话题。
