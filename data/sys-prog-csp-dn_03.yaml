- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: The One with the Memory Games
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存游戏
- en: '*Efficient* *Memory Management*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*高效* *内存管理*'
- en: Performance is critical for system programming. We discussed this in the previous
    chapter and outlined why it is crucial. Memory consumption is just as important,
    however. The trouble is that better performance often leads to worse memory usage.
    And trying to optimize for memory usage often leads to worse performance. As in
    all things in life, it is a matter of compromising.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 性能对于系统编程至关重要。我们在上一章讨论了这一点，并概述了为什么它至关重要。内存消耗同样重要。问题是，更好的性能往往会导致更差的内存使用。而试图优化内存使用往往会导致性能更差。就像生活中的所有事情一样，这是一个权衡的问题。
- en: That being said, you might also encounter situations where you get both simultaneously
    – for instance, using the stack instead of the heap (or value types instead of
    reference types) results in faster code using less memory.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你也可能遇到同时遇到两种情况的情况——例如，使用栈而不是堆（或值类型而不是引用类型）会导致代码运行更快，内存使用更少。
- en: However, you usually don’t get one item for free while pursuing the other. You
    have to make informed decisions and the correct choices. And that is what this
    chapter is all about. I hope you remember most of it once we reach the end of
    this chapter!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在追求其中一种的同时，通常不会免费获得另一种。你必须做出明智的决定和正确的选择。这正是本章的主要内容。我希望当我们到达本章的结尾时，你能记住大部分内容！
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: An overview of memory management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理概述
- en: An overview of the **garbage** **collector** (**GC**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收器（**GC**）概述
- en: How to correctly use `IDisposable`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何正确使用 `IDisposable`
- en: A long list of tips and tricks on how to save memory
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列关于如何节省内存的技巧和窍门
- en: Unsafe code and pointers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全代码和指针
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Everything in this chapter can be done in a plain installation of C#. The only
    thing you might need extra if you’re following along is the NuGet `MessagePack`
    package. You can install that through Visual Studio Code or using the following
    CLI command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有内容都可以在普通的 C# 安装中完成。如果你在跟随学习，可能需要额外的只是 NuGet `MessagePack` 包。你可以通过 Visual
    Studio Code 或使用以下 CLI 命令来安装：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An overview of the GC
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GC 概述
- en: .NET is a managed system. As discussed earlier, many issues developers had to
    deal with are now handled by the **Common Language Runtime** (**CLR**). The CLR
    abstracts away most of the tedious tasks a developer faces so that they can focus
    on functionality instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 是一个受管理的系统。正如之前所讨论的，许多开发者必须处理的问题现在都由 **公共语言运行时**（**CLR**）来处理。CLR 抽象掉了开发者面临的大部分繁琐任务，使他们能够专注于功能。
- en: '**Memory management** is a tricky thing to do right, but also very important.
    Doing this wrong usually leads to memory leakage or instability in the software.
    Although no software should have that, system programming needs to avoid this.
    It might lead to unstable systems, making the whole computer unusable. Therefore,
    it is good that .NET developers don’t have to worry about this. The GC manages
    much of the memory and deals with those intricate details.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存管理**是一项棘手但非常重要的任务。做错通常会导致内存泄漏或软件不稳定。尽管没有软件应该有这种情况，系统编程需要避免这种情况。它可能导致系统不稳定，使整个计算机无法使用。因此，.NET
    开发者不必担心这一点。GC 管理了大部分内存，并处理那些复杂的细节。'
- en: Learning how the GC works is worth it so that your code is much more memory
    efficient. That means knowing how memory allocation functions in .NET.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 GC 的工作原理是值得的，这样你的代码就会更加内存高效。这意味着了解内存分配在 .NET 中的工作方式。
- en: We already discussed the difference between the stack and the heap. But just
    as a reminder, the stack is the short-term, smaller, but faster piece of memory
    that’s used for value types, while the heap is longer-term and much more extensive
    but also slower.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了栈和堆之间的区别。但为了提醒一下，栈是短期、较小但较快的内存部分，用于值类型，而堆是长期、更广泛但较慢的内存部分。
- en: If you declare an integer in a code block, the CLR puts it on the stack. That
    memory is released at the end of that block’s scope. The heap works differently.
    Since items on the heap can live much longer, we need another way of handling
    this memory. That’s where GC comes in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个代码块中声明一个整数，CLR 会将其放在栈上。该内存会在该代码块的作用域结束时释放。堆的工作方式不同。由于堆上的项目可以存活更长时间，我们需要另一种处理这种内存的方法。这就是垃圾回收器（GC）的作用所在。
- en: The GC process can run on a separate thread or in the main or user thread. For
    now, it is easiest to assume that the GC runs on a background thread. We will
    deal with the real-world situation a bit later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: GC过程可以在单独的线程上运行或在主线程或用户线程中运行。目前，假设GC在后台线程上运行是最简单的。我们稍后会处理现实世界的情况。
- en: GC and its generations
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GC及其代数
- en: GC is a generational system. This means it works with generations. Does that
    help? I guess not. Okay, let me elaborate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: GC是一个代数系统。这意味着它与代数一起工作。这有帮助吗？我想没有。好吧，让我详细说明。
- en: 'Look at the following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码片段：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This snippet is not our most exciting piece of code, but we must start somewhere.
    The curly braces are necessary here, though.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不是我们最激动人心的代码片段，但我们必须从某个地方开始。这里的括号是必要的。
- en: The preceding code snippet results in less activity than expected, especially
    if you come from a C or C++ background.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段产生的活动比预期的要少，尤其是如果你有C或C++的背景。
- en: 'The following figures will help you make sense of what’s going on when we run
    the preceding code snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图将帮助您理解在运行上述代码片段时发生的情况：
- en: "![Figure \uFEFF3.1: The empty, allocated heap](img/B20924_04_01.jpg)"
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：空的、已分配的堆](img/B20924_04_01.jpg)'
- en: 'Figure 3.1: The empty, allocated heap'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：空的、已分配的堆
- en: During the program’s startup, the CLR allocates a continuous memory block. This
    block isn’t very big but big enough to house all the startup objects, plus anything
    else it can determine is needed. At that point, a pointer is created that points
    to the first area available for the project to use.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序启动期间，CLR分配了一个连续的内存块。这个块不是很大，但足够容纳所有启动对象，以及它确定需要的任何其他东西。到那时，创建了一个指针，指向项目可用的第一个区域。
- en: 'On line 1, we begin a code block. Then, on line 2, we create an instance of
    the `Object` type and store that in the `a` variable. The memory of all data that
    belongs to that object lives on the heap. The runtime initializes, calculates
    how big that memory for `a` should be, and moves the allocation pointer up to
    the next available piece of memory in the block. A pointer is created on the stack
    (we call it `a`), and that pointer points to the memory block on the heap where
    its data lives:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们开始一个代码块。然后，在第2行，我们创建一个`Object`类型的实例并将其存储在`a`变量中。属于该对象的所有数据内存都位于堆上。运行时初始化，计算`a`应该占用多少内存，并将分配指针移动到块中下一个可用的内存块。在栈上创建了一个指针（我们称之为`a`），该指针指向堆上存储其数据内存块：
- en: "![Figure \uFEFF3.2: The heap after creating object a](img/B20924_04_02.jpg)"
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：创建对象a后的堆](img/B20924_04_02.jpg)'
- en: 'Figure 3.2: The heap after creating object a'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：创建对象a后的堆
- en: 'On line 3, we end the scope of that variable. As we have learned, variables
    on the stack live only as long as the scope they belong to. Thus, `a` pointer
    is cleared, and its occupied memory is released. But on the heap, nothing happens.
    The data for `a` is still there, and the allocation pointer still points to the
    same place:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们结束该变量的作用域。正如我们所学的，栈上的变量只在其所属的作用域内存在。因此，`a`指针被清除，其占用的内存被释放。但在堆上，没有任何变化。`a`的数据仍然存在，分配指针仍然指向相同的位置：
- en: "![Figure \uFEFF3.3: The heap after a goes out of scope](img/B20924_04_03.jpg)"
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：变量a超出作用域后的堆](img/B20924_04_03.jpg)'
- en: 'Figure 3.3: The heap after a goes out of scope'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：变量a超出作用域后的堆
- en: Then, on line 4, we create a new scope block; on line 5, we create a new instance
    of `Object` and call it `b`. The whole circus starts all over again, but the data
    for `b` is now stored on top of `a`. Nobody knows about this; the data for `a`
    has become unreachable. But it is still there!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第4行，我们创建一个新的作用域块；在第5行，我们创建一个新的`Object`实例并称之为`b`。整个表演又从头开始，但`b`的数据现在存储在`a`的上面。没有人知道这一点；`a`的数据已经变得不可达。但它仍然在那里！
- en: "![Figure \uFEFF3.4: The heap when we allocate object b](img/B20924_04_04.jpg)"
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：分配对象b时的堆](img/B20924_04_04.jpg)'
- en: 'Figure 3.4: The heap when we allocate object b'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：分配对象b时的堆
- en: 'And, of course, on line 6, the scope ends, so the stack variable, `b`, is removed
    again. Again, nothing happens to the heap:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在第6行，作用域结束，因此栈变量`b`再次被移除。再次，堆上没有任何变化：
- en: '![](img/B20924_04_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20924_04_05.jpg)'
- en: 'Figure3.5: The heap after b also goes out of scope'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：变量b也超出作用域后的堆
- en: As you can see, we don’t allocate or deallocate memory on the heap. Here, a
    pointer moves up whenever we need a new object. Moving a pointer is much faster
    than allocating and freeing memory. Allocating and deallocating, or freeing memory,
    are very expensive performance-wise. Avoiding these operations as much as possible
    is one of the reasons applications in .NET can run so fast.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在堆上不分配或释放内存。在这里，每当我们需要一个新对象时，指针就会向上移动。移动指针比分配和释放内存要快得多。在性能上，分配和释放，或者说释放内存，是非常昂贵的。尽可能避免这些操作是.NET应用程序可以运行如此之快的原因之一。
- en: However, you have probably seen a potential problem. What happens when we run
    out of space on the heap? The allocation pointer cannot move beyond the end of
    that block, so what happens then?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能已经看到了一个潜在的问题。当我们用完堆上的空间时会发生什么？分配指针不能移动到该块的末尾，那么接下来会发生什么？
- en: I’m glad you asked. That’s when the GC comes into play. The moment we run out
    of memory in the block we allocated initially, the GC will have a look at all
    the items in that block.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 很高兴你问了。这就是垃圾回收器（GC）发挥作用的时候。当我们用完最初分配的块中的内存时，GC会查看该块中的所有项目。
- en: First, it goes through all objects in the heap and sees which still have active
    pointers pointing to them. In our example, we have none, but imagine that we have
    some other objects allocated that are still in scope.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它会遍历堆中的所有对象，看看哪些仍然有活跃的指针指向它们。在我们的例子中，我们没有，但想象一下我们有一些其他对象分配了，这些对象仍然在作用域内。
- en: The GC marks all those orphaned memory locations to know it can reclaim that
    memory. But what about the items that the GC cannot remove?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: GC将这些孤儿内存位置标记出来，以便知道它可以回收这些内存。但GC无法移除的项目怎么办？
- en: The answer to that question concerns the GC being “generational.” The CLR places
    each object in a particular part of the heap marked with a generation number.
    All new objects are in generation 0.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案涉及到GC是“代式的”。CLR将每个对象放置在堆的一个特定部分，该部分用代数标记。所有新对象都在第0代。
- en: When the GC does its trick, it moves all objects still alive and in scope to
    the next generation. They are now in the generation 1 heap.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当GC施展其魔法时，它会将所有仍然存活并在作用域内的对象移动到下一代。它们现在在第1代堆中。
- en: A bit more detail
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点更详细
- en: 'In reality, there are only two heaps: one for all generations and one for the
    **large object heap** (**LOH**) (we’ll cover this in more detail later). The heap
    is divided into sections, one for each generation. However, we can think of each
    generation as having its own heap. Although this isn’t technically correct, thinking
    about the layout like this makes it a bit easier to understand what’s going on.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，只有两个堆：一个用于所有代，一个用于**大型对象堆（LOH**）（我们将在后面更详细地介绍）。堆被分成几个部分，每个部分对应一个代。然而，我们可以将每个代视为有自己的堆。虽然这从技术上讲是不正确的，但这样思考会使理解正在发生的事情变得容易一些。
- en: Now, all objects that survived the garbage collection process are in the generation
    1 heap; all objects that can no longer be reached are ready to be cleaned up.
    The GC clears out the memory and sets the allocation pointer back to the beginning
    of the heap. Now, the whole thing can start all over again.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有在垃圾回收过程中幸存的对象都在第1代堆中；所有无法再到达的对象都准备好被清理。GC清除内存并将分配指针设置回堆的起始位置。现在，一切都可以从头开始。
- en: That’s pretty neat, isn’t it? But there’s another problem. What happens if our
    generation 1 heap fills up?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当不错，不是吗？但还有一个问题。如果我们的第1代堆填满了会怎样？
- en: In that case, we see a similar behavior. Everything in generation 1 that is
    no longer reachable (and that includes not being reachable from objects that are
    in other generations) is marked for deletion; the GC promotes all others to generation
    2.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们看到类似的行为。第1代中所有不再可到达的项目（包括不是从其他代中的对象可达的项目）都被标记为删除；GC将所有其他项目提升到第2代。
- en: Okay; let’s continue. What happens when generation 2 fills up? You would be
    wrong if you guessed that all reachable items move to generation 3\. There’s no
    generation 3\. If we fill up generation 2, the runtime allocates a new block that’s
    big enough to hold the current heap and sufficient to add more objects. Then,
    it moves all objects to the new heap and returns the old heap to the operating
    system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；让我们继续。当第2代填满时会发生什么？如果你猜测所有可到达的项目都移动到第3代，那你就错了。没有第3代。如果我们填满第2代，运行时将分配一个足够大的新块来容纳当前堆，并且足够添加更多对象。然后，它将所有对象移动到新的堆，并将旧堆返回给操作系统。
- en: Sometimes, the CLR asks for more memory for the heap and gets a slap on the
    wrist from the operating system. There’s no more memory available. In that case,
    we see the dreaded `OutOfMemoryException` error.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，CLR请求更多堆内存，但操作系统会对其进行惩罚，因为没有更多的内存可用。在这种情况下，我们会看到可怕的`OutOfMemoryException`错误。
- en: Handling OutOfM emoryException errors
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 处理OutOfMemoryException错误
- en: The rule with handling exceptions is that you should only catch exceptions you
    know how to handle so that you can bring the system back into a stable state.
    With `OutOfMemory`, you have no way of doing that. The `OutOfMemoryException`
    error is one of the exceptions you’d better just let go. You can’t do much here
    to help.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常的规则是，你应该只捕获你知道如何处理的异常，以便将系统恢复到稳定状态。对于`OutOfMemory`，你无法做到这一点。`OutOfMemoryException`错误是最好让它自行处理的异常之一。在这里你无法做太多来帮助。
- en: The LOH
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LOH
- en: 'You can probably imagine that moving data in memory takes a lot of time and
    will hinder your performance. And that is correct: performance takes a huge hit
    when the GC runs.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以想象，在内存中移动数据需要花费很多时间，这将阻碍你的性能。这是正确的：当GC运行时，性能会受到巨大打击。
- en: The GC is optimized to prevent that as much as possible, but memory operations
    are inherently expensive. Reallocating memory and moving the bytes around to all
    the different locations in particular take a lot of time to perform.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GC被优化以尽可能防止这种情况，但内存操作本身是昂贵的。特别是重新分配内存和将字节移动到所有不同位置需要花费大量时间。
- en: One of the things the CLR designers did to alleviate that problem a little bit
    was to declare a special heap called the LOH.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CLR设计者为了稍微缓解这个问题，声明了一个特殊的堆，称为LOH。
- en: As the name implies, it is a heap for large objects. Currently, it deals with
    large objects – that is, objects bigger than 85,000 bytes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这是一个用于大对象的堆。目前，它处理大对象——即大于85,000字节的对象。
- en: Objects of that size or bigger do not go to the regular heap. They are not subject
    to the generational behavior of the rest of the system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么大或更大的对象不会进入常规堆。它们不受系统其他部分的代际行为的影响。
- en: The GC does help with keeping the LOH clean, but it runs far less frequently.
    Also, it doesn’t have generations for the LOH.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GC确实有助于保持LOH的清洁，但它运行的频率远低于其他堆。此外，LOH没有代际。
- en: 'When the GC clears objects from the LOH, the memory gets fragmented. What this
    means is that after a while, our block of memory looks a bit like Swiss cheese:
    there are holes everywhere. Areas of the memory that were once occupied by objects,
    which have been reclaimed, are now empty. After a while, the memory consists of
    valid objects and empty space. That means that although technically there is enough
    memory to allocate new objects, the system cannot find one continuous block of
    memory. If that happens, the GC will compact the LOH to make the memory contiguous
    again. But that only happens on very rare occasions. This way of working means
    the LOH is much slower than the other heaps.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当GC从大型对象堆（LOH）中清除对象时，内存会变得碎片化。这意味着过了一段时间后，我们的内存块看起来有点像瑞士奶酪：到处都是孔洞。曾经被对象占用、现在已被回收的内存区域现在是空的。过了一段时间，内存就由有效的对象和空空间组成。这意味着虽然技术上还有足够的内存来分配新的对象，但系统找不到一块连续的内存。如果发生这种情况，GC将压缩LOH，使内存再次连续。但这只会在非常罕见的情况下发生。这种方式意味着LOH比其他堆慢得多。
- en: Also, the LOH doesn’t have a predefined size. It grows if needed. Again, this
    is a costly and slow operation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，LOH没有预定义的大小。如果需要，它会增长。这又是一个昂贵且缓慢的操作。
- en: The good news is that these large objects are out of your way in the usual heaps,
    so they don’t slow down the GC there.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，这些大对象在常规堆中不会妨碍你，所以它们不会减慢那里的GC。
- en: Be mindful when creating large objects. They can bring your application to a
    grinding halt.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建大对象时要小心。它们可能会让你的应用程序陷入停顿。
- en: Finalizers
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终结器
- en: You may have been programming in .NET for over a decade and have never seen
    or used a finalizer. If that is the case, good job. We don’t need them. Well,
    we mostly don’t. There are some edge cases when we do; one is when you use the
    `IDisposable` pattern. This pattern has a whole section dedicated to it later
    in this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经用.NET编程超过十年，从未见过或使用过终结器。如果是这样，做得好。我们不需要它们。嗯，我们大多数情况下不需要。有些边缘情况我们需要；其中一个是当你使用`IDisposable`模式时。这个模式在本章后面有专门的章节介绍。
- en: I want to show you what happens with the GC if you add a finalizer to your classes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向你展示，如果你在你的类中添加一个终结器（finalizer），垃圾回收器（GC）会发生什么。
- en: Fun fact!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实！
- en: 'Finalizers are often mistaken for destructors. That makes sense: if we have
    a constructor at the start of the lifetime of an object, why not have destructors
    at the end of that? C++ has them, after all. But we don’t. So, never call finalizers
    as destructors. They don’t destroy. They are pacifists who just want to clean
    up after them.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 终结器经常被误认为是析构函数。这很有道理：如果我们有一个构造函数在对象的生存期开始时，为什么不在结束时也有析构函数呢？毕竟C++有它们。但我们没有。所以，永远不要将终结器当作析构函数来调用。它们不会销毁。它们是和平主义者，只想在它们之后进行清理。
- en: 'Let me briefly explain what a finalizer is. A **finalizer** is a method in
    a C# class that the runtime calls just before the object is cleaned up and removed.
    Just like a constructor, it has a special name. The following code block provides
    an example of a finalizer:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我简要解释一下什么是终结器。**终结器**是C#类中的一个方法，运行时会在这个对象被清理和移除之前调用它。就像构造函数一样，它有一个特殊名称。下面的代码块提供了一个终结器的示例：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class, `MyClass`, has both a constructor and a finalizer. The constructor
    has the name of the class, an access modifier (`public`, in this case), no return
    type (since it is not a method), and it might have some parameters. I have no
    parameters here, but I could have added them if needed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类，`MyClass`，既有构造函数也有终结器。构造函数具有类的名称，一个访问修饰符（在这种情况下为`public`），没有返回类型（因为它不是一个方法），并且可能有一些参数。这里我没有参数，但如果需要，我可以添加它们。
- en: 'This constructor is called after the CLR has allocated the memory. You can
    think of it as being called as part of a “new” operation. You know when it is
    called: as soon as you create an instance, the CLR invokes the constructor. Simple
    enough, right?'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数是在CLR分配内存之后调用的。你可以将其视为“new”操作的一部分。你知道它何时被调用：一旦你创建了一个实例，CLR就会调用构造函数。很简单，对吧？
- en: 'So, an instance of a class can be created like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个类的实例可以创建如下：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The finalizer is a bit different. It has no access modifier, no return type,
    and no parameters. It is the name of the class that is preceded by a tilde (`~`).
    You never call this code. The CLR does. You cannot set any parameters here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 终结器有点不同。它没有访问修饰符，没有返回类型，也没有参数。它是类名前加上波浪号（`~`）。你永远不会调用这段代码。CLR会调用。你无法设置任何参数。
- en: The question is, of course, when is it called? And the answer is that we don’t
    know.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，问题是它何时被调用？答案是，我们不知道。
- en: Let’s go back to the GC run. Generation 0 is getting full, so the GC must clean
    up. It looks for all objects that are out of scope to remove that memory. Let’s
    assume `myClass` is also out of scope.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到GC运行过程。0代空间已满，因此GC必须进行清理。它会寻找所有超出作用域的对象以释放内存。假设`myClass`也超出了作用域。
- en: I explained how the GC cleans up memory previously but left out two steps the
    GC also takes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前解释了GC如何清理内存，但省略了GC也采取的两个步骤。
- en: The first extra step is that after it finds all the locations in memory without
    active variables pointing to them, it looks for objects in those areas with a
    finalizer. If it finds one, it will place a pointer to that memory structure in
    a special queue called `FReachableQueue` (the F stands for finalizer). Then, it
    leaves it alone. The memory on the heap for that object is not reclaimed. It is
    also not moved to another generation. It just survives the cleaning up. Now, it
    just sits there once more.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个额外步骤是，在它找到所有没有活跃变量指向它们的内存位置后，它会寻找那些区域具有终结器的对象。如果找到了一个，它将把对该内存结构的指针放入一个称为`FReachableQueue`的特殊队列中（F代表终结器）。然后，它就不再管它了。该对象的堆内存不会被回收。它也不会移动到另一个代。它只是存活在清理过程中。现在，它再次静静地坐在那里。
- en: Well, only until the GC runs again. That’s where the second step comes into
    play. Just before it cleans up the generation, it goes through `FReachableQueue`.
    For all objects in that queue, the CG calls the finalizers. Then, it removes the
    pointer from `FReachableQueue`, and the object is now finally ready to be garbage
    collected.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，直到GC再次运行。这就是第二个步骤发挥作用的地方。在清理代之前，它会遍历`FReachableQueue`。对于队列中的所有对象，CG会调用终结器。然后，它从`FReachableQueue`中移除指针，现在对象最终准备好被垃圾回收。
- en: 'This has some profound implications:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些深远的影响：
- en: Objects with finalizers survive an extra round of garbage collection. They stick
    around longer, adding to the memory pressure.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有终结器的对象会经历额外的垃圾回收轮次。它们存在的时间更长，增加了内存压力。
- en: Objects with finalizers will have their finalizers called, but we have no idea
    when. We don’t know when the GC runs, after all.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有终结器的对象将调用它们的终结器，但我们不知道何时调用。毕竟，我们不知道GC何时运行。
- en: Moving the pointers around is an extra step for the GC, making things even slower.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动指针是垃圾回收器的一个额外步骤，使得事情变得更慢。
- en: Finalizers are a huge performance drain. They are better not used at all. Unless,
    of course, you use the `IDisposable` pattern to clean up. We’ll discuss this next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 终结器是一个巨大的性能瓶颈。最好根本不用它。除非，当然，你使用 `IDisposable` 模式来清理。我们将在下一节讨论这个问题。
- en: IDisposable
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IDisposable`'
- en: .NET is a managed environment. I have said that before, and I will mention it
    again. I keep repeating this because many think “managed” means “I don’t have
    to take care of stuff.” And as we have seen, that is simply not true. Yes, the
    CLR takes away a lot of the pain other developers suffer, but still, there’s a
    lot that you have to do yourself – especially if you are, like we are, writing
    system software.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '.NET 是一个托管环境。我之前说过，我还会再次提到。我一直在重复这一点，因为许多人认为“托管”意味着“我不必担心这些事情。”正如我们所看到的，这根本不是真的。是的，CLR
    去除了其他开发者所承受的许多痛苦，但仍然，还有很多事情你必须自己去做——尤其是如果你，就像我们一样，在编写系统软件。 '
- en: One of the things the CLR does is clean up resources after us. Value types are
    on the stack and don’t need to be cleaned up. Reference types need to be cleaned
    up, but the GC takes care of that. However, as we have seen, cleaning up doesn’t
    always happen when we expect it to happen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 做的一件事是在我们之后清理资源。值类型位于堆栈上，不需要清理。引用类型需要清理，但垃圾回收器会处理。然而，正如我们所看到的，清理并不总是发生在我们期望它发生的时候。
- en: 'And there is another problem: the GC doesn’t clean up all used resources. The
    CLR only cleans up managed objects. Non-managed objects are yours to clean up
    and dispose of. Most examples that explain this behavior mention classes such
    as files and database connections. And to be honest, for most developers, those
    are the only real-life occurrences they will find when dealing with unmanaged
    resources. For us, this is a bit different. When writing system software, we,
    more often than usual, encounter things from low-level APIs, external hardware,
    interfacing with third-party software, attaching our code to external debuggers,
    and so on. We will see examples of these later in this book when we talk about
    the filesystem, networking, and interfacing with other hardware.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并且还有一个问题：垃圾回收器不会清理所有已使用的资源。CLR 只清理托管对象。非托管对象是你的责任去清理和处置。大多数解释这种行为的例子都提到了文件和数据库连接等类。坦白说，对于大多数开发者来说，这些是他们处理非托管资源时唯一会遇到的现实生活中的情况。对于我们来说，这有点不同。当我们编写系统软件时，我们比平时更经常地遇到来自低级
    API、外部硬件、与第三方软件接口、将我们的代码附加到外部调试器等情况。我们将在本书后面讨论文件系统、网络和与其他硬件接口时看到这些示例。
- en: So, you must understand how to clean up if the GC doesn’t do this for you. And
    that is where `IDisposable` comes into play.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你必须理解如果垃圾回收器没有为你做这件事，你应该如何清理。这就是 `IDisposable` 发挥作用的地方。
- en: 'The `IDisposable` interface is very simple. This is what it looks like:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDisposable` 接口非常简单。它看起来是这样的：'
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Classes that implement this interface must ensure they have a `void` method
    without parameters called `Dispose`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此接口的类必须确保它们有一个不带参数的 `void` 方法，名为 `Dispose`。
- en: 'It is an interface, so it doesn’t do anything. If you add it to a class, nothing
    happens. The CLR ignores it. This statement is important. I will repeat it: the
    CLR does nothing with classes that implement this interface.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个接口，所以它不做任何事情。如果你将它添加到一个类中，什么都不会发生。CLR 会忽略它。这个声明很重要。我会重复一遍：CLR 对实现此接口的类不做任何处理。
- en: The `IDisposable` interface is more like a contract. We add it to classes that
    deal with unmanaged resources. Other developers see that interface in the class
    declaration and assume they must handle unmanaged resources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDisposable` 接口更像是一个合同。我们将其添加到处理非托管资源的类中。其他开发者看到类声明中的该接口，就会假设他们必须处理非托管资源。'
- en: And that is it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。
- en: 'So, how do we implement it? Let’s have a look at the following sample:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现它？让我们看看下面的示例：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the constructor, we allocate a block of memory of `8 KB`. We store the pointer
    to that block in `ptr;`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们分配了一个 `8 KB` 的内存块。我们将该块的指针存储在 `ptr;` 中。
- en: This block of memory is unmanaged. So, it is up to us to clean it up as well.
    We decided to do that in the finalizer. After all, it is guaranteed to run, so
    we are good here!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这块内存是不受管理的。因此，清理它也取决于我们。我们决定在终结器中完成这项工作。毕竟，它是保证要运行的，所以我们在这里做得很好！
- en: But we have already established that we aren’t sure when this will happen. And
    we don’t want a block of perfectly fine memory just being allocated until the
    GC decides to run (twice, since it is in a finalizer!). That’s just wasting memory
    and a lot of CPU cycles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们已经确定我们不确定这将在何时发生。我们不想在垃圾回收器决定运行之前（由于它位于终结器中，所以是两次！）分配一大块完美的内存。这只是在浪费内存和大量的CPU周期。
- en: 'We need another way to clean up. Let’s rewrite the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一种清理方式。让我们重写代码：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code moves the cleanup code to a new method called `Cleanup`. If we want
    to use this class, we can simply create an instance and then make sure we always
    call `Cleanup()`. We can ensure that by using a `try-finally` block. Let’s do
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将清理代码移动到一个名为`Cleanup`的新方法中。如果我们想使用这个类，我们可以简单地创建一个实例，然后确保我们始终调用`Cleanup()`。我们可以通过使用`try-finally`块来确保这一点。让我们这样做：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is pretty simple, right? And to be honest, that is all there is to it
    for the `IDispose` interface. The most significant difference is that instead
    of having a method called `Cleanup()`, we have a method called `Dispose()`. And
    we mark our class with the correct interface, just as a courtesy to other developers.
    That way, they know they must clean up after using our class. Let’s do this using
    the following code block:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，对吧？说实话，这就是`IDispose`接口的全部内容。最显著的区别是，我们不再有一个名为`Cleanup()`的方法，而是有一个名为`Dispose()`的方法。我们用正确的接口标记我们的类，这是对其他开发者的一个礼貌。这样，他们就知道在使用我们的类之后必须进行清理。让我们使用以下代码块来做这件事：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And that’s all we need to do. In our calling code, we should call `Dispose()`
    instead of `Cleanup()` so that our code compiles. Let’s do that. I won’t show
    you that code here as I’m sure you know how to do that. However, I will show you
    the **Intermediate Language** (**IL**) code. As a reminder, IL is a language that
    is not quite C# but also not machine code. It sits in between. But it does give
    us a nice indication of what the compiler makes of our code before it turns it
    into actual machine code. The IL code looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的全部。在我们的调用代码中，我们应该调用`Dispose()`而不是`Cleanup()`，这样我们的代码才能编译。让我们这样做。我这里不会展示那段代码，因为我相信你知道如何做。然而，我会展示**中间语言（IL**）代码。作为一个提醒，IL是一种既不是C#也不是机器码的语言。它介于两者之间。但它确实给我们提供了一个很好的指示，说明编译器在将其转换为实际机器码之前对我们的代码做了什么。IL代码看起来是这样的：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The IL code looks almost identical to our C# code. The critical part for us
    is on lines 15 through 23\. This is the `finally` block, containing the call to
    the `Dispose()` method. We now know that, no matter what, our resources will be
    cleaned up.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: IL代码几乎与我们的C#代码相同。对我们来说，关键部分在15到23行。这是包含对`Dispose()`方法调用的`finally`块。我们现在知道，无论如何，我们的资源都将被清理。
- en: 'This is brilliant. It’s so useful (and important) that the people behind the
    C# language gave us a new construct that helps us in doing so: they gave us the
    `using` statement.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了。它非常有用（而且很重要），C#语言的背后的人给了我们一个新的结构，帮助我们做到这一点：他们给了我们`using`语句。
- en: 'Using that statement means that `Dispose()` is called when you don’t need the
    resource anymore. That calling can be done in two ways: as a block statement or
    as an inline statement.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用那个语句意味着当不再需要资源时，会调用`Dispose()`。这种调用可以通过两种方式完成：作为块语句或作为内联语句。
- en: 'The block statement looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 块语句看起来是这样的：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `using` starts a new scoping block. The resource can be deallocated and
    cleaned up at the end of the scope.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`using`开始一个新的作用域块。资源可以在作用域结束时被释放和清理。
- en: 'The inline variant is even easier:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 内联版本甚至更简单：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The compiler will detect when `myClass` goes out of scope automatically. As
    soon as that happens, the typical workflow of the `using` statement resumes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动检测`myClass`何时超出作用域。一旦发生这种情况，`using`语句的典型工作流程就会继续。
- en: “But,” I can almost hear you say, “you just told me that the CLR does nothing
    with that IDisposable interface, yet here it understands what to do with it!”
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: “但是，”我几乎能听到你说，“你刚才告诉我CLR对那个IDisposable接口没有任何操作，但在这里它理解如何处理它！”
- en: 'That’s a smart observation, but the knowledge about `IDisposable` is not in
    the CLR here. The compiler is the one who’s that smart. If we take the inline
    version of `using`, build our program, and inspect the IL, we’ll see the following
    code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个聪明的观察，但关于`IDisposable`的知识并不在CLR中。编译器才是那个聪明的。如果我们取`using`的内部版本，构建我们的程序，并检查IL，我们会看到以下代码：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are tiny differences between this code and the one where we called `Dispose()`
    ourselves, but these differences are not important. What’s important is that the
    compiler looked at our code and translated that into a `try-finally` block with
    the `Dispose()` method being called in that `finally` part. In other words, it
    does precisely the same thing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码和我们在自己调用`Dispose()`时的代码之间有一些细微的差别，但这些差别并不重要。重要的是编译器查看我们的代码，并将其转换为包含在`finally`部分调用`Dispose()`方法的`try-finally`块。换句话说，它确实做了完全相同的事情。
- en: So, `using` is just a convenient shorthand to instruct the compiler. If we had
    used `Cleanup()` instead of `Dispose()`, the compiler would not have understood
    it. But in the end, the code that gets run on the processor is the same. There’s
    no difference. There’s no magic involved in using `IDisposable()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`using`只是一个方便的简写，用来指示编译器。如果我们使用了`Cleanup()`而不是`Dispose()`，编译器就不会理解它。但最终，在处理器上运行的代码是相同的。没有差别。使用`IDisposable()`没有涉及任何魔法。
- en: The IDisposable pattern
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`IDisposable`模式'
- en: 'Unfortunately, we aren’t done yet. The preceding code works. It cleans up and
    does this when we don’t need the resources anymore. But we rely on the user of
    our `ResourceUser` class to do the right thing: they have to use `Dispose()` or
    a `using` statement. If they don’t, we might have a memory leak. And don’t forget
    that the developer who fails to do that is probably you, 6 months after you have
    forgotten what you did.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我们还没有完成。前面的代码是有效的。它在我们不再需要资源时进行清理和执行这些操作。但我们依赖于我们的`ResourceUser`类的用户做正确的事情：他们必须使用`Dispose()`或`using`语句。如果他们不这样做，我们可能会出现内存泄漏。而且别忘了，那个未能做到这一点的开发者可能就是你，六个月后你可能会忘记你做了什么。
- en: We need a better way to do this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种更好的方法来做这件事。
- en: The `IDisposable` pattern is a recipe to make sure the resources get cleaned
    up, no matter what.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDisposable`模式是一个确保资源得到清理的方案，无论发生什么情况。'
- en: For instance, what happens if the user of our class doesn’t call `Dispose()`,
    either directly or through the `using` statement? We need to clean up no matter
    what. Fortunately, we can do that. We have the finalizer. This always runs, although
    it might not run at the best time. But at least we can be sure that our resources
    get cleaned up eventually.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的类的用户没有直接或通过`using`语句调用`Dispose()`，会发生什么？无论发生什么情况，我们都需要清理。幸运的是，我们可以做到这一点。我们有终结器。它总是运行，尽管它可能不是在最佳时间运行。但至少我们可以确信我们的资源最终会得到清理。
- en: 'We could copy the cleaning-up code to our finalizer. However, we don’t want
    to clean up twice. The preferred way to ensure our resources are disposed of is
    to write an overloaded version of `Dispose`. The whole implementation looks like
    this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将清理代码复制到我们的终结器中。然而，我们不希望清理两次。确保我们的资源被处置的首选方式是编写一个`Dispose`的重载版本。整个实现看起来像这样：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s see what happens here.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里会发生什么。
- en: On line 3, we have the pointer to our unmanaged memory block. On line 4, I added
    a new field for another class that implements `IDisposable`. This field could
    be anything, such as a file or a database. What it is isn’t important here. All
    we need to know here is that it is a managed class we must clean up after use.
    On line 5, I added a Boolean that we use to see if the instance of this class
    has already been disposed of.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们有指向我们的非托管内存块的指针。在第4行，我添加了一个新字段，用于另一个实现`IDisposable`的类。这个字段可以是任何东西，比如一个文件或数据库。它是什么并不重要。我们在这里需要知道的是，它是一个在使用后必须清理的托管类。在第5行，我添加了一个布尔值，我们用它来查看这个类的实例是否已经被处置。
- en: Lines 6 through 10 comprise the constructor’s body in which we allocate our
    8K memory block.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行到第10行构成了构造函数的主体，其中我们分配了我们的8K内存块。
- en: On line 11, we have our `Dispose` method. In that, I first call an overloaded
    method of `Dispose` and give it a `true` parameter. We use this parameter to keep
    track of who calls the overloaded `Dispose`. What this parameter does is something
    I explain in a couple of lines below, but before I do that, I have to explain
    the `GC.SuppressFinalize(this)` line. This is the magic line. It tells the GC
    not to move this instance to `FReachableQueue` when it’s doing its magic. Effectively,
    this removes the finalizer code from our class so that when the GC runs, it can
    clear away the memory on the stack immediately instead of waiting for another
    run.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11行，我们有我们的`Dispose`方法。在那里，我首先调用一个重载的`Dispose`方法，并给它一个`true`参数。我们使用这个参数来跟踪谁调用了重载的`Dispose`。这个参数的作用我在下面几行中解释，但在那之前，我必须解释`GC.SuppressFinalize(this)`这一行。这是魔法行。它告诉GC在执行其魔法时不要将这个实例移动到`FReachableQueue`。实际上，这从我们的类中移除了终结器代码，这样当GC运行时，它可以立即清理堆栈上的内存，而不是等待另一次运行。
- en: After this, we have the finalizer. The finalizer only gets called if the class
    user forgets to call `Dispose` (or `using`) due to the `GC.SuppressFinalize(this)`
    call. This time, we call `Dispose(false)`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有终结器。终结器只有在类用户忘记调用`Dispose`（或`using`）并且由于`GC.SuppressFinalize(this)`调用而触发时才会被调用。这次，我们调用`Dispose(false)`。
- en: Let’s discuss the parameter I added to the `Dispose()` method and that I promised
    to explain. On line 20, we have the actual code for the cleanup. By now, I hope
    that you understand what the `isDisposing` flag does. If that flag is set to `true`,
    we got here because the user of the class called `Dispose()`. If the flag is `false`,
    the developer didn’t use `Dispose()` and left it to the finalizer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论我添加到`Dispose()`方法中的参数，并承诺要解释的。在第20行，我们有清理的实际代码。到现在为止，我希望你已经理解了`isDisposing`标志的作用。如果这个标志设置为`true`，我们就到了这里，因为类的用户调用了`Dispose()`。如果标志是`false`，开发者没有使用`Dispose()`，而是让它由终结器处理。
- en: Of course, we first check if we didn’t already clean up by checking the `_isDisposed`
    variable on line 22.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们首先检查是否已经清理，这是通过在第22行检查`_isDisposed`变量来完成的。
- en: Line 24 is essential. Our class has a managed resource that we need to clean
    up. But if we came from the finalizer, we have no idea when this code will run.
    It might be the case that the GC already cleaned up the memory allocated by `_someOtherDisposableClass`.
    There’s no way of knowing. If it had already been deallocated, calling `Dispose()`
    on it would result in a severe error and potentially crash our system. So, we
    must ensure we only call `Dispose` on that member if we are sure it is still around.
    If we got in this method via the finalizer, we cannot be sure. The order in which
    things are destroyed is non-deterministic. The only time we can be sure is when
    we got here through the call to `Dispose()`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第24行是至关重要的。我们的类有一个需要清理的托管资源。但如果我们从终结器来，我们就不知道这段代码会在什么时候运行。可能会出现GC已经清理了由`_someOtherDisposableClass`分配的内存的情况。我们无法知道。如果它已经被释放，那么调用它的`Dispose()`将导致严重错误，并可能导致我们的系统崩溃。因此，我们必须确保只有在确定它仍然存在的情况下才调用该成员的`Dispose()`。如果我们通过终结器进入这个方法，我们就不能确定。事物被销毁的顺序是非确定性的。我们能确定的时间只有当我们通过调用`Dispose()`进入这里时。
- en: The memory block, however, is something else. That block is unmanaged, so we
    know that the GC didn’t clean it up already. It can’t. That’s why we call it unmanaged.
    So, we clean it up here on lines 28 through 32, no matter what.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内存块是另一回事。那个块是未管理的，所以我们知道GC还没有清理它。它不能。这就是为什么我们称它为未管理。因此，我们在第28行到32行清理它，无论发生什么。
- en: 'And that is it. Things get a little bit more complicated if you have a derived
    class that stems from this class but isn’t so complex that you can’t figure it
    out yourself (hint: make `void Dispose(bool isDisposing)` protected virtual),'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。如果你有一个从这个类派生出来的派生类，但并不复杂到你自己无法理解（提示：使`void Dispose(bool isDisposing)`受保护的虚拟），事情会变得稍微复杂一些。
- en: The `IDisposable` interface is very important if you want your code to use memory
    as efficiently as possible. Here, you learned how to implement it properly and
    how to code in such a way as to remove memory leaks. Again, since we as system
    programmers are more likely to have to deal with unmanaged code compared to other
    developers, this is crucial knowledge.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让你的代码尽可能高效地使用内存，`IDisposable`接口非常重要。在这里，你学习了如何正确实现它，以及如何编写代码以消除内存泄漏。再次强调，由于我们作为系统程序员更有可能需要处理未管理代码，而不是其他开发者，这是至关重要的知识。
- en: But knowing about `IDisposable` is not enough. There are many more tips and
    tricks I want to share with you about saving memory in your app.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅了解 `IDisposable` 是不够的。我还有许多关于在您的应用程序中节省内存的技巧和窍门想要与您分享。
- en: Memory-saving tips and tricks
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节省内存的技巧和窍门
- en: System programmers need to be aware of the memory that’s used by the systems
    they write on. So, I want to share tips that will help you reduce **memory pressure**.
    Memory pressure is a fancy word to indicate how much memory is used compared to
    the amount of memory available. Again, some of these tips will make your system
    slower. As a system programmer, you must make informed choices and trade-offs
    between fast and memory-efficient code writing. Sometimes, you get lucky, and
    you get both. Other times, you must look at the options and pick the lesser of
    two evils. The following will cover specific things you can do to reduce memory
    pressure on your system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 系统程序员需要意识到他们所编写的系统所使用的内存。因此，我想分享一些可以帮助您减少**内存压力**的建议。内存压力是一个术语，用来表示与可用内存相比使用的内存量。再次强调，一些这些建议可能会使您的系统变慢。作为系统程序员，您必须做出明智的选择，在快速和内存高效的代码编写之间进行权衡。有时，您会幸运地两者兼得。其他时候，您必须考虑选项，选择两个恶行中较轻的一个。以下将涵盖您可以采取的具体措施来减少系统上的内存压力。
- en: '**Use value types over reference types**: Values types on the stack are usually
    smaller than reference types. The overhead of the pointer to the class and the
    pointers in the heap themselves can be a reason to move to value types, such as
    structs, instead of using reference types, such as classes. However, you’ll probably
    notice a performance hit if your structs get too big. Value types are copied by
    value when used as parameters, and copying big structures takes much longer.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用值类型而不是引用类型**：堆栈上的值类型通常比引用类型小。指向类的指针和堆本身中的指针的开销可能是转向值类型（如结构体）而不是使用引用类型（如类）的原因。然而，如果您的结构体变得太大，您可能会注意到性能损失。值类型在用作参数时按值复制，复制大结构体需要更长的时间。'
- en: '`ObjectPool<T>` class holds a pool of objects you can use and return when you’re
    done with them. Instead of creating an instance of your class and waiting for
    the GC to clean it up, you can make a couple and store them in the pool. Initially,
    this might increase memory pressure, but depending on your scenario, it might
    save you some memory usage.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectPool<T>` 类持有一个对象池，您可以在使用完毕后将其返回。您不需要创建类的实例并等待GC清理，而是可以创建几个实例并将它们存储在池中。最初，这可能会增加内存压力，但根据您的场景，这可能会节省一些内存使用。'
- en: '`List<T>`. The list does offer a lot of functionality. It can be very flexible
    but comes with a higher memory consumption.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T>`。列表提供了很多功能。它可以非常灵活，但代价是更高的内存消耗。'
- en: '`List<T>`, sometimes, it is tempting to use it to store some items. The same
    applies to `Dictionary<TKey, TValue>`. But you don’t always need it. If you know
    what you want to store in your classes, it might be more efficient to declare
    simpler variables for this and use those instead.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T>`，有时，使用它来存储一些项目可能会很有诱惑力。同样适用于 `Dictionary<TKey, TValue>`。但您并不总是需要它。如果您知道您想在类中存储什么，可能更有效的是声明更简单的变量来存储这些内容，并使用这些变量代替。'
- en: I have seen people using `Dictionary<TKey, TValue>` to store a username and
    an email address. Using two fixed strings for that would have been much easier,
    faster, and memory efficient. Be a smart developer!
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我看到有人使用 `Dictionary<TKey, TValue>` 来存储用户名和电子邮件地址。使用两个固定的字符串会更简单、更快、更节省内存。做一个聪明的开发者吧！
- en: '**Use Span<T> and Memory <T>**: Assume you have an array of integers. Nothing
    special, just something like this:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Span<T> 和 Memory <T>**：假设您有一个整数数组。没有什么特别的，只是像这样：'
- en: '[PRE14]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Arrays are reference types, so this allocates a memory block on the heap. There’s
    nothing wrong with that. You want to split the array into two parts for some reason.
    There are multiple ways of doing that, but the simplest (although not the fastest)
    is using Linq, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是引用类型，因此这会在堆上分配一个内存块。这并没有什么问题。您可能出于某种原因想要将数组分成两部分。有多种方法可以做到这一点，但最简单（尽管不是最快的）方法是使用Linq，如下所示：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we have three arrays on the heap. One is the original, and the others are
    the two new ones. That uses a lot of memory. That’s without me even mentioning
    the performance hit we get by copying all that data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在堆上有三个数组。一个是原始数组，其余的是两个新数组。这会消耗很多内存。即使我没有提到复制所有这些数据所带来的性能损失。
- en: Maybe you need a copy. If so, then this is a good approach. However, you should
    use `Span<T>` if you just need to split. This class is a view on the memory you
    give it. It isn’t copying; it’s just a window on the original data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你需要一份副本。如果是这样，那么这是一个好的方法。然而，如果你只需要分割，那么你应该使用`Span<T>`。这个类是你给它提供的内存的视图。它不是复制；它只是原始数据的窗口。
- en: 'That code looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码看起来是这样的：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code sample doesn’t copy the data or allocate a new array. It just gives
    you a view of the data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例不会复制数据或分配新的数组。它只是给你一个数据的视图。
- en: Of course, if the original array is garbage collected, the span points to invalid
    memory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果原始数组被垃圾回收，span将指向无效的内存。
- en: Here, `Memory<T>` is more or less the same, but it’s better when you’re using
    async operations. Next to that, a span always lives on the stack. So, you cannot
    have a span as a field in a class (remember, classes are reference types, so all
    their data is stored on the heap). In contrast, `Memory<T>` can be used on the
    heap so that you can use them as fields in classes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Memory<T>`大致相同，但当你使用异步操作时更好。此外，span始终位于堆栈上。因此，你不能在类中将span作为字段（记住，类是引用类型，所以它们的所有数据都存储在堆上）。相比之下，`Memory<T>`可以在堆上使用，这样你就可以将它们作为类的字段使用。
- en: '**Avoid boxing**: Value types are fast and memory-efficient, so long as they
    stay value types. As we discussed previously, value types suddenly have the annoying
    habit of turning into reference types. We call this process **boxing**. Boxing
    takes a lot more memory than the simple value type. So, try to be aware of those
    situations and avoid them if possible.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免装箱**：值类型速度快且内存效率高，只要它们保持为值类型。正如我们之前讨论的，值类型突然有了变成引用类型的讨厌习惯。我们称这个过程为**装箱**。装箱比简单的值类型占用更多的内存。因此，尝试意识到这些情况并在可能的情况下避免它们。'
- en: '**Use lazy initialization**: If you create an instance of a complicated class,
    you might not need to initialize all fields in the constructor. Sometimes, it’s
    better to do that only when needed. This way of working is called **lazy initialization**:
    try to postpone that initialization for as long as possible.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用延迟初始化**：如果你创建了一个复杂类的实例，你可能不需要在构造函数中初始化所有字段。有时，只在需要时这样做更好。这种方式被称为**延迟初始化**：尽可能推迟初始化。'
- en: '`System.IO.Compression`. This contains many classes that help you compress
    and deflate your data.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO.Compression`。这个命名空间包含许多帮助您压缩和解压数据的类。'
- en: '**Unload unnecessary data**: You could choose to remove data you don’t need
    lying around all the time. Then, when you need it, you can reload it on demand.
    The overhead of doing this might be worth it if you have large datasets and don’t
    always need them.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卸载不必要的数据**：你可以选择移除那些你不需要一直保留的数据。然后，当你需要它时，你可以按需重新加载它。如果你有大量数据集并且并不总是需要它们，那么这样做可能值得。'
- en: '`WeakReference<T>` reference. This means you tell the GC to remove the object
    if needed. Let me show you what I mean:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakReference<T>`引用。这意味着你告诉GC如果需要就移除对象。让我给你展示一下我的意思：'
- en: '[PRE17]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we create an instance of an object, called `myObject`. Then, we get a
    weak reference to it. Let’s assume that later in our code, we need `myObject`
    again. First, we ask `WeakReference` if the object is still available or if the
    GC has collected it. If it is available, we can use it. Otherwise, we recreate
    it and store the new pointer in `WeakReference`. Pretty neat.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`myObject`的对象实例。然后，我们获取它的弱引用。假设在我们的代码中稍后我们还需要`myObject`。首先，我们询问`WeakReference`对象是否仍然可用或GC是否已经收集了它。如果它可用，我们可以使用它。否则，我们重新创建它并将新的指针存储在`WeakReference`中。非常巧妙。
- en: '**Compact object representations**: Sometimes, you can save some memory by
    smartly combining data into other data structures. Let me show you. We can express
    three states a customer can have in the following manner:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧凑的对象表示**：有时，通过将数据智能地组合到其他数据结构中，你可以节省一些内存。让我给你展示一下。我们可以用以下方式表达客户可能拥有的三种状态：'
- en: '[PRE18]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `bool` is usually internally represented by a byte. So, this takes 3 bytes.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`bool`通常在内部用字节表示。因此，这需要3个字节。
- en: 'We could rewrite this as follows. First, we create a new `enum` value:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其重写如下。首先，我们创建一个新的`enum`值：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The notation I have used to assign the values reminds me where I am in the
    sequence: by doing a left shift, I can easily number the items (`0`, `1`, and
    `2`).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我用来分配值的表示法让我想起了我在序列中的位置：通过左移，我可以轻松地对项目进行编号（`0`、`1`和`2`）。
- en: Shifting bits
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 位移动
- en: In system programming, we work with bits and bytes a lot. So, you should be
    aware of this kind of notation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，我们经常处理位和字节。因此，你应该了解这种表示法。
- en: The `<<` operator takes all the bits in a byte and moves them one step to the
    left, effectively multiplying the value by 2\. So, `1 << 0` moves nothing, `1
    << 1` moves all bits 1 step and results in the value 2, while `1 << 2` moves the
    bits 2 steps, resulting in 4\. In binary, the results are `00000001`, `00000010`,
    and `00000100`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<` 运算符将一个字节的全部位向左移动一位，实际上是将值乘以 2。所以，`1 << 0` 不移动任何位，`1 << 1` 将所有位移动一位，结果为值
    2，而 `1 << 2` 将位移动两位，结果为 4。在二进制中，结果是 `00000001`、`00000010` 和 `00000100`。'
- en: 'We can set a variable as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样设置一个变量：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have the same information as we had in the first example, but this time,
    we’re only using one byte. That’s a 66% reduction in memory usage!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有与第一个例子中相同的信息，但这次我们只使用了一个字节。这减少了 66% 的内存使用率！
- en: '`null` allows them to be cleaned up. Since the CLR stores large objects on
    the much less frequently cleaned-up LOH, setting them to `null` enables the GC
    to clean them up there.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null` 允许它们被清理。由于 CLR 将大对象存储在很少清理的 LOH 上，将它们设置为 `null` 可以使 GC 在那里清理它们。'
- en: '**Consider using static classes**:Instance classes have many pointers going
    back and forth between the members and their data. These pointers and the member
    data can take up extra memory. Using static classes eliminates this overhead.
    The savings can be pretty significant.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑使用静态类**：实例类在其成员和其数据之间有许多指针来回移动。这些指针和成员数据可能会占用额外的内存。使用静态类消除了这种开销。节省可以相当显著。'
- en: At this point, I want to reiterate that for system developers, it is very important
    to be as memory-efficient as we can. The tips and tricks I just shared with you
    should be part of your development style. Saving memory frees up time from the
    GC and it makes your programs faster to load and usually also to execute. It helps
    in getting a better experience for the user. Of course, these tips and tricks
    can be applied to all sorts of C# programming. Every program could use better
    memory management. The same thing, however, cannot be said about unsafe code and
    pointers. Those are topics that most developers will rarely encounter. However,
    we, as system programmers, probably cannot avoid them. So, I think we should spend
    some time looking at them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我想重申，对于系统开发者来说，尽可能提高内存效率非常重要。我刚才与您分享的技巧和窍门应该成为您开发风格的一部分。节省内存可以释放 GC 的时间，并使您的程序加载和通常执行得更快。这有助于为用户提供更好的体验。当然，这些技巧和窍门可以应用于各种
    C# 编程。每个程序都可以使用更好的内存管理。然而，对于不安全代码和指针来说，情况并非如此。这些是大多数开发者很少会遇到的话题。然而，作为系统程序员，我们可能无法避免它们。因此，我认为我们应该花些时间来研究它们。
- en: Unsafe code and pointers in C#
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 中的不安全代码和指针
- en: If you’re concerned about the memory, you could take over from the CLR and the
    GC and do it all yourself. I wouldn’t recommend this, but sometimes, you have
    no choice. Although the compiler, the CLR, and the GC do amazing things, they
    cannot always predict what you are trying to achieve or what your limitations
    are. Especially for system developers, this can sometimes hinder you in achieving
    your goals. In those cases, you might have to resort to managing memory yourself.
    I think an example is in order here.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您担心内存，您可以接管 CLR 和 GC，并自己完成所有操作。我不建议这样做，但有时您别无选择。尽管编译器、CLR 和 GC 做了惊人的事情，但它们并不能总是预测您试图实现什么或您的限制是什么。特别是对于系统开发者来说，这有时可能会阻碍您实现目标。在这种情况下，您可能不得不自己管理内存。我认为这里应该举一个例子。
- en: 'Let’s start with a simple class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的类开始：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `MessagePackObject` and `Key` attributes come from the `MessagePack` NuGet
    library.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessagePackObject` 和 `Key` 属性来自 `MessagePack` NuGet 库。'
- en: The `MessagePack` library is a tool that enables you to serialize and deserialize
    instances of classes into a binary representation. Another popular serializer
    format is JSON, which is far less efficient regarding memory. That is why we’re
    using binary formatting here.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessagePack` 库是一个工具，它使您能够将类的实例序列化和反序列化成二进制表示。另一个流行的序列化格式是 JSON，它在内存效率方面远不如二进制格式。这就是为什么我们在这里使用二进制格式的原因。'
- en: 'I have written two methods: one to serialize and one to deserialize. The serializer
    comes first:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经编写了两个方法：一个用于序列化，一个用于反序列化。序列化器先来：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is pretty simple. We get an object and give it to the `Serialize` method
    of the `MessagePackSerializer` static class. That will return a `byte[]` value
    that we return to the caller of this method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。我们获取一个对象，并将其传递给 `MessagePackSerializer` 静态类的 `Serialize` 方法。这将返回一个 `byte[]`
    值，我们将其返回给此方法的调用者。
- en: 'Of course, this also needs deserialization:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也需要进行反序列化：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This method is slightly more complicated: we get a pointer to a piece of memory
    and the length of our data. We create a `byte[]` value of the correct size. Then,
    we copy the memory from the heap into the byte array so that we can deserialize
    it with the `MessagePackSerializer` class. The object we get is then returned.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法稍微复杂一些：我们获取一个内存块的指针和我们的数据长度。我们创建一个正确大小的`byte[]`值。然后，我们将堆中的内存复制到字节数组中，以便我们可以使用`MessagePackSerializer`类进行反序列化。然后，返回我们得到的对象。
- en: 'We can use these methods as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式使用这些方法：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we create an instance of `SimpleClass` and give it some data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`SimpleClass`的实例并给它一些数据。
- en: 'Then, we serialize that object using our new `SerializeToByteArray` method
    we discussed. This gives us a `byte[]` value with the raw data. Then, we allocate
    the memory on the heap where we want to store that data. We copy the data. Then,
    we can discard the `simpleClass` instance: it can be garbage collected.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用我们之前讨论的新的`SerializeToByteArray`方法来序列化该对象。这给我们一个包含原始数据的`byte[]`值。然后，我们在堆上分配我们想要存储数据的内存。我们复制数据。然后，我们可以丢弃`simpleClass`实例：它可以被垃圾回收。
- en: Note that the GC will never clean up the memory we just allocated. Our data
    is stored in our memory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，GC永远不会清理我们刚刚分配的内存。我们的数据存储在我们的内存中。
- en: If we want to use it, we need to deserialize it again, which is something we
    can do by calling `DeserializeFromByteArray`. We give the pointer to the allocated
    memory and the size we occupy.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用它，我们需要再次进行反序列化，这可以通过调用`DeserializeFromByteArray`来实现。我们提供分配的内存的指针和占用的大小。
- en: And, of course, we need to free the memory when we’re done with it. The GC doesn’t
    do that for us. We are responsible for this.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要在完成时释放内存。GC不会为我们做这件事。我们对此负责。
- en: In this example, we only used 29 bytes to store the data, which isn’t a lot.
    We can allocate that memory if needed and deallocate it when we decide. This is
    a very fast and efficient way of handling the memory of our system.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只用了29字节来存储数据，这并不多。如果需要，我们可以分配这些内存，并在我们决定时释放它们。这是处理我们系统内存的一种非常快速和高效的方式。
- en: Warning
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Don’t use `BinaryFormatter` to do this. Although using `BinaryFormatter` is
    much simpler, it is inherently unsafe. You are better off using `MessagePack`,
    as I showed here, or using a JSON-based serializer and deserializer. For more
    information, please read [https://aka.ms/binaryformatter](https://aka.ms/binaryformatter).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`BinaryFormatter`来做这件事。尽管使用`BinaryFormatter`要简单得多，但它本质上是不安全的。你最好使用我这里展示的`MessagePack`，或者使用基于JSON的序列化和反序列化器。更多信息，请参阅[https://aka.ms/binaryformatter](https://aka.ms/binaryformatter)。
- en: We can go a bit further with this. Using pointer arithmetic, we can manually
    copy all the data into our memory block. Since pointer arithmetic is unsafe, we
    need to tell the compiler we want to do this by using the `unsafe` keyword and
    setting the project options to `allow unsafe`, as we discussed at the end of the
    previous chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步。使用指针算术，我们可以手动将所有数据复制到我们的内存块中。由于指针算术是不安全的，我们需要通过使用`unsafe`关键字并将项目选项设置为`允许不安全`来告诉编译器我们想要这样做，正如我们在上一章末尾所讨论的。
- en: 'The serialization remains the same. Deserialization is simpler. The code to
    store the bits in our memory is slightly different. The whole code, however, is
    faster and more memory efficient. Here it is:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化保持一致。反序列化更简单。将比特存储到我们内存中的代码略有不同。然而，整个代码运行更快且更节省内存。下面是代码：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We start similarly by using `MessagePack` to get a binary representation of
    our object. But instead of using `Marshal.Copy()`, we copy the bytes ourselves.
    We have a pointer to the beginning of the data; we take the first byte, copy it
    into the memory block we allocated, increase the pointer, and repeat this until
    we copy the whole thing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以使用`MessagePack`获取我们对象的二进制表示的方式开始。但不是使用`Marshal.Copy()`，我们自行复制字节。我们有一个指向数据开始的指针；我们取第一个字节，将其复制到我们分配的内存块中，增加指针，然后重复此操作，直到复制整个数据。
- en: Deserialization works in the same way. We get the pointer to the block of memory
    we allocated, which now contains our data. We read the first byte, copy it into
    the array, and repeat until we finish.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化工作方式相同。我们获取我们分配的内存块的指针，现在它包含我们的数据。我们读取第一个字节，将其复制到数组中，然后重复，直到完成。
- en: Then, we deserialize it by calling the `MessagePackSerializer.Deserialize()`
    method, which takes a type, and we give it the array with all bytes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`MessagePackSerializer.Deserialize()`方法进行反序列化，该方法接受一个类型，我们给它一个包含所有字节的数组。
- en: Again, this is a speedy and efficient way to handle memory, but it does come
    with many risks. Remember, making a small mistake will mess up your day.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一种快速且高效的内存处理方式，但它确实伴随着许多风险。记住，一个小错误可能会让你的日子变得一团糟。
- en: 'Unsafe code and using pointers in your code can speed things up a lot. But
    I want to make sure you understand the implications: you’re taking over all control
    from the CLR. You’re responsible for making sure your program runs fine and safe.
    Make sure you know what you’re doing when going this route. If you do this, there
    are a lot of benefits when it comes to speed and memory efficiency!'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全代码和在你的代码中使用指针可以大大加快速度。但我想要确保你理解其影响：你正在接管CLR的所有控制权。你需要负责确保你的程序运行良好且安全。确保当你选择这条路线时，你知道自己在做什么。如果你这样做，在速度和内存效率方面会有很多好处！
- en: Next steps
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: I hope you remember most of the things we discussed, but just in case you forgot,
    we will go through the most essential points again.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能记住我们讨论的大多数内容，但以防万一你忘记了，我们将再次过一遍最关键的点。
- en: First, we discussed how the CLR and GC work together to remove the pain of memory
    management. We looked into how the GC works, what the generations mean, and what
    the LOH does.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们讨论了CLR和GC如何协同工作以减轻内存管理的痛苦。我们探讨了GC的工作原理，世代的意义，以及LOH的作用。
- en: We also talked about finalizers and why they can kill your performance. We also
    saw that they have a place when you use the `IDisposable` pattern (so long as
    you don’t forget to call `GC.SupressFinalize(this)` to remove the finalizer if
    it is unnecessary).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了终结器以及为什么它们可能会影响你的性能。我们还看到，当你使用`IDisposable`模式时（只要你不忘记调用`GC.SupressFinalize(this)`来移除不必要的终结器），它们确实有存在的理由。
- en: Then, I shared a couple of techniques you can use to optimize your memory usage
    if you need the least amount of memory usage in your system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我分享了一些你可以使用的技巧来优化你的内存使用，如果你需要你的系统中使用最少的内存量。
- en: I want to reiterate a crucial point about memory optimization. In 99 of 100
    cases, the CLR and the GC do an outstanding job. Trying to outsmart them doesn’t
    always result in better systems. The team behind these tools is good at what they
    do, and they use all the tricks in the book (and some that are not in that book!)
    to help you reduce memory pressure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我想重申关于内存优化的一个关键点。在99个案例中，CLR和GC都做得非常出色。试图超越它们并不总是能导致更好的系统。这些工具背后的团队在他们的领域里很擅长，他们使用了书中所有的技巧（以及一些书中没有的技巧！）来帮助你减轻内存压力。
- en: As a system programmer, you will run into situations where the GC and the CLR
    are just not doing a good enough job, and that is when the topics discussed here
    can help. But please be very careful. Managing memory can lead to weird and even
    catastrophic results when done wrong.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统程序员，你可能会遇到GC和CLR工作得不够好的情况，这时这里讨论的主题就能帮到你。但请务必非常小心。管理内存如果出错可能会导致奇怪甚至灾难性的后果。
- en: You should test and benchmark your code before tweaking memory usage. But if
    you follow my tips and advice, you can get exceptional results! However, things
    get much more complicated once you have multiple threads in your system. We need
    to talk about threads. A lot. And that is precisely what we are going to do in
    the next chapter!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整内存使用之前，你应该测试和基准测试你的代码。但如果你遵循我的建议和忠告，你可以得到非凡的结果！然而，一旦你的系统中有多线程，事情就会变得复杂得多。我们需要讨论线程。很多。这正是我们将在下一章中要做的！
