- en: Improving Application Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The performance of **Windows Presentation Foundation** (**WPF**) applications,
    in general, is one of its biggest problems. The more visual layers that our rendered
    data objects and UIs contain, the more time it takes to render them, so we often
    need to maintain a balance between making our applications visually appealing
    and making them perform better.
  prefs: []
  type: TYPE_NORMAL
- en: This situation can be improved by running our WPF applications on more powerful
    computers. This explains why these applications are most prevalent in the financial
    industry. However, not everyone can afford to update all of their users' computers
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there are a number of ways in which we can improve the performance
    of our WPF applications, and we'll investigate them here. The art of improving
    application performance really comes down to making a lot of small improvements
    that, together, all add up to a noticeable difference.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll explore how we can better utilize the graphics rendering
    power of our computer's graphics card and declare our resources more efficiently.
    We'll investigate how we can improve our application's performance by opting to
    use lighter weight UI controls, more efficient data binding modes, and by employing
    other techniques, such as virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the power of hardware rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've already learned, the visuals that WPF can output, while beautiful,
    can be very CPU-intensive and we often need to bear this in mind when designing
    our Views. However, rather than compromising our designs, we can offload the intensive
    rendering processes to the host computer's **Graphics Processing Unit** (**GPU**)
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: While WPF will default to utilize its software rendering pipeline, it is also
    able to take advantage of a hardware rendering pipeline. This hardware pipeline
    leverages features of Microsoft DirectX, as long as the host PC has DirectX version
    7, or higher, installed. Furthermore, if the version of DirectX that is installed
    is version 9 or higher, increased performance improvements will be seen.
  prefs: []
  type: TYPE_NORMAL
- en: The WPF Framework looks at the graphics hardware that is installed on the computer
    that it is running on and puts it into one of three categories, depending on its
    features, such as video RAM, shaders, and support for multi-textures. If it does
    not support version 7 of DirectX or higher, then it is classed in Rendering Tier
    0 and will not be used for hardware rendering at all.
  prefs: []
  type: TYPE_NORMAL
- en: However, if it does support DirectX version 7 or higher, but less than version
    9, then it is classed in Rendering Tier 1 and will be used for partial hardware
    rendering. However, as practically all new graphics cards support versions of
    DirectX higher than 9, they would all be classed in Rendering Tier 2 and would
    be used for full hardware rendering.
  prefs: []
  type: TYPE_NORMAL
- en: As the UI will freeze during the rendering time, care should be taken to minimize
    the number of visual layers that are rendered. Therefore, for WPF applications
    that will run on computers that have graphics hardware classed in Rendering Tier
    0 and use software rendering, we need to take extra care.
  prefs: []
  type: TYPE_NORMAL
- en: However, if our application is likely to be run on older computers, or computers
    with older graphics hardware, we can detect this using the rendering tier and
    run more efficient code in these instances. We can find out the rendering tier
    of the host computer's graphics hardware using the static `Tier` property of the
    `RenderCapability` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, instead of the type of this property being some kind of useful
    enumeration, it is, in fact, an integer, where only the high-order word represents
    the value of the tier and can be either `0`, `1`, or `2`. We can attain it by
    shifting the bits in the integer to read the value from just the last two bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know the rendering tier of the host computer''s graphics hardware,
    we can write code accordingly. For example, let''s imagine that we had a processor-intensive
    View, with lots of visuals making up each item in a collection. We could set the
    tier value to a property and data bind it to the View, where we could select different
    data templates to use depending on the processing power of the host computer.
    Let''s examine this example by first creating the missing enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a property of the `RenderingTier` type into our `StateManager`
    class from [Chapter 3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml), *Writing Custom
    Application Frameworks*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t need to inform the `INotifyPropertyChanged` interface of any changes
    to this property because it will only be set once upon application startup. Let''s
    adjust our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After casting the bit shifted integer value into our `RenderingTier` enumeration
    and setting it to the new `RenderingTier` property in the `StateManager` class,
    we can then start to use it in our Views to determine the level of visualizations
    that we can employ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a `ListBox` control that is displaying a collection
    of products. The idea is that we can declare three different data templates to
    define what each product will look like. We have a `SimpleDataTemplate` template
    that might just provide a text-based output, a `MoreComplexDataTemplate` template
    that could contain some basic visuals, and a `MostComplexDataTemplate` template
    that could contain several layers of visuals.
  prefs: []
  type: TYPE_NORMAL
- en: In the style that is applied to the list box, we set the default `SimpleDataTemp``late`
    template as the value of its `ItemTemplate` property. Using the `RenderingTier`
    property of the `StateManager` class, we then declare a couple of data triggers
    to switch the value of the `ItemTemplate` property to one of the more complex
    templates, depending on the rendering tier of the host computer.
  prefs: []
  type: TYPE_NORMAL
- en: Making more efficient resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we reference our resources, we can either use a `StaticResource` or a `DynamicResource`.
    If you remember from [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job*, a `StaticResource` will look up the value
    of the resource just once, which is comparative to a compile-time lookup. A `DynamicResource`
    will repeatedly look up the value of the resource each time it is requested, whether
    it has changed or not, just like a runtime lookup.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we should only ever use a `DynamicResource` if we really need
    to, as we can attain a much better performance by using the `StaticResource` class
    instead. If we find that we need to use a lot of `DynamicResource` references
    to access our resources, then we can refactor our code to data bind to properties
    in our `StateManager` class instead of the resources, in order to increase performance.
  prefs: []
  type: TYPE_NORMAL
- en: Another simple way to improve the performance of our resources is to reuse them.
    Instead of declaring them inline in the place that they are used in the XAML,
    we should declare them in a suitable resource section and reference them.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, each resource is created just once and shared. To extend this idea
    further, we could define all of our shared resources in the application resources
    in the `App.xaml` file and share them between all of the application Views.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a situation where some brush resources were declared inline with the
    XAML within a `DataTemplate` element. Now imagine that this template is set as
    the `ItemTemplate` of an `ItemsControl` object and that the collection that is
    data bound to its `ItemsSource` property contains a thousand elements.
  prefs: []
  type: TYPE_NORMAL
- en: The application will, therefore, create a thousand brush objects with identical
    properties for each brush that is declared locally within the data template. Now
    compare this to another situation where we declare each required brush just once
    in a resource section and reference it from the template. It's clear to see the
    benefit of this method and the huge savings that can be made of the computer's
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, this idea also affects the `Resources` sections of our Views, especially
    if we are displaying more than one of them at once. If we declare a View to define
    how each object in a collection should be rendered, then all of the resources
    that are declared in the View will be initialized once for each element in the
    collection. In this case, it is better to declare them at the application level.
  prefs: []
  type: TYPE_NORMAL
- en: Freezing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF, certain resource objects, such as animations, geometries, brushes, and
    pens, can be made `Freezable`. This provides special features that can help to
    improve the performance of our WPF applications. `Freezable` objects can either
    be frozen or unfrozen. In the unfrozen state, they behave like any other object;
    however, when frozen, they become immutable and can no longer be modified.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of freezing objects is that it can improve application performance,
    because frozen objects no longer require resources to be consumed when monitoring
    and issuing change notifications. Another benefit is that a frozen object is also
    safe to be shared across threads, unlike unfrozen objects.
  prefs: []
  type: TYPE_NORMAL
- en: Many UI-related objects extend the `Freezable` class to provide this functionality
    and most `Freezable` objects relate to the graphics sub-system, as rendering visuals
    is one of the areas where performance improvements are most needed.
  prefs: []
  type: TYPE_NORMAL
- en: Classes such as the `Brush`, `Geometry`, and `Transform` classes contain unmanaged
    resources and the system must monitor them for changes. By freezing these objects
    and making them immutable, the system is able to free up its monitoring resources
    and better utilize them elsewhere. Furthermore, even the memory footprint of a
    frozen object is considerably less than its unfrozen counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in order to make the greatest performance improvements, we should
    get used to freezing all of our resources in all of the `Resource` sections, as
    long as we have no plans to modify them. As most resources typically remain unmodified,
    we are usually able to freeze the vast majority of them and gain significant and
    noticeable improvements in performance by doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating Visually
    Appealing User Interfaces*, we learned how to freeze a `Freezable` object in code
    by calling its `Freeze` method. Let''s now look at how we can freeze our resources
    in XAML. First, we need to add a XAML namespace prefix to the presentation options
    namespace to access its `Freeze` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also include another XAML namespace prefix to be able to access
    the `Ignorable` attribute, and we set our `PresentationOptions` prefix as its
    value. This is because the `Freeze` attribute is primarily only recognized by
    the WPF XAML processor, and, in order to maintain compatibility with other XAML
    readers, we need to specify that the attribute can be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll find a full example in the *Drawing conclusions* section coming up soon,
    but for now, using a resource from an earlier example, let''s examine how to freeze
    a `Freezable` object in XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Some `Freezable` objects, such as the animation and geometry objects, can contain
    other `Freezable` objects. When a `Freezable` object is frozen, its child objects
    are also frozen. However, there are a few cases where a `Freezable` object cannot
    be frozen.
  prefs: []
  type: TYPE_NORMAL
- en: One case happens if it has any properties that might change in value, due to
    animations, data binding, or `DynamicResource` references. The other case occurs
    when the `Freezable` object has any child objects that cannot be frozen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are freezing resource type objects in the code behind of a custom control,
    for example, then we can call the `CanFreeze` property of the `Freezable` class
    to check whether each `Freezable` object can be frozen before attempting to freeze
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a `Freezable` object is frozen, it cannot be modified, and attempting
    to do so will cause an `InvalidOperationException` to be thrown. Note that a `Freezable`
    object cannot be unfrozen; so, to avoid this situation, we can check the value
    of the `IsFrozen` property before attempting to modify the object. If it is frozen,
    we can make a copy of it using its `Clone` method and modify that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If a `Freezable` object is cloned, any `Freezable` children that it might have
    will also be copied to enable modification. When a frozen object is animated,
    the animation system will make cloned copies of it in this way so that it can
    modify them. But, as this adds an overhead to performance, it is advisable not
    to freeze a `Freezable` object if you expect to be animated.
  prefs: []
  type: TYPE_NORMAL
- en: Using the right controls for performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, there are usually several different ways of achieving
    the same functionality, or UI display, when using WPF. Some ways will provide
    better performance than others. For example, we learned how some panels do more
    intensive layout work and, therefore, consume more CPU cycles and/or RAM than
    others.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this is one area that we can investigate in order to make performance
    improvements. If we do not require the complex layout and resizing abilities of
    a `Grid` panel, then we can gain a performance improvement by utilizing a more
    efficient `StackPanel` or `Canvas` panel instead.
  prefs: []
  type: TYPE_NORMAL
- en: Another example could be that if we do not require the ability to select in
    a collection control, then we should use an `ItemsControl` element instead of
    a `ListBox`. While swapping one control will not make much of a performance improvement
    on its own, making this same swap in the `DataTemplate` of an item that will be
    displayed thousands of times will make a noticeable difference.
  prefs: []
  type: TYPE_NORMAL
- en: As we discovered in [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job*, each time a UI element is rendered, the
    layout system must complete two passes, a measure pass and an arrange pass, which
    is collectively known as a layout pass. If the element has children and/or grandchildren,
    they will all need to complete the layout pass too. This process is intensive
    and the fewer passes that can be made, the quicker our Views will render.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, we need to be careful to ensure that we do not unnecessarily
    trigger additional passes of the layout system, as this can lead to poor performance.
    This can occur when adding or removing items to or from a panel, applying transforms
    on the elements, or by calling the `UIElement.UpdateLayout` method, which forces
    a new layout pass.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way that changes to a UI element will invalidate its children
    and force a new layout pass, we need to be especially careful when building hierarchical
    data in code. If we create the child elements first, then their parent objects,
    and then the parents of those objects, and so on, we will incur a huge performance
    hit, due to the existing child items being forced to perform multiple layout passes.
  prefs: []
  type: TYPE_NORMAL
- en: In order to address this issue, we need to always ensure that we build our tree
    from the top-down, rather than the top-up method just described. If we add the
    parent element(s) first, then add their children and their children if any, we
    can avoid the additional layout passes. The performance improvement of using the
    top-down method is approximately five times quicker to render, and so is not insignificant.
    Let's take a look at some further control-related performance benefits that we
    can employ next.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a requirement to draw shapes in our UI, such as in our callout
    window example in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating
    Visually Appealing User Interfaces*, we tend to use the abstract `Shape` class
    or, more accurately, one or more of its derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `Shape` class extends the `FrameworkElement` class, so it can make use of
    the layout system, be styled, have access to a range of stroke and fill properties,
    and its properties can be data bound and animated. This makes it easy to use and,
    generally, the preferred method of drawing in WPF applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, WPF also provides lower-level classes that can achieve the same end
    results, but more efficiently. The five classes that extend the abstract `Drawing`
    class have a much smaller inheritance hierarchy and, as such, have a much smaller
    memory footprint than their `Shape` object-based counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: The two most commonly used classes include the `GeometryDrawing` class, which
    is used to draw geometrical shapes, and the `DrawingGroup` class, which is used
    to combine multiple drawing objects into a single composite drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `Drawing` class is also extended by the `GlyphRunDrawing`
    class, which renders text; the `ImageDrawing` class, which displays images; and
    the `VideoDrawing` class, which enables us to play video files. As the `Drawing`
    class extends the `Freezable` class, further efficiency savings can be made by
    freezing its instances, that is, if they do not need to be modified afterward.
  prefs: []
  type: TYPE_NORMAL
- en: There is one other, and potentially even more efficient, method of drawing shapes
    in WPF. The `DrawingVisual` class does not provide event handling or layout functionality,
    so its performance is improved compared with other drawing methods. However, this
    is a code-only solution and there is no XAML-based `DrawingVisual` option.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, its lack of layout abilities means that, in order to display it,
    we need to create a class that extends a class that provides layout support in
    the UI, such as the `FrameworkElement` class. To be even more efficient, though,
    we could extend the `Visual` class, as that is the lightest-weight class that
    can be rendered in the UI, with the fewest properties and no events to handle.
  prefs: []
  type: TYPE_NORMAL
- en: This class would be responsible for maintaining a collection of `Visual` elements
    to be rendered, creating one or more `DrawingVisual` objects to add to the collection,
    and overriding a property and a method, in order to participate in the rendering
    process. It could also, optionally, provide event handling and hit-testing capabilities
    if user interaction was required.
  prefs: []
  type: TYPE_NORMAL
- en: It really depends on what we want to draw. Typically, the more efficient the
    drawing, the less flexible it is. For example, if we were just drawing some static
    clipart, background image, or, perhaps, logo, we could take advantage of the more
    efficient drawing methods. However, if we need our drawing to grow and shrink
    as the application windows change size, then we'll need to use the less efficient
    methods that provide more flexibility, or use another class in addition that provides
    that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore an example that creates the same graphical image using each
    of the three different drawing methods. We''ll define some smiley face emoticons,
    starting with the `Shape`-based method on the left-hand side, the `Drawing` object-based
    method in the center, and the `DrawingVisual`-based method on the right. Let''s
    first look at the visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1216ee2-906c-4871-bdd2-139de05898bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s inspect the XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that we can see straight away from this example is that the
    `Shape` object-based method of drawing is far simpler, achieving the same output
    as the far more verbose `Drawing` object-based method in far fewer lines of XAML.
    Let's now investigate the code.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the `PresentationOptions` XAML namespace, we declare a `RadialGradientBrush`
    resource and optimize its efficiency, by freezing it using the `Freeze` attribute
    that was discussed earlier in the chapter. Note that if we were planning on using
    this control multiple times simultaneously, then we could be even more efficient,
    by declaring all of our `Brush` and `Pen` objects in the application resources
    and referencing them with `StaticResource` references.
  prefs: []
  type: TYPE_NORMAL
- en: We then declare an outer `Grid` panel that has two columns. In the left column,
    we declare another `Grid` panel, with five rows and five columns. This inner panel
    is used to position the various `Shape` elements that make up the first smiley
    face. Note that we use star sizing on the row definitions of this panel in order
    to slightly increase the sizes of the top and bottom rows to better position the
    eyes and mouth of the face.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the panel, we define an `Ellipse` object to create the overall shape
    of the face, fill it with our brush from the resources, and add an outline with
    a black brush. We then use two further `Ellipse` elements filled with the black
    brush to draw the eyes and a `Path` element to draw the smile. Note that we do
    not fill the `Path` element, as that would look more like an open mouth than a
    smile.
  prefs: []
  type: TYPE_NORMAL
- en: Two other important points to note are that we must set the `Stretch` property
    to `Fill` in order to get the `Path` element to fill the available space that
    we provide it with, and we must set the `StrokeStartLineCap` and `StrokeEndLineCap`
    properties to `Round` to produce the nice, rounded ends of the smile.
  prefs: []
  type: TYPE_NORMAL
- en: 'We specify the shape that the `Path` element should be using its `Data` property
    and the inline mini-language that we used previously. Let''s now break this value
    down into the various mini-language commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous example, we start with the Move command, specified by `M` and
    the following coordinate pair, which dictates the start point for the line. The
    remainder is taken up with the Elliptical Arc command, which is specified by `A`
    and the following five figures.
  prefs: []
  type: TYPE_NORMAL
- en: In order, the five figures of the Elliptical Arc command relate to the size
    of the arc, or its *x* and *y* radii, its rotation angle, a bit field to specify
    whether the angle of the arc should be greater than 180 degrees or not, another
    bit field to specify whether the arc should be drawn in a clockwise or an anti-clockwise
    direction, and, finally, the end point of the arc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full details of this path mini-language syntax can be found on the Microsoft
    website. Note that we could change the bit field of the drawing direction to a
    `1` in order to draw a frown instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's move onto the second column of the outer `Grid` panel now. In this
    column, we recreate the same smiley face but using the more efficient `Drawing`
    object-based objects. As they cannot render themselves like the `Shape` classes
    and we need to utilize other elements to do that job for us, we define them inside
    a `DrawingBrush` element and use that to paint the background of a `Canvas` object.
  prefs: []
  type: TYPE_NORMAL
- en: There are two important things to note here. The first is that we could have
    used the `DrawingBrush` element to paint any class that extends the `FrameworkElement`
    class, such as a `Rectangle` element, or another type of panel.
  prefs: []
  type: TYPE_NORMAL
- en: The second is that as we have frozen the `DrawingBrush` element using the `Freeze`
    attribute, all of the inner elements that extend the `Freezable` type will also
    be frozen. In this case, that includes the `GeometryDrawing` objects, the `EllipseGeometry`
    and `PathGeometry` objects, and even the `Brush` and `Pen` elements that were
    used to paint them.
  prefs: []
  type: TYPE_NORMAL
- en: When using a `DrawingBrush` object to render our drawings, we must define them
    using the `Drawing` property. As we want to build up our image from multiple `Drawing`-based
    objects, we need to wrap them all in a `DrawingGroup` object.
  prefs: []
  type: TYPE_NORMAL
- en: In order to recreate the overall shape of the face, we start with a `GeometryDrawing`
    element and specify an `EllipseGeometry` object as its `Geometry` property value.
    With this `GeometryDrawing` element, we paint the background by setting a reference
    of our `RadialGradientBrush` resource to its `Brush` property, and define a new
    `Pen` instance in its `Pen` property to specify a stroke for it.
  prefs: []
  type: TYPE_NORMAL
- en: As with all `Geometry` objects, we specify its dimensions so that they are in
    scale with each other, rather than using exact pixel sizes. For example, our View
    is 150 pixels high; however, instead of setting the `Center` property of this
    `EllipseGeometry` object to 75, which is half of the height, we have set it to
    50.
  prefs: []
  type: TYPE_NORMAL
- en: As the two radii properties are also set to 50, they remain in scale with the
    position of the center and the resulting image is scaled to fit the container
    that it is rendered in. The scale that we use is up to our preference. For example,
    we could divide or multiply all of the coordinates, radii, and brush and pen thicknesses
    in our drawing example by the same amount and we would end up with the same face
    visual.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add another `GeometryDrawing` element with an `EllipseGeometry` object
    specified in its `Drawing` property for each of the two eyes on the face. These
    have no stroke and so have nothing assigned to the `Pen` property and are colored
    only using a black `Brush` set to their `Brush` properties. The final `GeometryDrawing`
    element hosts a `PathGeometry` object that draws the smile on the face.
  prefs: []
  type: TYPE_NORMAL
- en: Note that defining a `PathGeometry` object in XAML is far more verbose than
    using the path mini-language syntax. In it, we need to specify each `PathFigure`
    element in the `PathFigures` collection property, although actually declaring
    the surrounding collection in XAML is optional. In the case of our smile, we just
    need to define a single `PathFigure` element containing an `ArcSegment` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `StartPoint` property of the `PathFigure` element dictates where the arc
    should start, the `Size` property of the `ArcSegment` object relates to the size
    of the arc, or its *x* and *y* radii, while its `Point` property specifies the
    end point of the arc.
  prefs: []
  type: TYPE_NORMAL
- en: In order to define round ends for the smile, as we did with the previous smiley
    face, the `Pen` element that we specify for this `PathGeometry` object must have
    its `StartLineCap` and `EndLineCap` properties set to the `Round` member of the
    `PenLineCap` enumeration. This completes the second method of drawing a smiley
    face.
  prefs: []
  type: TYPE_NORMAL
- en: The third method uses `DrawingVisual` objects in code internally and results
    in a `Visual` object. As the items in the `Children` collection of the `Grid`
    panel are of the `UIElement` type, we cannot add our `Visual` control to it directly.
    Instead, we can set it to the `Visual` property of a `VisualBrush` element and
    paint the background of an efficient container, such as a `Canvas` control, with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at the code in this `SmileyFace` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are several classes that we could have extended our `SmileyFace` class
    from, in order to display it in the UI. As we saw in [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job,* most UI controls have a rich inheritance
    hierarchy, with each extended class offering some particular functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the most efficient container for our `DrawingVisual`, we want
    to extend a class that enables it to take part in the layout process, but adds
    as little additional overhead via unused properties and unrequired event handling
    as possible. As such, we have chosen the `Visual` class, which cannot be used
    as a UI element directly in the XAML, but it can be displayed as the visual of
    a `VisualBrush` element and used to paint a surface with.
  prefs: []
  type: TYPE_NORMAL
- en: To generate one or more `DrawingVisual` elements in our `SmileyFace` class,
    we need to declare and maintain a `VisualCollection` instance that will hold the
    `Visual` elements that we want to display. In the constructor, we initialize this
    collection and add the single `DrawingVisual` element that we want to render to
    it in this example, via the `GetFaceDrawingVisual` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GetFaceDrawingVisual` method, we first declare a new version of our
    `RadialBrush` resource using the `RadialGradientBrush` class and a `Pen` element
    and freeze them using their `Freeze` methods. Next, we initialize a single `DrawingVisual`
    element and access a `DrawingContext` object from its `RenderOpen` method, with
    which to draw our shape.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `DrawingContext` object to draw the ellipse that serves as the background
    for the face first. It is colored using the frozen `Brush` and `pen` elements.
    Note that, as the `Visual` class has no `Stretch` property or concept of size,
    the dimensions that we use here are exact device-independent pixel dimensions,
    rather than relative values, as were used in the previous drawing methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, our smiley faces are 150 pixels wide by 150 pixels tall, so
    the center position will be half of that. Therefore, these exact pixel values
    can be calculated by multiplying the relative values from the previous `Drawing`-based
    example by `1.5`.
  prefs: []
  type: TYPE_NORMAL
- en: However, we also need to consider the fact that the outline will be drawn half
    inside the drawing and half outside. As such, we need to adjust the two radii
    of this ellipse, reducing them by half of the outline size. As the pen used for
    this ellipse has a thickness of `5.25` device-independent pixels, we need to reduce
    each radius by `2.625`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the `DrawEllipse` method again to draw each of the eyes, passing
    in a black brush and no `Pen` element, along with their newly calculated positions
    and sizes. For the smile, we first need to create an `ArcSegment` element and
    add that to a collection of the `PathSegment` type, while initializing a `PathFigure`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: We then add the `PathFigure` object to a collection and pass that to the constructor
    of the `PathGeometry` object to initialize it. Next, we define the `Pen` object
    that will be used to draw the smile, ensuring that we set its `StartLineCap` and
    `EndLineCap` properties to the `Round` member of the `PenLineCap` enumeration,
    as in the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: We then freeze this `Pen` object and pass it, along with the `PathGeometry`
    object, to the `DrawGeometry` method of the `DrawingContext` object to draw it.
    Finally, we close the drawing context using its `Close` method and return the
    single `DrawingVisual` element that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: While we have now taken care of the code that draws our smiley face, we will
    not be able to see anything in the UI yet. In order to participate in the rendering
    process, we need to override a couple of members from the `Visual` class, the
    `VisualChildrenCount` property, and the `GetVisualChild` method.
  prefs: []
  type: TYPE_NORMAL
- en: When overriding these members, we need to inform the `Visual` class of the visuals
    that we want it to render for us. As such, we simply return the number of items
    in our internal `VisualCollection` object from the `VisualChildrenCount` property
    and return the item in the collection that relates to the specified `index` input
    parameter from the `GetVisualChild` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have added a check for invalid values from the `index` input
    parameter, although this shouldn't ever occur if we output the correct number
    of items from the `VisualChildrenCount` property in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have seen three different drawing methods for creating the same visual
    output, with each being more efficient than the previous one. However, apart from
    the efficiency differences, we should also be aware of the differences in these
    drawing methods when it comes to the manipulation and versatility of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s adjust the `Width` of our `DrawingView` class, set its
    `ClipToBounds` property to `true`, and view its new output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now run the application again and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6b6efa1-8049-48ae-b74c-1e4153a7481c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, these drawing methods behave differently
    when resized. The first method is redrawn at the current size and the thickness
    of each drawn line remains the same, even though the width of this face has been
    narrowed by the space provided to it from the parent `Grid` panel.
  prefs: []
  type: TYPE_NORMAL
- en: However, the second and third smiley faces actually look like squashed images,
    where the thickness of each line is no longer static; the more vertical the line
    is, the thinner it now becomes. The overall widths of these faces have also been
    adjusted by the parent `Grid` panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third face, however, has only been scaled by the `VisualBrush` object that
    is used to display it. If instead of extending the `Visual` class, we had wanted
    to derive from the `UIElement` class to utilize some of its functionality, or
    perhaps to enable us to display our `SmileyFace` control directly in the XAML,
    then we would see a different output. Let''s make a slight adjustment to our class
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also display it directly in the XAML now, replacing the `Canvas` and
    `VisualBrush` objects that previously displayed it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the application again and see the output, it will look very
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e591496-9319-4a2e-9272-1e5730e7942c.png)'
  prefs: []
  type: TYPE_IMG
- en: Because we specified exact values for our drawing, our `SmileyFace` control
    does not extend any class that would enable resizing or scaling, and we no longer
    have the `VisualBrush` object to resize it. That is, the drawing remains exactly
    as it would be at full size, except that it now no longer fits into the space
    provided to it from the parent `Grid` panel.
  prefs: []
  type: TYPE_NORMAL
- en: In order to build the ability to draw the shape at different sizes into our
    class, we'll need to derive it from a class that provides us with additional properties
    and functionality. The `FrameworkElement` class supplies us with both dimension
    properties that we can use to draw our shape at the required size and a `Loaded`
    event that we can use to delay the construction of our shape until the relevant
    size has been calculated by the layout system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the changes that we''d need to make to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first change is that we need to move the call to generate the shape from
    the constructor to the `SmileyFace_Loaded` handling method. If we had not moved
    this, our shape would have no size, because the `ActualWidth` and `ActualHeight`
    properties that are used to define its size would not have been set by the layout
    system at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the `GetFaceDrawingVisual` method, we need to replace the hardcoded
    values with divisions of the control's dimensions. The ellipse that draws the
    whole face is simple to calculate, with a position of half the width and height
    of the control and radii of half of the width and height of the control minus
    half of the thickness of the `Pen` element that draws its outline.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you were wondering where all of the remaining long decimal divisor
    values came from, the answer is basic mathematics. The original drawing was 150
    pixels wide by 150 pixels tall, so we can divide this by the various positions
    and sizes of the drawn lines from the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the ellipse that draws the first eye was previously centered with
    an `X` position of `44.25`. So, to calculate our required width divisor, we simply
    divide `150` by `44.25`, which equals `3.3898305084745761`. Therefore, when the
    control is provided with `150` pixels of space, it will draw the left eye at an
    `X` position of `44.25` and it will now scale correctly at all of the other sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The divisors for each position and size of the drawn shapes were all calculated
    using this method, to ensure that they would be sized appropriately for the space
    provided to our control. Note that we could have altered the brush and pen thicknesses
    likewise, but we have opted not to do so in this example for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running this example now, we again have a slightly different output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af68f172-08f9-49df-ad19-75ac2b3c2036.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the first and third faces look more similar, with the thicknesses of their
    drawn lines being static and unchanging along their length, unlike the second
    face. So, we can see that we have many options when it comes to creating custom
    drawings, and we need to balance the need for efficiency with the ease of use
    of the drawing method and also take the use of the resulting image into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving onto the next topic in this chapter, there are a few further efficiency
    savings that we can make when drawing complex shapes. If our code uses a large
    number of `PathGeometry` objects, then we can replace them by using a `StreamGeometry`
    object instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `StreamGeometry` class is specifically optimized to handle multiple path
    geometries and shows better performance than can be attained from using multiple
    `PathGeometry` instances. In fact, we have already been using the `StreamGeometry`
    class inadvertently, as that is what is used internally when the binding path
    mini-language syntax is parsed by the XAML reader.
  prefs: []
  type: TYPE_NORMAL
- en: It can be thought of in a similar way to the `StringBuilder` class, in that
    it is more efficient at drawing complex shapes than using multiple instances of
    the `PathGeometry` class, but it also has some overhead and so only benefits us
    when replacing a fair number of them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, rather than display our `DrawingVisual` using a `VisualBrush`, which
    is refreshed during each layout pass, if our drawings are never to be manipulated
    in the UI, it is even more efficient to create actual images from them and display
    those instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RenderTargetBitmap` class provides a simple way for us to create images
    from `Visual` instances, using its `Render` method. Let''s explore an example
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We start by initializing a `RenderTargetBitmap` object with the required dimensions,
    resolution, and pixel format of the image to create. Note that the `Pbgra32` member
    of the static `PixelFormats` class specifies a pixel format that follows the sRGB
    format, using 32 bits per pixel, with each of the four alpha, red, green, and
    blue channels receiving 8 bits each per pixel.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we pass our `DrawingVisual` element, or any other element that extends
    the `Visual` class, to the `Render` method of the `RenderTargetBitmap` class to
    render it. To make the operation more efficient still, we then call its `Freeze`
    method to freeze the object.
  prefs: []
  type: TYPE_NORMAL
- en: In order to save a PNG image file, we first initialize a `PngBitmapEncoder`
    object and add the `renderTargetBitmap` variable to its `Frames` collection via
    the `Create` method of the `BitmapFrame` class. Finally, we initialize a `Stream`
    object using the `File.Create` method, passing in the desired file name and path,
    and call its `Save` method to save the file to the computer's hard drive. Alternatively,
    the `JpegBitmapEncoder` class can be used to create a JPG image file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to find ways of using images more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Imaging more efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an image is displayed in a WPF application, it is loaded and decoded in
    its full size by default. If your application displays a number of thumbnails
    from the original images, then you can gain enhanced performance by copying your
    full-size images and then resizing them to the correct size for the thumbnails,
    rather than letting WPF do it for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can request that WPF decodes your images to the size required
    by the thumbnails, although, if you want to display the full-size images, you
    would really need to decode each full-size image separately. Let''s take a look
    at how we can achieve this by using a `BitmapImage` object as the source for an
    `Image` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The important part of this example is the `DecodePixelWidth` property of the
    `BitmapImage` class, which specifies the actual size of the image to decode to.
    In this example, this would result in a smaller memory footprint as well as faster
    rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the `DecodePixelHeight` and `DecodePixelWidth` properties of the
    `BitmapImage` class are both set, a new aspect ratio will be calculated from their
    values. However, if only one of these properties is set, then the image's original
    aspect ratio will be used. It is, therefore, customary to only set one of these
    properties in order to decode to a different size from the original, while maintaining
    its aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, when images are used in a WPF application, they are all cached into
    memory at load time. Another benefit that can be gained if using code in the aforementioned
    scenario is to set the `CacheOption` property of the `BitmapImage` class to the
    `OnDemand` enumeration member, which postpones the caching of the relevant image
    until the image is actually requested to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: This can save a significant amount of resources at load time, although each
    image will take a tiny bit longer to display the first time they are displayed.
    Once the image is cached, however, it will work in exactly the same way as the
    images created in the default way.
  prefs: []
  type: TYPE_NORMAL
- en: There is one additional property in the `BitmapImage` class that can be used
    to improve the performance when loading multiple image files. The `CreateOptions`
    property is of the `BitmapCreateOptions` enumeration type and enables us to specify
    initialization options that relate to the loading of images. This enumeration
    can be set using bitwise combinations as it specifies the `FlagsAttribute` attribute
    in its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The `DelayCreation` member can be used to delay the initialization of each image
    until it is actually required, thereby speeding up the process of loading the
    relevant View, while adding a tiny cost to the process of requesting each image
    when it is actually required.
  prefs: []
  type: TYPE_NORMAL
- en: This would benefit a photo gallery type of application, for example, where the
    initialization of each full-size image could be delayed until the user clicks
    on the appropriate thumbnail. It is only at that point that the image would be
    created, but as there would only be a single image to create at that point, the
    initialization time would be negligible.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is possible to set more than one of these members to the `CreateOptions`
    property using the bitwise OR operator (`|`), care should be taken to not also
    set the `PreservePixelFormat` member, unless specifically required, as that can
    result in lower performance. When it is not set, the system will choose the pixel
    format with the best performance by default. Let''s look at a short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When creating images in code, we need to initialize an instance of the `BitmapImage`
    class to use as the source for the actual `Image` object that will be displayed
    in the UI. When doing so, we need to call its `BeginInit` method before making
    changes to it and then call its `EndInit` method afterward. Note that all changes
    made after initialization will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: During initialization, we set the `CacheOption` property to the `OnDemand` member
    and the `CreateOptions` property to the `DelayCreation` member. Note that we do
    not set the `DecodePixelWidth` or `DecodePixelHeight` properties here, because
    this code example is setup for initializing the full-size images in our gallery
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, note that, in this particular example, we initialize the `Uri`
    object using an absolute file path, by passing the `Absolute` member of the `UriKind`
    enumeration into the constructor. If you prefer to work with relative file paths,
    you can change this line to specify a relative file path by passing the `Relative`
    member to the constructor instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Returning to the end of the example now, we can see the call to the `Freeze`
    method, which ensures that the `BitmapImage` object will be unmodifiable and in
    its most efficient state. This line can be omitted if the images need to be modified
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the `EndInit` method to signal the end of the `BitmapImage` object initialization,
    set the `BitmapImage` object as the `Source` property value of the `Image` object
    to return, and then return the `Image` object to the method caller.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen some tips on how to display our images more efficiently,
    let's investigate how we might do the same for our application's textual output.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the performance of textual output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WPF provides similar options for creating text as it does for drawing shapes;
    the more versatile the output method, the easier it is to use, but the less efficient
    it is and vice versa. The vast majority of us opt for the simplest, but least
    efficient, method of using the high-level `TextBlock` or `Label` elements.
  prefs: []
  type: TYPE_NORMAL
- en: While this doesn't typically cause us any problems when used in typical forms,
    there is definitely room for improvement when displaying thousands of text blocks
    in a data grid, or other collection control. If we require formatted text, we
    can utilize the more efficient `FormattedText` object; otherwise, we can use the
    lowest-level method and the most efficient `Glyphs` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a View that has a `Grid` panel with four rows. The first row holds
    a `Label` control, which although fairly efficient, is the least efficient of
    the textual output methods shown here and, as we'll see soon, should only be used
    in very specific circumstances. On it, we specify the `FontFamily`, `FontSize`,
    `FontWeight`, `FontStyle`, and `Foreground` properties to define how its text
    should look.
  prefs: []
  type: TYPE_NORMAL
- en: The second row contains a `TextBlock` element, which is slightly more efficient,
    and, like the `Label` element, we specify the `FontFamily`, `FontSize`, `FontWeight`, `FontStyle`,
    and `Foreground` properties on it directly. It's worth noting that to result in
    the same visual output, we don't need to set its `Padding` property to `0`, which
    was required with the `Label` control.
  prefs: []
  type: TYPE_NORMAL
- en: In the third row, we have a custom `FormattedTextOutput` control that uses a
    `FormattedText` object internally and is slightly more efficient still. As we'll
    see shortly, we need to specify the relevant properties of this text object in
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we see a `Glyphs` element in the fourth row and this represents the
    most efficient method of outputting text in a WPF application. Note that when
    using this method of textual output, we don't specify a font family by name, but
    instead set an exact font file path to its `FontUri` property.
  prefs: []
  type: TYPE_NORMAL
- en: As we want to match the bold italic version of the Times New Roman font, we
    specifically need to set the file path to that exact file. Therefore, we need
    to specify the `timesbi.ttf` file, rather than the normal `times.ttf` version.
    Other than setting the font size to the `FontRenderingEmSize` property and the
    margin to the `OriginX` and `OriginY` properties, this class is fairly self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing, let''s first take a look at the visual output of this View:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b839587f-85d3-46dd-b448-f25cd86a7f9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now take a look at the code inside the `FormattedTextOutput` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `FormattedTextOutput` class is a fairly simple affair, with a single Dependency
    Property and its associated CLR wrapper and a single overridden base class method.
    One very important point to note is our use of the `AffectsRender` member of the
    `FrameworkPropertyMetadataOptions` enumeration to specify that changes to this
    property need to cause a new rendering pass.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the `Text` property will be updated from any data binding after the
    `OnRender` method is called by the `UIElement` base class. Without specifying
    this option, our class will never output any data bound values. By specifying
    this option, we are, in fact, telling the Framework to call the `OnRender` method
    again each time this property value changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the overridden `OnRender` method, we first initialize a `FormattedText` object
    with basic properties, such as the text to render, the current culture, and the
    color, size, and type of the font to use. Additional style properties can be set
    using the various set methods that the class exposes. Finally, we call the `DrawText`
    method of the `DrawingContext` object specified by the `drawingContext` input
    parameter, passing in the `FormattedText` object and the position to render it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can use data binding with all of these text rendering methods,
    so let''s now update our previous example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, we can simply hardcode a value in our View Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Although we can data bind when using all of these textual output methods, there
    are some caveats to be aware of. We've just learned of one relating to the required
    metadata of the `Text` property in our custom `FormattedTextOutput` class and
    there is another relating to the `Glyphs` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has a requirement that the `UnicodeString` property cannot be empty if the
    `Indicies` property, which represents an alternative method of providing the text
    to render, is also empty. Unfortunately, because of this requirement, attempting
    to data bind to the `UnicodeString` property, as we did in our extended example,
    will result in a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To address this issue, we can simply provide a value for the `FallbackValue`
    property of the `Binding` class, so that the `Glyphs` class can be rest assured
    that even if there is no data bound value, its `UnicodeString` property will have
    a non-empty value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that setting the `FallbackValue` property to an empty string will result
    in the same error being raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There is one further issue regarding data binding; however, this time, it involves
    the `Content` property of the `Label` class. Because the `string` type is immutable,
    each time a data bound value updates the `Content` property, the previous `string` type
    will be discarded and replaced with the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if the default `ContentTemplate` element is used, it will generate
    a new `TextBlock` element and discard the previous element each time the property
    string is replaced. As a result, updating a data bound `TextBlock` is approximately
    four times quicker than updating a `Label` control. Therefore, if we need to update
    our data bound text values, we should not use a `Label` control.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, each method of rendering text has its own purpose. The `Label` control
    should specifically be used to label text fields in a form, and, in doing so,
    we can take advantage of its access key functionality and its ability to reference
    a target control. The `TextBlock` element is a general-purpose text output method
    that should be used the majority of the time.
  prefs: []
  type: TYPE_NORMAL
- en: The `FormattedText` object should really only be used when we specifically want
    to format some text in a particular way. It provides the ability to output text
    with a wide range of effects, such as being able to paint the stroke and fill
    of the text independently and to format particular ranges of characters within
    the rendered text string.
  prefs: []
  type: TYPE_NORMAL
- en: The `Glyphs` class extends the `FrameworkElement` class directly and is, therefore,
    extremely light-weight and should be utilized when we need to recreate our text
    output more efficiently than we can by using the alternative methods. Although
    the `FormattedText` class can make use of lower, core level classes to render
    its output, the most efficient way to render text is to use `Glyphs` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Liking the linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have already seen, each UI element that we use in our Views takes time
    to render. Simply put, the fewer elements that we use, the quicker the View will
    be displayed. Those of us that have used `Hyperlink` elements in our Views will
    already be aware that we cannot display them on their own but, instead, have to
    wrap them inside a `TextBlock` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as each `Hyperlink` element is self-contained, with its own navigation
    URI, content, and property options, we can actually display more than one of them
    in a single `TextBlock` element. This will reduce the render time; therefore,
    the more `TextBlock` elements that we can remove, the quicker it will become.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a collection of `Product` objects that are data bound to a `ListBox`,
    with each item displaying its name, price, and three commands in the form of `Hyperlink`
    objects. Let''s see what this looks like before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71baf69c-b6bc-4216-a5af-32069a49df30.png)'
  prefs: []
  type: TYPE_IMG
- en: Focusing on the links now, our example uses nine UI elements per item to render
    these three links. The `StackPanel` element keeps them altogether, with each `Hyperlink`
    object having its own `TextBlock` element and a further two `TextBlock` elements
    to display the pipe separator characters.
  prefs: []
  type: TYPE_NORMAL
- en: The `Hyperlink` objects are data bound to commands in the View Model and the
    `CommandParameter` property is data bound to the whole `Product` object that is
    set as the data source for each item. In this way, we will have access to the
    relevant `Product` instance in the View Model when a link is clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there is nothing wrong with this XAML, if we need to be more efficient,
    then we can replace everything inside the `StackPanel` and the panel itself with
    the following `TextBlock` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we now host all three `Hyperlink` objects inside a single `TextBlock`
    element and have replaced the two `TextBlock` elements that displayed the pipe
    characters with `Run` objects. Using the `Run` class is moderately more efficient
    than using one `TextBlock` element inside another.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need only render six elements per item to produce the links, including
    using two more efficient elements, rendering three elements fewer per item. However,
    if we had 1,000 products, we would end up rendering 3,000 fewer UI elements, with
    2,000 more efficient replacements, so it is easy to see how this can soon add
    up to some real efficiency savings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we could make further improvements, simply by removing the
    line under each link. Bizarrely, we can save up to 25 percent of the rendering
    time taken to render our `Hyperlink` elements if we remove their underlines. We
    can do this by setting their `TextDecorations` property to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We could extend this idea further, by only displaying the underline when the
    user''s mouse cursor is over the link. In this way, we still give the visual confirmation
    that the link is, in fact, a link, but we save the initial rendering time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let's now turn our attention to a number of performance improvements that we
    can make when data binding in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest improvement in performance when data binding can be obtained by
    simply setting the `Binding.Mode` property correctly. In order to make data binding
    possible, the Framework attaches handlers to listen out for changes to our data
    bound properties.
  prefs: []
  type: TYPE_NORMAL
- en: For two-way bindings, event handlers will be attached to the `PropertyChanged`
    event of the `INotifyPropertyChanged` interface to listen to changes in our data
    Model objects or View Models and to various other `XxxChanged` events in the relevant
    binding target controls to listen to UI-based property changes.
  prefs: []
  type: TYPE_NORMAL
- en: When we only require one-way bindings, we can save some computing resources
    by setting the `Mode` property of the `Binding` class to the appropriate member
    of the `BindingMode` enumeration. If you remember, when a data bound property
    is for display purposes only, we should set its `Mode` property to `OneWay`, and
    when we have no need to update an editable field from the View Model, we should
    set its `Mode` property to the `OneWayToSource` member.
  prefs: []
  type: TYPE_NORMAL
- en: In doing this, we cut down the number of event handlers listening for changes
    and, therefore, free up resources to be used where they are actually needed. Once
    again, the effect of doing this on one binding alone would be negligible, but
    if we practice this on every relevant binding, then the efficiency improvement
    will start to make a difference.
  prefs: []
  type: TYPE_NORMAL
- en: Another good practice to get into is to set the `FallbackValue` property of
    the `Binding` class on each binding that we declare. As mentioned in [Chapter
    4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml), *Becoming Proficient with Data
    Binding*, doing this will stop the WPF Framework from performing a lookup of the
    default value of the target Dependency Property when there are data binding errors
    and will prevent trace statements from being generated and output.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, setting the `TargetNullValue` property is similar to setting the `FallbackValue`
    property in that it is slightly more efficient than not setting it. Again, doing
    this on a single binding will have a negligible effect; however, if we do this
    on every binding, it will free up CPU cycles for rendering or other required processes.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the best binding-related way to increase the performance of our applications
    is to simply fix any data binding errors that we may have. Each time a binding
    cannot be resolved, the Framework will perform a number of checks, using up valuable
    resources, as mentioned previously in this section. Therefore, keeping the Output
    window free of binding errors is a must when it comes to performance.
  prefs: []
  type: TYPE_NORMAL
- en: Registering Dependency Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the *Using the right controls for performance* section earlier
    in this chapter, we need to be careful when setting the metadata for our Dependency
    Properties. Incorrectly specifying the framework metadata while registering our
    Dependency Properties can lower performance by forcing the layout system to unnecessarily
    perform additional layout passes.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we need to be careful when specifying any of the `AffectsMeasure`,
    `AffectsArrange`, `AffectsParentMeasure`, `AffectsParentArrange`, or `AffectsRender`
    members of the `FrameworkPropertyMetadataOptions` enumeration and ensure that
    they are actually required.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, if we specify the `Inherits` member of the `FrameworkPropertyMetadataOptions`
    enumeration when registering our Dependency Property, we are effectively increasing
    the length of time that invalidation will take on the property. As such, we should
    ensure that this particular metadata member is only used when it is really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: One last metadata option that can improve the performance of the application
    is the `SubPropertiesDoNotAffectRender` member. If the type of our Dependency
    Property is a reference type, we can specify this enumeration member to stop the
    layout system from checking for changes to all sub-properties of the object, which
    it would otherwise do by default.
  prefs: []
  type: TYPE_NORMAL
- en: While we may need to call the `OverrideMetadata` method of the `DependencyProperty`
    class to override the metadata of the pre-existing properties in the .NET Framework,
    this comes with a small performance impact. When setting the metadata for our
    own custom Dependency Properties, we should always use the appropriate `Register`
    or `RegisterAttached` method to specify our requirements, as this offers far better
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, when registering our custom Dependency Properties, we should also
    set their default values using the relevant `Register` or `RegisterAttached` method
    as they are created, rather than initializing each instance individually in a
    constructor, or by using some other method.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you are most probably aware, when dealing with collections that will be updated
    in a WPF application, we tend to prefer using the generic `ObservableCollection<T>`
    class. The reason for this is because this class implements the `INotifyCollectionChanged`
    interface, which notifies listeners of changes to the collection, such as adding,
    removing, or clearing items.
  prefs: []
  type: TYPE_NORMAL
- en: What we may not realize is the incredible performance improvement that we get
    from using this class to hold our data collections. When comparing this with the
    generic `List<T>` class, for example, we note that it does not automatically raise
    any collection changed event. In order to enable the View to display the updated
    collection, we need to reset it as the `ItemsSource` property value of the relevant
    collection control.
  prefs: []
  type: TYPE_NORMAL
- en: However, each time that the `ItemsSource` property is set, the data bound collection
    control will clear its current list of items and completely regenerate them again,
    which can be a time-consuming process. So, to add a single item to an `ObservableCollection<T>`
    takes approximately 20 milliseconds to render, but to reset the `ItemsSource`
    property value could take over 1.5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: However, if our collection is immutable and we will not be altering it in any
    way, we do not need to use the generic `ObservableCollection<T>` class, as we
    have no need for its change handlers. Rather than wasting resources on unused
    change handlers, we can use a different type of collection class.
  prefs: []
  type: TYPE_NORMAL
- en: While there is not a preferred type of collection to use when data binding immutable
    collections to UI controls, we should try to avoid using the `IEnumerable` class
    as the collection container. This type cannot be used directly by the `ItemsControl`
    class, and, when it is used, the WPF Framework will generate a generic `IList<T>`
    collection to wrap the `IEnumerable` instance and this can also negatively affect
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we'll explore other ways in which we can display large
    collections efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Shrinking data objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often, our applications will have fairly sizable data objects, with dozens,
    or even hundreds, of properties. If we were to load all of the properties for
    each data object when we have thousands of them, our application would slow down
    and possibly even run out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: We might think that we can save on RAM by simply not populating all of the property
    values; however, if we use the same classes, we'll soon find that even the default
    or empty values for these properties may consume too much memory. In general,
    and with a few exceptions, unset properties take the same amount of RAM as set
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: If our data model object has a very large number of properties, one solution
    would be to break it down into much smaller pieces. For example, we could create
    a number of smaller, sub product classes, such as `ProductTechnicalSpecification`,
    `ProductDescription`, `ProductDimension`, `ProductPricing`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than building one giant View to edit the whole product, we could then
    provide a number of smaller Views, perhaps even accessible from different tabs
    within the same View. In this way, we would be able to just load the `ProductDescription`
    objects for the user to select from and then load the individual sections of the
    product in each sub View.
  prefs: []
  type: TYPE_NORMAL
- en: There is a significant performance increase to be gained by this method, as
    binding to a single object with a great many properties can take up to four times
    longer than binding to a great many objects with fewer properties.
  prefs: []
  type: TYPE_NORMAL
- en: One alternative to breaking our data objects into smaller pieces would be to
    use the concept of thin data objects. For example, imagine that our `Product`
    class had dozens of properties and that we had thousands of products. We could
    create a `ThinProduct` class that contains only the properties that would be used
    to identify the full data object to load when selected and those displayed in
    the product collection.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we might simply need two properties in our `ThinProduct` class,
    a unique identification property, and a display name property. In this way, we
    can reduce the memory footprint of our products by a factor of 10 or even more.
    This means that they can be loaded from the database and displayed in a fraction
    of the time of the full `Product` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to facilitate easy transferal between the `Product` and `ThinProduct`
    classes, we can add constructors into each class that accepts the other type and
    updates the relevant properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties in this `ThinProduct` class basically mirror those from the
    `Product` class that we saw earlier, but only the ones that are used to identify
    each instance. A constructor is added that takes an input parameter of type `Product`
    to enable easy transferal between the two. A similar constructor is added to the
    `Product` class, but takes an input parameter of type `ThinProduct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that we have a View Model that displays a large number of products
    and in code, we actually load a large number of these much lighter `ThinProduct`
    instances. When the user selects one of the products to view or edit, we use the
    identification number of the selected item to then load the full `Product` object
    that relates to that identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a base collection of these `ThinProduct` instances in a property named
    `Products`, we could achieve this as follows. First, let''s bind our collection
    to a `ListBox` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When the user selects a product from the list, the collection's `CurrentItem`
    property will hold a reference to the selected item. If we attach a handler to
    the collection's `CurrentItemChanged` delegate when it is first loaded, we can
    be notified when the item is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'At that point, we can load the full `Product` object using the identifier from
    the selected `ThinProduct` instance and output the associated feedback to the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll find out how we can display our large collections
    more efficiently using collection controls, rather than having to break up our
    large classes into smaller classes or create associated thin data objects.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualizing collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we display large numbers of items in our collection controls, it can negatively
    affect the application's performance. This is because the layout system will create
    a layout container, such as a `ComboBoxItem` in the case of a `ComboBox`, for
    example, for every item in the data bound collection. As only a small subset of
    the complete number of items is displayed at any one time, we can take advantage
    of virtualization to improve the situation.
  prefs: []
  type: TYPE_NORMAL
- en: UI virtualization defers the generation and layout of these item containers
    until each item is actually visible in the relevant collection control, often
    saving on large amounts of resources. We can take advantage of virtualization
    without doing anything at all if we use `ListBox` or `ListView` controls to display
    our collections, as they use it by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtualization can also be enabled in `ComboBox`, `ContextMenu`, and `TreeView`
    controls, although it will have to be done manually. When using a `TreeView` control,
    we can enable virtualization by simply setting the `VirtualizingStackPanel.IsVirtualizing` Attached
    Property to `True` on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For other controls that use the `StackPanel` class internally, such as the
    `ComboBox` and `ContextMenu` controls, we can enable virtualization by setting
    an `ItemsPanelTemplate` element hosting an instance of the `VirtualizingStackPanel`
    class with its `IsVirtualizing` property set to `True` to its `ItemsPanel` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Apart from setting the `IsVirtualizing` property to `False`, there are a few
    other reasons why UI virtualization may not work. One case is when item containers
    have manually been added to an `ItemsControl` object or one of its derived controls.
    Another case is when the item containers are of different types.
  prefs: []
  type: TYPE_NORMAL
- en: The final reason why virtualization may not work is not so obvious and relates
    to the `CanContentScroll` property of the `ScrollViewer` class. This is an interesting
    property that specifies whether the `ScrollViewer` in a collection control will
    scroll its items in logical units or physical units. The default value is `False`,
    which smoothly scrolls in terms of physical units.
  prefs: []
  type: TYPE_NORMAL
- en: Physical units relate to the device-independent pixels that WPF works with,
    while logical units relate to the widths or heights of the collection items, depending
    on the orientation of the control. As the default value of the `CanContentScroll`
    property is `False`, this will need to be set to `True` to enable virtualization.
    This is so that scrolling is performed item by item and not pixel by pixel.
  prefs: []
  type: TYPE_NORMAL
- en: When virtualization is employed in a collection control that extends the `ItemsControl`
    class and the user scrolls, new item containers are created for the newly visible
    items and the containers for the items that are no longer visible are disposed
    of.
  prefs: []
  type: TYPE_NORMAL
- en: 'In version 3.5 of the .NET Framework, an optimization of the virtualization
    system was introduced. Container recycling enables the collection control to reuse
    the item containers, instead of creating new ones and disposing of old ones as
    the user scrolls. This offers an additional performance benefit and can be enabled
    by setting the `VirtualizationMode` Attached Property to a value of `Recycling`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: One further optimization that WPF provides us with is deferred scrolling. Normally,
    scrolling in a collection control continuously updates the UI. However, if our
    data items or their item containers have several layers of visuals that define
    them and scrolling is slow, we can opt to defer the UI update until scrolling
    has finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable deferred scrolling on a collection control, we need to set
    the `ScrollViewer.IsDeferredScrollingEnabled` Attached Property to `True`. Although
    we don''t generally use `ScrollViewer` elements in XAML directly, we can also
    attach this property to collection controls that host a `ScrollViewer` element
    in their control templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We've now investigated performance improvements that we can make with computer
    hardware, resources, correct control selection, methods of drawing and displaying
    images, outputting text, linking, data binding, minimizing memory footprints,
    and data virtualization. There is just one more essential area to look at, that
    is, events, so let's look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common causes of memory leaks appearing in an application is
    the failure to remove event handlers once they are no longer needed. When we attach
    an event handler to an object's event in the usual way, we are effectively passing
    that object a reference to the handler and creating a hard reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: When the object is no longer needed and could otherwise be disposed of, the
    reference in the object that raises the event will prevent that from occurring.
    This is because the garbage collector cannot collect an object that can be accessed
    from any part of the application code. In the worst-case scenario, the object
    being kept alive may contain numerous other objects and, therefore, inadvertently
    keep them alive as well.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this is that keeping objects alive after they are no longer
    needed will unnecessarily increase the memory footprint of the application, in
    some cases, with dramatic and irreversible consequences, leading to an `OutOfMemoryException`
    being thrown. It is, therefore, essential that we detach our event handlers from
    the events that they are subscribed to in objects that we have no further use
    for before trying to dispose of them.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, an alternative method that we can use to avoid this situation.
    In the .NET Framework, there is a `WeakReference` class and it can be used to
    remove the hard references caused by attaching event handlers to events using
    the traditional method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic idea is that the class that raises the event should maintain a collection
    of `WeakReference` instances and add to it each time another class attaches an
    event handler to the event. Let''s now create a new `WeakReferenceActionCommand`
    class from our `ActionCommand` class from earlier to use this `WeakReference`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We start by adding a declaration of our new collection containing objects of
    the `WeakReference` type to the pre-existing fields. The two constructors remain
    unchanged, but when attaching handlers in the `CanExecuteChanged` event, we now
    wrap the event handling delegate in a `WeakReference` object and add it to the
    collection. We still need to pass the references to the handlers that get attached
    through to the `RequerySuggested` event of the `CommandManager` class as before.
  prefs: []
  type: TYPE_NORMAL
- en: When an event handler is removed, we first double-check that our `WeakReference`
    collection is not `null` and simply return control to the caller if it is. If
    not, we use a `for` loop to iterate through the collection in reverse so that
    we can remove items without affecting the loop index.
  prefs: []
  type: TYPE_NORMAL
- en: We attempt to access the actual event handler from the `Target` property of
    each `WeakReference` object in turn, converting it to the `EventHandler` base
    type using the `as` keyword. We then remove the `WeakReference` instance if its
    event handler reference is either `null` or it matches the handler being removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a `null` reference in the `Target` property would be the result of
    an event handler from a class that has been disposed of by the garbage collector.
    As before, we then also detach the event handler from the `CommandManager.RequerySuggested` event.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to update our `RaiseCanExecuteChanged` method to use our new
    collection of `WeakReference` objects. In it, we again iterate through each instance
    in the collection using our `ForEach` Extension Method and after checking whether
    its `Target` property is `null` by using the null conditional operator, call it
    using the delegate's `Invoke` method.
  prefs: []
  type: TYPE_NORMAL
- en: So, the idea here is that we no longer directly hold on to any references to
    the attached event handlers and are, therefore, free to dispose of those classes
    at any point without fear of them being kept alive unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a number of options that we can use to increase
    the performance of our WPF applications. As we have now seen, this is more a case
    of making a large number of little changes to gain an overall noticeable performance
    benefit.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that we can utilize the graphics rendering power of our computer's graphics
    card and declare our resources more efficiently. We investigated ways to improve
    our application's performance using lighter-weight UI controls and more efficient
    methods of rendering drawings, images, and text. We also learned how to data bind,
    display large objects and collections, and handle events with improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate the final requirement for all professional
    applications, that is, deployment. In it, we will first cover the older method,
    using the Windows Installer software, and then progress to investigate the more
    common and up-to-date method, that is, using ClickOnce functionality.
  prefs: []
  type: TYPE_NORMAL
