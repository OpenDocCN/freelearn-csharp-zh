<html><head></head><body>
		<div><h1 id="_idParaDest-115" class="chapter-number"><a id="_idTextAnchor116"/>5</h1>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor117"/>Building Restful APIs</h1>
			<p>In today’s online-centric digital landscape, <strong class="bold">application programming interfaces </strong>(<strong class="bold">APIs</strong>) have become ubiquitous in the development of <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>) applications. They allow different systems and applications to communicate with each other and share data. Among the different types of <a id="_idIndexMarker256"/>APIs, <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>)ful APIs have become the most widely used and accepted standard, and that is what we will focus on in this chapter.</p>
			<p>This chapter will introduce you to the basics of building RESTful APIs and the key principles that guide their design. You will learn about the key components of a RESTful API, such as resources, representations, and the main HTTP verbs (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>).</p>
			<p>Additionally, you will learn about the various strategies to version RESTful APIs, such as URL versioning, custom header versioning, media type versioning, and deprecation and sunsetting.</p>
			<p>The main topics covered in this chapter are as follows:</p>
			<ul>
				<li>What are RESTful APIs?</li>
				<li>Matching API operations to HTTP verbs</li>
				<li>Designing better with REST</li>
				<li>Versioning public APIs</li>
				<li>Testing APIs</li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of the key principles and strategies to build RESTful APIs, and you will be well-equipped to design, develop, and test them.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor118"/>Technical requirements</h1>
			<p>All code from this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-5</a>.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>What are RESTful APIs?</h1>
			<p>REST was <a id="_idIndexMarker257"/>introduced by Roy Fielding in his doctoral dissertation at the University of California, Irvine, in 2000. In his dissertation, Fielding defined the architectural constraints that formed the basis of RESTful systems and described how REST could be used to build scalable and flexible web services. The concepts outlined in his dissertation have since become widely adopted and are used as the foundation to build many modern web APIs.</p>
			<p>RESTful APIs <a id="_idIndexMarker258"/>are a type of web-based interface that allows for communication between different software systems. They utilize a standard set of constraints and principles defined by the REST architecture to exchange data between a client and server. Resources are identified by unique URLs, and the behavior toward these resources is defined by the HTTP methods used. RESTful APIs are commonly used to build scalable and flexible web services and can return data in different formats, such as JSON or XML. They offer a simple and flexible way for different software systems to interact and exchange data over the internet.</p>
			<p>Let’s break down what the REST acronym means!</p>
			<p><strong class="bold">Representational</strong> refers to the idea that each resource in a RESTful API is represented by a unique identifier (such as a URL) and can be represented in a variety of formats, such as JSON or XML. The representation of a resource is a snapshot of its current state and can be used by a client to manipulate the resource.</p>
			<p>You can think of a resource as an object, such as a description of a user in a system. The user will typically have a unique ID that is used to refer to that user. In a REST system, the user <em class="italic">resource</em> with an ID = 123 could be <em class="italic">represented</em> by the following URL:</p>
			<p><code>https://www.a-system.com/api/v1/users/123</code></p>
			<p>The user can be retrieved, modified, or deleted by using this URL. The URL <em class="italic">represents</em> the user on any external system that is consuming the <strong class="bold">PAI</strong>.</p>
			<p>The <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>.</p>
			<p>If you were to issue a <code>GET</code> request to the preceding dummy URL, you would receive the <em class="italic">state</em> of the object represented by that URL.</p>
			<p><strong class="bold">Transfer</strong> refers <a id="_idIndexMarker259"/>to the transfer of the representation of a resource from a server to a client and vice versa. The transfer is typically performed over the HTTP protocol and is based on the principles of statelessness and uniform resource identification. In RESTful APIs, the transfer of state is used to create, read, update, and delete resources on the server.</p>
			<p>RESTful APIs do <a id="_idIndexMarker260"/>not have to communicate over HTTP, although they very often do. They could use any other possible communication protocol, such as <strong class="bold">remote procedure calls</strong> (<strong class="bold">RPCs</strong>). However, the large majority of RESTful APIs use HTTP as the chosen communication mechanism, and that is all that we will consider in this chapter. If you have a use case for an alternative communication protocol, then I hope the information in this chapter is useful in a more general sense!</p>
			<p>Before we get into the details of building restful APIs, there are a few general points to consider that will aid our understanding of some of the more complex concepts that will follow.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor120"/>Idempotency</h2>
			<p>In the<a id="_idIndexMarker261"/> context of a RESTful API, idempotency is a property of an API endpoint that allows multiple identical requests to have the same effect as a single request. This means that, regardless of the number of times the same request is made, the end result should be the same.</p>
			<p>An idempotent request will always produce the same response from a server, regardless of how many times it is executed. This property is useful to reduce the chance of errors and conflicts when making multiple requests to the same endpoint, especially when dealing with network connectivity issues or other types of failures.</p>
			<p>The most common HTTP methods considered idempotent are <code>GET</code>, <code>PUT</code>, <code>DELETE</code>, and certain types of <code>POST</code> requests. On the other hand, non-idempotent methods, such as <code>POST</code> without specifying the idempotent semantics, may have unintended side effects if repeated multiple times.</p>
			<p>This is to say that you can retrieve a resource at a URL as many times as you like, and the response will be the same every time. A <code>GET</code> request is idempotent.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor121"/>Safety</h2>
			<p>In the <a id="_idIndexMarker262"/>context of a RESTful API, a “safe” operation is one that is guaranteed not to modify the state of a server or have any side effects. Safe operations are read-only and do not alter any resources on the server.</p>
			<p>The most common example of a safe operation is a <code>GET</code> request, which retrieves data from the server without changing it. Other safe operations might include <code>OPTIONS</code>, <code>HEAD</code>, and some types of <code>POST</code> requests that are specifically designed to only retrieve data and not make any changes to the server state.</p>
			<p>Safe operations are contrasted with “unsafe” operations, such as <code>PUT</code>, <code>POST</code>, and <code>DELETE</code>, operations that modify the state of the server and may have side effects. These operations are considered unsafe because they can have unintended consequences if executed improperly, such as deleting important data or altering resources in unexpected ways.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/>HTTP status codes</h2>
			<p>HTTP status codes <a id="_idIndexMarker263"/>are three-digit numbers returned by a server in response to a client’s request. These codes indicate the outcome of the request and provide information about the status of the requested resource.</p>
			<p>There are many HTTP status codes – I will briefly reference only the set that I think is most applicable to building RESTful APIs. Don’t worry about memorizing all of these! As you will see, when we start to build up the examples, it is quite intuitive which ones should be used and when! And remember, information like this is only ever a Google search away!</p>
			<p>Each status code is a three-digit number. The first digit gives the category of the status code. There are five <a id="_idIndexMarker264"/>category codes, each with a specific meaning and purpose. These are as follows:</p>
			<ul>
				<li><code>100 Continue</code>.</li>
				<li><code>200 OK</code> and <code>201 Created</code>.</li>
				<li><code>301 Moved Permanently</code> and <code>302 Found</code>.</li>
				<li><code>400 Bad Request</code> and <code>401 Unauthorized</code>.</li>
				<li><code>500 Internal Server Error</code> and <code>503 </code><code>Service Unavailable</code>.</li>
			</ul>
			<p>There are <a id="_idIndexMarker270"/>many status codes within these categories. Some of <a id="_idIndexMarker271"/>the common and most applicable to RESTful APIs are given here:</p>
			<ul>
				<li><code>200 OK</code>: The request was successful, and the requested resource was returned. This status is commonly returned from a successful <code>GET</code>, <code>PUT</code>, or <code>PATCH</code> request.</li>
				<li><code>201 Created</code>: The request was successful, and a new resource was created as a result. This status code is often returned as the result of a successful <code>POST</code> request.</li>
				<li><code>204 No Content</code>: The request was successful, but no resource was returned. This status is commonly returned from a successful <code>DELETE</code> request.</li>
				<li><code>400 Bad Request</code>: The request was malformed or invalid. With a RESTful API, requests are often in JSON format. This would imply that the object is not correct per the expectations of the API.</li>
				<li><code>401 Unauthorized</code>: The request requires authentication, and the client did not provide valid credentials.</li>
				<li><code>403 Forbidden</code>: The client does not have access to the requested resource.</li>
				<li><code>404 Not Found</code>: The requested resource could not be found. The request is looking for a resource that is not there.</li>
				<li><code>405 Method Not Allowed</code>: The request method, such as <code>GET</code>, <code>POST</code>, and <code>DELETE</code>, is not allowed for the requested resource on the server.</li>
				<li><code>500 Internal Server Error</code>: An unspecified error occurred on the server. This<a id="_idIndexMarker272"/> status code is a “catch-all” error to let the user know that something has gone wrong on the server – for example, there could be an exception in the backend code.</li>
				<li><code>503 Service Unavailable</code>: The server is currently unable to handle the request due to maintenance or high traffic.</li>
			</ul>
			<p>There are<a id="_idIndexMarker273"/> many other HTTP status codes that can be used, each with a specific meaning and purpose. We will make use of these codes when we build out an example later in this chapter.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>Dealing with errors</h2>
			<p>When<a id="_idIndexMarker274"/> it comes to dealing with an error code on a RESTful API, it is important to have a clear and consistent approach in place. The HTTP status code is an essential part of this approach, and by using the status codes correctly, clients of the API are able to understand what has gone wrong and will have an idea as to why.</p>
			<p>In addition to using the status codes correctly, it also helps to provide clear and informative error messages. These messages should explain what has gone wrong in an easily understood way and, if possible, provide guidance on how to resolve the issue.</p>
			<p>The preceding will help users of the API, but it is also very important that the developers of the API are also informed when there has been an error so that they can take action to resolve or prevent recurrences. Because developers cannot watch over every API interaction, this is typically done with logging.</p>
			<p>Logging refers to the process of capturing and recording information about an API’s behavior and performance and persisting this information in a data store so that it can be searched later to identify issues and troubleshoot problems. Logging is an essential part of any API’s operational infrastructure, as it provides a record of what has happened <a id="_idIndexMarker275"/>on the system.</p>
			<p>This chapter will focus on API implementation, but we haven’t forgotten about logging and monitoring – we will cover both in detail in <a href="B19343_09.xhtml#_idTextAnchor219"><em class="italic">Chapter 9</em></a>!</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>JSON data formatting</h2>
			<p>While<a id="_idIndexMarker276"/> RESTful APIs do not have to use <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) formatting, it is an exceptionally popular choice and will be the <a id="_idIndexMarker277"/>formatting standard that is used throughout this book. JSON is a lightweight data exchange format that is easy for humans to read and write, and it is also easy for machines to parse and generate. It is completely language-independent, but it does make use of conventions that are familiar to the C family of languages (C, C++, C#, Java, and so on).</p>
			<p>Here is an example of some information represented as JSON:</p>
			<pre class="source-code">
{
    "name": "Roger Waters",
    "age": 79,
    "isBassist": true,
    "numbers": [90, 80, 85, 95],
    "address": {
        "street": "123 Main St",
        "city": "A Town",
    }
}</pre>
			<p>JSON data takes the form of key-value pairs, where each key is a string, and each value can be of type string, number, Boolean, null, array, or another JSON object. The ability to nest JSON objects allows for complex types to be represented in this straightforward way.</p>
			<p>The keys are always strings, so they are encased in double quotation marks. The values are encased in quotes if they are strings, square brackets if they are arrays, and curly brackets if <a id="_idIndexMarker278"/>they are objects. All of these are shown in the preceding snippet.</p>
			<p>We have established that JSON-encoded data will be sent and received over HTTP. Next, we will look at how that data is transmitted, looking at the most common HTTP verbs and describing how and when to use them.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor125"/>Matching API operations to HTTP verbs</h1>
			<p>In <a id="_idIndexMarker279"/>language, a verb is a “doing” word. It describes an action, state, or occurrence. In English, examples of verbs include “run,” “think,” “sing,” and “do,” as well as many thousands more!</p>
			<p>The HTTP verbs describe things that you can “do” over HTTP! Five main verbs are used – <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>. Each of these serves a different purpose, although the precise purpose of each is not tightly defined, and it is not uncommon to accidentally use the wrong one. In this section, we will cover the uses of the five commonly used HTTP verbs, and we will give an example of them being used in our demo application.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/>GET</h2>
			<p>The <code>GET</code> HTTP verb <a id="_idIndexMarker280"/>is used to <em class="italic">retrieve a resource from a server</em>. When <a id="_idIndexMarker281"/>a client sends a <code>GET</code> request to a server, the server responds by returning the requested resource to the client. The resource can be any type of data, such as a web page, image, or file. The <code>GET</code> verb is the most widely used HTTP verb and is considered to be a safe and idempotent method, which means that it can be called multiple times without any side effects. It is also cacheable, which means that the response can be stored in a cache and reused to improve performance. The <code>GET</code> verb should only be used to retrieve information and never to make changes on the server.</p>
			<p>When it comes to RESTful APIs, the <code>GET</code> verb is used to retrieve a representation of a resource or a collection of resources from a server. The resource can be identified by a <code>GET</code> request can also include query parameters, which can be used to filter the results or specify the format of the returned data. The server responds to a <code>GET</code> request with a representation of the resource in the form of an <a id="_idIndexMarker283"/>HTTP response, along with the appropriate HTTP status code. The most common status code for a <code>GET</code> request is <code>200 OK</code>, indicating that the request was successful and the resource was returned.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/>POST</h2>
			<p>The <code>POST</code> HTTP verb is <a id="_idIndexMarker284"/>used to <em class="italic">submit an entity to be processed by the resource identified by the URI</em>. A <code>POST</code> request is typically used to create a new<a id="_idIndexMarker285"/> resource or (sometimes) to update an existing one. The <code>POST</code> verb is not idempotent, which means that it can have different effects depending on how many times it is called. It is also not safe, meaning that it can modify the resource on the server.</p>
			<p>When a client sends a <code>POST</code> request to a RESTful API, typically, the server creates a new resource with the data provided in the request body and returns a response with a status code indicating the outcome of the request. The most common status code for a successful <code>POST</code> request is <code>201 Created</code>, indicating that a new resource has been successfully created. The URI of the newly created resource is typically included in the response headers so that the client application can retrieve and work with the newly created resource immediately. The data in a <code>POST</code> request can be in any format, such as JSON or XML, but it is usually in the JSON format.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor128"/>DELETE</h2>
			<p>The <code>DELETE</code> HTTP verb<a id="_idIndexMarker286"/> is used to <em class="italic">delete a resource from a server</em>. A <code>DELETE</code> request is <a id="_idIndexMarker287"/>used to remove the specified resource from the server. The <code>DELETE</code> verb is idempotent, which means that it can be called multiple times without any side effects. It is also not safe, meaning that it can modify the resource on the server.</p>
			<p>When a client sends a <code>DELETE</code> request to a RESTful API, the server deletes the specified resource and returns a response with a status code, indicating the outcome of the request. The most common status code for a successful <code>DELETE</code> request is <code>204 No Content</code>, indicating that the resource has been successfully deleted. The client usually doesn’t receive <a id="_idIndexMarker288"/>any content in the response body, only the status code. The <code>DELETE</code> request usually requires the URI of the resource to be specified in the request so that the server is able to identify which resource to delete.</p>
			<p>It’s worth<a id="_idIndexMarker289"/> noting that some RESTful APIs may not allow <code>DELETE</code> requests and will return a <code>405 Method Not Allowed</code> status code if a <code>DELETE</code> request is received.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>PUT</h2>
			<p>The <code>PUT</code> HTTP verb <a id="_idIndexMarker290"/>is used to <em class="italic">update an existing resource or create a new one if it does not exist</em>. A <code>PUT</code> request is used to submit a representation<a id="_idIndexMarker291"/> of the resource to be updated or created. The representation of the resource is included in the request body and typically encoded in a format such as JSON or XML. The <code>PUT</code> verb is idempotent, which means that it can be called multiple times without any side effects. It is also not safe, meaning that it can modify the resource on the server.</p>
			<p>When a client sends a <code>PUT</code> request to a RESTful API, the server updates the specified resource with the data provided in the request body and returns a response with a status code, indicating the outcome of the request. The most common status code for a successful <code>PUT</code> request is <code>200 OK</code>, indicating that the resource has been successfully updated. If a new resource is created, the <code>201 Created</code> status code will be returned. The URI of the updated resource is typically included in the response headers.</p>
			<p>It’s worth noting that <code>PUT</code> requests may require a client to send the full representation of the resource in the request body, including all properties, even if only a few of them are to be updated. This can make a <code>PUT</code> request inefficient in terms of bandwidth used, and it may be better to use the <code>PATCH</code> verb.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>PATCH</h2>
			<p>The <code>PATCH</code> HTTP verb is used to <em class="italic">partially update an existing resource on a server</em>. A <code>PATCH</code> request is<a id="_idIndexMarker292"/> used to submit a set of changes to be made to the specified<a id="_idIndexMarker293"/> resource rather than replacing the entire resource. The set of changes is typically encoded in a format such as JSON or XML and is included in the request body. The <code>PATCH</code> verb is idempotent, which means that it can be called multiple times without any side effects. It is also not safe, meaning that it can modify the resource on the server.</p>
			<p>In a <a id="_idIndexMarker294"/>RESTful API context, the <code>PATCH</code> verb is typically used to partially update an existing resource on the server. When a client sends a <code>PATCH</code> request to a RESTful API, the server applies the changes provided in the request body to the specified resource and returns a response with a status code indicating the outcome of the request. The most common status code for a successful <code>PATCH</code> request is <code>200 OK</code>, indicating that the resource <a id="_idIndexMarker295"/>has been successfully updated. The URI of the updated resource is typically included in the response headers. The data in a <code>PATCH</code> request can be in any format, such as JSON or XML.</p>
			<p>It’s worth noting that <code>PATCH</code> requests require a client to send a specific set of changes to be made to the resource rather than the full representation of the resource. This makes <code>PATCH</code> requests more lightweight and efficient than <code>PUT</code> requests for partial updates.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor131"/>Data transfer objects</h1>
			<p>Another important <a id="_idIndexMarker296"/>concept to understand when working with APIs is <strong class="bold">data transfer objects</strong> (<strong class="bold">DTOs</strong>). A DTO is a design pattern that is commonly used to transfer data between layers or systems. In the case of a RESTful API, this is typically to transfer data from the backend (API) to the frontend <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). The general purpose of DTOs is to decouple the structure of the data from the underlying systems that use it, allowing for more flexibility and easier maintenance. They also provide a standardized way to handle data, making it easier for different components of a system to communicate and exchange information.</p>
			<p>DTOs are particularly useful in RESTful APIs, as they provide a standard way to represent data when sending and receiving requests between a client and a server. When designing a RESTful API, the use of DTOs allows the API to define the structure of the data that is exchanged without having to tightly couple the implementation of the API to the structure of the data. This decoupling makes it easier to evolve the API and make changes to the underlying data model without affecting the API clients. Additionally, using DTOs enables the API to shape the data it returns to better match the needs of the client, reducing the amount of data transferred over the network and improving performance. Furthermore, DTOs can be used to validate the data being passed between the client and server, ensuring that only valid data is accepted and processed.</p>
			<p>The first set of DTOs that we will see in this chapter will look a lot like the entity types that we defined for our database in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a> and <a href="B19343_04.xhtml#_idTextAnchor102"><em class="italic">Chapter 4</em></a>, and they will relate to operations <a id="_idIndexMarker297"/>that we may wish to perform on the database. For example, the following entity type represents <code>Habit</code> in the database:</p>
			<pre class="source-code">
[Index(nameof(Id), nameof(UserId))]
public class GoodHabit : IHasTenant
{
    public int Id { get; set; }
    public string Name { get; set; } = default!;
    public int UserId { get; set; }
    public virtual User User { get; set; } = default!;
    public virtual ICollection&lt;Progress&gt; ProgressUpdates {
      get; set; } = default!;
    public virtual ICollection&lt;Reminder&gt; Reminders { get;
      set; } = default!;
    public virtual Goal Goal { get; set; } = default!;
    public Duration Duration { get; set; }
    public string TenantName { get; set; } = default!;
}</pre>
			<p>Let’s say that we wanted to create a simple <code>Habit</code> that only had a <code>Name</code> property populated and was tied to a certain <code>User</code>. We could send the following DTO:</p>
			<pre class="source-code">
    public class CreateHabitDto {
        public string Name { get; set; }
        public int UserId { get; set; }
    }</pre>
			<p>This could be used by the backend to create a simple <code>GoodHabit</code> object in the database.</p>
			<p>If we wanted to retrieve the <code>GoodHabit</code> objects but only with the name and ID properties, we could use a DTO that looked like this:</p>
			<pre class="source-code">
    public class GetGoodHabitDto {
        public int Id { get; set; }
        public string Name { get; set; }
    }</pre>
			<p>And, if we <a id="_idIndexMarker298"/>needed more information than simply a name and an ID, we could further define another DTO that looked like this:</p>
			<pre class="source-code">
    public class GetGoodHabitDetailDto {
        public int Id { get; set; }
        public string Name { get; set; }
        public string UserName { get; set; }
        public string GoalName { get; set; }
        public string Duration { get; set; }
    }</pre>
			<p>You can see how we can start with the entity type that has a lot of database-specific information, and we can selectively model that data in different ways for different use cases.</p>
			<p>We will illustrate this point with examples later in this chapter!</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor132"/>Designing better with REST</h1>
			<p>Good design <a id="_idIndexMarker299"/>with RESTful APIs is essential to create an API that is easy to use and understand. One of the key principles of REST is that it is based on the use of resources and their representations. Therefore, it’s essential to design the API’s resources and their representations in a way that is meaningful and consistent.</p>
			<p>When <a id="_idIndexMarker300"/>designing resources, it’s important to use URIs that are meaningful and consistent. Resources should be named in a way that is easy to understand, and the URIs should be structured logically and hierarchically – for example, <code>/users/1/orders/2</code> is more meaningful than <code>/users?id=1&amp;orderid=2</code>.</p>
			<p>Representations of resources should be in a format that is easy to parse, such as JSON or XML. It’s also important to use the <code>Content-Type</code> and <code>Accept</code> headers to specify the format of the request and response. This allows the client to specify its preferred format and the server to provide the appropriate representation.</p>
			<p>Another important aspect of a good RESTful API design is<a id="_idIndexMarker301"/> stateless communication. This means that a client and server should not maintain any state between requests. This can be achieved through the use of HTTP headers and cookies. This allows for a higher degree of scalability and flexibility, as the server does not have to maintain any state for each client.</p>
			<p>Security is also<a id="_idIndexMarker302"/> an important aspect of RESTful API design. It’s important to use secure communication protocols, such as HTTPS, and to implement authentication and authorization mechanisms to protect an API’s resources.</p>
			<p>In addition to the aforementioned points, good RESTful API design also includes error handling, caching, versioning, and documentation. Good documentation is essential for developers to understand how to use the API. It’s also important to provide clear and informative error messages to clients when an error occurs. In the previous chapter, we built up a database. In this chapter, we’ll now add an API to interact with the database that we built. We will use <a id="_idIndexMarker303"/>a very typical layer structure for a SaaS app that looks something like this:</p>
			<div><div><img src="img/B19343_05_01.jpg" alt="Figure 5.1 – The layering structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The layering structure</p>
			<p>In the preceding diagram, we can see the database and the <strong class="bold">object–relational mapping</strong> (<strong class="bold">ORM</strong>) that we covered in previous chapters. In this chapter, we are learning about the API, so we will build a service layer to interact with the database and a controller layer to handle communication with the UI or any other client.</p>
			<p>A <a id="_idIndexMarker304"/>service layer <a id="_idIndexMarker305"/>is an architectural pattern in software design that acts as an intermediary between the application’s UI and the underlying data storage. The main purpose of a service layer is to encapsulate and abstract the business logic of an application, promoting the separation of concerns and making it easier to maintain and modify the code. It also enables better unit testing, as the service layer can be tested in isolation from the rest of the application. Additionally, it can improve the scalability of an application by allowing the UI and data storage components to evolve independently.</p>
			<p>In a RESTful API, controllers <a id="_idIndexMarker306"/>are responsible for handling HTTP requests from clients and returning appropriate HTTP responses. They act as an intermediary between a client and an application’s business logic, using the appropriate service layer to perform any necessary operations.</p>
			<p>Controllers are responsible for mapping URLs to specific actions in an application, such as retrieving data from a database, creating new resources, or updating existing ones. They parse an incoming request to determine the desired action and then use the appropriate service layer to perform that action and generate a response.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>An example API design</h2>
			<p>You will <a id="_idIndexMarker307"/>recall that in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, we started to build out the <code>HabitService</code> API with a couple of endpoints. We’ll start from where <a id="_idIndexMarker308"/>we left off in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, but we will add a lot more functionality to the controller!</p>
			<p>The three endpoints that we have already added are the following:</p>
			<p>A <code>GET</code> endpoint that gets a single habit based on a passed-in ID:</p>
			<pre class="source-code">
public async Task&lt;IActionResult&gt; GetAsync(int id) =&gt; Ok(await _habitService.GetById(id));</pre>
			<p>Another <code>GET</code> endpoint that returns all of the habits:</p>
			<pre class="source-code">
public async Task&lt;IActionResult&gt; GetAsync() =&gt; Ok(await _habitService.GetAll());</pre>
			<p>And finally, a <code>POST</code> endpoint that will create a new habit in the database:</p>
			<pre class="source-code">
public async Task&lt;IActionResult&gt; CreateAsync(CreateHabitDto request) =&gt; Ok(await _habitService.Create(request.Name, request.Description));</pre>
			<p>In this<a id="_idIndexMarker309"/> section, we <a id="_idIndexMarker310"/>will add an endpoint for each of the five primary HTTP verbs that we have discussed in this chapter. We already have <code>GET</code> and <code>POST</code>, so we will add <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>.</p>
			<h3>DTOs</h3>
			<p>But, before we write <a id="_idIndexMarker311"/>the endpoints, we will first add the DTOs. We already have a <code>CreateHabitDto</code> that was added in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>. Run the following script from the root folder, or add the files manually:</p>
			<pre class="source-code">
<strong class="bold">cd GoodHabits.HabitService/Dtos; \</strong>
<strong class="bold">touch HabitDetailDto.cs; \</strong>
<strong class="bold">touch HabitDto.cs; \</strong>
<strong class="bold">touch UpdateHabitDto.cs; \</strong>
<strong class="bold">cd ..;</strong></pre>
			<p>Copy the following into the <code>HabitDetailDto</code> class:</p>
			<pre class="source-code">
namespace GoodHabits.HabitService.Dtos;
public class HabitDetailDto {
    public int Id { get; set; }
    public string Name { get; set; } = default!;
    public string UserName { get; set; } = default!;
    public string GoalName { get; set; } = default!;
    public string Duration { get; set; } = default!;
}</pre>
			<p>Then add the following to the <code>HabitDto</code> class:</p>
			<pre class="source-code">
namespace GoodHabits.HabitService.Dtos;
public class HabitDto
{
    public int Id { get; set; } = default!;
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
}</pre>
			<p>And finally, add<a id="_idIndexMarker312"/> the following to the <code>UpdateHabitDto</code> class:</p>
			<pre class="source-code">
namespace GoodHabits.HabitService.Dtos;
public class UpdateHabitDto
{
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
}</pre>
			<p>That is all that is required for the DTOs. We will use these when we start to build out the endpoints.</p>
			<h3>AutoMapper</h3>
			<p>We<a id="_idIndexMarker313"/> now <a id="_idIndexMarker314"/>need to consider a tool that we will use to convert between the database types and the DTOs. That tool is AutoMapper.</p>
			<p>AutoMapper is an open source library that enables you to establish a configuration to convert one object to another. This can be particularly useful when translating between different types of objects, such as database entities and DTOs. Even though both the DTO and the entities might have a similar structure, their implementation can differ. This library helps to keep your codebase clean and maintainable by reducing the amount of repetitive and boilerplate mapping code that is needed to translate between different types, making your application more efficient and easier to modify or add new features.</p>
			<p>AutoMapper is <a id="_idIndexMarker315"/>designed to <a id="_idIndexMarker316"/>make it easy to map one type of object to another, and it provides a simple, fluent API to define the mappings. Some of the key features of <a id="_idIndexMarker317"/>AutoMapper include:</p>
			<ul>
				<li>Support for flattening and unflattening of object hierarchies</li>
				<li>Support for converting between different data types and custom-type converters</li>
				<li>Support for advanced configuration options, such as mapping to and from interfaces and inheritance hierarchies</li>
				<li>Support for custom logic and conventions to be used during mapping</li>
				<li>Support for <strong class="bold">Language Integrated Query</strong> (<strong class="bold">LINQ</strong>) expressions to define mappings</li>
			</ul>
			<p>AutoMapper can help to keep your codebase clean and maintainable by reducing the amount of repetitive, boilerplate mapping code that is required to convert between different types. This can make your application more efficient, and it makes it easier to add new features or make changes to existing ones.</p>
			<p>To get started with AutoMapper, install the tool in the API project with the following command:</p>
			<pre class="source-code">
<strong class="bold">dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection</strong></pre>
			<p>With the packages updated, as shown in the preceding code snippet, we can start to create mappings for the database types that we have created.</p>
			<p>You will recall that we added an entity type called ‘Habit’ in the database project in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, and we have added a number of additional properties to the object in <a href="B19343_04.xhtml#_idTextAnchor102"><em class="italic">Chapter 4</em></a>. If you run the <code>HabitService</code> and use Thunder Client to hit the endpoint that returns all of the habits, you will see that the data which is returned includes all of these additional properties.</p>
			<p>This habit class represents a database entity. It is very specific to the database and works very well to represent the idea of a good habit for that specific use case. But, it does not work well to transmit data to the UI.</p>
			<p>We would rather that <a id="_idIndexMarker318"/>the data was sent to the UI in the form of a DTO, such as the one we created previously.</p>
			<ul>
				<li>There is no need to include the collections for the progress updates or the reminders. Including this information could add a huge amount to the required bandwidth of the app.</li>
				<li>The <code>TenentName</code> property is of no use to the user because they will already know which tenant they are!</li>
			</ul>
			<p>The DTO that we have created looks like this:</p>
			<pre class="source-code">
namespace GoodHabits.HabitService.Dtos;
public class HabitDto
{
    public int Id { get; set; } = default!;
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
}</pre>
			<p>In this example, we are taking the ID, name, and description of the habit directly from the entity type, but more complex transformations are also possible.</p>
			<p>While we could simply copy the properties over manually, that could quickly get very tedious, so we’ll use <code>AutoMapper</code> to do this automatically!</p>
			<p>Start by going into the <code>Program.cs</code> class and adding the <code>AutoMapper</code> service:</p>
			<pre class="source-code">
builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());</pre>
			<p>Next, open up the <code>HabitsController</code> class, and add the following to the <code>using</code> statements: using <code>AutoMapper</code>.</p>
			<p>Then, add the following to the class definition:</p>
			<pre class="source-code">
private readonly IMapper _mapper;</pre>
			<p>Next, add the <code>using</code> statement:</p>
			<pre class="source-code">
using AutoMapper;</pre>
			<p>Next, modify<a id="_idIndexMarker319"/> the constructor to take in the mapper, like so:</p>
			<pre class="source-code">
    public HabitsController(
        ILogger&lt;HabitsController&gt; logger,
        IHabitService goodHabitsService,
        IMapper mapper
        )
    {
        _logger = logger;
        _habitService = goodHabitsService;
        _mapper = mapper;
    }</pre>
			<p>Finally, modify the two existing <code>GET</code> endpoints in the controller to use <code>AutoMapper</code>, like this:</p>
			<pre class="source-code">
    [HttpGet("{id}")]
    public async Task&lt;IActionResult&gt; GetAsync(int id) =&gt;
      Ok(_mapper.Map&lt;HabitDto&gt;(await
      _habitService.GetById(id)));
    [HttpGet]
    public async Task&lt;IActionResult&gt; GetAsync() =&gt;
      Ok(_mapper.Map&lt;ICollection&lt;HabitDto&gt;&gt;(await
      _habitService.GetAll()));</pre>
			<p>Before, the controller was simply returning the entity object from the database, now that object is being mapped automatically to a DTO, which is returned from the controller. This does require a little configuration, though.</p>
			<p>The final<a id="_idIndexMarker320"/> step is to tell <code>AutoMapper</code> how it should convert between the two types.</p>
			<p>Add a folder called <code>Mappers</code> in the <code>HabitService</code> project and a class called <code>HabitMapper.cs</code>. You can use this script:</p>
			<pre class="source-code">
mkdir Mappers; \
cd Mappers; \
touch HabitMapper.cs; \
cd ..;</pre>
			<p>In this class, add the following:</p>
			<pre class="source-code">
using AutoMapper;
using GoodHabits.HabitService.Dtos;
using GoodHabits.Database.Entities;
namespace GoodHabits.HabitService.Mappers;
public class HabitMapper : Profile
{
    public HabitMapper()
    {
        CreateMap&lt;Habit, HabitDto&gt;();
    }
}</pre>
			<p>The <code>CreateMap</code> method instructs <code>AutoMapper</code> to map between the two types.</p>
			<p>You can now hit the<a id="_idIndexMarker321"/> endpoint using Thunder Client to get the habits, and you should see something like this:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19343_05_02.jpg" alt="Figure 5.2 – A successful response"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – A successful response</p>
			<p>This section has demonstrated how we can automatically convert between database types and types for data transfer. This is a very important piece of the API puzzle, and understanding how to operate AutoMapper will help you write better code and also reduce the amount of data sent between the API and any connected clients.</p>
			<h3>Modify the service</h3>
			<p>Before <a id="_idIndexMarker322"/>we can build the additional endpoints on the API to update and delete the habits, we need to add some functionality to the service class. We already created the service class and interface in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, but we will extend the functionality here.</p>
			<p>Add the following to the interface:</p>
			<pre class="source-code">
using GoodHabits.Database.Entities;
using GoodHabits.HabitService.Dtos;
namespace GoodHabits.HabitService;
public interface IHabitService
{
Task&lt;Habit&gt; Create(string name, string description);
Task&lt;Habit&gt; GetById(int id);
Task&lt;IReadOnlyList&lt;Habit&gt;&gt; GetAll();
Task DeleteById(int id);
Task&lt;Habit?&gt; UpdateById(int id, UpdateHabitDto request);
}</pre>
			<p>The <code>HabitService</code> class that implements the preceding interface will need to have two methods <a id="_idIndexMarker323"/>added to delete and update the habits that are stored in the database. Add the following two methods to the <code>HabitService</code> class:</p>
			<pre class="source-code">
    public async Task DeleteById(int id)
    {
        var habit = await _dbContext.Habits!.FindAsync(id)
          ?? throw new ArgumentException("User not found");
        _dbContext.Habits.Remove(habit);
        await _dbContext.SaveChangesAsync();
    }
    public async Task&lt;Habit?&gt; UpdateById(int id,
      UpdateHabitDto request)
    {
        var habit = await _dbContext.Habits!.FindAsync(id);
        if (habit == null) return null;
        habit.Name = request.Name;
        habit.Description = request.Description;
        await _dbContext.SaveChangesAsync();
        return habit;
    }</pre>
			<p>You will <a id="_idIndexMarker324"/>also need to add a <code>using</code> statement to the service class:</p>
			<pre class="source-code">
using GoodHabits.HabitService.Dtos;</pre>
			<p>That is all that is required in the service layer.</p>
			<p>That has been quite a lot of configuration, but we are now ready to build the controller class.</p>
			<h3>Add to the controller</h3>
			<p>We have<a id="_idIndexMarker325"/> done most of the heavy lifting already by adding the DTOs, configuring AutoMapper, and building the service layer. We will need to add three additional endpoints to the controller. Let’s start with the <code>DELETE</code> endpoint:</p>
			<pre class="source-code">
    [HttpDelete("{id}")]
    public async Task&lt;IActionResult&gt; DeleteAsync(int id)
    {
        await _habitService.DeleteById(id);
        return NoContent();
    }</pre>
			<p>This is pretty straightforward. It uses the service method to delete the entry in the database and then returns <code>NoContent</code> – which is considered best practice for a delete method.</p>
			<p>Next, add the endpoint to update the object with the <code>PUT</code> verb:</p>
			<pre class="source-code">
    [HttpPut("{id}")]
    public async Task&lt;IActionResult&gt; UpdateAsync(int id,
      UpdateHabitDto request)
    {
        var habit = await _habitService.UpdateById(id,
          request);
        if (habit == null)
        {
            return NotFound();
        }
        return Ok(habit);
    }</pre>
			<p>There is <a id="_idIndexMarker326"/>some error trapping here, which returns <code>404</code> if the client attempts to update an entry that does not exist.</p>
			<p>Finally, add the endpoint that updates an object using the <code>PATCH</code> verb:</p>
			<pre class="source-code">
    [HttpPatch("{id}")]
    public async Task&lt;IActionResult&gt; UpdateAsync(int id,
      [FromBody] JsonPatchDocument&lt;UpdateHabitDto&gt; patch)
    {
        var habit = await _goodHabitsService.GetById(id);
        if (habit == null) return NotFound();
        var updateHabitDto = new UpdateHabitDto { Name =
          habit.Name, Description = habit.Description };
        try
        {
            patch.ApplyTo(updateHabitDto, ModelState);
            if (!TryValidateModel(updateHabitDto)) return
              ValidationProblem(ModelState);
            await _goodHabitsService.UpdateById(id,
              updateHabitDto);
            return NoContent();
        }
        catch (JsonPatchException ex)
        {
            return BadRequest(new { error = ex.Message });
        }
    }</pre>
			<p>This is a<a id="_idIndexMarker327"/> little more involved, as it uses <code>JsonPatchDocument</code> to modify the object. You will also need to add two <code>using</code> statements:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.JsonPatch;
using Microsoft.AspNetCore.JsonPatch.Exceptions;</pre>
			<p>That is all that we need to do at this stage. We now have a good example of the five most common HTTP verbs. Before we move on, we should test that these all work. We will use Thunder Client for this.</p>
			<h3>Testing</h3>
			<p>To test the<a id="_idIndexMarker328"/> endpoint that we have just added, we will need a test client. In keeping with the theme of using <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), we <a id="_idIndexMarker329"/>will add an extension to the code so that we can do everything in one place. We have touched on this tool a couple of times already, but we will take a close look in this section.</p>
			<p>You’ll see the Thunder Client icon on the extensions toolbar:</p>
			<div><div><img src="img/B19343_05_03.jpg" alt="Figure 5.3 – The Thunder Client icon"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The Thunder Client icon</p>
			<p>With <a id="_idIndexMarker330"/>Thunder Client, you can hit your API straight from VS Code and check that it is behaving as expected. We’ll do this now. Start the API running by going to the terminal in VS Code, navigating to the API project, and typing the following:</p>
			<pre class="source-code">
dotnet run</pre>
			<p>This will build the project and get the API running. Now we can start adding the tests!</p>
			<h4>Add a GET request</h4>
			<p>Now, complete <a id="_idIndexMarker331"/>the following steps:</p>
			<ol>
				<li>Click on the Thunder Client icon (<em class="italic">if you don’t see this on the left-hand menu, exit and restart the </em><em class="italic">Docker environment</em>).</li>
				<li>Click on the <code>GoodHabits</code>.</li>
				<li><em class="italic">Right-click</em> on the newly created collection, click <code>GET </code>Habits (don’t click on the bit below the <strong class="bold">New Request</strong> button; right-click the collection).</li>
			</ol>
			<p>Your collection should look like this:</p>
			<div><div><img src="img/B19343_05_04.jpg" alt="Figure 5.4 – The Thunder Client collection"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The Thunder Client collection</p>
			<ol>
				<li value="4">Click <a id="_idIndexMarker332"/>on the <code>tenant</code> key with the <code>CloudSphere</code> value (you’ll remember from <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a> that we need to specify the tenant for the multi-tenancy).</li></ol></li>
			</ol>
			<p>When you’re <a id="_idIndexMarker333"/>done, it should look like this:</p>
			<div><div><img src="img/B19343_05_05.jpg" alt="Figure 5.5 – The configured request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The configured request</p>
			<p>The preceding screenshot shows a correctly configured <code>GET</code> request that should return all of the habits in the database.</p>
			<p>Finally, click<a id="_idIndexMarker334"/> the <code>GET</code> request and test the endpoint. You will see the following:</p>
			<div><div><img src="img/B19343_05_06.jpg" alt="Figure 5.6 – The returned habits"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – The returned habits</p>
			<p>We have put in quite a lot of work to get to this stage! We are showing the data from the <code>SeedData</code> file in the database project, returned from our <code>HabitsService</code>. We will shortly build a UI to present this information.</p>
			<h4>Add a POST request</h4>
			<p>Repeat the <a id="_idIndexMarker335"/>preceding, building a <code>POST</code><strong class="bold"> </strong>user request. In this case, we’ll need to specify the habit details in the body in JSON format:</p>
			<div><div><img src="img/B19343_05_07.jpg" alt="Figure 5.7 – The configured POST request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The configured POST request</p>
			<p>You can see that the JSON specified matches the <code>CreateHabitDto</code> class.</p>
			<p>Don’t forget to set the tenant in the header and change the request type to <code>POST</code>! Hitting <strong class="bold">Send</strong> will confirm that the habit has been created.</p>
			<p>So far, we have tested the <code>get all</code> endpoint and the <code>POST</code> endpoint. It would be a useful exercise to add another <code>GET</code> to test the <code>get-by-id</code> endpoint as well!</p>
			<h4>Add a DELETE request</h4>
			<p>We may <a id="_idIndexMarker336"/>want to delete a habit from the database, so we have added the required methods to the service and the controller. We can test this again in the same way:</p>
			<div><div><img src="img/B19343_05_08.jpg" alt="Figure 5.8 – The configured DELETE request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The configured DELETE request</p>
			<p>The <a id="_idIndexMarker337"/>preceding screenshot shows that no content is required in the body. But don’t forget to add the tenant header!</p>
			<h4>Add a PUT request</h4>
			<p>Testing<a id="_idIndexMarker338"/> the <code>PUT</code> endpoint that we have added is fairly straightforward. Configure a <code>PUT</code> request like this:</p>
			<div><div><img src="img/B19343_05_09.jpg" alt="Figure 5.9 – The configured PUT request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – The configured PUT request</p>
			<p>The preceding figure shows how to configure a <code>PUT</code> request. This will alter the name and description of the habit with <code>id=103</code>. You may need to change the ID in the URL if you have made changes to the data along the way. You can check that this has made the changes by<a id="_idIndexMarker339"/> hitting the <code>get-by-id</code> endpoint again.</p>
			<h4>Add a PATCH request</h4>
			<p>Testing<a id="_idIndexMarker340"/> the <code>PATCH</code> endpoint is a little more tricky. You will recall that the <code>PATCH</code> endpoint that we built in the controller is expecting a <code>JsonPatchDocument</code> object, so this is what we will have to supply. A <code>Patch</code> document could look like this:</p>
			<pre class="source-code">
[
    {
        "op": "replace",
        "path": "/Name",
        "value": "A New Name"
    }
]</pre>
			<p>The preceding code uses the <code>replace</code> operator to change the value of the <code>Name</code> variable. We can set up the request like this:</p>
			<div><div><img src="img/B19343_05_10.jpg" alt="Figure 5.10 – The configured PATCH request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – The configured PATCH request</p>
			<p>Configuring this and hitting send will update the habit with <code>id=103</code>. Again, you may need to change the ID in the URL.</p>
			<p>You will <a id="_idIndexMarker341"/>notice that the service will return a <code>204 No Content</code> response upon a successful patch. This is the expected behavior and is considered best practice for the response to a successful <code>PATCH</code>.</p>
			<p>This would be a good time to talk a bit more about HTTP codes!</p>
			<h3>Using the correct HTTP codes</h3>
			<p>Earlier in this chapter, we <a id="_idIndexMarker342"/>talked about HTTP status codes, and we looked at a few that may be useful to consider, even for the very basic examples we saw previously.</p>
			<p>The two that we should add and test are as follows:</p>
			<ul>
				<li>If a request is made to get a user that does not exist, the correct status code should be <code>404 </code><code>Not found</code></li>
				<li>If a successful request is made to create a new user, the correct status code should be <code>201 Created</code></li>
			</ul>
			<p>Because we have separated the service and the controller, we do not have to change any of the service logic to facilitate this. The controller has the sole responsibility for assigning the HTTP status codes. While the example here is fairly straightforward, I hope you can see how separating the logic in this way can be very beneficial when things start to get more complex.</p>
			<p>We’ll start by modifying the <code>GET</code> method, which takes an <code>id</code> parameter to look like this:</p>
			<pre class="source-code">
    [HttpGet("{id}")]
    public async Task&lt;IActionResult&gt; GetAsync(int id)
    {
        var habit = await _habitService.GetById(id);
        if (habit == null) return NotFound();
        return Ok(_mapper.Map&lt;HabitDto&gt;(await
          _habitService.GetById(id)));
    }</pre>
			<p>We <a id="_idIndexMarker343"/>have simply added a check to see whether the user object is <code>null</code>, and if so, we return <code>NotFound()</code>, which will return the <code>404</code> status code.</p>
			<p>You can test this in Thunder Client by requesting a user ID that you know doesn’t exist in your database:</p>
			<p class="IMG---Figure">    </p>
			<div><div><img src="img/B19343_05_11.jpg" alt="Figure 5.11 – Habit not found"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Habit not found</p>
			<p>In the preceding screenshot, we have demonstrated that requesting a non-existent user now results in a <code>404</code> HTTP status code.</p>
			<p>Next, let’s fix the HTTP code to create a new user. Modify the <code>Create</code> endpoint to look like the following:</p>
			<pre class="source-code">
    [HttpPost]
    public async Task&lt;IActionResult&gt;
      CreateAsync(CreateHabitDto request)
    {
        var habit = await _habitService
          .Create(request.Name, request.Description);
        var habitDto = _mapper.Map&lt;HabitDto&gt;(habit);
       return CreatedAtAction("Get", "Habits", new { id =
         habitDto.Id }, habitDto);
    }</pre>
			<p>We have <a id="_idIndexMarker344"/>changed the return from <code>Ok()</code> to <code>CreatedAtAction(…)</code>. This will return <code>201 – Created</code> and also the location of the newly created resource to the user.</p>
			<p>If you go back into Thunder Client and create another user, you will see the following:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19343_05_12.jpg" alt="Figure 5.12 – Created with a 201 status code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Created with a 201 status code</p>
			<p>Clicking on the <strong class="bold">Headers</strong> tab will give you the location of the newly created resource. This can be very useful to consumers of your API who may want to interact with the new resource immediately.</p>
			<p>If you look at the <code>PUT</code> and the <code>PATCH</code> endpoints in <code>HabitsController</code>, you can see that we are returning a few different status codes depending on what has happened when processing the response. It would be a good exercise to go through these and convince yourself that you have understood why each of them has been selected.</p>
			<p>If you look at the <code>PATCH</code> endpoint, you will see that it<a id="_idIndexMarker345"/> performs the following actions:</p>
			<ul>
				<li>It checks to see whether the ID provided is valid and, if not, returns <code>404 – </code><code>Not Found</code></li>
				<li>It checks to see whether the updated model is valid and, if not, returns a validation problem (a subset of <code>400 </code><code>Bad Request</code>)</li>
				<li>If there are any other issues with the update, it returns <code>400 </code><code>Bad Request</code></li>
				<li>If there are no issues, it returns <code>204 </code><code>No Content</code></li>
			</ul>
			<p>The <code>No Content</code> HTTP status code (<code>204</code>) is used to indicate that the server has successfully processed the request and that there is no response body to return. In the case of a <code>PATCH</code> request, the <code>No Content</code> status code is used to indicate that the server has successfully processed the update to the resource without returning any content in the <a id="_idIndexMarker346"/>response. The idea is that the client already knows what the updated resource looks like, and therefore, there is no need to return the updated resource information in the response. The client can simply assume that the update was successful and that the resource was updated as requested.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor134"/>Versioning public APIs</h1>
			<p>Versioning <a id="_idIndexMarker347"/>public RESTful APIs is the process of creating and maintaining multiple versions of an API to accommodate changes and new features. This ensures that existing clients are not affected by changes made to the API and that new clients can take advantage of the new features.</p>
			<p>Versioning is a <a id="_idIndexMarker348"/>critical aspect of API development and maintenance because it enables the evolution of an API over time while maintaining compatibility with existing clients. This is particularly important in cases where APIs are used by multiple clients, and breaking changes would impact the functionality of those clients. With versioning, multiple versions of an API can coexist, and clients can choose to upgrade to the latest version or continue using an earlier version that suits their needs. This way, versioning provides the necessary flexibility for APIs to evolve and improve over time without disrupting the stability of existing integrations.</p>
			<p>There are several strategies to version RESTful APIs, each with its own advantages and disadvantages:</p>
			<ul>
				<li><code>/v1/users</code> or <code>/v2/users</code>. This approach is easy to implement and understand, but it can be difficult to maintain and scale as the number of versions increases.</li>
				<li><code>X-API-Version</code>. This approach allows for more flexibility, as the URI does not have to change, but it can be more complex to implement and may not be supported by all clients.</li>
				<li><code>application/vnd.example.v1+json</code> or <code>application/vnd.example.v2+json</code>. This approach allows for more flexibility, as the URI and headers do not have to change, but it can be more complex to implement and may not be supported by all clients.</li>
				<li><strong class="bold">Deprecation and sunsetting</strong>: This <a id="_idIndexMarker355"/>strategy involves marking old versions of the API as deprecated and eventually sunsetting them. This approach allows for a gradual transition and gives clients time to update their code before the old version is removed.</li>
			</ul>
			<p>It is worth <a id="_idIndexMarker356"/>noting that the most appropriate versioning strategy will depend on the specific needs of an API and its clients. It’s important to communicate the versioning strategy and the timeline for the deprecation of old versions to the API’s clients in order to minimize disruption and allow them to plan accordingly.</p>
			<p>The most common way to version an API is to include the version number in the URL of the API endpoint. For example, the URL of an API endpoint might look like this:</p>
			<pre class="source-code">
https://api.example.com/v1/resources</pre>
			<p>This method allows different versions of an API to coexist and makes it easy to manage changes to the API over time by simply changing the version number in the URL. This also allows clients to choose which version of the API they want to use in their applications, and it helps prevent breaking changes in the API from affecting existing client applications.</p>
			<p>If a second version of the preceding example was created, it could be found at the following link:</p>
			<pre class="source-code">
https://api.example.com/v2/resources</pre>
			<p>A huge benefit <a id="_idIndexMarker357"/>of this is that both versions can exist at the same time and users who have clients that still expect the <code>v1</code> version can continue to work seamlessly. Of course, supporting multiple versions can be hard, and ideally, this would be a transient state with the intention to deprecate the <code>v1</code> version at some point.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/>Example code showing how to version an API</h2>
			<p>Previously<a id="_idIndexMarker358"/> in this chapter, we built a controller to manage the users and added a number of endpoints to it. We have not yet added any versioning to the API, though; note that the URLs that we have tested with (using Thunder Client) do not have a version associated with them, such as the following:</p>
			<pre class="source-code">
http://localhost:5100/api/habits</pre>
			<p>Let’s change that!</p>
			<p>Start by opening a console and adding the versioning package to the <code>HabitService</code> project:</p>
			<pre class="source-code">
<strong class="bold">dotnet add package Microsoft.AspNetCore.Mvc.Versioning</strong></pre>
			<p>Add the <code>using</code> statement into <code>Program.cs</code>:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc.Versioning;</pre>
			<p>Next, copy the following into <code>Program.cs</code>:</p>
			<pre class="source-code">
builder.Services.AddApiVersioning(opt =&gt;
    {
        opt.DefaultApiVersion = new
          Microsoft.AspNetCore.Mvc.ApiVersion(1,0);
        opt.AssumeDefaultVersionWhenUnspecified = true;
        opt.ReportApiVersions = true;
        opt.ApiVersionReader = ApiVersionReader.Combine(new
          UrlSegmentApiVersionReader(),
          new HeaderApiVersionReader("x-api-version"),
          new MediaTypeApiVersionReader("x-api-version"));
    });</pre>
			<p>Let’s review the <a id="_idIndexMarker359"/>preceding code in detail:</p>
			<ul>
				<li>The first flag sets the default API version. This allows a client to work with the API without specifying a version.</li>
				<li>The second flag instructs the application to use the default if nothing is specified. This is an example of defensive programming – your users will thank you for this!</li>
				<li>The third flag is returns options – this returns the available versions in the response header so that a calling client can see that there are options available for that method.</li>
				<li>Finally, <code>ApiVersionReader</code> makes it possible for clients to choose whether to put the version in the URL or the request header. Again, it’s good to give consumers of the API the choice in this.</li>
			</ul>
			<p>Now, we need to update <code>HabitsController</code> to work with multiple versions.</p>
			<p>To illustrate this point, we’ll just use a simple <code>GET</code> endpoint. But you can apply the same logic to any of the endpoints.</p>
			<p>Change the attributes of the <code>HabitsController</code> class to the following:</p>
			<pre class="source-code">
[ApiController]
[Route("api/[controller]")]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("1.0")]</pre>
			<p>Let’s prove what we have done by adding an endpoint to the controller and mapping it to <code>version 1.0</code>, like this:</p>
			<pre class="source-code">
    [MapToApiVersion("1.0")]
    [HttpGet("version")]
    public virtual async Task&lt;IActionResult&gt; GetVersion()
    {
        return Ok("Response from version 1.0");
    }</pre>
			<p>We have<a id="_idIndexMarker360"/> flagged this method as virtual so that we can override it in a subsequent version.</p>
			<p>Create a file called <code>HabitsControllerv2.cs</code> and add the following to it:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc;
namespace GoodHabits.HabitService.Controllers.v2;
[ApiController]
[Route("api/[controller]")]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("2.0")]
public class HabitsController : ControllerBase
{
    [MapToApiVersion("2.0")]
    [HttpGet("version")]
    public virtual IActionResult GetVersion()
    {
        return Ok("Response from version 2.0");
    }
}</pre>
			<p>Note that this maps the <code>version</code> endpoint to the <code>v2</code> API. You can test this in Thunder Client in the usual way, and you will see that changing the version you provide in the URL changes which response you get.</p>
			<p>Also, note that we have specified the <code>Route</code> attribute twice – once with the version included and <a id="_idIndexMarker361"/>once without. This allows the default versioning that we specified in <code>Program.cs</code> to take effect.</p>
			<p>In Thunder Client, run three tests – one test without a version, one with <code>v1</code>, and one with <code>v2</code>:</p>
			<ul>
				<li>No version: http://localhost:5100/api/Habits/version</li>
				<li>Version 1: <code>http://localhost:5100/api/v1/Habits/version</code></li>
				<li>Version 2: <code>http://localhost:5100/api/v2/Habits/version</code></li>
			</ul>
			<p>You will see that the first one returns <code>v1</code>, as that is the default, and you will see that the other two perform as you would expect.</p>
			<p>You should also note that the requests that we previously set up in Thunder Client continue to operate as expected. This is great from the point of view of a consumer of the API. We have just introduced versioning and added <code>v2</code> without breaking any existing functionality!</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/>Testing APIs</h1>
			<p>In this <a id="_idIndexMarker362"/>chapter, we have demonstrated quite extensively how to test your API using Thunder Client. Testing APIs (and testing in general) is a huge subject that could be the subject of a book on its own. If you are interested, I have provided some pointers for further reading in the following section!</p>
			<p>The following list provides some examples of the type of testing that you may want to carry out to ensure that your API is functioning correctly. Unit testing involves testing individual components of an API to ensure that they are working as expected. This is typically done using a unit testing framework, such as NUnit, and can be automated:</p>
			<ul>
				<li>Functional testing involves testing an API end to end to ensure that all the components are working together correctly. This can be done manually or by using an automated testing tool, such as Selenium or TestComplete.</li>
				<li>Integration testing involves testing an API in conjunction with other systems, such as a database or other API. This can be done using an integration testing framework, such as Cucumber or FitNesse.</li>
				<li>Performance testing involves testing an API to ensure that it can handle the expected load and is performing optimally.</li>
				<li>Security testing involves testing an API to ensure that it is secure and not vulnerable to common security threats, such as SQL injection or cross-site scripting. This can be done using a security testing tool, such as Nessus or OWASP ZAP.</li>
				<li>Usability testing involves testing an API to ensure that it is easy to use and understand. This can be done manually or by using a usability testing tool, such as UserTesting or Crazy Egg.</li>
				<li>Postman is a popular tool for testing RESTful APIs. It allows developers to easily create, send, and analyze HTTP requests. It has a user-friendly interface and supports various features, such as request and response validation, environment variables, and automated testing. It also allows us to test end-to-end scenarios, and it can be integrated with other tools such as Jenkins.</li>
			</ul>
			<p>It’s worth <a id="_idIndexMarker363"/>noting that testing RESTful APIs is an ongoing process that should be done throughout the development process, not just at the end. This will help to ensure that an API works as expected and any issues are identified and resolved quickly.</p>
			<p>In this chapter, we have demonstrated testing an API using Thunder Client inside VS Code. This is a very useful tool, with the benefit that the tests that are defined are saved in the repo and are checked against the code.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor137"/>Summary</h1>
			<p>We have covered a <em class="italic">lot</em> in this chapter! I hope it has not been overwhelming! We started at the start with a definition of REST. Then, we covered HTTP status codes and HTTP verbs to give some background on some of the underlying fundamentals of REST APIs.</p>
			<p>We then looked at an example, covered the five most important HTTP verbs (<code>GET</code>, <code>POST</code>, <code>DELETE</code>, <code>PUT</code>, and <code>PATCH</code>), and showed how we could build them and test them with Thunder Client right within VS Code!</p>
			<p>We also looked at <code>AutoMapper</code> and how to simplify object conversions to create DTOs from entity types.</p>
			<p>Finally, we worked through an example of how to version an API and looked at some additional testing techniques.</p>
			<p>In the next chapter, we will consider microservices, and we’ll look at how we can break up this application into a number of smaller microservices!</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/>Further reading</h1>
			<ul>
				<li>HTTP response status codes: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></li>
				<li>Using HTTP Methods for RESTful Services: <a href="https://www.restapitutorial.com/lessons/httpmethods.html">https://www.restapitutorial.com/lessons/httpmethods.html</a></li>
				<li>HATEOAS and Why It’s Needed in RESTful API? <a href="https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/">https://www.geeksforgeeks.org/hateoas-and-why-its-needed-in-restful-api/</a></li>
				<li>Testing an API: <a href="https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/">https://learning.postman.com/docs/designing-and-developing-your-api/testing-an-api/</a></li>
				<li>How to use API versioning in ASP.NET Core Web API and integrate it with Swagger using .NET 6: <a href="https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/">https://blog.christian-schou.dk/how-to-use-api-versioning-in-net-core-web-api/</a></li>
			</ul>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor139"/>Questions</h1>
			<ol>
				<li>What are the advantages of using <code>PATCH</code> over <code>PUT</code>?</li>
				<li>What is the benefit of using AutoMapper?</li>
				<li>What HTTP code should be used when a new resource has been created?</li>
				<li>What does the <code>500</code> range of HTTP codes signify?</li>
				<li>What does REST stand for?</li>
				<li>What is the purpose of DTOs?</li>
			</ol>
		</div>
	</body></html>