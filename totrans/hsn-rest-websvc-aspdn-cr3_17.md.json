["```cs\nnamespace Microsoft.Extensions.Hosting\n{\n    public abstract class BackgroundService : IHostedService, IDisposable\n    {\n        public virtual Task StartAsync(CancellationToken \n            cancellationToken);\n\n        protected abstract Task ExecuteAsync(CancellationToken \n            stoppingToken);\n\n        public virtual async Task StopAsync(CancellationToken \n            cancellationToken);\n    }\n}\n```", "```cs\ndotnet new worker -n HealthCheckWorker\n```", "```cs\n.\n├── Program.cs\n├── Properties\n│   └── launchSettings.json\n├── Worker.cs\n├── HealthCheckWorker.csproj\n├── appsettings.Development.json\n├── appsettings.json\n├── bin\n│   └── Debug\n│       └── netcoreapp3.0\n└── obj\n  ├── Debug\n      └── netcoreapp3.0\n```", "```cs\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace HealthCheckWorker\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureServices((hostContext, services) =>\n                {\n                    services.AddHostedService<Worker>();\n                });\n    }\n}\n```", "```cs\nnamespace HealthCheckWorker\n{\n    public class HealthCheckSettings\n    {\n        public string Url { get; set; }\n        public int IntervalMs { get; set; }\n    }\n}\n```", "```cs\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace HealthCheckWorker\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureServices((hostContext, services) =>\n {\n var healthCheckSettings = hostContext\n .Configuration\n                        .GetSection(\"HealthCheckSettings\") services.Configure<HealthCheckSettings>\n                        (healthCheckSettings);\n services.AddHostedService<Worker>();\n });\n    }\n}\n```", "```cs\npublic class Worker : BackgroundService\n    {\n        private readonly ILogger<Worker> _logger;\n        private readonly HealthCheckSettings _settings;\n        private HttpClient _client;\n\n        public Worker(ILogger<Worker> logger, \n IOptions<HealthCheckSettings> options)\n        {\n            _logger = logger;\n            _settings = options.Value;\n        }\n...\n```", "```cs\npublic class Worker : BackgroundService\n{\n    ...\n\n public override Task StartAsync(CancellationToken cancellationToken)\n {\n _client = new HttpClient();\n return base.StartAsync(cancellationToken);\n }\n\n protected override async Task ExecuteAsync(CancellationToken \n    stoppingToken)\n {\n while (!stoppingToken.IsCancellationRequested)\n {\n var result = await _client.GetAsync(_settings.Url);\n\n if (result.IsSuccessStatusCode)\n _logger.LogInformation($\"The web service is up. \n                HTTP {result.StatusCode}\");\n await Task.Delay(_settings.IntervalMs, stoppingToken);\n }\n }\n\n    ...\n}\n```", "```cs\npublic class Worker : BackgroundService\n{\n    ...\n\n public override Task StopAsync(CancellationToken cancellationToken)\n {\n _client.Dispose();\n return base.StopAsync(cancellationToken);\n }\n\n}\n```", "```cs\nFROM mcr.microsoft.com/dotnet/core/runtime:3.0 AS base\nWORKDIR /app\n\n# Step 1 - Building the project\nFROM mcr.microsoft.com/dotnet/core/sdk:3.0 AS build\nWORKDIR /src\nCOPY [\"HealthCheckWorker.csproj\", \"./\"]\nRUN dotnet restore \"./HealthCheckWorker.csproj\"\nCOPY . .\nWORKDIR \"/src/.\"\nRUN dotnet build \"HealthCheckWorker.csproj\" -c Release -o /app/build\n\n# Step 2 - Publish the project\nFROM build AS publish\nRUN dotnet publish \"HealthCheckWorker.csproj\" -c Release -o /app/publish\n\n# Step 3 - Run the project\nFROM base AS final\nWORKDIR /app\nCOPY --from=publish /app/publish .\nENTRYPOINT [\"dotnet\", \"HealthCheckWorker.dll\"]\n```", "```cs\ndocker build --rm -f \"Dockerfile\" -t healthcheckworker:latest \n```", "```cs\ndocker run --rm -d healthcheckworker:latest\n```", "```cs\ndotnet add ./src/Cart.Domain package RabbitMQ.Client\n```", "```cs\nusing MediatR;\n\nnamespace Cart.Domain.Events\n{\n    public class ItemSoldOutEvent : IRequest<Unit>\n    {\n        public string Id { get; set; }\n    }\n}\n```", "```cs\nnamespace Cart.Infrastructure.Configurations\n{\n    public class EventBusSettings\n    {\n        public string HostName { get; set; }\n        public string User { get; set; }\n        public string Password { get; set; }\n        public string EventQueue { get; set; }\n    }\n}\n```", "```cs\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Cart.Domain.Entities;\nusing Cart.Domain.Events;\nusing Cart.Domain.Repositories;\nusing MediatR;\n\nnamespace Cart.Domain.Handlers.Cart\n{\n    public class ItemSoldOutEventHandler : \n        IRequestHandler<ItemSoldOutEvent>\n    {\n        private readonly ICartRepository _cartRepository;\n\n        public ItemSoldOutEventHandler(ICartRepository cartRepository)\n        {\n            _cartRepository = cartRepository;\n        }\n\n        public async Task<Unit> Handle(ItemSoldOutEvent @event, \n            CancellationToken cancellationToken)\n        {\n            var cartIds = _cartRepository.GetCarts().ToList();\n\n            var tasks = cartIds.Select(async x =>\n            {\n                var cart = await _cartRepository.GetAsync(new Guid(x));\n                await RemoveItemsInCart(@event.Id, cart);\n            });\n\n            await Task.WhenAll(tasks);\n\n            return Unit.Value;\n        }\n\n        private async Task RemoveItemsInCart(string itemToRemove, \n            CartSession cartSessionSession)\n        {\n            if (string.IsNullOrEmpty(itemToRemove)) return;\n\n            var toDelete = cartSessionSession?.Items?.Where(x => \n                x.CartItemId.ToString() ==           \n                     itemToRemove).ToList();\n\n            if (toDelete == null || toDelete.Count == 0) return;\n\n            foreach (var item in toDelete) \n                cartSessionSession.Items?.Remove(item);\n\n            await _cartRepository.AddOrUpdateAsync(cartSessionSession);\n        }\n    }\n}\n```", "```cs\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Cart.Domain.Events;\nusing Cart.Domain.Handlers.Cart;\nusing Cart.Fixtures;\nusing Shouldly;\nusing Xunit;\n\nnamespace Cart.Domain.Tests.Handlers.Events\n{\n    public class ItemSoldOutEventHandlerTests : IClassFixture<CartContextFactory>\n    {\n        private readonly CartContextFactory _contextFactory;\n\n        public ItemSoldOutEventHandlerTests(CartContextFactory \n            cartContextFactory)\n        {\n            _contextFactory = cartContextFactory;\n        }\n\n        [Fact]\n        public async Task should_not_remove_records_when*soldout* message_contains_not_existing_id()\n        {\n            var repository = _contextFactory.GetCartRepository();\n            var itemSoldOutEventHandler = new \n                ItemSoldOutEventHandler(repository);\n            var found = false;\n\n            await itemSoldOutEventHandler.Handle(new ItemSoldOutEvent { \n                Id = Guid.NewGuid().ToString() }, \n                   CancellationToken.None);\n\n            var cartsIds = repository.GetCarts();\n\n            foreach (var cartId in cartsIds)\n            {\n                var cart = await repository.GetAsync(new Guid(cartId));\n                found = cart.Items.Any(i => i.CartItemId.ToString() == \n                    \"be05537d-5e80-45c1-bd8c-\n                     aa21c0f1251e\");\n            }\n\n            found.ShouldBeTrue();\n        }\n\n        ...\n    }\n}\n```", "```cs\n...\n        [Fact]\n        public async Task should_remove_records_when*soldout* messages_contains_existing_ids()\n        {\n            var itemSoldOutId = \"be05537d-5e80-45c1-bd8c-aa21c0f1251e\";\n            var repository = _contextFactory.GetCartRepository();\n            var itemSoldOutEventHandler = new \n                ItemSoldOutEventHandler(repository);\n            var found = false;\n\n            await itemSoldOutEventHandler.Handle(new ItemSoldOutEvent { \n              Id = itemSoldOutId }, \n                CancellationToken.None);\n\n            foreach (var cartId in repository.GetCarts())\n            {\n                var cart = await repository.GetAsync(new Guid(cartId));\n                found = cart.Items.Any(i => i.CartItemId.ToString() == \n                    itemSoldOutId);\n            }\n\n            found.ShouldBeFalse();\n        }\n    }\n}\n```", "```cs\ndotnet add package RabbitMQ.Client\n```", "```cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Cart.Domain.Events;\nusing Cart.Infrastructure.Configurations;\nusing MediatR;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Newtonsoft.Json;\nusing RabbitMQ.Client;\nusing RabbitMQ.Client.Events;\n\nnamespace Cart.Infrastructure.BackgroundServices\n{\n    public class ItemSoldOutBackgroundService : BackgroundService\n    {\n        private readonly IMediator _mediator;\n        private readonly ILogger<ItemSoldOutBackgroundService> _logger;\n        private readonly EventBusSettings _options;\n        private readonly IModel _channel;\n\n        public ItemSoldOutBackgroundService( IMediator mediator,\n            EventBusSettings options, ConnectionFactory factory, \n                ILogger<ItemSoldOutBackgroundService> logger)\n        {\n            _options = options;\n            _logger = logger;\n            _mediator = mediator;\n\n            try\n            {\n                var connection = factory.CreateConnection();\n _channel = connection.CreateModel();\n            }\n            catch (Exception e)\n            {\n                _logger.LogWarning(\"Unable to initialize the event bus: \n                    {message}\", e.Message);\n            }\n        }\n\n        ...\n    }\n}\n```", "```cs\nusing MediatR;\nusing Microsoft.Extensions.Hosting;\nusing Newtonsoft.Json;\nusing RabbitMQ.Client;\nusing RabbitMQ.Client.Events;\n\nnamespace Cart.Infrastructure.BackgroundServices\n{\n    public class ItemSoldOutBackgroundService : BackgroundService\n    {\n         ...\n\n        protected override Task ExecuteAsync(CancellationToken \n            stoppingToken)\n        {\n            stoppingToken.ThrowIfCancellationRequested();\n\n            var consumer = new EventingBasicConsumer(_channel);\n\n            consumer.Received += async (ch, ea) =>\n            {\n                var content = System.Text.Encoding.UTF8.\n                    GetString(ea.Body);\n                var @event = JsonConvert.DeserializeObject\n                    <ItemSoldOutEvent>(content);\n\n                await _mediator.Send(@event, stoppingToken);\n                _channel.BasicAck(ea.DeliveryTag, false);\n            };\n\n            try\n            {\n                consumer.Model.QueueDeclare(_settings.EventQueue, true, \n                    false);                                         \n                _channel.BasicConsume(_options.EventQueue, false, \n                    consumer);\n            }\n            catch (Exception e)\n            {\n                _logger.LogWarning(\"Unable to consume the event bus: \n                    {message}\", e.Message);\n            }\n\n            return Task.CompletedTask;\n        }\n    }\n}\n```", "```cs\nusing Cart.Infrastructure.Configurations;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing RabbitMQ.Client;\n\nnamespace Cart.Infrastructure.Extensions\n{\n    public static class EventsExtensions\n    {\n        public static IServiceCollection AddEventBus(this \n            IServiceCollection services, IConfiguration    \n         configuration)\n        {\n            var config = new EventBusSettings();\n            configuration.Bind(\"EventBus\", config);\n            services.AddSingleton(config);\n\n            ConnectionFactory factory = new ConnectionFactory\n            {\n                HostName = config.HostName,\n                UserName = config.User,\n                Password = config.Password\n            };\n\n            services.AddSingleton(factory);\n\n            return services;\n        }\n    }\n}\n```", "```cs\nusing System;\n...\n\nnamespace Cart.API\n{\n    public class Startup\n    {\n\n        public void ConfigureServices(IServiceCollection services)\n        {\n services\n                   ...\n                .AddEventBus(Configuration)\n                .AddHostedService<ItemSoldOutBackgroundService>();\n        }\n\n        ...\n    }\n}\n```", "```cs\n{\n...\n  \"EventBus\": {\n    \"HostName\": \"catalog_esb\",\n    \"User\": \"guest\",\n    \"Password\": \"guest\",\n    \"EventQueue\": \"ItemSoldOut\"\n  }\n}\n\n```"]