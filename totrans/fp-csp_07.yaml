- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functors and Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving from higher-order functions and delegates, we step into the world of
    functors, key players in functional programming. They allow us to work with wrapped
    values, such as lists or computational outcomes, in a structured way. This chapter
    explores the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functor laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicative functors and laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads and monad laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, the following are three self-check tasks to help you understand the
    existing knowledge of functors and monads.
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – Functor usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given a `Result<List<Tower>, string>` type that represents a list of towers,
    where `Tower` is a class containing properties such as `Id`, `Name`, and `Damage`,
    the task is to use the functor concept to apply a function to each tower that
    appends “(Upgraded)” to the end of its name to indicate that the tower has been
    upgraded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Task 2 – Applicative functor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you have two functions wrapped in the `Result` type: `Result<Func<Tower,
    bool>, string> ValidateDamage` checks whether a tower’s damage is within acceptable
    limits, and `Result<Func<Tower, bool>, string> ValidateName` checks whether the
    tower’s name meets certain criteria. Given a `Result<Tower, string>` representing
    a single tower, use applicative functors to apply both validation functions to
    the tower, ensuring both validations pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Task 3 – Monad usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given a sequence of operations needed to upgrade a tower—`FetchTower`, `UpgradeTower`,
    and `DeployTower`—with each potentially failing and returning `Result<Tower, string>`,
    use the monad concept to chain these operations together for a given tower ID.
    Ensure that if any step fails, the entire operation short-circuits and returns
    the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you successfully wrote the solutions for all three tasks, you are awesome!
    If you struggle or don’t know how to solve the tasks now, don’t worry, you will
    be awesome after completing this chapter and solving them.
  prefs: []
  type: TYPE_NORMAL
- en: What’s a functor?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia decided to use an analogy from Steve’s game to explain the concept of
    functors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Imagine a functor as a special upgrade station in your tower defense
    game. This station can take any tower and enhance it, but it always outputs a
    tower - just an* *improved version.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *That makes sense. So it’s like a consistent way to transform things
    without changing their* *core nature?*'
  prefs: []
  type: TYPE_NORMAL
- en: The term **functor** originates from category theory, a field of mathematics
    that deals with complex structures and mappings. In the world of programming,
    we adopt a simplified version of this concept to make it practical for data manipulation.
    In simple terms, functors are specialized containers that can hold data and have
    the ability to apply a function to every piece of data they hold, while keeping
    the overall structure intact. Imagine them as magic boxes that transform whatever
    is inside without altering the box itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not every data container that can apply functions to its elements
    is a functor. There are two laws that a container needs to abide by in order to
    be counted as a functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`identity` function to a functor should yield the same functor. In other words,
    if you map the `identity` function over a functor, the functor should remain unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composition law**: Composing two functions and then mapping the resulting
    function over a functor should be the same as first mapping one function over
    the functor and then mapping the other. This means that functor mappings should
    be composable in a way that doesn’t depend on the order in which they’re applied.'
  prefs: []
  type: TYPE_NORMAL
- en: I know it may sound a bit complicated, so let’s discuss these laws in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Identity law
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Identity law states that the application of the `identity` function to
    our container returns the same container. The “identity function” here is a function
    that always returns its input. In code, we can represent it with the help of `Func<T,
    T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And the usage of this function can be shown like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, the identity function seems useless, but it plays a big role
    in mathematical proofs in functional programming. Returning to functors, the Identity
    law means that if we map the identity function to our container, we should return
    the same result. Let’s move on to the second law.
  prefs: []
  type: TYPE_NORMAL
- en: Composition law
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This law states that either we compose two functions and then map the result
    over our container or map these functions consequently; the result will be the
    same. To understand how it can be applied to our code, let’s first create two
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One function adds pages to the book and returns it; another appends a subtitle
    to the book’s title and returns the result. Quite simple, right? Now, with the
    help of these functions, we can express our Composition law in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can understand from the output, the resulting collections are equal, thus
    our `List<Book>` container abides by the Composition law.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that a container doesn’t need to contain a set of elements to be considered
    a functor. Let’s recall the `Result` type we used in [*Chapter 5*](B21069_05.xhtml#_idTextAnchor221)
    and make an enhanced version of it by adding the `Map` method to be able to apply
    functions to the inner value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Map` method applies the incoming function to the value if the container
    holds a value; otherwise, no function is called and the error result is returned.
    And as the `Result` type now can apply functions to the underlying value, it starts
    to obey the two functor laws. Let’s see that with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Although we cannot directly retrieve the inner value for now, it can be seen
    using the debugger or the `Dump()` extension method in `LinqPad`. And as we can
    see, our `Result` type became a functor.
  prefs: []
  type: TYPE_NORMAL
- en: Functor benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Transforming our `Result<TValue, TError>` type into a functor offers several
    concise advantages, enhancing error handling and operational outcomes in functional
    programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Streamlined error handling**: Integrates both success and error outcomes
    in one structure, simplifying error management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composable operations**: Facilitates chaining operations on successful results,
    with automatic error propagation, improving code reusability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map` function’s intent is clear—transform the value on success, or bypass
    an error, making the code more understandable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type safety and clarity**: The explicit success and error states in the type
    signature enhance predictability and safety, ensuring comprehensive outcome handling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sounds exciting, right? And we can make our class even better by making it an
    applicative functor.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **applicative functor** is a type of functor that allows for the application
    of a function encapsulated within a functor to a value that is also wrapped within
    a functor. This concept translates into enabling operations that can gracefully
    handle multiple layers of computational contexts, such as error handling or asynchronous
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: While functors allow us to apply a function to a wrapped value, applicative
    functors extend this capability by enabling the application of functions that
    are themselves wrapped in a context. This distinction is crucial for operations
    where the function application itself may result in a computational context, such
    as failure, delay, or uncertainty. Let’s look at the difference using the book
    publishing system example.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a function that calculates royalties based on book sales and another
    function that adjusts these royalties based on market conditions. Both functions
    might fail due to various reasons, and their outputs might be wrapped in `Result`
    types to signify success or failure. Applicative functors allow us to apply these
    potentially failing functions to potentially failing inputs, orchestrating complex
    operations that gracefully handle multiple layers of potential failures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `CalculateRoyaltiesFunc` is a function that takes the number
    of sales and calculates the royalties as 10% of the sales. `AdjustRoyaltiesFunc`
    is a function that takes an initial royalty amount and adjusts it by a factor
    of `1.05` to account for market conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s assume we have a `Result<int, string>` representing the number of
    book sales, which could also fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the adjusted royalties, we first apply `CalculateRoyaltiesFunc`
    to `salesResult`, and then apply `AdjustRoyaltiesFunc` to the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of better understanding, let’s pretend that our first function
    returns an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we try to calculate `royaltiesResult` again, `IsSuccess` will be `false`
    and the `Error` property will contain the string `"Can't calculate royalties"`.
    The same situation will happen if the `AdjustRoyaltiesFunc` call results in an
    error. Both methods can fail; however, thanks to the `Apply` method, we can call
    them both in a safe manner. Sounds great, but what does this `Apply` method look
    like?
  prefs: []
  type: TYPE_NORMAL
- en: The Apply method implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the applicative functor pattern, we introduced the `Apply` method.
    This method takes `Result` that contains a function and applies it to the value
    inside the current `Result` instance if both are successful. If either the function
    or the value is wrapped in a failed `Result`, the `Apply` method propagates the
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, nothing special here. First, we ensure that both the current
    container state and the incoming `Result<Func<TValue, TResult>, TError>` state
    are successful. Then, we return a new `Result<TResult, TError>`. If either of
    the `IsSuccess` properties is `false`, a corresponding error is returned. However,
    an `Apply` method is not enough for a class to be considered an applicative functor;
    it must abide by applicative functor laws.
  prefs: []
  type: TYPE_NORMAL
- en: As Steve was grasping the concept of functors, Julia introduced a new challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Now, what if you wanted to apply multiple upgrades to a tower at once,
    but some upgrades might fail? This is where applicative functors come* *in handy.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Multiple upgrades at once? That could really streamline my* *upgrade
    system!*'
  prefs: []
  type: TYPE_NORMAL
- en: Applicative functor laws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four applicative functor laws: Identity, Homomorphism, Interchange,
    and Composition. Let’s go through each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Identity law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Identity law states that applying the identity function to a `Result`-wrapped
    value should yield the original `Result` without any change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Homomorphism law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This law demonstrates that applying a function to a value and then wrapping
    it is equivalent to wrapping the value and then applying the function within the
    `Result`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Interchange law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This law indicates that applying a wrapped function to a wrapped value should
    be equivalent to applying a function that applies its argument to the wrapped
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this law, we would need to extend our `Result` type to support applying
    a `Result`-wrapped function to a `Result`-wrapped value, which is not directly
    supported by the provided `Result` type structure. However, the conceptual application
    would look something like this in a system that supports it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Composition law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Composition law ensures that when we compose two or more functions and apply
    them to a functor, the order of function application does not affect the outcome.
    This property, known as associativity, is central to the Composition law. It ensures
    that if we have functions f, g, and h, composing them and then applying them to
    a functor F yields the same result regardless of how the functions are grouped
    during composition.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, consider two functions, f(x) = x + 1 and g(x) = x * 3\. According
    to the Composition law, composing f and g and then applying them to a value inside
    a functor should yield the same result as applying f to the functor and then g.
    Expressed mathematically, F.map(g(f(x))) is equivalent to F.map(f).map(g).
  prefs: []
  type: TYPE_NORMAL
- en: This associative property allows us to reason about composed functions confidently,
    knowing that the grouping of function applications does not impact the final outcome
    when applied to a functor. This principle enhances the predictability and reliability
    of functional programming, allowing developers to compose complex transformations
    succinctly and safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this law, similar to the Interchange law, we need a mechanism to compose
    functions within the `Result` context, which our current `Result` type definition
    does not directly support. Conceptually, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see our `Result` type abides by all these laws and can be counted
    as an applicative functor. From here, we need to take one more step to make it
    a monad.
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steve was excited about functors but still struggled to see their full potential
    in his game logic. Julia knew it was time to introduce monads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Let’s take your game’s upgrade system a step further. Imagine a series
    of operations: checking the player’s gold, deducting the cost, and applying the
    upgrade. Each step depends on the previous one succeeding. This is where* *monads
    shine.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *That sounds exactly like what I need for my upgrade system. How do
    monads* *handle this?*'
  prefs: []
  type: TYPE_NORMAL
- en: A **monad** represents an evolution of the concepts we explored with functors
    and applicative functors. While a functor allows us to map a function over a wrapped
    value and an applicative functor enables applying wrapped functions to wrapped
    values, monads introduce the ability to chain operations in a way that handles
    the context of those operations—be it errors, lists, options, or other computational
    contexts. Thus, we can say that a monad is an applicative functor that adheres
    to some additional laws.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of a monad is its ability to flatten layers of wrapping caused by
    applying functions that return wrapped values. This is crucial in avoiding deeply
    nested structures when performing multiple operations in sequence. Let’s break
    down this concept with an example from our book publishing system.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where we need to fetch a manuscript, edit it, and then format
    it for publishing. Each of these operations might fail and return `Result<TValue,
    TError>`, leading to nested `Result<Result<...>>` types. Monads allow us to perform
    these operations sequentially in a cleaner way.
  prefs: []
  type: TYPE_NORMAL
- en: The Bind method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key to monads is the `Bind` method (often called `flatMap` or `SelectMany`
    in different languages and frameworks). This method applies a function to the
    wrapped value, which returns the same kind of wrapper, and then flattens the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With `Bind`, we can chain operations without nesting. Let’s apply this to our
    publishing system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this pipeline, each step is applied only if the previous one succeeds, with
    any failure immediately short-circuiting the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Monad laws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as functors, monads must satisfy their laws to ensure consistency and
    predictability and there are three of them: Left Identity, Right Identity, and
    Associativity.'
  prefs: []
  type: TYPE_NORMAL
- en: Left Identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Wrapping a value and then binding with a function is the same as just applying
    the function to the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Right Identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Binding a wrapped value with a function that simply re-wraps the value should
    yield the original wrapped value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Associativity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The order of binding operations should not matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing monads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Monads shine in operations that involve sequences of computations where each
    step might fail or produce a new context. In our book publishing system, we can
    extend this pattern to handle user input validation, database transactions, or
    network calls, ensuring our code remains clean, readable, and maintainable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This approach not only simplifies error handling by propagating errors automatically
    but also keeps the happy path code clear and straightforward, without the need
    for manual checks or nested conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: Monads are like smart containers that help manage a series of steps, particularly
    when you’re dealing with tricky situations such as errors or tasks that take time
    to complete. By getting a handle on functors and then leveling up to monads, you
    can make your code not only more expressive but also easier to maintain and more
    reliable. Think about how we simplified tasks in our book publishing examples;
    monads and their friends can really untangle complicated logic and make dealing
    with mistakes a lot smoother, making your whole code base friendlier and less
    daunting to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Key takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude this chapter on functors and monads, let’s take a moment to
    summarize what we’ve learned:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fundamental concept of functors**: Functors are integral to functional programming
    for data manipulation. They act as “magic boxes” that allow us to apply a function
    to the data they hold, transforming the contents while maintaining the original
    structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not all containers are functors**: For a data container to be considered
    a functor, it must adhere to two critical laws: the Identity law and the Composition
    law. These laws ensure that functors operate predictably and consistently within
    their intended paradigms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity law**: The Identity law emphasizes that mapping an identity function
    (a function that returns its input) over a functor should leave the functor unchanged.
    This law underscores the non-intrusive nature of functor transformations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition law**: The Composition law asserts that the order in which functions
    are composed and applied to a functor does not affect the final outcome. This
    law highlights the composability and flexibility of functors in functional programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Result<TValue, TError>` type example, we explored how functors can be practically
    implemented to enhance error handling and operational outcomes. The `Map` method
    demonstrated the application of functions to the encapsulated value within the
    functor, adhering to the functor laws.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Applicative functors**: The chapter also introduced the concept of applicative
    functors, which build upon basic functors by allowing the application of functions
    wrapped within a functor to values also wrapped within a functor. This capability
    enables handling multiple layers of computational contexts gracefully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Applicative functor laws**: Applicative functors are governed by additional
    laws, including Identity, Homomorphism, Interchange, and Composition. These laws
    further ensure the reliable and predictable behavior of applicative functors in
    complex operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monads**: The discussion set the stage for the evolution into monads, which
    extend the concepts of functors and applicative functors by enabling the chaining
    of operations that handle the context of those operations, such as errors or asynchronous
    computations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In closing, functors and monads are not just theoretical constructs; they are
    pragmatic tools that can transform your code from ordinary to exceptional. Embrace
    the opportunities they offer, and watch as your programming skills reach new heights
    of expressiveness and efficiency. Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After explaining the concepts, Julia challenged Steve to apply what he’d learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Now that you understand the basics, why don’t you try refactoring your
    game’s upgrade system using monads? It should make your code more robust and easier
    to* *reason about.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *That’s a great idea! I can already see how this could simplify some
    of my more complex* *game logic.*'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given a `Result<List<Tower>, string>` type that represents a list of towers,
    where `Tower` is a class containing properties such as `Id`, `Name`, and `Damage`,
    the task is to use the functor concept to apply a function to each tower that
    appends “(Upgraded)” to the end of its name to indicate that the tower has been
    upgraded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you have two functions wrapped in the `Result` type: `Result<Func<Tower,
    bool>, string> ValidateDamage` checks whether a tower’s damage is within acceptable
    limits, and `Result<Func<Tower, bool>, string> ValidateName` checks whether the
    tower’s name meets certain criteria. Given a `Result<Tower, string>` representing
    a single tower, use applicative functors to apply both validation functions to
    the tower, ensuring both validations pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given a sequence of operations needed to upgrade a tower—`FetchTower`, `UpgradeTower`,
    and `DeployTower`—with each potentially failing and returning `Result<Tower, string>`,
    use the monad concept to chain these operations together for a given tower ID.
    Ensure that if any step fails, the entire operation short-circuits and returns
    the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These exercises aim to help you reinforce the concepts learned throughout this
    chapter and understand how to apply them in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you did all the exercises and just want to check out my solutions. If
    not, don’t worry, everything comes with experience. Now, let’s look at the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Map` method to apply a function to each tower in the list that appends
    “(Upgraded)” to its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution demonstrates how functors can encapsulate data and behavior,
    allowing for operations on contained data while preserving the context (success
    or failure) of the entire operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`towersResult.Map(...)`: This line uses the `Map` function, which is fundamental
    to the functor pattern. It applies a given function to the contained value if
    the `Result` is successful, without affecting the outer `Result` structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`towers.Select(tower => ...)`: Inside `Map`, a `Select` LINQ method iterates
    over each `Tower` object in the list, applying a lambda function that modifies
    the `Name` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tower.Name += " (Upgraded)"`: This operation appends `"(Upgraded)"` to the
    name of each tower, indicating that it has been upgraded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The applicative functor pattern extends the functor’s capabilities by allowing
    functions themselves to be wrapped in a context (such as `Result`). This solution
    uses this capability to apply multiple validation functions, wrapped in `Result`
    types, to a single video also wrapped in `Result`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we handle multiple potential failure points in a composable manner, showcasing
    the power of applicative functors in functional error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '`towerResult.Apply(ValidateDamage)` and `towerResult.Apply` **(ValidateName)**:
    These lines demonstrate the applicative functor’s `Apply` method. It takes `Result`
    containing a function and applies it to another `Result` containing a value, effectively
    unwrapping both and applying the function to the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chaining of `Bind` and `Map` ensures that if any validation fails, the entire
    validation process short-circuits and returns the failure. Otherwise, it combines
    the results of both validations into a single Boolean value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Monads extend the concept of applicative functors by allowing the chaining
    of operations that return a wrapped type, such as `Result<Tower, string>`, enabling
    a seamless and error-propagating sequence of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution shows monads’ ability to manage sequences of dependent operations
    within a context, making error handling more intuitive and linear, and thus significantly
    simplifying complex business logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FetchTower(towerId).Bind(UpgradeTower).Bind(DeployTower)`: This line illustrates
    the essence of monads through the `Bind` method. Each function in the chain (`FetchTower`,
    `UpgradeTower`, and `DeployTower`) potentially returns a `Result<Tower, string>`,
    and `Bind` ensures that each subsequent function is only executed if the previous
    one succeeded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The monadic pattern here guarantees that if any step in the process fails, the
    error is immediately propagated through the chain, bypassing subsequent steps
    and returning the failure result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed functors and their role in functional programming.
    We started with the basics, explaining that functors are like smart containers.
    They can hold data and also apply a function to that data while keeping their
    original shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at how functors work, showing how they let us run functions on the
    data they hold without needing to unpack and repack the container. We also covered
    the two main rules that functors follow: the Identity and Composition laws.'
  prefs: []
  type: TYPE_NORMAL
- en: Through examples, we saw how functors can be used in different situations, such
    as working with lists or handling errors more smoothly. We explored creating our
    own functors, which opens up new ways to tailor our code to fit exactly what we
    need. We made the full journey from functors to applicative functors and monads,
    learned about the laws that each of these “containers” adhere to, and saw them
    in some practical scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: As we wrap up this chapter, you should have a solid foundation in using functors
    and monads in your projects. They’re a simple yet powerful tool that can make
    a big difference in how you approach coding. Next up, in [*Chapter 8*](B21069_08.xhtml#_idTextAnchor360),
    *Recursion and Tail Calls*, we’ll dive into the recursion domain, where functions
    call themselves, and look at how tail calls can make recursion more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Practical Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we move from theory to practice, exploring how to apply functional
    programming concepts to real-world scenarios. We’ll start with recursion and tail
    calls, learning how to write efficient recursive functions. Then, we’ll explore
    currying and partial application, techniques that allow you to create more flexible
    and reusable functions. Finally, we’ll look at how to combine functions to create
    powerful data processing pipelines, bringing together many of the concepts learned
    throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21069_08.xhtml#_idTextAnchor360)*, Recursion and Tail Calls*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21069_09.xhtml#_idTextAnchor397)*, Currying and Partial Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21069_10.xhtml#_idTextAnchor426)*, Pipelines and Composition*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
