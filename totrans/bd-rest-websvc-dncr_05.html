<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Integrating External Components and Handling</h1>
                </header>
            
            <article>
                
<p><span><span>So far</span></span>, we have been developing our FlixOneStore. In the previous chapter, we added a shopping cart and shipping facility. However, some organizations may not need such facilities, as some organizations have everything in the house. For instance, our FlixOneStore requires an external component to help us track the assignment and payment-management system.</p>
<p>In this chapter, we will discuss the external components with the help of code examples. We will mainly cover the following topics:</p>
<ul>
<li>Understanding the middleware</li>
<li>Adding logging to our API in the middleware</li>
<li>Intercepting HTTP requests and responses by building our own middleware</li>
<li>JSON-RPC for RPC communication </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the middleware </h1>
                </header>
            
            <article>
                
<p>As the name suggests, middleware is a piece of software that connects two different or similar places. In the world of software engineering, middleware is a software component and is assembled in an application pipeline to handle requests and responses.</p>
<p>These components can also check whether a request should pass to the next components, or whether the request should be handled by a component before or after the next component is triggered/invoked. This request pipeline is built with the use of a request delegate. This request delegate interacts with each HTTP request.</p>
<p>Look at the following quote from the documentation of ASP.NET Core<span> (</span><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/</a>):</p>
<div class="packt_quote">"Middleware is software that's assembled into an application pipeline to handle requests and responses."</div>
<p>Look at the following diagram, showing an example of a simple middleware component:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9bce228e-7b7b-4e9c-8088-5adfcb279a1f.png" style="width:44.58em;height:15.92em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Requesting delegates</h1>
                </header>
            
            <article>
                
<p><span>Requests are handled by the</span> <kbd>Use</kbd>, <kbd>Run</kbd>, <kbd>Map</kbd>, and <kbd>MapWhen</kbd> <span>extension methods. These </span><span>methods configure the request delegates.</span></p>
<p>To understand this in detail, let's create a dummy project using <kbd>ASP.NET Core</kbd>. Go through the following steps:</p>
<ol>
<li>Open Visual Studio.</li>
<li>Go to <span class="packt_screen">File | New | Project</span>, or click <em>Ctrl</em> + <em>Shift</em> + <em>N</em>. Refer to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c0b2f086-c173-4d34-bd96-36a9f72eb2aa.png" style="width:43.00em;height:27.75em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Creating a new project using Visual Studio 2017</div>
<ol start="3">
<li>From the <span class="packt_screen">New Project</span> screen, select <span class="packt_screen">ASP.NET Core Web Application</span>.</li>
</ol>
<p> </p>
<ol start="4">
<li>Name your new project (say <kbd>Chap05_01</kbd>), select a location, and click <span class="packt_screen">OK</span>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/230053ba-e018-446e-bc6d-e6fd627bb5b1.png" style="width:52.58em;height:31.92em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Selecting new project template</div>
<ol start="5">
<li>From the new <span class="packt_screen">ASP.NET Core Web Application</span> template screen, choose the <span class="packt_screen">API</span> template. Make sure you select <span class="packt_screen">.NET Core</span> and <span class="packt_screen">ASP.NET Core 2.0</span>.</li>
</ol>
<p> </p>
<ol start="6">
<li>Click <span class="packt_screen">OK</span>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f27c348c-5b5b-49e9-9f5b-149c6bae1232.png" style="width:43.42em;height:28.25em;"/></div>
<ol start="7">
<li>Open <span class="packt_screen">Solution Explorer</span>. You will see the file/folder structure, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/59fe708a-495b-4023-b55d-7743d92329ce.png" style="width:21.50em;height:16.50em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Showing file/folder structure of Chap05_01 project</div>
<p>From the dummy project that we have just created, open the <kbd>Startup.cs</kbd> file and look at the <kbd>Configure</kbd> method, which contains the following code:</p>
<pre>// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.<br/>public void Configure(IApplicationBuilder app, IHostingEnvironment env)<br/>{<br/>  if (env.IsDevelopment())<br/>  {<br/>    app.UseDeveloperExceptionPage();<br/>  }<br/>  app.UseMvc();<br/>}</pre>
<p>The preceding code is self-explanatory: it tells the system to add <kbd>Mvc</kbd> to the request pipelines by initiating the <kbd>app.UseMvc()</kbd> extension method of <kbd>Microsoft.AspNetCore.Builder.IApplicationBuilder</kbd>.</p>
<div class="packt_infobox">You can get more information on <kbd>IApplicationBuilder</kbd> at <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder?view=aspnetcore-2.0">https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder?view=aspnetcore-2.0</a><span>.</span></div>
<p>It also instructs the system to use a particular exception page if the environment is in development. The preceding method configures the application.</p>
<p>In the next section, we will discuss <span>four</span><span> important</span> <kbd>IApplicationBuilder</kbd> <span>methods</span><span> </span><span>in detail.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use</h1>
                </header>
            
            <article>
                
<p>The <kbd>Use</kbd> method adds a delegate to the application request pipelines. Look at the following screenshot for the signature of this method:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/291321c1-da74-4bc7-85da-9ab284eee7ff.png" style="width:31.83em;height:8.42em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Signature of Use method</div>
<p>As we discussed in the previous section, the middleware methods can short circuit the request pipeline or pass the request to the next delegate.</p>
<div class="packt_tip">
<p>Short-circuiting a request is nothing but ending a request.</p>
</div>
<p>Look at the following code for the <kbd>Use</kbd> <span>method</span><span>:</span></p>
<pre>public void Configure(IApplicationBuilder app)<br/>{<br/>  async Task Middleware(HttpContext context, Func&lt;Task&gt; next)<br/>  {<br/>    //other stuff<br/>    await next.Invoke();<br/>    //other stuff<br/>  }<br/>  app.Use(Middleware);<br/>}</pre>
<p>In the preceding code, I have tried to explain the dummy implementation of the <kbd>Use</kbd> method with the help of a local function. Here, you can see that <kbd>Middleware</kbd> is invoking or passing the request to the next delegate, before or after <kbd>await next.Invoke();</kbd>. You can write/implement other code phrases, but these phrases should not send responses to the client, such as those that write output, produce the 404 status, and so on.</p>
<div class="packt_tip">
<p><strong>Local functions</strong> are the methods that are declared within a method and can be called within the scope of the method itself. These methods can only be used by another method.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Run</h1>
                </header>
            
            <article>
                
<p>The <kbd>Run</kbd> method adds a delegate to the request pipeline in the same way as the <kbd>Use</kbd> method, but this method terminates the request pipeline. Look at the following screenshot for the signature of this method:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6a5a0166-c10b-490c-8ccc-a4454aabc2a0.png" style="width:31.08em;height:4.17em;"/></div>
<p>Look at the following code:</p>
<pre>public void Configure(IApplicationBuilder app, ILoggerFactory logger)<br/>{<br/>  logger.AddConsole();<br/>  //add more stuff that does not responses client<br/>  async Task RequestDelegate(HttpContext context)<br/>  {<br/>    await context.Response.WriteAsync("This ends the request or <br/>    short circuits request.");<br/>  }<br/>  app.Run(RequestDelegate);<br/>}</pre>
<p>In the preceding code, I tried to show that <kbd>Run</kbd> terminates the request pipeline. Here, I used a local function, <kbd>RequestDelegate</kbd>.</p>
<p><span>You can see that I added a console logger b</span>efore this and that there is scope to add more code phrases, but not those phrases that send responses back to the client. Here, <kbd>Run</kbd> terminates by returning a string. Run Visual Studio or press <em>F5</em>—you will get an output similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/47ec67d8-9b78-4440-8bb0-223ef2a17710.png" style="width:27.17em;height:8.33em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Map</h1>
                </header>
            
            <article>
                
<p>The <kbd>Map</kbd> method helps when you want to connect multiple instances of middleware. To do this, <kbd>Map</kbd> calls another request delegate. Look at the following screenshot for the signature of this method:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9e767d6f-3229-463b-9373-8c8ec0ac298a.png" style="width:55.08em;height:3.25em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><sup>Signature of Map method</sup></div>
<p>Look at the following code:</p>
<pre>public void Configure(IApplicationBuilder app)<br/>{<br/>  app.UseMvc();<br/>  app.Map("/testroute", TestRouteHandler);<br/>  async Task RequestDelegate(HttpContext context)<br/>  {<br/>    await context.Response.WriteAsync("This ends the request or <br/>    short circuit request.");<br/>  }<br/>  app.Run(RequestDelegate);<br/>}</pre>
<p>In this code, I added a <kbd>Map</kbd> that just maps <kbd>&lt;url&gt;/testroute</kbd>. Following this is the same <kbd>Run</kbd> method that we discussed previously. <kbd>TestRoutehandler</kbd> is a private method. Look at the following code:</p>
<pre>private static void  TestRouteHandler(IApplicationBuilder app) <br/>{<br/>  async Task Handler(HttpContext context)<br/>  {<br/>    await context.Response.WriteAsync("This is called from testroute.<br/>    " + "This ends the request or short circuit request.");<br/>  }<br/>  app.Run(Handler);<br/>}</pre>
<p>Before <kbd>app.Run(Handler);</kbd> is a normal delegate. Now, run the code and look at the results. They should be similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/93907e52-1b91-46c5-9e62-7b3ab8e77ac8.png" style="width:20.17em;height:6.58em;"/></div>
<p>You can see that the root of the web application is showing the string that is mentioned in the <kbd>Run</kbd> delegate method. You will get the output shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a5cb5a2a-d3dd-417c-8f89-d9d3ddb0df73.png" style="width:27.00em;height:6.17em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding logging to our API in middleware</h1>
                </header>
            
            <article>
                
<p>In simple words, logging is nothing but the process or act of getting log files in one place to get the events or other actions that occur in APIs during communication. In this section, we will implement logging for our product APIs.</p>
<p>Before we start looking at how to log our APIs' events, let's first take a quick look at our existing product APIs.</p>
<div class="packt_infobox"><span>Refer to the </span><em>Request delegates </em><span>section to refresh your memory as to how </span><span>you can create a new ASP.NET Core project.</span></div>
<p>The following screenshot shows the project structure of our product APIs:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/84ad0efb-4932-4e26-82e1-460cbc488d84.png" style="width:24.67em;height:31.75em;"/></div>
<p>Here is our <kbd>Product</kbd> model:</p>
<pre>public class Product<br/>{<br/>  public Guid Id { get; set; }<br/>  public string Name { get; set; }<br/>  public string Description { get; set; }<br/>  public string Image { get; set; }<br/>  public decimal Price { get; set; }<br/>  public Guid CategoryId { get; set; }<br/>  public virtual Category Category { get; set; }<br/>}</pre>
<p>The <kbd>Product</kbd> model is a class that represents a product, containing properties.</p>
<p>Here is our repository interface:</p>
<pre>public interface IProductRepository<br/>{<br/>  void Add(Product product);<br/>  IEnumerable&lt;Product&gt; GetAll();<br/>  Product GetBy(Guid id);<br/>  void Remove(Guid id);<br/>  void Update(Product product);<br/>}</pre>
<p>The <kbd>IProductRepository</kbd> interface has methods that are required for our APIs to start with operations for a product.</p>
<p>Let's take a look at our <kbd>ProductRepository</kbd> class:</p>
<pre>public class ProductRepository : IProductRepository<br/>{<br/>  private readonly ProductContext _context;<br/>  public ProductRepository(ProductContext context) =&gt; <br/>  _context = context;<br/>  public IEnumerable&lt;Product&gt; GetAll() =&gt; _context.Products.<br/>  Include(c =&gt; c.Category).ToList();<br/>  public Product GetBy(Guid id) =&gt; _context.Products.Include<br/>  (c =&gt; c.Category).FirstOrDefault(x =&gt; x.Id == id);<br/>  public void Add(Product product)<br/>  {<br/>    _context.Products.Add(product);<br/>    _context.SaveChanges();<br/>  }<br/>  public void Update(Product product)<br/>  {<br/>    _context.Update(product);<br/>    _context.SaveChanges();<br/>  }<br/>  public void Remove(Guid id)<br/>  {<br/>    var product = GetBy(id);<br/>    _context.Remove(product);<br/>    _context.SaveChanges();<br/>  }<br/>}</pre>
<p>The <kbd>ProductRepository</kbd> class implements the <kbd>IProductRepository</kbd> interface. The preceding code is self-explanatory.</p>
<p>Open the <kbd>Startup.cs</kbd> file and add the following code:</p>
<pre>services.AddScoped&lt;IProductRepository, ProductRepository&gt;();<br/>services.AddDbContext&lt;ProductContext&gt;(<br/>o =&gt; o.UseSqlServer(Configuration.GetConnectionString<br/>("ProductConnection")));<br/>services.AddSwaggerGen(swagger =&gt;<br/>{<br/>  swagger.SwaggerDoc("v1", new Info { Title = "Product APIs", <br/>  Version = "v1" });<br/>});</pre>
<div class="packt_tip">
<p>For Swagger support for our Product APIs, you need to add the <kbd>Swashbuckle.ASPNETCore</kbd> <span>NuGet package</span><span>.</span></p>
</div>
<p>Now, open the <kbd>appsettings.json</kbd> file and add the following code:</p>
<pre>"ConnectionStrings": <br/>{<br/>  "ProductConnection": "Data Source=.;Initial <br/>  Catalog=ProductsDB;Integrated <br/>  Security=True;MultipleActiveResultSets=True"<br/>}</pre>
<p>Let's see what our <kbd>ProductController</kbd> contains:</p>
<pre>[HttpGet]<br/>[Route("productlist")]<br/>public IActionResult GetList()<br/>{<br/>  return new <br/>  OkObjectResult(_productRepository.GetAll().<br/>  Select(ToProductvm).ToList());<br/>}</pre>
<p>The preceding code is the <kbd>GET</kbd> resource of our product APIs. It calls the <kbd>GetAll()</kbd> method of our <kbd>ProductRepository</kbd>, transposes the response, and returns it. In the previous code, we have already instructed the system to resolve the <kbd>IProductRepository</kbd> <span>interface</span><span> </span><span>with the</span> <kbd>ProductRepository</kbd> <span>class.</span><span> R</span><span>efer to the </span><kbd>Startup</kbd> <span>class.</span></p>
<p>Here is the method that transposes the response:</p>
<pre>private ProductViewModel ToProductvm(Product productModel)<br/>{<br/>  return new ProductViewModel<br/>  {<br/>    CategoryId = productModel.CategoryId,<br/>    CategoryDescription = productModel.Category.Description,<br/>    CategoryName = productModel.Category.Name,<br/>    ProductDescription = productModel.Description,<br/>    ProductId = productModel.Id,<br/>    ProductImage = productModel.Image,<br/>    ProductName = productModel.Name,<br/>    ProductPrice = productModel.Price<br/>  };<br/>}</pre>
<p>The preceding code accepts a parameter of the <kbd>Product</kbd> <span>type</span><span> </span><span>and then returns an object of the <kbd>ProductViewModel</kbd></span> <span>type</span><span>.</span></p>
<p>The following code shows how our controller constructor is injected:</p>
<pre>private readonly IProductRepository _productRepository;<br/>public ProductController(IProductRepository productRepository)<br/>{<br/>  _productRepository = productRepository;<br/>}</pre>
<p>In the preceding code, we injected our <kbd>ProductRepository</kbd>, and it will be automatically initialized whenever anyone calls any resources of the product APIs.</p>
<p>Now, you are ready to play with the application. Run the application from the menu or click <em>F5</em>. In a web browser, you can use the suffix <kbd>/swagger</kbd> to the URL of the address.</p>
<div class="packt_tip"><span>For the complete source code, refer to the GitHub repository link at</span> <a href="https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core">https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core</a>.</div>
<p>It will show the Swagger API documentation, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-879 image-border" src="assets/81c11e65-4875-466e-a068-7a62e931b066.png" style="width:112.08em;height:49.08em;"/></div>
<p>Click on the <kbd>GET /api/Product/productlist</kbd> <span>resource</span><span>.</span><span> It will return a list of products, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-880 image-border" src="assets/2d825f3e-e331-434a-8d31-ad740b96efc1.png" style="width:35.25em;height:27.25em;"/></div>
<p>Let's implement logging for our API. Please note that to make our demo short and simple, I am not adding complex scenarios to track everything. I am adding simple logs to showcase the logging capabilities.</p>
<p>To start implementing logging for our product APIs, add a new class called <kbd>LogAction</kbd> in a new folder called <kbd>Logging</kbd>. Here is the code from the <kbd>LogAction</kbd> class:</p>
<pre>public class LogActions <br/>{<br/>  public const int InsertProduct = 1000;<br/>  public const int ListProducts = 1001;<br/>  public const int GetProduct = 1002;<br/>  public const int RemoveProduct = 1003;<br/>}</pre>
<p>The preceding code contains constants that are nothing but our application's actions, also called <strong>events</strong>.</p>
<p>Update our <kbd>ProductController</kbd>; it should now look like the following code:</p>
<pre>private readonly IProductRepository _productRepository;<br/>private readonly ILogger _logger;<br/>public ProductController(IProductRepository productRepository, ILogger logger)<br/>{<br/>  _productRepository = productRepository;<br/>  _logger = logger;<br/>}</pre>
<p>In the preceding code, we added an <kbd>ILogger</kbd> interface, which comes from a dependency injection container (see <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.0">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.0 </a>for more details).</p>
<p>Let's add the logging capability to the <kbd>GET</kbd> resource of the product API:</p>
<pre>[HttpGet]<br/>[Route("productlist")]<br/>public IActionResult GetList()<br/>{<br/>  _logger.LogInformation(LogActions.ListProducts, "Getting all<br/>  products.");<br/>  return new <br/>  OkObjectResult(_productRepository.GetAll().Select(ToProductvm).<br/>  ToList()); <br/>}</pre>
<p>The preceding code returns the product list and logs the information.</p>
<p>To test this scenario, we need a client or an API tool so we can see the output. To do this, we will use the <kbd>Postman</kbd> extension (see<a href="https://www.getpostman.com/"> https://www.getpostman.com/ </a>for more details).</p>
<p>First, we need to run the application. To do so, open the Visual Studio command prompt, move to your project folder, and then pass the command <kbd>dotnet run</kbd>. You will see a similar message to the one shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-881 image-border" src="assets/adeff017-ecbf-4077-bd70-3c2e468bb408.png" style="width:54.58em;height:6.83em;"/></div>
<p>Now, launch Postman and invoke the <kbd>GET /api/product/productlist</kbd> resource:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9f77c310-49f6-4d9c-b833-0d264193c9bd.png" style="width:58.08em;height:6.75em;"/></div>
<p>By clicking the <span class="packt_screen">Send</span> button, you would expect a list of products to be returned, but this is not the case, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/99026730-2294-43ba-85c6-535d9e4cac95.png" style="width:58.17em;height:8.83em;"/></div>
<p>The preceding exception occurs because <span>we are using a non-generic type </span><span>in our</span> <kbd>ProductController</kbd><span> that is not injectable. </span></p>
<p>So, we need to make slight changes in our <kbd>ProductController</kbd>. Look at the following code snippet:</p>
<pre>private readonly IProductRepository _productRepository;<br/>private readonly ILogger&lt;ProductController&gt; _logger;<br/>public ProductController(IProductRepository productRepository, ILogger&lt;ProductController&gt; logger)<br/>{<br/>  _productRepository = productRepository;<br/>  _logger = logger;<br/>}</pre>
<p>In the preceding code, I added a generic <kbd>ILogger&lt;ProductController&gt;</kbd> type. As it is injectable, it will get resolved automatically.</p>
<div class="packt_tip">Logging is slightly different in .NET Core 2.0 compared to its earlier versions. The implementation of the nongeneric <kbd>ILogger</kbd> is not available by default, but it is available for <kbd>ILogger&lt;T&gt;</kbd>. If you want to use nongeneric implementation, use <kbd>ILoggerFactory</kbd> instead of <kbd>ILogger</kbd>.<br/>
<br/>
In this case, the constructor of our <kbd>ProductController</kbd> would look like the following:<br/>
<br/>
<br/>
<kbd>private readonly IProductRepository _productRepository;</kbd><br/>
<kbd>private readonly ILogger _logger;</kbd><br/>
<br/>
<kbd>public ProductController(IProductRepository productRepository, ILoggerFactory logger)</kbd><br/>
<kbd>{</kbd><br/>
<kbd>_productRepository = productRepository;</kbd><br/>
<kbd>_logger = logger.CreateLogger("Product logger");</kbd><br/>
<kbd>}</kbd></div>
<p>Open the <kbd>Program</kbd> class and update it. It should look like the following code snippet:</p>
<pre>public static void Main(string[] args)<br/>{<br/>  var webHost = new WebHostBuilder()<br/>  .UseKestrel()<br/>  .UseContentRoot(Directory.GetCurrentDirectory())<br/>  .ConfigureAppConfiguration((hostingContext, config) =&gt;<br/>  {<br/>    var env = hostingContext.HostingEnvironment;<br/>    config.AddJsonFile("appsettings.json", optional: true,<br/>    reloadOnChange: true)<br/>    .AddJsonFile($"appsettings.{env.EnvironmentName}.json", <br/>    optional: true, reloadOnChange: true);<br/>    config.AddEnvironmentVariables();<br/>  })<br/>  .ConfigureLogging((hostingContext, logging) =&gt;<br/>  {</pre>
<pre>    logging.AddConfiguration(hostingContext.Configuration.<br/>    GetSection("Logging"));<br/>    logging.AddConsole();<br/>    logging.AddDebug();<br/>  })<br/>  .UseStartup&lt;Startup&gt;()<br/>  .Build();<br/>  webHost.Run();<br/>}</pre>
<p>You also need to update the <kbd>appsettings.json</kbd> file and write more code for the logger so that your file looks like the following snippet:</p>
<pre>{<br/>  "ApplicationInsights": <br/>  {<br/>    "InstrumentationKey": ""<br/>  },<br/>  "Logging": <br/>  {<br/>    "IncludeScopes": false,<br/>    "Console": <br/>    {<br/>      "LogLevel": <br/>      {<br/>        "Default": "Warning",<br/>        "System": "Information",<br/>        "Microsoft": "Information"<br/>      }<br/>    }<br/>  },<br/>  "ConnectionStrings": <br/>  {<br/>    "ProductConnection": "Data Source=.;Initial<br/>    Catalog=ProductsDB;Integrated   <br/>    Security=True;MultipleActiveResultSets=True"<br/>  }<br/>}</pre>
<p>Now, once again, open the <span>Visual Studio command prompt and write the <kbd>dotnet build</kbd> command. It will build the project, and you will get a message similar to the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span><img src="assets/712f7568-3d05-4989-87ea-78badf111be9.png" style="width:47.33em;height:13.08em;"/><br/></span></div>
<p>From this point, if you run Postman, it will give you the results, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/955ca74a-b21f-4f99-8816-ddfe33cb32e5.png" style="width:49.92em;height:28.50em;"/></div>
<p>The preceding code adds the ability to log the actions. You will receive <span>similar</span><span> </span><span>log actions to those shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span><img src="assets/4f57ea89-3a05-4cc4-841f-72f8095a8bf3.png" style="width:47.33em;height:23.75em;"/><br/></span></div>
<p>Here, we have written some code that uses the default <kbd>ILogger</kbd>. We have used default methods to invoke the logger; however, there are scenarios where we need a customized logger. In the next section, we will discuss how to write middleware for a custom logger.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Intercepting HTTP requests and responses by building our own middleware</h1>
                </header>
            
            <article>
                
<p>In this section, we will create our own middleware for our existing application. In this middleware, we will log all requests and responses. Let's go through the following steps:</p>
<ol>
<li>Open Visual Studio.</li>
</ol>
<p> </p>
<ol start="2">
<li>Open an existing project of the Product APIs by clicking <span class="packt_screen">File</span> | <span class="packt_screen">Open</span> | <span class="packt_screen">Project/Solution</span> (or pressing <em>Ctrl</em> + <em>Shift</em> + <em>O</em>), as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c7d1d3df-b9e8-4033-b1ef-d18001ade638.png" style="width:41.67em;height:29.08em;"/></div>
<ol start="3">
<li>Locate your solution folder and click <span class="packt_screen">Open</span>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/61661159-326b-4c8a-81da-d7b943efb169.png" style="width:44.17em;height:31.17em;"/></div>
<ol start="4">
<li>Open the solution explorer, add a new folder, and name it <kbd>Middleware</kbd> by right-clicking on the project name, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/01dd79d4-1500-4331-a7e8-5935fb70d39d.png" style="width:43.42em;height:39.50em;"/></div>
<ol start="5">
<li>Right-click on the <kbd>Middleware</kbd> folder and select <span class="packt_screen">Add | New Item</span>.</li>
<li>From the web templates, select the <span class="packt_screen">Middleware</span><span class="packt_screen"> Class</span> and name the new file <kbd>FlixOneStoreLoggerMiddleware</kbd>. Then, click <span class="packt_screen">Add</span>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bbc65dd4-b76a-4fd4-9cee-0f5b13150f20.png" style="width:49.33em;height:30.17em;"/></div>
<p style="padding-left: 60px">Your folder hierarchy should be like the one shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/da2e2fcb-191b-4c64-91ae-cf6b04d6f02d.png" style="width:27.08em;height:33.25em;"/></div>
<div class="packt_infobox">Thanks to <span>Justin Williams who provided a solution for POST resources; his solution is available at <a href="https://github.com/JustinJohnWilliams/RequestLogging">https://github.com/JustinJohnWilliams/RequestLogging</a></span><span>.</span></div>
<p>Look at the following code snippet of our <kbd>FlixOneStoreLoggerMiddleware</kbd> class:</p>
<pre>private readonly RequestDelegate _next;<br/>private readonly ILogger&lt;FlixOneLoggerMiddleware&gt; _logger;<br/>public FlixOneLoggerMiddleware(RequestDelegate next, ILogger&lt;FlixOneLoggerMiddleware&gt; logger)<br/>{<br/>  _next = next;<br/>  _logger = logger;<br/>}</pre>
<p>In the preceding code, we are simply taking advantage of the inbuilt DI using the <kbd>RequestDelegate</kbd> to create our custom middleware.</p>
<p>The following code shows us how we should be wiring up all requests and responses for the log:</p>
<pre>public async Task Invoke(HttpContext httpContext)<br/>{<br/>  _logger.LogInformation(await  <br/>  GetFormatedRequest(httpContext.Request));<br/>  var originalBodyStream = httpContext.Response.Body;<br/>  using (var responseBody = new MemoryStream())<br/>  {<br/>    httpContext.Response.Body = responseBody;<br/>    await _next(httpContext);<br/>    _logger.LogInformation(await <br/>    GetFormatedResponse(httpContext.Response));<br/>    await responseBody.CopyToAsync(originalBodyStream);<br/>  }<br/>}</pre>
<p>Refer to the <em>Request delegate</em> section in this chapter, where we looked at middleware. In the preceding code, we are simply logging the request and response with the help of the <kbd>ILogger</kbd> generic type. The <kbd>await _next(httpContext);</kbd> line continues with the request pipeline<span><span>.</span></span></p>
<p>Open the <kbd>Setup.cs</kbd> file and add the following code in the <kbd>Configure</kbd> method:</p>
<pre>loggerFactory.AddConsole(Configuration.GetSection("Logging"));<br/>loggerFactory.AddDebug();<br/>//custom middleware<br/>app.UseFlixOneLoggerMiddleware();</pre>
<p>In the preceding code, we take advantage of  <kbd>ILoggerFactory</kbd> and add <kbd>Console</kbd> and <kbd>Debug</kbd> to log the requests and responses. <span>The</span><span> </span><kbd>UseFlixOneLoggerMiddleware</kbd><span> method is actually an extension method. For this, add the following code to the </span><kbd>FlixOneStoreLoggerExtension</kbd> <span>class:</span></p>
<pre>public static class FlixOneStoreLoggerExtension<br/>{<br/>  public static IApplicationBuilder UseFlixOneLoggerMiddleware<br/>  (this IApplicationBuilder applicationBuilder)<br/>  {<br/>    return applicationBuilder.UseMiddleware&lt;FlixOneLoggerMiddleware&gt;();<br/>  }<br/>}</pre>
<p>Now, whenever any request comes to our product APIs, the log should appear, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a7b36f72-6571-4284-860f-f2c2f0ed525b.png"/></div>
<p>In this section, we created a custom middleware and then logged all requests and responses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON-RPC for RPC communication</h1>
                </header>
            
            <article>
                
<p><span>JSON-RPC is a stateless, lightweight remote procedure call (RPC) protocol. The specification (namely, JSON-RPC 2.0 specifications (see<a href="http://www.jsonrpc.org/specification"> http://www.jsonrpc.org/specification </a>for more details)) defines various data structures and their processing rules.</span></p>
<p>The main objects as per the specifications<span> are shown in the </span><span>following sections</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Request object</h1>
                </header>
            
            <article>
                
<p>The <kbd>Request</kbd> object represents any call/request that is sent to the server. The <kbd>Request</kbd> object has the following members:</p>
<ul>
<li><strong>jsonrpc</strong>: A string that indicates the version of the JSON-RPC protocol. It <em>must</em> be accurate (in this case, version 2.0).</li>
<li><strong>method</strong>: A string that has the name of the method to be adjured. Method names that begin with the word <kbd>rpc</kbd> and are succeeded by a period character (U+002E or ASCII 46) are restrained for rpc-internal methods and extensions, and <em>must not</em> be worn for anything else.</li>
<li><strong>params</strong>: A structured value that dominates the parameter values. It is to be worn throughout the conjuration of the method. This member <em>may</em> be deleted.</li>
<li><strong>id</strong>: An identifier fixed by the client that <em>must</em> have a string, number, or <em>null</em> value if constituted.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Response object</h1>
                </header>
            
            <article>
                
<p class="mce-root">As per the specifications, whenever a call is made to the server, there must be a response from the server. <span>The <kbd>Response</kbd> is expressed as a single JSON object with the following members:</span></p>
<ul>
<li><strong>jsonrpc</strong>: A string that is the version of the JSON-RPC protocol</li>
<li><strong>result</strong>: A required member, if the request succeeds</li>
<li><strong>error</strong>: A required member, if there was an error</li>
<li><strong>id</strong>: A required member</li>
</ul>
<p class="mce-root">In this section, we looked at an overview of JSON-RPC specification 2.0.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed the integration of external APIs/components regarding payment gateways, order tracking, notification services, and so on. We also implemented their functionality by using actual code.</p>
<p>Testing is the one process that helps us to make our code error free. It is also a practice for all developers who want to make their code clean and maintainable. In the next chapter, we will cover the testing paradigm in day-to-day development<span> </span><span>activities</span><span>. We will discuss some important terms associated with the test paradigm. We will also cover the theory around these terms, and then we will cover code examples, looking at stubs and mocks, and learning about integration, security, and performance testing.</span></p>


            </article>

            
        </section>
    </body></html>