<html><head></head><body>
		<div><h1 id="_idParaDest-214"><em class="italic"><a id="_idTextAnchor316"/>Chapter 10</em>: DDD – The Domain Layer</h1>
			<p>The previous chapter was an overall view of <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>), where you learned about the fundamental layers, building blocks, and principles of DDD. You also gained an understanding of the structure of the ABP solution and its relation to DDD.</p>
			<p>This chapter completely focuses on the implementation details of the domain layer with a lot of code examples and best practice suggestions. Here are the topics we will cover in this chapter:</p>
			<ul>
				<li>Exploring the example domain</li>
				<li>Designing aggregates and entities</li>
				<li>Implementing domain services</li>
				<li>Implementing repositories</li>
				<li>Building specifications</li>
				<li>Publishing domain events</li>
			</ul>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor317"/>Technical requirements</h1>
			<p>You can clone or download the source code of the <em class="italic">EventHub</em> project from GitHub: <a href="https://github.com/volosoft/eventhub">https://github.com/volosoft/eventhub</a>.</p>
			<p>If you want to run the solution in your local development environment, you need to have an IDE/editor (such as Visual Studio) to build and run ASP.NET Core solutions. Also, if you want to create ABP solutions, you need to have the ABP CLI installed, as explained in <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor318"/>Exploring the example domain</h1>
			<p>The examples in this chapter and the next chapter will mostly be based on the EventHub solution. So, it is essential to understand the domain first. <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>, has already explained the solution. You can check it if you want to refamiliarize yourself with the application and the solution structure. Here, we will explore the technical details and the domain objects.</p>
			<p>The following list introduces and explains the main concepts of the domain:</p>
			<ul>
				<li><strong class="bold">Event</strong> is the root object that represents an online or in-person event. An event has a title, description, start time, end time, registration capacity (optional), and a language (optional) as the main properties.</li>
				<li>An event is created (organized) by an <strong class="bold">Organization</strong>. Any <strong class="bold">User</strong> in the application can create an organization and organize events within that organization.</li>
				<li>An event can have zero or more <strong class="bold">Tracks</strong> with a track name (typically a simple label such as 1, 2, 3 or A, B, C). A track is a sequence of sessions. An event with multiple tracks makes it possible to organize parallel sessions.</li>
				<li>A track contains one or more <strong class="bold">Sessions</strong>. A session is a part of the event where attendees typically listen to a speaker for a certain length of time.</li>
				<li>Finally, a session can have zero or more <strong class="bold">Speakers</strong>. A speaker is a person who talks in the session and makes a presentation. Generally, every session will have a speaker. But sometimes, there can be multiple speakers, or there can be no speaker associated with the session. <em class="italic">Figure 10.1</em> (in the next section) shows the relation of an event to its tracks, sessions, and speakers.</li>
				<li>Any user in the application can <strong class="bold">Register</strong> for an event. Registered users are notified before the event starts or if the event time changes.</li>
			</ul>
			<p>You've learned about the fundamental objects in the EventHub application. The next section explains the first building block of DDD: aggregates.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor319"/>Designing aggregates and entities</h1>
			<p>It is very important to design your entities and aggregate boundaries since the rest of the solution components will be based on that design. In this section, we will first understand what an aggregate is. Then we will see some key principles of an aggregate design. Finally, I will introduce some explicit rules and code examples to understand how we should implement aggregates.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor320"/>What is an aggregate root?</h2>
			<p>An aggregate is a cluster of objects bound together by an aggregate root object. The aggregate root object is responsible for implementing the business rules and constraints related to the aggregate, keeping the aggregate objects in a valid state and preserving the data integrity. The aggregate root and the related objects have methods to achieve that responsibility.</p>
			<p>The <strong class="bold">Event</strong> aggregate shown in the following figure is a good example of aggregates:</p>
			<div><div><img src="img/Figure_10.1_B17287.jpg" alt="Figure 10.1 – The Event aggregate&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – The Event aggregate</p>
			<p>The examples in this <a id="_idIndexMarker638"/>chapter will mostly be based on the <code>Event</code> aggregate since it represents the essential concept of the EventHub solution. So, we should understand its design:</p>
			<ul>
				<li>The <code>Event</code> object is the aggregate root here, with a <code>GUID</code> primary key. It has a collection of <code>Track</code> objects (an event can have zero or more tracks).</li>
				<li>A <code>Track</code> is an entity with a <code>GUID</code> primary key and contains a list of <code>Session</code> objects (a track should have one or more sessions).</li>
				<li>A <code>Session</code> is also an entity with a <code>GUID</code> primary key and contains a list of <code>Speaker</code> objects (a session can have zero or more speakers).</li>
				<li>A <code>Speaker</code> is an entity with a composite primary key that consists of <code>SessionId</code> and <code>UserId</code>.</li>
			</ul>
			<p><code>Event</code> is a relatively complex aggregate. Most of the aggregates in an application will consist of a single entity, the aggregate root entity.</p>
			<p>The aggregate root is <a id="_idIndexMarker639"/>also an entity with a special role in the aggregate: it is the root entity of the aggregate and is responsible for sub-collections. I will refer to the term <strong class="bold">Entity</strong> for both aggregate root and sub-collection entities. So, the entity rules are valid for <a id="_idIndexMarker640"/>both object types, unless I specifically refer to one of them.</p>
			<p>In the next sections, I will introduce two fundamental properties of an aggregate, a single unit and a serialized object.</p>
			<h3>A single unit</h3>
			<p>An aggregate is retrieved (from the database) and stored (in the database) as a single unit, including all the <a id="_idIndexMarker641"/>properties and sub-collection entities. For example, if you want to add a new <code>Session</code> to an <code>Event</code>, you should do the following:</p>
			<ol>
				<li>Read the related <code>Event</code> object from the database with all the <code>Track</code>, <code>Session,</code> and <code>Speaker</code> objects.</li>
				<li>Use a method of the <code>Event</code> class to add the new <code>Session</code> object to a <code>Track</code> of the <code>Event</code>.</li>
				<li>Save the <code>Event</code> aggregate to the database together with the new changes.</li>
			</ol>
			<p>This might seem inefficient to developers who are used to working with relational databases and ORMs such as EF Core. However, it is necessary because that's how we keep the aggregate objects consistent and valid by implementing the business rules.</p>
			<p>Here is a simplified example application service method implementing that process:</p>
			<pre>public class EventAppService
    : EventHubAppService, IEventAppService
{
    //...
    public async Task AddSessionAsync(Guid eventId,
                                      AddSessionDto input)
    {
        var @event = 
            await _eventRepository.GetAsync(eventId);
        @event.AddSession(input.TrackId, input.Title,
            input.StartTime, input.EndTime);
        await _eventRepository.UpdateAsync(@event);
    }
}</pre>
			<p>For this example, the <code>event.AddSession</code> method internally checks whether the new session's start time and end time conflict with another session on the same track. Also, the time range of the <a id="_idIndexMarker642"/>session should not overflow the event time range. We may have other business rules, too. We may want to limit the number of sessions in an event or check whether the session's speaker has another talk in the same time range.</p>
			<p>Remember that DDD is for state changes. If you need a mass query or to prepare a report, you can optimize your database query as much as possible. However, for any change on an aggregate, we need all the objects on that aggregate to apply the business rules related to that change. If you are worried about the performance, see the <em class="italic">Keep aggregates small</em> section.</p>
			<p>At the end of the method, we've updated the <code>Event</code> entity using the repository's <code>UpdateAsync</code> method. If you are working with EF Core, you do not need to explicitly call the <code>UpdateAsync</code> method, thanks to EF Core's change tracking system. The changes will be saved since ABP's Unit of Work system calls the <code>DbContext.SaveChangesAsync()</code> method for you. However, for example, the MongoDB .NET Driver has no change tracking system, and you should explicitly call the <code>UpdateAsync</code> method to the <code>Event</code> object if you're using MongoDB.</p>
			<p class="callout-heading">About the IRepository.GetAsync Method</p>
			<p class="callout">The <code>GetAsync</code> method of the <a id="_idIndexMarker643"/>repository (used in the preceding example code block) retrieves the <code>Event</code> object as an aggregate (with all sub-collections) as a single unit. It works out of the box for MongoDB, but you need to configure your aggregate for EF Core to enable that behavior. See the <em class="italic">The Aggregate pattern</em> section in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a><em class="italic">, Working with the Data Access Infrastructure</em>, to remember how to configure it.</p>
			<p>Retrieving and saving an aggregate as a single unit brings us the opportunity to make multiple changes to the <a id="_idIndexMarker644"/>objects of a single aggregate and save all of them together with a single database operation. This way, all the changes in that aggregate become atomic by nature without needing an explicit database transaction.</p>
			<p class="callout-heading">The Unit of Work System</p>
			<p class="callout">If you need to change multiple aggregates (of the same or different types), you still need a database transaction. In this case, ABP's Unit of Work system (explained in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>) automatically handles database transactions by convention.</p>
			<h3>A serializable object</h3>
			<p>An aggregate should be serializable and transferrable on the wire as a single unit, including all of its <a id="_idIndexMarker645"/>properties and sub-collections. That means you are able to convert it to a byte array or an XML or JSON value, then deserialize (re-construct) it from the serialized value.</p>
			<p>EF Core does not serialize your entities, but a document database, such as MongoDB, may serialize your aggregate to a BSON/JSON value to store in the data source.</p>
			<p>This principle is not a design requirement for an aggregate, but it is a good guide while determining the aggregate boundary. For example, you cannot have properties referencing entities of other aggregates. Otherwise, the referenced object is also serialized as a part of your aggregate.</p>
			<p>Let's look at some more principles. The first rule, introduced in the next section, is the key practice to make an aggregate serializable.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor321"/>Referencing other aggregates by their ID</h2>
			<p>The first rule says that an aggregate (including the aggregate root and other classes) should not have <a id="_idIndexMarker646"/>navigation properties to other aggregates but can store their ID values when necessary.</p>
			<p>This rule makes the aggregate a self-contained, serializable unit. It also helps to not leak the business logic of an aggregate into another aggregate, by hiding aggregate details from other aggregates.</p>
			<p>See the following example code block:</p>
			<pre>public class Event : FullAuditedAggregateRoot&lt;Guid&gt;
{
    public Organization Organization { get; private set; }
    public string Title { get; private set; }
    ...
}</pre>
			<p>The <code>Event</code> class has a navigation property to the <code>Organization</code> aggregate, which is prohibited by this rule. If we serialize an <code>Event</code> object to a JSON value, the related <code>Organization</code> object is also serialized.</p>
			<p>In a proper implementation, the <code>Event</code> class can have an <code>OrganizationId</code> property for the related <code>Organization</code>:</p>
			<pre>public class Event : FullAuditedAggregateRoot&lt;Guid&gt;
{
    public Guid OrganizationId { get; private set; }
    public string Title { get; private set; }
    ...
}</pre>
			<p>Once we have an <code>Event</code> object and need to access the related organization details, we should query the <code>Organization</code> object from the database using <code>OrganizationId</code> (or perform a <code>JOIN</code> query to load them together at the beginning).</p>
			<p>If you are using a document database, such as MongoDB, this rule will seem natural to you. Because if you add a navigation property to the <code>Organization</code> aggregate, then the related <code>Organization</code> object is serialized and saved in the collection of <code>Event</code> objects in the database, which duplicates the organization data and copies it into all events. However, with <a id="_idIndexMarker647"/>relational databases, ORMs such as EF Core allow you to use such navigation properties and handle the relation without any problem. I still suggest implementing this rule since it keeps your aggregates simpler and reduces the complexity of loading related data. If you don't want to apply this rule, you can refer to the <em class="italic">Database provider independence</em> section of <a href="B17287_09_Epub_AM.xhtml#_idTextAnchor300"><em class="italic">Chapter 9</em></a>, <em class="italic">Understanding Domain-Driven Design</em>.</p>
			<p>The next section expresses a best practice: keep your aggregates small!</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor322"/>Keep aggregates small</h2>
			<p>Once we load and save an aggregate as a single unit, we may have performance and memory usage problems <a id="_idIndexMarker648"/>if the aggregate is too big. Keeping an aggregate simple and small is an essential principle, not just for performance but also to reduce the complexity.</p>
			<p>The main aspect that makes an aggregate big is the potential number of sub-collection entities. If a sub-collection of an aggregate root contains hundreds of items, that's a sign of a bad design. In a good aggregate design, the items in a sub-collection should not exceed a few dozen and should remain below 100–150 in edge cases.</p>
			<p>See the <code>Event</code> aggregate in the following code block:</p>
			<pre>public class Event : FullAuditedAggregateRoot&lt;Guid&gt;
{
  ...
  public ICollection&lt;Track&gt; Tracks { get; set; }
  public ICollection&lt;EventRegistration&gt; Registrations { 
      get; set; }
}
public class EventRegistration : Entity
{
    public Guid EventId { get; set; }
    public Guid UserId { get; set; }
}</pre>
			<p>There are two sub-collections of the <code>Event</code> aggregate in this example: <code>Tracks</code> and <code>Registrations</code>.</p>
			<p>The <code>Tracks</code> sub-collection is a collection of parallel tracks in the event. It typically contains a few items, so there's no problem with loading the tracks while loading an <code>Event</code> entity.</p>
			<p>The <code>Registrations</code> sub-collection is a collection of the registration records for the event. Thousands of people can register for a single event, which will be a significant performance problem <a id="_idIndexMarker649"/>if we load all registered people whenever loading an event. Also, most of the time, we don't need all registered users while manipulating an <code>Event</code> object. So, it would be better not to include the collection of registered people in the <code>Event</code> aggregate. In this example, the <code>EventRegistration</code> class is a sub-collection entity. For a better design, we should make it a separate aggregate root class.</p>
			<p>There are three main considerations while determining the boundaries of an aggregate:</p>
			<ul>
				<li>The objects related and used together</li>
				<li>Data integrity, validity, and consistency</li>
				<li>The load and save performance of the aggregate (as a technical consideration)</li>
			</ul>
			<p>In real life, most aggregate roots won't have any sub-collections. When you think to add a sub-collection to an aggregate, think about the object size as a technical factor.</p>
			<p class="callout-heading">Concurrency Control</p>
			<p class="callout">Another problem with big aggregate objects is that they increase the probability of the concurrent update problem since big objects are more likely to be changed by multiple users simultaneously. ABP Framework provides a standard model for concurrency control. Please <a id="_idIndexMarker650"/>refer to the documentation: <a href="https://docs.abp.io/en/abp/latest/Concurrency-Check">https://docs.abp.io/en/abp/latest/Concurrency-Check</a>.</p>
			<p>In the next section, we will discuss single and composite primary keys for entities.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor323"/>Determining the primary keys for entities</h2>
			<p>Entities are determined by their ID (a unique identifier or the <code>Guid</code> type for the entities of the pre-built modules. It also assumes that the user ID and tenant ID types are <code>Guid</code>. We discussed this topic in the <em class="italic">The GUID PK</em> section of <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>.</p>
			<p>ABP also allows you to use composite primary keys for your entities. A composite primary key consists of two or more properties (of an entity) that become a unique value together.</p>
			<p>As a best practice, use a single primary key (a <code>Guid</code> value, an incremental integer value, or whatever you want) for the aggregate root. You can use a single or composite primary for sub-collection entities.</p>
			<p class="callout-heading">Composite Keys in Non-Relational Databases</p>
			<p class="callout">Composite primary keys for sub-collection entities are generally used in relational databases because sub-collections have their own tables in a relational database. However, in a document database (such as MongoDB), you don't define primary keys for sub-collection entities since they don't have their own database collections. Instead, they are stored as a part of the aggregate root.</p>
			<p>In the <em class="italic">EventHub</em> project, <code>Event</code> is an aggregate root with a <code>Guid</code> primary key. <code>Track</code>, <code>Session</code>, and <code>Speaker</code> are sub-collection entities as a part of the <code>Event</code> aggregate. <code>Track</code> and <code>Session</code> entities have <code>Guid</code> primary keys, but the <code>Speaker</code> entity has a composite primary key.</p>
			<p>The <code>Speaker</code> entity class is shown in the following code block:</p>
			<pre>public class Speaker : Entity
{
    public Guid SessionId { get; private set; }
    public Guid UserId { get; private set; }
    public Speaker(Guid sessionId, Guid userId)
    {
        SessionId = sessionId;
        UserId = userId;
    }
    public override object[] GetKeys()
    {
        return new object[] {SessionId, UserId};
    }
}</pre>
			<p><code>SessionId</code> and <code>UserId</code> compose the unique identifier for the <code>Speaker</code> entity. The <code>Speaker</code> class is derived <a id="_idIndexMarker653"/>from the <code>Entity</code> class (without a generic argument). When you derive from the non-generic <code>Entity</code> class, ABP <a id="_idIndexMarker654"/>Framework forces you to define the <code>GetKeys</code> method to obtain the components of the composite key. If you want to use composite keys, refer to the documentation of your database provider (such as EF Core) to learn how to configure them. </p>
			<p>Beginning with the next section, we will look at the implementation details of aggregates and entities.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor324"/>Implementing entity constructors</h2>
			<p>A constructor method is used <a id="_idIndexMarker655"/>to create an object. The compiler creates a default parameterless constructor when we don't explicitly add a constructor to the class. Defining a constructor is a good way to ensure an object is properly created.</p>
			<p>An entity's constructor is responsible for creating a valid entity. It should get the required values as the constructor parameters to force us to supply these values during object creation so the <a id="_idIndexMarker656"/>new object is useful just after creation. It should check (validate) these parameters and set the properties of the entity. It should also initialize sub-collections and perform additional initialization logic if necessary.</p>
			<p>The following code block shows an entity (an aggregate root entity) from the <em class="italic">EventHub</em> project:</p>
			<pre>public class Country : BasicAggregateRoot&lt;Guid&gt;
{
    public string Name { get; private set; }
    private Country() { } // parameterless constructor
    public Country(Guid id, string name) 
        //primary constructor
        : base(id)
    {
        Name = Check.NotNullOrWhiteSpace(
               name, nameof(name),
               CountryConsts.MaxNameLength);
    }
}</pre>
			<p><code>Country</code> is a very simple entity that has a single property: <code>Name</code>. The <code>Name</code> property is required, so the <code>Country</code> primary constructor (the actual constructor that is intended to be used by the application developers) forces the developer to set a valid value to that property by defining a <code>name</code> parameter and checking whether it is empty or exceeds a maximum length constraint. <code>Check</code> is a static class of ABP Framework with various methods used to validate method parameters and throw an <code>ArgumentException</code> error for invalid parameters.</p>
			<p>The <code>Name</code> property has a private setter, so there is no way to change this value after the object creation. We can <a id="_idIndexMarker657"/>assume that countries don't change their names, for this example.</p>
			<p>The <code>Country</code> class's primary constructor takes another parameter, <code>Guid</code> <code>id</code>. We don't use <code>Guid.NewGuid()</code> in the constructor since we want to use the <code>IGuidGenerator</code> service of ABP Framework, which generates sequential GUID values (see <em class="italic">The GUID PK</em> section of <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>). We directly pass the <code>id</code> value to the base class (<code>BasicAggregateRoot&lt;Guid&gt;</code> in this example) constructor, which internally sets the <code>Id</code> property of the entity.</p>
			<p class="callout-heading">The Need for Parameterless Constructors</p>
			<p class="callout">The <code>Country</code> class also defines a private, parameterless constructor. This constructor is just for ORMs, so they can construct an object while reading from the database. Application developers do not use it.</p>
			<p>Let's see a more complex example, showing the primary constructor of the <code>Event</code> entity:</p>
			<pre>internal Event(
    Guid id,
    Guid organizationId,
    string urlCode,
    string title,
    DateTime startTime,
    DateTime endTime,
    string description)
    : base(id)
{
    OrganizationId = organizationId;
    UrlCode = Check.NotNullOrWhiteSpace(urlCode, urlCode,
              EventConsts.UrlCodeLength,
              EventConsts.UrlCodeLength);
    
    SetTitle(title);
    SetDescription(description);
    SetTimeInternal(startTime, endTime);    
    Tracks = new Collection&lt;Track&gt;();
}</pre>
			<p>The <code>Event</code> class's constructor takes the minimal required properties as the parameters, and checks and sets them <a id="_idIndexMarker658"/>to the properties. All these properties have private setters (see the source code) and are set via the constructor or some methods of the <code>Event</code> class. The constructor uses these methods to set the <code>Title</code>, <code>Description</code>, <code>StartTime</code>, and <code>EndTime</code> properties. </p>
			<p>Let's see the <code>SetTitle</code> method's implementation:</p>
			<pre>public Event SetTitle(string title)
{
    Title = Check.NotNullOrWhiteSpace(title, nameof(title),
            EventConsts.MaxTitleLength,
            EventConsts.MinTitleLength);
    Url = EventUrlHelper.ConvertTitleToUrlPart(Title) + "-" 
          + UrlCode;
    return this;
}</pre>
			<p>The <code>SetTitle</code> method assigns the given <code>title</code> value to the <code>Title</code> property by checking the constraints. It then sets the <code>Url</code> property, a calculated value based on the <code>Title</code> property, and the <code>UrlCode</code> property. This method is <code>public</code>, to use later when we need to change the <code>Event</code> entity's <code>Title</code> property.</p>
			<p><code>UrlCode</code> is an eight-character <a id="_idIndexMarker659"/>random unique value that is sent to the constructor and never changes. Let's see another method that the constructor calls:</p>
			<pre>private Event SetTimeInternal(DateTime startTime, 
                              DateTime endTime)
{
    if (startTime &gt; endTime)
    {
        throw new BusinessException(EventHubErrorCodes
            .EventEndTimeCantBeEarlierThanStartTime);
    }
    StartTime = startTime;
    EndTime = endTime;
    return this;
}</pre>
			<p>Here, we have a business rule: the <code>StartTime</code> value cannot be later than the <code>EndTime</code> value.</p>
			<p>The <code>EventHub</code> constructor is <code>internal</code> to prevent creating <code>Event</code> objects out of the domain layer. The application layer should always use the <code>EventManager</code> domain service to create a new <code>Event</code> entity. In the next section, we will see why we've designed it like that.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor325"/>Using services to create aggregates</h2>
			<p>The best way to create <a id="_idIndexMarker660"/>and initialize a new entity is using its public constructor because it is the simplest way. However, in some cases, creating an object requires some more complex business logic that is not possible to implement in the constructor. For such cases, we can use a factory method on a domain service to create the object.</p>
			<p>The <code>Event</code> class's primary constructor is <code>internal</code>, so the upper layers cannot directly create a new <code>Event</code> object. We should use the <code>EventManager</code> <code>CreateAsync</code> method to create a new <code>Event</code> object:</p>
			<pre>public class EventManager : DomainService
{
    ...
    public async Task&lt;Event&gt; CreateAsync(
        Organization organization,
        string title,
        DateTime startTime,
        DateTime endTime,
        string description)
    {
        return new Event(
            GuidGenerator.Create(),
            organization.Id,
            await _eventUrlCodeGenerator.GenerateAsync(),
            title,
            startTime,
            endTime,
            description
        );
    }
}</pre>
			<p>We will return to domain services later, in the <em class="italic">Implementing domain services</em> section of this chapter. With this simple <code>CreateAsync</code> method, we are creating a valid <code>Event</code> object and <a id="_idIndexMarker661"/>returning the new object. We needed such a factory method because we used the <code>eventUrlCodeGenerator</code> service to generate URL code for the new event. The <code>eventUrlCodeGenerator</code> service internally creates a random, eight-character code for the new event and also checks whether that code was used by another event before (see its source code if you want to learn more). That's why it is <code>async</code>: it performs a database operation.</p>
			<p>We've used a factory method of a domain service to create a new <code>Event</code> object because the <code>Event</code> class's constructor cannot use the <code>eventUrlCodeGenerator</code> service. So, you can create factory methods if you need external services/objects while creating a new entity.</p>
			<p class="callout-heading">Factory Service versus Domain Service</p>
			<p class="callout">An alternative <a id="_idIndexMarker662"/>approach can be creating a dedicated class <a id="_idIndexMarker663"/>for the factory method. That means we could create an <code>EventFactory</code> class and move the <code>CreateAsync</code> method inside it. I prefer a domain service method for creating entities to keep the construction logic close to the other domain logic related to the entity.</p>
			<p>Do not save the new entity to the database inside the <code>Factory</code> method and leave it to the client code (generally, an application service method). The <code>Factory</code> method's responsibility is to create the object and no more (think of it as an advanced constructor – an entity constructor cannot save the entity to the database, right?). The client code may need to perform additional operations on the entity before saving it. We will return to this topic in the next chapter.</p>
			<p>Do not overuse factory methods and keep using simple public constructors wherever possible. Creating a valid entity is important, but it is just the beginning of an entity's lifecycle. In the next section, we will see how to change an entity's state in a controlled way.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor326"/>Implementing business logic and constraints</h2>
			<p>An entity is responsible <a id="_idIndexMarker664"/>for keeping itself always valid. In addition to <a id="_idIndexMarker665"/>the constructor that ensures the entity is valid and consistent when it's first created, we can define methods on the entity class to change its properties in a controlled way.</p>
			<p>As a simple rule, if changing a property's value has pre-conditions, we should make its setter <code>private</code> and provide a method to change its value by implementing the necessary business logic and validating the provided value.</p>
			<p>See the <code>Description</code> property of the <code>Event</code> class:</p>
			<pre>public class Event : FullAuditedAggregateRoot&lt;Guid&gt;
{
    ...
    public string Description { get; private set; }
    
    public Event SetDescription(string description)
    {
        Description = Check.NotNullOrWhiteSpace(
            description, nameof(description),
            EventConsts.MaxDescriptionLength,
            EventConsts.MinDescriptionLength);
        return this;
    }
}</pre>
			<p>The <code>Description</code> property's setter is <code>private</code>. We provide the <code>SetDescription</code> method as the only way to change its value. In this method, we validate the <code>description</code> value: it should be a string that has a length of more than <code>50</code> (<code>MinDescriptionLength</code>) and less than <code>2000</code> (<code>MaxDescriptionLength</code>). These constants are defined in the <em class="italic">EventHub.Domain.Shared</em> project, so we can reuse them in DTOs, as <a id="_idIndexMarker666"/>we will see in the next chapter.</p>
			<p class="callout-heading">Data Annotation Attributes on Entity Properties</p>
			<p class="callout">You may ask whether we can use <code>[Required]</code> or <code>[StringLength]</code> attributes on the <code>Description</code> property instead of creating a <code>SetDescription</code> method and manually performing the validation. Such attributes require another system that performs the validation. For example, EF Core can validate the properties based on these data annotation attributes while saving the entity to the database. However, that's not enough because, in that way, the entity could be invalid until we try to save it to the database. The entity should always be valid!</p>
			<p>Let's see a more <a id="_idIndexMarker667"/>complex example, again from the <code>Event</code> class:</p>
			<pre>public Event AddSession(Guid trackId, Guid sessionId,
    string title, DateTime startTime, DateTime endTime,
    string description, string language)
{
    if (startTime &lt; this.StartTime || this.EndTime &lt; 
        endTime)
    {
        throw new BusinessException(EventHubErrorCodes
            .SessionTimeShouldBeInTheEventTime);
    }
    var track = GetTrack(trackId);
    track.AddSession(sessionId, title, startTime, endTime,
                     description, language);
    return this;
}
private Track GetTrack(Guid trackId)
{
    return Tracks.FirstOrDefault(t =&gt; t.Id == trackId) ??
        throw new EntityNotFoundException(typeof(Track),
                                          trackId);
}</pre>
			<p>The <code>AddSession</code> method accepts a <code>trackId</code> parameter since a session should belong to a track. It also accepts the <code>sessionId</code> of the new session (getting it as a parameter to let <a id="_idIndexMarker668"/>the client use the <code>IGuidGenerator</code> service <a id="_idIndexMarker669"/>to create the value). The remaining parameters are the required properties of the new session.</p>
			<p>The <code>AddSession</code> method first checks whether the new session is within the event's time range, then finds the right track (throws an exception otherwise) and delegates the remaining work to the <code>track</code> object. Let's see the <code>track.AddSession</code> method:</p>
			<pre>internal Track AddSession(Guid sessionId, string title,
    DateTime startTime, DateTime endTime,
    string description, string language)
{
    if (startTime &gt; endTime)
    {
        throw new BusinessException(EventHubErrorCodes
            .EndTimeCantBeEarlierThanStartTime);
    }
    foreach (var session in Sessions)
    {
      if (startTime.IsBetween(session.StartTime,
          session.EndTime) ||
          endTime.IsBetween(session.StartTime, 
          session.EndTime))
      {
        throw new BusinessException(EventHubErrorCodes
            .SessionTimeConflictsWithAnExistingSession);
      }
    }    
    Sessions.Add(new Session(sessionId, Id, title, 
                 startTime, endTime, description));    
    return this;
}</pre>
			<p>First of all, this method is <code>internal</code> to prevent using it out of the domain layer. It is always used by the <code>Event.AddSession</code> method shown earlier in this section.</p>
			<p>The <code>Track.AddSession</code> method <a id="_idIndexMarker670"/>loops through all the current sessions to check <a id="_idIndexMarker671"/>whether any session time conflicts with the new session. If there's no problem, it adds the session to the track.</p>
			<p>Returning <code>this</code> (the event object) from a setter method is a good practice since it allows us to chain the setters, for example, <code>eventObject.SetTime(…).SetDescription(…)</code>.</p>
			<p>Both of the example methods used the properties on the event object and did not depend on any external object. What if we need to use an external service or repository to implement the business rule?</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor327"/>Using external services in entity methods</h2>
			<p>Sometimes, the business rule you want to apply needs to use external services. Entities cannot inject service <a id="_idIndexMarker672"/>dependencies because of technical <a id="_idIndexMarker673"/>and design restrictions. If you need to use a service in an entity method, the proper way to do this is to get that service as a parameter.</p>
			<p>Assume that we have a business rule for the event capacity: you cannot decrease the capacity to <a id="_idIndexMarker674"/>lower than the currently registered <a id="_idIndexMarker675"/>user count. A <code>null</code> capacity value means there is no registration limitation.</p>
			<p>See the following implementation on the <code>Event</code> class:</p>
			<pre>public async Task SetCapacityAsync(
    IRepository&lt;EventRegistration, Guid&gt;
        registrationRepository, int? capacity)
{
    if (capacity.HasValue)
    {
        var registeredUserCount = await 
            registrationRepository.CountAsync(x =&gt;
                x.EventId == @event.Id);
        if (capacity.Value &lt; registeredUserCount)
        {
            throw new BusinessException(
            EventHubErrorCodes
            .CapacityCanNotBeLowerThanRegisteredUserCount);
        }
    }
    this.Capacity = capacity;
}</pre>
			<p>The <code>SetCapacityAsync</code> method uses a repository object to execute a database query to get the currently registered user count. If the count is higher than the new capacity value, then it throws an exception. The <code>SetCapacityAsync</code> method is async since it <a id="_idIndexMarker676"/>performs an async database call. The <a id="_idIndexMarker677"/>client (generally an application service method) is responsible for injecting and passing the repository service to this method.</p>
			<p>The <code>SetCapacityAsync</code> method guarantees implementing the business rule because the <code>Capacity</code> property's setter is <code>private</code>, and this method is the only way to change it.</p>
			<p>You can get external services into methods as parameters, as shown in this example. However, that approach makes the entity dependent on external services, making it complicated and harder to test. It also violates the single responsibility principle and mixes the business logic of different aggregates (<code>EventRegistration</code> is another aggregate root).</p>
			<p>There is a better way to implement the business logic that depends on external services or works on multiple aggregates: domain services.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor328"/>Implementing domain services</h1>
			<p>A domain service is another class in which we implement the domain rules and constraints. Domain services are typically needed when we need to work with multiple aggregates, and the <a id="_idIndexMarker678"/>business logic doesn't properly fit into any of these aggregates. Domain services are also used when we need to consume other services and repositories since they can use the dependency injection system.</p>
			<p>Let's re-implement the <code>SetCapacityAsync</code> method (in the previous section) as a domain service method:</p>
			<pre>public class EventManager : DomainService
{
    ...
    public async Task SetCapacityAsync(Event @event, 
                                       int? capacity)
    {
        if (capacity.HasValue)
        {
            var registeredUserCount = await
                _eventRegistrationRepository.CountAsync(
                    x =&gt; x.EventId == @event.Id);
            if (capacity.Value &lt; registeredUserCount)
            {
                throw new BusinessException(
                EventHubErrorCodes.CapacityCanNotBeLower
                ThanRegisteredUserCount);
            }
        }
        @event.Capacity = capacity;
    }
}</pre>
			<p>In this case, we've injected <code>IRepository&lt;EventRegistration, Guid&gt;</code> into the <code>EventManager</code> domain service (see the source code for all the details) and got the <code>Event</code> object as a <a id="_idIndexMarker679"/>parameter. The setter of the <code>Event.Capacity</code> property is now <code>internal</code> so that it can be set only in the domain layer, in the <code>EventManager</code> class.</p>
			<p>A domain service method should be fine-grained: it should make a small (yet meaningful and consistent) change to the aggregate. The application layer then combines these small changes to perform different use cases.</p>
			<p>We will explore application services in the next chapter. However, I find it useful to show an example application service method here that updates multiple properties on an event in a single request:</p>
			<pre>public async Task UpdateAsync(Guid id, 
                              UpdateEventDto input)
{
    var @event = await _eventRepository.GetAsync(id);
O
    @event.SetTitle(input.Title);
    @event.SetTime(input.StartTime, input.EndTime);
    await _eventManager.SetCapacityAsync(@event,
                                         input.Capacity);
    @event.Language = input.Language;
    await _eventRepository.UpdateAsync(@event);
}</pre>
			<p>The <code>UpdateAsync</code> method takes a DTO that contains the properties to be updated. It first retrieves the <code>Event</code> object from the database as a single unit, then uses <code>SetTitle</code> and <code>SetTime</code> methods <a id="_idIndexMarker680"/>on the <code>Event</code> object. These methods internally validate the provided values and properly change the property values.</p>
			<p>The <code>UpdateAsync</code> method then uses the domain service method, <code>eventManager.SetCapacity</code>, to change the capacity value.</p>
			<p>We directly set the <code>Language</code> property since it has a <code>public</code> setter and no business rule (it even accepts the <code>null</code> value). Do not create setter methods if they have no business rules or constraints. Also, do not create domain service methods simply to change the entity properties without any business logic.</p>
			<p>The <code>UpdateAsync</code> method finally uses the repository to update the <code>Event</code> entity in the database.</p>
			<p class="callout-heading">Domain Service Interfaces</p>
			<p class="callout">You do not need to introduce interfaces (such as <code>IEventManager</code>) for domain services since they are essential parts of the domain and should not be abstracted. However, if you want to mock domain services in unit tests, you may still want to create interfaces.</p>
			<p>A domain service method should not update the entity as a common principle. In this example, we set the <code>Language</code> property after calling the <code>SetCapacityAsync</code> method. If <code>SetCapacityAsync</code> updates the entity, we end up with two database update operations, which would be inefficient.</p>
			<p>As another good practice, accept the entity object as the parameter (as we've done in the <code>SetCapacityAsync</code> method) rather than its <code>id</code> value. If you accept its <code>id</code> value, you need to retrieve the entity <a id="_idIndexMarker681"/>from the database inside the domain service. This approach makes the application code load the same entity multiple times in different places in the same request (use case), which is inefficient and leads to bugs. Leave that responsibility to the application layer.</p>
			<p>A specific type of domain service method is the factory method to create aggregates, explained in the <em class="italic">Using services to create aggregates</em> section. Declare factory methods only if a public constructor on the aggregate root cannot implement the business constraints. This may be the case if checking the business constraint requires the use of external services.</p>
			<p>We've used repositories in many places so far. The next section explains the implementation details of repositories.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor329"/>Implementing repositories</h1>
			<p>To remember the definition, a repository is a collection-like interface used to access the domain objects <a id="_idIndexMarker682"/>stored in the data persistence system. It hides the complexity of data access logic behind a simple abstraction.</p>
			<p>There are some main rules for implementing repositories:</p>
			<ul>
				<li>Repository interfaces are defined in the domain layer, so the domain and application layers can use them. They are implemented in the infrastructure (or database provider integration) layer.</li>
				<li>Repositories are created for aggregate root entities but not for sub-collection entities. That is because the sub-collection entities should be accessed over the aggregate root. Typically, you have a repository for each aggregate root.</li>
				<li>Repositories work with domain objects, not DTOs.</li>
				<li>In an ideal design, repository interfaces should be independent of the database provider. So, do not get or return EF Core objects, such as <code>DbContext</code> or <code>DbSet</code>.</li>
				<li>Do not implement business logic inside repository classes.</li>
			</ul>
			<p>ABP provides an implementation of the repository pattern out of the box. We explored how to use generic <a id="_idIndexMarker683"/>repositories and implement custom repositories in <a href="B17287_06_Epub_AM.xhtml#_idTextAnchor177"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with the Data Access Infrastructure</em>. Here, I will discuss a few best practices.</p>
			<p>The last rule in the preceding list, "Do not implement business logic inside repository classes," is the most important rule because the others are clear to understand. Implementing business logic inside a repository is generally a result of incorrectly considering business logic.</p>
			<p>See the following example repository interface:</p>
			<pre>public interface IEventRepository : IRepository&lt;Event,
                                                Guid&gt;
{
    Task UpdateSessionTimeAsync(
        Guid sessionId, DateTime startTime, DateTime
            endTime);
    Task&lt;List&lt;Event&gt;&gt; GetNearbyEventsAsync();
}</pre>
			<p>At first sight, there is no problem; these methods are just performing some database operations. However, the devil is in the details.</p>
			<p>The first method, <code>UpdateSessionTimeAsync</code>, changes the timing of a session in an event. If you remember, we had a business rule: a session's timing cannot overlap with another session on the same track. It also cannot overflow the event time range. If we implement that rule in the repository method, we duplicate that business validation because it was already implemented inside the <code>Event</code> aggregate. If we don't implement that validation, it is obviously a bug. In a true implementation, this logic should be done in the aggregate. The repository should only query and update the aggregate as a single unit.</p>
			<p>The second method, <code>GetNearbyEventsAsync,</code> gets a list of events in the same city with the current user. The problem with this method is the <em class="italic">current user</em> is an application layer concept and requires an active user session. Repositories should not work with the current <a id="_idIndexMarker684"/>user. What if we want to reuse the same <em class="italic">nearby</em> logic in a background service where we don't have the current user in the current context? It is better to pass the city, date range, and other parameters to the method, so it simply brings the events. Entity properties are just values for the repositories. Repositories should not have any domain knowledge and should not use application layer features.</p>
			<p>Repositories are fundamentally used to create, update, delete, and query entities. ABP's generic repository implementation provides most of the common operations out of the box. It also provides an <code>IQueryable</code> object that you can use to build and execute queries using LINQ. However, building complex queries at the application layer mixes your application logic with the data querying logic that should ideally be at the infrastructure layer.</p>
			<p>See the following example method, which uses <code>IRepository&lt;Event, Guid&gt;</code> to get a l<a id="_idTextAnchor330"/>ist of events that a given user has spoken at:</p>
			<pre>public async Task&lt;List&lt;Event&gt;&gt; GetSpokenEventsAsync(Guid
                                                    userId)
{
    var queryable = 
        await _eventRepository.GetQueryableAsync();
    var query = queryable.Where(x =&gt; x.Tracks
        .Any(track =&gt; track.Sessions
          .Any(session =&gt; session.Speakers
            .Any(speaker =&gt; speaker.UserId == userId))));
    return await AsyncExecuter.ToListAsync(query);
}</pre>
			<p>In the first line, we are obtaining an <code>IQueryable&lt;Event&gt;</code> object. Then we are using the <code>Where</code> method to filter the events. Finally, we are executing the query to get the event list. </p>
			<p>The problem with writing such queries into application services is leaking querying logic to the application <a id="_idIndexMarker685"/>layer and making it impossible to reuse the querying logic when we need it somewhere else. To overcome the problem, we generally create a custom repository method to query the events:</p>
			<pre>public interface IEventRepository : IRepository&lt;Event,
                                                Guid&gt;
{
    Task&lt;List&lt;Event&gt;&gt; GetSpokenEventsAsync(Guid userId);
}</pre>
			<p>Now, we can use this custom repository method anywhere we need to get the events at which a user was a speaker.</p>
			<p>Creating custom repository methods is a good approach. But, with this approach, we have a lot of similar methods once the application grows. Assume that we wanted to get the event list in a specified date range, and we've added one more method:</p>
			<pre>public interface IEventRepository : IRepository&lt;Event,
                                                Guid&gt;
{
    Task&lt;List&lt;Event&gt;&gt; GetSpokenEventsAsync(Guid userId);
    Task&lt;List&lt;Event&gt;&gt; GetEventsByDateRangeAsync(DateTime
        minDate, DateTime maxDate);
}</pre>
			<p>What if we want to query the events with a date range and speaker filter? Create another method as shown in the following code block: </p>
			<pre>Task&lt;List&lt;Event&gt;&gt; GetSpokenEventsByDateRangeAsync(Guid userId, DateTime minDate, DateTime maxDate)</pre>
			<p>Actually, ABP provides the <code>GetListAsync</code> method, which takes an expression. So, we could remove all <a id="_idIndexMarker686"/>these methods and use the <code>GetListAsync</code> method with an arbitrary predicate.</p>
			<p>The following example uses the <code>GetListAsync</code> method to get a list of events at which a user is a speaker in the next 30 days:</p>
			<pre>public async Task&lt;List&lt;Event&gt;&gt; GetSpokenEventsAsync(Guid
                                                    userId)
{
    var startTime = Clock.Now;
    var endTime = Clock.Now.AddDays(30);
    return await _eventRepository.GetListAsync(x =&gt;
        x.Tracks
        .Any(track =&gt; track.Sessions
            .Any(session =&gt; session.Speakers
                .Any(speaker =&gt; speaker.UserId == userId)))
        &amp;&amp; x.StartTime &gt; startTime &amp;&amp; x.StartTime &lt;= 
            endTime    
    );
}</pre>
			<p>However, we've returned to the previous problem: mixing the querying complexity with the application code. Also, isn't the query getting hard to understand? You know, in real life, we have queries with much more complexity.</p>
			<p>Completely getting rid of complex queries may not be possible, but the next section offers an interesting solution to that problem: the specification pattern!</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor331"/>Building specifications</h1>
			<p>A specification is a named, reusable, combinable, and testable class to filter domain objects based on <a id="_idIndexMarker687"/>business rules. In practice, we can easily encapsulate filter expressions as reusable objects.</p>
			<p>In this section, we will begin with the most simple, parameterless specifications. We will then see more complex, parameterized specifications. Finally, we will learn how to combine multiple specifications to create a more complex specification.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor332"/>Parameterless specifications</h2>
			<p>Let's begin <a id="_idIndexMarker688"/>with a very simple specification <a id="_idIndexMarker689"/>class:</p>
			<pre>public class OnlineEventSpecification :
    Specification&lt;Event&gt;
{
    public override Expression&lt;Func&lt;Event, bool&gt;&gt;
        ToExpression()
    {
        return x =&gt; x.IsOnline == true;
    }
}</pre>
			<p><code>OnlineEventSpecification</code> is used to filter online events, which means it selects an event if it is an online event. It is derived from the base <code>Specification&lt;T&gt;</code> class provided by ABP Framework to create specification classes easily. We override the <code>ToExpression</code> method to filter the event objects. This method should return a lambda expression that returns <code>true</code> if the given <code>Event</code> entity (here, the <code>x</code> object) satisfies the condition (we could simply write <code>return x =&gt; x.IsOnline</code>).</p>
			<p>Now, if we want to get a list of online events, we can just use the repository's <code>GetListAsync</code> method with a specification object:</p>
			<pre>var events = _eventRepository
    .GetListAsync(new OnlineEventSpecification());</pre>
			<p>Specifications are <a id="_idIndexMarker690"/>implicitly converted to <a id="_idIndexMarker691"/>expressions (remember, the <code>GetListAsync</code> method can get an expression). If you want to explicitly convert them, you can call the <code>ToExpression</code> method:</p>
			<pre>var events = _eventRepository
    .GetListAsync(
        new OnlineEventSpecification().ToExpression());</pre>
			<p>So, we can use a specification wherever we can use an expression. In this way, we can encapsulate expressions as named, reusable objects.</p>
			<p>The <code>Specification</code> class provides another method, <code>IsSatisfiedBy</code>, to test a single object. If you have an <code>Event</code> object, you can easily check whether it is an online event or not:</p>
			<pre>Event evnt = GetEvent();
if (new OnlineEventSpecification().IsSatisfiedBy(evnt))
{
    // ...
}</pre>
			<p>In this example, we have somehow obtained an <code>Event</code> object, and we want to check whether it is online. <code>IsSatisfiedBy</code> gets an <code>Event</code> object and returns <code>true</code> if that object satisfies the condition. I accept that this example seems absurd because we could simply write <code>if(evnt.IsOnline)</code>. Such a simple specification was not necessary. However, in the next section, we will see more complex examples to make it much clearer.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor333"/>Parameterized specifications</h2>
			<p>Specifications can <a id="_idIndexMarker692"/>have parameters to be us<a id="_idTextAnchor334"/>ed in <a id="_idIndexMarker693"/>filtering expressions. See the following example:</p>
			<pre>public class SpeakerSpecification : Specification&lt;Event&gt;
{
    public Guid UserId { get; }
    public SpeakerSpecification(Guid userId)
    {
        UserId = userId;
    }
    
    public override Expression&lt;Func&lt;Event, bool&gt;&gt;
        ToExpression()
    {
        return x =&gt; x.Tracks
            .Any(t =&gt; t.Sessions
                .Any(s =&gt; s.Speakers
                    .Any(sp =&gt; sp.UserId == UserId)));
    }
}</pre>
			<p>We've created a <a id="_idIndexMarker694"/>parameterized specification class <a id="_idIndexMarker695"/>that checks whether the given user is a speaker at an event. Once we have that specification class, we can filter the events as shown in the following code block:</p>
			<pre>public async Task&lt;List&lt;Event&gt;&gt; GetSpokenEventsAsync(Guid
                                                    userId)
{
    return await _eventRepository.GetListAsync(
        new SpeakerSpecification(userId));
}</pre>
			<p>Here, we've just reused the <code>GetListAsync</code> method of the repository by providing a new <code>SpeakerSpecification</code> object. From now on, we can reuse this specification class if we need the <a id="_idIndexMarker696"/>same expression later, in another <a id="_idIndexMarker697"/>place in our application, without needing to copy/paste the expression. If we need to change the condition later, all those places will use the updated expression.</p>
			<p>If we need to check whether a user is a speaker at the given <code>Event</code>, we can reuse the <code>SpeakerSpecification</code> class by calling its <code>IsSatisfiedBy</code> method:</p>
			<pre>Event evnt = GetEvent();
if (new SpeakerSpecification(userId).IsSatisfiedBy(evnt))
{
    // ...
}</pre>
			<p>Specifications are powerful to create named and reusable filters, but they have another power too: combining specifications to create a composite specification object.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor335"/>Combining specifications</h2>
			<p>It is possible to combine <a id="_idIndexMarker698"/>multiple specifications using operator-like <code>And</code>, <code>Or</code>, and <code>AndNot</code> methods, or to reverse a specification with the <code>Not</code> method.</p>
			<p>Assume that I want to find the events where a given user is a speaker, and the event is online:</p>
			<pre>var events = _eventRepository.GetListAsync(
    new SpeakerSpecification(userId)
        .And(new OnlineEventSpecification())
        .ToExpression()
);</pre>
			<p>In this example, I combined <code>SpeakerSpecification</code> and <code>OnlineEventSpecification</code> objects to create a composite specification object. Explicitly calling the <code>ToExpression</code> class is necessary in this case because C# doesn't support implicitly converting from interfaces (the <code>And</code> method returns an <code>ISpecification&lt;T&gt;</code> reference).</p>
			<p>The following <a id="_idIndexMarker699"/>example finds the in-person (offline) events in the next 30 days where the given user is a speaker:</p>
			<pre>var events = _eventRepository.GetListAsync(
    new SpeakerSpecification(userId)
        .And(new DateRangeSpecification(Clock.Now,
             Clock.Now.AddDays(30)))
        .AndNot(new OnlineEventSpecification())
        .ToExpression()
);</pre>
			<p>In this example, we've reversed the <code>OnlineEventSpecification</code> object's filtering logic with the <code>AndNot</code> method. We've also used a <code>DateRangeSpecification</code> object that we haven't defined yet. It is a good exercise for you to implement yourself.</p>
			<p>An interesting example could be extending the <code>AndSpecification</code> class to create a specification class that combines two specifications:</p>
			<pre>public class OnlineSpeakerSpecification : 
    AndSpecification&lt;Event&gt;
{
    public OnlineSpeakerSpecification(Guid userId)
        : base(new SpeakerSpecification(userId),
               new OnlineEventSpecification())
    {
    }
}</pre>
			<p>The <code>OnlineSpeakerSpecification</code> class in this example combines the <code>SpeakerSpecification</code> class <a id="_idIndexMarker700"/>and the <code>OnlineEventSpecification</code> class, and can be used whenever you want to use a specification object.</p>
			<p class="callout-heading">When to Use Specifications</p>
			<p class="callout">Specifications are especially useful if they filter objects based on domain rules that can be changed in the future, so you don't want to duplicate them everywhere. You do not need to define specifications for the expressions you are using just for reporting purposes.</p>
			<p>The next section explains how to use domain events to publish notifications.</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor336"/>Publishing domain events</h1>
			<p>Domain events are <a id="_idIndexMarker701"/>used to inform other components and services about an important change to a domain object so that they can take action.</p>
			<p>ABP Framework provides two types of event buses to publish domain events, each with a different purpose:</p>
			<ul>
				<li>The <strong class="bold">local event bus</strong> is used to <a id="_idIndexMarker702"/>notify the handlers in the same process.</li>
				<li>The <strong class="bold">distributed event bus</strong> is used to <a id="_idIndexMarker703"/>notify the handlers in the same or different processes.</li>
			</ul>
			<p>Publishing and handling events are pretty easy with ABP Framework. The next section shows how to work with the local event bus, and then we will look at the distributed event bus.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor337"/>Using the local event bus</h2>
			<p>A local event handler is executed in the same unit of work (in the same local database transaction). If you are <a id="_idIndexMarker704"/>building a monolith application or want to handle events in the same service, the local event bus is fast and safe to use because it works in the same process.</p>
			<p>Assume that you want to publish a local event when an event's time changes, and you have an event handler that sends emails to the registered users about the change.</p>
			<p>See the simplified <a id="_idIndexMarker705"/>implementation of the <code>SetTime</code> method of the <code>Event</code> class:</p>
			<pre>public void SetTime(DateTime startTime, DateTime endTime)
{
    if (startTime &gt; endTime)
    {
        throw new BusinessException(EventHubErrorCodes     
            .EndTimeCantBeEarlierThanStartTime);
    }
    StartTime = startTime;
    EndTime = endTime;
    if (!IsDraft)
    {
        AddLocalEvent(new EventTimeChangedEventData(this));
    }
}</pre>
			<p>In this example, we are adding a local event, which will be published while updating the entity. ABP Framework overrides EF Core's <code>SaveChangesAsync</code> method to publish the events (for MongoDB, it is done in the repository's <code>UpdateAsync</code> method).</p>
			<p>Here, <code>EventTimeChangedEventData</code> is a plain class that holds the event data:</p>
			<pre>public class EventTimeChangedEventData
{
    public Event Event { get; }
    public EventTimeChangedEventData(Event @event)
    {
        Event = @event;
    }
}</pre>
			<p>Published events can be handled by creating a class that implements the <code>ILocalEventHandler&lt;TEventData&gt;</code> interface:</p>
			<pre>public class UserEmailingHandler :
    ILocalEventHandler&lt;EventTimeChangedEventData&gt;,
    ITransientDependency
{
    public async Task HandleEventAsync(
        EventTimeChangedEventData eventData)
    {
        var @event = eventData.Event;
        // TODO: Send email to the registered users!
    }
}</pre>
			<p>The <code>UserEmailingHandler</code> class can inject any service (or repository) to get a list of the registered users, and then send an email to inform them about the time change. You may have multiple <a id="_idIndexMarker706"/>handlers for the same event. If any handler throws an exception, the main database transaction is rolled back since the event handler is executed in the same database transaction.</p>
			<p>Events can be published in entities, as shown in the previous examples. They can also be published using the <code>ILocalEventBus</code> service.</p>
			<p>Let's assume that we don't publish the <code>EventTimeChangedEventData</code> event inside the <code>Event</code> class but want to publish it in an arbitrary class that can utilize the dependency injection system. See the following example application service:</p>
			<pre>public class EventAppService : EventHubAppService, 
    IEventAppService
{
    private readonly IRepository&lt;Event, Guid&gt; 
        _eventRepository;
    private readonly ILocalEventBus _localEventBus;
    public EventAppService(
        IRepository&lt;Event, Guid&gt; eventRepository,
        ILocalEventBus localEventBus)
    {
        _eventRepository = eventRepository;
        _localEventBus = localEventBus;
    }
    public async Task SetTimeAsync(
        Guid eventId, DateTime startTime, DateTime endTime)
    {
        var @event = 
            await _eventRepository.GetAsync(eventId);
        @event.SetTime(startTime, endTime);
        await _eventRepository.UpdateAsync(@event);
        await _localEventBus.PublishAsync(
            new EventTimeChangedEventData(@event));
    }
}</pre>
			<p>The <code>EventAppService</code> class injects the repository and <code>ILocalEventBus</code> service. In the <code>SetTimeAsync</code> method, we are using the local event bus to publish the same event.</p>
			<p>The <code>PublishAsync</code> method of the <code>ILocalEventBus</code> service immediately executes the event handlers. If any event handler throws an exception, you directly get the exception since the <code>PublishAsync</code> method doesn't handle exceptions. So, if you don't catch the exception, the whole unit of work is rolled back. </p>
			<p>It is better to publish the events in the entities or the domain services. If we publish the <code>EventTimeChangedEventData</code> event in the <code>Event</code> class's <code>SetTime</code> method, it is guaranteed to publish the event in any case. However, if we publish it in an application service, like in the last <a id="_idIndexMarker707"/>example, we may forget to publish the event in another place that changes the event times. Even if we don't forget, we will have duplicated code that is harder to maintain and open to potential bugs.</p>
			<p>Local events are especially useful to implement side-effects such as taking extra action when the state of an object changes. It is perfect for de-coupling and integrating different aspects of the system. In this section, we have used it to send a notification email to the registered users when an event's time changes. However, it should not be misused by distributing business logic flow into event handlers and making the whole process hard to follow.</p>
			<p>In the next section, we will see the second type of event bus.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor338"/>Using the distributed event bus</h2>
			<p>In the distributed event bus, an event is published through a message broker service, such as RabbitMQ or <a id="_idIndexMarker708"/>Kafka. If you are building a microservice/distributed solution, the distributed event bus can asynchronously notify the handlers in other services.</p>
			<p>Using the distributed event bus is pretty similar to the local event bus, but it is important to understand the differences and limitations.</p>
			<p>Let's assume that we want to publish a distributed event in the <code>Event</code> class's <code>SetTime</code> method when the event's time changes:</p>
			<pre>public void SetTime(DateTime startTime, DateTime endTime)
{
    if (startTime &gt; endTime)
    {
        throw new BusinessException(EventHubErrorCodes 
            .EndTimeCantBeEarlierThanStartTime);
    }
    StartTime = startTime;
    EndTime = endTime;
    if (!IsDraft)
    {
        AddDistributedEvent(new EventTimeChangedEto
        {
            EventId = Id, Title = Title,
            StartTime = StartTime, EndTime = EndTime
        });
    }
}</pre>
			<p>Here, we call the <code>AddDistributedEvent</code> method to publish the event (it is published when the entity is updated in the database). As an important difference from the local event, we are not passing the entity (<code>this</code>) object as the event data but copying some properties <a id="_idIndexMarker709"/>to a new object. That new object will be transferred between processes. It will be serialized in the current process and deserialized in the target process (ABP Framework handles the serialization and deserialization for you). So, creating a DTO-like object that carries only the required properties rather than the full object is better. The <strong class="bold">Eto</strong> (<strong class="bold">Event Transfer Object</strong>) suffix is the <a id="_idIndexMarker710"/>naming convention that we suggest but it is not necessary to use it.</p>
			<p>The <code>AddDistributedEvent</code> (and <code>AddLocalEvent</code>) method is only available in the aggregate root entities, not for sub-collection entities. However, publishing a distributed event in an arbitrary service is still possible using the <code>IDistributedEventBus</code> service:</p>
			<pre>await _distributedEventBus.PublishAsync(
    new EventTimeChangedEto
    {
        EventId = @event.Id,
        Title = @event.Title,
        StartTime = @event.StartTime,
        EndTime = @event.EndTime
    });</pre>
			<p>Inject the <code>IDistributedEventBus</code> service and use the <code>PublishAsync</code> method – that's all.</p>
			<p>The application/service <a id="_idIndexMarker711"/>that wants to get notified can create a class that implements the <code>IDistributedEventHandler&lt;T&gt;</code> interface, as shown in the following code block:</p>
			<pre>public class UserEmailingHandler :
    IDistributedEventHandler&lt;EventTimeChangedEto&gt;,
    ITransientDependency
{
    public Task HandleEventAsync(EventTimeChangedEto 
                                 eventData)
    {
        var eventId = eventData.EventId;
        // TODO: Send email to the registered users! 
    }
}</pre>
			<p>The event handler can use all the properties of the <code>EventTimeChangedEto</code> class. If it needs more data, you <a id="_idIndexMarker712"/>can add it to the <code>ETO</code> class. Alternatively, you can query the details from the database or perform an API call to the corresponding service in a distributed scenario.</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor339"/>Summary</h1>
			<p>This chapter covered the first part of implementing DDD. We've explored the domain layer building blocks and understood their design and implementation practices using ABP Framework.</p>
			<p>The aggregate is the most fundamental DDD building block, and the way we change an aggregate's state is very important and needs care. An aggregate should preserve its validity and consistency by implementing business rules. It is essential to draw aggregate boundaries correctly.</p>
			<p>On the other hand, domain services are useful for implementing the domain logic that touches multiple aggregates or external services. They work with the domain objects, not DTOs.</p>
			<p>The repository pattern abstracts the data access logic and provides an easy-to-use interface to other services in the domain and application layers. It is important not to leak your business logic into repositories. The specification pattern is a way to encapsulate data filtering logic. You can reuse and combine them when you want to select business objects.</p>
			<p>Finally, we explored how we can publish and subscribe to domain events with ABP Framework. Domain events are used to react to changes to domain objects in a loosely coupled way.</p>
			<p>The next chapter will continue with the building blocks, this time in the application layer. It will also discuss the differences between the domain and application layers with practical examples.</p>
		</div>
	</body></html>