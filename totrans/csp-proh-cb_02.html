<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Classes and Generics"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Classes and Generics</h1></div></div></div><p>Classes form the building blocks of software development and are essential in building good code. In this chapter, we will be looking at classes and generics and why we need to use them. The recipes we will be covering are going to be as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating and implementing an abstract class</li><li class="listitem" style="list-style-type: disc">Creating and implementing an interface</li><li class="listitem" style="list-style-type: disc">Creating and using a generic class or method</li><li class="listitem" style="list-style-type: disc">Creating and using a generic interface</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Introduction</h1></div></div></div><p>As you probably know, classes are simply containers for related methods and properties to describe some object in your software. An object is an instance of a specific class and, sometimes, mimics real-world things. When thinking of a car, you might create a vehicle class that contains certain attributes (properties) that all vehicles contain, such as automatic or manual transmission, wheel count (not all vehicles have only four wheels), or fuel type.</p><p>When we create an instance of the vehicle class, we can create a car object, an SUV object, and so on. Here lies the power of classes, which is to describe the world around us and translate it into a programming language that a compiler can understand.</p></div></div>
<div class="section" title="Creating and implementing an abstract class"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Creating and implementing an abstract class</h1></div></div></div><p>Many developers have heard about<a class="indexterm" id="id73"/> abstract classes, but their implementation is a mystery. How can <a class="indexterm" id="id74"/>you as a developer identify an abstract class and decide when to use one? The definition is quite a simple one actually. Once you understand this fundamental definition of an abstract class, when and why to use one becomes obvious.</p><p>Imagine for a moment that you are developing an application that manages the animals in a cat sanctuary. The cat sanctuary rehabilitates lions, tigers, jaguars, leopards, cheetahs, pumas, and even domestic cats. The common noun that describes all these animals is the word <span class="emphasis"><em>cat</em></span>. You can, therefore, safely assume that the abstraction of all these animals is a cat, and thus, this word identifies our abstract class. You would then create an abstract class called <code class="literal">Cat</code>.</p><p>However, you need to<a class="indexterm" id="id75"/> keep in mind that you will never ever create an instance of the abstract class <code class="literal">Cat</code>. All the classes that inherit from the abstract class also share some functionality. This means that you will create a <code class="literal">Lion</code> class and a <code class="literal">Tiger</code> class that inherit from the abstract class <code class="literal">Cat</code>. In other words, the inherited classes are a kind of cat. Both classes share functionality in the form of <code class="literal">Sleep()</code>, <code class="literal">Eat()</code>, <code class="literal">Hunt()</code>, and various other methods. In this way, we can ensure that inherited classes all contain this common functionality.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>Getting ready</h2></div></div></div><p>Let's go ahead and create our abstract class for cat. We will then use it to inherit from and create other objects to define<a class="indexterm" id="id76"/> different types of cats.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the Visual Studio <span class="strong"><strong>Solution Explorer</strong></span>, right-click on the solution, click on <span class="strong"><strong>Add</strong></span>, and then click on <span class="strong"><strong>New Project</strong></span>. Select <span class="strong"><strong>Class Library</strong></span> option to add a new class library project to your solution and call it <code class="literal">Chapter2</code>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_01.jpg"/></div></li><li class="listitem">A class library project <a class="indexterm" id="id77"/>called <code class="literal">Chapter2</code> is added to your solution. Go<a class="indexterm" id="id78"/> ahead and right-click on the default class called <code class="literal">Class1.cs</code> that was added to your <code class="literal">Chapter2</code> project and rename it to <code class="literal">Recipes.cs</code>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_02.jpg"/></div></li><li class="listitem">Once you have<a class="indexterm" id="id79"/> done this, your code should resemble the following code<a class="indexterm" id="id80"/> listing. You can see that the default class has been renamed to <code class="literal">Recipes</code> and that it exists in the <code class="literal">Chapter2</code> namespace:<div class="informalexample"><pre class="programlisting">namespace Chapter2
{
    public class Recipes
    {
    }
}</pre></div></li><li class="listitem">We will now change the default class <code class="literal">Recipes</code> to an abstract class called <code class="literal">Cat</code>. To do this, add the <code class="literal">abstract</code> keyword to the class and change the name from <code class="literal">Recipes</code> to <code class="literal">Cat</code>. We are now ready to describe the <code class="literal">Cat</code> abstract class:<div class="informalexample"><pre class="programlisting">namespace Chapter2
{
    public abstract class Cat
    {
    }
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The <code class="literal">abstract</code> keyword indicates to us that the object it is applied to has no implementation. When used in a class declaration, it basically tells the compiler that the class is to be used as a base class. This means that no instance of the class can be<a class="indexterm" id="id81"/> created. The only way in which implementation of the abstract class happens is when it is implemented by derived classes that inherit from the base class.</p></div></div></li><li class="listitem">Add three methods to<a class="indexterm" id="id82"/> the abstract class called <code class="literal">Eat()</code>, <code class="literal">Hunt()</code>, and <code class="literal">Sleep()</code>. You will notice that these methods don't contain a body (curly braces). This is because they have been defined as abstract. As with abstract classes, the abstract methods contained within the abstract class contain no implementation. These three methods basically describe functionality that is common to all cats. All cats must eat, hunt, and sleep. Therefore, to ensure that all classes that inherit from the <code class="literal">Cat</code> abstract class contain this functionality, it is added to the abstract class. These methods are then implemented in the derived classes, which we will see in the upcoming steps:<div class="informalexample"><pre class="programlisting">    public abstract class Cat
    {
        public abstract void Eat();
        public abstract void Hunt();
        public abstract void Sleep();
    }</pre></div></li><li class="listitem">We want to define two types of cat. The first type of cat we want to define is a lion. For this, we create a <code class="literal">Lion</code> class:<div class="informalexample"><pre class="programlisting">public class Lion
{

}</pre></div></li><li class="listitem">At this point in time, the <code class="literal">Lion</code> class is simply an ordinary class and does not contain any common functionality defined in the <code class="literal">Cat</code> abstract class. To inherit from the <code class="literal">Cat</code> abstract class, we need to add <code class="literal">: Cat</code> after the <code class="literal">Lion</code> class name. The <a class="indexterm" id="id83"/>colon indicates that the <code class="literal">Lion</code> class inherits from the <code class="literal">Cat</code> abstract class. The <code class="literal">Lion</code> class is therefore a derived class of the <code class="literal">Cat</code> abstract class:<div class="informalexample"><pre class="programlisting">public class Lion : Cat
{

}</pre></div><p>As soon as you specify that the <code class="literal">Lion</code> class inherits from the <code class="literal">Cat</code> class, Visual Studio will show you an error. This is expected, because we have told the compiler that the <code class="literal">Lion</code> class needs to inherit all the features of the <code class="literal">Cat</code> abstract class, but we have not actually added these features to the <code class="literal">Lion</code> class. The derived class is said to override the methods in the abstract class, and needs to specifically be written with the <code class="literal">override</code> keyword.</p></li><li class="listitem">If you hover over the<a class="indexterm" id="id84"/> red squiggly line underlining the <code class="literal">Lion</code> class, Visual Studio will offer an explanation for the error via the lightbulb feature. As you can see, Visual Studio is telling you that while you have defined the class to be inheriting from the abstract class, you have not implemented any of the abstract members of the <code class="literal">Cat</code> class:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_03.jpg"/></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>You can, therefore, see that using abstract classes is a fantastic way to enforce specific functionality within your system. If you define abstract members in an abstract class, the derived classes that inherit from that abstract class must implement those members; otherwise, your code will not compile. This can be used to enforce standards and practices adopted by your company, or to simply allow other developers to implement certain best practices as they use your base class for their derived classes. With the advent of the Visual Studio 2015 feature code analyzers, this can ensure a consistent development effort by the team.</p></div></div></li><li class="listitem">To implement these <a class="indexterm" id="id85"/>members that Visual Studio is warning us about, place your mouse cursor on the <code class="literal">Lion</code> class name and hit <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>. </em></span>(period). You can also click on the <span class="strong"><strong>Show potential fixes</strong></span> link in the lightbulb popup. Visual Studio will give you a small heads up, displaying the changes it will make to your code. You can preview these changes by clicking on the <span class="strong"><strong>Preview changes</strong></span> link, as well as fix all occurrences in the document, project, or solution by clicking on the appropriate link:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_04.jpg"/></div><p>After Visual Studio has added the changes displayed in the suggestions window, your <code class="literal">Lion</code> class will be correct and will look like the code listed in the following step.</p></li><li class="listitem">You will notice that Visual <a class="indexterm" id="id86"/>Studio automatically adds a <code class="literal">NotImplementedException</code> exception with the following line of code in each overridden<a class="indexterm" id="id87"/> method: <code class="literal">throw new NotImplementedException();</code>:<div class="informalexample"><pre class="programlisting">public class Lion : Cat
{
    public override void Eat()
    {
        throw new NotImplementedException();
    }

    public override void Hunt()
    {
        throw new NotImplementedException();
    }

    public override void Sleep()
    {
        throw new NotImplementedException();
    }
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>This is the default behavior of Visual Studio when overriding methods in the base class. Basically, if you had to instantiate the <code class="literal">Lion</code> class without writing any implementation in the overridden methods, a runtime exception would be generated. The idea of inheriting from our abstract class was to extend it and implement common functionality. This is where we need to implement that functionality, and this is the reason there is no implementation in the abstract class. The abstract class just tells us that the following methods need to be implemented. The derived class does the actual implementation.</p></div></div></li><li class="listitem">Go ahead and add some implementation to the overridden methods of the <code class="literal">Lion</code> class. First, add the <code class="literal">using static</code> statement for the <code class="literal">Console.WriteLine</code> method to the top of your class file:<div class="informalexample"><pre class="programlisting">using static System.Console;</pre></div></li><li class="listitem">Then, add the implemented code for the methods, as follows:<div class="informalexample"><pre class="programlisting">public override void Eat()
{
    WriteLine($"The {LionColor} lion eats.");
}

public override void Hunt()
{
    WriteLine($"The {LionColor} lion hunts.");
}

public override void Sleep()
{
    WriteLine($"The {LionColor} lion sleeps.");
}</pre></div></li><li class="listitem">Next, we will <a class="indexterm" id="id88"/>create another class called <code class="literal">Tiger</code> that also derives from<a class="indexterm" id="id89"/> the abstract class <code class="literal">Cat</code>. Follow step 7 to step 12 to create the <code class="literal">Tiger</code> class and inherit the <code class="literal">Cat</code> abstract class:<div class="informalexample"><pre class="programlisting">public class Tiger : Cat
{
    public override void Eat()
    {
        throw new NotImplementedException();
    }

    public override void Hunt()
    {
        throw new NotImplementedException();
    }

    public override void Sleep()
    {
        throw new NotImplementedException();
    }
}</pre></div></li><li class="listitem">Add the same implementation for the <code class="literal">Tiger</code> class, as follows:<div class="informalexample"><pre class="programlisting">public override void Eat()
{
    WriteLine($"The {TigerColor} tiger eats.");
}

public override void Hunt()
{
    WriteLine($"The {TigerColor} tiger hunts.");
}

public override void Sleep()
{
    WriteLine($"The {TigerColor} tiger sleeps.");
}</pre></div></li><li class="listitem">For our <code class="literal">Lion</code> class, add an enumerator for <code class="literal">ColorSpectrum</code> and a property called <code class="literal">LionColor</code>. It is here that the implementations of the <code class="literal">Lion</code> and <code class="literal">Tiger</code> classes will differ. While<a class="indexterm" id="id90"/> they both must implement the common functionality specified in the abstract class, namely <code class="literal">Eat()</code>, <code class="literal">Hunt()</code>, and <code class="literal">Sleep()</code>, only the lion can have a color of either brown or white in its available range of colors:<div class="informalexample"><pre class="programlisting">public enum ColorSpectrum { Brown, White }
public string LionColor { get; set; }</pre></div></li><li class="listitem">Next, add the <code class="literal">Lion()</code> constructor in our <code class="literal">Lion</code> class. This will allow us to specify a color for the lions in the cat sanctuary. The constructor also takes as parameter a variable of the <code class="literal">ColorSpectrum</code> enumerator type:<div class="informalexample"><pre class="programlisting">public Lion(ColorSpectrum color)
{
    LionColor = color.ToString();
}</pre></div></li><li class="listitem">Slightly similar to this, but quite <a class="indexterm" id="id91"/>different in color, the <code class="literal">Tiger</code> class can only have a <code class="literal">ColorSpectrum</code> enumeration that defines tigers as being orange, white, gold, blue (yes, you actually get a blue tiger), or black. Add the <code class="literal">ColorSpectrum</code> enumerator to the <code class="literal">Tiger</code> class, as well as a property called <code class="literal">TigerColor</code>:<div class="informalexample"><pre class="programlisting">public enum ColorSpectrum { Orange, White, Gold, Blue, Black }
public string TigerColor { get; set; }</pre></div></li><li class="listitem">Finally, we will create a <code class="literal">Tiger()</code> constructor for our <code class="literal">Tiger</code> class to set the colors of tigers in the cat sanctuary to the valid colors that tigers are found in. By doing this, we are separating certain functionality specific only to tigers and lions in their respective classes, while all the common functionality is contained in the abstract class <code class="literal">Cat</code>:<div class="informalexample"><pre class="programlisting">public Tiger(ColorSpectrum color)
{
    TigerColor = color.ToString();
}</pre></div></li><li class="listitem">To see the class in action, we first need to add a reference to our <code class="literal">Chapter2.cs</code> class file. Right-click on <span class="strong"><strong>References</strong></span> in the console application project:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_05.jpg"/></div></li><li class="listitem">The <span class="strong"><strong>Reference Manager</strong></span> window<a class="indexterm" id="id92"/> will open for the <code class="literal">CodeSamples</code> project. Select <code class="literal">Chapter2</code> and<a class="indexterm" id="id93"/> click on the <span class="strong"><strong>OK</strong></span> button. Then, add the <code class="literal">using Chapter2;</code> statement:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_06.jpg"/></div></li><li class="listitem">We now need to<a class="indexterm" id="id94"/> instantiate the <code class="literal">Lion</code> and <code class="literal">Tiger</code> classes. You<a class="indexterm" id="id95"/> will see that we set the respective cat's color from the constructor:<div class="informalexample"><pre class="programlisting">Lion lion = new Lion(Lion.ColorSpectrum.White);
lion.Hunt();
lion.Eat();
lion.Sleep();

Tiger tiger = new Tiger(Tiger.ColorSpectrum.Blue);
tiger.Hunt();
tiger.Eat();
tiger.Sleep();

Console.ReadLine();</pre></div></li><li class="listitem">When you run your console application, you see that the methods are called in sequence:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_07.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>How it works…</h2></div></div></div><p>While the example illustrated earlier is a rather simplistic one, the theory is sound. The abstract class takes <a class="indexterm" id="id96"/>collective functionality across all cats and groups so that it can be shared inside each derived class. No implementation exists in the abstract class; it only defines what needs to happen. Think of abstract classes as a type of blueprint for classes<a class="indexterm" id="id97"/> that inherit from the abstract class.</p><p>While the content of the implementation is up to you, the abstract class requires that you add the abstract methods it defines. From here on, you can create a solid foundation for similar classes in your applications that are supposed to share functionality. This is the goal of inheritance. Let's recap the features of an abstract class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can't instantiate an abstract class with the <code class="literal">new</code> keyword.</li><li class="listitem" style="list-style-type: disc">You can only add abstract methods and accessors to an abstract class.</li><li class="listitem" style="list-style-type: disc">You can never modify an abstract class as <code class="literal">sealed</code>. The <code class="literal">sealed</code> modifiers prevents inheritance, while abstract requires inheritance.</li><li class="listitem" style="list-style-type: disc">Any class derived from your abstract class must include the implementations of the abstract methods that were inherited from the abstract class.</li><li class="listitem" style="list-style-type: disc">Because abstract methods inside the abstract class have no implementation, they don't contain a body either.</li></ul></div></div></div>
<div class="section" title="Creating and implementing an interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Creating and implementing an interface</h1></div></div></div><p>For many developers, interfaces are confusing and their purpose not clearly understood. Interfaces are<a class="indexterm" id="id98"/> actually quite easy to get to grips with once you understand the concept that defines an interface.</p><p>Interfaces act like verbs. So, for example, if we had to create two classes called <code class="literal">Lion</code> and <code class="literal">Tiger</code> that derive from the <code class="literal">Cat</code> abstract class, the interface would describe some sort of action. Lions and tigers can<a class="indexterm" id="id99"/> roar (but not purr). We can then create an interface called <code class="literal">IRoarable</code>. If we had to derive a class called <code class="literal">Cheetah</code> from our abstract class <code class="literal">Cat</code>, we would not be able to use the <code class="literal">IRoarable</code> interface, because cheetahs purr. We would need to create an <code class="literal">IPurrable</code> interface.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>Getting ready</h2></div></div></div><p>Creating an interface is very similar to creating an abstract class. The difference is that the interface is describing what the class can do, in the case of the <code class="literal">Cheetah</code> class, by implementing <code class="literal">IPurrable</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If you haven't already done so in the previous recipe, create an abstract class called <code class="literal">Cat</code>:<div class="informalexample"><pre class="programlisting">public abstract class Cat
{
    public abstract void Eat();
    public abstract void Hunt();
    public abstract void Sleep();
}</pre></div></li><li class="listitem">Next, add a class called <code class="literal">Cheetah</code> that inherits from the <code class="literal">Cat</code> abstract class:<div class="informalexample"><pre class="programlisting">public class Cheetah : Cat
{
    
}</pre></div></li><li class="listitem">As soon as you inherit from the <code class="literal">Cat</code> abstract class, Visual Studio will show you a warning via the lightbulb feature. As you inherited from the abstract class <code class="literal">Cat</code>, you have to implement the abstract members within the abstract class in your derived class <code class="literal">Cheetah</code>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_08.jpg"/></div></li><li class="listitem">This is easily fixable by typing <span class="emphasis"><em>Ctrl</em></span> +<span class="emphasis"><em>.</em></span> (period) and fixing all occurrences in the <a class="indexterm" id="id100"/>document. You can also do this for the project or solution. For our purpose, we only select the <span class="strong"><strong>Document</strong></span> link at the<a class="indexterm" id="id101"/> bottom of the lightbulb suggestions. Visual Studio will automatically add the abstract methods defined in the abstract class to implement inside your <code class="literal">Cheetah</code> class:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_09.jpg"/></div></li><li class="listitem">You will notice that Visual Studio adds just the methods you need to override but will throw <code class="literal">NotImplementedException</code> if you try to use the class as is. The reason for using <a class="indexterm" id="id102"/>an abstract class is to implement the functionality<a class="indexterm" id="id103"/> defined in the abstract class <code class="literal">Cat</code> in the derived class <code class="literal">Cheetah</code>. Not doing so contravenes the rules for using abstract classes:<div class="informalexample"><pre class="programlisting">public class Cheetah : Cat
{
    public override void Eat()
    {
        throw new NotImplementedException();
    }

    public override void Hunt()
    {
        throw new NotImplementedException();
    }

    public override void Sleep()
    {
        throw new NotImplementedException();
    }
}</pre></div></li><li class="listitem">To add some implementation, modify your <code class="literal">Cheetah</code> class as follows. The implementation in the overridden methods is simple, but this validates the rule of writing some sort of implementation in the overridden methods:<div class="informalexample"><pre class="programlisting">public class Cheetah : Cat
{
    public override void Eat()
    {
        WriteLine($"The cheetah eats.");
    }

    public override void Hunt()
    {
        WriteLine($"The cheetah hunts.");
    }

    public override void Sleep()
    {
        WriteLine($"The cheetah sleeps.");
    }
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>You will notice that the following <code class="literal">WriteLine</code> method is used without the <code class="literal">Console</code> class. This is because we are using a new feature in C# 6.0 that allows developers to bring static classes into scope by adding the <code class="literal">using static System.Console;</code> statement to the top of your class file.</p></div></div></li><li class="listitem">Create an interface called <code class="literal">IPurrable</code> that will be implemented on the <code class="literal">Cheetah</code> class. A common naming convention for interfaces dictates that the interface name should be prefixed with a capital I:<div class="informalexample"><pre class="programlisting">interface IPurrable
{

}</pre></div></li><li class="listitem">Next, we will add <a class="indexterm" id="id104"/>a method to the interface that any class implementing the interface must implement. You will notice that the interface's <code class="literal">SoftPurr</code> method contains no implementation at all. It however specifies that we will need to pass this method an integer value for the decibel that the <code class="literal">Cheetah</code> class will purr at:<div class="informalexample"><pre class="programlisting">interface IPurrable
{
    void SoftPurr(int decibel);
}</pre></div></li><li class="listitem">The next step is to<a class="indexterm" id="id105"/> implement the <code class="literal">IPurrable</code> interface on the <code class="literal">Cheetah</code> class. To do this, we need to add the <code class="literal">IPurrable</code> interface name after the <code class="literal">Cat</code> abstract class name. If the <code class="literal">Cheetah</code> class did not inherit from the abstract class, then the interface name would simply follow after the colon:<div class="informalexample"><pre class="programlisting">public class Cheetah : Cat, IPurrable
{
    public override void Eat()
    {
        WriteLine($"The cheetah eats.");
    }

    public override void Hunt()
    {
        WriteLine($"The cheetah hunts.");
    }

    public override void Sleep()
    {
        WriteLine($"The cheetah sleeps.");
    }
}</pre></div></li><li class="listitem">After specifying that the <code class="literal">Cheetah</code> class implements the <code class="literal">IPurrable</code> interface, Visual Studio <a class="indexterm" id="id106"/>once again displays a warning via the lightbulb feature. It is warning us that the <code class="literal">Cheetah</code> class does not implement the <code class="literal">SoftPurr</code> method defined in the interface <code class="literal">IPurrable</code>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_10.jpg"/></div></li><li class="listitem">As we did earlier, we<a class="indexterm" id="id107"/> can let Visual Studio suggest possible fixes for the problems encountered by typing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>.</em></span> (period). Visual Studio suggests that the interface can be implemented implicitly or explicitly:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_11.jpg"/></div></li><li class="listitem">Knowing when to use an implicit or explicit implementation is also quite easy. We first need to<a class="indexterm" id="id108"/> know when using one over the other would be preferred. Let's start off by implementing the <code class="literal">SoftPurr</code> method implicitly by selecting the first<a class="indexterm" id="id109"/> option in the lightbulb suggestion. You will see that by selecting to implement the <code class="literal">SoftPurr</code> method defined in the <code class="literal">IPurrable</code> interface implicitly, adds it as if it were part of the <code class="literal">Cheetah</code> class:<div class="informalexample"><pre class="programlisting">public class Cheetah : Cat, IPurrable
{
    public void SoftPurr(int decibel)
    {
        throw new NotImplementedException();
    }

    public override void Eat()
    {
        WriteLine($"The cheetah eats.");
    }

    public override void Hunt()
    {
        WriteLine($"The cheetah hunts.");
    }

    public override void Sleep()
    {
        WriteLine($"The cheetah sleeps.");
    }
}</pre></div></li><li class="listitem">If we look at the <code class="literal">SoftPurr</code> method, it looks like a normal method inside the <code class="literal">Cheetah</code> class. This <a class="indexterm" id="id110"/>would be fine unless our <code class="literal">Cheetah</code> class already contains a property called <code class="literal">SoftPurr</code>. Go ahead and add a property called <code class="literal">SoftPurr</code> to your <code class="literal">Cheetah</code> class: <div class="informalexample"><pre class="programlisting">public class Cheetah : Cat, IPurrable
{
    public int SoftPurr { get; set; }
    
    public void SoftPurr(int decibel)
    {
        throw new NotImplementedException();
    }

    public override void Eat()
    {
        WriteLine($"The cheetah eats.");
    }

    public override void Hunt()
    {
        WriteLine($"The cheetah hunts.");
    }

    public override void Sleep()
    {
        WriteLine($"The cheetah sleeps.");
    }        
}</pre></div></li><li class="listitem">Visual Studio<a class="indexterm" id="id111"/> immediately displays a warning by telling us that the <code class="literal">Cheetah</code> class already contains a definition for <code class="literal">SoftPurr</code>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_12.jpg"/></div></li><li class="listitem">It is here that the<a class="indexterm" id="id112"/> use of an explicit implementation becomes evident. This <a class="indexterm" id="id113"/>specifies that the <code class="literal">SoftPurr</code> method is a member of the implementation defined in the <code class="literal">IPurrable</code> interface:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_13.jpg"/></div></li><li class="listitem">Therefore, selecting the second option to implement the interface explicitly will add the <code class="literal">SoftPurr</code> method to your <code class="literal">Cheetah</code> class as follows:<div class="informalexample"><pre class="programlisting">public class Cheetah : Cat, IPurrable
{
    public int SoftPurr { get; set; }

    void IPurrable.SoftPurr(int decibel)
    {
        throw new NotImplementedException();
    }

    public override void Eat()
    {
        WriteLine($"The cheetah eats.");
    }

    public override void Hunt()
    {
        WriteLine($"The cheetah hunts.");
    }

    public override void Sleep()
    {
        WriteLine($"The cheetah sleeps.");
    }        
}</pre></div><p>The compiler<a class="indexterm" id="id114"/> now knows that this is an interface that is being implemented and is therefore a valid line of code.</p></li><li class="listitem">For the purpose <a class="indexterm" id="id115"/>of this book, let's just use the implicit implementation. Let's write some implementation for the <code class="literal">SoftPurr</code> method and use the new <code class="literal">nameof</code> keyword in C# 6.0, as well as the interpolated string for the output. Also, remove the <code class="literal">SoftPurr</code> property added earlier:<div class="informalexample"><pre class="programlisting">public void SoftPurr(int decibel)
{
    WriteLine($"The {nameof(Cheetah)} purrs at {decibel} decibels.");
}</pre></div></li><li class="listitem">Heading over to our console application, we can call our <code class="literal">Cheetah</code> class as follows:<div class="informalexample"><pre class="programlisting">Cheetah cheetah = new Cheetah();
cheetah.Hunt();
cheetah.Eat();
cheetah.Sleep();
cheetah.SoftPurr(60);
Console.ReadLine();</pre></div></li><li class="listitem">Running the application <a class="indexterm" id="id116"/>will produce the following output:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_14.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How it works…</h2></div></div></div><p>So, you might be wondering what the difference between an abstract class and an interface is. It basically comes down to where you want your implementation. If you need to share functionality between<a class="indexterm" id="id117"/> derived classes, then an abstract class is the best fit for your needs. In other words, we had specific things that were common to all cats (lions, tigers, and cheetahs) such as hunting, eating, and sleeping. This is then best used within an abstract class.</p><p>If your implementation is specific to a class or several classes (but not all classes), then your best course of action would be to use an interface. In this case, the <code class="literal">IPurrable</code> interface can be applied to several classes (for example, cheetahs and domestic cats) but can't be applied to all cats (such as lions and tigers), because not all cats can purr.</p><p>Knowing this difference<a class="indexterm" id="id118"/> and where you need to place your implementation will<a class="indexterm" id="id119"/> aid you in deciding whether you need to use an abstract class or an interface.</p></div></div>
<div class="section" title="Creating and using a generic class or method"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Creating and using a generic class or method</h1></div></div></div><p>Generics is a very interesting <a class="indexterm" id="id120"/>way of writing code. Instead of specifying the data type of the elements in the code at<a class="indexterm" id="id121"/> design time, you can actually delay the specification of those <a class="indexterm" id="id122"/>elements until they are <a class="indexterm" id="id123"/>used in code. This basically means that your class or method can work with any data type.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>Getting ready</h2></div></div></div><p>We will start off by writing a generic class that can take any data type as a parameter in its constructor and do something with it.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declaring a generic class is actually very easy. All that we need to do is create the class with the generic type parameter <code class="literal">&lt;T&gt;</code>:<div class="informalexample"><pre class="programlisting">public class PerformAction&lt;T&gt;
{

}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The generic type parameter is basically a placeholder for a specific type that will need to be defined when the class of variable is instantiated. This means that the generic class <code class="literal">PerformAction&lt;T&gt;</code> can never just be used without specifying the type argument inside angle brackets when instantiating the class.</p></div></div></li><li class="listitem">Next, create a <code class="literal">private</code> variable of the generic type parameter <code class="literal">T</code>. This will hold the value we pass to the generic class:<div class="informalexample"><pre class="programlisting">public class PerformAction&lt;T&gt;
{
    private T _value;
}</pre></div></li><li class="listitem">We now need to add a constructor to the generic class. The constructor will take as parameter a value of type <code class="literal">T</code>. The private variable <code class="literal">_value</code> will be set to the parameter passed to<a class="indexterm" id="id124"/> the constructor:<div class="informalexample"><pre class="programlisting">public class PerformAction&lt;T&gt;
{
    private T _value;

    public PerformAction(T value)
    {
        _value = value;
    }
}</pre></div></li><li class="listitem">Finally, to complete our<a class="indexterm" id="id125"/> generic class, create a void return method <a class="indexterm" id="id126"/>called <code class="literal">IdentifyDataType()</code>. All that this is<a class="indexterm" id="id127"/> going to do is tell us what data type we passed to the generic class. We can find the type of the variable using <code class="literal">GetType()</code>:<div class="informalexample"><pre class="programlisting">public class PerformAction&lt;T&gt;
{
    private T _value;

    public PerformAction(T value)
    {
        _value = value;
    }

    public void IdentifyDataType()
    {
        WriteLine($"The data type of the supplied variable is {_value.GetType()}");
    }
}</pre></div></li><li class="listitem">To see the true beauty of our generic class in action, instantiate the generic class in the console application and specify different data type arguments inside the angle brackets of each new instantiation:<div class="informalexample"><pre class="programlisting">PerformAction&lt;int&gt; iAction = new PerformAction&lt;int&gt;(21);
iAction.IdentifyDataType();

PerformAction&lt;decimal&gt; dAction = new PerformAction&lt;decimal&gt;(21.55m);
dAction.IdentifyDataType();
            
PerformAction&lt;string&gt; sAction = new PerformAction&lt;string&gt;("Hello Generics");
sAction.IdentifyDataType();                        
            
Console.ReadLine();</pre></div></li><li class="listitem">Running your console <a class="indexterm" id="id128"/>application will output the given data types<a class="indexterm" id="id129"/> that you instantiated the generic class with each time:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_15.jpg"/></div><p>We have used the exact <a class="indexterm" id="id130"/>same class but let it perform with three very different data types. This kind of flexibility is a very powerful feature in your code.</p></li></ol></div><p>Another feature of C# is that <a class="indexterm" id="id131"/>you can constrain the generic types implemented:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We can do this by telling the compiler that only types that implement the <code class="literal">IDisposable</code> interface can be used with the generic class. Change your generic class by adding <code class="literal">where T : IDisposable</code> to it. Your generic class should now look like this:<div class="informalexample"><pre class="programlisting">public class PerformAction&lt;T&gt; where T : IDisposable
{
    private T _value;

    public PerformAction(T value)
    {
        _value = value;
    }

    public void IdentifyDataType()
    {
        WriteLine($"The data type of the supplied variable is {_value.GetType()}");
    }
}</pre></div></li><li class="listitem">Go back to the console application and have a look at the previous instantiations of the generic class:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_16.jpg"/></div><p>Visual Studio will tell<a class="indexterm" id="id132"/> you that the types underlined by the red squiggly lines do not implement <code class="literal">IDisposable</code> and therefore <a class="indexterm" id="id133"/>can't be supplied to the <code class="literal">PerformAction</code> generic class.</p></li><li class="listitem">Comment out those lines<a class="indexterm" id="id134"/> of code and add the following<a class="indexterm" id="id135"/> instantiation to your console application:<div class="informalexample"><pre class="programlisting">DataSet dsData = new DataSet();
PerformAction&lt;DataSet&gt; oAction = new PerformAction&lt;DataSet&gt;(dsData);
oAction.IdentifyDataType();</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Note that for this to work, you might need to add <code class="literal">using System.Data;</code> to your code file. This is needed so that you can declare a <code class="literal">DataSet</code>.</p></div></div></li><li class="listitem">As you might know, a <code class="literal">DataSet</code> type implements <code class="literal">IDisposable</code>, and therefore, it is a valid type to pass to our generic class. Go ahead and run the console application:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_17.jpg"/></div><p>The <code class="literal">DataSet</code> type is valid, and the generic class performs as expected, identifying the type of the parameter passed to the constructor.</p></li></ol></div><p>But what about generic <a class="indexterm" id="id136"/>methods? Well, just like generic classes, generic methods also do not specify their type at design time. It is<a class="indexterm" id="id137"/> only known when the method is called. Let's have<a class="indexterm" id="id138"/> a look at the following implementation of <a class="indexterm" id="id139"/> generic methods:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's go ahead and create a new helper class called <code class="literal">MyHelperClass</code>:<div class="informalexample"><pre class="programlisting">public class MyHelperClass
{
}</pre></div></li><li class="listitem">Inside this helper class, we will create a generic method called <code class="literal">InspectType</code>. What is interesting about this generic method is that it can return multiple types because the return type is also marked with the generic type parameter. Your generic method does not have to return anything. It can also be declared as <code class="literal">void</code>:<div class="informalexample"><pre class="programlisting">public class MyHelperClass
{
    public T InspectType&lt;T&gt;(T value) 
    {
        
    }
}</pre></div></li><li class="listitem">To illustrate that this generic<a class="indexterm" id="id140"/> method can return multiple types, we will output the type passed to<a class="indexterm" id="id141"/> the generic method to the console window and then return that type and display it in the console application. You will notice that you need to cast the return type as <code class="literal">(T)</code> when returning it:<div class="informalexample"><pre class="programlisting">public class MyHelperClass
{
    public T InspectType&lt;T&gt;(T value) 
    {
        WriteLine($"The data type of the supplied parameter is {value.GetType()}");

        return (T)value;
    }
}</pre></div></li><li class="listitem">In the console application, go ahead and create an enumerator called <code class="literal">MyEnum</code>. The generic method <a class="indexterm" id="id142"/>can also accept enumerators:<div class="informalexample"><pre class="programlisting">public enum MyEnum { Value1, Value2, Value3 }</pre></div></li><li class="listitem">After creating the<a class="indexterm" id="id143"/> enumerator, add the following code to the console application. We are instantiating and calling the <code class="literal">oHelper</code> class and passing different values to it:<div class="informalexample"><pre class="programlisting">MyHelperClass oHelper = new MyHelperClass();
var intExample = oHelper.InspectType(25);
Console.WriteLine($"An example of this type is {intExample}");

var decExample = oHelper.InspectType(11.78m);
Console.WriteLine($"An example of this type is {decExample}");

var strExample = oHelper.InspectType("Hello Generics");
Console.WriteLine($"An example of this type is {strExample}");

var enmExample = oHelper.InspectType(MyEnum.Value2);
Console.WriteLine($"An example of this type is {enmExample}");

Console.ReadLine();</pre></div></li><li class="listitem">If you run the console application, you will see that the generic method correctly identifies the type of the parameter passed to it and then returns that type to the calling code in the console application:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_18.jpg"/></div></li></ol></div><p>Generic methods can be <a class="indexterm" id="id144"/>used in a multitude of situations. This is however only an introduction<a class="indexterm" id="id145"/> to generic classes and methods. It is recommended that <a class="indexterm" id="id146"/>you do further research to learn how to implement<a class="indexterm" id="id147"/> generics in your code appropriately.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>How it works…</h2></div></div></div><p>At the heart of generics lies the ability to reuse a single class or method. It allows developers to essentially not<a class="indexterm" id="id148"/> repeat similar code throughout their code base. This conforms well to the <span class="strong"><strong>Don't Repeat Yourself</strong></span> (<span class="strong"><strong>DRY</strong></span>) principle. This design principle states that a specific bit of logic should be represented in code only once.</p><p>Using generic classes also allows developers to create a class that is type safe when compiling. Type safe basically means that the developer can be assured of the type of the object and can use the class in a specific way without experiencing any unexpected behavior. Therefore, the compiler takes over the burden of type safety.</p><p>Generics also allow<a class="indexterm" id="id149"/> developers to write less code because code can be reused, and less code also performs better.</p></div></div>
<div class="section" title="Creating and using a generic interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Creating and using a generic interface</h1></div></div></div><p>Generic interfaces <a class="indexterm" id="id150"/>work in much the same way as the previous examples in generics. Let's assume that we want to find the properties of certain classes in our code, but we<a class="indexterm" id="id151"/> can't be sure how many classes we will need to inspect. A generic interface could come in very handy here.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Getting ready</h2></div></div></div><p>We need to inspect several classes for their properties. To do this, we will create a generic interface that will return a list of all the properties found for a class as a list of strings.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>How to do it…</h2></div></div></div><p>Let's take a look at the following implementation of the generic interface as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go ahead and create a generic interface called <code class="literal">IListClassProperties&lt;T&gt;</code>. The interface will define a method that needs to be used called <code class="literal">GetPropertyList()</code> that simply uses a LINQ query to return a <code class="literal">List&lt;string&gt;</code> object:<div class="informalexample"><pre class="programlisting">interface IListClassProperties&lt;T&gt;
{
    List&lt;string&gt; GetPropertyList();
}</pre></div></li><li class="listitem">Next, create a generic class called <code class="literal">InspectClass&lt;T&gt;</code>. Let the generic class implement the <code class="literal">IListClassProperties&lt;T&gt;</code> interface created in the previous step:<div class="informalexample"><pre class="programlisting">public class InspectClass&lt;T&gt; : IListClassProperties&lt;T&gt;
{

}</pre></div></li><li class="listitem">As usual, Visual Studio will highlight that the interface member <code class="literal">GetPropertyList()</code> has not been implemented in the <code class="literal">InspectClass&lt;T&gt;</code> generic class:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_19.jpg"/></div></li><li class="listitem">To show any<a class="indexterm" id="id152"/> potential fixes, type <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>.</em></span> (period) and implement the<a class="indexterm" id="id153"/> interface implicitly:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_20.jpg"/></div></li><li class="listitem">This will create the <code class="literal">GetPropertyList()</code> method in your <code class="literal">InspectClass&lt;T&gt;</code> class without any implementation. You will add the implementation in a moment. If you try to run your code without adding any implementation to the <code class="literal">GetpropertyList() </code>method, the compiler will throw <code class="literal">NotImplementedException</code>:<div class="informalexample"><pre class="programlisting">public class InspectClass&lt;T&gt; : IListClassProperties&lt;T&gt;
{
    public List&lt;string&gt; GetPropertyList()
    {
        throw new NotImplementedException();
    }
}</pre></div></li><li class="listitem">Next, add a constructor to your <code class="literal">InspectClass&lt;T&gt;</code> class that takes a generic type parameter and sets it equal to the private variable <code class="literal">_classToInspect</code> that you also need to create. This is setting up the code that we will use to instantiate the <code class="literal">InspectClass&lt;T&gt;</code> object. We will <a class="indexterm" id="id154"/>pass to the object we need a list of properties from the constructor, and the constructor will set the private variable <code class="literal">_classToInspect</code> so that we can use it in our <code class="literal">GetPropertyList()</code> method implementation:<div class="informalexample"><pre class="programlisting">public class InspectClass&lt;T&gt; : IListClassProperties&lt;T&gt;
{
    T _classToInspect;
    public InspectClass(T classToInspect)
    {
        _classToInspect = classToInspect;
    }

    public List&lt;string&gt; GetPropertyList()
    {
        throw new NotImplementedException();
    }
}</pre></div></li><li class="listitem">To finish off our class, we <a class="indexterm" id="id155"/>need to add some implementation to the <code class="literal">GetPropertyList()</code> method. It is here that the LINQ query will be used to return a <code class="literal">List&lt;string&gt;</code> object of all the properties contained in the class supplied to the constructor:<div class="informalexample"><pre class="programlisting">public List&lt;string&gt; GetPropertyList()
{
    return _classToInspect.GetType().GetProperties().Select(p =&gt; p.Name).ToList();
}</pre></div></li><li class="listitem">Moving to our console application, go ahead and create a simple class called <code class="literal">Invoice</code>. This is one of several classes that can be used in the system, and the <code class="literal">Invoice</code> class is one of the smaller classes. It usually just holds invoice data specific to a record in the invoices records of the data store you connect to. We need to find a list of the properties in this class:<div class="informalexample"><pre class="programlisting">public class Invoice
{
    public int ID { get; set; }
    public decimal TotalValue { get; set; }
    public int LineNumber { get; set; }
    public string StockItem { get; set; }
    public decimal ItemPrice { get; set; }
    public int Qty { get; set; }
}</pre></div></li><li class="listitem">We can now make use of our <code class="literal">InspectClass&lt;T&gt;</code> generic class that implements the <code class="literal">IListClassProperties&lt;T&gt;</code> generic interface. To do this, we will create a new instance of the <code class="literal">Invoice</code> class. We will then instantiate the <code class="literal">InspectClass&lt;T&gt;</code> class, passing the type in the angle brackets and the <code class="literal">oInvoice</code> object to the constructor. We are now ready to call the <code class="literal">GetPropertyList()</code> method. The result is returned to a <code class="literal">List&lt;string&gt;</code> object called <code class="literal">lstProps</code>. We<a class="indexterm" id="id156"/> can then run <code class="literal">foreach</code> on the list, writing<a class="indexterm" id="id157"/> the value of each <code class="literal">property</code> variable to the console window:<div class="informalexample"><pre class="programlisting">Invoice oInvoice = new Invoice();
InspectClass&lt;Invoice&gt; oClassInspector = new InspectClass&lt;Invoice&gt;(oInvoice);
List&lt;string&gt; lstProps = oClassInspector.GetPropertyList();

foreach(string property in lstProps)
{
    Console.WriteLine(property);
}
Console.ReadLine();</pre></div></li><li class="listitem">Go ahead and run the code to see the output generated by inspecting the properties of the <code class="literal">Invoice</code> class:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_21.jpg"/></div><p>As you can see, the properties are listed as they exist in the <code class="literal">Invoice</code> class. The <code class="literal">IListClassProperties&lt;T&gt;</code> generic interface and the <code class="literal">InspectClass&lt;T&gt;</code> class don't care what type of class they need to inspect. They will take any class, run the code on it, and produce a result.</p></li></ol></div><p>But the preceding implementation<a class="indexterm" id="id158"/> still poses a slight problem. Let's have a look at one of the<a class="indexterm" id="id159"/> variation of this problem:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Consider the following code in the console application:<div class="informalexample"><pre class="programlisting">InspectClass&lt;int&gt; oClassInspector = new InspectClass&lt;int&gt;(10);
List&lt;string&gt; lstProps = oClassInspector.GetPropertyList();
foreach (string property in lstProps)
{
    Console.WriteLine(property);
}
Console.ReadLine();</pre></div><p>You can see that we have easily passed an integer value and type to the <code class="literal">InspectClass&lt;T&gt;</code> class, and the code does not show any warnings at all. In fact, if you ran this code, nothing would be returned and nothing outputs to the console window. What we need to do is implement the constraints on our generic class and interface.</p></li><li class="listitem">At the end of the interface implementation after the class, add the <code class="literal">where T : class</code> clause. The code now needs to look like this:<div class="informalexample"><pre class="programlisting">public class InspectClass&lt;T&gt; : IListClassProperties&lt;T&gt; where T : class
{
    T _classToInspect;
    public InspectClass(T classToInspect)
    {
        _classToInspect = classToInspect;
    }

    public List&lt;string&gt; GetPropertyList()
    {
        return _classToInspect.GetType().GetProperties().Select(p =&gt; p.Name).ToList();
    }
}</pre></div></li><li class="listitem">If we returned to our console application code, you will see that Visual Studio has underlined the <code class="literal">int</code> type passed to the <code class="literal">InspectClass&lt;T&gt;</code> class:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_22.jpg"/></div><p>The reason for this is because we have defined a constraint against our generic class and interface. We have told the compiler that we only accept reference types. Therefore, this applies to any class, interface array, type, or delegate. Our <code class="literal">Invoice</code> class will therefore be a valid type, and the constraint will not apply to it.</p></li></ol></div><p>We can also be more specific in <a class="indexterm" id="id160"/>our type parameter constraints. The reason for this is that we perhaps do not want to constrain the parameters to reference types. If we, for<a class="indexterm" id="id161"/> example, wanted to button down the generic class and interface to only accept classes created inside our current system, we can implement a constraint that the argument for <code class="literal">T</code> needs to be derived from a specific object. Here, we can use abstract classes again:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an abstract class called <code class="literal">AcmeObject</code> and specify that all classes that inherit from <code class="literal">AcmeObject</code> implement a property called <code class="literal">ID</code>:<div class="informalexample"><pre class="programlisting">public abstract class AcmeObject
{
    public abstract int ID { get; set; }
}</pre></div></li><li class="listitem">We can now ensure that objects we create in our code for which we need to read the properties from are derived from <code class="literal">AcmeObject</code>. To apply the constraint, modify the generic class and place the <code class="literal">where T : AcmeObject</code> constraint after the interface implementation. Your code should now look like this:<div class="informalexample"><pre class="programlisting">public class InspectClass&lt;T&gt; : IListClassProperties&lt;T&gt; where T : AcmeObject
{
    T _classToInspect;
    public InspectClass(T classToInspect)
    {
        _classToInspect = classToInspect;
    }

    public List&lt;string&gt; GetPropertyList()
    {
        return _classToInspect.GetType().GetProperties().Select(p =&gt; p.Name).ToList();
    }
}</pre></div></li><li class="listitem">In the console application, modify the <code class="literal">Invoice</code> class to inherit from the <code class="literal">AcmeObject</code> abstract <a class="indexterm" id="id162"/>class. Implement the <code class="literal">ID</code> property as defined in the abstract class:<div class="informalexample"><pre class="programlisting">public class Invoice : AcmeObject
{
    public override int ID { get; set; }
    public decimal TotalValue { get; set; }
    public int LineNumber { get; set; }
    public string StockItem { get; set; }
    public decimal ItemPrice { get; set; }
    public int Qty { get; set; }            
}</pre></div></li><li class="listitem">Create two more<a class="indexterm" id="id163"/> classes called <code class="literal">SalesOrder</code> and <code class="literal">CreditNote</code>. This time, however, only make the <code class="literal">SalesOrder</code> class inherit from <code class="literal">AcmeObject</code>. Leave the <code class="literal">CreditNote</code> object as is. This is so that we can clearly see how the constraint can be applied:<div class="informalexample"><pre class="programlisting">public class SalesOrder : AcmeObject
{
    public override int ID { get; set; }
    public decimal TotalValue { get; set; }
    public int LineNumber { get; set; }
    public string StockItem { get; set; }
    public decimal ItemPrice { get; set; }
    public int Qty { get; set; }
}

public class CreditNote
{
    public int ID { get; set; }
    public decimal TotalValue { get; set; }
    public int LineNumber { get; set; }
    public string StockItem { get; set; }
    public decimal ItemPrice { get; set; }
    public int Qty { get; set; }
}</pre></div></li><li class="listitem">Create the code needed to get the property list for the <code class="literal">Invoice</code> and <code class="literal">SalesOrder</code> classes. The <a class="indexterm" id="id164"/>code is straightforward, and we can see that Visual Studio does not complain about either of these two classes:<div class="informalexample"><pre class="programlisting">Invoice oInvoice = new Invoice();
InspectClass&lt;Invoice&gt; oInvClassInspector = new InspectClass&lt;Invoice&gt;(oInvoice);
List&lt;string&gt; invProps = oInvClassInspector.GetPropertyList();

foreach (string property in invProps)
{
    Console.WriteLine(property);
}
Console.ReadLine();
SalesOrder oSalesOrder = new SalesOrder();
InspectClass&lt;SalesOrder&gt; oSoClassInspector = new InspectClass&lt;SalesOrder&gt;(oSalesOrder);
List&lt;string&gt; soProps = oSoClassInspector.GetPropertyList();

foreach (string property in soProps)
{
    Console.WriteLine(property);
}
Console.ReadLine();</pre></div></li><li class="listitem">If, however, we had to try do the same for our <code class="literal">CreditNote</code> class, we will see that Visual Studio will warn <a class="indexterm" id="id165"/>us that we can't pass the <code class="literal">CreditNote</code> class to the <code class="literal">InspectClass&lt;T&gt;</code> class because the constraint we implemented only accepts objects that derive from our <code class="literal">AcmeObject</code> abstract class. By doing this, we have effectively taken control over exactly what we allow to be passed to our generic class and interface by means of constraints:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_02_23.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How it works…</h2></div></div></div><p>Speaking of generic interfaces, we have seen that we can implement behavior on a generic class by implementing <a class="indexterm" id="id166"/>a generic interface. The power of using the generic class and generic interface is well illustrated earlier.</p><p>Having said that, we do believe that knowing when to use constraints is also important so that you can close down your generic <a class="indexterm" id="id167"/>classes to only accept the specific types that you want. This ensures that you don't get any surprises when someone accidently passes an integer to your generic class.</p><p>Finally, the constraints that you can use are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">where T: struct</code>: The type argument must be any value types</li><li class="listitem" style="list-style-type: disc"><code class="literal">where T: class</code>: The type argument must be any reference types</li><li class="listitem" style="list-style-type: disc"><code class="literal">where T: new()</code>: The type argument needs to have a parameterless constructor</li><li class="listitem" style="list-style-type: disc"><code class="literal">where T: &lt;base class name&gt;</code>: The type argument must derive from the given base class</li><li class="listitem" style="list-style-type: disc"><code class="literal">where T: &lt;T must derive from object&gt;</code>: <code class="literal">T</code> The type argument must derive from the object after the colon</li><li class="listitem" style="list-style-type: disc"><code class="literal">where T: &lt;interface&gt;</code>: The type argument must implement the interface specified</li></ul></div></div></div></body></html>