- en: '*Chapter 9*: Selfies: Making Funny Faces'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：自拍：制作搞笑的面孔'
- en: In this chapter, you will learn how to use Unity AR Foundation for face tracking
    in order to make fun and entertaining face filters. I apologize in advance for
    showing my handsome face throughout this chapter – it's a necessary evil when
    working with selfies!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Unity AR Foundation进行面部追踪，以便制作有趣且娱乐性的面部滤镜。我提前为在这章中展示我英俊的面孔道歉——当与自拍一起工作时，这是必要的恶行！
- en: We'll start with a brief explanation of how face tracking works, and then we
    will create a new AR scene with face tracking enabled. We will use a couple of
    3D head models that track your head pose and to which you can add extra accessories,
    such as a hat and sunglasses. We are going to build a main menu so that the user
    can select and change models at runtime. We'll then work with dynamic face meshes
    and create several materials to easily switch between them. In the last part,
    we'll look at more advanced features such as eye tracking, face regions (ARCore),
    and blend shapes (ARKit).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从面部追踪的工作原理的简要说明开始，然后我们将创建一个启用面部追踪的新AR场景。我们将使用几个3D头部模型，这些模型可以追踪您的头部姿态，并且您可以添加额外的配件，如帽子和太阳镜。我们将构建一个主菜单，以便用户可以在运行时选择和更改模型。然后我们将处理动态面部网格，并创建几个材料，以便轻松地在它们之间切换。在最后一部分，我们将探讨更高级的功能，如眼动追踪、面部区域（ARCore）和混合形状（ARKit）。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding face tracking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解面部追踪
- en: Configuring a new AR scene for face tracking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置新的AR场景进行面部追踪
- en: Tracking the face pose with 3D models and accessories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用3D模型和配件追踪面部姿态
- en: Controlling the app's main mode and building a main menu
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制应用程序的主模式并构建主菜单
- en: Making dynamic face meshes with a variety of materials
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种材料制作动态面部网格
- en: Using eye-tracking (ARKit)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用眼动追踪（ARKit）
- en: Attaching stickers to face regions (ARCore)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将贴纸附加到面部区域（ARCore）
- en: Tracking expressive face blend shapes (ARKit)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪表情丰富的面部混合形状（ARKit）
- en: By the end of this chapter, you'll be familiar with many of the face tracking
    features in AR Foundation, ARCore, and ARKit. You will also have a working *Face
    Maker* project you can show off to your friends!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将熟悉AR Foundation、ARCore和ARKit中许多面部追踪功能。您还将拥有一个可以展示给朋友的*面部制作器*项目！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To implement the project in this chapter, you need Unity installed on your
    development computer and connected with a mobile device that supports augmented
    reality applications (see [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013),
    *Setting Up for AR Development*, for instructions). We also assume that you have
    the `ARFramework` template and its prerequisites installed (see [*Chapter 5*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119),
    *Using the AR User Framework*). The completed project can be found in this book''s
    GitHub repository, available at the following URL: [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现本章中的项目，您需要在您的开发计算机上安装Unity，并将其连接到支持增强现实应用程序的移动设备（有关说明，请参阅[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)，*为AR开发设置*）。我们还假设您已安装`ARFramework`模板及其先决条件（请参阅[*第5章*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)，*使用AR用户框架*）。完成的项目可以在本书的GitHub存储库中找到，网址如下：[https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)。
- en: Understanding face tracking
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面部追踪
- en: Let's start with some background on face tracking and the technology that makes
    it work. Face tracking is a kind of Augmented Reality that (usually) uses the
    front-facing camera on your mobile device. Apps such as Snapchat, Instagram, and
    Animoji have popularized face filter technology, and it has now become mainstream
    on mobile devices. It makes for highly entertaining and creative experiences.
    The technology detects facial features and expressions, and Unity AR Foundation
    enables you to write applications for attaching 3D objects to specific facial
    features that are tracked.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从面部追踪及其工作原理的背景知识开始。面部追踪是一种增强现实技术（通常）使用您的移动设备的正面摄像头。Snapchat、Instagram和Animoji等应用程序普及了面部滤镜技术，现在它已成为移动设备上的主流。它为高度娱乐和创造性的体验提供了可能。该技术检测面部特征和表情，Unity
    AR Foundation使您能够编写将3D对象附加到追踪到的特定面部特征的应用程序。
- en: Face tracking begins with a frame of the video from your device's camera. It
    analyzes the pixels, looking for patterns that represent a face – for example,
    the bridge of the nose is lighter than the pixels surrounding it, and the eyes
    are darker than the forehead. Key points and regions are recognized and used to
    construct a 3D mesh, like a mask, representing the face. Nodes of the mesh are
    "locked onto" key points in the image, allowing the mesh to follow not just the
    pose of the face, but detailed changes that correspond to human facial expressions,
    like a smile or a wink of the eye.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 人脸追踪从您设备摄像头的视频帧开始。它分析像素，寻找代表人脸的图案——例如，鼻梁的像素比周围的像素亮，眼睛比额头暗。关键点和区域被识别并用于构建一个类似于面具的
    3D 网格，代表人脸。网格的节点“锁定”在图像的关键点上，使得网格不仅能跟随人脸的姿态，还能跟随与人类面部表情相对应的详细变化，如微笑或眨眼。
- en: 'To learn more about how face tracking works, I encourage you to watch the seminal
    Vox video (over 3 million views) *How Snapchat''s filters work*, available at
    the following URL: [https://www.youtube.com/watch?v=Pc2aJxnmzh0](https://www.youtube.com/watch?v=Pc2aJxnmzh0).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于人脸追踪如何工作，我鼓励您观看由 Vox 制作的开创性视频（超过 300 万次观看）*Snapchat 的滤镜是如何工作的*，可在以下 URL
    查看视频：[https://www.youtube.com/watch?v=Pc2aJxnmzh0](https://www.youtube.com/watch?v=Pc2aJxnmzh0)。
- en: It's helpful to understand the distinction between face tracking and face identification,
    and how to track a face with AR Foundation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 了解人脸追踪与人脸识别之间的区别，以及如何使用 AR Foundation 追踪人脸是有帮助的。
- en: Face tracking versus face identification
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人脸追踪与人脸识别的区别
- en: A distinction should be made between *face tracking* and *face identification*.
    Face tracking, in general, is limited to detecting a human face and tracking its
    pose (position and rotation), facial features such as the forehead and nose, and
    changes representing expressions, such as opening your mouth or blinking your
    eyes. Face identification, on the other hand, adds recognition of the features
    that make your face unique and different from other faces. Face recognition is
    used as a fingerprint. One example of face recognition technology is for unlocking
    devices. More advanced (and creepy) face identification is increasingly being
    used by authoritarian governments and law enforcement to identify strangers in
    a crowd, using a large database of faces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应该区分**人脸追踪**和**人脸识别**。通常，人脸追踪限于检测人脸和跟踪其姿态（位置和旋转）、面部特征，如额头和鼻子，以及代表表情的变化，如张嘴或眨眼。另一方面，人脸识别增加了识别使您的面孔独特且与其他面孔不同的特征。面部识别被用作指纹。面部识别技术的一个例子是用于解锁设备。更高级（且令人不安）的人脸识别越来越多地被威权政府和执法机构用于在人群中识别陌生人，使用的是大量的人脸数据库。
- en: Using Unity AR Foundation, you can access the AR face-tracking capabilities
    of your device. We are going to examine this next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Unity AR Foundation，您可以访问设备的人脸追踪功能。我们将接下来探讨这一点。
- en: Tracking a face with AR Foundation
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AR Foundation 追踪人脸
- en: As you now know, a Unity project using AR Foundation and XR Plugins will have
    a scene that includes an **ARSession** and an **ARSessionOrigin** object. The
    AR Face Manager component is added to the AR Session Origin to enable face tracking.
    Like most AR Foundation features, this component wraps the Unity AR subsystems,
    namely the XR face subsystem (see [https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRFaceSubsystem.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRFaceSubsystem.html)).
    This in turn interfaces with the underlying XR plugin, such as ARCore or ARKit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在所知，使用 AR Foundation 和 XR 插件的 Unity 项目将包含一个场景，该场景包括一个 **ARSession** 和一个 **ARSessionOrigin**
    对象。将 AR Face Manager 组件添加到 AR Session Origin 中以启用人脸追踪。像大多数 AR Foundation 功能一样，此组件封装了
    Unity AR 子系统，即 XR 面部子系统（见 [https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRFaceSubsystem.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRFaceSubsystem.html)）。这反过来又与底层的
    XR 插件接口，例如 ARCore 或 ARKit。
- en: 'The **AR Face Manager** component references a face prefab provided by you.
    This prefab will be instantiated and tracked with the detected face. The component
    also provides a **Maximum Face Count** parameter, should you want the app to support
    multiple people in the same camera view (depending on the capabilities of the
    underlying device). The component is shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR人脸管理器**组件引用您提供的脸预制件。此预制件将被实例化并跟踪检测到的人脸。如果需要应用程序支持同一摄像头视图中多个人（取决于底层设备的功能），组件还提供了一个**最大人脸数量**参数。组件在以下屏幕截图中显示：'
- en: '![Figure 9.1 – The AR Face Manager component on an AR Session Origin object'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – AR会话源对象上的AR人脸管理器组件]'
- en: '](img/Figure_9.01_B15145.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.01_B15145.jpg]'
- en: Figure 9.1 – The AR Face Manager component on an AR Session Origin object
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – AR会话源对象上的AR人脸管理器组件
- en: 'The face prefab should have an **AR Face** component on it that represents
    a face detected by an AR device. It has properties including the face mesh vertices,
    facet normals, and transforms for the left and right eyes. Like other AR trackables,
    your scripts can subscribe to changes to know when faces have been added, updated,
    and removed. The specific properties available will depend on the capabilities
    of the underlying device. See the documentation available at the following URL:
    [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/api/UnityEngine.XR.ARFoundation.ARFace.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/api/UnityEngine.XR.ARFoundation.ARFace.html).
    Also, see the following URL: [https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRFace.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRFace.html).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 人脸预制件应该有一个表示由AR设备检测到的人脸的**AR人脸**组件。它具有包括人脸网格顶点、面法线和左右眼变换等属性。与其他AR可追踪对象一样，你的脚本可以订阅变化，以便知道何时添加、更新和删除人脸。具体可用的属性将取决于底层设备的功能。请参阅以下URL提供的文档：[https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/api/UnityEngine.XR.ARFoundation.ARFace.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/api/UnityEngine.XR.ARFoundation.ARFace.html)。另外，请参阅以下URL：[https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRFace.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRFace.html)。
- en: AR Foundation provides an interface for AR face tracking (not identification),
    using the AR Face Manager component added to your AR Session Origin object. We
    can now get started building a selfie face filter project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: AR Foundation提供了一个用于AR人脸跟踪（非识别）的接口，通过将AR人脸管理器组件添加到您的AR会话源对象。现在我们可以开始构建自拍人脸过滤器项目了。
- en: Getting started
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: To begin, we'll create a new scene named `FaceMaker` using the `ARFramework`
    scene template. If you're targeting iOS ARKit, there may be additional setup required,
    including installing the separate ARKit Face Tracking package. Then we'll add
    a project title to the UI before moving on to adding face tracking to the scene.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`ARFramework`场景模板创建一个名为`FaceMaker`的新场景。如果您针对iOS ARKit，可能需要额外的设置，包括安装单独的ARKit人脸跟踪包。然后，我们在添加人脸跟踪到场景之前，将项目标题添加到UI中。
- en: Creating a new scene using the ARFramework template
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ARFramework模板创建新场景
- en: 'Create a new scene in your Unity AR-ready project using the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤在你的Unity AR准备好的项目中创建一个新的场景：
- en: Select **File** | **New Scene**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件** | **新建场景**。
- en: In the **New Scene** dialog box, select the **ARFramework** template.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建场景**对话框中，选择**ARFramework**模板。
- en: Click **Create**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**。
- en: Select `Scenes/` folder in your project `Assets` folder, give it the name `FaceMaker`,
    and click **Save**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目`Assets`文件夹中的`Scenes/`文件夹中，将其命名为`FaceMaker`，然后点击**保存**。
- en: 'The new AR scene already has the following setup from the template:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 新的AR场景已经从模板中包含了以下设置：
- en: '**AR Session** game object with an AR Session component.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR会话**游戏对象，其中包含AR会话组件。'
- en: '**An AR Session Origin** rig with an AR Session Origin component, among others,
    and a child main camera. We will replace its AR Plane Manager component with an
    AR Face Manager one.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR会话源**装置，其中包含AR会话源组件和其他组件，以及一个子主摄像头。我们将用AR人脸管理器组件替换其AR平面管理器组件。'
- en: '**UI Canvas** is a screen space canvas with the child panels **Startup UI**,
    **Scan UI**, **Main UI**, and **NonAR UI** that we built for the **ARFramework**.
    It has the UI Controller component script that we wrote. We''ll update this with
    the project-specific UI.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI Canvas**是一个屏幕空间画布，包含我们为**ARFramework**构建的子面板**Startup UI**、**Scan UI**、**Main
    UI**和**NonAR UI**，它包含我们编写的UI控制器组件脚本。我们将使用项目特定的UI更新它。'
- en: '**Interaction Controller** is a game object we built for the ARFramework, with
    an interaction controller component script we wrote that helps the app switch
    between interaction modes, including Startup, Scan, Main, and NonAR modes. It
    also has a **Player Input** component configured with the **AR Input Actions**
    asset we previously created. We are going to customize the main mode for our face
    tracking app.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Interaction Controller**是我们为**ARFramework**构建的游戏对象，包含我们编写的交互控制器组件脚本，帮助应用在启动、扫描、主和非AR模式之间切换交互模式。它还包含配置了之前创建的**AR
    Input Actions**资产的**Player Input**组件。我们将为我们的面部追踪应用定制主模式。'
- en: '**OnboardingUX** is a prefab from the AR Foundation Demos project that provides
    AR session status messages and animated onboarding graphics prompts.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnboardingUX**是来自AR Foundation Demos项目的预制件，提供AR会话状态消息和动画引导图形提示。'
- en: 'Let''s start by setting the app title now as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置应用标题开始，如下所示：
- en: In the **Hierarchy**, unfold the **UI Canvas** object, and unfold its child
    **App Title Panel**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，展开**UI Canvas**对象，然后展开其子对象**App Title Panel**。
- en: Select the **Title Text** object.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Title Text**对象。
- en: In its `Face Maker`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`Face Maker`中。
- en: If you are targeting ARKit on iOS, there may be additional project setup required.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您针对iOS上的ARKit，可能需要额外的项目设置。
- en: Setting up iOS ARKit for face tracking
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置iOS ARKit以进行面部追踪
- en: 'To develop and build a project using face tracking with ARKit for an iOS device,
    you also need to install the ARKit Face Tracking package via the package manager.
    Perform the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用ARKit在iOS设备上开发和使用面部追踪的项目，您还需要通过包管理器安装ARKit Face Tracking包。执行以下步骤：
- en: Open the package manager using **Window** | **Package Manager**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Window** | **Package Manager**打开包管理器。
- en: In the **Packages** filter selection at the top left, choose **Unity Registry**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左上角的**包**过滤器选择中，选择**Unity Registry**。
- en: Use the search field at the top right to search for `ar`, and select the **ARKit
    Face Tracking** package from the packages list.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用右上角的搜索字段搜索`ar`，并从包列表中选择**ARKit Face Tracking**包。
- en: Click **Install** at the bottom right of the window.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的右下角点击**Install**。
- en: 'Then, configure ARKit XR Plugin for face tracking, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下步骤配置ARKit XR Plugin以进行面部追踪：
- en: Open the **Project Settings** window, using **Edit** | **Project Settings**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Edit** | **Project Settings**打开**Project Settings**窗口。
- en: On the left-side tabs menu, select **XR Plug-in Management** | **ARKit**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的选项卡菜单中，选择**XR Plug-in Management** | **ARKit**。
- en: Check the **Face Tracking** checkbox.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Face Tracking**复选框。
- en: Next, we will gather some assets that we'll be using in this chapter. Some of
    these are also provided in this book's GitHub repository. Others are third-party
    assets that you must download and import separately.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将收集一些在本章中将要使用的资产。其中一些也包含在本书的GitHub仓库中。其他是一些第三方资产，您必须单独下载并导入。
- en: Importing assets used in this project
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入项目中使用的资产
- en: First, you should already have the *AR Foundation Samples* assets in your project
    (the ones that we imported back in [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013),
    *Setting Up for AR Development*). If you followed along, these are in the `Assets/ARF-samples/`
    folder. It contains some useful example assets that we'll use and reference in
    this chapter that can give you additional insight into the capabilities of AR
    Foundation face tracking, as well as how to use those capabilities.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该已经在项目中拥有*AR Foundation Samples*资产（我们在[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)，*为AR开发设置*）中导入的资产。如果您跟随着步骤操作，这些资产位于`Assets/ARF-samples/`文件夹中。它包含一些有用的示例资产，我们将在本章中使用并参考，这些资产可以为您提供关于AR
    Foundation面部追踪功能的额外见解，以及如何使用这些功能。
- en: 'We are also going to use the assets from the *AR Face Assets* package from
    Unity (available in the Asset Store). These assets are also used in the Unity
    Learn tutorial, *AR Face Tracking with AR Foundation* ([https://learn.unity.com/project/ar-face-tracking-with-ar-foundations](https://learn.unity.com/project/ar-face-tracking-with-ar-foundations)).
    To import the package, follow these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用来自 Unity 的 *AR Face Assets* 包中的资产（可在资产商店中找到）。这些资产也用于 Unity Learn 教程，*使用
    AR Foundation 进行 AR 面部追踪* ([https://learn.unity.com/project/ar-face-tracking-with-ar-foundations](https://learn.unity.com/project/ar-face-tracking-with-ar-foundations))。要导入包，请按照以下步骤操作：
- en: 'Using your internet browser, go to the following URL: [https://assetstore.unity.com/packages/essentials/asset-packs/ar-face-assets-184187](https://assetstore.unity.com/packages/essentials/asset-packs/ar-face-assets-184187).'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的网络浏览器，访问以下网址：[https://assetstore.unity.com/packages/essentials/asset-packs/ar-face-assets-184187](https://assetstore.unity.com/packages/essentials/asset-packs/ar-face-assets-184187)。
- en: Click **Add to My Assets** (if necessary), then click **Open In Unity**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加到我的资产**（如有必要），然后点击 **在 Unity 中打开**。
- en: In Unity, this should open the **Package Manager** window (or select **Window**
    | **Package Manager**).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 中，这应该会打开 **包管理器** 窗口（或选择 **窗口** | **包管理器**）。
- en: Select **My Assets** from the **Packages** filter at the top left.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左上角的 **包** 过滤器中选择 **我的资产**。
- en: Find the **AR Face Assets** package and click **Download** and/or **Import**
    (bottom right). In the **Import Unity Package** window, click the **Import** button.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 **AR Face Assets** 包，点击 **下载** 和/或 **导入**（右下角）。在 **导入 Unity 包** 窗口中，点击 **导入**
    按钮。
- en: Convert the imported materials to the Universal Render Pipeline by selecting
    **Edit** | **Render Pipeline** | **Universal Render Pipeline** | **Upgrade Project
    Materials to URP Materials**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **编辑** | **渲染管线** | **通用渲染管线** | **升级项目材质到 URP 材质**，将导入的材质转换为通用渲染管线。
- en: '*Face accessories 3D models*: I have found some free 3D models to use in this
    project. You can also use them or substitute your own. If you wish to use them,
    they are included in the following GitHub repositories:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*面部配件 3D 模型*：我在这个项目中找到了一些免费的 3D 模型。你也可以使用它们或替换成你自己的。如果你想使用它们，它们包含在以下 GitHub
    仓库中：'
- en: 'Sunglasses: [https://free3d.com/3d-model/sunglasses-v1--803862.html](https://free3d.com/3d-model/sunglasses-v1--803862.html).
    OBJ format (submitted by *printable_models*, [https://free3d.com/user/printable_models](https://free3d.com/user/printable_models))'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太阳镜：[https://free3d.com/3d-model/sunglasses-v1--803862.html](https://free3d.com/3d-model/sunglasses-v1--803862.html)。OBJ
    格式（由 *printable_models* 提交，[https://free3d.com/user/printable_models](https://free3d.com/user/printable_models)）
- en: 'Top hat: [https://free3d.com/3d-model/cartola-278168.html.](https://free3d.com/3d-model/cartola-278168.html.)
    FBX format (submitted by *zotgames*, [https://free3d.com/user/zotgames](https://free3d.com/user/zotgames))'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高顶帽：[https://free3d.com/3d-model/cartola-278168.html.](https://free3d.com/3d-model/cartola-278168.html.)
    FBX 格式（由 *zotgames* 提交，[https://free3d.com/user/zotgames](https://free3d.com/user/zotgames)）
- en: If you're downloading these yourself, unzip and drag the files into your project's
    `Assets/` folder. We'll address the import settings and steps later in the chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自行下载，请解压并将文件拖入项目文件夹的 `Assets/` 中。我们将在本章后面讨论导入设置和步骤。
- en: '*Face stickers 2D sprite images*: For the ARCore-based face region stickers,
    I found some free clipart at Creative Commons. You can use them or substitute
    your own. If you wish to use them, they are included in the following GitHub repositories:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*面部贴纸 2D 精灵图像*：对于基于 ARCore 的面部区域贴纸，我在 Creative Commons 找到了一些免费的剪贴画。你也可以使用它们或替换成你自己的。如果你想使用它们，它们包含在以下
    GitHub 仓库中：'
- en: 'Eyebrows: [https://clipground.com/images/angry-eyebrows-clipart-11.png](https://clipground.com/images/angry-eyebrows-clipart-11.png)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 眉毛：[https://clipground.com/images/angry-eyebrows-clipart-11.png](https://clipground.com/images/angry-eyebrows-clipart-11.png)
- en: 'Mustache: [https://clipground.com/images/monocle-clipart-12.jpg](https://clipground.com/images/monocle-clipart-12.jpg)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胡须：[https://clipground.com/images/monocle-clipart-12.jpg](https://clipground.com/images/monocle-clipart-12.jpg)
- en: 'Licking lips: [https://clipground.com/images/licking-lips-clipart-12.jpg](https://clipground.com/images/licking-lips-clipart-12.jpg)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘴唇舔舐：[https://clipground.com/images/licking-lips-clipart-12.jpg](https://clipground.com/images/licking-lips-clipart-12.jpg)
- en: 'I used Photoshop to adapt each of these images with a transparent background,
    square-shaped canvas, and scaled to 512x512 pixels. These are imported as **Texture
    Type: Sprite (2D and UI)**.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Photoshop 将这些图像的背景调整为透明，画布形状为方形，并缩放到 512x512 像素。这些图像被导入为 **纹理类型：精灵（2D 和
    UI）**。
- en: 'For all the aforementioned assets, I also created button icons that we''ll
    use in the UI. These are also available on the GitHub repository in the `icons/`
    folder and are imported as **Texture Type: Sprite (2D and UI)**.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述所有资产，我还创建了我们将用于UI的按钮图标。这些图标也位于GitHub仓库的`icons/`文件夹中，并作为**纹理类型：精灵（2D和UI）**导入。
- en: We now have our basic scene created, as well as prerequisite assets imported
    into the project. We used the `ARFramework` scene template created for this book
    when creating the new scene, and updated the UI title text for this project. If
    you're working on iOS, we also installed extra required packages into the project.
    Then, we imported other graphic assets we're going to use, including the demo
    AR Face Assets pack provided by Unity. Let's now configure the scene for face
    tracking.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了基本场景，并将必需的资产导入到项目中。我们创建新场景时使用了为本书创建的`ARFramework`场景模板，并更新了此项目的UI标题文本。如果您在iOS上工作，我们还向项目中安装了额外的必需包。然后，我们导入了我们将要使用的其他图形资产，包括Unity提供的demo
    AR Face Assets包。现在，让我们为人脸跟踪配置场景。
- en: Configuring a new AR scene for face tracking
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为人脸跟踪配置新的AR场景
- en: There are a few simple steps required to configure an AR Foundation-based scene
    for face tracking. Since we're going to do selfies, we'll set up the AR camera
    to use input from the front-facing camera. Then we'll add an AR Face Manager component
    to the AR Session Origin. If you want to use the Unity Onboarding UX animated
    graphic to prompt the user, you can adapt the `ScanMode` script for that.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 配置基于AR Foundation的场景进行人脸跟踪需要几个简单的步骤。由于我们将进行自拍，我们将设置AR相机使用前置摄像头的输入。然后，我们将向AR
    Session Origin添加一个AR Face Manager组件。如果您想使用Unity Onboarding UX动画图形来提示用户，您可以为此修改`ScanMode`脚本。
- en: Let's get started!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Setting the AR camera for selfies
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置AR相机用于自拍
- en: 'Use the following steps to set up the AR camera for selfies:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤设置AR相机用于自拍：
- en: In the **Hierarchy**, unfold the **AR Session Origin** game object and select
    its child **Main Camera**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中展开**AR Session Origin**游戏对象，并选择其子对象**Main Camera**。
- en: In the **Inspector**, set **AR Camera Manager** | **Facing Direction** to **User**.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**AR Camera Manager** | **面向方向**设置为**用户**。
- en: We also need to set the AR Session tracking mode for rotation only. Select the
    **AR Session** game object in the **Hierarchy**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将AR Session跟踪模式设置为仅旋转。在**层次结构**中选择**AR Session**游戏对象。
- en: In the **Inspector**, set the **AR Session** | **Tracking Mode** to **Rotation
    Only**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**AR Session** | **跟踪模式**设置为**仅旋转**。
- en: Next, we'll add the AR Face Manager component to the AR Session Origin.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把AR Face Manager组件添加到AR Session Origin中。
- en: Adding an AR Face Manager component
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加AR Face Manager组件
- en: Using the scene provided by the `ARFramework` template, we will replace the
    given AR trackable components with an **AR Face Manager** one. For the **Face
    Prefab**, we'll start with the **TriAxes** prefab from the AR Samples project.
    If you examine this prefab, you'll discover it has an **AR Face** component, so
    it can be used as a trackable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ARFramework`模板提供的场景，我们将用**AR Face Manager**组件替换给定的AR可跟踪组件。对于**Face Prefab**，我们将从AR
    Samples项目中的**TriAxes**预制件开始。如果您检查这个预制件，您会发现它有一个**AR Face**组件，因此它可以作为可跟踪对象使用。
- en: 'To configure the **AR Session** to track faces, follow these steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置**AR Session**以跟踪人脸，请按照以下步骤操作：
- en: In the **Hierarchy** window, select the **AR Session Origin** game object.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**AR Session Origin**游戏对象。
- en: In the **Inspector** window, use the *three-dot context menu* (or *right-click*)
    on the **AR Plane Manager** component, and select **Remove Component**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，在**AR Plane Manager**组件上使用*三点上下文菜单*（或*右键点击*），然后选择**移除组件**。
- en: Use the `AR`, and add an **AR Face Manager** component.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `AR`，并添加一个**AR Face Manager**组件。
- en: In your `Assets/ARF-samples/Prefabs/` folder), and drag it into the **Inspector**,
    dropping it onto the **AR Face Manager** | **Face Prefab** slot.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Assets/ARF-samples/Prefabs/`文件夹中），将其拖动到**检查器**中，并将其放置在**AR Face Manager**
    | **Face Prefab**槽中。
- en: Save the scene using **File** | **Save**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **保存**保存场景。
- en: The scene is now basically set up for face tracking. `ARFamework` includes a
    scan mode that prompts the user to find a trackable object with their camera.
    We can now configure that for face tracking.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 场景现在基本上已经为人脸跟踪设置好了。`ARFamework`包括一个提示用户使用相机寻找可跟踪对象的扫描模式。我们现在可以为此配置人脸跟踪。
- en: Prompting the user to find a face, or not
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示用户寻找人脸，或是不寻找
- en: Optionally, you can have your app prompt the user to scan for their face. This
    is less necessary when using the selfie camera (with **Facing Direction** set
    to **User**) because when you're holding your phone and looking at the screen,
    the camera is looking right back at you! But if your app were using the world-facing
    camera instead, it might be necessary to use an instructional prompt to tell the
    user to find a face.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以让应用提示用户扫描人脸。当使用自拍相机（**面向方向**设置为**用户**）时，这不太必要，因为当你拿着手机看屏幕时，相机正对着你！但如果你的应用使用面向世界的相机，可能需要使用指导提示告诉用户找到人脸。
- en: 'To skip the scan mode and its instructional prompt, tell the startup mode to
    proceed directly to the main mode, using the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要跳过扫描模式和其指导提示，告诉启动模式直接进入主模式，使用以下步骤：
- en: In the **Hierarchy**, under the **Interaction Controller** game object, select
    the **Startup Mode** object.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，在**Interaction Controller**游戏对象下，选择**Startup Mode**对象。
- en: In the `Main` into the **Next Mode** property.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`中，将**Next Mode**属性设置为**Next Mode**。
- en: 'Otherwise, if you want to use scan mode, you''ll need to write a `FaceScanMode`
    script as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果你想使用扫描模式，你需要编写一个如下的`FaceScanMode`脚本：
- en: In your `Scripts/` folder, *right-click* and select `FaceScanMode`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Scripts/`文件夹中，*右键点击*并选择`FaceScanMode`。
- en: 'Open the script for editing and replace its contents as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本进行编辑，并替换其内容如下：
- en: '[PRE0]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The script shows the `Update`, waits until a face is being tracked before transitioning
    the app to the main mode.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脚本显示`Update`，等待检测到人脸后再将应用切换到主模式。
- en: In Unity, in the **Hierarchy** window, select the **Scan Mode** object (under
    **Interaction Controller**).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，在**层次结构**窗口中，选择**Scan Mode**对象（在**Interaction Controller**下）。
- en: Remove the old **Scan Mode** component using the three-dot context menu and
    then choose **Remove Component**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三点上下文菜单删除旧的**Scan Mode**组件，然后选择**移除组件**。
- en: Drag the new `FaceScanMode` script onto the **Scan Mode** game object, adding
    it as a component.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`FaceScanMode`脚本拖到**Scan Mode**游戏对象上，添加为组件。
- en: Drag the **AR Session Origin** game object from the **Hierarchy** onto the **Face
    Scan Mode** | **Face Manager** slot.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR Session Origin**游戏对象从**层次结构**拖到**Face Scan Mode** | **Face Manager**槽中。
- en: In the **Hierarchy**, navigate and select **UI Canvas** | **Scan UI** | **Animated
    Prompt**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，导航并选择**UI Canvas** | **Scan UI** | **Animated Prompt**。
- en: In the **Inspector**, set the **Instruction** property to **Find A Face**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**Instruction**属性设置为**Find A Face**。
- en: With this latter setup, the app starts in startup mode. After the AR Session
    is running, it goes to scan mode, prompting the user to find a face. Once a face
    is detected, the app proceeds to main mode (as yet, this does nothing). You also
    have the option to skip the scan mode prompt altogether by telling the startup
    mode to go straight to the main mode.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个后置设置，应用以启动模式开始。在AR会话运行后，它进入扫描模式，提示用户找到人脸。一旦检测到人脸，应用进入主模式（目前，这什么也不做）。你也可以选择通过告诉启动模式直接进入主模式来完全跳过扫描模式提示。
- en: Let's make sure everything works so far. You're now ready to try to run the
    scene.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保到目前为止一切正常。你现在可以尝试运行场景。
- en: Build and run
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建并运行
- en: 'Let''s do a **Build And Run** on your device to ensure the project is set up
    correctly. Use the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在你的设备上进行**构建和运行**，以确保项目设置正确。使用以下步骤：
- en: Save your work using **File** | **Save**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **保存**保存你的工作。
- en: Select **File** | **Build Settings** to open the **Build Settings** window.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件** | **构建设置**以打开**构建设置**窗口。
- en: Click `FaceMaker` scene to **Scenes In Build**, and ensure it is the only scene
    in the list with a checkmark.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`FaceMaker`场景到**构建中的场景**，并确保它是列表中唯一带有勾选标记的场景。
- en: Ensure your target device is plugged into a USB port and is ready.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的目标设备已连接到USB端口并准备就绪。
- en: Click **Build And Run** to build the project.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建和运行**来构建项目。
- en: In the following screen capture, you can see the face pose is visualized using
    the **TriAxes** prefab. I have tilted my head to the side and back a little to
    make the three axes more evident.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图上，你可以看到人脸姿态是通过**TriAxes**预制件可视化的。我已经稍微倾斜了头部，以便更明显地看到三个轴。
- en: '![Figure 9.2 – Tracking the face pose, visualized with the TriAxes prefab'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 使用TriAxes预制件可视化跟踪人脸姿态'
- en: '](img/Figure_9.02_B15145.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B15145.jpg)'
- en: Figure 9.2 – Tracking the face pose, visualized with the TriAxes prefab
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 使用TriAxes预制件可视化跟踪人脸姿态
- en: Note the direction of each of the axes. The axes are colored red, green, and
    blue, corresponding to X, Y, and Z respectively. The positive Z direction is in
    the direction that the device camera is facing, and thus, pointing towards my
    back.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个轴的方向。轴的颜色为红色、绿色和蓝色，分别对应X、Y和Z。正Z方向是设备相机面对的方向，因此，指向我的背部。
- en: Now that we have face tracking running, let's substitute this **TriAxes** prefab
    with something more interesting – a whole 3D head model.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了面部追踪，让我们用更有趣的东西替换这个**TriAxes**预制件——一个完整的3D头模型。
- en: Tracking the face pose with 3D heads
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用3D头部追踪面部姿态
- en: The AR Face Assets package from Unity that we imported at the top of this chapter
    contains a couple of 3D head models we can use in our project. We'll create prefabs
    of each model and try them separately in the AR Face Manager **Face Prefab** property.
    In the next section, we'll create a menu so that the user can pick which head
    to view at runtime.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章顶部导入的Unity AR Face Assets包中包含了一些3D头模型，我们可以在我们的项目中使用。我们将为每个模型创建预制件，并在AR Face
    Manager的**Face Prefab**属性中分别尝试它们。在下一节中，我们将创建一个菜单，以便用户可以在运行时选择查看哪个头。
- en: Making a Mr. Plastic Head prefab
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作Mr. Plastic Head预制件
- en: 'The first head prefab will use the Plasticscene Head assets given in the Unity
    AR Face Assets package, and found in the `Assets/AR face Assets/3D Head/Plasticene
    Head/` folder. This folder contains an FBX model named `Plasto_Head` and a material
    named `PlasiceneHead` (the typo is theirs). The model will require some transform
    adjustments before it can be used as a face prefab. To create a prefab for this
    model, use the following steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个头部预制件将使用Unity AR Face Assets包中提供的Plasticscene Head资产，位于`Assets/AR face Assets/3D
    Head/Plasticene Head/`文件夹中。此文件夹包含一个名为`Plasto_Head`的FBX模型和一个名为`PlasiceneHead`的材质（错误是他们的）。在用作面部预制件之前，该模型需要一些变换调整。要为该模型创建预制件，请按照以下步骤操作：
- en: In the `Prefabs/` folder (create one first if necessary) and choose `MrPlasticHead`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prefabs/`文件夹中（如果需要，请先创建一个）并选择`MrPlasticHead`。
- en: Click **Open Prefab** to begin editing.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开预制件**开始编辑。
- en: With the root object selected, in the **Inspector**, click **Add Component**.
    Then, search and choose **AR Face** to add an **AR Face** component.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择根对象后，在**检查器**中点击**添加组件**。然后，搜索并选择**AR Face**来添加一个**AR Face**组件。
- en: From the `Plastic_Head` model to the **Hierarchy** and drop it as a child of
    **MrPlasticHead**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Plastic_Head`模型到**层次结构**，并将其作为**MrPlasticHead**的子对象拖放。
- en: Select the `180`, so it's facing the camera.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`180`，使其面向相机。
- en: Set `0.6, 0.6, 0.6`). Then set `-0.2`. I selected these transform settings by
    trial and error and using a measuring cube (see the inset *Tip*).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`0.6, 0.6, 0.6`。然后设置`-0.2`。我通过试错和使用测量立方体（见插图*提示*）选择了这些变换设置。
- en: If the default material (converted to URP) appears too dark, select the child
    **Plaso_Head/Plasto_Head** object, and in the **Inspector**, under the **Plasicene
    Head** material, set the **Base Map** color to white (from middle gray).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果默认材质（转换为URP）看起来太暗，请选择子对象**Plaso_Head/Plasto_Head**，然后在**检查器**中，在**Plasticene
    Head**材质下，将**基础贴图**颜色设置为白色（从中间灰色）。
- en: Save the prefab and exit back to the scene `0, 0, 0`), `0, 0, 0`), and `0.125,
    0.125, 0.125`). This can help you decide the transform parameters of other imported
    models you are using.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存预制件并退出回到场景`0, 0, 0`)，`0, 0, 0`)，和`0.125, 0.125, 0.125`）。这可以帮助你决定你使用的其他导入模型的变换参数。
- en: 'Let''s see how this looks. Add the prefab to the **AR Face Manager** and build
    the project as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这看起来怎么样。将预制件添加到**AR Face Manager**，并按照以下步骤构建项目：
- en: In the **Hierarchy** window, select the **AR Session Origin** game object.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**AR Session Origin**游戏对象。
- en: From the **Project** window, drag the **MrPlasticHead** prefab into the **Inspector**,
    dropping it onto **AR Face Manager** | the **Face Prefab** slot.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口，将**MrPlasticHead**预制件拖放到**检查器**中，将其拖放到**AR Face Manager** | **Face
    Prefab**槽中。
- en: Save the scene using **File** | **Save**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **保存**来保存场景。
- en: 'Build the project using `PlasticeneHead` material uses three textures for the
    **Base** (albedo), **Normal**, and **Occlusion** maps. The **Base** texture provides
    the albedo coloring as if the surface of the mesh were painted with these pixels.
    The Normal map (also known as the Bump map or Height map) lets the shader alter
    the mathematical surface normal vector in more detail than given by the mesh geometry
    itself, simulating surface textures that are especially noticeable with lighting.
    Finally, the **Occlusion** map provides additional realism by darkening deeper
    crevasses in the surface texture, creating higher contrast as occurs in real-life
    materials. For a more detailed explanation, starting with **Normal** maps, see
    the following URL: [https://docs.unity3d.com/Manual/StandardShaderMaterialParameterNormalMap.html](https://docs.unity3d.com/Manual/StandardShaderMaterialParameterNormalMap.html).'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PlasticeneHead`材质构建项目，该材质为**基础**（反照率）、**法线**和**遮挡**图使用了三种纹理。**基础**纹理提供了反照率着色，就像网格的表面被这些像素涂上一样。法线图（也称为凹凸图或高度图）允许着色器以比网格几何本身给出的更详细的方式改变数学表面法线向量，模拟出在光照下特别明显的表面纹理。最后，**遮挡**图通过加深表面纹理中的凹槽，提供额外的真实感，创造出类似于现实材料中的更高对比度。对于更详细的解释，从**法线**图开始，请参阅以下网址：[https://docs.unity3d.com/Manual/StandardShaderMaterialParameterNormalMap.html](https://docs.unity3d.com/Manual/StandardShaderMaterialParameterNormalMap.html)。
- en: 'A screen capture of me with a Mr. Plastic Head head is shown below, together
    with the Mr. Facet Head model that we''ll use next:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了我使用Mr. Plastic Head头部的屏幕截图，以及我们将要使用的Mr. Facet Head模型：
- en: '![Figure 9.3 – Screen capture of myself with MrPlasticHead (right) and MrFacetHead
    (left)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.3 – 屏幕截图：我使用MrPlasticHead（右）和MrFacetHead（左）]'
- en: '](img/Figure_9.03_B15145.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B15145.jpg)'
- en: Figure 9.3 – Screen capture of myself with MrPlasticHead (right) and MrFacetHead
    (left)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.3 – 屏幕截图：我使用MrPlasticHead（右）和MrFacetHead（左）
- en: Let's make the **MrFacetHead** prefab next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作**MrFacetHead**预制体。
- en: Making a Mr. Facet Head prefab
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作Mr. Facet Head预制体
- en: 'There is a second model provided in the AR Face Assets package, Faceted Head,
    found in the `Assets/AR face Assets/3D Head/Faceted Head/` folder. This folder
    contains an FBX model named `FacetedHead`, and a material also named `FacetedHead`.
    As before, the model will require some transform adjustments to be used as a face
    prefab. To create a prefab for this model, use the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: AR Face Assets包中提供了一个第二个模型，Faceted Head，位于`Assets/AR face Assets/3D Head/Faceted
    Head/`文件夹中。此文件夹包含一个名为`FacetedHead`的FBX模型和一个也命名为`FacetedHead`的材质。与之前一样，该模型需要一些变换调整才能用作面部预制体。要为该模型创建预制体，请按照以下步骤操作：
- en: In the `Prefabs/` folder and choose `MrFacetHead`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prefabs/`文件夹中，选择`MrFacetHead`。
- en: Click **Open Prefab** to begin editing.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开预制体**开始编辑。
- en: With the root object selected, in the **Inspector**, click **Add Component**.
    Then, search and choose **AR Face** to add an **AR Face** component.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择根对象后，在**检查器**中，点击**添加组件**。然后，搜索并选择**AR Face**以添加**AR Face**组件。
- en: From the `FacetedHead` model to the **Hierarchy** and drop it as a child of
    **MrFacetHead**.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`FacetedHead`模型到**层次**，并将其作为**MrFacetHead**的子对象放下。
- en: With the `-90` so that it's facing the camera. Set `1.1, 1.1, 1.1`).
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“-90”调整到面向摄像机的位置。设置`1.1, 1.1, 1.1`）。
- en: If the default material (converted to URP) appears too dark, select the **FacetedHead**
    object, and in its **Inspector** under the **FacetedHead** material, set the **Base
    Map** color to white.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果默认材质（转换为URP）看起来太暗，选择**FacetedHead**对象，并在其**检查器**下的**FacetedHead**材质中，将**基础图**颜色设置为白色。
- en: Save the prefab, and exit back to the scene **Hierarchy** window, using the
    **<** button at the top left of the window.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存预制体，并使用窗口左上角的**<**按钮返回到场景**层次**窗口。
- en: In the **Hierarchy** window, select the **AR Session Origin** game object.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中，选择**AR会话原点**游戏对象。
- en: From the **Project** window, drag the **MrFacetHead** prefab into the **Inspector**,
    dropping it onto the **AR Face Manager** | **Face Prefab** slot.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口，将**MrFacetHead**预制体拖到**检查器**中，将其放置在**AR Face Manager** | **Face Prefab**槽中。
- en: Save the scene using **File** | **Save**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **保存**保存场景。
- en: Build the project using **File** | **Build And Run**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **构建并运行**构建项目。
- en: When it runs, you now have a Mr. Faceted Head head, as shown in the preceding
    figure (yes, those are my real eyes peering through the mask).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行时，你现在有一个Mr. Faceted Head头，如图所示（是的，那些是我的真实眼睛透过面具看出去的）。
- en: In this section, we created two prefabs, **MrPlasticHead** and **MrFacetHead**,
    using assets from the Unity *AR Face Assets* package that we imported earlier.
    Each of these has an AR Foundation **AR Face** component on its root GameObject
    and different imported models for the two heads. We tried using one of these in
    our app by adding it to the **AR Face Manager** component and running the scene.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了两个 prefab，**MrPlasticHead** 和 **MrFacetHead**，使用我们之前导入的 Unity *AR
    Face Assets* 包中的资产。每个这些 prefab 都在其根 GameObject 上有一个 AR Foundation **AR Face**
    组件，并为两个头部导入不同的模型。我们尝试在我们的应用中使用其中一个，通过将其添加到 **AR Face Manager** 组件并运行场景来测试。
- en: Wouldn't it be nice to let the user choose a head at runtime, rather than manually
    setting the AR Face Manager and rebuilding the project? Next, let's create a main
    menu, and a changeable face prefab we can control from the menu buttons.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户可以在运行时选择头部，而不是手动设置 AR Face Manager 并重新构建项目，那岂不是很好？接下来，让我们创建一个主菜单和一个可从菜单按钮控制的可变脸
    prefab。
- en: Building the Main mode and menu
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Main 模式和菜单
- en: In this section, we will set up the main mode app to handle user interactions,
    including face filter selections from a main menu. To do this, we first need to
    create a changeable face prefab that can be told which facial features to display.
    We'll write a `FaceMainMode` script that displays the main UI panel and passes
    change requests from the user to the face object. Then, we'll make a main menu
    with a set of horizontally scrolling buttons that the user can tap to change face
    filters.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置主模式应用以处理用户交互，包括从主菜单中选择面部滤镜。为此，我们首先需要创建一个可变脸 prefab，可以指定要显示哪些面部特征。我们将编写一个
    `FaceMainMode` 脚本，显示主 UI 面板并将用户的更改请求传递给面部对象。然后，我们将制作一个带有水平滚动按钮的主菜单，用户可以点击这些按钮来更改面部滤镜。
- en: Creating a changeable face prefab
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可变脸 prefab
- en: 'To create a face prefab that we can use for dynamically changing filters during
    runtime, we''ll start with an empty game object with an AR Face component, and
    add a script for setting the contained prefab object. Use the following steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个在运行时可以动态更改滤镜的 face prefab，我们将从一个带有 AR Face 组件的空游戏对象开始，并添加一个用于设置包含的 prefab
    对象的脚本。按照以下步骤操作：
- en: In the `Prefabs/` folder and choose `Changeable Face Prefab`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Prefabs/` 文件夹中并选择 `Changeable Face Prefab`。
- en: Click **Open Prefab** to begin editing.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **打开 Prefab** 以开始编辑。
- en: With the root object selected, in the **Inspector**, click **Add Component**.
    Search for and choose **AR Face** to add an **AR Face** component.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择根对象后，在 **Inspector** 中点击 **添加组件**。搜索并选择 **AR Face** 以添加 **AR Face** 组件。
- en: In your `Scripts/` folder, *right-click* and select `ChangeableFace`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Scripts/` 文件夹中，*右键点击* 并选择 `ChangeableFace`。
- en: 'Open the script for editing and replace its contents as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本进行编辑，并按照以下内容替换其内容：
- en: '[PRE1]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The script exposes a public `SetPosePrefab` function that instantiates the `prefab`
    argument as a child of the current object. If the requested prefab is already
    instantiated, the request is ignored. If there was a previously instantiated object,
    it is first destroyed. The function can be called with a null value for the `prefab`
    argument that will only clear the existing instantiated object.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该脚本公开了一个 `SetPosePrefab` 公共函数，该函数将 `prefab` 参数实例化为当前对象的子对象。如果请求的 prefab 已经实例化，则忽略请求。如果有之前实例化的对象，它首先被销毁。该函数可以用
    `prefab` 参数的 null 值调用，这将仅清除现有的实例化对象。
- en: Save the script and, back in Unity, drag the `ChangeableFace` script onto the
    **Changeable Face Prefab** root object.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，然后在 Unity 中，将 `ChangeableFace` 脚本拖放到 **Changeable Face Prefab** 根对象上。
- en: Save the prefab and exit back to the scene hierarchy using the **<** button
    at the top left of the window.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 prefab 并使用窗口左上角的 **<** 按钮退出回到场景层次结构。
- en: In the **Hierarchy**, select the **AR Session Origin** object. From the **Project**
    window, drag the **Changeable Face Prefab** into the **Inspector**, dropping it
    onto the **AR Face Manager** | **Face Prefab** slot.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 中选择 **AR Session Origin** 对象。从 **Project** 窗口，将 **Changeable
    Face Prefab** 拖入 **Inspector**，并将其放置在 **AR Face Manager** | **Face Prefab** 槽中。
- en: We now have a `ChangeableFace` script. We are planning to call its `SetPosePrefab`
    function from the main mode in response to a user button click. We should set
    up the main mode now.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `ChangeableFace` 脚本。我们计划在主模式中响应用户按钮点击时调用其 `SetPosePrefab` 函数。我们现在应该设置主模式。
- en: Writing a main mode controller script
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写主模式控制器脚本
- en: 'In our ARFramework template, interaction modes are represented with game objects
    under the interaction controller and are activated when a specific mode is enabled.
    The default `MainMode` script from the template is simply a placeholder. We should
    replace it now with a custom script for this project. To do so, follow these steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ARFramework模板中，交互模式通过交互控制器下的游戏对象表示，并在启用特定模式时激活。模板中的默认`MainMode`脚本只是一个占位符。我们现在应该用这个项目的自定义脚本替换它。为此，请按照以下步骤操作：
- en: In the `FaceMainMode`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FaceMainMode`。
- en: In the **Hierarchy**, select the **Main Mode** game object (under **Interaction
    Controller**).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**主模式**游戏对象（位于**交互控制器**下）。
- en: In the **Inspector**, remove the default **Main Mode** component using the three-dot
    menu, then click **Remove Component**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，使用三点菜单移除默认的**主模式**组件，然后点击**移除组件**。
- en: Drag the new `FaceMainMode` script onto the **Main Mode** object, adding it
    as a component.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`FaceMainMode`脚本拖放到**主模式**对象上，添加为组件。
- en: 'Open the `FaceMainMode` script for editing, and start it as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FaceMainMode`脚本进行编辑，并按照以下步骤启动：
- en: '[PRE2]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the main mode is enabled, it shows the main UI panel. This will contain
    the main menu buttons. When a menu button is clicked and it calls `ChangePosePrefab`,
    that in turn will call `SetPosePrefab` for any trackable faces in the scene.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当主模式启用时，它显示主UI面板。这将包含主菜单按钮。当点击菜单按钮并调用`ChangePosePrefab`时，它将依次调用场景中任何可跟踪人脸的`SetPosePrefab`。
- en: Let's create the menu UI next.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建菜单UI。
- en: Creating scrollable main menu buttons
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可滚动的主菜单按钮
- en: 'In our user framework, a mode''s UI panel will be enabled by the corresponding
    interaction mode. We''ll now add a horizontally-scrolling main menu to the main
    UI panel with buttons that can change the tracked face. Use the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用户框架中，一个模式的UI面板将通过相应的交互模式启用。现在，我们将添加一个水平滚动的菜单到主UI面板，其中包含可以更改跟踪人脸的按钮。请按照以下步骤操作：
- en: In the `MainMenu Panel`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainMenu Panel`。
- en: In the **Inspector**, use the **Anchor Presets** option (at the upper left of
    **Rect Transform**) to set **Bottom-Stretch**, then use *Shift + Alt + left-click
    Bottom-Stretch*.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，使用**锚点预设**选项（位于**矩形变换**的右上角）设置**底部拉伸**，然后使用*Shift + Alt + 左键点击底部拉伸*。
- en: Set `150`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`150`。
- en: Remove its **Image** component with the three-dot menu, then **Remove Component**
    (we won't have a background on this menu).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三点菜单移除其**图像**组件，然后**移除组件**（我们不会在这个菜单上使用背景）。
- en: In the **Hierarchy**, *right-click* the **MainMenu Panel**, and select **UI**
    | **Scroll View**.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，*右键点击***MainMenu Panel**，然后选择**UI** | **滚动视图**。
- en: Use **Anchor Presets** to click the **Stretch-Stretch** option, and then use
    *Shift + Alt + left-click Stretch-Stretch*.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**锚点预设**点击**拉伸-拉伸**选项，然后使用*Shift + Alt + 左键点击拉伸-拉伸*。
- en: Remove the **Image** component.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除**图像**组件。
- en: In the **Scroll Rect** component, uncheck **Vertical**.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**滚动矩形**组件中，取消勾选**垂直**。
- en: Delete the content of the **Horizontal Scrollbar** and **Vertical Scrollbar**
    fields, and disable (or delete) the **Scrollbar Horizontal** and **Scrollbar Vertical**
    game objects in the hierarchy.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**水平滚动条**和**垂直滚动条**字段的内容，并在层次结构中禁用（或删除）**滚动条水平**和**滚动条垂直**游戏对象。
- en: In the **Hierarchy**, unfold the child **Viewport** game object, and select
    the child **Content** game object.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，展开子**视口**游戏对象，并选择子**内容**游戏对象。
- en: Click **Add Component**, then search for and select **Horizontal Layout Group**.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加组件**，然后搜索并选择**水平布局组**。
- en: Uncheck all of its checkboxes, including **Child Force Expand** | **Width**
    and **Height**.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选所有复选框，包括**子强制扩展** | **宽度**和**高度**。
- en: Set `5`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`5`。
- en: Click **Add Component**, then search for and select **Content Size Fitter**.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加组件**，然后搜索并选择**内容大小适配器**。
- en: Set **Horizontal Fit** to **Preferred Size**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**水平适配**设置为**首选大小**。
- en: 'We now have a **MainMenu Panel** under **Main UI**. It contains a horizontally-scrolling
    content area, as shown in the following screenshot of the UI hierarchy with the
    **Content** object selected:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在**主UI**下有一个**MainMenu Panel**。它包含一个水平滚动的内容区域，如下面的UI层次结构截图所示，其中选择了**内容**对象：
- en: '![Figure 9.4 – Main UI hierarchy with content inspector shown'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 显示内容检查器的主UI层次结构]'
- en: '](img/Figure_9.04_B15145.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.04_B15145.jpg]'
- en: Figure 9.4 – Main UI hierarchy with content inspector shown
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 显示内容检查器的主UI层次结构
- en: 'We can now add buttons to the **Content** container. For now, we''ll create
    just two buttons, for the two heads. Later, we''ll expand it with more options.
    Each button will display an image icon (if you don''t have an icon for your own
    content, you can use text labels):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向**内容**容器添加按钮。目前，我们将创建两个按钮，用于两个头部。稍后，我们将通过更多选项来扩展它。每个按钮将显示一个图像图标（如果您没有自己内容的图标，可以使用文本标签）：
- en: In the `PlasticHead Button`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlasticHead Button`。
- en: Set its `150, 150`).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其`150, 150`）。
- en: Remove its child **Text** object (unless you don't have an icon image for this
    button).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除其子**文本**对象（除非您没有为该按钮的图标图像）。
- en: From the `plastichead icon` image asset (perhaps found in your `/icons` folder)
    onto the **Image** | **Source Image** slot.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`plastichead icon`图像资产（可能位于您的`/icons`文件夹中）到**图像** | **源图像**槽位。
- en: In the **Inspector**, click the **+** button at the bottom right of the **On
    Click** area of the **Button** component.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，点击**按钮**组件**On Click**区域右下角的**+**按钮。
- en: From the **Hierarchy**, drag the **Main Mode** object (under **Interaction Controller**),
    into the **Inspector**, and drop it onto the **On Click Object** slot.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**中，将**主模式**对象（在**交互控制器**下），拖到**检查器**中，并将其放到**On Click Object**槽位。
- en: In the **Function** selection list, choose **FaceMainMode** | **ChangePosePrefab**.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**功能**选择列表中，选择**FaceMainMode** | **ChangePosePrefab**。
- en: 'From the `Prefabs/` folder) onto the empty parameter slot, as shown in the
    following screenshot:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Prefabs/`文件夹)到下面的空参数槽位，如图下所示：
- en: '![Figure 9.5 – The PlasticHead button''s On Click action will pass the MrPlasticHead
    prefab to the FaceMainMode.ChangePosePrefab function'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 – PlasticHead按钮的On Click动作会将MrPlasticHead预制体传递给FaceMainMode.ChangePosePrefab函数'
- en: '](img/Figure_9.05_B15145.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.05_B15145.jpg)'
- en: Figure 9.5 – The PlasticHead button's On Click action will pass the MrPlasticHead
    prefab to the FaceMainMode.ChangePosePrefab function
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – PlasticHead按钮的On Click动作会将MrPlasticHead预制体传递给FaceMainMode.ChangePosePrefab函数
- en: 'Tip: Creating button icons'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：创建按钮图标
- en: To create many of the button icons used in this chapter, I sometimes start by
    making a screen capture of the actual game object. Then, in Photoshop, I isolate
    the shape by selecting its edges (using the Magic Wand tool) and make a cutout
    with a transparent background. I then crop the image on a square-shaped canvas
    and resize it to 256x256, before exporting it as a PNG file. Then, in Unity, I
    import the image and, in **Import Settings**, set **Texture Type** to **Sprite
    (2D or UI)**, and click **Apply**. The asset can now be used as a UI sprite in
    an image component like those on button objects.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建本章中使用的许多按钮图标，我有时会先制作实际游戏对象的屏幕截图。然后，在Photoshop中，通过选择其边缘（使用魔棒工具）来隔离形状，并制作一个带有透明背景的剪影。然后，我在一个方形画布上裁剪图像，并将其调整大小为256x256，然后将其导出为PNG文件。然后，在Unity中导入图像，并在**导入设置**中，将**纹理类型**设置为**精灵（2D或UI**），然后点击**应用**。现在，该资产可以作为UI精灵在图像组件中使用，如按钮对象上的那些。
- en: 'We now have one button in the **Main Menu**. This is for selecting the MrPlasticHead
    model. Let''s make a second button, for the MrFacetHead prefab. To do that, we
    can duplicate and modify the first button, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在**主菜单**中有一个按钮。这是用于选择MrPlasticHead模型的。让我们再创建一个按钮，用于MrFacetHead预制体。为此，我们可以复制并修改第一个按钮，如下所示：
- en: In the **Hierarchy**, select the **PlasticHead Button** game object.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**PlasticHead按钮**游戏对象。
- en: From the main menu, select `FacetHead Button`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单，选择`FacetHead Button`。
- en: From the `facethead icon` asset onto the **Image** | **Source Image** slot.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`facethead icon`资产到**图像** | **源图像**槽位。
- en: From the `Prefabs/` folder) onto the parameter slot (replacing the **MrPlasticHead**
    prefab already there).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Prefabs/`文件夹)到参数槽位（替换已存在的**MrPlasticHead**预制体）。
- en: The **Main Menu** now has two buttons. When the app runs, clicking one will
    show **MrPlasticHead** on my face. Clicking the other will show **MrFacetHead**.
    It would also be nice to offer a reset button that clears all the face filters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**主菜单**现在有两个按钮。当应用运行时，点击其中一个将在我脸上显示**MrPlasticHead**。点击另一个将显示**MrFacetHead**。提供重置按钮以清除所有面部过滤器也会很好。'
- en: Adding a reset face button
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加重置面部按钮
- en: 'We can also add a reset button that sets the current pose object to null. Let''s
    do this as a separate function in the `FaceMainMode` script. Use the following
    steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个重置按钮，将当前姿势对象设置为null。让我们在`FaceMainMode`脚本中作为一个单独的函数来做这件事。使用以下步骤：
- en: 'Open the `FaceMainMode` script for editing, and add a `ResetFace` function:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FaceMainMode`脚本进行编辑，并添加一个`ResetFace`函数：
- en: '[PRE3]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Unity, under `Reset Button`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，在`Reset Button`下。
- en: Set its `150, 150`). Remove its **Image** component.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其`150, 150`）。移除其**图像**组件。
- en: On its child `Reset`, check the **Auto Size** checkbox, and change the text
    **Vertex Color**, if you want.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其子`Reset`上，勾选**自动大小**复选框，如果你想的话，更改文本**顶点颜色**。
- en: Click the **+** button on the **On Click** list, drag the **Main Mode** object
    onto the **Object** slot, and select **FaceMainMode** | **ResetFace** from the
    **Function** list.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**点击**列表中的**+**按钮，将**主模式**对象拖放到**对象**槽中，并从**函数**列表中选择**FaceMainMode** | **ResetFace**。
- en: 'My main menu, at the bottom of the screen, now looks like this with its three
    buttons:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我的菜单，在屏幕底部，现在看起来是这样的，有三个按钮：
- en: '![Figure 9.6 – The Main Menu with three buttons'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 带有三个按钮的主菜单'
- en: '](img/Figure_9.06_B15145.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.06_B15145.jpg)'
- en: Figure 9.6 – The Main Menu with three buttons
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 带有三个按钮的主菜单
- en: You're now ready to build and run the project. Save your work (**File** | **Save**)
    and build it (**File** | **Build and Run**). You now have a little Face Maker
    app that lets you choose between 3D heads or **resetting the scene**!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以构建并运行项目了。保存你的工作（**文件** | **保存**）并构建它（**文件** | **构建和运行**）。你现在有一个小小的Face
    Maker应用，它允许你选择3D头像或**重置场景**！
- en: In this section, we created a **Changeable Face Prefab** that you can set the
    child prefab of at runtime so the user can select different head models for their
    selfie. We then created a **Main Menu** panel with horizontally scrollable buttons,
    and added buttons that allow the user to choose **MrPlasticHead**, **MrFacetHead**,
    or to reset the current model.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个**可更换的面部预制件**，你可以在运行时设置其子预制件，以便用户可以为他们的自拍选择不同的头像模型。然后我们创建了一个**主菜单**面板，其中包含水平可滚动的按钮，并添加了允许用户选择**MrPlasticHead**、**MrFacetHead**或重置当前模型的按钮。
- en: Next, let's add some 3D accessories to your face – sunglasses and a hat.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们给你的脸添加一些3D配饰——太阳镜和帽子。
- en: Attaching 3D Accessories
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加3D配饰
- en: Suppose you now want to accessorize your face and head. The setup is very similar
    to the pose prefabs we just used. For this, we will introduce a couple of third-party
    models downloaded from the web (and imported into your project at the top of this
    chapter). We'll also add an `AddAccessory` function to the **Changeable Face Prefab**
    that allows the user to view more than one accessory at a time.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在想给你的脸和头添加配饰。设置与我们所使用的姿势预制件非常相似。为此，我们将介绍一些从网络下载的第三方模型（并在本章顶部导入到你的项目中）。我们还将向**可更换的面部预制件**添加一个`AddAccessory`函数，允许用户一次查看多个配饰。
- en: Wearing a hat
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 戴着帽子
- en: I found a 3D hat on the internet ([https://free3d.com/3d-model/cartola-278168.html](https://free3d.com/3d-model/cartola-278168.html)),
    and we downloaded and installed it earlier in this chapter. Feel free to use this
    model and/or find your own model to add to the project. I installed it in my `Assets/Models/TopHat/`
    folder. The model is an FBX file named `CapCartola`. We'll also need to configure
    its materials.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我在网上找到了一个3D帽子（[https://free3d.com/3d-model/cartola-278168.html](https://free3d.com/3d-model/cartola-278168.html)），我们之前在本章中下载并安装了它。请随意使用此模型，或找到自己的模型添加到项目中。我将其安装在我的`Assets/Models/TopHat/`文件夹中。该模型是一个名为`CapCartola`的FBX文件。我们还需要配置其材质。
- en: 'If you select the `CapCartola` model in the **Project** window and unfold it,
    you''ll notice it has child **Camera** and **Light** objects. This is not unusual
    for models exported from some 3D modeling programs such as Blender, for example.
    We obviously do not need these in our scene, so we''ll also remove them from the
    imported model. Then we''ll extract and set up the materials, and then put them
    together as a prefab. Follow these steps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择**项目**窗口中的`CapCartola`模型并将其展开，你会注意到它有子**相机**和**灯光**对象。这对于从某些3D建模程序（例如Blender）导出的模型来说并不罕见。显然，我们不需要这些对象在我们的场景中，所以我们将从导入的模型中移除它们。然后我们将提取并设置材质，然后将它们作为一个预制件组合在一起。按照以下步骤操作：
- en: In the `CapCartola` model (in the `Assets/Models/TopHat/` folder).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CapCartola`模型（位于`Assets/Models/TopHat/`文件夹中）。
- en: In the **Inspector**, you'll see **Import Settings**. Make sure the **Model**
    tab is selected at the top of the window.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，你会看到**导入设置**。确保窗口顶部的**模型**选项卡被选中。
- en: Uncheck the **Import Cameras** and **Import Lights** checkboxes. Then click
    **Apply**.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择**导入相机**和**导入灯光**复选框。然后点击**应用**。
- en: Select the **Materials** tab at the top of the **Inspector** window.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口的顶部选择**材质**选项卡。
- en: Click the `Material.001` (for the hat itself) and `Material.002` (for its ribbon
    band). These are already associated with the model.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Material.001`（用于帽子本身）和`Material.002`（用于其丝带带）。这些已经与模型关联。
- en: In the `Prefabs/` folder and select `TopHat`. Then open the prefab for editing.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prefabs/`文件夹中，选择`TopHat`。然后打开预制体进行编辑。
- en: From the **Project** window, drag the **CapCartola** model into the **Hierarchy**,
    creating a child instance under the root **TopHat** object.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口，将**CapCartola**模型拖入**层次结构**中，在根**TopHat**对象下创建一个子实例。
- en: With `0, 0.18, -0.02`), `(-20, 0, 0`), and `0.077, 0.077, 0.077`).
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`(0, 0.18, -0.02)`，`(-20, 0, 0)`，和`0.077, 0.077, 0.077)`）。
- en: Unfold **CapCartola** in the **Hierarchy** and select its child **Cylinder**
    object.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中展开**CapCartola**，并选择其子**Cylinder**对象。
- en: In the `#331D1D`).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`#331D1D`下）。
- en: Likewise, under `#FF1919`).
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在`#FF1919`下）。
- en: If you add an **AR Face** component to the root object, you can test it out
    right away by using it as the **AR Face Manager** | **Face Prefab**.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将**AR Face**组件添加到根对象中，你可以立即通过将其用作**AR Face Manager** | **面部预制体**来测试它。
- en: '**Save** the prefab and exit back to the scene hierarchy.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**预制体并退出场景层次结构。'
- en: You now have a **TopHat** prefab that you can use to accessorize your face.
    Let's also add sunglasses.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个可以用来装饰你脸部的**TopHat**预制体。让我们也添加一副太阳镜。
- en: Sporting cool sunglasses
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摩登太阳镜
- en: I found a 3D sunglasses model on the internet ([https://free3d.com/3d-model/sunglasses-v1--803862.html](https://free3d.com/3d-model/sunglasses-v1--803862.html)),
    which we downloaded and installed earlier in this chapter. I installed it in my
    `Assets/Models/Sunglasses/` folder. The original model is an OBJ file named `12983_Sunglasses_v2_l3`.
    We'll also need to configure its materials.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我在网上找到了一个3D太阳镜模型（[https://free3d.com/3d-model/sunglasses-v1--803862.html](https://free3d.com/3d-model/sunglasses-v1--803862.html)），我们之前在本章中已下载并安装。我将其安装在我的`Assets/Models/Sunglasses/`文件夹中。原始模型是一个名为`12983_Sunglasses_v2_l3`的OBJ文件。我们还需要配置其材质。
- en: 'Extract and set up the materials, and then put the model together as a prefab
    using the following steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤提取并设置材质，然后将模型组装成预制体：
- en: In the `12983_Sunglasses_v2_l3` model and select it.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`12983_Sunglasses_v2_l3`模型中选择它。
- en: In the `sunglasses_body` and `sunglasses_lens`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sunglasses_body`和`sunglasses_lens`中。
- en: Select the **sunglasses_body** material and adjust it as you desire. I made
    mine black. The lens material may be fine as is (dark with transparency).
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**sunglasses_body**材质并根据需要调整它。我将其设置为黑色。镜片材质可能已经是好的（深色且有透明度）。
- en: In the `Prefabs/` folder and select `Sunglasses`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prefabs/`文件夹中，选择`Sunglasses`。
- en: Open the **Sunglasses** prefab for editing.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**太阳镜**预制体进行编辑。
- en: From the **Project** window, drag the **12983_Sunglasses_v2_l3** model into
    the **Hierarchy**, creating a child instance under the root **Sunglasses**.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口，将**12983_Sunglasses_v2_l3**模型拖入**层次结构**中，在根**Sunglasses**对象下创建一个子实例。
- en: With `-0.08, -0.025, -0.058`), `(-90, 90, 09`), and `0.0235, 0.0235, 0.0235`).
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`(-0.08, -0.025, -0.058)`，`(-90, 90, 09)`，和`0.0235, 0.0235, 0.0235)`）。
- en: If you also add an **AR Face** component to the root object, you can test it
    out right away by using it as the **AR Face Manager** | **Face Prefab**.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你也在根对象中添加了**AR Face**组件，你可以立即通过将其用作**AR Face Manager** | **面部预制体**来测试它。
- en: Save the prefab and exit back to the scene hierarchy.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存预制体并退出场景层次结构。
- en: We now have two models we can use as face accessories. You can test them out
    by manually adding one to the **AR Session Origin** | **AR Face Manager** | **Face
    Prefab** slot and building and running the project. When you're done, don't forget
    to put the **Changeable Face Prefab** back into the slot.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个可以作为面部配饰使用的模型。你可以通过手动将其中一个添加到**AR会话起源** | **AR面部管理器** | **面部预制体**槽位，构建并运行项目来测试它们。完成后，别忘了将**可更换面部预制体**放回槽位。
- en: Next, we'll add support for these accessories in the scripts.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在脚本中添加对这些配饰的支持。
- en: Updating the scripts for accessories
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新配饰脚本
- en: We need to update the `ChangeableFace` script to manage the accessory objects.
    It will maintain a list of the current accessory objects, ensuring we create only
    one instance of any prefab.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新`ChangeableFace`脚本以管理配饰对象。它将维护当前配饰对象的列表，确保我们只创建任何预制体的一个实例。
- en: Instead of destroying an accessory object when it's removed from the scene,
    we'll disable it, and then re-enable it if the user adds the same object again.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当从场景中移除一个配饰对象时，我们不会销毁它，而是将其禁用，如果用户再次添加相同的对象，我们再重新启用它。
- en: We also need to update the `FaceMainMode` script with a function that the menu
    buttons can call. This in turn passes the requested prefab to `ChangeableFace`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`FaceMainMode`脚本，添加一个菜单按钮可以调用的函数。这反过来会将请求的预制体传递给`ChangeableFace`。
- en: 'Use the following steps to update your scripts:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤更新你的脚本：
- en: 'Begin by opening the `ChangeableFace` script for editing and add the following
    declaration at the top of the class:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`ChangeableFace`脚本进行编辑，并在类的顶部添加以下声明：
- en: '[PRE4]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We're using a dictionary to maintain the list of instantiated accessory objects,
    keyed by the prefab.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用字典来维护已实例化配件对象的列表，键为预制件。
- en: 'Then, add an `AddAccessory` function as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下`AddAccessory`函数：
- en: '[PRE5]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`AddAccessory` instantiates the prefab as a child of the face and adds it to
    the `accessories` list. However, if the prefab has already been instantiated,
    we remove it from the scene by setting it as inactive. Likewise, if you try to
    add it again, it is reactivated.'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AddAccessory`将预制件实例化为脸部的子对象，并将其添加到`accessories`列表中。然而，如果预制件已经被实例化，我们将通过将其设置为非活动状态来从场景中移除它。同样，如果你再次尝试添加它，它将被重新激活。'
- en: 'Next, we''ll add a `ResetAccessories` function that removes all accessories,
    as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个`ResetAccessories`函数，用于移除所有配件，如下所示：
- en: '[PRE6]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Tip: Avoid garbage collection by using object caching'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士：通过使用对象缓存来避免垃圾回收
- en: In this `AddAccessory` function, I could have called `Destroy` to remove an
    existing instance, and then called `Instantiate` again if and when the object
    was added a second time. Instead, I'm managing memory by simply disabling existing
    objects when not wanted and reusing the same instances when requested. Repeatedly
    instantiating and destroying objects at runtime can cause memory fragmentation
    and require Unity to perform memory `Destroy`.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个`AddAccessory`函数中，我本可以调用`Destroy`来移除现有的实例，然后在对象第二次添加时再次调用`Instantiate`。相反，我通过在不需要时简单地禁用现有对象并在需要时重用相同的实例来管理内存。在运行时重复实例化和销毁对象会导致内存碎片化，并需要Unity执行内存`Destroy`。
- en: 'Next, we can open the `FaceMainMenu` script for editing, and add an `AddAccessory`
    function that will be called by the menu buttons, as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以打开`FaceMainMenu`脚本进行编辑，并添加一个将被菜单按钮调用的`AddAccessory`函数，如下所示：
- en: '[PRE7]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, add the following highlighted code to `ResetFace`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下突出显示的代码添加到`ResetFace`：
- en: '[PRE8]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're now ready to add menu buttons for the TopHat and Sunglasses accessories.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好为高顶礼帽和太阳镜配件添加菜单按钮。
- en: Adding accessories to the main menu
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主菜单中添加配件
- en: 'To add new buttons to the main menu, we can duplicate an existing button and
    modify it by following these steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要向主菜单添加新按钮，我们可以复制一个现有的按钮，并按照以下步骤修改它：
- en: In the `HatAccessory Button`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HatAccessory Button`上。
- en: From the `tophat icon` asset onto the **Image** | **Source Image** slot.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`tophat icon`资产拖放到**图像** | **源图像**槽位。
- en: On the `FaceMainMode.AddAccessory`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FaceMainMode.AddAccessory`上。
- en: From the `Prefabs/` folder) onto the parameter slot.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Prefabs/`文件夹拖放到参数槽位。
- en: Likewise, repeat *steps 1-4* for a `SunglassesAcessory Button`, using the `sunglasses
    icon` image and the **Sunglasses** prefab asset.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，重复*步骤1-4*为`SunglassesAcessory Button`，使用`sunglasses icon`图像和**太阳镜**预制件资产。
- en: Save the scene and build the project. When you tap the hat button, you're wearing
    a top hat. Tap it again to remove it. In the following screen capture, I'm wearing
    the facet face, top hat, and sunglasses. I've never looked so cool!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景并构建项目。当你点击帽子按钮时，你将戴上高顶礼帽。再次点击以取下它。在下面的屏幕截图中，我戴着面罩、高顶礼帽和太阳镜。我从未看起来这么酷！
- en: '![Figure 9.7 – Selfie with me wearing a top hat, sunglasses, and faceted face
    at the same time'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 我戴着高顶礼帽、太阳镜和面罩的自拍](img/Figure_9.07_B15145.jpg)'
- en: '](img/Figure_9.07_B15145.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 我戴着高顶礼帽、太阳镜和面罩的自拍](img/Figure_9.07_B15145.jpg)'
- en: Figure 9.7 – Selfie with me wearing a top hat, sunglasses, and faceted face
    at the same time
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 我戴着高顶礼帽、太阳镜和面罩的自拍
- en: In this section, we built upon the basic face pose tracking features by adding
    other models to be tracked at the same time. We created prefabs for the TopHat
    and Sunglasses using models download from the web. Then, we updated the `ChangeableFace`
    script to handle multiple accessory objects. This implements good memory management
    practices by avoiding duplicate instances of the same prefab and caching the spawned
    instances in a dictionary list. After updating the `FaceMainMode` script with
    a public `AddAccessory` function, we added new buttons to the main menu so that
    the user can accessorize their head with a hat and/or sunglasses.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过添加其他要同时跟踪的模型来扩展了基本的面部姿态跟踪功能。我们使用从网络上下载的模型创建了高顶礼帽和太阳镜的预制件。然后，我们更新了`ChangeableFace`脚本以处理多个配件对象。通过避免相同预制件的重复实例并缓存生成的实例在字典列表中，我们实现了良好的内存管理实践。在将公共`AddAccessory`函数更新到`FaceMainMode`脚本后，我们在主菜单中添加了新的按钮，以便用户可以用帽子和/或太阳镜装饰他们的头部。
- en: So far, all our faces are fixed-expression static models. AR Foundation also
    supports the dynamic visualization of faces. Let's try that next.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的面部都是固定表情的静态模型。AR Foundation 也支持面部的动态可视化。让我们尝试一下。
- en: Making dynamic face meshes with a variety of materials
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用各种材料制作动态面部网格
- en: To show an augmented face that matches your real-life expressions, Unity AR
    Foundation lets you generate a face mesh dynamically at runtime. On this mesh,
    you can apply different materials, giving the effect of you wearing arbitrary
    face masks. To add this to our project, we'll first look at the default face game
    object given by AR Foundation. Then we'll create several different materials to
    use. To integrate this feature into our project, we'll extend the `ChangeableFace`
    script to switch materials, add a similar function to the `FaceMainMode` script
    to update the face trackables, and then add menu buttons to switch materials.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示与你的真实表情匹配的增强现实面部，Unity AR Foundation 允许你在运行时动态生成面部网格。在这个网格上，你可以应用不同的材料，产生你戴着任意面部面具的效果。为了将此功能添加到我们的项目中，我们首先查看
    AR Foundation 提供的默认面部游戏对象。然后我们将创建几个不同的材料来使用。为了将此功能集成到我们的项目中，我们将扩展 `ChangeableFace`
    脚本来切换材料，向 `FaceMainMode` 脚本添加一个类似的功能来更新面部跟踪器，然后添加菜单按钮来切换材料。
- en: Exploring AR Default Face
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 AR 默认面部
- en: 'You can create a dynamic face game object for AR Foundation from the Unity
    menu at **GameObject** | **XR** | **AR Default Face**. The object includes an
    **AR Face Mesh Visualizer** component that generates a face mesh at runtime that
    matches your facial expressions, including moving your mouth and raising your
    eyebrows. Let''s quickly try it out before we add this feature to our **Changeable
    Face Prefab**. Use the following steps:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 Unity 菜单的 **GameObject** | **XR** | **AR Default Face** 创建一个用于 AR Foundation
    的动态面部游戏对象。该对象包含一个 **AR Face Mesh Visualizer** 组件，该组件在运行时生成与你的面部表情匹配的面部网格，包括移动你的嘴巴和扬起你的眉毛。在我们将此功能添加到我们的
    **Changeable Face Prefab** 之前，让我们快速尝试一下。使用以下步骤：
- en: From the Editor menu bar, select **GameObject** | **XR** | **AR Default Face**.
    This creates an object named **AR Default Face** in the scene hierarchy.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从编辑器菜单栏中选择 **GameObject** | **XR** | **AR Default Face**。这将在场景层次结构中创建一个名为 **AR
    Default Face** 的对象。
- en: Note that you won't see this object in your Scene window because the mesh is
    dynamically generated at runtime, so there's nothing to render yet.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你不会在场景窗口中看到这个对象，因为网格是在运行时动态生成的，所以还没有东西可以渲染。
- en: 'Replace the default material (the one included is not for URP): In the `Materials/`
    folder (create one first if necessary), and name it `DefaultFace Material`. Set
    the **Base Map** color to your favorite color. Drag the material onto the **AR
    Default Face** object.'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换默认材料（包含的默认材料不适合 URP）：在 `Materials/` 文件夹中（如有必要，先创建一个），并将其命名为 `DefaultFace Material`。将
    **基础贴图**颜色设置为你的喜欢的颜色。将材质拖动到 **AR Default Face** 对象上。
- en: Make it a prefab. Drag the `Prefabs/` folder.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使其成为一个预制件。将 `Prefabs/` 文件夹拖动。
- en: Then delete it from the **Hierarchy**.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从 **Hierarchy** 中删除它。
- en: Now, drag the prefab onto your **AR Session Origin** | **AR Face Manager** |
    **Face Prefab** slot.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将预制件拖动到你的 **AR 会话原点** | **AR 面部管理器** | **面部预制件**槽位。
- en: 'Here''s a screen capture of me wearing the default mask, and smiling brightly,
    on the left. On the right is a scene view of my face mesh generated at runtime:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张我戴着默认面具、面带灿烂笑容的屏幕截图，在左边。右边是我的脸部网格在运行时生成的场景视图：
- en: '![Figure 9.8 – Me wearing an AR default mask (left) and a wireframe of my face
    mesh (right)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8 – 我戴着 AR 默认面具（左）和我脸部网格的线框图（右）]'
- en: '](img/Figure_9.08_B15145.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.08_B15145.jpg]'
- en: Figure 9.8 – Me wearing an AR default mask (left) and a wireframe of my face
    mesh (right)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 我戴着 AR 默认面具（左）和我脸部网格的线框图（右）
- en: It's easy to replace this default material with other materials to make your
    own masks.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 用其他材料替换这个默认材料很容易，以制作你自己的面具。
- en: Creating face materials
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建面部材料
- en: 'For fun (and for the purposes of instruction), let''s try using an arbitrary
    photo as a face texture. I''ll use a picture named `WinterBarn.jpg` (this was
    also used in [*Chapter 6*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136), *Gallery:
    Building an AR App*). Create a new material using the photo, with the following
    steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩（以及教学目的），让我们尝试使用任意照片作为面部纹理。我将使用名为 `WinterBarn.jpg` 的图片（这也在 [*第 6 章*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136)，*图库：构建
    AR 应用*）中使用，按照以下步骤创建一个新的材质：
- en: '*Right-click* in your `Materials/` folder and select `PhotoFace Material`.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Materials/` 文件夹中 *右键点击* 并选择 `PhotoFace Material`。
- en: Drag a photo from the `WinterBar.jpg`) onto the **Base Map** texture chip. Ensure
    the **Base Map** color is white.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将照片从`WinterBar.jpg`拖动到**基础地图**纹理芯片上。确保**基础地图**颜色为白色。
- en: Duplicate the `PhotoFace Prefab`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`PhotoFace Prefab`。
- en: Open the new prefab for editing and drag the **PhotoFace Material** onto it.
    **Save** the prefab and return to the scene hierarchy.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的预制件进行编辑，并将**PhotoFace Material**拖动到上面。**保存**预制件并返回场景层次结构。
- en: To try it out, drag the **PhotoFace Prefab** onto **AR Face Manager** | **Face
    Prefab** and run the scene.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要尝试它，将**PhotoFace Prefab**拖动到**AR Face Manager** | **Face Prefab**并运行场景。
- en: 'This ought to give you a feeling of how a 2D texture image is mapped onto the
    face mesh. This is called `PopFace_Albedo`) for the face mesh:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你一种感觉，即二维纹理图像是如何映射到面部网格上的。这被称为`PopFace_Albedo`面部网格：
- en: '![Figure 9.9 – Ordinary 2D image as face texture (left), and a UV mapped face
    texture (right)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 普通二维图像作为面部纹理（左），以及 UV 映射的面部纹理（右）'
- en: '](img/Figure_9.09_B15145.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.09_B15145.jpg)'
- en: Figure 9.9 – Ordinary 2D image as face texture (left), and a UV mapped face
    texture (right)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 普通二维图像作为面部纹理（左），以及 UV 映射的面部纹理（右）
- en: In this way, you can use any 2D photograph or image that you want. Try others
    for yourself, such as your national flag, the logo of your favorite sports team,
    and so on.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以使用任何你想要的二维照片或图像。尝试一些其他的，比如你的国旗，你最喜欢的运动队的标志等等。
- en: The `PopFace_Albedo` texture shown in the preceding figure is included in the
    AR Face Assets package from Unity that we imported into our project at the beginning
    of this chapter. Make a material for that now by repeating *steps 1-5*, naming
    the material `PopFace Material`, and using `PopFace_Albedo` for the **Base Map**
    texture.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中显示的`PopFace_Albedo`纹理包含在 Unity 导入到我们项目中的 AR Face Assets 包中。现在通过重复*步骤 1-5*，命名为`PopFace
    Material`，并使用`PopFace_Albedo`作为**基础地图**纹理来制作材料。
- en: Likewise, the AR Face Assets package includes textures for a robot face. Again,
    repeat *steps 1-5* for a new `RobotFace Material`, using `Robot_Albedo` for the
    `Robot_Normal` and `Robot_Occlusion` for **Normal Map** and **Occlusion Map**,
    respectively.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，AR Face Assets 包还包括机器人面部的纹理。再次，为新的`RobotFace Material`重复*步骤 1-5*，使用`Robot_Albedo`作为`Robot_Normal`，使用`Robot_Occlusion`分别作为**法线图**和**遮挡图**。
- en: When adding the **Normal Map** texture, you may be prompted with **This texture
    is not marked as a normal map**. Click the **Fix Now** button to apply the required
    **Import Settings**.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加**法线图**纹理时，你可能会收到提示**此纹理未标记为法线图**。点击**立即修复**按钮以应用所需的**导入设置**。
- en: 'The following figure shows me wearing the **RobotFace** and **PopFace** masks.
    Not obvious in these screen captures is the fact that the face mesh follows my
    facial expressions in real time:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了戴着**RobotFace**和**PopFace**面具的我。在这些屏幕截图不太明显的是，面部网格会实时跟随我的面部表情：
- en: '![Figure 9.10 – Selfies using the Robot PBR material (left), and the Pop albedo
    texture (right)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – 使用机器人 PBR 材质（左）和 Pop 反照率纹理（右）的自拍'
- en: '](img/Figure_9.10_B15145.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_B15145.jpg)'
- en: Figure 9.10 – Selfies using the Robot PBR material (left), and the Pop albedo
    texture (right)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 使用机器人 PBR 材质（左）和 Pop 反照率纹理（右）的自拍
- en: 'Info: Using Procreate to paint your own textures'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：使用 Procreate 绘制自己的纹理
- en: If you're interested in painting your own UV mapped face textures (and have
    an iPad), the Procreate app ([https://procreate.art/](https://procreate.art/))
    has a feature for doing this (check out *Dilmer Valecillos's* video on this at
    [https://youtu.be/FOxhcRzDLx8](https://youtu.be/FOxhcRzDLx8)).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣自己绘制 UV 映射的面部纹理（并且拥有 iPad），Procreate 应用([https://procreate.art/](https://procreate.art/))具有此功能（查看[Dilmer
    Valecillos](https://youtu.be/FOxhcRzDLx8)关于此功能的视频）。
- en: With the materials made, we can add the face mesh visualizer to the changeable
    face prefab, so it will generate the face mesh at runtime.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 制作好材料后，我们可以将面部网格可视化器添加到可变面部预制件中，这样它将在运行时生成面部网格。
- en: Adding a face mesh visualizer to the changeable face prefab
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将面部网格可视化器添加到可变面部预制件
- en: 'To integrate a dynamic face mesh into our app, we should add it to our versatile
    **Changeable Face Prefab**. We will need the same components as the **AR Default
    Face** game object we generated earlier, and they need to be on the prefab''s
    root object. Use the following steps to add them manually:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要将动态面部网格集成到我们的应用程序中，我们应该将其添加到我们的多功能**可变面部预制件**中。我们需要与之前生成的**AR 默认面部**游戏对象相同的组件，并且它们需要位于预制件的根对象上。使用以下步骤手动添加它们：
- en: Open **Changeable Face Prefab** for editing.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**可变面部预制件**进行编辑。
- en: With the prefab root object selected, click **Add Component** in the **Inspector**.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择预制体根对象后，在**检查器**中点击**添加组件**。
- en: Search for and select the **AR Face Mesh Visualizer** component.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并选择**AR Face Mesh Visualizer**组件。
- en: Search for and select a **Mesh Filter** component.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并选择一个**网格过滤器**组件。
- en: Search for and select a **Mesh Renderer** component.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并选择一个**网格渲染器**组件。
- en: Drag the **DefaultFace Material** from the **Project** window onto the **Changeable
    Face Prefab** root object.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**默认面材质**从**项目**窗口拖动到**可变面预制体**根对象上。
- en: Save the prefab.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存预制体。
- en: Back in the scene hierarchy, drag the **Changeable Face Prefab** asset onto
    the **AR Session Origin** | **AR Face Manager** | **Face Prefab** slot.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景层次结构中返回，将**可变面预制体**资产拖动到**AR会话起源** | **AR面管理器** | **面预制体**槽位。
- en: If you build and run now, you'll see the default face mesh. All the menu buttons
    still work, letting you add 3D head models and accessories.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行，你会看到默认的面网格。所有菜单按钮仍然工作，让你添加3D头部模型和配件。
- en: We want to have buttons that let the user choose between face materials. For
    that, we need to update our scripts.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有按钮让用户在面材质之间进行选择。为此，我们需要更新我们的脚本。
- en: Controlling the face material
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制面材质
- en: 'We can hide or show the face mesh by toggling the **AR Face Mesh Visualizer**
    and **Mesh Render** components. Use the following steps:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过切换**AR Face Mesh Visualizer**和**Mesh Render**组件来隐藏或显示面网格。使用以下步骤：
- en: 'Open the `ChangeableFace` script for editing and add the following at the top
    of the script:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ChangeableFace`脚本进行编辑，并在脚本顶部添加以下内容：
- en: '[PRE9]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code to declare and initialize references to the `ARFaceMeshVisualizer`
    and `MeshRenderer` components:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以声明和初始化对`ARFaceMeshVisualizer`和`MeshRenderer`组件的引用：
- en: '[PRE10]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll start the app with the face mesh not visible, so both components are disabled.
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将启动应用程序，使面网格不可见，因此两个组件都是禁用的。
- en: 'Then, add a `SetMeshMaterial` function as follows:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个`SetMeshMaterial`函数，如下所示：
- en: '[PRE11]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When given a material, `mat`, the function sets it in the renderer and makes
    sure the visualizer and renderer components are enabled. If you pass a `null`
    value for the `mat`, then the components will be disabled.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当给定材质`mat`时，该函数将其设置在渲染器中，并确保可视化器和渲染器组件被启用。如果你为`mat`传递一个`null`值，那么组件将被禁用。
- en: 'Next, open the `FaceMainMode` script and add a `ChangeMaterial` function, as
    follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`FaceMainMode`脚本并添加一个`ChangeMaterial`函数，如下所示：
- en: '[PRE12]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Like the other functions in the script, it loops through any trackables and
    calls into the changeable component.
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像脚本中的其他函数一样，它遍历任何可追踪项并调用可变组件。
- en: 'Next, update the `ResetFace` function with the following highlighted line:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下突出显示的行更新`ResetFace`函数：
- en: '[PRE13]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code is now written. We added a `SetMaterial` function to the `ChangeableFace`
    script that enables the mesh visualizer and sets the material to render. To the
    `FaceMainMode` script, we added a `ChangeMaterial` function that calls `SetMaterial`
    on each trackable AR face.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在已经编写完成。我们在`ChangeableFace`脚本中添加了一个`SetMaterial`函数，它启用了网格可视化器并将材质设置为渲染。在`FaceMainMode`脚本中，我们添加了一个`ChangeMaterial`函数，它对每个可追踪的AR面调用`SetMaterial`。
- en: We're now ready to add menu buttons for the various mesh materials.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好添加各种网格材质的菜单按钮。
- en: Adding face materials to the main menu
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加到主菜单的面材质
- en: 'To add new buttons to the main menu, we can duplicate an existing button and
    modify it, as we did earlier. Use the following steps:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新的按钮到主菜单，我们可以复制一个现有的按钮并修改它，就像我们之前做的那样。使用以下步骤：
- en: In the `DefaultFace Button`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DefaultFace Button`。
- en: From the `default face icon` asset onto the **Image** | **Source Image** slot.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`default face icon`资产拖动到**图像** | **源图像**槽位。
- en: On the button **On Click** action, change **Function** to **FaceMainMode.ChangeMaterial**.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮的**点击**动作中，将**函数**更改为**FaceMainMode.ChangeMaterial**。
- en: From the `Materials/` folder) onto the parameter slot.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Materials/`文件夹拖动到参数槽位。
- en: Likewise, repeat *steps 1-4* three times, for `PhotoFace Button` (using the
    `photo face icon` image, and the `PopFace Button`, and for `RobotFace Button`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，重复*步骤1-4*三次，对于`PhotoFace Button`（使用`photo face icon`图像，以及`PopFace Button`，和`RobotFace
    Button`。
- en: 'Save the scene and build the project. When you tap one of the face material
    buttons, it renders the face mesh. The following cropped screen capture shows
    the horizontally-scrolled menu with the new buttons:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景并构建项目。当你点击其中一个面材质按钮时，它会渲染面网格。以下截图中显示了带有新按钮的水平滚动菜单：
- en: '![Figure 9.11 – Face mesh texture buttons on the main menu'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11 – 主菜单上的面网格纹理按钮'
- en: '](img/Figure_9.11_B15145.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11](img/Figure_9.11_B15145.jpg)'
- en: Figure 9.11 – Face mesh texture buttons on the main menu
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 主菜单上的面部网格纹理按钮
- en: In this section, we added an `FaceMainMode`. This then forwards it to the trackable
    face(s).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们添加了一个 `FaceMainMode`。然后它将这个模式转发到可追踪的面部。
- en: While the face visualizer can follow some of your expressions, including raised
    eyebrows and opening your mouth, it does nothing for your eyes. Let's consider
    eye tracking next.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然面部可视化器可以跟随一些你的表情，包括扬起眉毛和张开嘴巴，但它对你的眼睛没有任何作用。让我们接下来考虑眼动追踪。
- en: Using eye tracking (ARKit)
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用眼动追踪（ARKit）
- en: For eye tracking, as you might expect, you are given the pose transforms for
    each eye, which you can use to update your own "eyeball" game objects. For this
    feature, I'll show you how to do it, but leave the details of integrating it into
    the project up to you. Presently, this feature requires an iOS device with a **TrueDepth**
    camera.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于眼动追踪，正如你所预期的，你将获得每个眼睛的姿势变换，你可以使用这些变换来更新你自己的“眼球”游戏对象。对于这个功能，我会向你展示如何实现，但将集成到项目中的细节留给你。目前，这个功能需要一个带有
    **TrueDepth** 相机的 iOS 设备。
- en: To learn more about eye tracking with AR Foundation, take a look at the `EyeLasers`
    scene given in the AR Foundation sample assets (we installed these in the `Assets/ARF-samples/`
    folder).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 AR Foundation 的眼动追踪信息，请查看 AR Foundation 示例资产中提供的 `EyeLasers` 场景（我们已将其安装到
    `Assets/ARF-samples/` 文件夹中）。
- en: 'The **Face Prefab** in the scene''s **AR Face Manager** is the **AR Eye Laser
    Visualizer** prefab. This has an **AR Face** component (as you would expect),
    plus an **Eye Pose Visualizer**. This visualizer script, in turn, is given an
    eyeball prefab. In this specific scene, it is given the **Eye Laser Prefab**.
    This simply contains a long thin cylinder that''ll be rendered to look like a
    laser beam. In summary, these dependencies could be depicted as the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的 **AR Face Manager** 中的 **Face Prefab** 是 **AR Eye Laser Visualizer** 预制体。这有一个
    **AR Face** 组件（正如你所期望的），还有一个 **Eye Pose Visualizer**。这个可视化脚本反过来又给了一个眼球预制体。在这个特定的场景中，它被赋予了
    **Eye Laser Prefab**。这只是一个包含一个细长圆柱体的简单预制体，它将被渲染成激光束。总的来说，这些依赖关系可以表示如下：
- en: EyeLasers scene -> AR Eye Laser Visualizer face prefab -> Eye Pose Visualizer
    script -> Eye Laser Prefab
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: EyeLasers 场景 -> AR Eye Laser Visualizer 面部预制体 -> Eye Pose Visualizer 脚本 -> Eye
    Laser Prefab
- en: 'The `EyePoseVisualizer` script is an example script (not part of the AR Foundation
    package itself). Briefly, you give it an eyeball prefab, which is instantiated
    twice and parented by the `ARFace`, `leftEye`, and `rightEye` pose transforms.
    For example, you''ll find this line of code in the script''s `CreateEyeGameObjectsIfNecessary`
    function (line 45):'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`EyePoseVisualizer` 脚本是一个示例脚本（本身不是 AR Foundation 包的一部分）。简而言之，你给它一个眼球预制体，该预制体被实例化两次，并由
    `ARFace`、`leftEye` 和 `rightEye` 姿势变换作为父级。例如，你会在脚本的 `CreateEyeGameObjectsIfNecessary`
    函数（第 45 行）中找到以下代码行：'
- en: '[PRE14]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As a child of the tracked eye transforms, the spawned objects appear to automatically
    track with your detected eye movements.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 作为追踪眼变换的子对象，生成的对象似乎会自动跟踪你的检测到的眼动。
- en: 'The script also subscribes to the `ARFace` and `update` events, where it toggles
    the eyes'' visibility based on the trackable''s tracking state, as shown in the
    following code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还订阅了 `ARFace` 和 `update` 事件，根据可追踪对象的追踪状态切换眼睛的可见性，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Tip: Using updated events with face tracking'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：使用带有面部追踪的更新事件
- en: This script illustrates another best practice for face tracking with AR Foundation.
    By subscribing to the trackables' `updated` events, it toggles the visibility
    of instantiated prefabs based on the trackable's `trackingState`, as well as the
    overall `ARSession.state`. You might consider refactoring the functions in our
    `FaceMainMode` class to handle `updated` events in this way too.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本展示了使用 AR Foundation 进行面部追踪的另一个最佳实践。通过订阅可追踪对象的 `updated` 事件，它根据可追踪对象的 `trackingState`
    以及整体的 `ARSession.state` 来切换实例化预制体的可见性。你可能考虑重构我们 `FaceMainMode` 类中的函数，以便以这种方式处理
    `updated` 事件。
- en: 'Eye tracking is not available on all platforms. When the script is enabled,
    it first checks the Unity eye tracking subsystem. If the feature is not supported,
    the component disables itself, as highlighted in the following `OnEnable` function
    (lines 65-78):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 眼动追踪并非在所有平台上都可用。当脚本启用时，它首先检查 Unity 眼动追踪子系统。如果该功能不受支持，组件会自行禁用，如下面的 `OnEnable`
    函数（第 65-78 行）所示：
- en: '[PRE16]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you want to try this yourself with an eyeball instead of a laser beam, the
    following URL contains a free eyeball 3D model you could use: [https://free3d.com/3d-model/eyeball--33237.html.](https://free3d.com/3d-model/eyeball--33237.html.)
    Make it into a prefab and substitute it for the eye laser prefab on the AR eye
    laser visualizer prefab''s **Eye Pose Visualizer** | **Eye Prefab** slot.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试使用眼球而不是激光束，以下URL包含一个您可以使用免费眼球3D模型：[https://free3d.com/3d-model/eyeball--33237.html.](https://free3d.com/3d-model/eyeball--33237.html.)将其制作成预制件，并用它替换AR眼激光可视化预制件上的**Eye
    Pose Visualizer** | **Eye Prefab**槽位。
- en: This is fantastic! However, you can do so much more. For example, with ARCore,
    you can attach graphics to specific regions of the face. Let's look into that
    now.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！然而，你可以做更多的事情。例如，使用ARCore，你可以将图形附加到面部特定区域。现在让我们来看看这一点。
- en: Attaching stickers to face regions (ARCore)
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将贴纸附加到面部区域（ARCore）
- en: 'If your project is using ARCore XR Plugin and Android, you have access to ARCore-specific
    features, including transforms for three important face regions: the nose tip,
    left forehead, and right forehead. If you raise your left eyebrow, for example,
    that transform will move independently of the rest of the face, providing some
    more detail to the facial expressions in your app.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目正在使用ARCore XR插件和Android，您将能够访问ARCore特定的功能，包括三个重要面部区域的变换：鼻尖、左额和右额。例如，如果您抬起左眉毛，该变换将独立于面部其余部分移动，为您的应用程序中的面部表情提供更多细节。
- en: In addition to what we do here, you may also want to look at the `ARF-samples/`
    folder in your project), and the `ARCoreFaceRegionManager` script it uses. The
    code we develop in this section is considerably simpler and easier to follow.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里做的事情之外，您还可能想查看项目中的`ARF-samples/`文件夹，以及它使用的`ARCoreFaceRegionManager`脚本。我们在这个部分开发的代码相当简单且易于理解。
- en: To demonstrate ARCore face regions, we'll implement several 2D stickers and
    attach them to the 3D face regions. We'll let you add eyebrows, a mustache, and
    licking lips using clipart that we identified at the top of this chapter (and
    I edited in Photoshop). They've been imported as **Sprite (2D and UI)**. These
    are available in this book's GitHub repository.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示ARCore面部区域，我们将实现几个2D贴纸并将它们附加到3D面部区域。我们将让您使用我们在本章顶部识别的剪贴画（以及我在Photoshop中编辑的）添加眉毛、胡须和舔嘴唇。它们已被导入为**Sprite（2D和UI）**。这些可以在本书的GitHub仓库中找到。
- en: We can start by creating the sticker prefabs.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从创建贴纸预制件开始。
- en: Creating the sticker prefabs
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建贴纸预制件
- en: 'To make prefabs of these clipart images, use the following steps:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作这些剪贴画图像的预制件，请按照以下步骤操作：
- en: '*Right-click* in the `Mustache Prefab`. Then open it for editing.'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Mustache Prefab`上*右键单击*。然后打开它进行编辑。
- en: From the `mustache` image onto the root **Mustache Prefab**. This creates a
    child object named **mustache** with a **Sprite Renderer** component.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`mustache`图像到根**Mustache Prefab**。这会创建一个名为**mustache**的子对象，并带有**Sprite Renderer**组件。
- en: Set the `0, -0.02, 0`) and `0,019, 0,019, 0,019`).
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`(0, -0.02, 0)`和`(0,019, 0,019, 0,019)`。
- en: Save the prefab.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存预制件。
- en: Repeat *steps 1-4*, making `Lips Prefab` using the `licking-lips` sprite image.
    Use `0, -0.05, 0`) and `0,019, 0,019, 0,019`).
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1-4*，使用`licking-lips`贴图图像创建`Lips Prefab`。使用`(0, -0.05, 0)`和`(0,019, 0,019,
    0,019)`。
- en: Again, repeat *steps 1-4*, making `Eyebrow Left Prefab` using the `eyebrow-left`
    sprite image. Use `0, -0.01, 0`) and `0,019, 0,019, 0,019`).
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，重复*步骤1-4*，使用`eyebrow-left`贴图图像创建`Eyebrow Left Prefab`。使用`(0, -0.01, 0)`和`(0,019,
    0,019, 0,019)`。
- en: And likewise, one more time, make `Eyebrow Right Prefab` using the `eyebrow-right`
    sprite image. Use `0, -0.01, 0`) and `0,019, 0,019, 0,019`).
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，再次，使用`eyebrow-right`贴图图像创建一个`Eyebrow Right Prefab`。使用`(0, -0.01, 0)`和`(0,019,
    0,019, 0,019)`。
- en: We now have prefabs for a mustache, lips, and eyebrows. Let's write the scripts
    to attach them using the ARCore face regions support.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了胡须、嘴唇和眉毛的预制件。让我们编写脚本，使用ARCore面部区域支持将它们附加起来。
- en: Managing attachments' positions
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理附件的位置
- en: We'll create a separate script, `FaceRegionAttachments` on `ChangeableFace`
    script because the code is ARCore-specific and is relatively long.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`ChangeableFace`脚本上创建一个单独的脚本，名为`FaceRegionAttachments`，因为代码是ARCore特定的，并且相对较长。
- en: 'The lines of code that depend on ARCore are enclosed in `#if UNITY_ANDROID
    &&!UNITY_EDITOR` compiler symbols, so they will not run in a non-Android environment
    (including the desktop play mode). Use the following steps:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于ARCore的代码行被包含在`#if UNITY_ANDROID &&!UNITY_EDITOR`编译器符号中，因此它们将在非Android环境中（包括桌面播放模式）不会运行。请按照以下步骤操作：
- en: Create a new C# script named `FaceRegionAttachments` and open it for editing.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本命名为`FaceRegionAttachments`并打开它进行编辑。
- en: 'Start writing the script by replacing the content with the following code:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过替换以下代码来开始编写脚本：
- en: '[PRE17]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The script first declares that we're using the ARFoundation API as well as ARCore.
    Then, at the top of the class, we declare variables for `ARFaceManager` and the
    object's `ARFace`, and initialize these in `Start`. We also declare two dictionaries,
    `prefabs` and `objs`, that will be indexed by the ARCore `region` identifier (enum).
    We then declare a `NativeArray` of `ARCoreFaceRegionData` named `faceRegions`
    that we'll be using in `Update`.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脚本首先声明我们正在使用ARFoundation API以及ARCore。然后，在类顶部声明`ARFaceManager`和对象的`ARFace`变量，并在`Start`中初始化这些变量。我们还声明了两个字典`prefabs`和`objs`，它们将按ARCore的`region`标识符（枚举）索引。然后，我们声明了一个名为`faceRegions`的`NativeArray`，其中包含`ARCoreFaceRegionData`，我们将在`Update`中使用它。
- en: 'Add a `SetRegionAttachment` function (that will be called from `FaceMainMode`)
    as follows:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`SetRegionAttachment`函数（它将由`FaceMainMode`调用），如下所示：
- en: '[PRE18]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The function gets a `region` ID and a `prefab`, instantiates the `prefab`, and
    records both the `prefab` and spawned object in the dictionaries. If there is
    already a spawned object, it is first destroyed and removed from the lists. We
    check if the new prefab was the same as the current one, so it won't be respawned
    again, effectively allowing the menu button to toggle on and off as an attachment
    by clicking twice.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数获取一个`region` ID和一个`prefab`，实例化`prefab`，并将`prefab`和生成的对象记录在字典中。如果已经有一个生成的对象，它首先被销毁并从列表中移除。我们检查新的`prefab`是否与当前的一个相同，因此它不会再次重生，从而允许菜单按钮通过点击两次来切换附件的开和关。
- en: 'On each `Update`, we need to ask ARCore for the current list of face regions,
    and update the spawned object transforms accordingly, as follows:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次`Update`中，我们需要向ARCore请求当前的面部区域列表，并相应地更新生成的对象变换，如下所示：
- en: '[PRE19]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can also provide a public `Reset` function that destroys all the instantiated
    objects and clears the dictionaries:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以提供一个公共的`Reset`函数，它销毁所有实例化的对象并清除字典：
- en: '[PRE20]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, it''s good practice to dispose of the `faceRegions` native array when
    this game object is destroyed, as follows:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当这个游戏对象被销毁时，良好的做法是按照以下方式处置`faceRegions`本地数组：
- en: '[PRE21]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Save the script, then, back in Unity, open the **Changeable Face Prefab** asset
    for editing.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本后，在Unity中打开**可更改的面部预制体**资产进行编辑。
- en: Drag the `FaceRegionAttachments` script onto the root `Destroy` and `Instantiate`
    for the same prefabs.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FaceRegionAttachments`脚本拖放到相同预制体的根`Destroy`和`Instantiate`上。
- en: 'Now we''ll update the `FaceMainMode` script to use it and provide public functions
    that the menu buttons can call, as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新`FaceMainMode`脚本以使用它，并提供公共函数，菜单按钮可以调用，如下所示：
- en: 'Open the `FaceMainMode` script for editing, and start by adding the following
    lines at the top of the file (needed for the `enum` `ARCoreFaceRegion` definition):'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FaceMainMode`脚本进行编辑，并在文件顶部添加以下行（用于`enum` `ARCoreFaceRegion`定义）：
- en: '[PRE22]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a private `SetRegionAttachment` function that loops through the trackables
    and calls `SetRegionAttachment` on them:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个私有的`SetRegionAttachment`函数，它遍历可追踪对象并在它们上调用`SetRegionAttachment`：
- en: '[PRE23]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, expose this capability via separate public functions we can call from
    the menu button Unity actions, as follows:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过我们可以从菜单按钮Unity动作中调用的单独公共函数公开此功能，如下所示：
- en: '[PRE24]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Save the script.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Here, we created a new `FaceRegionAttachments` script that maintains dictionary
    lists of `prefabs` and spawned `objs` for game objects attached to specific face
    regions. On each frame `Update`, the `objs` transforms are updated based on the
    face region's pose transform, so it tracks with its region. This implementation
    allows multiple attachments on a face, but only one per region. Then, we updated
    the `FaceMainMode` script with public functions that can be called by menu buttons
    to add attachments.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的`FaceRegionAttachments`脚本，它维护字典列表`prefabs`和生成的`objs`，用于特定面部区域附加的游戏对象。在每一帧`Update`中，`objs`变换基于面部区域的姿态变换进行更新，因此它与区域一起跟踪。这种实现允许在面部上添加多个附件，但每个区域只有一个。然后，我们更新了`FaceMainMode`脚本，其中包含可以由菜单按钮调用的公共函数来添加附件。
- en: We can now make the menu buttons.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建菜单按钮。
- en: Adding region attachments to the main menu
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向主菜单添加区域附件
- en: 'As we did earlier, to add new buttons to the main menu, we can duplicate an
    existing button and modify it. Use the following steps:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，要向主菜单添加新按钮，我们可以复制一个现有的按钮并修改它。使用以下步骤：
- en: In the `Mustache Button`.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Mustache Button`中。
- en: From the `mustache icon` asset onto the **Image** | **Source Image** slot.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`mustache icon`资产拖动到**图像** | **源图像**槽位。
- en: On the button **On Click** action, change **Function** to **FaceMainMode.SetNoseAttachment**.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮的**点击**动作中，将**函数**更改为**FaceMainMode.SetNoseAttachment**。
- en: From the **Project** window, drag the **Mustache Prefab** asset onto the parameter
    slot.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口，将**Mustache Prefab**资产拖动到参数槽位。
- en: Repeat *steps 1-4* for `Lips Button`, using the `licking-lips icon` image, and
    the **Lips Prefab** asset. Use the same function as the mustache, **FaceMainMode.SetNoseAttachment**.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`licking-lips icon`图像和**Lips Prefab**资产，重复*步骤1-4*为`Lips Button`。使用与胡须相同的函数，**FaceMainMode.SetNoseAttachment**。
- en: 'Repeat *steps 1-4* again for `Eyebrows Button`, using the `eyebrows icon` image.
    This time, we''ll have two **On Click** actions, one for each eye. The first calls
    **FaceMainMode.SetForeheadLeftAttachment** with the **EyebrowLeft Prefab**. The
    second calls **FaceMainMode.SetForeheadRightAttachment** with the **EyebrowRight
    Prefab**, as shown in the following:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次重复*步骤1-4*为`Eyebrows Button`，使用`eyebrows icon`图像。这次，我们将有两个**点击**动作，一个用于每个眼睛。第一个调用**FaceMainMode.SetForeheadLeftAttachment**与**EyebrowLeft
    Prefab**。第二个调用**FaceMainMode.SetForeheadRightAttachment**与**EyebrowRight Prefab**，如下所示：
- en: '![Figure 9.12 – The eyebrows button has two On Click actions, for both the
    left and'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12 – 眉毛按钮有两个点击动作，用于左侧和'
- en: right regions and prefabs](img/Figure_9.12_B15145.jpg)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧区域和预制件](img/Figure_9.12_B15145.jpg)
- en: Figure 9.12 – The eyebrows button has two On Click actions, for both the left
    and right regions and prefabs
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 眉毛按钮有两个点击动作，用于左侧和右侧的区域和预制件
- en: 'Save the scene and build the project. When you tap one of the region attachment
    buttons, it adds its sticker prefabs to the scene. The mustache and lips both
    set the nose attachment so you can only view one at a time. The following screen
    captures show me all decked out, including combining it with other face augmentations
    we created earlier (right):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景并构建项目。当你点击其中一个区域附加按钮时，它会将其贴纸预制件添加到场景中。胡须和嘴唇都设置了鼻子附加，所以你一次只能查看一个。以下屏幕截图显示了我全部装备的样子，包括将其与其他我们之前创建的面部增强功能结合（右侧）：
- en: '![Figure 9.13 – Selfie screenshots with multiple stickers, and (on the right)
    combined'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 带有多个贴纸的自拍截图，以及（在右侧）结合'
- en: with other augmentations](img/Figure_9.13_B15145.jpg)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他增强功能结合](img/Figure_9.13_B15145.jpg)
- en: Figure 9.13 – Selfie screenshots with multiple stickers, and (on the right)
    combined with other augmentations
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 带有多个贴纸的自拍截图，以及（在右侧）与其他增强功能结合
- en: Because this feature is specific to ARCore, you will probably want to hide the
    sticker buttons if you try building the project for iOS. We can add those next.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个功能是针对ARCore的，如果你尝试为iOS构建项目，你可能想隐藏贴纸按钮。我们可以稍后添加这些。
- en: ARCore-only UI buttons
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARCore专用UI按钮
- en: This face region stickers feature only runs on ARCore and Android. If you plan
    to build the same project on iOS (as well as Android), we already account for
    code compilation issues using conditional compile symbols. However, the menu buttons
    will still be visible. You could disable them by hand in the editor before doing
    a build, or you could let a script handle it.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这个面部区域贴纸功能仅在ARCore和Android上运行。如果你计划在iOS（以及Android）上构建相同的项目，我们已经通过条件编译符号解决了代码编译问题。然而，菜单按钮仍然可见。你可以在构建之前在编辑器中手动禁用它们，或者你可以让脚本处理它。
- en: 'Use the following `ARCoreOnly` script to hide buttons from the UI (unless you''re
    targeting Android). If you''re targeting Android but using play mode in the editor
    (using the AR Foundation remote tool), this script will disable the button so
    that it is visible but not interactable:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下`ARCoreOnly`脚本来隐藏UI中的按钮（除非你的目标是Android）。如果你针对Android但使用编辑器中的播放模式（使用AR Foundation远程工具），此脚本将禁用按钮，使其可见但不能交互：
- en: '[PRE25]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Drag a copy of this script onto the mustache button, lips button, and eyebrows
    button game objects so that they can only be used with ARCore.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本的副本拖动到胡须按钮、嘴唇按钮和眉毛按钮游戏对象上，以便它们只能与ARCore一起使用。
- en: To summarize, in this section, we created several sticker prefabs containing
    `FaceRegionAttachments`, that uses the native `ARCoreFaceRegionData` (via `ARCoreFaceSubsystem`)
    to find the pose transform of each face region (nose tip, left forehead, and right
    forehead), and track each spawned game object with the given face region. We added
    menu buttons for each of the stickers that call public functions in `FaceMainMenu`
    by passing the sticker prefab to add. This in turn forwards the prefab to the
    trackable faces. Feel free to add more sticker prefabs and buttons, using similar
    steps to the ones found in this section.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们创建了包含 `FaceRegionAttachments` 的几个贴纸预制件，它使用本地的 `ARCoreFaceRegionData`（通过
    `ARCoreFaceSubsystem`）来找到每个面部区域（鼻尖、左额头和右额头）的姿态变换，并跟踪每个生成的游戏对象与给定的面部区域。我们为每个贴纸添加了菜单按钮，通过传递贴纸预制件来调用
    `FaceMainMenu` 中的公共函数。这反过来又把预制件传递给了可追踪的面部。你可以自由地添加更多的贴纸预制件和按钮，使用与本章中找到的类似步骤。
- en: This is cool, but having just three face regions is kind of limited. Using ARKit,
    you have access to much more refined detail about face geometry. This is achieved
    with the use of blend shapes.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，但只有三个面部区域似乎有点局限。使用 ARKit，你可以获取更多关于面部几何的精细细节。这是通过使用混合形状实现的。
- en: Tracking expressive face blend shapes (ARKit)
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪表达式的面部混合形状（ARKit）
- en: 'ARKit introduces additional advanced face tracking features available only
    on iOS devices, including blend shapes. **Blend shapes** refer to morphing mesh
    geometries that are commonly used for animating the faces of NPCs (non-player
    characters) in video games and VR applications. Presently, they are an ARKit-specific
    feature. ARKit blend shapes provide intricate details of facial expressions as
    separate features, such as a left or right eye blink, looking down, eyes wide
    open, cheek puff, cheek squint, jaw left, mouth dimple, and many more. Each feature
    is given a coefficient on a scale of 0.0 to 1.0\. This shape data can be forwarded
    to the Unity **Skinned Mesh Renderer** ([https://docs.unity3d.com/Manual/class-SkinnedMeshRenderer.html](https://docs.unity3d.com/Manual/class-SkinnedMeshRenderer.html))
    that is used in character animation. A good explanation and conversation can be
    found at the following URL: [https://www.quora.com/What-is-blendshape-exactly](https://www.quora.com/What-is-blendshape-exactly).'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ARKit 引入了仅在 iOS 设备上可用的额外高级面部跟踪功能，包括混合形状。**混合形状**指的是用于在视频游戏和 VR 应用程序中动画 NPC（非玩家角色）面部网格几何形状的变形。目前，它们是
    ARKit 特有的功能。ARKit 混合形状提供了面部表情的详细细节，作为单独的特征，例如左眼或右眼眨眼、向下看、眼睛睁大、脸颊膨胀、脸颊皱眉、下巴左倾、嘴部酒窝等。每个特征都有一个在
    0.0 到 1.0 范围内的系数。这些形状数据可以转发到 Unity **骨骼蒙皮渲染器**（[https://docs.unity3d.com/Manual/class-SkinnedMeshRenderer.html](https://docs.unity3d.com/Manual/class-SkinnedMeshRenderer.html)），用于角色动画。有关更详细的解释和讨论，请参阅以下网址：[https://www.quora.com/What-is-blendshape-exactly](https://www.quora.com/What-is-blendshape-exactly)。
- en: Building an animated rig (with bones and a skinned mesh) is beyond the scope
    of this book. Instead, by way of explanation, I'll walk through the example assets
    given in the AR Foundation samples project's `ARKitFaceBlendShapes` scene, found
    in the `Assets/ARF-samples/scenes/FaceTracking/` folder. To begin, you can try
    it yourself (if you're set up for iOS development) by building the `ARKitFaceBlendShapes`
    scene. Now, let's take a closer look.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个动画骨架（带有骨骼和蒙皮网格）超出了本书的范围。相反，为了解释，我将通过 AR Foundation 示例项目中的 `ARKitFaceBlendShapes`
    场景的示例资产进行说明，该场景位于 `Assets/ARF-samples/scenes/FaceTracking/` 文件夹中。首先，你可以尝试自己构建
    `ARKitFaceBlendShapes` 场景（如果你已经为 iOS 开发做好了准备）。现在，让我们更仔细地看看。
- en: Opening the scene in the Unity Editor, you will find `SlothHead` prefab for
    the **Face Prefab**.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中打开场景，你会找到用于**面部预制件**的 `SlothHead` 预制件。
- en: 'Opening the `ARKitBlenShapeVisualizer`. This is an example script provided
    with AR Foundation samples (it is not part of the AR Foundation package itself).
    This component has a parameter for **Skinned Mesh Renderer**. This is on the **Sloth_Head2**
    child object, as shown in the following screenshot:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `ARKitBlenShapeVisualizer`。这是一个与 AR Foundation 示例一起提供的示例脚本（它本身不是 AR Foundation
    包的一部分）。此组件有一个用于**骨骼蒙皮渲染器**的参数。它位于**Sloth_Head2**子对象上，如下面的截图所示：
- en: '![Figure 9.14 – The SlothHead prefab has the sample ARKitBlendShapeVisualizer
    script that references the skinned mesh render on the child Sloth_Head2](img/Figure_9.14_B15145.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – SlothHead 预制件具有示例 ARKitBlendShapeVisualizer 脚本，该脚本引用了子对象 Sloth_Head2
    上的骨骼蒙皮渲染](img/Figure_9.14_B15145.jpg)'
- en: Figure 9.14 – The SlothHead prefab has the sample ARKitBlendShapeVisualizer
    script that references the skinned mesh render on the child Sloth_Head2
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – SlothHead预制件具有示例ARKitBlendShapeVisualizer脚本，该脚本引用了子Sloth_Head2上的skinned
    mesh render
- en: 'Open the `ARKitBlendShapeVisualizer` script in your code editor. You''ll find
    a function, `CreateFeatureBlendMapping`, that is called `Awake`. This maps ARKit
    blend shape names (type `ARKitBlendShapeLocation`) with corresponding indexes
    on the `skinnedMeshRenderer`. For the list of locations and descriptions, see
    the following URL: [https://docs.unity3d.com/Packages/com.unity.xr.arkit-face-tracking@4.2/api/UnityEngine.XR.ARKit.ARKitBlendShapeLocation.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arkit-face-tracking@4.2/api/UnityEngine.XR.ARKit.ARKitBlendShapeLocation.html).'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开`ARKitBlendShapeVisualizer`脚本。你会找到一个名为`CreateFeatureBlendMapping`的函数，它被`Awake`调用。这个函数将ARKit混合形状名称（类型`ARKitBlendShapeLocation`）与`skinnedMeshRenderer`上的相应索引进行映射。有关位置和描述的列表，请参阅以下URL：[https://docs.unity3d.com/Packages/com.unity.xr.arkit-face-tracking@4.2/api/UnityEngine.XR.ARKit.ARKitBlendShapeLocation.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arkit-face-tracking@4.2/api/UnityEngine.XR.ARKit.ARKitBlendShapeLocation.html)。
- en: 'The following screenshot shows the **Sloth_Head2** object''s **Skinned Mesh
    Renderer**, with some of its **BlendShapes** visible in the Unity **Inspector**:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**Sloth_Head2**对象的**Skinned Mesh Renderer**，其中一些**BlendShapes**在Unity
    **Inspector**中可见：
- en: '![Figure 9.15 – Skinned Mesh renderer component with some of the blend shapes
    listed'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.15 – Skinned Mesh renderer component with some of the blend shapes
    listed'
- en: '](img/Figure_9.15_B15145.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.15_B15145.jpg]'
- en: Figure 9.15 – Skinned Mesh renderer component with some of the blend shapes
    listed
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 包含一些列出混合形状的Skinned Mesh renderer组件
- en: The ARKit blend shape locations are mapped to the **Skinned Mesh Renderer**
    ones.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: ARKit混合形状的位置映射到**Skinned Mesh Renderer**的位置。
- en: Then the `ARKitBlendShapeVisualizer` script, which subscribes to the `ARFace`
    `updated` events with the `OnUpdated` function, in turn, calls its `UpdateFaceFeatures`
    function. `UpdateFaceFeatures` gets the current blend shape coefficients from
    ARKit (`m_ARKitFaceSubsystem.GetBlendShapeCoefficients`), and for each coefficient,
    sets that coefficient value (scaled by a global scalar) to the `skinnedMeshRender`.
    From there, Unity does its magic, deforming and animating the mesh geometry to
    be rendered on the screen. This is not simple but does make sense if you can follow
    it correctly.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`ARKitBlendShapeVisualizer`脚本，它使用`OnUpdated`函数订阅`ARFace`的`updated`事件，反过来，它调用其`UpdateFaceFeatures`函数。`UpdateFaceFeatures`从ARKit获取当前的混合形状系数（`m_ARKitFaceSubsystem.GetBlendShapeCoefficients`），并为每个系数，将该系数值（按全局标度缩放）设置到`skinnedMeshRender`。从那里，Unity执行其魔法，变形和动画网格几何形状以在屏幕上渲染。这并不简单，但如果正确理解，是有意义的。
- en: That's basically how blend shapes work. Developing your own models and code
    may require a good familiarity with the parts of Unity in question, but all the
    information you need is accessible. You will be successful if you know how to
    use it.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是混合形状的工作原理。开发自己的模型和代码可能需要熟悉Unity的相关部分，但所有你需要的信息都是可访问的。如果你知道如何使用它，你就会成功。
- en: Summary
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you built a face maker app that handles face tracking with
    the forward-facing (user-facing) camera on a mobile device. You learned that the
    `ChangeableFace` script that we could update from the `FaceMainMode` script.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你构建了一个面部制作应用程序，该应用程序使用移动设备上的面向前方的（面向用户的）摄像头处理面部跟踪。你了解到我们可以从`FaceMainMode`脚本更新`ChangeableFace`脚本。
- en: You used this architecture to explore several ways of rendering tracked faces.
    First, you used the face pose to render an instantiated 3D head model (**MrPlasticHead**
    and **MrFacetHead**). Next, you used this technique to add accessories to the
    face, including a **TopHat** and **Sunglasses**. Then, you added an **AR Face
    Mesh Visualizer** to generate a face mesh dynamically at runtime, and then made
    several materials that can be applied to the mesh to make a wide variety of face
    masks. If you're on ARCore, you also implemented face region stickers using sprite
    images attached to ARCore face regions. Finally, you learned about ARKit-specific
    face tracking features, including eye tracking and blend shapes. In the process,
    you implemented a horizontally-scrolling main menu button that lets users choose
    various combinations of face filters. All this was great fun!
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用这种架构来探索了几种渲染跟踪面部的方法。首先，您使用面部姿态来渲染一个实例化的3D头部模型（**MrPlasticHead**和**MrFacetHead**）。接下来，您使用这项技术为面部添加配件，包括**高顶帽**和**太阳镜**。然后，您添加了一个**AR面部网格可视化器**，在运行时动态生成面部网格，并制作了多种可以应用于网格的材料，以制作各种面部面具。如果您使用的是ARCore，您还实现了使用附加到ARCore面部区域的小精灵图像的面部区域贴纸。最后，您了解了ARKit特定的面部跟踪功能，包括眼动跟踪和混合形状。在这个过程中，您实现了一个水平滚动的主菜单按钮，允许用户选择各种面部滤镜的组合。这一切都很有趣！
- en: You now have a working knowledge of how to build AR applications in Unity using
    AR Foundation. If you followed along with each of the chapters of this book, you
    will have learned how to set up your system for AR development with Unity configured
    to build on your target platform and mobile device. You created a simple AR scene,
    learning the main game objects required for AR, including the AR Session and AR
    Session Origin. You also explored the sample AR projects provided by Unity. Next,
    you learned about improving the developer workflow and troubleshooting your apps,
    considering situations unique to AR development.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经掌握了如何在Unity中使用AR Foundation构建AR应用程序的知识。如果您跟随本书的每一章，您将学习如何使用Unity配置您的系统以在目标平台和移动设备上构建AR开发。您创建了一个简单的AR场景，学习了AR所需的主要游戏对象，包括AR会话和AR会话原点。您还探索了Unity提供的示例AR项目。接下来，您学习了如何改进开发人员的工作流程和解决您的应用程序的问题，考虑到AR开发的独特情况。
- en: You created a user framework for developing an AR application that included
    onboarding graphics, interaction modes, and UI panels. This was saved as a scene
    template for reuse. You learned how to use the framework, first building a simple
    place-object scene with a simple main menu.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个用于开发AR应用程序的用户框架，包括入门图形、交互模式和UI面板。这个框架被保存为场景模板以供重复使用。您学习了如何使用这个框架，首先构建了一个简单的放置对象场景，其中包含一个简单的主菜单。
- en: In the third part of the book, you built several AR applications, including
    a picture gallery that lets you place framed photos on your walls, with menus
    and user interactivity. You improved the app, adding editing tools to move, resize,
    delete, and change the images displayed in virtual pictures in the scene. In the
    next project, you used image tracking to present 3D graphics and information about
    the planets using real-life printed flashcards. Finally, in this chapter, you
    built a face tracking app with a scrolling menu containing a variety of face heads,
    masks, and attachable accessories to make fun selfies.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第三部分，您构建了几个AR应用程序，包括一个相册，您可以在墙上放置带框的照片，具有菜单和用户交互功能。您改进了应用程序，添加了编辑工具来移动、调整大小、删除和更改场景中虚拟图片中显示的图像。在下一个项目中，您使用了图像跟踪来展示3D图形和关于行星的信息，使用现实生活中的印刷闪卡。最后，在本章中，您构建了一个面部跟踪应用程序，其中包含一个滚动菜单，包含各种面部头部、面具和可附加的配件，以制作有趣的快照。
- en: This is just the start. AR Foundation and Unity provide even more support for
    augmented reality applications, including object tracking and geotagging with
    GPS, as well as the full richness of the Unity platform for the development of
    interactive 3D games and applications. Go out and augment the world!
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是开始。AR Foundation和Unity为增强现实应用程序提供了更多的支持，包括使用GPS进行对象跟踪和地理标记，以及Unity平台的全丰富性，用于开发交互式3D游戏和应用。走出户外，增强世界吧！
