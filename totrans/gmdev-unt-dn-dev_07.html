<html><head></head><body>
		<div id="_idContainer274">
			<h1 id="_idParaDest-82"><em class="italic"><a id="_idTextAnchor078"/>Chapter 5</em>: Working with the Unity Physics System</h1>
			<p>A physics simulation in a game is not only an indispensable function for implementing the realism in the game. Adding a physics simulation to your game can usually improve the fun and playability of the game. Generally speaking, it determines how objects move and how they collide with one another, such as the collision between a player and a wall and the effect of gravity. As a popular game engine, Unity provides developers with a variety of tools, allowing developers to integrate physics simulation functions in their games.</p>
			<p>We will cover the following key topics in this chapter:</p>
			<ul>
				<li>Concepts in the Unity Physics system</li>
				<li>Scripting with the Physics system</li>
				<li>Creating a simple game based on the Physics system</li>
				<li>Increasing the performance of the Physics system</li>
			</ul>
			<p>By the end of this chapter, you will be able to apply the physics simulation correctly and efficiently in Unity to add more realism or fun to your game.</p>
			<p>Now, let's get started!</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor079"/>Technical requirements</h1>
			<p>You can find complete code examples on GitHub under the following repository:  <a href="https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers">https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers</a>. </p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor080"/>Concepts in the Unity Physics system</h1>
			<p>A  simulation is a useful function of <a id="_idIndexMarker435"/>a game. Unity provides different tools for different purposes. For example, if we want to develop a 3D game, then we can use the built-in 3D physics integrated with the <strong class="bold">Nvidia PhysX engine</strong>. If we want to add a<a id="_idIndexMarker436"/> physics simulation to a 2D game, then we can choose the built-in 2D <a id="_idIndexMarker437"/>physics integrated with the <strong class="bold">Box2D engine</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">PhysX</strong> is an open source, real-time physics <a id="_idIndexMarker438"/>engine middleware SDK developed by Nvidia as a part of the Nvidia GameWorks software suite. <strong class="bold">Box2D</strong> is a free, open source 2D physics simulator engine.</p>
			<p>In addition to these built-in Physics solutions, Unity also provides Physics engine packages. These are the <strong class="source-inline">Unity Physics</strong> package and the <strong class="source-inline">Havok Physics for Unity</strong><strong class="bold"> </strong>package. They are different from the built-in Physics systems. They need to be installed separately using <strong class="source-inline">Unity's Package Manager</strong>, and they are used in projects<a id="_idIndexMarker439"/> with Unity's <strong class="bold">Data-Oriented Technology Stack (DOTS)</strong>. We will introduce DOTS in later chapters.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Havok Physics</strong> is designed primarily for<a id="_idIndexMarker440"/> video games and allows for the real-time collision and dynamics of Rigidbodies in 3D.</p>
			<p>In this chapter, we will focus on the built-in physics and will first learn the basic concepts of the Unity Physics system.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor081"/>Collider</h2>
			<p>Similar to the rendering <a id="_idIndexMarker441"/>function, a physics engine also needs to <a id="_idIndexMarker442"/>understand the shape of <strong class="source-inline">GameObjects</strong> in a game scene in order to perform physics simulation correctly. When developing a Unity project, we can use the <strong class="bold">Collider</strong> component to define the shape of a GameObject for physical collision calculations.</p>
			<p>It should be noted that the shape defined by a collider does not have to be exactly the same as the shape of the model. We <a id="_idIndexMarker443"/>can even create a collider without a model display. For example, we can create a new cube in the scene, and a collider <a id="_idIndexMarker444"/>component will be created and attached to this cube automatically. Then, the shape of the collider can be modified from the Inspector window, as shown in the following image; its shape is different from the shape of the model.</p>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="image/Figure_5.01_B17146.jpg" alt="Figure 5.1 – Modifying the shape of the Collider (green frame)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Modifying the shape of the Collider (green frame)</p>
			<p>In order to reduce the complexity of physics <a id="_idIndexMarker445"/>simulation and improve the performance of the game, we often use some rough shapes, such as the <strong class="bold">Box Collider</strong> and<a id="_idIndexMarker446"/> the <strong class="bold">Sphere Collider</strong>. Next, we will explore one of the most commonly used colliders, namely, the Box Collider.</p>
			<h3>Primitive colliders</h3>
			<p>Unity provides a set <a id="_idIndexMarker447"/>of primitive colliders for game developers, including the <a id="_idIndexMarker448"/>Sphere Collider and the Box Collider. The Box Collider is one of the most commonly used colliders in Unity. It will be automatically created and assigned to the Cube object in a scene, as we see in <em class="italic">Figure 5.1</em>. We can also add a new Box Collider to a GameObject manually, as follows:</p>
			<ol>
				<li>Create a new GameObject in the scene by clicking the <strong class="bold">Create Empty</strong> button.</li>
			</ol>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/Figure_5.02_B17146.jpg" alt="Figure 5.2 – Creating a new GameObject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Creating a new GameObject</p>
			<ol>
				<li value="2">Select this newly created <a id="_idIndexMarker449"/>GameObject and click the <strong class="bold">Add Component</strong> button in the<a id="_idIndexMarker450"/> Inspector window. </li>
			</ol>
			<div>
				<div id="_idContainer234" class="IMG---Figure">
					<img src="image/Figure_5.03_B17146.jpg" alt="Figure 5.3 – Add Component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Add Component</p>
			<ol>
				<li value="3">Here, we can select the <strong class="bold">Physics &gt; Box Collider</strong> button or enter <strong class="source-inline">Box Collider</strong> in the search <a id="_idIndexMarker451"/>box to add the Box Collider component to this GameObject.</li>
			</ol>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="image/Figure_5.04_B17146.jpg" alt="Figure 5.4 – Adding the Box Collider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Adding the Box Collider</p>
			<p>Now we have<a id="_idIndexMarker452"/> added a new <strong class="bold">Box Collider</strong> component, and the properties<a id="_idIndexMarker453"/> of this Box Collider are shown in the following screenshot:</p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/Figure_5.05_B17146.jpg" alt="Figure 5.5 – Properties of the Box Collider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Properties of the Box Collider</p>
			<p>The <strong class="bold">Edit Collider</strong> button at the top allows us to edit the shape of this box in the scene. Below this button, there is an <strong class="bold">Is Trigger</strong> checkbox which, if enabled, means this collider will be used as a trigger. We will introduce more details about triggers later. The third property of this collider is the <strong class="bold">Material</strong> property, for referring to a <strong class="bold">Physics Material</strong> instance. The <a id="_idIndexMarker454"/>default value of the <strong class="bold">Material</strong> property is null, and we can assign an instance of Physics Material to adjust the friction and bouncing effects of colliding objects. The last two properties, <strong class="bold">Center</strong> and <strong class="bold">Size</strong>, are used to modify the position and size of this box.</p>
			<p>As we<a id="_idIndexMarker455"/> mentioned earlier, similar to the Box Collider, Unity also <a id="_idIndexMarker456"/>provides other colliders with primitive shapes, such as the Sphere Collider. </p>
			<p>We use them in cases where the accuracy of physical collision simulations is not high, but if the game requires accurate physical collision simulations, then we can also use another collider, namely, <strong class="bold">Mesh Collider</strong>.</p>
			<h3>Mesh Collider</h3>
			<p>Sometimes, we need to <a id="_idIndexMarker457"/>develop some game projects that require high physical simulation accuracy. In this case, the physical shape of the GameObject is often<a id="_idIndexMarker458"/> required to be consistent with the shape of the model mesh of the GameObject. This is why we need a Mesh Collider.</p>
			<p>There are different ways to create and add a Mesh Collider to a GameObject. Because the Mesh Collider needs the information of the mesh, so, the first way to create a Mesh Collider is by importing the model into the Unity Editor. You can check the <strong class="bold">Generate Colliders</strong> checkbox to import the mesh that automatically attaches mesh colliders, as shown in <em class="italic">Figure 5.6</em>:</p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/Figure_5.06_B17146.jpg" alt="Figure 5.6 – Generate Colliders&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Generate Colliders</p>
			<p>Unity also allows<a id="_idIndexMarker459"/> us to add a <strong class="bold">Mesh Collider</strong> component to a GameObject<a id="_idIndexMarker460"/> manually. The steps for adding a Mesh Collider are similar to the steps for adding a Box Collider in the previous section. After selecting the target GameObject, click the <strong class="bold">Add Component</strong> button, and then select <strong class="bold">Physics &gt; Mesh Collider</strong> to add it to the GameObject, as shown in <em class="italic">Figure 5.7</em>:</p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/Figure_5.07_B17146.jpg" alt="Figure 5.7 – Adding a Mesh Collider to a GameObject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Adding a Mesh Collider to a GameObject</p>
			<p>Since the mesh of a model may consist of many vertices and triangles, and the Mesh Collider will be generated based on the mesh, the computational cost of a Mesh Collider is much larger than that of the colliders introduced before. Even by default, Unity does not calculate the <a id="_idIndexMarker461"/>collision between mesh colliders, but only calculates the collision<a id="_idIndexMarker462"/> between a Mesh Collider and primitive colliders, such as a Box Collider and a Sphere Collider.</p>
			<p>In order to enable collision detection between mesh colliders, we need to reduce their complexity by checking the <strong class="bold">Convex</strong> checkbox of the Mesh Collider component, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/Figure_5.08_B17146.jpg" alt="Figure 5.8 – Properties of a Mesh Collider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Properties of a Mesh Collider</p>
			<p>By enabling this checkbox, <strong class="bold">Mesh Collider</strong> is limited to 255 triangles. If we look at the GameObject in the scene at the same time, we can see that the Mesh Collider is only roughly consistent with the model's mesh, and that the complexity has been greatly reduced.</p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/Figure_5.09_B17146.jpg" alt="Figure 5.9 – A convex Mesh Collider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – A convex Mesh Collider</p>
			<p>However, if we run the game now, we will find that no physical effects are applied to the game; for <a id="_idIndexMarker463"/>example, objects will not fall due to gravity. This is because our <a id="_idIndexMarker464"/>game still lacks an important component. Let's explore this next! </p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor082"/>Rigidbody</h2>
			<p>The <strong class="bold">Rigidbody</strong> component is <a id="_idIndexMarker465"/>an indispensable component for applying physical effects in Unity. By adding Rigidbody to a GameObject, physics will control the <a id="_idIndexMarker466"/>GameObject, such as applying gravity to it. Rigidbodies are usually used with colliders; if two Rigidbodies collide with one another, unless the two GameObjects have colliders attached, they will not have a collision effect between them but will pass through each other.</p>
			<p>Now, let's add a <strong class="bold">Rigidbody</strong> component<a id="_idIndexMarker467"/> to a GameObject in the scene:</p>
			<ol>
				<li value="1">Create a new cube in the scene by clicking the <strong class="bold">3D Object &gt; Cube</strong> button.</li>
			</ol>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/Figure_5.10_B17146.jpg" alt="Figure 5.10 – Creating a new cube&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Creating a new cube</p>
			<ol>
				<li value="2">Select this newly created cube and click the <strong class="bold">Add Component</strong> button in the Inspector window. And<a id="_idIndexMarker468"/> as you can see in <em class="italic">Figure 5.11</em>, a Box Collider has been attached to the cube:</li>
			</ol>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/Figure_5.11_B17146.jpg" alt="Figure 5.11 – Add Component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Add Component</p>
			<ol>
				<li value="3">Here, we<a id="_idIndexMarker469"/> can select the <strong class="bold">Physics &gt; Rigidbody</strong> button to add a <strong class="bold">Rigidbody </strong>component to this <a id="_idIndexMarker470"/>cube.</li>
			</ol>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="image/Figure_5.12_B17146.jpg" alt="Figure 5.12 – Adding the Box Collider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Adding the Box Collider</p>
			<p>Now we have added a new <strong class="bold">Rigidbody</strong> component, and the properties of this Rigidbody are <a id="_idIndexMarker471"/>shown in <em class="italic">Figure 5.13</em>:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="image/Figure_5.13_B17146.jpg" alt="Figure 5.13 – Properties of a Rigidbody&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Properties of a Rigidbody</p>
			<p>As we can see in <em class="italic">Figure 5.13</em>, the <strong class="bold">Use Gravity</strong> property of the Rigidbody is checked by default, which<a id="_idIndexMarker472"/> means that this Rigidbody will apply gravity to the cube. If we run the game at this time, we<a id="_idIndexMarker473"/> will find that the cube will fall down under the influence of gravity.</p>
			<p>In addition to the <strong class="bold">Use Gravity</strong> property, the Rigidbody has other properties, and we will introduce these properties below.</p>
			<p>The first property of a Rigidbody component is <strong class="bold">Mass</strong>, which determines how Rigidbodies react when they collide with each other. Next is the <strong class="bold">Drag</strong> property, which determines how much air resistance the object is affected by when it is moving under force. By default, the value is <strong class="bold">zero</strong>, which means there is no air resistance when the cube is moving by force. The <strong class="bold">Angular Drag</strong> property is similar to the <strong class="bold">Drag</strong> property, the difference being that it determines how much air resistance affects the object when rotating from torque.</p>
			<p>The <strong class="bold">Is Kinematic</strong> property is important because it determines whether this GameObject will be controlled by the Physics system in Unity. By default, it's disabled. If we enable it, this GameObject will no longer be driven by physics. The <strong class="bold">Interpolate</strong> property is useful when you find that the Rigidbody's movement is jerky. The default value of <strong class="bold">Interpolate</strong> is <strong class="bold">None</strong>, but Unity allows us to select different options for this property, such as <strong class="bold">Interpolate</strong> or <strong class="bold">Extrapolate</strong>, which, respectively, indicate that the transform is based on the transform of the previous frame for smoothing, or that the transform is smoothed based on the estimated transform of the next frame, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/Figure_5.14_B17146.jpg" alt="Figure 5.14 – Options of the Interpolate property&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – Options of the Interpolate property</p>
			<p>Next is the <strong class="bold">Collision Detection</strong> property. Sometimes, if a Rigidbody is moving too fast, causing the physics engine to not<a id="_idIndexMarker474"/> detect the collision in time, then maybe adjusting this property is <a id="_idIndexMarker475"/>a good idea. Unity also provides us with different options for <strong class="bold">Collision</strong><em class="italic"> </em><strong class="bold">Detection</strong>; these are <strong class="bold">Discrete</strong>, <strong class="bold">Continuous</strong>, <strong class="bold">Continuous Dynamic</strong>, and <strong class="bold">Continuous Speculative</strong>.</p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/Figure_5.15_B17146.jpg" alt="Figure 5.15 – Options of the Collision Detection property&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – Options of the Collision Detection property</p>
			<p>The <strong class="bold">Discrete</strong> option is the <a id="_idIndexMarker476"/>default value and is used for detecting normal collisions. If you encountered issues with fast object collisions, then <strong class="bold">Continuous</strong> is a good choice, but you should remember that <strong class="bold">Continuous</strong> will impact performance compared to <strong class="bold">Discrete</strong>.</p>
			<p>If you want to restrict a Rigidbody's motion, such as restricting the Rigidbody from moving in a certain direction or not being able to rotate on a certain axis, then you can do so by modifying the <strong class="bold">Constraints</strong> property. </p>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="image/Figure_5.16_B17146.jpg" alt="Figure 5.16 – The Constraints property&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – The Constraints property</p>
			<p>As shown in <em class="italic">Figure 5.16</em>, you can select an axis to prevent the Rigidbody from moving along it.</p>
			<p>Through a Rigidbody component, we add physical effects to a GameObject, but sometimes we don't want the GameObject to move according to the results of the physics simulation, but<a id="_idIndexMarker477"/> just want to be able to detect the collision between two objects and trigger some<a id="_idIndexMarker478"/> events. This is a common function in games; for example, the player triggers the corresponding logic after entering a certain area. Next, we will introduce another feature provided by Unity to implement such requirements. </p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor083"/>Trigger</h2>
			<p>In addition to providing<a id="_idIndexMarker479"/> collision effects, colliders can also be used as triggers. However, unlike being used as a normal collider, when a trigger is enabled, there is no collision effect when Rigidbodies collide. However, the physical effect will still take effect; for example, a trigger can still fall under the influence of gravity, but it will not collide with other Rigidbodies.</p>
			<p>When developing a<a id="_idIndexMarker480"/> Unity project, triggers are used to detect external interactions from other GameObjects and execute the code in the <strong class="source-inline">OnTriggerEnter</strong>, <strong class="source-inline">OnTriggerStay</strong>, or <strong class="source-inline">OnTriggerExit</strong> functions in the script. These three functions represent three different stages of interactions, namely, entering, staying, and exiting. We will introduce more details about those functions in the next section. For the moment, let's<a id="_idIndexMarker481"/> create a trigger by performing the following steps:</p>
			<ol>
				<li value="1">Select the Cube object we created earlier to open Inspector window.</li>
				<li>Enable the <strong class="bold">Is Trigger</strong> property of the Box Collider component attached to this Cube object, as shown in the following screenshot:      </li>
			</ol>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="image/Figure_5.17_B17146.jpg" alt="Figure 5.17 – Enabling the Is Trigger property&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – Enabling the Is Trigger property</p>
			<p>Now, this cube is set as a trigger, and it will no longer block other Rigidbodies. Since it is now a trigger, we can use it to create game levels. For example, when the player touches this cube, it will trigger <a id="_idIndexMarker482"/>a trap.</p>
			<p>As a reminder, Unity also provides physical components used for 2D. If you want to develop a 2D game and need to apply physical effects to your game, then you can easily add 2D versions of these<a id="_idIndexMarker483"/> physical components in the same way.</p>
			<p>By reading this section, we have learned some concepts of Unity's Physics system, such as colliders, Rigidbodies, and triggers. Next, we will continue to explore how to use C# scripts to interact with the Physics system.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor084"/>Scripting with the Physics system</h1>
			<p>In this section, we will <a id="_idIndexMarker484"/>explore how to interact with the <a id="_idIndexMarker485"/>Physics system via C# scripts. Similar to the previous section, we will also introduce the C# methods for colliders, triggers, and Rigidbodies, respectively. We will start with the C# methods for colliders.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor085"/>Collision methods</h2>
			<p>When a collider is not used as <a id="_idIndexMarker486"/>a trigger, collisions between Rigidbodies still occur. These three methods are called when a collision occurs, and the parameter type is the <strong class="bold">Collision</strong> class, which provides some<a id="_idIndexMarker487"/> information to describe the collision, such as the contact point and the impact velocity of the collision.</p>
			<h3>OnCollisionEnter</h3>
			<p>The first <a id="_idIndexMarker488"/>method is <strong class="source-inline">OnCollisionEnter</strong>, which is called when this collider begins to touch another collider. It is useful when you want to make this object be affected by a physical collision, but also want to perform some game logic when the collision occurs. For example, when a bullet hits the target in a game, a corresponding explosion effect can be generated for it, as the following C# code snippet demonstrates:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class CollisionTest : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">[SerializeField] </p>
			<p class="source-code">private Transform _explosionPrefab;</p>
			<p class="source-code">    private void <strong class="bold">OnCollisionEnter</strong>(Collision collision)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var contact = collision.contacts[0];</p>
			<p class="source-code">        var rotation =</p>
			<p class="source-code">          Quaternion.FromToRotation(Vector3.up,</p>
			<p class="source-code">          contact.normal);</p>
			<p class="source-code">        var position = contact.point;</p>
			<p class="source-code">        Instantiate(_explosionPrefab, position, rotation);</p>
			<p class="source-code">        Destroy(gameObject);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the code snippet, we accessed<a id="_idIndexMarker489"/> the contact point data provided by the collision object and instantiated the explosion asset at that point.</p>
			<h3>OnCollisionStay</h3>
			<p><strong class="source-inline">OnCollisionStay</strong> is the second <a id="_idIndexMarker490"/>method we will explore here. As long as two objects collide, <strong class="source-inline">OnCollisionStay</strong> will be called once per frame. Since this method will be called during the collision of objects, it is suitable to be used to implement some logic that will last for a period of time. An interesting example of this is as follows: Suppose you are developing a helicopter game, and you want the helicopter's engine to run at 60% of its maximum strength when the skid touches the ground. In this case, we can use the following code snippet to implement this<a id="_idIndexMarker491"/> function:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class CollisionTest : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    private void OnCollisionStay(Collision collision)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (collision.gameObject.name == "Ground")</p>
			<p class="source-code">        {</p>
			<p class="source-code">            //Reduce engine strength to 60%</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<h3>OnCollisionExit</h3>
			<p>The last method I want to introduce here is <strong class="source-inline">OnCollisionExit</strong>. As the name of this method implies, it will be <a id="_idIndexMarker492"/>called when this collider stops touching another collider. If some content is generated at the beginning of the object collision via <strong class="source-inline">OnCollisionEnter</strong>, and you want to destroy them when the object collision ends, then you should consider using <strong class="source-inline">OnCollisionExit</strong>:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class CollisionTest : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    private bool _isGrounded;</p>
			<p class="source-code">    private void OnCollisionEnter(Collision collision)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _isGrounded = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private void OnCollisionExit(Collision collision)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _isGrounded = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding code snippet <a id="_idIndexMarker493"/>demonstrates how to use <strong class="source-inline">OnCollisionExit</strong> to reset the <strong class="source-inline">_isGrounded</strong> field. </p>
			<p>We have covered typical methods used in colliders. Now, we'll look at how to use triggers in a Unity project.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor086"/>Trigger methods</h2>
			<p>In fact, we still use <a id="_idIndexMarker494"/>colliders to<a id="_idIndexMarker495"/> implement triggers, and just need to check the <strong class="bold">Is Trigger</strong> option of the <strong class="bold">Collider</strong> component. At this time, the collider will no longer produce the physical collision effect, but activate trigger events.</p>
			<p>There are three events commonly used to implement a trigger, namely, <strong class="source-inline">OnTriggerEnter</strong>, <strong class="source-inline">OnTriggerStay</strong>, and <strong class="source-inline">OnTriggerExit</strong>. These three methods are called when two GameObjects collide, and the parameter type is the <strong class="source-inline">Collider</strong> class, which provides information about other colliders involved in this collision.</p>
			<h3>OnTriggerEnter</h3>
			<p>The first method is <strong class="source-inline">OnTriggerEnter</strong>, which is called when this collider begins touching another <a id="_idIndexMarker496"/>collider. The <strong class="bold">Is Trigger</strong> option should be enabled in this case. This method is useful when you want to trigger some operations on surrounding elements but don't want to produce physical collision effects. For example, you could use this to implement a trap in your game.</p>
			<p>It is also very simple to use. We <a id="_idIndexMarker497"/>only need to include the game logic that will be triggered in the definition of this method, as shown in the following code snippet:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class TriggerTest : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    private void OnTriggerEnter(Collider other)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Debug.Log($"{this} enters {other}");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When this GameObject collides with another GameObject, the string by means of which this GameObject enters the other GameObject will be printed in the Console window.</p>
			<h3>OnTriggerStay</h3>
			<p><strong class="source-inline">OnTriggerStay</strong> is the second <a id="_idIndexMarker498"/>method we will explore here. Similar to the <strong class="source-inline">OnCollisionStay</strong> method we discussed before, <strong class="source-inline">OnTriggerStay</strong> will be called in all frames when other colliders touch this trigger. This method is also suitable for implementing trap-like gameplay in a game; for example, the player enters a poisonous fog and will continue to be hurt:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class TriggerTest : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    private void OnTriggerStay(Collider other)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Debug.Log($"{this} stays {other}");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we also only need to put the <a id="_idIndexMarker499"/>game logic that will be triggered in the definition of the <strong class="source-inline">OnTriggerStay</strong> method, as shown in the preceding code snippet.</p>
			<h3>OnTriggerExit</h3>
			<p>The last method I want to<a id="_idIndexMarker500"/> introduce here is <strong class="source-inline">OnTriggerExit</strong>. This method will be called when other colliders leave the trigger. This method is suitable for some tasks, such as destroying the GameObjects created when other colliders enter this trigger, resetting the state, and so on. The following code snippet shows how to destroy a GameObject in <strong class="source-inline">OnTriggerExit</strong>:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class TriggerTest : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    private void OnTriggerExit(Collider other)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Destroy(other.gameObject);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor087"/>Methods of Rigidbody</h2>
			<p>The <strong class="bold">Rigidbody</strong> component provides us<a id="_idIndexMarker501"/> with the ability to directly interact with the Physics system in Unity. We can use the <a id="_idIndexMarker502"/>methods provided by the <strong class="bold">Rigidbody </strong>component in the C# script to apply a force to this Rigidbody, and we can also apply a force to a Rigidbody that simulates explosion effects.  </p>
			<p>It should be noted that, as we mentioned in <a href="B17146_02_Final_ASB_ePub.xhtml#_idTextAnchor025"><em class="italic">Chapter 2</em></a>, <em class="italic">Scripting Concepts in Unity</em>, in a script, it is recommended to use the <strong class="source-inline">FixedUpdate</strong> function for a physical update, so we should call Rigidbody <a id="_idIndexMarker503"/>methods in the <strong class="source-inline">FixedUpdate</strong> function to apply the physical effect. Now, let's explore some commonly used methods.</p>
			<h3>AddForce</h3>
			<p>The <strong class="source-inline">AddForce</strong> method is one of the<a id="_idIndexMarker504"/> most commonly used methods related to physics. As its name implies, we can call this method to apply a force to the Rigidbody. The function signature of <strong class="source-inline">AddForce</strong> is as follows:</p>
			<p class="source-code">public void AddForce(Vector3 force,</p>
			<p class="source-code">  [DefaultValue("ForceMode.Force")] ForceMode mode);</p>
			<p>As you can see, this method requires two parameters, namely, the force vector in world coordinates and the type of force to apply. <strong class="source-inline">AddForce</strong> allows us to define a force vector and choose how to apply this force to the GameObject to affect how our GameObject moves.</p>
			<p>The first parameter, <strong class="source-inline">force</strong>, is a vector type that specifies the direction in which the force is applied to this object.</p>
			<p>On the other hand, the <strong class="source-inline">ForceMode</strong> type parameter, <strong class="source-inline">mode</strong>, determines the type of force applied. <strong class="source-inline">ForceMode</strong> is an <strong class="source-inline">enum</strong> type, which defines four different types of force. By default, the <strong class="source-inline">AddForce</strong> method will add a continuous force to the Rigidbody, using its mass. In the following section, I will introduce the different types of force modes in detail.</p>
			<h4>ForceMode</h4>
			<p><strong class="source-inline">ForceMode</strong> is defined<a id="_idIndexMarker505"/> in the <strong class="source-inline">UnityEngine</strong> namespace, and we can see its definition in the following code snippet:</p>
			<p class="source-code">namespace UnityEngine</p>
			<p class="source-code">{</p>
			<p class="source-code">    //</p>
			<p class="source-code">    // Summary:</p>
			<p class="source-code">    //     Use ForceMode to specify how to apply a force</p>
			<p class="source-code">           using Rigidbody.AddForce.</p>
			<p class="source-code">    public enum ForceMode</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //</p>
			<p class="source-code">        // Summary:</p>
			<p class="source-code">        //     Add a continuous force to the rigidbody,</p>
			<p class="source-code">               using its mass.</p>
			<p class="source-code">        <strong class="bold">Force</strong> = 0,</p>
			<p class="source-code">        //</p>
			<p class="source-code">        // Summary:</p>
			<p class="source-code">        //     Add an instant force impulse to the</p>
			<p class="source-code">               rigidbody, using its mass.</p>
			<p class="source-code">        <strong class="bold">Impulse</strong> = 1,</p>
			<p class="source-code">        //</p>
			<p class="source-code">        // Summary:</p>
			<p class="source-code">        //     Add an instant velocity change to the</p>
			<p class="source-code">               rigidbody, ignoring its mass.</p>
			<p class="source-code">        <strong class="bold">VelocityChange</strong> = 2,</p>
			<p class="source-code">        //</p>
			<p class="source-code">        // Summary:</p>
			<p class="source-code">        //     Add a continuous acceleration to the</p>
			<p class="source-code">               rigidbody, ignoring its mass.</p>
			<p class="source-code">        <strong class="bold">Acceleration</strong> = 5</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As the preceding code snippet shows, there are four types of force mode, namely, <strong class="source-inline">Force</strong>, <strong class="source-inline">Impulse</strong>, <strong class="source-inline">VelocityChange</strong>, and <strong class="source-inline">Acceleration</strong>. </p>
			<p><strong class="source-inline">Force</strong> is the default<a id="_idIndexMarker506"/> mode and in this mode, more force must be applied to push or distort objects with larger masses because it depends on the mass of the Rigidbody. It will add a continuous force to the Rigidbody.</p>
			<p>If we choose <strong class="source-inline">Impulse</strong> mode as the argument, then the <strong class="source-inline">AddForce</strong> method will apply an instant force impulse to the Rigidbody. This mode is suitable for simulating forces from explosions or collisions. As with the <strong class="source-inline">Force</strong> mode, the <strong class="source-inline">Impulse</strong> mode also depends on the mass of the Rigidbody.</p>
			<p><strong class="source-inline">VelocityChange</strong> is the third mode here. If we select this mode, then Unity will apply the velocity change instantly with a single function call. It should be noted that the <strong class="source-inline">VelocityChange</strong> mode is different from the <strong class="source-inline">Impulse</strong> mode and the <strong class="source-inline">Force</strong> mode. The <strong class="source-inline">VelocityChange</strong> mode does not depend on the mass of the Rigidbody, which means that <strong class="source-inline">VelocityChange</strong> will change the velocity of each Rigidbody in the same way.</p>
			<p>The last mode is <strong class="source-inline">Acceleration</strong> mode. If this mode is selected, then Unity will add a continuous acceleration to the Rigidbody. Like the <strong class="source-inline">VelocityChange</strong> mode, <strong class="source-inline">Acceleration</strong> mode also ignores the mass of the Rigidbody, which means <strong class="source-inline">AddForce</strong> will move every Rigidbody the same way.</p>
			<p>So far, we have learned the different force modes available for the <strong class="source-inline">AddForce</strong> method. Next, let's create a new C# script and apply a force to the cube by calling <strong class="source-inline">AddForce</strong>:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class RigidbodyMethods : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">[SerializeField] </p>
			<p class="source-code">private Rigidbody _rigidbody;</p>
			<p class="source-code">[SerializeField] </p>
			<p class="source-code">private float _thrust = 50f;</p>
			<p class="source-code">    private void Start()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _rigidbody = GetComponent&lt;Rigidbody&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private void FixedUpdate()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (Input.GetKey(KeyCode.F))</p>
			<p class="source-code">        {</p>
			<p class="source-code">            _rigidbody.AddForce(transform.forward *</p>
			<p class="source-code">              _thrust);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        if (Input.GetKey(KeyCode.A))</p>
			<p class="source-code">        {</p>
			<p class="source-code">            _rigidbody.AddForce(transform.forward *</p>
			<p class="source-code">              _thrust, ForceMode.Acceleration);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As shown in the code, we can apply a continuous force to the Rigidbody by pressing the <em class="italic">F</em> key on the keyboard and<a id="_idIndexMarker507"/> applying a continuous acceleration to the Rigidbody by pressing the <em class="italic">A</em> key on the keyboard.</p>
			<h3>MovePosition</h3>
			<p>Sometimes, we just want to<a id="_idIndexMarker508"/> move our GameObjects and don't want to deal with forces. The <strong class="source-inline">MovePosition</strong> method of Rigidbody can help us to achieve this goal.</p>
			<p>The function signature of <strong class="source-inline">MovePosition</strong> is as follows:</p>
			<p class="source-code">public void MovePosition(Vector3 position);</p>
			<p>Here, we need a parameter position to provide the new position for the Rigidbody object to move to. To make the Rigidbody move smoothly, we often use interpolation to achieve a smooth transition between frames. Since <strong class="source-inline">MovePosition</strong> is still a method of Rigidbody, we still call it in the <strong class="source-inline">FixedUpdate</strong> function, as shown in the following code snippet:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class RigidbodyMethods : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">[SerializeField] </p>
			<p class="source-code">private Rigidbody _rigidbody;</p>
			<p class="source-code">[SerializeField] </p>
			<p class="source-code">private float _speed = 50f;</p>
			<p class="source-code">    private void Start()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _rigidbody = GetComponent&lt;Rigidbody&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private void FixedUpdate()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var direction = new</p>
			<p class="source-code">          Vector3(Input.GetAxis("Horizontal"), 0,</p>
			<p class="source-code">          Input.GetAxis("Vertical"));</p>
			<p class="source-code">        _rigidbody.MovePosition(transform.position +</p>
			<p class="source-code">          direction * Time.deltaTime * _speed);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we get user<a id="_idIndexMarker509"/> input as the direction of movement and apply the movement to the current position. You can also see that the movement vector is multiplied by <strong class="source-inline">deltaTime</strong> and <strong class="source-inline">speed</strong>, which is for smooth movement.</p>
			<p>After reading this section, we learned how to interact with the Physics system through C# scripts. But it's best if we implement a simple game ourselves using the physics system, and that's what we'll do in the next section! Let's move on.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor088"/>Creating a simple game based on the Physics system </h1>
			<p>We have learned the<a id="_idIndexMarker510"/> concepts of Unity's Physics system and discussed how to use C# code to interact with the Physics system. Next, we will use the knowledge <a id="_idIndexMarker511"/>we have learned to create a simple physics-based ping-pong game in Unity.</p>
			<p>First, let's perform the following steps to create a <strong class="bold">Plane</strong> object as a ping-pong table:</p>
			<ol>
				<li value="1">Right-click on the <strong class="bold">Hierarchy</strong> window to open the menu.</li>
				<li>Select <strong class="bold">3D Object &gt; Plane</strong> to create a new <strong class="bold">Plane</strong> object in the editor.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="image/Figure_5.18_B17146.jpg" alt="Figure 5.18 – Creating a Plane object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18 – Creating a Plane object</p>
			<ol>
				<li value="3">Rename the <strong class="bold">Plane</strong> object<a id="_idIndexMarker512"/> to <strong class="source-inline">Table</strong>.</li>
				<li>Select <strong class="bold">Table</strong> to open its Inspector <a id="_idIndexMarker513"/>window, modify the <strong class="bold">Z</strong> value of <strong class="bold">Scale</strong> to <strong class="source-inline">2</strong>, and we can see that a Mesh Collider has been added to this object by default.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/Figure_5.19_B17146.jpg" alt="Figure 5.19 – The Inspector window of &quot;Table&quot;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19 – The Inspector window of "Table"</p>
			<ol>
				<li value="5">Let's create four <a id="_idIndexMarker514"/>Cube objects as walls on the table by selecting <strong class="bold">3D Object &gt; Cube</strong>, which is similar to the process of creating a <strong class="bold">Plane</strong> object. By <a id="_idIndexMarker515"/>default, a Box Collider has been added to every Cube object. </li>
				<li>We can easily adjust the position, size, and rotation of these four Cube objects by using the tools in the editor to create the walls on the table.</li>
			</ol>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/Figure_5.20_B17146.jpg" alt="Figure 5.20 – Creating walls on the table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20 – Creating walls on the table</p>
			<p>In order to make the<a id="_idIndexMarker516"/> table look less boring, we can apply different <a id="_idIndexMarker517"/>materials to the walls and the table. Now we have set up the ping-pong table, as shown in the following image:</p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="image/Figure_5.21_B17146.jpg" alt="Figure 5.21 – The ping-pong table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21 – The ping-pong table</p>
			<p>Next, we need to create two players, namely, <strong class="bold">Player1</strong> and <strong class="bold">Player2</strong>. To keep it simple, we still use two Cube objects as players:</p>
			<ol>
				<li value="1">Select <strong class="bold">3D Object &gt; Cube</strong> to create a new Cube object in the scene. </li>
				<li>Rename the Cube object to <strong class="source-inline">Player1</strong>.</li>
				<li>Adjust the position<a id="_idIndexMarker518"/> and size of <strong class="bold">Player1</strong>. For example, we can modify the <strong class="bold">X</strong> value of <strong class="bold">Scale</strong> to <strong class="source-inline">3</strong>. </li>
			</ol>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/Figure_5.22_B17146.jpg" alt="Figure 5.22 – The Inspector window of Player1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22 – The Inspector window of Player1</p>
			<ol>
				<li value="4">Let's repeat the <a id="_idIndexMarker519"/>preceding steps to create another player.</li>
				<li>We can use different colors to identify <strong class="bold">Player1</strong> and <strong class="bold">Player2</strong> to distinguish them, as the following figure shows: </li>
			</ol>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="image/Figure_5.23_B17146.jpg" alt="Figure 5.23 – Player1 and Player2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23 – Player1 and Player2</p>
			<p>Now we have the <strong class="bold">Player</strong> objects in our<a id="_idIndexMarker520"/> simple game. Next, we will add a ping-pong<a id="_idIndexMarker521"/> ball to our game:</p>
			<ol>
				<li value="1">Select <strong class="bold">3D Object &gt; Sphere</strong> to create a new <strong class="bold">Sphere</strong> object in the scene. </li>
				<li>Rename the <strong class="bold">Sphere</strong> object to <strong class="source-inline">Ball</strong>.</li>
				<li>Select <strong class="bold">Ball</strong> to open its Inspector window. We can see that a Sphere Collider has been added to the ball by default.</li>
			</ol>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="image/Figure_5.24_B17146.jpg" alt="Figure 5.24 – The Sphere Collider component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24 – The Sphere Collider component</p>
			<ol>
				<li value="4">Then, we need to <a id="_idIndexMarker522"/>add a <strong class="bold">Rigidbody</strong> component to this <a id="_idIndexMarker523"/>ball by clicking the <strong class="bold">Add Component</strong> button and selecting <strong class="bold">Physics &gt; Rigidbody</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="image/Figure_5.25_B17146.jpg" alt="Figure 5.25 – Adding a Rigidbody component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.25 – Adding a Rigidbody component</p>
			<ol>
				<li value="5">Then, we change the <strong class="bold">Interpolate</strong> option of this <strong class="bold">Rigidbody</strong> component from <strong class="bold">None</strong> to <strong class="bold">Interpolate</strong> to make the transformation smooth based on the transformation of the previous frame.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="image/Figure_5.26_B17146.jpg" alt="Figure 5.26 – Changing the Interpolate option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.26 – Changing the Interpolate option</p>
			<ol>
				<li value="6">Then, we also<a id="_idIndexMarker524"/> change the <strong class="bold">Collision Detection</strong> option of this <strong class="bold">Rigidbody</strong> component from <strong class="bold">Discrete</strong> to <strong class="bold">Continuous Dynamic</strong> so that we <a id="_idIndexMarker525"/>can handle the fast-moving ping-pong ball correctly.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="image/Figure_5.27_B17146.jpg" alt="Figure 5.27 – Changing the Collision Detection option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.27 – Changing the Collision Detection option</p>
			<ol>
				<li value="7">Since the real-world ping-pong ball will bounce back when it hits an obstacle, in order to simulate this bounce effect, we need to create a physic material by clicking <strong class="bold">Create &gt; Physic Material</strong> in the Project window.</li>
			</ol>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="image/Figure_5.28_B17146.jpg" alt="Figure 5.28 – Creating a physic material&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.28 – Creating a physic material</p>
			<ol>
				<li value="8">Let's select the newly created <a id="_idIndexMarker526"/>physic material to open the Inspector window and change both <strong class="bold">Dynamic Friction</strong> and <strong class="bold">Static Friction</strong> from <strong class="source-inline">0.4</strong> to <strong class="source-inline">0</strong>, and <strong class="bold">Bounciness</strong> from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>. Also, set the <strong class="bold">Friction Combine</strong> option to <strong class="source-inline">Multiply</strong> and<a id="_idIndexMarker527"/> the <strong class="bold">Bounce Combine</strong> option to <strong class="source-inline">Maximum</strong>, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="image/Figure_5.29_B17146.jpg" alt="Figure 5.29 – Physic Material settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.29 – Physic Material settings</p>
			<ol>
				<li value="9">Then, assign this physic material to the <strong class="bold">Material</strong> option of the Sphere Collider.</li>
			</ol>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="image/Figure_5.30_B17146.jpg" alt="Figure 5.30 – Assigning the physic material to the Sphere Collider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.30 – Assigning the physic material to the Sphere Collider</p>
			<p>Now we have set up <a id="_idIndexMarker528"/>the ping-pong ball that will be used in our game. Next, let's create a new C# script to apply force to the ball to move it:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class PingPongBall : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    [SerializeField] private Rigidbody _rigidbody;</p>
			<p class="source-code">    [SerializeField] private Vector3 _initialImpulse;</p>
			<p class="source-code">    private void Start()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _rigidbody.<strong class="bold">AddForce</strong>(_initialImpulse,</p>
			<p class="source-code">          <strong class="bold">ForceMode.Impulse</strong>);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this script, we are using the <strong class="source-inline">AddForce</strong> method <a id="_idIndexMarker529"/>and <strong class="source-inline">Impulse</strong> force mode that we learned about previously to apply an impulse force to the ball. The direction and magnitude of the force are provided by the <strong class="source-inline">_initialImpulse</strong> variable. This can be set in the editor.</p>
			<p>Let's now attach this script to the ball and provide a value for the <strong class="source-inline">_initialImpulse</strong> variable.</p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="image/Figure_5.31_B17146.jpg" alt="Figure 5.31 – Ping Pong Ball (Script)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.31 – Ping Pong Ball (Script)</p>
			<p>As the preceding screenshot <a id="_idIndexMarker530"/>demonstrates, the <a id="_idIndexMarker531"/>value of the <strong class="source-inline">_initialImpulse</strong> variable is (<strong class="source-inline">8</strong>, <strong class="source-inline">0</strong>, <strong class="source-inline">8</strong>), which means we add an instant force impulse pointing to the lower-right corner of the table to the Rigidbody. </p>
			<p>Let's play the game and see what happens.</p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="image/Figure_5.32_B17146.jpg" alt="Figure 5.32 – The ball is bounced&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.32 – The ball is bounced</p>
			<p>From the picture, we can <a id="_idIndexMarker532"/>see that the ping-pong ball in the game hit the wall and bounced. Next, we will add more logic to the player objects so that we can control them in the game.</p>
			<p>However, before we<a id="_idIndexMarker533"/> start to write C# code for our player objects, we should first add a <strong class="bold">Rigidbody</strong> component to each of them, and set the <strong class="bold">Rigidbody</strong> component settings as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer264" class="IMG---Figure">
					<img src="image/Figure_5.33_B17146.jpg" alt="Figure 5.33 – Settings of the player's Rigidbody component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.33 – Settings of the player's Rigidbody component</p>
			<p>As you can see from the screenshot, we first set the mass of the <strong class="bold">Rigidbody</strong> component to <strong class="source-inline">1000</strong> and disabled the effect of gravity by unchecking the <strong class="bold">Use Gravity</strong> option.</p>
			<p>Then, it is worth your<a id="_idIndexMarker534"/> attention that we have restricted the movement of the Rigidbody. Since the player object will only move along the x axis and will not<a id="_idIndexMarker535"/> rotate, we only keep the Rigidbody moving along the x axis without constraint.</p>
			<p>Next, we also need to configure the controls for these two different players, as shown in the following steps:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Project Settings</strong> window by selecting <strong class="bold">Edit &gt; Project Settings</strong> in the editor.</li>
			</ol>
			<div>
				<div id="_idContainer265" class="IMG---Figure">
					<img src="image/Figure_5.34_B17146.jpg" alt="Figure 5.34 – Opening the Project Settings window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.34 – Opening the Project Settings window</p>
			<ol>
				<li value="2">Select <strong class="bold">Input Manager</strong> from the navigation on the left to open the <strong class="bold">Input Manager</strong> window.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer266" class="IMG---Figure">
					<img src="image/Figure_5.35_B17146.jpg" alt="Figure 5.35 – Opening the Input Manager window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.35 – Opening the Input Manager window</p>
			<ol>
				<li value="3">We will define the <a id="_idIndexMarker536"/>input axis and related actions of player 1 and player 2 in this window to allow us to use the up and down arrow keys and the w and s keys to control the movement of these two player objects, respectively, as shown<a id="_idIndexMarker537"/> in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="image/Figure_5.36_B17146.jpg" alt="Figure 5.36 – Setting up the input controls for players&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.36 – Setting up the input controls for players</p>
			<p>So far, we have set up the Rigidbody components and the input control needed by the player objects, and then we can write a C# script to control the player objects in our game.</p>
			<p>Remember the <strong class="source-inline">MovePosition</strong> method we introduced before? Here, we will use this method to <a id="_idIndexMarker538"/>move the player <a id="_idIndexMarker539"/>objects:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class Player : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">[SerializeField] </p>
			<p class="source-code">private Rigidbody _rigidbody;</p>
			<p class="source-code">[SerializeField] </p>
			<p class="source-code">private float _speed = 10f;</p>
			<p class="source-code">[SerializeField] </p>
			<p class="source-code">private bool _isPlayerOne;</p>
			<p class="source-code">    private void Start()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _rigidbody = GetComponent&lt;Rigidbody&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private void FixedUpdate()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var inputAxis = _isPlayerOne ? "PlayerOneMove" :</p>
			<p class="source-code">          "PlayerTwoMove";</p>
			<p class="source-code">        var direction = new</p>
			<p class="source-code">          Vector3(<strong class="bold">Input.GetAxis</strong>(inputAxis), 0, 0);</p>
			<p class="source-code">        _rigidbody.<strong class="bold">MovePosition</strong>(transform.position +</p>
			<p class="source-code">          direction * Time.deltaTime * _speed);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As shown in the preceding code, this script will first determine which player the object is, get the corresponding input settings, and<a id="_idIndexMarker540"/> then determine the direction of the object's movement based on the player's input. </p>
			<p>Now, let's attach this script to these two player objects and start the game!</p>
			<div>
				<div id="_idContainer268" class="IMG---Figure">
					<img src="image/Figure_5.37_B17146.jpg" alt="Figure 5.37 – The ping-pong game&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.37 – The ping-pong game</p>
			<p>As shown in the preceding<a id="_idIndexMarker541"/> image, we can now use the <em class="italic">w</em> and <em class="italic">s</em> keys and the <em class="italic">up</em> and <em class="italic">down</em> keys to control the movement of player 1 and player 2 and, as expected, the ping-pong ball will bounce when it hits the players.</p>
			<p>In this section, we made a simple physics-based game, and now we will introduce how to optimize the performance of the Physics system when developing a game in Unity.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor089"/>Increasing the performance of the Physics system</h1>
			<p>Physical simulation requires <a id="_idIndexMarker542"/>a lot of calculations, especially in the case of high physical accuracy requirements. Therefore, it is very important to understand how to use Unity's Physics system correctly and reduce unnecessary computing overhead.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor090"/>The Unity Profiler</h2>
			<p>First, we should learn<a id="_idIndexMarker543"/> how to use tools to view and locate performance bottlenecks caused by the Physics system in Unity. </p>
			<p>The <strong class="bold">Profiler</strong> tool in the Unity Editor is our <a id="_idIndexMarker544"/>recommended tool, which allows us to easily view various performance data and locate performance issues related to the Physics system. </p>
			<p>Taking the ping-pong game we just made as an example, we can perform the following steps to view the performance data of this game:</p>
			<ol>
				<li value="1">Start the game in the editor by clicking the <strong class="bold">Play</strong> button.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="image/Figure_5.38_B17146.jpg" alt="Figure 5.38 – Playing the game in the editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.38 – Playing the game in the editor</p>
			<ol>
				<li value="2">Click <strong class="bold">Window &gt; Analysis &gt; Profiler</strong> or use the keyboard shortcut <em class="italic">Ctrl + 7</em> (<em class="italic">Command + 7</em> on macOS) to open the <strong class="bold">Profiler</strong> window.</li>
				<li>Click the <strong class="bold">CPU Usage</strong> module area in the <strong class="bold">Profiler</strong> window to view the performance data of CPU <a id="_idIndexMarker545"/>overheads, such as the CPU time consumed by <strong class="bold">FixedUpdate.PhysicsFixedUpdate</strong>, as shown here:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="image/Figure_5.39_B17146.jpg" alt="Figure 5.39 – The Unity Profiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.39 – The Unity Profiler</p>
			<p>In addition to the <strong class="bold">CPU Usage</strong> module, we can also view the detailed information of the Physics system, such as the<a id="_idIndexMarker546"/> number of Rigidbodies and the number of contacts at a specific moment, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="image/Figure_5.40_B17146.jpg" alt="Figure 5.40 – The Physics data in the profiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.40 – The Physics data in the profiler</p>
			<p>Next, we will introduce some tips for improving the performance of the Physics system.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor091"/>Increasing the fixed timestep</h2>
			<p>One idea to reduce the <a id="_idIndexMarker547"/>cost of physics computing is to reduce the number of updates per second of the Physics system. We can perform the following steps to increase this <strong class="bold">Fixed Timestep</strong> setting to achieve this goal:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Project Settings</strong> window by selecting <strong class="bold">Edit &gt; Project Settings</strong> in the editor.</li>
				<li>Select <strong class="bold">Time</strong> from the navigation on the left to open the <strong class="bold">Time</strong> window.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="image/Figure_5.41_B17146.jpg" alt="Figure 5.41 – Time settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.41 – Time settings</p>
			<ol>
				<li value="3">The default value of <strong class="bold">Fixed Timestep</strong> is <strong class="bold">0.02</strong>, which means the Physics system will be updated 50 times per second. To reduce the number of updates per second, we can increase this value. </li>
			</ol>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor092"/>Reducing unnecessary layer-based collision detections</h2>
			<p>Unity uses a rather <a id="_idIndexMarker548"/>inefficient physical collision detection mode by default; that is, collision detection is performed on all GameObjects. We can reduce the number of collision detections by modifying the <strong class="bold">Layer Collision Matrix</strong> field in the <strong class="bold">Physics</strong> settings of Unity and setting different layers for different GameObjects. The following steps demonstrate how to modify it:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Project Settings</strong> window by selecting <strong class="bold">Edit &gt; Project Settings</strong> in the editor.</li>
				<li>Select <strong class="bold">Physics</strong> from the navigation on the left to open the <strong class="bold">Physics</strong> window.</li>
				<li>You can find <strong class="bold">Layer Collision Matrix</strong> at the bottom of the <strong class="bold">Physics</strong> window, and you can see in <em class="italic">Figure 5.42</em> that <a id="_idIndexMarker549"/>everything collides with everything by default. We should only enable the layers that require collision detection in this matrix.</li>
			</ol>
			<div>
				<div id="_idContainer273" class="IMG---Figure">
					<img src="image/Figure_5.42_B17146.jpg" alt="Figure 5.42 – Layer Collision Matrix&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.42 – Layer Collision Matrix</p>
			<p>In this section, we introduced how to use Unity's Profiler tool to view the performance data of the Physics system and explored how to optimize the performance of the latter.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor093"/>Summary</h1>
			<p>In this chapter, we started by introducing the physics solutions provided by Unity, including two built-in physics solutions, <strong class="bold">Nvidia PhysX engine</strong> and <strong class="bold">Box2D engine</strong>, and Unity also provides Physics engine packages, namely, the <strong class="bold">Unity Physics package</strong> and the <strong class="bold">Havok Physics for Unity package</strong>. Then, we explored some of the most important concepts in Unity's Physics system, such as the <strong class="bold">Collider</strong> component, the <strong class="bold">Rigidbody</strong> component, and <strong class="bold">Triggers</strong>. We also discussed how to create a new script in Unity to interact with Unity's Physics system.</p>
			<p>Then, we demonstrated how to implement a physics-based ping-pong game in Unity.</p>
			<p>Finally, we explored some best practices for applying a physics simulation in Unity to optimize the performance problems caused by the Physics system.</p>
			<p>In the next chapter, we will be discussing how to implement video and audio features in Unity.</p>
		</div>
	</body></html>