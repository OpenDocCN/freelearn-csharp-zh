<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-66">
    <a id="_idTextAnchor094">
    </a>
    
     5
    
   </h1>
   <h1 id="_idParaDest-67">
    <a id="_idTextAnchor095">
    </a>
    
     The Middleware Pipeline
    
   </h1>
   <p>
    
     APIs are collections of commands that can be triggered on request.
    
    
     When a request is received, we can execute logic that is bespoke to the use case of that request.
    
    
     However, a request does not instantly hit our endpoints as soon as it is received.
    
    
     There is a pipeline that is first traversed before our logic can be executed and the request is eventually returned to the client.
    
    
     This pipeline is called the middleware pipeline, and it is a feature set within ASP.NET that allows us to extend our APIs in a way that separates concerns, optimizes performance, and
    
    
     
      promotes reusability.
     
    
   </p>
   <p>
    
     In this chapter, we are going to explore
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      An introduction
     
     
      
       to middleware
      
     
    </li>
    <li>
     
      Configuring
     
     
      
       middleware pipelines
      
     
    </li>
    <li>
     
      Implementing
     
     
      
       custom middleware
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-68">
    <a id="_idTextAnchor096">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     You are encouraged to write and extend the code examples shown in this chapter to improve your practical understanding.
    
    
     However, if you wish to gain access to the source code, you can obtain it from the following GitHub
    
    
     
      link:
     
    
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     
      
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-69">
    <a id="_idTextAnchor097">
    </a>
    
     An introduction to middleware
    
   </h1>
   <p>
    <strong class="bold">
     
      Middleware
     
    </strong>
    
     as a
    
    <a id="_idIndexMarker126">
    </a>
    
     concept was introduced to ASP.NET in ASP.NET Core.
    
    
     Replacing the older HTTP pipeline model, which used HTTP modules and HTTP handlers, it offers a simpler and more flexible way to manage the way HTTP requests are handled
    
    
     
      by APIs.
     
    
   </p>
   <p>
    
     If you think of an API application as a pipeline with requests traveling through it, the concept becomes
    
    
     
      more straightforward.
     
    
   </p>
   <p>
    
     Middleware is
    
    <a id="_idIndexMarker127">
    </a>
    
     a component that sits on the pipeline before a request is handled by an endpoint.
    
    
     It is executed on every request and is part of a sequence, with components executing in the order in which they
    
    
     
      were registered.
     
    
   </p>
   <p>
    
     Each middleware component has a role to play, with the ability to affect the request irrespective of the endpoint it has requested.
    
    
     Each middleware component can be built in, such as routing, for example, or custom middleware, written for specific purposes such as logging or authentication, to name
    
    
     
      a couple.
     
    
   </p>
   <p>
    
     Once a middleware component has completed its work, it passes the request to the next middleware component in the pipeline, until all middleware components have been traversed.
    
    
     Then the request can hit the endpoint holding the code written, which has logic specific to
    
    
     
      that endpoint.
     
    
   </p>
   <p class="callout-heading">
    
     Middleware progression
    
   </p>
   <p class="callout">
    
     It’s worth noting that while it is true that middleware components pass requests on to each other in a chain, they only do this unless there is a reason for the request to be terminated, with an exception being returned.
    
    
     Depending on the context, a middleware pipeline can end prematurely
    
    
     
      by design.
     
    
   </p>
   <p>
    
     As you have seen in the previous chapters, endpoints must send some form of response to their clients.
    
    
     Once request handling has been completed, endpoints then send the response back to the client via the middleware pipeline, where it travels once again through each middleware component in
    
    
     
      reverse order.
     
    
   </p>
   <p>
    
     Here is a visualization of
    
    <a id="_idIndexMarker128">
    </a>
    
     an example
    
    
     
      request pipeline:
     
    
   </p>
   <div><div><img alt="Figure 5.1: An example middleware pipeline flow" src="img/B20968_05_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.1: An example middleware pipeline flow
    
   </p>
   <p>
    
     Middleware is a very
    
    <a id="_idIndexMarker129">
    </a>
    
     important aspect of not just minimal APIs but ASP.NET in general, with widespread use in web API and MVC projects.
    
    
     It provides developers with a way of registering custom behavior at the application level, as a design pattern that decouples this behavior from
    
    
     
      endpoint-specific logic.
     
    
   </p>
   <p>
    
     For example, there are certain logs that might need to be captured every time a request is received.
    
    
     This could be a log stating that a resource such as a SQL database was accessed as part of a request, or an error log if the request should not have
    
    
     
      been made.
     
    
   </p>
   <p>
    
     It would be inefficient to include the logging code in every endpoint as they are written, and the developer would have to remember to include the logic to capture the log message.
    
    
     This is, as you can imagine, not sustainable and is a
    
    <a id="_idIndexMarker130">
    </a>
    
     violation of the
    
    <strong class="bold">
     
      don’t repeat yourself
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DRY
     
    </strong>
    
     ) principle.
    
    
     Using a logging middleware component means that the required log messages will be captured every time a request is received, and it only has to be
    
    
     
      configured once.
     
    
   </p>
   <p>
    
     This is not to say that middleware components
    
    <em class="italic">
     
      must
     
    </em>
    
     be general in their execution.
    
    
     They are classes or methods like any other and have access to the incoming request in the form of an
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     object.
    
    
     As a result, they can scrutinize the request just like an endpoint can and execute any custom logic applicable to that request before the endpoint
    
    
     
      is reached.
     
    
   </p>
   <p>
    
     Let’s look at a basic example of a middleware
    
    <a id="_idIndexMarker131">
    </a>
    
     component that is created as a class.
    
    
     The component simply writes to the console before calling the next component in
    
    
     
      the sequence:
     
    
   </p>
   <pre class="source-code">
public class MySuperSimpleMiddlewareClass
{
    private readonly RequestDelegate _next;
    public MySuperSimpleMiddlewareClass(
        RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        Console.WriteLine(
            "Request handled by middleware component");
        await _next(context);
        Console.WriteLine(
            "Response handled by middleware component");
    }
}</pre>
   <p>
    
     This middleware
    
    <a id="_idIndexMarker132">
    </a>
    
     class has a constructor that receives an object of type
    
    <strong class="source-inline">
     
      RequestDelegate
     
    </strong>
    
     when the class is instantiated.
    
    
     This delegate is a representation of the next middleware component in the pipeline.
    
    
     The
    
    <strong class="source-inline">
     
      _next()
     
    </strong>
    
     delegate can be used to call the next middleware component and continue
    
    
     
      the sequence.
     
    
   </p>
   <p>
    
     Understanding how the pipeline passes control flow between each component is critical, but it’s worth nothing if we don’t know how to build our own components.
    
    
     We’ll now move on to explore how you can create and configure middleware within
    
    
     
      your pipeline.
     
    
   </p>
   <h1 id="_idParaDest-70">
    <a id="_idTextAnchor098">
    </a>
    
     Configuring middleware pipelines
    
   </h1>
   <p>
    
     You can structure a middleware component in different ways depending on its purpose.
    
    
     The previous example demonstrated the creation of a simple middleware component using a class.
    
    
     Let’s explore this type of component in more detail before looking at other ways of building and
    
    
     
      registering them.
     
    
   </p>
   <h2 id="_idParaDest-71">
    <a id="_idTextAnchor099">
    </a>
    
     Middleware classes
    
   </h2>
   <p>
    
     Middleware classes
    
    <a id="_idIndexMarker133">
    </a>
    
     need to have an
    
    <strong class="source-inline">
     
      Invoke
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      InvokeAsync
     
    </strong>
    
     method so that they can be triggered when it is their turn.
    
    
     Notice how, in the example we saw in the previous section, we have a method called
    
    <strong class="source-inline">
     
      _next()
     
    </strong>
    
     , passing in the
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     object that the same method received.
    
    
     This is where the middleware component calls the next component in
    
    
     
      the pipeline.
     
    
   </p>
   <p>
    
     Once you’ve created a middleware component, you will need to add it to the pipeline.
    
    
     In a minimal API, the setup of the API takes place in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     , with the creation of a
    
    
     <strong class="source-inline">
      
       WebApplication
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     Remember in the previous chapters when we created an instance of
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     and called it
    
    <strong class="source-inline">
     
      app
     
    </strong>
    
     ?
    
    
     This
    
    <strong class="source-inline">
     
      app
     
    </strong>
    
     object has a method called
    
    <strong class="source-inline">
     
      UseMiddleware&lt;T&gt;()
     
    </strong>
    
     .
    
    
     This allows us to tell the
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     object that it should use a middleware component of a specific type.
    
    
     If we wanted to register our
    
    <strong class="source-inline">
     
      MySuperSimpleMiddleware
     
    </strong>
    
     class as middleware, we would do it before we start the
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     object
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       app.Run()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
WebApplicationBuilder builder =
    WebApplication.CreateBuilder(args);
var app = builder.Build();
app.UseMiddleware&lt;MySuperSimpleMiddlewareClass&gt;();
app.Run();</pre>
   <p>
    
     Now that the middleware has been added to our
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     object.
    
    
     it will be invoked within
    
    
     
      the pipeline.
     
    
   </p>
   <p>
    
     Writing middleware in a class has its advantages and disadvantages.
    
    
     On one hand, it might make sense to use a class to be keep middleware tidy and decoupled from the
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     object.
    
    
     You might also want to use a factory design pattern to produce and register
    
    <a id="_idIndexMarker134">
    </a>
    
     appropriate middleware classes.
    
    
     On the other hand, the use of a class may be overkill.
    
    
     After all, we are building
    
    <em class="italic">
     
      minimal APIs
     
    </em>
    
     , where, most of the time, it is favorable to keep logic small
    
    
     
      and simple.
     
    
   </p>
   <p>
    
     In the spirit of minimalism, there is an alternative to middleware classes in the form of
    
    
     
      inline middleware.
     
    
   </p>
   <h2 id="_idParaDest-72">
    <a id="_idTextAnchor100">
    </a>
    
     Inline middleware
    
   </h2>
   <p>
    
     This is a lot simpler than using
    
    <a id="_idIndexMarker135">
    </a>
    
     classes.
    
    
     When
    
    <a id="_idIndexMarker136">
    </a>
    
     creating middleware inline, we create and register the component with our
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     object in one block of code.
    
    
     Once again, considering our instance of
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     called
    
    <strong class="source-inline">
     
      app
     
    </strong>
    
     , we will still be passing in an
    
    <strong class="source-inline">
     
      HTTPContext
     
    </strong>
    
     object and
    
    <strong class="source-inline">
     
      RequestDelegate
     
    </strong>
    
     object, but instead of a constructor, private field, and
    
    <strong class="source-inline">
     
      InvokeAsync()
     
    </strong>
    
     method, everything will happen inside the body of
    
    
     
      the endpoint.
     
    
   </p>
   <p>
    
     Let’s look at how we could rewrite
    
    <strong class="source-inline">
     
      MySuperSimpleMiddlewareClass
     
    </strong>
    
     into an inline
    
    
     
      middleware component:
     
    
   </p>
   <pre class="source-code">
app.Use(async (context, next) =&gt;
{
    Console.WriteLine(
        "Request handled by inline middleware component");
    await next(context);
    Console.WriteLine(
        "Response handled by inline middleware component");
});</pre>
   <p>
    
     In this example, we add
    
    <strong class="source-inline">
     
      app.UseMiddleware&lt;MySuperSimpleMiddlewareClass&gt;()
     
    </strong>
    
     with the much more generic
    
    <strong class="source-inline">
     
      app.Use()
     
    </strong>
    
     .
    
    
     Instead of specifying a type, we are now passing an asynchronous anonymous function that will be registered to the pipeline.
    
    
     The body of the lambda expression shown in the example is the equivalent of
    
    <strong class="source-inline">
     
      InvokeAsync()
     
    </strong>
    
     found
    
    
     
      within
     
    
    
     <strong class="source-inline">
      
       MySuperSimpleMiddlewareClass
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Just like before, we are writing a console message on the incoming request, followed by a call to the
    
    <strong class="source-inline">
     
      RequestDelegate
     
    </strong>
    
     , object which passes to the next component.
    
    
     We then have another console message, which will be executed on the request response as it travels back through the pipeline on its way to
    
    
     
      the client.
     
    
   </p>
   <p>
    
     The beauty of registering middleware inline is its consistency with the endpoints you create.
    
    
     If you were to register small middleware components in this way, before constructing endpoints by mapping
    
    <a id="_idIndexMarker137">
    </a>
    
     them onto the
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     object, your project would
    
    <a id="_idIndexMarker138">
    </a>
    
     indeed be minimal in the way minimal APIs were designed
    
    
     
      to be.
     
    
   </p>
   <p>
    
     We have covered the basics of configuring pipelines in the previous section, but there are some pitfalls that you should be aware of to ensure you are getting the benefits
    
    
     
      of middleware.
     
    
   </p>
   <h3>
    
     Maintaining order
    
   </h3>
   <p>
    
     As we discussed in the first part
    
    <a id="_idIndexMarker139">
    </a>
    
     of the chapter, middleware resides as a sequence of components within a pipeline in which a request travels between the client
    
    
     
      and server.
     
    
   </p>
   <p>
    
     This sequence of components is linear, meaning that the order in which individual components are executed is critical, depending on their
    
    
     
      respective goals.
     
    
   </p>
   <p>
    
     The order of execution is determined by the order in which the components are registered, and how they are registered is determined by the way they are constructed – that is, class-based or as
    
    
     
      inline middleware.
     
    
   </p>
   <p>
    
     Each of these components can modify the request and the response within the pipeline.
    
    
     As you can imagine, this makes it easy to produce unexpected results if caution is not taken.
    
    
     For example, as part of your pipeline, you may need to add a field to the payload.
    
    
     This is fine, but if you have another middleware component within the pipeline that references that new field, you have created a dependency
    
    
     
      between components.
     
    
   </p>
   <p>
    
     If the component that references the new field was to be registered before the component that created it, the pipeline would hit an exception because a property that does not yet exist will have
    
    
     
      been referenced.
     
    
   </p>
   <p>
    
     Therefore, when writing middleware, it is essential that you verify that the request is hitting each component in the
    
    
     
      correct order.
     
    
   </p>
   <p>
    
     Go ahead and run the
    
    <a id="_idIndexMarker140">
    </a>
    
     project containing these middleware examples.
    
    
     You will see the order in which the middleware is executing in the logs shown in the
    
    <strong class="bold">
     
      Output
     
    </strong>
    
     tab accessible from the bottom left of the window in
    
    
     
      Visual Studio.
     
    
   </p>
   <h3>
    
     Default middleware
    
   </h3>
   <p>
    
     There are built-in middleware
    
    <a id="_idIndexMarker141">
    </a>
    
     components that ASP.NET automatically registers for
    
    <a id="_idIndexMarker142">
    </a>
    
     minimal API projects depending on the way they have
    
    
     
      been configured.
     
    
   </p>
   <p>
    
     If the hosting environment is set to
    
    <strong class="source-inline">
     
      Development
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      UseDeveloperExceptionPage
     
    </strong>
    
     middleware will be registered.
    
    
     This component displays a page showing error responses from the pipeline when they occur, which is very useful
    
    
     
      for debugging.
     
    
   </p>
   <p>
    
     The routing that we depend on and worked with in the previous chapter is itself a middleware.
    
    
     It is added automatically by ASP.NET if endpoints exist.
    
    
     ASP.NET will not add it automatically if you add
    
    
     <strong class="source-inline">
      
       UseRouting()
      
     </strong>
    
    
    
    
     
      manually.
     
    
   </p>
   <p>
    
     After
    
    <strong class="source-inline">
     
      UseRouting
     
    </strong>
    
     , ASP.NET will also add
    
    <strong class="source-inline">
     
      UseAuthentication
     
    </strong>
    
     if
    
    <strong class="source-inline">
     
      IAuthenticationSchemeProvider
     
    </strong>
    
     is detected in the service provider.
    
    
     Like
    
    <strong class="source-inline">
     
      UseRouting
     
    </strong>
    
     , if you add the component manually, ASP.NET will skip adding
    
    <strong class="source-inline">
     
      UseAuthentication
     
    </strong>
    
     .
    
    
     The same is true for
    
    <strong class="source-inline">
     
      UseAuthorization()
     
    </strong>
    
     with
    
    <strong class="source-inline">
     
      IAuthorizationSchemeProvider
     
    </strong>
    
     .
    
    
     Most default middleware will not be noticed by the developer
    
    <a id="_idIndexMarker143">
    </a>
    
     unless
    
    <a id="_idIndexMarker144">
    </a>
    
     there is a need to
    
    
     
      override it.
     
    
   </p>
   <p>
    
     Now that we’ve explored middleware as a concept, we should move on to discuss how we can extend minimal APIs by writing our own
    
    
     
      custom middleware.
     
    
   </p>
   <h1 id="_idParaDest-73">
    <a id="_idTextAnchor101">
    </a>
    
     Implementing custom middleware
    
   </h1>
   <p>
    
     Custom middleware is
    
    <a id="_idIndexMarker145">
    </a>
    
     any middleware component that either you have written yourself or is not part of the default middleware components registered
    
    
     
      by ASP.NET.
     
    
   </p>
   <p>
    
     Custom middleware affords us a lot of flexibility in the way we extend the functionality of our API outside of
    
    
     
      request endpoints.
     
    
   </p>
   <p>
    
     Some examples of custom middleware might be
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Logging middleware
      
     </strong>
     
      :  Capture
     
     <a id="_idIndexMarker146">
     </a>
     
      events and store logs as
     
     <a id="_idIndexMarker147">
     </a>
     
      requests
     
     
      
       are received
      
     
    </li>
    <li>
     <strong class="bold">
      
       Error-handling middleware
      
     </strong>
     
      : Have
     
     <a id="_idIndexMarker148">
     </a>
     
      specific ways that errors are
     
     <a id="_idIndexMarker149">
     </a>
     
      treated within
     
     
      
       the pipeline
      
     
    </li>
    <li>
     <strong class="bold">
      
       Validation middleware
      
     </strong>
     
      :  Check
     
     <a id="_idIndexMarker150">
     </a>
     
      that data is in a specific state on
     
     <a id="_idIndexMarker151">
     </a>
     
      receipt
     
     
      
       or response.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Request-timing middleware
      
     </strong>
     
      : Record the
     
     <a id="_idIndexMarker152">
     </a>
     
      time a request takes
     
     <a id="_idIndexMarker153">
     </a>
     
      for the purposes of monitoring
     
     
      
       and telemetry
      
     
    </li>
    <li>
     <strong class="bold">
      
       IP-blocking middleware
      
     </strong>
     
      : Check
     
     <a id="_idIndexMarker154">
     </a>
     
      the IP address of the request’s remote
     
     <a id="_idIndexMarker155">
     </a>
     
      host and check to see if it is in the
     
     
      
       ban list
      
     
    </li>
   </ul>
   <p>
    
     Let’s write
    
    <a id="_idIndexMarker156">
    </a>
    
     some custom middleware using the example of logging.
    
    
     In this example, we’ll keep things simple and minimal by writing the middleware as an inline
    
    
     
      middleware component.
     
    
   </p>
   <p>
    
     Open
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     and start by creating a new blank middleware component; that is to say, create a
    
    <strong class="source-inline">
     
      Use()
     
    </strong>
    
     method receiving an
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     object and a
    
    <strong class="source-inline">
     
      RequestDelegate
     
    </strong>
    
     object with nothing in the body of the accompanying
    
    
     
      lambda expression:
     
    
   </p>
   <pre class="source-code">
app.Use(async (context, next) =&gt;
{
});</pre>
   <p>
    
     Now we have a blank canvas for a simple middleware component, we can add some logic to log some content.
    
    
     In this example, we’re going to log the content to
    
    
     
      the console.
     
    
   </p>
   <p>
    
     The question is,
    
    <em class="italic">
     
      what
     
    </em>
    
     do we want
    
    
     
      to log?
     
    
   </p>
   <p>
    
     The useful thing about having the request passed into the component as a
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     instance, is that we can access the individual properties of the request via this object.
    
    
     This means we can access the target HTTP method, the target route, and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     Let’s start by logging some content from the request as it is received, before passing the control flow on to the next component in the pipeline.
    
    
     To do this, update the body of the lambda expression so that it reflects this updated
    
    
     
      example here:
     
    
   </p>
   <pre class="source-code">
app.Use(async (context, next) =&gt;
{
    Console.WriteLine(
        $"Request: {context.Request.Method}
        {context.Request.Path}");
    await next(context);
});</pre>
   <p>
    
     Now our middleware is accessing data from the request and using string interpolation, arranging the data into a string that can be logged to the console.
    
    
     This gives our API the benefit of being auditable (easy to track and review historical events) and easier to maintain.
    
    
     On top of this, because we’ve used a custom middleware, we’ve not had to repeat ourselves by writing the same log for each endpoint
    
    
     
      we create.
     
    
   </p>
   <p>
    
     Remember, the middleware components on the pipeline don’t just execute for the incoming request.
    
    
     The outgoing response also traverses the middleware pipeline in reverse on its way back to
    
    
     
      the client.
     
    
   </p>
   <p>
    
     If we wanted to log the contents of the response to the console as it travels back through the pipeline, we could simply add another
    
    <strong class="source-inline">
     
      Console.WriteLine()
     
    </strong>
    
     statement underneath our call to
    
    <strong class="source-inline">
     
      next()
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      Response
     
    </strong>
    
     member of the
    
    <strong class="source-inline">
     
      HttpContex
     
    </strong>
    
     t object should provide us with up-to-date data for the outgoing response, which we can log, as in the example
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
app.Use(async (context, next) =&gt;
{
    Console.WriteLine(
        $"Request: {context.Request.Method}
        {context.Request.Path}");
    await next(context);
    Console.WriteLine(
        $"Response: {context.Response.StatusCode}");
});</pre>
   <p>
    
     As a
    
    <a id="_idIndexMarker157">
    </a>
    
     reminder, this was an inline middleware component, meaning that it was created using a lambda expression in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     .
    
    
     For the sake of consistency, here is an example of how the same middleware component could be written in
    
    
     
      a class:
     
    
   </p>
   <pre class="source-code">
public class LoggingMiddleware
{
    private readonly RequestDelegate _next;
    public LoggingMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        Console.WriteLine(
            $"Request: {context.Request.Method}
            {context.Request.Path}");
        await _next(context);
        Console.WriteLine(
            $"Response: {context.Response.StatusCode}");
    }
}</pre>
   <p>
    
     Here is
    
    <a id="_idIndexMarker158">
    </a>
    
     how the
    
    <strong class="source-inline">
     
      Program
     
    </strong>
    
     class
    
    <strong class="source-inline">
    </strong>
    
     would look after registering the
    
    
     
      class-based middleware:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.UseMiddleware&lt;LoggingMiddleware&gt;();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();</pre>
   <p>
    
     Logging
    
    <a id="_idIndexMarker159">
    </a>
    
     is a straightforward example of middleware’s ability to take action before routes are hit.
    
    
     For more complex use cases, it might be necessary to
    
    <strong class="bold">
     
      short-circuit
     
    </strong>
    
     the
    
    <a id="_idIndexMarker160">
    </a>
    
     pipeline.
    
    
     This would stop other components in the pipeline from executing and can be easily achieved by omitting the call to the
    
    
     <strong class="source-inline">
      
       RequestDelegate
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     Short-circuiting is simple enough, but what if our middleware has a level of complexity that means it might have to block routing from taking place?
    
    
     This would mean the middleware stops the request from reaching the
    
    <a id="_idIndexMarker161">
    </a>
    
     intended endpoint, or any endpoints
    
    
     
      at all.
     
    
   </p>
   <p>
    
     To understand this concept
    
    <a id="_idIndexMarker162">
    </a>
    
     further, we need to look at a style of middleware component called
    
    
     <strong class="bold">
      
       terminal middleware
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-74">
    <a id="_idTextAnchor102">
    </a>
    
     Terminal middleware
    
   </h2>
   <p>
    
     Classic middleware
    
    <a id="_idIndexMarker163">
    </a>
    
     components such as the ones we have worked with in this
    
    <a id="_idIndexMarker164">
    </a>
    
     chapter all have one thing in common – the requests that pass through them on the pipeline will eventually reach an endpoint, and then the endpoint will handle sending the requests back through the pipeline to
    
    
     
      the client.
     
    
   </p>
   <p>
    
     However, there are scenarios where we would not want a request to reach the endpoint.
    
    
     For example, if we had implemented a banned IP list, in which IP addresses for malicious or suspicious hosts were listed, we would want to achieve the following
    
    
     
      with middleware:
     
    
   </p>
   <ol>
    <li>
     
      Identify the IP address of the remote host sending
     
     
      
       the request
      
     
    </li>
    <li>
     
      Determine whether the IP address is on the list of
     
     
      
       banned IPs
      
     
    </li>
    <li>
     
      If it is a banned IP address, send a response back to the client from the middleware, stating that the host is forbidden from
     
     
      
       proceeding further
      
     
    </li>
   </ol>
   <p>
    
     Let’s write our own middleware component that checks incoming IP addresses and blocks the request from going any further
    
    
     
      if needed.
     
    
   </p>
   <p>
    
     First, create a
    
    <em class="italic">
     
      scaffold
     
    </em>
    
     of a
    
    
     
      middleware class:
     
    
   </p>
   <pre class="source-code">
public class IPBlockingMiddleware
{
    private readonly RequestDelegate _next;
    public IPBlockingMiddleware(RequestDelegate next,
        IEnumerable&lt;string&gt; blockedIPs)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        await _next(context);
    }
}</pre>
   <p>
    
     At the moment, our middleware doesn’t do anything, other than simply passing control to the next component in
    
    
     
      the pipeline.
     
    
   </p>
   <p>
    
     Looking back at the
    
    <a id="_idIndexMarker165">
    </a>
    
     three goals of our IP-blocking middleware, the first
    
    <a id="_idIndexMarker166">
    </a>
    
     goal is to identify the IP address of the requesting host.
    
    
     This information can be retrieved from the
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     object as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
var requestIP =
    context.Connection.RemoteIpAddress?.ToString();</pre>
   <p>
    
     Next, we need to identify whether the requesting IP address is a banned IP.
    
    
     To do this, we need to add a collection to store the banned list, and then a check against the incoming
    
    
     
      IP address.
     
    
   </p>
   <p>
    
     Add a private
    
    <strong class="source-inline">
     
      HashSet&lt;string&gt;
     
    </strong>
    
     field under the
    
    <strong class="source-inline">
     
      RequestDelegate
     
    </strong>
    
     field.
    
    
     We’ll use this as our
    
    
     
      banned list:
     
    
   </p>
   <pre class="source-code">
private readonly HashSet&lt;string&gt; _blockedIPs;</pre>
   <p>
    
     This list can be passed to the middleware when it is registered via
    
    
     
      its constructor.
     
    
   </p>
   <p>
    
     Update the constructor to
    
    
     
      reflect this:
     
    
   </p>
   <pre class="source-code">
public IPBlockingMiddleware(RequestDelegate next,
    IEnumerable&lt;string&gt; blockedIPs)
    {
        _next = next;
        _blockedIPs = new HashSet&lt;string&gt;(blockedIPs);
    }</pre>
   <p>
    
     Now all that remains is to act against the offending request.
    
    
     We can write messages into the response to the client via the
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     object.
    
    
     Here, we can include a message to inform
    
    <a id="_idIndexMarker167">
    </a>
    
     the client that their IP address is blocked.
    
    
     Following this, we can use a
    
    <strong class="source-inline">
     
      return
     
    </strong>
    
     statement
    
    <a id="_idIndexMarker168">
    </a>
    
     to stop the request in
    
    
     
      its tracks:
     
    
   </p>
   <pre class="source-code">
public async Task InvokeAsync(HttpContext context)
    {
        var requestIP =
            context.Connection.RemoteIpAddress?.ToString();
        if (_blockedIPs.Contains(requestIP))
        {
            context.Response.StatusCode = 403;
            Console.WriteLine(
                $"IP {requestIP} is blocked.");
            await context.Response.WriteAsync(
                "Your IP is blocked.");
            return;
        }
        Console.WriteLine($"IP {requestIP} is allowed.");
        await _next(context);
    }</pre>
   <p>
    
     Once all these changes have been added, we will have a fully functioning custom middleware class that is able to detect banned IP addresses for incoming requests and block them from
    
    <a id="_idIndexMarker169">
    </a>
    
     reaching the endpoints
    
    
     
      we’ve configured.
     
    
   </p>
   <p>
    
     Your
    
    <strong class="source-inline">
     
      IPBlockingMiddleware
     
    </strong>
    
     class should
    
    <a id="_idIndexMarker170">
    </a>
    
     now look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
public class IPBlockingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly HashSet&lt;string&gt; _blockedIPs;
    public IPBlockingMiddleware(RequestDelegate next,
        IEnumerable&lt;string&gt; blockedIPs)
    {
        _next = next;
        _blockedIPs = new HashSet&lt;string&gt;(blockedIPs);
    }
    public async Task InvokeAsync(HttpContext context)
    {
        var requestIP =
            context.Connection.RemoteIpAddress?.ToString();
        if (_blockedIPs.Contains(requestIP))
        {
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync(
                "Your IP is blocked.");
            return;
        }
        await _next(context);
    }
}</pre>
   <p>
    
     In the preceding
    
    <a id="_idIndexMarker171">
    </a>
    
     middleware example, we have a constructor parameter in the form of a list of blocked IPs.
    
    
     This means that when registering the middleware in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     , the list would have to be created beforehand, and then
    
    <a id="_idIndexMarker172">
    </a>
    
     passed in
    
    
     
      during registration:
     
    
   </p>
   <pre class="source-code">
//Create the list of blocked Ips
private readonly List&lt;string&gt; _blockedIPs =
    new List&lt;string&gt; { "192.168.1.1", "203.0.113.0" };
app.UseMiddleware&lt;IPBlockingMiddleware&gt;(_blockedIPs);</pre>
   <p>
    
     You could test the
    
    <strong class="source-inline">
     
      IPBlocking
     
    </strong>
    
     functionality by adding the loopback address to the blacklist.
    
    
     This should return a response with a
    
    <strong class="source-inline">
     
      403
     
    </strong>
    
     
      status code:
     
    
   </p>
   <pre class="source-code">
app.UseMiddleware&lt;IPBlockingMiddleware&gt;(
    new List&lt;string&gt; { "::1" }
);</pre>
   <p>
    
     Gradually, we’re starting to introduce more complex logic into our minimal API with custom and default middleware components.
    
    
     As complexity increases, so does the probability that errors will occur.
    
    
     As we know, all potential errors must be handled to maintain
    
    
     
      system continuity.
     
    
   </p>
   <p>
    
     Middleware
    
    <a id="_idIndexMarker173">
    </a>
    
     can also be used to achieve this.
    
    
     Let’s explore how we can write a
    
    <a id="_idIndexMarker174">
    </a>
    
     component that catches and handles unexpected behavior and errors that may occur within
    
    
     
      the pipeline.
     
    
   </p>
   <h2 id="_idParaDest-75">
    <a id="_idTextAnchor103">
    </a>
    
     Handling errors within the middleware pipeline
    
   </h2>
   <p>
    
     In
    
    <a id="_idIndexMarker175">
    </a>
    
     this example, we will stick with a class-based middleware component structure, as it offers a clean structure with types that can be swapped out as needed.
    
    
     (This is more of a personal preference than
    
    
     
      good practice.)
     
    
   </p>
   <p>
    
     A dedicated error handling component can be useful, as it ensures that you are always able to review and address errors as they occur, rather than facing the problematic and often embarrassing situation where an unhandled exception crashes the
    
    
     
      application completely.
     
    
   </p>
   <p>
    
     Here is an example of a basic exception-handling
    
    
     
      middleware component:
     
    
   </p>
   <pre class="source-code">
public class ExceptionHandlingMiddleware
{
    private readonly RequestDelegate _next;
    public ExceptionHandlingMiddleware(
        RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            Console.WriteLine(
                $"Exception caught: {ex.Message}");
            context.Response.StatusCode = 500;
            await context.Response.WriteAsync(
                "An unexpected error occurred.");
        }
    }
}</pre>
   <p>
    
     Notice how, in this code, the
    
    <strong class="source-inline">
     
      try catch
     
    </strong>
    
     block in
    
    <strong class="source-inline">
     
      InvokeAsync()
     
    </strong>
    
     doesn’t do much at all in the
    
    <strong class="source-inline">
     
      try
     
    </strong>
    
     body.
    
    
     It simply passes execution to the next component.
    
    
     This is because this middleware will be the first component in the pipeline to be registered.
    
    
     It is the first because we are not interested in handling errors at the first component in the pipeline, but we are for all other
    
    <a id="_idIndexMarker176">
    </a>
    
     components.
    
    
     By placing our logic in the
    
    <strong class="source-inline">
     
      catch
     
    </strong>
    
     body,
    
    <strong class="source-inline">
    </strong>
    
     any errors that happen later in the pipeline will
    
    <em class="italic">
     
      bubble up
     
    </em>
    
     to this component and be caught, allowing us to handle them and then update the response to the
    
    
     
      client accordingly.
     
    
   </p>
   <p>
    
     It also covers us for the handling of any exceptions during the execution of middleware components on the return journey (the response) as the flow of execution is heading back toward this component.
    
    
     As the component was the first to be registered, it will be the last to execute on the
    
    
     
      return journey.
     
    
   </p>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      catch
     
    </strong>
    
     statement, we can do whatever is needed to handle the exception.
    
    
     In this example, we simply write the value of the caught exception’s
    
    <strong class="source-inline">
     
      Message
     
    </strong>
    
     field to the console.
    
    
     Then we set the status code of the request to
    
    <strong class="source-inline">
     
      500 INTERNAL SERVER ERROR
     
    </strong>
    
     and write a message into the response.
    
    
     All of this happens via the
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     object that travels through
    
    
     
      the pipeline.
     
    
   </p>
   <p>
    
     If you wanted to force one of these exceptions to see an example of the output, you could create a dedicated example endpoint that simply throws
    
    
     
      an exception:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/employees/exceptionexample", () =&gt;
{
    throw new NotImplementedException();
});</pre>
   <p>
    
     Calling this endpoint
    
    <a id="_idIndexMarker177">
    </a>
    
     while in
    
    <strong class="source-inline">
     
      Debug
     
    </strong>
    
     mode will display the exception details in
    
    
     
      the browser.
     
    
   </p>
   <div><div><img alt="Figure 5.2: Exception details shown in the browser for debugging purposes" src="img/B20968_05_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.2: Exception details shown in the browser for debugging purposes
    
   </p>
   <p>
    
     In this chapter, we’ve delved deep into the intricacies of middleware and pipeline customization in minimal APIs.
    
    
     By understanding the concepts and practical implementations of middleware, we’ve laid the groundwork for creating more robust, maintainable, and flexible API applications.
    
    
     Let’s summarize the key points and skills
    
    
     
      we’ve covered.
     
    
   </p>
   <h1 id="_idParaDest-76">
    <a id="_idTextAnchor104">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we explored the essential role that middleware plays in the ASP.NET Core minimal APIs.
    
    
     Middleware components are pivotal in the request-response lifecycle, enabling developers to handle key areas of a system such as logging, authentication, error handling,
    
    
     
      and more.
     
    
   </p>
   <p>
    
     We started by introducing the concept of middleware and explaining how it fits into the overall architecture of minimal APIs.
    
    
     Middleware components act as intermediaries that can inspect, modify, or terminate HTTP requests and responses.
    
    
     This modular approach promotes a clean separation of concerns and enhances the maintainability of
    
    
     
      the application.
     
    
   </p>
   <p>
    
     Next, we delved into configuring middleware pipelines, illustrating how the order of middleware registration affects the processing of requests.
    
    
     Middleware components are executed in the order they are added to the pipeline, and the response travels back through the pipeline in reverse order.
    
    
     This sequential processing model is critical for ensuring that each middleware component functions correctly
    
    
     
      and efficiently.
     
    
   </p>
   <p>
    
     We then moved on to implementing custom middleware, providing examples such as logging and IP blocking.
    
    
     These examples demonstrated how custom middleware can be tailored to meet specific
    
    
     
      application requirements.
     
    
   </p>
   <p>
    
     We highlighted the importance of error-handling middleware, showing how it can be used to catch and manage exceptions centrally, thereby simplifying error management and improving
    
    
     
      application robustness.
     
    
   </p>
   <p>
    
     Middleware is a fantastic way of extending the functionality of minimal APIs, but they are useless if their requests don’t have data that can be reviewed, manipulated, and transformed.
    
    
     In the next chapter, we’ll explore how data traveling through an API can be mapped for it to be processed optimally
    
    
     
      and accurately.
     
    
   </p>
  </div>
 </body></html>