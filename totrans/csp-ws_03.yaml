- en: 3\. Delegates, Events, and Lambdas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 委托、事件和Lambda
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how delegates are defined and invoked, and you
    will explore their wide usage across the .NET ecosystem. With this knowledge,
    you will move on to the inbuilt `Action` and `Func` delegates to discover how
    their usage reduces unnecessary boilerplate code. You will then see how multicast
    delegates can be harnessed to send messages to multiple parties, and how events
    can be incorporated into event-driven code. Along the way, you will discover some
    common pitfalls to avoid and best practices to follow that prevent a great application
    from turning into an unreliable one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何定义和调用委托，并探索它们在.NET生态系统中的广泛使用。有了这些知识，你将转向内置的`Action`和`Func`委托，以了解它们的用法如何减少不必要的样板代码。然后，你将看到如何利用多播委托向多个参与者发送消息，以及如何将事件集成到事件驱动代码中。在这个过程中，你将发现一些常见的陷阱和最佳实践，以防止一个优秀应用程序变成不可靠的应用程序。
- en: This chapter will demystify the lambda syntax style and show how it can be used
    effectively. By the end of the chapter, you will be able to use the lambda syntax
    comfortably to create code that is succinct, as well as easy to grasp and maintain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将揭开lambda语法风格的神秘面纱，并展示如何有效地使用它。到本章结束时，你将能够舒适地使用lambda语法来创建简洁、易于理解和维护的代码。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you learned some of the key aspects of Object Oriented
    Programming (OOP). In this chapter, you will build on this by looking at the common
    patterns used specifically in C# that enable classes to interact.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了面向对象编程（OOP）的一些关键方面。在本章中，你将通过查看C#中用于使类相互交互的常见模式来在此基础上进行构建。
- en: Have you found yourself working with a code that has to listen to certain signals
    and act on them, but you cannot be sure until runtime what those actions should
    be? Maybe you have a block of code that you need to reuse or pass to other methods
    for them to call when they are ready. Or, you may want to filter a list of objects,
    but need to base how you would do that on a combination of user preferences. Much
    of this can be achieved using interfaces, but it is often more efficient to create
    chunks of code that you can then pass to other classes in a type-safe way. Such
    blocks are referred to as delegates and form the backbone of many .NET libraries,
    allowing methods or pieces of code to be passed as parameters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否发现自己正在处理必须监听某些信号并在其上采取行动的代码，但你无法确定这些行动应该在运行时是什么？也许你有一段需要重用或传递给其他方法的代码块，以便它们在准备好时调用。或者，你可能想过滤一组对象，但需要根据用户偏好的组合来决定如何进行。许多这样的功能可以通过使用接口来实现，但通常更有效的方法是创建可以以类型安全的方式传递给其他类的代码块。这些块被称为委托，是许多.NET库的骨架，允许将方法或代码片段作为参数传递。
- en: The natural extension to a delegate is the event, which makes it possible to
    offer a form of optional behavior in software. For example, you may have a component
    that broadcasts live news and stock prices, but unless you provide a way to opt
    into these services, you may limit the usability of such a component.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 委托的自然扩展是事件，这使得在软件中提供一种可选行为成为可能。例如，你可能有一个广播实时新闻和股票价格的组件，但除非你提供一种方式来选择加入这些服务，否则你可能限制了该组件的可使用性。
- en: User Interface (UI) apps often provide notifications of various user actions,
    for example, keypresses, swiping a screen, or clicking a mouse button; such notifications
    follow a standard pattern in C#, which will be discussed fully in this chapter.
    In such scenarios, the UI element detecting such actions is referred to as a publisher,
    whereas the code that acts upon those messages is called a subscriber. When brought
    together, they form an event-driven design referred to as the publisher-subscriber,
    or pub-sub, pattern. You will see how this can be used in all types of C#. Remember
    that its usage is not just the exclusive domain of UI applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面（UI）应用程序通常提供各种用户动作的通知，例如按键、滑动屏幕或点击鼠标按钮；这些通知在C#中遵循一个标准模式，将在本章中详细讨论。在这种情况下，检测此类动作的UI元素被称为发布者，而执行这些消息的代码被称为订阅者。当它们结合在一起时，形成了一种称为发布者-订阅者或pub-sub的事件驱动设计。你将看到如何在所有类型的C#中使用它。记住，它的使用并不局限于UI应用程序。
- en: Finally, you will learn about lambda statements and lambda expressions, collectively
    known as lambdas. These have an unusual syntax, which can initially take a while
    to become comfortable with. Rather than having lots of methods and functions scattered
    within a class, lambdas allow for smaller blocks of code that are often self-contained
    and located within close proximity to where they are used in the code, thereby
    offering an easier way to follow and maintain code. You will learn about lambdas
    in detail in the latter half of this chapter. First, you will learn about delegates.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习关于lambda语句和lambda表达式，统称为lambda。这些具有不寻常的语法，一开始可能需要一段时间才能适应。与在类中分散许多方法和函数不同，lambda允许更小的代码块，通常是自包含的，并且位于代码中使用它们的附近，从而提供了一种更容易跟踪和维护代码的方法。你将在本章的后半部分详细了解lambda。首先，你将学习关于委托（delegates）的内容。
- en: Delegates
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托
- en: The .NET delegate is similar to function pointers found in other languages,
    such as C++; in other words, it is like a pointer to a method to be invoked at
    runtime. In essence, it is a placeholder for a block of code, which can be something
    as simple as a single statement or a full-blown multiline code block, complete
    with complex branches of execution, that you ask other code to execute at some
    point in time. The term delegate hints at some form of **representative**, which
    is precisely what this placeholder concept relates to.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: .NET委托与其他语言中找到的函数指针类似，例如C++；换句话说，它是一个指向将在运行时调用的方法的指针。本质上，它是一个代码块的占位符，这可能是一个简单的语句，也可能是一个完整的、多行的代码块，包括复杂的执行分支，你要求其他代码在某个时间点执行。术语“委托”暗示了一种形式的“代表”，这正是这个占位符概念所关联的。
- en: Delegates allow for minimum coupling between objects, and much less code. There
    is no need to create classes that are derived from specific classes or interfaces.
    By using a delegate, you are defining what a compatible method should look like,
    whether it is in a class or struct, static, or instance-based. The arguments and
    return type define this calling compatibility.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 委托允许对象之间的最小耦合和更少的代码。不需要创建从特定类或接口派生的类。通过使用委托，你定义了一个兼容方法的外观，无论它是在类或结构体中，静态的还是基于实例的。参数和返回类型定义了这个调用兼容性。
- en: Furthermore, delegates can be used in a callback fashion, which allows multiple
    methods to be wired up to a single publication source. They often require much
    less code and provide more features than found using an interface-based design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，委托可以以回调的方式使用，这允许将多个方法连接到单个发布源。它们通常需要的代码更少，并且提供的功能比基于接口的设计更多。
- en: 'The following example shows how effective delegates can be. Suppose you have
    a class that searches for users by surname. It would probably look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了委托的有效性。假设你有一个通过姓氏搜索用户的类。它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You then need to extend this to include a search of the user''s login name:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要扩展这个功能，包括搜索用户的登录名：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once again, you decide to add yet another search, this time by location:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你决定添加另一个搜索，这次是通过位置：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You start the searches with code like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始搜索的代码如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Can you see the pattern that is occurring every time? You are repeating the
    same code that iterates through the list of users, applying a Boolean condition
    (also known as a predicate) to find the first matching user.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出每次发生的是什么模式吗？你正在重复相同的代码，该代码遍历用户列表，应用布尔条件（也称为谓词）以找到第一个匹配的用户。
- en: The only thing that is different is that the predicate decides whether a match
    has been found. This is one of the common cases where delegates are used at a
    basic level. The `predicate` can be replaced with a delegate, acting as a placeholder,
    which is evaluated when required.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不同的是，谓词（predicate）决定是否找到了匹配项。这是委托在基本级别使用的一个常见案例。`predicate`可以用一个委托替换，作为占位符，在需要时进行评估。
- en: Converting this code to a delegate style, you define a delegate named `FindUser`
    (this step can be skipped as .NET contains a delegate definition that you can
    reuse; you will come to this later).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码转换为委托风格，你定义一个名为`FindUser`的委托（这一步可以跳过，因为.NET包含一个可以重用的委托定义；你将在稍后了解这一点）。
- en: 'All you need is a single helper method, `Find`, which is passed a `FindUser`
    delegate instance. Find knows how to loop through the users, invoking the delegate
    passing in the user, which returns true or false for a match:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要一个辅助方法，`Find`，它接受一个`FindUser`委托实例。`Find`知道如何遍历用户，调用委托并传入用户，以返回匹配的布尔值：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the code is kept together and is much more concise now. There
    is no need to cut and paste code that loops through the users, as that is all
    done in one place. For each type of search, you simply define a delegate once
    and pass it to `Find`. To add a new type of search, all you need to do is define
    it in a single statement line, rather than copying at least eight lines of code
    that repeat the looping function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码现在更加紧凑。不需要剪切和粘贴遍历用户的代码，因为所有这些都在一个地方完成。对于每种类型的搜索，你只需定义一个 delegate 并将其传递给
    `Find`。要添加新的搜索类型，你只需在单行语句中定义它，而不是复制至少八行重复的循环函数。
- en: The lambda syntax is a fundamental style used to define method bodies, but its
    strange syntax can prove to be an obstacle at first. At first glance, lambda expressions
    can look odd with their `=>` style, but they do offer a cleaner way to specify
    a target method. The act of defining a lambda is similar to defining a method;
    you essentially omit the method name and use `=>` to prefix a block of code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 语法是定义方法体的一种基本风格，但它的奇怪语法可能会在最初成为障碍。乍一看，Lambda 表达式可能看起来很奇怪，因为它们有 `=>` 风格，但它们确实提供了一种更简洁的方式来指定目标方法。定义
    Lambda 的行为与定义方法类似；你基本上省略了方法名，并使用 `=>` 作为代码块的占位符。
- en: You will now look at another example, using interfaces this time. Consider that
    you are working on a graphics engine and need to calculate the position of an
    image onscreen each time the user rotates or zooms in. Note that this example
    skips any complex math calculations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将查看另一个示例，这次使用接口。假设你正在开发一个图形引擎，并且需要在用户每次旋转或缩放时计算屏幕上图像的位置。注意，此示例跳过了任何复杂的数学计算。
- en: 'Consider that you need to transform a `Point` class using the `ITransform`
    interface with a single method named `Move`, as shown in the following code snippet:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你需要使用 `ITransform` 接口和名为 `Move` 的单个方法来转换 `Point` 类，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the user rotates an object, you need to use `RotateTransform`, and for
    a zoom operation, you will use `ZoomTransform`, as follows. Both are based on
    the `ITransform` interface:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户旋转一个对象时，你需要使用 `RotateTransform`，而对于缩放操作，你将使用 `ZoomTransform`，如下所示。两者都基于 `ITransform`
    接口：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, given these two classes, a point can be transformed by creating a new `Transform`
    instance, which is passed to a method named `Calculate`, as shown in the following
    code. `Calculate` calls the corresponding `Move` method, and does some extra unspecified
    work on point, before returning point to the caller:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定这两个类，可以通过创建一个新的 `Transform` 实例并将其传递给名为 `Calculate` 的方法来转换一个点，如下面的代码所示。`Calculate`
    调用相应的 `Move` 方法，并在点上进行一些额外的未指定工作，然后返回点给调用者：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a standard class and interface-based design, but you can see that you
    have made a lot of effort to create new classes with just a single numeric value
    from a `Move` method. It is a worthwhile idea to have the calculations broken
    down into an easy-to-follow implementation. After all, it could have led to a
    future maintenance problem if implemented in a single method with multiple if-then
    branches.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于类和接口的标准设计，但你也可以看到，你为了从 `Move` 方法中仅使用一个数值就创建了大量的新类。将计算分解成易于遵循的实现是一个值得考虑的想法。毕竟，如果在一个方法中实现多个
    if-then 分支，可能会引起未来的维护问题。
- en: By re-implementing a delegate-based design, you still have maintainable code,
    but much less of it to look after. You can have a `TransformPoint` delegate and
    a new `Calculate` function that can be passed a `TransformPoint` delegate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新实现基于 delegate 的设计，你仍然拥有可维护的代码，但需要照看的部分要少得多。你可以有一个 `TransformPoint` delegate
    和一个可以传递 `TransformPoint` delegate 的新 `Calculate` 函数。
- en: 'You can invoke a delegate by appending brackets around its name and passing
    in any arguments. This is similar to how you would call a standard class-level
    function or method. You will cover this invocation in more detail later; for now,
    consider the following snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其名称周围添加括号并传递任何参数来调用 delegate。这与调用标准类级别的函数或方法的方式相似。你将在稍后详细介绍这种调用；现在，考虑以下代码片段：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You still need the actual target `Rotate` and `Zoom` methods, but you do not
    have the overhead of creating unnecessary classes to do this. You can add the
    following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要实际的 `Rotate` 和 `Zoom` 方法，但不需要创建不必要的类来执行此操作。你可以添加以下代码：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, calling the method delegates is as simple as the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用名为 delegate 的方法就像以下这样简单：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how using delegates in this way helps eliminate a lot of unnecessary
    code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 delegate 的这种方式如何帮助消除大量不必要的代码。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/AcwZA](https://packt.link/AcwZA).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/AcwZA](https://packt.link/AcwZA)找到用于此示例的代码。
- en: In addition to invoking a single placeholder method, a delegate also contains
    extra plumbing that allows it to be used in a **multicast** manner, that is, a
    way to chain multiple target methods together, each being invoked one after the
    other. This is often referred to as an invocation list or delegate chain and is
    initiated by code that acts as a publication source.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用单个占位符方法外，委托还包含额外的管道，允许它以**多播**方式使用，即一种将多个目标方法链接在一起的方式，每个方法依次被调用。这通常被称为调用列表或委托链，由充当发布源代码启动。
- en: 'A simple example of how this multicast concept applies can be seen in UIs.
    Imagine you have an application that shows the map of a country. As the user moves
    their mouse over the map, you may want to perform various actions, such as the
    following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将这种多播概念应用于UI的一个简单例子可以在UI中看到。想象一下，你有一个显示一个国家地图的应用程序。当用户将鼠标移到地图上时，你可能想执行以下各种操作：
- en: Changing the mouse pointer to a different shape while over a building.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当鼠标悬停在建筑物上时，将鼠标指针更改为不同的形状。
- en: Showing a tooltip that calculates the real-world longitude and latitude coordinates.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一个计算真实世界经纬度坐标的工具提示。
- en: Showing a message in a status bar that calculates the population of the area
    where the mouse is hovering.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态栏中显示计算鼠标悬停区域人口的消息。
- en: To achieve this, you would need some way to detect when the user moves the mouse
    over the screen. This is often referred to as the publisher. In this example,
    its sole purpose is to detect mouse movements and publish them to anyone who is
    listening.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，你需要一种方法来检测用户何时将鼠标移到屏幕上。这通常被称为发布者。在这个例子中，它的唯一目的是检测鼠标移动并将它们发布给任何正在监听的人。
- en: To perform the three required UI actions, you would create a class that has
    a list of objects to notify when the mouse position changes, allowing each object
    to perform whatever activity it needs, in isolation from the others. Each of these
    objects is referred to as a subscriber.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行所需的三个UI操作，你需要创建一个类，该类具有一个对象列表，当鼠标位置改变时通知这些对象，允许每个对象独立于其他对象执行所需的任何活动。这些对象中的每一个都被称为订阅者。
- en: 'When your publisher detects that the mouse has moved, you follow this pseudo
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的发布者检测到鼠标已移动时，你将遵循以下伪代码：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This assumes that `subscriptionList` is a list of objects, perhaps based on
    an interface with the `OnMouseMoved` method. It is up to you to add code that
    enables interested parties to subscribe to and unsubscribe from the `OnMouseMoved`
    notifications. It would be an unfortunate design if code that has previously subscribed
    has no way to unsubscribe and gets called repeatedly when there is no longer any
    need for it to be called.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设`subscriptionList`是一个对象列表，可能基于具有`OnMouseMoved`方法的接口。添加代码以使感兴趣方能够订阅和取消订阅`OnMouseMoved`通知取决于你。如果之前已订阅的代码没有取消订阅的方式，并且在不再需要调用时反复被调用，这将是一个不幸的设计。
- en: In the preceding code, there is a fair amount of coupling between the publisher
    and subscribers, and you are back to using interfaces for a type-safe implementation.
    What if you then needed to listen for keypresses, both key down and key up? It
    would soon get quite frustrating having to repeatedly copy such similar code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发布者和订阅者之间存在相当多的耦合，你将回到使用接口进行类型安全实现。如果你还需要监听按键，包括按键按下和按键释放，很快就会感到非常沮丧，需要反复复制如此相似的代码。
- en: Fortunately, the delegate type contains all this as inbuilt behavior. You can
    use single or multiple target methods interchangeably; all you need to do is invoke
    a delegate and the delegate will handle the rest for you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，委托类型包含所有这些内置行为。你可以单目标或多目标方法互换使用；你所需要做的就是调用一个委托，委托将为你处理其余部分。
- en: You will take an in-depth look at multicast delegates shortly, but first, you
    will explore the single-target method scenario.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将很快深入了解多播委托，但首先，你将探索单目标方法场景。
- en: Defining a Custom Delegate
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义委托
- en: Delegates are defined in a way that is similar to that of a standard method.
    The compiler does not care about the code in the body of a target method, only
    that it can be invoked safely at some point in time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 委托的定义方式与标准方法类似。编译器不关心目标方法体中的代码，只关心它可以在某个时间点安全地被调用。
- en: 'The `delegate` keyword is used to define a delegate, using the following format:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下格式定义 `delegate` 关键字：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following list describes each component of this syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了此语法的每个组成部分：
- en: 'Scope: An access modifier, such as `public`, `private`, or `protected`, to
    define the scope of the delegate. If you do not include a modifier, the compiler
    will default to marking it as private, but it is always better to be explicit
    in showing the intent of your code.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：一个访问修饰符，例如 `public`、`private` 或 `protected`，用于定义委托的作用域。如果你不包括修饰符，编译器将默认将其标记为
    `private`，但总是最好明确地显示你代码的意图。
- en: The `delegate` keyword.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delegate` 关键字。'
- en: 'Return type: If there is no return type, `void` is used.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型：如果没有返回类型，则使用 `void`。
- en: 'Delegate name: This can be anything that you like, but the name must be unique
    within the namespace. Many naming conventions (including Microsoft''s) suggest
    adding `Handler` or `EventHandler` to your delegate''s name.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托名称：这可以是任何你喜欢的名称，但名称必须在命名空间内是唯一的。许多命名约定（包括微软的）建议将 `Handler` 或 `EventHandler`
    添加到你的委托名称中。
- en: Arguments, if required.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，则提供参数。
- en: Note
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Delegates can be nested within a class or namespace; they can also be defined
    within the global namespace, although this practice is discouraged. When defining
    classes in C#, it is common practice to define them within a parent namespace,
    typically based on a hierarchical convention that starts with the company name,
    followed by the product name, and finally the feature. This helps to provide a
    more unique identity to a type.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 委托可以嵌套在类或命名空间内；它们也可以在全局命名空间中定义，尽管这种做法是不被推荐的。在 C# 中定义类时，常见的做法是在父命名空间中定义它们，通常基于以公司名称开始，然后是产品名称，最后是功能的分层约定。这有助于为类型提供更独特的标识。
- en: By defining a delegate without a namespace, there is a high chance that it will
    clash with another delegate with the same name if it is also defined in a library
    without the protection of a namespace. This can cause the compiler to become confused
    as to which delegate you are referring to.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在没有任何命名空间的情况下定义委托，如果它也在没有命名空间保护的库中定义了具有相同名称的另一个委托，那么它很可能与另一个委托发生冲突。这可能导致编译器混淆，不知道你指的是哪个委托。
- en: In earlier versions of .NET, it was common practice to define custom delegates.
    Such code has since been replaced with various inbuilt .NET delegates, which you
    will look at shortly. For now, you will briefly cover the basics of defining a
    custom delegate. It is worthwhile know about this if you maintain any legacy C#
    code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 的早期版本中，定义自定义委托是一种常见的做法。此类代码后来被各种内置的 .NET 委托所取代，你将在稍后查看。现在，你将简要介绍定义自定义委托的基础知识。如果你维护任何遗留的
    C# 代码，了解这一点是很有价值的。
- en: In the next exercise, you will create a custom delegate, one that is passed
    a `DateTime` parameter and returns a Boolean to indicate validity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将创建一个自定义委托，它接受一个 `DateTime` 参数并返回一个布尔值以指示有效性。
- en: 'Exercise 3.01: Defining and Invoking Custom Delegates'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.01：定义和调用自定义委托
- en: Say you have an application that allows users to order products. While filling
    in the order details, the customer can specify an order date and a delivery date,
    both of which must be validated before accepting the order. You need a flexible
    way to validate these dates. For some customers, you may allow weekend delivery
    dates, while for others, it must be at least seven days away. You may also allow
    an order to be back-dated for certain customers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个允许用户订购产品的应用程序。在填写订单详情时，客户可以指定订单日期和交货日期，这两个日期在接受订单之前都必须经过验证。你需要一种灵活的方式来验证这些日期。对于某些客户，你可能允许周末的交货日期，而对于其他客户，交货日期至少必须提前七天。你还可以允许某些客户的订单日期倒退。
- en: You know that delegates offer a way to vary an implementation at runtime, so
    that is the best way to proceed. You do not want multiple interfaces, or worse,
    a complex jumble of `if-then` statements, to achieve this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道委托提供了一种在运行时改变实现的方式，因此这是最佳的做法。你不想使用多个接口，或者更糟糕的是，一个复杂的 `if-then` 语句的混乱，来实现这一点。
- en: 'Depending on the customer''s profile, you can create a class named `Order`,
    which can be passed different date validation rules. These rules can be validated
    by a `Validate` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据客户的配置文件，你可以创建一个名为 `Order` 的类，该类可以传递不同的日期验证规则。这些规则可以通过一个 `Validate` 方法进行验证：
- en: 'Perform the following steps to do so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: Create a new folder called `Chapter03`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter03` 的新文件夹。
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise01`,
    using the CLI `dotnet` command, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Chapter03`文件夹，并使用CLI `dotnet`命令创建一个新的控制台应用程序，名为`Exercise01`，如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will see the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open `Chapter03\Exercise01.csproj` and replace the contents with these settings:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter03\Exercise01.csproj`并将内容替换为以下设置：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open `Exercise01\Program.cs` and clear the contents.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise01\Program.cs`并清除内容。
- en: The preference for using namespaces to prevent a clash with objects from other
    libraries was mentioned earlier, so to keep things isolated, use `Chapter03.Exercise01`
    as the namespace.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命名空间来防止与其他库中的对象冲突的偏好已经在前面提到过，因此为了保持独立，使用`Chapter03.Exercise01`作为命名空间。
- en: 'To implement your date validation rules, you will define a delegate that takes
    a single `DateTime` argument and returns a Boolean value. You will name it `DateValidationHandler`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现你的日期验证规则，你将定义一个接受单个`DateTime`参数并返回布尔值的代理。你将把它命名为`DateValidationHandler`：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, you will create a class named `Order`, which contains details of the
    order and can be passed to two date validation delegates:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个名为`Order`的类，它包含订单的详细信息，并且可以被传递给两个日期验证代理：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how you have declared two read-only, class-level instances of `DateValidationHandler`,
    one to validate the order date and a second to validate the delivery date. This
    design assumes that the date validation rules are not going to be altered for
    this `Order` instance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你如何声明了两个只读的类级别实例`DateValidationHandler`，一个用于验证订单日期，另一个用于验证交付日期。这种设计假设对于这个`Order`实例，日期验证规则不会改变。
- en: 'Now for the constructor, you pass the two delegates:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是构造函数，你传递这两个代理：
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this design, a different class is typically responsible for deciding which
    delegates to use, based on the selected customer's profile.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，通常有一个不同的类负责根据所选客户的配置文件决定使用哪个代理。
- en: 'You need to add the two date properties that are to be validated. These dates
    may be set using a UI that listens to keypresses and applies user edits directly
    to this class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要添加两个待验证的日期属性。这些日期可以使用一个监听按键并直接将用户编辑应用到这个类的UI来设置：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now add an `IsValid` method that passes `OrderDate` to the `orderDateValidator`
    delegate and `DeliveryDate` to the `deliveryDateValidator` delegate:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个`IsValid`方法，将`OrderDate`传递给`orderDateValidator`代理，将`DeliveryDate`传递给`deliveryDateValidator`代理：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If both are valid, then this call will return `true`. The key here is that
    `Order` doesn''t need to know about the precise implementation of an individual
    customer''s date validation rules, so you can easily reuse `Order` elsewhere in
    a program. To invoke a delegate, you simply wrap any arguments in brackets, in
    this case passing the correct date property to each delegate instance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两者都有效，那么这个调用将返回`true`。关键在于`Order`不需要知道单个客户的日期验证规则的确切实现，因此你可以在程序的其他地方轻松重用`Order`。要调用代理，你只需将任何参数用括号括起来，在这种情况下，将正确的日期属性传递给每个代理实例：
- en: 'To create a console app to test this, add a `static` class called `Program`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个控制台应用程序来测试这个，添加一个名为`Program`的`static`类：
- en: '[PRE21]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You want to create two functions that validate whether the date passed to them
    is valid. These functions will form the basis of your delegate target methods:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想要创建两个函数来验证传递给它们的日期是否有效。这些函数将构成你的代理目标方法的基础：
- en: '[PRE22]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how both have the exact signature that the `DateValidationHandler` delegate
    is expecting. Neither is aware of the nature of the date that they are validating,
    as that is not their concern. They are both marked `static` as they do not interact
    with any variables or properties anywhere in this class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它们都有`DateValidationHandler`代理期望的确切签名。它们两个都不知道它们正在验证的日期的性质，因为这不是它们的关注点。由于它们在这个类的任何地方都不与任何变量或属性交互，所以它们都被标记为`static`。
- en: 'Now for the `Main` entry point. Here, you create two `DateValidationHandler`
    delegate instances, passing `IsPastDate` to one and `IsWeekendDate` to the second.
    These are the target methods that will get called when each of the delegates is
    invoked:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是`Main`入口点。在这里，你创建了两个`DateValidationHandler`代理实例，将`IsPastDate`传递给一个，将`IsWeekendDate`传递给另一个。这些是当每个代理被调用时将被调用的目标方法：
- en: '[PRE23]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now you can create an `Order` instance, passing in the delegates and setting
    the order and delivery dates:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以创建一个`Order`实例，传递代理并设置订单和交付日期：
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are various ways to create delegates. Here, you have assigned them to
    variables first to make the code clearer (you will cover different styles later).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建委托有多种方式。在这里，您首先将它们分配给变量，以使代码更清晰（您将在后面了解不同的风格）。
- en: 'Now it''s just a case of displaying the dates in the console and calling `IsValid`,
    which, in turn, will invoke each of your delegate methods once. Notice that a
    custom date format is used to make the dates more readable:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只需在控制台中显示日期并调用`IsValid`即可，这将依次调用您的每个委托方法。请注意，使用了自定义日期格式，以便使日期更易于阅读：
- en: '[PRE25]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the console app produces output like this:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序的输出如下：
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This order is **not** valid as the delivery date is a Thursday, not a weekend
    as you require:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此顺序**不**有效，因为交付日期是星期四，而不是您所需的周末：
- en: You have learned how to define a custom delegate and have created two instances
    that make use of small helper functions to validate dates. This gives you an idea
    of how flexible delegates can be.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何定义自定义委托，并创建了两个实例，这些实例使用小的辅助函数来验证日期。这使您了解委托是多么灵活。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/cmL0s](https://packt.link/cmL0s).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/cmL0s](https://packt.link/cmL0s)找到用于此练习的代码。
- en: The Inbuilt Action and Func Delegates
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置的Action和Func委托
- en: 'When you define a delegate, you are describing its signature, that is, the
    return type and a list of input parameters. With that said, consider these two
    delegates:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个委托时，您正在描述其签名，即返回类型和输入参数列表。话虽如此，考虑这两个委托：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'They both have the same signature but vary by name alone, which is why you
    can declare an instance of each and have them **both** point at the **same** target
    method when invoked:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它们具有相同的签名，但仅名称不同，这就是为什么您可以在调用时声明每个实例，并使它们**都**指向**相同**的目标方法：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the console app produces the same results in both calls:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序在两次调用中都产生相同的结果：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/r6B8n](https://packt.link/r6B8n).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/r6B8n](https://packt.link/r6B8n)找到用于此示例的代码。
- en: It would be great if you could dispense with defining both `DoStuff` and `DoMoreStuff`
    delegates and use a more generalized delegate with precisely the same signature.
    After all, it does not matter in the preceding snippet if you create a `DoStuff`
    or `DoMoreStuff` delegate, since both make a call to the same target method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能省去定义`DoStuff`和`DoMoreStuff`委托，并使用具有完全相同签名的更通用委托，那就太好了。毕竟，在先前的代码片段中，您创建`DoStuff`或`DoMoreStuff`委托都没有关系，因为它们都调用相同的目标方法。
- en: .NET does, in fact, provide various inbuilt delegates that you can make use
    of directly, saving you the effort of defining such delegates yourself. These
    are the `Action` and `Func` delegates.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: .NET实际上提供了各种内置委托，您可以直接使用它们，从而节省了您自己定义这些委托的努力。这些是`Action`和`Func`委托。
- en: There are many possible combinations of `Action` and `Func` delegates, each
    allowing an increasing number of parameters. You can specify anywhere from zero
    to 16 different parameter types. With so many combinations available, it is extremely
    unlikely that you will ever need to define your own delegate type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action`和`Func`委托的组合有很多种可能，每种组合都允许使用更多参数。您可以从0到16种不同的参数类型中进行选择。由于组合众多，您几乎不需要定义自己的委托类型。'
- en: It is worth noting that `Action` and `Func` delegates were added in a later
    version of .NET and, as such, the use of custom delegates tends to be found in
    older legacy code. There is no need to create new delegates yourself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Action`和`Func`委托是在.NET的后续版本中添加的，因此自定义委托的使用通常在较老的遗留代码中找到。您不需要自己创建新的委托。
- en: 'In the following snippet, `MyMethod` is invoked using the three-argument `Func`
    variation; you will cover the odd-looking `<string, int, string>` syntax shortly:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`MyMethod`使用三个参数的`Func`变体调用；您很快就会了解这个看起来很奇怪的`<string, int, string>`语法：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This produces the same return value as the two earlier invocations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生的返回值与前面的两次调用相同：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Before you continue exploring `Action` and `Func` delegates, it is useful to
    explore the `Action<string, int, string>` syntax a bit further. This syntax allows
    type parameters to be used to define classes and methods. These are known as generics
    and act as placeholders for a particular type. In *Chapter 4*, *Data Structures
    and LINQ*, you will cover generics in much greater detail, but it is worth summarizing
    their usage here with the `Action` and `Func` delegates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续探索 `Action` 和 `Func` 委托之前，探索一下 `Action<string, int, string>` 语法可能会有所帮助。这种语法允许使用类型参数来定义类和方法。这些被称为泛型，并作为特定类型的占位符。在
    *第4章*，*数据结构和LINQ* 中，你会更详细地了解泛型，但在这里用 `Action` 和 `Func` 委托总结它们的用法是值得的。
- en: 'The non-generic version of the `Action` delegate is predefined in .NET as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action` 委托的非泛型版本在 .NET 中如下预定义：'
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you know from your earlier look at delegates, this is a delegate that does
    not take any arguments and does not have a return type; it is the simplest type
    of delegate available.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，从你对委托的早期了解来看，这是一个不接受任何参数且没有返回类型的委托；这是可用的最简单类型的委托。
- en: 'Contrast that with one of the generic `Action` delegates predefined in .NET:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与.NET中预定义的泛型 `Action` 委托之一进行对比：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can see this includes a `<T>` and `T` parameter section, which means it
    accepts a `Action` that is constrained to a string, which takes a single string
    argument and returns no value, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这包括一个 `<T>` 和 `T` 参数部分，这意味着它接受一个受限于字符串的 `Action`，它接受单个字符串参数并返回无值，如下所示：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'How about an `int` constrained version? This also has no return type and takes
    a single `int` argument:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个受限于 `int` 的版本呢？这也没有返回类型，并且接受单个 `int` 参数：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Can you see the pattern here? In essence, the type that you specify can be used
    to declare a type at compile time. What if you wanted two arguments, or three,
    or four…or 16? Simple. There are `Action` and `Func` generic types that can take
    up to **16** different argument types. You are very unlikely to be writing code
    that needs more than 16 parameters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在这里看到模式吗？本质上，你指定的类型可以在编译时用来声明一个类型。如果你想用两个、三个、四个……或者16个参数呢？很简单。有 `Action` 和
    `Func` 泛型类型可以接受多达 **16** 种不同的参数类型。你不太可能编写需要超过16个参数的代码。
- en: 'This two-argument `Action` takes `int` and `string` as parameters:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接受两个参数的 `Action` 以 `int` 和 `string` 作为参数：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can spin that around. Here is another two-argument `Action`, but this takes
    a `string` parameter and then an `int` parameter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把它转过来。这里有一个接受两个参数的 `Action`，但这个 `Action` 接受一个 `string` 参数和一个 `int` 参数：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These cover most argument combinations, so you can see that it is very rare
    to create your own delegate types.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些涵盖了大多数参数组合，所以你可以看到，创建自己的委托类型是非常罕见的。
- en: 'The same rules apply to delegates that return a value; this is where the `Func`
    types are used. The generic `Func` type starts with a single value type parameter:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的规则适用于返回值的委托；这就是 `Func` 类型被使用的地方。泛型 `Func` 类型以单个值类型参数开始：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the following example, `funcE` is a delegate that returns a Boolean value
    and takes no arguments:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`funcE` 是一个返回布尔值且不接受任何参数的委托：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Can you guess which is the return type from this rather long `Func` declaration?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出这个相对较长的 `Func` 声明返回的类型是什么吗？
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This gives a delegate that returns a `string` . In other words, the last argument
    type in a `Func` defines the return type. Notice that `funcF` takes four arguments:
    `bool`, `int`, `int`, and `DateTime`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个返回 `string` 的委托。换句话说，`Func` 中的最后一个参数类型定义了返回类型。注意 `funcF` 接受四个参数：`bool`、`int`、`int`
    和 `DateTime`。
- en: In summary, generics are a great way to define types. They save a lot of duplicate
    code by allowing type parameters to act as placeholders.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，泛型是定义类型的好方法。通过允许类型参数作为占位符，它们可以节省大量的重复代码。
- en: Assigning Delegates
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配委托
- en: You covered creating custom delegates and briefly how to assign and invoke a
    delegate in *Exercise 3.01*. You then looked at using the preferred `Action` and
    `Func` equivalents, but what other options do you have for assigning the method
    (or methods) that form a delegate? Are there other ways to invoke a delegate?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 *练习3.01* 中介绍了创建自定义委托和简要介绍了如何分配和调用委托。然后你查看使用首选的 `Action` 和 `Func` 等效项，但你有其他方法来分配构成委托的方法（或方法）吗？还有其他调用委托的方法吗？
- en: Delegates can be assigned to a variable in much the same way that you might
    assign a class instance. You can also pass new instances or static instances around
    without having to use variables to do so. Once assigned, you can invoke the delegate
    or pass the reference to other classes so they can invoke it, and this is often
    done within the Framework API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 委托可以被分配给一个变量，其方式与分配一个类实例类似。你还可以传递新的实例或静态实例，而无需使用变量。一旦分配，你可以调用委托或将引用传递给其他类，以便它们可以调用它，这通常在框架API中完成。
- en: 'You will now look at a `Func` delegate, which takes a single `DateTime` argument
    and returns a `bool` value to indicate validity. You will use a `static` class
    containing two helper methods, which form the actual target:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将查看一个`Func`委托，它接受一个`DateTime`参数并返回一个`bool`值以指示有效性。你将使用包含两个辅助方法的`static`类，这些方法形成实际的目标：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/mwmxh](https://packt.link/mwmxh).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/mwmxh](https://packt.link/mwmxh)找到此示例使用的代码。
- en: Note that the `DateValidators` class is marked as `static`. You may have heard
    the phrase **statics are inefficient**. In other words, creating an application
    with many static classes is a weak practice. Static classes are instantiated the
    first time they are accessed by running code and remain in memory until the application
    is closed. This makes it difficult to control their lifetime. Defining small utility
    classes as static is less of an issue, provided they do indeed remain stateless.
    Stateless means they do not set any local variables. Static classes that set local
    states are very difficult to unit test; you can never be sure that the variable
    set is from one test or another test.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`DateValidators`类被标记为`static`。你可能听说过“静态是不高效的”这句话。换句话说，创建一个包含许多静态类的应用程序是一种弱实践。静态类在第一次通过运行代码访问时被实例化，并保持内存中直到应用程序关闭。这使得控制它们的生存期变得困难。如果确实是无状态的，将小型实用类定义为静态就不再是问题。无状态意味着它们不会设置任何局部变量。设置局部状态的静态类非常难以进行单元测试；你永远无法确定设置的变量来自一个测试还是另一个测试。
- en: In the preceding snippet, `IsFuture` returns `true` if the `Date` property of
    the `DateTime` argument is later than the current date. You are using the static
    `DateTime.Today` property to retrieve the current system date. `IsWeekend` is
    defined using an expression-bodied syntax and will return `true` if the `DateTime`
    argument's day of the week falls on a Saturday or Sunday.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`IsFuture`如果`DateTime`参数的`Date`属性晚于当前日期，则返回`true`。你正在使用静态的`DateTime.Today`属性来检索当前系统日期。"IsWeekend"使用表达式主体语法定义，如果`DateTime`参数的星期几是星期六或星期日，则返回`true`。
- en: 'You can assign delegates the same way that you would assign regular variables
    (remember you do `futureValidator` and `weekendValidator`. Each constructor is
    passed the actual target method, the `IsFuture` or `IsWeekend` instance, respectively:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像分配常规变量一样分配委托（记住你分配了`futureValidator`和`weekendValidator`。每个构造函数都传递实际的目标方法，分别是`IsFuture`或`IsWeekend`实例）：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that it is not valid to use the `var` keyword to assign a delegate without
    wrapping in the `Func` prefix:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用`var`关键字在不包含`Func`前缀的情况下分配委托是不合法的：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This results in the following compiler error:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下编译器错误：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Taking this knowledge of delegates, proceed to how you can invoke a delegate.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了委托的知识之后，继续了解如何调用委托。
- en: Invoking a Delegate
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用委托
- en: 'There are several ways to invoke a delegate. For example, consider the following definition:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个委托有多种方式。例如，考虑以下定义：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To invoke `futureValidator`, you must pass in a `DateTime` value, and it will
    return a `bool` value using any of these styles:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`futureValidator`，你必须传递一个`DateTime`值，它将使用以下任何一种样式返回一个`bool`值：
- en: 'Invoke with the null-coalescing operator:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空合并运算符调用：
- en: '[PRE46]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is the preferred and safest approach; you should always check for a null
    before calling `Invoke`. If there is a chance that a delegate does not point to
    an object in memory, then you must perform a null reference check before accessing
    methods and properties. A failure to do so will result in `NullReferenceException`
    being thrown. This is the runtime's way of warning you that the object is not
    pointing at anything.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是首选且最安全的方法；在调用`Invoke`之前，你应该始终检查是否为null。如果有可能委托不指向内存中的对象，那么在访问方法和属性之前必须执行空引用检查。不这样做会导致抛出`NullReferenceException`。这是运行时警告你对象没有指向任何东西的方式。
- en: By using the null-coalescing operator, the compiler will add the null check
    for you. In the code, you explicitly declared `futureValidator`, so here it cannot
    be null. But what if you had been passed `futureValidator` from another method?
    How can you be sure that the caller had correctly assigned a reference?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用空合并运算符，编译器会为你添加空值检查。在代码中，你明确声明了`futureValidator`，所以在这里它不能为空。但如果你是从另一个方法传递`futureValidator`，你如何确保调用者正确地分配了引用？
- en: Delegates have additional rules that make it possible for them to throw `NullReferenceException`
    when invoked. In the preceding example, `futureValidator` has a single target,
    but as you will see later, the `NullReferenceException`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 委托有额外的规则，使得它们在调用时可以抛出`NullReferenceException`。在前面的例子中，`futureValidator`有一个单一的目标，但正如你将看到的，`NullReferenceException`。
- en: Direct Invoke
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接调用
- en: 'This is the same as the previous method, but without the safety of the null
    check. This is not recommended for the same reason; that is, the delegate can
    throw a `NullReferenceException`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面的方法相同，但没有空值检查的安全性。同样，这也不推荐，因为委托可能会抛出`NullReferenceException`：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Without the `Invoke` prefix
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有使用`Invoke`前缀
- en: 'This looks more succinct as you simply call the delegate without the `Invoke`
    prefix. Again, this is not recommended due to a possible null reference:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来更简洁，因为你只需调用委托而不需要`Invoke`前缀。然而，这并不推荐，因为可能存在空引用：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Try assigning and safely invoking a delegate through an exercise by bringing
    them together.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将它们放在一起进行练习，尝试安全地分配和调用一个委托。
- en: 'Exercise 3.02: Assigning and Invoking Delegates'
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.02：分配和调用委托
- en: In this exercise, you are going to write a console app showing how a `Func`
    delegate can be used to extract numeric values. You will create a `Car` class
    that has `Distance` and `JourneyTime` properties. You will prompt the user to
    enter the distance traveled yesterday and today, passing this information to a
    `Comparison` class that is told how to extract values and calculate their differences.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个控制台应用程序，展示如何使用`Func`委托提取数值。你将创建一个具有`Distance`和`JourneyTime`属性的`Car`类。你将提示用户输入昨天和今天的行程距离，并将这些信息传递给一个`Comparison`类，该类被告知如何提取值并计算它们的差异。
- en: 'Perform the following steps to do so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise02`,
    using the CLI `dotnet` command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Chapter03`文件夹，并使用CLI `dotnet`命令创建一个新的控制台应用程序，命名为`Exercise02`：
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open `Chapter03\Exercise02.csproj` and replace the entire file with these settings:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter03\Exercise02.csproj`并将整个文件替换为以下设置：
- en: '[PRE50]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Open `Exercise02\Program.cs` and clear the contents.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise02\Program.cs`并清除其内容。
- en: Start by adding a record called `Car`. Include the `System.Globalization` namespace
    for string parsing. Use the `Chapter03.Exercise02` namespace to keep code separate
    from the other exercises.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一个名为`Car`的记录。包含`System.Globalization`命名空间以进行字符串解析。使用`Chapter03.Exercise02`命名空间以保持代码与其他练习的分离。
- en: 'Add two properties, `Distance` and `JourneyTime`. They will have `init`-only
    properties, so you will use the `init` keyword:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个属性，`Distance`和`JourneyTime`。它们将只有`init`属性，所以你将使用`init`关键字：
- en: '[PRE51]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, create a class named `Comparison` that is passed a `Func` delegate to
    work with. The `Comparison` class will use the delegate to extract either the
    `Distance` or `JourneyTime` properties and calculate the difference for two `Car`
    instances. By using the flexibility of delegates, `Comparison` will not know whether
    it is extracting `Distance` or `JourneyTime`, just that it is using a double to
    calculate the differences. This shows that you can reuse this class should you
    need to calculate other `Car` properties in the future:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`Comparison`的类，该类传递一个`Func`委托以进行操作。`Comparison`类将使用委托提取`Distance`或`JourneyTime`属性，并计算两个`Car`实例之间的差异。通过使用委托的灵活性，`Comparison`将不知道它是在提取`Distance`还是`JourneyTime`，只知道它正在使用一个双精度值来计算差异。这表明，如果你需要将来计算其他`Car`属性，你可以重用这个类：
- en: '[PRE52]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add three properties that form the results of the calculation, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个属性，如下所示：
- en: '[PRE53]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now for the calculation, pass two `Car` instances, one for the car journey
    yesterday, `yesterdayCar`, and one for today, `todayCar`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进行计算，传递两个`Car`实例，一个用于昨天的汽车行程`yesterdayCar`，另一个用于今天的行程`todayCar`：
- en: '[PRE54]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To calculate a value for `Yesterday`, invoke the `valueSelector` `Func` delegate,
    passing in the `yesterdayCar` instance. Again, remember that the `Comparison`
    class is unaware whether it is extracting `Distance` or `JourneyTime`; it just
    needs to know that when the `delegate` is invoked with a `Car` argument, it will
    get a double number back:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算 `Yesterday` 的值，调用 `valueSelector` `Func` 委托，传入 `yesterdayCar` 实例。再次记住，`Comparison`
    类不知道它是在提取 `Distance` 还是 `JourneyTime`；它只需要知道当 `delegate` 被一个 `Car` 参数调用时，它会返回一个双精度浮点数：
- en: '[PRE55]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Do the same to extract the value for `Today` by using the same `Func` delegate,
    but passing in the `todayCar` instance instead:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的 `Func` 委托，通过传递 `todayCar` 实例来提取 `Today` 的值，但使用相同的方式：
- en: '[PRE56]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now it is just a case of calculating the difference between the two extracted
    numbers; you don''t need to use the `Func` delegate to do that:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只是计算两个提取的数字之间的差异；你不需要使用 `Func` 委托来做这件事：
- en: '[PRE57]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So, you have a class that knows how to invoke a `Func` delegate to extract
    a certain `Car` property when it is told how to. Now, you need a class to wrap
    up the `Comparison` instances. For this, add a class called `JourneyComparer`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，你有一个知道如何调用 `Func` 委托来提取特定 `Car` 属性的类。现在，你需要一个类来封装 `Comparison` 实例。为此，添加一个名为
    `JourneyComparer` 的类：
- en: '[PRE58]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the car journey, you need to calculate the difference between the `Yesterday`
    and `Today` `Distance` properties. To do so, create a `Comparison` class that
    is told how to extract a value from a `Car` instance. You may as well use the
    same name for this `Comparison` class as you will extract a car''s `Distance`.
    Remember that the `Comparison` constructor needs a `Func` delegate that is passed
    a `Car` instance and returns a double value. You will add `GetCarDistance()` shortly;
    this will eventually be invoked by passing `Car` instances for yesterday''s and
    today''s journeys:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于汽车行程，你需要计算 `Yesterday` 和 `Today` 的 `Distance` 属性之间的差异。为此，创建一个 `Comparison`
    类，告诉它如何从一个 `Car` 实例中提取值。你可以使用与提取汽车 `Distance` 相同的名称来命名这个 `Comparison` 类。记住，`Comparison`
    构造函数需要一个 `Func` 委托，它接收一个 `Car` 实例并返回一个双精度值。你很快就会添加 `GetCarDistance()`；这最终将通过传递昨天和今天的行程
    `Car` 实例来调用：
- en: '[PRE59]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Repeat the process as described in the preceding steps for a `JourneyTime`
    `Comparison`; this one should be told to use `GetCarJourneyTime()` as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照前面步骤描述的过程，为 `JourneyTime` `Comparison` 重复此过程；这个应该被告知使用 `GetCarJourneyTime()`，如下所示：
- en: '[PRE60]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, add another `Comparison` property called `AverageSpeed` as follows.
    You will see shortly that `GetCarAverageSpeed()` is yet another function:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加另一个名为 `AverageSpeed` 的 `Comparison` 属性，如下所示。你很快就会看到 `GetCarAverageSpeed()`
    是另一个函数：
- en: '[PRE61]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now for the `GetCarDistance` and `GetCarJourneyTime` local functions, they
    are passed a `Car` instance and return either `Distance` or `JourneyTime` accordingly:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `GetCarDistance` 和 `GetCarJourneyTime` 这两个局部函数，它们接收一个 `Car` 实例，并相应地返回 `Distance`
    或 `JourneyTime`：
- en: '[PRE62]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`GetCarAverageSpeed`, as the name suggests, returns the average speed. Here,
    you have shown that the `Func` delegate just needs a compatible function; it doesn''t
    matter what it returns as long as it is `double`. The `Comparison` class does
    not need to know that it is returning a calculated value such as this when it
    invokes the `Func` delegate:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如其名所示，`GetCarAverageSpeed` 返回平均速度。在这里，你展示了 `Func` 委托只需要一个兼容的函数；只要返回 `double`
    类型，它返回什么并不重要。`Comparison` 类不需要知道它在调用 `Func` 委托时返回的是这样的计算值：
- en: '[PRE63]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The three `Comparison` properties should be defined like this:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个 `Comparison` 属性应该这样定义：
- en: '[PRE64]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now for the main `Compare` method. This will be passed two `Car` instances,
    one for `yesterday` and one for `today`, and it simply calls `Compare` on the
    three `Comparison` items passing in the two `Car` instances:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是主 `Compare` 方法。这个方法将传入两个 `Car` 实例，一个用于 `yesterday`，一个用于 `today`，并且它只是简单地调用三个
    `Comparison` 项目上的 `Compare`，传入两个 `Car` 实例：
- en: '[PRE65]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You need a console app to enter the miles traveled per day, so add a class
    called `Program` with a static `Main` entry point:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一个控制台应用程序来输入每天行驶的英里数，因此添加一个名为 `Program` 的类，并包含一个静态的 `Main` 入口点：
- en: '[PRE66]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can randomly assign journey times to save some input, so add a new `Random`
    instance and the start of a `do-while` loop, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以随机分配行程时间以节省一些输入，因此添加一个新的 `Random` 实例和 `do-while` 循环的开始，如下所示：
- en: '[PRE67]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Read for yesterday''s distance, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式读取昨天的距离：
- en: '[PRE68]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can use the distance to create yesterday''s `Car` with a random `JourneyTime`,
    as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用距离来创建昨天的 `Car`，并随机分配 `JourneyTime`，如下所示：
- en: '[PRE69]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Do the same for today''s distance:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于今天的距离也做同样的处理：
- en: '[PRE70]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now that you have two `Car` instances populated with values for yesterday and
    today, you can create the `JourneyComparer` instance and call `Compare`. This
    will then call `Compare` on your three `Comparison` instances:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您有两个填充了昨天和今天值的`Car`实例，您可以创建`JourneyComparer`实例并调用`Compare`。这将调用您的三个`Comparison`实例的`Compare`方法：
- en: '[PRE71]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, write the results to the console:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将结果写入控制台：
- en: '[PRE72]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Write out yesterday''s results:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出昨天的成果：
- en: '[PRE73]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Write out today''s results:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出今天的成果：
- en: '[PRE74]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, write the summary values using the `Difference` properties:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`Difference`属性写入摘要值：
- en: '[PRE75]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finish off the `do-while` loop, exiting if the user enters an empty string:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成以下`do-while`循环，如果用户输入空字符串则退出：
- en: '[PRE76]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Running the console and entering distances of `1000` and `900` produces the
    following results:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台并输入距离`1000`和`900`产生以下结果：
- en: '[PRE77]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The program will run in a loop until you enter a blank value. You will notice
    a different output as the `JourneyTime` is set using a random value returned by
    an instance of `Random` class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将在循环中运行，直到您输入空白值。您会注意到输出不同，因为`JourneyTime`是使用`Random`类实例返回的随机值设置的。
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/EJTtS](https://packt.link/EJTtS).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/EJTtS](https://packt.link/EJTtS)找到用于此练习的代码。
- en: In this exercise, you have seen how a `Func<Car, double>` delegate is used to
    create general-purpose code that can be easily reused without the need to create
    extra interfaces or classes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已经看到了如何使用`Func<Car, double>`委托来创建通用代码，这些代码可以轻松重用，而无需创建额外的接口或类。
- en: Now it is time to look at the second important aspect of deletes and their ability
    to chain multiple target methods together.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看删除的第二个重要方面以及它们将多个目标方法链接在一起的能力了。
- en: Multicast Delegates
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播委托
- en: So far, you have invoked delegates that have a single method assigned, typically
    in the form of a function call. Delegates offer the ability to combine a list
    of methods that are executed with a single invocation call, using the `+=` operator,
    any number of additional target methods can be added to the target list. Every
    time the delegate is invoked, each one of the target methods gets invoked too.
    But what if you decide you want to remove a target method? That is where the `-=`
    operator is used.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经调用了分配了单个方法的委托，通常是函数调用的形式。委托提供了使用`+=`运算符将一系列方法组合在一起执行的能力，可以添加任意数量的附加目标方法到目标列表中。每次调用委托时，每个目标方法都会被调用。但如果你决定要删除一个目标方法呢？这就是`-=`运算符的用武之地。
- en: 'In the following code snippet, you have an `Action<string>` delegate named
    `logger`. It starts with a single target method, `LogToConsole`. If you were to
    invoke this delegate, passing in a string, then the `LogToConsole` method will
    be called once:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，您有一个名为`logger`的`Action<string>`委托。它以单个目标方法`LogToConsole`开始。如果您调用此委托并传入一个字符串，则将调用`LogToConsole`方法一次：
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If you were to watch the call stack, you would observe these calls:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察调用栈，您会看到这些调用：
- en: '[PRE79]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To add a new target method, you use the `+=` operator. The following statement
    adds `LogToFile` to the `logger` delegate''s invocation list:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新的目标方法，您使用`+=`运算符。以下语句将`LogToFile`添加到`logger`委托的调用列表中：
- en: '[PRE80]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, every time you invoke `logger`, both `LogToConsole` and `LogToFile` will
    be called. Now invoke `logger` a second time:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次调用`logger`时，都会调用`LogToConsole`和`LogToFile`。现在再次调用`logger`：
- en: '[PRE81]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The call stack looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 调用栈看起来如下：
- en: '[PRE82]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Again, suppose you use `+=` to add a third target method called `LogToDataBase`
    as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设您使用`+=`添加一个名为`LogToDataBase`的第三个目标方法，如下所示：
- en: '[PRE83]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now invoke it once again:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次调用它：
- en: '[PRE84]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The call stack looks like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 调用栈看起来如下：
- en: '[PRE85]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'However, consider that you may no longer want to include `LogToFile` in the
    target method list. In such a case, simply use the `-=` operator to remove it,
    as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑您可能不再希望将`LogToFile`包含在目标方法列表中。在这种情况下，只需使用`-=`运算符将其删除，如下所示：
- en: '[PRE86]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can again invoke the delegate as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以再次按如下方式调用委托：
- en: '[PRE87]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And now, the call stack looks like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用栈如下所示：
- en: '[PRE88]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As can be seen, this code resulted in just `LogToConsole` and `LogToDataBase`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，此代码只导致了`LogToConsole`和`LogToDataBase`的调用。
- en: By using delegates in this way, you can decide which target methods get called
    based on certain criteria at runtime. This allows you to pass this configured
    delegate into other methods, to be invoked as and when needed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式使用委托，您可以在运行时根据某些标准来决定调用哪些目标方法。这允许您将配置好的委托传递给其他方法，以便在需要时调用。
- en: You have seen that `Console.WriteLine` can be used to write messages to the
    console window. To create a method that logs to a file (as `LogToFile` does in
    the preceding example), you need to use the `File` class from the `System.IO`
    namespace. `File` has many static methods that can be used to read and write files.
    You will not go into full details about `File` here, but it is worth mentioning
    the `File.AppendAllText` method, which can be used to create or replace a text
    file containing a string value, `File.Exists`, which is used to check for the
    existence of a file, and `File.Delete`, to delete a file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到 `Console.WriteLine` 可以用来将消息写入控制台窗口。要创建一个将日志记录到文件的方法（如前一个示例中的 `LogToFile`
    所做的那样），您需要使用 `System.IO` 命名空间中的 `File` 类。`File` 有许多静态方法可以用来读取和写入文件。这里不会详细介绍 `File`，但值得提到的是
    `File.AppendAllText` 方法，它可以用来创建或替换包含字符串值的文本文件，`File.Exists` 用于检查文件是否存在，以及 `File.Delete`
    用于删除文件。
- en: Now it is time to practice what you have learned through an exercise.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过练习来实践你所学到的知识了。
- en: 'Exercise 3.03: Invoking a Multicast Delegate'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.03：调用多播委托
- en: In this exercise, you will use a multicast delegate to create a cash machine
    that logs details when a user enters their PIN and asks to see their balance.
    For this, you will create a `CashMachine` class that invokes a configured **logging**
    delegate, which you can use as a controller class to decide whether messages are
    sent to the file or to the console.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用多播委托创建一个当用户输入他们的 PIN 并要求查看他们的余额时记录详细信息的自动柜员机。为此，您将创建一个 `CashMachine`
    类，该类调用配置好的 **记录** 委托，您可以使用它作为控制器类来决定消息是否发送到文件或控制台。
- en: You will use an `Action<string>` delegate as you do not need any values to return.
    Using `+=`, you can control which target methods get called when your delegate
    is invoked by `CashMachine`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用 `Action<string>` 委托，因为您不需要返回任何值。使用 `+=`，您可以在 `CashMachine` 调用您的委托时控制哪些目标方法被调用。
- en: 'Perform the following steps to do so:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise03`,
    using the CLI `dotnet` command:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Chapter03` 文件夹，并使用 CLI `dotnet` 命令创建一个新的控制台应用程序，名为 `Exercise03`：
- en: '[PRE89]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Open `Chapter03\Exercise03.csproj` and replace the entire file with these settings:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Chapter03\Exercise03.csproj` 并用以下设置替换整个文件：
- en: '[PRE90]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Open `Exercise03\Program.cs` and clear the contents.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Exercise03\Program.cs` 并清除其内容。
- en: Add a new class called `CashMachine`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `CashMachine` 的新类。
- en: 'Use the `Chapter03.Exercise03` namespace:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Chapter03.Exercise03` 命名空间：
- en: '[PRE91]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `CashMachine` constructor is passed the `Action<string>` delegate, which
    you can assign to a `readonly` class variable called `_logger`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`CashMachine` 构造函数传递了一个 `Action<string>` 委托，您可以将它分配给一个名为 `_logger` 的 `readonly`
    类变量。'
- en: 'Add a `Log` helper function that checks whether the `_logger` delegate is null
    before invoking:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `Log` 辅助函数，在调用 `_logger` 委托之前检查它是否为 null：
- en: '[PRE92]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'When the `VerifyPin` and `ShowBalance` methods are called, a message should
    be logged with some details. Create these methods as follows:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用 `VerifyPin` 和 `ShowBalance` 方法时，应该记录一些详细信息。创建这些方法如下：
- en: '[PRE93]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, add a console app that configures a `logger` delegate that you can pass
    into a `CashMachine` object. Note that this is a common form of usage: a class
    that is responsible for deciding how messages are logged by other classes. Use
    a constant, `OutputFile`, for the filename to be used for file logging, as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个控制台应用程序，配置一个 `logger` 委托，您可以将其传递给 `CashMachine` 对象。请注意，这是一种常见的使用形式：一个负责决定其他类如何记录消息的类。使用一个常量
    `OutputFile` 来指定用于文件记录的文件名，如下所示：
- en: '[PRE94]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Each time the program runs, it should start with a `File.Delete` to delete
    the output file:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次程序运行时，它应该以 `File.Delete` 开始，以删除输出文件：
- en: '[PRE95]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create a delegate instance, `logger`, that starts with a single target method,
    `LogToConsole`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个委托实例，`logger`，它以单个目标方法 `LogToConsole` 开始：
- en: '[PRE96]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Using the `+=` operator, add `LogToFile` as a second target method to also
    be called whenever the delegate is invoked by `CashMachine`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `+=` 操作符，将 `LogToFile` 作为第二个目标方法添加，以便在 `CashMachine` 调用委托时也会被调用：
- en: '[PRE97]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You will implement the two target logging methods shortly; for now, create
    a `cashMachine` instance and get ready to call its methods, as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将很快实现两个目标日志方法；现在，创建一个`cashMachine`实例并准备调用其方法，如下所示：
- en: '[PRE98]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Prompt for a `pin` and pass it to the `VerifyPin` method:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示输入`pin`并将其传递给`VerifyPin`方法：
- en: '[PRE99]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In case you enter a blank value, then it is checked and a warning is displayed.
    This will then close the program using a `return` statement.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入一个空值，则会进行检查并显示警告。然后，程序将使用`return`语句关闭。
- en: 'Wait for the `Enter` key to be pressed before calling the `ShowBalance` method:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`ShowBalance`方法之前，等待`Enter`键被按下：
- en: '[PRE100]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now for the logging methods. They must be compatible with your `Action<string>`
    delegate. One writes a message to the console and the other appends it to the
    text file. Add these two static methods as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来看一下日志方法。它们必须与你的`Action<string>`委托兼容。一个将消息写入控制台，另一个将其追加到文本文件。按照以下方式添加这两个静态方法：
- en: '[PRE101]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Running the console app, you see that `VerifyPin` and `ShowBalance` calls are
    written to the console:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，你会看到`VerifyPin`和`ShowBalance`调用被写入控制台：
- en: '[PRE102]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'For each `logger` delegate invocation, the `LogToFile` method will also be
    called, so when opening `activity.txt`, you should see the following line:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个`logger`委托调用，`LogToFile`方法也会被调用，所以当你打开`activity.txt`时，你应该看到以下行：
- en: '[PRE103]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/h9vic](https://packt.link/h9vic).
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/h9vic](https://packt.link/h9vic)找到这个练习使用的代码。
- en: It is important to remember that delegates are immutable, so each time you use
    the `+=` or `-=` operators, you create a **new** delegate instance. This means
    that if you alter a delegate after you have passed it to a target class, you will
    not see any changes to the methods called from inside that target class.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，委托是不可变的，所以每次你使用`+=`或`-=`运算符时，你都会创建一个新的委托实例。这意味着如果你在将委托传递给目标类之后修改了它，你将不会看到目标类内部调用该方法有任何变化。
- en: 'You can see this in action in the following example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的示例中看到这个操作：
- en: '[PRE104]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'All objects in C# have a `GetHashCode()` function that returns a unique ID.
    Running the code produces this output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的所有对象都有一个`GetHashCode()`函数，它返回一个唯一的ID。运行代码会产生以下输出：
- en: '[PRE105]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: You can see that the `+=` call. This shows that the object reference is changing
    each time.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`+=`的调用。这表明对象引用每次都在改变。
- en: 'Now look at another example using an `Action<string>` delegate. Here, you will
    use the `+=` operator to add target methods and then use `-=` to remove the target methods:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看另一个使用`Action<string>`委托的示例。在这里，你将使用`+=`运算符添加目标方法，然后使用`-=`来移除目标方法：
- en: '[PRE106]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You start with one target method, `LogToConsole`, and then add the same target
    method a second time. Invoking the logger delegate using `logger("Console x 2")`
    results in `LogToConsole` being called twice.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你从一个目标方法`LogToConsole`开始，然后再次添加相同的目标方法。使用`logger("Console x 2")`调用日志委托会导致`LogToConsole`被调用两次。
- en: 'You then use `-=` to remove `LogToConsole` **twice** such that had two targets
    and now you do not have any at all. Running the code produces the following output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`-=`移除`LogToConsole`**两次**，这样原本有两个目标，现在一个都没有了。运行代码会产生以下输出：
- en: '[PRE107]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'However, rather than `logger("logger is now null")` running correctly, you
    end up with an unhandled exception being thrown like so:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`logger("logger is now null")`没有正确运行，你最终会得到一个未处理的异常，如下所示：
- en: '[PRE108]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: By removing the last target method, the `-=` operator returned a null reference,
    which you then assigned to the logger. As you can see, it is important to always
    check that a delegate is not null before trying to invoke it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除最后一个目标方法，`-=`运算符返回了一个空引用，然后你将其分配给了日志。正如你所看到的，在尝试调用委托之前始终检查委托是否为空是非常重要的。
- en: Multicasting with a Func Delegate
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Func委托进行多播
- en: So far, you have used `Action<string>` delegates within `Action` delegates.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经在`Action`委托内部使用了`Action<string>`委托。
- en: You have seen that `Func` delegates are used when a return value is required
    from an invoked delegate. It is also perfectly legal for the C# complier to use
    `Func` delegates in multicast delegates.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到当需要从调用的委托中获取返回值时使用`Func`委托。C#编译器在多播委托中使用`Func`委托也是完全合法的。
- en: 'Consider the following example where you have a `Func<string, string>` delegate.
    This delegate supports functions that are passed a string and return a formatted
    string is returned. This could be used when you need to format an email address
    by removing the `@` sign and dot symbols:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中有一个`Func<string, string>`代理。此代理支持传递字符串并返回格式化字符串的函数。这可以在你需要通过删除`@`符号和点符号来格式化电子邮件地址时使用：
- en: '[PRE109]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'You start by assigning the `RemoveDots` string function to `emailFormatter`
    and invoke it using the `Address` constant:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先将`RemoveDots`字符串函数分配给`emailFormatter`，并使用`Address`常量调用它：
- en: '[PRE110]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Then you add a second target, `RemoveAtSign`, and invoke `emailFormatter` a
    second time:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你添加第二个目标，`RemoveAtSign`，并第二次调用`emailFormatter`：
- en: '[PRE111]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Running the code produces this output:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE112]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The first invocation returns the `admin@googlecom` string. The `RemoveAtSign`
    added to the target list, returns a value with only the `@` symbol removed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用返回`admin@googlecom`字符串。添加到目标列表中的`RemoveAtSign`返回一个只删除了`@`符号的值。
- en: Note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/fshse](https://packt.link/fshse).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/fshse](https://packt.link/fshse)找到用于此示例的代码。
- en: Both `Func1` and `Func2` are invoked, but only the value from `Func2` is returned
    to both `ResultA` and `ResultB` variables, even though the correct arguments are
    passed in. When a `Func<>` delegate is used with multicast in this manner, all
    of the target `Func` instances are called, but the return value will be that of
    the last `Func<>` in the chain. `Func<>` is better suited in a single method scenario,
    although the compiler will still allow you to use it as a multicast delegate without
    any compilation error or warning.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`Func1`和`Func2`都被调用，但只有`Func2`的值返回到`ResultA`和`ResultB`变量中，即使传递了正确的参数。当以这种方式使用多播的`Func<>`代理时，链中的所有目标`Func`实例都会被调用，但返回值将是链中最后一个`Func<>`的值。`Func<>`更适合单方法场景，尽管编译器仍然允许你将其用作多播代理而不会出现编译错误或警告。'
- en: What Happens When Things Go Wrong?
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当事情出错时会发生什么？
- en: When a delegate is invoked, all methods in the invocation list are called. In
    the case of single-name delegates, this will be one target method. What happens
    in the case of multicast delegates if one of those targets throws an exception?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用代理时，调用列表中的所有方法都会被调用。对于单名称代理，这将是一个目标方法。如果其中的一个目标抛出异常，多播代理会发生什么？
- en: 'Consider the following code. When the `logger` delegate is invoked, by passing
    in `try log this`, you may expect the methods to be called in the order that they
    were added: `LogToConsole`, `LogToError`, and finally `LogToDebug`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码。当调用`logger`代理时，通过传入`try log this`，你可能期望方法按它们添加的顺序被调用：`LogToConsole`，`LogToError`，最后是`LogToDebug`：
- en: '[PRE113]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: If any target method throws an exception, such as the one you see in `LogToError`,
    then the remaining targets are **not** called.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何目标方法抛出异常，例如你在`LogToError`中看到的，那么剩余的目标将**不会**被调用。
- en: 'Running the code results in the following output:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE114]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: You will see this output because the `LogToDebug` method wasn't called at all.
    Consider a UI with multiple targets listening to a mouse button click. The first
    method fires when a button is pressed and disables the button to prevent double-clicks,
    the second method changes the button's image to indicate success, and the third
    method enables the button.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这个输出，因为`LogToDebug`方法根本没有被调用。考虑一个有多个目标监听鼠标按钮点击的UI。第一个方法在按钮被按下时触发，并禁用按钮以防止双击，第二个方法更改按钮的图像以指示成功，第三个方法启用按钮。
- en: If the second method fails, then the third method will not get called, and the
    button could remain in a disabled state with an incorrect image assigned, thereby
    confusing the user.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个方法失败，则第三个方法将不会调用，按钮可能保持禁用状态，并分配了不正确的图像，从而使用户感到困惑。
- en: 'To ensure that all target methods are run regardless, you can enumerate through
    the invocation list and invoke each method manually. Take a look at the .NET `MulticastDelegate`
    type. You will find that there is a function, `GetInvocationList`, that returns
    an array of the delegate objects. This array contains the target methods that
    have been added:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所有目标方法都运行，你可以遍历调用列表并手动调用每个方法。看看.NET的`MulticastDelegate`类型。你会发现有一个函数`GetInvocationList`，它返回一个包含代理对象的数组。这个数组包含已添加的目标方法：
- en: '[PRE115]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: You can then loop through those target methods and execute each one inside a
    `try`/`catch` block. Now practice what you learned through this exercise.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以遍历这些目标方法，并在`try`/`catch`块中执行每个方法。现在通过这个练习来练习你所学到的内容。
- en: 'Exercise 3.04: Ensuring All Target Methods Are Invoked in a Multicast Delegate'
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.04：确保在多播代理中调用所有目标方法
- en: Throughout this chapter, you have been using `Action<string>` delegates to perform
    various logging operations. In this exercise, you have a list of target methods
    for a logging delegate and you want to ensure that "all" target methods are invoked
    even if earlier ones fail. You may have a scenario where logging to a database
    or filesystem fails occasionally, maybe due to network issues. In such a situation,
    you will want other logging operations to at least have a chance to perform their
    logging activity.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你一直在使用`Action<string>`代理来执行各种日志操作。在这个练习中，你有一个日志代理的目标方法列表，并且你想要确保“所有”目标方法都被调用，即使早期的一些方法失败了。你可能有一个场景，日志记录到数据库或文件系统偶尔会失败，可能是因为网络问题。在这种情况下，你希望其他日志操作至少有机会执行它们的日志活动。
- en: 'Perform the following steps to do so:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise04`,
    using the CLI `dotnet` command:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Chapter03`文件夹，并使用CLI `dotnet`命令创建一个新的控制台应用程序，命名为`Exercise04`：
- en: '[PRE116]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Open `Chapter03\Exercise04.csproj` and replace the entire file with these settings:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter03\Exercise04.csproj`并替换整个文件为以下设置：
- en: '[PRE117]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Open `Exercise04\Program.cs` and clear the contents.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise04\Program.cs`并清除其内容。
- en: 'Now add a static `Program` class for your console app, including `System` and,
    additionally, `System.IO` as you want to create a file:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为你的控制台应用程序添加一个静态的`Program`类，包括`System`，以及额外的`System.IO`，因为你想要创建一个文件：
- en: '[PRE118]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Use a `const` to name the logging file. This file is created when the program executes:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个`const`来命名日志文件。当程序执行时，此文件将被创建：
- en: '[PRE119]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now you must define the app''s `Main` entry point. Here you delete the output
    file if it already exists. It is best to start with an empty file here, as otherwise,
    the log file will keep growing every time you run the app:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在必须定义应用程序的`Main`入口点。在这里，如果你已经存在输出文件，则删除它。最好在这里从一个空文件开始，否则每次运行应用程序时，日志文件都会不断增长：
- en: '[PRE120]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'You will start with `logger` having just one target method, `LogToConsole`,
    which you will add shortly:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将开始于只有一个目标方法`logger`，即`LogToConsole`，你很快就会添加它：
- en: '[PRE121]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'You use the `InvokeAll` method to invoke the delegate, passing in `"First call"`
    as an argument. This will not fail as `logger` has a single valid method and you
    will add `InvokeAll` shortly, too:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用`InvokeAll`方法来调用代理，传入`"First call"`作为参数。这不会失败，因为`logger`有一个有效的方法，你很快也会添加`InvokeAll`：
- en: '[PRE122]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The aim of this exercise is to have a multicast delegate, so add some additional
    target methods:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本练习的目的是拥有一个多播代理，因此添加一些额外的目标方法：
- en: '[PRE123]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Try a second call using `InvokeAll` as follows:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式尝试第二次调用`InvokeAll`：
- en: '[PRE124]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Now for the target methods that were added to the delegate. Add the following
    code for this:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在对于添加到代理中的目标方法。为此添加以下代码：
- en: '[PRE125]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'You can now implement the `InvokeAll` method:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以实现`InvokeAll`方法：
- en: '[PRE126]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: It is passed an `Action<string>` delegate that matches the `logger` delegate
    type, along with an `arg` string to use when invoking each target method. Before
    that though, it is important to check that `logger` is not already null and there
    is nothing you can do with a null delegate.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 它传递了一个与`logger`代理类型匹配的`Action<string>`代理，以及一个用于调用每个目标方法的`arg`字符串。在此之前，检查`logger`是否已经为null，以及你无法对null代理做任何事情是很重要的。
- en: 'Use the delegate''s `GetInvocationList()` method to get a list of all the target
    methods:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代理的`GetInvocationList()`方法来获取所有目标方法的列表：
- en: '[PRE127]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, loop through each item in the list as follows:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式遍历列表中的每个项目：
- en: '[PRE128]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'After wrapping each loop element in a `try`/`catch`, cast `del` into an `Action<string>`:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将每个循环元素包裹在`try`/`catch`块中之后，将`del`强制转换为`Action<string>`：
- en: '[PRE129]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`GetInvocationList` returns each item as the base delegate type regardless
    of their actual type.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInvocationList`返回每个项目作为基本代理类型，而不考虑它们的实际类型。'
- en: 'If it is the correct type and **not** null, then it is safe to try invoking:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它是正确的类型并且**不是**null，那么尝试调用它是安全的：
- en: '[PRE130]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: You have added some extra details to show what is about to be invoked by using
    the delegate's `Method.Name` property.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加了一些额外的细节来显示将要使用代理的`Method.Name`属性调用的内容。
- en: 'Finish with a `catch` block that logs the error message if an error was caught:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，添加一个`catch`块来记录捕获到的错误消息： '
- en: '[PRE131]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Running the code, creates a file called `Exercise04.txt` with the following results:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，会创建一个名为`Exercise04.txt`的文件，其中包含以下结果：
- en: '[PRE132]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You will see that it catches the error thrown by `LogToDatabase` and still allows
    `LogToFile` to be called.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到它捕获了`LogToDatabase`抛出的错误，同时仍然允许调用`LogToFile`。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/Dp5H4](https://packt.link/Dp5H4).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/Dp5H4](https://packt.link/Dp5H4)找到用于此练习的代码。
- en: It is now important to expand upon the multicast concept using events.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重要的是要使用事件来扩展多播概念。
- en: Events
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: In the previous sections, you have created delegates and invoked them directly
    in the same method or passed them to another method for it to invoke when needed.
    By using delegates in this way, you have a simple way for code to be notified
    when something of interest happens. So far, this has not been a major problem,
    but you may have noticed that there appears to be no way to prevent an object
    that has access to a delegate from invoking it directly.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经创建了委托，并在同一方法中直接调用它们，或者将它们传递给其他方法，以便在需要时调用。通过这种方式使用委托，你有一个简单的方法来让代码在发生感兴趣的事情时得到通知。到目前为止，这还没有成为一个大问题，但你可能已经注意到似乎没有方法可以防止一个可以访问委托的对象直接调用它。
- en: 'Consider the following scenario: you have created an application that allows
    other programs to register for notifications when a new email arrives by adding
    their target method to a delegate that you have provided. What if a program, either
    by mistake or for malicious reasons, decides to invoke your delegate itself? This
    could quite easily overwhelm all the target methods in your invocation list. Such
    listener programs should never be allowed to invoke a delegate in this way—after
    all, they are meant to be passive listeners.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：你创建了一个应用程序，允许其他程序通过将它们的目标方法添加到你提供的委托中，来注册当收到新电子邮件时的通知。如果一个程序，无论是由于错误还是恶意原因，决定自己调用你的委托，会发生什么？这可能会轻易地压倒你的调用列表中的所有目标方法。这样的监听程序绝对不应该以这种方式调用委托——毕竟，它们应该是被动的监听者。
- en: You could add extra methods that allow listeners to add or remove their target
    methods from the invocation list and shield the delegate from direct access, but
    what if you have hundreds of such delegates available in an application? That
    is a great deal of code to write.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加额外的允许监听者将它们的目标方法添加或从调用列表中删除的方法，并保护委托免受直接访问，但如果你在一个应用程序中有数百个这样的委托，这将需要编写大量的代码。
- en: The `event` keyword instructs the C# complier to add extra code to ensure that
    a delegate can **only** be invoked by the class or struct that it is declared
    in. External code can add or remove target methods but is prevented from invoking
    the delegate. Attempting to do so results in a compiler error.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`关键字指示C#编译器添加额外的代码以确保委托只能由声明它的类或结构体调用。外部代码可以添加或删除目标方法，但被阻止调用委托。尝试这样做会导致编译器错误。'
- en: This pattern is commonly known as the pub-sub pattern. The object raising an
    event is called the event sender or **publisher**; the object(s) receiving the
    event are called event handlers or **subscribers**.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常被称为发布-订阅模式。引发事件的对象被称为事件发送者或**发布者**；接收事件的对象被称为事件处理程序或**订阅者**。
- en: Defining an Event
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个事件
- en: 'The `event` keyword is used to define an event and its associated delegates.
    Its definition looks similar to the way delegates are defined, but unlike delegates,
    you cannot use the global namespace to define events:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`关键字用于定义事件及其关联的委托。其定义看起来与委托的定义方式相似，但与委托不同，你不能使用全局命名空间来定义事件：'
- en: '[PRE133]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Events have four elements:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 事件有四个元素：
- en: 'Scope: An access modifier, such as `public`, `private`, or `protected`, to
    define the scope.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：一个访问修饰符，如`public`、`private`或`protected`，用于定义作用域。
- en: The `event` keyword.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`关键字。'
- en: 'Delegate type: The associated delegate, `EventHandler` in this example.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托类型：关联的委托，例如本例中的`EventHandler`。
- en: 'Event name: This can be anything you like, `MouseDoubleClicked`, for example.
    However, the name must be unique within the namespace.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件名称：可以是任何你喜欢的名称，例如`MouseDoubleClicked`。然而，名称必须在命名空间内是唯一的。
- en: Events are typically associated with the inbuilt .NET delegates, `EventHandler`,
    or its generic `EventHandler<>` version. It is rare to create custom delegates
    for events, but you may find this in older legacy code created prior to the `Action`
    and generic `Action<T>` delegates.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通常与内置的.NET委托`EventHandler`或其泛型版本`EventHandler<>`相关联。为事件创建自定义委托很少见，但你可能会在`Action`和泛型`Action<T>`委托之前创建的旧版代码中找到它。
- en: 'The `EventHandler` delegate was available in early versions of .NET. It has
    the following signature, taking a sender `object` and an `EventArgs` parameter:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventHandler`委托在.NET的早期版本中可用。它具有以下签名，接受一个发送者`object`和一个`EventArgs`参数：'
- en: '[PRE134]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The more recent generic-based `EventHandler<T>` delegate looks similar; it
    also takes a sender `object` and a parameter defined by the type `T`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 更近期的基于泛型的`EventHandler<T>`委托看起来相似；它也接受一个发送者`object`和一个由类型`T`定义的参数：
- en: '[PRE135]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The `sender` parameter is defined as `object`, allowing any type of object to
    be sent to subscribers for them to identify the sender of the event. This can
    be useful in a situation where you have a centralized method that needs to work
    on various types of objects rather than specific instances.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`sender`参数被定义为`object`，允许发送任何类型的对象到订阅者，以便他们可以识别事件的发送者。这在需要集中处理各种类型对象而不是特定实例的情况下非常有用。'
- en: For example, in a UI app, you may have one subscriber that listens for an OK
    button being clicked, and a second subscriber that listens for a **Cancel** button
    being clicked–each of these could be handled by two separate methods. In the case
    of multiple checkboxes used to toggle options on or off, you could use a single
    target method that simply needs to be told that a checkbox is the sender, and
    to toggle the setting accordingly. This allows you to reuse the same checkbox
    handler rather than creating a method for every checkbox on a screen.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个UI应用程序中，你可能有一个订阅者监听OK按钮被点击，另一个订阅者监听**取消**按钮被点击——每个这些都可以由两个不同的方法处理。在多个复选框用于切换选项开或关的情况下，你可以使用一个单一的目标方法，只需要告诉它复选框是发送者，并相应地切换设置。这允许你重用相同的复选框处理程序，而不是为屏幕上的每个复选框创建一个方法。
- en: It is not mandatory to include details of the sender when invoking an `EventHandler`
    delegate. Often, you may not want to divulge the inner workings of your code to
    the outside; in this case, it is common practice to pass a null reference to the
    delegate.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`EventHandler`委托时，包含发送者的详细信息不是强制的。通常，你可能不希望向外界透露你代码的内部工作原理；在这种情况下，将null引用传递给委托是一种常见的做法。
- en: The second argument in both delegates can be used to provide extra contextual
    information about the event (for example, was it the left or right mouse button
    that was pressed?). Traditionally, this extra information was wrapped up using
    a class derived from `EventArgs`, but that convention has been relaxed in newer
    .NET versions.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 两个委托中的第二个参数可以用来提供关于事件的额外上下文信息（例如，是左键还是右键被按下？）。传统上，这些额外信息是通过从`EventArgs`派生的类包装的，但在较新的.NET版本中，这种约定已经放宽。
- en: There are two standard .NET delegates you should for your event definition?
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该为你的事件定义使用两个标准的.NET委托吗？
- en: '`EventHandler`: This can be used when there is no extra information to describe
    the event. For example, a checkbox click event may not need any extra information,
    it was simply clicked. In this case, it is perfectly valid to pass null or `EventArgs.Empty`
    as the second parameter. This delegate can often be found in legacy apps that
    use a class derived from `EventArgs` to describe the event further. Was it a double-click
    of the mouse that triggered this event? In this case, a `Clicks` property may
    have been added to an `EventArgs` derived class to provide such extra details.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventHandler`: 当没有额外信息描述事件时可以使用。例如，复选框点击事件可能不需要任何额外信息，它只是被点击了。在这种情况下，传递null或`EventArgs.Empty`作为第二个参数是完全有效的。这个委托通常可以在使用从`EventArgs`派生的类进一步描述事件的旧版应用程序中找到。是鼠标的双击触发了这个事件吗？在这种情况下，可能已经向从`EventArgs`派生的类中添加了一个`Clicks`属性来提供这样的额外细节。'
- en: '`EventHandler<T>`: Since the inclusion of generics in C#, this has become the
    more frequently used delegate for events, simply because using generics requires
    fewer classes to be created.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventHandler<T>`: 由于C#中泛型的引入，这已成为更频繁使用的委托事件，仅仅因为使用泛型需要创建更少的类。'
- en: 'Interestingly, no matter what scope you give to your event (`public`, for example),
    the C# compiler will internally create a private member with that name. This is
    the key concept with events: only the class that defines the event may **invoke
    it**. Consumers are free to add or remove their interest, but they **cannot**
    invoke it themselves.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，无论你给事件赋予什么范围（例如 `public`），C# 编译器都会在内部创建一个具有该名称的私有成员。这是事件的关键概念：只有定义事件的类才能**调用**它。消费者可以自由添加或删除他们的兴趣，但不能**自己**调用它。
- en: When an event is defined, the publisher class in which it is defined can simply
    invoke it as and when needed, in the same way that you invoke delegates. In the
    earlier examples, a point was made of always checking that the delegate is not
    null before invoking. The same approach should be taken with events, as you have
    little control over how or when a subscriber may add or remove their target methods.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义一个事件时，定义该事件的发布者类可以简单地按需调用它，就像调用委托一样。在早期示例中，强调了在调用之前始终检查委托是否为空。对于事件，也应采取相同的方法，因为你对订阅者如何或何时添加或删除目标方法几乎没有控制权。
- en: When a publisher class is initially created, all events have an initial value
    of null. This will change to not null when any subscriber adds a target method.
    Conversely, as soon as a subscriber removes a target method, the event will revert
    to null if there are no methods left in the invocation list and all this is handled
    by the runtime. This is the standard behavior you saw earlier with delegates.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当发布者类最初创建时，所有事件都有一个初始值为空。当任何订阅者添加目标方法时，这会变为非空。相反，一旦订阅者删除目标方法，如果调用列表中没有其他方法，事件将恢复为空。这是你之前在委托中看到的标准行为。
- en: 'You can prevent an event from ever becoming null by adding an empty delegate
    to the end of the event definition:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在事件定义的末尾添加一个空委托来防止事件永远为空：
- en: '[PRE136]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Rather than having the default null value, you are adding your own default delegate
    instance—one that does nothing. Hence the blank between the `{}` symbols.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用默认的空值，你添加了自己的默认委托实例——一个什么也不做的实例。因此，在 `{}` 符号之间有一个空格。
- en: 'There is a common pattern often followed when using events within a publisher
    class, particularly in classes that may be subclassed further. You will now see
    this with the help of a simple example:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用发布者类中的事件时，通常会遵循一个常见的模式，尤其是在可能进一步派生的类中。现在，通过一个简单的示例，你将看到这一点：
- en: 'Define a class, `MouseClickedEventArgs`, that contains additional information
    about the event, in this case, the number of mouse clicks that were detected:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `MouseClickedEventArgs` 的类，该类包含关于事件的附加信息，在本例中，是检测到的鼠标点击次数：
- en: '[PRE137]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Observe the `MouseClickPublisher` class, This has a `MouseClicked` event defined
    using the generic `EventHandler<>` delegate.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下 `MouseClickPublisher` 类，它使用泛型 `EventHandler<>` 委托定义了一个 `MouseClicked` 事件。
- en: 'Now add the `delegate { };` block to prevent `MouseClicked` from being null
    initially:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加 `delegate { };` 块以防止 `MouseClicked` 初始为空：
- en: '[PRE138]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Add an `OnMouseClicked` virtual method that gives any further subclassed `MouseClickPublisher`
    classes a chance to suppress or change the event notification, as follows:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `OnMouseClicked` 虚拟方法，以便任何进一步派生的 `MouseClickPublisher` 类有机会抑制或更改事件通知，如下所示：
- en: '[PRE139]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Now you need a method that tracks the mouse clicks. In this example, you will
    not actually show how mouse clicks are detected, but you will call `OnMouseClicked`,
    passing in `2` to indicate a double-click.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你需要一个跟踪鼠标点击的方法。在这个例子中，你实际上不会展示如何检测鼠标点击，但你将调用 `OnMouseClicked`，传递 `2` 来指示双击。
- en: 'Notice how you have not invoked the `MouseClicked` event directly; you always
    go via the `OnMouseClicked` intermediary method. This provides a way for other
    implementations of `MouseClickPublisher` to override the event notification if
    they need to:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，你没有直接调用 `MouseClicked` 事件；你总是通过 `OnMouseClicked` 中间方法来调用。这为其他 `MouseClickPublisher`
    的实现提供了覆盖事件通知的方式：
- en: '[PRE140]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now add a new type of publisher that is based on `MouseClickPublisher`:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个基于 `MouseClickPublisher` 的新类型的发布者：
- en: '[PRE141]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This `MouseSingleClickPublisher` overrides the `OnMouseClicked` method and only
    calls the base `OnMouseClicked` if a single click was detected. By implementing
    this type of pattern, you allow different types of publishers to control whether
    events are fired to subscribers in a customized manner.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseSingleClickPublisher` 覆盖了 `OnMouseClicked` 方法，并且只有在检测到单次点击时才调用基类的 `OnMouseClicked`。通过实现这种模式，你允许不同类型的发布者以定制的方式控制是否向订阅者触发事件。'
- en: Note
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/J1EiB](https://packt.link/J1EiB).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/J1EiB](https://packt.link/J1EiB) 找到用于此示例的代码。
- en: You can now practice what you learned through the following exercise.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过以下练习来练习你所学的知识。
- en: 'Exercise 3.05: Publishing and Subscribing to Events'
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.05：发布和订阅事件
- en: In this exercise, you will create an alarm clock as an example of a publisher.
    The alarm clock will simulate a `Ticked` event. You will also add a `WakeUp` event
    that is published when the current time matches an alarm time. In .NET, `DateTime`
    is used to represent a point in time, so you will use that for the current time
    and alarm time properties. You will use `DateTime.Subtract` to get the difference
    between the current time and the alarm time and publish the `WakeUp` event when
    it is due.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个闹钟作为发布者的示例。闹钟将模拟 `Ticked` 事件。你还将添加一个 `WakeUp` 事件，当当前时间与闹钟时间匹配时发布。在
    .NET 中，`DateTime` 用于表示时间点，因此你将使用它来表示当前时间和闹钟时间属性。你将使用 `DateTime.Subtract` 来获取当前时间和闹钟时间之间的差异，并在到期时发布
    `WakeUp` 事件。
- en: 'Perform the following steps to do so:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise05`,
    using the CLI `dotnet` command:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Chapter03` 文件夹，并使用 CLI `dotnet` 命令创建一个新的控制台应用程序，命名为 `Exercise05`：
- en: '[PRE142]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Open `Chapter03\Exercise05.csproj` and replace the entire file with these settings:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Chapter03\Exercise05.csproj` 并将整个文件替换为以下设置：
- en: '[PRE143]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Open `Exercise05\Program.cs` and clear the contents.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Exercise05\Program.cs` 并清空其内容。
- en: 'Add a new class called `AlarmClock`. Here you need to use a `DateTime` class,
    so include the `System` namespace:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `AlarmClock` 的新类。在这里你需要使用 `DateTime` 类，因此包含 `System` 命名空间：
- en: '[PRE144]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: You will offer two events for subscribers to listen to—`WakeUp`, based on the
    non-generic `EventHandler` delegate (since you will not pass any extra information
    in this event), and `Ticked`, which uses the generic `EventHandler` delegate with
    a `DateTime` parameter type.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为订阅者提供两个事件来监听——`WakeUp`，基于非泛型的 `EventHandler` 委托（因为你不会在此事件中传递任何额外信息），以及 `Ticked`，它使用泛型的
    `EventHandler` 委托，并带有 `DateTime` 参数类型。
- en: 'You will use this to pass along the current time to display in the console.
    Notice that both have the initial `delegate {};` safety mechanism:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将使用这个方法来传递当前时间以在控制台显示。注意，两者都包含初始的 `delegate {};` 安全机制：
- en: '[PRE145]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Include an `OnWakeUp` override as an example, but do not do the same with `Ticked`;
    this is to show the different invocation approaches:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含一个 `OnWakeUp` 重写作为示例，但不要对 `Ticked` 做同样的事情；这是为了展示不同的调用方法：
- en: '[PRE146]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Now add two `DateTime` properties, the alarm and clock times, as follows:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加两个 `DateTime` 属性，闹钟时间和时钟时间，如下所示：
- en: '[PRE147]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'A `Start` method is used to start the clock. You simulate a clock ticking once
    every minute for `24 hours` using a simple loop as follows:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Start` 方法来启动时钟。你通过一个简单的循环模拟时钟每分钟响一次，持续 `24小时`，如下所示：
- en: '[PRE148]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'For each simulated minute, increment the clock using `DateTime.AddMinute` and
    publish the `Ticked` event, passing in `this` (the `AlarmClock` sender instance)
    and the clock time:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个模拟的分钟，使用 `DateTime.AddMinute` 增加时钟，并发布 `Ticked` 事件，传入 `this`（`AlarmClock`
    发送实例）和时钟时间：
- en: '[PRE149]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '`ClockTime.Subtract` is used to calculate the difference between the click
    and alarm times.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ClockTime.Subtract` 来计算点击时间和闹钟时间之间的差异。
- en: 'You pass the `timeRemaining` value to the local function, `IsTimeToWakeUp`,
    calling the `OnWakeUp` method and break out of the loop if it is time to wake
    up:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将 `timeRemaining` 值传递给本地函数 `IsTimeToWakeUp`，调用 `OnWakeUp` 方法，并在需要醒来时跳出循环：
- en: '[PRE150]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Use the `IsTimeToWakeUp`, a relational pattern, to see whether there is less
    than one minute remaining. Add the following code for this:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `IsTimeToWakeUp`，一个关系模式，来查看是否剩余时间不足一分钟。为此添加以下代码：
- en: '[PRE151]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Now add a console app that subscribes to the alarm clock and its two events
    by starting from the static void `Main` entry point:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个控制台应用程序，它从静态 `void Main` 入口点开始订阅闹钟及其两个事件：
- en: '[PRE152]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Create the `AlarmClock` instance and use the `+=` operator to subscribe to
    the `Ticked` event and the `WakeUp` events. You will define `ClockTicked` and
    `ClockWakeUp` shortly. For now, just add the following code:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `AlarmClock` 实例，并使用 `+=` 运算符订阅 `Ticked` 事件和 `WakeUp` 事件。你将很快定义 `ClockTicked`
    和 `ClockWakeUp`。现在，只需添加以下代码：
- en: '[PRE153]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Set the clock''s current time, use `DateTime.AddMinutes` to add `120` minutes
    to the alarm time, and then start the clock, as follows:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置时钟的当前时间，使用 `DateTime.AddMinutes` 向闹钟时间添加 `120` 分钟，然后启动时钟，如下所示：
- en: '[PRE154]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Finish off `Main` by prompting for the `Enter` key to be pressed:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提示按 `Enter` 键来完成 `Main` 方法：
- en: '[PRE155]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Now you can add the event subscriber local methods:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以添加事件订阅者的局部方法：
- en: '[PRE156]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '`ClockWakeUp` is passed sender and `EventArgs` arguments. You don''t use either
    of these, but they are required for the `EventHandler` delegate. When this subscriber''s
    method is called, you write `"Wake up"` to the console.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClockWakeUp`传递发送者和`EventArgs`参数。你不需要这些参数，但它们对于`EventHandler`委托是必需的。当这个订阅者的方法被调用时，你将`"Wake
    up"`写入控制台。'
- en: '`ClockTicked` is passed the `DateTime` argument as required by the `EventHandler<DateTime>`
    delegate. Here, you pass the current time, so you write that to the console using
    `:t` to show the time in a short format:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ClockTicked`传递了`DateTime`参数，这是`EventHandler<DateTime>`委托所要求的。在这里，你传递当前时间，因此使用`:t`将时间以短格式写入控制台：'
- en: '[PRE157]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Running the app produces this output:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序会产生以下输出：
- en: '[PRE158]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: In this example you see that the alarm clock simulates a tick every minute and
    publishes a `Ticked` event.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到闹钟每分钟模拟一次滴答声并发布一个`Ticked`事件。
- en: Note
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/GPkYQ](https://packt.link/GPkYQ).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/GPkYQ](https://packt.link/GPkYQ)找到用于此练习的代码。
- en: Now it is time to grasp the difference between events and delegates.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候掌握事件和委托之间的区别了。
- en: Events or Delegates?
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件或委托？
- en: 'On the face of it, events and delegates look remarkably similar:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，事件和委托看起来非常相似：
- en: Events are an extended form of delegates.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件是委托的扩展形式。
- en: Both offer **late-bound** semantics, so rather than calling methods that are
    known precisely at compile-time, you can defer a list of target methods when known
    at runtime.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都提供**后期绑定**的语义，因此，而不是在编译时精确知道的方法调用，你可以在运行时延迟一个目标方法列表。
- en: Both are `Invoke()` or, more simply, the `()` suffix shortcut, ideally with
    a null check before doing so.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都是`Invoke()`或更简单的`()`后缀快捷方式，理想情况下在使用之前进行空值检查。
- en: 'The key considerations are as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 关键考虑因素如下：
- en: 'Optionality: Events offer an optional approach; callers can decide to opt into
    events or not. If your component can complete its task without needing any subscriber
    methods, then it is preferable to use an event-based approach.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选性：事件提供了一种可选的方法；调用者可以决定是否加入事件。如果你的组件可以在不需要任何订阅者方法的情况下完成任务，那么使用基于事件的方法更可取。
- en: 'Return types: Do you need to handle return types? Delegates associated with
    events are always void.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型：你需要处理返回类型吗？与事件相关联的委托总是无返回值的。
- en: 'Lifetime: Event subscribers typically have a shorter lifetime than their publishers,
    leaving the publisher to continue detecting new messages even if there are no
    active subscribers.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期：事件订阅者通常比发布者有更短的生存期，即使没有活跃的订阅者，发布者也会继续检测新消息。
- en: Static Events Can Cause Memory Leaks
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态事件可能导致内存泄漏
- en: Before you wrap up your look at events, it pays to be **careful** when using
    events, particularly those that are statically defined.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在你结束对事件的审视之前，使用事件时要格外小心，尤其是那些静态定义的事件。
- en: Whenever you add a subscriber's target method to a publisher's event, the publisher
    class will store a reference to your target method. When you have finished using
    a subscriber instance and it remains attached to a `static` publisher, it is possible
    that the memory used by your subscriber will not be cleared up.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你将订阅者的目标方法添加到发布者的事件中时，发布者类将存储对你的目标方法的引用。当你完成对订阅者实例的使用，并且它仍然附加到一个`static`发布者上时，你的订阅者使用的内存可能不会被清理。
- en: These are often referred to as orphaned, phantom, or ghost events. To prevent
    this, always try to pair up each `+=` call with a corresponding `-=` operator.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常被称为孤儿、幽灵或鬼魂事件。为了防止这种情况，始终尝试将每个`+=`调用与相应的`-=`操作符配对。
- en: Note
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reactive Extensions (Rx) ([https://github.com/dotnet/reactive](https://github.com/dotnet/reactive))
    is a great library for leveraging and taming event-based and asynchronous programming
    using LINQ-style operators. Rx provides a way to time-shift, for example, buffering
    a very chatty event into manageable streams with just a few lines of code. What's
    more, Rx streams are very easy to unit test, allowing you to effectively take
    control of time.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式扩展（Rx）([https://github.com/dotnet/reactive](https://github.com/dotnet/reactive))
    是一个用于利用和驯服基于事件和异步编程的LINQ样式操作符的出色库。Rx 提供了一种时间转换的方法，例如，只需几行代码就可以将非常嘈杂的事件缓冲到可管理的流中。更重要的是，Rx
    流非常容易进行单元测试，让你能够有效地控制时间。
- en: Now read about the interesting topic of lambda expressions.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来了解一下有趣的 lambda 表达式主题。
- en: Lambda Expressions
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: 'Throughout the previous sections, you have mainly used class-level methods
    as targets for your delegates and events, such as the `ClockTicked` and `ClockWakeUp`
    methods, that were also used in *Exercise 3.05*:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您主要使用类级方法作为委托和事件的目标，例如在*练习3.05*中也使用的`ClockTicked`和`ClockWakeUp`方法：
- en: '[PRE159]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The `ClockWakeUp` and `ClockTicked` methods are easy to follow and step through.
    However, by converting them into lambda expression syntax, you can have a more
    succinct syntax and closer proximity to where they are in code.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClockWakeUp`和`ClockTicked`方法易于理解和逐步执行。然而，通过将它们转换为lambda表达式语法，您可以拥有更简洁的语法，并且与它们在代码中的位置更接近。'
- en: 'Now convert the `Ticked` and `WakeUp` events to use two different lambda expressions:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`Ticked`和`WakeUp`事件转换为使用两个不同的lambda表达式：
- en: '[PRE160]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: You have used the same `+=` operator, but instead of method names, you see `(sender,
    e) =>` and identical blocks of code, as seen in `ClockTicked` and `ClockWakeUp`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用了相同的`+=`运算符，但您看到的是`(sender, e) =>`而不是方法名，以及与`ClockTicked`和`ClockWakeUp`中相同的代码块。
- en: 'When defining a lambda expression, you can pass any parameters within parentheses,
    `()`, followed by `=>` (this is often read as **goes to**), and then by your expression/statement
    block:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 定义lambda表达式时，您可以在括号`()`内传递任何参数，然后是`=>`（这通常读作**goes to**），然后是您的表达式/语句块：
- en: '[PRE161]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The code block can be as complex as you need and can return a value if it is
    a `Func`-based delegate.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块可以像您需要的那么复杂，如果它是一个基于`Func`的委托，则可以返回一个值。
- en: The compiler can normally infer each of the parameter types, so you do not even
    need to specify their types. Moreover, you can omit the parentheses if there is
    only one argument and the compiler can infer its type.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常可以推断每个参数类型，因此您甚至不需要指定它们的类型。此外，如果只有一个参数并且编译器可以推断其类型，则可以省略括号。
- en: Wherever a delegate (remember that `Action`, `Action<T>`, and `Func<T>` are
    inbuilt examples of a delegate) needs to be used as an argument, rather than creating
    a class or local method or function, you should consider using a lambda expression.
    The main reason is that this often results in less code, and that code is placed
    closer to the location where it is used.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时需要将委托（记住`Action`、`Action<T>`和`Func<T>`是委托的内置示例）用作参数，而不是创建一个类或局部方法或函数，您都应该考虑使用lambda表达式。主要原因是这样通常会产生更少的代码，并且代码放置在它被使用的位置附近。
- en: 'Now consider another example on Lambda. Given a list of movies, you can use
    the `List<string>` class to store these string-based names, as shown in the following snippet:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑另一个关于Lambda的例子。给定一个电影列表，您可以使用`List<string>`类来存储这些基于字符串的名称，如下面的代码片段所示：
- en: '[PRE162]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'You can use the `List.Sort` method to sort the names alphabetically (the final
    output will be shown at the end of this example):'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`List.Sort`方法按字母顺序对名称进行排序（最终输出将在本例的末尾显示）：
- en: '[PRE163]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'If you need more control over how this sort works, the `List` class has another
    `Sort` method that accepts a delegate of this form: `delegate int Comparison<T>(T
    x, T y)`. This delegate is passed two arguments of the same type (`x` and `y`)
    and returns an `int` value. The `int` value can be used to define the sort order
    of items in the list without you having to worry about the internal workings of
    the `Sort` method.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多控制排序的方式，`List`类还有一个接受此形式委托的`Sort`方法：`delegate int Comparison<T>(T x,
    T y)`。此委托传递两个相同类型的参数（`x`和`y`）并返回一个`int`值。您可以使用`int`值来定义列表中项的排序顺序，而无需担心`Sort`方法的内部工作原理。
- en: As an alternative, you can sort the names to exclude `"The"` from the beginning
    of movie titles. This is often used as an alternative way to list names. You can
    achieve this by passing a lambda expression, using the `( )` syntax to wrap two
    strings, `x, y`, that will be passed by `Sort()` when it invokes your lambda.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，您可以对名称进行排序，以排除电影标题开头的`"The"`。这通常用作列出名称的替代方法。您可以通过传递一个lambda表达式并使用`( )`语法来包装两个字符串`x,
    y`，当`Sort()`调用您的lambda时，这两个字符串将被传递，来实现这一点。
- en: 'If `x` or `y` starts with your noise word, `"The"`, then you use the `string.Substring`
    function to skip the first four characters. `String.Compare` is then used to return
    a numeric value that compares the resulting string values, as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`或`y`以您的噪声词`"The"`开头，那么您将使用`string.Substring`函数跳过前四个字符。然后使用`String.Compare`返回一个数值，该数值比较结果字符串值，如下所示：
- en: '[PRE164]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'You can then write out the sorted results to the console:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将排序后的结果输出到控制台：
- en: '[PRE165]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Running the example code produces the following output:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例代码会产生以下输出：
- en: '[PRE166]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: You can see that the second set of names is sorted with `"The"` is ignored.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，第二组名称按`"The"`被忽略的顺序排序。
- en: Note
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [http://packt.link/B3NmQ](http://packt.link/B3NmQ).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://packt.link/B3NmQ](http://packt.link/B3NmQ)找到用于此示例的代码。
- en: To see these lambda statements put into practice, try your hand at the following exercise.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这些lambda表达式在实际中的应用，尝试以下练习。
- en: 'Exercise 3.06: Using a Statement Lambda to Reverse Words in a Sentence'
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.06：使用语句Lambda反转句子中的单词
- en: In this exercise, you are going to create a utility class that splits the words
    in a sentence and returns that sentence with the words in reverse order.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个实用类，该类可以将句子中的单词拆分并返回单词顺序颠倒的句子。
- en: 'Perform the following steps to do so:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise06`,
    using the CLI `dotnet` command:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Chapter03`文件夹，并使用CLI `dotnet`命令创建一个新的控制台应用程序，命名为`Exercise06`：
- en: '[PRE167]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Open `Chapter03\Exercise06.csproj` and replace the entire file with these settings:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter03\Exercise06.csproj`，并将整个文件替换为以下设置：
- en: '[PRE168]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Open `Exercise02\Program.cs` and clear the contents.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise02\Program.cs`并清除其内容。
- en: 'Add a new class named `WordUtilities` with a string function called `ReverseWords`.
    You need to include the `System.Linq` namespace to help with the string operations:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`WordUtilities`的新类，其中包含一个名为`ReverseWords`的字符串函数。你需要包含`System.Linq`命名空间以帮助进行字符串操作：
- en: '[PRE169]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Define a `Func<string, string>` delegate called `swapWords` that takes a string
    input and returns a string value:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`swapWords`的`Func<string, string>`委托，它接受一个字符串输入并返回一个字符串值：
- en: '[PRE170]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'You will accept a string input argument named `phrase`:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将接受一个名为`phrase`的字符串输入参数：
- en: '[PRE171]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Now for the lambda statement body. Use the `string.Split` function to split
    the `phrase` string into an array of strings using a space as the splitting character:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来看lambda表达式体。使用`string.Split`函数将`phrase`字符串拆分为一个字符串数组，以空格作为分隔符：
- en: '[PRE172]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '`String.Reverse` reverses the order of strings in the array, before finally
    joining the reversed words string array in a single string using `string.Join`.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.Reverse`在将反转的单词字符串数组使用`string.Join`连接成一个字符串之前，先反转数组中字符串的顺序。'
- en: 'You have defined the required `Func`, so invoke it by passing the sentence
    parameter and returning that as the result:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经定义了所需的`Func`，因此通过传递句子参数并返回结果来调用它：
- en: '[PRE173]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Now for a console app that prompts for a sentence to be entered, which is passed
    to `WordUtilities.ReverseWords`, with the result being written to the console:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为一个控制台应用程序，它提示输入一个句子，该句子被传递给`WordUtilities.ReverseWords`，并将结果写入控制台：
- en: '[PRE174]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Running the console app produces results output similar to this:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生类似以下的结果输出：
- en: '[PRE175]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Note
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/z12sR](https://packt.link/z12sR).
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/z12sR](https://packt.link/z12sR)找到用于此练习的代码。
- en: You will conclude this look at lambdas with some of the less obvious issues
    that you might not expect to see when running and debugging.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过查看一些不太明显的问题来结束对lambda表达式的探讨，这些问题你可能不会在运行和调试时预期看到。
- en: Captures and Closures
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获和闭包
- en: Lambda expressions can **capture** any of the variables or parameters within
    the method where they are defined. The word capture is used to describe the way
    that a lambda expression captures or reaches up into the parent method to access
    any variables or parameters.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以**捕获**定义方法中任何变量或参数。捕获这个词用来描述lambda表达式如何捕获或向上进入父方法以访问任何变量或参数。
- en: 'To grasp this better, consider the following example. Here you will create
    a `Func<int, string>` called `joiner` that joins words together using the `Enumerable.Repeat`
    method. The `word` variable (known as an `Outer Variables`) is captured inside
    the body of the `joiner` expression:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，考虑以下示例。在这里，你将创建一个名为`joiner`的`Func<int, string>`，它使用`Enumerable.Repeat`方法将单词连接起来。`word`变量（称为外部变量）被捕获在`joiner`表达式的主体中：
- en: '[PRE176]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Running the preceding example produces the following output:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的示例会产生以下输出：
- en: '[PRE177]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: You invoked the `joiner` delegate by passing `2` as an argument. At that moment
    in time, the outer `word` variable has a value of `"hello"`, which is repeated
    twice.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过传递`2`作为参数调用了`joiner`委托。在那个时刻，外部`word`变量的值为`"hello"`，它被重复两次。
- en: 'This confirms that captured variables, from the parent method, were evaluated
    `Func` was invoked. Now change the value of `word` from `hello` to `goodbye` and
    invoke `joiner` once again, passing `3` as the argument:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了从父方法捕获的变量在 `Func` 被调用时被评估。现在将 `word` 的值从 `hello` 更改为 `goodbye`，并再次调用 `joiner`，传递
    `3` 作为参数：
- en: '[PRE178]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Running this example produces the following output:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例会产生以下输出：
- en: '[PRE179]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: It is worth remembering that it does not matter where in the code you defined
    `joiner`. You could have changed the value of `word` to any number of strings
    before or after declaring `joiner`.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，你定义 `joiner` 的位置在代码中并不重要。你可以在声明 `joiner` 之前或之后将 `word` 的值更改为任意数量的字符串。
- en: 'Taking captures one step further, if you define a variable with the same name
    inside a lambda, it will be scoped `word`, which will have no effect on the outer
    variable with the same name:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 将捕获进一步扩展，如果你在 lambda 中定义了一个与相同名称的变量，它将具有 `word` 的作用域，这将对该名称的外部变量没有任何影响：
- en: '[PRE180]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The preceding example results in the following output. Notice how the outer
    variable, `word`, remains unchanged from `goodbye`:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的结果如下。注意外部变量 `word` 从 `goodbye` 保持不变：
- en: '[PRE181]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Finally, you will look at the concept of closures that is a subtle part of the
    C# language and often leads to unexpected results.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将了解 C# 语言的一个微妙概念——闭包，它经常导致意外的结果。
- en: 'In the following example, you have a variable, `actions`, that contains a `List`
    of `Action` delegates. You use a basic `for` loop to add five separate `Action`
    instances to the list. The lambda expression for each `Action` simply writes that
    value of `i` from the `for` loop to the console. Finally, the code simply runs
    through each `Action` in the `actions` list and invokes each one:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你有一个变量 `actions`，它包含一个 `Action` 委托的 `List`。你使用基本的 `for` 循环向列表中添加五个单独的
    `Action` 实例。每个 `Action` 的 lambda 表达式只是将 `for` 循环中的 `i` 的值写入控制台。最后，代码只是遍历 `actions`
    列表中的每个 `Action` 并调用它们：
- en: '[PRE182]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Running the example produces the following output:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生以下输出：
- en: '[PRE183]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The reason why `MyAction: i` did not start from `0` is that the value of `i`,
    when accessed from inside a `Action` delegate, is only evaluated once the `Action`
    is invoked. By the time each delegate is invoked, the outer loop has already repeated
    five times over.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAction: i` 没有从 `0` 开始的原因是，当从 `Action` 委托内部访问 `i` 的值时，它只会在 `Action` 被调用后评估。到每个委托被调用时，外部循环已经重复了五次。'
- en: Note
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/vfOPx](https://packt.link/vfOPx).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/vfOPx](https://packt.link/vfOPx) 找到用于此示例的代码。
- en: This is similar to the capture concept you observed, where the outer variables,
    `i` in this case, are only evaluated when invoked. You used `i` in the `for` loop
    to add each `Action` to the list, but by the time you invoked each action, `i`
    had its final value of `5`.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你在捕获概念中观察到的类似，其中外部变量（在这种情况下为 `i`），只有在被调用时才会被评估。你在 `for` 循环中使用 `i` 将每个 `Action`
    添加到列表中，但在调用每个动作时，`i` 已经有了它的最终值 `5`。
- en: This can often lead to unexpected behavior, especially if you assume that an
    `i` is being used inside each action's loop variable. To ensure that the incrementing
    value of `i` is used inside each lambda expression, you need to introduce a `for`
    loop, one that takes a copy of the iterator variable.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会导致意外的行为，特别是如果你假设每个动作的循环变量中使用了 `i`。为了确保在 lambda 表达式内部使用 `i` 的递增值，你需要引入一个
    `for` 循环，它包含迭代变量的副本。
- en: 'In the following code snippet, you have added the `closurei` variable. It looks
    very subtle, but you now have a more locally scoped variable, which you access
    from inside the lambda expression, rather than the iterator, `i`:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，你添加了 `closurei` 变量。它看起来非常微妙，但现在你有一个更局部的作用域变量，你从 lambda 表达式内部而不是迭代器
    `i` 访问它：
- en: '[PRE184]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Running the example produces the following output. You can see that the incrementing
    value is used when each `Action` is invoked, rather than the value of `5` that
    you saw earlier:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生以下输出。你可以看到，当每个 `Action` 被调用时，使用的是递增的值，而不是你之前看到的 `5` 的值：
- en: '[PRE185]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: You have covered the key aspects of delegates and events in event-driven applications.
    You extended this by using the succinct coding style offered by lambdas, to be
    notified when events of interest occur.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经涵盖了事件驱动应用程序中委托和事件的关键方面。你通过使用 lambda 提供的简洁编码风格扩展了这一点，以便在感兴趣的事件发生时得到通知。
- en: You will now bring these ideas together into an activity in which you will use
    some of the inbuilt .NET classes with their own events. You will need to adapt
    these events to your own format and publish so they can be subscribed to by a
    console app.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将把这些想法整合到一个活动中，在这个活动中，您将使用一些内置的.NET类及其自己的事件。您需要将这些事件适配到您自己的格式，并发布它们，以便控制台应用程序可以订阅。
- en: Now it is time to practice all you have learned through the following activity.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候通过以下活动来练习您所学到的一切。
- en: 'Activity 3.01: Creating a Web File Downloader'
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.01：创建网页文件下载器
- en: You plan to investigate patterns in US storm events. To do this, you need to
    download storm event datasets from online sources for later analysis. The National
    Oceanic and Atmospheric Administration is one such source of data and can be accessed
    from [https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles](https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 您计划调查美国风暴事件的模式。为此，您需要从在线来源下载风暴事件数据集以供后续分析。国家海洋和大气管理局是此类数据的一个来源，可以通过[https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles](https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles)访问。
- en: You are tasked with creating a .NET Core console app that allows a web address
    to be entered, the contents of which are downloaded to a local disk. To be as
    user-friendly as possible, the application needs to use events that signal when
    an invalid address is entered, the progress of a download, and when it completes.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是创建一个.NET Core控制台应用程序，允许输入一个网址，并将该网址的内容下载到本地磁盘。为了尽可能友好，应用程序需要使用表示输入无效地址、下载进度和完成时的事件。
- en: Ideally, you should try to hide the internal implementation that you use to
    download files, preferring to adapt any events that you use to ones that your
    caller can subscribe to. This form of adaption is often used to make code more
    maintainable by hiding internal details from callers.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您应该尝试隐藏您用于下载文件的内部实现，更愿意将您使用的任何事件适配为调用者可以订阅的事件。这种适配形式通常用于通过隐藏内部细节来使代码更易于维护。
- en: 'For this purpose, the `WebClient` class in C# can be used for download requests.
    As with many parts of .NET, this class returns objects that implement the `IDisposable`
    interface. This is a standard interface and it indicates that the object you are
    using should be wrapped in a `using` statement to ensure that any resources or
    memory are cleaned away for you when you have finished using the object. `using`
    takes this format:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，C#中的`WebClient`类可以用于下载请求。与.NET的许多部分一样，这个类返回实现`IDisposable`接口的对象。这是一个标准接口，它表示您正在使用的对象应该被`using`语句包裹，以确保在您完成使用对象后，任何资源或内存都会为您清理。`using`的格式如下：
- en: '[PRE186]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Finally, the `WebClient.DownloadFileAsync` method downloads files in the background.
    Ideally, you should use a mechanism that allows one part of your code to `System.Threading.ManualResetEventSlim`
    is a class that has `Set` and `Wait` methods that can help with this type of signaling.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`WebClient.DownloadFileAsync`方法在后台下载文件。理想情况下，您应该使用一种机制，允许代码的一部分使用`System.Threading.ManualResetEventSlim`类，该类具有`Set`和`Wait`方法，可以帮助进行此类信号。
- en: 'For this activity, you will need to perform the following steps:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，您需要执行以下步骤：
- en: Add a progress changed `EventArgs` class (an example name could be `DownloadProgressChangedEventArgs`)
    that can be used when publishing progress events. This should have `ProgressPercentage`
    and `BytesReceived` properties.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个进度更改的`EventArgs`类（一个示例名称可以是`DownloadProgressChangedEventArgs`），当发布进度事件时可以使用。这个类应该有`ProgressPercentage`和`BytesReceived`属性。
- en: The `WebClient` class from `System.Net` should be used to download a requested
    web file. You should create an adapter class (a suggested name is `WebClientAdapter`)
    that hides your internal usage of `WebClient` from your callers.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用`System.Net`中的`WebClient`类来下载请求的网页文件。您应该创建一个适配器类（建议的名称为`WebClientAdapter`），以隐藏您对`WebClient`的内部使用情况。
- en: Your adapter class should provide three events—`DownloadCompleted`, `DownloadProgressChanged`,
    and `InvalidUrlRequested`—that a caller can subscribe to.
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的适配器类应该提供三个事件——`DownloadCompleted`、`DownloadProgressChanged`和`InvalidUrlRequested`——调用者可以订阅这些事件。
- en: The adapter class will need a `DownloadFile` method that calls the `WebClient`
    class's `DownloadFileAsync` method to start the download request. This requires
    converting a string-based web address into a Uniform Resource Identifier (URI)
    class. The `Uri.TryCreate()` method can create an absolute address from the string
    entered via the console. If the call to `Uri.TryCreate` fails, you should publish
    the `InvalidUrlRequested` event to indicate this failure.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器类需要一个`DownloadFile`方法，该方法调用`WebClient`类的`DownloadFileAsync`方法来启动下载请求。这需要将基于字符串的网页地址转换为统一资源标识符（URI）类。`Uri.TryCreate()`方法可以从控制台输入的字符串创建一个绝对地址。如果`Uri.TryCreate`的调用失败，您应该发布`InvalidUrlRequested`事件来指示这个失败。
- en: '`WebClient` has two events—`DownloadFileCompleted` and `DownloadProgressChanged`.
    You should subscribe to these two events and republish them using your own similar
    events.'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebClient`有两个事件——`DownloadFileCompleted`和`DownloadProgressChanged`。您应该订阅这两个事件，并使用您自己的类似事件重新发布它们。'
- en: Create a console app that uses an instance of `WebClientAdapter` (as created
    in *Step 2*) and subscribe to the three events.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个控制台应用程序，使用`WebClientAdapter`的实例（如*步骤2*中创建的）并订阅这三个事件。
- en: By subscribing to the `DownloadCompleted` event, you should indicate success
    in the console.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过订阅`DownloadCompleted`事件，您应该在控制台指示成功。
- en: By subscribing to `DownloadProgressChanged`, you should report progress messages
    to the console showing the `ProgressPercentage` and `BytesReceived` values.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过订阅`DownloadProgressChanged`，您应该在控制台报告进度消息，显示`ProgressPercentage`和`BytesReceived`值。
- en: By subscribing to the `InvalidUrlRequested` event, you should show a warning
    on the console using a different console background color.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过订阅`InvalidUrlRequested`事件，您应该在控制台使用不同的控制台背景颜色显示警告。
- en: Use a `do` loop that allows the user to repeatedly enter a web address. This
    address and a temporary destination file path can be passed to `WebClientAdapter.DownloadFile()`
    until the user enters a blank address to quit.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个`do`循环允许用户重复输入一个网页地址。这个地址和一个临时的目标文件路径可以传递给`WebClientAdapter.DownloadFile()`，直到用户输入一个空地址来退出。
- en: 'Once you run the console app with various download requests, you should see
    an output similar to the following:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您运行了带有各种下载请求的控制台应用程序，您应该看到以下类似的输出：
- en: '[PRE187]'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: By completing this activity, you have seen how to subscribe to events from an
    existing .NET event-based publisher class (`WebClient`), adapting them to your
    own specification before republishing them in your adapter class (`WebClientAdapter`),
    which were ultimately subscribed to by a console app.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，您已经看到了如何从现有的.NET基于事件的发布者类（`WebClient`）订阅事件，在将它们重新发布到您的适配器类（`WebClientAdapter`）之前，根据您自己的规格进行适配，最终这些事件由控制台应用程序订阅。
- en: Note
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: Summary
  id: totrans-635
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you took an in-depth look at delegates. You created custom
    delegates and saw how they could be replaced with their modern counterparts, the
    inbuilt `Action` and `Func` delegates. By using null reference checks, you discovered
    the safe way to invoke delegates and how multiple methods can be chained together
    to form multicast delegates. You extended delegates further to use them with the
    `event` keyword to restrict invocation and followed the preferred pattern when
    defining and invoking events. Finally, you covered the succinct lambda expression
    style and saw how bugs can be avoided by recognising the use of captures and closures.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您深入了解了委托。您创建了自定义委托，并看到了它们如何被现代的内置`Action`和`Func`委托所替代。通过使用空引用检查，您发现了调用委托的安全方式，以及如何将多个方法链接在一起形成多播委托。您进一步扩展了委托，使用`event`关键字来限制调用，并遵循定义和调用事件时的首选模式。最后，您涵盖了简洁的lambda表达式风格，并看到了如何通过识别捕获和闭包的使用来避免错误。
- en: In the next chapter, you will look at LINQ and data structures, the fundamental
    parts of the C# language.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解LINQ和数据结构，这是C#语言的基本组成部分。
