- en: 16 Mediator and CQRS Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter covers the building blocks of the next chapter, which is about
    **Vertical Slice Architecture**. We begin with a quick overview of Vertical Slice
    Architecture to give you an idea of the end goal. Then, we explore the **Mediator**
    design pattern, which plays the role of the middleman between the components of
    our application. That leads us to the **Command Query Responsibility Segregation**
    (**CQRS**) pattern, which describes how to divide our logic into commands and
    queries. Finally, we consolidate our learning by exploring MediatR, an open-source
    implementation of the Mediator design pattern, and send queries and commands through
    it to demonstrate how the concepts we have studied so far come to life in real-world
    application development.In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A high-level overview of Vertical Slice Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Mediator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the CQS pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code smell – Marker Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MediatR as a mediator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin with the end goal.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level overview of Vertical Slice Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before starting, let’s look at the end goal of this chapter and the next. This
    way, it should be easier to follow the progress toward that goal throughout the
    chapter.As we covered in *Chapter 14*, *Layering and Clean Architecture*, a layer
    groups classes together based on shared responsibilities. So, classes containing
    data access code are part of the data access layer (or infrastructure). People
    represent layers using horizontal slices in diagrams like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1: Diagram representing layers as horizontal slices](img/file99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Diagram representing layers as horizontal slices'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “vertical slice” in “Vertical Slice Architecture” comes from that; a vertical
    slice represents the part of each layer that creates a specific feature. So, instead
    of dividing the application into layers, we divide it into features. A feature
    manages its data access code, domain logic, and possibly even presentation code.
    The key is to loosely couple the features from one another and keep each feature’s
    components close together. In a layered application, when we add, update, or remove
    a feature, we must change one or more layers, which too often translates to “all
    layers.”On the other hand, with vertical slices, we keep features isolated, allowing
    us to design them independently. From a layering perspective, this is like flipping
    your way of thinking about software to a 90° angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2: Diagram representing a vertical slice crossing all layers](img/file100.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Diagram representing a vertical slice crossing all layers'
  prefs: []
  type: TYPE_NORMAL
- en: Vertical Slice Architecture does not dictate the use of **CQRS**, the **Mediator**
    pattern, or **MediatR**, but these tools and patterns flow very well together,
    as we see in the next chapter. Nonetheless, these are just tools and patterns
    that you can use or change in your implementation using different techniques;
    it does not matter and does not change the concept.
  prefs: []
  type: TYPE_NORMAL
- en: We explore additional ways of building feature-oriented applications in *Chapter
    18*, *Request-EndPoint-Response (REPR)*, and *Chapter 20*, *Modular Monolith*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The goal is to encapsulate features together, use CQRS to divide the application
    into requests (commands and queries), and use MediatR as the mediator of that
    CQRS pipeline, decoupling the pieces from one another.You now know the plan. We
    explore Vertical Slice Architecture later. Meanwhile, let’s begin with the Mediator
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Mediator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Mediator** pattern is another GoF design pattern that controls how objects
    interact with one another (making it a behavioral pattern).
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mediator’s role is to manage the communication between objects (colleagues).
    Those colleagues should not communicate together directly but use the mediator
    instead. The mediator helps break tight coupling between these colleagues.**A
    mediator is a middleman who relays messages between colleagues**.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with some UML diagrams. From a very high level, the Mediator pattern
    is composed of a mediator and colleagues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3: Class diagram representing the Mediator pattern](img/file101.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Class diagram representing the Mediator pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an object in the system wants to send a message to one or more colleagues,
    it uses the mediator. Here is an example of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4: Sequence diagram of a mediator relaying messages to colleagues](img/file102.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Sequence diagram of a mediator relaying messages to colleagues'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is also valid for colleagues; a colleague must also use the mediator if
    they need to talk to each other, as depicted in the following class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5: Class diagram representing the Mediator pattern including colleagues’
    collaboration](img/file103.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Class diagram representing the Mediator pattern including colleagues’
    collaboration'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this diagram, `ConcreteColleague1` is a colleague but also the consumer
    of the mediator. For example, that colleague could send a message to another colleague
    using the mediator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6: Sequence diagram representing colleague1 communicating with
    colleague2 through the mediator](img/file104.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Sequence diagram representing colleague1 communicating with colleague2
    through the mediator'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a mediator standpoint, its implementation most likely contains a collection
    of colleagues to communicate with, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7: Class diagram representing a simple hypothetical concrete mediator
    implementation](img/file105.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Class diagram representing a simple hypothetical concrete mediator
    implementation'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored some UML diagrams, let’s look at some code.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Mediator (IMediator)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Mediator project consists of a simplified chat system using the Mediator
    pattern. Let’s start with the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The system is composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IMediator` interface represents a mediator that can send messages to colleagues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IColleague` interface represents a colleague that can receive messages.
    It also has a `Name` property so we can output meaningful values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Message` class represents a message sent by an `IColleague` implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we implement the `IMediator` interface in the `ConcreteMediator` class,
    which broadcasts the messages to all `IColleague` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That mediator is simple; it forwards all the messages it receives to every
    colleague it knows. The last part of the pattern is the `ConcreteColleague` class
    which lets an instance of the `IMessageWriter<TMessage>` interface output the
    messages (we explore that interface next):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That class could hardly be simpler: it takes a name and an `IMessageWriter<TMessage>`
    implementation when created, then it stores a reference for future use.The `IMessageWriter<TMessage>`
    interface serves as a presenter and controls how the messages are displayed. The
    `IMessageWriter<TMessage>` interface is unrelated to the Mediator pattern. Nevertheless,
    it is a way to manage how a `ConcreteColleague` object outputs the messages without
    coupling it with a specific target. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The consumer of the system is an integration test defined in the `MediatorTest`
    class. The test uses the chat system and asserts the output using a custom implementation
    of the `IMessageWriter` interface. Let’s start by analyzing the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The test starts by defining three colleagues with their own `TestMessageWriter`
    implementation (names were randomly generated).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second part of the preceding `Arrange` block, we create the subject
    under test (`mediator`) and register the three colleagues. At the end of that
    `Arrange` block, we also define the expected output of our test. It is important
    to note that we control the output from the `TestMessageWriter` implementation
    (defined at the end of the `MediatorTest` class). Next is the `Act` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `Act` block, we send three messages through the `mediator`
    instance. Next is the `Assert` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the `Assert` block, we ensure that all colleagues receive the messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateConcreteColleague` method is a helper method that encapsulates the
    creation of the colleagues, enabling us to write the one-liner declaration used
    in the `Arrange` section of the test. Next, we look at the `IMessageWriter` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `TestMessageWriter` class writes the messages into `StringBuilder`,
    making it easy to assert the output. If we were to build a GUI for that, we could
    write an implementation of `IMessageWriter<Message>` that writes to that GUI;
    in the case of a web UI, it could use **SignalR** or write to the response stream
    directly, for example.To summarize the sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The consumer (the unit test) sends messages to colleagues through the mediator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `TestMessageWriter` class writes those messages to a `StringBuilder` instance.
    Each colleague has its own instance of the `TestMessageWriter` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code asserts that all colleagues received the expected messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example illustrates that the Mediator pattern allows us to break the direct
    coupling between colleagues. The messages reached colleagues without them knowing
    about each other.Colleagues should communicate through the mediator, so the Mediator
    pattern would not be complete without that. Let’s implement a more advanced chatroom
    to tackle this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Mediator (IChatRoom)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous code sample, we named the classes after the Mediator pattern
    actors, as shown in *Figure 14.7*. While this example is very similar, it uses
    domain-specific names instead and implements a few more methods to manage the
    system showing a more tangible implementation. Let’s start with the abstractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IChatRoom` interface is the mediator, and it defines two methods instead
    of one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Join`, which allows `IParticipant` to join `IChatRoom`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Send`, which sends a message to the others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IParticipant` interface is the colleague and also has a few more methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Send`, to send messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReceiveMessage`, to receive messages from the other `IParticipant` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChatRoomJoined`, to confirm that the `IParticipant` object has successfully
    joined a chatroom.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ChatMessage` class is the same as the previous `Message` class, but it
    references `IParticipant` instead of `IColleague`.Let’s now look at the `IParticipant`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` class represents our default `IParticipant`. A `User` instance can
    chat in only one `IChatRoom`. THe program can set the chat room by calling the
    `ChatRoomJoined` method. When it receives a message, it delegates it to its `IMessageWriter<ChatMessage>`.
    Finally, a `User` instance can send a message through the mediator (`IChatRoom)`.
    The `Send` method throws a `ChatRoomNotJoinedException` to enforce that the `User`
    instance must join a chat room before sending messages (code-wise: the `_chatRoom`
    field must not be `null`).We could create a `Moderator`, `Administrator`, `SystemAlerts`,
    or any other `IParticipant` implementation as we see fit, but not in this sample.
    I am leaving that to you to experiment with the Mediator pattern.Now let’s look
    at the `ChatRoom` class (the mediator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ChatRoom` class is slimmer than the `User` class. It allows participants
    to join and sends chat messages to registered participants. When joining a `ChatRoom`,
    it keeps a reference on the `IParticipant`, tells that `IParticipant` that it
    has successfully joined then sends a `ChatMessage` to all participants announcing
    the newcomer.With those few pieces, we have a Mediator implementation. Before
    moving to the next section, let’s look at the `Consumer` instance of `IChatRoom`,
    which is another integration test. Let’s start with the skeleton of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have the following pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: The test case is an empty placeholder that we are about to look into.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CreateTestUser` method helps simplify the `Arrange` section of the test
    case, similar to before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TestMessageWriter` implementation is similar to the previous example, accumulating
    messages in a `StringBuilder` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a reference, the `IMessageWriter` interface is the same as the previous
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s explore the test case, starting with the `Arrange` block, where
    we create four users with their respective `TestMessageWriter` instances (names
    were also randomly generated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `Act` block, our test users join the `chatroom` instance and send
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in the Assert block, Rutter did not join the chatroom, so we expect no
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since King is the first to join the channel, we expect him to receive all messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Kelley was the second user to join the chatroom, so the output contains almost
    all messages except the line saying `[King]: Has joined the channel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Daveen joined after King and Kelley exchanged a few words, so we expect the
    conversation to be shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To summarize the test case, we have four users. Three of them joined the same
    chatroom at a different time and chatted a little. The output is different for
    everyone since the time you join matters. All participants are loosely coupled,
    thanks to the Mediator pattern, allowing us to extend the system without impacting
    the existing pieces. Leveraging the Mediator pattern helps us create maintainable
    systems; many small pieces are easier to manage and test than a large component
    handling all the logic.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we explored in the two preceding projects, a **mediator** allows us to decouple
    the components of our system. **The mediator is the middleman between colleagues**,
    and it served us well in the small chatroom samples where each colleague can talk
    to the others without knowing how and without knowing them.Now let’s see how the
    Mediator pattern can help us follow the **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: The mediator extracts the communication responsibility from colleagues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: With a mediator relaying the messages, we can create new colleagues
    and change the existing colleagues’ behaviors without impacting the others. If
    we need a new colleague, we can register one with the mediator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: The Mediator pattern divides the system into multiple small interfaces
    (`IMediator` and `IColleague`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: All actors of the Mediator pattern solely depend on other interfaces.
    We can implement a new mediator and reuse the existing colleagues’ implementations
    if we need new mediation behavior because of the dependency inversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we explore CQRS, which allows us to separate commands and queries, leading
    to a more maintainable application. After all, all operations are queries or commands,
    no matter how we call them.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CQS pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Command-Query Separation (CQS)** is a subset of the **Command Query Responsibility
    Segregation (CQRS)** pattern.Here’s the high-level difference between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: With CQS, we divide operations into commands and queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With CQRS, we apply the concept to the system level. We separate models for
    reading and for writing, potentially leading to a distributed system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we stick with CQS and tackle CQRS in *Chapter 18*, *Introduction
    to Microservices Architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The goal is to divide all operations (or requests) into two categories: commands
    and queries.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A command mutates the state of an application.** For example, creating, updating,
    and deleting an entity are commands. In theory, a command should not return a
    value. In practice, they often do, especially for optimization purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A query reads the state of the application but never changes it.** For example,
    reading an order, reading your order history, and retrieving your user profile
    are queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing operations into mutator requests (write/command) and accessor requests
    (read/query) creates a clear separation of concerns, leading us toward the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is no definite design for this, but for us, the flow of a command should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8: Sequence diagram representing the abstract flow of a command](img/file106.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: Sequence diagram representing the abstract flow of a command'
  prefs: []
  type: TYPE_NORMAL
- en: 'The consumer creates a command object and sends it to a command handler, applying
    the mutation to the application. I called it `Entities` in this case, but it could
    have sent a SQL `UPDATE` command to a database or a web API call over HTTP; the
    implementation details do not matter.The concept is the same for a query, but
    it returns a value instead. Very importantly, the query must not change the state
    of the application. A query should only read data, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9: Sequence diagram representing the abstract flow of a query](img/file107.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Sequence diagram representing the abstract flow of a query'
  prefs: []
  type: TYPE_NORMAL
- en: Like the command, the consumer creates a query object and sends it to a handler,
    which then executes some logic to retrieve and return the requested data. We can
    replace `Entities` with anything the handler needs to query the data.Enough talk—let’s
    look at the CQS project.
  prefs: []
  type: TYPE_NORMAL
- en: Project – CQS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Context**: We need to build an improved version of our chat system. The old
    system worked so well that we need to scale it up. The mediator was of help to
    us, so we kept that part, and we picked the CQS pattern to help us with this new,
    improved design. A participant was limited to a single chatroom in the past, but
    now a participant must be able to chat in multiple rooms simultaneously.The new
    system is composed of three commands and two queries:'
  prefs: []
  type: TYPE_NORMAL
- en: A participant must be able to join a chatroom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A participant must be able to leave a chatroom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A participant must be able to send a message into a chatroom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A participant must be able to obtain the list of participants that joined a
    chatroom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A participant must be able to retrieve the existing messages from a chatroom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first three are commands, and the last two are queries. The system is backed
    by the following mediator that makes heavy use of C# generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not familiar with generics, this might look daunting, but that code
    is way simpler than it looks. Next, the `ICommand` interface is empty, which we
    could have avoided, but it helps describe our intent. The `ICommandHandler` interface
    defines the contract a class must implement to handle a command. That interface
    defines a `Handle` method that takes the command as a parameter. The generic parameter
    `TCommand` represents the type of command the class implementing the interface
    can handle. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IQuery<TReturn>` interface is similar to the `ICommand` interface but
    has a `TReturn` generic parameter indicating the query''s return type. The IQueryHandler
    interface is also very similar, but its `Handle` method takes an object of type
    `TQuery` as a parameter and returns a `TReturn` type. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IMediator` interface allows registering command and query handlers using
    its `Register` methods. It also supports sending commands and queries through
    its `Send` methods. Then we have the `ChatMessage` class, which is similar to
    the last two samples (with an added creation date):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the updated `IParticipant` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'All methods of the `IParticipant` interface accept an `IChatRoom` parameter
    to support multiple chatrooms. The updated `IChatRoom` interface has a name and
    a few basic operations to meet the requirement of a chatroom, like adding and
    removing participants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going into commands and the chat itself, let’s take a peek at the `Mediator`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `Mediator` class supports registering commands and queries as well as sending
    a query to a handler or sending a command to zero or more handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'I omitted the implementation of `HandlerDictionary` because it does not add
    value to the example, it is just an implementation detail, but it would have added
    unnecessary complexity. It is available on GitHub: [https://adpg.link/2Lsm](https://adpg.link/2Lsm).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now to the commands. I grouped the commands and the handlers together to keep
    it organized and readable, but you could use another way to organize yours. Moreover,
    since this is a small project, all the commands are in the same file, which would
    not be viable for something bigger. Remember, we are playing LEGO blocks, this
    chapter covers the CQS pieces, but you can always use them with bigger pieces
    like Clean Architecture or other types of architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We cover ways to organize commands and queries in subsequent chapters.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s start with the `JoinChatRoom` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Command` class represents the command itself, a data structure that carries
    the command data. The `Handler` class handles that type of command. When executed,
    it adds the specified `IParticipant` to the specified `IChatRoom`, using the `ChatRoom`
    and `Requester` properties (highlighted line). Next feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That code represents the exact opposite of the `JoinChatRoom` command, the `LeaveChatRoom`
    handler removes an `IParticipant` from the specified `IChatRoom` (highlighted
    line).
  prefs: []
  type: TYPE_NORMAL
- en: Nesting the classes like this allows reusing the class name `Command` and `Handler`
    for each feature.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To the next feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SendChatMessage` feature, on the other hand, handles two things (highlighted
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: It adds the specified `Message` to `IChatRoom` (now only a data structure that
    keeps track of users and past messages).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also sends the specified `Message` to all `IParticipant` instances that joined
    that `IChatRoom`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are starting to see many smaller pieces interacting with each other to create
    a more developed system. But we are not done; let’s look at the two queries, then
    the chat implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListParticipants` handler uses the specified `IChatRoom` and returns its
    participants (highlighted line). Now, to the last query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `ListMessages` handler uses the specified `IChatRoom` instance to return
    its messages.
  prefs: []
  type: TYPE_NORMAL
- en: Because all commands and queries reference `IParticipant`, we could enforce
    rules such as “`IParticipant` must join a channel before sending messages,” for
    example. I decided to omit these details to keep the code simple, but feel free
    to add those features if you want to.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at the `ChatRoom` class, which is a simple data structure
    that holds the state of a chatroom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a second look at the `ChatRoom` class, it has a `Name` property.
    It contains a list of `IParticipant` instances and a list of `ChatMessage` instances.
    Both `ListMessages()` and `ListParticipants()` return the list `AsReadOnly()`,
    so a clever programmer cannot mutate the state of `ChatRoom` from the outside.
    That’s it; the new `ChatRoom` class is a façade over its underlying dependencies.Finally,
    the `Participant` class is probably the most exciting part of this system because
    it is the one that makes heavy use of our Mediator and CQS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Every method of the `Participant` class, apart from `NewMessageReceivedFrom`,
    sends a command or a query through the `IMediator` interface, breaking the tight
    coupling between the participants and the system’s operations (that is, the commands
    and queries). The `Participant` class is also a simple façade over its underlying
    dependencies, delegating most of the work to the mediator.Now that we have covered
    the numerous tiny pieces let’s look at how everything works together. I grouped
    several test cases that share the following setup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The test program setup is composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One `IMediator` field initialized with a `Mediator` instance, which enables
    all colleagues to interact with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two `IChatRoom` fields initialized with `ChatRoom` instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three `IParticipant` uninitialized fields, later initialized with `Participant`
    instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three `TestMessageWriter` instances, one per participant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor registers all handlers with the `Mediator` instance so it knows
    how to handle commands and queries. It also creates the participants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, the names of the participants are randomly generated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `TestMessageWriter` implementation is a little different and accumulates
    the data in a list of tuples (`List<(IChatRoom, ChatMessage)>`) to assess what
    the participants send:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the first test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding test case, Reagen and Garner join Room 1, while Reagen and
    Cornelia join Room 2\. Then Reagen requests the list of participants from Room
    1, which outputs Reagen and Garner. Under the hood, it uses commands and queries
    through a mediator, breaking tight coupling between the colleagues. Here is a
    sequence diagram representing what happens when a participant joins a chatroom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.10: Sequence diagram representing the flow of a participant (p)
    joining a chatroom (c)](img/file108.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Sequence diagram representing the flow of a participant (p) joining
    a chatroom (c)'
  prefs: []
  type: TYPE_NORMAL
- en: The participant (`p`) creates a `JoinChatRoom` command (`joinCmd`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`p` sends `joinCmd` through the mediator (`m`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`m` finds and dispatches `joinCmd` to its handler (`handler`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`handler` executes the logic (adds `p` to the chatroom).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`joinCmd` ceases to exist afterward; commands are ephemeral.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That means `Participant` never interacts directly with `ChatRoom` or other
    participants.Then a similar workflow happens when a participant requests the list
    of participants of a chatroom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.11: Sequence diagram representing the flow of a participant (p)
    requesting the list of participants of a chatroom (c)](img/file109.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Sequence diagram representing the flow of a participant (p) requesting
    the list of participants of a chatroom (c)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Participant` (`p`) creates a `ListParticipants` query (`listQuery`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`p` sends `listQuery` through the mediator (`m`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`m` finds and dispatches the query to its handler (`handler`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`handler` executes the logic (lists the participants of the chatroom).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`listQuery` ceases to exist afterward; queries are also ephemeral.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once again, `Participant` does not interact directly with `ChatRoom`.Here is
    another test case where `Participant` sends a message to a chatroom, and another
    `Participant` receives it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding test case, Reagen joins Room 1 while Garner joins Rooms 1
    and 2\. Then Reagen sends a message to Room 1, and we verify that Garner received
    it once.The `SendMessageTo` workflow is very similar to the other one that we
    saw but with a more complex command handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12: Sequence diagram representing the flow of a participant (p)
    sending a message (msg)to a chatroom (c)](img/file110.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: Sequence diagram representing the flow of a participant (p) sending
    a message (msg)to a chatroom (c)'
  prefs: []
  type: TYPE_NORMAL
- en: 'From that diagram, we can observe that we pushed the logic to the `Handler`
    class of the `SendChatMessage` feature. All the other actors work together with
    limited to no knowledge of each other.This demonstrates how CQS works with a mediator:'
  prefs: []
  type: TYPE_NORMAL
- en: A consumer (the participant in this case) creates a command (or a query).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The consumer sends that command through the mediator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mediator sends that command to one or more handlers, each executing their
    piece of logic for that command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can explore the other test cases to familiarize yourself with the program
    and the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: You can debug the tests in Visual Studio; use breakpoints combined with *Step
    Into (F11)* and *Step Over (F10)* to explore the sample.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I also created a `ChatModerator` instance that sends a message in a “moderator
    chatroom” when a message contains a word from the `badWords` collection. That
    test case executes multiple handlers for each `SendChatMessage.Command`. I’ll
    leave you to explore these other test cases yourself so we don’t wander astray
    from our goal.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The CQS and CQRS patterns suggest dividing the operations of a program into
    **commands** and **queries**. A command mutates data, and a query fetches data.
    We can apply the **Mediator** pattern to break the tight coupling between the
    pieces of a program using CQS, like sending commands and queries.Dividing the
    program this way helps separate the different pieces and focus on the commands
    and queries that travel from a consumer through the mediator to one or more handlers.
    The data contract of commands and queries becomes the program’s backbone, trimming
    down the coupling between objects and tying them to those thin data structures
    instead, leaving the central piece (the mediator) to manage the links between
    them.On the other hand, you may find the codebase more intimidating when using
    CQS due to the multiple classes. It adds some complexity, especially for a small
    program like this. However, each type does less (having a single responsibility),
    making it easier to test than a more sizable class with many responsibilities.Now
    let’s see how CQRS can help us follow the **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Dividing an application into commands, queries, and handlers takes us
    toward encapsulating single responsibilities into different classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: CQS helps extend the software without modifying the existing code, such
    as adding handlers and creating new commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: CQS makes it easier to create multiple small interfaces with a clear
    distinction between commands, queries, and their respective handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have explored CQRS, CQS, and the Mediator pattern, we explore the
    Marker Interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Code smell – Marker Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used the empty `ICommand` and `IQuery<TReturn>` interfaces in the code samples
    to make the code more explicit and self-descriptive. Empty interfaces are a sign
    that something may be wrong: a code smell. We call those **marker interfaces**.In
    our case, they help identify commands and queries but are empty and add nothing.
    We could discard them without any impact on our system. On the other hand, we
    are not performing magic tricks or violating any principles, so they don’t harm
    but help define the intent. Moreover, we could leverage them to make the code
    more dynamic, like leveraging dependency injection to register handlers. Furthermore,
    I designed those interfaces this way as a bridge to the next project.Back to the
    marker interfaces, here are two types of marker interfaces that are code smells
    in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Markers can be used to define metadata. A class “implements” the empty interface,
    and some consumer does something with it later. It could be an assembly scanning
    for specific types, a choice of strategy, or something else.Instead of creating
    marker interfaces to add metadata, try to use custom attributes. The idea behind
    attributes is to add metadata to classes and their members. On the other hand,
    interfaces exist to create a contract, and they should define at least one member;
    empty contracts are like a blank sheet.In a real-world scenario, you may want
    to consider the cost of one versus the other. Markers are very cheap to implement
    but can violate architectural principles. Attributes can be as cheap to implement
    if the mechanism is already implemented or supported by the framework but can
    cost much more than a marker interface, depending on the scenario. Before deciding,
    I recommend you evaluate the cost of both options.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency identifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need markers to inject some specific dependency in a particular class,
    you are most likely cheating the **Inversion of Control** principle. Instead,
    you should find a way to achieve the same goal using dependency injection, such
    as by contextually injecting your dependencies.Let’s start with the following
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In our program, we have two implementations and two markers, one for each implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is barebones, but all the building blocks are there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StrategyA` implements `IStrategyA`, which inherits from `IStrategy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StrategyB` implements `IStrategyB`, which inherits from `IStrategy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `IStrategyA` and `IStrategyB` are empty marker interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, the consumer needs to use both strategies, so instead of controlling dependencies
    from the composition root, the consumer requests the markers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Consumer` class exposes the strategies through properties to assert its
    composition later. Let’s test that out by building a dependency tree, simulating
    the composition root, and then asserting the value of the consumer properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Both properties are of the expected type, but that is not the problem. The
    `Consumer` class controls what dependencies to use and when to use them by injecting
    markers A and B instead of two `IStrategy` instances. Due to that, we cannot control
    the dependency tree from the composition root. For example, we cannot change `IStrategyA`
    to `IStrategyB` and `IStrategyB` to `IStrategyA`, nor inject two `IStrategyB`
    instances or two `IStrategyA` instances, nor even create an `IStrategyC` interface
    to replace `IStrategyA` or `IStrategyB`.How do we fix this? Let’s start by deleting
    our markers and injecting two `IStrategy` instances instead (the changes are highlighted).
    After doing that, we end up with the following object structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Consumer` class no longer controls the narrative with the new implementation,
    and the composition responsibility falls back to the composition root. Unfortunately,
    there is no way to do contextual injections using the default dependency injection
    container, and I don’t want to get into a third-party library for this. But all
    is not lost yet; we can use a factory to help ASP.NET Core build the `Consumer`
    instance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: From this point forward, we control the program’s composition, and we can swap
    A with B or do anything else that we want to, as long as the implementation respects
    the `IStrategy` contract.To conclude, using markers instead of doing contextual
    injection breaks the inversion of control principle, making the consumer control
    its dependencies. That’s very close to using the `new` keyword to instantiate
    objects. Inverting the dependency control back is easy, even using the default
    container.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to inject dependencies contextually, I started an open source project
    in 2020 that does that. Multiple other third-party libraries add features or replace
    the default IoC container altogether if needed. See the *Further reading* section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we start the last part of this chapter. It showcases an open-source tool
    that can help us build CQS-oriented applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using MediatR as a mediator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are exploring MediatR, an open-source mediator implementation.What
    is MediatR? Let’s start with its maker’s description from its GitHub repository,
    which brands it as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Simple, unambitious mediator implementation in .NET”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'MediatR is a simple but very powerful tool doing in-process communication through
    messaging. It supports a request/response flow through commands, queries, notifications,
    and events, synchronously and asynchronously.We can install the NuGet package
    using the .NET CLI: `dotnet add package MediatR`.Now that I have quickly introduced
    the tool, we are going to explore the migration of our Clean Architecture sample
    but instead use MediatR to dispatch the `StocksController` requests to the core
    use cases. We use a similar pattern with MediatR than what we built in the CQS
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: Why migrate our Clean Architecture sample? The primary reason we are building
    the same project using different models is for ease of comparison. It is much
    easier to compare the changes of the same features than if we were building completely
    different projects.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the advantages of using MediatR in this case? It allows us to organize
    the code around use cases (vertically) instead of services (horizontally), leading
    to more cohesive features. We remove the service layer (the `StockService` class)
    and replace it with multiple use cases (features) instead (the `AddStocks` and
    `RemoveStock` classes). MediatR also enables a pipeline we can extend by programming
    behaviors. Those extensibility points allow us to manage cross-cutting concerns,
    such as requests validation centrally, without impacting the consumers and use
    cases. We explore request validation in *Chapter 17*, *Getting Started with Vertical
    Slice Architecture*.Let’s jump into the code now to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Clean Architecture with MediatR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Context**: We want to break some more of the coupling in the Clean Architecture
    project we built in *Chapter 14*, *Understanding Layering*, by leveraging the
    **Mediator** pattern and a **CQS** approach.The clean architecture solution was
    already solid, but MediatR will pave the way to more good things later. The only
    “major” change is the replacement of the `StockService` with two feature objects,
    `AddStocks` and `RemoveStocks`, which we explore soon.First, we must install the
    `MediatR` NuGet package in the `Core` project, where the features will live. Moreover,
    it will transiently cascade to the `Web` project, allowing us to register MediatR
    with the IoC container. In the `Program.cs` file, we can register MediatR like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: That code scans the Core assembly for MediatR-compatible pieces and registers
    them with the IoC Container. The `NotEnoughStockException` class is part of the
    core project.
  prefs: []
  type: TYPE_NORMAL
- en: I picked the `NotEnoughStockException` class but could have chosen any class
    from the `Core` assembly. There are more registration options.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'MediatR exposes the following types of messages (as of version 12):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Request/response* that has one handler; perfect for commands and queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Notifications* that support multiple handlers; perfect for an event-based
    model applying the Publish-Subscribe pattern where a notification represents an
    event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Request/response streams* that are similar to request/response but stream
    the response through the `IAsyncEnumerable<T>` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cover the Publish-Subscribe pattern in *Chapter 19*, *Introduction to Microservices
    Architecture*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that everything we need related to MediatR is “magically” registered, we
    can look at the use cases that replace the `StockService`. Let’s have a look at
    the updated `AddStocks` code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we covered both use cases in the previous chapters and the changes are
    very similar, we will analyze both together, after the `RemoveStocks` use case
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed in the code, I chose the same pattern to build the
    commands as I did with the CQS sample, so we have a class per use case containing
    two nested classes: `Command` and `Handler`. This structure makes for very clean
    code when you have a 1-on-1 relationship between the command class and its handler.Using
    the MediatR request/response model, the command (or query) becomes a request and
    must implement the `IRequest<TResponse>` interface. The handlers must implement
    the `IRequestHandler<TRequest, TResponse>` interface. Instead, we could implement
    the `IRequest` and `IRequestHandler<TRequest>` interfaces for a command that returns
    nothing (`void`).'
  prefs: []
  type: TYPE_NORMAL
- en: More options are part of MediatR, and the documentation is complete enough to
    dig deeper yourself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s analyze the anatomy of the `AddStocks` use case. Here is the old code
    as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The first difference is that we moved the loose parameters (highlighted) into
    the `Command` class, which encapsulates the whole request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `Command` class specifies the handler’s expected return value by implementing
    the `IRequest<TResponse>` interface, where `TResponse` is an `int`. That gives
    us a typed response when sending the request through MediatR. This is not “pure
    CQS” because the command handler returns an integer representing the updated `QuantityInStock`.
    However, we could call that optimization since executing one command and one query
    would be overkill for this scenario (possibly leading to two database calls instead
    of one).I’ll skip the `RemoveStocks` use case to avoid repeating myself, as it
    follows the same pattern. Instead, let’s look at the consumption of those use
    cases. I omitted the exception handling to keep the code streamlined and because
    `try`/`catch` blocks would only add noise to the code in this case and hinder
    our study of the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In both delegates, we inject an `IMediator` and a command object (highlighted).
    We also let ASP.NET Core inject a `CancellationToken`, which we pass to MediatR.
    The model binder loads the data from the HTTP request into the objects that we
    send using the `Send` method of the `IMediator` interface (highlighted). Then
    we map the result into the `StockLevel` DTO before returning its value and an
    HTTP status code of `200` `OK`. The `StockLevel` record class is the same as before.This
    example contains almost the same code as our CQS example, but we used MediatR
    instead of manually programming the pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The default model binder cannot load data from multiple sources. Because of
    that, we must inject `productId` and assign its value to the `command.ProductId`
    property manually. Even if both values could be taken from the body, the resource
    identifier of that endpoint would become less exhaustive (no `productId` in the
    URI).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With MVC, we could create a custom model binder.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With minimal APIs, we could create a static `BindAsync` method to manually do
    the model binding, which is not very extensible and would tightly couple the `Core`
    assembly with the `HttpContext`. I suppose we will need to wait for .NET 9+ to
    get improvements into that field.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I’ve left a few links in the *further reading* section relating to this.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With MediatR, we packed the power of a CQS-inspired pipeline with the Mediator
    pattern into a Clean Architecture application. We broke the coupling between the
    request delegates and the use case handler (previously a service). A simple DTO,
    such as a command object, makes endpoints and controllers unaware of the handlers,
    leaving MediatR as the middleman between the commands and their handlers. Due
    to that, the handlers could change along the way without impacting the endpoint.Moreover,
    we could configure more interaction between the command and the handler with `IRequestPreProcessor`,
    `IRequestPostProcessor`, and `IRequestExceptionHandler`. These allow us to extend
    the MediatR request pipeline with cross-cutting concerns like validation and error
    handling.MediatR helps us follow the SOLID principles the same way as the Mediator
    and CQS patterns combined. The only drawback of the overall design, which has
    nothing to do with MediatR, is that we used the commands as the DTOs. We could
    create custom DTOs and map them to command objects. However, you will understand
    in the next chapter where I was heading with this transitory design.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at the Mediator pattern, which allows us to cut the
    ties between collaborators, mediating the communication between them. Then we
    studied the CQS pattern, which advises the division of software behaviors into
    commands and queries. Those two patterns are tools that cut tight coupling between
    components.Afterward, we updated a Clean Architecture project to use MediatR,
    an open-source generic mediator that is CQS-oriented. There are many more possible
    uses than we explored, but this is still a great start. This concludes another
    chapter exploring techniques to break tight coupling and divide systems into smaller
    parts.All those building blocks lead us to the next chapter, where we piece those
    patterns and tools together to explore the Vertical Slice Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What does the CQS stand for, and what is the purpose of this design pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we use a mediator inside a colleague to call another colleague?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In CQS, can a command return a value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How much does MediatR cost?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imagine a design with a marker interface to add metadata to some classes. Do
    you think you should review that design?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few links to build on what we have learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'MediatR: [https://adpg.link/ZQap](https://adpg.link/ZQap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get rid of setting `ProductId` manually in the Clean Architecture with MediatR
    project, you can use the open-source project `HybridModelBinding` or read the
    official documentation about custom model binding and implement your own:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom Model Binding in ASP.NET Core: [https://adpg.link/65pb](https://adpg.link/65pb)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Damian Edward’s MinimalApis.Extensions project on GitHub: [https://adpg.link/M6zS](https://adpg.link/M6zS)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ForEvolve.DependencyInjection` is an open-source project that adds support
    for contextual dependency injection and more: [https://adpg.link/myW8](https://adpg.link/myW8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CQS stands for Command-Query Separation. It's a software design principle that
    separates operations that change the state of an object (commands) from those
    that return data (queries). This helps in minimizing side effects and preventing
    unexpected changes in program behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, you can. The goal of the Mediator pattern is to mediate communication between
    colleagues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the original sense of CQS: no, a command can’t return a value. The idea
    is that a query reads data while commands mutate data. A command can return a
    value in a looser sense of CQS. For example, nothing stops a create command from
    returning the created entity partially or totally. You can always trade a bit
    of modularity for a bit of performance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MediatR is a free, open-source project licensed under Apache License 2.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, you should. Using Marker Interfaces to add metadata is generally wrong.
    Nevertheless, you should analyze each use case individually, considering the pros
    and cons before jumping to a conclusion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
