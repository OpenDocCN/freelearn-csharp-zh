- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Generating Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成代码
- en: So far in the book, we’ve looked at how powerful metaprogramming can be in .NET
    at runtime. Doing everything at runtime has the benefit of the flexibility to
    adapt to things that occur at runtime. The downside of doing this at runtime is
    that it has a performance impact. This is where the C# Roslyn compiler really
    shines. We had the capability to generate code in the past with commercial products
    such as PostSharp ([https://www.postsharp.net/](https://www.postsharp.net/)) or
    **Intermediate Language** (**IL**) weaving, using projects such as Fody ([https://github.com/Fody/Fody](https://github.com/Fody/Fody))
    But with Roslyn, code generation has truly been democratized and made easy for
    anyone to do.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中我们已经探讨了元编程在.NET运行时是多么强大。在运行时做所有事情的好处是能够适应运行时发生的事情。在运行时做这件事的缺点是它会影响性能。这正是C#
    Roslyn编译器真正发光的地方。我们过去有能力使用像PostSharp ([https://www.postsharp.net/](https://www.postsharp.net/))
    或**中间语言**（**IL**）编织这样的商业产品来生成代码，使用Fody ([https://github.com/Fody/Fody](https://github.com/Fody/Fody))等项目。但有了Roslyn，代码生成真正实现了民主化，并且变得对任何人来说都很容易做到。
- en: Personally, I’ve worked with all the techniques throughout the years, and finally,
    with Roslyn, I can realize a lot of the metaprogramming I like to do without sacrificing
    performance. And I can do so in a more consistent way than before.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我多年来一直使用所有这些技术，最终，通过Roslyn，我可以在不牺牲性能的情况下实现我喜欢的许多元编程。而且我可以以一种比以前更一致的方式做到这一点。
- en: The C# Roslyn compiler enables this by allowing developers to be part of its
    compilation pipeline through a set of APIs. With the APIs, we can investigate
    the code that’s there and reason about it and then generate new code, which will
    then be compiled and incorporated into the final binary.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C# Roslyn编译器通过允许开发者通过一组API参与其编译管道来实现这一点。有了这些API，我们可以调查现有的代码，对其进行分析，然后生成新的代码，这些代码将被编译并集成到最终的二进制文件中。
- en: In this chapter, we’ll explore how to leverage Roslyn compiler extensions for
    generating code, taking a deep dive into the specifics of generating code at compile
    time. We’ll learn how to examine syntax trees and generate additional code, and
    even look at how to use Roslyn to generate text reports from your code via metadata.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用Roslyn编译器扩展来生成代码，深入探讨在编译时生成代码的细节。我们将学习如何检查语法树并生成额外的代码，甚至看看如何使用Roslyn通过元数据从代码中生成文本报告。
- en: 'We will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Generating additional code for the Roslyn compiler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Roslyn编译器生成额外的代码
- en: (Ab)using the compiler to generate not just C# code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （滥用）编译器来生成不仅仅是C#代码
- en: Improving the developer experience
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高开发者体验
- en: By the end of this chapter, you’ll have a strong grasp of how to use Roslyn
    to generate code at compile time, and you’ll have a toolkit of techniques and
    best practices for implementing metaprogramming techniques in C# that leverage
    the power of the Roslyn compiler platform. So, let’s dive in!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深刻理解如何使用Roslyn在编译时生成代码，并且你将拥有一套技术和最佳实践的工具包，用于在C#中实现利用Roslyn编译器平台能力的元编程技术。因此，让我们深入探讨吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to this chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter16](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter16))
    and builds on top of the **Fundamentals** code, which can also be found on GitHub
    ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章特定的源代码可以在GitHub上找到（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter16](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter16)），并且基于**基础**代码，该代码同样可在GitHub上找到（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)）。
- en: Generating additional code for the Roslyn compiler
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Roslyn编译器生成额外的代码
- en: One of the most powerful capabilities of the Roslyn compiler platform is the
    ability to generate additional code at compile time. This means that we can create
    new C# code during the compilation process and have it compiled alongside the
    rest of our code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn编译器平台最强大的功能之一是能够在编译时生成额外的代码。这意味着我们可以在编译过程中创建新的C#代码，并将其与其他代码一起编译。
- en: We will look into how you can leverage Roslyn to generate additional code for
    the compiler. This is super helpful and can help increase your and your team’s
    productivity by removing the need for repetitive tasks. Since you’re working inside
    the compiler, you’ll have to work with the language the compiler understands and
    how it represents code – **Abstract Syntax** **Trees** (**ASTs**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何利用 Roslyn 生成编译器的额外代码。这非常有用，可以帮助提高你和你的团队的生产力，通过消除重复性任务的需求。由于你在编译器内部工作，你将不得不使用编译器理解的语言以及它表示代码的方式——**抽象语法树**（**ASTs**）。
- en: ASTs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASTs
- en: An **AST** is a data structure used to represent the structure of source code.
    You can compare it to what you already find in the .NET Expression APIs, as we
    saw in *Chapter 7*, *Reasoning about Expressions*. It is a hierarchy consisting
    of nodes that represent the code elements found in the language, such as classes,
    methods, fields, and properties. The outcome from the compiler from the AST is
    in its final stage of the binary IL code. While Expressions do this at runtime
    and are mutatable at runtime, ASTs are static when entering the final stage of
    the compiler pipeline. However, until the final stage, the AST can be reasoned
    about and changed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**AST** 是一种用于表示源代码结构的数据结构。你可以将其与我们在第 7 章“推理表达式”中看到的 .NET 表达式 API 中的内容进行比较。它是一个由表示语言中找到的代码元素（如类、方法、字段和属性）的节点组成的层次结构。编译器从
    AST 生成的结果是其最终阶段的二进制 IL 代码。虽然表达式在运行时执行此操作并且可以在运行时进行修改，但 AST 在进入编译器管道的最终阶段时是静态的。然而，在最终阶段之前，AST
    可以被推理并修改。'
- en: The AST is constructed by parsing the source code, interpreting all the keywords
    and variables, and breaking it down into nodes, which then sit together in a tree-like
    structure. ASTs are used as an intermediate representation of code within compilers
    or code analysis tools. Once the source code has been converted into an AST, it
    becomes much easier to analyze and manipulate the code. For example, a tool might
    use an AST to identify potential bugs or transform the code in some way.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: AST 是通过解析源代码、解释所有关键字和变量，并将其分解为节点来构建的，这些节点随后以树状结构组合在一起。AST 被用作编译器或代码分析工具中代码的中间表示形式。一旦源代码被转换为
    AST，分析和处理代码就变得容易得多。例如，一个工具可能使用 AST 来识别潜在的错误或以某种方式转换代码。
- en: One of the key benefits of Roslyn is its extensibility. Because Roslyn is open
    source and provides a rich set of APIs for working with the AST, developers can
    easily create their own code analysis tools that leverage the compiler’s AST.
    For example, a developer might create a tool that analyzes code for security vulnerabilities,
    or a tool that automatically generates documentation for a code base.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn 的一个关键优势是其可扩展性。因为 Roslyn 是开源的，并提供了一套丰富的 API 用于处理抽象语法树（AST），开发者可以轻松创建自己的代码分析工具，利用编译器的
    AST。例如，开发者可能创建一个分析代码安全漏洞的工具，或者一个自动为代码库生成文档的工具。
- en: 'To make it easy for developers to extend Roslyn, the platform provides a number
    of extensibility points, such as the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让开发者更容易扩展 Roslyn，平台提供了一系列扩展点，例如以下内容：
- en: '**Syntax trees**: Developers can create their own syntax trees to represent
    code, and use them with the Roslyn APIs'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法树**：开发者可以创建自己的语法树来表示代码，并使用 Roslyn API'
- en: '**Syntax rewriters**: Developers can create syntax rewriters that transform
    the AST in various ways, such as renaming variables or extracting methods'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法重写器**：开发者可以创建语法重写器，以各种方式转换 AST，例如重命名变量或提取方法'
- en: '**Diagnostics**: Developers can create their own diagnostics that identify
    issues with code, such as potential bugs or style violations'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诊断**：开发者可以创建自己的诊断，以识别代码中的问题，例如潜在的错误或样式违规'
- en: '**Code fix providers**: Developers can create code fix providers that automatically
    fix any issues identified by diagnostics'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码修复提供者**：开发者可以创建代码修复提供者，自动修复诊断中识别出的任何问题'
- en: With these extensibility points, Roslyn makes it easy for developers to create
    extensions that can improve the quality of the code written or improve productivity
    by automatically generating plumbing code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些扩展点，Roslyn 使得开发者能够轻松创建扩展，这些扩展可以改善所编写的代码质量，或者通过自动生成管道代码来提高生产力。
- en: Compiler theory and how ASTs work is a big topic on its own, something that
    is outside the scope of this book. Instead, let's get our hands dirty and get
    a glimpse of what can be done.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器理论和 AST 的工作原理是一个很大的主题，这超出了本书的范围。相反，让我们动手实践，看看可以做什么。
- en: Application metrics
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序指标
- en: An important aspect of running systems in production is observability. By observability,
    I mean the ability to observe important aspects of an application. Logging is
    one of these aspects, where you instrument your code with log messages that get
    written and captured by a log search indexer. Logging can be very verbose, so
    it is not ideal for simple measurement values, such as counters, gauges, or histograms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中运行系统的一个重要方面是可观察性。通过可观察性，我指的是观察应用程序重要方面的能力。日志是这些方面之一，其中你使用日志消息对你的代码进行仪表化，这些日志消息会被写入并被日志搜索索引器捕获。日志可能非常冗长，因此它不适合简单的测量值，如计数器、仪表或直方图。
- en: With the release of .NET 6, Microsoft introduced a namespace called **System.Diagnostics.Metrics**.
    The classes in this new namespace are perfect for when you want to observe values
    that change over time. In addition to this, there are packages out there that
    support **OpenTelemetry** ([https://opentelemetry.io](https://opentelemetry.io)),
    enabling you to capture the different values in popular collectors such as Prometheus,
    Azure AppInsight, and more. For our sample, we will just be using the console
    viewer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着.NET 6的发布，微软引入了一个名为**System.Diagnostics.Metrics**的命名空间。当您想要观察随时间变化的值时，这个新命名空间中的类是完美的。除此之外，还有一些支持**OpenTelemetry**（[https://opentelemetry.io](https://opentelemetry.io)）的包，这使得您能够捕获像Prometheus、Azure
    AppInsight等流行收集器中的不同值。对于我们的示例，我们只将使用控制台查看器。
- en: With how Microsoft has built support for metrics, it’s very easy to use while
    it lacks the nice and structured approach Microsoft built for logging. To see
    the issue, we’ll start by using the metrics as intended from the out-of-the-box
    experience and then improve on it. Let’s get started!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 微软构建了对指标的支持，使用起来非常方便，尽管它缺乏微软为日志构建的优雅和结构化方法。为了看到问题，我们将首先从开箱即用的体验开始使用指标，然后对其进行改进。让我们开始吧！
- en: Let’s start by creating a new project for the chapter. You should create this
    new project next to the **Fundamentals** project you have been using throughout
    the book and also the **Roslyn.Extensions** project that was established in [*Chapter
    15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn* *Compiler Extensions*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先为这一章创建一个新的项目。你应该在本书中使用的**Fundamentals**项目旁边创建这个新项目，以及在第15章中建立的**Roslyn.Extensions**项目[*Chapter
    15*](B19418_15.xhtml#_idTextAnchor250)，*Roslyn* *编译器扩展*。
- en: 'Create a folder called **Chapter16**, change into this folder on your command
    line, and create a new web project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为**Chapter16**的文件夹，在命令行中切换到这个文件夹，并创建一个新的Web项目：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should know the basics of a web project. Let’s change it so that we can
    use controllers. Change the **Program.cs** file to look like the following:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该了解Web项目的基础知识。让我们将其修改为可以使用控制器。将**Program.cs**文件修改如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code adds the controllers to **builder.Services** and then maps all the
    controllers in your application before running the app.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将控制器添加到**builder.Services**中，然后在运行应用程序之前映射应用程序中的所有控制器。
- en: 'Since the goal is to capture metrics, you’re going to need what is called a
    **Meter**, which is used for the values you want to track. You can have multiple
    **Meter** classes for different areas of your system if you want, but it is common
    to have one per application. Add a file called **Metrics.cs** and make it look
    like the following:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于目标是捕获指标，你需要一个被称为**仪表**的东西，用于跟踪你想要的值。如果你想为系统中的不同区域创建多个**仪表**类，那也是可以的，但通常每个应用程序只有一个。添加一个名为**Metrics.cs**的文件，并使其看起来如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code pulls in the **System.Diagnostics.Metrics** namespace and then exposes
    a global **Meter** called **Chapter16**. This can then be used by any code in
    the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码引入了**System.Diagnostics.Metrics**命名空间，并公开了一个名为**Chapter16**的全局**仪表**。然后，任何应用程序中的代码都可以使用它。
- en: 'You now want to add something that creates values within the meter. Add a file
    called **EmployeesController.cs** and make it look like the following:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你想要添加一些在仪表中创建值的东西。添加一个名为**EmployeesController.cs**的文件，并使其看起来如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code introduces a web API controller with a single action that lives in
    the **/api/employees** route. The action only returns **Ok()** – an HTTP 200 status.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码引入了一个位于**/api/employees**路由的单个操作的Web API控制器。该操作仅返回**Ok()** – HTTP 200状态。
- en: Important note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For this chapter, we’re not focused on the functionality of what we’re building
    but rather focused on the technical problem we’re trying to solve. For this reason,
    we also make it accept an HTTP **GET**. Normally, it would be an HTTP **POST**
    and also include a payload with details about the employee to register.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们不是关注我们正在构建的功能，而是关注我们试图解决的技術问题。因此，我们也让它接受 HTTP **GET** 请求。通常，它会是 HTTP
    **POST** 请求，并包含有关要注册的员工的详细信息负载。
- en: 'Let’s instrument the code with a counter for counting the number of registered
    employees. To do this, you’ll need to add a couple of **using** statements at
    the top of the **EmployeeController.cs** file:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用一个计数器来测量已注册员工的数量来对代码进行度量。为此，你需要在 **EmployeeController.cs** 文件的顶部添加几个 **using**
    语句：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now you can add a counter in the **EmployeesController** class. Add the following
    at the top of the class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在 **EmployeesController** 类中添加一个计数器。在类的顶部添加以下内容：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code introduces a counter that is created using the global meter. It is
    created statically so that we don’t create multiple instances of the same counter
    in the same application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码引入了一个使用全局计量器创建的计数器。它是静态创建的，这样我们就不需要在同一个应用程序中创建多个相同的计数器实例。
- en: 'To use the counter, change the **Register()** method to look like the following:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用计数器，将 **Register()** 方法修改成以下样子：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code uses the **_registeredEmployees** counter by calling the **Add()**
    method on it. It also passes along tags, which it sets up before calling **Add()**.
    Tags are a way to group values being added. The counter, from a top level, will
    then aggregate all values tagged, while you can monitor each individual tagged
    value on its own. This is super helpful for breaking down the metrics you want
    to monitor. The **Register()** method breaks down the values by year, month, and
    day.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过在 **_registeredEmployees** 计数器上调用 **Add()** 方法来使用该计数器。它还传递了标签，这些标签是在调用 **Add()**
    之前设置的。标签是一种将添加的值分组的方式。从顶级来看，计数器将聚合所有标记的值，而你可以在自己的标签上单独监控每个值。这对于分解你想要监控的指标非常有帮助。**Register()**
    方法通过年份、月份和日期来分解值。
- en: Important note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Tag values are **object**. You could pass it a **DateOnly** instance instead,
    but this illustrates the use of multiple tags.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 标签值是 **对象**。你也可以传递一个 **DateOnly** 实例，但这说明了多个标签的使用。
- en: 'With the first counter in place, it is time to see what this actually looks
    like. To do so, you need to install a tool called **dotnet-counters**. This is
    done by running the following in your terminal:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在放置了第一个计数器之后，是时候看看这实际上是什么样子了。为此，你需要安装一个名为 **dotnet-counters** 的工具。这可以通过在终端中运行以下命令来完成：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then. you can start your application by running this:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以通过运行以下命令来启动你的应用程序：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see an output similar to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下类似的内容：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In another terminal, you can start the metrics monitor by running the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中，你可以通过运行以下命令来启动指标监控器：
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should then see something like the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下类似的内容：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since there haven’t been any requests yet to the API endpoint, the value won’t
    show up yet. Keep the monitor running and open a browser and navigate to the endpoint
    (for example, **http://localhost:5000/api/employees**); you should then see something
    like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于还没有对 API 端点发起任何请求，所以值目前不会显示。保持监控器运行，并在浏览器中导航到端点（例如，**http://localhost:5000/api/employees**）；你应该会看到以下类似的内容：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The value will be sampled once per second. If you hit your browser multiple
    times, you should see **0** at the end of the line increase and then fall back
    to **0**. This is expected as it just shows the current measurements and not an
    aggregate over time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 值将每秒采样一次。如果你多次点击浏览器，你应该会看到行尾的 **0** 增加，然后回落到 **0**。这是预期的，因为它只显示当前的测量值，而不是随时间聚合的值。
- en: Even though the metrics API in .NET is simple and easy to use, it can quite
    easily become very verbose, especially when you have tags you want to associate.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 .NET 中的指标 API 简单易用，但它很容易变得非常冗长，尤其是当你想要关联标签时。
- en: Improving the developer experience
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高开发者体验
- en: In your business code, it looks strange to have the setup code for metrics on
    every method. It is also very verbose and cumbersome. Imagine an evolved application
    with a lot of metrics you want to collect; it kinda becomes messy. You can obviously
    clean this up by encapsulating the metrics, either with methods in the classes
    that need metrics or pulled out into their own classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的业务代码中，每个方法上都有度量指标的设置代码看起来很奇怪。这也非常冗长且繁琐。想象一下，在一个已经发展并需要收集大量度量的应用中；这会变得有些混乱。你可以显然通过封装度量指标来清理这个问题，要么在需要度量的类中使用方法，要么将它们提取到它们自己的类中。
- en: However, I quite like the approach Microsoft has to logs, as we saw in [*Chapter
    14*](B19418_14.xhtml#_idTextAnchor219), *Aspect-Oriented Programming*. For its
    approach to logging, it relies on a code generator that runs at compile time and
    puts in code that gets included in the finished binary.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我相当喜欢微软对日志的处理方法，正如我们在**第14章**中看到的，*面向方面编程*。对于日志处理，它依赖于一个在编译时运行的代码生成器，并将代码放入最终的二进制文件中。
- en: 'Let’s mimic this and create an improved developer experience:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模仿这个方法，并创建一个改进的开发者体验：
- en: 'Within the **Fundamentals** project, create a folder called **Metrics**. In
    this folder, add a file called **CounterAttribute.cs** and make it look like the
    following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Fundamentals**项目中，创建一个名为**Metrics**的文件夹。在这个文件夹中，添加一个名为**CounterAttribute.cs**的文件，并使其看起来如下：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code introduces an attribute that represents a counter. Counters can have
    a name and description associated with them. It is a generic attribute, allowing
    you to specify the type used for the counter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码引入了一个表示计数器的属性。计数器可以有一个与之关联的名称和描述。这是一个通用属性，允许你指定用于计数器的类型。
- en: 'In the **Metrics** folder in the **Fundamentals** project, add a file called
    **GlobalMetrics.cs** and make it look like the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Fundamentals**项目的**Metrics**文件夹中，添加一个名为**GlobalMetrics.cs**的文件，并使其看起来如下：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This introduces a globally accessible **Meter** instance, which will make it
    predictable for the code generator you’ll be building, as it will need access
    to this. However, it defaults to a meter called **Global**, which we want to override.
    Open the **Program.cs** file within **Chapter16** and add the following at the
    top of the file after the **using** statements:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这引入了一个全局可访问的**Meter**实例，这将使你将要构建的代码生成器更容易预测，因为它需要访问这个实例。然而，它默认使用名为**Global**的计量器，我们希望覆盖它。打开**Chapter16**中的**Program.cs**文件，并在**using**语句之后添加以下内容：
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The goal of this chapter is to provide a simpler way of doing metrics. This
    will be done through the technique of creating a partial class providing method
    signatures without implementations. The source code generator will create an implementation
    of the partial class and provide implementations for each of the methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是提供一个更简单的方式来执行度量。这将通过创建一个提供方法签名但不提供实现的局部类来实现。源代码生成器将创建局部类的实现并为每个方法提供实现。
- en: 'Let’s add the metrics file for **EmployeesController**. Add a file called **Employees**
    **ControllerMetrics.cs** and add the following to it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为**EmployeesController**添加度量文件。添加一个名为**EmployeesControllerMetrics.cs**的文件，并在其中添加以下内容：
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code sets up a static partial class, which is important as this will be
    a criterion for finding which classes to generate source code for. All counters
    are then represented as methods with a given name and a **[Counter]** attribute
    with details. Every parameter on the method will be used as a tag.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码设置了一个静态的局部类，这对于确定要为哪些类生成源代码是一个重要的标准。所有计数器都表示为具有给定名称和**[Counter]**属性（包含详细信息）的方法。方法上的每个参数都将用作标签。
- en: You’ve now prepared the basics needed for the source code generator to be able
    to work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经为源代码生成器能够工作准备了所需的基本内容。
- en: Setting up the code template
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置代码模板
- en: The code generator will generate the code that will implement partial classes.
    To do this, you’ll use a template file that represents the source code to generate.
    As a template language, you’re going to be using something called **Handlebars**
    ([https://handlebarsjs.com](https://handlebarsjs.com)). There is a .NET implementation
    of this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成器将生成实现局部类的代码。为此，你将使用一个表示要生成的源代码的模板文件。作为一个模板语言，你将使用一个叫做**Handlebars**的东西([https://handlebarsjs.com](https://handlebarsjs.com))。这有一个.NET实现。
- en: 'Open the **Roslyn.Extensions.csproj** file in the **Roslyn.Extensions** folder
    and add the following package reference in an **ItemGroup** with the other package
    references:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **Roslyn.Extensions.csproj** 文件，该文件位于 **Roslyn.Extensions** 文件夹中，并在包含其他包引用的
    **ItemGroup** 中添加以下包引用：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The **PrivateAssets="all"** attribute instructs it to be a reference only for
    this project and only be used with the extension itself, meaning that any assemblies
    from **Handlebars** will not be included in any projects referencing this project.
    In addition, you have to set **GeneratePathProperty="true"**. This will create
    a variable specific to the package and allow us to instruct which specific assembly
    of **Handlebars** to use; otherwise, the compiler will say **FileNotFoundError**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**PrivateAssets="all"** 属性指示它仅为此项目提供引用，并且只能与扩展本身一起使用，这意味着来自 **Handlebars**
    的任何程序集都不会包含在引用此项目的任何项目中。此外，您必须设置 **GeneratePathProperty="true"**。这将创建一个特定于包的变量，并允许我们指定要使用的
    **Handlebars** 的特定程序集；否则，编译器将显示 **FileNotFoundError**。'
- en: 'To specify the correct assembly, add the following to **Roslyn.Extensions.csproj**
    in the **Roslyn.Extensions** folder at the end of the file, within the **Project**
    tag:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定正确的程序集，请将以下内容添加到 **Roslyn.Extensions.csproj** 文件中，该文件位于 **Roslyn.Extensions**
    文件夹的末尾，在 **Project** 标签内：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With **Handlebars** properly installed, you’re ready to create the template
    you need for generating the code. Before you create the template, you’ll need
    to set up all the types of data you’ll pass to the template.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确安装了 **Handlebars** 之后，您就可以创建生成代码所需的模板了。在创建模板之前，您需要设置所有将传递给模板的数据类型。
- en: 'In the **Roslyn.Extensions** folder, create a folder called **Metrics**. Add
    a file called **MetricsTemplateData.cs** and add the following to it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Roslyn.Extensions** 文件夹中，创建一个名为 **Metrics** 的文件夹。添加一个名为 **MetricsTemplateData.cs**
    的文件，并将其内容添加如下：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**MetricsTemplateData** will be the root object being passed to the template.
    It contains the namespace for the generated code and then the class name for the
    class that will be generated. It then goes on to hold a collection of all the
    counters it will generate for.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**MetricsTemplateData** 将是传递给模板的根对象。它包含生成代码的命名空间，然后是生成类的类名。然后继续包含它将生成的所有计数器的集合。'
- en: 'For the counter definitions, add a file called **CounterTemplateData.cs** and
    add the following to it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计数器定义，添加一个名为 **CounterTemplateData.cs** 的文件，并将其内容添加如下：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The **CounterTemplateData** type holds information about the type of counter,
    the method name representing it, the name of the counter, and a description to
    be used with the counter. Lastly, it holds all the tags associated with the counter
    when called.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**CounterTemplateData** 类型包含有关计数器类型、表示它的方法名称、计数器名称以及与计数器一起使用的描述的信息。最后，它包含在调用时与计数器关联的所有标签。'
- en: 'For the tag definition, add a file called **CounterTagTemplateData.cs** and
    make it look like the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标签定义，添加一个名为 **CounterTagTemplateData.cs** 的文件，并使其看起来如下：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The tag contains a type, which will be reflected in the signature of the method
    being called and then the name.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 标签包含一个类型，这将在被调用方法的签名中反映出来，然后是名称。
- en: With the object definitions for the parameters for the template, it’s time to
    add the template.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板的参数对象定义完成后，是时候添加模板了。
- en: 'In the **Roslyn.Extensions** folder, create a folder called **Templates**,
    and within the **Templates** folder, add a file called **Metrics.hbs** and make
    it look like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Roslyn.Extensions** 文件夹中，创建一个名为 **Templates** 的文件夹，并在 **Templates** 文件夹中添加一个名为
    **Metrics.hbs** 的文件，并使其看起来如下：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Within the template, there is data context. The top-level item will be the **MetricsTemplateData**
    instance. This is where the **{{Namespace}}** and **{{ClassName}}** values are
    inserted. The use of **{{}}** with text represents values that can be replaced,
    and the text itself is then a property that exists in the current context it’s
    in. When the value in the quotes starts with a **#** symbol, it uses a function
    to resolve it. Handlebars have some automatic magic and recognize enumerables,
    such as **Counters**. Handlebars will loop through these and anything within its
    scope will be output for each instance. The template uses these techniques throughout
    to replace all the values found in the objects passed to it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，存在数据上下文。顶级项将是**MetricsTemplateData**实例。这是插入**{{Namespace}}**和**{{ClassName}}**值的地方。使用**{{}}**与文本表示可替换的值，而文本本身是当前上下文中存在的属性。当引号内的值以**#**符号开头时，它使用一个函数来解析它。Handlebars有一些自动魔法，可以识别可枚举的，如**Counters**。Handlebars将遍历这些，并且在其作用域内的任何内容都将为每个实例输出。模板通过这些技术在整个过程中替换传递给它的对象中找到的所有值。
- en: 'The end result for **EmployeesControllerMetrics** will end up rendered like
    the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**EmployeesControllerMetrics**的最终结果将呈现如下：'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the template in place, we need a way to programmatically access it in the
    code generator. To enable that, you want to embed any template files into the
    assembly at compile time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板就绪的情况下，我们需要一种在代码生成器中程序化访问它的方法。为了实现这一点，你希望在编译时将任何模板文件嵌入到程序集中。
- en: 'Open **Roslyn.Extensions.csproj** and add an **ItemGroup** within the **Project**
    tag that looks like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**Roslyn.Extensions.csproj**，在**Project**标签内添加一个类似以下的**ItemGroup**：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The **EmbeddedResource** tag instructs the compiler to include all **hbs** files
    within the **Templates** folder and make them embedded resources of the assembly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**EmbeddedResource**标签指示编译器将**Templates**文件夹内的所有**hbs**文件包含在内，并将它们作为程序集的嵌入式资源。'
- en: Embedded resources are part of the assembly and are referred to as resources.
    They can be accessed directly on the assembly they belong to.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式资源是程序集的一部分，被称为资源。它们可以直接在它们所属的程序集上访问。
- en: 'Let’s create a helper class to get access to the template and future templates
    you’ll be adding. In the **Templates** folder of the **Roslyn.Extensions** project,
    add a file called **TemplateTypes.cs**. Make it look like the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个辅助类来获取访问模板和未来将添加的模板。在**Roslyn.Extensions**项目的**Templates**文件夹中添加一个名为**TemplateTypes.cs**的文件。使其看起来如下：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code introduces a private method called **GetTemplate()** on the **TemplateTypes**
    class. It leverages **GetManifestResourceStream()** on the assembly instance.
    The compiler will by convention make namespaces of the folder and any subfolder
    of the embedded resource. Accessing the resources will then be like accessing
    types in it. Since the template sits in the **Templates** folder, it will be in
    the same folder and then the same namespace as the **TemplateTypes** class. This
    is therefore used as the prefix for the name of the template before the name of
    the template. The code then uses a **StreamReader** to read the resource stream
    to the end, giving you a string holding the template.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在**TemplateTypes**类中引入了一个名为**GetTemplate()**的私有方法。它利用程序集实例上的**GetManifestResourceStream()**。按照惯例，编译器将文件夹及其任何子文件夹的命名空间。访问资源将类似于访问其中的类型。由于模板位于**Templates**文件夹中，它将与**TemplateTypes**类的同一文件夹和同一命名空间相同。因此，这被用作模板名称前缀的前缀。然后代码使用**StreamReader**读取资源流到末尾，给你一个包含模板的字符串。
- en: At the top of the **TemplateTypes** class sits a property representing the **Metrics**
    template.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**TemplateTypes**类顶部有一个属性表示**Metrics**模板。'
- en: Now we have the template and code for accessing it, you can move on to creating
    the code generator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了访问它的模板和代码，你可以继续创建代码生成器。
- en: Building the source code generator
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建源代码生成器
- en: In order for the code generator to generate code only for classes that match
    the criteria, you need a syntax receiver that gets called on every node from the
    source code being compiled.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码生成器只为符合标准的类生成代码，你需要一个在每个源代码编译节点上被调用的语法接收器。
- en: 'Add a file called **MetricsSyntaxReceiver.cs** in the **Metrics** folder within
    the **Roslyn.Extensions** project. Add the following code to it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Roslyn.Extensions**项目的**Metrics**文件夹内添加一个名为**MetricsSyntaxReceiver.cs**的文件。向其中添加以下代码：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code implements the **ISyntaxReceiver** interface with the **OnVisitSyntaxNode()**
    method, which will be called on every AST node from the compiler. The purpose
    of **MetricsSyntaxReceiver** is to narrow down what classes are of interest for
    code generation. First, it filters down by requiring it to be a **class**, then
    it looks as if the class is partial and static. The last filter is to look for
    any members of the class, looking for static partial methods. If all of the criteria
    are met, it will add the class to a candidate list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码实现了**ISyntaxReceiver**接口，并带有**OnVisitSyntaxNode()**方法，该方法将在编译器的每个AST节点上被调用。**MetricsSyntaxReceiver**的目的在于缩小对代码生成感兴趣的类的范围。首先，它通过要求它必须是**类**来过滤，然后看起来这个类是部分静态的。最后的过滤是查找类的任何成员，寻找静态部分方法。如果所有标准都满足，它将把该类添加到候选列表中。
- en: 'With the receiver filtering down, it’s time for the generator itself to be
    set up. Next to the **MetricsSyntaxReceiver.cs** file, add a file called **MetricsSourceGenerator.cs**.
    Add the following code to it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收器过滤完成后，现在是设置生成器本身的时候了。在**MetricsSyntaxReceiver.cs**文件旁边，添加一个名为**MetricsSourceGenerator.cs**的文件。将以下代码添加到其中：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code creates a class called **MetricsSourceGenerator**, which implements
    the **ISourceGenerator** interface with its **Execute()** and **Initialize()**
    methods. For the generator to work, you also have to add the **[Generator]** attribute.
    In the **Initialize()** method, the code registers the syntax receiver you put
    in.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个名为**MetricsSourceGenerator**的类，该类实现了**ISourceGenerator**接口，并带有其**Execute()**和**Initialize()**方法。为了生成器能够工作，您还必须添加**[Generator]**属性。在**Initialize()**方法中，代码注册了您放入的语法接收器。
- en: 'In the **Execute()** method is where all the magic will happen. Let’s start
    by adding the following to the body of the **Execute()** method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Execute()**方法中，所有魔法都将发生。让我们首先将以下内容添加到**Execute()**方法的主体中：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code is expecting **SyntaxReceiver** to be **MetricsSyntaxReceiver**; if
    it’s not, it’s just returned. Then, it goes on to get an instance of the type
    definition for the **CounterAttribute** type. Notice the name is a little strange;
    **CounterAttribute'1**. This is because the type is a generic type and internally
    in .NET, the type will get the postfix with a number of saying the number of generic
    arguments it has.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码期望**SyntaxReceiver**是**MetricsSyntaxReceiver**；如果不是，它就返回。然后，它继续获取**CounterAttribute**类型定义的实例。注意名称有点奇怪；**CounterAttribute'1**。这是因为该类型是泛型类型，在.NET内部，类型将根据泛型参数的数量后缀一个数字。
- en: For all the candidates **MetricsSyntaxReceiver** has found, the code loops through
    and sets up a **MetricsTemplateData** instance for the class. It then gets what
    is known as the semantic model based on the syntax tree of the class. The semantic
    model in Roslyn provides a deeper understanding of the meaning of code beyond
    its syntax. It can be used for tasks such as name binding, type checking, error
    checking, and automated refactoring.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**MetricsSyntaxReceiver**找到的所有候选者，代码将循环遍历并为类设置一个**MetricsTemplateData**实例。然后，它根据类的语法树获取所谓的语义模型。Roslyn中的语义模型提供了对代码意义的更深入理解，这超出了其语法。它可以用于诸如名称绑定、类型检查、错误检查和自动化重构等任务。
- en: Classes have members and the code walks through all the members and filters
    and skips those that are not methods. From the semantic model, it gets the declared
    symbol of the method, which lets us nicely access the attributes on it. It then
    looks for **CounterAttribute**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类有成员，代码遍历所有成员并过滤掉那些不是方法的成员。从语义模型中，它获取方法的声明符号，这使得我们可以很好地访问其上的属性。然后，它查找**CounterAttribute**。
- en: At the very end, it generates the source code from the template, but only if
    there are any counters to generate for. It provides the source code by using the
    **AddSource()** method provided by **GeneratorExecutionContext**. The convention
    for generated files is to include the type name and then postfix it with **.g.cs**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后，它从模板生成源代码，但仅当有要生成的计数器时才会这样做。它通过使用**GeneratorExecutionContext**提供的**AddSource()**方法来提供源代码。生成的文件约定是包含类型名称，然后后缀为**.g.cs**。
- en: 'For the generator to kick in, it needs the counters. Add the following code
    to the **Execute()** method, replacing the **//** **Generate** comment:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动生成器，它需要计数器。将以下代码添加到**Execute()**方法中，替换**// Generate**注释：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code gathers the information from the attribute and method information to
    provide the data the template needs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从属性和方法信息中收集信息，以提供模板所需的数据。
- en: That is pretty much it for the generator to work. Since we’re leaning on the
    setup done in [*Chapter 15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn Compiler
    Extensions*, all we now need to do is start using it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是生成器要做的所有事情。由于我们依赖于在[*第15章*](B19418_15.xhtml#_idTextAnchor250)中完成的设置，*Roslyn编译器扩展*，我们现在需要做的就是开始使用它。
- en: Test driving the source generator
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试源生成器
- en: 'To get the **Chapter16** code compiled and working, follow these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译并使**Chapter16**代码工作，请按照以下步骤操作：
- en: 'First, you need to add a reference to the **Fundamentals** project:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要为**基础**项目添加一个引用：
- en: '[PRE30]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, you need a reference to the **Roslyn.Extensions** project. This needs
    to be a little bit different since you want it to automatically use the generator.
    Add a **ProjectReference** in the **Chapter16.csproj** file next to the reference
    to the **Fundamentals** project, looking like the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要**Roslyn.Extensions**项目的引用。这需要稍微不同一些，因为您希望它自动使用生成器。在**Chapter16.csproj**文件中，在**基础**项目的引用旁边添加一个**ProjectReference**，如下所示：
- en: '[PRE31]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This instructs the reference to use the analyzer and not include any of its
    assemblies in the output of **Chapter16**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示引用使用分析器，并且不在**第16章**的输出中包含其任何程序集。
- en: 'To start using the new way of doing metrics, you’ll need to change the **EmployeeController**
    class. Open the **EmployeeController.cs** file in the **Chapter16** folder and
    change the **Register()** method to look like the following:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用新的指标方式，您需要更改**EmployeeController**类。在**Chapter16**文件夹中打开**EmployeeController.cs**文件，并将**Register()**方法更改为以下内容：
- en: '[PRE32]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code now uses the new partial class instead of dealing with the counter
    and tags itself.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在使用新的部分类，而不是自己处理计数器和标签。
- en: 'Perform a build on the **Chapter16** project:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**第16章**项目上执行构建：
- en: '[PRE33]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Within the **obj** folder, you can now see the result of the source generator:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在**obj**文件夹中，您现在可以看到源生成器的结果：
- en: '![](img/B19418_16_01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_16_01.jpg)'
- en: Figure 16.1 – Generated file in the filesystem
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 文件系统中的生成文件
- en: 'Open **EmployeesControllerMetrics.g.cs** and confirm you have the expected
    result:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**EmployeesControllerMetrics.g.cs**并确认您有预期的结果：
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run your project and then start the monitor by running this:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的项目，然后通过运行以下命令启动监控：
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And then trigger the API by using a browser and navigating to the endpoint
    (for example, **http://localhost:5000/api/employees**). You should see an output
    similar to the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过浏览器导航到端点（例如，**http://localhost:5000/api/employees**）来触发API。您应该看到以下类似输出：
- en: '[PRE36]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This technique can be very powerful. More types of metrics can be supported
    and extended, giving you a more intuitive and simple way of working with metric
    values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以非常强大。可以支持更多类型的指标并扩展，为您提供一个更直观和简单的方式来处理指标值。
- en: Adding source code that gets compiled is very powerful and you are not limited
    to adding just partial classes; you can in fact add anything you want, which can
    be super useful. That being said, you’re not just limited to outputting source
    files for the compiler. You can produce other artifacts as well.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 添加要编译的源代码非常强大，您不仅限于添加部分类；实际上，您可以添加任何您想要的，这可以非常有用。但话虽如此，您不仅限于为编译器输出源文件。您还可以生成其他工件。
- en: (Ab)using the compiler to generate not just C# code
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （滥用）编译器来生成不仅仅是C#代码
- en: Since you can basically do anything within the code generator, you could go
    and generate anything else. One of the things we use it for in my day-to-day work
    is to generate TypeScript files from our C# code. This is super useful and we
    save a lot of time and gain consistency in the TypeScript, in line with the REST
    APIs in C#.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您基本上可以在代码生成器中做任何事情，您可以去生成其他任何东西。我们在日常工作中用它来做的一件事是从我们的C#代码生成TypeScript文件。这非常有用，我们节省了大量时间，并在TypeScript中获得了与C#
    REST API一致的一致性。
- en: Let’s go and do something that doesn’t end up in a C# file. Based on the **Fundamentals**
    project in the GitHub repository and what you have built so far in the book, you
    should have a namespace called **Fundamentals.Compliance.GDPR** and an attribute
    called **PersonalIdentifiableInformation**, which was introduced in [*Chapter
    5*](B19418_05.xhtml#_idTextAnchor083), *Leveraging Attributes*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去做一些不会最终出现在C#文件中的事情。基于GitHub仓库中的**基础**项目和您在本书中迄今为止所构建的内容，您应该有一个名为**Fundamentals.Compliance.GDPR**的命名空间和一个名为**PersonalIdentifiableInformation**的属性，该属性在[*第5章*](B19418_05.xhtml#_idTextAnchor083)中介绍，*利用属性*。
- en: This attribute is great for marking types that collect **Personally Identifiable
    Information** (**PII**) as well as the reason for collecting PII. In [*Chapter
    5*](B19418_05.xhtml#_idTextAnchor083), *Leveraging Attributes*, we used it at
    runtime to create a runtime report. What we could instead do is create this report
    at compile time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性非常适合标记收集**个人身份信息**（**PII**）的类型以及收集PII的原因。在[*第5章*](B19418_05.xhtml#_idTextAnchor083)中，*利用属性*，我们在运行时用它来创建运行时报告。我们本可以做的另一件事是在编译时创建这个报告。
- en: 'Add a file in the **Chapter16** folder called **Employee** and make it look
    like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Chapter16**文件夹中添加一个名为**Employee**的文件，并使其看起来如下所示：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The **Employee** type has its properties annotated with the **[PersonalIdentifiableInformation]**
    attribute, declaring the specific reason for collecting the information. This
    is what we want to output in a GDPR report saying which types have members that
    hold PII.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**Employee**类型具有用**[PersonalIdentifiableInformation]**属性注解的属性，声明了收集信息的具体原因。这是我们希望在GDPR报告中输出的内容，说明哪些类型具有包含PII的成员。'
- en: Building the generator
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建生成器
- en: In order for our generator to know where to output the resulting file, it will
    need a configurable property. The current directory when running in the context
    of the compiler will be the path where the compiler sits and typically a place
    you don’t have write access to write to. Besides, it is not very useful to write
    files at a random location.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的生成器知道在哪里输出结果文件，它需要一个可配置的属性。在编译器上下文中运行时的当前目录是编译器所在的位置，通常是一个您没有写入权限的地方。此外，在随机位置写入文件也不是很有用。
- en: 'Generators can have properties that get configured in the **.csproj** files.
    For them to be visible to the generator, you need to tell the compiler that the
    property should be visible. To do this, open the **Roslyn.Extensions.props** file,
    which you should have in the **Roslyn.Extensions** folder, and add an **ItemGroup**
    within the **Project** tag that looks like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器可以在**.csproj**文件中具有属性。为了让它们对生成器可见，您需要告诉编译器该属性应该是可见的。为此，打开位于**Roslyn.Extensions**文件夹中的**Roslyn.Extensions.props**文件，并在**Project**标签内添加一个看起来如下所示的**ItemGroup**：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, in the **Chapter16.csproj** file in the **Chapter16** folder, you will
    need to add a reference to the **props** file. Add the following at the top of
    the file within the **Project** tag:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**Chapter16**文件夹中的**Chapter16.csproj**文件中，您需要添加对**props**文件的引用。在**Project**标签内文件的顶部添加以下内容：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, within **PropertyGroup**, you need to add the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**PropertyGroup**内添加以下内容：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This configures the **GDPRReport** variable to point to the folder of the **Chapter16.csproj**
    file and then adds **GDPRReport.txt** to the path.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将**GDPRReport**变量配置为指向**Chapter16.csproj**文件的文件夹，然后向路径中添加**GDPRReport.txt**。
- en: As you did with the metrics source generator, you’ll need a syntax receiver
    for filtering the candidates.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在度量源生成器中所做的那样，您需要一个语法接收器来过滤候选者。
- en: 'Create a folder called **GDPR** in the **Roslyn.Extensions** project and add
    a file called **GDPRSyntaxReceiver.cs**. Make the file look like the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Roslyn.Extensions**项目中创建一个名为**GDPR**的文件夹，并添加一个名为**GDPRSyntaxReceiver.cs**的文件。使文件看起来如下所示：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The filter for this syntax receiver is a simple one. It’s interested in syntax
    nodes that are types. This would include classes and records.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法接收器的过滤器很简单。它对类型语法节点感兴趣。这包括类和记录。
- en: 'Now you need the source generator. Add a file called **GDPRSourceGenerator.cs**
    alongside the **GDPRSyntaxReceiver.cs** file and add the following to it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要源生成器。在**GDPRSyntaxReceiver.cs**文件旁边添加一个名为**GDPRSourceGenerator.cs**的文件，并将其中的以下内容添加到其中：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The code sets up the basics for the source generator and also sets up the initials
    for the **Execute()** method. It will only perform the job if **SyntaxReceiver**
    is **GDPRSyntaxReceiver**. Next, it goes and gets the **GDPRReport** variable
    from config. All values are prefixed with **build_property** for the ones coming
    from the build. It then goes on to create the report file before it gets the **PersonalIdentifiableInformationAttribute**
    type for filtering later.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码为源生成器设置了基本设置，并为**Execute()**方法设置了初始值。它只有在**SyntaxReceiver**是**GDPRSyntaxReceiver**时才会执行任务。接下来，它从配置中获取**GDPRReport**变量。所有值都以**build_property**为前缀，对于来自构建的值。然后它继续创建报告文件，在获取用于后续过滤的**PersonalIdentifiableInformationAttribute**类型之前。
- en: 'Continue the **Execute()** method with the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用以下代码**Execute()**方法：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The code looks at the candidates from the syntax receiver. If the candidate
    is a record, it enumerates the parameters of it and adds them as a symbol of interest.
    It then goes on to walk through the members of the candidate, adding them as a
    symbol of interest.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从语法接收者查看候选者。如果候选者是一个记录，它将枚举其参数并将它们作为感兴趣的符号添加。然后它继续遍历候选者的成员，并将它们作为感兴趣的符号添加。
- en: Now that you’ve collected all symbols of interest, it’s time to filter down
    only the symbols that are annotated with the **PersonalIdentifiableInformation**
    attribute.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经收集了所有感兴趣的符号，是时候过滤出仅带有**PersonalIdentifiableInformation**属性的符号了。
- en: 'Within the candidates **foreach** loop, add the following at the end:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在候选者的**foreach**循环中，在末尾添加以下内容：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The code iterates the symbols by looking at any attributes. If the symbol has
    the **[Personal** **IdentifiableInformation]** attribute, it’s added to the **memberNamesAndReason**
    list.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过查看任何属性来迭代符号。如果符号具有**[个人可识别信息]**属性，它将被添加到**memberNamesAndReason**列表中。
- en: If there are members in the **memberNamesAndReason** list, it outputs the type
    and the members with the reason.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**memberNamesAndReason**列表中有成员，它将输出类型和成员及其原因。
- en: 'Now, you can build your application (in the **Chapter16** folder):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在**第16章**文件夹中构建您的应用程序：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should now see a file called **GDPRReport.txt** in your project folder.
    Open it and confirm that you’re seeing something similar to the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在项目文件夹中看到一个名为**GDPRReport.txt**的文件。打开它，确认您看到以下内容：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Having this level of transparency in your code and the ability to show it to
    official auditors is great. It shows you have control over compliance and this
    will ultimately help you in the long run. You could also version this file by
    simply adding it to your source code repository and then during release builds,
    you could commit any changes to it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中拥有这种透明度，并能够将其展示给官方审计员是很好的。这表明您对合规性有控制权，这最终将有助于您长期发展。您还可以通过将其添加到源代码存储库来对文件进行版本控制，然后在发布构建期间，您可以提交对它的任何更改。
- en: It is different to work with extending the compiler itself, it is a somewhat
    different runtime environment from what you’d expect in normal application development.
    You’ve probably already started asking how to debug and might have experienced
    your code not working even though it should have.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与扩展编译器本身相比，这是与您在正常应用程序开发中预期的运行时环境略有不同。您可能已经开始了如何调试的询问，并且可能已经经历过代码即使应该工作却不起作用的情况。
- en: Improving the developer experience
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高开发者体验
- en: Working with the Roslyn compiler can be hard. After all, it’s running inside
    the context of the compiler. One way to ease the pain is to do unit testing and
    actually test all your code from tests, something we will look into more in [*Chapter
    17*](B19418_17.xhtml#_idTextAnchor299), *Static* *Code Analysis*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与Roslyn编译器一起工作可能很困难。毕竟，它是在编译器上下文中运行的。减轻痛苦的一种方法是通过单元测试，并实际上从测试中测试所有代码，我们将在[*第17章*](B19418_17.xhtml#_idTextAnchor299)中更详细地探讨，*静态代码分析*。
- en: Debugging
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: 'However, sometimes, you just simply need to see things with your bare eyes
    through the debugger. The technique I use for this is to add the following code
    into my Roslyn extension code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时您只需要通过调试器用肉眼查看事物。我用于此的技术是将以下代码添加到我的Roslyn扩展代码中：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, I can put breakpoints for the places at which I want to break and then
    attach the debugger. You want to attach it to the compiler and it typically shows
    up like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以在想要中断的地方设置断点，然后附加调试器。您希望将其附加到编译器上，它通常显示如下：
- en: '![](img/B19418_16_02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19418_16_02.jpg)'
- en: Figure 16.2 – Compiler process to attach to caching
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 附加到缓存的编译器过程
- en: 'Another thing that can be painful is if you’re doing changes in the extension
    and these are not reflected. There are a couple of reasons why this might be the
    case. One is that it doesn’t see any changes during an incremental build in the
    project using the extension. You can clean the build output by doing the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件可能令人痛苦的事情是，如果您在扩展中做更改，这些更改没有反映出来。这可能有几个原因。一个是它没有在项目中使用扩展的增量构建期间看到任何更改。您可以通过以下方式清理构建输出：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Otherwise, you can run the build telling it to not perform an incremental build
    as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以运行构建，告诉它不要执行增量构建，如下所示：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another condition that could occur is that compiler holds a build server in
    memory that caches things and optimizes the developer experience. Sometimes, you
    need to shut it down. You do that by issuing the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能发生的情况是编译器在内存中保留了一个构建服务器，它缓存了一些内容并优化了开发者的体验。有时，你需要关闭它。你可以通过以下方式做到这一点：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Optimization
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: A form of optimization that can be applied to source generators is to use the
    incremental source generator approach. It combines the syntax receiver and generator
    and runs consistently while the build server is running, providing code generation
    as you type in the editor (for editors that support it).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用于源生成器的一种优化形式是使用增量源生成器方法。它结合了语法接收器和生成器，在构建服务器运行时持续运行，在编辑器中输入时提供代码生成（对于支持它的编辑器）。
- en: Working with the compiler can be a bit tedious, but is totally worth it when
    you get everything working.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与编译器一起工作可能会有些繁琐，但当你让一切正常运行时，这绝对是值得的。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how to leverage Roslyn compiler extensions for
    generating code at compile time. We looked at the basics of generating additional
    code for the compiler. We also looked at how you can leverage the Roslyn source
    generators to generate files other than C#, which is a powerful technique that
    can increase productivity and also provide true business value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何利用 Roslyn 编译器扩展在编译时生成代码。我们研究了为编译器生成额外代码的基础。我们还探讨了如何利用 Roslyn 源生成器生成除
    C# 之外的文件，这是一种强大的技术，可以提高生产力，同时也提供真正的商业价值。
- en: You should now have an understanding of what C# code generators are and how
    you can implement one. And hopefully, you also have a few ideas brewing of what
    you can use it for.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经了解了 C# 代码生成器是什么以及如何实现一个。而且，希望你也已经有了一些关于如何使用它的想法。
- en: As I mentioned in the chapter, we use the compiler’s extensibility and ability
    to generate code to actually generate TypeScript code. This has proven to be a
    major productivity boost for our developers. There are some code generators already
    out there that take OpenAPI definitions and convert them into JavaScript or TypeScript,
    but they’re then limited to what this standard supports. And if you want it to
    be in a certain shape, or support a specific frontend framework, that might not
    be enough. We had these requirements and then decided on building an extension
    that supports our needs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章中提到的，我们利用编译器的可扩展性和生成代码的能力来实际生成 TypeScript 代码。这已经证明对我们的开发者来说是一个巨大的生产力提升。已经有一些代码生成器可以将
    OpenAPI 定义转换为 JavaScript 或 TypeScript，但它们随后就局限于这个标准所支持的功能。如果你希望它以某种形状存在，或者支持特定的前端框架，那么这可能就不够了。我们有了这些需求，然后决定构建一个支持我们需求的扩展。
- en: In the next chapter, we’ll take things a step further and explore how to use
    Roslyn compiler extensions for static code analysis. As you might have picked
    up thus far, I tend to focus on code quality. Coming up, we’ll explore how to
    build custom code analyzers and code fixes, and we’ll see how these tools can
    be used to automatically detect and correct coding issues.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更进一步，探讨如何使用 Roslyn 编译器扩展进行静态代码分析。正如你可能已经注意到的，我倾向于关注代码质量。接下来，我们将探讨如何构建自定义代码分析器和代码修复，我们将看到这些工具如何被用来自动检测和纠正编码问题。
