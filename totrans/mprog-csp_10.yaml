- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Convention over Configuration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约定优于配置
- en: Our programs need to be configured. Some of these configurations are things
    such as connection strings to a database or a URL for a REST API we are calling.
    These might change depending on the different environments our code is running
    in (e.g. development, testing, or production). On top of this, we often have to
    configure our code to be able to run as we expect. The type of configuration we
    do is often dictated by some third-party library or framework we’re using. In
    growing solutions, this type of configuration tends to also grow, and since configuration
    is often done at a specific point during the startup of the program, it’s not
    uncommon to end up with large files acting as dumping grounds for this type of
    thing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序需要配置。这些配置中的一些是数据库连接字符串或我们正在调用的REST API的URL等。这些可能取决于我们的代码运行的不同环境（例如，开发、测试或生产）。除此之外，我们通常还需要配置我们的代码，以便能够按预期运行。我们进行的配置类型通常由我们使用的第三方库或框架决定。在增长型解决方案中，这种类型的配置也倾向于增长，并且由于配置通常在程序启动的特定点进行，因此最终成为这种类型事物的垃圾场的情况并不少见。
- en: In this chapter, we will look into how we can leverage the power of the metadata
    we already have in running code to make code automatically configure itself and
    become more consistent as a result.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用我们在运行代码中已有的元数据的力量，使代码自动配置并因此变得更加一致。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Inversion of control and its role
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制反转及其作用
- en: Automatic ServiceCollection registrations by convention
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过约定自动进行ServiceCollection注册
- en: By end the of the chapter, you will have an idea of what conventions can do
    for you and how they can make you more productive and also allow you to create
    more consistent code bases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解约定能为你做什么，以及它们如何使你更高效，并允许你创建更一致的代码库。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter10](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter10))
    and it builds on top of the **Fundamentals** code that is found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的特定源代码可以在GitHub上找到 ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter10](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter10))，它基于可在[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)找到的**基础知识**代码。
- en: You will need Docker Desktop installed ([https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)),
    Postman ([https://www.postman.com](https://www.postman.com)), and a MongoDB editor
    such as Compass ([https://www.mongodb.com/try/download/compass](https://www.mongodb.com/try/download/compass)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装Docker Desktop ([https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/))、Postman
    ([https://www.postman.com](https://www.postman.com))以及MongoDB编辑器，如Compass ([https://www.mongodb.com/try/download/compass](https://www.mongodb.com/try/download/compass))。
- en: Inversion of control and its role
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制反转及其作用
- en: Software needs structure really fast when growing beyond one page of source
    code. Typically, you’d group things logically in types that have a specific purpose
    in your system. With your software being broken up for better maintainability,
    the different parts are then often dependent on each other to be able to perform
    the overall tasks you need it to do.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件的源代码超过一页时，软件需要快速建立结构。通常，你会根据系统中的特定目的将事物逻辑地分组到类型中。随着你的软件被拆分以更好地维护，不同的部分通常相互依赖，以便能够执行你需要它完成的整体任务。
- en: Building a module for registering users
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建用户注册模块
- en: 'Let’s build a simple system that handles a user sign-up feature exposed as
    a REST API. Start by creating a folder called **Chapter10**. Change into this
    folder in your command line and create a new web-based project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的系统，该系统处理作为REST API公开的用户注册功能。首先创建一个名为 **Chapter10** 的文件夹。在命令行中切换到该文件夹，并创建一个新的基于Web的项目：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The type of information you’d want to capture involves both personal information
    and also the user’s credentials that we want to have as part of the body of our
    API. Add a file called **RegisterUser.cs** and add the following to it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要捕获的信息类型包括个人信息以及我们希望作为我们API主体的用户凭证。添加一个名为 **RegisterUser.cs** 的文件，并将其添加以下内容：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The **RegisterUser** type takes all the different properties you want to capture
    for the user for the API. This is not what you want to store directly in a database.
    When you store this, you want to store this as two separate things – the user
    credentials and the user details. Create a file called **User.cs** and add the
    following to it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**RegisterUser** 类型包含您想要为 API 用户捕获的所有不同属性。这不是您想要直接存储在数据库中的内容。当您存储这些信息时，您希望将其存储为两个独立的部分——用户凭据和用户详细信息。创建一个名为
    **User.cs** 的文件，并将其添加以下内容：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The **User** type only captures the actual user name and the password and has
    a unique identifier for the user. Then add a file called **UserDetails** and add
    the following to it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**User** 类型仅捕获实际用户名和密码，并为用户有一个唯一的标识符。然后添加一个名为 **UserDetails** 的文件，并添加以下内容：'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**UserDetails** holds the rest of the information we will be getting from the
    **RegisterUser** type.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**UserDetails** 包含我们从 **RegisterUser** 类型中获取的其余信息。'
- en: The next thing we need is an API controller to take this and store the information
    in the database. We will be using MongoDB as a backing store.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要的是一个 API 控制器来接收这些信息并将信息存储到数据库中。我们将使用 MongoDB 作为后端存储。
- en: 'We will be relying on a third-party library to access MongoDB. Add the package
    to the project by running the following in the terminal:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依赖第三方库来访问 MongoDB。通过在终端中运行以下命令将包添加到项目中：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a file called **UsersController** and add the following to it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 **UsersController** 的文件，并将其添加以下内容：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code sets up in its constructor the database and gets the two different
    collections in which we will be storing the user information coming in. The register
    API method then takes **RegisterUser** and splits it up into the two respective
    types and inserts them into each of their MongoDB collections.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在其构造函数中设置数据库并获取我们将存储用户信息的两个不同集合。注册 API 方法然后将 **RegisterUser** 分解成两个相应的类型并将它们插入到各自的
    MongoDB 集合中。
- en: Important note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In a real system, you would obviously encrypt the password with a strong (preferably
    one-way) encryption strategy and not just store the password as clear text.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际系统中，您显然会使用强大的（最好是单向的）加密策略来加密密码，而不仅仅是将其作为明文存储。
- en: 'Open your **Program.cs** file and make it look like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的 **Program.cs** 文件，并使其看起来如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before you run the solution so far, you need to start the MongoDB server. You
    do this by using Docker. In your terminal, run the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行到目前为止的解决方案之前，您需要启动 MongoDB 服务器。您可以通过 Docker 来完成此操作。在您的终端中运行以下命令：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The command should start MongoDB as a background daemon and expose port **27017**
    so that you can connect to it. You should see something similar to the following
    line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应启动 MongoDB 作为后台守护进程并公开端口 **27017**，以便您可以连接到它。您应该看到以下类似行：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is the unique identifier of the running Docker image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行 Docker 图像的唯一标识符。
- en: 'You can now run the code you’ve created so far from your terminal:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从终端运行您到目前为止创建的代码：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should now see something similar to the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到以下类似的内容：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Testing the API
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 API
- en: With the code thus far, you now have an API that has a route of **/api/users/register**
    that accepts an HTTP POST.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的代码，现在您有一个具有 **/api/users/register** 路由的 API，该路由接受 HTTP POST 请求。
- en: 'You can test your API by using Postman with the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤使用 Postman 测试您的 API：
- en: Select **POST**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **POST**。
- en: Enter the URL for the API – **http://localhost:5000/api/user/register**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 API 的 URL – **http://localhost:5000/api/user/register**。
- en: In the **Body** tab, select **Raw** as the input and then **JSON** as the type.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Body** 选项卡中，选择 **Raw** 作为输入，然后选择 **JSON** 作为类型。
- en: Important note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The port of the URL has to match the port in the output where it says **Now
    listening on:** **http://localhost:{your port}**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: URL 的端口号必须与输出中提到的端口号匹配，即 **Now listening on:** **http://localhost:{your port}**。
- en: '![](img/B19418_10_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_10_01.jpg)'
- en: Figure 10.1 – Testing the API using Postman
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 使用 Postman 测试 API
- en: Once you’ve clicked **Send**, you should get **200 OK** at the bottom. Then
    you can open the MongoDB editor – for instance, Compass, as suggested in the pre-requisites.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Send** 后，您应该在底部获得 **200 OK**。然后您可以打开 MongoDB 编辑器——例如，Compass，如预置要求中建议的那样。
- en: 'Create a new connection to the MongoDB server and perform the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 MongoDB 服务器连接并执行以下步骤：
- en: Make sure the connection string is pointing to your MongoDB server. By default,
    it should say **mongodb://localhost:27017**, which matches the code.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保连接字符串指向您的 MongoDB 服务器。默认情况下，它应该显示 **mongodb://localhost:27017**，这与代码匹配。
- en: Click the **Connect** button.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接**按钮。
- en: '![](img/B19418_10_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19418_10_02.jpg)'
- en: Figure 10.2 – Creating a new connection
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 创建新的连接
- en: Once connected, you should see the database **TheSystem** on the left-hand side
    and, within it, the collections. Clicking the **user** collection or **user-details**,
    you should see the data you registered on the right side.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 连接成功后，你应该在左侧看到数据库**TheSystem**以及其中的集合。点击**user**集合或**user-details**，你应该在右侧看到你注册的数据。
- en: '![](img/B19418_10_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19418_10_03.jpg)'
- en: Figure 10.3 – Registered data
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 注册的数据
- en: This is all fine, and the code certainly does its job as expected. But the code
    could be improved.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很正常，代码确实按照预期完成了它的任务。但代码可以改进。
- en: Refactoring the code
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重构
- en: 'There are a couple of challenges with this type of code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的代码有几个挑战：
- en: Firstly, the controller is taking on the responsibility for the infrastructure
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，控制器正在承担基础设施的责任
- en: Secondly, it also takes on the responsibility for the actual domain logic and
    knowing exactly how to store things in a database
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它还承担了实际领域逻辑的责任，并确切知道如何在数据库中存储数据
- en: An API surface should instead just rely on other subsystems to do their specific
    job and then delegate to them rather and then become a composition.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: API界面应该只依赖于其他子系统来完成它们特定的任务，然后委托给它们，而不是成为组合。
- en: For instance, we could go and isolate the user credential registration and the
    user details registration into two different services that we could use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将用户凭证注册和用户详细信息注册隔离成两个不同的服务，我们可以使用它们。
- en: Creating services
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建服务
- en: 'Let’s pull it apart a little bit and start putting in some structure. Create
    a file called **UsersService.cs** and make it look like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微拆分一下，并开始添加一些结构。创建一个名为**UsersService.cs**的文件，并使其看起来如下：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code is doing exactly the same as it did in **UsersController** for registering
    the user, just that it is now formalized as a service. Let’s do the same for the
    user details. Create a file called **UserDetailsService.cs** and make it look
    like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在注册用户方面与**UsersController**中执行的操作完全相同，只是现在正式化为服务。让我们为用户详细信息做同样的事情。创建一个名为**UserDetailsService.cs**的文件，并使其看起来如下：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As with **UsersService**, the code does exactly the same as the original code
    in **UsersController**, only now separated out and focused.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与**UsersService**一样，代码与**UsersController**中的原始代码完全相同，但现在它是分离的，并且更加专注。
- en: This is a great step. Now the infrastructure details of the database are hidden
    from the outside world and anyone wanting to register a user only has to focus
    on the information needed to do so and not how it’s done.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的步骤。现在，数据库的基础设施细节对外部世界是隐藏的，任何想要注册用户的人只需要关注完成注册所需的信息，而不需要关注它是如何完成的。
- en: The next step is for you to change **UsersController** to leverage the new services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是你需要将**UsersController**更改为利用新服务。
- en: Changing the controller
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改控制器
- en: 'Go and change the controller to look like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 去更改控制器，使其看起来如下：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code creates an instance of the **UsersService** class in the constructor
    and uses the **Register** method directly in the **Register** API method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在构造函数中创建**UsersService**类的实例，并在**Register** API方法中直接使用**Register**方法。
- en: If you run the sample at this point and perform the **HTTP POST** again, you
    will get the exact same result.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行这个示例并再次执行**HTTP POST**，你将得到完全相同的结果。
- en: '**UsersService** and **UserDetailsService** are now dependencies that **UsersController**
    have and it creates those dependencies as instances itself. There are a couple
    of downsides to this. The dependencies are basically now following the life cycle
    of the controller. Since controllers are created once per web request, it means
    **UsersService** and **UserDetailsService** will be created every time as well.
    This could be a performance issue, and is not really a problem the controller
    should be worried about. Its main job is just to provide an API surface for registering
    users.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**UsersService**和**UserDetailsService**现在是**UsersController**的依赖项，并且它作为实例创建这些依赖项。这有几个缺点。依赖项现在基本上遵循控制器的生活周期。由于控制器是每个Web请求创建一次，这意味着**UsersService**和**UserDetailsService**也将每次创建。这可能会成为性能问题，并且并不是控制器应该担心的问题。它的主要工作只是提供一个用于注册用户的API界面。'
- en: It’s also very hard to be able to write tests for **UsersController**, as the
    dependencies are now hard-wired and it brings in all the infrastructure with it
    and then makes it much harder to test the logic of **UsersController** in isolation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖项现在被硬编码，并且它带来了所有基础设施，这使得为**UsersController**编写测试变得非常困难，因为它使得单独测试**UsersController**的逻辑变得更加困难。
- en: This is where dependency inversion comes in, by reversing the relationship and
    saying that the system, in our case **UsersController**, is not responsible for
    creating the instance itself, but rather has it as an argument to the constructor,
    and letting whoever is instantiating the controller be responsible for providing
    the dependencies **UsersController** has.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是依赖反转发挥作用的地方，通过反转关系，我们说系统，在我们的案例中是**UsersController**，不负责创建实例本身，而是将其作为构造函数的参数，并让任何实例化控制器的人负责提供**UsersController**所需的依赖项。
- en: 'Change **UsersController** to take the dependency on the constructor:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将**UsersController**修改为通过构造函数接受依赖项：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code now takes **UsersService** and **UserDetailsService** as arguments
    and uses those directly instead of creating an instance of them itself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在接受**UsersService**和**UserDetailsService**作为参数，并直接使用它们，而不是自己创建它们的实例。
- en: We now have the benefit of the dependencies being very clear to the outside
    world. The life cycle of **UsersService** can then be managed outside of the controller.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，依赖关系对外部世界来说非常清晰。因此，**UsersService**的生命周期可以在控制器之外进行管理。
- en: However, since the controller is taking the concrete instances, it is still
    tied to the infrastructure. This can be improved upon to decouple the infrastructure
    and make it more testable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于控制器正在处理具体的实例，它仍然与基础设施紧密相连。这可以通过解耦基础设施并使其更易于测试来改进。
- en: Contract oriented
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于契约
- en: To improve further on this, we could also extract the content of **UsersService**
    and **UserDetailsService** into interfaces and use those instead. The benefits
    of that are that you would decouple from the concrete implementation and its infrastructure
    needs and add flexibility in your code by allowing different implementations and,
    depending on the configuration or the system being in a specific state, switch
    out which implementation of the interface to use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步改进，我们还可以将**UsersService**和**UserDetailsService**的内容提取到接口中，并使用这些接口。这样做的好处是，您将解耦具体实现及其基础设施需求，并通过允许不同的实现以及根据配置或系统处于特定状态来切换接口的实现来增加代码的灵活性。
- en: An additional benefit of extracting into an interface is that you make it easier
    to write tests that focus purely on the unit being tested and only the interaction
    with its dependencies, without having to bring in the entire infrastructure to
    write the automated test.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将内容提取到接口中的另一个好处是，这使得编写仅关注被测试单元及其依赖项交互的测试变得更加容易，而无需引入整个基础设施来编写自动化测试。
- en: 'Create a file called **IUsersService.cs** and make it look like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为**IUsersService.cs**的文件，并使其看起来如下：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code holds the **Register** method with the same signature as in the original
    **UsersService** class. Then the implementation of **UsersService** only changes
    by adding the **IUsersService** inheritance. Open the **UsersService** file and
    make it implement the **IUsersService** interface:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码保留了与原始**UsersService**类中相同的签名的**Register**方法。然后，**UsersService**的实现仅通过添加**IUsersService**继承来改变。打开**UsersService**文件，使其实现**IUsersService**接口：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For **UserDetailsService**, we want to do the same. Add a file called **IUserDetailsService.cs**
    and make it look like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**UserDetailsService**，我们想要做同样的事情。添加一个名为**IUserDetailsService.cs**的文件，并使其看起来如下：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code holds the **Register** method with the same signature as in the original
    **UserDetailsService** class. Then the implementation of **UserDetailsService**
    only changes by adding the **IUserDetailsService** inheritance. Open the **UserDetailsService**
    file and make it implement the **IUserDetailsService** interface:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码保留了与原始**UserDetailsService**类中相同的签名的**Register**方法。然后，**UserDetailsService**的实现仅通过添加**IUserDetailsService**继承来改变。打开**UserDetailsService**文件，使其实现**IUserDetailsService**接口：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With these two changes, we can now change how we express the dependencies.
    In **UsersController**, you then change from using **UsersService** to **IUsersService**
    and **UserDetailsService** to **IUserDetailsService**:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两项更改，我们现在可以改变表达依赖关系的方式。在**UsersController**中，您将使用**UsersService**改为**IUsersService**，并将**UserDetailsService**改为**IUserDetailsService**：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code now takes the two **IUsersService** and **IUserDetailsService** dependencies
    using their interfaces and the rest of the code remains unchanged.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的代码使用它们的接口来获取两个 **IUsersService** 和 **IUserDetailsService** 依赖项，其余代码保持不变。
- en: So far, we’ve discussed dependencies and the benefits of the **dependency inversion
    principle**. Still, we need to be able to provide these dependencies. And it is
    very impractical if we have to manually provide these all around our system and
    maintain life cycles of them in different ways. It could lead to a very messy,
    unmaintainable code base and could also lead to unknown side effects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了依赖项和 **依赖反转原则** 的好处。然而，我们还需要能够提供这些依赖项。如果我们必须手动在系统各处提供这些依赖项，并以不同的方式维护它们的生命周期，这将非常不切实际。它可能导致非常混乱、难以维护的代码库，也可能导致未知副作用。
- en: What you really want is something that manages this for you. This is what is
    known as an **inversion of control container** (**IoC container**). Its job is
    to hold information about all your services, which implementation is used for
    what interface, and also the life cycle of these. The IoC container is a centralized
    piece that you configure at the beginning of your application and after its configuration
    is done, you can ask it to provide instances of anything that is registered with
    it. It’s very useful for registering any kind of dependencies, not just the ones
    where it is an interface to an implementation. You can register concrete types,
    delegate types, or pretty much anything.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你真正需要的是一种为你管理这些的机制。这就是所谓的**控制反转容器**（**IoC 容器**）。它的任务是保存有关所有服务的信息，包括用于什么接口的实现，以及这些服务的生命周期。IoC
    容器是一个集中式的组件，你需要在应用程序开始时进行配置，配置完成后，你可以要求它提供已注册的任何实例。这对于注册任何类型的依赖项非常有用，而不仅仅是那些作为实现接口的依赖项。你可以注册具体类型、代理类型，或者几乎任何东西。
- en: The IoC container works recursively and will deal with dependencies of dependencies
    and resolve everything correctly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: IoC 容器递归地工作，并将处理依赖项的依赖项，并正确地解决所有问题。
- en: In ASP.NET Core, the concept of an IoC container is already set up out of the
    box and is really easy to use with what is known as **ServiceCollection**, where
    you can set up all the service registrations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，IoC 容器的概念已经默认设置好，并且使用名为 **ServiceCollection** 的机制非常容易使用，其中你可以设置所有服务注册。
- en: Automatic ServiceCollection registrations by convention
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过约定自动注册 ServiceCollection
- en: We’ve now left the code in a non-functional state. This is because the built-in
    IoC container does not know how to resolve the **IUsersService** dependency and
    **IUserDetailsService**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将代码留在了非功能状态。这是因为内置的 IoC 容器不知道如何解决 **IUsersService** 依赖项和 **IUserDetailsService**。
- en: 'You need to explicitly tell ASP.NET which implementation it should use. Open
    your **Program.cs** file and put in the binding as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要明确告诉 ASP.NET 应该使用哪个实现。打开你的 **Program.cs** 文件，并按照以下方式添加绑定：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code adds a registration in the ASP.NET Core **ServiceCollection** for **IUsersService**
    to be resolved to **UsersService**, and it also explicitly says that it should
    add it as a **singleton**. This means that there will only be one instance of
    this service within the process.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 ASP.NET Core 的 **ServiceCollection** 中添加了一个注册项，将 **IUsersService** 解析为 **UsersService**，并且它还明确指出应该将其添加为
    **单例**。这意味着在进程内将只有一个此类服务的实例。
- en: You should now have a working program again, the only difference now is that
    the ASP.NET IoC container is resolving the instance for you, and it will be the
    same instance for every request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该又有一个正常工作的程序了，唯一的区别现在就是 ASP.NET 的 IoC 容器正在为你解析实例，并且对于每个请求，它都将使用相同的实例。
- en: Important note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Singletons can be dangerous. If the type being a singleton has a dependency
    on something that shouldn’t be a singleton but should in fact be new on every
    request, the type being singleton will be a blocker for that. Use them wisely.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 单例可能会很危险。如果一个类型作为单例，它依赖于不应该作为单例但应该在每个请求中都是新的东西，那么这个单例类型将成为一个阻碍。要明智地使用它们。
- en: The code thus far is very contained and simple. In real systems, you tend to
    want to be even clearer about responsibilities by dividing up the code into more
    focused units.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码非常简洁且简单。在实际系统中，你通常会希望通过将代码划分为更专注的单元来更加清晰地划分责任。
- en: Further refactoring
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步重构
- en: Too much responsibility lies on **UsersService** right now. The database part
    is not something it should own. Knowing how to create a database connection is
    something that should be extracted so that you do that in one place. Be conscious
    of the responsibilities of each unit in your system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 **UsersService** 承担的责任过多。数据库部分不是它应该拥有的东西。知道如何创建数据库连接是应该提取出来，以便你在同一个地方做这件事。要意识到你系统中每个单元的责任。
- en: 'Let’s introduce a unit representing the database. Start by creating an interface
    by adding a file called **IDatabase.cs** to the project, and make it look like
    the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一个表示数据库的单位。首先，通过向项目中添加一个名为 **IDatabase.cs** 的文件来创建一个接口，并使其看起来如下：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The interface gives us access to getting MongoDB collections for types specified
    using generics.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口使我们能够通过泛型指定类型来获取 MongoDB 集合。
- en: Important note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: By creating an abstraction for the database, one could argue we could have gone
    further and created something that represented the database operations you typically
    do adhering to what is known as the repository pattern. If you did that, you would
    quickly find that you would not be able to work with the underlying database and
    its capabilities. Also, for the context of this book, we’ll keep it at this level.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为数据库创建一个抽象，我们可以进一步争论，可以创建一个代表你通常执行的数据库操作的东西，这符合所谓的存储库模式。如果你这样做，你会很快发现你将无法与底层数据库及其功能一起工作。此外，对于本书的上下文，我们将保持在这个级别。
- en: 'With the **IDatabase** interface in place, you now need an implementation of
    it. Create a file called **Database.cs** and add the following to it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了 **IDatabase** 接口之后，你现在需要一个实现它的实现。创建一个名为 **Database.cs** 的文件，并将其添加如下：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code contains most of the database access you had in **UsersService** but
    adds a dimension of mapping types to collection names.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含了你在 **UsersService** 中大部分的数据库访问，但增加了将类型映射到集合名称的维度。
- en: As a little bit of a sidetrack, but still on the theme of convention over configuration,
    let’s improve the **Database** class a little bit. At the top of the class, there
    is the map of **Type** to the collection name. This is something that would grow
    over time. If you look at the **User** type, it gets mapped to **Users** – a convention
    that I prefer, having the collection names as plural, indicating there is more
    than one user.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小插曲，但仍然是在约定优于配置的主题上，让我们稍微改进一下 **Database** 类。在类的顶部，有一个将 **Type** 映射到集合名称的映射。这是随着时间的推移而增长的东西。如果你查看
    **User** 类型，它被映射到 **Users** – 我更喜欢这种约定，因为集合名称是复数形式，表示有多个用户。
- en: Important note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The concept of convention over configuration was coined by David Heinemeier
    Hansson to describe the philosophy of the Ruby on Rails web framework. You can
    read more about it here: [https://rubyonrails.org/doctrine#convention-over-configuration](https://rubyonrails.org/doctrine#convention-over-configuration).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 约定优于配置的概念是由 David Heinemeier Hansson 提出的，用来描述 Ruby on Rails 网络框架的哲学。你可以在这里了解更多信息：[https://rubyonrails.org/doctrine#convention-over-configuration](https://rubyonrails.org/doctrine#convention-over-configuration)。
- en: 'This is something that can be automated and would truly be convention over
    configuration. Let’s pull in a third-party library that deals with pluralization
    for us. Go to your terminal and run the following in the **Chapter10** folder:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以自动化的，真正是约定优于配置。让我们引入一个第三方库来为我们处理复数化。转到你的终端，并在 **Chapter10** 文件夹中运行以下命令：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The **Humanizer** library knows how to pluralize English words by default, but
    it has support for other languages as well. I recommend reading more about it
    over on GitHub ([https://github.com/Humanizr/Humanizer](https://github.com/Humanizr/Humanizer)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Humanizer** 库默认知道如何复数化英语单词，但它也支持其他语言。我建议你到 GitHub 上了解更多信息（[https://github.com/Humanizr/Humanizer](https://github.com/Humanizr/Humanizer)）。'
- en: 'With the package installed, you can improve and simplify your **Database**
    code. Change the **Database** class to be like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了包后，你可以改进和简化你的 **Database** 代码。将 **Database** 类修改如下：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code is pretty much the same, except you now don’t have **Dictionary** with
    the mapping between **Type** and collection names. Also, for the **GetCollection()**
    method, you no longer need to do a lookup but instead, just use the type name
    and use the **.Pluralize()** extension method on it. With this, you’re leveraging
    the type metadata to your advantage in a very simple way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎相同，只是你现在不再有**Dictionary**来映射**Type**和集合名称。对于**GetCollection()**方法，你不再需要进行查找，而是直接使用类型名称，并在其上使用**.Pluralize()**扩展方法。通过这种方式，你以非常简单的方式利用了类型元数据。
- en: With this fix, you’ve basically made your code future-proof and will not have
    to perform open-heart surgery on the code to add support for a new collection.
    It’s a predictable convention.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次修复，你基本上使你的代码具备了未来性，并且不需要对代码进行开放心脏手术来添加对新集合的支持。这是一个可预测的约定。
- en: Since you now have encapsulated the infrastructure part of the system into the
    **Database** class, you can now start fixing **UserService** and **UserDetailsService**
    to leverage this centerpiece.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你现在已经将系统的基础设施部分封装到了**Database**类中，你现在可以开始修复**UserService**和**UserDetailsService**，以便利用这个核心组件。
- en: 'Start by changing **UsersService** to the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将**UsersService**修改成以下样子：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code now completely gets rid of the management of the database connection
    and how to get a collection, and also not even the name of the collection, instead
    pulling in **IDatabase** as a dependency and letting the implementation of that
    interface take the full responsibility of the infrastructure. This is now just
    by convention, and you can trust that it will be a predictable collection name
    for the type you give it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在完全去除了对数据库连接的管理以及如何获取集合的管理，甚至不再需要集合的名称，而是引入**IDatabase**作为依赖项，并让该接口的实现承担全部的基础设施责任。现在这只是一个约定，你可以相信它将为提供的类型提供一个可预测的集合名称。
- en: 'You need to do the same to **UserDetailsService**. Change it to the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要对**UserDetailsService**做同样的操作。修改成以下样子：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As with **UsersService**, the code change is pretty much the same, bringing
    in the **IDatabase** infrastructure dependency and letting **UserDetailsService**
    focus on its primary job of registering user details.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与**UsersService**一样，代码更改几乎相同，引入了**IDatabase**基础设施依赖，并让**UserDetailsService**专注于其主要的任务，即注册用户详情。
- en: The activity of refactoring the code has led to a more decoupled system and
    a more maintainable system, where each component is laser-focused on doing one
    thing, a single responsibility. It now needs to be brought together.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构的活动导致了一个更加解耦的系统和一个更易于维护的系统，其中每个组件都专注于做一件事，单一职责。现在需要将其整合起来。
- en: Composing
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: 'With the system broken up into focused components, we have to bring it together.
    Since the IoC container does not know how to resolve **IDatabase**, we need to
    add that binding. Change your **Program.cs** to look like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将系统拆分成专注的组件后，我们需要将其整合起来。由于IoC容器不知道如何解析**IDatabase**，我们需要添加这个绑定。将你的**Program.cs**修改成以下样子：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code adds the **.AddSingleton<IDatabase, Database>()** call to register
    the binding between **IDatabase** and **Database** and also say we only need it
    to be a singleton. You should, at this point, have a working system again. Running
    this and performing the API call using Postman should give you the same result
    as before.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码添加了**.AddSingleton<IDatabase, Database>()**调用，以注册**IDatabase**和**Database**之间的绑定，并说明我们只需要它是一个单例。此时，你应该又拥有了一个正常工作的系统。运行这个程序并使用Postman进行API调用，应该会得到与之前相同的结果。
- en: However, already there is a bit of a code smell here. The fact that we have
    to go and manually add a registration to the IoC container for everything we add
    is again open-heart surgery we have to perform every time we create something.
    With just a couple of components, this not only becomes tedious but quickly also
    makes **Program.cs** a dumping ground for this type of configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里已经有点代码异味了。我们必须手动添加注册到IoC容器中的每一项，这又是一次必须进行的开放心脏手术。对于只有几个组件，这不仅变得繁琐，而且很快就会使**Program.cs**成为此类配置的垃圾场。
- en: Luckily, there is a pattern we can turn into a convention. All the implementations
    have an interface representation that is named the same as the implementation,
    only prefixed with a capital *I*. This is a very common convention. We can make
    the code more future-proof by discovering the connections between the interfaces
    and implementations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个模式我们可以将其转变为一种约定。所有的实现都有一个接口表示，其名称与实现相同，只是前面加了一个大写字母 *I*。这是一个非常常见的约定。我们可以通过发现接口和实现之间的联系来使代码更具未来性。
- en: 'Even though we can discover the relationship between implementations and interfaces,
    we wouldn’t know how to know which life cycle they should be. To do this, we shift
    the responsibility of knowing the life cycle onto the implementation. We do this
    by introducing metadata in the form of attributes. The default behavior should
    be that every binding we do is **transient**, meaning that we get a new instance
    every time we ask the IoC container. Then all we need is attributes for overriding
    that behavior. For this sample, we’ll keep it to only one life cycle: singleton.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以发现实现和接口之间的关系，但我们不知道如何知道它们的生命周期。为了做到这一点，我们将知道生命周期的责任转移到实现上。我们通过引入以属性形式存在的元数据来实现这一点。默认行为应该是我们进行的每个绑定都是
    **transient**，这意味着每次我们向 IoC 容器请求时都会得到一个新的实例。然后我们只需要为覆盖该行为提供属性。对于这个示例，我们将只保留一个生命周期：单例。
- en: 'Add a file called **SingletonAttribute.cs** and make it look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 **SingletonAttribute.cs** 的文件，并使其看起来如下：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code represents an attribute that is for classes and lets you look for during
    discovery and decide whether or not it is a singleton.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码代表了一个属性，它适用于类，并允许你在发现过程中查找，并决定它是否是一个单例。
- en: 'Let’s take advantage of the **Fundamentals** project in the GitHub repository
    mentioned in the pre-requisites. You should add a project reference to it for
    this chapter by doing the following in your terminal:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用在先决条件中提到的 GitHub 仓库中提到的 **Fundamentals** 项目。你应该通过在终端执行以下操作来为这一章添加对该项目的引用：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Important note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The path to the project might be different on your computer, depending on where
    you have the **Fundamentals** project from the GitHub repository.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的路径可能因你的计算机而异，取决于你从 GitHub 仓库中获取的 **Fundamentals** 项目。
- en: What you now want to do is create an extension method for **IServiceCollection**
    that you’ve been calling to register bindings with.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在想要做的是为 **IServiceCollection** 创建一个扩展方法，你一直用它来注册绑定。
- en: 'Start by adding a file called **ServiceCollectionExtensions.cs** and make it
    look like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个名为 **ServiceCollectionExtensions.cs** 的文件，并使其看起来如下：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code just sets up a new extension method called **AddBindingsByConvention()**
    that also takes the **ITypes** system from **Fundamentals** and returns **services**
    given to it to be able to chain calls when using the method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仅设置了一个名为 **AddBindingsByConvention()** 的新扩展方法，它还从 **Fundamentals** 中获取 **ITypes**
    系统，并返回给它的 **services**，以便在使用方法时能够进行链式调用。
- en: 'Go and add the following to the top of the **AddBindingsConvention()** method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前往并添加以下代码到 **AddBindingsConvention()** 方法的顶部：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code uses **ITypes** to get all the discovered types in the system. For
    every type, it looks at whether the type implements any interfaces. If it does
    implement an interface, it will see whether any of the interfaces match the convention.
    The convention is that the interface type and the implementation type have to
    be in the same namespace and that the interface type has to match the name of
    the implementation, only prefixed with a capital *I*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 **ITypes** 来获取系统中所有发现的数据类型。对于每一个类型，它都会检查该类型是否实现了任何接口。如果实现了接口，它将检查是否有任何接口符合约定。约定是接口类型和实现类型必须在同一个命名空间中，并且接口类型必须与实现类型的名称匹配，只是前面加了一个大写字母
    *I*。
- en: 'The result of this will be a collection of types that matches the convention.
    Next, you’ll need to add code that registers the bindings. Add the following code
    after the previous code you added in the **AddBindingsByConvention()** method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将得到一个符合约定的类型集合。接下来，你需要添加代码来注册绑定。在 **AddBindingsByConvention()** 方法中添加以下代码之后：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code loops through all the types that adhere to the convention and gets
    the actual interface and then binds it either as a singleton or transient based
    on whether or not the implementation has **SingletonAttribute** or not.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遍历所有遵循约定的类型，获取实际的接口，然后根据实现是否具有 **SingletonAttribute** 将其绑定为单例或瞬态。
- en: 'Let’s go and make all the services singleton using the attribute. Open the
    **Database.cs** file and add **SingletonAttribute** in front of the type declaration:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用属性将所有服务设置为单例。打开**Database.cs**文件，在类型声明前添加**SingletonAttribute**：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Do the same for **UserDetailsService**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**UserDetailsService**也做同样的操作：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And then do the same for **UsersService**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对**UsersService**也做同样的操作。
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'All you now need to do is change the program startup. Open **Program.cs** and
    change it to look like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在需要做的就是更改程序启动。打开**Program.cs**，将其更改为以下内容：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The code changes from all the explicit bindings of the different services to
    now leverage the **Types** class from **Fundamentals**, binding it as a singleton,
    and then adding all the bindings discovered by convention.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从所有不同服务的显式绑定变为现在利用**Fundamentals**中的**Types**类，将其绑定为一个单例，然后添加所有由惯例发现的绑定。
- en: Running your application should still give you the same behavior and it should
    work in the exact same way. The only difference is that everything is now by convention,
    and you can just add things without having to configure anything.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行您的应用程序应该仍然给您带来相同的行为，并且它应该以完全相同的方式工作。唯一的区别是现在一切都是通过惯例，您只需添加内容，无需进行任何配置。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you’ve tasted a little bit of how powerful conventions can
    be for concrete everyday C# coding, touching on how to improve the experience
    working with the IoC container in ASP.NET Core by optimizing a common scenario
    of registering services by their interface. We’ve also looked at how designing
    by contract helps you create a system that is more flexible and much easier to
    test.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经尝到了惯例在具体日常C#编码中的强大作用，了解了如何通过优化注册服务接口的常见场景来提高在ASP.NET Core中使用IoC容器的工作体验。我们还探讨了通过契约设计如何帮助您创建一个更加灵活且易于测试的系统。
- en: The concept of *convention over configuration* is probably the thing that has
    impacted me personally the most in my career. It makes your code more consistent
    and if you fail to be consistent, it doesn’t work, which is a good thing because
    then you will have to fix your code to be more consistent.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: “惯例优于配置”的概念可能是对我个人职业生涯影响最大的事情。它使您的代码更加一致，如果您未能保持一致，代码将无法工作，这本身就是一个好事，因为那时您将不得不修复代码以使其更加一致。
- en: Having to not configure everything and just be able to add code is a true productivity
    boost, and anyone working on the project will thank you for it. However, you need
    to be clear with all team members about what the conventions are, otherwise, they
    will not thank you at all. There is nothing worse than having your code work or
    not work seemingly arbitrarily. Document it and be clear about how things work.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不必配置一切，只需能够添加代码，这确实能大大提高生产力，任何参与项目的人都会为此感谢您。然而，您需要向所有团队成员清楚地说明这些惯例，否则他们可能不会感谢您。没有什么比代码似乎任意地工作或不工作更糟糕的了。请记录下来，并清楚地说明事物是如何运作的。
- en: Also worth mentioning is that conventions are not for all projects and are not
    necessarily for all teams. For conventions to make sense, the team needs to accept
    that way of working. If the team prefers reading code and seeing everything explicitly
    set up, then conventions will only cause confusion. If the project is a very small
    one, it might not be worth the cognitive overhead.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，惯例并非适用于所有项目，也并非适用于所有团队。为了使惯例有意义，团队需要接受这种工作方式。如果团队更喜欢阅读代码并看到所有内容都明确设置，那么惯例只会造成混淆。如果项目非常小，可能不值得付出认知上的开销。
- en: Coming up in the next chapter, we’ll get more into the open/closed principle,
    something we’ve touched on in this chapter, and see how it can benefit your code
    base.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨开放/封闭原则，这是我们本章中提到的内容，并看看它如何使您的代码库受益。
