<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-255"><a id="_idTextAnchor265"/>11</h1>
<h1 id="_idParaDest-256"><a id="_idTextAnchor266"/>Implementing Continuous Integration with GitHub Actions</h1>
<p>You wrote unit tests and other types of tests and you are happy about your code coverage and quality. So far so good, but who is going to make sure these tests are going to run every time the code changes? Is it the developer that is pushing new code? What if they forget? What if there are merge problems in source control that might break your tests? Who is going to check?</p>
<p>You’ve already figured out the answer. It is the <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) system that you should have in place. CI is the natural companion to unit testing, and you can rarely find a modern project today without a CI system in place.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>An introduction to continuous integration</li>
<li>Implementing a CI process with GitHub Actions</li>
</ul>
<p>By the end of the chapter, you will be able to implement an end-to-end CI process with GitHub Actions.</p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor267"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/.github/workflows">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/.github/workflows</a></p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor268"/>Introduction to continuous integration</h1>
<p>The idea behind <a id="_idIndexMarker784"/>the term <strong class="bold">CI</strong> is that new code is continuously integrated with existing code, which results in a system that can be shipped to production at any time (or at least this is the intention).</p>
<p>The route from software development to production is referred to as the <strong class="bold">release pipeline</strong>, where the code <a id="_idIndexMarker785"/>passes through multiple processes to reach production, such as compiling the code, deploying the binaries on the dev environment, allowing a QA to pull the code to a certain environment, and others. CI is an integral part of the release pipeline.</p>
<p>A CI system requires <a id="_idIndexMarker786"/>a host so that it can do various operations on the code. The host is a combination of a server and an operating system:</p>
<div><div><img alt="Figure 11.1 – CI server in an OS " height="215" src="img/Figure_11.1_B18370.jpg" width="600"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – CI server in an OS</p>
<p>Here are <a id="_idIndexMarker787"/>a few examples of on-premise CI servers:</p>
<ul>
<li>Cruise Control</li>
<li>Team <a id="_idIndexMarker788"/>City</li>
<li><strong class="bold">Team Foundation Server</strong> (<strong class="bold">TFS</strong>)</li>
<li>Jenkins</li>
<li>Octopus Deploy</li>
</ul>
<p>You will be able to find a SaaS solution for the previously mentioned system as well. However, today, the native cloud solutions are more popular, such as the following:</p>
<ul>
<li>GitHub Actions</li>
<li>Azure DevOps</li>
<li>AWS CodePipeline</li>
<li>Octopus Cloud</li>
<li>GitLab CI/CD</li>
</ul>
<p>The concepts of <a id="_idIndexMarker789"/>these systems are the same and when you learn one, you can easily learn another. Now, let’s see how a CI system works.</p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor269"/>CI workflow</h2>
<p>A CI system applies a workflow to your code by executing a series of actions. The actions are configurable and may <a id="_idIndexMarker790"/>vary between one project and another based on the project’s needs. This is a generic workflow for a CI system:</p>
<div><div><img alt="Figure 11.2 – CI workflow " height="1015" src="img/Figure_11.2_B18370.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – CI workflow</p>
<p>When a developer pushes new code into the source control, the CI system is usually listening for this event. It takes a copy of the code and tries to compile it similarly to what happens when you compile on your machine. Then, it tries to discover all the unit tests in your test projects and execute them.</p>
<p>CI systems are highly <a id="_idIndexMarker791"/>customizable, so a developer might add execution for multiple types of tests and other housekeeping steps.</p>
<p>If any step fails, the CI system will abandon the build and mark it as failed, and notify the developer via a pre-configured way, such as an email.</p>
<p>If all the steps pass, then a <strong class="bold">continuous deployment</strong> (<strong class="bold">CD</strong>) system can be plugged into the end of this <a id="_idIndexMarker792"/>process. A CD system deploys your built code (binaries) into servers based on your specific preferences. Therefore, you always hear the terms <em class="italic">CI/CD</em> used simultaneously.</p>
<p>Next, we are going to discuss the importance of CI in a software engineering process.</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor270"/>The benefits of CI systems</h2>
<p>CI systems are usually plugged in from sprint zero of an agile process. They exist from day one for good <a id="_idIndexMarker793"/>reasons. Obviously, building a CI system pipeline takes time and effort, so there should be a justification for the added effort. Here, we will see the importance and benefits of a CI system.</p>
<h3>Having the code compiling at all times </h3>
<p>How many times in a team project have you pulled the latest code from source control and discovered <a id="_idIndexMarker794"/>that it does not compile? The CI system ensures the code compiles at all times and the best practice is not to pull the new code if the CI flags a previous push as a failure, because you won’t be able to continue working unless you fix the code yourself or wait for your colleague to fix it.</p>
<p>Of course, you will have to pull the broken build if you are intending to fix it, but the CI gives you an earlier indication.</p>
<p>Usually, broken code in source control happens when a developer doesn’t pull the latest from source <a id="_idIndexMarker795"/>control, and compiles and executes the tests before pushing their code.</p>
<h3>Having the unit tests passing at all times</h3>
<p>Developers might <a id="_idIndexMarker796"/>forget to execute the unit tests on their machine before pushing their code, but the CI system won’t forget! </p>
<p>As per the previous discussion in this book, where unit tests should be high-performance, the CI should take no time in running all your unit tests to feed back to the team that the build is safe and ready for them to pull the new code.</p>
<p>I have specifically mentioned unit tests as they provide fast feedback. You might have other types of tests that might take time to execute, and you may decide whether you want to execute them with every push or at certain times of the day. Other tests are usually slow and take minutes to execute, and you might want to run them in parallel but not block the feedback until they finish, which might be 10 minutes or an hour.</p>
<h3>Compiling the code in a ready state for CD</h3>
<p>If the build has compiled successfully and passed testing, then this is ready for manual testing if you have <a id="_idIndexMarker797"/>this as part of your software engineering process or if you have binaries ready to be deployed to your environments by the CD process.</p>
<p>The CD process takes the output of your CI and deploys it to configured locations such as your dev environment, UAT, and production.</p>
<p>CI is not optional anymore in today’s software engineering process, as you can see from the benefits. There is no excuse not to implement one. It is cheap, and it is easy to implement, as we are going to see next when we utilize GitHub Actions.</p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor271"/>Implementing a CI process with GitHub Actions</h1>
<p>Initially, when I <a id="_idIndexMarker798"/>was designing <a id="_idIndexMarker799"/>the guidelines for the chapters in this book, I was planning to give a sample implementation using Azure DevOps, as it has a popular CI system. However, GitHub Actions climbed up fast and quickly became the developers’ choice in configuring a CI system, so I changed my mind and I am going to use GitHub Actions instead.</p>
<p>GitHub Actions can deal with multiple programming stacks; one of them is .NET Core, which is what we are concerned about in this chapter.</p>
<p>Obviously, you will need to have a GitHub account for using GitHub Actions and you will be glad to <a id="_idIndexMarker800"/>know that the <a id="_idIndexMarker801"/>free tier gives you 2,000 minutes/month of running time, which should be enough for a small solo project.</p>
<p>Next, we are going to use GitHub Actions as a CI system for the project in <a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a>, <em class="italic">Building an App with Repositories and Document DB</em> you don’t need to have read the chapter, we just want a solution that has a project and unit tests against it so we can demonstrate how Actions works and <a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a> has that.</p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor272"/>Creating a sample project in a GitHub repo</h2>
<p>To follow along, you <a id="_idIndexMarker802"/>will need to have a GitHub account with a GitHub repository hosting a .NET project. If you don’t <a id="_idIndexMarker803"/>have one, then you can create a free GitHub account.</p>
<p>You will need the code of <a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a> in your repository, so the fastest way to do that is to go on this book’s GitHub page and hit <strong class="bold">Fork</strong> | <strong class="bold">Create a new fork</strong>:</p>
<div><div><img alt="Figure 11.3 – Create a new fork " height="400" src="img/Figure_11.3_B18370.jpg" width="1209"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Create a new fork</p>
<p>Or go to the repository URL and add <code>/fork</code> to the end, like this: <a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/fork">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/fork</a>. Then hit <strong class="bold">Create fork</strong>:</p>
<div><div><img alt="Figure 11.4 – Filling in the form and hitting Create fork " height="931" src="img/Figure_11.4_B18370.jpg" width="1288"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Filling in the form and hitting Create fork</p>
<p>The fork will <a id="_idIndexMarker804"/>copy the content of a repository into a newly created repository that you own so <a id="_idIndexMarker805"/>you can play with the code without affecting the original repository.</p>
<p>While we’ve copied all the code, we are only interested in this earlier chapter (<a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a>) in the solution, located in the following:</p>
<pre>/ch10/UqsAppointmentBooking/UqsAppointmentBooking.sln</pre>
<p>Now that you have the same code, we can create the GitHub Actions CI for this project.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor273"/>Creating a workflow</h2>
<p>First, to write <a id="_idIndexMarker806"/>any configuration for <a id="_idIndexMarker807"/>GitHub Actions, you will have to be familiar with YAML. YAML is a file format <a id="_idIndexMarker808"/>alternative to JSON that is geared for readability by humans. You will see examples of YAML as we go along.</p>
<p>Let’s create a workflow for the <a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a> project using the GitHub Actions wizard. From your GitHub repository, select <strong class="bold">Actions</strong> | <strong class="bold">New workflow</strong>:</p>
<div><div><img alt="Figure 11.5 – Creating a new workflow " height="651" src="img/Figure_11.5_B18370.jpg" width="1224"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Creating a new workflow</p>
<p>GitHub <a id="_idIndexMarker809"/>Actions comes back with <a id="_idIndexMarker810"/>a list of suggestions based on your repository content:</p>
<div><div><img alt="Figure 11.6 – Suggestion list for a GitHub Actions workflow template " height="748" src="img/Figure_11.6_B18370.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Suggestion list for a GitHub Actions workflow template</p>
<p>Our code is .NET Core, so the first suggestion is suitable; let’s hit <strong class="bold">Configure</strong>. We will get this page:</p>
<div><div><img alt="Figure 11.7 – Creating a workflow " height="236" src="img/Figure_11.7_B18370.jpg" width="1209"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Creating a workflow</p>
<p>Note that GitHub has already suggested a file location for your workflow configuration:</p>
<pre>/.github/workflows/dotnet.yml</pre>
<p>GitHub Actions <a id="_idIndexMarker811"/>lives in the <code>workflows</code> directory. It <a id="_idIndexMarker812"/>also suggested the following YAML code for a start:</p>
<pre>name: .NET
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Setup .NET
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: 6.0.x
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore
    - name: Test
      run: dotnet test --no-build --verbosity normal</pre>
<p>This workflow is called <code>.NET</code> and will be <a id="_idIndexMarker813"/>triggered when someone pushes code into the main branch or raises a <code>pull</code> request to the main branch.</p>
<p>The CI system uses the latest version of Ubuntu Linux available at GitHub Actions, which at the time of <a id="_idIndexMarker814"/>writing is Ubuntu 20.04. The OS <a id="_idIndexMarker815"/>will be hosting the build while various actions are applied to it. Linux is usually chosen by default because it is more efficient to run and cheaper than Windows, and obviously supports .NET Core.</p>
<p>Then the execution of the steps starts with the following: </p>
<ol>
<li><code>actions/checkout@v3</code>: This action checks out your repository, so your workflow can access it. This is requesting version 3 of this action.</li>
<li><code>actions/setup-dotnet@v2</code>: Fetches .NET SDK using version 2 of this library and specifies .NET Core 6 as the .NET version. This allows us to use .NET CLI after.</li>
<li><code>dotnet restore</code>: This is a <a id="_idIndexMarker816"/>standard .NET <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) command to restore the NuGet packages.</li>
<li><code>dotnet build</code>: Compiles the solution.</li>
<li><code>dotnet test</code>: Executes all the test projects in the solution.</li>
</ol>
<p><em class="italic">Steps 1</em> and <em class="italic">2</em> prepare your workspace on the host OS to be able to execute the <code>.NET CLI</code> command in the same way you would execute it on your local machine. As you’ve already figured out, the whole text uses YAML syntax.</p>
<p>You can go ahead and push the <strong class="bold">Start commit</strong> button:</p>
<div><div><img alt="Figure 11.8 – Start commit " height="219" src="img/Figure_11.8_B18370.jpg" width="1209"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Start commit</p>
<p>After this, click <a id="_idIndexMarker817"/>on the <strong class="bold">Actions</strong> tab to see <a id="_idIndexMarker818"/>how GitHub Actions is going to execute these commands:</p>
<div><div><img alt="Figure 11.9 – Failed build " height="432" src="img/Figure_11.9_B18370.jpg" width="965"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Failed build</p>
<p>As you’ve noticed with the red sign, the build has failed. You could click on the failed build to know more:</p>
<div><div><img alt="Figure 11.10 – Description of build failure " height="835" src="img/Figure_11.10_B18370.jpg" width="1209"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Description of build failure</p>
<p>You can see <a id="_idIndexMarker819"/>why this failed: it was unable <a id="_idIndexMarker820"/>to find the solution file to restore the dependencies. This is an expected error as our solution file for <a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a> lives in the <code>/ch10/UqsAppointmentBooking</code> directory and not on <code>/</code> (the root), so we need to modify the YAML file to reflect this.</p>
<p>Pull the latest from source control, and you will notice that you have a new directory called <code>workflows</code> (<code>/.github/workflows</code>) and inside this directory, you will find the file that we have just created: <code>dotnet.yml</code>.</p>
<p>You can edit this <a id="_idIndexMarker821"/>YAML file using any plain text editor. I use <strong class="bold">Visual Studio Code</strong> for this. We need to edit this file to instruct Actions where to find the solution file:</p>
<pre>    …
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./ch10/UqsAppointmentBooking
    steps:
    …</pre>
<p>I have modified the preceding YAML to include the location of the solution file. If you push this file to GitHub, this will trigger a build. You can see the results in the <strong class="bold">Actions</strong> tab:</p>
<div><div><img alt="Figure 11.11 – Build pass " height="417" src="img/Figure_11.11_B18370.jpg" width="1211"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Build pass</p>
<p>The passing build <a id="_idIndexMarker822"/>means that all the steps that <a id="_idIndexMarker823"/>we specified in our YAML file have passed. You can click the passed build to look at how every step is executed and to ensure that your steps passed accurately and not by coincidence. </p>
<p>We have created our CI system on GitHub Actions for our project. Now, every time a team member modifies the code, the CI workflow will kick in.</p>
<p>Let’s focus a bit more on the test part.</p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor274"/>CI and testing</h2>
<p>The last line in <a id="_idIndexMarker824"/>the YAML steps is meant to trigger all available tests in the solution:</p>
<pre>    - name: Test
      run: dotnet test --no-build --verbosity normal</pre>
<p>This targets all the tests in your solution, which might be a combination of unit tests, Sintegration tests, integration tests, and system tests. Executing all the tests that you have might not be ideal based on what your project does. This will delay the feedback of the recent push and block other team members from validating that the build is safe to use.</p>
<p>So, you might want to restrict your workflow to unit tests only. You can modify the run command to the following:</p>
<pre>dotnet test --filter FullyQualifiedName~Tests.Unit 
    --no-build --verbosity normal</pre>
<p>This will target all tests with <code>Tests.Unit</code> in their namespace. So, you don’t execute all tests and you get fast feedback.</p>
<p>For other tests, you <a id="_idIndexMarker825"/>can write another YAML file that contains a new workflow and schedule it to run at a different event, such as multiple times per day.</p>
<p>Let’s see what happens when a test fails.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor275"/>Simulating failed tests</h2>
<p>Let’s say that a <a id="_idIndexMarker826"/>colleague forgot to run the unit tests before pushing to source control, heaven forbid. We can simulate this by changing the line from <a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a><em class="italic">’s</em> <code>SlotService</code> from <code>||</code> to <code>&amp;&amp;</code> and pushing the code to source control:</p>
<div><div><img alt="Figure 11.12 – Breaking the logic in the code to trigger failed tests " height="120" src="img/Figure_11.12_B18370.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Breaking the logic in the code to trigger failed tests</p>
<p>This change will fail the existing unit tests in the solution, and it is usually trapped before pushing to source control, but if pushed, the CI system will report the following:</p>
<div><div><img alt="Figure 11.13 – Failed tests in source control " height="618" src="img/Figure_11.13_B18370.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Failed tests in source control</p>
<p>The previous screen will show multiple failing points and if you scroll down, it will show you more of a <a id="_idIndexMarker827"/>description of the failed test, what was expected, and what was produced instead:</p>
<div><div><img alt="Figure 11.14 – Failed tests description " height="715" src="img/Figure_11.14_B18370.jpg" width="1275"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – Failed tests description</p>
<p>You can conclude what went wrong by reading the description. Obviously, we know what went wrong here because we broke the code on purpose. In other situations, we could understand <a id="_idIndexMarker828"/>what went wrong from the description of the error on GitHub Actions or we should be able to run the unit tests again on our local machine and try to figure out the situation.</p>
<p>You’ve seen an implementation that uses a workflow. Let’s next understand the concept behind it.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor276"/>Understanding workflows</h2>
<p>The module in <a id="_idIndexMarker829"/>GitHub Actions is a workflow and a workflow looks like this:</p>
<div><div><img alt="Figure 11.15 – Workflows " height="461" src="img/Figure_11.15_B18370.jpg" width="775"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Workflows</p>
<p>A workflow lives in a YAML file in <a id="_idIndexMarker830"/>the <code>/.github/workflows</code> directory in your repository. Each workflow will run when triggered by an event(s) in your repository, or they can be triggered manually or at a defined schedule. In the previous example, the events that would trigger the workflow are pushing into the main branch and raising pull requests to <code>main</code>.</p>
<p>I hope this section did a good job of introducing you to GitHub Actions. Of course, there are more advanced options such as <code>matrix</code> and other features, but <em class="italic">Rome wasn’t built in a day</em>. You can start <a id="_idIndexMarker831"/>with the basics and progress into an expert quickly to gain fine control within your release pipeline.</p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor277"/>Summary</h1>
<p>A CI system is a must in today’s software engineering process and a continuation of the effort that was put into TDD. </p>
<p>This chapter introduced GitHub Actions as a good example of a CI system and used the code of <a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a> as a realistic example. By completing this chapter, I trust you should be able to add CI configuration to your arsenal of tools.</p>
<p>In the next chapter, we will see how to consider adding tests to a brownfield project, as we don’t always have the luxury of starting a greenfield project all the time.</p>
<h1 id="_idParaDest-268"><a id="_idTextAnchor278"/>Further reading</h1>
<p>To learn more about the topics discussed in the chapter, you can refer to the following links:</p>
<ul>
<li><em class="italic">YAML files</em>: <a href="https://yaml.org/">https://yaml.org/</a> </li>
<li><em class="italic">GitHub Actions workflows</em>: <a href="https://docs.github.com/en/actions/using-workflows/about-workflows%0D">https://docs.github.com/en/actions/using-workflows/about-workflows</a></li>
<li><em class="italic">Continuous Integration</em> by Martin Fowler: <a href="https://martinfowler.com/articles/continuousIntegration.xhtml">https://martinfowler.com/articles/continuousIntegration.xhtml</a></li>
</ul>
</div>
</div>
</body></html>