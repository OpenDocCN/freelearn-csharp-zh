<html><head></head><body>
        

                            
                    Managing Dependencies with the Service Locator Pattern
                
            
            
                
<p>This chapter will be brief because the Service Locator pattern we will review is simple and efficient. The core idea of this pattern is straightforward: it revolves around having a central registry of initialized dependencies. But to be more precise, these dependencies are components that offer specific services that we can expose with interfaces we call "service contracts". Hence, when a client needs to call upon a particular service, it doesn't need to know how to localize and initialize it; it just needs to ask the Service Locator pattern, and this will do all the legwork to fulfill the service contract.</p>
<p class="mce-root">As we will see in this chapter, it's quite a simple design and is easy to implement.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the Service Locator pattern</li>
<li>Implementing a Service Locator pattern</li>
<li>Reviewing alternative solutions</li>
</ul>
<p>We simplified this chapter's code example for learning purposes, to present the pattern's core concepts without being distracted by the implementation details. So, the code shown is neither optimized nor contextualized enough to be used as-is in a project.</p>
<h1 id="uuid-a5c5c691-37ca-4211-9480-b820bec7c680">Technical requirements</h1>
<p>The following chapter is hands-on, so you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following Unity-specific engine and C# language concepts:</p>
<ul>
<li>Statics</li>
<li>Generics</li>
</ul>
<p>If unfamiliar with these concepts, please review <a href="c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml">Chapter 3</a>, <em>A Short Primer to Programming in Unity</em>.</p>
<p>The code files of this chapter can be found on GitHub, at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter16">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter16</a>.</p>
<p class="mce-root">Check out the following video to see the code in action: <a href="https://bit.ly/36AKWli">https://bit.ly/36AKWli</a></p>
<p class="mce-root"/>
<p>Static is a keyword modifier. A method declared as static in a class can be called without instantiating an object.  </p>
<h1 id="uuid-7c13f498-c9b0-45e4-bd9c-ec66e123b905">Understanding the Service Locator pattern</h1>
<p>Compared to more traditional patterns, the Service Locator pattern has less academic theory behind it and is very pragmatic in its overall design. As its name implies, its purpose is to locate services for a client. It achieves this by maintaining a central registry of objects that offer specific services.</p>
<p>Let's review a diagram of a typical Service Locator implementation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0d532f91-cc29-465f-ac92-14affd8ebd4f.png" style="width:52.67em;height:30.67em;"/></p>
<p>Figure 16.1 – Diagram of the Service Locator pattern</p>
<p>As we can see, we could easily say that the Service Locator pattern is acting as a proxy between the clients (requestors) and the service providers, and this approach decouples them to a certain degree. A client will only need to call the Service Locator pattern when it has a dependency to resolve and needs access to a service. We could say that the Service Locator pattern is acting similarly to a waiter in a restaurant, taking orders from clients and acting as an intermediary between the various services that the restaurant offers to its clientele.</p>
<p>The Service Locator pattern has a bad reputation in some circles; experts often criticize it for being an anti-pattern. The core reason for this criticism is that it violates several coding best practices as it hides class dependencies instead of exposing them. In consequence, this could make your code harder to maintain and test.</p>
<h2 id="uuid-cd6cdd5c-c5c0-4d69-a96a-8f99a0b1c801">Benefits and drawbacks of the Service Locator pattern</h2>
<p>Here are some of the potential benefits of using the Service Locator pattern:</p>
<ul>
<li><strong>Runtime optimization</strong>: The Service Locator pattern can optimize an application by dynamically detecting more optimized libraries or components to complete a specific service, depending on the runtime context.</li>
<li><strong>Simplicity</strong>: Service Locator is one of the most straightforward dependency management patterns to implement and doesn't have the steep learning curve of a <strong>dependency injection</strong> (<strong>DI</strong>) framework. Hence, you can quickly start using it in a project or teach it to colleagues.</li>
</ul>
<p>Here are some drawbacks of using the Service Locator pattern:</p>
<ul>
<li><strong>Black boxing</strong>: The Service Locator pattern's registry obfuscates class dependencies. Consequently, some issues might pop up at runtime instead of during compilation if dependencies are missing or incorrectly registered.</li>
<li><strong>Globally dependent</strong>: If overly used and with the wrong intentions, the Service Locator pattern can become a global dependency in itself that's arduous to manage. Your code will become excessively dependent on it, and eventually, it won't be easy to decouple it from the rest of your core components. </li>
</ul>
<p>The Service Locator pattern was popular among Java developers; it was defined in part by Martin Fowler in a blog post published in 2004, which you can read here:<br/>
<br/>
<a href="https://martinfowler.com/articles/injection.html">https://martinfowler.com/articles/injection.html</a></p>
<h2 id="uuid-671b573b-a614-4ef0-863f-baba3f438876">When to use the Service Locator pattern</h2>
<p class="mce-root">The question on when to use the Service Locator pattern is self-explanatory, based on its description. For example, if you have a list of services that you dynamically need to access but want to encapsulate the process involved in obtaining them, then this pattern can offer a solution.</p>
<p class="mce-root">But another aspect we should consider when contemplating using the Service Locator pattern is when not to use it. Because a Service Locator pattern is usually globally accessible, as its name implies, it should locate and provide access to services. Then, we should use it only to expose services that have a global scope.</p>
<p class="mce-root">For instance, we need to access the <strong>heads-up display</strong> (<strong>HUD</strong>) to update one of its <strong>user interface</strong> (<strong>UI</strong>) components. Should we consider the HUD a global service that should be accessible through the Service Locator pattern? The answer should be no, as the HUD only appears during certain parts of the game and should be accessible only by particular components in a specific context. But if we design a custom logging system, we could justify exposing it through a Service Locator pattern, as we might need to log information from anywhere in our code independently of context and scope.</p>
<p class="mce-root">Now that we have gone through the theory, let's get our hands dirty and write a Service Locator pattern to provide access to a logger, an analytics system, and an <strong>advertising network</strong> (<strong>ad network</strong>) provider.</p>
<h1 id="uuid-fc5532cf-54a7-4a17-a683-c33791036484">Implementing a Service Locator pattern</h1>
<p>We are going to implement a basic Service Locator pattern to expose three specific services, as follows:</p>
<ul>
<li><strong>Logger</strong>: A service that acts as a facade to a centralized logging system</li>
<li><strong>Analytics</strong>: A service that sends custom analytical information to a backend to provide insight on player behavior</li>
<li><strong>Advertisement</strong>: A service that pulls video <strong>advertisements</strong> (<strong>ads</strong>) from a network and displays them to monetize the game's content at specific moments</li>
</ul>
<p>We are adding these services to the registry of the Service Locator pattern because of their following characteristics:</p>
<ul>
<li>They offer a specific service.</li>
<li>They need to be accessible from anywhere in the code base.</li>
<li>They can be mocked or removed without causing any regression in the gameplay code.</li>
</ul>
<p>As we are going to see from the following code example, implementing a basic Service Locator pattern is a straightforward process. These are the steps we'll take:</p>
<ol>
<li>Let's start by implementing the most important ingredient—the <kbd>ServiceLocator</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">using System;<br/>using System.Collections.Generic;<br/><br/>namespace Chapter.ServiceLocator<br/>{<br/>    public static class ServiceLocator<br/>    {<br/>        private static readonly <br/>            IDictionary&lt;Type, object&gt; Services = <br/>                new Dictionary&lt;Type, Object&gt;();<br/><br/>        public static void RegisterService&lt;T&gt;(T service)<br/>        {<br/>            if (!Services.ContainsKey(typeof(T)))<br/>            {<br/>                Services[typeof(T)] = service;<br/>            }<br/>            else<br/>            {<br/>                throw new <br/>                    ApplicationException<br/>                    ("Service already registered");<br/>            }<br/>        }<br/><br/>        public static T GetService&lt;T&gt;()<br/>        {<br/>            try<br/>            {<br/>                return (T) Services[typeof(T)];<br/>            }<br/>            catch<br/>            {<br/>                throw new <br/>                    ApplicationException<br/>                    ("Requested service not found.");<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">This version of a Service Locator pattern has three primary responsibilities, outlined as follows:</p>
<ul>
<li>It manages a registry of services in the form of a <kbd>Dictionary</kbd>.</li>
<li>It offers a static function named <kbd>RegisterService()</kbd> that permits an object to be registered as a service.</li>
<li>It returns an instance of <kbd>service</kbd> of a specific type when requested through the <kbd>GetService()</kbd> function.</li>
</ul>
<p style="padding-left: 60px">It has to take into account that both <kbd>RegisterService()</kbd> and <kbd>GetService()</kbd> are static functions, hence they are accessible directly without needing to initialize the <kbd>ServiceLocator</kbd> class.</p>
<p style="padding-left: 60px" class="mce-root">The <kbd>Services</kbd> dictionary holds a list of available services, and we flagged it as <kbd>readonly</kbd> and <kbd>private</kbd>; thus, we protect it from being overridden or accessed directly. Instead, a client will have to go through the public methods that the Service Locator pattern exposes to add or get a service.</p>
<p style="padding-left: 60px">Now that we have our Service Locator class ready, we can now start implementing some service contracts in the form of interfaces.</p>
<ol start="2">
<li class="mce-root">Our first interface is for the <kbd>Logger</kbd> service, as illustrated in the following code snippet:</li>
</ol>
<pre style="color: black;padding-left: 60px">namespace Chapter.ServiceLocator<br/>{<br/>    public interface ILoggerService<br/>    {<br/>        void Log(string message);<br/>    }<br/>}</pre>
<ol start="3">
<li>The next interface is for the <kbd>Analytics</kbd> service, as we can see here:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.ServiceLocator<br/>{<br/>    public interface IAnalyticsService<br/>    {<br/>        void SendEvent(string eventName);<br/>    }<br/>}</pre>
<ol start="4">
<li>And lastly, we implement the code for our <kbd>Advertisement</kbd> service's interface, as follows:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.ServiceLocator<br/>{<br/>    public interface IAdvertisement<br/>    {<br/>        void DisplayAd();<br/>    }<br/>}</pre>
<ol start="5">
<li>And now, we are going to implement concrete service classes, starting with the <kbd>Logger</kbd> class. The code to accomplish this is illustrated in the following snippet:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.ServiceLocator<br/>{<br/>    public class Logger: ILoggerService<br/>    {<br/>        public void Log(string message)<br/>        {<br/>            Debug.Log("Logged: " + message);<br/>        }<br/>    }<br/>}</pre>
<ol start="6">
<li>Next up is the <kbd>Analytics</kbd> class. Here's the code you'll need to implement this:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.ServiceLocator<br/>{<br/>    public class Analytics : IAnalyticsService<br/>    {<br/>        public void SendEvent(string eventName)<br/>        {<br/>            Debug.Log("Sent: " + eventName);<br/>        }<br/>    }<br/>}</pre>
<ol start="7">
<li>And lastly, we implement our concrete <kbd>Advertisement</kbd> service class, as follows:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.ServiceLocator<br/>{<br/>    public class Advertisement : IAdvertisement<br/>    {<br/>        public void DisplayAd()<br/>        {<br/>            Debug.Log("Displaying video advertisement");<br/>        }<br/>    }<br/>}</pre>
<p>We now have a Service Locator pattern with services that we can register and access from anywhere.</p>
<h2 id="uuid-88441af5-0ce8-4bcc-9926-b9eb5a54bfe5">Testing the Service Locator pattern</h2>
<p class="mce-root">To test our implementation of the Service Locator pattern, let's write a client class that we will attach as a component to a GameObject in an empty Unity scene, as follows:</p>
<pre>using UnityEngine;<br/><br/>namespace Chapter.ServiceLocator<br/>{<br/>    public class ClientServiceLocator : MonoBehaviour<br/>    {<br/>        void Start() {<br/>            RegisterServices();<br/>        }<br/><br/>        private void RegisterServices() {<br/>            ILoggerService logger = new Logger();<br/>            ServiceLocator.RegisterService(logger);<br/><br/>            IAnalyticsService analytics = new Analytics();<br/>            ServiceLocator.RegisterService(analytics);<br/><br/>            IAdvertisement advertisement = new Advertisement();<br/>            ServiceLocator.RegisterService(advertisement);<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            GUILayout.Label("Review output in the console:");<br/><br/>            if (GUILayout.Button("Log Event")) {<br/>                ILoggerService logger = <br/>                    ServiceLocator.GetService&lt;ILoggerService&gt;();<br/>                <br/>                logger.Log("Hello World!");<br/>            }<br/><br/>            if (GUILayout.Button("Send Analytics")) {<br/>                IAnalyticsService analytics = <br/>                    ServiceLocator.GetService&lt;IAnalyticsService&gt;();<br/>                <br/>                analytics.SendEvent("Hello World!");<br/>            }<br/><br/>            if (GUILayout.Button("Display Advertisement")) {<br/>                IAdvertisement advertisement = <br/>                    ServiceLocator.GetService&lt;IAdvertisement&gt;();<br/>                <br/>                advertisement.DisplayAd();<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">It's important to note that in an actual implementation of the Service Locator pattern in a Unity project, we would register our services as early as possible during our game's lifespan so that they are made available at all times—for example, this task could be given to a <kbd>GameManager</kbd> object that we initialized in the first scene of our project. If we know that the scene and the Game Manager object will always be loaded when the player starts the game, we are sure the registry of the Service Locator pattern will be updated before clients start requesting access to services.</p>
<p class="mce-root">A key benefit of our approach is that we are registering services by referring to their interfaces, which means that at the moment we register services, we can choose which concrete implementation to use. Thus, we could easily have mock versions of each service running in a debug build. Furthermore, this approach will avoid adding noise to the logs and analytics during the <strong>quality assurance</strong> (<strong>QA</strong>) phase.</p>
<p class="mce-root">Hence, this is one of the cool features of this pattern; you can dynamically inject various service versions depending on the runtime context.</p>
<p>One of the main benefits of using Unity as your engine is that it offers a range of integrated services, including ads and analytics services, therefore most of the time, you will not have to implement them by hand. You can read about the range of available Unity services at the following link: <a href="https://docs.unity3d.com/Manual/UnityServices.html">https://docs.unity3d.com/Manual/UnityServices.html.</a></p>
<h1 id="uuid-1d0257df-8df3-4fbe-b058-3243fe1d1580">Reviewing alternative solutions</h1>
<p>If you are having issues with the management of dependencies in your code base, it might be time to start investigating the use of a DI framework. DI is a technique in which an object receives dependencies it needs through an "injection mechanism." There are several ways an object can receive its dependencies—through the constructor, a setter, or even with an interface that provides an injector method.</p>
<p class="mce-root">The best way to start using DI in a structured manner is through a framework because this gives you a helping hand in managing complex relationships between objects, the initialization process, and the lifespan of dependencies. In conclusion, you should start considering using a DI framework when you see tight coupling between classes and when their dependencies are becoming a bottleneck to writing consistent, testable, and maintainable code.</p>
<div><strong>Extenject</strong> is a free DI framework for Unity that can be downloaded from the Asset Store:<br/>
<br/>
<a href="https://assetstore.unity.com/packages/tools/utilities/extenject-dependency-injection-ioc-157735">https://assetstore.unity.com/packages/tools/utilities/extenject-dependency-injection-ioc-157735</a></div>
<h1 id="uuid-668d7363-1064-40eb-ac21-86a842ae5263">Summary</h1>
<p>In this chapter, we reviewed the Service Locator pattern. This pattern is a simple solution to resolving a recurring challenge of managing dependencies between objects relying on services (functionalities) that other objects offer. In its simplest form, the Service Locator pattern decouples the relationship between a client (requester) and a service provider.</p>
<p>We have arrived at the end of our journey, as this is the last chapter of the book. We hope you enjoyed the content of each chapter. Please remember that the concepts presented throughout this book are just introductions, not the final word on the subject matter. There's a lot more to learn about design patterns, Unity, and game development—so much that we can't define it in a single book. Thus, we encourage you to continue learning, take what we reviewed together in each chapter, and make it better because there's always room for improvement.</p>


            

            
        
    </body></html>