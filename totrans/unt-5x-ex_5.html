<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Project C – a 2D Adventure</h1></div></div></div><p>In this chapter, we will begin a completely new project; specifically, a 2D adventure game in which the player controls an alien character, exploring and navigating a dangerous world complete with quests and interactive elements. This project will incorporate elements and ideas from previous chapters as well as focus on new techniques, such as Complex Collisions, 2D Physics, Singletons and Statics, and more. In short, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">2D characters and player movement</li><li class="listitem" style="list-style-type: disc">Assembling complex and multipart characters</li><li class="listitem" style="list-style-type: disc">Level design</li><li class="listitem" style="list-style-type: disc">2D Physics and collision detection<div><div><h3 class="title"><a id="note19"/>Note</h3><p>The starting project and assets can be found in the book companion files in the <code class="literal">Chapter05/Start</code> folder. You can start here and follow along with this chapter if you don't have your own project already.</p></div></div></li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>A 2D Adventure – getting started</h1></div></div></div><p>Adventure <a id="id303" class="indexterm"/>games require the player to use their cunning, dexterity, mental sharpness, and acumen to make progress. Such games feature dangerous obstacles, challenging missions, and character interaction, as opposed to <em>all-out</em> action like many first-person shooter games. Our adventure game will be no exception. See <em>Figure 5.1</em> for a glimpse of the game that we'll create. In this game, the player moves around using the keyboard arrows or <em>W</em>, <em>A</em>, <em>S</em>, <em>D</em> keys. Furthermore, they can jump with the spacebar and interact with characters simply by approaching them. During the game, the player will be tasked with a mission from an NPC character to collect an ancient gem hidden somewhere within a level. The player must then navigate dangerous obstacles in search of the gem, and then finally collect it before returning to the NPC, completing the game.</p><div><img src="img/figure_05_01.jpg" alt="A 2D Adventure – getting started"/><div><p>Figure 5.1: The 2D adventure game to create</p></div></div><p>To get started with creating the adventure, create a completely new and empty Unity project, and then import the <code class="literal">Particles</code>, <code class="literal">Effects</code>, <code class="literal">Characters</code>, <code class="literal">2D</code>, <code class="literal">ParticleSystems</code>, and <code class="literal">CrossPlatformInput</code> packages. You can import these from the <strong>Project Creation Wizard</strong> or from the <a id="id304" class="indexterm"/>application menu via the <strong>Assets</strong> | <strong>Import Packages</strong> option. See <em>Figure 5.2</em>. Details on how to import standard assets are included in <a class="link" href="ch01.html" title="Chapter 1. The Coin Collection Game – Part 1">Chapter 1</a>, <em>The Coin Collection Game – Part 1</em>.</p><div><img src="img/figure_05_02.jpg" alt="A 2D Adventure – getting started"/><div><p>Figure 5.2: Importing packages to a new project from the Project Creation screen</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Importing assets</h1></div></div></div><p>Starting from an empty <a id="id305" class="indexterm"/>project created in the previous section, let's now import the texture assets we'll be using, both for the player character and environment. The assets to import are included in the book companion files in the <code class="literal">Chapter05/Assets</code> folder. From here, select all textures together in Windows Explorer or Mac Finder, and drag and drop them to the Unity Project panel in a designated <code class="literal">Textures</code> folder. (Create one if you haven't already!). This imports all relevant textures to the active Project. See <em>Figure 5.3</em>:</p><div><img src="img/figure_05_03.jpg" alt="Importing assets"/><div><p>Figure 5.3: Importing texture assets to the Project</p></div></div><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Remember that you can always use the Thumbnail Size Slider (at the bottom right corner of the Project panel) to adjust the size of thumbnail previews in order  to get an easier view of your texture assets.</p></div></div><p>By default, Unity <a id="id306" class="indexterm"/>assumes that all imported textures will eventually be used as regular textures applied to 3D models in the scene, such as cubes, spheres, and meshes. In most cases, this assumption is correct because most games are 3D. However, for 2D games like the one we're making, the settings should be different. In our case, objects don't recede in the distance, moving further away, but just remain at a constant offset from the camera. For this reason, we must adjust some crucial properties for all imported textures. Specifically, select all imported textures, and, from the <strong>Object Inspector</strong>, change the <strong>Texture Type</strong> field from <strong>Texture</strong> to <strong>Sprite 2D and UI</strong>. Then, remove the check mark from the <strong>Generate Mip Maps</strong> box. Then, click on the <strong>Apply</strong> button. When you do this, Unity flags the assets as having a <em>2D usage</em> internally. It allows transparent backgrounds to be applied where applicable (such as for PNG sprites) and also has important performance implications for graphics rendering, as we'll see. See <em>Figure 5.4</em>:</p><div><img src="img/figure_05_04.jpg" alt="Importing assets"/><div><p>Figure 5.4: Configuring imported textures</p></div></div><p>Now that we've <a id="id307" class="indexterm"/>imported all essential textures for the project, let's configure our main scene, game camera, and target resolution. Switch to the <strong>Game</strong> tab and set the resolution to <strong>1024 x 600</strong>; which works well across many devices. To do this, click on the <strong>Free Aspect</strong> button from the <strong>Game</strong> tab toolbar and pick <strong>1024 x 600</strong> from the drop-down menu, if it appears as an option. If not, click on the <strong>+</strong> button from the bottom of the list to add the new resolution. See <em>Figure 5.5</em>:</p><div><img src="img/figure_05_05.jpg" alt="Importing assets"/><div><p>Figure 5.5: Adding game resolutions</p></div></div><p>To add a new <a id="id308" class="indexterm"/>resolution, enter a custom name in the <strong>Name</strong> field, select <strong>Fixed Resolution</strong> from the <strong>Type</strong> drop-down, and then type your resolution dimensions in the <strong>Width &amp; Height</strong> fields. Once completed, click on <strong>OK</strong>. Your target resolution should then be added as a selectable option from the <strong>Game</strong> tab. See <em>Figure 5.6</em>:</p><div><img src="img/figure_05_06.jpg" alt="Importing assets"/><div><p>Figure 5.6: Creating a custom resolution</p></div></div><p>Next, we'll configure the scene camera for a 2D setup so that our textures, when added as sprites, will display onscreen at a 1:1 ratio, texel for pixel. To achieve this, select the <strong>MainCamera</strong> in the scene, either by clicking on it in the <strong>Scene viewport</strong> or selecting it in the <strong>Scene Hierarchy</strong>. Then, from the <strong>Object Inspector</strong>, change <strong>Projection</strong> to <strong>Orthographic</strong>. This ensures that the camera displays objects in true 2D with perspective and foreshortening effects removed. Then change the camera Size to <code class="literal">3</code>. The formula for this field is <em>Screen Height / 2 / Pixel to World</em>. In this case, the <em>Screen Height</em> is <em>600</em>. Thus, <em>600 / 2 = 300</em>. Then, <em>300 / 100 = 3</em>. <em>100</em> refers to the pixel to world ratio applied to sprite textures; this details how many pixels in the texture will be mapped to a square meter in the world. A <a id="id309" class="indexterm"/>value of <code class="literal">1</code> means <em>1 pixel = 1 meter</em>. This value can be viewed and changed by selecting a sprite in the <strong>Project</strong> panel and changing the <strong>Pixel to World ratio</strong> field in the <strong>Object Inspector</strong>. See <em>Figure 5.7</em>:</p><div><img src="img/figure_05_07.jpg" alt="Importing assets"/><div><p>Figure 5.7: Configuring camera orthographic size</p></div></div><p>To test the <a id="id310" class="indexterm"/>camera and scene settings, simply drag and drop a background texture from the <strong>Project</strong> panel to the scene. The <strong>Background</strong> textures are sized at exactly 1024 x 600 to fit the scene background. Therefore, when added to a scene and when the camera is configured correctly, the background textures should fill the screen. See <em>Figure 5.8</em>:</p><div><img src="img/figure_05_08.jpg" alt="Importing assets"/><div><p>Figure 5.8: Testing the camera settings with a texture</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Creating an environment – getting started</h1></div></div></div><p>Our adventure <a id="id311" class="indexterm"/>game will feature three separate but connected scenes, which the player may explore, moving from one scene to the next. The player may travel between scenes, simply by walking off the edge of one and then moving into the next. Each scene consists primarily of platforms and ledges and, in some cases, dangers and obstacles. In terms of graphical assets, each scene is made from two textures or sprites: the background and foreground. An example for Scene 1 is shown in <em>Figures 5.9</em> and and <em>Figure 5.10</em>. <em>Figure 5.9</em> represents the background scene and <em>Figure 5.10</em> represents the foreground, which includes a complete layout of all the platforms and ledges that the player must traverse. These files are included in the book companion files in the <code class="literal">Chapter05/Assets</code> folder:</p><div><img src="img/figure_05_09.jpg" alt="Creating an environment – getting started"/><div><p>Figure 5.9: Scene background - tex_level01_bck.png</p></div></div><div><img src="img/figure_05_10.jpg" alt="Creating an environment – getting started"/><div><p>Figure 5.10: Scene foreground - tex_level01_design.png</p></div></div><p>Let's create the first level now, based on the sprites in <em>Figures 5.9</em> and <em>Figure 5.10</em>. To do this, use the existing empty scene, or create a new scene, ensuring that the scene camera is configured to <a id="id312" class="indexterm"/>display textures at their native size. Then, drag and drop both the background and foreground sprites from the <strong>Project</strong> panel to the scene. Both will be added to the scene as separate sprite objects. Then, position them both to the World Origin at (0,0,0). See <em>Figure 5.11</em>:</p><div><img src="img/figure_05_11.jpg" alt="Creating an environment – getting started"/><div><p>Figure 5.11: Adding a scene background and foreground</p></div></div><div><div><h3 class="title"><a id="note21"/>Note</h3><p>If you drag and drop both the background and foreground textures together as one selection from the <strong>Project</strong> panel to the scene, Unity may ask you to create an Animation when you release your mouse. In such cases, Unity assumes that you want to create an animated sprite in which each selected texture becomes a frame of animation played in a sequence. You don't want to do this; instead, drag and drop each sprite to a separate <strong>Hierarchy</strong> panel, allowing both the foreground and background to be seen at the same time.</p></div></div><p>Both sprite objects are now added to the scene at the same world position (0,0,0). The question arises now <a id="id313" class="indexterm"/>as to which sprite Unity should display on top, given that both sprites overlap one another. Left as it is right now, there is a conflict and ambiguity about depth order, and we cannot rely on Unity consistently showing the correct sprite on top. We can solve this problem with two methods: one is to move the sprite forward in the <em>Z</em> axis, closer to the Orthographic camera; and the other is to change its <strong>Order</strong> setting from the <strong>Object Inspector</strong>. High values for <strong>Order</strong> result in the sprite appearing atop lower-order sprites. Here, I'll use both methods and that's fine too! See <em>Figure 5.12</em>. Note, however, that <strong>Order</strong> always takes precedence over <strong>Position</strong>. This means that higher-order objects will always appear on top of lower-order objects, even if higher-order objects are positioned behind lower-order objects.</p><div><img src="img/figure_05_12.jpg" alt="Creating an environment – getting started"/><div><p>Figure 5.12: Ordering sprite layers in a scene</p></div></div><p>Before moving further, let's get organized in terms of scene hierarchy to prevent overcomplication and confusion happening later. Select each environment object and name them appropriately. I named the background <code class="literal">scene_background</code> and the foreground <code class="literal">scene_foreground</code>. Having done this, create a new, empty <strong>GameObject</strong> named <code class="literal">Env</code> (for Environment), which will be the ultimate parent or ancestor of all static (non-movable) objects in the environment. This lets us group together all related objects easily. To do this, choose <strong>GameObject</strong> | <strong>Create Empty</strong> from the application menu, position the created empty object to the world origin, and drag and drop both the background and foreground objects as its children. See <em>Figure 5.13</em>:</p><div><img src="img/figure_05_13.jpg" alt="Creating an environment – getting started"/><div><p>Figure 5.13: Organizing the scene hierarchy</p></div></div><p>By switching to the Game tab, we can get an early preview of the level as it will appear to the gamer in terms of mood and emotional resonance. This feel can be enhanced further by adding some Camera Post-process Effects. These refer to pixel-based effects that can be applied to the camera in order to enhance the atmosphere of the final, rendered image on each frame. The <a id="id314" class="indexterm"/>
<strong>Image Effects</strong> are included in the Effects package, which you should have imported during the project creation phase. If you did not import the package at that time, you can do so now by navigating to <strong>Assets</strong> | <strong>Import Package</strong> | <strong>Effects</strong>. The <strong>Image Effects</strong> assets are stored in the <code class="literal">Standard Assets/Effects</code> folder. Once imported, you can add Image Effects to the selected camera via the Application Menu by choosing <strong>Component</strong> | <strong>Image Effects</strong> and then choosing the effect to add. See <em>Figure 5.14</em>:</p><div><img src="img/figure_05_14.jpg" alt="Creating an environment – getting started"/><div><p>Figure 5.14: Adding Image Effects to the selected camera</p></div></div><p>For this level, and all other levels in the game, I'll add the following two image effects: <strong>Bloom Optimized</strong> and <strong>Noise and Grain</strong>. Once added, you will typically need to adjust the sliders and settings in the <strong>Inspector</strong> to achieve the look you want, continually previewing the result in the <strong>Game</strong> <a id="id315" class="indexterm"/>tab. The <strong>Scene</strong> tab remains unaffected by image effects. The complete range of settings I've used for both image effects are included in <em>Figure 5.15</em>. In many cases, these settings will take some trial and error—tweak values and observe the effect.</p><div><img src="img/figure_05_15.jpg" alt="Creating an environment – getting started"/><div><p>Figure 5.15: Image Effects applied to the game camera</p></div></div><p>Good work. The scene so far features a background and foreground taken from texture files and enhancing <a id="id316" class="indexterm"/>special effects using the Image Effects assets package. This is a great start, but there's still much to do so let's move on!</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Environment Physics</h1></div></div></div><p>The main problem <a id="id317" class="indexterm"/>with our level as it stands is that it lacks interactivity. Specifically, if we dragged and dropped a player object to the level and pressed play on the toolbar, the player would drop through the floor and walls because the foreground texture isn't recognized by Unity as a solid object. It's just a texture and exists only in appearance and not in substance. In this section, we'll correct this using Physics and Colliders. To get started, we'll create a temporary player object (not the final version but just a temporary <em>White Box</em> version used only for testing purposes). To create this, generate a capsule object in the scene by navigating to <strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Capsule</strong> from the application menu. Set the <em>Z</em> position of the transform to match the foreground texture (for me, this is <code class="literal">-2</code>). Once generated, remove <strong>Capsule Collider</strong> from the object. By default, the Capsule is assigned a 3D collider (such as the <strong>Capsule Collider</strong>), which is useful primarily for 3D physics, but our game will be 2D. To remove the Collider, click on the Cog icon on the <strong>Capsule Collider</strong> component in the <strong>Object Inspector</strong> and choose <strong>Remove Component</strong> from the menu. See <em>Figure 5.16</em>:</p><div><img src="img/figure_05_16.jpg" alt="Environment Physics"/><div><p>Figure 5.16: Removing a Capsule Collider component</p></div></div><p>To make the object compatible with 2D Physics, add a Circle Collider component by choosing <a id="id318" class="indexterm"/>
<strong>Component</strong> | <strong>Physics 2D</strong> | <strong>Circle Collider</strong> from the application menu. Once added, use the <strong>Offset</strong> and <strong>Radius</strong> settings on the Circle Collider component in the Inspector to adjust the size and position of the circle in relation to the capsule object in order to approximate the feet of a player character. To aid you in positioning the <strong>Circle Collider</strong> more easily, you can switch the <strong>Scene</strong> viewport mode to <strong>Wireframe</strong> and <strong>2D</strong>, if needed. To do this, use the <strong>2D Toggle</strong> button and the <strong>Scene Render</strong> mode drop-down button in the viewport toolbar. See <em>Figure 5.17</em>:</p><div><img src="img/figure_05_17.jpg" alt="Environment Physics"/><div><p>Figure 5.17: Adjusting the Circle Collider for the player character</p></div></div><p>Next, to make the <strong>Circle Collider</strong> work with 2D Physics, add a RigidBody2D component to the Capsule. To do this, select <strong>Component</strong> | <strong>Physics 2D</strong> | <strong>RigidBody2D</strong> from the application menu. You can confirm that this has worked by previewing the game in Play mode. When you click on the play icon, the Capsule object should fall down and through the foreground floor under the effect of gravity. See <em>Figure 5.18</em>:</p><div><img src="img/figure_05_18.jpg" alt="Environment Physics"/><div><p>Figure 5.18: Adding a Rigidbody 2D component to a test character</p></div></div><p>Now, it's <a id="id319" class="indexterm"/>time to configure the foreground texture to work as a unified whole with physics. Right now, our test player character falls through the floor and this is not what we want. To fix this, we'll need to add a collider to the foreground environment. One method for this is to use Edge Collider 2D. This lets you draw out a low polygon mesh collider around your ground image manually, approximating the terrain. To get started, select the foreground in the scene and then choose <strong>Component</strong> | <strong>Physics 2D</strong> | <strong>Edge Collider 2D</strong> from the application menu. Doing this will add an Edge Collider 2D component to the foreground object. See <em>Figure 5.19</em>:</p><div><img src="img/figure_05_19.jpg" alt="Environment Physics"/><div><p>Figure 5.19: Adding an Edge Collider</p></div></div><p>By default, adding an Edge Collider 2D appears to have little effect on the selected object or any other objects, except for a single horizontal line drawn across the width of the scene. This can be seen in the <strong>Scene</strong> tab when the <strong>Foreground</strong> object is selected and in the <strong>Game</strong> tab if the <strong>Gizmos</strong> tool button is enabled. If the player is positioned above the horizontal line and <a id="id320" class="indexterm"/>you press Play on the toolbar, the player character will fall downward and treat the horizontal edge as a solid platform. See <em>Figure 5.20</em>:</p><div><img src="img/figure_05_20.jpg" alt="Environment Physics"/><div><p>Figure 5.20: The Edge Collider is useful to approximate platforms and solid surfaces</p></div></div><p>Of course, our terrain isn't simply a straight-edged surface. Rather, it has elevations, bumps, and platforms. These can be approximated closely with the Edge Collider 2D component using the <strong>Collider Edit</strong> mode. To access this mode, click on the <strong>Edit Collider</strong> button from the <strong>Object Inspector</strong>. See <em>Figure 5.21</em>:</p><div><img src="img/figure_05_21.jpg" alt="Environment Physics"/><div><p>Figure 5.21: The Edit Collider mode lets you change the shape of an Edge Collider 2D</p></div></div><p>With the <strong>Edit Collider</strong> mode active, you can reshape the collider to conform to the terrain. Let's focus on one area such as the bottom right-hand side of the terrain. By moving your mouse cursor over the edge points of the <strong>Edge Collider</strong> (the green line), you can click and drag to reposition it. To approximate the bottom right island of the terrain, click and drag <a id="id321" class="indexterm"/>the rightmost edge point to the right-hand side of the scene. See <em>Figure 5.22</em>:</p><div><img src="img/figure_05_22.jpg" alt="Environment Physics"/><div><p>Figure 5.22: Starting to reshape the Edge Collider to approximate the terrain</p></div></div><p>Next, click and drag the left point of the collider to match with the leftmost edge of the right-hand island. See <em>Figure 5.23</em>:</p><div><img src="img/figure_05_23.jpg" alt="Environment Physics"/><div><p>Figure 5.23: Positioning the left-most of the right-hand island</p></div></div><p>Now that the left and right edge points are positioned, let's add some additional points on the line between to reshape it, conforming to the right-hand island. Move your cursor anywhere on the line, click and drag to insert a new point, and reposition it to match the island. Repeat this process, adding additional points to reshape the line as needed. See <em>Figure 5.24</em>:</p><div><img src="img/figure_05_24.jpg" alt="Environment Physics"/><div><p>Figure 5.24: Shaping the Edge Collider to the right-most island</p></div></div><p>You now have a fully shaped line that matches the terrain's right-most island. Having created this, exit the <strong>Edit Collider</strong> mode by simply clicking on the <strong>Edit Collider</strong> button again from the <strong>Object Inspector</strong>. To create colliders for the remaining islands of the terrain, add a new <strong>Edge Collider</strong> to the same object. You can then add any number of <strong>Edge Colliders</strong> to a single object, and each collider should be used to approximate the topology of a single, isolated island in the complete terrain. See <em>Figure 5.25</em>:</p><div><img src="img/figure_05_25.jpg" alt="Environment Physics"/><div><p>Figure 5.25: Multiple Edge Colliders on one object can be used to approximate complex terrain</p></div></div><p>Multiple Edge Collider components are now added together to a single foreground object, approximating the complete terrain for the scene. We can now test play collisions against the <strong>Player Capsule</strong> object by pressing the play icon on the toolbar and seeing how the capsule reacts against the terrain. This time, the capsule will collide and interact with the ground as opposed to passing <a id="id322" class="indexterm"/>through. This confirms that the terrain is configured appropriately with the physics system. See <em>Figure 5.26</em>:</p><div><img src="img/figure_05_26.jpg" alt="Environment Physics"/><div><p>Figure 5.26: Capsule Object interacting with a terrain made from Edge Colliders</p></div></div><p>Congratulations! In this section, we've created a complete terrain for a single scene using Edge Collider components. This terrain not only fits the screen and appears as intended, but acts as a physical obstacle for the player character and other physics-based objects. Of course, so far, we've been using a rough approximation for the player and now it's time to expand upon this.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Creating a player</h1></div></div></div><p>The player <a id="id323" class="indexterm"/>character is a small, green alien-looking creature that can be controlled and guided by the gamer through a level using many conventional platform-game mechanics, such as walking, jumping, and interacting. In the previous section, we built a <em>White Box</em> (prototype) character to test physical interactions with the environment, but here, we'll develop the player character in more depth. <em>Figure 5.27</em> illustrates our character texture imported earlier in the chapter, representing all limbs and parts for the player:</p><div><img src="img/figure_05_27.jpg" alt="Creating a player"/><div><p>Figure 5.27: Character and his limbs in a consolidated texture</p></div></div><p>The player texture, as <a id="id324" class="indexterm"/>shown in <em>Figure 5.27</em>, is called an <strong>Atlas Texture</strong> or <strong>Sprite Sheet</strong> <a id="id325" class="indexterm"/>because it contains all frames or parts of a character in a single texture space. The problem with this texture, as it stands, is that when dragged and <a id="id326" class="indexterm"/>dropped from the <strong>Project</strong> panel to the scene, it'll be added as a single, self-contained sprite. This is because Unity recognizes all the separate parts as a single sprite. Rather, these should be separated into distinct units. See <em>Figure 5.28</em>:</p><div><img src="img/figure_05_28.jpg" alt="Creating a player"/><div><p>Figure 5.28: The player sprite texture needs to be divided into separate parts</p></div></div><p>To divide the character texture into separate parts on a per-limb basis, we'll use <strong>Sprite Editor</strong>. To access this tool, select the character texture in the <strong>Project</strong> panel. Then, from the <strong>Object Inspector</strong>, change <strong>Sprite Mode</strong> from <strong>Single</strong> to <strong>Multiple</strong>. Then, click on <strong>Apply</strong>. Next, click on the <strong>Sprite Editor</strong> button to open the <strong>Sprite Editor</strong> tool, allowing you cut apart the whole texture into specific slices. See <em>Figure 5.29</em>:</p><div><img src="img/figure_05_29.jpg" alt="Creating a player"/><div><p>Figure 5.29: Specifying a sprite as Multiple</p></div></div><p>With the <strong>Sprite Editor</strong> tool, you can separate different parts of a texture into discrete and separate units. One <a id="id327" class="indexterm"/>method to achieve this is by drawing a rectangle around each image area that should be separate, and simply clicking and dragging your mouse to draw a texture region. See <em>Figure 5.30</em>:</p><div><img src="img/figure_05_30.jpg" alt="Creating a player"/><div><p>Figure 5.30: Drawing a sprite manually</p></div></div><p>Now, although a sprite can be separated manually, as we've just seen, Unity can often cut apart the texture automatically, identifying isolated areas of pixels and saving us a lot of time. We'll do that here for the player character. To do this, click on the <strong>Slice</strong> button listed at the top <a id="id328" class="indexterm"/>left corner of the <strong>Sprite Editor</strong> window. See <em>Figure 5.31</em>:</p><div><img src="img/figure_05_31.jpg" alt="Creating a player"/><div><p>Figure 5.31: Accessing the Slice tool</p></div></div><p>From the <strong>Slice</strong> tool window, ensure that <strong>Type</strong> is set to <strong>Automatic</strong>, which means that Unity will auto-detect the location of separate sprites. <strong>Pivot</strong> can be left at <strong>Center</strong>, determining the pivot point for each sprite. <strong>Method</strong> should be <strong>Delete Existing</strong>, meaning that any existing sprites or slices in the texture space will be erased and replaced entirely by the newly autogenerated slices. Then, click on the <strong>Slice</strong> button to confirm the operation and the texture will be sliced into separate sprites with a clear border drawn around each sprite. See <em>Figure 5.32</em>:</p><div><img src="img/figure_05_32.jpg" alt="Creating a player"/><div><p>Figure 5.32: A fully sliced sprite</p></div></div><p>The texture is now divided into several sprites: head, body, arm, and leg. The final character in-scene will obviously have two arms and two legs but these will be formed from duplicated sprites. The final process now is to set the pivot point for each sprite—the point around which the sprite will rotate. This will be important later to animate the character correctly, as we'll see. Let's start by setting the pivot for the head. Select the head sprite in the editor and then click and drag the pivot handle (blue circle) to reposition the sprite's center of rotation. Click and drag the handle to the bottom middle of the head, roughly <a id="id329" class="indexterm"/>where the head would connect to the neck. This makes sense because the head will rotate and hinge from around this point. As you move the pivot around, you should see the <strong>X</strong> and <strong>Y</strong> values change from the <strong>Custom Pivot</strong> field in the <strong>Sprite Properties</strong> dialog, shown in the bottom right-hand corner of the <strong>Sprite Editor</strong> window. See <em>Figure 5.33</em>:</p><div><img src="img/figure_05_33.jpg" alt="Creating a player"/><div><p>Figure 5.33: Repositioning the sprite pivot</p></div></div><p>Next, position the pivot for the arm, which should be at the shoulder joint where the arm connects to a torso; then <a id="id330" class="indexterm"/>for the leg, which should be near the hip where the leg connects to a torso, and finally, the torso itself, whose pivot should be at the hip joint. See <em>Figure 5.34</em>:</p><div><img src="img/figure_05_34.jpg" alt="Creating a player"/><div><p>Figure 5.34: Positioning the pivot for the torso</p></div></div><p>When completed, click on the <strong>Apply</strong> button to confirm changes and then close the <strong>Sprite Editor</strong>. On returning to the main Unity interface, the appearance of the character texture will have changed in the <strong>Project</strong> panel. Specifically, the character texture features a small arrow icon attached to the right-hand side. When you click this, the texture expands to review all the separate <a id="id331" class="indexterm"/>sprites in a row, which can be dragged and dropped individually to the scene. See <em>Figure 5.35</em>:</p><div><img src="img/figure_05_35.jpg" alt="Creating a player"/><div><p>Figure: 5.35: Previewing character sprites</p></div></div><p>Now that we've isolated all player sprite textures, we can start to build a game character in the scene. Start by creating an empty game object with the <strong>GameObject</strong> | <strong>Create Empty</strong> command from the application menu. Name the object <code class="literal">Player</code> and assign it a Player Tag from the Inspector. This object will act as the ultimate or topmost parent object for the player character. Existing beneath this object as children will be the character's constituent parts: torso, arms, and legs. So, let's drag and drop the Torso sprite from the <strong>Project</strong> panel to the <strong>Hierarchy</strong> panel as a child of the <strong>Player</strong> object. See <em>Figure 5.36</em>:</p><div><img src="img/figure_05_36.jpg" alt="Creating a player"/><div><p>Figure 5.36: Starting the player character</p></div></div><p>After the torso has been added, we can add legs and arms. The arms should be added as children of the torso because the torso determines where the arms will be. However, the legs should be added as <a id="id332" class="indexterm"/>children of the <strong>Player</strong> object and are therefore siblings of the torso, because the torso can rotate independently of the legs. See <em>Figure 5.37</em> for the complete hierarchical arrangement. As you add each limb, you'll want to offset its position so that it appears correctly in relation to other limbs—the head should appear above the feet and so on.</p><div><img src="img/figure_05_37.jpg" alt="Creating a player"/><div><p>Figure 5.37: Building a character</p></div></div><p>The rendering order of body parts is probably not correct by default insofar as each item will have an identical order in the Sprite Renderer component. This means that Unity could potentially render each limb in any order, allowing arms to appear in front of the head, legs to appear in front of the body, and so on. To correct this, we'll select each limb in turn and assign it an appropriate order value, taking care that it's higher than the world background order and less than the world foreground order. I've assigned the body an order of <code class="literal">103</code>, the head <a id="id333" class="indexterm"/>
<code class="literal">105</code>, left arm <code class="literal">102</code>, right arm <code class="literal">104</code>, left leg <code class="literal">100</code>, and right leg <code class="literal">101</code>. See <em>Figure 5.38</em>:</p><div><img src="img/figure_05_38.jpg" alt="Creating a player"/><div><p>Figure 5.38: Ordering body parts</p></div></div><p>The rendering order for limbs is now configured successfully. Let's set up collisions and physics for the player. To do this, add two colliders—a Circle Collider to approximate the character feet, allowing us to determine when the character is in contact with the ground, and a Box Collider that approximates most of the body including the head. These colliders can be added by selecting the <strong>Player</strong> object (the topmost object) and then navigating to <strong>Component</strong> | <strong>Physics 2D</strong> | <strong>Circle Collider 2D</strong> and <strong>Component</strong> | <strong>Physics 2D</strong> | <strong>Box Collider 2D</strong>. See <em>Figure 5.39</em>:</p><div><img src="img/figure_05_39.jpg" alt="Creating a player"/><div><p>Figure 5.39: Adding two colliders to the Player Object: Circle Collider and Box Collider</p></div></div><p>The Circle Collider is of special importance because it's the primary means to determine whether the character is touching the ground, and it'll also be in contact with the ground as the character moves. For <a id="id334" class="indexterm"/>this reason, a Physics Material should be assigned to this collider to prevent friction effects from stopping or corrupting character motion as it moves around the scene. To achieve this, create a new Physics Material by right-clicking in the empty space in the <strong>Project</strong> panel and choose <strong>Create</strong> | <strong>Physics2D Material</strong> from the context menu. Name the material <code class="literal">Low Friction</code>. See <em>Figure 5.40</em>:</p><div><img src="img/figure_05_40.jpg" alt="Creating a player"/><div><p>Figure 5.40: Creating a new Physics Material</p></div></div><p>Select the Physics2D material in the <strong>Project</strong> panel, and from the <strong>Inspector</strong>, change the Friction setting to <code class="literal">0.1</code>. Then, drag and drop the Physics2D material from the <strong>Project</strong> panel to the <strong>Material</strong> slot for the CircleCollider2D component on the <strong>Player</strong> object. See <em>Figure 5.41</em>. Using these settings, the character will behave more realistically.</p><div><img src="img/figure_05_41.jpg" alt="Creating a player"/><div><p>Figure 5.41: Assigning a Physics material to the player character</p></div></div><p>Then, finally assign RigidBody2D to the <strong>Player</strong> object and set both <strong>Linear Drag</strong> and <strong>Gravity Scale</strong> to <code class="literal">3</code>. In addition, set <strong>Collison Detection</strong> to <strong>Continuous</strong> for the most accurate collision detection and <strong>Freeze Rotation</strong> of the object on the <em>Z</em> axis because the player character should <a id="id335" class="indexterm"/>never rotate. Now, you have a fully completed physical object representing the player. See <em>Figure 5.42</em>. Good work!</p><div><img src="img/figure_05_42.jpg" alt="Creating a player"/><div><p>Figure 5.42: Configuring the player character for Physics</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Scripting the player movement</h1></div></div></div><p>The game so far <a id="id336" class="indexterm"/>features an environment with collision data and a multipart player object that interacts and responds to this environment. The player, however, cannot yet be controlled, and this section explores controller functionality further. The user will have two main input mechanics, namely, movement (walking left and right) and jumping. This input can be read seamlessly and easily using <code class="literal">CrossPlatformInputManager</code>, which is a native Unity asset package. This package was imported at the project creation phase, but it can be imported now via the application menu with <strong>Assets</strong> | <strong>Import Package</strong> | <strong>CrossPlatformInput</strong>. Once imported, open the <code class="literal">Standard Assets</code> | <code class="literal">CrossPlatformInput</code> | <code class="literal">Prefabs</code> folder and drag and drop the <strong>MobileTiltControlRig</strong> prefab to the scene. This prefab lets you read input data across a range of devices, mapping directly to the horizontal and vertical axes that we've already seen in previous chapters. See <em>Figure 5.43</em>:</p><div><img src="img/figure_05_43.jpg" alt="Scripting the player movement"/><div><p>Figure 5.43: Cross-platform input prefabs offer easy multidevice control</p></div></div><p>Let's now script player controls. To do this, create a new C# script named <code class="literal">PlayerControl.cs</code> and attach it to the Player character. The full source code for this file is given in <a id="id337" class="indexterm"/>the  <em>Code Sample 5.1</em>:</p><div><pre class="programlisting">//--------------------------------
using UnityEngine;
using System.Collections;
using UnityStandardAssets.CrossPlatformInput;
//--------------------------------
public class PlayerControl : MonoBehaviour
{
  //--------------------------------
  public enum FACEDIRECTION {FACELEFT = -1, FACERIGHT = 1};
  //Which direction is the player facing - left or right?
  public FACEDIRECTION Facing = FACEDIRECTION.FACERIGHT;
  //Which objects are tagged as ground
  public LayerMask GroundLayer;
  //Reference to rigidbody
  private Rigidbody2D ThisBody = null;
  //Reference to transform
  private Transform ThisTransform = null;
  //Reference to feet collider
  public CircleCollider2D FeetCollider = null;
  //Are we touching the ground?
  public bool isGrounded = false;
  //What are the main input axes
  public string HorzAxis = "Horizontal";
  public string JumpButton = "Jump";
  //Speed variables
  public float MaxSpeed = 50f;
  public float JumpPower = 600;
  public float JumpTimeOut = 1f;
  //Can we jump right now?
  private bool CanJump = true;
  //Can we control player?
  public bool CanControl = true;
  public static PlayerControl PlayerInstance = null;
  //--------------------------------
  public static float Health
  {
    get
    {
      return _Health;
    }

    set
    {
      _Health = value;

      //If we are dead, then end game
      if(_Health &lt;= 0)
      {
        Die();
      }
    }
  }

  [SerializeField]
  private static float _Health = 100f;
  //--------------------------------
  // Use this for initialization
  void Awake ()
  {
    //Get transform and rigid body
    ThisBody = GetComponent&lt;Rigidbody2D&gt;();
    ThisTransform = GetComponent&lt;Transform&gt;();

    //Set static instance
    PlayerInstance = this;
  }
  //--------------------------------
  //Returns bool - is player on ground?
  private bool GetGrounded()
  {
    //Check ground
    Vector2 CircleCenter = new Vector2(ThisTransform.position.x, ThisTransform.position.y) + FeetCollider.offset;
    Collider2D[] HitColliders = Physics2D.OverlapCircleAll(CircleCenter, FeetCollider.radius, GroundLayer);
    if(HitColliders.Length &gt; 0) return true;
    return false;
  }
  //--------------------------------
  //Flips character direction
  private void FlipDirection()
  {
    Facing = (FACEDIRECTION) ((int)Facing * -1f);
    Vector3 LocalScale = ThisTransform.localScale;
    LocalScale.x *= -1f;
    ThisTransform.localScale = LocalScale;
  }
  //--------------------------------
  //Engage jump
  private void Jump()
  {
    //If we are grounded, then jump
    if(!isGrounded || !CanJump)return;

    //Jump
    ThisBody.AddForce(Vector2.up * JumpPower);
    CanJump = false;
    Invoke ("ActivateJump", JumpTimeOut);
  }
  //--------------------------------
  //Activates can jump variable after jump timeout
  //Prevents double-jumps
  private void ActivateJump()
  {
    CanJump = true;
  }
  //--------------------------------
  // Update is called once per frame
  void FixedUpdate ()
  {
    //If we cannot control character, then exit
    if(!CanControl || Health &lt;= 0f)
    {
      return;
    }

    //Update grounded status
    isGrounded = GetGrounded();
    float Horz = CrossPlatformInputManager.GetAxis(HorzAxis);
    ThisBody.AddForce(Vector2.right * Horz * MaxSpeed);

    if(CrossPlatformInputManager.GetButton(JumpButton))
      Jump();

    //Clamp velocity
    ThisBody.velocity = new Vector2(Mathf.Clamp(ThisBody.velocity.x, -MaxSpeed, MaxSpeed), 
      Mathf.Clamp(ThisBody.velocity.y, -Mathf.Infinity, JumpPower));

    //Flip direction if required
    if((Horz &lt; 0f &amp;&amp; Facing != FACEDIRECTION.FACELEFT) || (Horz &gt; 0f &amp;&amp; Facing != FACEDIRECTION.FACERIGHT))
      FlipDirection();
  }
  //--------------------------------
  void OnDestroy()
  {
    PlayerInstance = null;
  }
  //--------------------------------
  //Function to kill player
  static void Die()
  {
    Destroy(PlayerControl.PlayerInstance.gameObject);
  }
  //--------------------------------
  //Resets player back to defaults
  public static void Reset()
  {
    Health = 100f;
  }
  //--------------------------------
}
//--------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec23"/>Code Sample 5.1</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id338" class="indexterm"/><code class="literal">PlayerControl</code> class is responsible for handling all player input, making the character move left and right and jump.</li><li class="listitem" style="list-style-type: disc">To achieve player movement, a reference to the RigidBody2D component is retained in the <code class="literal">ThisBody</code> variable, which is retrieved in the <code class="literal">Awake</code> function. The <a id="id339" class="indexterm"/>movement and motion of the player is set using the <code class="literal">RigidBody2D.Velocity</code> variable. More information on this variable can be found online at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html">http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">FlipDirection</code> function is used to invert the horizontal scale of the sprite, turning it to face left or right as needed (reversing the image direction, for example, <code class="literal">1</code> and <code class="literal">-1</code>). From Unity 5.3 onward, the <code class="literal">Flip</code> property of the <code class="literal">SpriteRenderer</code> component can be used instead.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">FixedUpdate</code> function is used instead of Update to update the movement of the player character because we're working with <code class="literal">RigidBody2D</code>—a physics-based component. All physics functionality should be updated in <code class="literal">FixedUpdate</code> that is invoked at a fixed interval each second as opposed to every <a id="id340" class="indexterm"/>frame. More information can be found at the Unity online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">GetGrounded</code> function detects where any <code class="literal">CircleCollider</code> intersects and overlaps with any other collider in the scene on a specific layer. In short, this function indicates whether the player character is touching the ground at the position of the feet. If so, the player is able to jump; otherwise, the player cannot jump as they are already airborne. Double-jumping is not allowed in this game!</li></ul></div><p>For the preceding code to work correctly, a few tweaks must be made to both the scene and player character. Specifically, the <code class="literal">GetGrounded</code> function requires that the floor area of the level is grouped together on a single layer. This simply means that the level foreground should be on a distinctive layer from other objects. To achieve this, create a new layer named <code class="literal">Ground</code>, and then assign the foreground object to this layer. To create a new layer, select the foreground object and, from the <strong>Object Inspector</strong>, click on the drop-down named <a id="id341" class="indexterm"/>
<strong>Layer</strong>. Then, select Add Layer from the context menu. See <em>Figure 5.44</em>:</p><div><img src="img/figure_05_44.jpg" alt="Code Sample 5.1"/><div><p>Figure 5.44: Adding a new layer</p></div></div><p>Then, add <a id="id342" class="indexterm"/>a new layer named <code class="literal">Ground</code> simply by entering <code class="literal">Ground</code> in an available type-in field. See <em>Figure 5.45</em>:</p><div><img src="img/figure_05_45.jpg" alt="Code Sample 5.1"/><div><p>Figure 5.45: Creating a new ground layer</p></div></div><p>Now, assign the foreground object to the <code class="literal">Ground</code> layer. Simply select the foreground object, and then select the <strong>Ground</strong> layer from the <strong>Layer</strong> drop-down in the <strong>Object Inspector</strong>. After the foreground object is assigned to the ground layer, the <code class="literal">PlayerControl</code> script requires us to indicate which layer has been designated for the ground. To achieve this, select the <strong>Player</strong> object and, from the <strong>Object Inspector</strong>, select the <strong>Ground</strong> layer for the <strong>Ground Layer</strong> field. See <em>Figure 5.46</em>:</p><div><img src="img/figure_05_46.jpg" alt="Code Sample 5.1"/><div><p>Figure 5.46: Selecting the Ground layer for collision detection</p></div></div><p>In addition, the <strong>Feet Collider</strong> slot needs assignment too in order to indicate which collider object should be used for ground collision detection. For this field, you need to drag and <a id="id343" class="indexterm"/>drop the <strong>CircleCollider</strong> component to the <strong>Feet Collider</strong> slot. See <em>Figure 5.47</em>:</p><div><img src="img/figure_05_47.jpg" alt="Code Sample 5.1"/><div><p>Figure 5.47: The Feet Collider detects when the character is in contact with the ground</p></div></div><p>Now, give the player character a test run. Simply click on the play icon on the toolbar and test out the controls of the player character. <em>W</em>, <em>A</em>, <em>S</em>, <em>D</em> (or the arrow keys) will move the player character around. The spacebar makes the character jump. See <em>Figure 5.48</em>:</p><div><img src="img/figure_05_48.jpg" alt="Code Sample 5.1"/><div><p>Figure 5.48: Play testing with the player character</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Optimization</h1></div></div></div><p>Our work so <a id="id344" class="indexterm"/>far has produced an interesting environment and a controllable character within this environment. Before moving forward, let's turn our attention to optimization—an issue that should be considered early during development. Optimization refers to the tips and tricks that we can apply to improve runtime performance as well as our workflow generally. Here, we'll consider prefabs to improve our workflow and Sprite Packing to improve runtime performance. Let's start with prefabs.</p><p>A prefab is a Unity asset that lets you group together many objects in a scene and package them together as a single unit that can be added to the <strong>Project</strong> panel as an asset. From here, the prefab can be added as a complete unit to any other scene or environment as though it were a separate and complete <em>thing</em>. The player character is an ideal candidate for a prefab because it must feature in all the other scenes we create. Let's create a prefab from the player. To do this, simply drag and drop the <strong>Player</strong> object to the <strong>Project</strong> panel in a separate folder called <code class="literal">Prefabs</code>. See <em>Figure 5.49</em>:</p><div><img src="img/figure_05_49.jpg" alt="Optimization"/><div><p>Figure 5.49: Generating a player prefab</p></div></div><p>After the <strong>Prefab</strong> is created, the <strong>Player</strong> object name in the hierarchy panel will turn blue, indicating that it's connected to the Prefab asset. This means that if you select the <strong>Prefab</strong> in the <strong>Project</strong> panel and make changes in the Inspector, then the <strong>Player</strong> object in the scene will change <a id="id345" class="indexterm"/>automatically to match these changes. You can, however, break the connection between the <strong>Player</strong> in the scene and <strong>Prefab</strong> by selecting the <strong>Player</strong> object and choosing <strong>GameObject</strong> | <strong>Break Prefab Instance</strong> from the application menu. This converts the scene object into a separate and independent duplicate of the Prefab. See <em>Figure 5.50</em>:</p><div><img src="img/figure_05_50.jpg" alt="Optimization"/><div><p>Figure 5.50: Breaking a prefab instance</p></div></div><p>Most of the time, however, you'll want to keep the connection between objects and their prefabs. Sometimes, though, you may make changes to the object in the scene, and then want these changes to feedback to the <strong>Prefab</strong> asset in the <strong>Project</strong> panel, affecting all other linked instances if there are any. To do this, select the object to which changes have been made, and then <a id="id346" class="indexterm"/>select <strong>GameObject</strong> | <strong>Apply Changes to Prefab</strong> from the application menu. See <em>Figure 5.51</em>:</p><div><img src="img/figure_05_51.jpg" alt="Optimization"/><div><p>Figure 5.51: Applying changes to a prefab</p></div></div><p>In addition to making Prefabs, you'll also want to optimize the render performance for your 2D games. Right now, when running the game, Unity will perform a unique and separate draw call for each and every unique texture or sprite onscreen at the time. A draw call simply refers to a step or process cycle that Unity must run through to properly display a graphic onscreen, such as a mesh, material, or texture. Draw calls represent a computational expense, and so it's a good idea to reduce them wherever possible.</p><p>For 2D games, we can reduce draw calls by batching together related textures, such as all the props for a scene, all the enemies, or all the weapons. That is, by indicating to Unity that a group of textures belong together, Unity can perform internal optimizations that increase render performance. Specifically, Unity will paste all related textures in a single and larger internal texture that it uses instead. To achieve this optimization, select all <em>prop</em> textures. For our game, I will include the <strong>Player</strong>, <strong>House</strong>, <strong>Platform</strong>, and <strong>Gem</strong> as props. These textures are all featured in the <strong>Project</strong> panel, though not all are used in the game yet. Select these textures and, from the Inspector, assign them the same name for the <strong>Packing Tag</strong> field (Props). Then, click on <strong>Apply</strong>. See <em>Figure 5.52</em>:</p><div><img src="img/figure_05_52.jpg" alt="Optimization"/><div><p>Figure 5.52: Assigning multiple textures to the same Packing Tag</p></div></div><p>Now, repeat <a id="id347" class="indexterm"/>this process for the <strong>Backgrounds</strong>, selecting all backgrounds and assigning them to the <strong>Background Packing</strong> tag. Then, click on <strong>Apply</strong>. See <em>Figure 5.53</em>:</p><div><img src="img/figure_05_53.jpg" alt="Optimization"/><div><p>Figure 5.53: Creating a Background batch of textures</p></div></div><p>That's it! Now, when you press on the play icon, Unity will automatically batch and organize the textures for optimal performance based on your groupings. This technique can significantly reduce draw calls. On pressing the play icon, you may see a loading bar or progress bar while Unity internally generates a new texture set. During Play Mode, you can view how Unity has organized the textures through the <strong>Sprite Packer</strong> window. To access this, select <strong>Window</strong> | <strong>Sprite Packer</strong>. See <em>Figure 5.54</em>:</p><div><img src="img/figure_05_54.jpg" alt="Optimization"/><div><p>Figure 5.54: Unity organizes all similarly tagged textures into the same texture space as an Atlas</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Summary</h1></div></div></div><p>Superb work! We've come a long way in this chapter, from a blank project to an effective 2D game in which a player character can navigate a complete 2D environment with 2D Physics. The character can move left and right and jump, and the sprite texture will change to match the direction of travel as well. In addition, Sprite Packing has been used to optimize runtime performance, which is ideal for mobile devices. In the next chapter, we'll continue working by adding obstacles, collectable objects, and more!</p></div></body></html>