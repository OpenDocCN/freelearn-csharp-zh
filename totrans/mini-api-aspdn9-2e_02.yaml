- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Creating Your First Minimal API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个最小化API
- en: The convenience of the .NET ecosystem could not be more evident by the steps
    you took in the last chapter. Minimal APIs in .NET live up to their name by having
    not only minimal logic and dependencies but also minimal setup requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你采取的步骤充分体现了.NET生态系统的便利性。.NET中的最小API不仅具有最小逻辑和依赖，而且具有最小设置要求，真正做到了名副其实。
- en: Just by creating your first project, you have technically already created your
    first minimal API. It’s functional out of the box, with a **GET** endpoint that
    returns a response.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 只需创建你的第一个项目，你实际上已经创建了你的第一个最小化API。它开箱即用，包含一个**GET**端点，返回响应。
- en: Obviously, there is more to minimal APIs than what we saw in the **Hello World**
    example. There are different HTTP request methods, varying endpoints, and more
    advanced response generation to consider as part of a straightforward API.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最小API的内容远不止我们在**Hello World**示例中看到的那样。我们需要考虑不同的HTTP请求方法、不同的端点以及更高级的响应生成，这些都是简单API的一部分。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Project structure and organization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构和组织
- en: Defining endpoints and routes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义端点和路由
- en: Building the employee management API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建员工管理API
- en: Handling HTTP requests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理HTTP请求
- en: By the end of the chapter, you’ll have gained experience in defining endpoints
    for handling HTTP requests. You’ll also be able to implement basic HTTP request
    handling and response generation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得定义端点以处理HTTP请求的经验。你还将能够实现基本的HTTP请求处理和响应生成。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the directions in this chapter, you’ll need to have the following
    installed on your Windows, macOS, or Linux machine:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的指示，你需要在你的Windows、macOS或Linux机器上安装以下内容：
- en: .NET 9.0 **Software Development** **Kit** ( **SDK** )
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 9.0 **软件开发** **工具包** ( **SDK** )
- en: Visual Studio or Visual Studio Code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 或 Visual Studio Code
- en: C# Extension for Visual Studio Code (if you are using Visual Studio Code)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code的C#扩展（如果你使用Visual Studio Code）
- en: 'If you followed the setup guidance in [*Chapter 1*](B20968_01.xhtml#_idTextAnchor014)
    , then you are ready to follow the directions in this chapter. However, if you
    still need to configure the preceding tools, then please follow the [*Chapter
    1*](B20968_01.xhtml#_idTextAnchor014) setup instructions under the *Installing
    required tools and dependencies* section. The code for this chapter is available
    in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET
    -9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9) .'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了[*第1章*](B20968_01.xhtml#_idTextAnchor014)中的设置指南，那么你就可以按照本章的指示进行操作。然而，如果你仍然需要配置前面的工具，那么请在*安装所需工具和依赖项*部分下遵循[*第1章*](B20968_01.xhtml#_idTextAnchor014)的设置说明。本章的代码可在GitHub仓库中找到：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET
    -9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9) 。
- en: Project structure and organization
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构和组织
- en: The rules around how a project is structured and organized are not exactly rigid,
    but it is important to ensure that you are organizing your projects in a cohesive
    and accessible manner. With minimal APIs in general, we are aiming for simplicity.
    Project structure and organization in minimal APIs specifically are no different.
    Therefore, it may not come as a shock that the project structure for minimal APIs
    outlined in the following examples will be extremely basic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于项目结构和组织的规则并不完全严格，但确保你以一致和可访问的方式组织项目是很重要的。在一般情况下，我们追求的是简单性。在最小API中，项目结构和组织也是如此。因此，以下示例中的最小API项目结构可能不会让你感到惊讶，它将非常基础。
- en: In the following three subsections, we look at the elements needed to simplify
    our project structure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下三个小节中，我们将探讨简化项目结构所需元素。
- en: Endpoints
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端点
- en: '**Endpoints** are the *open doors* to your API. Each endpoint sits within an
    area of your domain (e.g., employees or inventory) and is responsible for specific
    actions within that domain, such as adding, updating, or removing an inventory
    item.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**端点**是API的**开放门户**。每个端点位于你的域（例如，员工或库存）的一个区域，并负责该域内的特定操作，如添加、更新或删除库存项。'
- en: In ASP.NET **Controller** -based projects, you would usually distribute endpoints
    for each area of the domain into logical groups called **Controllers** . Each
    **Controller** is a class containing endpoints that are relevant to that **Controller’s**
    domain area.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 ASP.NET **Controller** 的项目中，您通常会根据域的每个区域将端点分配到逻辑组中，称为 **Controllers**。每个
    **Controller** 是一个包含与该 **Controller** 的域区域相关的端点的类。
- en: However, in minimal APIs, it is normal for endpoints to simply be defined in
    the app’s entry-point, within **Program.cs** .
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在最小化 API 中，端点通常简单地定义在应用程序的入口点，在 `Program.cs` 中。
- en: Models
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: Just like in **Model-View-Controller** ( **MVC** ) projects, a model in minimal
    APIs can be used to encapsulate domain objects. Models are usually created as
    their own classes. In the upcoming examples, which demonstrate API endpoint mappings,
    I will be creating logic for an API that manages employees. Therefore, I will
    use a model in the form of an **Employee** class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 **Model-View-Controller**（**MVC**）项目中一样，在最小 API 中，模型可以用来封装域对象。模型通常创建为其自己的类。在即将到来的示例中，我将创建用于管理员工的
    API 的逻辑。因此，我将使用 **Employee** 类作为模型。
- en: 'Using a class to represent domain objects brings many benefits, including the
    following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个类来表示域对象会带来许多好处，包括以下内容：
- en: '**Separation of concerns** : Models encapsulate the data for the application,
    separating it from the business logic, which will be found within the API layer
    in our case.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：模型封装了应用程序的数据，将其与业务逻辑分离，在我们的情况下，业务逻辑将在 API 层找到。'
- en: '**Reusability** : Model objects can be reused by business logic across the
    application.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：模型对象可以在应用程序的业务逻辑中被重用。'
- en: '**Loose coupling** : Thanks to the separation of concerns between data and
    business logic, changes to the API need not affect the structure of the data inadvertently.
    This is particularly important in common cases where models mirror a database
    table’s structure through an ORM such as Entity Framework or Dapper (See [*Chapter
    8*](B20968_08.xhtml#_idTextAnchor132) ).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松散耦合**：由于数据和业务逻辑之间的关注点分离，API 的更改不需要无意中影响数据的结构。这在常见情况下尤为重要，其中模型通过 ORM（如 Entity
    Framework 或 Dapper）镜像数据库表的结构（见 [*第 8 章*](B20968_08.xhtml#_idTextAnchor132)）。'
- en: Staying organized
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 保持组织
- en: While minimal API project structures can afford to stay very simple, it’s still
    important to keep them organized. It is good practice to keep all models in a
    dedicated **Models** folder and all endpoints in their own **Endpoints** folder.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最小 API 项目结构可以保持非常简单，但仍然重要的是要保持它们有组织。良好的做法是将所有模型放在专门的 **Models** 文件夹中，所有端点放在它们自己的
    **Endpoints** 文件夹中。
- en: For the final piece in the project structure puzzle, we have routes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目结构拼图中的最后一部分，我们有路由。
- en: Routes
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: If endpoints are the open door into the API, **routes** are the address of each
    door. By creating a route, you are defining the URLs that your API will respond
    to, and which piece of logic will be executed as a result.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端点是进入 API 的敞开大门，那么 **路由** 就是每扇门的位置。通过创建路由，您正在定义您的 API 将响应的 URL，以及将执行哪个逻辑片段。
- en: Routes can be standalone or contain parameters that will be passed through to
    the resulting API logic.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 路由可以是独立的或包含将被传递到结果 API 逻辑中的参数。
- en: In the endpoint on the following pages, you will see routes defined in the form
    of strings, indicating the text that should be appended onto the application’s
    base URL to access specific endpoints.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下页面上的端点中，您将看到以字符串形式定义的路由，指示应附加到应用程序的基本 URL 上的文本，以访问特定端点。
- en: For example, if our application is hosted at **getInventoryItem** , the full
    URL for that endpoint would become [https://adventureworks.com/getInventoryItem](https://adventureworks.com/getInventoryItem)
    .
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的应用程序托管在 `getInventoryItem` 上，该端点的完整 URL 将成为 [https://adventureworks.com/getInventoryItem](https://adventureworks.com/getInventoryItem)。
- en: We can, however, make our routes more generic. **getInventoryItem** is certainly
    clear, but it is better practice to, where possible, send different kinds of requests
    to a generic route, with different logic firing depending on the HTTP method in
    use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以，然而，使我们的路由更加通用。`getInventoryItem` 确实很清晰，但更好的做法是，在可能的情况下，向通用路由发送不同类型的请求，根据使用的
    HTTP 方法触发不同的逻辑。
- en: For example, instead of naming our route **getinventoryitem** , we could apply
    the generic name **inventoryitems** to as many HTTP methods as is relevant. This
    means that a **GET** request (we will learn about these methods in the next section)
    to this route will get an inventory item, but a **POST** to the same route will
    create one.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们不必将路由命名为**getinventoryitem**，而可以将通用名称**inventoryitems**应用于与HTTP方法相关的任何路由。这意味着对这个路由的**GET**请求（我们将在下一节中了解这些方法）将获取一个库存项目，但对该路由的**POST**请求将创建一个。
- en: 'This is deemed to be a best practice for naming routes, for several reasons:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这被认为是一种命名路由的最佳实践，原因有几个：
- en: '**Consistency** : Since having a generic endpoint has become an API convention,
    it allows your API to conform to an agreed standard.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：由于具有通用端点已成为API约定，它允许您的API符合一个已同意的标准。'
- en: '**Intuitiveness** : Most developers consuming an API will work to the same
    standard. This means that they will be more quickly able to pick up your API.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直观性**：大多数消费API的开发人员都会遵循相同的标准。这意味着他们将能够更快地了解您的API。'
- en: '**RESTful principles** : Allowing the HTTP method to identify the function
    of an endpoint rather than the route allows us to conform to RESTful principles,
    which encourage good use of **CREATE, READ, UPDATE, DELETE** ( **CRUD** ) operations,
    idempotency (during multiple identical requests, the server’s state is never changed,
    and it returns the same results for the same request each time), and the need
    for full coverage of the standard HTTP methods ( **GET** , **POST** , **PUT**
    , **PATCH** , **DELETE** ).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RESTful原则**：允许HTTP方法识别端点的功能而不是路由，使我们能够符合RESTful原则，这些原则鼓励良好的**CREATE、READ、UPDATE、DELETE**（**CRUD**）操作、幂等性（在多个相同的请求中，服务器状态不会改变，并且每次对相同请求返回相同的结果），以及需要全面覆盖标准HTTP方法（**GET**、**POST**、**PUT**、**PATCH**、**DELETE**）。'
- en: In contrast to the list, if you have API endpoints that support an HTTP method
    in a very bespoke use case, you can still create routes that are more specific.
    However, the customary practice is to use the generic route naming convention
    that we outlined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表相反，如果您有支持HTTP方法的API端点，这些方法在非常特定的用例中，您仍然可以创建更具体的路由。然而，常规做法是使用我们概述的通用路由命名约定。
- en: Understanding routes is critical to minimal API development in addition to most
    API fram eworks. Let’s turn our attention to the way in which routes and their
    endpoints are defined.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理解路由对于最小API开发至关重要，除了大多数API框架之外。让我们转向定义路由及其端点的方式。
- en: Defining endpoints and routes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义端点和路由
- en: Like any other RESTful API framework, minimal API endpoints are accessed using
    different HTTP methods. Depending on the HTTP method used to contact the API endpoint,
    a different result will be produced, or an action will be executed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他RESTful API框架一样，使用不同的HTTP方法访问最少的API端点。根据用于联系API端点的HTTP方法，会产生不同的结果或执行不同的操作。
- en: In the next few sections, we will look at some examples of endpoints being mapped
    with different HTTP methods.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将查看一些端点与不同HTTP方法映射的示例。
- en: GET methods
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET方法
- en: An HTTP **GET** method is a request for information. On successful retrieval,
    the API endpoint returns a **200 OK** status code, along with the requested data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP **GET** 方法是一个请求信息。在成功检索后，API端点返回一个 **200 OK** 状态码，以及请求的数据。
- en: The example shows a **GET** endpoint mapped to the **"/employees"** route. It
    gets the employee ID contained within the URL and uses this to find the relevant
    employee data before returning it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例显示一个**GET**端点映射到**"/employees"**路由。它获取URL中包含的员工ID，并使用这个ID来查找相关的员工数据，然后再返回。
- en: 'For example, if this API were hosted at constoso.com, a **GET** call to [contoso.com/employees/24](https://contoso.com/employees/24)
    would retrieve the employee whose ID is **24** :'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果这个API托管在constoso.com，对[contoso.com/employees/24](https://contoso.com/employees/24)的**GET**调用将检索ID为**24**的员工：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s look at **POST** methods now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看**POST**方法。
- en: POST methods
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST方法
- en: An HTTP **POST** method is a request to create something. On successful execution,
    the API endpoint usually returns a **201 Created** status code (this is best practice,
    although some APIs return the standard **200 OK** code), along with any relevant
    data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP **POST** 方法是创建某物的请求。在成功执行后，API端点通常返回一个**201 Created**状态码（这是最佳实践，尽管一些API返回标准的**200
    OK**代码），以及任何相关的数据。
- en: The following example shows a **POST** method mapped to the **"/employees"**
    endpoint. It expects to receive an employee payload in JSON format. The endpoint
    then converts the payload into an object of the **Employee** type, before calling
    some other back-end code to create an **Employee** , using this object as a parameter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了将 **POST** 方法映射到 **"/employees"** 端点。它期望接收一个 JSON 格式的员工负载。端点然后将负载转换为
    **Employee** 类型的对象，在调用一些其他后端代码以使用此对象作为参数创建 **Employee** 之前。
- en: If everything worked as expected, the endpoint returns a **201 Created** status
    code, along with the **Employee** **Created** message.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，端点返回 **201 Created** 状态码，以及 **Employee** **Created** 消息。
- en: 'For example, if this API were hosted at **constoso.com** , a **POST** call
    would execute the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果这个 API 在 **constoso.com** 上托管，一个 **POST** 调用将执行以下代码：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Up next, we look at **PUT** methods.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 **PUT** 方法。
- en: PUT methods
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**PUT** 方法'
- en: An HTTP **PUT** method is a request to update something. It’s important to remember
    that **PUT** updates a resource in a particular way compared to the **PATCH**
    method, which has its own way of updating.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP **PUT** 方法是一个用于更新内容的请求。重要的是要记住，与具有自己更新方式的 **PATCH** 方法相比，**PUT** 方法以特定的方式更新资源。
- en: '**PUT** methods require a payload that represents the entire resource being
    updated. So, in the case of our **Employee** API, if you were to use a **PUT**
    endpoint to update an existing employee, the API endpoint would expect a full
    **Employee** object to be sent in the request. It would then find the existing
    employee and replace it with the one sent in the request.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**PUT** 方法需要一个表示正在更新的整个资源的负载。因此，在我们的 **Employee** API 的例子中，如果您要使用 **PUT** 端点更新现有员工，API
    端点将期望在请求中发送一个完整的 **Employee** 对象。然后它会找到现有的员工，并用请求中发送的一个替换它。'
- en: On successful execution, the API endpoint returns the standard **200 OK** status
    code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行后，API 端点返回标准的 **200 OK** 状态码。
- en: The example shows a **PUT** method mapped to the **"/employees"** route. It
    expects to receive an employee payload in JSON format. Like in the preceding **POST**
    example, the endpoint converts this JSON payload into an object of the **Employee**
    type, before finding the original employee and calling a method to replace it
    with the updated one
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例展示了将 **PUT** 方法映射到 **"/employees"** 路由。它期望接收一个 JSON 格式的员工负载。与前面的 **POST**
    示例类似，端点将此 JSON 负载转换为 **Employee** 类型的对象，然后在找到原始员工并调用一个方法用更新后的对象替换它之前。
- en: 'For example, if this API was hosted at constoso.com, a **PUT** call would execute
    the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果这个 API 在 constoso.com 上托管，一个 **PUT** 调用将执行以下代码：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: PATCH methods
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**PATCH** 方法'
- en: Like a **PUT** method, an HTTP **PATCH** method is also a request to update
    something. However, the way it does its update is different. Instead of requiring
    a payload containing a representation of the entire object, a **PATCH** method
    only requires that the individual values that need to be changed are sent as part
    of the request. The API can then take care of updating the relevant properties
    on the existing object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **PUT** 方法类似，HTTP **PATCH** 方法也是一个用于更新内容的请求。然而，它执行更新的方式不同。**PATCH** 方法不需要包含整个对象表示的负载，只需将需要更改的个别值作为请求的一部分发送即可。然后
    API 可以负责更新现有对象的相关属性。
- en: On successful execution, the API endpoint usually returns the standard **200
    OK** status code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行后，API 端点通常返回标准的 **200 OK** 状态码。
- en: The example shows a **PATCH** method mapped to the **"/updateEmployeeName"**
    route. It expects to receive an **Employee** object like **POST** and **PUT**
    . However, it is only interested in the **Name** and **Id** properties. This means
    that as long as a JSON payload is sent and it contains these properties, it will
    work. Using these properties, the code fetches the right object of the **Employee**
    type based on the given Id. It then updates the name property on the retrieved
    employee only, without overwriting the whole object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例展示了将 **PATCH** 方法映射到 **"/updateEmployeeName"** 路由。它期望接收一个类似于 **POST** 和 **PUT**
    的 **Employee** 对象。然而，它只对 **Name** 和 **Id** 属性感兴趣。这意味着只要发送一个包含这些属性的 JSON 负载，它就会工作。使用这些属性，代码根据给定的
    Id 获取正确的 **Employee** 类型对象。然后只更新检索到的员工的名称属性，而不覆盖整个对象。
- en: 'For example, if this API was hosted at constoso.com, a **P** **ATCH** call
    would execute the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果这个 API 在 constoso.com 上托管，一个 **P** **ATCH** 调用将执行以下代码：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The final method we will look at is **DELETE** .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个方法是 **DELETE** 。
- en: DELETE method
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DELETE 方法
- en: A **DELETE** method is self-explanatory in terms of what it does. Sending an
    ID for a resource as a parameter in the same way we did for the **GET** endpoint,
    the API can locate that specific resource and then remove it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**DELETE** 方法在描述其功能方面是自解释的。将资源的ID作为参数发送，就像我们在**GET**端点所做的那样，API可以定位到该特定资源并将其删除。'
- en: In most cases, on success, a **DELETE** method will usually return the standard
    **200 OK** status code, but it may instead return **204 No Content** , which is
    also fine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，成功时，**DELETE**方法通常会返回标准的**200 OK**状态码，但也可以返回**204 No Content**，这也是可以的。
- en: The following example shows a **DELETE** method mapped to the **"/employees"**
    route. The endpoint will use the **Id** parameter to find the corresponding object
    of the **Employee** type as the target for deletion. After removing the **Employee**
    object, it returns a **204 No Content** status code to the client.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个映射到**"/employees"**路由的**DELETE**方法。端点将使用**Id**参数来找到要删除的**Employee**类型的对应对象。删除**Employee**对象后，它向客户端返回**204
    No Content**状态码。
- en: 'If this API was hosted at constoso.com, a **DELETE** call to [https://contoso.com/employees](https://contoso.com/employees)
    would execute the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个API托管在constoso.com上，对[https://contoso.com/employees](https://contoso.com/employees)的**DELETE**调用将执行以下代码：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you feel you’ve understood the different HTTP methods available to our
    API, turn to the next section to start building a basic minimal API based on a
    simple, real-world use case.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你觉得你已经理解了我们API提供的不同HTTP方法，就转到下一节，开始基于一个简单、真实世界的用例构建一个基本的API。
- en: Building the employee management API
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建员工管理API
- en: Now that we have covered an overview of routing and endpoints, along with the
    ways in which they support the various HTTP methods, let’s start building a new
    minimal API project, with the use case of employee management.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了路由和端点，以及它们如何支持各种HTTP方法，让我们开始构建一个新的最小API项目，以员工管理为例。
- en: Our goal in this section will be to create a repository of employees on which
    our API can operate. The API will then be able to get, create, update, and delete
    employees.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是创建一个员工库，我们的API可以在其上操作。然后，API将能够获取、创建、更新和删除员工。
- en: Creating the API
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建API
- en: Follow the next few steps to create the employee management API.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建员工管理API。
- en: 'If you haven’t followed the steps in [*Chapter 1*](B20968_01.xhtml#_idTextAnchor014)
    to create your ASP.NET project in Visual Studio or Visual Studio Code, follow
    them first, and then continue with the next steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有按照[*第1章*](B20968_01.xhtml#_idTextAnchor014)中的步骤在Visual Studio或Visual Studio
    Code中创建你的ASP.NET项目，请首先遵循这些步骤，然后继续下一步：
- en: 'You may already have this in your project, but if not, ensure that it is present
    at the top of **Program.cs** . This will build the **WebApplication** instance
    that hosts the minimal API:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经在项目中有了这个，如果没有，确保它在**Program.cs**的顶部。这将构建托管最小API的**WebApplication**实例：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The two lines in the previous step are enough to build the **WebApplication**
    instance, but it still needs to be started. Add this line to the bottom of your
    class to start the instance:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一步中的两行足以构建**WebApplication**实例，但仍然需要启动。将此行添加到类的底部以启动实例：
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you have a runnable app, but no endpoints. Before we define those endpoints,
    we need some data to work with. We’ll come back to **Program.cs** to define the
    endpoints shortly. But before that, let’s create a model of the **Employee** type:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个可运行的程序，但没有端点。在我们定义这些端点之前，我们需要一些数据来工作。我们将在稍后回到**Program.cs**来定义端点。但在那之前，让我们创建**Employee**类型的模型：
- en: In the folder structure of the project, create a new folder called **Models**
    .
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的文件夹结构中，创建一个名为**Models**的新文件夹。
- en: Inside the new folder, create a new class called **Employee** .
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹内，创建一个名为**Employee**的新类。
- en: 'Create these properties in the **Employee** class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Employee**类中创建这些属性：
- en: '[PRE7]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This model can be used to represent an **Employee** resource, on which the API
    can perform various CRUD operations. Ordinarily, we would keep this data in a
    database, such as SQL, but for now, we’re going to keep it simple and store the
    employees in a collection. To do this, the collection needs to be situated somewhere
    in which it can be accessed by the endpoints we’re about to create.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模型可以用来表示**Employee**资源，API可以在其上执行各种CRUD操作。通常，我们会将此类数据保存在数据库中，例如SQL，但为了简单起见，我们现在将将其保存在一个集合中。为此，该集合需要位于可以被我们即将创建的端点访问的地方。
- en: At the top level of the project, (the same level as **Program.cs** ), create
    a new class called **EmployeeManager** .
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目顶层（与**Program.cs**相同的级别），创建一个名为**EmployeeManager**的新类。
- en: We want this class to be available at any time, without the need to instantiate
    it, so make it a static class.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这个类在任何时候都可以使用，而不需要实例化它，所以将其设为静态类。
- en: 'Add a private **List** of the **Employee** type at the top of the class. Your
    class should look like this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类顶部添加一个私有的**List**类型的**Employee**。你的类现在应该看起来像这样：
- en: '[PRE8]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we have an easily accessible class that can store the employees. As the
    collection is private, we can now add a set of methods that can be publicly exposed
    to the endpoints to perform operations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个易于访问的类，可以存储员工。由于集合是私有的，我们现在可以添加一组可以公开暴露给端点以执行操作的方法。
- en: 'We’re about to create logic for the CRUD actions to be performed on each **Employee**
    in the collection. As part of this, it will be necessary to look up each employee
    object in the list. Let’s add a private function that will find this for us, for
    reuse on each CRUD operation. With the private function added, the class now looks
    like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将为对集合中每个**Employee**执行的CRUD操作创建逻辑。作为这部分，将需要查找列表中的每个员工对象。让我们添加一个私有的函数，它将为我们找到这些信息，以便在每次CRUD操作中重复使用。添加了私有函数后，类现在看起来像这样：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, update the class so that it contains the CRUD methods and functions
    shown in this code sni ppet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新类，使其包含此代码片段中显示的CRUD方法和函数：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The **EmployeeManager** class will now enable our API endpoints to perform specific
    CRUD actions on employees in the collection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**EmployeeManager**类将使我们的API端点能够对集合中的员工执行特定的CRUD操作。'
- en: Creating the first endpoint
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建第一个端点
- en: The first endpoint to add will be the **GET** endpoint for retrieving a specific
    **Employee** object by its ID.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加的第一个端点将是用于通过其ID检索特定**Employee**对象的**GET**端点。
- en: 'Create the following **GET** endpoint in **Program.cs** right above the final
    **app.Run()** line you added earlier in the chapter:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Program.cs**文件中，在之前章节中添加的最终**app.Run()**行上方创建以下**GET**端点：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code starts by referencing the **WebApplication** instance known as **app**
    , calling the **MapGet** method. There are equivalent mapping methods in **WebApplication**
    named based on the type of HTTP method. Examples include **MapPut** , **MapPost**
    , and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先引用了名为**app**的**WebApplication**实例，调用**MapGet**方法。在**WebApplication**中，有基于HTTP方法类型的等效映射方法。例如，包括**MapPut**、**MapPost**等等。
- en: The first parameter expected on the mapping method will be the route you wish
    to listen to. In this case, we are mapping to the **"/employees/{id}"** route,
    which uses a routing parame ter (more on this in [*Chapter 4*](B20968_04.xhtml#_idTextAnchor081)
    ) to capture an employee ID.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 映射方法预期的第一个参数将是您希望监听的路径。在这种情况下，我们正在映射到**"/employees/{id}"**路由，它使用一个路由参数（更多内容请参阅[*第4章*](B20968_04.xhtml#_idTextAnchor081)）来捕获员工ID。
- en: This is then followed by a second parameter in the form of a lambda expression,
    which uses the passed-in ID to execute the intended logic. At this point, the
    code calls the **Create()** function defined in the **EmployeeManager** class
    before finally returning the result to the client.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这随后是一个以lambda表达式形式提供的第二个参数，它使用传入的ID来执行预期的逻辑。在此阶段，代码在最终将结果返回给客户端之前，调用了**EmployeeManager**类中定义的**Create()**函数。
- en: 'Add the remaining endpoints to **Program.cs** below the **GET** endpoint we
    just created and above the **app.Run()** method. **Program.cs** should now look
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚创建的**GET**端点下方和**app.Run()**方法上方，将剩余的端点添加到**Program.cs**中。现在**Program.cs**应该看起来像这样：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You’ll notice that all of the subsequent endpoints you’ve mapped follow a similar
    pattern to the first **GET** endpoint you added. Each of them specifies the HTTP
    method type that is being used, followed by the route, then by any parameters.
    There is then a body that executes relevant logic before a result is returned.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，您映射的所有后续端点都遵循与您添加的第一个**GET**端点相似的模式。每个端点都指定了正在使用的HTTP方法类型，然后是路由，然后是任何参数。然后是一个在返回结果之前执行相关逻辑的正文。
- en: 'At this point, the code should compile. (If it does not, check that everything
    has been typed in correctly.) So, run the application (click the play button in
    Visual Studio or use the **dotnet run** terminal command in Visual Studio Code)
    and make some test requests to each of the created endpoints. The **POST** , **PUT**
    , and **PATCH** endpoints expect an **Employee** object as a parameter, so ensure
    that you have sent JSON that mirrors the structure of the **Employee** model.
    Look at this example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码应该可以编译。（如果不行，请检查是否所有内容都已正确输入。）因此，运行应用程序（在 Visual Studio 中点击播放按钮或在 Visual
    Studio Code 中使用 **dotnet run** 终端命令）并对每个创建的端点进行一些测试请求。**POST**、**PUT** 和 **PATCH**
    端点期望一个 **Employee** 对象作为参数，因此请确保您发送的 JSON 与 **Employee** 模型的结构相匹配。看看这个例子：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having created an endpoint, it is time we test it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建端点后，现在是时候测试它了。
- en: Testing your endpoint using OpenAPI
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OpenAPI 测试您的端点
- en: .NET 9 introduces OpenAPI integration, meaning that you can simply install a
    package and change the configuration of your API in **Program.cs** to generate
    a JSON representation of your API and its endpoints. This is useful because you
    can import it into API tools such as Postman, from which you can then easily test
    your APIs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 9 引入了 OpenAPI 集成，这意味着您只需安装一个包，并在 **Program.cs** 中更改 API 的配置，就可以生成 API 及其端点的
    JSON 表示。这很有用，因为您可以将它导入 API 工具（如 Postman），然后您可以从那里轻松测试您的 API。
- en: 'If you wish to test in this manner, follow these steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想以这种方式进行测试，请按照以下步骤操作：
- en: Install the **Microsoft.AspNetCore.OpenApi** package via NuGet.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 NuGet 安装 **Microsoft.AspNetCore.OpenApi** 包。
- en: 'Update **Program.cs** so that it uses OpenApi:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 **Program.cs** 以使用 OpenApi：
- en: '[PRE14]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the API and navigate to the **openAPI/v1.json** route. This will provide
    you with a representation of your API schema, which can be imported into API clients
    such as Postman for testing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 API 并导航到 **openAPI/v1.json** 路由。这将为您提供 API 架构的表示，可以将其导入 API 客户端（如 Postman）进行测试。
- en: At this point in the chapter, you’ve now mapped endpoints with varying HTTP
    methods, provided them with routes and parameters, created models, and added logic
    to be executed. The goal of the endpoint is to return a response to the client.
    We now need to handle the requests by returning a response.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章的这个阶段，您已经映射了具有不同 HTTP 方法的端点，为它们提供了路由和参数，创建了模型，并添加了要执行的逻辑。端点的目标是向客户端返回响应。我们现在需要通过返回响应来处理请求。
- en: Handling HTTP requests
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求
- en: ASP.NET provides a handy helper object for sending responses back to clients,
    called **IResult** .
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 提供了一个方便的辅助对象，用于将响应发送回客户端，称为 **IResult**。
- en: An **IResult** contains properties that can be used to represent standard HTTP
    responses for many different scenarios. For example, we could use IResult to return
    a specific status code, return JSON data, or even trigger **ASP.NET Identity**
    provider functionality such as challenges and sign-in/out.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**IResult** 包含可以用于表示许多不同场景的标准 HTTP 响应的属性。例如，我们可以使用 IResult 返回特定的状态码，返回 JSON
    数据，甚至触发 **ASP.NET Identity** 提供程序的功能，如挑战和登录/注销。'
- en: We can create a new IResult easily using ASP.NET’s **Results** factory class.
    In the preceding examples, you will have seen references to this factory class,
    where the API has returned status codes by calling **Results.OK()** and **Results.Created()**
    , to name a few.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 ASP.NET 的 **Results** 工厂类轻松创建一个新的 IResult。在前面的示例中，您已经看到了对这个工厂类的引用，其中
    API 通过调用 **Results.OK()** 和 **Results.Created()** 等方式返回状态码。
- en: 'Some of these simple HTTP status code methods have optional parameters that
    allow you to return strongly typed objects as JSON. For example, while you can
    simply return a **200** result by omitting any parameters in **Results.OK()**
    , you can also pass an object argument, and it will be sent back to the client.
    This was done in our Employee API endpoints for the **GET** endpoint:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的 HTTP 状态码方法中的一些有可选参数，允许您以 JSON 格式返回强类型对象。例如，虽然您可以通过在 **Results.OK()** 中省略任何参数简单地返回一个
    **200** 结果，但您也可以传递一个对象参数，并将其发送回客户端。我们在 Employee API 端点的 **GET** 端点中就是这样做的：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The ability to pass strongly typed .NET objects such as **Employee** back to
    the client in a helper method is one of the most powerful aspects of minimal APIs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在辅助方法中将强类型 .NET 对象（如 **Employee**）传递回客户端的能力是最小 API 最强大的特性之一。
- en: 'There’ll be more detailed examples of handling HTTP requests in [*Chapter 4*](B20968_04.xhtml#_idTextAnchor081)
    . For now, here are some examples of how **Results** can be used to return common
    HTTP responses:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B20968_04.xhtml#_idTextAnchor081)中将有更多详细示例来处理HTTP请求。现在，这里有一些示例说明如何使用**Results**来返回常见的HTTP响应：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After exploring **Results** , let’s take a look at one of its alternatives.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了**Results**之后，让我们看看它的一个替代方案。
- en: Typed Results
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Typed Results**'
- en: An alternative to using **Results** to return specific HTTP status codes is
    **TypedResults** , which is similar to **Results** but where the example responses
    using **Results** return an **IResult** each time, **TypedResults** returns a
    strongly typed object representing the status code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Results**返回特定HTTP状态码的替代方案是**TypedResults**，它与**Results**类似，但**Results**的示例响应每次返回一个**IResult**，而**TypedResults**返回一个表示状态码的强类型对象。
- en: '**TypedResults** implements a factory returning the appropriate strongly typed
    object that implements **IResult** for the specified status (e.g., returning **OK<string>**
    for a **200** **OK** result).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypedResults**实现了一个工厂，返回适当的强类型对象，该对象实现了**IResult**，用于指定的状态（例如，对于**200** **OK**结果返回**OK<string>**）。'
- en: 'You can use **TypedResults** in virtually the same way you use **Results**
    . Here’s an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**TypedResults**几乎与使用**Results**相同的方式。以下是一个示例：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'NET 9 also introduces support for **500 INTERNAL SERVER ERROR** responses in
    **TypedResults** :'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 9还引入了对**500 内部服务器错误**响应的支持，在**TypedResults**中：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, you should now have a decent understanding of how to handle HTTP
    requests, returning the relevant HTTP status codes and strongly typed objects
    back to the client. Let us sum up everything we have covered in this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经对如何处理HTTP请求有了相当的了解，包括返回相关的HTTP状态码和强类型对象给客户端。让我们总结一下本章所涵盖的所有内容。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we covered most of the introductory aspects of creating simple
    minimal APIs, and you created your first minimal API project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了创建简单最小API的大部分入门内容，并且你创建了你的第一个最小API项目。
- en: You learned how to define endpoints, and how they act as doors into the API,
    each of them sitting on their respective routes. Using the example of the **Employee**
    API, you gained insight into how to structure your project, splitting endpoints
    and data to achieve the benefits of loose coupling and reusability.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何定义端点，以及它们如何作为进入API的门，每个端点都位于它们各自的路径上。以**Employee** API为例，你了解了如何构建你的项目结构，将端点和数据分离以实现松耦合和可重用性的好处。
- en: You explored the concept of models as data structures that describe the domain
    objects in use by the API, and you built a simple CRUD system for manipulating
    data during requests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你探讨了模型作为数据结构的概念，这些数据结构描述了API使用的域对象，并且你构建了一个简单的CRUD系统来处理请求中的数据。
- en: Finally, you gained a basic understanding of how to handle HTTP requests in
    a minimal API, using ASP.NET helper logic to compose and return responses to clients.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解了如何在最小API中处理HTTP请求，使用ASP.NET辅助逻辑来组合并返回响应给客户端。
- en: Armed with your foundational knowledge, turn to the next chapter, where we will
    explore the anatomy of a minimal API. We’ll delve deeper and more scientifically
    into the key components that make up minimal APIs, and you’ll be introduced to
    some of the various architectural and design patterns that can be adopted to fully
    realise their potential.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了基础知识之后，转向下一章，我们将探讨最小API的结构。我们将更深入、更科学地探讨构成最小API的关键组件，并介绍一些可以采用以充分发挥其潜力的各种架构和设计模式。
