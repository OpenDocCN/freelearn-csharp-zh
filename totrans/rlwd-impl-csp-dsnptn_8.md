# 8

# 现在你已经了解了一些图案，接下来是什么？

在撰写这本书的过程中，我向几位朋友、同事以及至少一位我的许多死敌征求了意见。他们无一例外地会询问他们在学校学习或在一个项目中使用的某个图案，想知道为什么它没有被包括在这本精彩的著作中。对他们问题的简短回答是：本书的目标是专注于你可以快速添加到你的编码工具库中的图案。这些图案能快速回报你的时间和金钱的投资。

我选择省略的许多图案与我在这本书中包含的图案非常相似。被选中的图案完全是我个人的偏好。这些图案在我作为获奖的软件工程师使用 C#的 25 年经验中证明是最有用的。

到本章结束时，我们将涵盖以下主题：

+   我们没有涵盖的 GoF 图案将简要讨论。

+   **面向对象编程**（**OOP**）之外的图案。有一些图案不适用于 OOP——例如，设计用来描述数据库或网络结构的图案。

+   如何创建你自己的图案。GoF 书为创建你自己的图案提供了一个格式。

请注意，我仅使用图表。本章没有代码。同样，也没有任何技术要求。

# 我们没有讨论的图案

我没有涵盖 GoF 书中的所有 23 个图案。我只涵盖了一半左右。许多因素都影响了决定包含哪些图案以及在本章中隐含讨论哪些图案。有些图案比它们的价值更麻烦。**备忘录模式**解决了一个可以用几个.NET 特性轻松解决的问题。有些图案没有被包括，因为它们与我们覆盖的另一个图案非常相似。有些是你可能永远不会需要的图案。**解释器模式**只有在你在发明一种新的编程语言时才有用。由于**领域特定语言**（**DSLs**）的流行，这很少再做了。存在用于构建 DSL 的工具，这排除了需要解释器模式的需求。

这里是原始 GoF 书中我们没有在这本书中涵盖的图案：

+   原型

+   适配器

+   享元

+   责任链

+   代理

+   解释器

+   中介者

+   备忘录

+   状态

+   模板方法

+   访问者

我将在以下章节中从高层次讨论这些图案。

## 原型

对象的复制可能很棘手，但如果你的对象是平的，没有组成，只有几个字段，那就没问题了。然而，复制一个使用组合和继承构建的复杂对象的深度副本——它有每一层的几个层次——就更加困难了。*深度复制*指的是从最高层到最低层对对象进行精确复制。第一步是从相同的类中实例化一个新对象。然后，你需要将所有属性和字段中的值复制到新对象中。只有在你想要复制的对象中的每个字段或属性都是 `public` 的情况下，你才能这样做。这包括用于组成你正在复制对象的全部对象。即使你设法做到了这一点，你创建的副本也将是用于复制所使用的依赖类。

让我们从另一个角度来看。你开始了一个与 *Transylvanian Historical Society* 的项目。你的任务是逐块复制由一个名为 Vlad von Dracula 的人拥有的城堡。城堡的复制品将是一个位于另一个城镇的博物馆。有一个问题：城堡的吊桥是升起的，你不被允许进入。

复制城堡的外部部分并不难，但复制内部——尤其是地下室里那个令人毛骨悚然的墓穴——是不可能的。除非你有内部帮助。一个名叫 Renfield 的人提供了帮助。因为他从未离开过城堡的墙壁，所以他完全了解城堡的内部。如果你能让 Renfield 从内部帮助你，复制城堡就不会那么困难。

Prototype 是一种创建型模式，它使你能够逐块复制对象。它通过将复制任务委托给对象本身来实现。简而言之，这是一项内部工作。复制操作本身被称为 **克隆**。能够自我克隆的对象被称为原型。

看一下以下图示：

![图 8.1：当你想要能够对对象进行深度复制时，使用 Prototype 模式。](img/B18605_Figure_8.1.jpg)

图 8.1：当你想要能够对对象进行深度复制时，使用 Prototype 模式。

让我们根据图上的数字来回顾一下 Prototype 模式图，如下所示：

1.  `Prototype` 接口定义了执行克隆操作的方法。

1.  `ConcretePrototype` 实现了 Prototype 接口，并提供了 `Clone` 方法的实现。如果你的对象结构复杂，这个方法定位为能够看到对象内部的所有内容。这个方法可能被重构，使其名称变为 *Renfield*。他是城堡内部可以帮助你克隆的人。`Clone` 方法同样可以提供复制对象所需的所有细节，而不会损失任何数据。

如果你需要从由具体子类定义的一小套对象中复制大量类，原型模式可以非常有用。回想一下我们的自行车工厂。假设有几种非常受欢迎的自行车配置。进一步假设菲比的机器人需要一个新的`bicycle`对象来制造一辆实物自行车。在这种情况下，会实例化一个`bicycle`对象，制造自行车，然后销毁该对象。

在这种情况下，制作一组“主副本”的流行自行车型号和配置是有意义的。这些主副本可以被克隆，而不是软件需要运行昂贵的构建方法来生成符合常见配置的新自行车。

## 适配器

我在我的吉普车后备箱里放了两套扳手。一套是常见的 3/8 英寸机械棘轮扳手套装。有一次我从奥扎克山脉的度假地开车回家经过俄克拉荷马州。我们选择了一条风景优美的路线，通过州内的森林小道行驶。我们正开着车，突然在路中间压到了一块木板。这是不可避免的。我立即切换了汽车显示屏到轮胎，在接下来的几英里里，我看到一个轮胎的压力逐渐下降。我的一个轮胎里扎了钉子。我在第一个机会停车，找到了一块平坦的地面，这样我就可以安全地升起我的车并更换轮胎。

我的妻子和两个女儿和我在一起。我们必须把所有的行李从车里拿出来才能到达千斤顶。如果你曾经尝试过用工厂提供的工具换轮胎，那么你就明白我当时有多热、多沮丧，而且被困在路边。一辆皮卡停在了我们后面，司机戴着牛仔帽、牛仔裤和 T 恤，主动提出要帮助我们。我能看到他车后有一系列昂贵的电动工具。我接受了他的提议。我们用他的电动扳手松开了轮胎的螺母，几分钟内我们就回到了路上。我发誓回到家后第一件事就是买一套和他一样的工具箱。

我一回到家，就迫不及待地想用我的新电动扳手做更多的事情，而不仅仅是换轮胎。毕竟，爆胎并不是经常发生。我想用它来配合我的另一套棘轮扳手。不幸的是，我另一套工具中的 3/8 英寸套筒不能与½英寸的电动工具配合使用。如果你不熟悉这些工具，可以查看以下截图：

![图 8.2：我的电动冲击扳手只有在使用适配器的情况下才能使用套筒扳手。](img/B18605_Figure_8.2.jpg)

图 8.2：我的电动冲击扳手只有在使用适配器的情况下才能使用套筒扳手。

动力扳手就像一个普通的扳手，只不过动力工具上的驱动方头更大。驱动方头是工具上你安装套筒的部分，套筒上有方孔。3/8 英寸的套筒根本无法安装在½英寸的驱动方头上。也就是说，直到我找到了适配器，它才适配。适配器让我可以使用一个接口——比如 3/8 英寸的套筒——与另一个接口，比如½英寸动力套筒工具的驱动方头。

适配器模式对你的类也做了同样的事情。适配器实现允许具有不同接口的两个类一起使用。如果我的扳手问题用**统一建模语言**（**UML**）来表示，可能看起来像这样：

![图 8.3：遵循适配器模式的类结构用于允许遵循一个接口的类与不同接口无缝工作。](img/B18605_Figure_8.3.jpg)

图 8.3：遵循适配器模式的类结构用于允许遵循一个接口的类与不同接口无缝工作。

让我们这样分解一下：

1.  动力扳手是客户端，我们需要一种方法将较小的 3/8 英寸套筒连接到½英寸驱动方头上。为此，我们需要一个适配器。

1.  适配器应该用接口来描述，以防止紧密耦合。这个接口要求一个`AttachSocket`方法，该方法在具体适配器类中实现。

1.  具体适配器类实现了接口，并包含一个接受客户端可以适配的东西的方法。

1.  `ThreeEighthsInchSocket`类代表你想要连接到客户端的不兼容接口。

简而言之，适配器实现了客户端接口——在这个例子中是`ISocketWrenchAdapter`。它还包装了我们与之交互的类——在这种情况下，是`ThreeEighthsInchSocket`。适配器在适配器类中调用`AttachSocket`方法时，从动力工具接收驱动方头。这个方法内部的逻辑操作将输入转换为适配者可以使用的东西。在软件术语中，客户端会调用适配器类。被调用的方法会提供转换逻辑，以便将传递给方法的内容转换为与适配者兼容。

当你需要利用第三方或遗留系统与新工作结合时，这个模式可以非常有用。

## Flyweight

你有没有想过某个想法让你整夜无法入睡？或者也许你有一个让你醒来的想法？你正睡得很香，然后突然醒来。你的半睡半醒的大脑刚刚想出了第 37 行的问题所在。

在一个晚上的启发式狂热中，Kitty 想知道如果有一天，Bumble Bikes 的需求爆炸了会怎样。如果这家小公司被数千个订单淹没怎么办？Phoebe 构建的机器人制造系统每次构建自行车时都会实例化一个自行车对象。每个自行车对象都会占用服务器**随机存取存储器**（**RAM**）的空间。Kitty 决定尝试使用开发服务器进行模拟。经过几次负载测试后，她确定她可以加载 1,000 个带有桥接画家系统的自行车对象实例。一旦对象计数超过 1,000 个并发对象，服务器开始变慢。一旦她在内存中达到 2,000 个对象，系统几乎完全停止运行，变得不可用。

解决这个问题的明显方法是为服务器订购更多的 RAM。当然，这使其成为硬件问题。我们是软件开发者。也许有一种方法可以通过严格使用软件模式来解决这个问题。也许一个小调整可以防止我们不得不向那个爱拍马屁的老板要求几千美元的升级。

享元模式用于将每个对象状态的一些共享元素移动到一个共享对象中。有时，你可以将大量数据从内存中移出并放入一个共享对象中。你在任何有高对象计数的地方都会看到这一点。例如，如果你使用 C#与 Unity 开发游戏软件，你的游戏可能会有数百甚至数千个敌人。也许你正在利用一个自制的粒子系统，有数千个闪亮的移动粒子，或者也许你正在进行一个工厂模拟，数千辆自行车由一小批机器人制造。

考虑以下图示：

![图 8.4：享元模式涉及将重复的状态变量移入一个单独的对象中，以便可以共享以减少内存占用。](img/B18605_Figure_8.4.jpg)

图 8.4：享元模式涉及将重复的状态变量移入一个单独的对象中，以便可以共享以减少内存占用。

让我们根据图中的数字来分解它，如下所示：

1.  这里，我们有一个包含所有部件的`Bicycle`类。对于我们的模拟，我们只将制造公路自行车。定序系统允许客户使用特殊的喷漆定制自行车车架，或者从标准颜色中选择一种。座椅也可以更换为几种型号中的一种。然而，其余的属性没有提供定制选项。它们将是我们制造的每辆公路自行车都相同的。

1.  现在，看看如果我们把那些不变化的状态部分移入一个单独的类会发生什么。在这里，我们的`Bicycle`类只包含我们制造的每辆自行车之间可能不同的那些属性。

1.  所有对象共有的状态元素被称为外显状态，并在`BicycleFlyweightCommonState`类中表示。这个名字有点长，但我想要确保你能识别出哪部分是轻量级。我们可以创建这个类的一个实例，并与 Phoebe 模拟中的所有一百万个`Bicycle`类共享。

假设`Bicycle`类在实例化时占用 16 **千字节**（**KB**）的内存。如果 Phoebe 想要生成一百万个，那将消耗 16 **千兆字节**（**GB**）的内存。一旦我们将重复的状态转移到轻量级对象中，我们就可以为单个对象节省 14 KB。由于我们只实例化一次，内存占用只包括内在状态。我们以 2 KB 的实例化 1 百万个自行车对象，总消耗是 2 GB 加上轻量级类中单个外显状态的微不足道的 14 KB。这几乎减少了 8 倍！我不知道你怎么样，但如果我们能通过重新排列一些类来将软件的内存占用减少 8 倍，我会高兴一周！

## 责任链

Bumble Bikes 的成功并不完全归功于 Kitty 的设计或 Phoebe 的卓越机器人技术。Bumble Bikes 还注重质量，**质量保证**（**QA**）是完全自动化的。一套摄像头通过 OpenCV 使用**人工智能**（**AI**）进行一系列检查。检查从车架开始，然后移动到把手，传动部件，刹车，车轮，轮胎，最后是座椅。AI 执行检查所使用的逻辑不包含在单个方法中。那样会违反**单一职责原则**（**SRP**）。相反，每个检查的逻辑都封装在每个单独的检查方法中。检查是顺序发生的，从车架开始。如果任何检查失败，自行车将被标记为缺陷，并放置一旁，由人类自行车技师进行修复。

你可以在以下图中看到 QA 检查的概述：

![图 8.5：自行车上的顺序质量保证检查是责任链的一个例子。](img/B18605_Figure_8.5.jpg)

图 8.5：自行车上的顺序质量保证检查是责任链的一个例子。

这个顺序排列的检查集使用责任链模式。如果任何检查失败，剩余的检查将不会执行。这就是丰田制造汽车的方式。如果在装配线上发现缺陷，一切都会停止，直到问题得到纠正。

模式本身采取的形式如下：

![图 8.6：责任链模式在需要状态化的事件序列时被使用。](img/B18605_Figure_8.6.jpg)

图 8.6：责任链模式在需要状态化的事件序列时被使用。

让我们按以下方式分解它：

1.  一个接口，通常称为`IHandler`，定义了两个方法。`Handle`方法定义了实现检查逻辑的方法签名。`Next`方法允许我们在当前步骤通过的情况下移动到下一个检查。

1.  抽象处理类定义了下一个处理程序，这是具体类之间的一个共同属性。

1.  具体类从`Handler`继承，并使用`Handle`方法实现它们的检查逻辑，该方法覆盖了基类方法。同样，`Next`方法覆盖了基类，并用于将接力棒传递给下一个跑步者，或者在我们的案例中，将当前的检查传递给下一个。

流程图逻辑自图灵机以来就存在了。因此，有一个模式来封装这个普遍概念并不令人惊讶。

## 代理

一天，Kitty 和 Phoebe 接到 Eloise Swanson 博士的电话。Swanson 博士成立了一家名为“美国机器人及机械人”的新公司。她公司的新产品是一款高端的用于机器人控制的**软件开发工具包**（**SDK**）。Swanson 博士在麻省理工学院（**MIT**）的硕士研究生期间研究了 Phoebe 的设计，并认为 Bumble Bikes 是进行 beta 测试的良好合作伙伴。

该 SDK 非常有效且易于使用。然而，它并不能完全替代 Kitty 和 Phoebe 编写的软件。首先，任何 SDK 都无法完全替代任何业务的定制软件。第二个问题是膨胀，因为 SDK 被设计成可以与任何机器人系统协同工作。大量的代码被用来考虑每一种可能性。

Kitty 和 Phoebe 发现 SDK 非常适合控制他们的喷漆机器人。然而，只有在需要定制从未进行过的喷漆工作时才需要它。一旦完成喷漆工作，它就会被编目，颜色公式就可以重复使用。来自“美国机器人”的 SDK 使喷漆工作大大缩短，但代价是初始化缓慢和占用大量内存。如果女孩们要将她们的代码与 SDK 结合，当然她们不会这样做，那么所有的工作都会因为一个昂贵的初始化过程而变慢，而这个过程她们很少会用到。

解决方案是在需要时才懒加载 SDK 对象。代理模式允许你定义并使用一个对象占位符。然后，代理可以在需要时仅加载大而慢的 SDK 类。其余的生产过程将不受影响。

让我们以下面的图为例，检查代理模式的结构：

![图 8.7：代理模式可以在需要之前用一个简单的对象替换一个更复杂的对象。](img/B18605_Figure_8.7.jpg)

图 8.7：代理模式可以在需要之前用一个简单的对象替换一个更复杂的对象。

将其分解将有助于我们进一步理解，所以我们将这样做：

1.  我们从第三方供应商那里有这个 SDK。我们知道与第三方供应商的 SDK 紧密耦合从一开始就是一个坏主意。在这种情况下，SDK 有一个我们想要使用的方法，但它的包含类有一个大而慢的构造函数，并且对象很少被使用。我们需要一种方法，在需要时才懒加载这个对象，同时防止紧密耦合。

1.  我们创建一个接口以防止紧密耦合。我们的客户端软件可以要求这个接口，只要我们能够保持接口，未来的任何变化都是可以接受的。

1.  然后，我们创建一个包装器来持有 SDK 实例。包装器持有 `BigSlowButVeryUsefulPaintService` 的一个实例，这个实例可能需要几分钟才能实例化。这已经是很长时间了，考虑到我们只需要一个方法。我们的包装器实例化 `BigSlowButVeryUsefulPaintService`，然后在真正需要时才调用昂贵的 `InitializeSystem` 方法。由于我们承担了实例化成本，我们可以将实例存储在私有属性中，并在需要时再次使用。这听起来可能像单例模式，但单例模式确保只创建一个实例。在这里，我们只是在重复使用我们已经制作好的东西，这并不完全相同。

记住，任何需要第三方、遗留或过于昂贵的对象占位符的时候，都要使用代理模式。这将防止紧密耦合，并推迟在实例化时可能发生的昂贵操作，直到它们真正需要时。

## Interpreter

解释器模式是你可能永远不会需要的一种模式。当需要解释一种可以用**抽象语法树**（**ASTs**）表示的自定义语言时，会使用这种模式。随着**领域特定语言**（**DSLs**）的流行，整个工具包，如 JetBrains Meta Programming System 和 Visual Studio Enterprise 的建模 SDK，使得创建自定义语言解释器成为一个相对简单的项目。

由于 DSLs 超出了本书关于模式的范围，我将在本章末尾的“进一步阅读”部分列出我提到的 DSL 工具的参考。

## Mediator

想象 Bumble Bikes 的未来并不困难，他们的自动化制造系统可能会扩展并变得更加复杂。目前，我们有建造模式控制着制造自行车和轮椅的机器人。有两个物理工厂，每个工厂只专注于几种产品。所有这些在未来都可能改变。

我曾在一家飞机制造商与另一家飞机制造商的合资企业工作。我们的公司制造动力装置（发动机）并组装最终的飞机。合作伙伴公司制造飞机机身。其他合作伙伴公司提供航空电子设备，这些是现代飞机中存在的电子飞行控制系统。还有一家公司制造我不得谈论的军事组件。

假设 Bumble Bikes 有如此多的制造操作。即使它们都集中在一个工厂里，所有不同机器人制造系统之间的信号通信水平可能会变得非常混乱。如果每个系统都要直接与其他系统通信，我们很快就会陷入麻烦。

如果你曾经使用 HTML 和 JavaScript 创建过大型网络应用程序，你可能会遇到类似的问题。你有数十种不同的代码片段在响应来自用户交互、计时器、**表示状态传输**（**REST**）**应用程序编程接口**（**API**）调用、第三方 SDK（如 jQuery）和第三方广告网站注入到你的网站以进行货币化的数百个信号时修改**文档对象模型**（**DOM**）。当这样一个系统在信号复杂度方面达到临界质量时，它就会变得缓慢，几乎无法调试和维护。

让我们再考虑一个例子：自然灾害，如飓风或龙卷风。如果所有**第一响应者**（**FRs**）都能直接相互联系呢？每位消防员都可以通过无线电与每位警察联系，警察可以与每位**紧急医疗服务**（**EMS**）单位联系。EMS 响应者可以直接与分级护士和红十字会志愿者交谈。所有这些都在一个大的开放通信渠道上发生。在这种环境下，你生存下来的机会有多大？开放直接通信有时可能是一件好事，但我认为我们所有人都意识到它无法扩展。现在，想象一下，在一个软件片段中有数百个对象，它们都可以直接访问堆栈上所有其他对象。你看到了问题，对吧？

在所有这些情况下，都需要某种形式的调度器：一个通信的中心枢纽。中介者模式体现了这个角色。中介者充当所有通信的中心枢纽，并以受控的方式将请求路由到需要它们的对象。让我们看看这里显示的图：

![图 8.8：中介者模式涉及一个单一的中心对象，该对象在对象之间指导调用。](img/B18605_Figure_8.8.jpg)

图 8.8：中介者模式涉及一个单一的中心对象，该对象在对象之间指导调用。

根据图中的数字，它的工作方式如下：

1.  这是同事对象的基础类。

1.  你有一群同事对象，需要一种集中的通信方式。这里我只有四个，这可能不足以导致我们转向中介者模式。但想象一下，400 个对象都在直接相互通信！就像我之前说的那样，直接通信无法扩展！

1.  我们创建了一个名为`IMediator`的接口，当你大声说出来时听起来很酷。这通常可以防止紧密耦合。

1.  现在来说说好的部分。一个基于`IMediator`接口的中心对象包含所有对象的实例，并在它们之间定义了通信通道，这些通道以我称为`ReactWithX`的方法的形式存在，其中 X 是与发送信号的对象相对应的数字。`ReactWith1`会在`Colleague1`上调用一个适当的方法，依此类推。

这个模式旨在简化通信过程，但它通常会导致一个非常大的对象，其中包含大量的内部组件实例和方法用于通信。您必须权衡`Mediator`类的复杂性与其提供的集中化好处。一方面，作为一个开发者，有一个类可以在您的 IDE 中设置断点是很不错的。就像一头狮子在观察当地的饮水点一样，最终，所有消息流量都会通过这个类，这使得查找错误变得简单。

然而，这个类本身可能会变得难以控制。

## Memento

您是否曾经保存过游戏或在您最喜欢的编辑器中使用过撤销功能？如果是这样，那么您可能已经与 Memento 模式互动过。对于记忆点的最佳类比是一种酷但过时的技术。当我还在上小学的时候，最热门的相机被称为宝丽来。那时的相机大多使用胶卷。您会在相机上拍照，然后把胶卷拿到药店去冲洗。大约需要一周的时间才能拿到您的照片。然而，使用宝丽来，您可以在几分钟内拍照，照片从相机中弹出并自行冲洗。如果您摇动照片，冲洗过程似乎会更快一些，这引发了一首流行的歌词和相应的舞蹈动作，“像宝丽来照片一样摇动它”。

那时候，我们把这些图片称为*快照*。今天，这个术语与 Memento 模式一起使用。一个快照，就像宝丽来照片一样，是特定时间点的事件或地点的表示。同样，在软件中也是如此：快照表示对象在某个时间点的状态。就像照片一样，软件快照可以保存为记忆点——提醒您对象处于该状态的那一次。

文本编辑器，例如您的 IDE 或 Microsoft Word，会持续跟踪您文档的状态，并在您键入时保存记忆点。当您在键盘上按下*Ctrl*/*Command + Z*时，您可以按顺序回到越来越早的记忆点。

初看之下，这似乎很简单。您只需创建一个`List<>`对象来保存，比如说，用户最近做的 100 个状态更改。也许您每 30 秒左右存储一个记忆点。这很简单。只有当您的状态中的每个对象以及用于继承和组合的每个对象都有 100%的公共属性时，这才会变得简单。如果整个状态都是公共的，您就不需要这个模式了。

这里真正的障碍与我们在之前的原型模式中遇到的相同。我们试图复制德古拉伯爵的城堡，但我们不允许进入前门。复制城堡的外部是简单的，但要复制整个城堡需要内部演员。这在备忘录模式中同样适用。在备忘录的情况下，内部演员是一个嵌套类。嵌套类可以访问外部类的状态，并可以存储我们的建议`List<>`对象，包含我们的撤销历史。让我们看看这里显示的图表：

![图 8.9：备忘录模式](img/B18605_Figure_8.9.jpg)

图 8.9：备忘录模式。

由于最熟悉的例子是文本编辑器，我使用了它来绘制图表。让我们回顾一下图表的编号部分，如下：

1.  这个类代表的是`DocumentEditor`类，即我们的客户端。备忘录模式称这个类为发起者，因为存储的状态来自这里。

1.  当编辑器需要保存撤销状态——或者，更确切地说，保存文件时——它可以使用`Memento`类进行存储。请注意，所有内部内容都是私有的。`Memento`类嵌套在发起者内部；它定义为`DocumentEditor`类内部的嵌套类。除了被锁定外，你还应该考虑`Memento`类是不可变的：一旦创建，就不应该再改变它们。私有属性通过构造函数设置，随后不再修改。这意味着在实现时，不应该为这些属性提供任何 setter 访问器方法。

1.  在 UML 中绘制内部类没有标准的方法，所以我将`Caretaker`类放在虚线框外面，作为一个视觉提示，表明这个类有所不同。记住，`Memento`位于`DocumentEditor`内部，而不是通过组合。`Caretaker`类反过来包含`Originator`字段中的`DocumentEditor`对象。因此，`Caretaker`类负责创建和恢复备忘录，以及撤销历史。

备忘录模式可能很难正确实现，你可能在职业生涯中走得很远都不需要它。即使你在一家人文编辑器公司找到工作，你也很可能使用许多优秀的第三方**用户界面**（**UI**）控件，例如来自 Telerik 的控件，这些控件已经为你实现了这一功能。

值得注意的是，你可以使用 C#的序列化库实现几乎相同的效果。通常，保存应用程序状态也涉及持久化。好的编辑器让你可以撤销最后 100 次更改。伟大的编辑器让你可以在编辑会话之间这样做。你可以关闭笔记本电脑，飞越世界，重新启动，你的撤销历史仍然可用，因为它们被序列化（保存）到你的硬盘上的某个文件中。

.NET 框架为我们提供了一系列序列化选项，包括`System.Runtime.Serialization`、`System.Runtime.Serialization.Json`和`System.Text.Json.Serialization`。每个都包含一组旨在使将对象序列化到文件变得相当简单的类。然而，你仍然会面临私有属性的问题。幸运的是，微软为我们提供了`DataContractSerializer`类，它可以帮助你绕过这个限制，而无需使用复杂的类结构或担心备忘录的不可变性。

## 状态

我得承认，回顾过去八章，我可能应该介绍这种模式。你会用到它，尤其是如果你在 Unity 3D 游戏开发中工作。如果你不熟悉这个工具包，它本质上是一个能够为游戏机、PC、Mac、移动设备和网络创建 AAA 游戏的引擎。我在当地学院教授 Unity 游戏开发多年，因此我对它有着特殊的感情，尽管我从未作为职业游戏开发者工作过。Unity 3D 游戏引擎使用有限状态机来控制游戏角色的动画。它使用可视化编辑器来定义状态以及当游戏角色状态改变时使用的动画。

状态模式涉及根据对象内部状态的变化来改变对象的行为。一个对象的状态在概念上只是它在某个时间点所有属性值的集合。如果你制作一个你在乡村四处奔跑与僵尸战斗的游戏，你可能会用不同的行为来定义你的僵尸。大多数时候，它们只是在随机地四处游荡，寻找新鲜的 BRAINS！

当有大脑的东西出现在视野中时，僵尸的行为会改变。它一边拖着脚步向携带大脑的生物走去，一边反复地嘶吼“BRAINS！”一旦僵尸进入手臂可触及的范围，它的行为再次改变。僵尸攻击！

我们有一个对象，具有三种行为，所有这些行为都由内部状态控制。当我们把行为和状态结合起来时，我们就形成了所谓的有限状态机。它是有限的，因为僵尸的行为数量是有限的。在这种情况下，数量是 3。有限状态机可以像下面这样绘制：

![图 8.11：表示视频游戏中僵尸行为的有限状态机。](img/B18605_Figure_8.10.jpg)

图 8.11：表示视频游戏中僵尸行为的有限状态机。

这个状态图显示了不同状态之间的转换。僵尸不能随机攻击一个距离太远的受害者。它必须先看到受害者，然后缩短距离。模式的图示如下：

![图 8.12：状态模式。](img/B18605_Figure_8.11.jpg)

图 8.12：状态模式。

让我们将其分解如下：

1.  `IState`接口定义了可能的行为。我们的僵尸可以巡逻、接近可见的受害者，并攻击。

1.  `Context`类持有实现`IState`接口的对象的引用，用于与具体状态对象通信。

1.  具体状态对象包含特定状态的方法。

上下文对象可以通过交换在私有状态属性中持有的具体状态对象来改变状态。这意味着上下文可以强制执行任何状态转换的逻辑。

我之前没有包括状态模式，因为它与我们在*第五章*中介绍的策略模式非常相似。凯蒂和菲比使用策略模式为自行车创建了一个导航系统。系统的行为根据用户请求的地形类型而改变。

## 模板方法

模板方法模式与我们在*第五章*中介绍的策略模式非常相似。这是一种行为模式，它允许你定义算法的结构，但将实现推迟到子类，这些子类覆盖了实际的逻辑而不是结构。

在*第五章*中，菲比为自行车设计了一个导航计算机。它使用策略模式来计算导航路线，取决于骑行者是否想要通过铺砌的道路、未铺砌的砾石道路还是极端地形。我们也可以用模板方法模式做到同样的事情，这就是为什么我没有觉得有必要介绍两者。

结构可以在以下图中看到：

![图 8.13：模板模式。](img/B18605_Figure_8.12.jpg)

图 8.13：模板模式。

让我们看看编号的部分，如下所示：

1.  抽象模板类定义了一个形成算法的类的结构。算法的步骤被定义为抽象的，可以在子类中的具体实现中覆盖。然而，这些步骤是在模板类中的方法中调用的。在我的例子中，我称之为`ExecuteTemplate()`，这个方法没有被覆盖。`ExecuteTemplate()`按顺序调用步骤，这永远不会改变。模板定义了可覆盖的逻辑，但每次使用模板时结构都是一致的。

1.  这些是覆盖算法步骤的具体类。注意`AlgoImplementationA`类覆盖了父类中的所有步骤。`AlgoImplementationB`类只覆盖了几个步骤。

这个模式允许你使用普通的继承来创建非常灵活的算法实现。

## 访客

访问者模式是另一种行为模式，旨在帮助你“附加”新的行为到现有对象上。其动机集中在 SOLID 原则（如果你需要这个缩写的解释，请回到*第二章*）。开放封闭原则得到了尊重，因为你是在不修改现有类的情况下添加行为的。单一职责原则也得到了尊重，因为通常你添加的行为是新的，可能几乎与原始类的目的无关。

这个名字背后的想法来源于这样一个观点：一个封装了新行为的对象可以访问现有的、已建立的类，从而允许它执行新的行为。你实际上是在教一只老狗新把戏。

想象一个你的身体有一个能力插槽的世界。你可以像将记忆卡插入相机一样轻松地插入新的行为。需要学会开直升机来逃离邪恶的秘密特工吗？插入飞行训练的卡片，你就可以瞬间驾驶任何民用或军用飞机！需要像五星级厨师一样烹饪吗？插入烹饪技能的卡片，你就能在任何烹饪比赛中击败戈登·拉姆齐或博比·弗莱！需要在夜总会施展舞技吗？插入夜总会技能的卡片，你就可以尽情跳舞！只是要注意最后一个。你无法知道卡片上可能还有什么其他技能。

让我们抛开最后一个例子，看看下面的图示：

![图 8.14：访问者模式。](img/B18605_Figure_8.13.jpg)

图 8.14：访问者模式。

让我们把它分解如下：

1.  我们的`Visitor`接口定义了一组方法，这些方法必须实现以向现有的对象图授予新的超级能力。我们很幸运，C#支持方法重载。方法重载指的是只要方法签名不同，语言就可以重用方法名称。如果你不确定这是什么意思，请查看本书末尾的*附录 1*。我们将在那里介绍它。并非所有的面向对象语言都支持这种功能，但 C#支持。我们的接口定义了具有相同名称但具有不同参数类型的方法。

1.  另一个名为`Element`的接口定义了如何接受访问者。如果你想在未来的世界中获得新的能力，你将不得不在你的头骨上添加一个插槽，以便我们有一个地方可以插入我们的能力卡。同样，你的类将需要根据这个接口添加一个额外的方法。你不需要更改类中的任何现有方法或逻辑。你只需要添加一个接受访问者的方法。

1.  具体的访问者类实现了我们的接口并提供新的行为逻辑。请注意，我们没有使用`IElement`接口作为参数类型。传入的具体对象类型决定了基于方法重载运行哪个方法。

1.  这些是实现了`Element`接口的现有类。

当我想起 C#中的访问者模式时，有几个想法浮现在脑海中。首先，它感觉非常像装饰者模式，但重点是对象图而不是单个类。这可能只是我个人的感觉？

另一个类似的模式是第五章中提到的组合模式，再次在第七章和第八章中提到。Kitty 和 Phoebe 使用组合模式对一个用于组成自行车传动系统的对象图进行了一系列的计算，以计算重量和成本。Tom 通过在设计时将组合模式编织到对象图中来改进了设计。区别在于，组合模式在图外的对象上操作，而访问者模式是在插入新的行为。

最后，我第一次读到访问者模式时，立刻想到了扩展方法。扩展方法是 C#独有的。它们允许你使用一个单独的类文件向现有类添加行为。它们不是访问者模式的实现，但如果你的需求很简单，你可能想从扩展方法开始。如果扩展方法不够用，那么尝试更复杂的访问者模式。

# 超越 OOP 领域的模式

面向对象编程领域只是起点。还有一些超越 OOP 领域的模式，你很可能听说过，但可能不知道它们是编码化的模式。

## 软件架构模式

在软件架构领域寻找更多模式的一个明显区域。这似乎像是我们一直在谈论软件架构。是的，我们一直在谈论。然而，软件架构并不局限于面向对象编程（OOP）。本书中的每个模式都依赖于使用 C#，因为它是一种面向对象编程语言。软件架构模式跨越了所有语言，并真正帮助我们定义系统，而不仅仅是增强我们代码的结构。让我们看看一些你可能之前已经听说过的例子。

### 客户端-服务器模式

我们实际上已经涵盖了这一点——我们只是没有将其称为模式。这个模式涉及**对等网络**（**P2P**）架构，包括一个服务器和通常许多客户端。客户端向服务器发出请求并对结果进行处理。这基本上就是互联网的工作方式。

### 微服务模式

微服务模式包括将大型、单体应用程序分解成小型、自包含但相互依赖的服务。这个想法是将单一责任原则（SRP）推向其最终实现。想象一下，一个带有少量端点的 REST API，这些端点共同只服务于一个目的，比如密码重置。而不是将密码重置构建到一个更大的 API 中，该 API 执行数十个其他操作，密码重置变成了一个微服务。

这个想法是，维护小型单用途 API 更容易。权衡来自于依赖系统调用之间的延迟以及网络拓扑结构的结果复杂性。

### 模型-视图-控制器（MVC）模式

你肯定听说过这个！你会在将应用程序代码分为三个层次时在 Web 应用程序中看到它，如下所示：

+   一个包含表示数据模型的代码的模型层，通常通过**对象关系映射器**（**ORM**）实现。

+   一个表示**用户体验**（**UX**）的视图层。

+   一个控制器层，它代表接受视图请求和处理从模型层返回的数据所需的逻辑。这种配置体现了**关注点分离**（**SoC**）的理想。

### 发布-订阅（pub-sub）模式

这又是另一个在许多形式中都很受欢迎的模式。有时你会看到对象级别的实现，比如我们在*第五章*中讨论的观察者模式。你也会在 Redis、RabbitMQ 和 Apache Kafka 等软件中看到更高层次的架构实现。

在所有情况下，想法是允许从中央源进行通信。消息被发送到一个发布者，然后发布者将消息发布给相关的订阅者。这对于分布式架构至关重要。

### 命令查询责任分离（CQRS）模式

该模式旨在解决数据库查询数据发生的频率远高于数据库更新的情况。如果你有一个报告系统，其中报告被生成但很少随后修改，这是一个值得学习的模式。其解决方案通常涉及将很少更改但经常查询的数据分离到一个称为数据仓库的单独数据库中。这可以提高读写性能，因为责任是分离的。权衡来自于实施成本，这通常涉及建立一个单独的数据库服务器来处理分离的负载。

## 数据访问模式

数据访问模式出现在你与关系型数据库或甚至非关系型数据库的传统代码交互的任何地方。由于关系型数据库自 1970 年以来一直存在，并且基本上没有变化，并且完全无处不在，因此它们有自己的模式集并不令人惊讶。我在 Clifton Nock 所著的《数据访问模式：面向对象应用程序中的数据库交互》一书中磨练了我的技能。我将在本章末尾的“进一步阅读”部分列出这本书的详细信息。

这里只是书中的一些模式，你可能会认识。

### ORM

你听说过**实体框架**（**EF**）吗？作为一名 C#开发者，你必须生活在某种高度学术性的岩石之下，才没有听说过微软的旗舰 ORM。ORM 的工作是在 SQL 数据库（如 SQL Server）中的关系结构到 C#中的对象之间映射数据。如果一个模式是解决频繁发生的问题的解决方案，那么这可能是软件开发中最重要的模式之一。

这种模式的实现，通常封装在第三方库中，或者在我们的案例中，在.NET 框架中，允许开发者仅使用 C#对象进行工作。使用 ORM，你永远不需要在应用程序数据库中创建或更新表结构。你永远不需要在代码中解决复杂的连接或连接长 SQL 语句。你创建一组代表你的数据库结构的对象。然后查询这些模型类，通过数据操作来操作你的数据库。

优点是，如果你不知道——或者不喜欢——SQL，你永远不需要直接与之打交道。权衡之处在于应用程序的性能。EF 代码在扩展规模上比直接连接到数据库运行得慢得多。它还给你的应用程序增加了一层依赖。这只是可能出错的一个额外因素。如果你觉得我不是它的粉丝，那你就对了。我喜欢 ORM 用于小型项目，用户数量有限。例如，如果你正在制作一个供内部使用的应用程序，并且你有有限的时间来创建它，使用 ORM 可能会帮助你更快地完成任务。

相反，如果你正在为大量用户制作应用程序，放弃 ORM 的便利性，直接实现我们的下一个模式，这将给你巨大的性能控制权，允许你利用数据库软件的全部功能。

### Active Domain Object

**Active Domain Object**（**ADO**）模式很有趣，因为当你看到 ADO 时，你可能想到的是微软的**ActiveX 数据对象**（**ADO**）或者 ADO 的更老前辈**数据访问对象**（**DAO**）。然而，这可能只适用于 35 岁以上的人。这些技术已经有一段时间没有处于前沿了。

ADO 模式封装了数据访问和相关对象实现。他们的目标是消除模式实现之外的任何与数据库的直接交互。听起来熟悉吗？这正是微软 ADO 和 DAO 被设计来做的。我怀疑这不是巧合。

大多数开发者不使用这种模式，他们通常已经转向使用 EF 等 ORM。然而，如果你有 SQL 技能，通过直接通过原生驱动程序访问数据库，你通常可以创建一个性能更好的应用程序。

### 需求缓存

我的妻子和孩子经常这样做。开玩笑的，但也不是。有很多缓存模式。需求缓存体现在一个按需懒加载的缓存中。这里起主要作用的是你不知道数据何时会被需要，但你希望只支付一次检索数据的代价。

我的应用程序包括一个需求缓存，作为 Web 应用程序的一部分。我的应用程序中的一些查询返回大型记录集或包括相当多的处理，可能需要几秒钟才能完成。这听起来可能并不糟糕，但对于 Web 应用程序来说，这是一个漫长的过程。我的需求缓存方法在请求数据时首先检查缓存（在我的情况下是 Redis）。如果它在缓存中，数据就从缓存中提供。如果不在，我就检索并缓存它。第一个请求数据的客户承担性能惩罚，但之后的每个客户都能非常快速地获取数据。

### 事务

这又是另一个无处不在的数据处理术语，实际上是一个模式。在数据库术语中，事务指的是必须作为一个单元完成的多个 SQL 语句。例如，如果你有一个自动取款机，并且你想从一个账户取款并转到另一个账户，你需要这个操作作为一个工作单元——事务。

你从账户 A 中取出 100 美元，并将 100 美元存入账户 B。如果任一 SQL 语句失败，你需要考虑整个事务失败，并完全回滚所有更改。

### 乐观锁和悲观锁

没有什么比在数据库中处理锁更让应用程序开发者抓狂的了。乐观锁的使用是为了防止错过数据库更新。你会在**库存管理系统（IMSs**）中找到这种模式的使用，在这些系统中，最新的库存数据对于销售库存至关重要。上周末，我在一家热门商店买了一台新的衣物烘干机。我妻子挑选了一台完美的烘干机，烘干机上面的标牌写着，“现在订购，您将在 3 天内收到”。销售员去输入订单时发现，这些产品不仅缺货，而且制造商不接受退货订单。

标牌假设仓库有库存，并基于过时的信息。现在，用数据库查询替换标牌。销售应用程序查询以查看是否有烘干机库存。在同一个时刻，在城里的另一家商店，有人刚刚购买了同一型号的烘干机。

第一家商店的店员如何知道是否真的有烘干机可用？乐观锁模式包括在数据库表的每一行上创建一个版本号。在这种情况下，如果行版本号自事务开始以来没有改变，并且不锁定数据库行以进行更新，数据库将乐观地假设烘干机可用。

相比之下，在相同的场景中，如果第二个销售员的交易正在进行中更新库存行数据，悲观锁将阻止销售员的销售交易进行。

# 创建自己的模式

你认为你有一个自己设计模式的想法吗？GoF 书籍提供了一个模板文档框架，用于发布你自己的模式。我不会在这里完全重复它，但我会为你概述它。它包括以下四个基本要素：

1.  名称和分类

1.  问题描述

1.  解决方案描述

1.  使用该模式的后果

让我们简要谈谈每个部分。

## 名称和分类

每个模式都需要一个描述该模式的名称。大多数现有的模式名称都让人联想到日常语言中的通用词汇。单词*memento*指的是一个能够唤起过去时光记忆的物理对象。单词*singleton*则唤起了只有一个事物的想法。想出一个简短、易于记忆的名称，能够唤起模式背后的理念。

你还需要一个分类。在这本书中，我们观察到了 GoF 书中的三种分类：创建型模式、结构型模式和行为型模式。在前几节中，你看到了其他使用模式的领域也有自己的分类列表。也许你的模式适合现有的分类。如果不适合，你需要发明一个新的分类。

你的模式可能还有一个别名；一个“**也称为**”(**AKA**)的名称。装饰者模式也被称为包装器。如果有任何别名，请记录下来。

## 问题描述

本节文档描述了你的模式旨在解决的问题。当 GoF 描述问题时，他们会将其分解为几个更小的部分，如下所述：

+   *意图*指的是你的模式的整体目标。

+   *动机*/*驱动力*说明了为什么有人会使用你的模式。这比“因为它很酷”或因为它解决了特定问题要深入。当我们讨论第一章中的反模式时，我们描述了一组导致反模式出现的驱动力。在本节中，我们正在寻找类似的原因，以了解你的新模式为何相关且有用。

+   *适用性*列出模式的上下文。列出模式有用的简短情况列表。

虽然没有必要填充每一个空缺，但你将认识到我们在本书中使用的元素。

## 解决方案描述

在描述解决方案时，你需要描述用于构建设计的元素。阐述元素之间的关系。描述元素如何协作，并确保解释每个元素的责任。你可能还需要将这一部分分成更小的部分，如下所示：

+   *参与者*列出参与模式解决方案的类、对象、接口、枚举等。

+   *协作*描述了参与者之间的协作方式。

+   *结构*将包含模式的通用形式的 UML 图，也许还有更贴近现实的具体用例图。这是我在这本书中涵盖的每个模式所使用的格式。我发现通用图单独使用时不太有用。如果后面跟着一个具体示例，开发者可以查看这两个图，并更容易地将它们与他们的工作联系起来。

+   *实现*部分包含如何实现该模式的描述。在这本书中，我使用了编号图来描述各个部分是如何组合在一起的。

+   *示例代码*或*伪代码*通常不言自明。我建议使用现实世界的例子，而不是类 A 从类 B 继承，类 B 又组合了类 C。这太抽象了。如果你想让人们使用你的模式，找到使其与他们的工作相关的方法。

## 使用该模式的结果

你应该始终讨论使用你的模式所带来的积极成果和权衡。大多数模式都有支持者和反对者。如果你在网上阅读有关模式的资料，你会看到关于某些模式可能成为反模式的健康辩论。我们在讨论*第三章*中的 Singleton 模式时，就提出了这样一个案例。模式越复杂，出现权衡的可能性就越大。模板方法模式极其简单。我怀疑提出这个模式的人是否曾因考虑可能的负面结果而失眠。相比之下，*第四章*中提出的外观模式（Façade pattern）在第三方框架的复杂性和不需要第三方框架暴露的所有内容的开发者的易用性之间提供了一个权衡。

# 并非每个人都喜欢模式

我们在*第三章*中对 Singleton 模式的讨论中展示了，并不是每个人都认为模式是对软件开发领域的积极贡献。通常的论点是设计模式只是对无能、低效或不完整的 OOP 语言的权宜之计。学术文献表明，在 GoF 书中，当使用诸如**列表处理**（List Processing）或 Dylan 之类的语言时，多达 17 个模式变得不再必要。什么？谁甚至使用这些？

另一组学术上的反对者主张将你的范式从面向对象编程（OOP）切换到**面向方面编程**（AOP）作为解决所有问题的方案。你可能已经知道，OOP 旨在通过在现实世界中建模事物来解决问题。AOP 旨在将行为建模为横切关注点。AOP 不应该与 OOP 竞争，但有些论点将其定位为竞争关系。

核心观点是，总会有辩论说：“如果你只是切换到语言 X、框架 Y 或范式 Z，你所有的模式问题都会得到解决！”我对这种说法的回答是提醒你要警惕“黄金锤”！

# 概述

模式无处不在。有一个名为仿生学的领域，旨在研究受自然界模式启发的技术。现在谈论软件开发而不提及**人工智能**（**AI**）是很困难的，其主要任务是使用称为**机器学习**（**ML**）的技术在大量数据中寻找模式。自 1843 年 Ada Lovelace 编写了大多数人认为的第一个计算机程序以来，软件行业一直在嗡嗡作响。在那段时间里，我们反复遇到了相同的挑战和挫折。最终，我们足够聪明，开始把它们写下来并谈论它们。

我们一直在学习模式，其核心实际上仅仅是一种方式，通过这种方式我们可以传达与组织优化代码相关的最佳想法。

在本章中，我们简要介绍了原始 GoF 书中的一些模式，这些模式在本书的前几章中没有涉及，作为本书故事的一部分。在每个案例中，我出于一两个原因省略了这些模式，如下所述：

+   如果一个模式与已经介绍过的另一个模式非常相似，我就没有介绍它。状态模式与策略模式非常相似。策略模式适合我的故事，所以我使用了它。

+   如果一个模式非常复杂且很少使用，我就没有介绍它。备忘录模式是一个很好的例子。有更简单的方法来处理表示对象快照的使用案例，例如.NET 的序列化功能，这否定了复杂备忘录模式实现的需要。

我们超越了 GoF 模式，甚至超越了面向对象模式，列出了软件和数据库架构其他领域的一些常见且高度熟悉的模式。我们以如何记录你自己的模式（如果你发现了新的模式）的概述作为结尾。我在本章中给你留下了最后的警告。你可能会想关上这本书，像疯子一样在办公室里到处大喊“模式！”不要笑。我见过这种情况发生。如果你这样做，预期会有一些翻白眼。并不是每个人都认为模式是个好主意，有时他们是对的。模式本身很容易陷入黄金锤反模式。记住——模式是为了简化并改进你的软件。如果它们使事情变得更慢或更复杂，你必须在这些情况下放弃它们。模式是工具，而不是教条。

只有一处 loose end（未了结的尾巴）需要解决。

# 萨恩迪斯广场 – 德克萨斯州沃斯堡

在德克萨斯州沃斯堡，那是一个温泉天。那是 MS-150 自行车拉力赛的最后一天。MS-150 是一项每年为治疗**多发性硬化症**（**MS**）的研究筹集数百万美元的活动。达拉斯地区的数千名自行车手参加了这场 150 英里、为期两天的活动。大多数当地自行车店都在沃斯堡市中心的购物和娱乐区 Sundance Square 设立了帐篷。作为白金赞助商，Bumble Bikes 在终点线处搭建了一个大型帐篷。

汤姆、莱克西和卡瑞娜正在帐篷里工作，向冲过终点的勇敢者们提供水和击掌。虽然超过 3,000 名骑手开始这场拉力赛，但不到 10%的人真正完成。大多数人因为膝盖疼痛或设备故障而中途放弃。汤姆和莱克西密切注视着一群骑手，他们完全预期他们会是最后一名完成比赛的。这是一个拉力赛，而不是比赛。骑手们不是在相互竞争——他们是在与自己竞争，看看自己是否有完成全程的能力。他们在第一天从普莱诺出发，骑行 75 英里到达德克萨斯州赛车场，那里举行当地的**全国汽车赛车协会**（**NASCAR**）比赛。第二天他们再次出发，但首先在赛车场跑了一圈，然后骑行 75 英里到达沃斯堡。

“*他们就在那里!*”莱克西喊道，她眯着眼睛朝远处的一个小山丘看去。“Bumbles 队”正在翻越这座山丘，所有人都在骑全新的 Hillcrest 自行车：凯蒂、菲比，以及大多数 Bumble Bikes 的员工，还有凯蒂和菲比的父亲。

自从他确诊以来已经过去了 10 年。化疗和类固醇治疗对治疗这种疾病无效。事实上，类固醇导致了严重的骨质疏松症。医生们已经放弃了，说已经没有更多的办法可以尝试。凯蒂和菲比无数次地祈祷，最终得到了当地教堂非正式联盟的支持。

凯蒂和菲比制作的轮椅非常有帮助。他们免费为世界各地的儿童医院制作并分发了超过 1,000 辆轮椅。Bumble Bikes 的自行车和轮椅销售稳步增长，直到成为世界上第三大自行车制造商，也是唯一一家在其产品中标注**美国**（**US**）的公司。MegaBikeCorp，凯蒂和菲比多年前实习的公司，排名第 19 位。

他们的父亲多年来一直在使用他的“Texas Tank”。这种设计证明生产成本太高，无法大规模生产，所以他们只制作了一辆。尽管他非常喜欢他的“Tank”，但他每天都会尝试站起来。大多数日子他会摔倒。直到有一天，他没有摔倒。

就像它突然开始一样，有一天它停止了。医生们无法解释这一点。他们多年前就已经用尽了所有的想法。凯蒂和菲比知道他们的祈祷得到了回应。

这需要多年的物理治疗。在疾病几乎摧毁了他喉咙中的肌肉之后，需要电击疗法来让他的声带恢复工作。他每天在胃部注射以治疗骨质疏松症。他每天进行短距离散步——最初是几块街区，但后来是几英里。月复一月，年复一年，他变得越来越强壮。他将他的*德克萨斯坦克*换成了 Bumble Bikes 的新款带电机的电动自行车。汤姆很高兴将*坦克*从他的手中拿走。这款新电动自行车提供了一种助力踏车的电机。电机并不是做所有的工作——它只是帮助。

最终，他能够再次骑上普通自行车了，今天，他和他的女儿们以及一支小型残疾人骑行队伍一起骑行了 75 英里到达终点线。Bumble Bikes 为无法使用双腿的骑行者生产了手摇自行车，并邀请任何没有这种自行车的骑行者加入*Team Bumbles*。

当他们看到队伍的*最后一名*，随后是警察护送通过终点线时，广场上所有人停止了手中的事情，为他们欢呼。这是一条非常漫长的道路，不仅仅是因为一天内骑行 75 英里是很长的距离。终点线意味着的不仅仅是拉力的结束。最重要的是，他们作为一个家庭一起跨过了终点线。

# 进一步阅读

+   [`www.redhat.com/architect/14-software-architecture-patterns`](https://www.redhat.com/architect/14-software-architecture-patterns)

+   *诺克，克利夫顿。数据访问模式：面向对象应用程序中的数据库交互。波士顿：Addison-Wesley，2004.*

+   本书配套网站：[`csharppatterns.dev`](https://csharppatterns.dev)

# 附录 1：C#中 OOP 原则的简要回顾

编程语言的领域中有数百种选择。如果你正在阅读这本书，你可能在旅途中某个时刻遇到过 C#。对于一些人来说，C#是他们唯一学过的语言。对于其他人来说，它是第三或第四种语言。也许你每天都在用 C#开发，已经很多年了，或者你可能刚刚开始学习，现在它成了你的新好朋友。

我意识到读者们带着不同的经验水平、不同的背景和不同的职业目标来到这本书。我过去在 LinkedIn Learning 上发布了一个非常受欢迎的视频系列，旨在教授 C#入门。说实话，这始终是我最喜欢的受众。教新手软件开发就像在一个缺乏远见的世界上教授魔法。我每周几乎都能在我的学生中看到“啊哈！”的时刻，我在南方卫理公会大学的全栈代码训练营教授。

我对撰写这本书的前景感到兴奋的一件事是这本书能帮助你迈出下一步。要么你刚刚学会了如何编码，要么你可能已经成功使用了多年的魔法技巧，但你现在意识到还有更多东西要学。模式是一个很好的下一步。学习模式会使你在编程的几乎所有其他方面都变得更好。

这里的问题是，我不知道你在你的旅程中处于什么位置。如果你是我的 SMU 学生，你已经非常擅长 JavaScript，并想迈出下一步。C# 与 JavaScript 完全不同。仅知道 JavaScript 就跳入这本书会有难度，但并非不可能。如果你是自学成才的，你可能专注于我所说的“生存技能”。它们包括基本的面向对象编程以及如何与数据库和可能的技术工作。如果你在大学里学习如何编码，你的教科书可能不太有启发性。我知道。我在大学和学院里教了 25 年书。通常，我写自己的材料，因为市面上好的书籍很少。

无论你现在身处何地，无论你来自何方，这一章都是为了指引你。最初，我打算将这作为本书的第二章。我的编辑明智地建议我们尽快开始使用模式。她建议添加一个附录，我们在整本书中都提到了。你将获得良好的复习或 C# 的快速课程。

在这个附录中，你可以期待学习以下内容：

+   关于 C# 的快速背景介绍以及如何沿着一系列分类学线条定义这种语言。这听起来很复杂，但你会发现它相当基础。

+   C# 的语法机制，长度和细节足够让你通过这本书。由于这本书主要处理普通的 C# 对象（POCOs）和来自 .NET Framework 的几个常见类型，如列表，这一节是可能的。

+   如何使用 Windows 中的三个常见 IDE 设置本书中的项目。我们使用了两种项目类型：命令行项目和库。

+   如何克隆本书中涵盖的示例代码项目。

让我们开始吧！

# 技术要求

这个附录主要是基本主题的概述，而不是项目集合。话虽如此，在附录的末尾，你将指导使用目前市场上最流行的三个 C# IDE。你将有一个选择。无论你选择哪个 IDE，你都需要一台运行 Windows 操作系统的计算机。我使用的是 Windows 10。本书中使用的项目可能在 Mac 或 Linux 上也能正常工作，但我没有在那里测试过，所以你的体验可能会有所不同。

要遵循本章末尾的 IDE 教程，你需要以下内容：

+   这些 IDE 之一：

    +   Visual Studio

    +   **Visual Studio Code** (**VS Code**)

    +   JetBrains Rider

+   .NET Core 6 SDK

你可以在 GitHub 上找到本章的完整项目文件，网址为 [`github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/appendix-1`](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/appendix-1)。

# C# 的简要背景

让我直接大声说出来：C# 是 Java 的仿制品。如果你知道 Java 但不知道 C#，你将会非常容易上手。现在，假装我没有先提到这一点，让我穿上我的灯芯绒运动夹克。夹克上有肘部的补丁。我在夹克的正面口袋里放了一根烟斗，让它竖起来，这样你可以看到它。当然，在这个时代，没有人会想到把烟草或其他东西放进去。那是不对的。但为了尽可能看起来像一位大学教授，我可以稍微讲一些历史。

C# 语言是微软为企业和游戏编程的旗舰语言产品。它由安德斯·赫尔伯格于公元 2000 年设计。我的有些学生声称我非常古老，所以我通过指出它是公元 AD 而不是 BC 来澄清这一点。该语言通过 **欧洲计算机制造商协会**（**ECMA**）提交并获得批准，作为标准化语言。你可能知道这个机构也标准化了 JavaScript，它实际上被称为 ECMAScript。许多语言都是标准化的。这仅仅意味着语言有一个公开的规范可用，其他人可以根据规范创建基于该语言的竞争性实现。C# 是微软的实现。有一个开源的竞争对手叫做 Mono，它曾经在一些领域非常流行，包括跨平台移动和游戏开发。

当微软推出 C# 时，它还发布了 .NET Framework 和 Visual Studio。.NET Framework 是一套庞大的库，为 C# 以及其他微软语言提供了语言支持基础设施。每个支持的语言都可以将其代码编译成中间格式。这种中间形式称为 **Microsoft Intermediate Language**（**MSIL**），然后可以使用 .NET 运行时执行。这使得整体语言架构与 Java 非常相似，Java 编译成中间形式称为字节码，然后在 **Java 虚拟机**（**JVM**）上执行。

该语言的声明性设计目标包括以下内容：

+   一种简单、通用、面向对象的语言

+   支持强大的静态类型变量系统

+   数组类型上的自动边界检查和未初始化变量的检测

+   自动垃圾回收

+   源代码的可移植性；代码应在各种环境中执行，无需显著更改代码且无需重新编译

让我们进一步探讨这些想法。

## C# 是一种通用编程语言

几乎每个人都听说过理查德·克莱本在 1842 年发明的东西。我在图 A.1 中向你展示了一个可调节扳手：

![图 A1.1：一个可调节扳手。你可以用它来做几乎所有需要扳手的活儿。如果你遇到麻烦，你也可以用它来开瓶盖和钉钉子。它是一个多用途的工具，就像 C# 语言一样，可以用来制作几乎任何类型的软件](img/Figure_A1.1_B18605.png)

图 A1.1：一个可调节扳手。你可以用它来做几乎所有需要扳手的活儿。如果你遇到麻烦，你也可以用它来开瓶盖和钉钉子。它是一个多用途的工具，就像 C# 语言一样，可以用来制作几乎任何类型的软件

在美国，我们称之为 *crescent 扳手*，而许多其他国家称之为 *spanners*。这个扳手是一个通用扳手。它可以用于各种适合扳手的任务，从松开和拧紧 IKEA 家具上的金属紧固件到在你的 1957 年雪佛兰汽车中安装新引擎，再到为你的厨房水槽安装新的垃圾处理器。

现在考虑图 A1.2 中的扳手：

![图 A1.2：这是一个 basin 扳手。它只适用于一件事：在洗碗池下拧紧水龙头硬件上的固定螺母。它是一个专用工具，就像 SQL 是一种专用语言一样。两者都只能用于一个目的](img/B18605_Figure_A1.2.jpg)

图 A1.2：这是一个 basin 扳手。它只适用于一件事：在洗碗池下拧紧水龙头硬件上的固定螺母。它是一个专用工具，就像 SQL 是一种专用语言一样。两者都只能用于一个目的

你可能以前从未遇到过这样的东西。这个看起来奇怪的装置被称为 *basin 扳手*。它只有一个任务。它用于在安装新的厨房或浴室水槽时拧紧水龙头连接。扳手头可以旋转 180 度，这样你就可以在所有管道周围操作。长把手帮助你处理向下突出的水槽碗，如果你用通用扳手尝试这样做，这会阻挡你的操作。

同样，存在一些专用语言，其中最流行的是**结构化查询语言**（**SQL**）。SQL 只用于查询关系型数据库。你不能用它来制作视频游戏或操作系统。

另一方面，C# 是一种通用语言。它可以用来制作从企业级软件到 AAA 级视频游戏几乎任何东西。是的，有人曾经尝试用 C# 制作一个名为 *SharpOS* 的操作系统，这表明用 C# 编写操作系统是可能的。

选择 C# 作为你的首选语言的最大原因是其灵活性。结合 .NET 框架，你拥有数千个构建块。你可以使用它们来构建你可能需要的任何软件。

## C# 是纯粹且完全面向对象的

你会在编程语言中看到两种主要的范式：面向对象编程和函数式编程语言。也许当有可能在单一语言中混合这两种范式时，会出现第三种范式。让我们来看看它们之间的区别：

| **面向对象编程** | **函数式编程** |
| --- | --- |
| 代码被组织成类，作为程序的主要构建块。 | 代码被组织成不同的函数，这些函数使用它们的参数代替属性。 |
| 方法通常具有副作用。它们可以在方法内部改变对象的状态。 | 纯函数永远不会产生副作用。 |
| 在面向对象编程中，我们支持可变和不可变对象。 | 函数式编程从不支持可变变量。如果你想改变某物，你必须创建一个新的变量。 |
| 数据存储在对象的属性中，并且从设计角度来看，它们比通常只用于改变对象状态的函数具有更高的优先级。 | 设计目标集中在函数上。它们接受不可变输入并产生输出。 |

图 A1.3：面向对象编程和函数式编程之间的区别。

一些语言，如 C#和 Java，是严格面向对象的。像 Haskell 和 F#这样的语言是严格函数式的，而像 JavaScript、Python 和 PHP 这样的语言可以支持其中一种或两种范式。本书重点介绍的原始**四人帮**（**GoF**）软件设计模式，是围绕面向对象编程使用 SmallTalk 语言构建的。自然地，我们将严格关注面向对象编程。

## C#使用静态、强类型系统

关于类型系统，存在三种不同的观点。首先，让我告诉你我所说的**类型系统**是什么意思。编程语言有一个共同的目的：它们都接受某种输入并将其转换为某种输出。程序的输入和输出被称为**数据**。就你的计算机而言，存在三种基本的数据类型。

**字符串**是字母数字数据——想想字母和数字。如果你能在键盘上输入它，它就是字母数字的。

第二种数据类型是**数字**。我想你知道这是什么意思。虽然数字可以是字母数字字符串，但你不能使用字符串进行数学运算。这种区别是强类型系统的核心，所以请记住这一点。

第三种基本的数据类型是**布尔值**。布尔值是二进制的，这意味着它们可以具有真或假的值。有时，这个值会表示为 0（假）和 1（真），或者 0（假）和非 0（真）。

这三种基本类型被称为**原始数据类型**。在**强类型系统**中，当你声明变量或创建函数时，你必须告诉你的程序你将使用什么类型的数据。

除了原始类型之外，C# 支持创建自己的类型作为对象。像原始类型一样，这些类型是强的，也是静态的。**静态类型系统**意味着当你说你将使用一个变量来存储字符串时，你永远不能将变量更改为任何其他类型。它是静态的，意味着它永远不会改变其类型。

虽然 C# 和许多其他语言使用强静态类型系统，但其他语言并不如此。JavaScript 采取了相反的方法。JavaScript 使用弱动态类型系统。在这种系统中，创建一个变量并赋予任何类型的值是完全正常和合理的。比如说，我们创建一个名为 *foo* 的变量并将其设置为“这是一个字符串。”

接下来的那一行可以将值 9 赋予名为 *foo* 的变量。你不需要用变量声明类型的事实表明这是一个 **弱类型系统**。你可以随时更改类型的事实表明这是一个动态类型系统。JavaScript 非常强大和灵活，但它对于学习过强静态系统的开发者来说感觉非常陌生。这种想法认为 JavaScript 是一种“玩具语言”，不适合严肃的工作。这当然是完全错误的。

你会遇到第三种类型系统，这被称为鸭子类型。最著名的使用鸭子类型的系统可能是 Python。在 Python 中，你看到了 C# 中的强静态类型和 JavaScript 中的弱动态系统之间的中间地带。

在 Python 中，你不需要用变量声明类型。然而，Python 解释器会观察变量是如何使用的，并推断出一个强类型。这种系统被称为鸭子类型，因为创建这种类型系统的设计者声称：“如果它像鸭子走路，像鸭子嘎嘎叫，那么它就是一只鸭子。”

C# 的后续版本也支持鸭子类型，所以我们将在稍后看到一些示例。

## C# 具有自动边界检查和未初始化变量的检测功能。

C# 的创建是为了纠正其他语言的不足。你几乎可以听到在过去 20 年中创建的每一种新语言都是如此。某个团体讨厌 C 或 Java 中某些工作的方式，因此他们创建了一种新的语言。通常，它们是其他语言所谓好部分的混合体。如果你不相信我，可以了解一下苹果的 *Swift* 语言，谷歌创建的 *Rust* 语言或 *Golang* 语言。C# 并无不同。

研究表明，缺乏边界检查和未初始化变量都是软件错误的主要来源。实际上，这里的目的是创建一种让开发者更难犯错的编程语言。在接下来的几个特性中，我们将讨论实现这一目标的方法。

边界检查是指数组。数组是一种特殊类型，允许你在单个变量中存储多个值。由于 C#是强类型，数组元素必须都是同一类型。你可以有一个字符串数组、数字数组或对象数组。此外，在 C#中，当你定义一个数组时，你必须告诉你的程序你将放入数组中的元素数量。一旦设置，大小就固定了，你不能不跳过一些比喻性的障碍来改变它。

未初始化的变量不仅仅是代表工作马虎——在某些编程语言中，它们可能是危险的。C 编程语言在这里值得一提。C 在过去 10 年中经历了一些剧烈的变化，但在我你这个年纪的时候，C 的座右铭是“权力越大，责任越大。”我认为这也是蜘蛛侠的座右铭。也许彼得·帕克应该成为一名程序员而不是摄影师。

在 C 语言中，就像在大多数语言中一样，一个变量只是一个指向内存地址的指针。计算机内存就像一个公寓楼。实际上，C#和 Visual Basic 的早期版本将它们的内存模型称为“公寓线程”。公寓是你和你的东西的容器。有些公寓小而经济（除非你住在纽约市，在这种情况下，它们只是小）。其他公寓更大，也更贵。无论它们的大小、形状和装饰如何，它们的职能是容纳你和你的东西。

每个公寓楼中的公寓都有一个公寓地址号码。因此，你可以有效地表示“我想把我的东西放在 122 号公寓*”。如果你在工作中得到加薪，并决定升级，你可以把你的东西搬到更大的 300 号公寓。地址告诉我们你的东西在哪里，而你的公寓楼经理知道每个公寓的大小和价格。

计算机内存以同样的方式工作。有一些地址寄存器（如公寓楼）可以存储不同大小的物品。我们可以扩展我们的类比，说公寓管理员是运行你的程序的计算机。因为它保留了一个每个公寓地址和每个公寓占用空间的列表，所以它知道容器在哪里。

地址不是像 122 或 300 这样的简单数字。它们更复杂，不容易处理。因此，我们不是处理地址，而是可以给我们的公寓或容器一个简单易懂的名字，这个名字描述了你的变量在程序中的使用方式。

当你创建一个定义大小的容器，比如一个公寓（小而便宜与大而昂贵），它有一个地址。但你不使用那个地址，而是使用你认为容易使用和记忆的任何名字。

现在想象一个作为建筑一部分建造的公寓，但它充满了建造时留下的建筑垃圾和垃圾。没有人租过这个公寓，所以没有人清理过这个混乱。这是一个未初始化的变量。如果有人想租这个公寓并在同一天搬进去，也就是说访问地址，他们会发现里面都是垃圾。当一个具有强大静态类型系统的运行程序遇到它不期望的垃圾时，程序会崩溃。如果你曾经遇到过 Windows 中的**蓝屏死机**（**BSOD**），你就知道这看起来像什么。未初始化的变量将保留上次使用该内存地址时留下的任何垃圾。在 C 语言中，手动分配和释放内存是工作中的一个主要头痛问题。如果你做错了，事情会以最不优雅的方式崩溃。C 开发者真正需要的是一种处理垃圾回收的方法。

## C#支持自动垃圾回收

我们刚才讨论的噩梦场景显示了语言改进的必要性。C#旨在简单且实用。在 C 语言中，当 C#被构想出来时，我们手动分配内存地址。这意味着执行一个使用十六进制值定义你的分配的语句。大多数人在以 10 为基数的情况下工作得很好。我们的旧环境让我们在心理上将十进制（基数 10）数字转换为基数 8（八进制）和基数 16（十六进制）来进行内存分配。然后，我们使用那个内存，当我们完成时，我们需要记得释放内存。在我们的公寓比喻中，这相当于搬出公寓并在过程中彻底打扫。当我们释放内存时，公寓应该准备好供人入住。

如果我们有一个自动处理分配和释放的语言会怎样？我们有。C#有一个垃圾回收系统，为你处理一切。你创建一个变量，细节由.NET 运行时处理。当你的变量超出作用域时，它会被标记为清理，最终运行时的垃圾回收过程会为你释放和清理内存。正如你可以想象的那样，在一个没有安全网的系统中进行手动分配和释放内存也是错误的主要来源。

## C#代码具有高度的便携性

C#语言规范旨在拥有可移植的代码。在 C#和.NET 的最早版本中，我们并不非常可移植。我们只有 Windows。你无法在 Mac、Linux 或手机上运行 C#代码。游戏机也不行。

开源社区创建了 Mono，这是 C#的开源版本，旨在在 Linux 操作系统上运行，但它始终落后于微软在 C#中的实现几年。最终，Mono 成为 C#开发者利用他们的语言技能，使用 Mono 和名为 Xamarin 的框架创建移动应用程序，为 Android 和 iPhone 平台提供了一种非常流行的途径。

一个名为 Unity 3D 的游戏开发引擎也利用了 Mono，并将 AAA 级别的游戏引擎带到了大众市场。在此之前，像 Unreal 这样的游戏引擎都是严格内部使用的。唯一开发高质量游戏的方法是在能够负担得起非常昂贵的 SDK 的公司工作。Unity 3D 打开了游戏开发行业的门户，他们使用 C#/Mono 来实现这一点。

随着时间的推移，微软使每种语言的迭代都更加便携。当微软宣布其 Azure 云平台时，我们看到了一个巨大的转变。他们明智地认识到，大多数 IT 专业人士永远不会使用限制他们使用微软产品的系统。Linux 拥有大多数网络服务器的份额。当云计算在受欢迎程度上达到临界质量时，我们看到微软的生态系统中引入了大量的开源兼容性，包括 .NET Core，它允许我们编译和运行 C# 或任何 .NET 语言，在几乎任何类型的硬件环境中运行，使你的代码真正便携。这种便携性来自 .NET 运行时。让我解释一下这意味着什么。

任何编程语言执行代码的方式都有几种。首先，有可以编译成原生机器代码的代码。为此，你需要像 C、C++ 或 Rust 这样的语言。以这种方式编译的程序在“裸机”上运行，这使得它们在执行速度上非常快，但用于此的语言通常更难使用。C 和 C++ 要求你监控你的内存使用情况，这是这些工具中编写的主要错误来源。Rust 通过非常严格的编译时间限制来消除内存错误。使用这些语言可能会很沮丧，而且你的上市时间通常较慢，尤其是在首次采用这些语言时。在开发者的生产力和软件运行时的性能之间有一个权衡。

第二阵营是使用解释器的语言。通常，这些语言是脚本语言，例如 Python、PERL 和 Lua。这些语言围绕开发者生产力构建，通常牺牲执行速度和效率。

第三组处于中间位置。所有 .NET 语言，与 Java 类似，都编译成中间二进制格式。Java 称之为字节码。C# 和其他 .NET 语言称之为**公共中间语言**（**CIL**）。这些二进制格式比解释语言执行得更快、更高效，但它们确实需要一个运行时来执行中间形式。

记住任何给定语言的代码发布版本可能的表现是很重要的。总的来说，编译后的 C# 代码通常比“裸机”编译语言慢，但差距并不大。

# C# 的语言机制

我们已经提到 C#是一种严格的**面向对象编程**（**OOP**）语言。OOP 语言支持一系列抽象特性，在我们继续之前，你需要理解这些特性。首先，OOP 语言与过程式语言组织代码的方式不同。在 OOP 中，我们使用代码来模拟现实世界中的元素。现实世界元素使用**属性**、**方法**和**事件**来描述。

例如，如果我要模拟一个圆，我可能会给它一组如图 A1.3 所示的属性：

![图 A1.4：一个圆，就像其他任何事物一样，可以通过描述其属性集来表示](img/B18605_Figure_A1.3.jpg)

图 A1.4：一个圆，就像其他任何事物一样，可以通过描述其属性集来表示

使用这些属性，我可以描述我在程序屏幕上想要绘制的任何圆。

实际上，属性是属于圆的变量。它们包含描述圆的数据。当描述属于对象的变量时，我们称之为*属性*、*成员变量*或*成员*。

此外，对象还描述了它们可能执行的动作。当我们从 OOP 的角度谈论函数时，我们称之为方法。我们可以说我们的圆对象有一个名为`draw()`的方法，它根据描述圆的属性将圆绘制到屏幕上。我们还可以添加一个调整圆大小的方法。方法与函数是同一件事，因此我们可以传递参数。我们的调整大小方法需要知道圆的新半径。它可能这样被调用：`resize(100)`。这将把圆的半径从 200 改为 100。

对象通常还有一组专门的方法，用于响应事件。事件可以描述为程序运行期间发生的*事情*。常见的例子可能包括用户点击圆圈、将光标悬停在圆圈上、用鼠标右键点击圆圈、在触摸屏上长按圆圈，或者时间的流逝。也许你希望圆圈在 10 秒后消失。

对象并不需要具备所有这些部分。有些对象仅使用属性来表示数据。有些则仅用于常量和方法，例如 C#中的`Math`类。然而，大多数情况下，它们是混合使用的。

除了对象通过属性和方法组织之外，还有一些其他术语需要学习：

+   封装

+   组合

+   继承

+   多态

+   开放递归

所有这些都听起来非常复杂，但别担心，这正是我在这里的原因。我们将在本章中涉及所有这些概念。

面向对象编程首次在 20 世纪 80 年代通过 Ada 编程语言出现。Ada 是以编程先驱 Augusta Ada King，Countess of Lovelace 的名字命名的。你可能听说过她，她是 Ada Lovelace。以她的名字命名的语言是在与美国国防部（**DoD**）签订的合同下创建的，旨在取代当时在 DoD 使用的 450 多种不同的编程语言。正如你可以想象的那样，它有一些很大的挑战。Ada 语言对编程的影响，就像 Tucker 汽车对美国汽车工业的影响一样。1948 年的 Tucker 汽车是第一个提供标准安全带、水冷铝制发动机、碟刹、燃油喷射和独立悬挂的汽车。这些都是现代汽车的标准功能，我们很难想象今天没有这些功能就购买汽车。然而，在 20 世纪 40 年代设计和制造的汽车上，这些功能并不存在，或者至少不是在单一汽车上。

原始的 Ada 语言支持面向对象、基于合同的编程、强类型、显式的并发语法、任务、消息传递、使用私有和受保护类进行封装，以及由编译器强制执行的代码安全性。听起来熟悉吗？许多现代语言，包括 C#，都包含这些特性，这主要归功于 Ada 所体现的优点。

面向对象编程（OOP）之所以流行，是因为它允许你以有意义且易于理解的方式组织你的软件。首先学习 OOP 的开发者很难切换到其他方式。在与这两种思维方式共事多年后，我认为 OOP 是创建大型软件项目的最佳方式，因为它迫使你以某种特定的方式思考。面向对象编程的主要原则，其中一些在 SOLID 原则中有所涉及，就像内置的方式，以最安全的方式使你的软件可维护、可测试和可扩展。我认为在最初学习模式时使用面向对象的语言很重要。模式的原作是基于 Java 的，这与 C#非常相似。这本书中提出的许多想法在非面向对象、多范式或动态语言中可能无法工作或必须强行适应。例如，JavaScript ES5 被认为是面向对象的，但对象是动态的。通过这种方式，我的意思是，在代码运行期间，你可以随时更改任何对象的结构，包括语言内部支持的任何对象。你甚至可以因为 JavaScript 使用原型继承而改变一个对象的所有实例。JavaScript 是弱类型，它支持的类型列表有限。类和封装在 ES5 中根本不存在。在像这样的语言中研究模式是困难的，因为模式需要一个基础的限制规则集，而在许多其他语言中并不完全存在。

通过选择使用 C#，你将自己与开发软件时使用已知、经过实战检验的模式的所有关键原则对齐。

## C#中的变量

我认为变量的最简单定义如下：

*变量是一个命名容器，它在计算机内存中存储数据。*

当你学习一种编程语言时，你需要知道该语言是强类型还是弱类型。

在**强类型**语言中，也称为静态类型语言，你必须定义变量的数据类型。你必须告诉程序你正在给定的变量中存储什么类型的数据。

在**弱类型语言**中，你不需要声明类型，因为实际上只有一个类型：一切都是对象。

这里有一个很好的思考方式。数据可以有一个形状，容器也可以。容器也有一个确定的大小。你不能把一磅糖放进只能容纳四分之一磅的容器里。然而，你可以把同样的一磅糖放进一个有空间的 5 加仑桶里。

C# 是一种静态类型语言，它支持**隐式类型**，也称为**鸭子类型**。在像 C# 这样的强类型语言中，你会看到如下这样的代码：

`int myNumber = 5;`

这里，我们创建了一个名为 `myNumber` 的变量，类型为 `int`，并将其初始值设置为 `5`。

隐式类型允许我们进行一个小小的改动：

`var myNumber = 5;`

与类型声明出现在名称之前不同，你使用一个通用的关键字 `var`。编译器会将这些语句视为相同。编译器可以根据其初始赋值来确定变量的类型。在这里，我们看到初始赋值为 5，因此编译器会假设你想要这是一个整数（`int`）。如果你不是这个意思，你可以给编译器一个提示。比如说，我们真正想要 `myNumber` 是 `decimal` 类型。由于 5 和 5.0 之间没有数学上的区别，编译器会出错，最终你会在代码中得到红色的波浪线，表明你有问题。你如何指定类型并仍然使用 `var` 关键字语法？看这里：

`var myNumber = 5d;`

我们在数字后面添加一个 *d* 作为后缀。就这样，编译器现在知道你想要这是一个十进制数。但我跑题了。

### 由内存大小使用的有符号数值类型

C# 支持有符号和无符号数值类型。编程语言中的数字在内存中使用二进制补码的数学运算来处理，如图 A1.4 所示：

![图 A1.5：计算机中整数的表示使用一个称为二进制补码的数学概念。有一年，我以一个整数的身份参加了办公室的万圣节派对。我把这个图印在了 T 恤上。最好的服装是那些需要解释的](img/B18605_Figure_A1.4.jpg)

图 A1.5：计算机中整数的表示使用一个称为二进制补码的数学概念。有一年，我以一个整数的身份参加了办公室的万圣节派对。我把这个图印在了 T 恤上。最好的服装是那些需要解释的

如果你是一个数学爱好者，可以查看进一步阅读部分提供的维基百科页面。

对于我们其他人来说，这个概念可以简单地解释。任何打算存储数字的变量都将有一个数字的最小和最大大小。例如，常见的 32 位整数（`int32`）在最小端有-2,147,483,648 的范围，最大值为 2,147,483,647。我们必须从最大值中减去一个来考虑零。大小范围由使用的内存空间量决定。我刚才展示的范围代表**有符号**类型的容量，这意味着它支持小于零的数字。如果你不关心负值，C# 允许你使用**无符号**类型，这些类型将范围扩展到 0 到 4,294,967,295。

C# 允许你通过选择众多有符号和无符号的范围来控制内存使用。换句话说，有符号数值类型由内存大小使用来界定。我认为这是大多数开发者忘记或忽视的一个点，因为我们大多数人需要整数时，只是使用 `int`。我之前使用了一个类比：

*你不可能把一磅糖放入只能装四分之一磅的容器中。然而，你却可以把同样的一磅糖放入一个 5 加仑的桶中，还有富余的空间。*

在 5 加仑的桶中有很多浪费的空间。你可以通过选择一个与使用方式兼容的范围来控制浪费。想想看，你有多少次看到或做过这样的事情：

`int myAge = 54;`

这是一种巨大的空间浪费。首先，一个人的年龄不可能是负数。将其改为以下内容是有意义的：

`uint myAge = 54;`

在这里，我们使用 32 位整数的无符号版本。看看你能否从以下表格中选择一个更合适的类型：

| **类型** | **描述** | **最小值** | **最大值** | **位数** |
| --- | --- | --- | --- | --- |
| `bool` | 布尔值 | False (0) | True (1) | 1 |
| `byte` | 无符号字节 | 0 | 255 | 8 |
| `sbyte` | 有符号字节 | -128 | 127 | 8 |
| `short` | 有符号短整数 | -32,768 | 32,767 | 16 |
| `ushort` | 无符号短整数 | 0 | 65,535 | 16 |
| `int` | 有符号整数 | -2,147,483,648 | 2,147,483,647 | 32 |
| `uint` | 无符号整数 | 0 | 4,294,967,295 | 32 |
| `long` | 有符号长整数 | -9e18 | 9e18 | 64 |
| `ulong` | 无符号长整数 | 0 | 1.8e19 | 64 |

图 A1.6：C#整数类型列表及其范围和每种类型消耗的内存量。

如你所见，随着我们向下查看图表，我们使用的内存越来越多。位是计算机可以处理的最小单位。64 位整数只能用*±9 kajillion*或*18 kajillion*这样的术语来理解，这取决于它是有符号的还是无符号的。

我们为什么要用一个最大值为 80 亿的 32 位无符号整数来表示一个人的年龄？要么我们不了解数值类型的划分，要么我们只是懒惰，这是我们之前在*第一章*中提到的那种令人衰弱的力之一。我们刚刚打破了一扇窗户，把我们引入了一个大泥球。我们应该使用一个最小值为 0，最大值为 255 的无符号字节。除了在夏威夷的一个秘密岛屿上生活的猫王，以及显然永生的 Chuck Norris 之外，大多数正常人类都不会活过 100 岁。当你考虑到地球大约有 45 亿年的历史时，你开始看到这种常见做法的愚蠢。如果你这样做，你并不孤单。微软在其 C# 文档中也这样做。我差点开玩笑说写作者是糟糕的程序员，但如果我这样做，那我就自讨苦吃。只要你现在意识到你在浪费很多内存，我不会责怪你立即将所有生产代码从 `int` 改为 `byte`。

*图 A1.7* 展示了我们所有的有效整数类型。对于浮点数和文本类型，有类似的名字和范围。所有这些类型都被认为是 `int` 关键字映射到 `Int32` 类。

实际列表最终变成了类似于 *图 A1.7* 中的列表：

| **别名/原始关键字** | **.NET 类型** |
| --- | --- |
| `bool` | System.Boolean |
| `byte` | System.Byte |
| `sbyte` | System.Sbyte |
| `short` | System.Int16 |
| `ushort` | System.Uint16 |
| `int` | System.Int32 |
| `uint` | System.Uint32 |
| `long` | System.Int64 |
| `ulong` | System.UInt64 |

图 A1.7：C# 整数范围的完整列表，第一列是别名，第二列是实际实现类。

C# 允许使用别名，并且通常别名指向用大写字母表示的相同类名。所有原始类型都在 .NET 的 `System` 对象中。你创建的几乎每个 Visual Studio 项目都在顶部有一个 `using System` 语句。这就是为什么你可以看到字符串以多种不同的方式创建。

使用全部小写字母定义的字符串之所以有效，是因为别名：

`var string foo = "bar";`

使用大写 `String` 关键字定义的字符串之所以有效，是因为你项目顶部可能存在的 `using System` 语句：

`var String bar = "baz";`

当然，你也可以这样写：

`var System.String fooBarBaz = "foo bar baz";`

实际上，我从未见过有人这样做。多年前，我在附近的一所大学教授 C# 初级编程课程时，`String` 和 `string` 之间的区别是一个广泛询问的问题，尤其是来自之前学习过 Java 的学生。Java 缺乏这些类型的别名。

### 使用不同引号分隔字符和字符串类

这个点很短，但如果你是从其他语言过来的，或者如果你经常切换语言，那么它值得提一下。C# 有用于字符串和字符的单独的类类型。字符串类型是 `System.String`。它是一个使用频率很高的别名，就是 `string`。字符类型，即单个字符字符串，是通过使用 `System.Char` 类或简单地使用 `char` 创建的。赋值时使用的引号也很重要。许多语言，如 JavaScript 和 Python，允许你单引号和双引号互换使用。在 C# 中，字符串用双引号表示，而字符使用单引号赋值。它们是不可互换的。

### 收藏

JavaScript 有 `数组`（也就是我希望在工作中能用来写书的东西）。Python 有 `列表`。Java 有 `ArrayLists`。C# 有一个广泛的 **集合**。C# 有类似于 JavaScript 的数组，但它们更有限。你必须提前设置你要放入数组中的项目数量，一旦设置，这个数量就不能轻易改变。C# 中更有用的数组形式是 .NET List 类。

列表类类似于数组，除了你可以在需要的时候随时添加和删除项目。它们要灵活得多。列表在 C# 中是强类型的，就像其他所有东西一样。这意味着列表中的所有项目都必须是同一类型。C# 有一个名为 `<>` 的系统来处理这个问题。在书中，你会看到对 `List<>` 的引用。这表示一个泛型列表，再次强调，这意味着只要你放入列表中的所有东西都是同一类型，你就可以把任何东西放入列表。如果你想创建一个字符串列表，它可能看起来像这样：

```cs
var myStrings = new List<string>();
myStrings.add("foo");
myStrings.add("bar");
```

要使用这些泛型集合，你必须在类文件顶部添加一个语句，如下所示：

```cs
using System.Collections.Generic;
```

泛型集合是 .NET 框架中最灵活和最广泛使用的类之一。你肯定会很早很频繁地遇到它们。

## 类

到目前为止，我关于你对面向对象编程（OOP）了解的假设是，你知道类是什么以及它的用途。万一这是一个无效的假设，我们现在就澄清一下。一个 *类* 可以被看作是房子的蓝图。蓝图描述了建造房子所需知道的一切。你可以使用这个蓝图建造你需要的任何数量的房子，在你建造它们的时候，你可以改变每座房子的个别属性。它们不必都是相同的大小或颜色，也不必都有一定数量的窗户。在你建造房子的时候，你可以改变这些属性中的任何一个。

在大多数面向对象编程语言中，类是定义对象构造的主要形式。甚至还有称为构造函数的特殊方法，当对象被实例化时运行，也就是说，当你使用 new 关键字创建对象实例时。

这里是之前我使用的 `Person` 类的例子。这次，我添加了所有部分，这样我就可以向你展示了：

```cs
using System;
namespace MyProject;
class Person
{
  public string Name { get; set; }
  public byte Age { get; set; }
  public Person()
  {
    Name = string.Empty;
    Age = 0;
  }
  public Person(string name){
  {
    Name = name;
    Age = 0;
  }
  public Person(string name, int age)
  {
    Name = name;
    Age = age;
  }
  public override string ToString()
  {
    return "Person: " + Name + " " + Age;
  }
}
```

一个类有几个主要部分：

+   使用语句来定义依赖项

+   命名空间

+   类名

+   构造函数

+   属性

+   方法

让我们逐一介绍每个部分。

### 使用语句

在 C#中，`using`关键字有两个含义。当你在一个类的顶部看到它时，它指的是类的依赖项。这在大多数语言中都很常见。在 Java 和 Python 中，这个词是`import`。在 JavaScript 中，根据你使用的约定，它可以是`require`或`import`。在 C#中，关键字是`using`。这个语句向编译器发出信号，表明我们将要引用的某些类存在于我们项目的其他部分，甚至可能存在于项目外部，这就是当我们使用第三方库时的情况。

例如，为了使用`Console.WriteLine`方法，该方法将文本打印到控制台，首先，我们必须声明我们将使用`System`命名空间。我们通过以下语句来完成：

```cs
using System;
```

`Console`对象位于`System`命名空间中。`using`语句告诉编译器我们将使用该命名空间中的类。最后一个语句很自然地过渡到下一个主题。

### 命名空间

命名空间是组织 C#代码的一种方式。如果你来自 Java，你使用过包。在 Python 中，它们被称为模块。在 JavaScript 中，你导出你想要在模块化代码中公开的对象。在 C#中，命名空间出现在你的类文件顶部。通常，它对应于你的项目名称。如果你在项目中创建文件夹来分割你的代码，通常，命名空间会反映文件夹结构。

在前面的示例代码中，我们有一个名为`MyProject`的命名空间，这将是 C#项目的名称。如果我创建一个名为`helpers`的文件夹来存放一些辅助对象，这些文件夹中的命名空间将是`MyProject.helpers`。

命名空间不是绝对必需的。大多数集成开发环境（IDE）会自动将它们添加进去，所以你通常会看到它们。五年前，当我最后一次使用 Unity 3D 游戏引擎时，IDE 没有自动在类代码中添加命名空间。虽然没有命名空间也可以工作，但这种情况很少见。Visual Studio 和 Rider 在创建类时会自动添加命名空间。在 VS Code 中，一切都是手动的，所以你可能需要自己添加。

### 类名

命名类的行并不难找：

```cs
class Person
```

你只需使用关键字`class`后跟类的名称。按照惯例，类名使用 Pascal 大小写约定，这意味着类名中的每个单词都由一个大写字母表示。如果我们想要创建一个表示零售店楼层经理的类的类，我们会称它为`FloorManager`。

类，就像属性和方法一样，可以使用访问修饰符来定义它们可以被如何访问。我们稍后会更多地讨论这个问题。

### 构造函数和实例化

构造函数是一种特殊的方法，当您`创建实例`（即实例化）时运行。看吧？这是一个每个软件开发者都需要理解的术语。实例化发生在您在构造函数方法前加上`new`关键字时。这就是为什么您的`new`语句后面总是有一个括号的原因。构造函数返回根据构造函数中的任何代码设置的实例。如果您没有提供构造函数，.NET 编译器在编译时会添加一个空的构造函数。

构造函数有一些定义规则。首先，构造函数的方法名必须与类的名称匹配。其次，您不能定义返回类型，因为它固定为返回正在构建的类的实例。

C# 允许您拥有多个重载的构造函数。这意味着只要类型和参数数量不同，您就可以有多个构造函数。我们之前提供的代码示例包含三个构造函数：

```cs
public Person()
  {
    Name = string.Empty;
    Age = 0;
  }
  public Person(string name){
  {
    Name = name;
    Age = 0;
  }
  public Person(string name, int age)
  {
    Name = name;
    Age = age;
  }
```

注意以下事项：

+   所有构造函数都命名为 `Person`，因为这是类的名称。它们必须与类的名称匹配，否则它们不是有效的构造函数。

+   没有指定返回类型。返回类型应该在 `public` 关键字和构造函数方法名称之间。

+   尽管这三个函数因为参数数量不同而具有相同的名称，但这在语法上是允许的。第一个构造函数没有参数，第二个有一个参数，第三个有两个参数。这被称为*方法重载*，它是一种多态形式。

构造函数是建立对象初始状态的一种非常有用的方式，即在对象创建的瞬间。我经常说，软件开发者的首要任务是确保程序中的任何对象都无法进入无效状态。

在前面的例子中，构造函数的语法有些过度。C# 会自动将 age 属性初始化为 0。我将字符串初始化为空字符串，因为我不喜欢处理 null 值的歧义。有时，你选择的语言，在这个例子中是 C#，会尝试为你处理一些事情，比如初始化。依赖自动的语言特性会导致精神上的懒惰，这是我在*第一章*中提到的具有破坏性的力量之一，它会导致混乱、难以维护的代码。如果你不相信我，去 YouTube 上找找关于 JavaScript 自动分号插入“功能”的视频。你需要记住，你的代码是一组将被地球上最愚蠢的东西之一执行的指令。计算机会字面地处理一切，如果你的指令中包含任何歧义，总会出现糟糕的喜剧。当然，有些人把这称为工作保障，每个人都需要好的战争故事来讲述。就像有一次，团队里的某个人将一个不完整的 SQL 更新语句粘贴到 SSMS 中，指向了一个生产数据库，并将所有客户记录更新到了一个账户。每天有百万用户使用的系统瘫痪了 7 个小时。为了清楚起见，不，那不是我。如果是我，我永远不会提起这件事。我是在指出一个观点。那次痛苦的经历发生是因为有人太懒惰，没有正确地完成他们的工作。就我个人而言，我宁愿做正确的事情，让我的周末保持空闲。当我编写代码时，我总是明确且有意。这让我远离麻烦。始终关注你的对象状态，并编写代码以防止无效状态。你的构造函数是第一道防线。第二道防线是封装，我们很快就会谈到。

### 属性

对象由状态变量和能够对这些状态变量执行工作的函数组成。这是一种说法，即对象就像两个常见编程概念的结合：变量和函数。类被设计用来表示现实世界中的对象。现实世界中的任何对象都是由其描述性属性定义的。它是什么颜色？它比面包箱大吗？物理对象进一步由它们能够做什么来定义。一辆车可以行驶，一只狗可以吠叫，等等。

现在，让我们专注于对象的描述符。很容易称它们为属性。一个篮球有周长、橙色、黑色线条和它所含空气量等属性。这些都是篮球的属性。在 C# 类中，属性看起来像这样：

```cs
public string Name { get; set; }
```

单词 `public` 是一个访问修饰符。我们之前在附录中描述过。

每个属性都有一个名称。这个属性的名称是 `Name`，它被定义为字符串。说 `{ get; set; }` 的部分使其成为一个自动实现的属性，这是一种我稍后会解释的简单封装形式。

你使用点符号来访问实例化对象上的属性。例如，要设置`Person`对象的`Name`属性，你需要实例化然后像这样设置它：

```cs
var somebody = new Person();
somebody.Name = "Bruce";
```

访问修饰符定义了 C#中属性、方法和甚至类的可用性。

### 方法

方法是附加到对象上的函数。由于 C#是严格面向对象的，我们可能应该始终将它们称为方法而不是函数，但这两个词实际上是同义的。即使是 OOP（面向对象编程）的坚定支持者有时也会不小心说出*函数*这个词。把这个问题放一边，关于 C#中的方法，有几个要点需要记住。首先，它们遵循与变量相同的规则，即它们是强类型的。它们需要传入的任何参数都应该是已类型化的，以及返回值也应该是已类型化的。像变量一样，方法名需要在作用域内是唯一的。

C#使用类似于 C 语言的 C-like 方法签名，这是所有基于 C 的语言的共同特点。方法签名由定义方法独特性的部分组成：

+   函数的名称

+   参数的数量和类型

+   返回值的类型

在前面的例子中，我们有这个方法：

```cs
public override string ToString()
{
  return "Person: " + Name + " " + Age;
}
```

在这个方法签名中，我们可以看到这个方法是公开的。它可以被程序中的任何类访问。我们可以看到它的名字是`ToString`，并且它不接受任何参数。此外，我们可以看到这个方法预期返回一个字符串。

这个方法在访问修饰符和返回类型之间有一个额外的关键字。它说`override`。`ToString()`方法在 C#中的每个对象上都有，因为该方法在 Object 基类中。它总是从基类继承到每个你创建的对象中。基类实现并不非常有用。非常常见的是用更有用的东西来覆盖函数。这正是前面例子中发生的事情。我们通过用我们自己的实现覆盖基类实现来更改基类实现。我们在本书涵盖的项目中做了很多这样的地方。

# 封装

这个概念涉及到 OOP（面向对象编程）最重要的方面之一：维护对象的状态。

在前面的*图 A1.3*中，我展示了一个具有一组描述你所看到的圆的属性值的圆。随着你的程序运行，这些属性可能会根据程序中的事件而改变。如果你在程序执行过程中的任何时刻对这个圆进行快照，你就可以谈论它的当前状态。它目前有一个 200 像素的半径，黑色线条颜色和深灰色填充颜色。让我们编写一些代码，以最简单的方式表示我们的圆，没有任何封装，这样我们就可以稍后看到它被添加：

```cs
public class Circle
{
  ushort centerX;
  ushort centerY;
  ushort radius;
  byte lineWidth;
  string lineColor;
  string fillColor;
}
```

在这个列表中，我们创建了一个 `Circle` 类，并在其中定义了基于我们之前讨论的字段。请注意，我没有说属性。在 C# 中，属性和字段是不同的。字段仅仅是成员变量。这些字段是开放的。实际上，任何其他类都可以在任何时候直接修改这些字段。为什么这是不好的呢？记住，这全部都是为了保护状态。有一个负半径真的没有意义，这就是为什么我使用了无符号短整型。同样，计算机上的图形坐标系统通常严格为正，0,0 位于屏幕的左上角。因此，我这里使用了无符号短整型，因为我们不需要负值，而且上限看起来是合理的。到目前为止，我做得一切都很正确，除了我没有在限制基于类型的无效值的基础上保护状态。

让我们想象一下，你正在编写一个像 *Adobe Illustrator* 或开源程序 *Inkscape* 这样的程序。这些程序处理矢量图形，并且它们肯定需要一个结构来处理圆形。从代码行数和类的数量来看，这两个程序都相当庞大。我意识到这两个程序都不是用 C# 编写的，但如果它们是的话，想象一下每个程序在任何给定时刻都会有成千上万的不同的对象在飞舞。如果其中任何一个对象有在任意时刻修改我们圆形对象属性的能力，那么在圆形中找到和调试奇怪的行为变化几乎是不可能的。通常，缺乏封装是由于懒惰的致命罪过、缺乏想象力，或者两者兼而有之。

我们的程序可以在任何时候更改这些属性。封装的目的是防止你将你的对象置于一个无效的状态。例如，如果我尝试指定一个负数的半径，这实际上是没有意义的。

为了保护我们的对象不进入无效状态，我们可以使用访问修饰符隐藏属性。访问修饰符是定义“谁或什么”可以更改对象状态的关键字。在一个理想程序中，对象应该始终只负责自己的状态。程序中的不同对象不应该直接操作半径。除了访问问题之外，除了我们的强类型变量系统之外，没有其他东西在监控传入数据的类型。为了改进事情，让我们从半径开始。早些时候，我提到我认为`ushort`是一个合适的类型，因为它是无符号的，不支持负值。此外，我认为下一个最低的无符号类型`byte`，最大值为 256，太小了。我很容易就能看到需要能够制作直径大于 256 像素的圆。但是 65K 可能太大。假设我想将最大半径限制为 1,000 像素。这可能很明智，因为在大型图形组合中，我们可能有成千上万的圆，我们应该考虑我们的内存消耗。我们可以通过一个特殊函数来隐藏半径字段，该函数检查你设置的半径是否有效，在这种情况下，是一个介于 0 和 1,000 之间的数字。

这里有两个步骤。首先，你必须使用访问修饰符隐藏半径。最常见的访问修饰符如下所示：

+   **公共**：任何内容都可以访问属性或方法。

+   **私有**：只有这个对象可以访问属性或方法。

+   **受保护**：只有这个对象及其后代可以访问属性或方法。在讨论继承之后，我们将进一步讨论这个问题。

你会在大多数面向对象的语言中找到这些。C#有一些额外的访问修饰符：

+   **内部**：同一程序集内的任何内容都可以访问属性或方法。

+   **受保护的内部**：属性或方法只能由声明它的程序集内的代码或从创建它的类的子类访问。

+   **私有受保护**：属性或方法可以被声明在同一程序集中的子类访问。

你可以使用以下表格来可视化这一点：

![图 A1.8：调用者位置的相对访问级别](img/B18605_Figure_A1.5.jpg)

图 A1.8：调用者位置的相对访问级别

让我们回到改进`Circle`类。我们将做的第一个改进是给半径字段添加一个私有访问修饰符。我还会将`radius`移到顶部，这样在讨论中更容易看到：

```cs
public class Circle
{
  private ushort radius;
  ushort centerX;
  ushort centerY;
  byte lineWidth;
  string lineColor;
  string fillColor;
}
```

私有访问修饰符告诉我们，只有“这个特定对象”中的方法可以更改半径。这很完美，但现在半径字段完全隐藏了。没有从外部设置它的方法，我们当然需要在某个时候这样做。让我们将访问修饰符更改为更宽容的：

```cs
public class Circle
{
  private ushort radius;
  ushort centerX;
  ushort centerY;
  byte lineWidth;
  string lineColor;
  string fillColor;
}
```

好的。现在我们回到了起点。公共访问修饰符意味着任何东西都可以更改半径。这不好！该死！

我们需要私有回退，但我们需要它更好一些。我们需要访问器方法来允许我们从对象外部获取和设置字段值，但以一种我们控制的方式。当我这样做时，我使用一个常见的约定，将字段重命名，使其以下划线开头。这样做是为了我们可以轻松记住它是一个私有回退字段：

```cs
 private ushort _radius;
```

接下来，让我们添加一个访问器方法，以便我们可以获取半径。`get` 方法通常被称为 *getter*。我们不需要对这个方法有任何限制：

```cs
 public ushort getRadius()
 {
  return _radius;
 }
```

接下来，让我们处理手头的真正问题，即控制半径的设置方式。另一个访问器方法可以用来：

```cs
 public void setRadius(int newRadius)
 {
  if(newRadius >= 0 && newRadius <= 1000)
  {
    _radius = newRadius;
  }
  else
  {
    throw new Exception("The radius must be between 0 
    and 1000.");
  }
 }
}
```

现在我们有一个 `set` 方法，通常被称为 *setter*，可以设置值。请注意，它的访问修饰符是公共的，这是我们刚刚学到的意味着任何东西都可以访问它。这个设置器方法包含检查新半径是否符合所需范围的代码。如果符合，它就会将半径更改为新值。现在对象控制着自己的状态。你不能随意将值设置为无效的数字。你必须 *请求* 对象更改其半径值，而且它不会自动说 *好的* – 它会检查确保你没有传递一些没有意义的东西。

此外，访问器方法还可以用来定义只读属性。通过简单地忽略创建公共设置器方法，你限制了将私有字段值设置给这个类中其他方法的权限。

## C# 自动实现属性

如果你是一个 C# 老兵，你现在可能正在对这本书大喊大叫。不要这样做。首先，除非你戴着耳机，否则这会让你看起来很疯狂，然后至少你周围的人会认为你只是在对着岳母大喊大叫。其次，这本书非常敏感。你可能会伤害它的感情。我明白。早期的例子绝对不是我们通常在 C# 中创建访问器方法的方式 – 至少不是现在。在我和你一样大的时候，汽油是每加仑 35 美分，我们就是这样做的。我喜欢这样展示给你，因为我认为如果不解释它是如何工作的就把 `int foo { get; set; }` 丢给某人，那有点残忍，也就是说，这就是平均的 C# 书籍可能会涵盖它的方式。众所周知，*残忍* 是平均的。那是一个数学双关语吗？是的，我认为是。

现代 C#定义属性有不同的语法，基于这样一个观点：大多数属性实际上都是字段。但如果你把它们当作字段，你的面向对象教授会给你一个 B，因为你没有封装它们。我们不能这样。我可以回到我的肥皂箱上，谴责它们的存在，但我有一个页数限制需要遵守，所以我们来看看它们是如何工作的，你可以决定它们是否是一个好主意。

如果你想要说明你的类是完全封装的，但不需要任何逻辑来控制状态，你的代码最终会变成很多像这样的样板代码：

```cs
public class Student {
  private string _firstName;
  private string _lastName;
  private int _age;
  public string getFirstName(){
    return _firstName;
  }
  public void setFirstName(string firstName){
    _firstName = firstName;
  }
  public string getlastName(){
    return _lastName;
  }
  public void setLastName(string lastName){
    _lastName = lastName;
  }
  public int getAge(){
    return _age;
  }
  public void setAge(int age){
    if(age > -1 && age < 970){
      _age = age;
    } else {
      throw new Exception("Age must be between 0 and 
      970 years");
    }
  }
}
```

这是一大堆不做什么的代码。它只存在于调用类成员 *封装* 的服务中。在这种情况下，可能没有必要控制姓名字段的第一和最后部分。我想不出你可能会对数据类型施加的任何限制，除了它必须是一个用户界面中的必填字段。假设样板代码是合法的，但我们想现代化并使用自动实现的属性。你的代码可以简化为这样：

```cs
public class Student {
  public string FirstName {get; set;}
  public string LastName {get; set;}
```

自动实现的属性允许你在不需要在获取器和设置器方法中放入逻辑的情况下使用这种简化的语法。

## 带有后备变量的访问器逻辑

封装的实际力量在于你使用访问器方法来控制对象的状态。作为开发者，你的最大任务是确保你的对象无法进入无效状态。例如，考虑 `Age` 属性。年龄属性中的负数没有意义。同样，一亿年也没有意义。据我所知，有史以来最长寿的人类是《旧约》中的玛土撒拉，他活到了大约 970 岁。由于没有访问器逻辑，我可以将年龄设置为 100 岁或 1,000,000,000 年。如果我想让控制逻辑限制输入值，我需要创建类似这样的东西：

```cs
  private int _age;
```

在这里，我们创建了一个名为 `_age` 的私有后备变量。我们需要这个变量来保存值，因为属性现在处于访问器逻辑的控制之下。通常，以下划线开头的私有变量命名是常见的。

接下来，我们添加逻辑。在获取器上我们实际上并不需要任何特殊的东西：

```cs
  public int Age {
    get => _age;
```

设置器是魔法发生的地方：

```cs
    set {
      if(value > -1 && value < 970){
        _age = value;
      } else {
        throw new Exception("Age must be between 0 and 
        970 years");
      }
    }
  }
}
```

然后，我们使用自动实现的方法语法来创建属性，但这次内容更丰富。本质上，获取器的语法是一个返回 `_age` 后备变量的胖箭头函数。设置器除了值变量外都很直接。这个值变量从哪里来？这是魔法。它是语言的一部分，用于这种场景。它保存了传递给设置器的任何值。

# 继承

C# 是一种静态编译的语言，支持经典继承模型。我所说的静态编译是指你的对象结构不能改变，除非你停止运行程序，修改类的源代码，重新编译，然后再次运行。你可以将 C# 的静态特性与设计为动态的语言（如 JavaScript）进行对比。

JavaScript 与许多约定不同，其中最不寻常的是它使用原型进行继承而不是类。就这个而言，它不支持封装。它基于 Lambda 函数的概念，这在 JavaScript 被发明时也是新颖的。JavaScript 使用词法作用域而不是我们在 C#中找到的更传统的块作用域。简而言之，如果你只了解 C#，JavaScript 与 C#相比真的很奇怪。

既然我们已经确定了有不止一种继承方式，让我们回到 C#中看看它是如何工作的。

假设你正在编写软件来跟踪学校或大学的教师和学生群体。你需要建模一个学生类——可能像这样：

```cs
public class Student
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string EmailAddress { get; set; }
    public float GradePointAverage { get; set; }
    public List<Course> Courses { get; set; }
    public void Study()
    {
        Console.WriteLine("I am studying");
    }
    public void TakeTest()
    {
        Console.WriteLine("I am taking a test!");
    }

    public void DoHomework()
    {
        Console.WriteLine("I am doing homework.");
    }

    public void AskParentsForMoney()
    {
        Console.WriteLine("Hey Dad, do you have a 
        minute?");
    }
}
```

此外，你还需要建模一个`professor`类——可能像这样：

```cs
public class Professor
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string EmailAddress { get; set; }
    public bool HasTenure {get; set;
    public List<Course> Courses { get; set; }

    public void GradeTest()
    {
        Console.WriteLine("I am grading a test.");
    }

    public void TeachClass()
    {
        Console.WriteLine("I am teaching a class.");
    }
    public void BegForResearchFunding()
    {
        Console.WriteLine("Hey National Science Foundation, 
        do you have a minute?");
    }
}
```

这里我们遇到了一个问题。由于这些属性在两个类中都被使用，所以有很多属性是冗余的。面向对象分析（OOAD）会让我们通过将公共属性抽象成超类来重新设计这两个类。这留下了只有`Student`和`Professor`类中独特的元素。提升到超类中的明显目标属性如下：

+   `FirstName`

+   `LastName`

+   `Email`

+   `Courses`

明显的目标提升包括学生类中的`AskParentsForMoney()`方法和教授类中的`BegForResearchFunding()`方法。它们实际上做的是同一件事。唯一的区别是询问谁放弃现金。

让我们创建一个超类：

```cs
public abstract class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string EmailAddress { get; set; }
    public List<Course> Courses { get; set; }
    public void BegForMoney(string who)
    {
        Console.WriteLine("Hey " + who + ", do you have a 
        minute?");
    }
}
```

我把超类命名为`Person`。它包含学生和教授之间的公共元素。现在，让我们让`Student`类从`Person`类继承。为了表示继承，我将在第一行添加一个冒号后跟超类：

```cs
public class Student : Person
{
```

现在，我只保留在超类中未定义的属性。只有一个：

```cs
    public float GradePointAverage { get; set; }
```

对于方法也是如此。我只需要那些不在超类中的方法：

```cs
    public void Study()
    {
        Console.WriteLine("I am studying");
    }
    public void TakeTest()
    {
        Console.WriteLine("I am taking a test!");
    }

    public void DoHomework()
    {
        Console.WriteLine("I am doing homework.");
    }

}
```

我可以用同样的方式对`Professor`类做同样的事情：

```cs
public class Professor : Person
{
    public bool HasTenure { get; set; }

    public void GradeTest()
    {
        Console.WriteLine("I am grading a test.");
    }

    public void TeachClass()
    {
        Console.WriteLine("I am teaching a class.");
    }
}
```

现在，这个类只包含`Professor`类中独特的属性和方法。公共属性和方法在`Person`超类中。

理解继承的关键是口头表达`Person`、`Student`和`Professor`之间的关系。我们可以说一个`Student`*是*一个`Person`（在他们的大学一年级和二年级可能存在争议），我们也可以说一个`Professor`*是*一个`Person`（在他们获得终身教职后可能存在争议）。这种口头表达既定义了又说明了超类（有时称为父类）与其后代（称为子类或孩子）之间的关系。

这引出了一个问题：是否有可能实例化`Person`类？答案是：不会。`Person`类被设计成是一个父类。它不打算被直接使用。那些不打算被实例化的类被称为`Person`类，如下所示：

```cs
public abstract class Person
```

`abstract`关键字将防止直接实例化。

只需记住，继承是 OOP 工具箱中的一个重要部分。继承就像鸡蛋一样。它是均衡早餐的一部分，但一个真正好的早餐还应该有一些纤维。让我们通过学习接口来给我们的代码增加一些比喻性的纤维。接口并不能像一碗低糖燕麦粥那样减少你患心脏病的风险。使用它们可能会在你发现一旦将它们纳入其中，你的代码将多么灵活时降低你的压力水平，这同样很好。如果你吃低糖燕麦粥*并且*在代码中使用接口，也许你会在寿命上与猫王一较高下。

# 接口

**接口**通过定义类必须具有的公共方法签名和属性来定义类必须采取的结构的一部分或全部。这是一个强大的工具，它允许你为对象的行为创建一个规范。接口的力量通过这样一个事实而倍增，即你不仅限于实现单个接口，与使用子类化的情况相比，在子类化中你只允许有一个父类。

接口用于松散地定义行为或类型。向所有在场的*Unity 3D*开发者致敬：想象一下创建一个玩家与僵尸和 H.P. Lovecraft 想象中的古老生物战斗的视频游戏——哦，还有猫，因为猫很可怕。每个怪物都可以有自己的类。你可以创建一个接口来定义诸如战斗、奔跑、吃人等行为。这样的视频游戏可能看起来像*图 A1.9*：

![图 A1.9：一个巧妙使用接口将行为映射到游戏角色中的角色设计糟糕的视频游戏](img/B18605_Figure_A1.6.jpg)

图 A1.9：一个巧妙使用接口将行为映射到游戏角色中的角色设计糟糕的视频游戏。

使用这些接口，你可以在不必要地适合继承链的对象上定义行为，并最终得到非常容易扩展的游戏代码。

与继承相比，接口的关键优势在于灵活性。在*第二章*中，我们学习了 SOLID 原则，并了解了避免将类紧密耦合在一起的技术。如果你在一个具有`Monster`类型的类上定义一个属性，那么只有`Monster`或`Monster`的子类才能工作。你的类与`Monster`紧密耦合。如果你通过一个接口，例如`IEatHumans`，来定义它，那么只要所有你需要的是该接口定义的方法，你就可以传递任何实现该接口的对象。

## 定义接口

实际上，如果下周游戏导演决定在游戏中添加一个新的怪物，如果新怪物不符合我们创建的结构，我们不需要重新调整我们的对象层次结构。我们只需创建一个新的类，并使用接口来定义其结构。让我们用 C# 编写我们在 *图 A1.9* 中看到的内容，这样我们就可以看到代码中的样子，而不仅仅是图表。四个角色使用了三个接口：

1.  `IRun`

1.  `IFight`

1.  `IEatHumans`

让我们从 `IRun` 接口开始。创建接口相当简单。你所需要做的只是指定方法签名的基本要素——具体来说，是返回类型、方法名称以及参数的名称和类型：

```cs
public interface IRun
{
    void Jog();
    void Sprint();
}
```

这很简单。我们在这里所做的是指定任何实现此接口的类都必须有两个方法，这两个方法都有 `void` 返回类型。其中一个必须命名为 `Jog()`，它不接受任何参数，另一个必须命名为 `Sprint()`，它也不接受任何参数。如果你使用的是一个好的 IDE，任何实现接口的类都会在你的代码中用红色波浪线标记，直到你满足接口的所有要求。让我们接下来做 `IFight`：

```cs
public interface IFight
{
    void Attack();
}
```

`IFight` 表示任何实现此接口的类都必须有一个名为 `Attack()` 的方法，该方法返回 `void` 并且不接受任何参数：

```cs
public interface IEatHumans
{
    void Chomp();
}
```

`IEatHumans` 要求实现类必须有一个名为 `Chomp()` 的方法，该方法不接受任何参数并返回 `void`。接口很简单。让我们看看它们是如何使用的。

## 实现接口

首先，让我们为 `HelplessVictim` 创建一个类。该类实现了 `IRun` 接口。语法与继承相同。我们使用冒号来表示接口实现，这与从超类继承时相同：

```cs
public class HelplessVictim : IRun
{
    public void Jog()
    {
        throw new NotImplementedException();
    }
    public void Sprint()
    {
        throw new NotImplementedException();
    }
}
```

为了满足接口，我们必须实现两个方法，`Jog()` 和 `Sprint()`，它们必须与接口中指定的完全一致。这很好。如果我们需要实现多个接口怎么办？一个类不能有两个父类。幸运的是，C# 不支持多重继承，这是 C++ 程序员临床疯狂的主要原因之一。然而，类可以实现任意数量的接口。让我们创建一个 `AncientTerror` 类，它实现了三个接口——`IRun`、`IFight` 和 `IEatHumans`：

```cs
public class AncientTerror : IRun, IFight, IEatHumans
{
    public void Chomp()
    {
        throw new NotImplementedException();
    }
    public void Attack()
    {
        throw new NotImplementedException();
    }
    public void Jog()
    {
        throw new NotImplementedException();
    }
    public void Sprint()
    {
        throw new NotImplementedException();
    }
}
```

`IRun` 要求实现相同的 `Jog()` 和 `Sprint()` 方法。请注意，对于不同的类，不需要有完全相同的实现。实例方法只需符合接口即可。`IFight` 要求添加一个名为 `Attack()` 的方法，该方法返回 `void` 并且不接受任何参数。`IEatHumans` 要求我们根据接口添加一个 `Chomp()` 方法。

我会把最可怕的怪物，僵尸和家猫，留到最后的问答部分作为一个练习。挑战自己，看看你是否能想出这两个剩余类的基本实现！

# C# 开发的 IDE

每当我使用一种新的或不熟悉的语言时，我最想了解的是用于该语言工作的工具。好的工具可以使学习和使用该语言变得容易得多。微软意识到了这一点，在发布 C#语言和相应的.NET 运行时后，他们也发布了 Visual Studio——这是一个专门为 C#和另一种非常流行的编程语言 Visual Basic 编写的 IDE。

Visual Basic 是 Visual Studio 的前身。在 20 世纪 90 年代，Visual Basic 是微软最广泛使用的开发语言产品。该公司还销售了一个针对 C++开发的 IDE，称为 Visual C++，并短暂而无效地尝试了 Java，推出了 Visual J++。在这些工具包中，Visual Basic 无疑是其中最重要的。当时，Visual C++被“严肃”的开发者使用。由于微软 Windows 是用 C 和 C++编写的，因此 Visual C++的工具首先是为了支持这项工作而设计的。企业级软件真正成为可能并主流化，这要归功于 BASIC 语言。事实上，BASIC 语言构成了微软自身的基石。比尔·盖茨购买了 BASIC 编译器的权利，并与**微软磁盘操作系统**（**MS-DOS**）一起，形成了将成为世界上最大的软件公司之一的实体。

Visual Basic 是由艾伦·库珀设计的。库珀是一位有远见的人。Visual Basic 的用户界面是计算机软件的第一个所见即所得设计平台。在万维网出现之前，我们构建的软件仅能在桌面上运行，而 Visual Basic 是推动行业创新的力量。

但历史就讲到这里。今天，我想介绍三个重要的集成开发环境（IDE）。很可能你已经使用过其中之一。这些工具包括以下内容：

+   Visual Studio

+   VS Code

+   Rider

当然，还有其他 IDE，但这三个是最受欢迎、最完整，坦白说，最重要的。如果你使用 Mac，值得一提的是，Visual Studio for Mac 并不是 Visual Studio 的移植版。之前我提到了 C#的开源版本 Mono。开发 Mono 的团队创建了一个名为*Monodevelop*的 IDE。它看起来很像苹果的 X-Code IDE，并且被设计成允许 Linux 开发者编写 C#程序。"Monodevelop"是开源的，并最终分叉成为*Xamarin Studio*。"Xamarin Studio"是一个面向移动开发的 IDE。几年前，微软收购了 Xamarin。该技术的另一个分支成为了 Visual Studio for Mac。我提到它是因为它与我们将要讨论的 IDE 看起来完全不同，所以如果你使用 Mac，我的截图可能不会很有帮助。

要学习模式，你只需要使用这些 IDE 提供功能的一小部分。在本节中，我想带你了解本书中提到的两种项目类型：命令行项目和库项目。

命令行程序是您可以创建的最简单的程序，实际上可以运行。它们没有用户界面，并且从，您猜对了，命令行中运行。库是用于存放要在项目之间共享的对象的代码项目。在 *第三章* 中，我创建了一个共享库，它被许多其他章节使用，因为它们有很多相同的代码，重复输入相同的类会非常乏味。

让我们首先从 Visual Studio 开始看看这些 IDE。

## Visual Studio

Visual Studio 无需进一步介绍。您可以在 [`www.visualstudio.com`](https://www.visualstudio.com) 获取一份。IDE 有三个版本：

+   Visual Studio Community

+   Visual Studio Professional

+   Visual Studio Enterprise

前两个版本在许可方式上实际上是一样的，只是许可方式不同。社区版在满足许可要求的情况下是免费的。这些事情会随着时间的推移而变化，所以我不想在这里引用那些要求。请查看 Visual Studio 网站，看看您是否符合免费许可证的资格。

Visual Studio Professional 是同一工具的付费版本。如果您为拥有一定数量开发人员或收入达到一定数额的公司工作，您需要购买订阅。

Visual Studio Enterprise 是付费版本中更昂贵的一种，它包含了许多专业版中不存在的额外功能。

任何这些版本都可以与本书一起使用。我将演示社区版，它再次与专业版没有区别。

### 创建命令行项目

下载、安装、注册并启动 IDE 后，您将看到一个类似于 *图 A1.10* 的屏幕。

![图 A1.10：Visual Studio 2022 的启动屏幕。](img/B18605_Figure_A1.7.jpg)

图 A1.10：Visual Studio 2022 的启动屏幕。

点击窗口右下角的 **创建新项目** 按钮。这样做会显示 *图 A1.11*：

![图 A1.11：使用此对话框在 Visual Studio 中创建一个新项目。](img/B18605_Figure_A1.8.jpg)

图 A1.11：使用此对话框在 Visual Studio 中创建一个新项目。

在 C# 中，您正在寻找的是 *控制台应用程序* 项目。如果您完整安装了 Visual Studio，请注意，该工具可能会同时显示 Visual Basic 和 C# 项目。请确保您选择 C# 版本的模板。请注意，模板上的图标表示它们使用的语言，如图 *图 A1.12* 所示：

![图 A1.12：注意项目模板上的图标；很容易不小心在错误的语言中生成新项目。](img/B18605_Figure_A1.9.jpg)

图 A1.12：注意项目模板上的图标；很容易不小心在错误的语言中生成新项目。

如果您没有看到**控制台应用程序**项目模板，可以使用顶部的搜索对话框进行搜索，如图 A.13 所示：

![图 A1.13：如果您没有看到控制台应用程序模板，可以搜索它](img/B18605_Figure_A1.10.jpg)

图 A1.13：如果您没有看到控制台应用程序模板，可以搜索它

点击**控制台应用程序**模板，然后在对话框的右下角点击**下一步**。这将带您到一个标题为**配置您的项目**的对话框，如图 A1.14 所示：

![图 A1.14：通过命名和指定位置来配置您的项目](img/B18605_Figure_A1.11.jpg)

图 A1.14：通过命名和指定位置来配置您的项目

此对话框允许您为项目命名并指定其在硬盘上的位置。您还可以选择将解决方案命名为与项目不同的名称。解决方案是一组项目绑定在一起的一组文件。这允许您以方便的方式处理多个相关项目。也许您有一个属于同一组的 Web 应用程序和相关的命令行程序。解决方案允许您将相关项目存储在一起。如果您将相关项目存储在一起，可能不想将解决方案命名为与项目相同的名称。对于本书中的练习，这并不重要。

我们将项目命名为 `BicycleConsoleApp`。我们将解决方案命名为 `BicycleSolution`。请使用您计算机上方便的位置。底部的复选框指定文件夹结构。您可以保持它未选中。您的项目配置应类似于图 A1.15。点击对话框右下角的**下一步**按钮：

![图 A1.15：附加信息对话框允许您设置项目的框架](img/B18605_Figure_A1.12.jpg)

图 A1.15：附加信息对话框允许您设置项目的框架

**附加信息**对话框允许您选择用于开发的 .NET Framework 类型。在撰写本文时，默认值为**.NET 6.0（长期支持）**。只需接受默认设置并点击**创建**按钮。这将完成项目创建，您将看到完整的 IDE，如图 A1.16 所示：

![图 A1.16：新项目已在 Visual Studio 中创建并准备就绪](img/B18605_Figure_A1.13.jpg)

图 A1.16：新项目已在 Visual Studio 中创建并准备就绪

您的项目已准备就绪！您现在可以开始编写代码了。

### 添加新类

一旦创建项目，您将需要添加新类。要添加类，右键单击 `BicycleConsoleApp` 项目，您将找到一个上下文菜单。找到**添加**选项，将其悬停。第二个菜单展开。在菜单底部找到**类...**并点击它。您可以在图 A1.17 中看到菜单布局：

![图 A1.17：从 Visual Studio 的解决方案资源管理器访问的添加类菜单项。](img/B18605_Figure_A1.14.jpg)

图 A1.17：从 Visual Studio 的解决方案资源管理器访问的添加类菜单项。

下一步是使用 *图 A1.18* 中的对话框指定你想要添加的内容。在这种情况下，我们正在添加一个类。注意，还有一个添加接口的选项。你可能需要两者，但现在，让我们专注于添加类：

![图 A1.18：Visual Studio 中的“添加新项”对话框可以用来添加任何东西，包括类和接口。](img/B18605_Figure_A1.15.jpg)

图 A1.18：Visual Studio 中的“添加新项”对话框可以用来添加任何东西，包括类和接口。

点击 **类**，然后给文件起一个与你要创建的类名相同的名字。通常，我会遵循古老的 Java 习惯，每个文件一个类。点击 **添加** 按钮，类就会被创建并添加到你的项目中。

要添加接口，遵循相同的步骤，但选择 **接口** 而不是 **类**。按照惯例，C# 接口总是以字母 I 开头（如“接口”），因此将你的文件命名为你计划命名的接口名。

### 向解决方案添加库项目

当你创建了命令行应用程序项目时，Visual Studio 也创建了一个解决方案。解决方案是项目的容器。即使你只有一个项目，它也会在解决方案内部。你可以向解决方案中添加更多项目。这是一种方便地将相关项目放在一起的方法。

库项目用于存放可重用的代码，这些代码旨在在项目之间访问。在这本书的 *第 3-5 章* 中，我使用库来存放常见的类，例如那些模拟我们在这些章节中构建的自行车类的基本部分。在现实世界中，你通常将你的业务逻辑放在库中。当你这样做时，你可以在 Web 应用程序、移动应用程序和桌面应用程序中利用该逻辑，而无需在三个地方重复代码。

创建库项目很容易。在解决方案资源管理器中右键单击解决方案。找到 **添加** 选项，将其悬停，然后点击 **新建项目**。会出现一个新的项目对话框，如图 *图 A1.19* 所示：

![图 A1.19：在 Visual Studio 中用于向解决方案添加新项目的上下文菜单。](img/B18605_Figure_A1.16.jpg)

图 A1.19：在 Visual Studio 中用于向解决方案添加新项目的上下文菜单。

在对话框顶部的搜索框中定位到 `Library`。确保类库模板使用的是 C# 语言，而不是其他语言，如 Visual Basic 或 F#。点击 `BicycleLibrary`。位置应默认为解决方案的位置，以及由此扩展的我们刚刚创建的控制台应用程序项目。点击 **下一步** 按钮。

下一个对话框允许你为项目选择.NET 运行时。通常，你希望这些匹配。我们为控制台应用程序选择了.NET 6.0，所以这里也应该选择相同的东西。点击**创建**按钮，Visual Studio 将为你生成项目的文件。

### 将库项目链接到控制台项目

在你能够使用库之前，你必须在该`BicycleConsoleApp`项目中创建对其的引用。要创建引用，右键单击控制台应用程序中的**依赖项**选项，然后点击**添加项目引用**。这将显示一个对话框，如图*A1.20*所示：

![图 A1.20：在 Visual Studio 中向项目中添加项目依赖项所用的菜单。](img/B18605_Figure_A1.17.jpg)

图 A1.20：在 Visual Studio 中向项目中添加项目依赖项所用的菜单。

**项目**选项位于对话框的顶部，可能已经选中。你应该能在列表中看到你的库项目名称。点击你刚刚创建的库项目旁边的复选框，然后点击**确定**。

你的库现在在你的控制台应用程序项目中可用。

### 引用库

当你创建库项目时，Visual Studio 创建了一个名为`Class1.cs`的文件。让我们向该类添加一个方法，然后看看如何在控制台应用程序中引用它。

在类库项目中打开`Class1.cs`文件。添加以下代码：

```cs
namespace BicycleLib;
public class Class1
{
  public string SayHello()
    {
        return "Hello from the Bicycle Library!";
    }
}
```

保存文件。

现在，打开控制台应用程序项目中的`Program.cs`文件。你应该看到一个“Hello World”程序。用以下代码替换起始代码：

```cs
using System;
using BicycleLibrary;
var test = new Class1();
Console.WriteLine(test.SayHello());
```

注意，当你输入代码（输入代码，不要复制粘贴——复制粘贴学不到任何东西！）时，你会发现 IntelliSense 会为你提供关于你在库中添加的方法的提示。实际上，你就像使用控制台应用程序项目的一部分一样使用库中的代码！

剩下的唯一一件事就是：构建项目。

### 构建和运行控制台项目

C#应用程序会被编译。如果你习惯于像 JavaScript 或 Python 这样的解释型语言，你可能不熟悉这一步。C#编译器，代号`foo`（`foo`可以是任何给定的对象），增强型文本编辑器可能会为你提供所有可能的选项。真正优秀的编辑器可能会使用概率或 AI 来缩小范围。Visual Studio 只会根据自省显示可行的选项。最新的 Visual Studio 版本开始包含 AI 功能。当 AI 与 IntelliSense 结合时，结果令人恐惧。你可以期待 Visual Studio 为你编写整个代码块，而不仅仅是样板代码；你的代码中的实际方法。

与编译型语言一起工作的好处之一是更好的代码提示和关于代码错误的早期警告。编译器不允许最常见的错误类型，因此你必须尽早找到并修复它们，因为你必须这样做。编译型语言的产品在执行速度方面通常也更快。

在 Visual Studio 中构建非常简单，有几种方法可以做到。最直接的方法是运行你的程序。要这样做，只需在工具栏中点击绿色箭头。*图 A1.21* 显示了**运行**按钮的位置。不幸的是，*图 A1.21* 没有彩色。书籍编辑的老板们咕哝着关于预算和钱不是从树上长出来的话。我还没有见过 Packt 的老板，但我怀疑他们以前经常和我父亲（愿他在天堂安息）*很多*次一起出去玩。好消息是，你真的在 IDE 中找不到它：

![图 A1.21：在 IDE 中找到绿色三角形；这是运行按钮。](img/B18605_Figure_A1.18.jpg)

图 A1.21：在 IDE 中找到绿色三角形；这是运行按钮。

当你点击**运行**按钮时，你的程序将构建，然后与附加的调试器一起执行。你将看到你的运行程序，如图 *A1.22* 所示：

![图 A1.22：程序在窗口中运行。](img/B18605_Figure_A1.19.jpg)

图 A1.22：程序在窗口中运行。

要停止程序，请在运行的控制台应用程序窗口中按你的电脑的**任意**键：

![图 A1.23：按任意键退出 Visual Studio 的程序运行；如果你的电脑没有像我一样的任意键，你可以使用空格键。](img/B18605_Figure_A1.20.jpg)

图 A1.23：按任意键退出 Visual Studio 的程序运行；如果你的电脑没有像我一样的任意键，你可以使用空格键。

**任意**键在较旧的键盘上很常见。它确实限制了使用字母 *H* 编写代码的能力。由于我住在德克萨斯州，我只用 *J*。为了能够快速退出运行中的程序，这是微不足道的代价。

如果你的电脑没有**任意**键，只需按空格键。请注意，暂停信息不是你程序的一部分，如果你发布应用程序，它将不会出现。这是 Visual Studio 暂停应用程序。控制台应用程序通常在一秒内运行并退出。如果出现问题，程序将完成，显示错误，然后在你有机会看到任何内容之前关闭窗口。因此，Visual Studio 为你做了件好事，在程序退出之前冻结窗口，以便你可以检查它。你的程序应该没有错误地运行。

这就结束了我们对 Visual Studio 的简要游览。如果你对在 Windows 中设置 Visual Studio 开发环境的视频教程感兴趣，你可以在 [`csharppatterns.dev`](https://csharppatterns.dev) 找到相关链接。

## VS Code

VS Code 的名字与 Visual Studio 很相似，但它完全是另一种生物。它不是完整的 IDE，而是一个增强型文本编辑器，而不是真正的 IDE。我们刚刚介绍了微软的黄金标准编辑工具。我为什么要谈论 VS Code 呢？答案是：VS Code 目前拥有超过 50% 的市场份额，成为大多数开发者每天使用的最受欢迎的工具。这有一些很好的理由：

+   VS Code 占用的空间比 Visual Studio 小得多，Visual Studio 所需的总空间接近 45 GB。您可以减小 Visual Studio 的占用空间，但 VS Code 仍然会保持更小的占用空间。

+   VS Code 启动非常快。Visual Studio 则不然。您可以使用 VS Code 快速查看从 GitHub 拉取的存储库或同事共享的某个文件夹。启动 Visual Studio 是一种承诺。如果您使用的是性能较低的计算机，您可能可以在 IDE 的启动屏幕出现之前处理电子邮件、快速浏览社交媒体、喝咖啡，甚至给母亲打电话。顺便说一句，给母亲打电话！她想念您。

+   VS Code 与几乎所有编程语言都兼容。自然，它与 Microsoft 支持的语言以及其他流行的语言（如 Golang 或 Rust）配合得很好。此外，您会发现扩展程序允许您使用它来处理一些奇怪的语言。原始的 GoF 书籍使用了 SmallTalk 编程语言，由两家扩展供应商提供。您还可以找到 Ada、Haskell 以及更多。Visual Studio 主要用于 Microsoft 语言产品的主流工作。

+   VS Code 在所有操作系统上提供一致的用户体验。Visual Studio 是一个仅适用于 Windows 的程序。它无法在 Linux 上运行。Visual Studio Mac 是一个完全不同的程序，外观与 Windows 版本截然不同。这种一致性使得该工具成为学校、大学和像我所在南方卫理公会大学那样的代码训练营的流行选择。

VS Code 有很多优点。像 Visual Studio 一样，VS Code 也可以在 [`www.visualstudio.com`](https://www.visualstudio.com) 下载。

如果 VS Code 将成为您首选的编辑器，那么您需要安装 .NET Core SDK 以提供用于与 C# 一起工作的工具和编译器。

### 安装 .NET Core

如果您打算使用 VS Code，则需要安装 .NET Core SDK 以获得用于与 C# 一起工作的工具和编译器。您可以从 [`dotnet.microsoft.com/en-us/download`](https://dotnet.microsoft.com/en-us/download) 下载它。当然，这本书出版后，该网址可能会发生变化，在这种情况下，您将需要变得机智。安装它很简单。

在安装了 VS Code 和 .NET Core SDK 之后，您就可以开始使用了。如果您阅读了在 Visual Studio 中设置项目的步骤，VS Code 的步骤则非常不同。

### 创建新的解决方案

Visual Studio 一步即可创建项目和解决方案。这是 VS Code。每个步骤都是单独执行的，并且所有操作都通过命令行完成。从技术上讲，VS Code 并未真正参与其中。您使用的是在安装 .NET Core SDK 时安装的 `dotnet` 命令行工具。您可以在 Windows Terminal 中完成所有这些操作。

由于 Windows Terminal 随 Windows 11 一起提供，因此无需安装任何其他软件。如果您从未使用过它，请点击如图 A1.24 所示的 `Terminal`。启动应用程序。如果您仍在使用 Windows 10，请搜索 `PowerShell` 而不是 `Terminal`：

![图 A1.24：使用 VS Code 进行的大多数项目设置工作都在终端窗口中完成。](img/B18605_Figure_A1.21.jpg)

图 A1.24：使用 VS Code 进行的大多数项目设置工作都在终端窗口中完成。

在打开终端（或 PowerShell）的情况下，输入此命令：

```cs
dotnet new sln -o BicycleSolution
```

这里，`-o` 是用于 *输出* 的。这告诉命令为解决方案创建一个文件夹。除了创建文件夹外，该命令在 `BicycleSolution` 文件夹中生成一组文件。让我们看看。输入以下内容：

```cs
cd BicyleSolution
```

然后，输入以下内容：

```cs
dir
```

`dir`（目录）命令将列出当前工作目录中的所有文件。您应该会看到类似于 *图 A1.25* 的内容：

![图 A1.25：我们新解决方案命令的结果](img/B18605_Figure_A1.22.jpg)

图 A1.25：我们新解决方案命令的结果。

我们有一个解决方案，但里面什么都没有。我们需要一些项目来使解决方案变得有用。

### 创建命令行项目

接下来，我们将向当前解决方案文件夹添加一个控制台应用程序。首先，使用 `cd` 命令进入 `BicycleSolution` 文件夹。从现在开始，我给出的命令基于这样一个假设，即您的当前工作目录是 `BicycleSolution` 文件夹。

要将控制台应用程序添加到解决方案中，请在终端窗口中输入以下命令：

```cs
dotnet new console -o BicycleConsoleApp
```

这将创建一个新的控制台应用程序。同样，`-o` 是用于输出的。这告诉命令将项目命名为什么。`dotnet` 命令为控制台应用程序项目生成样板文件，如图 A1.27 所示：

![图 A1.27：我们的命令为您生成了命令行项目的文件结构。](img/B18605_Figure_A1.23.jpg)

图 A1.27：我们的命令为您生成了命令行项目的文件结构。

一旦创建了应用程序，您需要使用此命令将其添加到您的解决方案中：

```cs
dotnet sln add BicycleConsoleApp/BicycleConsoleApp.csproj
```

命令的结果可以在 *图 A1.28* 中看到：

![图 A1.28：控制台应用程序已成功添加到解决方案。](img/B18605_Figure_A1.24.jpg)

图 A1.28：控制台应用程序已成功添加到解决方案中。

文件夹结构不会有明显的变化。该命令修改了 `BicycleSolution.sln` 文件以包含 `BicycleConsoleApp` 项目。您的命令行项目已准备好使用。

### 创建库项目

库项目用于存放可重用的代码，这些代码旨在在项目之间访问。在本书的第 3-5 章*中，我使用库来存储常见的类，例如那些模拟我们在这些章节中构建的自行车类的基本部分的类。在现实世界中，您通常将业务逻辑放在库中。当您这样做时，您可以在 Web 应用程序、移动应用程序和桌面应用程序中利用该逻辑，而无需在三个地方重复代码。

要在解决方案文件夹中创建一个库项目，请在您的终端窗口中输入以下命令：

```cs
dotnet new classlib -o BicycleLibrary
```

如前所述，该命令在当前解决方案中创建一个新的项目。`-o`开关告诉命令输出什么名称，在这种情况下，是库项目的名称。创建了库项目后，你需要使用以下命令将项目添加到你的解决方案中：

```cs
dotnet sln add BicycleLibrary/BicycleLibrary.csproj
```

使用`dir`命令确认你的文件夹结构看起来像图 A1.29 中的我的结构：

![图 A1.29：创建了解决方案、控制台应用程序和库项目后的项目结构。](img/B18605_Figure_A1.25.jpg)

图 A1.29：创建了解决方案、控制台应用程序和库项目后的项目结构。

现在你有了库项目，你需要设置控制台应用程序和库项目之间的引用。

### 将库链接到控制台项目

要将控制台项目链接到库项目，请输入以下命令：

```cs
dotnet add BicycleConsoleApp/BicycleConsoleApp.csproj reference BicycleLibrary/BicycleLibrary.csproj
```

库已链接到控制台应用程序项目。我们在终端窗口中花费了很多时间。现在是时候开始在 VS Code 中工作了。

### 启动 VS Code 并添加 C# 扩展

在 VS Code 中添加类或接口很容易。你可以通过在终端窗口中输入以下内容来启动 VS Code，我们一直在使用这个窗口：

```cs
code .
```

你读得对：输入`code`，然后输入一个空格和一个句号，然后按*Enter*。这个命令会启动 VS Code 并加载解决方案文件夹。你会看到你通常的安全警告，如图 A1.30 所示：

![图 A1.30：你信任你刚刚创建的文件吗？](img/B18605_Figure_A1.26.jpg)

图 A1.30：你信任你刚刚创建的文件吗？

假设你信任自己的工作，点击**是**。如果你不信任，请简要关闭这本书，深入思考。考虑你是否宁愿生活在一个美丽而无聊的安全世界，那里永远不会对你造成伤害；一个充满美丽花朵的世界，它们的香气只会让你想起生活中最好的时刻。或者你更愿意生活在一个充满高风险和彻底毁灭可能性的世界？海盗船在港口里是安全的藏身之处。但它们不是用来在那里停留的！这是你的时刻！去做吧！点击**是的，我信任作者**按钮！我保证，如果你这样做，你将在生活中转一个弯。已经长出脊椎了，点击按钮吧！顺便说一句：我的律师希望我提醒你，作者不对恶意软件、计算机损坏、声誉损害或点击此按钮导致的海盗袭击负责。

解决了个人问题（如果你有的话）后，让我们继续。

我提到过，VS Code 并不被视为一个完整的 IDE。它是一个通用编码工具，不假设你将如何使用它。因此，VS Code 并没有内置 C# 支持。自然地，Microsoft 有一个插件可以帮助你处理 C#。项目打开时，你可能会被提示安装此插件。如果你没有，你可以按照图 A1.30 中显示的步骤进行安装：

![图 A1.30：Microsoft 为 VS Code 提供了一个免费的扩展，使使用 C#更加愉快。](img/B18605_Figure_A1.27.jpg)

图 A1.30：Microsoft 为 VS Code 提供了一个免费的扩展，使使用 C#更加愉快。

首先，单击界面左侧菜单上的**扩展**按钮（1）。然后，在搜索栏中搜索此扩展（2）：

```cs
@id:ms-dotnettools.csharp
```

这将使列表缩小到单个扩展。单击它，然后单击安装按钮。现在 VS Code 完全了解 C#语言和你的项目结构。

### 添加类或接口

在资源管理器视图中右键单击`BicycleConsoleApp`文件夹，然后单击**新建文件**，如*图 A1.31*所示：

![图 A1.31：在资源管理器区域右键单击，然后单击“新建文件”以创建新文件。](img/B18605_Figure_A1.28.jpg)

图 A1.31：在资源管理器区域右键单击，然后单击“新建文件”以创建新文件。

一旦你点击了`.cs`扩展。例如，我把我文件命名为`Class1.cs`。如果你正在创建一个接口，通常的做法是将文件名以大写 I 开头（例如，“Interface”）。

### 向 BicycleLibrary 项目添加代码

让我们在`BicycleLibrary`项目中添加一个方法，以便我们可以验证它是否已链接并正确工作。

在`BicycleLibrary`项目中找到`Class1.cs`文件。当你创建项目时，该文件为你生成。单击文件，它将在编辑器中打开。添加以下代码：

```cs
namespace BicycleLibrary;
public class Class1
{
  public string SayHello()
    {
        return "Hello from the Bicycle Library!";
    }
}
```

一定要保存文件！将你的项目与我的项目进行比较，如*图 A1.32*所示：

![图 S1.32：库代码已添加到 BicycleLibrary 项目中的 Class1.cs 文件。](img/B18605_Figure_A1.29.jpg)

图 S1.32：库代码已添加到 BicycleLibrary 项目中的 Class1.cs 文件。

接下来，让我们切换到`BicycleConsoleApp`项目中的`Program.cs`文件。替换掉由`dotnet`生成的行，使用以下内容：

```cs
using System;
using BicycleLibrary;
var test = new Class1();
Console.WriteLine(test.SayHello());
```

当你输入时，IntelliSense 会显示我们添加到`BicycleLibrary`项目的库方法，就像它在`BicycleConsoleApp`项目中一样。将你的工作与*图 A1.33*进行核对：

![图 A1.33：带有我们的测试代码的更新后的 Program.cs 文件。](img/B18605_Figure_A1.30.jpg)

图 A1.33：带有我们的测试代码的更新后的 Program.cs 文件。

我们的使命已经完成！只剩下一件事要做：构建项目。

### 构建和运行控制台项目

我们可以切换回我们的终端窗口，但 VS Code 有一个集成的终端窗口。使用它比不断切换窗口更方便。

要激活它，使用键盘快捷键*Ctrl* + *`*（控制+反引号）。此外，你可以从主菜单中选择**视图**然后**终端**，如*图 A1.34*所示：

![图 A1.34：您可以使用此菜单项或 Ctrl + `作为键盘快捷键在 VS Code 中打开集成的终端窗口。](img/B18605_Figure_A1.31.jpg)

图 A1.34：您可以使用此菜单项在 VS Code 中打开集成终端窗口，或者使用 Ctrl + `作为键盘快捷键。

运行项目将会构建项目，然后执行`BicycleConsoleApp`项目的可执行文件，该文件由`Program.cs`文件中的代码组成。要在终端窗口中运行程序，请输入以下命令：

```cs
dotnet run –-project .\BicycleConsoleApp\BicycleConsoleApp.csproj
```

您将看到程序正在构建，命令行项目将会运行。您应该在终端窗口中看到“来自自行车库的问候！”消息，就像您在*图 A1.35*中看到的那样：

![图 A1.35：这是我们测试运行的结果。](img/B18605_Figure_A1.32.jpg)

图 A1.35：这是我们测试运行的结果。

这就结束了我们对 VS Code 的简要游览。如果您对在 Windows 中设置 VS Code 开发环境感兴趣，并希望有一个视频教程来指导您，您可以在[`csharppatterns.dev`](https://csharppatterns.dev)找到相关链接。

## Rider

JetBrains Rider 是 C# IDE 世界中的最新成员。JetBrains 以其为 Java（*IntelliJ Idea*）、Python（*Pycharm*）、PHP（*PHPStorm*）和 JavaScript（*WebStorm*）等语言制作出色的 IDE 而闻名。他们还构建了谷歌的 Android 开发 IDE，*Android Studio*。除了 IDE 之外，该公司还拥有一个非常受欢迎的 Visual Studio 插件产品，名为*Resharper*。*Resharper*中的工具为您提供了许多在*Visual Studio Enterprise*中找到的类似功能，但成本却低得多。

我使用 Rider 创建这本书，主要是因为程序中提供的代码格式化和重构工具。此外，我经常使用他们的一些其他 IDE，并且我已经将键盘快捷键配置为在每种语言 IDE 中都是通用的。这纯粹是个人偏好。我知道我可以使用 Rider 更快地完成这本书。

Rider 不是一个免费产品。对于独立开发者有一个较低成本的版本，而在公司使用时，同样的产品会以更高的价格出售。如果您对使用这个工具感兴趣，请查看[`www.jetbrains.com/rider`](https://www.jetbrains.com/rider)获取更多信息。

由于我使用 Rider 创建了这本书，如果我不至少带您参观一下，那就显得有些奇怪了。让我们再次使用 Rider 来做这个练习。

### 创建命令行项目

当您启动 Rider 时，您将看到一个**欢迎**屏幕对话框。在对话框右上角单击**新项目**按钮，如图*图 A1.36*所示：

![图 A1.36：Rider 中的欢迎屏幕，新项目按钮被突出显示。](img/B18605_Figure_A1.33.jpg)

图 A1.36：Rider 中的欢迎屏幕，新项目按钮被突出显示。

单击按钮会弹出一个新的对话框，如图*图 A1.37*所示：

![图 A1.37：Rider 中的项目创建。](img/B18605_Figure_A1.34.jpg)

图 A1.37：Rider 中的项目创建。

使用 Rider，所有内容都在一个屏幕上。找到 `BicycleSolution` 和 `ProjectName` 为 `BicycleConsoleApp`。点击**创建**按钮，您的项目将被生成。完整的 IDE 将会显示，您将在 IDE 窗口的左侧的探索器面板中找到您的项目层次结构。

### 添加类或接口

添加类与我们在前面提到的其他两个 IDE 中的操作相同。右键单击 `BicycleSolution` 项目。出现一个上下文菜单，如图 A1.38 所示：

![图 A1.38：将类或接口添加到项目中的功能可以在您右键单击项目时在上下文菜单中找到。](img/B18605_Figure_A1.35.jpg)

图 A1.38：将类或接口添加到项目中的功能可以在您右键单击项目时在上下文菜单中找到。

将鼠标悬停在**添加**菜单项上，然后在子菜单中找到**类/接口**。点击它。您将看到一个小的对话框，要求您命名类或接口。列表中还有一些其他可能性，但本书只关注类和接口。选择**类**选项，并为您想要的类命名。一旦按下*Enter*，您将看到类文件已添加到您的项目中。

当您需要一个接口时，遵循相同的程序，但不要选择**类**，而是选择**接口**。不要忘记，在 C# 中，接口的命名约定规定以字母 I（如“Interface”）开头命名接口。

接下来，我们将查看如何将库项目添加到我们的解决方案中，以便在项目之间最大化代码重用。

### 创建库项目

库项目用于存放可重用的代码，这些代码旨在在项目之间可访问。在本书的第 3-5 章，我使用库来存放常见的类，例如那些模拟我们在这些章节中构建的自行车基本部分的类。在现实世界中，您通常将业务逻辑放在库中。当您这样做时，您可以在 Web 应用程序、移动应用程序和桌面应用程序中利用该逻辑，而无需在三个地方重复代码。

在探索器菜单中右键单击 `BicycleSolution`。将鼠标悬停在**添加**选项上，并选择**新建项目...**。您可以在图 A1.39 中看到这一点：

![图 A1.39：在 Rider 中将项目添加到解决方案的操作是通过右键单击解决方案，然后悬停在**添加**上，然后点击**新建项目**。](img/B18605_Figure_A1.36.jpg)

图 A1.39：在 Rider 中将项目添加到解决方案的操作是通过右键单击解决方案，然后悬停在**添加**上，然后点击**新建项目**。

您将得到我们最初开始的相同项目对话框。定位到 `BicycleLibrary`。您的项目应该与我的项目一致，如图 A1.40 所示：

![图 A1.40：按照所示设置您的新的库项目](img/B18605_Figure_A1.37.jpg)

图 A1.40：按照所示设置您的新的库项目。

点击**创建**按钮，你会在解决方案中找到一个新项目。你的资源管理器窗格应该看起来像*图 A1.41*：

![图 A1.41：资源管理器窗格显示了解决方案中的两个项目。](img/B18605_Figure_A1.38.jpg)

图 A1.41：资源管理器窗格显示了解决方案中的两个项目。

在我们能够在控制台应用程序项目中使用库之前，我们需要通过引用将两个项目链接起来。

### 将库项目链接到控制台项目

在资源管理器窗格中，定位到`BicycleConsoleApp`项目，并在项目层次结构中右键单击`Dependencies`项。会出现一个上下文菜单，如图 A1.42 所示：

![图 A1.42：在资源管理器窗格中右键单击依赖项时显示上下文菜单。](img/B18605_Figure_A1.39.jpg)

图 A1.42：在资源管理器窗格中右键单击依赖项时显示上下文菜单。

点击**添加引用**。会出现一个对话框，如图 A1.43 所示：

![图 A1.43：Rider 中的添加引用对话框。](img/B18605_Figure_A1.40.jpg)

图 A1.43：Rider 中的添加引用对话框。

你应该看到库项目被列出。勾选库旁边的复选框，然后点击**添加**。你现在可以从控制台应用程序项目中引用库项目。让我们试试看。

### 测试链接库

在`BicycleLibrary`项目中打开`Class1.cs`文件。添加以下代码：

```cs
namespace BicycleLibrary;
public class Class1
{
  public string SayHello()
    {
        return "Hello from the Bicycle Library!";
    }
}
```

这是我第三次输入相同的代码。谢天谢地，英语语言不需要作者遵循 DRY 原则。

接下来，在`BicycleConsoleApp`项目中打开`Program1.cs`文件。将该文件中的代码更改为以下内容：

```cs
using System;
using BicycleLibrary;
var test = new Class1();
Console.WriteLine(test.SayHello());
```

当你输入代码时，你应该会看到代码提示显示你能够访问该库。一旦输入了代码，我们就准备好运行测试。

### 构建和运行控制台项目

与 Visual Studio 一样，你正在寻找一个表示工具栏中**运行**按钮的大绿箭头。你可以在*图 A1.44*中看到这个按钮被突出显示，遗憾的是，不是以颜色显示。

当你点击**运行**按钮时，你的项目会像在 Visual Studio 中一样构建并运行，并附加调试器。与 Visual Studio 不同，你的程序在 Rider 的集成终端中运行，就像在 VS Code 中一样。你可以在*图 A1.44*中看到我运行的结果：

![图 A1.44：在 Rider 中完成测试程序的运行；已指出终端窗口。](img/B18605_Figure_A1.41.jpg)

图 A1.44：在 Rider 中完成测试程序的运行；已指出终端窗口。

这就结束了我们对*Rider*的简要游览。如果你对在 Windows 中设置*Rider*开发环境的视频教程感兴趣，你可以在[`csharppatterns.dev`](https://csharppatterns.dev)找到链接。

# 摘要

这个附录原本打算是一个关于使用 C#的简要总结。我几乎没把它包括在书中。你可以在很多其他地方获得关于该语言的培训和指导。然而，鉴于我几十年来一直在教授 C#，我觉得如果是从其他语言转过来的，或者对 C#的经验有限，或者有一段时间没有接触了，我可能能够更简洁、更全面地帮助你入门。

在这个过程中，我们学习了以下内容：

+   C#是一种标准化的通用、严格面向对象的语言。

+   C#使用强、静态类型系统。

+   C#的设计旨在通过一些特性来限制在 C 和 C++开发中最常见的错误，例如边界检查、轻松的内存分配和自动垃圾回收。

+   C#支持许多不同的数值类型，包括有符号和无符号变体。

+   如何创建自动实现的属性和方法，以及如何处理封装。

+   如何在 C#中使用面向对象的基石，包括继承和与接口一起工作。

在所有这些之后，我们得到了一个关于 C#最流行的三个 IDE 选择的基本教程：Visual Studio、VS Code 和 Rider。我称这个附录为简洁。我不会说它很短，但考虑到大多数只介绍 Visual Studio 的 C#书籍的大小，我认为这是一个物有所值的交易。如果你还想了解更多，请访问[`csharppatterns.dev`](https://csharppatterns.dev)，那里我提供了额外的资源链接。

# 进一步阅读

+   *《C#面向对象编程入门：C#和.NET》*，作者 Praveenkumar Bouna。

+   *《C#开发者用 Visual Studio Code》*，作者 Praveenkumar Bouna。

+   *《动手实践 Visual Studio 2022》*，作者 Hector Uriel Perez Rojas 和 Miguel Angel Teheran Garcia。

+   [`csharppatterns.dev`](https://csharppatterns.dev) 提供了额外的资源链接。

# 附录 2：统一建模语言（UML）入门

你不需要仔细思考就能意识到，设计软件与设计其他事物有很多相似之处。在*第一章*《你的意大利面盘上有一个大泥球》中，我们讨论了来自建筑领域先驱的软件模式的底层，不是软件架构，而是涉及建筑和城市架构的传统、工程和设计实践。1977 年，Christopher Alexander 记录了一种旨在形成城镇最佳实践基础的模式语言。他的书描述了 253 个模式，这些模式被视为建筑设计的典范。这本书把所有东西都分解成了对象。

**面向对象分析设计**（**OOAD**），作为一种与 **面向对象编程**（**OOP**）相关的实践，涉及独立于编写代码的练习来设计对象结构。这通常是由软件架构师或高级开发者负责的工作。软件架构师类似于建筑的建筑师：他们设计应用程序的结构。这可以在实施团队选择项目编程语言之前完成，实施团队是负责构建建筑师设计的内容的团队。

OOAD 利用一组编码为 **统一建模语言**（**UML**）的文档规范。它听起来像是一种编程语言，但它不是。相反，它是一个创建图例的标准，用于解释软件系统中组件的结构和关系。

这样想。如果你是一个音乐作曲家，你可以在乐谱上写下你的音符。你可以在不接触任何乐器的情况下做到这一点。如果你在作曲方面很在行，你可以在纸上使用乐谱符号创作完整的管弦乐作品。然后你可以把乐谱交给一个乐团和指挥，假设乐团由合格的乐手组成，他们应该能够演奏你的音乐。建筑师就像作曲家一样。程序员就像音乐家，而团队领导或主要开发者就像指挥。

在整本书中，UML 类图被用来传达将要在我们现实世界项目中实现的设计模式代码的结构。如果你之前从未使用过 UML，你可能需要一个简短的入门指南。本附录旨在成为那个指南。它不能替代研究生级别的 OOAD 课程，甚至也不能替代阅读一本关于 UML 的整本书。我只会涵盖我们全书所使用的图例规范，以便你能够理解这些图例，以及它们是如何转换为代码的。

再次强调，UML 不是一个编程语言；它是一个用于绘制代码规范的规范。UML 2.5 规范中有 14 种类型的图。我们只需要一种；在所有不同的图例中，最常见的是 *类图*。

# 技术要求

有很多工具可以绘制 UML 图，尽管我已经展示了众多这样的图，但我对制作它们的工具却视而不见。在现实世界中，这种练习通常是在白板上进行的。白板适合那些后来会被擦除的临时绘图。对于这本书，我的图例需要更加持久，所以我使用的是：

+   运行 **Windows** 操作系统的计算机。我使用的是 **Windows 10**。说实话，这并不重要，因为所有操作系统中都有大量的绘图工具，而且有很多可以在你的浏览器中工作。

+   一个绘图工具。我使用的是 **Microsoft Visio**。

市场上有很多 UML 工具。以下是我多年来使用过的一些工具的简要列表：

+   **Microsoft Visio**

+   **StarUML**

+   **Altova UModel**

+   **Dia**

+   **Umbrello**

+   **Umlet**

+   **Omnigraffle**（仅限 **Mac**）

网上还有很多。我倾向于使用运行在我电脑上的应用程序，而不是基于浏览器的解决方案。

# 类图的构成

类图由几种类型的结构和一组表示结构之间关系的连接线组成。结构如下：

+   一个类（显然）

+   接口

+   枚举

+   包（展开和折叠）

结构之间的连接线显示了这些结构是如何相关的。我们可以表达的关系包括以下内容：

+   继承

+   接口实现

+   组合

+   关联

+   依赖

+   聚合

+   有向关联

UML 图上最后可能出现的元素是注释。注释就是你所想的那样。有时，架构师需要添加比标准 UML 允许的更多一点的信息。注释让你可以做到这一点。你不应该用它们来写一封信。在实现逻辑中，最常见的短注释。

要理解这本书中的模式，你需要理解类图。这本书中的每个模式至少用到一个 UML 图表达。最重要的模式每个都有两个图覆盖。

让我们看看 UML 图的各个部分。一旦你意识到所有图块的含义，它们就不难理解。让我们从结构开始。

## 类

类图是对象类的视觉表示。假设我们的程序需要我们像 *图 A2.1* 中的那样建模一个圆：

![图 A2.1：这不是一个圆的 UML 图。](img/B18605_Figure_A2.01.jpg)

图 A2.1：这不是一个圆的 UML 图。

如果我们想在 UML 中建模这个，类图将看起来像 *图 A2.2*。

![图 A2.2：这是一个 UML 图的例子。类名 Circle 在顶部，后面跟着属性列表、分隔线和方法列表。+ 表示它们都是公共的。](img/B18605_Figure_A2.02.jpg)

图 A2.2：这是一个 UML 图的例子。类名 Circle 在顶部，后面跟着属性列表、分隔线和方法列表。+ 表示它们都是公共的。

那不是太难，对吧？它是一个分成三个部分的框。

顶部部分包含类的名称。类只是我在 UML 图中放入的编码版本。理解这些细节对于 *第三章* 中关于“用创造模式发挥创意”的覆盖至关重要。这些模式围绕着对象创建。

*图 A2.2* 中间的框包含了这个类成员的属性列表。注意它们没有类型。有些人会在图中添加类型。我被告知不要这样做，因为这只是一个实现细节。建筑师只是设计；他们不会比必要的更多地去约束建造者。实现这个图画的程序员选择类型。如果你既是建筑师又是开发者，如果你觉得这样有帮助，可以自由地指定类型。

在属性列表下方，我们画一条线来区分属性部分和下一部分。Visio 在我的绘图中使用的是虚线。虚线没有意义。它可以是一条实线或任何你喜欢的线条样式。

*图 A2.2* 底部的框是一个方法列表。它不包括实现方法的细节或它们的功能——只是名称和任何参数。

你可能已经注意到图中有一些 `+` 符号。这些指的是你的访问修饰符。与类型一样，有些建筑师会添加它们，而有些则不会。其他人会在至关重要的地方添加它们——当类如果不尊重这个细节就无法工作时。我屈服于诱惑，制作了一个可爱的图来展示访问修饰符在*图 A2.3* 中的样子。

![图 A2.3：访问修饰符。](img/B18605_Figure_A2.03.jpg)

图 A2.3：访问修饰符。

加号（`内部`，但它们是 C#特有的，所以 UML 不会有它们的符号。如果你不理解这些访问修饰符，请参阅*附录 1*）。

就这些！UML 类图在本质上非常简单。我们还没有完成。UML 图可以显示不同级别的细节。这完全取决于你的偏好和你的图目的受众。当我研究生阶段的 OOAD（面向对象分析与设计）时，我的教授希望我在图中尽可能少地包含实现细节。这个习惯一直伴随着我。我看到其他人把所有细节都绘制到最小。我从未是那种微观管理的人，所以我打算尽可能地把事情留给开发者。

### 抽象类

抽象类是我们不允许直接实例化的类。你只能实例化抽象类的子类。绘制它们需要对图进行微小的修改。*图 A2.4* 中有一个例子。

![图 A2.4：当绘制抽象类时，用斜体字写出类的名称。](img/B18605_Figure_A2.04.jpg)

图 A2.4：当绘制抽象类时，用斜体字写出类的名称。

在这里，我们可以看到`Shape`类是抽象的，而`Circle`类不是。要指定一个类为抽象类，你需要在顶部的框中用斜体字写出类的名称。注意这一点！有时，这可能会很难看到，特别是如果你的绘图工具使用了一种可爱的字体，使得斜体难以辨认。

### 绘制所需类型

有时候，你绝对必须定义属性类型、方法参数或返回类型，因为实现确实需要它。在这些情况下，你可以在图中指定类型，就像我在 *图 A2.5* 中所做的那样。

![图 A2.5：你可以使用冒号后跟类型来指定特定类型。](img/B18605_Figure_A2.05.jpg)

图 A2.5：你可以使用冒号后跟类型来指定特定类型。

`Image` 类在这里有一个属性，它绝对必须是 `Shape` 类型。它用冒号分隔属性名称和其类型来表示。同样，我可以为方法指定返回类型。`Image` 类有一个名为 `GetCircle()` 的方法，它必须返回 `Circle`。它也用冒号和位于方法签名之后类型来类似地指定。

### 构造函数

构造函数是一个在对象实例化时被调用的特殊方法。*附录 1* 详细介绍了这一点，如果你不确定我的意思的话。构造函数必须与定义它的类的名称相同。对于很多人来说，仅仅看到与类名相同的名称就足够了。它也可以更正式地绘制，如图 *图 A2.6* 所示。

![图 A2.6：UML 图中的构造函数难以错过](img/B18605_Figure_A2.06.jpg)

图 A2.6：UML 图中的构造函数难以错过。

你不可能错过它。它是前面带有令人讨厌的 `<<constructor>>` 的方法。由于令人讨厌的东西非常有教育意义，这就是我将使用的约定。

### 不要绘制每个微小的细节

在网页设计的世界里，设计师在与客户打交道时使用了一个已经存在了几个世纪的技巧。在处理初步设计时，目标是确保布局正确，不要专注于文案。当你试图在网页设计中放入虚假文案时，问题就出现了。客户会关注文案的内容，他们会试图润色页面上的文字。目标是获得对设计的认可，但这是不可能的，因为所有利益相关者都陷入了占位文本的内容。

为了解决这个问题，设计师使用 *lorem ipsum* 文本。*lorem ipsum* 是归功于罗马政治家和诗人马尔库斯·图利乌斯·西塞罗的一本著名伦理学书籍中的单词。文本看起来像这样：

“Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum。”

这段文本被放置在设计草案中，作为实际副本的占位符。由于文本难以理解，任何查看带有此文本的设计的人都不会被诱惑去评论内容。他们专注于设计。

在 UML 中，当你想要这样做时，你可以使用空或几乎空的类来鼓励利益相关者，即开发者，专注于模式设计而不是你命名的属性。

我在这本书中做了很多这样的事情。项目不是真实的，代码在作为教学工具之外并不重要。我们在这里是为了学习模式。你可以期待看到很多像*图 A2.7*这样的图表。

![图 A2.7：在设计模式时，看到没有填写所有细节的类是正常的。重点是设计和评论结构，而不是内容。](img/B18605_Figure_A2.07.jpg)

图 A2.7：在设计模式时，看到没有填写所有细节的类是正常的。重点是设计和评论结构，而不是内容。

在`Person`和`Teacher`类中，我使用了占位符。在`Student`类中，我没有指定任何内容。这两种表示法都是有效的。当你确定了结构，你可以选择填写缺失的属性、方法和关系，或者将它们留给开发者作为实现细节。

如果你选择前者，要小心。当你刚开始习惯使用 UML 时，很容易将其用作指定细节的工具。抵制这种诱惑。如果不这样做，你的图表会变得如此复杂，以至于失去了意义。

## 接口

接口对于面向对象分析和模式绘图非常重要。绘制它们与绘制类没有太大区别。它们看起来一样，只是在图表标题框中表达了一个令人讨厌的`<<Interface>>`。

![图 A2.7：UML 中的一个接口。](img/B18605_Figure_A2.08.jpg)

图 A2.7：UML 中的一个接口。

一些语言只允许你在接口中实现方法。C#中的接口可以指定除了通常的公共方法之外的公共属性，因此可以在接口上定义属性是合法的。再次强调：接口中方法的所有属性都必须是公共的。你只会看到`+`符号作为访问修饰符。

## 枚举

枚举指的是一组很少改变的有限值。例如，美国各州名单 70 年来没有变化。一周中的日子在数千年来也没有变化。这些都是枚举的好候选者。让我们看看一个快速示例：

```cs
public enum DaysOfWeek { Mon, Tue, Wed, Thur, Fri, Sat, Sun };
```

它们可以用作类型，其效果是防止虚假数据被传递到属性或变量中：

```cs
var dayOff = DaysOfWeek.Wednesday;
```

这比仅仅将其作为字符串要好：

```cs
var dayOff = "Wednesday";
```

我将变量设置为“`Wednesday"`”，但正如我的`enum`显示的那样，我的程序期望一个非常具体的值。字符串“`Wednesday`”是不正确的。只要是一个字符串，我就可以轻松地设置任何值。如果我的类需要一个星期中的某一天，并且我使用枚举作为类型，那么就不可能传入*Bruceday*作为星期中的某一天。*Bruceday*只出现在我的家里，那里每一天都是美丽、美丽的*Bruceday*。我已经尝试了多年将其标准化为国际上公认的休息日。我想这应该是肯定的，当国家超级巨星 Alan Jackson 录制了“`It’s Bruceday Somewhere.`”这首歌时。但在最后一刻，他将其标题改为“`It’s Five O’Clock Somewhere.`”。我认为这是一个错误。显然，你必须是一个北欧或希腊神，一个主序星，或者一个行星体，你才会被认真对待。

列表，就像接口一样，在标题框中添加了一个令人讨厌的符号，如*图 A2.8*所示。

![图 A2.8：UML 中的枚举。](img/B18605_Figure_A2.09.jpg)

图 A2.8：UML 中的枚举。

当你绘制一个枚举时，属性代表枚举中包含的值。枚举没有方法，所以图的下部不会有任何内容。也没有访问修饰符。只显示内容。

## 包

包是前面结构的集合。在 C#中，你会称它为命名空间。有两种方式来绘制包：展开和折叠。展开的包会用一个矩形框住属于该命名空间的类和结构。它们用来显示包的内容。

折叠的包不显示内容。它们只是命名空间的表示。你可以在*图 A2.9*中看到展开和折叠包的示例。

![图 A2.9：UML 中的展开和折叠包。](img/B18605_Figure_A2.10.jpg)

图 A2.9：UML 中的展开和折叠包。

我在书中只使用了一次展开的包来表示对第三方库的依赖。

# 连接器

在商业中，成功的一个重要因素是与你共事的人之间的关系。对于类、接口、枚举和包的系统来说，也是如此。除了类图中的结构外，图也许更重要的是表达结构之间的关系，使用一套标准化的线条和符号。这些线条将结构连接在一起。让我们看看 UML 类图中表达的关系。

## 继承

两个类之间的继承用一端带有开放三角箭头的实线表示。例如，如果我有一个名为`Person`的类，另一个名为`Student`的类继承自`Person`，则图表将看起来像*图 A2.10*。

![图 A2.10：继承用实线和一个指向基类的空三角箭头表示。](img/B18605_Figure_A2.11.jpg)

图 A2.10：继承用带有空心三角形箭头指向基类的实线表示。

箭头应指向继承类到基类的方向。你表达的是学生 **IS A** 人的关系。作为一个最佳实践，基类总是绘制在子类之上，因此箭头应始终向上。

## 接口实现

如果您不确定这些是什么，我们已在 *附录 1* 中讨论了接口。接口是传递依赖关系最灵活的方式，而不会将两个对象紧密耦合在一起。这使得它们对我们研究模式非常重要。

当一个类实现一个接口时，你从实现接口的类到接口本身画一条虚线。线的末端有一个空心箭头指向接口，如 *图 A2.11* 所示。

![图 A2.11：接口实现线是虚线，有一个空心箭头从实现类指向接口。](img/B18605_Figure_A2.12.jpg)

图 A2.11：接口实现线是虚线，有一个空心箭头从实现类指向接口。

## 组合

组合指的是由其他对象创建一个对象。你通过说 **HAS A** 来表达一个关系。要创建一个 `car` 对象，你可能需要一个 `engine` 对象和一个车标对象。你会说一辆车 *有一个* 车标，你就是在表达组合。参见 *图 A.12* 了解组合的示例。

![图 A2.12：UML 中的组合使用实线表示，包含类的末端有一个菱形。](img/B18605_Figure_A2.13.jpg)

图 A2.12：UML 中使用实线表示组合，包含类的末端有一个菱形。

在 UML 中，组合用实线在类之间绘制，一端有一个实心菱形。菱形应指向放入其中的类。在我们的 `Car` 类中。

## 关联

两个类之间的关联表示它们相互交互。一个 `driver` 对象与一个 `car` 对象交互。司机往车里加油。汽车将司机带到另一个地方。要在 UML 中绘制关联，你使用没有箭头的实线，如 *图 A2.13* 所示。

![图 A2.13：关联显示了相互交互的对象。](img/B18605_Figure_A2.14.jpg)

图 A2.13：关联显示了相互交互的对象。

## 聚合

聚合是一种涉及多重性的关联类型。一个 `warehouse` 对象将与库存项目有“一个订单有许多库存项目”的关系。不要将其与组合混淆。它不仅看起来像同一件事，而且符号也几乎相同。聚合在实线上表现为一个空心的菱形，如 *图 A2.14* 所示。

![图 A2.14：聚合在实线上表现为一个空心的菱形。](img/B18605_Figure_A2.15.jpg)

图 A2.14：聚合在实线上用一个空心的菱形表示。

聚合和组合是不同的。组合指的是从其他对象构建一个对象。聚合指的是对象之间存在一对一、一对多或多对多的关系，但对象可以独立存在。如果我们有一个`CollegeCourse`对象，我们可以用`student`对象来表示聚合。一个班级中有很多学生。如果大学取消了课程，学生不会立即消失。你可以有一个没有班级的学生。

## **有向关联**

一个有向关联显示了容器关系。一个`spaceship`对象以这种方式与`passenger`对象相关联。乘客被包含在飞船内。请注意，飞船不是由乘客组成的，所以它不同于组合。有向关联可以像在*图 A2.15*中看到的那样绘制。

![图 A2.15：两个类之间的有向关联。](img/B18605_Figure_A2.16.jpg)

图 A2.15：两个类之间的有向关联。

线是实线，箭头是两条线而不是三角形。

## **依赖**

当一个类依赖于另一个类时，你会发现当需要修改时，你将不得不同时修改这两个类。如果你改变一个，你就必须改变另一个。想象一下一个电源插头和一个电源插座。它们确实是设计成相互物理依赖的。如果你不得不改变插头的形状，你可能也必须改变插座的设计，反之亦然。两个类之间的依赖关系是我们通常力求避免的，尽管它们是不可避免的。这可能听起来很禅宗，但我指的是两个类之间的关系。依赖关系用带有非三角形箭头的虚线表示，如图*A.16*所示。

![图 A2.16：类之间的依赖关系用虚线和指向依赖关系的锐角箭头绘制。](img/B18605_Figure_A2.17.jpg)

图 A2.16：类之间的依赖关系用虚线和指向依赖关系的锐角箭头绘制。

这些关系可以用“A **依赖于** B 尽可能地少变化”来表述。我添加了最后一部分来提醒我讨论在*第二章**，*《为 C#中模式的实际应用做准备》*中的 SOLID 原则。SOLID 中的 O 代表开闭原则。类应该对扩展开放但对修改封闭。依赖是不可避免的，但当你看到图中的依赖关系时，要仔细审查它们并小心实现。

# **笔记**

**笔记**就是你所想的那样。有时，架构师需要添加比标准 UML 允许的更多一点的信息。笔记让你可以做到这一点。你可以在*图 A2.17*中看到一个例子。

![图 A2.17：这是 UML 中笔记的样子。](img/B18605_Figure_A2.18.jpg)

图 A2.17：这是 UML 中笔记的样子。

你不应该用它们来写一封长信。在实现逻辑中的简短笔记是你最常见到的。

# 最佳实践

UML 类图易于创建和理解，或者至少它们应该是这样的。不幸的是，许多图表都成为了我在*第一章*中提到的相同力量的受害者。它们可能成为金锤，而且它们可能不受控制地变得过于复杂，以至于不再有用。软件随着时间的推移逐渐屈服于这些力量。有时，需要数年才能使一个仓库充满意大利面。图表往往在几天内就会变得支离破碎。UML 是一个计划。如果你的计划是一团糟的灾难，那么你的软件怎么可能不是呢？

为了遏制这些破坏性力量的潮流，我将给你四个提示，以保持你的图表有用、易于阅读，并希望这能帮助你避免分析瘫痪。

## 少即是多——不要试图将所有内容都放入一个大的图表中

UML 图表原本是供开发团队使用的，但它们经常与其他项目利益相关者共享。如果你带着一个看起来像爱国者导弹系统引导系统图样的图表参加会议，你 shouldn’t expect to be well received. 开发者不会欣赏你，管理层也不会对你有很高的评价。在*第六章**，远离 IDE！在编码前使用模式*和*第七章**，*除了打字外别无他物：轮椅项目的实现*中，如果你试图在一个图表中绘制整个项目，UML 图可能会变得过于庞大。查看*图 A2.18*。即使我在 3 英尺宽、2 英尺高的绘图仪上打印它，图表仍然难以阅读。

![图 A2.18：不要这样做！这个图表涵盖了第七章中展示的整个项目。它太大、太复杂，而且无法在一页纸上显示。](img/B18605_Figure_A2.19.jpg)

图 A2.18：不要这样做！这个图表涵盖了*第七章*中展示的整个项目。它太大、太复杂，而且无法在一页纸上显示。

最好是把系统分解成小块，并绘制这些小块。你会在*第七章*中看到这一点。绘制小型系统的图表并保持它们简单。一般来说，我尽量保持最多一页或两页。如果图表无法适应两页标准纸张，那么它可能太大，你需要找到一种方法将其分解成更小的部分。

## 不要越界

在经典电影 *鬼怪猎人* 中，故事的主角发明了一种危险的、高科技的质子加速器，它能发射一束能量流，能够捕捉并保持鬼魂。在电影中，发明这项技术的首席科学家警告他的同志们永远不要让能量流交叉，这意味着他们永远不应该让两个质子包的能量脉冲相互交叉。试着想象你所知道的所有生命瞬间结束，因为你的身体中的所有原子粒子以光速爆炸。他们称之为 *完全质子反转*。这很糟糕。

现在，将同样的谨慎应用于你的 UML 图中的交叉线。交叉线是模糊的。你能做的最好的事情就是让它看起来像电路图，让一条线跳过另一条线。你可以在 *图 A2.19* 中看到一个例子。

![图 A2.19：D 类和 E 类的连接器跨越了 C 类和 A 类之间的界限](img/B18605_Figure_A2.20.jpg)

图 A2.19：D 类和 E 类的连接器跨越了 C 类和 A 类之间的界限

你不确定它们的起源和终止位置。如果没有办法不交叉线条绘制类图，那么它可能太大了。

如果线是通往同一地方，则不适用。B 类和 C 类都继承自 A 类。技术上，它们的线是连接而不是交叉。当这种情况发生时，我会努力将线连接在一起，使它们看起来像一条线。

## 线条的最直接路径会导致混乱

这种最佳实践已经融入了你在网上找到的更好的 UML 绘图工具中。即使是 Visio 也默认这样做。在类之间绘制直线会导致图表混乱。你可以在 *图 A2.20* 中看到我的意思。

![图 A2.20：带有直角的迂回线瞬间使图表看起来更好。](img/B18605_Figure_A2.21.jpg)

图 A2.20：带有直角的迂回线瞬间使图表看起来更好。

最好绘制一条更迂回但易于跟随的线，正如我们之前提到的，它不会与其他线交叉。

## 父元素位于子元素之上

当你在绘制任何类型的继承或接口实现图时，你应该始终将父元素绘制在子元素之上，或者至少与子元素一样高，如图 *图 A2.21* 所示。

![图 A2.21：父元素应该始终位于子元素之上，这意味着你的箭头应该始终向上。](img/B18605_Figure_A2.22.jpg)

图 A2.21：父元素应该始终位于子元素之上，这意味着你的箭头应该始终向上。

只要你保持一致，这会使你的图表更容易跟随。

## 保持你的图表整洁

花时间保持你的图表整洁。我还会给你同样的建议，用于你的代码。清理不再使用的部分。纠正你的拼写。细节很重要！我还会补充说，你应该选择易于阅读的字体。你的图表中的字体应该很好地显示斜体，这样你就可以始终看到抽象类。

# 摘要

本附录涵盖了 UML。虽然它听起来像是一种编程语言，但实际上它是一种绘制图表的标准方式，用于表示结构和代码模式。我们只需要 14 个认可的 UML 文档中的 1 个就能通过这本书，但我们使用的这个文档被广泛使用。

类图显示了系统的结构以及这些结构之间的关系。结构可能是类、接口、枚举和包。常见的关系包括继承、接口实现、组合、关联等。可以在图表中添加注释以提供更多细节，但应保持简洁。

我们学习了 UML 类图的最佳实践，包括尽可能使图表清晰易读。避免图表中出现因试图定义结构之间所有可能的关系而产生的杂乱。相反，应专注于对图表实现至关重要的那些关系。一个好的图表不一定必须完全符合 UML 的标准。一个好的图表是能够快速传达信息，只包含足够细节以便开发者能够成功实现图表意图，而不需要过度管理每个细节。

# 进一步阅读

Baumann, Henriette, Patrick Grassle, and Philippe Baumann. 《UML 2.0 实战：基于项目的教程》. Packt Publishing, 2005.
