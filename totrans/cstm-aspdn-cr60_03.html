<html><head></head><body>
		<div id="_idContainer012">
			<h1 id="_idParaDest-33"><em class="italic"><a id="_idTextAnchor049"/>Chapter 3</em>: Customizing Dependency Injection</h1>
			<p>In this third chapter, we'll take a look at ASP.NET Core <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) and how to customize it to use a different DI container, if needed.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Using a different DI container</li>
				<li>Exploring the <strong class="source-inline">ConfigureServices</strong> method</li>
				<li>Using a different <strong class="source-inline">ServiceProvider</strong></li>
				<li>Introducing Scrutor</li>
			</ul>
			<p>The topics in this chapter refer to the hosting layer of the ASP.NET Core architecture:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_2.1_B17996.jpg" alt="Figure 3.1 – ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – ASP.NET Core architecture</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor050"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core MVC application. Open your console, shell, or Bash terminal and change to your working directory. Use the following command to create a new MVC application:</p>
			<p class="source-code">dotnet new mvc -n DiSample -o DiSample</p>
			<p>Now, open the project in Visual Studio by double-clicking the project file, or in Visual Studio Code by typing the following command in the already-open console:</p>
			<p class="source-code">cd DiSample</p>
			<p class="source-code">code .</p>
			<p>All of the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-35">U<a id="_idTextAnchor051"/><a id="_idTextAnchor052"/>sing a different DI container</h1>
			<p>In most projects, you don't really need to use a different DI container. The existing DI implementation in ASP.NET Core supports the main basic features and works both effectively and quickly. However, some other DI containers<a id="_idIndexMarker034"/> support a number of interesting features<a id="_idIndexMarker035"/> you might want to use in your application:</p>
			<ul>
				<li>Create an application<a id="_idIndexMarker036"/> that supports modules as lightweight dependencies using Ninject, for example, modules you might want to put into a specific directory and have them be automatically registered in your application.</li>
				<li>Configure the services in a configuration file outside the application, in an XML or JSON file instead of in C# only. This is a common feature in various DI containers, but not yet supported in ASP.NET Core.</li>
				<li>Add services at runtime, probably because you don't want to have an immutable DI container. This is also a common feature in some DI containers.</li>
			</ul>
			<p>Let's now see how the <strong class="source-inline">ConfigureServices</strong> method enables you to use alternative DI containers<a id="_idTextAnchor053"/><a id="_idTextAnchor054"/>.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor055"/>Exploring the ConfigureServices method</h1>
			<p>Let's compare the current <strong class="source-inline">ConfigureServices</strong> method with a previous long-term support version to see what<a id="_idIndexMarker037"/> has changed. If you created a new ASP.NET Core project using version 3.1 and open <strong class="source-inline">Startup.cs</strong>, you will find the method to configure the services, which looks like this:</p>
			<p class="source-code">public void ConfigureServices(IServiceCollection services)</p>
			<p class="source-code">{</p>
			<p class="source-code">    services.Configure&lt;CookiePolicyOptions&gt;(options =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // This lambda determines whether user</p>
			<p class="source-code">        // consent for non-essential cookies is</p>
			<p class="source-code">        // needed for a given request.</p>
			<p class="source-code">         options.CheckConsentNeeded = context =&gt; true;</p>
			<p class="source-code">    });</p>
			<p class="source-code">    services.AddControllersWithViews();</p>
			<p class="source-code">    services.AddRazorPages();</p>
			<p class="source-code">}</p>
			<p>In contrast, in ASP.NET Core 6.0, there is no <strong class="source-inline">Startup.cs</strong> anymore, and the configuring of the services is done in <strong class="source-inline">Program.cs</strong>, which looks like this:</p>
			<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p>
			<p class="source-code">// Add services to the container.</p>
			<p class="source-code">builder.Services.AddControllersWithViews();</p>
			<p class="source-code">var app = builder.Build();</p>
			<p class="source-code">// The rest of the file isn't relevant for this chapter</p>
			<p>In both cases, the method gets <strong class="source-inline">IServiceCollection</strong>, which is already filled with a bunch of services that are required by ASP.NET Core. This service was added by the hosting services and parts of ASP.NET Core that are executed before the <strong class="source-inline">ConfigureServices</strong> method was called.</p>
			<p>Inside the method, some more services are added. First, a configuration class that contains cookie policy options is added to <strong class="source-inline">ServiceCollection</strong>. After that, the <strong class="source-inline">AddMvc()</strong> method adds another bunch of services required by the MVC framework. So far, we have around 140 services registered to <strong class="source-inline">IServiceCollection</strong>. However, the service collection isn't the actual DI container.</p>
			<p>The actual DI container is wrapped in the so-called <strong class="bold">service provider</strong>, which will be created<a id="_idIndexMarker038"/> out of the service collection. <strong class="source-inline">IServiceCollection</strong> has an extension method registered to create an <strong class="source-inline">IServiceProvider</strong> out of the service collection, which you can see in the following code snippet:</p>
			<p class="source-code">IServiceProvider provider = services.BuildServiceProvider()</p>
			<p><strong class="source-inline">ServiceProvider</strong> contains the immutable container that cannot be changed at runtime. With the default <strong class="source-inline">ConfigureServices</strong> method, <strong class="source-inline">IServiceProvider</strong> is created in the background<a id="_idIndexMarker039"/> after this method is called.</p>
			<p>Next, we'll learn more about applying an alternative <strong class="source-inline">ServiceProvider</strong> as part of the DI customization proc<a id="_idTextAnchor056"/><a id="_idTextAnchor057"/>ess.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor058"/>Using a different ServiceProvider</h1>
			<p>Changing to a different or custom DI container<a id="_idIndexMarker040"/> is relatively easy if the other container already supports ASP.NET Core. Usually, the other container will use <strong class="source-inline">IServiceCollection</strong> to feed its own container. The third-party DI containers move the already-registered services to the other container by looping over the collection:</p>
			<ol>
				<li>Let's start by using <strong class="source-inline">Autofac</strong> as a third-party container. Type the following command into your command line to load the NuGet package:<p class="source-code"><strong class="bold">dotnet add package Autofac.Extensions.DependencyInjection</strong></p><p><strong class="source-inline">Autofac</strong> is good for this because you are easily able to see what is happening here.</p></li>
				<li>To register a custom<a id="_idIndexMarker041"/> IoC container, you need to register a different <strong class="source-inline">IServiceProviderFactory</strong>. In that case, you'll want to use <strong class="source-inline">AutofacServiceProviderFactory</strong> if you use <strong class="source-inline">Autofac</strong>. <strong class="source-inline">IServiceProviderFactory</strong> will create a <strong class="source-inline">ServiceProvider</strong> instance. The third-party container should provide one, if it supports ASP.NET Core.<p>You should place this small extension method in <strong class="source-inline">Program.cs</strong> to register <strong class="source-inline">AutofacServiceProviderFactory</strong> with <strong class="source-inline">IHostBuilder</strong>:</p><p class="source-code">using Autofac;</p><p class="source-code">using Autofac.Extensions.DependencyInjection;</p><p class="source-code"> </p><p class="source-code">namespace DiSample;</p><p class="source-code">public static class IHostBuilderExtension</p><p class="source-code">{</p><p class="source-code">    public static IHostBuilder </p><p class="source-code">      UseAutofacServiceProviderFactory(</p><p class="source-code">        this IHostBuilder hostbuilder)</p><p class="source-code">    {</p><p class="source-code">        hostbuilder.UseServiceProviderFactory</p><p class="source-code">          &lt;ContainerBuilder&gt;(</p><p class="source-code">        new AutofacServiceProviderFactory());</p><p class="source-code">        return hostbuilder;</p><p class="source-code">    }</p><p class="source-code">}</p><p>Don't forget to add using statements to <strong class="source-inline">Autofac</strong> and <strong class="source-inline">Autofac.Extensions.DependencyInjection</strong>.</p></li>
				<li>To use this extension method, you can use <strong class="source-inline">AutofacServiceProvider</strong> in <strong class="source-inline">Program.cs</strong>:<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p><p class="source-code">builder.Host.UseAutofacServiceProviderFactory();</p><p class="source-code">// Add services to the container.</p><p class="source-code">builder.Services.AddControllersWithViews();</p></li>
			</ol>
			<p>This adds the <strong class="source-inline">AutofacServiceProviderFactory</strong> function to <strong class="source-inline">IHostBuilder</strong> and enables the <strong class="source-inline">Autofac</strong> IoC container. If you have<a id="_idIndexMarker042"/> this in place, you will use <strong class="source-inline">Autofac</strong> if you add services to <strong class="source-inline">IServiceCollection</strong> using the defau<a id="_idTextAnchor059"/><a id="_idTextAnchor060"/>lt way.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor061"/>Introducing Scrutor</h1>
			<p>You don't always need to replace the existing .NET Core DI container to get and use some cool features. At the beginning<a id="_idIndexMarker043"/> of this chapter, I mentioned the autoregistration of services, which can be done with other DI containers. This can also be done with a nice NuGet package called <strong class="bold">Scrutor</strong> (<a href="https://github.com/khellang/Scrutor">https://github.com/khellang/Scrutor</a>) by <em class="italic">Kristian Hellang</em> (<a href="https://kristian.hellang.com">https://kristian.hellang.com</a>). Scrutor extends <strong class="source-inline">IServiceCollection</strong> to automatically register services with the .NET Core DI contain<a id="_idTextAnchor062"/>er.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Andrew Lock has published a pretty detailed blog post relating to Scrutor. Rather than just repeating<a id="_idIndexMarker044"/> what he said, I suggest that you just go ahead and read that post to learn more about it: <em class="italic">Using Scrutor to automatically register your services with the ASP.NET Core DI container</em>, available at <a href="https://andrewlock.net/using-scrutor-to-automatically-register-your-services-with-the-asp-net-core-di-container/">https://andrewlock.net/using-scrutor-to-automatically-register-your-services-with-the-asp-net-core-di-c<span id="_idTextAnchor063"/>o<span id="_idTextAnchor064"/>ntainer/</a>.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor065"/>Summary</h1>
			<p>Using the approaches we have demonstrated in this chapter, you will be able to use any .NET Standard-compatible DI container to replace the existing one. If the container of your choice doesn't include <strong class="source-inline">ServiceProvider</strong>, create your own that implements <strong class="source-inline">IServiceProvider</strong> and uses the DI container inside. If the container of your choice doesn't provide a method to populate the registered services in the container, create your own method. Loop over the registered services and add them to the other container.</p>
			<p>Actually, the last step sounds easy but can be a hard task, because you need to translate all the possible <strong class="source-inline">IServiceCollection</strong> registrations into registrations of the other container. The complexity of that task depends on the implementation details of the other DI container.</p>
			<p>Anyway, you have the choice to use any DI container that is compatible with .NET Standard. You can change a lot of the default implementations in ASP.NET Core.</p>
			<p>This is also something you can do with the default HTTPS behavior on Windows, which we will learn more about in the next chapter.</p>
		</div>
	</body></html>