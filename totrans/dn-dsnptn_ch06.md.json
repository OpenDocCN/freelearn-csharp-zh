["```cs\n    public override void  \n    Observer_ExpressionChangedEvent( string expression) \n    { \n      MainWindow mw = this._ctrl as MainWindow; \n      mw.Expr = expression; \n      ExpressionBuilder builder = new  \n      ExpressionBuilder(expression); \n      Exp expr_tree = builder.GetExpression(); \n\n      if ( expr_tree != null ) \n      mw.Render(); \n    } \n\n```", "```cs\n    public abstract class BaseObserver \n    { \n      protected delegate void \n      ExpressionEventHandler(string expression); \n      protected ExpressionEventHandler ExpressionChangedEvent; \n      protected Control _ctrl = null; \n      public abstract void Observer_ExpressionChangedEvent(string     \n      expression);\n```", "```cs\n    public BaseObserver(Control ctrl) \n    { \n      this.ExpressionChangedEvent +=  \n      new ExpressionEventHandler( \n      Observer_ExpressionChangedEvent); \n      this._ctrl = ctrl; \n    } \n\n```", "```cs\n    private void OnChange(string expression) \n    { \n      if (ExpressionChangedEvent != null) \n      ExpressionChangedEvent(expression); \n    } \n    public void Update(string expression) \n    { \n      OnChange(expression); \n    } \n  } \n\n```", "```cs\n    public class Subject \n    { \n      List<BaseObserver> observers = new List<BaseObserver>(); \n      private delegate void NotifyHandler(string expression); \n      private event NotifyHandler NotifyEvent; \n\n      public Subject(){ \n        this.NotifyEvent += new NotifyHandler(Notify); \n      } \n\n      public void UpdateClient(string expression){ \n        OnNotify(expression); \n      } \n\n      private void OnNotify(string expression){ \n        if (NotifyEvent != null) \n        NotifyEvent(expression); \n      } \n\n      private void Notify(string expression){ \n        foreach (BaseObserver b in observers) \n        b.Update(expression); \n      } \n\n      public void RegisterClient(BaseObserver obs){ \n        observers.Add(obs); \n      } \n    } \n\n```", "```cs\n    class ExpressionObserver : BaseObserver \n    { \n      public ExpressionObserver(Window _win) : \n      base(_win){ } \n\n      public override void  \n      Observer_ExpressionChangedEvent(string expression) \n      { \n        MainWindow mw = this._ctrl as MainWindow; \n        mw.Expr = expression; \n        ExpressionBuilder builder = new  \n        ExpressionBuilder(expression); \n        Exp expr_tree = builder.GetExpression(); \n\n        if ( expr_tree != null ) \n          mw.Render(); \n      } \n    } \n\n```", "```cs\n    _observer = new ExpressionObserver(this); \n    _subject = new Subject(); \n    _subject.RegisterClient(_observer); \n\n```", "```cs\n    private void text_changed(object sender, TextChangedEventArgs e) \n    { \n      if ( _subject != null ) \n      _subject.UpdateClient(this.ExprText.Text); \n    } \n\n```", "```cs\n    // AST for 5*10 \n    Exp e = new BinaryExp( \n    new NumericConstant(5), \n    new NumericConstant(10), \n    OPERATOR.MUL); \n\n```", "```cs\n    // AST for -(10+(30+50)) \n    Exp e = new UnaryExp( \n      new BinaryExp( \n        new NumericConstant(10), \n        new BinaryExp( \n          new NumericConstant(30), \n          new NumericConstant(50), \n        OPERATOR.PLUS), \n      OPERATOR.PLUS) \n    ,OPERATOR.MINUS); \n\n```", "```cs\n    public class RUNTIME_CONTEXT \n    { \n      private double _t = 0 ; \n      public RUNTIME_CONTEXT(){ } \n      public double T { \n        get { return _t; } \n        set { _t = value; } \n      } \n    } \n\n```", "```cs\n    abstract class Exp{ \n      public abstract double Evaluate(RUNTIME_CONTEXT cont);\n    } \n\n```", "```cs\n    public enum OPERATOR{ \n      ILLEGAL = -1,PLUS, MINUS, DIV, MUL \n    } \n\n```", "```cs\n    class Exp // Base class for Expression \n    class NumericConstant // Numeric Value \n    class BinaryExp // Binary Expression \n    class UnaryExp // Unary Expression \n    class SineExp // Trig fn \n    class SineExp // Trig \n    class Var // psuedo variable $t \n\n```", "```cs\n    public class NumericConstant : Exp \n    { \n      private double _value; \n      public NumericConstant(double value){ _value = value;} \n\n      public override double Evaluate(RUNTIME_CONTEXT cont) \n      { return _value;} \n    } \n\n```", "```cs\n    public class BinaryExp : Exp \n    { \n      private Exp _ex1, _ex2; \n      private OPERATOR _op; \n\n      public BinaryExp(Exp a, Exp b, OPERATOR op) \n      { _ex1 = a; _ex2 = b; _op = op; } \n\n      public override double Evaluate(RUNTIME_CONTEXT cont) \n      { \n        switch (_op) \n        { \n          case OPERATOR.PLUS: \n            return _ex1.Evaluate(cont) + _ex2.Evaluate(cont); \n          case OPERATOR.MINUS: \n            return _ex1.Evaluate(cont) - _ex2.Evaluate(cont); \n          case OPERATOR.DIV: \n            return _ex1.Evaluate(cont) / _ex2.Evaluate(cont); \n          case OPERATOR.MUL: \n            return _ex1.Evaluate(cont) * _ex2.Evaluate(cont); \n        } \n        return Double.NaN; \n      } \n    } \n\n```", "```cs\n    public class UnaryExp : Exp \n    { \n      private Exp _ex1; \n      private OPERATOR _op; \n      public UnaryExp(Exp a, OPERATOR op) \n      {_ex1 = a;_op = op } \n      public override double Evaluate(RUNTIME_CONTEXT cont) \n      { \n        switch (_op) \n        { \n          case OPERATOR.PLUS: \n          return _ex1.Evaluate(cont); \n          case OPERATOR.MINUS: \n          return -_ex1.Evaluate(cont); \n        } \n        return Double.NaN; \n      } \n    } \n\n```", "```cs\n    class SineExp : Exp \n    { \n      private Exp _ex1; \n      public SineExp(Exp a) \n      { _ex1 = a; } \n      public override double Evaluate(RUNTIME_CONTEXT cont){ \n        double val = _ex1.Evaluate(cont); \n        return Math.Sin(val); \n      } \n    } \n\n```", "```cs\n    class CosExp : Exp \n    { \n      private Exp _ex1; \n      public CosExp(Exp a) \n      { _ex1 = a;} \n      public override double Evaluate(RUNTIME_CONTEXT cont){ \n        double val = _ex1.Evaluate(cont); \n        return Math.Cos(val); \n      } \n    } \n\n```", "```cs\n    class Var : Exp \n    { \n      public Var(){} \n      public override double Evaluate(RUNTIME_CONTEXT cont){ \n        return cont.T; \n      } \n    } \n\n```", "```cs\n    <Expr> ::= <Term> | Term { + | - } <Expr> \n    <Term> ::= <Factor> | <Factor> {*|/} <Term> \n    <Factor>::= <number> | ( <expr> ) | {+|-} <factor> |  \n                SIN(<expr>) | COS(<expr>) | $t \n\n```", "```cs\n    public enum TOKEN \n    { \n      ILLEGAL_TOKEN = -1, // Not a Token \n      TOK_PLUS = 1, // '+' \n      TOK_MUL, // '*' \n      TOK_DIV, // '/' \n      TOK_SUB, // '-' \n      TOK_OPAREN, // '(' \n      TOK_CPAREN, // ')' \n      TOK_DOUBLE, // '(' \n      TOK_TPARAM, // $t \n      TOK_SIN, // SIN \n      TOK_COS, // COS \n      TOK_NULL // End of string \n    } \n\n```", "```cs\n    while (<there is input>)  \n    { \n      switch(currentchar) { \n        case Operands: \n          <advance input pointer> \n          return TOK_XXXX; \n        case '$': \n          <Now Look for 't'> \n          if found return TOK_TPARAM \n            else Error \n        case Number: \n          <Extract the number(Advance the input)> \n          return TOK_DOUBLE; \n        case 'S' or 'C': \n          <Try to see whether it is SIN/COS> \n          Advance the input \n          return TOK_SIN Or TOK_COS \n        default: \n          Error \n      } \n    } \n\n```", "```cs\n    public class RDParser : Lexer \n    { \n      TOKEN Current_Token; \n      public RDParser(String str): base(str){} \n\n      public Exp CallExpr() \n      { \n        Current_Token = GetToken(); \n        return Expr(); \n      } \n\n```", "```cs\n    //Implementation of <Expr> ::= <Term> | Term { + | - } <Expr>  \n    Grammar \n    public Exp Expr() \n    { \n      TOKEN l_token; \n      Exp RetValue = Term(); \n      while (Current_Token == TOKEN.TOK_PLUS ||  \n      Current_Token == TOKEN.TOK_SUB) \n      { \n        l_token = Current_Token; \n        Current_Token = GetToken(); \n        Exp e1 = Expr(); \n        RetValue = new BinaryExp(RetValue, e1, \n        l_token == TOKEN.TOK_PLUS ?  \n        OPERATOR.PLUS : OPERATOR.MINUS); \n      } \n      return RetValue; \n    } \n\n```", "```cs\n    //Implementation of <Term> ::= <Factor> | <Factor> {*|/} <Term>     \n    Grammar \n    public Exp Term() \n    { \n      TOKEN l_token; \n      Exp RetValue = Factor(); \n      while (Current_Token == TOKEN.TOK_MUL ||  \n      Current_Token == TOKEN.TOK_DIV) \n      { \n        l_token = Current_Token; \n        Current_Token = GetToken(); \n        Exp e1 = Term(); \n        RetValue = new BinaryExp(RetValue, e1, \n        l_token == TOKEN.TOK_MUL ?  \n        OPERATOR.MUL : OPERATOR.DIV);  \n      } \n      return RetValue; \n    } \n\n```", "```cs\n    //Implementation of <Factor>::= <number> | ( <expr> ) | {+|-}   \n    <factor> |  \n    //SIN(<expr>) | COS(<expr>) | $t Grammar \n    public Exp Factor() \n    { \n      TOKEN l_token; \n      Exp RetValue = null; \n\n      if (Current_Token == TOKEN.TOK_DOUBLE) \n      { \n        RetValue = new NumericConstant(GetNumber()); \n        Current_Token = GetToken(); \n      } \n\n```", "```cs\n    else if (Current_Token == TOKEN.TOK_TPARAM) \n    { \n      RetValue = new Var(); \n      Current_Token = GetToken(); \n    } \n\n```", "```cs\n    else if ( Current_Token == TOKEN.TOK_SIN || \n    Current_Token == TOKEN.TOK_COS) \n    { \n      TOKEN old = Current_Token; \n      Current_Token = GetToken(); \n      if (Current_Token != TOKEN.TOK_OPAREN) \n      { \n        Console.WriteLine(\"Illegal Token\"); \n        throw new Exception(); \n      } \n      Current_Token = GetToken(); \n      RetValue = Expr();  // Recurse \n\n      if (Current_Token != TOKEN.TOK_CPAREN) \n      { \n        Console.WriteLine(\"Missing Closing Parenthesis\\n\"); \n        throw new Exception(); \n      } \n\n      Retvalue = (old == TOKEN.TOK_COS) ? \n      new CosExp(RetValue) : \n      new SineExp(RetValue); \n      Current_Token = GetToken(); \n    } \n\n```", "```cs\n    else if (Current_Token == TOKEN.TOK_OPAREN)  \n    { \n      Current_Token = GetToken(); \n      RetValue = Expr();  // Recurse \n      if (Current_Token != TOKEN.TOK_CPAREN) \n      { \n        Console.WriteLine(\"Missing Closing Parenthesis\\n\"); \n        throw new Exception(); \n      } \n      Current_Token = GetToken(); \n    } \n\n```", "```cs\n    else if (Current_Token == TOKEN.TOK_PLUS ||  \n    Current_Token == TOKEN.TOK_SUB) \n    { \n      l_token = Current_Token; \n      Current_Token = GetToken(); \n      RetValue = Factor(); // Recurse \n      RetValue = new UnaryExp(RetValue, \n      l_token == TOKEN.TOK_PLUS ?  \n      OPERATOR.PLUS : OPERATOR.MINUS); \n    } \n    else \n    { \n      Console.WriteLine(\"Illegal Token\"); \n      throw new Exception(); \n    } \n    return RetValue; \n  } \n} \n\n```", "```cs\n    <Expr> ::= <Term> | Term { + | - } <Expr> \n\n```", "```cs\n    <Term> ::= <Factor> | <Factor> {*|/} <Term> \n\n```", "```cs\n    <Factor>::= <number> | ( <expr> ) | {+|-} <factor> | SIN(<expr>) |  \n    COS(<expr>) | $t\n```", "```cs\n    public class AbstractBuilder{} \n\n    public class ExpressionBuilder : AbstractBuilder \n    { \n      public string _expr_string; \n      public ExpressionBuilder(string expr) \n      { _expr_string = expr; } \n\n      public Exp GetExpression() \n      { \n        try \n        { \n          RDParser p = new RDParser(_expr_string); \n          return p.CallExpr(); \n        } \n        catch (Exception) \n        { \n          return null; \n        } \n      } \n    } \n\n```", "```cs\n    double t = -x / 2; \n    double final = x / 2; \n    ExpressionBuilder bld = new ExpressionBuilder(expr); \n    Exp e = bld.GetExpression(); \n    if (e == null) \n      return false; \n\n```", "```cs\n\n    RUNTIME_CONTEXT context = new RUNTIME_CONTEXT(); \n    context.T = t; \n    for (; t < final; t += 4) \n    { \n      context.T=t; \n      double n = e.Evaluate(context); \n      RenderAPixel(); \n    }\n```"]