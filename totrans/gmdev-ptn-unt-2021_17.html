<html><head></head><body>
        

                            
                    Adapting Systems with an Adapter
                
            
            
                
<p>In a world full of different types of cables and plugs, we have all become accustomed to the concept of adapters. The Adapter pattern will be one of those patterns that will be easy for you to grasp because it correlates so perfectly with our real-world experiences with technology. The Adapter pattern's name perfectly reveals its core purpose; it offers us a way to seamlessly use old code with new code by adding an interface between the code that will act as an adapter.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Understanding the Adapter pattern</li>
<li>Implementing the Adapter pattern</li>
</ul>
<p>The examples presented in this chapter are skeleton code. It's simplified for learning purposes so we can focus on the structure of the pattern. It might not be optimized or contextualized enough to be used as is in your project.</p>
<h1 id="uuid-4141d985-8e06-4594-99cb-2aa8c136bef3">Technical requirements</h1>
<p>The following chapter is hands-on, so you will need to have a basic understanding of Unity and C#.</p>
<p>The code files of this chapter can be found on GitHub: <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14</a><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14"><br/>
<br/></a></p>
<p class="mce-root">Check out the following video to see the Code in Action: <br/>
<a href="https://bit.ly/3wBHqkX">https://bit.ly/3wBHqkX</a></p>
<h1 id="uuid-94938ef1-8768-4b78-b2d8-6f67cea69dd2">Understanding the Adapter pattern</h1>
<p class="mce-root">As its name implies, the Adapter pattern adapts two incompatible interfaces; like a plug adapter, it doesn't modify what it adjusts but bridges one interface with another. This approach can be beneficial when dealing with legacy code that you cannot refactor due to its fragility, or when you need to add features to a third-party library but don't want to modify it to avoid issues when upgrading it.</p>
<p class="mce-root">Here's a quick breakdown of the two main approaches to implementing the Adapter pattern:</p>
<ul>
<li class="mce-root"><strong>Object Adapter</strong>: In this version, the pattern uses object composition, and the adapter acts as a wrapper around the adapted object. It's helpful if we have a class that doesn't have the methods we require, but we can't modify it directly. The Object Adapter adopts the methods of the original class and adapts them to what we need.</li>
<li class="mce-root"><strong>Class Adapter</strong>: In this version of the pattern, the adapter uses inheritance to adapt the interface of an existing class to that of another. It's useful when we need to adjust a class so it can work with others but can't modify it directly.</li>
</ul>
<p>In our code example, we will use a permutation of the Class Adapter as it's more challenging to learn. If we understand the Class Adapter version, then we can extrapolate an understanding of the Object Adapter version.</p>
<p>Let's take a look at a side-by-side diagram of the Object and Class Adapters; the core differences are subtle, but the similarities are apparent:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/82dbcfc8-0321-4c29-90ec-32dbf28f35e9.png" style="width:48.33em;height:40.92em;"/></p>
<p>Figure 14.1 – Diagram of a replay system </p>
<p>As you can see, in both cases, the <strong>Adapter</strong> class is positioned between the <strong>Client</strong> and the adapted entity (<strong>Adaptee</strong>). But the Class Adapter establishes a relationship with the Adaptee through inheritance. In contrast, the Object Adapter uses composition to wrap an instance of the Adaptee for adaption.</p>
<p>In both cases, the entity that we are adapting is not modified. And the client is not aware of what we are adapting; it just knows that it has a consistent interface to communicate with the adapted object.</p>
<p>Composition and inheritance are ways to define relationships between objects; they describe how they relate to each other. And that difference in the relationship structure determines in part the difference between the Object and Class Adapters.</p>
<p class="mce-root">Another point to address is that the Adapter can sometimes be confused with the Facade pattern. We must understand that the core difference between them is that the Facade pattern establishes a simplified front-facing interface to a complex system. But the Adapter adapts incompatible systems while maintaining a consistent interface for a client.</p>
<p class="mce-root">Both patterns are related as they are both structural patterns but have entirely different purposes.</p>
<div><strong>Composition</strong> is one of the core concepts of <strong>O</strong><strong>bject-Oriented Programming</strong> (<strong>OOP</strong>); it refers to the concept of combining simple types to make more complex ones. For instance, a motorbike has wheels, an engine, and a handlebar. So composition establishes a "has a" relationship while inheritance sets an "is a" relationship.</div>
<h2 id="uuid-1a4a4b8f-9dc9-4b2e-8dc9-df0a891fe9b0">Benefits and drawbacks of the Adapter pattern</h2>
<p>The following are some of the benefits of the Adapter pattern:</p>
<ul>
<li><strong>Adapting without modifying</strong>: The main benefit of the Adapter pattern is that it offers a standard approach to adapting old or third-party code without modifying it.</li>
<li><strong>Reusability and flexibility</strong>: This pattern permits the continued use of legacy code on new systems with minimal changes; this has an immediate return on investment.</li>
</ul>
<p>The following are some potential drawbacks of the Adapter pattern:</p>
<ul>
<li><strong>Persisting legacy</strong>: The ability to use legacy code with new systems is cost-effective, but in the long term, it can become an issue, because the old code might limit your upgrade options as it becomes deprecated and incompatible with new versions of Unity or third-party libraries.</li>
<li><strong>Slight overhead</strong>: Because, in some instances, you are redirecting calls between objects, there might be a slight performance hit, usually too small to become an issue.</li>
</ul>
<p>The Adapter is part of the structural pattern family, including the Facade, Bridge, Composite, Flyweight, and Decorator.</p>
<h2 id="uuid-3f421f50-ac72-400a-b4a4-efdb9ec922db">When to use the Adapter pattern</h2>
<p>A potential use case for the Adapter in Unity is when you have a third-party library that you downloaded from the Unity Asset Store, and you need to modify some of its core classes and interfaces to add new features. But when changing third-party code, you risk having merge issues every time you pull an update from the library owners.</p>
<p class="mce-root">Hence, you find yourself in a situation where you choose to wait for the third-party library owners to integrate the changes you need or modify their code and add the missing features. Both choices have their risks versus rewards. But the Adapter pattern gives us a solution to this dilemma by letting us place an adapter between existing classes so they can work together without modifying them directly.</p>
<p class="mce-root">Let's imagine we are working on the code base of a project that uses an inventory system package downloaded from the Unity Asset Store. The system is excellent; it saves the player's purchased or gifted inventory items to a secure cloud backend service. But there's one problem, it doesn't support local disk saves. This limitation has become an issue in our project because we need both local and cloud saves for redundancy purposes.</p>
<p class="mce-root">In this scenario, we could easily modify the vendor's code and add the feature we need. But when they release their next update, we will have to merge our code with theirs. This approach can be an error-prone process. Instead, we will use the Adapter pattern and implement a wrapper that will maintain a consistent interface to the inventory system while adding local-save support. And in the process, we will not have to modify any of the existing classes. Thus, we will be able to avoid changing the vendor's code and still have your local save system handle the saving of inventory items.</p>
<p class="mce-root">We will implement an example of this use case in the next section. But in conclusion, the Adapter pattern is handy in situations in which you have incompatible systems that need to interface with each other. Still, you want to avoid modifying any existing code.</p>
<h1 id="uuid-9891d187-abe5-42ce-82e1-6fad914f0855">Implementing the Adapter pattern</h1>
<p>The code example will be simple; we will not attempt to write an entire local disk save system because that's not the focus of this chapter. Instead, we will write the skeleton of the system to concentrate on the use of the Adapter pattern and not be impeded by unrelated implementation details.</p>
<h2 id="uuid-0d588cd0-764c-4e82-9b73-46ba79b4176c">Implementing the Adapter pattern</h2>
<p>To start off, we will implement a placeholder class that will mock the third-party inventory system as presented in the scenario of the previous section:</p>
<ol>
<li>The <kbd>InventorySystem</kbd> class provided by our fictional provider has three methods, <kbd>AddItem()</kbd>, <kbd>RemoveItem()</kbd>, and <kbd>GetInventory()</kbd>. All of these methods are hardcoded to use cloud storage and we can't modify them:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections.Generic;<br/><br/>namespace Chapter.Adapter<br/>{<br/>    public class InventorySystem<br/>    {<br/>        public void AddItem(InventoryItem item)<br/>        {<br/>            Debug.Log(<br/>                "Adding item to the cloud");<br/>        }<br/><br/>        public void RemoveItem(InventoryItem item)<br/>        {<br/>            Debug.Log(<br/>                "Removing item from the cloud");<br/>        }<br/><br/>        public List&lt;InventoryItem&gt; GetInventory()<br/>        {<br/>            Debug.Log(<br/>                "Returning an inventory list stored in the cloud");<br/><br/>            return new List&lt;InventoryItem&gt;();<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>Next up is the class that will act as our adapter in this scenario. It adds the ability to save inventory items to a local disk. But it also exposes a new functionality that permits the merging and syncing of the player's local and cloud inventories:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections.Generic;<br/><br/>namespace Chapter.Adapter {<br/>    public class InventorySystemAdapter:<br/>        InventorySystem, IInventorySystem {<br/><br/>        private List&lt;InventoryItem&gt; _cloudInventory;<br/><br/>        public void SyncInventories() {<br/>            var _cloudInventory = GetInventory();<br/><br/>            Debug.Log(<br/>                "Synchronizing local drive and cloud inventories");<br/>        }<br/><br/>        public void AddItem(<br/>            InventoryItem item, SaveLocation location) {<br/><br/>            if (location == SaveLocation.Cloud)<br/>                AddItem(item);<br/><br/>            if (location == SaveLocation.Local)<br/>                Debug.Log("Adding item to local drive");<br/><br/>            if (location == SaveLocation.Both)<br/>                Debug.Log(<br/>                    "Adding item to local drive and on the cloud");<br/>        }<br/><br/>        public void RemoveItem(<br/>            InventoryItem item, SaveLocation location) {<br/><br/>            Debug.Log(<br/>                "Remove item from local/cloud/both");<br/>        }<br/><br/>        public List&lt;InventoryItem&gt; <br/>            GetInventory(SaveLocation location) {<br/><br/>            Debug.Log(<br/>                "Get inventory from local/cloud/both");<br/><br/>            return new List&lt;InventoryItem&gt;();<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">Notice that by inheriting the third party's <kbd>InventorySystem</kbd> class, we have access to all its properties and methods. Thus we can continue to use its core functionalities while adding our own. We are modifying nothing in the process, just adapting it.</p>
<ol start="3">
<li>We are going to expose an interface to our new inventory system:</li>
</ol>
<pre style="padding-left: 60px">using System.Collections.Generic;<br/><br/>namespace Chapter.Adapter<br/>{<br/>    public interface IInventorySystem<br/>    {<br/>        void SyncInventories();<br/><br/>        void AddItem(<br/>            InventoryItem item, SaveLocation location);<br/><br/>        void RemoveItem(<br/>            InventoryItem item, SaveLocation location);<br/><br/>        List&lt;InventoryItem&gt; GetInventory(SaveLocation location);<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The client who uses this interface is not aware that it's communicating with a system adapted from another. The Adaptee is also not aware that we are adapting it. Like a charger adapter, the phone and cable are unaware of which plug they are connected to, only that current is passing through the system and charging the battery. </p>
<ol start="4">
<li>To complete our implementation, we need to add an <kbd>enum</kbd> that exposes the save locations:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.Adapter<br/>{<br/>    public enum SaveLocation<br/>    {<br/>        Disk,<br/>        Cloud,<br/>        Both<br/>    }<br/>}</pre>
<ol start="5">
<li>And for our last step, we will implement a placeholder <kbd>InventoryItem</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Adapter<br/>{<br/>    [CreateAssetMenu(<br/>        fileName = "New Item", menuName = "Inventory")]<br/>    public class InventoryItem : ScriptableObject<br/>    {<br/>        // Placeholder class<br/>    }<br/>}</pre>
<h2 id="uuid-84e1ac84-4141-4c98-a066-b4969f98293b">Testing the Adapter pattern implementation</h2>
<p>To test our implementation in your instance of Unity, copy all the classes we just reviewed into your project and attach the following client class to an empty GameObject in a new Unity scene:</p>
<pre>using UnityEngine;<br/><br/>namespace Chapter.Adapter<br/>{<br/>    public class ClientAdapter : MonoBehaviour<br/>    {<br/>        public InventoryItem item;<br/>        <br/>        private InventorySystem _inventorySystem;<br/>        private IInventorySystem _inventorySystemAdapter;<br/>        <br/><br/>        void Start()<br/>        {<br/>            _inventorySystem = new InventorySystem();<br/>            _inventorySystemAdapter = new InventorySystemAdapter();<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            if (GUILayout.Button("Add item (no adapter)"))<br/>                _inventorySystem.AddItem(item);<br/><br/>            if (GUILayout.Button("Add item (with adapter)"))<br/>                _inventorySystemAdapter.<br/>                    AddItem(item, SaveLocation.Both);<br/>
        }<br/>    }<br/>}</pre>
<p>We now can build a new inventory system that uses the functionality of an older one provided by a third party. We can continue to pull library updates from the third-party website with confidence and without the need to worry about merge issues. Our system can grow in features while we continue to adapt theirs, and if one day we want to remove their system from our code base and just use our own, we could start the deprecation process by updating the <kbd>adapter</kbd> class.</p>
<h1 id="uuid-59e28481-b807-4615-bb26-87ea32b7cc81">Summary</h1>
<p class="mce-root">In this chapter, we added the Adapter pattern to our toolbox. It's a type of pattern that's very beneficial to have in our back pocket. One of the biggest challenges for a professional programmer is dealing with incompatible systems that are often developed by external vendors or other teams inside an organization. A consistent approach to adapting existing classes can only be helpful, especially when time becomes an issue and it's just faster to reuse old code for new purposes.</p>
<p class="mce-root">In the next chapter, we will review a close cousin of the Adapter, the Facade pattern, which we will use to manage the growing complexity in our code.</p>


            

            
        
    </body></html>