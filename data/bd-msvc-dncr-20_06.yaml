- en: Securing Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务安全
- en: Security is one of the most important cross-cutting concerns for web applications.
    Unfortunately, data breaches of well-known sites seem commonplace these days.
    Taking this into account, information and application security has become critical
    to web applications. For the same reason, secure applications should no longer
    be an afterthought. Security is everyone's responsibility in an organization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是网络应用最重要的横切关注点之一。不幸的是，知名网站的数据泄露似乎已成为家常便饭。考虑到这一点，信息和应用安全对网络应用变得至关重要。同样，安全应用不应再是事后考虑的事情。在组织中，安全是每个人的责任。
- en: Monolithic applications have less surface area when compared to microservices,
    however, microservices are distributed systems by nature. Also, in principle,
    microservices are isolated from each other; hence, well-implemented microservices
    are more secure as compared to monolithic applications. A monolith has different
    attack vectors compared to microservices. The microservice architecture style
    forces us to think differently in the context of security. However, let me tell
    you upfront, microservice security is a complex domain to understand and implement.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务相比，单体应用具有更小的攻击面。然而，微服务本质上是由分布式系统组成的。原则上，微服务是相互隔离的；因此，实施良好的微服务比单体应用更安全。单体与微服务相比有不同的攻击向量。微服务架构风格迫使我们从安全的角度进行不同的思考。然而，我要提前告诉你，微服务安全是一个复杂且难以理解和实施的领域。
- en: Before we dive deep into microservice security, let's understand our approach
    toward it. We will be focusing more on how authentication and authorization (collectively
    referred to as **auth** in the chapter henceforth) work and the options available
    within the .NET ecosystem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨微服务安全之前，让我们了解我们对此的方法。我们将更多地关注认证和授权（在章节中统称为**认证**）的工作方式以及.NET生态系统中的可用选项。
- en: 'We will explore Azure API management and its suitability as an API gateway
    for .NET-based microservice environments; we''ll also see how Azure API management
    can help us protect microservices through its security features. Then, we''ll
    briefly touch base with different, peripheral aspects that have *defense in depth* mechanisms
    for microservice security. We will also discuss the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索Azure API管理及其作为.NET微服务环境API网关的适用性；我们还将看到Azure API管理如何通过其安全功能帮助我们保护微服务。然后，我们将简要介绍为微服务安全提供*深度防御*机制的不同外围方面。我们还将讨论以下主题：
- en: Why are form authentication and older techniques not sufficient?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么表单认证和较老的技术不足够？
- en: Authentication and the available options, including OpenID and Azure Active
    Directory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和可用的选项，包括OpenID和Azure Active Directory
- en: Introducing OAuth 2.0
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍OAuth 2.0
- en: Introducing Azure API management as an API gateway
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Azure API管理作为API网关
- en: Using Azure API management for security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure API管理进行安全
- en: Interservice communication security approaches
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互服务通信安全方法
- en: Container security and other peripheral security aspects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器安全和其他外围安全方面
- en: Security in monolithic applications
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体应用中的安全性
- en: To understand microservice security, let's step back and recall how we used
    to secure .NET monolithic applications. This will help us better grasp why a microservice's
    auth mechanism needs to be different.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解微服务安全，让我们回顾一下我们过去是如何保护.NET单体应用的。这将帮助我们更好地理解为什么微服务的认证机制需要不同。
- en: The critical mechanism to secure applications has always been auth. Authentication
    verifies the *identity* of a user. Authorization manages what a user can or cannot
    access, also known as *permissions*. Encryption, well, that's the mechanism that
    helps you protect data as it passes between the client and server. We're not going
    to discuss encryption too much though, just ensure the data that goes over the
    wire is encrypted everywhere. This can be achieved through the use of the HTTPS
    protocol.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 保护应用的关键机制一直是认证。认证验证用户的*身份*。授权管理用户可以或不可以访问的内容，也称为*权限*。加密，嗯，这是帮助你在客户端和服务器之间传输数据时保护数据的机制。不过，我们不会过多地讨论加密，只需确保所有通过网络传输的数据都进行了加密。这可以通过使用HTTPS协议来实现。
- en: 'The following diagram depicts the flow of a typical auth mechanism in .NET
    monoliths:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了.NET单体中典型认证机制的流程：
- en: '![](img/32f49f3e-6ee8-46b2-bab1-522df1864c8b.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32f49f3e-6ee8-46b2-bab1-522df1864c8b.png)'
- en: In the preceding diagram, we can see that the user enters his or her username
    and password typically through a web browser. Then, this request hits some thin
    layer in a web application that is responsible for auth. This layer or component
    connects to the user credential store, typically an SQL server in the case of
    a .NET application. The auth layer verifies user-supplied credentials against
    the username and password stored in the credential store.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到用户通常通过Web浏览器输入他们的用户名和密码。然后，这个请求击中了Web应用中的一个薄层，该层负责认证。这个层或组件连接到用户凭据存储，在.NET应用的情况下通常是SQL服务器。认证层验证用户提供的凭据与凭据存储中存储的用户名和密码是否匹配。
- en: Once the user credentials are verified for the session, a session cookie gets
    created in the browser. Unless the user has a valid session cookie, he cannot
    access the app. Typically, a session cookie is sent with every request. Within
    these kinds of monolithic applications, modules can freely interact with each
    other since they are in the same process and have in-memory access. This means trust
    is implicit within those application modules so they do not need separate validation
    and verification of requests while talking to each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证了会话的用户凭据，浏览器中就会创建一个会话cookie。除非用户有一个有效的会话cookie，否则他无法访问应用。通常，会话cookie会随每个请求一起发送。在这些类型的单体应用中，模块可以自由地相互交互，因为它们在同一个进程中，并且有内存访问权限。这意味着在这些应用模块之间信任是隐含的，因此它们在相互通信时不需要单独验证和验证请求。
- en: Security in microservices
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的安全性
- en: Now let's look at the case of microservices. By nature, microservices are distributed
    systems. There is not a single instance of an application; rather, there are several
    distinct applications that coordinate with each other in harmony to produce the
    desired output.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看微服务的案例。从本质上讲，微服务是分布式系统。没有单个应用实例；相反，有多个不同的应用，它们和谐地相互协调以产生所需的输出。
- en: Why won't a traditional .NET auth mechanism work?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么传统的 .NET 认证机制不起作用？
- en: 'One of the possible approaches for microservice security might be this: we
    mimic the same behavior as that of the auth layer in a monolith. This could be
    depicted as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务安全性的可能方法之一可能是：我们模仿单体应用中认证层的相同行为。这可以描述如下：
- en: '![](img/9605f3e4-dac1-41d9-ac5a-f72ffbd955ae.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9605f3e4-dac1-41d9-ac5a-f72ffbd955ae.png)'
- en: In this approach, we distributed the auth layer and provided it to all the microservices.
    Since each one is a different application, it will need its own auth mechanism.
    This inherently means that the user credential store is also different for every
    microservice. This raises so many questions, such as how do we keep the auth in
    sync across all services? How can we validate inter-service communication, or
    do we skip it? We do not have satisfactory answers to these questions. Hence,
    this approach does not make sense and just increases complexity. With this approach,
    we cannot even be sure whether it will work in the real world.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们将认证层进行了分布式部署，并将其提供给所有微服务。由于每个都是一个不同的应用，它将需要一个自己的认证机制。这本质上意味着每个微服务的用户凭据存储也是不同的。这引发了许多问题，例如我们如何保持所有服务之间的认证同步？我们如何验证服务间的通信，或者我们是否跳过它？我们对这些问题没有满意的答案。因此，这种方法没有意义，只是增加了复杂性。采用这种方法，我们甚至不能确定它是否能在现实世界中工作。
- en: There is one more factor we need to take into account for modern applications.
    In the microservice world, we need to support native mobile apps and other non-standard
    form factor devices as well as IoT applications. With the significant proliferation
    of native mobile applications, the microservice architecture also needs to support
    secure communication between those clients and microservices. This is different
    from the traditional web browser-based user interface. On mobile platforms, a web
    browser is not part of any native mobile app. This means cookie-based or session-based
    authentication is not possible. So microservices need to support this kind of
    interoperability between client applications. This was never a concern for .NET
    monolithic applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代应用，我们还需要考虑一个额外的因素。在微服务世界中，我们需要支持原生移动应用和其他非标准形态设备，以及物联网应用。随着原生移动应用的显著普及，微服务架构也需要支持客户端和微服务之间的安全通信。这与传统的基于Web浏览器的用户界面不同。在移动平台上，Web浏览器不是任何原生移动应用的一部分。这意味着基于cookie或基于会话的认证是不可能的。因此，微服务需要支持这种客户端应用之间的互操作性。这对于.NET单体应用从未是问题。
- en: In the case of traditional authentication, the browser is responsible for sending
    the cookie upon each request. But we're not using the browser for a native mobile
    app. In fact, we're neither using ASPX pages, nor the form's authentication module.
    For an iOS client or Android, it's something different altogether. What's more,
    we are also trying to restrict unauthorized access to our API. In the preceding
    example, we'd be securing the client, be it an MVC app or a Windows phone app,
    and not the microservice. Moreover, all these mobile client devices are not part
    of the trust subsystem. For every request, we cannot trust that the mobile user
    is indeed the owner; the communication channel is not secured either. So any request
    coming from them cannot be trusted at all.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统认证的情况下，浏览器负责在每次请求时发送 cookie。但我们在原生移动应用中并没有使用浏览器。实际上，我们既没有使用 ASPX 页面，也没有使用表单的认证模块。对于
    iOS 客户端或 Android，情况完全不同。更重要的是，我们还在尝试限制对 API 的未授权访问。在前面的例子中，我们会保护客户端，无论是 MVC 应用还是
    Windows Phone 应用，而不是微服务。此外，所有这些移动客户端设备都不是信任子系统的组成部分。对于每个请求，我们无法信任移动用户确实是所有者；通信通道也没有得到保护。因此，来自他们的任何请求都完全不可信。
- en: But apart from these problems, there's another more conceptual problem we have.
    Why should the application be responsible for authenticating users and authorization?
    Shouldn't this be separated out?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但除了这些问题之外，我们还有一个更概念性的问题。为什么应用程序应该负责认证用户和授权？这不是应该分开的吗？
- en: One more solution to this is using the SAML protocol, but again, this is based
    on SOAP and XML, so not really a good fit for microservices. The complexity of
    the implementation of SAML is also high.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一个方案是使用 SAML 协议，但同样，这基于 SOAP 和 XML，所以并不是微服务的最佳选择。SAML 实现的复杂性也很高。
- en: Therefore, it is evident from the preceding discussion that we need a token-based
    solution. The solution for microservices' auth comes in the form of OpenID Connect
    and OAuth 2.0\. OpenID Connect is the standard for authentication and OAuth 2.0
    is the specification for the authorization. However, this authorization is delegated
    by nature.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从前面的讨论中可以明显看出，我们需要一个基于令牌的解决方案。微服务认证的解决方案以 OpenID Connect 和 OAuth 2.0 的形式出现。OpenID
    Connect 是认证的标准，OAuth 2.0 是授权的规范。然而，这种授权本质上是委托的。
- en: We will see this in detail in further sections. But before that, let's take
    a detour and look at JSON Web Tokens and see why they are significant with respect
    to microservice security.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中详细探讨这一点。但在那之前，让我们暂时偏离一下，看看 JSON Web Tokens，并了解为什么它们在微服务安全方面具有重要意义。
- en: JSON Web Tokens
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Tokens
- en: '**JSON Web Tokens** (**JWT**) is pronounced *JOT*. It is a well-defined JSON
    schema or format to describe the tokens involved in a data exchange process. JWTs
    are described in *RFC 7519*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Web Tokens** (**JWT**) 读作 *JOT*。它是一个定义良好的 JSON 架构或格式，用于描述数据交换过程中涉及的令牌。JWTs
    在 *RFC 7519* 中进行了描述。'
- en: JWTs are not tied to either OpenID Connect or OAuth 2.0\. This means they can
    be used independently, irrespective of OAuth 2.0 or OpenID Connect. OpenID Connect
    mandates the use of a JWT for all the tokens that are exchanged in the process.
    In OAuth 2.0, the use of JWTs isn't mandated, more a kind of implementation format.
    Moreover, the .NET framework has built-in support for JWT.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JWTs 与 OpenID Connect 或 OAuth 2.0 无关。这意味着它们可以独立使用，不受 OAuth 2.0 或 OpenID Connect
    的影响。OpenID Connect 强制在过程中交换的所有令牌都使用 JWT。在 OAuth 2.0 中，JWT 的使用不是强制性的，而更像是一种实现格式。此外，.NET
    框架内置了对 JWT 的支持。
- en: The purpose of a JWT-based security token is to produce a data structure that
    contains information about the issuer and the recipient along with a description
    of the sender's identity. Therefore, tokens should be protected over the wire
    so they cannot be tampered with. To do so, tokens are signed with symmetric or
    asymmetric keys. This means when a receiver trusts the issuer of the token, it
    can also trust the information inside it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基于JWT的安全令牌的目的是生成一个包含发行者、接收者信息以及发送者身份描述的数据结构。因此，令牌应该在传输过程中得到保护，以防止被篡改。为此，令牌使用对称或非对称密钥进行签名。这意味着当接收者信任令牌的发行者时，它也可以信任其中的信息。
- en: 'Here is an example of a JWT:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 JWT 的例子：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the encoded form of a JWT. If we see the same token in decoded form,
    it has three components: header, payload, and signature; they are all separated
    by a period (.). The preceding example token can be decoded as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 JWT 的编码形式。如果我们以解码形式查看相同的令牌，它有三个部分：头部、负载和签名；它们都由点号 (.) 分隔。前面的示例令牌可以按以下方式解码：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'NET v.4.5.1 and onward has built-in support for generating and consuming JWTs.
    You can install JWT support in any .NET application using the package manager
    console with the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 4.5.1及以后的版本内置了对生成和消费JWT的支持。您可以使用包管理控制台使用以下命令在任何.NET应用程序中安装JWT支持：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Visit [https://jwt.io/](https://jwt.io/), where you can view and decode JWTs
    very easily. Moreover, you can add it as part of the Chrome debugger as well,
    which is quite handy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://jwt.io/](https://jwt.io/)，您可以在那里非常容易地查看和解码JWT。此外，您还可以将其添加到Chrome调试器中，这非常方便。
- en: What is OAuth 2.0?
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是OAuth 2.0？
- en: Okay, you might not know what OAuth 2.0 is, but you will have surely used it
    for several websites. Nowadays, many websites allow you to log in with your username
    and password for Facebook, Twitter, or Google accounts. Go to your favorite website,
    for example, the [www.stackoverflow.com](http://www.stackoverflow.com) login page.
    There is a login button that says you can sign in with your Google account, for
    example. When you click on the Google button, it takes you to Google's login page
    along with some of the permissions mentioned. Here you provide your Google username
    and password and click on the Allow button to grant permissions to your favorite
    site. Then, Google redirects you to Stack Overflow and you are logged in with
    appropriate permissions in Stack Overflow. This is merely the end user experience
    for OAuth 2.0 and OpenID Connect.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你可能不知道OAuth 2.0是什么，但你肯定在多个网站上使用过它。如今，许多网站允许你使用Facebook、Twitter或Google账户的用户名和密码登录。例如，访问你喜欢的网站，比如[www.stackoverflow.com](http://www.stackoverflow.com)的登录页面。那里有一个登录按钮，上面写着你可以使用Google账户登录，例如。当你点击Google按钮时，它会带你到Google的登录页面，并显示一些提到的权限。在这里，你提供你的Google用户名和密码，然后点击允许按钮，以授予你喜欢的网站权限。然后，Google将你重定向到Stack
    Overflow，你将使用适当的权限在Stack Overflow上登录。这仅仅是OAuth 2.0和OpenID Connect的最终用户体验。
- en: 'OAuth 2.0 can be best described as a series of specification-turned-authorization
    frameworks. *RFC 6749* defines OAuth as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0可以最好地描述为一系列规范转变为授权框架。*RFC 6749*将OAuth定义为以下内容：
- en: '"The OAuth 2.0 authorization framework enables a third-party application to
    obtain limited access to an HTTP service, either on behalf of a resource owner
    by orchestrating an approval interaction between the resource owner and the HTTP
    service, or by allowing the third-party application to obtain access on its own
    behalf."'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “OAuth 2.0授权框架允许第三方应用程序代表资源所有者通过在资源所有者和HTTP服务之间协调一个批准交互，或者允许第三方应用程序代表自己获取对HTTP服务的有限访问。”
- en: OAuth 2.0 handles authorization on the web, in native mobile applications, and
    all headless server applications (these are nothing more than microservice instances
    in our context). You must be wondering why we are discussing authorization first
    instead of authentication. The reason is that OAuth 2.0 is a delegated authorization
    framework. This means, to complete the authorization flow, it relies on an authentication
    mechanism.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0处理网络、原生移动应用程序以及所有无头服务器应用程序（在我们的语境中，这些不过是微服务实例）。你可能想知道为什么我们先讨论授权而不是认证。原因是OAuth
    2.0是一个委托授权框架。这意味着，为了完成授权流程，它依赖于一个认证机制。
- en: Now let's see some terminology associated with it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些与之相关的术语。
- en: 'OAuth 2.0 roles describe the involved parties in the authorization process:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0角色描述了授权过程中的相关方：
- en: 'Resource: The entity that is getting protected from unintended access and usage.
    This is nothing more than a microservice in our case.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源：这是指从未授权访问和使用的实体。在我们的案例中，这不过是一个微服务。
- en: 'Resource owner: Resource owner is a person or entity who owns the specified
    resource. When a person owns a resource, he or she is an end user.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者：资源所有者是指拥有指定资源的个人或实体。当一个人拥有资源时，他就是最终用户。
- en: 'Client: Client is the term used to refer to all kinds of client applications.
    This refers to any application trying to access the protected resource. In a microservices''
    context, the applications involved are single page applications, web user interface
    clients, and native mobile applications, or even a microservice that is trying
    to access another microservice downstream.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端：客户端是指所有类型的客户端应用程序。这指的是任何试图访问受保护资源的应用程序。在微服务语境中，涉及的应用程序包括单页应用程序、Web用户界面客户端、原生移动应用程序，甚至是一个试图访问下游另一个微服务的微服务。
- en: 'Authorization server: This is the server that hosts the secure token service
    and issues tokens to the client after successfully authenticating the resource
    owner and obtaining permissions from the resource owner or on their behalf.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器：这是托管安全令牌服务并在成功验证资源所有者并从资源所有者或代表他们获得权限后向客户端颁发令牌的服务器。
- en: You may have noticed that OAuth does differentiate between end users and applications
    used by an end user. This is a bit odd but makes perfect sense since it is also
    generally viewed as saying, *I am authorizing this app to perform these actions
    on my behalf*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 OAuth 区分了最终用户和最终用户使用的应用程序。这有点奇怪，但完全合理，因为它也被普遍视为“我正在授权这个应用程序代表我执行这些操作”。
- en: 'The following diagram depicts how these roles interact with each other in the
    general flow of authorization in the OAuth framework:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了这些角色如何在 OAuth 框架中授权的一般流程中相互交互：
- en: '![](img/e58404a3-3107-4236-ba49-b9e8dda72c70.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e58404a3-3107-4236-ba49-b9e8dda72c70.png)'
- en: 'In *step 6*, illustrated in the preceding diagram, the client passes the authorization
    grant to the authorization server. This step is not as simple as it looks. Authorization
    grants are of different types. The grant types represent four, different possible
    use cases for getting access tokens in OAuth 2.0\. If you choose the wrong grant
    type, you might be compromising security:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 6*，如前图所示，客户端将授权授予传递给授权服务器。这一步看起来并不简单。授权授予有多种类型。授权类型代表 OAuth 2.0 中获取访问令牌的四种不同可能的使用场景。如果你选择了错误的授权类型，可能会危及安全：
- en: 'Authorization code: This is the typical OAuth grant used by server-side web
    applications, the one you would use in your ASP.NET apps.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权代码：这是服务器端 Web 应用程序典型使用的 OAuth 授权，你会在你的 ASP.NET 应用程序中使用它。
- en: 'Implicit: Authenticating with a server returns an access token to the browser,
    which can then be used to access resources. This is useful for single page applications
    where communication cannot be private.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式：通过服务器进行身份验证会返回一个访问令牌到浏览器，然后可以用来访问资源。这对于通信不能是私密的单页应用程序很有用。
- en: 'Resource owner password credentials: This requires the user to directly enter
    their username and password in the application. It is useful when you are developing
    a first-party application to authenticate with your own servers. For example,
    a mobile app might use a resource owner grant to authenticate with your own servers.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证：这要求用户直接在应用程序中输入他们的用户名和密码。当你开发一个用于与自己的服务器进行身份验证的第一方应用程序时，这很有用。例如，一个移动应用程序可能会使用资源所有者授权来与你的服务器进行身份验证。
- en: 'Client credentials: This is typically used when the client is acting on its
    own behalf (the client is also the resource owner) or is requesting access to
    protected resources based on an authorization previously arranged with the authorization
    server.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端凭证：这通常用于客户端代表自己（客户端也是资源所有者）或基于与授权服务器预先安排的授权请求访问受保护资源时使用。
- en: What is OpenID Connect?
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 OpenID Connect？
- en: OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. OpenID
    Connect is all about authentication. It allows clients to verify end users based
    on the authentication performed by an authorization server. It is also used to
    obtain basic profile information about the end user in an interoperable and REST-like
    manner.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect 1.0 是 OAuth 2.0 协议之上的简单身份层。OpenID Connect 全部关于身份验证。它允许客户端根据授权服务器执行的身份验证来验证最终用户。它还以可互操作和类似
    REST 的方式获取关于最终用户的基本配置文件信息。
- en: So OpenID Connect allows clients of all types—web-based, mobile, and JavaScript—to
    request and receive information about authenticated sessions and end users. We
    know that OAuth 2.0 defines access tokens. Well, OpenID Connect defines a standardized
    identity token (commonly referred to as **ID token**). The identity token is sent
    to the application so the application can validate who the user is. It defines
    an endpoint to get identity information for that user, such as their name or email
    address. That's the user info endpoint.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，OpenID Connect 允许所有类型的客户端——基于 Web、移动和 JavaScript 的客户端——请求并接收有关经过身份验证的会话和最终用户的信息。我们知道
    OAuth 2.0 定义了访问令牌。那么，OpenID Connect 定义了一个标准化的身份令牌（通常称为 **ID 令牌**）。身份令牌被发送到应用程序，以便应用程序可以验证用户身份。它定义了一个端点，用于获取该用户的信息，例如他们的姓名或电子邮件地址。这就是用户信息端点。
- en: It's built on top of OAuth 2.0, so the flows are the same. It can be used with
    the authorization code grant and implicit grant. It's not possible with the client
    credentials grant, as the client credentials grant is for server-to-server communication.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它建立在 OAuth 2.0 之上，因此流程是相同的。它可以与授权码授权和隐式授权一起使用。由于客户端凭据授权用于服务器到服务器的通信，因此无法使用客户端凭据授权。
- en: There's no end user involved in the process so there's no end user identity
    either. Likewise, it doesn't make sense for the resource owner path of usage or
    process. Now how does that work? Well, instead of only requesting an access token,
    we'll request an additional ID token from the **security token service** (**STS**) that
    implements the OpenID Connect specification. The client receives an ID token,
    and usually, also an access token. To get more information for the authenticated
    user, the client can then send a request to the user info endpoint with the access
    token; this user info endpoint will then return the claims about the new user.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中没有涉及最终用户，因此也没有最终用户身份。同样，对于使用或流程的资源所有者路径来说，这也没有意义。那么它是如何工作的呢？好吧，我们不仅请求访问令牌，还会从实现
    OpenID Connect 规范的 **安全令牌服务**（**STS**）请求一个额外的 ID 令牌。客户端收到一个 ID 令牌，通常还会收到一个访问令牌。为了获取有关已认证用户的更多信息，客户端可以随后使用访问令牌向用户信息端点发送请求；然后该端点将返回关于新用户的声明。
- en: OpenID supports authorization code flow and implicit flow. It also adds some
    more additional protocols, which are discovery and dynamic registration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID 支持授权码流和隐式流。它还增加了一些额外的协议，包括发现和动态注册。
- en: Azure Active Directory
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Active Directory
- en: There are multiple providers for OAuth 2.0 and OpenID Connect 1.0 specifications.
    **Azure Active Directory** (**Azure AD**) is one of them. Azure AD provides organizations
    with enterprise-grade identity management for cloud applications. Azure AD integration
    will give your users a streamlined sign-in experience, and it will help your application
    conform to the IT policy. Azure AD provides advanced security features, such as
    multifactor authentication, and scales really well with application growth. It
    is used in all Microsoft Azure Cloud products, including Office 365, and processes
    more than a billion sign-ins per day.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'OAuth 2.0 和 OpenID Connect 1.0 规范有多个提供者。**Azure Active Directory**（**Azure
    AD**）就是其中之一。Azure AD 为组织提供企业级云应用程序的身份管理。Azure AD 集成将为您的用户提供流畅的登录体验，并帮助您的应用程序符合
    IT 政策。Azure AD 提供高级安全功能，如多因素身份验证，并且随着应用程序的增长而具有良好的可扩展性。它被用于所有 Microsoft Azure
    云产品中，包括 Office 365，并且每天处理超过十亿次登录。 '
- en: One more interesting aspect of traditional .NET environments is that they can
    integrate their organizational Windows Server Active Directory with Azure AD really
    well. This can be done with the Azure AD sync tool or the new capability of pass-through
    authentication. So, organizational IT compliances will still be managed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 .NET 环境的一个有趣方面是，它们可以将组织的 Windows Server Active Directory 与 Azure AD 集成得非常好。这可以通过
    Azure AD 同步工具或新的传递身份验证功能来实现。因此，组织的 IT 合规性仍然会被管理。
- en: Microservice Auth example with OpenID Connect, OAuth 2.0, and Azure AD
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenID Connect、OAuth 2.0 和 Azure AD 的微服务身份验证示例
- en: Now we are well-equipped with all the prerequisite knowledge to start coding.
    Let's try and build a `ToDoList` application. We are going to secure `TodoListService`,
    which represents one of our microservices. In the solution, the `ToDoList` microservice
    is represented by the `TodoListService` project and `ToDoListWebApp` represents
    the server-side web application. It will be easier to follow if you open up the
    Visual Studio solution named `OpenIdOAuthAzureAD.sln` provided with this chapter.
    This example uses the client credentials grant.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了所有先决知识，可以开始编码了。让我们尝试构建一个 `ToDoList` 应用程序。我们将要保护 `TodoListService`，它代表我们的一个微服务。在解决方案中，`ToDoList`
    微服务由 `TodoListService` 项目表示，而 `ToDoListWebApp` 代表服务器端 Web 应用程序。如果您打开本章提供的名为 `OpenIdOAuthAzureAD.sln`
    的 Visual Studio 解决方案，这将更容易理解。此示例使用客户端凭据授权。
- en: Note that, due to the ever-changing nature of Azure portal and the corresponding
    Azure services UI, it is advisable that you use the Azure Service management API
    and automate some of the registration tasks about to follow. However, for learning
    purposes and largely for encouraging developers who are new to Azure or might
    be trying Azure AD for the first time, we are going to follow the Azure portal
    user interface.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 Azure 门户和相应的 Azure 服务 UI 的不断变化，建议您使用 Azure 服务管理 API 并自动化一些即将进行的注册任务。然而，出于学习和鼓励新接触
    Azure 或可能首次尝试 Azure AD 的开发者的目的，我们将遵循 Azure 门户用户界面。
- en: 'Here are the prerequisites:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是先决条件：
- en: Visual Studio 2017 Update 3
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017 更新 3
- en: An Azure subscription (if you don't have this, you can use the free trial account
    for this demo)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Azure 订阅（如果您没有这个，您可以使用此演示的免费试用账户）
- en: 'Azure AD tenant (single-tenant): You can also work with your Azure account''s
    own default directory, which should be different from that of the Microsoft organization'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure AD 租户（单租户）：您也可以使用您 Azure 账户的默认目录，这应该与 Microsoft 组织的不同。
- en: Registration of TodoListService and TodoListWebApp with Azure AD tenant
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure AD 租户注册 TodoListService 和 TodoListWebApp
- en: Now let's look at how to register `TodoListService`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何注册 `TodoListService`。
- en: 'In this step, we will add `TodoListService` with Azure AD tenant. To achieve
    this, log in to the Azure management portal, then do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，我们将使用 Azure AD 租户添加 `TodoListService`。为了实现这一点，请登录到 Azure 管理门户，然后执行以下操作：
- en: 'Click on App registrations. Click on the Add button. It will open the Create
    pane, as depicted here:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用注册”。点击添加按钮。它将打开创建窗格，如图所示：
- en: '![](img/64a8579c-88d4-4915-ba87-4fa8380a541c.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64a8579c-88d4-4915-ba87-4fa8380a541c.png)'
- en: 'Provide all the mandatory details as displayed in the preceding screenshot
    and click on the Create button at the bottom of the Create pane. While we are
    providing a sign-on URL, make sure that you are providing it for your app. In
    our case, `TodoListService` is a microservice, so we won''t have a special sign-in
    URL. Hence, we have to provide the default URL or just the hostname of our microservice.
    Here we are going to run the service from our machine, so the localhost URL will
    be sufficient. You can find the sign-in URL once you right-click on project URL
    under `TodoListService` project and navigate to Web, as shown in the following
    diagram:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供前面截图显示的所有必填详细信息，并在创建窗格的底部点击创建按钮。当我们提供登录 URL 时，请确保您为您的应用程序提供它。在我们的例子中，`TodoListService`
    是一个微服务，因此我们不会有特殊的登录 URL。因此，我们必须提供默认 URL 或只是我们的微服务的主机名。我们将从我们的机器上运行该服务，因此 localhost
    URL 就足够了。您可以在“TodoListService”项目下的项目 URL 上右键单击，然后转到 Web，如图所示：
- en: '![](img/c17fcbdb-a832-45a4-a51a-0be9d55c28c7.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c17fcbdb-a832-45a4-a51a-0be9d55c28c7.png)'
- en: A sign-in URL in Azure portal should have the trailing `/`; otherwise, you may
    face an error, even if you execute all the steps correctly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 门户中的登录 URL 应该有尾随的 `/`；否则，即使您正确执行了所有步骤，也可能遇到错误。
- en: If you deploy your service with the Microsoft Azure App Service plan, you will
    get a URL that is similar to `https://todolistservice-xyz.azurewebsites.net/`.
    You can later change the sign-on URL if you deploy the service on Azure.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用 Microsoft Azure App Service 计划部署您的服务，您将获得一个类似于 `https://todolistservice-xyz.azurewebsites.net/`
    的 URL。如果您在 Azure 上部署服务，您可以稍后更改登录 URL。
- en: Once you click on the Create button, Azure will add the application to your
    Azure AD Tenant. However, there are still a few more details that need to be completed
    for finishing the registration of TodoListService. So navigate to App Registration
    | TodoListService | Properties. You will notice that there are a few more additional
    properties, such as App ID URL, which has been provided now.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦点击创建按钮，Azure 将将应用程序添加到您的 Azure AD 租户中。然而，为了完成 TodoListService 的注册，还需要填写一些更多细节。因此，导航到“应用注册”|“TodoListService”|“属性”。您会注意到还有一些额外的属性，例如
    App ID URL，现在已经提供了。
- en: 'For the App ID URL, enter [`https://[Your_Tenant_Name]/TodoListService`](https://%5BYour_Tenant_Name%5D/TodoListService),
    replacing `[Your_Tenant_Name]` with the name of your Azure AD tenant. Click on
    OK to complete the registration. The final configuration should look like this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 App ID URL，输入 [`https://[Your_Tenant_Name]/TodoListService`](https://[Your_Tenant_Name]/TodoListService)，将
    `[Your_Tenant_Name]` 替换为您的 Azure AD 租户名称。点击确定完成注册。最终的配置应如下所示：
- en: '![](img/084b7590-c707-4eb9-a75c-898ae12cf8b9.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/084b7590-c707-4eb9-a75c-898ae12cf8b9.png)'
- en: 'Now we move on to the registration of TodoListWebApp:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续注册 TodoListWebApp：
- en: First, we register TodoListWebApp. This is necessary since we are going to use
    OpenID Connect to connect to this browser-based web application. So we need to
    establish the trust between the end user, that is, us and TodoListWebApp.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们注册 TodoListWebApp。这是必要的，因为我们打算使用 OpenID Connect 连接到这个基于浏览器的 Web 应用程序。因此，我们需要在最终用户（即我们）和
    TodoListWebApp 之间建立信任。
- en: Click on App registrations. Click on the Add button. It will open up the Create
    pane, as depicted in the following screenshot. Fill in the sign-in URL as `https://localhost:44322/`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用注册”。点击“添加”按钮。它将打开创建面板，如以下屏幕截图所示。填写登录 URL 为 `https://localhost:44322/`。
- en: 'Once again, as in the TodoListService  registration, we will be able to view
    most of the additional properties once we create the web app. So, the final properties
    configuration will look like this:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在 TodoListService 注册过程中，一旦创建 Web 应用程序，我们就能查看大部分附加属性。所以，最终的属性配置将看起来像这样：
- en: '![](img/4a21493b-5c13-4e8c-b04b-cb687e1f607b.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a21493b-5c13-4e8c-b04b-cb687e1f607b.png)'
- en: 'A setting to note here is the logout URL: we set it as `https://localhost:44322/Account/EndSession`.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里需要注意的一个设置是注销 URL：我们将其设置为 `https://localhost:44322/Account/EndSession`。
- en: This is because after ending the session, Azure AD will redirect the user to
    this URL. For the App ID URL, enter `https://[Your_AD_Tenant_Name]/TodoListWebApp`,
    replacing [`Your_AD_Tenant_Name`] with the name of your Azure AD tenant. Click
    on OK to complete the registration.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为在结束会话后，Azure AD 将将用户重定向到这个 URL。对于 App ID URL，输入 `https://[Your_AD_Tenant_Name]/TodoListWebApp`，将
    `[Your_AD_Tenant_Name]` 替换为您的 Azure AD 租户名称。点击“确定”以完成注册。
- en: 'Now we need to set up permissions between TodoListWebApp so that it can call
    our microservice: TodoListService. So, navigate to App Registration | TodoListWebApp | Required
    Permissions again and click on Add. Now click on 1 Select an API. This navigation
    is displayed in the following screenshot. You need to key in ToDoListService for
    it to show up in the API pane:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在 TodoListWebApp 中设置权限，以便它可以调用我们的微服务：TodoListService。因此，再次导航到“应用注册”|“TodoListWebApp”|“必需权限”并点击“添加”。现在点击“1
    选择一个 API”。此导航在以下屏幕截图中显示。您需要键入 ToDoListService 以使其在 API 面板中显示：
- en: '![](img/46044531-310c-4a25-aa0d-29b222d2bf12.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46044531-310c-4a25-aa0d-29b222d2bf12.png)'
- en: Now you will be able to view the Enable Access pane, where you have to tick
    for Access TodoListService Permissions under the Delegated Permissions, and Done
    under the Add API access pane. This will save the permissions.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将能够查看“启用访问”面板，在该面板下，您需要在“委托权限”下勾选“访问 TodoListService 权限”，并在“添加 API 访问”面板下勾选“完成”。这将保存权限。
- en: Generation of AppKey for TodoListWebApp
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 TodoListWebApp 生成 AppKey
- en: Another important step for registration is adding `client_secret`, which is
    necessary to establish trust between Azure AD and TodoListWebApp. This `client_secret`
    is generated only once and configured in the web application. To generate this
    key, navigate to App Registrations | TodoListWebApp | Keys. Then, add the description
    as `AppKey` and click on Save. Once the key is saved, the value of the key is
    autogenerated by Azure and will be displayed next to the description. This key
    is displayed only once, so you have to immediately copy it and save it for later
    use. We will be keeping this key in the `web.config` file of TodoListWebApp in
    this case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注册过程中的另一个重要步骤是添加 `client_secret`，这是在 Azure AD 和 TodoListWebApp 之间建立信任所必需的。这个
    `client_secret` 只生成一次，并在 Web 应用程序中进行配置。要生成这个密钥，请导航到“应用注册”|“TodoListWebApp”|“密钥”。然后，将描述添加为“AppKey”并点击保存。一旦密钥保存，Azure
    将自动生成密钥值，并将其显示在描述旁边。这个密钥只会显示一次，所以您必须立即复制并保存以供以后使用。在这种情况下，我们将把这个密钥保存在 TodoListWebApp
    的 `web.config` 文件中。
- en: 'The key stored will be displayed on the Azure portal as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的密钥将在 Azure 门户中如下显示：
- en: '![](img/a983ea10-4845-4d3d-809f-d39af7965390.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a983ea10-4845-4d3d-809f-d39af7965390.png)'
- en: For production-grade applications, it is a bad idea to keep `client_Secret`
    and all such critical key values in `web.config`. It is good practice to keep
    them encrypted and isolated from applications. For such purposes, in production-grade
    applications, you can use Azure key-vault ([https://azure.microsoft.com/en-us/services/key-vault/](https://azure.microsoft.com/en-us/services/key-vault/))
    to keep all your keys protected. Another advantage of a key vault is that you
    can manage the keys according to the environment, such as dev-test-staging and
    production.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产级应用程序，将 `client_Secret` 和所有此类关键密钥值保留在 `web.config` 中是一个坏主意。良好的做法是将它们加密并与应用程序隔离。为此目的，在生产级应用程序中，您可以使用
    Azure Key Vault ([https://azure.microsoft.com/en-us/services/key-vault/](https://azure.microsoft.com/en-us/services/key-vault/))
    来保护所有密钥。密钥库的另一个优点是您可以按环境管理密钥，例如 dev-test-staging 和生产。
- en: Configuring Visual Studio solution projects
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Visual Studio 解决方案项目
- en: First, we look at how to configure this with the `TodoListService` project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看如何使用 `TodoListService` 项目进行配置。
- en: 'Open the `web.config` file and replace the following keys:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `web.config` 文件并替换以下密钥：
- en: Search for the `ida:Tenant` key. Replace its value with your AD tenant name,
    for example, `contoso.onmicrosoft.com`. This will also be part of any of the application's
    APP ID URL.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `ida:Tenant` 密钥。将其值替换为您的 AD 租户名称，例如，`contoso.onmicrosoft.com`。这也将成为应用程序 APP
    ID URL 的一部分。
- en: Replace the `ida:Audience ` key. Replace its value with `https://[Your_AD_Tenant_Name]/TodoListService`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换 `ida:Audience` 密钥。将其值替换为 `https://[您的 AD 租户名称]/TodoListService`。
- en: Replace `[Your_AD_Tenant_Name]` with the name of your Azure AD tenant.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `[您的 AD 租户名称]` 替换为您的 Azure AD 租户名称。
- en: Now let's see how to configure this with the `TodoListWebApp` project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 `TodoListWebApp` 项目进行配置。
- en: 'Open the `web.config` file and find and replace the following keys with the
    provided values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `web.config` 文件并找到并替换以下密钥，使用提供的值：
- en: Replace `todo:TodoListResourceid` with `https://[Your_Tenant_Name]/TodoListService`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `todo:TodoListResourceid` 替换为 `https://[您的租户名称]/TodoListService`。
- en: Replace `todo:TodoListBaseAddress` with `https://localhost:44321/`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `todo:TodoListBaseAddress` 替换为 `https://localhost:44321/`。
- en: Replace `ida:ClientId` with the application ID of ToDoListWebApp. You can get
    it by navigating to App Registration | TodoListWebApp.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ida:ClientId` 替换为 ToDoListWebApp 的应用程序 ID。您可以通过导航到 App Registration | TodoListWebApp
    获取它。
- en: Replace `ida:AppKey` with `client_secret` that we generated in step 2 of the
    process of registering TodoListWebApp. If you missed noting this key, you need
    to delete the previous key and generate a new key.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ida:AppKey` 替换为在注册 TodoListWebApp 的过程中步骤 2 中生成的 `client_secret`。如果您错过了记录此密钥，您需要删除之前的密钥并生成一个新的密钥。
- en: Replace `ida:Tenant` with your AD tenant name, for example, `contoso.onmicrosoft.com`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ida:Tenant` 替换为您的 AD 租户名称，例如，`contoso.onmicrosoft.com`。
- en: Replace `ida:RedirectUri` with the URL you want the application to redirect
    to when the user signs out of TodoListWebApp. In our case, the default is `https://localhost:44322/` since
    we want the user to navigate to the home page of the application.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ida:RedirectUri` 替换为当用户从 TodoListWebApp 登出时应用程序要重定向到的 URL。在我们的例子中，默认是 `https://localhost:44322/`，因为我们希望用户导航到应用程序的主页。
- en: Generate client certificates on IIS Express
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 IIS Express 上生成客户端证书
- en: Now `TodoListService` and `TodoListWebApp` will talk over a secure channel.
    To establish a secure channel, `ToDoListWebApp` needs to trust the client certificate.
    Both services are hosted on the same machine and run on IIS Express.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `TodoListService` 和 `TodoListWebApp` 将通过安全通道进行通信。为了建立安全通道，`ToDoListWebApp`
    需要信任客户端证书。这两个服务都托管在同一台机器上，并在 IIS Express 上运行。
- en: 'To configure your computer to trust the IIS Express SSL certificate, open the
    PowerShell command window as an administrator. Query your personal certificate
    store to find the thumbprint of the certificate for `CN=localhost`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置计算机信任 IIS Express SSL 证书，以管理员身份打开 PowerShell 命令窗口。查询您的个人证书存储以找到 `CN=localhost`
    证书的指纹：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, add the certificate to the trusted root store:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将证书添加到受信任的根存储中：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding set of instructions will add a client certificate to the local
    machine's certificate store.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上一组指令将客户端证书添加到本地计算机的证书存储中。
- en: Running both the applications
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行两个应用程序
- en: 'We are done with all those tedious configuration screens and replacing of keys.
    Excited? But before you hit *F5*, set `ToDoListService` and `ToDoListWebApp` as
    startup projects. Once this is done, we can safely run our application and be
    greeted with the landing page of our application. If you click on the Sign-in
    button, you will be redirected to [login.microsoftonline.com](http://login.microsoftonline.com); this represents
    the Azure AD login. Once you are able to log in, you will see the landing page
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了所有那些繁琐的配置屏幕和密钥替换。兴奋吗？但在你按下 *F5* 之前，将 `ToDoListService` 和 `ToDoListWebApp`
    设置为启动项目。一旦完成，我们就可以安全地运行我们的应用程序，并欢迎来到我们应用程序的登录页面。如果你点击登录按钮，你将被重定向到 [login.microsoftonline.com](http://login.microsoftonline.com)；这代表
    Azure AD 登录。一旦你能够登录，你将看到以下登录页面：
- en: '![](img/e29198da-d86b-4acc-a219-c9565624f490.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e29198da-d86b-4acc-a219-c9565624f490.png)'
- en: You can observe network traffic and URL redirection when you log in to the application
    to study a detailed exchange of ID tokens and get an access token. If you explore
    the application through the ToDoList menu, you will be able to access the ToDoList
    screen as well as add items to ToDoList. This is where our `TodoListService` microservice
    is getting called, as well as getting authorization permissions from the `TodoWebApp`
    web application. If you explore the profile menu, you will see the ID token return
    along with your first name, last name, and email ID, which shows OpenID Connect
    in action.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你登录应用程序以研究 ID 令牌的详细交换并获取访问令牌时，你可以观察到网络流量和 URL 重定向。如果你通过 ToDoList 菜单探索应用程序，你将能够访问
    ToDoList 屏幕以及向 ToDoList 添加项目。这就是我们的 `TodoListService` 微服务被调用的地方，以及从 `TodoWebApp`
    网络应用程序获取授权权限的地方。如果你探索配置文件菜单，你会看到 ID 令牌与你的名字、姓氏和电子邮件 ID 一起返回，这显示了 OpenID Connect
    的实际应用。
- en: If you want to explore the code in detail, `TodoListController.cs` in the TodoListService
    project, `Startup.Auth.cs`, and `TodoListController.cs` contain interesting bits
    of code along with explanatory comments.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要详细探索代码，`TodoListService` 项目的 `TodoListController.cs`、`Startup.Auth.cs`
    和 `TodoListController.cs` 包含了一些有趣的代码片段以及解释性注释。
- en: In this example, we used OAuth and OpenID Connect to secure a browser-based
    user interface, a web application, and a microservice. Things might be different if
    we have an API gateway between the user interface web app and microservice. In
    this case, we need to establish trust between the web app and API gateway. Also,
    we have to pass the ID token and access token from the web app to the API gateway.
    This, in turn, passes the tokens to the microservice. However, it is not feasible
    to cover the discussion and implementation in this chapter's scope.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 OAuth 和 OpenID Connect 来保护基于浏览器的用户界面、网络应用程序和微服务。如果我们有一个 API 网关位于用户界面网络应用程序和微服务之间，事情可能会有所不同。在这种情况下，我们需要在
    Web 应用程序和 API 网关之间建立信任。此外，我们必须将 ID 令牌和访问令牌从 Web 应用程序传递到 API 网关。然后，它将这些令牌传递到微服务。然而，在本章的范围内讨论和实现这一点是不切实际的。
- en: Azure API management as an API gateway
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure API 管理作为一个 API 网关
- en: Another important pattern in microservices' implementation is **Backends For
    Frontends** (**BFF**). This pattern was introduced and made popular by Sam Newman.
    The actual implementation of the BFF pattern is done by introducing the API gateway
    between various types of clients and microservices.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务实现中的另一个重要模式是 **前后端分离**（**BFF**）。这个模式是由 Sam Newman 引入并推广的。BFF 模式的实际实现是通过在各类客户端和微服务之间引入
    API 网关来完成的。
- en: 'This is depicted in the following diagram:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下图中表示：
- en: '![](img/d10acc55-d9a0-4d01-806d-95039ad04cfc.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d10acc55-d9a0-4d01-806d-95039ad04cfc.png)'
- en: Azure API Management (henceforth referred to as **Azure APIM** or just **APIM**
    ) is just the right fit, and it can act as an API gateway in .NET-based microservice
    implementation. Since Azure APIM is one of the cloud services, it is ultra-scalable
    and can be integrated well within the Azure ecosystem. In the current chapter,
    we will focus on the following features of Azure APIM.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Azure API Management（以下简称 **Azure APIM** 或 **APIM**）正是合适的选择，它可以在基于 .NET 的微服务实现中充当
    API 网关。由于 Azure APIM 是云服务之一，它具有超强的可扩展性，并且可以很好地集成到 Azure 生态系统中。在本章中，我们将重点关注 Azure
    APIM 的以下功能。
- en: 'Azure APIM is logically divided into three parts:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Azure APIM 在逻辑上分为三个部分：
- en: 'API gateway: API gateway is merely a proxy between client applications and
    services. It is responsible for the following functionalities; these are mainly
    used by various applications to talk to microservices:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关：API网关仅仅是客户端应用程序和服务之间的代理。它负责以下功能；这些主要用于各种应用程序与微服务通信：
- en: Accepts API calls and routes them to your backends
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受API调用并将它们路由到您的后端
- en: Verifies API keys, JWTs, and certificates
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证API密钥、JWT和证书
- en: Supports auth through Azure AD and OAuth 2.0 access token
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持通过Azure AD和OAuth 2.0访问令牌进行身份验证
- en: Enforces usage quotas and rate limits
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行使用配额和速率限制
- en: Transforms your API on the fly without code modifications
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需代码修改即可即时转换API
- en: Caches backend responses where set up
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存后端响应的设置位置
- en: Logs call metadata for analytics purposes
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为分析目的记录调用元数据
- en: 'Publisher portal: This is the administrative interface to organize and publish
    an API program. It is mainly used by microservice developers to make microservices/APIs
    available to API consumers or client applications. Through this, API developers
    can:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者门户：这是组织并发布API程序的行政接口。它主要用于微服务开发者使微服务/API可供API消费者或客户端应用程序使用。通过这种方式，API开发者可以：
- en: Define or import API schema
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义或导入API模式
- en: Package APIs into products
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将API打包成产品
- en: Set up policies such as quotas or transformations on the APIs
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在API上设置策略，如配额或转换
- en: Get insights from analytics
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从分析中获得洞察
- en: Manage users
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户
- en: 'Developer portal: This serves as the main web presence for API consumers where
    they can do the following:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者门户：这作为API消费者的主要网络存在，他们可以执行以下操作：
- en: Read the API documentation
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读API文档
- en: Try out an API via the interactive console
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交互式控制台尝试API
- en: Create an account and subscribe to it to get the API keys
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建账户并订阅以获取API密钥
- en: Access analytics on their own usage
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析它们自己的使用情况
- en: Azure APIM comes with an easy-to-follow user interface and good documentation.
    Azure API management also comes with its REST API, hence all the capabilities
    of the Azure APIM portal, which you see can see, can be programmatically achieved
    by Azure REST API endpoint available for Azure APIM.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Azure APIM附带易于遵循的用户界面和良好的文档。Azure API管理还附带其REST API，因此您在Azure APIM门户中看到的所有功能都可以通过Azure
    REST API端点以编程方式实现。
- en: 'Now, let''s quickly look at some security-related concepts in Azure APIM and
    how they can be used in microservices:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速了解一下Azure APIM中的一些安全相关概念以及它们如何在微服务中使用：
- en: 'Products: Products are merely a collection of APIs. They also contain usage
    quota and terms of use.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品：产品仅仅是API的集合。它们还包含使用配额和使用条款。
- en: 'Policies: Policies are dynamic security features of API management. They allow
    the publisher to change the behavior of the API through configuration. Policies
    are a collection of statements that are executed sequentially upon the request
    or response of an API. API management is fundamentally a proxy that is sitting
    between our microservices hosted in Azure and client applications. By virtue of
    the fact that it is an intermediate layer, it is able to provide additional services.
    These additional services are defined in a declarative XML-based syntax called
    **policies**. Azure APIM allows various policies. In fact, you can compose your
    own custom policies by combining the existing ones. A few of the important policies
    are as follows:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略：策略是API管理的动态安全功能。它们允许发布者通过配置更改API的行为。策略是在API请求或响应上顺序执行的语句集合。API管理本质上是一个代理，位于我们托管在Azure中的微服务和客户端应用程序之间。由于它是一个中间层，因此能够提供额外的服务。这些额外服务是在称为**策略**的声明性XML语法中定义的。Azure
    APIM允许各种策略。实际上，您可以通过组合现有的策略来创建自己的自定义策略。以下是一些重要的策略：
- en: 'Access restriction policies:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问限制策略：
- en: 'Check the HTTP header: This policy checks whether a specific HTTP header or
    its value exists in every request received by Azure APIM.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查HTTP头：此策略检查是否每个接收到的Azure APIM请求中存在特定的HTTP头或其值。
- en: 'Limit call rate by subscription: This policy provides allow or deny access
    to the microservice based on the number of times the specific service has been
    called on a per subscription basis.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过订阅限制调用速率：此策略根据每个订阅中特定服务被调用的次数，允许或拒绝对微服务的访问。
- en: 'Restrict caller IPs: This policy refers to white-boxing of IP addresses so
    only known IPs can access the services.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制调用者IP：此策略指的是IP地址的白盒化，因此只有已知的IP可以访问服务。
- en: 'Set usage quota by subscription: This policy allows a number of calls. It allows
    you to enforce a renewable or lifetime call volume and/or bandwidth quota on a
    per subscription basis.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按订阅设置使用配额：此策略允许一定数量的调用。它允许您在每个订阅的基础上强制执行可续订或终身调用量以及/或带宽配额。
- en: 'Validate JWT: This policy validates the JWT token parameter that is used for
    auth in applications.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证JWT：此策略验证用于应用程序认证的JWT令牌参数。
- en: 'Authentication policies:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证策略：
- en: Authenticate with basic : This policy helps apply basic authentication over
    the incoming request.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本认证进行认证：此策略有助于在入站请求上应用基本认证。
- en: 'Authenticate with client certificate: This policy helps carry out authentication
    of a service that is behind the API gateway, using client certificates.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端证书进行认证：此策略有助于使用客户端证书对API网关后面的服务进行认证。
- en: 'Cross domain policies:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨域策略：
- en: 'Allow cross-domain calls: This policy enables us to make CORS requests through
    Azure APIM.'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许跨域调用：此策略使我们能够通过Azure APIM进行CORS请求。
- en: 'CORS : This adds CORS support to an endpoint or a microservice to allow cross-domain
    calls from browser-based web applications.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CORS：这为端点或微服务添加了CORS支持，允许基于浏览器的Web应用程序进行跨域调用。
- en: 'JSONP: The JSONP policy adds **JSON padding** (**JSONP**) support to an endpoint
    or entire microservice to allow cross-domain calls from Java Script web applications.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSONP：JSONP策略为端点或整个微服务添加了**JSON填充**（**JSONP**）支持，以允许Java Script Web应用程序进行跨域调用。
- en: 'Transformation policies:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换策略：
- en: 'Mask URLs in content: This policy masks URLs in response; it does so via Azure
    APIM.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内容中遮蔽URL：此策略通过Azure APIM遮蔽响应中的URL。
- en: 'Set backend service: This policy alters the behavior of the backend service
    of an incoming request.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置后端服务：此策略改变了入站请求的后端服务行为。
- en: Another great thing about policies is they can be applied for inbound and outbound
    requests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 策略的另一个优点是它们可以应用于入站和出站请求。
- en: Rate limit and quota policy example
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速率限制和配额策略示例
- en: 'In the preceding section, we saw what is meant by a policy. Now let''s see
    an example. The following is one of the quota policies applied for an endpoint:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了策略的含义。现在让我们看看一个例子。以下是一个应用于端点的配额策略之一：
- en: '[PRE5]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we are limiting incoming requests (inbound) from a single user.
    So, an API user can only make `100` calls within `60` seconds. If they try to
    make more calls within that duration, the user will get an error with status code
    `429`, which basically states *Rate limit is exceeded*. Also, we are assigning
    the quota limit of `200` calls in a year for the same user. This kind of throttling
    behavior is a great way to protect microservices from unwanted requests and even
    DOS attacks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在限制来自单个用户的入站请求（入站）。因此，API用户只能在60秒内进行`100`次调用。如果他们在该时间段内尝试进行更多调用，用户将收到状态码为`429`的错误，这基本上表示*速率限制已超过*。此外，我们为同一用户分配了每年`200`次的配额限制。这种节流行为是保护微服务免受不受欢迎的请求甚至DOS攻击的好方法。
- en: Azure APIM also supports Auth with OAuth 2.0 and OpenID Connect. Inside the
    publisher portal, you can easily see OAuth and OpenID Connect tabs to configure
    the providers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Azure APIM还支持使用OAuth 2.0和OpenID Connect进行认证。在发布者门户中，您可以轻松地看到OAuth和OpenID Connect选项卡以配置提供者。
- en: Container security
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器安全
- en: Docker is a big part of the containerization of applications used in the industry.
    With the widespread usage of containers, it is evident that we need to have effective
    security measures around containers. If we take a look at the internal architecture
    of containers, they are quite close to the host operating system kernel.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是工业应用容器化的一个重要部分。随着容器的大规模使用，很明显，我们需要在容器周围采取有效的安全措施。如果我们看一下容器的内部架构，它们与宿主操作系统的内核非常接近。
- en: 'Docker applies the principle of least privilege to provide isolation and reduce
    the attack surface. Despite the advances, the following points will help you understand
    the security measures you can take for containers:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Docker应用了最小权限原则来提供隔离并减少攻击面。尽管取得了进展，以下要点将帮助您了解可以为容器采取的安全措施：
- en: Ensure all the container images used for microservices are signed and originate
    from a trusted registry
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有用于微服务的容器镜像都已签名并来自受信任的注册表
- en: Harden the host environment, the daemon process, and images
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强宿主环境、守护进程和镜像的安全性
- en: Follow the principle of least privilege and do not elevate access to access
    devices
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循最小权限原则，不要提升对访问设备的访问权限
- en: Use control groups in Linux to keep tabs on resources, such as memory, I/O,
    and CPU
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Linux中的控制组来监控资源，如内存、I/O和CPU。
- en: Even though containers live for a very short duration, logging all of the container
    activity is advisable and important to understand for post analysis
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管容器生命周期非常短暂，但记录所有容器活动是建议的，并且对于后续分析非常重要。
- en: If possible, integrate the container scanning process with tools, such as Aqua
    ([http://www.aquasec.com](http://www.aquasec.com)) or Twistlock ([https://www.twistlock.com](https://www.twistlock.com))
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，将容器扫描过程与工具集成，例如Aqua ([http://www.aquasec.com](http://www.aquasec.com))
    或 Twistlock ([https://www.twistlock.com](https://www.twistlock.com))。
- en: Other security best practices
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他安全最佳实践
- en: 'The microservice architectural style is new, although some of the security
    practices around the infrastructure and writing secure code are still applicable.
    In this section, let''s discuss some of these practices:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构风格是新的，尽管围绕基础设施和编写安全代码的一些安全实践仍然适用。在本节中，让我们讨论一些这些实践：
- en: 'Standardization of libraries and frameworks: There should be a process to introduce
    new libraries and frameworks or tools in the development process. This will ease
    out patching in case any vulnerability is found; it will also minimize the risks
    introduced by ad hoc implementation of libraries or tools around development.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库和框架的标准化：在开发过程中引入新的库、框架或工具应该有一个流程。这将简化补丁的修复，如果发现任何漏洞；它也将最小化由开发中临时实施的库或工具带来的风险。
- en: 'Regular vulnerability identification and mitigation: Using the industry standard
    vulnerability scanner to scan the source code and binaries should be a regular
    part of development. The findings and observations should be addressed as equally
    as functional defects.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期漏洞识别和缓解：使用行业标准的安全扫描器扫描源代码和二进制文件应该是开发过程中的一个常规部分。发现和观察结果应该像功能缺陷一样得到处理。
- en: 'Third-party audits and pen testing: External audits and penetration testing
    exercises are immensely valuable. There should be a regular practice of conducting
    such exercises. This is quite essential in applications where mission critical
    or sensitive data is handled.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方审计和渗透测试：外部审计和渗透测试练习非常有价值。应该定期进行此类练习。这对于处理关键任务或敏感数据的应用程序来说至关重要。
- en: 'Logging and monitoring: Logging is quite a useful technique for detecting and
    recovering from attacks. Having the capability of aggregating logs from different
    systems is essential in the case of microservices. Tools such as Riverbed, AppDynamics,
    and Splunk are quite useful in this space.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和监控：日志是一种非常有用的技术，可以用于检测和从攻击中恢复。在微服务的情况下，能够聚合来自不同系统的日志是必不可少的。Riverbed、AppDynamics和Splunk等工具在这个领域非常有用。
- en: 'Firewalls: Having one or more firewall at network boundaries is always beneficial.
    Firewall rules should be properly configured.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙：在网络边界拥有一个或多个防火墙总是有益的。防火墙规则应该配置得当。
- en: 'Network segregation: Network partitioning is constrained and limited in the
    case of monoliths. However, with microservices, we need to logically create different
    network segments and subnets. Segmentation based on microservices'' interaction
    patterns can be very effective to keep and develop additional security measures.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络隔离：在单体架构的情况下，网络分区是受限制和有限的。然而，在微服务架构中，我们需要逻辑上创建不同的网络段和子网。基于微服务交互模式的分区可以非常有效地保持和发展额外的安全措施。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The microservice architectural style, being distributed by design, gives us
    better options to protect valuable business-critical systems. Traditional .NET-based
    authentication and authorization techniques are not sufficient and cannot be applied
    to the microservice world. We also saw why secure token-based approaches, such
    as OAuth 2.0 and OpenID Connect 1.0, are becoming concrete standards for microservice
    authorization and authentication. If you want to have more general information
    related to security, do visit **Open Web Application Security Project** (**OWASP**)
    at [http://www.owasp.org](http://www.owasp.org) and Microsoft Security development
    life cycle at [https://www.microsoft.com/en-us/sdl/](https://www.microsoft.com/en-us/sdl/).
    Azure AD can support OAuth 2.0 and OpenID Connect 1.0 very well. Azure API Management
    can also act as an API gateway in microservices' implementation and also provide
    nifty security features, such as policies.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构风格，由于其设计上的分布式特性，为我们提供了更好的保护宝贵业务关键系统的选项。传统的基于 .NET 的身份验证和授权技术不足以应用在微服务世界中。我们也看到了为什么基于安全令牌的方法，如
    OAuth 2.0 和 OpenID Connect 1.0，正在成为微服务授权和认证的实体标准。如果您想了解更多与安全相关的通用信息，请访问**开放网络应用安全项目**（**OWASP**）的网站
    [http://www.owasp.org](http://www.owasp.org) 和微软安全开发生命周期 [https://www.microsoft.com/en-us/sdl/](https://www.microsoft.com/en-us/sdl/)。Azure
    AD 可以很好地支持 OAuth 2.0 和 OpenID Connect 1.0。Azure API 管理还可以在微服务的实现中充当 API 网关，并提供诸如策略等便捷的安全功能。
- en: Azure AD and Azure API management provide quite a few powerful features to monitor
    and log the requests received. This will be quite useful, not only for security
    but also for tracing and troubleshooting scenarios. We will see logging, monitoring,
    and the overall instrumentation around troubleshooting of microservices in the
    next chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Azure AD 和 Azure API 管理提供了许多强大的功能来监控和记录接收到的请求。这对安全和追踪及故障排除场景都将非常有用。我们将在下一章中看到关于微服务故障排除的日志记录、监控和整体仪表化。
