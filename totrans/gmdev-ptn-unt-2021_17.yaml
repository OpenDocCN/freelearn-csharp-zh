- en: Adapting Systems with an Adapter
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器适配系统
- en: In a world full of different types of cables and plugs, we have all become accustomed
    to the concept of adapters. The Adapter pattern will be one of those patterns
    that will be easy for you to grasp because it correlates so perfectly with our
    real-world experiences with technology. The Adapter pattern's name perfectly reveals
    its core purpose; it offers us a way to seamlessly use old code with new code
    by adding an interface between the code that will act as an adapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个充满各种类型电缆和插头的世界中，我们都已经习惯了适配器的概念。适配器模式将是那些你容易掌握的模式之一，因为它与我们在技术领域的真实世界经验完美相关联。适配器模式的名字完美地揭示了其核心目的；它通过在充当适配器的代码之间添加一个接口，为我们提供了一种无缝使用旧代码与新代码的方法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the Adapter pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解适配器模式
- en: Implementing the Adapter pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现适配器模式
- en: The examples presented in this chapter are skeleton code. It's simplified for
    learning purposes so we can focus on the structure of the pattern. It might not
    be optimized or contextualized enough to be used as is in your project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的示例是骨架代码。为了学习目的而简化，以便我们可以专注于模式的结构。它可能没有足够优化或上下文化，不能直接用于你的项目。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The following chapter is hands-on, so you will need to have a basic understanding
    of Unity and C#.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节是实践性的，因此你需要对Unity和C#有一个基本的了解。
- en: The code files of this chapter can be found on GitHub: [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14)
    [](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14)
    [](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter14)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码是如何在行动中应用的：
- en: '[https://bit.ly/3wBHqkX](https://bit.ly/3wBHqkX)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3wBHqkX](https://bit.ly/3wBHqkX)'
- en: Understanding the Adapter pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解适配器模式
- en: As its name implies, the Adapter pattern adapts two incompatible interfaces;
    like a plug adapter, it doesn't modify what it adjusts but bridges one interface
    with another. This approach can be beneficial when dealing with legacy code that
    you cannot refactor due to its fragility, or when you need to add features to
    a third-party library but don't want to modify it to avoid issues when upgrading
    it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，适配器模式适配两个不兼容的接口；就像插头适配器一样，它不会修改它调整的内容，而是将一个接口与另一个接口连接起来。当处理无法重构的脆弱遗留代码时，或者当你需要向第三方库添加功能但不想修改它以避免升级时，这种方法可能是有益的。
- en: 'Here''s a quick breakdown of the two main approaches to implementing the Adapter
    pattern:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两种实现适配器模式的主要方法的快速概述：
- en: '**Object Adapter**: In this version, the pattern uses object composition, and
    the adapter acts as a wrapper around the adapted object. It''s helpful if we have
    a class that doesn''t have the methods we require, but we can''t modify it directly.
    The Object Adapter adopts the methods of the original class and adapts them to
    what we need.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象适配器**：在这个版本中，模式使用对象组合，适配器作为被适配对象的包装器。如果我们有一个没有我们需要的方法的类，但我们不能直接修改它，这很有帮助。对象适配器采用原始类的方
    法并将其适配到我们所需要的。'
- en: '**Class Adapter**: In this version of the pattern, the adapter uses inheritance
    to adapt the interface of an existing class to that of another. It''s useful when
    we need to adjust a class so it can work with others but can''t modify it directly.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类适配器**：在这个模式的版本中，适配器使用继承来适配现有类的接口以适应另一个接口。当我们需要调整一个类以便它可以与其他类一起工作，但不能直接修改它时，这很有用。'
- en: In our code example, we will use a permutation of the Class Adapter as it's
    more challenging to learn. If we understand the Class Adapter version, then we
    can extrapolate an understanding of the Object Adapter version.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们将使用类适配器的一种变体，因为它更具挑战性。如果我们理解了类适配器版本，那么我们可以推断出对象适配器版本的理解。
- en: 'Let''s take a look at a side-by-side diagram of the Object and Class Adapters;
    the core differences are subtle, but the similarities are apparent:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看对象适配器和类适配器的并排图；核心差异微妙，但相似之处明显：
- en: '![](img/82dbcfc8-0321-4c29-90ec-32dbf28f35e9.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82dbcfc8-0321-4c29-90ec-32dbf28f35e9.png)'
- en: Figure 14.1 – Diagram of a replay system
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 重放系统图
- en: As you can see, in both cases, the **Adapter** class is positioned between the **Client** and
    the adapted entity (**Adaptee**). But the Class Adapter establishes a relationship
    with the Adaptee through inheritance. In contrast, the Object Adapter uses composition
    to wrap an instance of the Adaptee for adaption.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在两种情况下，**适配器**类都位于**客户端**和适配实体（**适配者**）之间。但是，类适配器通过继承与适配者建立关系。相比之下，对象适配器使用组合来包装适配者的一个实例以进行适配。
- en: In both cases, the entity that we are adapting is not modified. And the client
    is not aware of what we are adapting; it just knows that it has a consistent interface
    to communicate with the adapted object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们正在适配的实体没有被修改。客户端也不知道我们在适配什么；它只知道它有一个一致的接口来与适配对象通信。
- en: Composition and inheritance are ways to define relationships between objects;
    they describe how they relate to each other. And that difference in the relationship
    structure determines in part the difference between the Object and Class Adapters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 组合和继承是定义对象之间关系的方法；它们描述了它们如何相互关联。而这种关系结构的不同部分决定了对象适配器和类适配器之间的差异。
- en: Another point to address is that the Adapter can sometimes be confused with
    the Facade pattern. We must understand that the core difference between them is
    that the Facade pattern establishes a simplified front-facing interface to a complex
    system. But the Adapter adapts incompatible systems while maintaining a consistent
    interface for a client.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要说明的是，适配器有时会与外观模式混淆。我们必须理解，它们之间的核心区别在于，外观模式为复杂系统建立了一个简化的前端接口。但适配器适配不兼容的系统，同时为客户端保持一致的接口。
- en: Both patterns are related as they are both structural patterns but have entirely
    different purposes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式相关，因为它们都是结构型模式，但具有完全不同的目的。
- en: '**Composition** is one of the core concepts of **O****bject-Oriented Programming**
    (**OOP**); it refers to the concept of combining simple types to make more complex
    ones. For instance, a motorbike has wheels, an engine, and a handlebar. So composition
    establishes a "has a" relationship while inheritance sets an "is a" relationship.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合**是面向对象编程（OOP）的核心概念之一；它指的是将简单类型组合成更复杂类型的概念。例如，摩托车有轮子、发动机和把手。因此，组合建立了一个“拥有”关系，而继承则建立了一个“是”关系。'
- en: Benefits and drawbacks of the Adapter pattern
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器模式的好处和缺点
- en: 'The following are some of the benefits of the Adapter pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些适配器模式的好处：
- en: '**Adapting without modifying**: The main benefit of the Adapter pattern is
    that it offers a standard approach to adapting old or third-party code without
    modifying it.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需修改即可适配**：适配器模式的主要优点是它提供了一种标准方法来适配旧代码或第三方代码，而无需对其进行修改。'
- en: '**Reusability and flexibility**: This pattern permits the continued use of
    legacy code on new systems with minimal changes; this has an immediate return
    on investment.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性和灵活性**：此模式允许在新系统上以最小的更改继续使用旧代码；这具有立即的投资回报。'
- en: 'The following are some potential drawbacks of the Adapter pattern:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些适配器模式的潜在缺点：
- en: '**Persisting legacy**: The ability to use legacy code with new systems is cost-effective,
    but in the long term, it can become an issue, because the old code might limit
    your upgrade options as it becomes deprecated and incompatible with new versions of
    Unity or third-party libraries.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久遗产**：使用旧代码与新系统兼容的能力是成本效益的，但从长远来看，可能会成为一个问题，因为随着旧代码变得过时且与Unity或第三方库的新版本不兼容，它可能会限制你的升级选项。'
- en: '**Slight overhead**: Because, in some instances, you are redirecting calls
    between objects, there might be a slight performance hit, usually too small to
    become an issue.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻微开销**：因为，在某些情况下，你需要在对象之间重定向调用，这可能会带来轻微的性能损失，通常太小，不会成为问题。'
- en: The Adapter is part of the structural pattern family, including the Facade,
    Bridge, Composite, Flyweight, and Decorator.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器是结构型模式家族的一部分，包括外观（Facade）、桥接（Bridge）、组合（Composite）、享元（Flyweight）和装饰器（Decorator）。
- en: When to use the Adapter pattern
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用适配器模式
- en: A potential use case for the Adapter in Unity is when you have a third-party
    library that you downloaded from the Unity Asset Store, and you need to modify
    some of its core classes and interfaces to add new features. But when changing
    third-party code, you risk having merge issues every time you pull an update from
    the library owners.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，适配器的一个潜在用例是当你有一个从Unity Asset Store下载的第三方库，你需要修改其一些核心类和接口以添加新特性。但是，每次从库所有者那里拉取更新时，更改第三方代码都会带来合并问题。
- en: Hence, you find yourself in a situation where you choose to wait for the third-party
    library owners to integrate the changes you need or modify their code and add
    the missing features. Both choices have their risks versus rewards. But the Adapter
    pattern gives us a solution to this dilemma by letting us place an adapter between
    existing classes so they can work together without modifying them directly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你发现自己处于一个选择等待第三方库所有者集成所需更改或修改他们的代码并添加缺失特性的情况。这两种选择都有其风险与回报。但适配器模式通过允许我们在现有类之间放置适配器，从而提供了一个解决这个困境的方法，这样它们就可以在不直接修改它们的情况下一起工作。
- en: Let's imagine we are working on the code base of a project that uses an inventory
    system package downloaded from the Unity Asset Store. The system is excellent;
    it saves the player's purchased or gifted inventory items to a secure cloud backend
    service. But there's one problem, it doesn't support local disk saves. This limitation
    has become an issue in our project because we need both local and cloud saves
    for redundancy purposes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在为一个项目编写代码库，该项目使用的是从Unity Asset Store下载的库存系统包。该系统非常出色；它将玩家的购买或赠送的库存项目保存到安全的云后端服务。但有一个问题，它不支持本地磁盘保存。这种限制已经成为我们项目中的一个问题，因为我们需要本地和云保存以实现冗余。
- en: In this scenario, we could easily modify the vendor's code and add the feature
    we need. But when they release their next update, we will have to merge our code
    with theirs. This approach can be an error-prone process. Instead, we will use
    the Adapter pattern and implement a wrapper that will maintain a consistent interface
    to the inventory system while adding local-save support. And in the process, we
    will not have to modify any of the existing classes. Thus, we will be able to
    avoid changing the vendor's code and still have your local save system handle
    the saving of inventory items.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以轻松地修改供应商的代码并添加我们需要的特性。但是，当它们发布下一个更新时，我们必须将我们的代码与他们的代码合并。这种方法可能是一个容易出错的流程。相反，我们将使用适配器模式并实现一个包装器，它将保持对库存系统的统一接口，同时添加本地保存支持。在这个过程中，我们不需要修改任何现有的类。因此，我们将能够避免更改供应商的代码，同时仍然让您的本地保存系统处理库存项目的保存。
- en: We will implement an example of this use case in the next section. But in conclusion,
    the Adapter pattern is handy in situations in which you have incompatible systems
    that need to interface with each other. Still, you want to avoid modifying any
    existing code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中实现这个用例的示例。但总的来说，适配器模式在需要相互接口但不希望修改现有代码的不兼容系统的情况下非常有用。
- en: Implementing the Adapter pattern
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现适配器模式
- en: The code example will be simple; we will not attempt to write an entire local
    disk save system because that's not the focus of this chapter. Instead, we will
    write the skeleton of the system to concentrate on the use of the Adapter pattern
    and not be impeded by unrelated implementation details.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例将会很简单；我们不会尝试编写一个完整的本地磁盘保存系统，因为这不是本章的重点。相反，我们将编写系统的框架，以便专注于适配器模式的使用，并且不会因为无关的实现细节而受阻。
- en: Implementing the Adapter pattern
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现适配器模式
- en: 'To start off, we will implement a placeholder class that will mock the third-party
    inventory system as presented in the scenario of the previous section:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现一个占位符类，它将模拟上一节场景中展示的第三方库存系统：
- en: 'The `InventorySystem` class provided by our fictional provider has three methods,
    `AddItem()`, `RemoveItem()`, and `GetInventory()`. All of these methods are hardcoded
    to use cloud storage and we can''t modify them:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们虚构的提供者提供的`InventorySystem`类有三个方法，`AddItem()`、`RemoveItem()`和`GetInventory()`。所有这些方法都是硬编码为使用云存储，我们无法修改它们：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next up is the class that will act as our adapter in this scenario. It adds
    the ability to save inventory items to a local disk. But it also exposes a new
    functionality that permits the merging and syncing of the player''s local and
    cloud inventories:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是将在这种情况下充当适配器的类。它增加了将库存项目保存到本地磁盘的能力。但它还暴露了新的功能，允许合并和同步玩家的本地和云库存：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that by inheriting the third party's `InventorySystem` class, we have
    access to all its properties and methods. Thus we can continue to use its core
    functionalities while adding our own. We are modifying nothing in the process,
    just adapting it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过继承第三方的`InventorySystem`类，我们可以访问其所有属性和方法。因此，我们可以在添加自己的同时继续使用其核心功能。我们在过程中没有修改任何东西，只是在适配它。
- en: 'We are going to expose an interface to our new inventory system:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向我们的新库存系统提供一个接口：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The client who uses this interface is not aware that it's communicating with
    a system adapted from another. The Adaptee is also not aware that we are adapting
    it. Like a charger adapter, the phone and cable are unaware of which plug they
    are connected to, only that current is passing through the system and charging
    the battery.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此接口的客户不会意识到它正在与另一个系统进行通信。适配者（Adaptee）也不知道我们在适配它。就像充电适配器一样，手机和电缆不知道它们连接的是哪个插头，只知道电流正在通过系统并为电池充电。
- en: 'To complete our implementation, we need to add an `enum` that exposes the save
    locations:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的实现，我们需要添加一个`enum`来暴露保存位置：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And for our last step, we will implement a placeholder `InventoryItem` class:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的最后一步，我们将实现一个占位符`InventoryItem`类：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Testing the Adapter pattern implementation
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试适配器模式实现
- en: 'To test our implementation in your instance of Unity, copy all the classes
    we just reviewed into your project and attach the following client class to an
    empty GameObject in a new Unity scene:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你在Unity实例中的实现，将我们刚刚审查的所有类复制到你的项目中，并将以下客户端类附加到一个新Unity场景中的空GameObject上：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now can build a new inventory system that uses the functionality of an older
    one provided by a third party. We can continue to pull library updates from the
    third-party website with confidence and without the need to worry about merge
    issues. Our system can grow in features while we continue to adapt theirs, and
    if one day we want to remove their system from our code base and just use our
    own, we could start the deprecation process by updating the `adapter` class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建一个新的库存系统，该系统使用由第三方提供的旧功能。我们可以继续从第三方网站自信地拉取库更新，而无需担心合并问题。我们的系统可以在我们继续适配他们的同时增加功能，如果有一天我们想从我们的代码库中移除他们的系统并只使用我们自己的，我们可以通过更新`adapter`类开始弃用过程。
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added the Adapter pattern to our toolbox. It's a type of
    pattern that's very beneficial to have in our back pocket. One of the biggest
    challenges for a professional programmer is dealing with incompatible systems
    that are often developed by external vendors or other teams inside an organization.
    A consistent approach to adapting existing classes can only be helpful, especially
    when time becomes an issue and it's just faster to reuse old code for new purposes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将适配器模式添加到我们的工具箱中。这是一种非常有用的模式，应该放在我们的口袋里。对于专业程序员来说，最大的挑战之一是处理由外部供应商或其他团队在组织内部开发的不可兼容的系统。采用一致的方法来适配现有的类只能是有益的，尤其是在时间成为问题，直接重用旧代码用于新目的更快的时候。
- en: In the next chapter, we will review a close cousin of the Adapter, the Facade
    pattern, which we will use to manage the growing complexity in our code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾适配器的近亲——外观模式（Facade pattern），我们将使用它来管理代码中的日益增长的复杂性。
