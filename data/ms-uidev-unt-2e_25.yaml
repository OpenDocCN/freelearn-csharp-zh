- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: The New Input System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新输入系统
- en: Unity’s `Update()` method to determine if a device received an input. This usually
    results in multiple if-else branches within your `Update()` method that control
    what happens for each input received.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的 `Update()` 方法用于确定设备是否接收到了输入。这通常会在你的 `Update()` 方法中导致多个 if-else 分支，以控制每个接收到的输入所发生的事情。
- en: The Input System divorces the handling of individual input devices from code
    by using an event-based programming methodology. Instead of having to create reference
    to each of your input devices within your code, you create code that reacts to
    specific actions. The Input System then controls which Interaction from which
    Input devices trigger these actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 输入系统通过使用基于事件的编程方法将处理单个输入设备的任务从代码中分离出来。你不需要在代码中为每个输入设备创建引用，而是创建响应特定操作的代码。然后，输入系统控制哪些来自哪些输入设备的交互触发这些操作。
- en: This separation of input handling and code allows you to make more customizable
    controls, more easily handle different Input Devices, and more easily handle controls
    from different consoles that have extremely different control schemes. Additionally,
    the modularity of the Input System allows you to easily copy your control schemes
    to other projects, since the information is all stored on an asset.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将输入处理和代码分离的做法允许你创建更可定制的控制，更容易处理不同的输入设备，以及更容易处理来自具有极不同控制方案的不同控制台的控制。此外，输入系统的模块化允许你轻松地将你的控制方案复制到其他项目中，因为所有信息都存储在资产中。
- en: This chapter is meant to be an introduction to the Input System and will give
    you an overview of the key concepts so that you can start using the Input System
    within your projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在介绍输入系统，并将为你概述关键概念，以便你可以在项目中开始使用输入系统。
- en: 'In this chapter, I will discuss the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论以下内容：
- en: How to install the Input System
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装输入系统
- en: The differences in polling vs subscribing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询与订阅之间的差异
- en: The basic elements involved with the Input System
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与输入系统相关的基本元素
- en: How to write code that uses the Input System’s to control your game
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写使用输入系统控制游戏的代码
- en: How to convert a project that uses the old Input System (the Input Manager)
    to one that uses the new Input System
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将使用旧输入系统（输入管理器）的项目转换为使用新输入系统
- en: Two different ways to connect your Input System to your code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的输入系统连接到代码的两种不同方式
- en: Before we begin looking at how to work with the Input System, it needs to be
    imported into your project. Let’s look at how to do that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看如何使用输入系统之前，需要将其导入到你的项目中。让我们看看如何做到这一点。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the asset files and codes of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2020](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2020)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章的资产文件和代码：[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2020](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2020)
- en: Installing the Input System
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装输入系统
- en: The Input System is no longer in preview and is officially part of Unity. However,
    it does not come pre-packaged in unity and must be installed. You can install
    the Input System into your Project via the Package Manager, by completing the
    following steps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输入系统不再处于预览状态，并正式成为 Unity 的一部分。然而，它并没有预装在 unity 中，必须安装。你可以通过包管理器完成以下步骤，将输入系统安装到你的项目中。
- en: Select **Unity Registry** from the dropdown menu.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择 **Unity 注册表**。
- en: '![Figure 20.1: Changing the Package filter in the Package Manager](img/Figure_20.01_B18327.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.1：在包管理器中更改包过滤器](img/Figure_20.01_B18327.jpg)'
- en: 'Figure 20.1: Changing the Package filter in the Package Manager'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.1：在包管理器中更改包过滤器
- en: Search for the **Input System** in the list and select **Install**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中搜索 **Input System** 并选择 **安装**。
- en: '![Figure 20.2: Finding the Input System in the Package Manger](img/Figure_20.02_B18327.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.2：在包管理器中找到输入系统](img/Figure_20.02_B18327.jpg)'
- en: 'Figure 20.2: Finding the Input System in the Package Manger'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.2：在包管理器中找到输入系统
- en: You will see the following pop up which you must agree to in order to proceed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个弹出窗口，你必须同意才能继续。
- en: '![Figure 20.3: A Warning about changing input systems](img/Figure_20.03_B18327.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.3：关于更改输入系统的警告](img/Figure_20.03_B18327.jpg)'
- en: 'Figure 20.3: A Warning about changing input systems'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.3：关于更改输入系统的警告
- en: The warning is indicating that any code you wrote using the old Input System
    will no longer function. This is a destructive action and may break your game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告表明，你使用旧输入系统编写的任何代码将不再工作。这是一个破坏性行为，可能会破坏你的游戏。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I recommend you create a new project to explore the Input System as installing
    it may be destructive to your project. It will cause all code written using the
    Input Manager to cease functioning. Don’t install it in a pre-existing project
    until you are comfortable doing so.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你创建一个新的项目来探索输入系统，因为安装它可能会对你的项目造成破坏。它将导致使用输入管理器编写的所有代码停止工作。在你感到舒适之前，不要在现有的项目中安装它。
- en: Once you reopen your project, you may want to return to the Package Manager
    and install the various Samples provided by Unity with the Package. I recommend
    you install the Simple Demo and UI vs Game Input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新打开你的项目时，你可能想回到包管理器，并使用包安装Unity提供的各种示例。我建议你安装简单演示和UI与游戏输入。
- en: Since this is a new Input System, it does use a new methodology to access inputs
    than the old Input System. Let’s first discuss the differences in these methodologies
    before we begin looking at the various elements of the Input System.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个新的输入系统，它确实使用了一种与旧输入系统不同的方法来访问输入。在我们开始查看输入系统的各个元素之前，让我们首先讨论这些方法之间的差异。
- en: Polling vs subscribing
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询与订阅
- en: We discussed the Input Manager in [*Chapter 8*](B18327_08.xhtml#_idTextAnchor147)
    and up until recently, it was the only way to track inputs from devices in a Unity-built
    game. When using the Input Manager, you assign specific Axes to different input
    actions. You then write a C# script that constantly checks to see if that action
    is performed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第8章*](B18327_08.xhtml#_idTextAnchor147)中讨论了输入管理器，直到最近，它一直是跟踪Unity构建的游戏中设备输入的唯一方式。当使用输入管理器时，你将特定的轴分配给不同的输入操作。然后，你编写一个C#脚本，不断检查该操作是否被执行。
- en: '![Figure 20.4: C# script watching for specific inputs defined by the Input
    Manager](img/Figure_20.04_B18327.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图20.4：监视由输入管理器定义的特定输入的C#脚本](img/Figure_20.04_B18327.jpg)'
- en: 'Figure 20.4: C# script watching for specific inputs defined by the Input Manager'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.4：监视由输入管理器定义的特定输入的C#脚本
- en: 'To accomplish this, your code would look something like the following pseudocode:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你的代码可能看起来像以下伪代码：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This technique of requesting information at a regular interval, is called **polling**.
    You can use the polling pattern for accessing information from the Input System
    in a similar way that you could with the Input Manager. However, to make your
    code more modular, most of your code when using the Input System will use a **publisher-subscriber**
    (**pub-sub**) pattern.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定期请求信息的技术被称为**轮询**。你可以使用轮询模式以类似的方式从输入系统中获取信息，就像你可以使用输入管理器一样。然而，为了使你的代码更加模块化，当你使用输入系统时，大部分代码将使用**发布者-订阅者**（**pub-sub**）模式。
- en: 'Consider the following analogy: you really enjoy content from a specific YouTube
    content creator. You check their channel every day to see if they have released
    new content. However, you find this cumbersome and instead decide to subscribe
    to their channel. Now the YouTube channel will alert you whenever new content
    is posted, saving you the work. Imagine how much work you save yourself from if
    you had hundreds of YouTube channels you wanted to be updated on by subscribing
    to their channels instead of constantly checking in on them.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类比：你非常喜欢某个YouTube内容创作者的内容。你每天都会查看他们的频道，看看是否有新内容发布。然而，你发现这样做很麻烦，于是决定订阅他们的频道。现在，YouTube频道会在有新内容发布时提醒你，这样就节省了你的工作。想象一下，如果你有数百个YouTube频道想要通过订阅来获取更新，而不是不断检查它们，你会节省多少工作量。
- en: Let’s tie the analogy to coding. Instead of your C# script having to constantly
    check in on the various inputs in the `Update()` method, you can instead **subscribe**
    to specific events defined by the **Input System**. In more technical speak, you
    will write event subscriber methods that listen for specific events raised by
    the Input System.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个类比与编码联系起来。而不是你的C#脚本需要在`Update()`方法中不断检查各种输入，你还可以**订阅**由**输入系统**定义的特定事件。用更技术性的语言来说，你将编写事件订阅方法，以监听由输入系统引发的特定事件。
- en: '![Figure 20.5: C# script listening for specific events defined by the New Input
    System](img/Figure_20.05_B18327.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图20.5：监听由新输入系统定义的特定事件的C#脚本](img/Figure_20.05_B18327.jpg)'
- en: 'Figure 20.5: C# script listening for specific events defined by the New Input
    System'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.5：监听由新输入系统定义的特定事件的C#脚本
- en: 'So, when using the New Input System, your code may look something like the
    following pseudocode:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用新的输入系统时，您的代码可能看起来像以下伪代码：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Input System will determine which events to call based on inputs you specify
    and your code will subscribe to those events, performing the appropriate functions
    whenever those events happen.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输入系统将根据您指定的输入和您的代码订阅的事件来确定调用哪些事件，当这些事件发生时，您的代码将执行适当的函数。
- en: So, how do you tell the Input System which events to call based on which input?
    And what types of events can it call from those inputs? You do this through the
    use of Actions, Interactions, and Input Binding. Let’s explore these concepts
    now.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何根据哪种输入来告诉输入系统调用哪些事件？以及它可以从这些输入调用哪些类型的事件？您可以通过使用动作、交互和输入绑定来完成此操作。现在让我们探讨这些概念。
- en: Input System elements
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入系统元素
- en: In the Input Manager, you list various Axes and define what buttons can trigger
    these axes. In the Input System, you define a set of **Actions** and describe
    what **Interactions** the various **Controls** of the **Input Device** can trigger
    those Actions through **Input Bindings**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入管理器中，您列出各种轴并定义哪些按钮可以触发这些轴。在输入系统中，您定义一组**动作**并描述输入设备的各种**控制**如何通过**输入绑定**触发这些动作。
- en: For example, you could create the Input Binding that binds the Space Bar on
    a keyboard to a jump Action through a pressed Interaction, where the Input device
    would be the keyboard and the Controls would be all the keys on the keyboard.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以通过一个按下的交互将键盘上的空格键绑定到一个跳跃动作的输入绑定来创建输入绑定，其中输入设备是键盘，控制是键盘上的所有键。
- en: '![Figure 20.6: An example of an Input Binding](img/Figure_20.06_B18327.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图20.6：输入绑定的示例](img/Figure_20.06_B18327.jpg)'
- en: 'Figure 20.6: An example of an Input Binding'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.6：输入绑定的示例
- en: You can create these sets of **Actions** within what is known as an **Action
    Map**. Action Maps contain a list of Actions. The Actions contain the information
    about the Input Bindings. The general idea is to create Action Maps that contain
    groups of actions based on their purpose for example all character control Actions
    may go in one Action Map and all UI Actions may go in a separate one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在所谓的**动作图**中创建这些动作集合。动作图包含动作列表。动作包含有关输入绑定的信息。一般想法是创建包含基于其目的的动作组的动作图，例如所有角色控制动作可以放在一个动作图中，所有用户界面动作可以放在另一个动作图中。
- en: You can view your Action Maps, Actions, Bindings, and Interactions in the Action
    Editor. For example, here is the `Player` and `UI`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在动作编辑器中查看您的动作图、动作、绑定和交互。例如，这里显示了“玩家”和“用户界面”。
- en: '![Figure 20.7: The Action Editor](img/Figure_20.07_B18327.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图20.7：动作编辑器](img/Figure_20.07_B18327.jpg)'
- en: 'Figure 20.7: The Action Editor'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.7：动作编辑器
- en: Within the `Player` Action Map, you can see the `Jump` Action, with the `Space
    [Keyboard]` Binding, and the `Press` Interaction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在“玩家”动作图中，您可以看到带有“空格[键盘]”绑定和“按下”交互的“跳跃”动作。
- en: 'To start creating your Actions and Action Maps, right click within an `Assets`
    folder and select `Inputs` within your `Assets` folder. When you do so, you should
    get something that looks like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建您的动作和动作图，在“资产”文件夹内右键单击，并在您的“资产”文件夹中选择“输入”。这样做时，您应该得到以下类似的内容：
- en: '![Figure 20.8: An Action Asset’s Inspector and icon representation](img/Figure_20.08_B18327.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图20.8：动作资产的检查器和图标表示](img/Figure_20.08_B18327.jpg)'
- en: 'Figure 20.8: An Action Asset’s Inspector and icon representation'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.8：动作资产的检查器和图标表示
- en: You can either double click on the asset you just created or select **Edit asset**
    from its Inspector to view the Action Editor. The Action Editor will contain your
    list of Action Maps and Actions while displaying each of the Action’s properties.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以双击您刚刚创建的资产，或从其检查器中选择**编辑资产**来查看动作编辑器。动作编辑器将包含您的动作图和动作列表，同时显示每个动作的属性。
- en: '![Figure 20.9: The Action Editor of a newly created Action Asset](img/Figure_20.09_B18327.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图20.9：新创建的动作资产的动作编辑器](img/Figure_20.09_B18327.jpg)'
- en: 'Figure 20.9: The Action Editor of a newly created Action Asset'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.9：新创建的动作资产的动作编辑器
- en: Selecting the **+** sign in the **Action Maps** section will create a new Action
    Map.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在**动作图**部分选择**+**号将创建一个新的动作图。
- en: A new Action Map will automatically come with a **New action**, which you can
    rename.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 新的动作图将自动包含一个**新动作**，您可以重命名它。
- en: '![Figure 20.10: An Action Map with its New action](img/Figure_20.10_B18327.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图20.10：带有新动作的动作图](img/Figure_20.10_B18327.jpg)'
- en: 'Figure 20.10: An Action Map with its New action'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.10：带有新动作的 Action Map
- en: Selecting **<No Binding>** will allow you to create an Input Binding.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **<无绑定>** 将允许您创建输入绑定。
- en: I will cover an example of how to select Binding and Interactions in the Examples
    section at the end of this chapter, but for now, let’s look at how you can hook
    these Actions to your code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章末尾的示例部分中介绍如何选择绑定和交互的示例，但就目前而言，让我们看看您如何将这些 Actions 连接到您的代码。
- en: Connecting Actions to code
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Actions 连接到代码
- en: There are multiple ways to work with the Input System’s Actions in your code.
    In this section, I will give a general overview of the most important topics that
    should allow you to get started working with the Input System.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中处理 Input System 的 Actions 有多种方法。在本节中，我将概述最重要的主题，这将使您能够开始使用 Input System。
- en: 'To connect your Actions to your code, you will need to import the `InputSystem`
    with the following statement:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的 Actions 连接到您的代码，您需要使用以下语句导入 `InputSystem`：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two ways in which I will discuss connecting Actions to your Code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我将讨论两种将 Actions 连接到您代码的方法：
- en: Referencing the Action Asset
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用 Action Asset
- en: Using the `PlayerInput` component
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `PlayerInput` 组件
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about alternate ways you can connect Actions to your code,
    see the following Unity documentation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将 Actions 连接到您代码的替代方法的更多信息，请参阅以下 Unity 文档：
- en: '[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflows.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflows.xhtml)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflows.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflows.xhtml)'
- en: 'You can reference the Action Asset creating a variable of type `InputActionsAsset`
    like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考创建类型为 `InputActionsAsset` 的变量 Action Asset 的方法：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can then assign the value of `actions` in the Inspector.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在检查器中分配 `actions` 的值。
- en: 'And to reference the specific Action within a `InputActionAsset`, you could
    create a variable of type `InputAction`, like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `InputActionAsset` 中引用特定的 Action，您可以创建一个类型为 `InputAction` 的变量，如下所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You could then assign it by finding the specific Action Map and Action within
    the Action Asset, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过找到 Action Asset 中的特定 Action Map 和 Action 来分配它，如下所示：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you find the reference to the Action Asset, you will need to enable and
    disable the appropriate Action Maps. For Example, if you had an Action Map named
    `Player`, you could do the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到 Action Asset 的引用，您需要启用和禁用适当的 Action Maps。例如，如果您有一个名为 `Player` 的 Action
    Map，您可以执行以下操作：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you have a reference to the `InputActionAsset`, you can have your methods
    subscribe to the various callbacks of the Action. Each Action has the following
    callbacks that you can subscribe to:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了 `InputActionAsset` 的引用，您可以让您的方程序订阅 Action 的各种回调。每个 Action 都有以下回调，您可以订阅：
- en: '`Performed`: The Action’s Interaction is complete'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Performed`：动作的交互已完成'
- en: '`Started`: The Action’s Interaction has started'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Started`：动作的交互已经开始'
- en: '`Waiting`: The Action is enabled and waiting for an Input to cause trigger
    an Interaction'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Waiting`：动作已启用并等待输入以触发交互'
- en: '`Canceled`: The Action’s Interaction has been canceled'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Canceled`：动作的交互已被取消'
- en: '`Disabled`: The Action cannot receive any input as it is disabled'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Disabled`：由于禁用，动作无法接收任何输入'
- en: 'So, for example, you could subscribe to an Action named `Jump` on an Action
    Map named `Player` that is triggered by a button press with something like the
    following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以在名为 `Player` 的 Action Map 上订阅名为 `Jump` 的 Action，该 Action 由按钮按下触发，如下所示：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you wish to poll the Actions rather than subscribe to the callback events,
    you use the `ReadValue<TValue>()` method like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望轮询 Actions 而不是订阅回调事件，您可以使用 `ReadValue<TValue>()` 方法，如下所示：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you’re not a big fan of writing code, you can instead use the `PlayerInput`
    component. The `PlayerInput` component will allow you to specify which methods
    in your C# scripts are called by the various Actions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是编写代码的大粉丝，您可以使用 `PlayerInput` 组件。`PlayerInput` 组件将允许您指定您的 C# 脚本中哪些方法被各种
    Actions 调用。
- en: '![Figure 20.11: The default Player Input component](img/Figure_20.11_B18327.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.11：默认的 Player 输入组件](img/Figure_20.11_B18327.jpg)'
- en: 'Figure 20.11: The default Player Input component'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.11：默认的 Player 输入组件
- en: Using this method vs directly referencing the Actions in your code is mostly
    up to preference. It takes less code, but it takes more Inspector work. As a programmer
    by trade, I personally prefer the method that references the Actions in code.
    I find it easier to debug, more customizable, and quicker to edit when there are
    multiple objects using Actions. However, when I am working on a project that has
    designers making changes in the Inspector, who don’t want to work in code, using
    the `PlayerInput` component is a good solution as it allows them to do things
    without me. You can also use a combination and it’s all based on your needs and
    preferences.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法与直接在代码中引用动作主要取决于个人喜好。它需要的代码更少，但需要更多的检查器工作。作为一名程序员，我个人更喜欢在代码中引用动作的方法。我发现它更容易调试，更可定制，当有多个对象使用动作时，编辑起来也更快。然而，当我在一个项目中工作时，设计师在检查器中做出更改，他们不想在代码中工作，使用`PlayerInput`组件是一个好的解决方案，因为它允许他们在我不知情的情况下完成任务。您也可以结合使用，一切基于您的需求和偏好。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn more about the various ways you can access Actions with your code,
    see the following documentation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解您可以使用代码访问动作的各种方法，请参阅以下文档：
- en: '[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflow-ActionsAsset.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflow-ActionsAsset.xhtml)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflow-ActionsAsset.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/manual/Workflow-ActionsAsset.xhtml)'
- en: Now that we have a general idea of how the Unity Input System works, let’s look
    at some examples of how to work with it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Unity输入系统的工作原理有了大致的了解，让我们看看一些如何与之工作的示例。
- en: Examples
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: Now that we’ve reviewed the basics of getting started with the Input System,
    let’s look at some examples of how to implement it. We’ll look at one very basic
    example of a character controller. We’ll start with an example that uses the old
    Input Manager and then adjust it to use the Input System.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了开始使用输入系统的基本知识，让我们看看一些如何实现它的示例。我们将查看一个非常基础的字符控制器示例。我们将从一个使用旧输入管理器的示例开始，然后调整它以使用输入系统。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is a super basic character controller. It is simplified to make the process
    of converting it to the Input System easier to understand.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基础的字符控制器。它被简化了，以便更容易理解将其转换为输入系统的过程。
- en: The example we will use is just a cat that jumps and moves around.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的示例只是一个会跳跃和四处移动的猫。
- en: '![Figure 20.12: The character controller example using the old Input System](img/Figure_20.12_B18327.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图20.12：使用旧输入系统的字符控制器示例](img/Figure_20.12_B18327.jpg)'
- en: 'Figure 20.12: The character controller example using the old Input System'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.12：使用旧输入系统的字符控制器示例
- en: 'Before you begin these examples, complete the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这些示例之前，请完成以下步骤：
- en: Create a new 2D Unity Project.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的2D Unity项目。
- en: Import the `Chapter 20` `– Example 1 - Start` Package provided by the book’s
    source code using `Chapter 20` `– Example 1` to get a feel of how the cat moves
    around. It’s nothing fancy or particularly impressive, but the cat will jump with
    the space bar and move back and forth with the arrow keys and *A*- *D* keys.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Chapter 20` `– Example 1 - Start`包，该包由本书的源代码提供，通过`Chapter 20` `– Example
    1`来感受猫的移动方式。这没有什么花哨的或特别令人印象深刻的地方，但猫可以用空格键跳跃，用箭头键和*A*- *D*键前后移动。
- en: 'Open the `InputManagerBasicCharacterController.cs` class and review the code.
    The key section of code is the `Update()` method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`InputManagerBasicCharacterController.cs`类并查看代码。关键代码部分是`Update()`方法：
- en: '[PRE9]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice the use of `Input.GetAxis("Horizontal")` and `Input.GetButtonDown` **("Jump")**
    . These are defined within the Input Manager which you can find in **Edit** |
    **Project Settings** | **Input Manager**.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到使用了`Input.GetAxis("Horizontal")`和`Input.GetButtonDown` **("Jump")**。这些函数定义在输入管理器中，您可以在**编辑**
    | **项目设置** | **输入管理器**中找到。
- en: Now that you’ve played the game. Install the Input System Package and restart
    when requested. See the *Installing the Input System* section for steps.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经玩过游戏后，安装输入系统包，并在请求时重新启动。有关步骤，请参阅**安装输入系统**部分。
- en: If you try to play the game now, you will see the following error in your console.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您现在尝试玩游戏，您将在控制台看到以下错误。
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is because when we installed the Input System, the project stopped accepting
    inputs that use `UnityEngine.Input`. The cat will no longer move in response to
    our key presses.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为当我们安装输入系统时，项目停止接受使用`UnityEngine.Input`的输入。猫将不再对按键做出响应。
- en: Ok, now that we have our project started and set up, we can convert that code
    to something that can be used by the Input System! Let’s start by setting up our
    Actions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们的项目已经开始并设置好了，我们可以将代码转换为可以被输入系统使用的代码！让我们先设置我们的动作。
- en: Creating basic character controller Actions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本角色控制器动作
- en: Before we start adjusting our code, we first have to set up our Action Map and
    Actions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始调整代码之前，我们首先必须设置我们的动作映射和动作。
- en: 'To set up your basic character controller Actions, complete the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置你的基本角色控制器动作，请完成以下步骤：
- en: Create a new folder called `Inputs` within your `Assets` folder.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的“Assets”文件夹中创建一个名为“Inputs”的新文件夹。
- en: Right-click within the folder and select **Create** | **Input Actions**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹内右键单击并选择**创建** | **输入动作**。
- en: Rename the new Action Asset to `CatActions`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的动作资产重命名为`CatActions`。
- en: Double-click `CatActions.inputActions` to open the Action Editor.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`CatActions.inputActions`以打开动作编辑器。
- en: Check the **Auto-Save** box so that any changes you make will automatically
    save.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**自动保存**复选框，以便您所做的任何更改都将自动保存。
- en: '![Figure 20.13: Selecting Auto-Save](img/Figure_20.13_B18327.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图20.13：选择自动保存](img/Figure_20.13_B18327.jpg)'
- en: 'Figure 20.13: Selecting Auto-Save'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.13：选择自动保存
- en: 'Now we need to add an Action Map that will hold all the Actions for our character.
    Create a new Action Map by selecting the plus sign and then naming the Action
    Map `Player`. You should now see the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个动作映射，它将包含我们角色的所有动作。通过选择加号并命名动作映射为“Player”来创建一个新的动作映射。你现在应该看到以下内容：
- en: '![Figure 20.14: The Player Action Map](img/Figure_20.14_B18327.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图20.14：玩家动作映射](img/Figure_20.14_B18327.jpg)'
- en: 'Figure 20.14: The Player Action Map'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.14：玩家动作映射
- en: Let’s create the `Jump` action by renaming `New action` to `Jump`. You can do
    so by double-clicking on the words **New action**. Notice that the **Action Type**
    is set to **Button**. This means the Jump Action will be triggered by button-like
    inputs.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过将“新建动作”重命名为“跳跃”来创建“跳跃”动作。你可以通过双击“新建动作”这个词来实现。注意**动作类型**被设置为**按钮**。这意味着跳跃动作将由类似按钮的输入触发。
- en: '![Figure 20.15: The Jump Action’s properties](img/Figure_20.15_B18327.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图20.15：跳跃动作的属性](img/Figure_20.15_B18327.jpg)'
- en: 'Figure 20.15: The Jump Action’s properties'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.15：跳跃动作的属性
- en: Click on the arrow next to the `Jump` Action to view all of its bindings. You
    should see **<****No Binding>.**
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`跳跃`动作旁边的箭头以查看所有绑定。你应该看到**无绑定**。
- en: '![Figure 20.16: The Jump Action’s bindings](img/Figure_20.16_B18327.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图20.16：跳跃动作的绑定](img/Figure_20.16_B18327.jpg)'
- en: 'Figure 20.16: The Jump Action’s bindings'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.16：跳跃动作的绑定
- en: Click on `Space`, then select **Space [Keyboard]**. This will bind the spacebar
    on the keyboard to this Action. Notice it automatically names the binding for
    you.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`空格`键，然后选择**空格 [键盘]**。这将把键盘上的空格键绑定到这个动作。注意它会自动为你命名绑定。
- en: 'Now let’s tell this binding what Interaction it can accept. Select the plus
    sign next to **Interactions** and select **Press** from the dropdown. Your Player
    Action Map should now look as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来告诉这个绑定它可以接受哪种交互。在**交互**旁边选择加号，并从下拉菜单中选择**按下**。你的玩家动作映射现在应该如下所示：
- en: '![Figure 20.17: The Press Interaction on the Space [Keyboard] binding](img/Figure_20.17_B18327.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图20.17：空格 [键盘] 绑定上的按下交互](img/Figure_20.17_B18327.jpg)'
- en: 'Figure 20.17: The Press Interaction on the Space [Keyboard] binding'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.17：空格 [键盘] 绑定上的按下交互
- en: Now we want to add the Action that will be bound to the keys that were previously
    referenced by `"Horizontal"` in the Input Manager. Select the plus sign next to
    `Move`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想要添加一个绑定到之前在输入管理器中由“水平”引用的键的动作。在“移动”旁边选择加号。
- en: Set its **Action Type** to **Value** and its **Control Type** to **Vector2**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**动作类型**设置为**值**，其**控制类型**设置为**Vector2**。
- en: 'Now we need to add the key bindings. Select the plus sign next to the `Move`
    Action and you’ll notice, since we set `Move` as a different Action Type than
    `Jump`, it has different **Binding Options**. Select **Add Up\Down\Left\Right
    Composite**. You should now see the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加键绑定。在“移动”动作旁边选择加号，你会注意到，因为我们把“移动”设置为与“跳跃”不同的动作类型，它有不同的**绑定选项**。选择**添加上下左右复合**。你现在应该看到以下内容：
- en: '![Figure 20.18: The 2D vector bindings](img/Figure_20.18_B18327.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图20.18：2D向量绑定](img/Figure_20.18_B18327.jpg)'
- en: 'Figure 20.18: The 2D vector bindings'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.18：2D向量绑定
- en: Delete the **Up** and **Down** Bindings as well as the one marked **<No Binding>**,
    because we do not need them. You can do this by right-clicking on them and selecting
    **Delete**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 **Up** 和 **Down** 绑定以及标记为 **<No Binding>** 的绑定，因为我们不需要它们。你可以通过右键点击并选择 **Delete**
    来完成此操作。
- en: Select `Left Arrow` in the **Path** to find **Left** **Arrow [Keyboard]**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **路径** 中选择 `Left Arrow` 以找到 **Left Arrow [Keyboard]**。
- en: 'Select `Right Arrow` in the **Path** to find **Right Arrow [Keyboard]**. You
    should now have the following Actions and Bindings.![Figure 20.19: The Left and
    Right Bindings](img/Figure_20.19_B18327.jpg)'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **路径** 中选择 `Right Arrow` 以找到 **Right Arrow [Keyboard]**。你现在应该有以下动作和绑定。![图
    20.19：左右绑定](img/Figure_20.19_B18327.jpg)
- en: 'Figure 20.19: The Left and Right Bindings'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 20.19：左右绑定
- en: We have now bound our arrow keys to the move action.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已经将箭头键绑定到了移动动作。
- en: 'Now we need to bind the *A* and *D* keys. Duplicate the **Left: Left Arrow
    [Keyboard]** and **Right: Right Arrow [Keyboard]** bindings by right clicking
    them and selecting **Duplicate**.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在我们需要绑定 *A* 和 *D* 键。通过右键点击并选择 **Duplicate** 来复制 **Left: Left Arrow [Keyboard]**
    和 **Right: Right Arrow [Keyboard]** 绑定。'
- en: Select the duplicate `a keyboard` into the **Path** to find **A [Keyboard]**.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **路径** 中选择复制的 `a keyboard` 以找到 **A [Keyboard]**。
- en: 'Select the duplicate `d keyboard` into the **Path** to find **D [Keyboard]**.
    You should now see the following Actions and Bindings:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **路径** 中选择复制的 `d keyboard` 以找到 **D [Keyboard]**。你现在应该看到以下动作和绑定：
- en: '![Figure 20.20: All the necessary Actions and Bindings](img/Figure_20.20._B18327.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.20：所有必要的动作和绑定](img/Figure_20.20._B18327.jpg)'
- en: 'Figure 20.20: All the necessary Actions and Bindings'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.20：所有必要的动作和绑定
- en: 'Now that we’re done hooking up our Actions, we can start using them with our
    code! I’ll show you two ways to do this: with the `PlayerInput` Component and
    by referencing the Action in our script.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了动作的连接，我们可以开始使用它们与我们的代码！我会展示两种方法：使用 `PlayerInput` 组件和通过在脚本中引用动作。
- en: Creating a basic character controller with the PlayerInput Component
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PlayerInput 组件创建一个基本的角色控制器
- en: Switching our code to use Actions and the `PlayerInput` component, requires
    a bit of code adjustment and some Inspector work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的代码切换到使用 Actions 和 `PlayerInput` 组件，需要一些代码调整和一些检查器工作。
- en: 'To use Actions with the `PlayerInput` Component, complete the following steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `PlayerInput` 组件与动作，请完成以下步骤：
- en: To preserve the previous example, I am going to duplicate the scene and call
    it `Chapter 20` `– Example 2`; duplicate the `InputManagerBasicCharacterController.cs`
    script; and rename the duplicate to `PlayerInputBasicCharacterController.cs.`
    If you’d rather just work in the same scene with the same script, you can skip
    this step. However, if you do want to do this, make sure to also change the name
    of the script in the class definition and add the script as a component to the
    `Cat` in your new scene.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保留前面的例子，我将复制场景并命名为 `Chapter 20` `– Example 2`；复制 `InputManagerBasicCharacterController.cs`
    脚本；并将副本重命名为 `PlayerInputBasicCharacterController.cs`。如果你只想在同一个场景中使用相同的脚本，可以跳过这一步。然而，如果你确实想这么做，确保也要更改类定义中的脚本名称，并将脚本作为组件添加到你的新场景中的
    `Cat` 对象上。
- en: Let’s start by adjusting the script. We’ll be removing the code within the `Update()`
    method that checks for the Input Axes and instead use public methods that can
    be hooked up in the Inspector. Comment out all the code within the `Update()`
    method. Don’t delete it, b/c we’ll cut and paste some of it to other methods later.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先调整脚本。我们将移除 `Update()` 方法中检查输入轴的代码，并改用可以在检查器中连接的公共方法。注释掉 `Update()` 方法中的所有代码。不要删除它，因为我们稍后会将其中一些代码剪切粘贴到其他方法中。
- en: 'Add the following statement to the top of your script:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下语句添加到你的脚本顶部：
- en: '[PRE11]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new method called `OnJump()`. This will be the method that is called
    when the `Jump` Action is triggered. It should look as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的方法 `OnJump()`。这将是在 `Jump` 动作被触发时调用的方法。它应该如下所示：
- en: '[PRE12]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We want our `OnJump()` method to perform similarly to the following statement
    we have commented out in our `Update()` method.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望我们的 `OnJump()` 方法的表现与我们在 `Update()` 方法中注释掉的以下语句相似。
- en: '[PRE13]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Cut and paste it into the `OnJump()` method.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其复制粘贴到 `OnJump()` 方法中。
- en: 'Remove `&& Input.GetButtonDown("Jump")` from the `if` statement. Your `OnJump()`
    method should now appear as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `if` 语句中移除 `&& Input.GetButtonDown("Jump")`。现在你的 `OnJump()` 方法应该如下所示：
- en: '[PRE14]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let’s hook this method up in the Inspector. Select your `Cat` from the
    Hierarchy and add the `PlayerInput` Component. Your Cat’s Inspector should have
    the following components:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在检查器中连接这个方法。从层次结构中选择您的`Cat`，并添加`PlayerInput`组件。您的Cat检查器应具有以下组件：
- en: '![Figure 20.21: Some of the components on Cat](img/Figure_20.21._B18327.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图20.21：Cat上的一些组件](img/Figure_20.21._B18327.jpg)'
- en: 'Figure 20.21: Some of the components on Cat'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.21：Cat上的一些组件
- en: 'Now let’s add our Actions to the `CatActions` from the Project folder into
    the **Actions** slot. Your component should now look as follows:![Figure 20.22:
    Assigning CatActions to the PlayerInput component](img/Figure_20.22._B18327.jpg)'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将我们的动作添加到项目文件夹中的`CatActions`到**Actions**槽中。您的组件现在应如下所示：![图20.22：将CatActions分配给PlayerInput组件](img/Figure_20.22._B18327.jpg)
- en: 'Figure 20.22: Assigning CatActions to the PlayerInput component'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图20.22：将CatActions分配给PlayerInput组件
- en: Notice it already found our **Player** Action Map and added it as the **Default
    Map**. If we had more Action Maps, there would be others in the dropdown we could
    choose from.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意它已经找到了我们的**Player**动作映射并将其添加为**默认映射**。如果我们有更多的动作映射，还有其他选项可供选择。
- en: From the **Behavior** dropdown, select **Invoke Unity Events**. This will add
    an **Events** setting that can be expanded to reveal a list of **Player** Events.
    Expanding **Player** will show the two Actions we have defined within the Player
    Map along with some other useful Actions.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Behavior**下拉菜单中选择**Invoke Unity Events**。这将添加一个**Events**设置，可以展开以显示**Player**事件的列表。展开**Player**将显示我们在玩家映射中定义的两个动作以及其他一些有用的动作。
- en: '![Figure 20.23: The Various Player Action Events](img/Figure_20.23._B18327.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图20.23：各种玩家动作事件](img/Figure_20.23._B18327.jpg)'
- en: 'Figure 20.23: The Various Player Action Events'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.23：各种玩家动作事件
- en: 'We can hook up our `OnJump()` method to the `Cat` into the Object slot, and
    then selecting **PlayerInputBasicCharacterController** | **OnJump**. Your **Jump**
    Event should now appear as follows:![Figure 20.24: The Player Jump Event calling
    our OnJump method](img/Figure_20.24._B18327.jpg)'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将我们的`OnJump()`方法连接到`Cat`对象的`Object`槽中，然后选择**PlayerInputBasicCharacterController**
    | **OnJump**。您的**Jump**事件现在应如下所示：![图20.24：玩家跳跃事件调用我们的OnJump方法](img/Figure_20.24._B18327.jpg)
- en: 'Figure 20.24: The Player Jump Event calling our OnJump method'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图20.24：玩家跳跃事件调用我们的OnJump方法
- en: Play the game and you should see the cat jump when you press the spacebar.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 玩游戏，当您按下空格键时，您应该看到猫跳跃。
- en: 'Now let’s hook up the Move Action. Return to your code and create the following
    method:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们连接移动动作。返回您的代码并创建以下方法：
- en: '[PRE15]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following variable declaration to your code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码中添加以下变量声明：
- en: '[PRE16]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we got the `movement` variable from the Input Axis, we used the following
    line:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们从输入轴获取`movement`变量时，我们使用了以下行：
- en: '[PRE17]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will get the value of the Move Action whenever the `OnMove()` method is
    called.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在调用`OnMove()`方法时获取移动动作的值。
- en: 'Return to your `Update()` method and uncomment the remaining code. Your `Update()`
    method should appear as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回您的`Update()`方法并取消注释剩余的代码。您的`Update()`方法现在应如下所示：
- en: '[PRE18]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Delete the following line that uses the old Input System.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除以下使用旧输入系统的行。
- en: '[PRE19]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Edit the remaining line to use the `moveVector` instead of the movement float.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将剩余的行编辑为使用`moveVector`而不是`movement`浮点数。
- en: '[PRE20]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Remove the `movement` float variable declaration since we no longer need it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除不再需要的`movement`浮点变量声明。
- en: 'Return to your Inspector and add the `OnMove()` method to the `Cat` into the
    Object slot, and then selecting **PlayerInputBasicCharacterController** | **OnMove**.
    Your Move Event should now appear as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回您的检查器，并将`OnMove()`方法添加到`Cat`的`Object`槽中，然后选择**PlayerInputBasicCharacterController**
    | **OnMove**。您的移动事件现在应如下所示：
- en: '![Figure 20.25: The Player Move Event calling our OnMove method](img/Figure_20.25._B18327.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图20.25：玩家移动事件调用我们的OnMove方法](img/Figure_20.25._B18327.jpg)'
- en: 'Figure 20.25: The Player Move Event calling our OnMove method'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.25：玩家移动事件调用我们的OnMove方法
- en: Play the game and your cat should now be able to move and jump!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏，现在您的猫应该能够移动和跳跃了！
- en: Personally, I’m not a fan of using the `PlayerInput` component. Since I am a
    programmer by trade, I prefer to spend most of my time in my code editor rather
    than the Unity Editor. I find debugging code that is hooked up in the inspector
    difficult to debug. When I do use this functionality, I try to make life easier
    for my future self (or my other programming coworkers) by adding comments to the
    code that states what components call what methods. This can make debugging and
    understanding the way the code works a little easier. Using a code editor like
    Jetbrains Rider can relieve some of this stress, as it will indicate where code
    is hooked up in the Inspector, but it does not always show all necessary information
    and you can’t count on your coworkers also having the Rider IDE. If you have a
    similar preference, I will show you in the next example how to do this in a code-centric
    way.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我不太喜欢使用 `PlayerInput` 组件。由于我是一名程序员，我更喜欢把大部分时间花在代码编辑器上，而不是 Unity 编辑器上。我发现调试在检查器中连接的代码比较困难。当我使用此功能时，我会尝试通过在代码中添加注释来使未来的自己（或我的其他编程同事）的生活更轻松，注释中说明了哪些组件调用哪些方法。这可以使调试和理解代码的工作方式变得更容易。使用像
    Jetbrains Rider 这样的代码编辑器可以减轻一些压力，因为它会指示代码在检查器中的连接位置，但它并不总是显示所有必要的信息，而且你不能指望你的同事也使用
    Rider IDE。如果你有类似的偏好，我将在下一个示例中向你展示如何以代码为中心的方式完成此操作。
- en: Creating a basic character controller by referencing Actions in your code
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过在代码中引用动作创建基本角色控制器
- en: 'To redo our previous example so that it references the Actions in code, complete
    the following steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新执行我们之前的示例，以便在代码中引用动作，请完成以下步骤：
- en: To preserve the previous example, I am going to duplicate the scene and call
    it `Chapter 20` `– Example 3`; duplicate the `PlayerInputBasicCharacterController.cs`
    script; and rename the duplicate to `ActionReferenceBasicCharacterController.cs`.
    If you’d rather just work in the same scene with the same script, you can skip
    this step. However, if you do want to do this, make sure to also change the name
    of the script in the class definition and add the script as a component to the
    `Cat` in your new scene.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保留之前的示例，我将复制场景并命名为 `第20章` `– 示例3`；复制 `PlayerInputBasicCharacterController.cs`
    脚本；并将副本重命名为 `ActionReferenceBasicCharacterController.cs`。如果你更愿意在同一个场景中使用相同的脚本，你可以跳过此步骤。但是，如果你确实想这样做，请确保也更改类定义中的脚本名称，并将脚本作为组件添加到你的新场景中的
    `Cat` 对象上。
- en: Delete the `Cat`’s Inspector. Notice if you try to play the game now, the cat
    will not move or jump, since we removed the component that tied the inputs to
    our code.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `Cat` 的检查器。注意，如果你现在尝试玩游戏，猫将不会移动或跳跃，因为我们移除了将输入与我们的代码连接的组件。
- en: Open the `ActionReferenceBasicCharacterController.cs` script.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ActionReferenceBasicCharacterController.cs` 脚本。
- en: Comment out the `OnMove()` method. We will not be calling this via an Event
    in the Inspector, so we do not need the method. However, we will write code similar
    to it, so I’ll comment it out for now so I can copy and paste it into the correct
    place later.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉 `OnMove()` 方法。我们不会在检查器中通过事件调用此方法，因此不需要该方法。然而，我们将编写类似于此方法的代码，所以我现在先注释掉它，以便稍后可以复制并粘贴到正确的位置。
- en: 'The first thing we need to do is get a reference to the Action Asset that holds
    all of our Actions. Create the following variable declaration:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取包含所有动作的动作资产的引用。创建以下变量声明：
- en: '[PRE21]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can go ahead and hook this up in the Inspector by dragging the `CatActions`
    asset into the **Actions** slot.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将 `CatActions` 资产拖动到检查器的 **动作** 槽中，在检查器中完成此操作。
- en: Return to the script. Add an empty `OnEnable()` method and `OnDisable()` method
    to your script. We’ll add some code to them momentarily.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到脚本。为你的脚本添加一个空的 `OnEnable()` 方法和 `OnDisable()` 方法。我们稍后会向它们添加一些代码。
- en: I prefer to put the `OnEnable()` method right under the `Awake()` method since
    it executes after it and the `OnDisable()` method at the bottom of the script
    since it will execute after all of our other methods.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我喜欢将 `OnEnable()` 方法放在 `Awake()` 方法下面，因为它在它之后执行，而将 `OnDisable()` 方法放在脚本底部，因为它将在我们的其他所有方法之后执行。
- en: Since we are referencing our Actions via code, we will need to enable and disable
    our Action Map. Add the following boldened lines of code to your `OnEnable()`
    and `OnDisable()` methods.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们通过代码引用我们的动作，我们需要启用和禁用我们的动作映射。将以下加粗的代码行添加到你的 `OnEnable()` 和 `OnDisable()`
    方法中。
- en: '[PRE22]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now let’s hook up our Jump Action. We will accomplish this by subscribing to
    the Jump Action’s `performed` event. Add the following code to your `OnEnable()`
    method.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们连接我们的跳跃动作。我们将通过订阅跳跃动作的`performed`事件来完成此操作。将以下代码添加到你的`OnEnable()`方法中。
- en: '[PRE23]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This should be enough to get the `OnJump()` method we already wrote working
    with your Action Map. Play the game and you can now see the cat jump when you
    press the space bar.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该足以让之前编写的`OnJump()`方法与你的动作映射一起工作。玩游戏，你现在可以在按下空格键时看到猫跳跃。
- en: 'While not entirely necessary for this example, I prefer to make a habit of
    always unsubscribing from any events I subscribe to in `OnDisable()`. Making a
    habit of doing it will save me from problems in the future when it is necessary.
    So, add the following line of code to the top of your `OneDisable()` method:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然在这个例子中并非完全必要，但我更喜欢养成在`OnDisable()`中总是取消订阅任何已订阅事件的习惯。养成这个习惯将使我未来在需要时避免问题。因此，将以下代码行添加到你的`OneDisable()`方法顶部：
- en: '[PRE24]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let’s hook up our Move Action. To do this, we can create a reference to
    the `InputAction` that represents the Move Action to make it easily accessible
    via code. Add the following variable declaration to the top of your code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们连接我们的移动动作。为此，我们可以创建一个表示移动动作的`InputAction`的引用，以便通过代码轻松访问。将以下变量声明添加到你的代码顶部：
- en: '[PRE25]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now let’s initialize it. Add the following line of code to your `OnEnable()`
    method.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们初始化它。将以下代码行添加到你的`OnEnable()`方法中。
- en: '[PRE26]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Instead of subscribing to the Move Action, we’ll poll it in our `Update()` method.
    Cut and paste the following code from within your commented out `OnMove()` method
    to the top of your `Update()` method. You can delete the `OnMove()` method now.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是订阅移动动作，而是在`Update()`方法中轮询它。将以下代码从你的注释掉的`OnMove()`方法中剪切并粘贴到`Update()`方法顶部。你现在可以删除`OnMove()`方法了。
- en: '[PRE27]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will get an error on the `context` variable. It was a parameter for the
    `OnMove()` method and does not exist within the `Update()` method. Instead of
    reading the value of `context`, we will read the value of `playerMoveAction`.
    Replace `context` with `playerMoveAction` so that your `Update()` method appears
    as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在`context`变量上遇到错误。它是`OnMove()`方法的参数，在`Update()`方法中不存在。我们不再读取`context`的值，而是读取`playerMoveAction`的值。将`context`替换为`playerMoveAction`，以便你的`Update()`方法如下所示：
- en: '[PRE28]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And that should be sufficient to get our cat moving with Actions and without
    the `PlayerInput` component. Play the game and watch the cat move around and jump
    when you press the appropriate keys.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样应该足以让我们的猫通过动作移动，而不需要`PlayerInput`组件。玩游戏，观察猫在按下适当的键时移动和跳跃。
- en: I know that setting our specific project up to use the Input System rather than
    using the Input Manager was a lot more work and may not seem worth it. And for
    this tiny example, that is probably true. However, if we wanted to create a cross
    platform version of this project that accepted inputs from multiple types of devices,
    adding new Bindings to an Action within an Action Map is significantly less work
    than adding in a new line of code for each possible input configuration we want
    to work with.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道将我们的特定项目设置为使用输入系统而不是使用输入管理器要花费更多的工作，可能看起来不值得。对于这个微小的例子，这可能确实如此。然而，如果我们想要创建一个跨平台版本的项目，该版本可以接受来自多种类型设备的输入，那么在动作映射中为动作添加新的绑定比为每个我们想要处理的可能输入配置添加新的一行代码要简单得多。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to use the New Input System to collect input
    for your game. This allows us to make an easily customizable input system that
    can make controlling our game via various input devices significantly easier in
    the long run. It may take a bit if set work to set up, but it can save you a lot
    of effort in the long run.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用新的输入系统来收集游戏输入。这使我们能够创建一个易于定制的输入系统，可以从长远来看显著简化通过各种输入设备控制游戏。虽然设置起来可能需要一些工作，但它可以节省你大量的精力。
- en: And so, we come to an end of the book! I have no more User Interface knowledge
    to impart to you.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们来到了本书的结尾！我再也没有更多用户界面知识可以传授给你们了。
