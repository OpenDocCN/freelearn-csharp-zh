- en: Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: State-driven behavior DIY states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior State Design Pattern classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior with Unity Scriptable Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publisher-Subscriber pattern C# delegates and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC) pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer programming in general, some types of features and requirements
    occur commonly. For computer game programming, there are often features for new
    games that have things in common with existing games. Software **Design Patterns**
    are reusable, computer-language-independent templates for how to solve common
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Not all design patterns are needed for all languages (for example, some computer
    languages may have features that already provide an easy way to solve a common
    problem). In this chapter, we'll explore several common design patterns in the
    context of Unity game programming in the C# programming language.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no need to reinvent the wheel, and there are many advantages for game
    programmers to adopt tried-and-tested approaches to solving common features for
    game projects. Design patterns have been designed by experience, and refined to
    encourage good programming practice and well-designed architectural software solutions.
    A common theme in design patterns is the independence of code components, and
    clearly-defined interfaces for when components do need to know about each other
    and the protocols for their interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the recipes focus on three main design patterns, all of which
    are well known and found not only in game software designs but in the design of
    many interactive software systems, such as web applications and mobile phone programming.
    The design patterns explored in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The State pattern**: States and their transitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Publisher-Subscriber pattern**: Observers subscribing to event-publishing
    objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Model-View-Controller (MCV) pattern**: Separating internal workings from
    UI components and display representations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, examples are presented in generic object-oriented designs,
    also there are C#-specific features (such as **delegates** and **events**), and
    some Unity-specific features (such as **scriptable objects**). While generic approaches
    have the advantage that programmers from other languages or domains will be instantly
    familiar with their Unity game implementations, the most significant game memory-speed
    improvements are found through exploiting language- and engine-specific features.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# **Delegate** variables are like a container for a function (or collection
    of functions) that can be passed around and invoked. They have values assigned
    to them and can be changed at runtime. **Delegates** can multicast through the
    use of the `+=` operator, multiple methods can be assigned a single delegate,
    and all will be invoked when the delegate is invoked. C# **events** are a special,
    more secure kind of delegate. By defining public static event variables, we restrict
    other script classes to only be allowed to:'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe one of their methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribe one of their methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events ensure a good separation of our code logic, and mean that the script
    class publishing events does not need to know anything about, or how many, other
    script classes are subscribing to published events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some sources where you can learn more about **Design Patterns** and
    Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity tutorial about **Scriptable Objects** for enemy state-driven AI:
    [https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern](https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Unity tutorial about **delegates** and **events**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117](https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://unity3d.com/learn/tutorials/topics/scripting/events](https://unity3d.com/learn/tutorials/topics/scripting/events)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prime[31]''s video about Unity delegates and events (from 2011, but still a
    nice introduction): [http://www.youtube.com/watch?v=N2zdwKIsXJs](http://www.youtube.com/watch?v=N2zdwKIsXJs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eric Nordeus'' tutorial on Unity and **Design Patterns**: [http://www.habrador.com/tutorials/programming-patterns/](http://www.habrador.com/tutorials/programming-patterns/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity **Model-View-Controller** tutorials:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gameasutra: [https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php](https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eduardo Dias Da Costa: [https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development](https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jackson Dunstan: [https://jacksondunstan.com/articles/3092](https://jacksondunstan.com/articles/3092)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior DIY states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Games as a whole, and individual objects or characters, can often be thought
    of (or modeled as) passing through different states or modes. Modeling states
    and changes of state (due to events or game conditions) is a very common way to
    manage the complexity of games and game components. In this recipe, we create
    a simple three-state game (game playing/game won/game lost) using a `GameManager`
    class. Buttons and a timer are provided to simulate the events that would allow
    a player to win or lose the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db3d658f-f2bb-45a7-b80a-21f607df37ec.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use states to manage object behavior, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create two UI Buttons at the top-middle of the screen. Name one `Button-win`
    and edit its text to read `Win Game`. Name the second `Button-lose` and edit its
    text to read `Lose Game`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UI Text object at the top left of the screen. Name this `Text-state-messages`,
    and set its Rect Transform height property to `300` and its Text (Script) Paragraph
    Vertical Overflow property to `Overflow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script class,&nbsp;`GameStates.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the&nbsp;`MyGameManager.cs`&nbsp;C# script class, and add an instance
    object as a component to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the&nbsp;`ButtonActions.cs`&nbsp;C# script class, and add an instance
    object as a component to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the Hierarchy, select the Button-win button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the ButtonsActions component in the Main Camera GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, select the Button-lose button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the ButtonActions component in the Main Camera GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, select the Main Camera GameObject. Drag this GameObject into
    the Inspector to ensure that all three GameManager (Script) public variables (Text
    State Messages, Button Win Game, and Button Lose Game)&nbsp;have the corresponding
    Canvas GameObjects dragged into them (the two buttons and the UI Text GameObject).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As can be seen in the following state chart figure, this recipe models a simple
    game, which starts in the `GamePlaying` state; then, depending on the button clicked
    by the user, the game moves either into the `GameWon` state or the `GameLost`
    state. Also, if the user waits too long (five seconds) to click on a button, the
    game moves into the `GameLost` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible states of the system are defined using the enumerated&nbsp;`GameStateType`&nbsp;type
    in the&nbsp;`GameStates` class, and the current state of the system at any point
    in time is stored in the&nbsp;`currentState` variable of GameManager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/618d0afd-9a1a-42b7-878d-22f91b072349.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial state,&nbsp;`GamePlaying`, is set in the `Start()` method of `MyGameManager`.
  prefs: []
  type: TYPE_NORMAL
- en: '`GameManager` seems to now be a special asset name in Unity, for that reason,
    we have named our game manager script classes `MyGameManager` to avoid any issues.'
  prefs: []
  type: TYPE_NORMAL
- en: When the `MyGameManager` object receives messages (for example, every frame
    for `Update()`), its behavior must be appropriate for the current state. So, we
    see a `Switch` statement in the&nbsp;`Update()` method&nbsp;that calls state-specific
    methods. For example, if the current state is `GamePlaying`, when an `Update()`
    message is received, the `UpdateStateGamePlaying()` method will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NewGameState(...)` method first calls the `OnMyStateExit(...)` method
    with the current state, since there may be actions to be performed when a particular
    state is exited; for example, when the `GamePlaying` state is exited, it destroys
    the two buttons. Next, the `NewGameState(...)` method sets the `currentState`
    variable to be assigned the new state. Next, the `OnMyStateEnter(...)` method
    is called, since there may be actions to be performed immediately when a new state
    is entered. Finally, a message divider is posted     to the UI Text box, with a call to the `PostMessageDivider()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The `BUTTON_CLICK_ACTION_WIN_GAME()` and `BUTTON_CLICK_ACTION_LOSE_GAME()` methods
    are executed if their corresponding buttons have been clicked. They move the game
    into the corresponding `GameWon` or `GameLost` state.
  prefs: []
  type: TYPE_NORMAL
- en: Logic has been written in the `UpdateStateGamePlaying()` method, so once&nbsp;`MyGameManager`
    has been in the `GamePlaying` state for more than a certain time (defined in the&nbsp;`timeToPressAButton`
    variable), the game will automatically change into the `GameLost` state.
  prefs: []
  type: TYPE_NORMAL
- en: So, for each state, we may need to write methods for state exit, state entry,
    and update events, and also a main method for each event with a Switch statement
    to determine which state method should be called (or not). As can be imagined,
    the size of our methods and the number of methods in our `MyGameManager` class
    will grow significantly as more states and a more complex game logic are needed
    for non-trivial games.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipe takes a more sophisticated approach to state-driven games, where
    each state has its own class. The next recipe in this chapter illustrates how
    to manage the complexity of states with class inheritance and the State Design
    Pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior using the State Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous pattern illustrated not only the usefulness of modeling game states,
    but also how a game manager class can grow in size and become unmanageable. To
    manage the complexity of many states and complex behaviors of states, the State
    pattern has been proposed in the software-development community. Design patterns
    are general-purpose software component architectures that have been tried and
    tested and found to be good solutions to commonly-occurring software-system features.
    The key features of the State pattern are that each state is modeled by its own
    class and that all states inherit (are subclassed) from a single parent state
    class. The states need to know about each other in order to tell the game manager
    to change the current state. This is a small price to pay for the division of
    the complexity of the overall game behavior into separate state classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Many thanks to the contribution from Bryan Griffiths, which has helped
    improve this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds upon the previous recipe. So, make a copy of that project,
    open it, and then follow the steps for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manage an object''s behavior using the State pattern architecture, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script class called `GameState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class called `StateGamePlaying`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class called `StateGameWon`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class called `StateGameLost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the contents of the&nbsp;`MyGameManager`&nbsp;C# script class with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the Hierarchy, select the Button-win button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the GameManager component in the Main Camera GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, select the Button-lose button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the GameManager component in the Main Camera GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, select the Main Camera GameObject. Drag&nbsp;it into the Inspector
    to ensure that all three GameManager (Script) public variables (Text State Messages,
    Button Win Game, and Button Lose Game)&nbsp;have the corresponding Canvas GameObjects
    dragged into them (the two buttons and the **UI Text** GameObject).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scene is very straightforward for this recipe. There is the single Main
    Camera GameObject that has the `MyGameManager` script object component attached
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: "A C# scripted class is defined for each state that the game needs to manage—for\
    \ this example,&nbsp;`StateGamePlaying`, `StateGameWon`, and `StateGameLost`.\
    \ Each of these state classes is a subclass of `GameState`. `GameState` defines\
    \ properties \Land methods that all subclass states will possess:"
  prefs: []
  type: TYPE_NORMAL
- en: 'An enumerated type `EventType`, which defines the two possible button click
    events that the game might generate: `ButtonWinGame` and `ButtonLoseGame`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gameManager` variable so that each state object has a link to the game
    manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor method that accepts a reference to `MyGameManager`, which&nbsp;automatically
    makes the `gameManager` variable refer to the passed-in `MyGameManager` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The four methods with empty bodies: `OnMyStateEntered()`, `OnMyStateExit()`,
    `OnEventRecieved(...)`, and `StateUpdate()`. Note that these methods are declared
    virtual so that they can be overridden by subclasses if necessary, but if not
    overridden then will do nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the `MyGameManager` class''s&nbsp;`Awake()` method is executed, three
    state objects are created, one for each of the playing/win/lose classes. These
    state objects are stored in their corresponding variables: `stateGamePlaying`,
    `stateGameWon`, and `stateGameLost`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `MyGameManager` class has a variable called `currentState`, which is a reference
    to the current state object at any time while the game runs (initially, it will
    be null). Since it is of the `GameState` class (the parent of all state classes),
    it can refer to any of the different state objects.
  prefs: []
  type: TYPE_NORMAL
- en: After `Awake()`, `GameManager` will receive a `Start()` message. This method
    initializes&nbsp;`currentState` to be the `stateGamePlaying` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each frame,&nbsp;`GameManager` will receive `Update()` messages. Upon receiving
    these messages, `GameManager` sends a `StateUpdate()` messages to&nbsp;`currentState     &nbsp;`&nbsp;object. So, for each frame, the object for the current state of the
    game will execute those methods. For example, when&nbsp;`currentState` is set
    to game playing, for each frame, the `gamePlayingObject` will calls its (in this
    case, empty) `StateUpdate()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The `StateGamePlaying` class implements statements in its `OnEventReceived()`
    method so that when the user clicks on a button, the `gamePlayingObject` will
    call the `GameManager` instance's `NewState(...)` method, passing it the object
    corresponding to the new state. So for example, if the user clicks on Button-win,
    the `NewState(...)` method is passed to `gameManager.stateGameWon`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Timer event to lose the game after five seconds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The state pattern solution makes it much simpler, and cleaner to add new features.
    For example, to add the five-second-timer feature to this recipe, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script class called `SimpleTimer`, and add an instance object
    as a component to the Main Camera GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new event type of `TimerFinished` to the `GameState` script class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new case to the switch statement in `StateGamePlaying`, so that this
    `TimerFinished` event also causes the game to go into the `GameLost` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, some of the complexity of different types of events causing
    the `MyGameManager` to change its current state was implemented by other scripted
    objects (`ButtonActions` and `SimpleTimer` as scripted object components inside
    Main Camera) invoking the&nbsp;`PublishEventToCurrentState(...)` public method.
    A better was to implement events in games is provided later in this chapter in
    the&nbsp;*Publisher-Subscriber pattern C# delegates and events* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State-driven behavior with Unity Scriptable Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity has a feature called Scriptable Objects. Scriptable Objects are asset
    files stored in the `Assets` folder, like any other asset (such as Materials or
    Textures). In some ways,&nbsp;Scriptable Objects are like Monobehaviours, but
    they are not attached to GameObjects. Both logic (code) and data can be stored
    as asset files in the form of&nbsp;Scriptable Objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we implement a state-based game where the game starts in a game-playing
    state, and goes to a game-lost state when a timer runs out. If two stars are collected
    before the timer runs out, the game goes into the game-won state. A **UI Button**
    is offered to the user, which collects a star each time it is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see, Scriptable Object asset files are used to represent which decisions
    cause which state changes to take place.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manage a game''s state-driven behavior with Unity Scriptable Objects, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **UI Button** in the middle of the screen. Name it `Button-collect-star`
    and edit its text to read `Collect a star`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Text** object at the top-right of the screen. Name this `Text-current-state`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Text** object at the top-left of the screen. Name this `Text-stars-collected`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second UI Text object at the top-left of the screen, positioned below
    `Text-stars-collected`. Name this `Text-seconds-left`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script class called `Decision`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class called `Transition`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class called `State`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class called `StateController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class called `GameWonDecision`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class called `GameLostDecision`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class called `MyGameManager`, and add an instance object
    as a component of the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the Hierarchy, select the Button-collect-star button, and for its Button
    (Script) component, add an OnClick action to call the `BUTTON_ACTION_PickupOneStar()`
    method from the `MyGameManager` component in the Main Camera GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create two new folders, named `_Decisions` and `_States`.
    These folders will contain the Scriptable Object asset files for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the&nbsp;`_Decisions` folder, create two new Decision Scriptable Objects
    named `GameWonDecision` and `GameLostDecision`. Do this by choosing menu: Assets
    | Create | MyGame | Decisions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the&nbsp;`_States` folder, create three new State Scriptable Objects named
    `StateGamePlaying`, `StateGameWon`, and `StateGameLost`. Do this by choosing menu:
    Assets | Create | MyGame | State.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the&nbsp;Project panel folder `_States`, select the&nbsp;`StateGamePlaying`
    Scriptable Object, and in the Inspector, set the size of its Transitions property
    to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Element 0, set the Decision to GameWonDecision and the True&nbsp;state to
    StateGameWon
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Element 1, set the Decision to GameLostDecision and the True&nbsp;state
    to StateGameLost:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/36fe5ff2-2a96-4d8a-babb-f9622131b3bf.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Hierarchy, select the Main Camera GameObject. Drag it into the Inspector
    to ensure that all three GameManager (Script) public variables (Text Current State,
    Text Stars Collected, and Text Seconds Left)&nbsp;have the corresponding Canvas
    **UI Text** GameObjects dragged into them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. The game should start in `StateGamePlaying`. If the user does
    nothing, when the timer gets to zero, the game should go into `StateGameLost`.
    If the user clicks the button twice (simulating collecting two stars) before the
    timer hits zero, the game should go into `StateGameWon`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GameManager knows nothing about the state-based decisions going on in this
    game. It has a public method giving the number of seconds left in the timer: `GetTimeRemaining()`.
    It also has a public method that returns a Boolean (true/false) about whether
    or not all stars have been collected: `HasCollectedAllStars()`. It also has references
    to the three&nbsp;**UI Text** GameObjects, so it can keep the display updated
    with the time left and stars collected. A public&nbsp;`DispayCurrentState(...)`&nbsp;method
    also updates the name of current game state (that is, whatever was passed to this
    method).'
  prefs: []
  type: TYPE_NORMAL
- en: The core game behavior is driven by the `StateController` script class. This
    maintains the current state, and has a reference to the instance object of the
    `MyGameManager` class that is its sibling component in the Main Camera. Its `Awake()`
    method gets the reference to the `MyGameManager` object. Its `Update()`&nbsp;method
    invokes the current state's `UpdateState(...)` method. It passes a reference to
    itself to the current state. It also has a third public method, `TransitionToState(...)`,
    which allows a state to instruct the controller to change the current state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Transition` class has no methods, it simply stores references to two objects:
    a decision and the state that the system will to change to if the decision is
    true.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Decision` class is abstract, which means there will never be any objects
    created from this class, but subclasses may be defined. It declares that any subclasses
    must implement a method named `Decide(...)`, which&nbsp;returns a Boolean (true/false)
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The `State` class has an array of `Transition` objects, and its `UpdateState()`
    method simple invokes its `CheckTransitions(...)` method.&nbsp;`CheckTransitions(...)`
    loops through each transition, testing its `Decision`. If the decision is true,
    it tells&nbsp;`StateController` to make the current state the true state of the
    transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we have declared two subclasses of the `Decision` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameWonDecision`: This class'' `Decide(...)` method returns the value of its&nbsp;`GameWonActionDetected(...)`
    method.&nbsp;`GameWonActionDetected(...)` returns the value of the game manager''s
    `HasCollectedAllStars()` method, that is, the game-won decision is true when the
    game manager says that all stars have been collected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameWonDecision`: This class''s&nbsp;`Decide(...)` method returns the value
    of its&nbsp;`GameLostActionDetected(...)` method.&nbsp;`GameLostActionDetected(...)`
    returns true if the game manager''s timer is zero or less (time has run out).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have created five scriptable object assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Three states**: `StateGamePlaying`, `StateGameWon`, `StateGameLost`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two decisions**: `GameWonDecision` and `GameLostDecision`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We were able to create these Scriptable Object assets via the Create menu through
    the statements immediately before the script-class declarations for `Decision`
    and `State` that declared that there should be a new sub-menu in the Create Asset
    menu named MyGame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The only one of these Scriptable Objects that needed any customizing was `StateGamePlaying`.
    Two transitions were defined in this object:'
  prefs: []
  type: TYPE_NORMAL
- en: If `GameWonDecision` becomes true, the State Controller should set the current
    state to `StateGameWon`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `GameLostDecision` becomes true, the State Controller should set the current
    state to `StateGameLost`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it may seem like there was a lot of work for this simple game, what this
    recipe illustrates is how some generic state-machine classes can be created (`State`,
    `Decision`, `Transition`, `StateController`), and that the actual game behavior
    is modelled through a set of Scriptable Object assets, and two classes to implement
    the decision-making for special game events (`GameWonDecision` and `GameLostDecision`).
  prefs: []
  type: TYPE_NORMAL
- en: Since Scriptable Object are asset files, there are only one of them. At times,
    we may want the same Scriptable Object to be used by different GameObjects when
    the game is running—for example, the state transitions for the AI of lots of different
    enemy characters may share the use of the same Scriptable Object. For this reason,
    a reference to a `StateController` object instance is passed when methods are
    invoked on `State` and `Decision` Scriptable Objects,&nbsp;so the logic in the
    methods of the Scriptable Object can work on whatever run-time controller object
    is provided with. This is an example of another design pattern known as the **Delegate**
    design pattern (not to be confused with a C# delegate!).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the game to model Player health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To further understand the power of this data-centric approach to state-based
    games, let''s add the following behavior to the game:'
  prefs: []
  type: TYPE_NORMAL
- en: The player has a health value, starting at 100% (a float value of 1.0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each frame, a random amount of health is added or subtracted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game is lost if the health of the player goes down to zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement this feature, all we need to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a test to the&nbsp;`GameLostDecision`&nbsp;script class to return true
    if time or health are zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `health` feature to the&nbsp;`GameManager` script class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We could also add another **UI Text** on screen to see the current value of
    health. If the public `healthPlusMaximum` variable is set smaller than the minus
    maximum (for example,&nbsp;`0.02`), the health will go downwards since the random
    average will be less than zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add another state, such as&nbsp;`StatePauseGame`, all that is needed are
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new&nbsp;`GamePausedDecision` script class, with the logic to detect
    whether the game is paused (for example, the game manager could have an&nbsp;`isPaused`&nbsp;boolean
    variable that gets set to true when the user presses the *P* key)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new&nbsp;`StateGamePaused` Scriptable Object State
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new&nbsp;`GamePausedDecision` Scriptable Object State
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a third transition to the&nbsp;`StateGamePlaying`&nbsp;Scriptable Object
    State (element 2), with `GamePausedDecision` and the true state of `StateGamePaused`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see this approach to state-driven games using Scriptable Objects taken much
    further, including adding the feature for actions to be performed during each
    state, follow the online video Unity tutorial about Scriptable Objects for enemy
    state-driven AI:&nbsp;[https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern](https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publisher-Subscriber pattern C# delegates and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When events can be based on visibility, distance, or collisions, we can use
    such events as `OnTriggerExit` and `OnBecomeInvisible`. When events can be based
    on time periods, we can use coroutines. However, some events are unique to each
    game situation, and C# offers several methods of broadcasting user-defined event
    messages to scripted objects. One approach is the `SendMessage(...)` method, which,
    when sent to a GameObject, will check every Monobehaviour scripted component and
    execute the named method if its parameters match. However, this involves an inefficient
    technique known as reflection. C# offers another event message approach known
    as delegates and events, which we describe and implement in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and events work in a similar way to `SendMessage(...)`, but are much
    more efficient since Unity maintains a defined list of which objects are listening
    to the broadcast events. `SendMessage(...)` should be avoided if performance is
    important, since it means that Unity has to analyze each scripted object (reflect
    over the object) to see whether there is a public method corresponding to the
    message that has been sent; this is much slower than using delegates and events.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates separate the code declaring the delegate from any of the codes (classes)
    that use the delegate. The script-class that declares the public delegate does
    not need to know anything about the object or objects that make use of its delegated
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and events implement the **Publisher-Subscriber design pattern** (**pubsub**).
    This is also known as the **Observer** design pattern. Objects can subscribe one
    of their methods to receive a particular type of event message from a particular
    publisher. In this recipe, we'll have a manager class that will publish new events
    when **UI Buttons** are clicked. We'll create some **UI objects**, some of which
    subscribe to the color-change events. Each time a color-change event is published,
    subscribed **UI objects** receive the event message and change their color accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add a console event logger, to listen for and log messages about
    color-change events.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# publisher objects don''t have to worry about how many objects subscribe
    to them at any point in time (it could be none or 1,000!). This is known as **loose
    coupling**, since it allows different code components to be written (and maintained)
    independently and is a desirable feature of object-oriented code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2154430f-5063-4aa5-a1ab-610c558782c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, a Unity Package has been provided (`colorChangeScene.unitypackage`)
    in the `17_04` folder. This package contains a scene with **UI Buttons** and other
    objects for the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the Publisher-Subscriber pattern using C# delegates and events,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity project, and delete the default&nbsp;`Scenes` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided Unity package (`colorChangeScene.unitypackage`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `ColorManager` C# script class to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the&nbsp;`ColorChangeListenerImage`&nbsp;C# script class, and add an
    instance object as a component to the&nbsp;`Image-listening` and `Slider-listening`
    GameObjects (both children of&nbsp;Canvas | listening-game-objects):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the&nbsp;`ColorChangeListenerText`&nbsp;C# script class, and add an
    instance object as a component to the&nbsp;`Text-listening` GameObject&nbsp;(a
    child of&nbsp;Canvas | listening-game-objects):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `ColorChangeListenerConsole` C# script class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `ColorModel` C# script class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With button-GREEN selected in the Hierarchy, add a new OnClick() event for this
    button, dragging the Main Camera as the target GameObject and selecting the&nbsp;BUTTON_ACTION_make_green()
    public function. Do the same for the button-BLUE and button-RED buttons with the&nbsp;BUTTON_ACTION_make_blue()
    and BUTTON_ACTION_make_red() functions, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. When you click a change-color button, the three **UI objects**
    on the right of the screen show all changes to the corresponding color, while
    the two **UI objects** at the bottom-left of the screen remain in the default
    white color. You should also see `Debug.Log` messages in the Console panel, showing
    the RBG color corresponding to the button that was clicked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have added an instance object of `ColorManager` to the Main Camera. This
    class does three main things:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an instance object of the&nbsp;`ColorChangeListenerConsole` script class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates an instance object of the&nbsp;`ColorModel` script class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offers three public methods that can be invoked by clicking the red/green/blue
    UI Buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time a button is clicked, the `colorModel` object is told to `SetColor(...)`
    to the corresponding color.
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorModel`&nbsp;script class has a private variable of the current color.
    This value can be changed by invoking its `SetColor(...)` method (from the `ColorManager`
    when a button is clicked). As well as changing the value of color, the&nbsp;`SetColor(...)`&nbsp;method
    also invokes the&nbsp;`PublishColorEvent()` method. The&nbsp;`PublishColorEvent()`&nbsp;method
    publishes the&nbsp;`OnChangeColor(this.color)` event,&nbsp;so that all registered
    listeners to this event will be invoked with the new color value.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side of the screen, we have three GameObjects: Image-listening,
    Slider-listening, and Text-listening. Each of these objects has a scripted component
    of either `ColorChangeListenerImage` or `ColorChangeListenerText`. These components
    register their respective `OnChangeColor(...)` methods to listen for `OnChangeColor(this.color)`
    events. The `ColorChangeListenerImage` and `ColorChangeListenerText` script classes
    both register their `ChangeColor(...)` methods to the `OnChangeColor(...)` event
    of the `ColorModel` script class.'
  prefs: []
  type: TYPE_NORMAL
- en: The&nbsp;`ColorChangeListenerConsole`&nbsp;script class also registers its `ChangeColor(...)`
    methods to the `OnChangeColor(...)` event of the&nbsp;`ColorModel` script class.
  prefs: []
  type: TYPE_NORMAL
- en: Since our scripted objects may be disabled and enabled at different times, each
    time a scripted `ColorChangeListener` object is enabled (such as when its GameObject
    parent is instantiated), its `OnChangeColor()` method is added (`+=`) to the list
    of those subscribed to listen for color-change events, likewise, each time `ColorChangeListenerImage`
    or `Text` objects are disabled, those methods are removed (`-=`) from the list
    of event subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important that methods are removed from the list of subscribers to
    an event when they are no longer required. Failure to do this can lead to significant
    problems, such as memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: When `ColorChangeListenerImage` or a `Text` object receives a color-change message,
    its subscribed `OnChangeColor()` method is executed and the color of the appropriate
    component is changed to the received color value (green/red/blue).
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorManager` class declares a **Delegate** named `ColorChangeHandler`.
    Delegates define the return type (in this case, `void`) and argument signature
    of methods that can be delegated (subscribed) to an event. In this case, methods
    must have the argument signature of a single parameter of the&nbsp;`Color` type.
    Our `OnChangeColor()` method in the&nbsp;`ColorChangeListenerImage`, `Text`, and
    `Console`&nbsp;classes matches this argument signature and so is permitted to
    subscribe to&nbsp;`changeColorEvent` in the `ColorManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that&nbsp;`ColorChangeListenerConsole` does not have `OnEnable`
    or `OnDisable` methods. This is because it is not a MonoBehaviour, and so does
    not receive Unity runtime events such as `Awake()`, `Update()`, or `OnEnable()`.
    However, being a simple class, it can have a constructor method invoked when a
    new object instance is created with the new keyword, and a destructor method invoked
    when the object is no longer referenced. So it is in those methods that these
    objects register and deregister to listen to `ColorModel.OnChangeColor` events.
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC) pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Model-View-Controller** (**MVC**) pattern is a software architecture that
    tries to separate the data (Model) from the displays (Views) and actions that
    change that data (Controller).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we use the MVC pattern to implement a feature of many games—a
    visual health bar representing the Player''s numeric health value (in this case,
    a float number from 0.0 - 1.0). As the user presses the Up/Down arrow keys (simulating
    healing and damage), the value of the player''s heath changes. With the health-change
    events, the visual display and a **Console** log are updated to present the new
    health values to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f1a83c1-3d1a-4ecd-8b51-b8ba25b99953.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, two images been provided in the `17_05` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`health_bar_outline.png`: A red heart image and outline for the health filler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`health_bar_fill_blue_to_green.png`: A graduated (blue left to green right)
    filler image, indicating how much health is left'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thanks to Pixel Art Maker for the health bar image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://pixelartmaker.com/art/49e2498a414f221](http://pixelartmaker.com/art/49e2498a414f221)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the MVC pattern in Unity, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the two provided images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Image** named `Image-health-bar-outline`, and populate it with
    the `health_bar_outline` image asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Image** named `Image-health-bar-filler`, and populate it with
    the `health_bar_fill_blue_to_green` image asset. In the Inspector for the Image
    (Script) component, set the Image Type to Filled, and the Fill Type to Horizontal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arrange your **Canvas** so that Image-health-bar-filler is before Image-health-bar
    in the Hierarchy (the filler appears behind the outline).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script class,&nbsp;`Player`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class,&nbsp;`PlayerController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class,&nbsp;`HealthBarDisplay`, and add an instance
    object as a component to `Image-health-bar-filler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class,&nbsp;`HealthChangeLogger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `PlayerManager` C# script class&nbsp;to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Run the game. Pressing the Up/Down arrow keys should raise/lower the player's
    health, which should be confimed by the meter fill image, and in the `Debug.Log()`
    messages in the **Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You were provided with two&nbsp;**UI Images**:&nbsp;one is a health bar outline
    (red heart and a black outline), the second is the filler image—to show dark blue
    to light blue to green, for weak to strong health values.
  prefs: []
  type: TYPE_NORMAL
- en: You set the Image Type of Image-health-bar-filler to be Filled, and that it
    is to be filled Horizontally (left to right). Therefore, the fillAmount property
    of a UI Image determines how much of this filler image is displayed to the user
    (from `0.0` to `1.0`).
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerManager`&nbsp;script class is a manager script that initializes the&nbsp;`PlayerController`
    and `HealthChangeLogger` objects, and also allows the user to change the health
    of the Player by pressing the Up and Down arrow keys (simulating healing/damage
    during a game). Via the `Update()` method, each Up/Down arrow key press invokes
    the `PlayerController` methods:&nbsp;`AddToHealth()` and `ReducedHealth()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerController`&nbsp;script class creates a `PlayerModel` object in its
    constructor. It has two other methods, `AddToHealth()` and `ReducedHealth()`,
    that add to/reduce the health of the `PlayerModel` object by `+0.5` and `-0.1`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerModel`&nbsp;script class manages values for `Player` health, and
    uses delegates and events to publish health changes to any listening **View**
    classes. When a new object is created, the health property is initialized, and
    a health-change event is published to all listening objects. Likewise, when the
    `AddHealth(...)` and `ReduceHealth(...)` methods are invoked with a value, the
    value of the health is changed, and the health-change event is published to all
    listening objects. The&nbsp;`OnHealthChange`&nbsp;event is visible to other objects
    as a static public event. The&nbsp;`PublishHealthChangeEvent()`&nbsp;method publishes
    the new value of health by invoking all listening `OnHealthChange(...)` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two View classes that register to listen for `Player.OnHealthChange(...)`
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HealthBarDisplay`: Updates&nbsp;`fillAmount` for a UI Image for each new health
    value received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HealthChangeLogger`: Prints messages about the new `Player health` value received
    to the Debug.Log file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As can be seen, each of the Model/View/Controller classes is quite small and
    simple, and each has their own, well-defined responsibilities. It would be easy
    to add another kind of health-change event listener, perhaps to play a sound,
    without having to change any code in any of these existing classes. Likewise,
    it would be straightforward to add a new property to our `PlayerModel` (perhaps
    a score or inventory value of stars collected, and then add another public static
    event for score/inventory changes to be published to subscribed listening views).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only&nbsp;`PlayerManager` is a MonoBehaviour. One of the advantages of this
    MVC&nbsp;architecture is that each of these components becomes much easier to
    unit-test in isolation. A version of this recipe is used as an example in the&nbsp;*State
    Design Pattern* *PlayMode and Unit Testing a health bar with events, logging,
    and exceptions*&nbsp;recipe in Chapter 19, *Automated Testing*&nbsp;.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
