- en: Chapter 3. Demystifying Xamarin.Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。揭秘Xamarin.Android
- en: 'It''s now time to take a deeper dive into Xamarin.Android to see how it pulls
    off the same magic as Xamarin.iOS. In this chapter, we will see that Xamarin.iOS
    and Xamarin.Android share many of the same design goals. However, Xamarin.Android
    does not rely on static compilation. Many of the goals are achieved through completely
    different methods. This chapter covers the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入探讨Xamarin.Android，看看它是如何实现与Xamarin.iOS相同的魔法的。在本章中，我们将看到Xamarin.iOS和Xamarin.Android拥有许多相同的设计目标。然而，Xamarin.Android不依赖于静态编译。许多目标是通过完全不同的方法实现的。本章涵盖了以下主题：
- en: Mono CLR and Dalvik VM—working side by side
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono CLR和Dalvik VM—并行工作
- en: Application packaging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序打包
- en: Mono assemblies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono程序集
- en: Xamarin.Android bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin.Android绑定
- en: Attributes for the `ApplicationManifest.xml` file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationManifest.xml`文件的属性'
- en: Garbage collection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Mono CLR and Dalvik VM – working side by side
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mono CLR和Dalvik VM – 并行工作
- en: 'Android apps run within the **Dalvik Virtual Machine** (**Dalvik VM**), which
    is somewhat similar to a Java VM, but optimized for devices with limited resources.
    As we discussed in [Chapter 1](ch01.html "Chapter 1. Xamarin and Mono – a Pathway
    to the Unnatural"), *Xamarin and Mono – a Pathway to the Unnatural*, Xamarin products
    are based on the Mono platform that has its own VM called the **Common Language
    Runtime** (**CLR**). The key question to ask here is, "In which environment does
    a Xamarin.Android app run?" The answer is both. If you take a look at the next
    diagram, you will see for yourself how these two runtimes coexist:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用在**Dalvik虚拟机**（Dalvik VM）中运行，它与Java VM有些相似，但针对资源有限的设备进行了优化。正如我们在[第1章](ch01.html
    "第1章。Xamarin和Mono – 通向非自然之路")中讨论的，*Xamarin和Mono – 通向非自然之路*，Xamarin产品基于Mono平台，该平台有自己的虚拟机，称为**公共语言运行时**（CLR）。这里的关键问题是，“Xamarin.Android应用在哪个环境中运行？”答案是两者都运行。如果您看一下下一张图，您会亲自看到这两个运行时是如何共存的：
- en: '![Mono CLR and Dalvik VM – working side by side](img/0838OT_03_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Mono CLR和Dalvik VM – 并行工作](img/0838OT_03_01.jpg)'
- en: Both environments seem quite different from each other, so how does an app run
    in both? Xamarin.Android's power is achieved through a concept called peer objects
    and a Java framework called **Java Native Interface** (**JNI**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个环境看起来相当不同，那么一个应用如何在两者中运行呢？Xamarin.Android的强大功能是通过一个称为同伴对象的概念以及一个名为**Java
    Native Interface**（JNI）的Java框架实现的。
- en: Introducing the Java Native Interface
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Java Native Interface
- en: Let's start with JNI. This is a framework that allows non-Java code with languages
    such as C++ or C#, as an example, to call or be called by Java code running inside
    a JVM. As you can see from the previous diagram, JNI is a critical component in
    the overall Xamarin.Android architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从JNI开始。这是一个框架，允许非Java代码，例如C++或C#，调用或被运行在JVM内部的Java代码调用。正如您可以从之前的图中看到的那样，JNI是Xamarin.Android整体架构中的关键组件。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can find some supporting information on JNI, particularly on peer objects,
    in [Chapter 2](ch02.html "Chapter 2. Demystifying Xamarin.iOS"), *Xamarin.Android
    Architecture* in Packt Publishing's *Xamarin Mobile Application Development for
    Android*, *Mark Reynolds*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第2章](ch02.html "第2章。揭秘Xamarin.iOS")中找到一些关于JNI的支持信息，特别是关于同伴对象，在Packt Publishing出版的《Xamarin
    Mobile Application Development for Android》中的*Xamarin.Android架构*，由*马克·雷诺兹*撰写。
- en: Peer objects
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同伴对象
- en: Peer objects are a pair of objects that work together to carry out the functionality
    of an Android app. One of these is a managed object residing in the Mono CLR,
    while the other is a Java object residing in the Dalvik VM.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同伴对象是一对共同工作以执行Android应用功能的对象。其中一个是位于Mono CLR中的托管对象，另一个是位于Dalvik VM中的Java对象。
- en: Xamarin.Android is delivered with a set of assemblies called the Android binding
    libraries. Classes in the Android binding libraries correspond to the Java classes
    in the Android application framework, and the methods on the binding classes act
    as wrappers, to call corresponding methods on Java classes. These binding classes
    are commonly known as **Managed Callable Wrappers** (**MCW**). Because whenever
    you create a C# class that inherits from one of these binding classes, a corresponding
    Java proxy class is generated at build time. The Java proxy contains a generated
    override for each overridden method in your C# class and acts as a wrapper to
    call the corresponding method on the C# class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Android 随附一组称为 Android 绑定库的组件。Android 绑定库中的类对应于 Android 应用程序框架中的 Java
    类，绑定类上的方法作为包装器，用于调用 Java 类上的相应方法。这些绑定类通常被称为 **托管可调用包装器**（**MCW**）。因为每当您创建一个从这些绑定类继承的
    C# 类时，在构建时都会生成一个相应的 Java 代理类。Java 代理包含对您的 C# 类中每个重写方法的生成重写，并作为包装器来调用 C# 类上的相应方法。
- en: Peer objects can be created from within the Dalvik VM by the Android application
    framework or from within the Mono CLR by the code you write in the overridden
    methods. A reference between the two peer objects is kept by each instance of
    a MCW and can be accessed through the `Android.Runtime.IJavaObject.Handle` property.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Peer 对象可以通过 Android 应用程序框架在 Dalvik VM 内部创建，或者可以通过您在重写方法中编写的代码在 Mono CLR 内部创建。每个
    MCW 实例都保留两个 Peer 对象之间的引用，并且可以通过 `Android.Runtime.IJavaObject.Handle` 属性访问。
- en: 'You can see for yourself how peer objects collaborate together here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以亲自看到 Peer 对象如何协作：
- en: '![Peer objects](img/0838OT_03_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Peer objects](img/0838OT_03_02.jpg)'
- en: Xamarin.Android application packaging
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Android 应用程序打包
- en: 'Android applications are delivered for installation in an Android package format,
    which is an archive file with a `.apk` extension. An Android package contains
    the apps code and all of the supporting files required to run the app that includes
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用程序以 Android 包格式交付，这是一种具有 `.apk` 扩展名的存档文件。Android 包包含应用程序代码和运行应用程序所需的所有支持文件，包括以下内容：
- en: Dalvik executables (`*.dex` files)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dalvik 可执行文件（`*.dex` 文件）
- en: Resources
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源
- en: Native libraries
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生库
- en: The application manifest
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序清单
- en: 'Xamarin.Android apps follow the same standard with the following additions:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Android 应用程序遵循以下标准，并增加了以下内容：
- en: C# code is compiled into assemblies and stored in a top-level folder named `assemblies`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 代码编译成组件并存储在名为 `assemblies` 的顶级文件夹中
- en: Mono runtime libraries are stored along with other native libraries in the `lib`
    folder
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono 运行时库与其他原生库一起存储在 `lib` 文件夹中
- en: Understanding Mono assemblies
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Mono 组件
- en: Like Xamarin.iOS, Xamarin.Android ships with an extended subset of Silverlight
    and desktop .NET assemblies. Together, these libraries provide the .NET runtime
    library support for developers, including namespaces such as `System.IO` and `System.Threading`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Xamarin.iOS 一样，Xamarin.Android 随附了 Silverlight 和桌面 .NET 组件的扩展子集。这些库共同为开发者提供
    .NET 运行时库支持，包括 `System.IO` 和 `System.Threading` 等命名空间。
- en: Xamarin.Android is not binary compatible with assemblies compiled for a different
    profile, meaning your code must be recompiled to generate assemblies, specifically
    targeting the Xamarin.Android profile. This is essentially the same thing you
    have to do if you're targeting other profiles such as Silverlight or .NET 4.5.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Android 与为不同配置编译的组件不兼容，这意味着您的代码必须重新编译以生成组件，具体针对 Xamarin.Android 配置。如果您针对其他配置，如
    Silverlight 或 .NET 4.5，本质上也需要这样做。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a complete list of assemblies that ship with Xamarin.Android, you can refer
    to [http://docs.xamarin.com/guides/android/under_the_hood/assemblies](http://docs.xamarin.com/guides/android/under_the_hood/assemblies).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取随 Xamarin.Android 一起提供的组件的完整列表，您可以参考 [http://docs.xamarin.com/guides/android/under_the_hood/assemblies](http://docs.xamarin.com/guides/android/under_the_hood/assemblies)。
- en: Xamarin.Android bindings
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Android 绑定
- en: Xamarin.Android also ships with a set of binding libraries that provide the
    support for Android development. The binding libraries form the second big part
    of the magic behind Xamarin.Android similar to the way in which the Mono CLR and
    Dalvik VM function. The following sections delve into the details of these bindings.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Android 还提供了一套绑定库，为 Android 开发提供支持。绑定库构成了 Xamarin.Android 魔法的第二大组成部分，类似于
    Mono CLR 和 Dalvik VM 的功能。以下部分深入探讨了这些绑定的细节。
- en: The design principles
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计原则
- en: 'A number of goals or design principles guided the development of the binding
    libraries. These principles are critical to make C# developers productive in an
    Android development. The following represents a summary of the design principles,
    where you will notice some similarities with the Xamarin.iOS bindings:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列目标或设计原则指导了绑定库的开发。这些原则对于使 C# 开发者在 Android 开发中变得高效至关重要。以下是对设计原则的总结，您将注意到与 Xamarin.iOS
    绑定的一些相似之处：
- en: Allow developers to subclass Java classes in the same way they subclass other
    .NET classes
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许开发者以与其他 .NET 类相同的方式子类化 Java 类。
- en: Make common Java tasks easy, and tough Java tasks possible
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使常见的 Java 任务变得简单，困难的 Java 任务变得可行。
- en: Expose JavaBean properties as C# properties
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JavaBean 属性公开为 C# 属性。
- en: Expose a strongly typed API
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开一个强类型 API。
- en: Expose C# delegates (lambdas, anonymous methods, and `System.Delegate`) instead
    of single-method interfaces when appropriate and applicable
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当和适用的情况下，暴露 C# 委托（lambda 表达式、匿名方法以及 `System.Delegate`），而不是单方法接口。
- en: Provide a mechanism to call arbitrary Java libraries (`Android.Runtime.JNIEnv`)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种机制来调用任意的 Java 库（`Android.Runtime.JNIEnv`）。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A complete discussion around these principles can be found at [http://docs.xamarin.com/guides/android/advanced_topics/api_design](http://docs.xamarin.com/guides/android/advanced_topics/api_design).
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这些原则的完整讨论可以在 [http://docs.xamarin.com/guides/android/advanced_topics/api_design](http://docs.xamarin.com/guides/android/advanced_topics/api_design)
    找到。
- en: Properties
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'To the greatest extent possible, JavaBean properties in the Android framework
    classes are transformed into C# properties. The following rules are always followed
    whenever this takes place:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在尽可能大的范围内，Android 框架类中的 JavaBean 属性被转换为 C# 属性。以下规则始终在发生这种情况时遵循：
- en: Firstly, read/write properties are created for both the getter and setter method
    pairs
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，为获取器和设置器方法对创建读写属性。
- en: Read-only properties are created for getters without the corresponding setter
    methods
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于没有相应设置器的获取器，创建只读属性。
- en: In the rare case that only a setter exists, no write-only properties are created
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非常罕见的情况下，如果只存在设置器，则不会创建只写属性。
- en: Finally, no properties are created when the type will be an array
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当类型将是数组时，不会创建任何属性。
- en: Events versus listeners
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件与监听器
- en: Android APIs follow the Java pattern in order to define and hook up event listeners.
    C# developers should be more familiar with the similar concepts of delegates and
    events.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Android API 依照 Java 模式来定义和连接事件监听器。C# 开发者应该更熟悉类似的概念：委托和事件。
- en: 'The following is an example of Java event listeners:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 Java 事件监听器的示例：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This following is the equivalent code that uses C# events:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与 C# 事件等效的代码：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Android bindings provide events when possible. The following rules are
    followed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Android 绑定在可能的情况下提供事件。以下规则被遵循：
- en: When the listener has a set prefix such as `setOnClickListener`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当监听器具有如 `setOnClickListener` 之类的设置前缀时。
- en: When the listener callback has a void return
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当监听器回调没有返回值时。
- en: When the listener accepts only a single parameter, the interface has only a
    single method, and the interface name ends with `Listener`
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当监听器只接受单个参数时，接口只有一个方法，并且接口名称以 `Listener` 结尾。
- en: When an event is not created due to one of the rules enlisted here, a specific
    delegate is generated that supports the appropriate signature.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件不是由于这里列出的规则之一创建时，将生成一个支持适当签名的特定委托。
- en: Special help with collections
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集合方面提供特殊帮助。
- en: 'The native Android APIs uses list, set, and map collections extensively from
    `java.util`. The Android bindings expose these collections using interfaces from
    `System.Collections.Generic`. In addition, Xamarin.Android provides a set of helper
    classes that implement each corresponding .NET collection and provides faster
    marshaling because they do not actually perform a copy. The following table shows
    how these classes map:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 原生 Android API 广泛使用 `java.util` 中的列表、集合和映射集合。Android 绑定通过 `System.Collections.Generic`
    中的接口公开这些集合。此外，Xamarin.Android 提供了一组辅助类，它们实现了每个相应的 .NET 集合，并提供更快的封送处理，因为它们实际上并没有执行复制。以下表格显示了这些类的映射：
- en: '| Java type | .NET interface | Helper class |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| Java 类型 | .NET 接口 | 辅助类 |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `java.util.Set<E>` | `ICollection<T>` | `Android.Runtime.JavaSet<T>` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.Set<E>` | `ICollection<T>` | `Android.Runtime.JavaSet<T>` |'
- en: '| `java.util.List<E>` | `IList<T>` | `Android.Runtime.JavaList<T>` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.List<E>` | `IList<T>` | `Android.Runtime.JavaList<T>` |'
- en: '| `java.util.Map<K,V>` | `IDictionary<TKey,TValue>` | `Android.Runtime.JavaDictionary<K,V>`
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.Map<K,V>` | `IDictionary<TKey,TValue>` | `Android.Runtime.JavaDictionary<K,V>`
    |'
- en: '| `java.util.Collection<E>` | `ICollection<T>` | `Android.Runtime.JavaCollection<T>`
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.Collection<E>` | `ICollection<T>` | `Android.Runtime.JavaCollection<T>`
    |'
- en: Xamarin.Android allows you to pass any collection (which implements the correct
    interface) into the Android API methods. For example, `List` implements `IList`
    and can be used when an `IList` entity is required. However, for performance reasons,
    it is recommended that you use the helper classes anytime you need to pass any
    of these collection types into an Android API method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Android允许你将任何集合（实现了正确的接口）传递给Android API方法。例如，`List`实现了`IList`，可以在需要`IList`实体时使用。然而，出于性能考虑，建议你在需要将这些集合类型传递给Android
    API方法时使用辅助类。
- en: Interfaces
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'Java and C# both support interfaces; however, Java supports additional capabilities.
    Also, both support the ability to define a set of method names and signatures.
    In addition, Java supports the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Java和C#都支持接口；然而，Java支持额外的功能。此外，两者都支持定义一组方法名称和签名的能力。此外，Java还支持以下功能：
- en: Nested interface definitions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套接口定义
- en: Fields (`public final static` only)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段（仅限`public final static`）
- en: 'In general, the following items describe how the Android bindings provide the
    following Java interfaces:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，以下项目描述了Android绑定如何提供以下Java接口：
- en: A C# interface with the same name but prefixed by `I` and containing method
    declarations is created. For example, `android.view.Menu` is created as `Android.Views.IMenu`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有相同名称但以`I`开头并包含方法声明的C#接口。例如，`android.view.Menu`被创建为`Android.Views.IMenu`。
- en: An abstract class with the same name as the Java interface is generated, which
    contains definitions for the constants from the Android interface. For example,
    the constants from `android.view.Menu` are placed in the generated abstract class
    `Android.Views.Menu`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个与Java接口同名但包含常量定义的抽象类，例如，`android.view.Menu`中的常量被放置在生成的抽象类`Android.Views.Menu`中。
- en: A C# interface is generated for each nested interface and is given a name prefixed
    by `I`, the name of the parent Java interface, followed by the name of the nested
    Java interface.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个嵌套接口生成一个C#接口，并使用以`I`开头的前缀，后跟父Java接口的名称，然后是嵌套Java接口的名称。
- en: Classes in the Android bindings that implement an Android interface containing
    constants get a nested `InterfaceConsts` type generated that also contains definitions.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android绑定中实现包含常量的Android接口的类会生成一个嵌套的`InterfaceConsts`类型，它也包含定义。
- en: Mapping nested classes
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套类映射
- en: 'Java and C# both support the definition of nested classes. However, Java supports
    two types of nested classes: static and non-static. The following points clarify
    how it does this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Java和C#都支持嵌套类的定义。然而，Java支持两种类型的嵌套类：静态和非静态。以下要点说明了它是如何做到这一点的：
- en: Java static nested classes are the same as C# nested classes and are translated
    directly
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java静态嵌套类与C#嵌套类相同，可以直接翻译
- en: 'Non-static nested classes, also known as inner classes, are somewhat different;
    additional rules apply:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非静态嵌套类，也称为内部类，有一些不同；适用额外的规则：
- en: A reference to an instance of the containing type must be provided as a parameter
    in the constructor to the inner class.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数中必须提供一个指向包含类型的实例的引用作为参数，用于内部类。
- en: In the case of inheriting from an inner class, the derived class must be nested
    within a type. This type inherits properties from the class that contains the
    base inner class, and the derived class must provide a constructor of the same
    type as the C# containing type.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从内部类继承的情况下，派生类必须嵌套在某个类型中。此类型从包含基本内部类的类继承属性，并且派生类必须提供一个与C#包含类型相同类型的构造函数。
- en: Mapping the Runnable interface
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Runnable接口映射
- en: Java provides the `java.lang.Runnable` interface with a single method, `run()`,
    in order to implement delegation. The Android platform makes use of this interface
    in a number of places such as `Activity.runOnUIThread()` and `View.post()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一个包含单个方法`run()`的`java.lang.Runnable`接口，以便实现委托。Android平台在多个地方使用此接口，例如`Activity.runOnUIThread()`和`View.post()`。
- en: C# provides the `System.Action` delegate for a method with a void return and
    no parameters; thus, it maps very nicely to the `Runnable` interface. The Android
    bindings provide overloads that accept an `Action` parameter for all API members
    that accept a `Runnable` interface in the native API.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The `IRunnable` overloads were also left in place so that types that are returned
    from other API calls can be used.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many places, the Android APIs uses `int` constants as parameters to specify
    processing options. To increase type safety, the Android bindings create enumerations
    to replace `int` constants when possible. The following example shows the use
    of the `ActivityFlags.NewTaskenum` value rather than the native `FLAG_ACTIVITY_NEW_TASK`
    constant:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another great advantage of using an `enum` class is the enhanced support that
    you get with code completion in IDEs such as Xamarin Studio and Visual Studio.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin.Android generates a file named `Resource.Designer.cs` in the `Resources`
    folder of your project. This file contains constants for all of the resources
    referenced in your app and serves the same purpose as the `R.java` file generated
    for traditional Android apps.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Attributes for the ApplicationManifest.xml file
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android applications have a manifest file (`AndroidManifest.xml`) that tells
    the Android platform everything it needs to know to successfully run the application,
    including the following features:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The minimum API level required by the application
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware/software features used or required by the application
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissions required by the application
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial activity to start when the application is launched
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries required by the application
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.Android provides a robust set of .NET attributes that can be used to
    adorn your C# classes so that much of the information required in `ApplicationManifest.xml`
    will be automatically generated at compile time. Use of these attributes simplifies
    the task of keeping the manifest in sync with your code. For example, if you rename
    an `Activity` class, the next time you compile, the corresponding `<Activity/>`
    element in the manifest is automatically updated.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the use of the `Activity` attribute to specify
    the launch activity for an app:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will result in the following entry in the `ApplicationManifest.xml` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although .NET attributes are a convenient way to keep your code and manifest
    file in sync, the use of these attributes is not required.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Editor for the ApplicationManifest.xml file
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xamarin Studio also provides an editor for `ApplicationManifest.xml`. This
    can be used instead of attributes or to edit content that cannot be set through
    the use of attributes such as the hardware/software features required and permissions.
    The following screenshot depicts the editor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Editor for the ApplicationManifest.xml file](img/0838OT_03_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Garbage collection
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Xamarin.Android apps run in two different VMs, garbage collection is
    somewhat complex and creates some interesting challenges. Therefore, we have devoted
    significant time to discuss this process. Xamarin.Android uses Mono''s simple
    generational garbage collector, which supports two types of collections called
    minor and major:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Xamarin.Android应用程序在两个不同的虚拟机（VM）中运行，垃圾回收过程相对复杂，并带来了一些有趣的挑战。因此，我们投入了大量的时间来讨论这个过程。Xamarin.Android使用Mono的简单代际垃圾回收器，它支持两种类型的收集，称为小集合和主集合：
- en: '**Minor collections**: These collections are cheap and thus invoked frequently.
    Minor collections collect recently allocated and dead objects and are invoked
    after every few MB of allocations. You can manually invoke a minor collection
    with the following code:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小集合**：这些集合成本低廉，因此调用频率较高。小集合收集最近分配和死亡的对象，并在分配了几MB之后调用。您可以使用以下代码手动调用小集合：'
- en: '[PRE5]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Major collections**: These collections are expensive and are thus invoked
    less frequently. Major collections reclaim all dead objects and are only invoked
    when memory is exhausted for the current heap size. You can manually invoke a
    major collection with the following code:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主集合**：这些集合成本高昂，因此调用频率较低。主集合回收所有已死亡的对象，并且仅在当前堆大小耗尽时调用。您可以使用以下代码手动调用主集合：'
- en: '[PRE6]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can review a more detailed discussion on Mono's simple generational garbage
    collector at [http://www.mono-project.com/Compacting_GC](http://www.mono-project.com/Compacting_GC).
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在[http://www.mono-project.com/Compacting_GC](http://www.mono-project.com/Compacting_GC)上查看关于Mono简单代际垃圾回收器的更详细讨论。
- en: 'Before we continue with the discussion, it will help us if we group objects
    in an app into the following categories:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论之前，如果我们把应用程序中的对象分组到以下类别中，这将对我们有所帮助：
- en: '**Managed objects**: These are any C# objects you create from standard libraries
    such as the Mono runtime libraries. They are garbage collected like any other
    C# object and have no special connection to any classes from the Android bindings.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管对象**：这些是从标准库（如Mono运行时库）创建的任何C#对象。它们像其他任何C#对象一样进行垃圾回收，并且与Android绑定中的任何类没有特殊联系。'
- en: '**Java objects**: These are Java objects that reside in the Dalvik VM that
    were created as a part of some process, but not exposed to a managed object through
    JNI. These objects are collected as any other Java object, and there is little
    that we need to discuss about them.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java对象**：这些是位于Dalvik VM中的Java对象，作为某些过程的一部分创建，但未通过JNI暴露给托管对象。这些对象像任何其他Java对象一样进行收集，关于它们我们不需要讨论太多。'
- en: '**Peer objects**: As we mentioned earlier, peer objects are a managed object
    and Java object pair that communicates via JNI. It works together to carry out
    the functionality of an Android app.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同等对象**：如我们之前提到的，同等对象是管理对象和Java对象对，通过JNI进行通信。它们协同工作以执行Android应用程序的功能。'
- en: JNI global and weak references
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JNI全局和弱引用
- en: 'JNI references come in a couple of different types and they have a big impact
    on when objects can be collected. Specifically, we will discuss two types of JNI
    references, which are global and weak references:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JNI引用有几种不同类型，并且对对象何时可以被收集有很大影响。具体来说，我们将讨论两种类型的JNI引用，即全局和弱引用：
- en: '**Global reference**: A JNI global reference is a reference from "native",
    or in our case managed code, to a Java object managed by the Dalvik VM. A JNI
    global reference is established between peer objects when they are initially created.
    A JNI global reference will prevent the Dalvik garbage collector from performing
    the required action as it indicates the object is still in use.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局引用**：JNI全局引用是从“本地”或在我们的情况下是托管代码到由Dalvik VM管理的Java对象的引用。当对象最初创建时，JNI全局引用在同等对象之间建立。JNI全局引用将阻止Dalvik垃圾回收器执行所需操作，因为它表示对象仍在使用中。'
- en: '**Weak reference**: A JNI weak reference also allows a managed object to reference
    a Java object, but the difference is that a weak reference will *not* prevent
    the Dalvik VM GC from collecting it.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱引用**：JNI弱引用也允许托管对象引用Java对象，但不同之处在于弱引用将*不会*阻止Dalvik VM GC收集它。'
- en: We will see how these differ later on in this chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到它们之间的差异。
- en: Mono collections
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mono集合
- en: 'Mono collections are where the fun happens. As mentioned earlier, simple managed
    objects are collected normally, but peer objects are collected by performing the
    following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Mono集合是发生有趣事情的地方。如前所述，简单的托管对象通常进行正常收集，但同等对象通过执行以下步骤进行收集：
- en: All managed peers are eligible for Mono collection, meaning they are not referenced
    by any other managed objects. They have their JNI global reference replaced with
    a JNI weak reference. This allows the Dalvik VM to collect the Java peer if no
    other Java objects in the VM reference them.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有托管对等对象都符合 Mono 收集的条件，这意味着它们不被任何其他托管对象引用。它们的 JNI 全局引用被替换为 JNI 弱引用。这允许 Dalvik
    VM 在没有其他 Java 对象在 VM 中引用它们的情况下回收 Java 对等对象。
- en: A Dalvik VM GC is invoked that allows the Java peers with weak global references
    to be collected.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会调用 Dalvik VM 的 GC，允许具有弱全局引用的 Java 对等对象被回收。
- en: Managed peers with a JNI weak reference, as created in step 1, are evaluated.
    If the Java peer has been collected, then the managed peer is also collected.
    If the Java peer has not been collected, then it is replaced with a JNI global
    reference and the managed peer is not collected until a future GC.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤 1 中创建的具有 JNI 弱引用的托管对等对象将被评估。如果 Java 对等对象已被回收，则托管对等对象也会被回收。如果 Java 对等对象尚未被回收，则它将被替换为
    JNI 全局引用，托管对等对象将不会在未来的 GC 中被回收。
- en: The end result is that an instance of a managed peer will live as long as it's
    referenced by a managed code or its corresponding Java peer is referenced by a
    Java code. To shorten the lifetime of peers, dispose of peer objects when they
    are no longer needed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，托管对等对象的实例将与其被托管代码引用或其对应的 Java 对等对象被 Java 代码引用的时间一样长。为了缩短对等对象的生存期，当它们不再需要时，请销毁对等对象。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Calling the `Dispose()` method manually severs the connection between the peers
    by freeing the JNI global reference, thus allowing each VM to collect the objects
    as soon as possible.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 手动调用 `Dispose()` 方法通过释放 JNI 全局引用来切断对等对象之间的连接，从而允许每个 VM 尽快地回收对象。
- en: Automatic collections
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动收集
- en: From Xamarin.Android 4.1.0 version onwards, a full garbage collection is performed
    automatically when a `gref` threshold has crossed 90 percent of the known maximum
    `gref` values for the platform.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Xamarin.Android 4.1.0 版本开始，当 `gref` 阈值超过平台已知最大 `gref` 值的 90% 时，会自动执行完整垃圾回收。
- en: 'When you perform an automatic collection, a message similar to the following
    is displayed in the debug log:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行自动收集时，调试日志中会显示类似以下的消息：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Invocations of the automatic GC are nondeterministic and might not happen at
    best times. If you are experiencing a pause in processing, look for messages in
    the logcat that might indicate that an automatic GC occurred. When this scenario
    occurs, you can consider when you can use `Dispose()` to reduce the lifetime of
    the peer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自动 GC 的调用是非确定性的，可能不会在最佳时机发生。如果你在处理过程中遇到暂停，请查看日志中可能表明自动 GC 发生的消息。当这种情况发生时，你可以考虑何时使用
    `Dispose()` 来减少对等对象的生存期。
- en: Helping the GC
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助 GC
- en: 'There are a number of ways in which you can help the GC with the collection
    process. The following sections provide some additional thoughts:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以帮助 GC 进行回收过程。以下部分提供了一些额外的思考：
- en: '**Disposing of peer objects**: Get rid of managed peers when they are no longer
    needed and consider invoking a minor GC. As we mentioned earlier, the Mono GC
    does not have a complete picture of the memory situation. To Mono, peer objects
    appear to take up only 20 bytes because the MCWs don''t add instance variables.
    Hence, all of the memory is associated with the corresponding Java object and
    allocated to the Dalvik VM. If you have an instance of `Android.Graphics.Bitmap`
    loaded with a 2 MB image, the Mono GC only sees the 20 bytes and thus disposing
    of the object will be a low priority to the GC.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销毁对等对象**：当托管对等对象不再需要时，请将其销毁并考虑调用小 GC。如我们之前提到的，Mono GC 对内存状况没有完整的了解。对于 Mono
    来说，对等对象似乎只占用 20 字节，因为 MCWs 没有添加实例变量。因此，所有内存都与相应的 Java 对象相关联，并分配给 Dalvik VM。如果你有一个加载了
    2 MB 图像的 `Android.Graphics.Bitmap` 实例，Mono GC 只能看到 20 字节，因此销毁对象对 GC 来说将是低优先级的。'
- en: '**Reduce direct references in peer objects**: Whenever a managed peer is scanned
    during GC, the entire object graph is scanned, meaning every object it directly
    references is scanned as well. Objects with a significant number of direct references
    can cause a pause when the GC runs.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少对等对象中的直接引用**：在 GC 期间扫描托管对等对象时，会扫描整个对象图，这意味着它直接引用的每个对象也会被扫描。具有大量直接引用的对象可能导致
    GC 运行时发生暂停。'
- en: '**Minor collections**: Minor collections are relatively cheap. You can consider
    invoking minor collections at the end of an activity or after completing a significant
    set of service calls or background processing.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型收集**: 小型收集相对便宜。您可以考虑在活动结束时或完成一组重要的服务调用或后台处理之后调用小型收集。'
- en: '**Major collections**: Major collections are expensive and should rarely be
    performed manually. Only consider manually invoking a major collection after a
    significant processing cycle when a large amount of resource has been freed and
    you can live with a pause in the app''s responsiveness.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要收集**: 主要收集成本较高，应很少手动执行。只有在经过一段重要的处理周期后，大量资源已释放且您可以忍受应用响应性暂停时，才考虑手动调用主要收集。'
- en: Xamarin.Android Designer
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Android 设计器
- en: 'Xamarin provides a plugin for Xamarin Studio that can be used to design layout
    files for Xamarin.Android apps. The designer supports a **Content** mode for visual
    drag-and-drop and a **Source** mode for XML-based editing. The following screenshot
    depicts the designer opened in the **Content** mode:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin为Xamarin Studio提供了一个插件，可用于设计Xamarin.Android应用的布局文件。该设计器支持**内容**模式进行视觉拖放和**源**模式进行基于XML的编辑。以下截图显示了在**内容**模式下打开的设计器：
- en: '![Xamarin.Android Designer](img/0838OT_03_04.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.Android 设计器](img/0838OT_03_04.jpg)'
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the architecture of Xamarin.Android, discussed
    the design goals, and looked at some of the details of its implementation. We
    also looked at how memory management works with a Xamarin.Android app. In the
    next chapter, we will start developing a Xamarin.iOS app.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了Xamarin.Android的架构，讨论了设计目标，并查看了一些实现细节。我们还探讨了Xamarin.Android应用中的内存管理是如何工作的。在下一章中，我们将开始开发一个Xamarin.iOS应用。
