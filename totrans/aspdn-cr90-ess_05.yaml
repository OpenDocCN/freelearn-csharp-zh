- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Data and Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application, at some point, will consume data, whether through services
    or even in a data source, such as a SQL Server database or MySQL. Interacting
    with the database is an important feature, and ASP.NET Core 9 offers mechanisms
    such as Entity Framework Core and easily integrates with other database interface
    providers, such as Dapper, a library optimized for abstracting data access in
    a simple way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a SQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding SQL, NoSQL, ORM, and Micro ORM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Entity Framework core and Dapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore communication between web applications and databases using technologies
    such as Entity Framework and Dapper, in addition to understanding important concepts
    such as the use of ORM and different data persistence models.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has some prerequisites in order to get the most out of it. Therefore,
    you will need to install Docker and Azure Data Studio.
  prefs: []
  type: TYPE_NORMAL
- en: All source code and examples for this chapter can be found in the GitHub repository
    at [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Docker installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use Docker as the basis for running a SQL database server. Using Docker
    will avoid the problems associated with installing databases on different operating
    systems as it is a portable option.
  prefs: []
  type: TYPE_NORMAL
- en: To install Docker, follow the instructions for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Run the following command as an administrator on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Mac
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Access the following link and follow the tutorial for installation according
    to your processor: [https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac](https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker supports **Ubuntu** , **Debian** , and **Fedora** . Use the instructions
    according to your platform at [https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Azure Data Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Data Studio is a specialized database editor and will be used to perform
    database operations, such as table creation, inclusion, and record querying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its installation is simple, and it supports different operating systems: [https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio](https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a SQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In each chapter, we have learned about different aspects involving ASP.NET Core
    9 and how this platform provides a large number of resources for the development
    of the most diverse types of applications. Each application has a purpose, which
    is to process data that generates information for users. However, at some point,
    your application will end up interacting with a data persistence model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data persistence** occurs in several ways, but in general, it is the serialization
    of information allocated in memory to the disk, which can be in the form of files,
    and commonly takes place using a data persistence platform, such as a **Database
    Management System** ( **DBMS** ) or non-relational data. We will discuss these
    two persistence models in more depth soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Most applications use a persistence model based on databases such as SQL Server,
    Oracle, and MySQL. Each DBMS has models of administration, typing, and organization
    of resources; however, they share the same purpose of persisting data in a tabular
    format and use **Structured Query Language** ( **SQL** ) to manipulate and manage
    all persisted data.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 can communicate with different types of DBMS, but we will focus
    on the SQL Server database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an application to connect to a database, the following are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: A database driver (a NuGet package)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A connection string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the desired resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this model, we can connect to any database that has a NuGet package ported
    to the .NET platform, such as the **System.Data.SqlClient** package for SQL databases,
    allowing applications to easily implement a persistence model.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the principles related to the interaction between applications
    and data persistence, let’s learn how the ASP.NET Core 9 platform communicates
    with a SQL Server database.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In current versions of the .NET platform, they work mainly with the **dependency
    injection** ( **DI** ) design pattern, which allows the use of a technique called
    **inversion of control** ( **IoC** ), causing classes and their dependencies to
    be managed by the .NET dependency container.
  prefs: []
  type: TYPE_NORMAL
- en: DI in .NET
  prefs: []
  type: TYPE_NORMAL
- en: The DI pattern design’s main objective is to abstract the management of class
    instances and their respective dependencies. It is a common practice in most high-performance
    solutions. If you want to learn more about DI, visit [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Through DI, we can register a class to control the connection to the database.
    We will work with this approach in the topic where we will learn about using the
    Entity Framework in the *Working with EF Core and* *Dapper* section.
  prefs: []
  type: TYPE_NORMAL
- en: For now, it is important to understand the fundamentals of communicating between
    an application and the database. We will use SQL Server as the DBMS and for this,
    you must consult the *Technical requirements* section and install the Docker Engine.
    How Docker works is beyond the scope of this book. However, its use will allow
    you to continue with the examples described in this chapter without any compatibility
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start configuring the database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to run a Docker container to run SQL Server. We will use
    the following command to start an instance of SQL Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s review the preceding command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**docker run** : This uses the Docker Engine to run a container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-d** : This parameter is used to execute the command in the background.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-e** : These are definitions of environment variables, used when starting
    the container. In this case, the **ACCEPT_EULA** variable is configured to agree
    with Microsoft’s terms and the **MSSQL_SA_PASSWORD** parameter is where a password
    is defined for the SA user, the default SQL user administrator.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-p** : This defines the port of the host machine that will be used to communicate
    with port 1433 of the container. In this scenario, we’re defining the host and
    container ports as the same, 1433.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mcr.microsoft.com/mssql/server:2019-latest** : This is the type and version
    of the Docker image that will be run.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker does all the magic of downloading the SQL Server image onto your machine
    and running it in a virtualized way. The preceding command will return a hash
    code indicating that the image is running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The running image will be listed as shown in *Figure 5* *.1* , and the number
    of images listed may be different if you already use Docker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Docker image running](img/B21788_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Docker image running
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about Docker
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about Docker, take a look at the following official documentation:
    [https://docs.docker.com/](https://docs.docker.com/) .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the image running, open **Azure Data Studio** , installed
    as described in the *Technical requirements* section, and click the **Create a
    connection** button, as highlighted in *Figure 5* *.2* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Creating a connection to the database](img/B21788_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Creating a connection to the database
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the fields as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Server** : **localhost,1433**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication type** : **SQL Login**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User** **name** : **sa**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password** : **Password123**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the other parameters as they are, then click **Connect** . In some cases,
    a popup will be displayed informing you about the use of certificates. Just click
    the **Enable Trust server certificate** button. This certificate is automatically
    created by Azure Data Studio, so don’t worry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After making the connection, you will have access to the server, which only
    has the standard databases. Click on the **New Query** option and you will see
    a new tab, as shown in *Figure 5* *.3* , that we will use to create a database
    and a table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – New Query tab](img/B21788_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – New Query tab
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the book GitHub repository, in the [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078)
    folder, copy the code from the **InitialDb.sql** file and paste it into the **New
    Query** tab, created previously, in Azure Data Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then click the **Run** button. The **DbStore** database and the **Product**
    table will be created, and some products will be inserted as an example of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have prepared the SQL database, it’s time to create a simple console
    application, make the connection, and list the data from the product table.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SQL client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, the .NET platform has more modern ways of establishing
    a connection to the database and we will talk more about this subject in the *ORM
    and Micro ORM* section. However, it is important that you understand the fundamentals
    of communication between an application and a database.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will create a console application and add the necessary NuGet
    package to connect to the previously prepared SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we’ll open the terminal in a folder of your choice and execute the following
    commands in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the project ready, we will need to carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a connection to the database. We will use the **SqlConnection** class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a SQL command that will be executed. We will use the **SqlCommand** class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read data based on the SQL command. We will use the **SQLDataReader** class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the data on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In just six steps, we will be able to interact with a data source. The code
    in the **Program.cs** file must be identical to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s discuss the most important details of this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step was to create the database connection class, **SqlConnection**
    , which receives a connection string as a parameter in the constructor. The connection
    string can be understood as the address of the database server. In this case,
    this address is made up of three basic properties: **Server** , **user id** ,
    and **password** . The default connection port is **1433** , which can be omitted,
    but you must explicitly define it if the connection port is different. These are
    the same parameters used previously to connect to the database through Azure Data
    Studio through the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: The connection string offers several other types of parameters to determine
    how the connection will be made. The version we are currently using is the simplest.
  prefs: []
  type: TYPE_NORMAL
- en: Connection String
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, the connection string is made up of different parameters, including
    sensitive data such as username and password. For this reason, it is good practice
    to keep connection string management out of the source code, to prevent vulnerabilities
    and to prevent sensitive data from being available in the application’s version
    control. We will learn secure credential management approaches in [*Chapter 9*](B21788_09.xhtml#_idTextAnchor146)
    . More details about connection strings can be found in this great reference:
    [https://www.connectionstrings.com/sql-server/](https://www.connectionstrings.com/sql-server/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: After creating the **SqlConnection** object, it is time to open the connection
    using the **sql.Open()** code. Next, the **SqlCommand** class is created, where
    the constructor receives an SQL string and also the database connection object.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL code used performs a simple query on the **Product** table, obtaining
    all available rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: '**SqlCommand** has different methods, such as **ExecuteNonQuery** , that are
    generally used to execute commands that change the database, such as **Insert**
    , **Delete** , and **Update** , or **ExecuteReader** , which is being used in
    this example to obtain data from the Product table. The **ExecuteReader** method
    returns an object of type **SqlDataReader** , which abstracts the rows and columns
    into an object, where it is possible to perform interactions and access table
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: All this abstraction work is done by the **System.Data.SqlClient** library,
    which has access to the SQL Server database connection driver and provides several
    classes for manipulating data.
  prefs: []
  type: TYPE_NORMAL
- en: After obtaining the data by executing the **ExecuteReader** method, we finally
    iterate on the returned object by displaying the data obtained from the database.
  prefs: []
  type: TYPE_NORMAL
- en: All code is protected by a **try..catch..finally** block to guarantee error
    handling and, above all, to close the connection at the end of use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can analyze the result of listing the database records in *Figure 5* *.4*
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Displaying records in the Product table](img/B21788_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Displaying records in the Product table
  prefs: []
  type: TYPE_NORMAL
- en: Despite being a simple application, we learned important concepts and fundamentals
    related to interactions between applications and databases. We use SQL Server
    as a base, but the lessons learned apply to other data sources, such as MySQL
    or Oracle, varying, of course, the connection, command, and reading objects.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we prepared the basis of the environment for the remainder of the
    chapter, where we will explore other concepts, starting with the differences between
    relational and non-relational databases, in addition to understanding what ORM
    and Micro ORMs are.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SQL, NoSQL, ORM, and Micro ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the emergence of different application structures and needs, different
    ways of managing data have also been developed. Choosing the right database and
    interaction methods has a significant impact on application performance, scalability,
    and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, with the increase in systems complexity, new technologies for manipulating
    data obtained through DBMSs have also emerged, such as **Object-relational mapping**
    ( **ORM** ) and micro ORM. Each of the technologies has benefits for certain contexts,
    and it is important to know them correctly as there are no silver bullets.
  prefs: []
  type: TYPE_NORMAL
- en: SQL versus NoSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complexity of applications and different data management needs have led
    to several challenges for companies, such as having suitable performance for managing
    large amounts of data, which leads to maintainability and scalability challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Along with these variables, keeping the servers running perfectly is expensive.
    **Relational Database Management System** ( **RDBMS** ) were the main means of
    tracking organizations’ information, and their approach in a relational model
    that prioritizes the integrity and relationship between information has defined
    how development teams handle data manipulation for years.
  prefs: []
  type: TYPE_NORMAL
- en: '**Relational databases** have tables that represent a type of information.
    This information is distributed in columns, representing the characteristics of
    a piece of data. Complete data is determined in a row of a table. Tables can have
    relationships with other tables, associating different data to compose information.
    That’s why they are called relational models. The example in *Figure 5* *.5* shows
    some tables and their relationships, representing a data abstraction from a bank
    account application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Basic bank account data model](img/B21788_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Basic bank account data model
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, you can see that a customer has an account that has transactions.
    This is a basic representation of this context. But in large contexts, this relational
    structure model leads to different challenges for companies and follows the application
    development model based on how data should be persisted.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases provide flexibility; however, basing applications on the
    data model shown in *Figure 5* *.5* leads to several challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Modern systems need to have flexibility and elasticity, and in some cases must
    be technology agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: With the emergence of the cloud, the possibility of having elastic resources
    also emerged. However, maintaining a cluster of data and synchronizing and managing
    it is not an easy or cheap task, even in cloud environments. Nowadays, through
    **Platform as a Service** ( **PaaS** ), such activities are abstracted by cloud
    providers; however, they come at a cost.
  prefs: []
  type: TYPE_NORMAL
- en: With the evolution of technology, other types of persistence models and different
    opportunities for applications and companies have emerged. One of the big terms
    generally misunderstood in the technical community a few years ago was the term
    **NoSQL** , which means **non-relational database** or **not-only SQL** .
  prefs: []
  type: TYPE_NORMAL
- en: This persistence model has a different approach to the traditional relational
    model. NoSQL databases have a more flexible data structure that does not have
    many restrictions about how data will be persisted.
  prefs: []
  type: TYPE_NORMAL
- en: For many years, NoSQL was seen as the new persistence model for DBMSs, causing
    companies to try to migrate to this model without fully understanding the fundamentals
    and using relational database approaches in NoSQL structures.
  prefs: []
  type: TYPE_NORMAL
- en: This way of interacting with a different source of data persistence had several
    benefits, including making developers, engineers, and companies change their perspective
    on application development, but focused on the business instead of how the data
    should be persisted.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5* *.6* , we can see most of the differences between relational databases
    and NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Biggest differences in relational databases and NoSQL](img/B21788_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Biggest differences in relational databases and NoSQL
  prefs: []
  type: TYPE_NORMAL
- en: 'The NoSQL approach offers different types of data persistence that bring several
    benefits to applications. The most common are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Key-value stores ( Redis, Memcached)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document databases ( MongoDB, Couchbase)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Column-family databases ( Cassandra, HBase)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph databases ( Neo4j, OrientDB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Likewise, the data manipulation model for NoSQL is different from relational
    databases, and query methods vary depending on the NoSQL database type and may
    not be as standardized as SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it is important to understand that NoSQL databases often prioritize
    scalability, performance for specific query patterns, and flexibility to handle
    evolving data structures.
  prefs: []
  type: TYPE_NORMAL
- en: But when should we use one approach over the other?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the following table to understand the differences between persistence
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **RDBMS** | **NoSQL** |'
  prefs: []
  type: TYPE_TB
- en: '| Structure | Rigid, predefined schemas | Flexible, adaptable, schemas can
    be schema-less or defined on-the-fly |'
  prefs: []
  type: TYPE_TB
- en: '| Scalability | Usually scales vertically (increase hardware power) | Often
    designed for horizontal scaling (adding more servers) |'
  prefs: []
  type: TYPE_TB
- en: '| Consistency | Strong ACID guarantees | Eventual consistency is common for
    faster writes |'
  prefs: []
  type: TYPE_TB
- en: '| Querying | Powerful, expressive SQL queries | Varies by database type, potentially
    less powerful than SQL for complex relationships |'
  prefs: []
  type: TYPE_TB
- en: '| Use cases | Data with rigid schemas, complex relationships, strong consistency
    needs | High-volume data, rapidly changing data models, high performance, specific
    query patterns, distributed systems |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Comparison between data persistence models
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Table 5.1* , RDBMSs excel in predictable and structured data models,
    where data accuracy and relationships are key. NoSQL stands out in scenarios where
    flexibility, massive scalability, and high performance for specific needs take
    priority. Both are excellent proposals for different types of applications, with
    their varied applicability, such as an application persisting data in SQL Server
    and using Redis to manage the cache of some information, avoiding constant access
    to the database. Both approaches are used for the same application.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, ASP.NET Core 9 allows us to work with different types of data models
    because it is extensible and dynamic. Let’s delve a little deeper into two important
    concepts for manipulating data in relational databases, which are ORMs and Micro
    ORMs.
  prefs: []
  type: TYPE_NORMAL
- en: ORM and Micro ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ORM is a technique that acts as a bridge between the world of **object-oriented
    programming** ( **OOP** ) and the relational world of databases. OOP models data
    as objects with properties and behaviors, while databases work with tables, rows,
    and columns.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned at the beginning of the chapter, we use objects such as **SqlConnection**
    , **SqlCommand** , and **SqlDatReader** to read data in SQL Server. This is a
    simple approach, but as businesses become more complex, it can be a big problem
    to work with obtaining and mapping data to apply the required business rules in
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the example of the **Products** table, we implemented in the *Using the SQL
    Client* section, a SQL query was used to obtain all existing records. In real,
    large-scale applications, it is impractical for any interaction by users to be
    necessary to obtain all records from a table. This could cause serious performance
    problems in the application.
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary to insert, delete, and update data, and even customize searches
    through filters, meaning that a SQL command is written for each situation. Furthermore,
    for data to be processed efficiently, it is necessary to abstract what persistence
    is and what the business domain is. In C#, we can work with the concept of **object
    orientation** at a high level and, in this context, ORM emerges as a powerful
    technique that allows us to focus on the business, in addition to other flexibilities.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of an ORM on the .NET platform is called **Entity Framework**
    ( **EF** ). EF provides all the high-level mechanisms for manipulating and translating
    data either from objects to databases or from databases to C# objects.
  prefs: []
  type: TYPE_NORMAL
- en: With EF, we don’t need to worry about writing SQL queries for the various operations
    in a database. EF also has other features, such as **migrations** , which allow
    you to update the database according to the developed code model, providing a
    great solution for database versioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how ORM works, look at *Figure 5* *.7* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Simple data model of a banking system](img/B21788_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Simple data model of a banking system
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that it is possible to obtain data in a C# application, as we learned
    previously. To translate the data objects shown in *Figure 5* *.7* , it would
    be necessary to create three C# classes: **Customer.cs** , **Account.cs** , and
    **Movement.cs** . However, for each of the classes, it would be necessary to write
    different SQL queries to perform any operations on the database. Furthermore,
    for each business need, it would be necessary to map the data to C# classes and
    vice versa to persist data.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that to obtain customer data, such as their accounts and transactions,
    it would be necessary to carry out at least three database queries, interact with
    **SqlDataReader** objects, and create the respective C# objects. Although it is
    not a very complex job, as the software becomes more complex, with various changes,
    this model becomes problematic.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine changing the name of the **Description** column in the **Movement**
    table to **Event** . It would even be necessary to change all the SQL queries
    created in C#, in addition to the mappings. When it comes to more complex data
    models, maintenance difficulties and possible problems grow exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with an ORM, this entire task is abstracted and less complicated.
    Fortunately, EF provides a great solution for this scenario, requiring the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection string** : Database address and access credentials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DbContext object** : Orchestrator of the connection to the database and management
    of objects and mappings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DbSet** : Domain objects that will be mapped to database objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core manages all the communication with the database, mapping, and migrations,
    allowing developers to focus on the business.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **DbContext** class for the example in *Figure 5* *.7* would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will implement this class in more detail in the next section. At this point,
    it is important to understand that all the tables that will be managed by **DbContext**
    are properties of the class **BankingDbContext** with the type **DbSet** .
  prefs: []
  type: TYPE_NORMAL
- en: The mapping of database objects is generally done by conventions, where EntityFramework
    Core compares the property names and types against the table column names and
    types in the database, but can be easily customized using specialized attributes
    or classes.
  prefs: []
  type: TYPE_NORMAL
- en: Conventions in EF Core
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about conventions, visit [https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions](https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'With mapping database conventions, we can obtain all the customers in the database
    through the **BankingDbContext** class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code, the **GetAllAccountsAsync** method searches
    for all the accounts in the database. The EF Core **ToListAsync** method will
    query the database asynchronously, returning a list of **Account** objects.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code shows a simple and powerful approach using ORM, without needing
    to manage the connection or write SQL commands, as they are generated by EF, in
    addition to there being no need to map database objects into classes. All these
    functionalities are already abstracted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, ORMs provide several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reduced boilerplate code* : ORMs automatically generate much of the repetitive
    SQL code ( **SELECT** , **INSERT** , **UPDATE** ), allowing developers to focus
    on application logic, not data access code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enhanced productivity* : Working with objects is often more intuitive for
    developers who are used to OOP principles, speeding up development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Increased maintainability* : ORMs provide a certain level of abstraction between
    your application code and the specific database, making it easier to switch database
    providers or refactor your data model with less impact on your codebase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, ORM technologies have pros and cons to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Performance overhead* : In some cases, the SQL queries generated by an ORM
    might not be the most efficient. Experienced developers can often write more performant
    SQL by hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Potential abstraction issues* : ORMs can hide some of the underlying database
    concepts, which can be beneficial, but might make optimization or troubleshooting
    more challenging for those unfamiliar with database fundamentals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core is in version 8 and, over the years, it has been improved, with different
    features added. However, we still recommend using the best technology offered
    to us wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Although ORM technologies are becoming increasingly modern, there is still a
    concern about performance, especially when you have a complex data model, with
    several levels of relationships between objects. ORMs are often not capable of
    generating extremely performant queries, and, in some cases, it is necessary to
    use other resources, such as the Micro ORM approach learned at the beginning of
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this context of facilitating work between the application and database objects,
    the concept of Micro ORM emerged.
  prefs: []
  type: TYPE_NORMAL
- en: '**Micro ORMs** are conceptually very similar to the ORM model. However, micro
    ORMs abstracts the database mapping objects into C# classes but prioritize performance.
    In some cases, they even provide some automatic generation of queries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some differences between Micro ORM and ORM are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Footprint* : Micro ORMs have a much smaller code base and fewer dependencies,
    resulting in significantly less overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Complexity* : Micro ORMs offer a basic set of features for mapping and executing
    queries, leaving behind many of the complexities found in traditional ORMs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Control* : With less abstraction, developers have more direct control over
    the SQL queries being executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Features* : Micro ORMs typically lack these features often found in larger
    ORMs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensive object relationship management
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change tracking
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic schema migrations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity maps (entity tracking to prevent duplicate payloads)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some Micro ORM technologies commonly used by the .NET community, the
    most famous of which is called Dapper.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper is open source
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dapper library is open source and is constantly being updated. There is
    a comparison between different ORM engines, including EF Core, on GitHub: [https://github.com/DapperLib/Dapper](https://github.com/DapperLib/Dapper)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Using a Micro ORM does not preclude using an ORM. They can coexist in an application,
    depending on the need and context. It is important to keep in mind that this approach
    allows us to bring greater quality to our applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover, in a practical way, the use of EF Core and
    Dapper based on the previously mentioned *bank* *account* concept.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what an ORM and a Micro ORM are, the time has come to
    implement solutions using these approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Working with EF Core and Dapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ORM and Micro ORM are widely techniques used in modern applications due to their
    various benefits. As we have learned, ASP.NET Core 9 has several options for working
    with data models from different technologies. We will learn how to use EF Core
    as an ORM, and we will also use Dapper as a Micro ORM.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the example of the bank account data model, we have tables *Customer*
    , *Account* , and *Movement* , we will create a project to connect to the SQL
    database we configured at the beginning of the chapter, which is running in a
    Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: The complete solution code will therefore be available in the GitHub repository
    mentioned in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, we will use a Minimal API project and, to do this, open the
    terminal in administrator mode and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to add the EF Core libraries that will be necessary for the application
    to connect to the SQL server database. Additionally, we will need to install an
    EF CLI tool. This tool will be used to apply some updates to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first command installs the EF CLI tool, and the following commands are the
    EF libraries that will be used to connect the application to the database.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core database providers
  prefs: []
  type: TYPE_NORMAL
- en: EF Core has the ability to work with different databases; it is not restricted
    to SQL Server. More details about the available providers can be found at [https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli](https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The project is now ready to be configured, and we will perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the connection string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create model classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class that inherits from **DbContext** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the **DbContext** created in the ASP.NET Core 9 DI container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add migrations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you perform these steps, you will notice some differences from implementing
    communication with the database in the traditional approach using **SqlConnection**
    , **SqlCommand** , and **SqlDataReader** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project in Visual Studio Code with the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete project has the structure shown in *Figure 5* *.8* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Banking project project structure](img/B21788_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Banking project project structure
  prefs: []
  type: TYPE_NORMAL
- en: To configure the connection string, we will use **appsettings.json** . It is
    important to mention that information containing user credentials should not be
    available directly in a code repository. The best practice is to use secrets or
    even a configuration server such as **Azure App Configurator** to manage this
    information. We’ll talk more about good security practices in [*Chapter 6*](B21788_06.xhtml#_idTextAnchor093)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'For teaching purposes, we will add the connection string to the **appsettings.json**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are using the same connection string as the database server running through
    Docker, with an additional default, **Database=dbBanking** , which will be used
    for this application. The JSON **ConnectionStrings** object is an ASP.NET Core
    9 convention, with each property of this object representing a different connection
    string.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core does all the work of managing the connection and mapping database entities
    into C# objects, as well as generating SQL commands. For this to be possible,
    there is a base object that we must use to map the domain classes. This base object
    is called **DbContext** .
  prefs: []
  type: TYPE_NORMAL
- en: '**DBContext** implements the **Unit of Work** design pattern, managing all
    states of the objects manipulated in memory and persisting changes when necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit of Work pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Unit of Work design pattern is used in different contexts, favoring the
    separation of responsibilities, such as separating all the business rules of an
    application from the responsibility of communicating with and manipulating data
    in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about the Unit of Work pattern at [https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance](https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the project structure shown in *Figure 5* *.8* , we will create
    a class called **BankingDbContext.cs** that will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For the application we are creating, the class is quite simple. Let’s explore
    the most important points of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DbContext** : The **BankingDbContext** class inherits from the **DbContext**
    superclass, which has the necessary abstractions for communication between the
    application and the database, state management, mapping, and the generation of
    SQL commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BankingDbContext** constructor: The class constructor receives, as a parameter,
    the generic **DbContextOptions<BankingDbContext>** class, which allows us to pre-define
    configurations that will be used in the DI container to create an instance of
    the **DbContext** object. The constructor can also receive a connection string;
    however, it is good practice to use the C# options pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DbSet** : Each property of the **DbSet** type represents a table in the database,
    and it is these properties that provide information to EF Core to transform data
    from tables into objects and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# options pattern
  prefs: []
  type: TYPE_NORMAL
- en: The **options pattern** is widely used in the .NET platform with the aim of
    providing strongly typed access to groups of related settings.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about the options pattern at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The **BankingDbContext** class is now complete and provides everything needed
    to interact with the SQL database. The mapping model used, in this case, is based
    on the EF Core convention, which infers the name of the table and columns from
    the name of the class and its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the **Account.cs** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Based on this class and the EF Core convention, it is expected that there will
    be a table named **Account** and columns called **Id** , **Name** , **Balance**
    , and **CustomerId** in the database.
  prefs: []
  type: TYPE_NORMAL
- en: But there is, in addition, a property called **Customer** and a collection of
    **Movement** objects. Due to the existence of the **CustomerId** property, EF
    infers that there is a relationship with the **Customer** table, which has a foreign
    key ( **<TableName>+Id** ) in the **Account** table. Likewise, because there is
    a **Movement** collection, EF infers that the **Account** class may have one or
    more **Movements** in the **Movement** table.
  prefs: []
  type: TYPE_NORMAL
- en: However, if it is necessary to follow different naming standards from database
    to database, the names of tables, columns, primary keys, and so on can be mapped
    directly into the **DbContext** class using the fluent API. This can be done using
    data annotation in the domain classes, or even by implementing a specific mapping
    class for each entity using the **IEntityTypeConfiguration<TEntity>** interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example represents a custom or manual mapping of the **Customer**
    class to the **tbl_customer** table. In order to customize the mapping of classes
    in database entities, it is necessary to override the **OnModelCreating** method,
    inherited from the **DbContext** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the code, it is possible to define all the attributes required
    for the correct mapping of entities.
  prefs: []
  type: TYPE_NORMAL
- en: With the **BankingDbContext** class finalized, we must configure it in the DI
    container and configure the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the following line to the **Program.cs** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We use the **AddDbContext<BankingDbContext>** extension method to configure
    the connection string that will be used for the connection. Note that we are using
    the **options** property, which is expected in the **DbContext** constructor,
    and through the use of the **UseSqlServer** extension method, we are recovering
    the connection string that we configured in the **appsettings.json** file.
  prefs: []
  type: TYPE_NORMAL
- en: The application is practically ready to communicate with the database; however,
    it will still be necessary to add migrations and update the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal in the project directory and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This command uses the EF CLI tool that we installed previously, adding migrations
    with the name **InitialDatabase** .
  prefs: []
  type: TYPE_NORMAL
- en: The objective of migrations is to allow the application and the database to
    remain synchronized in the objects that are used. In real applications, changes
    to the database, such as creating new tables or adding or removing columns, can
    happen constantly. These changes impact both the database in question and the
    application that consumes the objects in this database. When adding a migration,
    such as in the preceding command, we are taking a picture of the domain model
    that the application uses, and EF Core generates the scripts that will be applied
    to the database to keep it up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Migrations create a set of classes in the project. These classes must not be
    changed manually. As we can see in *Figure 5* *.9* , three files were added to
    the application’s **Migrations** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Initial database migration files](img/B21788_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Initial database migration files
  prefs: []
  type: TYPE_NORMAL
- en: 'When observing a snippet of code extracted from the **InitialDatabase.cs**
    suffix file, we observe that they are resource creation scripts in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With each change in your application’s domain model, a new migration must be
    added. This way, you will maintain a history of changes, and this will facilitate
    the maintenance and evolution of the database and the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will need to update the database. So far, we have not run any SQL scripts
    on SQL Server, much less created the database. Instead of opening Azure Data Studio
    to perform this task, we will use the EF Core CLI tool to update the database
    according to the version mapped in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, run the following command in the terminal, in the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The CLI tool will connect to SQL Server and execute scripts to create the database
    and tables mapped in the application. *Figure 5* *.10* displays the created objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Objects created in the database using the EF CLI tool](img/B21788_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Objects created in the database using the EF CLI tool
  prefs: []
  type: TYPE_NORMAL
- en: 'All communication with the database has been properly configured. The time
    has come to add the APIs to interact with the database. Therefore, create the
    following routes in the **Program.cs** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The above routes perform operations on the Customer table. Notice the first
    Get method. This method receives as a parameter an instance of the **BankingDbContext**
    object that is automatically resolved through the .NET Core dependency injection
    DI context.
  prefs: []
  type: TYPE_NORMAL
- en: Then, using the **dbContext.Customers.ToListAsync(cancellationToken)** code,
    all existing customers in the database are retrieved. We only use the **Customers**
    **DbContext** and **DbSet** , and EF Core takes care of creating the SQL query
    to select the records. There is no need to open connections, create commands,
    or even map manually. Everything is done transparently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Post** method performs the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dbContext.Customers.AddAsync** : The **Customer** object is passed as a parameter
    in the request body. This is then added to **DbSet** in the same way as we would
    add an item to a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dbContext.SaveChangesAsync** : When executing this method, **dbContext**
    updates the database. This means that if there were other operations on the **DbSets**
    , such as removal, updates, or additions, this information would only be updated
    in the database after executing the **SaveChanges** or **SaveChangesAsync** methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous processing and cancellation token
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous processing is a fundamental aspect of modern web application development.
    In ASP.NET Core 9, asynchronous methods allow the server to handle more requests
    simultaneously by not blocking threads during operations such as database queries,
    file access, or consuming HTTP resources. This approach allows the application
    to scale and respond quickly under load. The **async** and **await** keywords
    make it possible to write asynchronous code that is easy to maintain and read,
    and the .NET platform abstracts the complexity of managing asynchronous mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: In conjunction with asynchronous methods, it is a good practice to use cancellation
    tokens, which allow applications to properly handle the cancellation of requests,
    making applications more responsive and resilient. The cancellation token associated
    with an asynchronous method propagates a cancellation signal throughout all of
    the application’s asynchronous operations, allowing them to terminate early and
    free up resources. ASP.NET Core 9 and C# simplify asynchronous programming and
    the use of cancellation tokens, providing a robust framework that ensures applications
    remain responsive even under varying loads.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about asynchronous programming and token cancellation,
    visit [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)
    and [https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads](https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads)
    .
  prefs: []
  type: TYPE_NORMAL
- en: With this, we can run the application to interact with the database in a simple
    way, making it possible to perform any operations using **Language Integrated
    Query** ( **LINQ** ), such as advanced filters or obtaining records ordered by
    specific columns.
  prefs: []
  type: TYPE_NORMAL
- en: The use of an ORM provides several benefits for high-level applications and,
    likewise, several challenges when we delegate the management of data management
    complexity to the ORM. This makes them slow, since, despite several innovations
    and improvements, in many cases, they are not the best choice when it comes to
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Micro ORMs are great options; they have similar performance to
    traditional approaches and mapping capabilities like ORMs. Therefore, let’s explore
    how Dapper can be used to add more features to the database communication model.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Dapper** is a Micro ORM that gives us the ability to interact with the database
    in a performative way while mapping database entities into C# objects.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a simple-to-use yet powerful library. Its mapping model is interesting
    and flexible, allowing you to create different types of query result projections
    quickly and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper and EF Core are not mutually exclusive technologies, and using both approaches
    in a project can provide great benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the Dapper library to the project created previously by executing
    the following command in the terminal, in the application directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All the prerequisites required to work with Dapper have already been implemented
    in the project, the main one being the connection string that we configured in
    the **appsettings.json** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the **Program.cs** file to add two new routes that use Dapper
    to perform a query where we can obtain all the customers in the database and query
    a customer by **Id** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explore the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: In C# and ASP.NET Core 9, the **_ => new** syntax is known as discarded lambda
    and is used when there is no need to use the input parameter of the lambda expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SqlConnection** : We are adding the **SqlConnection** object to the DI container
    using the same connection string used by the **DbContext** . We are using the
    **AddScoped** method, which means that each time the **SqlConnection** object
    is used during a request, it will be reused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QueryAsync** : We are getting all the customers from the database using a
    simple SQL query. The desired columns have been added to the SQL command, along
    with an **ORDER BY NAME** statement. **QueryAsync** is a **SqlConnection** extension
    method and, when it obtains the result, it will automatically map the data to
    C# objects based on the names of the properties and columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the data from the database
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, it is not recommended to fetch all the records from a database in
    a single query as there may be thousands or millions of records in the database
    tables, which can cause performance problems. Keep in mind that the example proposed
    here is intended to facilitate understanding of the concept and should not be
    used in production applications. The recommended solution is to use pagination.
    Pagination involves breaking data into small, manageable chunks. To learn more,
    the following page contains implementation examples: [https://learn.microsoft.com/en-us/ef/core/querying/pagination](https://learn.microsoft.com/en-us/ef/core/querying/pagination)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryFirstOrDefaultAsync** : In the same way as the previous method, a query
    is made in the database and if the record is found, it will be returned and mapped
    to a Customer object. If the record is not found, then it returns the value **Null**
    . The important point in the SQL query is the use of the **@Id** parameter. Dapper
    methods can substitute named parameters in the string. So, after defining the
    SQL command with the parameters, we must define an object that contains the named
    properties of the same parameters as the parameters defined in the SQL command.
    In the code example above, the defined parameter is named **@Id** , which requires
    that the object passed as a parameter has a property named Id, like the snippet
    **new {Id = id}** . Using an object allows us to define more than one parameter
    if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of SQL commands, in this case, allows us to create more performant queries
    for different purposes. Likewise, Dapper can be used to add, change, and remove
    records in the database.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we do not need to manage the SQL connections that are controlled
    by the DI container, and we benefit from the ORM’s automatic mapping approach.
  prefs: []
  type: TYPE_NORMAL
- en: Dapper SqlBuilder
  prefs: []
  type: TYPE_NORMAL
- en: Dapper also has an extension that makes it easier to write SQL commands in the
    format needed by the Micro ORM called Dapper SQL Builder. It is a very useful
    extension, even when it is necessary to manipulate SQL strings according to some
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about the Dapper SQL Builder extension by visiting [https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder](https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder)
    .
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, both ORM and Micro ORM are great allies in the communication
    model with the database and can be used together, providing different benefits
    in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: This flexibility of ASP.NET Core 9 allows us to create different types of applications,
    from the simplest to the most complex, and interact with databases using best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about data persistence in ASP.NET Core 9, exploring
    how applications interact with databases to store and manage critical information.
    You’ve compared the strengths of relational (SQL) and non-relational (NoSQL) databases,
    allowing you to choose the right fit for your project. Additionally, you’ve seen
    how ORMs such as EF Core simplify development by mapping objects to database records,
    and you’ve learned about the benefits of Micro ORMs such as Dapper for fine-grained
    control over performance-critical database operations.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take another step toward developing high-quality applications by learning
    about security best practices in [*Chapter 6*](B21788_06.xhtml#_idTextAnchor093)
    . We’ll explore essential best practices and strategies for defending your applications
    against vulnerabilities. You’ll learn how to ensure user data protection, authentication
    security, and overall application integrity – vital foundations for building robust,
    reliable web applications.
  prefs: []
  type: TYPE_NORMAL
