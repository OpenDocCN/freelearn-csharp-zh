<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Baking Cupcake Towers</h1></div></div></div><p>In this second chapter, we will begin to build our game. We will see how it's possible to place objects in 2D space and create templates for the most used objects. Furthermore, we will see how Unity deals with scripts, and we will write a couple of our own for our game.</p><p>In particular, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Placing objects in 2D space</li><li class="listitem">Setting up the map for our game</li><li class="listitem">Using tags and layers</li><li class="listitem">Creating Prefabs (templates for game objects)</li><li class="listitem">Creating new scripts</li><li class="listitem">Basic concepts of scripting in Unity</li><li class="listitem">Writing our first two scripts for our game</li></ul></div><p>Like all the other chapters of this book, you will find the <em>Homework</em> section at the end. It has a range of different exercises for you to do to improve your skills and implement a range of different functionalities into your game.</p><p>So, let's get started by learning how to place 2D objects into the scene.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>2D objects</h1></div></div></div><p>In the previous chapter, we saw that 2D objects in Unity are Sprites. However, we didn't mention how to import them into the scene.</p><p>The easiest way to bring your Sprites into the scene is to drag and drop them from the <strong>Project</strong> panel into the <strong>Scene view</strong>. Unity will automatically create a new game object with the same name of the Sprite along with a Sprite Renderer attached. We have already covered this component in the previous chapter. Since we will not use Sorting Layers (as we decided in the previous chapter), we don't need to change any settings when dragging a new Sprite into the scene.</p><p>Another way to add Sprites to the scene is by right-clicking on the <strong>Hierarchy</strong> panel and then <strong>2D Object | Sprite</strong>. However, in the Sprite Renderer, you need to specify which Sprite to use.</p><p>Let's bring the <code class="literal">Pink_Sprinkle</code> Sprite into our scene (you can find it in the <code class="literal">Graphics/projectiles</code> folder within the <code class="literal">projectiles_sheet_01</code> file). It appears like this in the <strong>Scene</strong> view:</p><div><img src="img/image00354.jpeg" alt="2D objects"/></div><p style="clear:both; height: 1em;"> </p><p>Since Sprites are also GameObjects, you can have access to their <strong>Transform</strong> properties, as shown here:</p><div><img src="img/image00355.jpeg" alt="2D objects"/></div><p style="clear:both; height: 1em;"> </p><p>This means that you can change their position along the <em>x</em> axis and the <em>y</em> axis, as well as the scale and the rotation. Remember that the <em>z</em>-axis is used to determine the depth, as we discussed in the previous chapter.</p><p>By using the <strong>Scale</strong> parameter, it is possible to flip the Sprite. However, keep in mind that this will also flip its children. As we saw in the previous chapter, from Unity 5.3 to flip a Sprite it is preferable to use the <strong>Flip</strong> variable on the <strong>Sprite Renderer</strong>.</p><div><h3 class="title"><a id="note12"/>Note</h3><p>You can create an empty game object by navigating to the top bar menu and select <strong>GameObject | Create Empty</strong>. Alternatively, on the <strong>Hierarchy</strong> panel, click on <strong>Create</strong>, then select <strong>Create Empty</strong>. Creating an empty game object is a very useful when we need to create containers of other game objects, or if we want to build our game object from scratch.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Parenting game objects</h1></div></div></div><p>Each game object can have a parent. This means that the game objects will move, rotate, and scale along with its parent.</p><p>I could use many words to explain this concept, but there are things which videos can explain better than words. As such, there is a very short video explaining, <em>The Hierarchy and Parent-Child relationships </em>at: <a class="ulink" href="https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships">https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships</a>.</p><p>I recommend that you to watch it before you continue reading this book. I'll wait for you here.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Difference between world coordinates and local coordinates</h1></div></div></div><p>Every game object in Unity has a position, but a position needs a reference frame (more about reference frames later in <a class="link" title="Chapter 5. The Secret Ingredient Is a Dash of Physics" href="part0062.xhtml#aid-1R42S1">Chapter 5</a>, <em>The Secret Ingredient Is a Dash of Physics</em>). In particular, Unity offers two ways to see (and set) coordinates:</p><div><ul class="itemizedlist"><li class="listitem"><strong>World coordinates</strong>: These are absolute coordinates of where the game object is located (by absolute, I mean with respect to the world frame, which is considered to be absolute in the game)</li><li class="listitem"><strong>Local coordinates</strong>: These are the coordinates of where the game object is with respect to its parent</li></ul></div><p>You can easily switch between the two coordinates with a toggle in the upper-right part of the Unity interface, as shown in the following screenshot:</p><div><img src="img/image00356.jpeg" alt="Difference between world coordinates and local coordinates"/></div><p style="clear:both; height: 1em;"> </p><p>As shown in the preceding screenshot, they are both toggles, but the one to switch between world and local coordinates is the one on the left. At the moment, it is selected to be on <strong>Global</strong>, which means on world coordinates.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Ordering the different layers with Z-Buffering</h1></div></div></div><p>In the previous chapter, we decided to use Z-Buffering instead of Sorting Layers. However, we need to decide which elements of our game will be in the foreground compared to the others.</p><p>In addition, it is important to keep in mind how the camera is set. Select <strong>Main Camera</strong>, which should be the only camera in the scene. This is what the <strong>Inspector</strong> should look like:</p><div><img src="img/image00357.jpeg" alt="Ordering the different layers with Z-Buffering"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, by default, its <strong>Z</strong> value on the the position is set to <code class="literal">-10</code>. This means you cannot have any greater negative values (that means smaller than <code class="literal">-10</code>) in the <strong>Z</strong> value of a Sprite, otherwise it will not be rendered. For our purpose, <code class="literal">-10</code> is perfect, and we will stick with it.</p><p>Next, we need to assign a <strong>Z</strong> value to all the elements that we have. We can start to place the map in the background, by assigning the lowest depth (maximum <strong>Z</strong> value) that we have in mind; in this case it's zero.</p><p>Then, we would like to have the enemies. Therefore, we can set their <strong>Z</strong> value to <code class="literal">-1</code>. After them, the projectiles and the towers, respectively <code class="literal">-2</code> and <code class="literal">-3</code>. Finally, we need to add another value for the foreground. Here is a summary table:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><strong>Elements</strong></p>
</td><td>
<p><strong>Z value (depth)</strong></p>
</td><td>
<p><strong>Reasons</strong></p>
</td></tr><tr><td>
<p>Map</p>
</td><td>
<p><code class="literal">0</code></p>
</td><td>
<p>The map has the lowest value, since it will be behind everything.</p>
</td></tr><tr><td>
<p>Enemies</p>
</td><td>
<p><code class="literal">-1</code></p>
</td><td>
<p>Enemies are rendered after the map, since they may pass behind the towers, which we would like to keep visible. Furthermore, also the projectiles should be visible on the enemies, just before they hit them.</p>
</td></tr><tr><td>
<p>Projectiles</p>
</td><td>
<p><code class="literal">-2</code></p>
</td><td>
<p>Projectiles are shot from the towers, so it may look odd having the projectiles on top of the tower, whereas appearing from the back appears more natural.</p>
</td></tr><tr><td>
<p>Towers</p>
</td><td>
<p><code class="literal">-3</code></p>
</td><td>
<p>The towers don't have any other layer on top of them, excluding the map overlay.</p>
</td></tr><tr><td>
<p>Map Overlay</p>
</td><td>
<p><code class="literal">-9</code></p>
</td><td>
<p>This is in the foreground, so it has to be rendered last. We chose <code class="literal">-9</code> instead of <code class="literal">-4</code> because we may add some other layers, but the foreground is always the closest one to the camera. We will see what this layer contains in the next section.</p>
</td></tr><tr><td>
<p>Main Camera</p>
</td><td>
<p><code class="literal">-10</code></p>
</td><td>
<p>As default.</p>
</td></tr></tbody></table></div><p>We need to keep these values in mind when we create the Prefabs for our game elements. This is important both for this chapter and the rest of the book.</p><div><h3 class="title"><a id="note13"/>Note</h3><p>We will discuss what a Prefab is later in the chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Unfolding the map</h1></div></div></div><p>We are finally ready to place the 2D map in our scene.</p><p>In the previous chapter, we have set the resolution to 16:9. Therefore, the maps that we will find in our packages are ready to use.</p><p>Let's start by dragging the <code class="literal">sugar_mountain_map</code> Sprite from the <code class="literal">Graphics/maps</code> folder into our scene. We need to place it in (0,0,0). Please note that the <em>z</em> axis is set to zero.</p><p>It is a perfect map for what we need. For example, on the left side, there is the beginning of the path that the sweet-tooth pandas will follow. At the end of the path, there is the Sugar castle that the player needs to protect. Furthermore, there is enough space at the top to implement our user interface in <a class="link" title="Chapter 3. Communicating with the Player – the User Interface" href="part0043.xhtml#aid-190861">Chapter 3</a>, <em>Communicating with the Player - the User Interface</em>.</p><p>The next step is to modify the camera settings. What we want to do is to fit the entire map in the <strong>Camera</strong> view. To achieve this, just modify the <strong>Size</strong> properties to <code class="literal">22.5</code> as shown here:</p><div><img src="img/image00358.jpeg" alt="Unfolding the map"/></div><p style="clear:both; height: 1em;"> </p><p>As a result, our map will be perfectly centered in the <strong>Camera</strong> view. This is what we should see in the <strong>Scene</strong> view with the camera selected:</p><div><img src="img/image00359.jpeg" alt="Unfolding the map"/></div><p style="clear:both; height: 1em;"> </p><p>Now, let's bring in one of the cupcake tower we sliced in the previous chapter; for instance, the <code class="literal">ChocolateChip_Cupcake_Tower_2</code>. If we drag it to the beginning of the path, we have the following problem:</p><div><img src="img/image00360.jpeg" alt="Unfolding the map"/></div><p style="clear:both; height: 1em;"> </p><p>Or also at the bottom of the map:</p><div><img src="img/image00361.jpeg" alt="Unfolding the map"/></div><p style="clear:both; height: 1em;"> </p><p>In fact, the cupcake tower is not supposed to be on the rock, but behind it, due to the perspective. Since we are working in a 2D world, we need to create a perspective. Luckily, our package contains an overlay of our map. It also contains all the assets that should be in the foreground, as shown here:</p><div><img src="img/image00362.jpeg" alt="Unfolding the map"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note14"/>Note</h3><p>Please note that usually, all the assets are on different levels so we can customize their positions. However, in the package they are pre-placed as for your convenience, so we don't lose time to learn amazing things!</p></div><p>So, let's add also this overlay to the scene. It is called <code class="literal">sugar_mountain_map_overlay</code> and can be found inside the <code class="literal">Graphics/maps</code> folder. Again, remember to set its <em>x</em> and <em>y</em> positions to zero. After we have done this, we don't see any difference, and the cupcake tower still hovers over the rock. In fact, we have decided from the previous section, that all of the <em>z</em>-axis values should be assigned to the different game elements. If you remember, the value for the map overlay is <code class="literal">-9</code>.</p><p>Once you have set the map overlay <em>z</em>-axis value, our cupcakes should behave as we wished:</p><div><img src="img/image00363.jpeg" alt="Unfolding the map"/></div><p style="clear:both; height: 1em;"> </p><p>It behaves in the right way here, as well:</p><div><img src="img/image00364.jpeg" alt="Unfolding the map"/></div><p style="clear:both; height: 1em;"> </p><p>The map is finally ready. One last touch; we should parent the map overlay to the map itself. Therefore, if we need to change the map, they will move and scale together.</p><p>Before we continue our journey, remember to delete the cupcake tower, since we only needed it for testing purposes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Layers and tags</h1></div></div></div><p>If you already have in mind what are you going to do, it's good to set everything up at the beginning. In particular, Unity has some labels that can be given to game objects. These are layers and tags. Unity uses these two properties to discriminate amongst certain kinds of game objects.</p><p>By default, some of them are already defined, but we need a few more for our project. From the toolbar menu, we can access the layers and tags settings by navigating to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Tags and Layers</strong>. As a result, the <strong>Inspector</strong> should now look like the following screenshot:</p><div><img src="img/image00365.jpeg" alt="Layers and tags"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note15"/>Note</h3><p>In this menu, we also have the possibility to change the sorting layers for rendering 2D objects. However, as mentioned earlier, we will use Z-Buffering to achieve the same effect.</p></div><p>Let's expand the <strong>Tags</strong> menu, as follows:</p><div><img src="img/image00366.jpeg" alt="Layers and tags"/></div><p style="clear:both; height: 1em;"> </p><p>To add a new tag, just press on the + button in the bottom-right corner. We need to add two tags, respectively <code class="literal">Enemy</code> and <code class="literal">
<strong>Projectile</strong></code>, as shown in the following screenshot:</p><div><img src="img/image00367.jpeg" alt="Layers and tags"/></div><p style="clear:both; height: 1em;"> </p><p>In fact, we will need these two tags later on in the development of this game. In fact, when a cupcake tower searches for surrounding objects, it needs to discriminate between enemies and projectiles.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Prefabs</h1></div></div></div><p>When the scene begins to fill up with objects, some of these objects might become complex. By complex, I mean with a lot of components and children. If we need to use many of them in the game and maybe change all of them at once, Unity offers the possibility to create a Prefab.</p><p>As the name suggests, it is an object already assembled with all the necessary components and ready to be placed in the scene. The advantage is the possibility to reuse it often and to change all its instances quickly.</p><div><h3 class="title"><a id="note16"/>Note</h3><p>If an object in the scene is a Prefab, its name in the <strong>Hierarchy</strong> panel is blue. If the name is red, instead, this means that there are some references missing.</p></div><p>To keep our project organized, let's create a folder named <code class="literal">Prefabs</code>, if we haven't done so yet. Inside the folder, right-click and then select <code class="literal">Create/Prefab</code>. You can name it as you want, but for this book, let's stick with <code class="literal">Pink_Sprinkle_Projectile_Prefab</code>.</p><p>We already have the sprinkle in the scene, so from the <strong>Hierarchy</strong> panel, drag it into the <code class="literal">Pink_Sprinkle_Projectile_Prefab</code>.</p><p>Now, we can also erase the previous sprinkle from the scene, as we don't need it anymore. For testing purposes, you can try to add as many sprinkles as you want in the scene by dragging the Prefab into the <strong>Scene</strong> view. Of course, remember to erase them before continuing with the rest of this chapter.</p><p>When we select an object that is an instance of a Prefab, three additional buttons appear in the <strong>Inspector</strong>, as shown in the following screenshot:</p><div><img src="img/image00368.jpeg" alt="Prefabs"/></div><p style="clear:both; height: 1em;"> </p><p>These are their functions:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Select</strong>: This is a shortcut to quickly select in the <strong>Project</strong> panel the Prefab of the object.</li><li class="listitem"><strong>Revert</strong>: If we did some changes in the instance of the Prefab (the current selected object), these do not affect the Prefab. By clicking on this button, we revert all the changes to the original Prefab.</li><li class="listitem"><strong>Apply</strong>: If, on the other hand, you are satisfied with the changes you made to this instance of the Prefab, by clicking on this button, you can apply these changes to the Prefab. As a result, you may modify all of the other instances in the scene. So be careful when you use this function.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>The game view</h1></div></div></div><p>You should already know about the game view, but there might be some new types of functionality that you didn't know about before. So, a short recap might be useful, before we move on in our journey.</p><p>First of all, we have our three main buttons, which you should be very familiar with, as shown here:</p><div><img src="img/image00369.jpeg" alt="The game view"/></div><p style="clear:both; height: 1em;"> </p><p>The first is the play button, which makes your game run. The second button pauses the game, and allows you to tweak some settings. The last one makes your game run for one frame only.</p><p>In the top-left corner, we have the displays and the resolution tabs that we covered in the previous chapter. In the opposite corner (top-right), there are many different yet useful toggles, as shown in the following screenshot:</p><div><img src="img/image00370.jpeg" alt="The game view"/></div><p style="clear:both; height: 1em;"> </p><p>These are their functions:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Maximize on Play</strong>: If this is on, every time you push the play button, the game view will be maximized to the largest window it can be. It's useful for testing the game in almost full screen; otherwise, it can be a little bit hard to tweak values without having a second monitor.</li><li class="listitem"><strong>Mute Audio</strong>: If this is enabled, as the name suggests, it silences all the audio sources in the game.</li><li class="listitem"><strong>Stats</strong>: If this is on, it provides some basic feedback about the performance of your game, as shown here:</li></ul></div><div><img src="img/image00371.jpeg" alt="The game view"/></div><p style="clear:both; height: 1em;"> </p><div><ul class="itemizedlist"><li class="listitem"><strong>Gizmos</strong>: These are used to identify objects in the scenes. However, we will see these later in <a class="link" title="Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence" href="part0077.xhtml#aid-29DRA1">Chapter 6</a>, <em>Through a Sea of Sprinkles - Navigation in Artificial Intelligence</em>.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Math background</h1></div></div></div><p>Either you like math or not; however, it is a fact that it is required for game development. We don't have time to go through all the math behind this game, since it is required to have a complete toolset for game development. However, this section introduces you to some basic concepts that we will need for the rest of the book. In addition, it also makes some references to the official documentation so that you can learn a bit more about it.</p><p>If you feel confident with some of the following topics, you are free to skip them:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Vectors</strong>: They are really important in game development, because they are able to describe spaces (both 3D and 2D). They can represent a position or a direction. You can read more about them at <a class="ulink" href="https://docs.unity3d.com/Manual/VectorCookbook.html">https://docs.unity3d.com/Manual/VectorCookbook.html</a> and watch this video: <a class="ulink" href="https://unity3d.com/learn/tutorials/topics/scripting/vector-maths">https://unity3d.com/learn/tutorials/topics/scripting/vector-maths</a>.</li><li class="listitem"><strong>Probability</strong><strong>: </strong>This is very important when we want a sample to emerge from our game, by including uncertainty and chances for the player. A common example is in RTS or MMORPG games, where the amount of damage is often between a range (determined by the character's stat), but the actual and real amount of damage uses random numbers. Another case is when an attack should be critical so to inflict double the damage. At the end of the chapter it is explained how to extract random numbers in Unity. However, consider buying a proper math book about probability; it might be worthwhile.</li><li class="listitem"><strong>Radians and Degrees</strong>: Angles can have two unit of measurements. Radians are usually used to perform calculations, but Unity has some constants that by a multiplication can convert one to the other representation. You can read more about these at <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html">https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html</a> and <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html">https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html</a>.</li><li class="listitem"><strong>Trigonometry</strong>: This is really important, because the sine and the cosine functions are often used to achieve believable behavior, since Mother Nature uses them for our world. Unluckily, there are no shortcuts. Therefore, if you really want to understand them and get into them, you should read any book about trigonometry. However, the most important notion used is that they range the value of their arguments between <code class="literal">-1</code> and <code class="literal">+1</code>.</li><li class="listitem"><strong>Quaternions</strong>: This is a math entity that's not very intuitive, since it involves the analysis of complex numbers. However, it's not important to know them in detail (except in really specific cases) when programming in Unity. In fact, it's enough to know that Unity uses them to store rotations. Also, there are functions to convert from the Euler representations (the most intuitive of three angles). The reason of this choice is behind the scope of this book, but it's due a numerical instability of the Euler representation. You can learn more about them by watching the following video: <a class="ulink" href="https://unity3d.com/learn/tutorials/topics/scripting/quaternions">https://unity3d.com/learn/tutorials/topics/scripting/quaternions</a>.</li><li class="listitem"><strong>Atan2()</strong>: This is a function that is really important in game development, because it is able to calculate the angle of a vector. You can read more about this function at <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html">https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html</a>.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Scripting in Unity</h1></div></div></div><p>In this section, we will learn one of the toughest topics in game development! However, I strongly encourage you not to be scared, but try to practice a lot. As a result, you will be able to master every single detail of your game. And that is awesome!</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Creating new scripts</h2></div></div></div><p>First of all, we need to understand how to create new scripts in Unity. The easiest way is to select a game object and in the <strong>Inspector</strong>, navigate to <strong>Add Component</strong> | <strong>New Script</strong>. In this way, you still have the possibility to rename it, but the script will be located in the <code class="literal">Asset</code> folder. Furthermore, it's not possible to create a class that cannot be attached to a game object.</p><p>A much better way is to create a folder called <code class="literal">Scripts</code> in the <strong>Project</strong> panel, if you haven't done so yet. Then, right-click and navigate to <strong>Create</strong> | <strong>C# Script</strong>. As a result, it will be in the right folder, and we don't have problems if we create a script that cannot be attached to game objects.</p><p>For the rest of this book, it will be assumed that every new script will be created in this way, and always in the <code class="literal">Scripts</code> folder.</p><p>Keeping the name of the script in mind is important, because the file should have the same name as the main class in the script. This means that if we change the name of the class later on, we need to rename the file accordingly as well. However, this may break some references in other scripts that will require correcting. So, be careful when changing names.</p><p>To open a script, you need to double-click on it. Unity will open a script editor. By default, it will be Monodevelop. However, it is possible to change this setting by navigating through <strong>Edit | Preferences...</strong>. In the <strong>External Tool</strong> tab, you can change the <strong>External Script Editor</strong>. Another commonly used script editor is Visual Studio, it can can be downloaded from <a class="ulink" href="https://www.visualstudio.com/">https://www.visualstudio.com/</a>.</p><p>However, if this is your first experience with Unity, I suggest that you stick with Monodevelop. In any case, for this book, we don't have any requirements (as far as you are able to edit the scripts), so feel free to choose the one you like best.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Basics about scripts</h2></div></div></div><p>If this is your first time scripting in Unity, there is some information to know before we begin.</p><div><h3 class="title"><a id="note17"/>Note</h3><p>Unity mainly supports two languages: C# and JavaScript. Since we created a C# script in the previous section, we are going to use this language for the rest of this book.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec4"/>Variables</h3></div></div></div><p>Variables can be public, private, or protected. We will not cover the last one, since we don't have enough time for that, and it's not really important when getting started with Unity development. Private variables can be used only within the script itself. Usually they are used to store internal data of the script that doesn't need to be shared among other components.</p><p>Public variables, instead, can be accessed from any script, so we need to pay attention where to use them. It's good practice to implement the <code class="literal">get</code> and <code class="literal">set</code> functions, when applicable. Even if we will not use them much in this book, it's worth learning what they are, which you can do at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/w86s7x04.aspx">https://msdn.microsoft.com/en-us/library/w86s7x04.aspx</a>.</p><p>Furthermore, public variables are visible in the <strong>Inspector</strong>. In fact, just for testing purposes, you can create a new script and add the following integer variable:</p><pre class="programlisting">public int testVariable; &#13;
</pre><p>As a result, after you have saved the script, you are able to set its value in the <strong>Inspector</strong>, as shown in the following screenshot:</p><div><img src="img/image00372.jpeg" alt="Variables"/></div><p style="clear:both; height: 1em;"> </p><p>As a consequence, public variables don't need to be set within the script in order to be able to use them. Often, we would like to have a public variable, since it will be set from another script, but not visible on the <strong>Inspector</strong>. You can achieve that in Unity by using an attribute.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec5"/>Attributes</h3></div></div></div><p>Before variables and functions, Unity allows us to insert an attribute. An attribute is enclosed between <code class="literal">[</code> and <code class="literal">]</code>, and can contain different parameters. Around 30 attributes exist and they really differ in functionality and usage. Since we don't have the time to go through them all, we will just cover the most commonly used ones:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">Header</code> attribute is formatted as <code class="literal">[Header("string")]</code>. It creates a header before the variables that follow it. Here is an example of adding the attribute to the variable of the test script we used earlier:<pre class="programlisting">        [Header("This is a heading")] &#13;
        public int testVariable; &#13;
</pre><p>The result is the following:</p><div><img src="img/image00373.jpeg" alt="Attributes"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">The <code class="literal">HideInInspector</code> attribute is formatted as <code class="literal">[HideInInspector]</code>. It hides the variable that follows it from the <strong>Inspector</strong>. Here it is in use, in the previous example:<pre class="programlisting">        [HideInInspector]&#13;
        public int testVariable;</pre><p>And this is the result:</p><div><img src="img/image00374.jpeg" alt="Attributes"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">The <code class="literal">Range</code> attribute is formatted as <code class="literal">[Range(minValue, maxValue)]</code>. It captures the possible values of the variable in the range of numbers from <code class="literal">minValue</code> to <code class="literal">maxValue</code>. Again, we use the previous example:<pre class="programlisting">        [Range(-10, 10)] &#13;
        public int testVariable; &#13;
</pre><p>This is the result we obtain:</p><div><img src="img/image00375.jpeg" alt="Attributes"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Finally, The <code class="literal">Tooltip</code> attribute is formatted as <code class="literal">[Tooltip("string")]</code>. It creates a tooltip in the <strong>Inspector</strong> when the cursor is hovering over that variable:<pre class="programlisting">        [Tooltip("This is a tooltip")] &#13;
        public int testVariable; &#13;
</pre><p>Here is the result (when the cursor hovers):</p><div><img src="img/image00376.jpeg" alt="Attributes"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec6"/>Functions</h3></div></div></div><p>Any script that derives from the <code class="literal">MonoBehaviour</code> class has two main functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Start()</code>: This function is called only once, when the game starts. It's useful to set all the variables and get the references we need within this function.</li><li class="listitem"><code class="literal">Update()</code>: This function is called every frame, and needs to compute things in real time, such as velocity or behaviors. However, since this is called so often, we need to pay attention to what we code inside, to avoid slowing down our game too often.</li></ul></div><p>There are other functions that can be implemented and that will be automatically called. In actual fact, there are more than 60!</p><p>We will use some of them later on, so we will introduce them here and see them in detail in later chapters:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">OnTriggerEnter2D()</code>: This is called when another object with a collider enters the trigger collider attached to the game object. We will see this better later on, when we deal with physics.</li><li class="listitem"><code class="literal">OnMouseDown()</code>: This is called when the player has pressed the mouse button while over the game object if it has a collider attached. Furthermore, it can be a <code class="literal">Coroutine</code> and works with <code class="literal">GUIElements</code> too.</li><li class="listitem"><code class="literal">OnEnable()</code>: This is called when the object becomes enabled and active.</li></ul></div><p>You can find out more about them at <a class="ulink" href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Comments</h2></div></div></div><p>As we mentioned in the previous chapter, game development is not an easy process, since it involves many stages. For this reason, it's really important to document everything that we do. This doesn't mean writing something that will be published, but just a couple of lines to remind yourself and your team what you have accomplished. In fact, human memory is great at remembering concepts, but not good for details! This is essential during the scripting stage. It is important to be able to read what the rest of your team or yourself have written a few days ago. When coding, it's easy to get lost among the many lines of code when you don't use comments!</p><p>Since Unity uses a C# compiler, it is possible to insert comments inside the code. Comments are lines that will be ignored (not compiled), and as the name suggests, they help to leave messages to those who will read the code.</p><p>There are two main ways to comment in C#. The first is to insert <code class="literal">//</code> at the beginning of a line. As a result, everything that comes after until the next line will be ignored. The second one is used when we have more than one line. It consists to surround the comment with an opening tag <code class="literal">/*</code> and the closing tag <code class="literal">*/</code>. As a result, everything within these two tags will be ignored. Here is an example:</p><pre class="programlisting">
<em>//This line is commented</em> &#13;
This other one is not. &#13;
<em>/*Here it is &#13;
again &#13;
commented*/</em>
</pre><div><h3 class="title"><a id="note18"/>Note</h3><p>Comments are also used to build automatic documentations and as markups for other things. However, this is out the scope of this book.</p></div><p>I strongly suggest that you always try to insert comments in your code, so it is easier to read later on. For your convenience, all the code that comes with this book is provided with comments, helping you to understand what is happening and where.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Execution order</h2></div></div></div><p>Another important concept about scripting in Unity is the <strong>Execution Order</strong>. It may be fundamental that some scripts or parts of code are executed before others. As a result, this will affect how the shared resources are modified and the efficiency as well.</p><p>The standard ordering is as follows:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>Editor</strong>: In particular, the <code class="literal">Reset()</code> function.</li><li class="listitem"><strong>Scene Load</strong>: Functions such as <code class="literal">Awake()</code>, <code class="literal">OnEnable()</code>, and <code class="literal">OnLevelWasLoaded()</code> are called.</li><li class="listitem"><strong>Before the first frame update</strong>: All the <code class="literal">Start()</code> functions in the scripts are called (if the object is active!).</li><li class="listitem"><strong>In between frames</strong>: the <code class="literal">OnApplicationPause()</code> function is performed.</li><li class="listitem"><strong>Update</strong>: All the different <code class="literal">Update()</code> functions are called.</li><li class="listitem"><strong>Rendering</strong>: Specific rendering functions are performed.</li><li class="listitem"><strong>Coroutines</strong>: They are executed until a yield statement is found</li><li class="listitem"><strong>When the object is destroyed</strong>: The <code class="literal">Destroy()</code> function is called.</li><li class="listitem"><strong>When quitting</strong>: Functions to be executed when disabling game objects or when quitting the game are called.</li></ol><div></div><p>Of course, this is just scratching the surface to give you an idea about the execution order. If you are interested in finding out more on this topic, you can find a detailed explanation of the execution order in the official documentation, at <a class="ulink" href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a>.</p><p>Unity offers also the possibility to change the execution order within your scripts when you have specific needs. This can be done by navigating on the toolbar to, <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Script Execution Order</strong>. As a result, this window will appear on the <strong>Inspector</strong>, where it is possible to change the order:</p><div><img src="img/image00377.jpeg" alt="Execution order"/></div><p style="clear:both; height: 1em;"> </p><p>For more information about this, you can visit the following link: <a class="ulink" href="https://docs.unity3d.com/Manual/class-ScriptExecution.html">https://docs.unity3d.com/Manual/class-ScriptExecution.html</a>. However, the execution order for scripts is for specific needs that we don't have, so we won't touch any of these settings. However, I hope that this section helped you to get a better understanding of the logic behind Unity. Saying that, I encourage you to re-read this section when you gain a better understanding of scripting in Unity.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Making sprinkles</h1></div></div></div><p>In the <em>Prefabs</em> section, we created the Prefab for our sprinkle projectile. In this section, we will see how to make sprinkles move into the 2D space. In particular, we will learn how to create and use scripts in Unity for 2D game elements.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>The projectile class</h2></div></div></div><p>Since there might be different projectiles in our game that can be thrown against the sweet-tooth pandas, and not only sprinkles, we need to define a general class. All the different kinds of projectile will follow some general rules:</p><div><ul class="itemizedlist"><li class="listitem">They move in a straight line</li><li class="listitem">They carry information about how much damage they will inflict on the enemies</li></ul></div><p>Whereas the first is identical for all the projectiles, the second depends on the specific kind of projectile that will be fired. So, we need to create a template. Once we attach this script to a game object, we can set some of its variables and tweak its behavior. In this specific case, we want to tweak how much damage is given and how fast.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec7"/>Scripting the projectile mother class</h3></div></div></div><p>So, to begin, let's create a new script and name it <code class="literal">ProjectileScript</code>. Next, we need to define four variables. The first is for the amount of damage, the second for its speed, and the third one, for its direction, since we need to know where the projectile is heading. The last variable stores its life duration expressed in seconds. As a consequence, it also sets, together with the speed variable, how far the projectile can reach. In fact, if the projectile misses the target, we don't want it going straight on forever, because this would consume computational resources and slow down our game. So after this duration, we need to destroy it. To do this, we can add the following four variables:</p><pre class="programlisting">public float damage;    <em> //How much damage will the enemy receive</em> &#13;
public float speed = 1f;       <em>//How fast the projectile moves</em> &#13;
public Vector3 direction; <em>//What direction the projectile is heading</em> &#13;
public float lifeDuration = 10f; <em>//How long the projectile lives before</em>
<em>  self-destructing</em>
</pre><p>The next thing to do is to set some of these parameters in the <code class="literal">Start()</code> function. Since the direction will be given by the entity that will throw the projectile, we don't have a guarantee that it has a unit norm. As consequence, we need to normalize the direction. Then, we need to rotate the graphic of our projectile, which in this case is the sprinkle, towards the right direction. In order to achieve this, we need to compute the angle using the <code class="literal">Atan2()</code> function. After we have transformed this in degrees, we use the <code class="literal">AngleAxis()</code> function in the <code class="literal">Quaternion</code> class to rotate our game object. Finally, we need to set a timer before the game object is destroyed. As a result, this will be our <code class="literal">Start()</code> function:</p><pre class="programlisting">void Start() { &#13;
<em>  //Normalize the direction</em> &#13;
  direction = direction.normalized; &#13;
 &#13;
<em>  //Fix the rotation</em> &#13;
  float angle = Mathf.Atan2(-direction.y, direction.x) * Mathf.Rad2Deg; &#13;
  transform.rotation = Quaternion.AngleAxis(angle, Vector3.forward); &#13;
 &#13;
<em>  //Set the timer for self-destruction</em> &#13;
  Destroy(gameObject, lifeDuration); &#13;
} &#13;
</pre><p>In the <code class="literal">Update()</code> function, we just need to move the sprinkle in that direction. If the sprinkle collides with something, such as a Panda, it's a case that we will discuss in <a class="link" title="Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike" href="part0056.xhtml#aid-1LCVG1">Chapter 5</a>, <em>No Longer Alone - Sweet-Toothed Pandas Strike</em>. So, we need to update its position according to its direction and speed, keeping it dependent on the time. So, we can write the following:</p><pre class="programlisting">
<em>// Update the position of the projectile according to time and speed</em> &#13;
void Update() { &#13;
  transform.position += direction * Time.deltaTime * speed; &#13;
} &#13;
</pre><p>At the end, save the script. There is still a lot of work to do on this script. For instance, the direction should be only on the <em>x</em> and <em>y</em>, and not on the <em>z</em>, since it is used in the Z-Buffering method. However, for now it is fine, and we will look at all these issues later on in the book.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Tons of sprinkles through Prefabs</h2></div></div></div><p>Now that we have a general script that achieves the behavior of a projectile, we need to actually make the Prefab of our sprinkles with such behavior.</p><p>We have already created a Prefab for our sprinkle projectile, but we need to change it. So, go into the <code class="literal">Prefabs</code> folder in the <strong>Project</strong> panel, and select our <code class="literal">Pink_Sprinkle_Projectile_Prefab</code>. In the <strong>Inspector</strong>, we need to add the script that we have just created. So, navigate to <strong>Add Component</strong> | <strong>Script</strong> | <strong>ProjectileScript</strong>. As a result, you should see the following:</p><div><img src="img/image00378.jpeg" alt="Tons of sprinkles through Prefabs"/></div><p style="clear:both; height: 1em;"> </p><p>We need to tweak the values, at least for testing purposes, so that we can see our sprinkle moving. We can assign a direction such as (1, 1, 0) and any value to the <strong>Damage</strong> variable. At the end, we should have something like the following:</p><div><img src="img/image00379.jpeg" alt="Tons of sprinkles through Prefabs"/></div><p style="clear:both; height: 1em;"> </p><p>If we press the play button, we can see our sprinkle leading in the direction we specified, and be destroyed after <code class="literal">10</code> seconds.</p><p>Then, we need to assign the <strong>Z</strong> value on the Prefab. Since it is a projectile, we can look at the table with all the <strong>Z </strong>values for our objects we made earlier. Therefore, we need to assign <code class="literal">-2</code> as the value. We also need to assign the tag to our projectile. We will use this tag later on, but it's better to assign it now to the Prefab.</p><p>To assign a tag, on top of the <strong>Inspector</strong>, just below the game object name, there is the <strong>Tag</strong> field, as highlighted in the following screenshot:</p><div><img src="img/image00380.jpeg" alt="Tons of sprinkles through Prefabs"/></div><p style="clear:both; height: 1em;"> </p><p>Once clicked, a drop-down menu appears, where it is possible to choose from the different tags, including the two we defined previously:</p><div><img src="img/image00381.jpeg" alt="Tons of sprinkles through Prefabs"/></div><p style="clear:both; height: 1em;"> </p><p>We can assign the <strong>Projectile</strong> tag to our Prefab, and in the end, it should look like this:</p><div><img src="img/image00382.jpeg" alt="Tons of sprinkles through Prefabs"/></div><p style="clear:both; height: 1em;"> </p><p>And this is all we need to do to fabricate our projectiles. In fact, we can now use this Prefab to spawn the sprinkles when we need to.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Baking cupcakes towers</h1></div></div></div><p>In this section, we will see how to create our towers. This is not an easy task, but by doing this we will acquire a lot of scripting skills.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>What a cupcake tower does</h2></div></div></div><p>First of all, it's useful to write down what we want to achieve and define what exactly a cupcake tower is supposed to do.</p><p>The best way is to write down a list, to have clear idea of what we are trying to achieve:</p><div><ul class="itemizedlist"><li class="listitem">A cupcake tower is able to detect pandas within a certain range.</li><li class="listitem">A cupcake tower shoots a different kind of projectile according to its typology against the pandas within a certain range. Furthermore, within this range, it uses a policy to decide which panda to shoot.</li><li class="listitem">There is a reload time before the cupcake tower is able to shoot again.</li><li class="listitem">The cupcake tower can be upgraded (to a bigger cupcake!), increasing its stats and therefore changing its appearance.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Scripting the cupcake tower</h2></div></div></div><p>As we have seen in the previous section, there are many things to implement. Let's start by creating a new script and naming it <code class="literal">CupcakeTowerScript</code>. As we already mentioned for the projectile script, in this chapter, we implement the main logic, but of course there is always space to improve, as we will see later in the book.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec8"/>Shooting to the pandas</h3></div></div></div><p>Even if we don't have enemies yet, we can already start to program the behavior of the cupcake towers to shoot to the enemies. In this section, we will learn a bit about using physics to detect objects within a range. However, we will see colliders in more detail in <a class="link" title="Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike" href="part0056.xhtml#aid-1LCVG1">Chapter 5</a>, <em>No Longer Alone - Sweet-Toothed Pandas Strike</em>.</p><p>Let's start by defining four variables. The first three are public, so we can set them in the Inspector. The last one is private, since we only need it to check how much time has elapsed. In particular, the first three variables store the parameters of our tower. There are the projectile Prefab, its range, and its reload time. We can write the following:</p><pre class="programlisting">public float rangeRadius;  <em>//Maximum distance that the Cupcake Tower&#13;
  can shoot</em> &#13;
public float reloadTime;   <em>//Time before the Cupcake Tower is able to&#13;
  shoot again</em> &#13;
public GameObject projectilePrefab; <em>//Projectile type that is fired&#13;
  from the Cupcake Tower</em> &#13;
private float elapsedTime; <em>//Time elapsed from the last time the&#13;
  Cupcake Tower has shot</em>
</pre><p>Now, in the <code class="literal">Update()</code> function we need to check if enough time has elapsed in order to shoot. This can be easily done by using an if statement. In any case, at the end, the time elapsed should be increased:</p><pre class="programlisting">void Update () { &#13;
  if (elapsedTime &gt;= reloadTime) { &#13;
    <em>//Rest of the code</em> &#13;
  } &#13;
  elapsedTime += Time.deltaTime; &#13;
} &#13;
</pre><p>Within the <code class="literal">if</code> statement, we need to reset the elapsed time, so as to be able to shoot the next time. Then, we need to check whether there are some game objects within its range or not:</p><pre class="programlisting">if (elapsedTime &gt;= reloadTime) { &#13;
 <em> //Reset elapsed Time</em> &#13;
  elapsedTime = 0; &#13;
<em>  //Find all the gameObjects with a collider within the range of the&#13;
    Cupcake Tower</em> &#13;
  Collider2D[] hitColliders =&#13;
    Physics2D.OverlapCircleAll(transform.position, rangeRadius); &#13;
 <em> //Check if there is at least one gameObject found</em>&#13;
  if (hitColliders.Length != 0) { &#13;
   <em> //Rest of the code</em> &#13;
  } &#13;
} &#13;
</pre><p>If there are enemies within range, we need to decide a policy about which enemy the tower should be targeted. There are different ways to do this and different strategies that the tower itself could choose. Here, we are going to implement one where the nearest enemy to the tower will be the one targeted. Different policies and strategies will be discussed in the last chapter of this book.</p><p>To implement this policy, we need to loop all all the game objects that we have found in range, check if they actually are enemies, and using distances, pick the nearest one. To achieve this, write the following code inside the previous if statement:</p><pre class="programlisting"> if (hitColliders.Length != 0) { &#13;
  <em> //Loop over all the gameObjects to identify the closest to the&#13;
     Cupcake Tower </em>&#13;
   float min = int.MaxValue; &#13;
   int index = -1; &#13;
 &#13;
   for (int i = 0; i &lt; hitColliders.Length; i++) { &#13;
     if (hitColliders[i].tag == "Enemy") { &#13;
       float distance =&#13;
         Vector2.Distance(hitColliders[i].transform.position,&#13;
           transform.position); &#13;
       if (distance &lt; min) { &#13;
         index = i; &#13;
         min = distance; &#13;
       } &#13;
     } &#13;
   } &#13;
   if (index == -1) &#13;
   return; &#13;
   <em>//Rest of the code</em> &#13;
 } &#13;
</pre><p>Once we find the target, we need to get the direction that the tower will throw the projectile. So, let's write this:</p><pre class="programlisting">
<em>//Get the direction of the target </em> &#13;
Transform target = hitColliders[index].transform; &#13;
Vector2 direction = (target.position - transform.position).normalized; &#13;
</pre><p>Finally, we need to instantiate a new projectile, and assign to it the direction of the enemy, as follows:</p><pre class="programlisting">
<em>//Create the Projectile</em> &#13;
GameObject projectile = GameObject.Instantiate(projectilePrefab,&#13;
  transform.position, Quaternion.identity) as GameObject; &#13;
projectile.GetComponent&lt;ProjectileScript&gt;().direction = direction; &#13;
</pre><p>Instantiating GameObjects is usually slow, and it should be avoided. However, for learning purposes, we can live with that. In the last chapter, we will see some optimization technique to get rid of this instantiation. And that is it for shooting the enemies.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec9"/>Upgrading the cupcake tower, making it even tastier</h3></div></div></div><p>In order to create a function to upgrade the tower, we first need to define a variable to store the actual level of the tower:</p><pre class="programlisting">public int upgradeLevel; <em> //Level of the Cupcake Tower</em>
</pre><p>Then, we need an array with all the Sprites for the different upgrades, like this:</p><pre class="programlisting">public Sprite[] upgradeSprites; <em>//Different sprites for the different&#13;
  levels of the Cupcake Tower</em>
</pre><p>A third variable is required to check when the cupcake tower is upgradable, so we can add:</p><pre class="programlisting">
<em>//Boolean to check if the tower is upgradable</em> &#13;
public bool isUpgradable = true; &#13;
</pre><p>Finally, we can create our upgrade function. The first thing to do is to check if the tower is actually upgradable and then increase its level. Then, we can check (based on how many different graphics we have), if the tower has reached its maximum level, and in that case is preventing the player from upgrading it anymore, by assigning the false value to the <code class="literal">isUpgradable</code> variable. After that, we need to upgrade the graphics, and increase the stats. Feel free to tweak these values as you prefer. However, don't forget to assign the new Sprite. In the end, you should have something like the following:</p><pre class="programlisting">public void Upgrade() { &#13;
 <em> //Check if the tower is upgradable</em> &#13;
  if (!isUpgradable) { &#13;
    return; &#13;
  } &#13;
 &#13;
  <em>//Increase the level of the tower</em> &#13;
  upgradeLevel++; &#13;
 &#13;
 <em> //Check if the tower has reached its last level</em> &#13;
  if(upgradeLevel &lt; upgradeSprites.Length) { &#13;
    isUpgradable = false; &#13;
  } &#13;
 &#13;
 <em> //Increase the stats of the tower</em> &#13;
  rangeRadius += 1f; &#13;
  reloadTime -= 0.5f; &#13;
 &#13;
 <em> //Change graphics of the tower</em> &#13;
  GetComponent&lt;SpriteRenderer&gt;().sprite = upgradeSprites[upgradeLevel]; &#13;
} &#13;
</pre><p>Save the script, and for now, we are done with it. We will need to modify this function later in the book, but for now, let's create a Prefab for our cupcake.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>A pre-baked cupcake tower through Prefabs</h2></div></div></div><p>As we have done with the sprinkles, we need to do something similar for the cupcake tower. In the <code class="literal">Prefabs</code> folder in the <strong>Project</strong> panel, create a new Prefab by right-clicking and then navigating to <strong>Create</strong> | <strong>Prefab</strong>. Name it <code class="literal">SprinklesCupcakeTower</code>.</p><p>Now, drag and drop <code class="literal">Sprinkles_Cupcake_Tower_0</code> from the <code class="literal">Graphics/towers</code> folder (within the <code class="literal">cupcake_tower_sheet-01</code> file) in the <strong>Scene</strong> View. Attach <code class="literal">CupcakeTowerScript</code> to the object by navigating to <strong>Add Component</strong> | <strong>Script</strong> | <code class="literal">CupcakeTowerScript</code>. The <strong>Inspector</strong> should look like the following:</p><div><img src="img/image00383.jpeg" alt="A pre-baked cupcake tower through Prefabs"/></div><p style="clear:both; height: 1em;"> </p><p>We need to assign <code class="literal">Pink_Sprinkle_Projectile_Prefab</code> to the <strong>Projectile Prefab</strong> variable. Then, we need to assign the different Sprites for the upgrades. In particular, we can use <code class="literal">Sprinkles_Cupcake_Tower_*</code> (replacing the <code class="literal">*</code> with the level of the cupcake tower) from the same sheet as earlier. Don't worry too much about the other parameters of the tower, such as the range radius or the reload time, since we will see how to balance the game later on. At the end, this is what we should see:</p><div><img src="img/image00384.jpeg" alt="A pre-baked cupcake tower through Prefabs"/></div><p style="clear:both; height: 1em;"> </p><p>The last step is to drag this game object inside the Prefab. As a result, our cupcake tower is ready.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec31"/>More about coding in Unity</h1></div></div></div><p>Before we continue, there are few more things to learn.</p><p>Later in the book, we will use both static variables and inheritance. These are topics related with C# more than with Unity, but they are important if you want to become a good game developer. Next, you can find a very brief explanation, but I recommend that you learn them properly from a C# book.</p><p>Finally, there is probability, which is a topic of math, as we discussed previously, and it is essential in game development. However, once you know the basics of probability, you should be able to generate random numbers in Unity.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Static variables</h2></div></div></div><p>Some classes (or components, in the case of Unity), contain variables, which eventually can be set in the Inspector or changed at runtime. However, the whole class can share a variable among all its instances. Such variables are referred to as static variables and are declared with the <code class="literal">static</code> keyword. A common use is to share a reference to another component, which all the instances of the class should refer to. We will see this better later in the book, when we will use static variables</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Inheritance</h2></div></div></div><p>If different classes share many features in common, we could give them an inheritance structure. This means, to have a parent class that holds the general and common features between these classes, and then they are implemented as children of the parent. A common example to clarify this is imagining the classes Fruit, Apple, and Banana. Fruit is the parent class, which holds all the properties of being a fruit (such as that it is edible), and the children share the same feature of the parent (since both an Apple and a Banana are fruits, and therefore edible). Then, they can implement the specific features of that fruit. For instance, the Apple is red, whereas the Banana is yellow.</p><p>Sometimes, the parent class can also have functions (such as <code class="literal">Eat()</code>) which all the children can give their own implementation. This leads to the difference between the abstract and virtual methods.</p><p>Abstract methods are so abstract that the parent class cannot give an implementation of it, but its children have to. Virtual methods, instead, can be implemented in the parent class, since it offers general functionality, but children can override it to give a better implementation of it.</p><p>We will look at inheritance in more detail, in <a class="link" title="Chapter 7. Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay Programming" href="part0088.xhtml#aid-2JTHG1">Chapter 7</a>, <em>Trading Cupcakes and the Ultimate Battle for the Cake - Gameplay Programming</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Random numbers in Unity</h2></div></div></div><p>Generating random numbers in Unity is easy since Unity provides the class <code class="literal">Random</code>, which allows us to generate random numbers. The most used function of this class is <code class="literal">Range()</code>, which generates a random number between a min and a max value. Here is an example:</p><pre class="programlisting">
<em>//Generates a random number between 2 and 30</em> &#13;
Random.Range(2, 30); &#13;
</pre><p>For more information about the <code class="literal">Random</code> class, visit the official documentation here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Random.html">https://docs.unity3d.com/ScriptReference/Random.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Homework</h1></div></div></div><p>In this chapter, we have seen how to use Prefabs to quickly replicate and clone GameObjects. So, before you continue with the next chapter, let's get good at using Prefabs.</p><p>The following two exercises are needed to have the game completed at the end:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>Arming the Cupcakes Towers (Part I)</strong>:Inside <code class="literal">projectiles_sheet_01</code> in the <code class="literal">Graphics/projectiles</code> folder, there are nine different projectiles; however, we used only one, <code class="literal">Pink_Sprinkle</code>. Create the other eight Prefabs, with meaningful names. Don't forget to attach the projectile script to all of them. Do not worry too much about the values assigned inside the script, such as the damage, since we will see the balance of the game later on in the book. However, do not forget to assign the right <strong>Z</strong> value and the proper tag.</li><li class="listitem"><strong>Arming the Cupcakes Towers (Part II)</strong>: Inside <code class="literal">cupcake_tower_sheet-01</code> in the <code class="literal">Graphics/towers</code> folder, there are three different towers with their respective upgrading levels; however, we only used the sprinkle cupcake tower. Create the other two Prefabs for the chocolate and lemon cupcake towers. Don't forget to attach the cupcake tower script to both of them and assign the respective projectiles and upgrade levels graphic. Again, don't worry much about the values, such as the range radius, because we will see the balance of the game later in the book. However, don't forget to assign the right <strong>Z</strong> value.<p>The following exercises will help you to improve your skills by familiarizing yourself with best practices:</p></li><li class="listitem"><strong>Formatting scripts for designers (Part I)</strong>: In our scripts, we used many variables. Comments next to them help us to understand their function; however, these comments are hidden to designers. Therefore, it's good practice to add tooltips to show up in the <strong>Inspector</strong>. If you want, you can use the text of the comments as parameter for the tooltips.</li><li class="listitem"><strong>Formatting scripts for designers (Part II)</strong>: Even if our scripts in the <strong>Inspector</strong> look good, they can be improved if we add some headings before groups of variables. So, assign meaningful headings and reorder the variables to fit in these headings.</li><li class="listitem"><strong>Formatting scripts for designers (Part III)</strong>: The <code class="literal">direction</code> variable inside the projectile script must be set to public since it is changed from the cupcake tower script. However, it should be visible in the <strong>Inspector</strong>. Use attributes to hide it from the <strong>Inspector</strong>.</li><li class="listitem"><strong>Formatting scripts for designers (Part IV)</strong>: Some variables in our scripts are better to show with a slider rather than a numeric input field, especially those that cannot assume negative numbers. For these, transform their appearance to a slider and don't allow negative values for them.</li><li class="listitem"><strong>Best Practices (Part I)</strong>: Inside the cupcake tower script there is the <code class="literal">Upgrade Level</code> variable, which is private. However, it might be useful to create a get function to retrieve its value. By following the guidelines in the link shown in the <em>Variables</em> section of this chapter, implement the respective get function.</li><li class="listitem"><strong>Best Practices (Part II)</strong>: Again inside the cupcake tower script, inside the <code class="literal">Upgrade()</code> function, the <code class="literal">GetComponent()</code> function is called to get the <code class="literal">SpriteRenderer</code>. Best practice suggests to call this function only once and store the reference inside a variable. Create a new variable to store the <code class="literal">SpriteRenderer</code> component attached to the cupcake tower game object. Assign its value inside the <code class="literal">Start()</code> function by using the <code class="literal">GetComponent()</code> function. Then, use this variable in the <code class="literal">Upgrade()</code> function to update the graphic of the cupcake tower.</li><li class="listitem"><strong>Best Practices (Part III)</strong>: We didn't define a tag for the cupcake towers because we don't need to distinguish between them. However, it's good practice to assign a tag to them. This is because it might be needed later on when we would like to extend our game (for example, enemies that try to avoid cupcake towers within their limits). Therefore, create a new cupcake tower tag and assign it to all the cupcake tower Prefabs (there should be three, also counting the one created in the first exercise of this section).</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we have seen how to use Prefabs to quickly replicate and clone game objects. We also learned how to place 2D objects, order them with the Z-Buffering method, as well as how to set up tags and layers in Unity. Then, we created a couple of scripts, and learned along the way how to code complex behaviors with just a few lines. In fact, we explored how Unity handles scripts, their main functions and attributes, and the general execution order.</p><p>However, we will improve the scripts written in this chapter later on in the book, to improve the gameplay. In fact, the goal of this chapter was to get used to scripts, and to write down the main logic. Therefore, improving and tweaking is left for later.</p><p>In the next chapter, we will dive into the UI world, and integrate it into our game.</p></div></body></html>