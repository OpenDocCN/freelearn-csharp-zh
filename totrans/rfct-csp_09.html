<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-190"><a id="_idTextAnchor189"/>9</h1>
<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Advanced Unit Testing</h1>
<p>As we’ve seen, testing is incredible and can give you the freedom to effectively refactor your code in relative safety. Sometimes, code is written in a way that makes testing difficult and you need a few more tools. In this chapter, we’ll explore a handful of popular .NET libraries that can improve the readability of your tests and give you more options for testing code – including those tricky classes with complex data or dependencies.</p>
<p>We’ll cover the following topics in this chapter:</p>
<ul>
<li>Creating readable tests with Shouldly</li>
<li>Generating test data with Bogus</li>
<li>Mocking dependencies with Moq and NSubstitute</li>
<li>Pinning tests with Snapper</li>
<li>Experimenting with Scientist .NET</li>
</ul>
<h1 id="_idParaDest-192"><a id="_idTextAnchor191"/>Technical requirements</h1>
<p>The code for this chapter is available from GitHub at https://github.com/PacktPublishing/Refactoring-with-CSharp in the <code>Chapter09</code> folder.</p>
<p>Libraries change with new releases and some of these changes may cause issues with code in this chapter. Because of this, here are the exact names and versions of the libraries that are used in this chapter at the time of writing:</p>
<ul>
<li><strong class="bold">Bogus 34.0.2</strong></li>
<li><strong class="bold">FluentAssertions 6.11.0</strong></li>
<li><strong class="bold">Moq 4.20.2</strong></li>
<li><strong class="bold">NSubstitute 5.0.0</strong></li>
<li><strong class="bold">Scientist 2.0.0</strong></li>
<li><strong class="bold">Shouldly 4.2.1</strong></li>
<li><strong class="bold">Snapper 2.4.0</strong></li>
</ul>
<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/>Creating readable tests with Shouldly</h1>
<p>In <a href="B21324_06.xhtml#_idTextAnchor133"><em class="italic">Chapter 6</em></a>, we saw how the <code>Assert</code> class is used to verify the behavior of existing classes through code<a id="_idIndexMarker519"/> such as the following:</p>
<pre class="source-code">
Assert.Equal(35, passengerCount);</pre>
<p>This code <a id="_idIndexMarker520"/>verifies that <code>passengerCount</code> is equal to <code>35</code> and fails the test if it is a different number.</p>
<p>Unfortunately, this code has two problems:</p>
<ul>
<li>Assert methods take in the expected value first and the actual value second. This is different than how most people think about things and can lead to confusing test failure messages, as we saw in <a href="B21324_06.xhtml#_idTextAnchor133"><em class="italic">Chapter 6</em></a>.</li>
<li>The code doesn’t read incredibly well in English, which can slow you down as you are reading tests.</li>
</ul>
<p>Several open-source libraries address this issue by providing an alternative syntax for writing assertions in unit tests through sets of extension methods they introduce.</p>
<p>The most popular of these libraries are FluentAssertions and Shouldly. While FluentAssertions is by far the more popular library, I find Shouldly to read more naturally, so we’ll start with that.</p>
<p>Let’s look at installing Shouldly and getting started with its syntax before looking at a similar example with FluentAssertions.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>Installing the Shouldly NuGet package</h2>
<p>Shouldly is not<a id="_idIndexMarker521"/> a library that is included by default in any project template built into Visual Studio. Because of this, we need to add it to our project.</p>
<p>In Visual Studio, we use a <strong class="bold">package manager</strong> called <strong class="bold">NuGet Package Manager</strong> to install external dependencies from<a id="_idIndexMarker522"/> package sources such as the one at <a href="http://nuget.org">nuget.org</a>.</p>
<p>If you’ve programmed in JavaScript, this concept is very similar to JavaScript package managers such as Yarn or NPM. While other package managers download the code and have you compile it, NuGet downloads <em class="italic">compiled</em> versions of external code and allows your code to reference things<a id="_idIndexMarker523"/> defined in those projects without slowing your build process.</p>
<p>To install a package, right-click on the <code>Chapter9Tests</code> project in <strong class="bold">Solution Explorer</strong> and choose <strong class="bold">Manage </strong><strong class="bold">NuGet Packages</strong>.</p>
<p>Next, click on the <code>Shouldly</code> in the search bar. Your search results should look something like those in <em class="italic">Figure 9</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 9.1 – NuGet Package Manager showing results for Shouldly" src="img/B21324_09_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – NuGet Package Manager showing results for Shouldly</p>
<p>You should see an entry named Shouldly by Jake Ginnivan et al. in the list on the left. Select it by clicking on it. The details on the right will then list information about this package, including its license terms and dependencies.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Always check the author and the exact name of the package you are looking for as many have similar names.</p>
<p>Using the <strong class="bold">Version</strong> dropdown in the details area on the right, you can choose the specific version of the library <a id="_idIndexMarker524"/>to install. Usually, it’s fine to leave this as the latest stable version, but occasionally, you may need to select a prior version for compatibility purposes.</p>
<p>When you click <strong class="bold">Install</strong>, Shouldly and anything it depends on will automatically be downloaded and installed into your project. When installing packages, a window may open showing you various license terms or dependencies, such as those shown in <em class="italic">Figure 9</em><em class="italic">.2</em>. Read these carefully, especially if you are using a library in your workplace:</p>
<div><div><img alt="Figure 9.2 – Dependencies needed to install Shouldly" src="img/B21324_09_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Dependencies needed to install Shouldly</p>
<p>Now that we have Shouldly installed, let’s learn how to work with it.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Writing readable assertions with Shouldly</h2>
<p>In <code>PassengerTests.cs</code>, there’s an existing <code>PassengerFullNameShouldBeAccurate</code> test that instantiates a <code>Passenger</code> object, grabs the<a id="_idIndexMarker525"/> value out of the object’s <code>FullName</code> field, and <a id="_idIndexMarker526"/>makes sure the resulting name matches the expected value, as shown in the following code:</p>
<pre class="source-code">
[Fact]
public void PassengerFullNameShouldBeAccurate() {
    // Arrange
    Passenger passenger = new() {
        FirstName = "Dot",
        LastName = "Nette",
    };
    // Act
    string name = passenger.FullName;
    // Assert
    <strong class="bold">Assert.Equal("Dot Nette", name);</strong>
}</pre>
<p>Using Shouldly, we can<a id="_idIndexMarker527"/> make this assertion a lot more readable.</p>
<p>First, let’s<a id="_idIndexMarker528"/> add a <code>Usings.cs</code> file by adding a <code>using</code> for Shouldly at the end of<a id="_idIndexMarker529"/> that file:</p>
<pre class="source-code">
global using Xunit;
<strong class="bold">global using Shouldly;</strong></pre>
<p>This <code>global using</code> directive allows you to work with things in the Shouldly namespace anywhere in the <code>Chapter9Tests</code> project. Put another way, it is the equivalent of if every file in the project had a <code>using Shouldly;</code> statement at the top of the file.</p>
<p>Now that we have Shouldly installed and its namespace imported, we can rewrite the assertion from earlier by using one of the many extension methods provided by Shouldly, as shown here:</p>
<pre class="source-code">
[Fact]
public void PassengerFullNameShouldBeAccurate() {
    // Arrange
    Passenger passenger = new() {
        FirstName = "Dot",
        LastName = "Nette",
    };
    // Act
    string name = passenger.FullName;
    // Assert
    <strong class="bold">name.ShouldBe("Dot Nette");</strong>
}</pre>
<p>Here, Shouldly adds a <code>ShouldBe</code> extension method to the <code>string</code>, allowing us to call this method in a very readable <a id="_idIndexMarker530"/>way. This code is functionally equivalent to <code>Assert.Equal</code>, but it is <a id="_idIndexMarker531"/>significantly more readable. Additionally, you are far less likely to confuse which parameter is the expected value versus the actual value under this way of working with things.</p>
<p>Shouldly has a wide variety of extension methods, including <code>ShouldBe</code>, <code>ShouldNotBe</code>, <code>ShouldBeGreaterThan</code>/<code>ShouldBeLessThan</code>, <code>ShouldContain</code>, <code>ShouldNotBeNull</code>/<code>ShouldBeNull</code>, <code>ShouldStartWith</code>/<code>ShouldEndWith</code>, and more.</p>
<p>To illustrate this, let’s look at a more complex test written without Shouldly:</p>
<pre class="source-code">
[Fact]
public void ScheduleFlightShouldAddFlight() {
    // Arrange
    FlightScheduler scheduler = new();
    PassengerFlightInfo flight = _flightFaker.Generate();
    // Act
    scheduler.ScheduleFlight(flight);
    // Assert
    var result = scheduler.GetAllFlights();
<strong class="bold">    Assert.NotNull(result);</strong>
<strong class="bold">    Assert.Equal(1, result.Count());</strong>
<strong class="bold">    Assert.Contains(flight, result);</strong>
}</pre>
<p>This code uses <code>FlightScheduler</code> to schedule a flight using the Bogus library, which we’ll discuss later in this chapter. Once a flight has been scheduled, the code gets all the flights and asserts that the <a id="_idIndexMarker532"/>resulting collection is not null, has only one item, and the flight we scheduled<a id="_idIndexMarker533"/> is in that collection.</p>
<p>This code isn’t too bad, but I still prefer the Shouldly version:</p>
<pre class="source-code">
[Fact]
public void ScheduleFlightShouldAddFlight() {
    // Arrange
    FlightScheduler scheduler = new();
    PassengerFlightInfo flight = _flightFaker.Generate();
    // Act
    scheduler.ScheduleFlight(flight);
    // Assert
    var result = scheduler.GetAllFlights();
<strong class="bold">    result.ShouldNotBeNull();</strong>
<strong class="bold">    result.Count().ShouldBe(1);</strong>
<strong class="bold">    result.ShouldContain(flight);</strong>
}</pre>
<p>In general, I find the Shouldly library to have more consistent parameter ordering and result in more readable tests. Because of this, I find myself more productive and use Shouldly wherever I can.</p>
<p class="callout-heading">Practice exercise</p>
<p class="callout">As an exercise, I’d encourage you to take the starting code for this chapter and convert the various tests so that they use Shouldly instead of standard assertions. Feel free to experiment with other assertions as you go. This chapter’s final code uses Shouldly if you want to check your answers.</p>
<p>Before we see <a id="_idIndexMarker534"/>what else<a id="_idIndexMarker535"/> Shouldly can do, let’s look at FluentAssertions, a popular library fulfilling a similar role as Shouldly.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>Writing readable assertions with FluentAssertions</h2>
<p>FluentAssertions does the<a id="_idIndexMarker536"/> same thing that Shouldly does, but<a id="_idIndexMarker537"/> the approach of its syntax is less oriented on calling single methods like Shouldly’s <code>ShouldContain</code>. Instead, FluentAssertions prefers chaining together several method calls to produce a similar result.</p>
<p>Let’s look at a test of the baggage pricing system as an illustration:</p>
<pre class="source-code">
[Fact]
public void CarryOnBaggageIsPricedCorrectly() {
    // Arrange
    BaggageCalculator calculator = new();
    int carryOnBags = 2;
    int checkedBags = 0;
    int passengers = 1;
    bool isHoliday = false;
    // Act
    decimal result = calculator.CalculatePrice(checkedBags,
        carryOnBags, passengers, isHoliday);
    // Assert
    <strong class="bold">result.Should().Be(60m);</strong>
}</pre>
<p>This code creates <code>BaggageCalculator</code> and then sends a series of factors to that calculator’s <code>CalculatePrice</code> method before performing its assertions via the <code>Should().Be(60m)</code> syntax.</p>
<p>Before we explore this in more depth, I should point out that, like Shouldly, FluentAssertions does not <a id="_idIndexMarker538"/>come pre-installed. You’ll need to install FluentAssertions with NuGet Package<a id="_idIndexMarker539"/> Manager, the same way you did earlier for Shouldly. You’ll also need to add a <code>using FluentAssertions;</code> statement to your code file to see the FluentAssertions extension methods.</p>
<p>Now that we’ve established how to get started with FluentAssertions, let’s take a closer look at that <code>result.Should().Be(60m)</code> syntax.</p>
<p>Most actions in FluentAssertions flow out of the <code>Should</code> methods. Notice that there are multiple <code>Should</code> methods in FluentAssertions, with each one related to a specific type of data you might work with.</p>
<p>These <code>Should</code> methods return a strongly-typed object such as <code>NumericAssertions&lt;decimal&gt;</code>
in the case of the calculator assertions. These assertion objects contain various constraint methods, allowing you to do targeted assertions such as <code>Be</code>, <code>NotBe</code>, <code>BeLessThan</code>, <code>BePositive</code>, <code>BeOneOf</code>, and others.</p>
<p>There are a few advantages to the FluentAssertions approach:</p>
<ul>
<li>It’s easier to find assertion methods since they all go through <code>Should()</code></li>
<li>The constraint methods allow you to combine assertions such as <code>result.Should().BePositive().And.BeInRange(50, 70)</code></li>
</ul>
<p>Unfortunately, FluentAssertions has a slightly higher learning curve and is a little more verbose than Shouldly, which might result in slightly less readable tests.</p>
<p>Ultimately, it’s up to you and your team as to what style you prefer, but both Shouldly and FluentAssertions can significantly improve the readability of your tests and your enjoyment of the test writing experience.</p>
<p>Before we introduce our next new library, let’s talk about one more thing Shouldly can do that might be helpful.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Testing performance with Shouldly</h2>
<p>One of the reasons people find themselves refactoring code is to look for ways of improving the <a id="_idIndexMarker540"/>performance of code that is known to be slow.</p>
<p>Imagine you are following <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) and are investigating code that takes an unacceptably long time to<a id="_idIndexMarker541"/> iterate through a list of items.</p>
<p>The first step in TDD is to write a failing test, so you now need to write a test that fails if the performance of a method is too slow.</p>
<p>We’ll talk about reasons why you might not want to write a test around performance in a bit, but let’s explore how you would go about testing performance first.</p>
<p>In order to fail tests involving code that performs too slowly, you’d need to be able to measure how long that code took to run. To do that, you could create a <code>Stopwatch</code> object, start it, stop it, and then verify the duration of that watch, as shown here:</p>
<pre class="source-code">
[Fact]
public void ScheduleFlightShouldNotBeSlow() {
    // Arrange
    FlightScheduler scheduler = new();
    PassengerFlightInfo flight = _flightFaker.Generate();
    int maxTime = 100;
<strong class="bold">    Stopwatch stopwatch = new();</strong>
    // Act
<strong class="bold">    stopwatch.Start();</strong>
    scheduler.ScheduleFlight(flight);
<strong class="bold">    stopwatch.Stop();</strong>
<strong class="bold">    long milliSeconds = stopwatch.ElapsedMilliseconds;</strong>
    // Assert
<strong class="bold">    milliSeconds.ShouldBeLessThanOrEqualTo(maxTime);</strong>
}</pre>
<p>This code will fail if it takes more than 100 milliseconds (0.1 seconds) to run <code>ScheduleFlight</code>, but this approach has a couple of disadvantages:</p>
<ul>
<li>There’s a lot <a id="_idIndexMarker542"/>of setup code required for this approach. In this case, over half of the test method is devoted to <code>Stopwatch</code>.</li>
<li>The test waits for the method to complete before the test is failed. If it takes 10 seconds to complete the method, the test waits the full time. This is inefficient because once the 100-millisecond threshold is crossed, the test will never pass.</li>
</ul>
<p>Shouldly gives us a more compact <code>Should.CompleteIn</code> method that solves both problems:</p>
<pre class="source-code">
[Fact]
public void ScheduleFlightShouldNotBeSlow() {
  // Arrange
  FlightScheduler scheduler = new();
  PassengerFlightInfo flight = _flightFaker.Generate();
  TimeSpan maxTime = TimeSpan.FromMilliseconds(100);
  // Act
  <strong class="bold">Action testAction = () =&gt; scheduler.ScheduleFlight(flight);</strong>
  // Assert
  <strong class="bold">Should.CompleteIn(testAction, maxTime);</strong>
}</pre>
<p>This code creates an action to schedule the flight that Shouldly will invoke as part of the test. This action isn’t invoked until it is passed into the <code>Should.CompleteIn</code> method, which also requires a maximum amount of time to allow the method to run.</p>
<p>When Shouldly runs your action, it tracks the elapsed time internally and will cancel your action and fail the test once that threshold is reached. This results in more compact test code that won’t take longer than the maximum allowable amount of time.</p>
<p>So, now that we know how to write simple performance tests using Shouldly or plain old .NET with <code>Stopwatch</code>, let’s talk about why you might not want to do this.</p>
<p>Good tests should be fast and result in a repeatable result. Tests will be run by a variety of machines in a variety<a id="_idIndexMarker543"/> of different circumstances, such as when the processor has relatively little work to do or when the processor is completely overloaded. Tests may also be run in isolation or parallel, alongside, other tests. Additionally, with .NET, it is normal to see variations in performance from run to run.</p>
<p>All these things mean that performance testing is going to be more chaotic than you like and the maximum allowable duration is something you should consider carefully. If your tests are run in a <strong class="bold">continuous integration/continuous delivery</strong> (<strong class="bold">CI/CD</strong>) pipeline (which they should be, as we’ll talk <a id="_idIndexMarker544"/>about in <em class="italic">Part 4</em> of this book), it’s likely that the build machine’s CPU and memory characteristics look nothing like a developer workstation. To combat this, you may need to pick a significantly higher number than you normally would to avoid random failures due to a slow test environment. On the other hand, if you make your timeout too long, you won’t detect legitimate performance issues.</p>
<p>My general stance is that performance testing is something that should rarely ever be codified into unit tests due to the chaotic nature of performance metrics and the wide variety of machines that<a id="_idIndexMarker545"/> might run tests. Instead, I tend to prefer periodic profiling using a dedicated tool such as <strong class="bold">Visual Studio Enterprise</strong> or <strong class="bold">JetBrains dotTrace</strong> for those <a id="_idIndexMarker546"/>areas that are truly critical to performance.</p>
<p>That said, there is value in performance tests, but you may spend more time than you’d expect finding a good maximum test duration number.</p>
<p>Let’s move on to another library that makes your life easier when testing: <strong class="bold">Bogus</strong>.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor197"/>Generating test data with Bogus</h1>
<p>In <a href="B21324_06.xhtml#_idTextAnchor133"><em class="italic">Chapter 6</em></a>, I mentioned<a id="_idIndexMarker547"/> that tests are a form of documentation that <a id="_idIndexMarker548"/>explains how your system should work.</p>
<p>Keeping that in mind, look at the following test, which<a id="_idIndexMarker549"/> tests the<a id="_idIndexMarker550"/> interaction of the <code>Passenger</code> and <code>BoardingProcessor</code> classes:</p>
<pre class="source-code">
[Fact]
public void BoardingMessageShouldBeAccurate() {
  // Arrange
  Passenger passenger = new() {
    BoardingGroup = 7,
    FirstName = "Dot",
    LastName = "Nette",
    MailingCity = "Columbus",
    MailingStateOrProvince = "Ohio",
    MailingCountry = "United States",
    MailingPostalCode = "43081",
    Email = "noreply@packt.com",
    RewardsId = "CSA88121",
    RewardMiles = 360,
    IsMilitary = false,
    NeedsHelp = false,
  };
  BoardingProcessor boarding =
    new(BoardingStatus.Boarding, group:3);
  // Act
  string message = boarding.BuildMessage(passenger);
  // Assert
  message.ShouldBe("Please Wait");
}</pre>
<p>A lot of setup is needed in the <em class="italic">Arrange</em> phase before <code>BuildMessage</code> can be called. But what aspects of that setup are important? Which parts of the <code>Passenger</code> object contribute to that person being allowed to board versus being told to wait?</p>
<p>While it’s important to create<a id="_idIndexMarker551"/> test objects that look accurate, mixing irrelevant properties with vital <a id="_idIndexMarker552"/>properties can lead to difficulties interpreting what’s important about test data or why a test should pass instead of fail.</p>
<p>Bogus is a library that generates realistic random data of different types. Bogus helps solve this problem by giving you a good way of generating random data for those less critical parts of your objects.</p>
<p>This has the simultaneous benefit of focusing your attention on the more critical portions of your tests while also generating random data to test your assertion that the values in the other properties truly don’t matter.</p>
<p>Like the other libraries in this chapter, Bogus must be installed via NuGet and then referenced in a <code>using </code><code>Bogus;</code> statement.</p>
<p>Let’s look at the <em class="italic">Arrange</em> section of the earlier test using Bogus:</p>
<pre class="source-code">
// Arrange
Faker&lt;Passenger&gt; faker = new();
faker.RuleFor(p =&gt; p.FirstName, f =&gt; f.Person.FirstName)
 .RuleFor(p =&gt; p.LastName, f =&gt; f.Person.LastName)
 .RuleFor(p =&gt; p.Email, f =&gt; f.Person.Email)
 .RuleFor(p =&gt; p.MailingCity, f =&gt; f.Address.City())
 .RuleFor(p =&gt; p.MailingCountry, f =&gt; f.Address.Country())
 .RuleFor(p =&gt; p.MailingState, f =&gt;f.Address.State())
 .RuleFor(p =&gt; p.MailingPostalCode, f=&gt;f.Address.ZipCode())
 .RuleFor(p =&gt; p.RewardsId, f =&gt; f.Random.String2(8))
 .RuleFor(p =&gt; p.RewardMiles,
          f =&gt; f.Random.Number(int.MaxValue));
Passenger passenger = faker.Generate();
passenger.BoardingGroup = 7;
passenger.NeedsHelp = false;
passenger.IsMilitary = false;</pre>
<p>As you’ve likely noticed, this code is significantly different than the earlier code. It uses a <code>Faker&lt;Passenger&gt;</code> object from Bogus that will generate a different random <code>Passenger</code> object every time<a id="_idIndexMarker553"/> the <code>Generate()</code> method is called.</p>
<p>These <code>Passenger</code> objects <a id="_idIndexMarker554"/>will use Bogus’ library of random data to generate reasonable test data, as shown in <em class="italic">Figure 9</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 9.3 – A randomized passenger with somewhat realistic values" src="img/B21324_09_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – A randomized passenger with somewhat realistic values</p>
<p>The way this works is that you can set rules that <code>Faker</code> will follow when it sees a given property using the <code>RuleFor</code> method.</p>
<p>Using <code>RuleFor</code>, you can specify the property you want to program a response to in the first argument and then specify a function to get a value in the second parameter.</p>
<p>As an example, the <code>RuleFor(p =&gt; p.Email, f =&gt; f.Person.Email)</code> line has two function parameters. The first one uses <code>p</code> to represent the <code>Passenger</code> object and focuses on that object’s <code>Email</code> property. The second parameter takes in a <code>Faker</code> instance as <code>f</code> and the function may choose to use it to generate a value that <code>Faker</code> will use when generating a person.</p>
<p><code>Faker</code> contains many different types of data, from fake company names to ZIP codes to product names, IP addresses, and even absurd things such as hacker speak and “rants” such as reviews.</p>
<p>Now, if you look closely at the data <code>Faker</code> generates, it doesn’t always make sense. For example, <em class="italic">Figure 9</em><em class="italic">.3</em> listed the person as living in Larsonland, Minnesota with a postal code of 78950 and a country of “Cocos (Keeling) Islands.” Individually, these things are fine, but these different properties conflict wildly with one another.</p>
<p>If you need your data to make sense, you’ll need to write more nuanced rules for how these properties interact. Despite these limitations, Bogus gives you a great way of adding randomness to<a id="_idIndexMarker555"/> your code for the inconsequential data.</p>
<p>Often, when using <a id="_idIndexMarker556"/>Bogus, you’ll create your <code>Faker</code> instance in a separate method or the test constructor, which simplifies your code significantly:</p>
<pre class="source-code">
[Fact]
public void BoardingMessageShouldBeAccurate() {
<strong class="bold">  Faker&lt;Passenger&gt; faker = BuildPersonFaker();</strong>
<strong class="bold">  Passenger passenger = faker.Generate();</strong>
<strong class="bold">  passenger.BoardingGroup = 7;</strong>
<strong class="bold">  passenger.NeedsHelp = false;</strong>
<strong class="bold">  passenger.IsMilitary = false;</strong>
  BoardingProcessor boarding =
    new(BoardingStatus.Boarding, group: 3);
  // Act
  string message = boarding.BuildMessage(passenger);
  // Assert
  message.ShouldBe("Please Wait");
}</pre>
<p>Notice how this approach minimizes Bogus’ role in things and focuses your attention on how the randomly generated person is further configured. This helps you see that the important factors for someone not boarding the plane yet are as follows:</p>
<ul>
<li>They are in a higher boarding group than the current group</li>
<li>They are not military</li>
<li>They do not<a id="_idIndexMarker557"/> need help boarding the plane</li>
</ul>
<p>Bogus isn’t just <a id="_idIndexMarker558"/>for tests. For example, I’ve used Bogus successfully for prototyping user interfaces and generating data for small game projects. However, Bogus is a valuable addition to your testing toolbox.</p>
<p>Let’s move on to look at ways of isolating dependencies with a pair of mocking libraries.</p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor198"/>Mocking dependencies with Moq and NSubstitute</h1>
<p>So far, we’ve looked at a few libraries that improve the readability of your tests. In this section, we’ll look at <strong class="bold">mocking frameworks</strong> and <a id="_idIndexMarker559"/>see how libraries can help you more effectively test your code.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Understanding the need for mocking libraries</h2>
<p>Let’s discuss why mocking frameworks are<a id="_idIndexMarker560"/> necessary by revisiting the <code>FlightBookingManager</code> example we introduced in the previous chapter while discussing dependency injection:</p>
<pre class="source-code">
public class FlightBookingManager {
<strong class="bold">  private readonly IEmailClient _email;</strong>
<strong class="bold">  public FlightBookingManager(IEmailClient email) {</strong>
<strong class="bold">    _email = email;</strong>
<strong class="bold">  }</strong>
  public bool BookFlight(Passenger passenger,
    FlightInfo flight, string seat) {
    if (!flight.IsSeatAvailable(seat)) {
      return false;
    }
    flight.AssignSeat(passenger, seat);
    string message = "Your seat is confirmed";
    return <strong class="bold">_email.SendMessage(passenger.Email, message)</strong>;
  }
}</pre>
<p>Here, this class requires <code>IEmailClient</code> when <code>FlightBookingManager</code> is created. The client is then stored in the <code>_email</code> field and this is later used to send a message when a flight is booked. Passing in <code>IEmailClient</code> as a parameter to the constructor is an example of dependency injection and allows our class to work with anything that implements<a id="_idIndexMarker561"/> the <code>IEmailClient</code> interface.</p>
<p>Unfortunately, it also means that to test the class, we must provide an implementation of <code>IEmailClient</code>, even if we’re not explicitly testing something email-related.</p>
<p>Since we generally don’t want to send emails when unit testing our code, that means we’d need a separate implementation of <code>IEmailClient</code>. We could make one by declaring a class and implementing the <code>IEmailClient</code> interface with a minimal implementation.</p>
<p>Let’s say that <code>IEmailClient</code> was defined as follows:</p>
<pre class="source-code">
public interface IEmailClient {
  bool SendMessage(string email, string message);
}</pre>
<p>You could create a <code>TestEmailClient</code> that meets this requirement:</p>
<pre class="source-code">
public class TestEmailClient <strong class="bold">: IEmailClient</strong> {
  public bool SendMessage(string email, string message)
    =&gt; true;
}</pre>
<p>Here, the implementation of the test client is very simple and does the minimum possible needed to compile the code, which in this case is returning true, indicating a message was successfully sent. This type of class is <a id="_idIndexMarker562"/>sometimes called a <strong class="bold">test double</strong>, a <strong class="bold">test stub</strong>, or simply a <strong class="bold">mock object</strong>. These <a id="_idIndexMarker563"/>names are due to these classes looking<a id="_idIndexMarker564"/> like real implementations for testing <a id="_idIndexMarker565"/>purposes without having all their functionality. In this chapter, I will refer to these as mock objects since that will help mocking frameworks make more sense later.</p>
<p>This lets us write a test using the <code>TestEmailClient</code> mock object we created:</p>
<pre class="source-code">
[Fact]
public void BookingFlightShouldSucceedForEmptyFlight() {
  // Arrange
<strong class="bold">  TestEmailClient emailClient = new();</strong>
<strong class="bold">  FlightBookingManager manager = new(emailClient);</strong>
  Passenger passenger = GenerateTestPassenger();
  FlightInfo flight = GenerateEmptyFlight("Paris",
    "Toronto");
  // Act
  bool booked = manager.BookFlight(passenger, flight,"2B");
  // Assert
  booked.ShouldBeTrue();
}</pre>
<p>Here, we can safely test a flight without sending an email by providing <code>TestEmailClient</code> instead of a real email client.</p>
<p>Unfortunately, mock objects have their drawbacks. Let’s say we wanted to write another test that verifies that trying to book a seat that’s already occupied doesn’t send an email. In that case, we’d need to create another mock object with a different implementation.</p>
<p>In this case, we’d want to fail the test if the <code>SendMessage</code> method was called, so that method should throw<a id="_idIndexMarker566"/> an exception or use the <code>Assert.Fail</code> method to cause the test to fail, as shown here:</p>
<pre class="source-code">
public class SendingNotAllowedEmailClient : IEmailClient {
  public bool SendMessage(string email, string message) {
    Assert.Fail("You should not have sent an email");
    return false;
  }
}</pre>
<p>Let’s consider a more nuanced example. Let’s say you want to verify that the <code>BookFlight</code> method calls the <code>SendMessage</code> method on its <code>IEmailClient</code> one time and one time only.</p>
<p>We could test this by building a specialized mock object that had a counter of all the times it was called, but that’s yet more complexity in our test code that we don’t necessarily need. If the definition of what’s in <code>IEmailClient</code> ever changes, all our mock objects that implement that interface will also need to be updated.</p>
<p>Because so many tests need mock objects and each test tests something slightly different, writing and maintaining mock objects manually can be a lot of work. This is the core problem that mocking libraries exist to solve.</p>
<p>While there are several popular mocking libraries in .NET, the most popular for many years has been Moq. We’ll explore Moq next before looking at an alternative.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>Creating mock objects with Moq</h2>
<p>Moq, pronounced <a id="_idIndexMarker567"/>either “Mock” or “Mock-you” in the words of its creator, <em class="italic">is a mocking library built around using LINQ to create, configure, and verify the behavior of </em><em class="italic">mock objects</em>.</p>
<p>Just like the other libraries in this chapter, you’ll need to install Moq from NuGet Package Manager and import it into your file via a <code>using </code><code>Moq;</code> statement.</p>
<p>With Moq, you don’t create mock objects on your own; instead, you tell Moq the interface you want to implement or the class you want to inherit and Moq automatically creates an object that meets these requirements.</p>
<p>Let’s revisit our flight <a id="_idIndexMarker568"/>booking test from earlier in this chapter using Moq:</p>
<pre class="source-code">
[Fact]
public void BookingFlightShouldSucceedForEmptyFlight() {
  // Arrange
<strong class="bold">  Mock&lt;IEmailClient&gt; clientMock = new();</strong>
<strong class="bold">  IEmailClient emailClient = clientMock.Object;</strong>
  FlightBookingManager manager = new(emailClient);
  Passenger passenger = GenerateTestPassenger();
  FlightInfo flight = GenerateEmptyFlight("Hamburg",
    "Cairo");
  // Act
  bool booked = manager.BookFlight(passenger, flight,"2B");
  // Assert
  booked.ShouldBeTrue();
}</pre>
<p>Here, we instantiate a <code>Mock</code> instance named <code>clientMock</code> that will create a new mock object in the form of <code>IEmailClient</code>. We then call the <code>Object</code> property on <code>clientMock</code> and the Moq library automatically generates an object that implements <code>IEmailClient</code> in the simplest way possible.</p>
<p>Since we don’t care how the email client works in this example, this is all we need to do to generate a simple mock object that we can pass to <code>FlightBookingManager</code>. Not only is this less code, but we can stay in the test method while defining our mock object, and if the definition for <code>IEmailClient</code> ever changes, we don’t need to update the mock object since Moq takes care of that for us.</p>
<p>Of course, there’s a lot more that Moq can do, so let’s see how you can use it to configure how your mock<a id="_idIndexMarker569"/> objects behave.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>Programming Moq return values</h2>
<p>By default, methods on <a id="_idIndexMarker570"/>Moq’s mock objects will return the default value for that type. For example, a method returning a <code>bool</code> object would return <code>false</code>, and a method returning an <code>int</code> object would return <code>0</code>.</p>
<p>Sometimes, you need Moq to return something different. In these cases, you can set up your mock object by calling Moq’s <code>Setup</code> method. For example, if you needed the <code>SendMessage</code> method to return <code>true</code> instead of <code>false</code> for any value that was passed in, you could write the following code:</p>
<pre class="source-code">
Mock&lt;IEmailClient&gt; mockClient = new();
<strong class="bold">mockClient.Setup(c =&gt; c.SendMessage(It.IsAny&lt;string&gt;(),</strong>
<strong class="bold">                                    It.IsAny&lt;string&gt;())</strong>
<strong class="bold">                 ).Returns(true);</strong>
IEmailClient emailClient = mockClient.Object;</pre>
<p>Here, the <code>Setup</code> method requires you to tell it what method or property you are configuring. Since we’re configuring the <code>SendMessage</code> method, we specify it in the arrow function.</p>
<p>Next, Moq needs to know when it should apply this rule. You can program your mock objects to reply differently based on different parameters, so you could have a <code>Setup</code> call for different parameter values to the same method.</p>
<p>In our case, we want the method to always return <code>true</code>, regardless of what is passed in, so we specify that with Moq’s <code>It.IsAny</code> syntax.</p>
<p>Before we finish our discussion of Moq, we’ll look at a final example and teach you how to verify how many times a given method was called on your mock objects.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>Verifying Moq calls</h2>
<p>Sometimes, you <a id="_idIndexMarker571"/>want to test the behavior of a method and verify that calling one method causes it to call something on another object. Moq lets you do this by verifying that a method has been called a specific number of times.</p>
<p>This can include verifying that a method wasn’t called, which can be helpful for cases like the example we discussed earlier involving making sure emails aren’t sent out in cases where a seat couldn’t be reserved.</p>
<p>To accomplish this, we can call Moq’s <code>Verify</code> methods, as shown in the following case, which verifies that an<a id="_idIndexMarker572"/> email was sent once and only once when booking a flight:</p>
<pre class="source-code">
[Fact]
public void BookingFlightShouldSendEmails() {
    // Arrange
<strong class="bold">    Mock&lt;IEmailClient&gt; mockClient = new();</strong>
    mockClient.Setup(c =&gt; c.SendMessage(It.IsAny&lt;string&gt;(),
        It.IsAny&lt;string&gt;())).Returns(true);
    IEmailClient emailClient = mockClient.Object;
    FlightBookingManager manager = new(emailClient);
    Passenger passenger = GenerateTestPassenger();
    FlightInfo flight = GenerateEmptyFlight("Sydney","LA");
    // Act
    bool result= manager.BookFlight(passenger,flight,"2C");
    // Assert
    result.ShouldBeTrue();
<strong class="bold">    mockClient.Verify(c =&gt; c.SendMessage(passenger.Email,</strong>
<strong class="bold">        It.IsAny&lt;string&gt;()), Times.Once);</strong>
<strong class="bold">    mockClient.VerifyNoOtherCalls();</strong>
}</pre>
<p>Here, we call <code>Verify</code> on our <code>Mock</code> instance to verify that the <code>SendMessage</code> method was called exactly one time with the passenger’s email address and any email body. If the method wasn’t called or was called multiple times, this will fail our test.</p>
<p>In other words, this one <code>Verify</code> line protects us from cases where the system didn’t email the user when it should have, as well as cases where it might have sent too many emails.</p>
<p>Next, the code calls <code>VerifyNoOtherCalls</code>. This method will cause the test to fail if some other method on our <code>IEmailClient</code> was called that was not verified by a previous <code>Verify</code> statement. This can be handy for ensuring that the code is not doing unexpected things <a id="_idIndexMarker573"/>with the objects you provide it.</p>
<p class="callout-heading">A note on verifying behavior</p>
<p class="callout">The developer community has historically been divided on whether it is good practice to verify that calling code calls some other piece of code in your unit tests. The argument against verifying the behavior of your tests is that it shouldn’t matter how a method implements something if it produces the right results. The counter-argument is that sometimes, the desired result of your method is the callout to the external code, such as our code here, which calls the <code>SendMessage</code> call. You and your team will need to decide when it is appropriate to use <code>Verify</code> in your tests.</p>
<p>Moq can seem complex to work with initially, but you don’t need to use all its features to benefit from it. As we saw earlier, just using Moq to generate simple mock objects can save you significant work in maintaining a growing number of manually created mock objects over time.</p>
<p>You won’t always need to use Moq’s <code>Setup</code> or <code>Verify</code> methods, but they’re very helpful when you want them.</p>
<p>For years, Moq has been the dominant mocking library in .NET, but recently, NSubstitute has been gaining popularity. This results in a higher likelihood that you may encounter it in the workplace as a substitute for Moq. Let’s explore NSubstitute briefly and see how it accomplishes similar things to Moq using a different syntax.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>Mocking with NSubstitute</h2>
<p>NSubstitute is a similar <a id="_idIndexMarker574"/>mocking library to Moq, but its approach is to avoid arrow functions where possible and prefer code that looks more like standard method calls.</p>
<p>Like other libraries in this chapter, you’ll need to install NSubstitute via NuGet Package Manager and then import it via a <code>using </code><code>NSubstitute;</code> statement.</p>
<p>Once you have NSubstitute installed and imported, you can use it in code, as follows:</p>
<pre class="source-code">
[Fact]
public void BookingFlightShouldSendEmailsNSubstitute() {
  // Arrange
<strong class="bold">  IEmailClient emailClient= Substitute.For&lt;IEmailClient&gt;();</strong>
<strong class="bold">  emailClient.SendMessage(Arg.Any&lt;string&gt;(),</strong>
<strong class="bold">                          Arg.Any&lt;string&gt;()</strong>
<strong class="bold">                         ).Returns(true);</strong>
  FlightBookingManager manager = new(emailClient);
  Passenger passenger = GenerateTestPassenger();
  FlightInfo flight = GenerateEmptyFlight("Sydney","LA");
  // Act
  bool result = manager.BookFlight(passenger, flight,"2C");
  // Assert
  result.ShouldBeTrue();
<strong class="bold">  emailClient.Received()</strong>
<strong class="bold">             .SendMessage(passenger.Email,</strong>
<strong class="bold">                          Arg.Any&lt;string&gt;());</strong>
}</pre>
<p>Note how NSubstitute’s <code>Substitute.For</code> returns the object you’re creating instead of creating an object like <code>Mock&lt;IEmailClient&gt;</code> did with Moq. This change makes your code a little simpler <a id="_idIndexMarker575"/>to work with but also means you now need to call methods like <code>Received()</code> and <code>DidNotReceive()</code> to get access to the method to verify.</p>
<p>In general, NSubsitute is very similar to Moq but with a simpler syntax. This simplicity has its advantages, particularly in code readability and a lowered learning curve for new developers. Unfortunately, this sometimes comes at the price of NSubstitute not having the full range of<a id="_idIndexMarker576"/> features you’re used to with Moq.</p>
<p>Now that we’ve explored mocking libraries, let’s move on to completely different types of unit tests.</p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor204"/>Pinning tests with Snapper</h1>
<p>Let’s say you’ve inherited some complex legacy code that returns an object with a lot of properties. Some<a id="_idIndexMarker577"/> of these properties may, in turn, contain other complex objects with their own nest of properties. You’re just starting to work with this code and need to make a change, but there aren’t any tests in place and you’re not even sure what properties are important to verify.</p>
<p>I’ve seen this scenario a few times now and can attest that a special testing library called Snapper is a fantastic solution to this problem.</p>
<p>What Snapper does is it creates a snapshot of an object and stores it to disk in a JSON file. When Snapper next runs, it generates another snapshot and then compares it to the snapshot it stored previously. If the snapshots differ at all, Snapper will fail the test and alert you to that problem.</p>
<p class="callout-heading">Snapper and Jest</p>
<p class="callout">For those of you with a JavaScript background, Snapper<a id="_idIndexMarker578"/> was inspired by the snapshot testing capabilities found in JavaScript’s Jest testing library.</p>
<p>Let’s see what a sample test looks like with Snapper.</p>
<p>As usual, first, we install Snapper via NuGet and add a <code>using </code><code>Snapper;</code> statement.</p>
<p>After that, we’ll write a test against a complex object, <code>FlightManifest</code>:</p>
<pre class="source-code">
[Fact]
public void FlightManifestShouldMatchExpectations() {
  // Arrange
  FlightInfo flight = GenerateEmptyFlight("Alta", "Laos");
  Passenger p1 = new("Dot", "Netta");
  Passenger p2 = new("See", "Sharp");
  flight.AssignSeat(p1, "1A");
  flight.AssignSeat(p2, "1B");
  LegacyManifestGenerator generator = new();
  // Act
  FlightManifest manifest = generator.Build(flight);
  // Assert
<strong class="bold">  manifest.ShouldMatchSnapshot();</strong>
}</pre>
<p>Here, we call <code>ShouldMatchSnapshot</code> to verify that the<a id="_idIndexMarker579"/> object matches the current snapshot.</p>
<p>This will generate the snapshot the first time, but subsequent runs will compare the object’s snapshot to the stored snapshot. If the resulting snapshot is different, you’ll see a test failure with details about the difference, such as the one that occurs when a passenger’s name is changed, as shown in <em class="italic">Figure 9</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 9.4 – A failing snapshot test showing the difference between two properties" src="img/B21324_09_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – A failing snapshot test showing the difference between two properties</p>
<p>Sometimes, you’ll add new properties or realize that the stored snapshot was based on buggy data and you’ll want to update<a id="_idIndexMarker580"/> your snapshots. You can do this by temporarily adding an <code>UpdateSnapshots</code> attribute to your test method, as shown here:</p>
<pre class="source-code">
[Fact]
<strong class="bold">[UpdateSnapshots]</strong>
public void FlightManifestShouldMatchExpectations() {</pre>
<p>After this, re-run your test to update the stored snapshot, then remove the <code>UpdateSnapshots</code> attribute. This final step is important because the test with <code>UpdateSnapshots</code> included will never fail a snapshot test but rather replace the snapshot every time.</p>
<p>Snapshot testing is not for every project and not for every team. It is a very useful broad safety net that you can include as the first test for complex return values, but it is far less useful as a test that documents the behavior of a system. Additionally, snapshot tests can be very brittle and cause tests to fail for trivial things such as modified dates being different between two otherwise identical sets of data.</p>
<p>Still, I find that Snapper and snapshot testing can be an appropriate opening move while trying to bring tests to particularly complex areas of legacy systems.</p>
<p>Now, let’s close this chapter out with a similar library that helps you compare several different implementations with each other.</p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/>Experimenting with Scientist .NET</h1>
<p>Scientist .NET is<a id="_idIndexMarker581"/> a library built by GitHub for scientifically refactoring the critical parts of your application.</p>
<p>Let’s say you have a portion of your application that is vital to what the business does but has a significant amount of technical debt. You want to refactor it, but you’re afraid of breaking anything and your existing tests are not sufficient to address those fears, but you’re not sure what tests you need to add. In your estimation, the only thing that will let you feel good about your new code is to see how it does in production.</p>
<p>This is what Scientist .NET helps with. Scientist .NET lets you deploy your new code alongside the legacy code it hopes to replace and compares the results of the two pieces of code. Alternatively, Scientist .NET can be used in unit tests to verify that the old version of a component<a id="_idIndexMarker582"/> and the new version of the component achieves the same results.</p>
<p>This concept will hopefully be a bit clearer in a moment. Let’s jump into a specific example that looks at replacing <code>LegacyManifestGenerator</code> with <code>RewrittenManifestGenerator</code>.</p>
<p>Like before, we’ll need to install the Scientist package from NuGet and then add a <code>using GitHub;</code> statement to the top of our file.</p>
<p>Next, let’s look at the science experiment comparing the two manifest generators:</p>
<pre class="source-code">
[Fact]
public void FlightManifestExperimentWithScientist() {
  FlightInfo flight = GenerateEmptyFlight("Alta", "Laos");
  Passenger p1 = new("Dot", "Netta");
  Passenger p2 = new("See", "Sharp");
<strong class="bold">  Scientist.Science&lt;FlightManifest&gt;("Manifest", exp =&gt; {</strong>
<strong class="bold">    exp.Use(() =&gt; {</strong>
<strong class="bold">      LegacyManifestGenerator generator = new();</strong>
<strong class="bold">      return generator.Build(flight);</strong>
<strong class="bold">    });</strong>
<strong class="bold">    exp.Try(() =&gt; {</strong>
<strong class="bold">      RewrittenManifestGenerator generator = new();</strong>
<strong class="bold">      return generator.Build(flight);</strong>
<strong class="bold">    });</strong>
<strong class="bold">    exp.Compare((a, b)=&gt; a.Arrival == b.Arrival &amp;&amp;</strong>
<strong class="bold">                         a.Departure == b.Departure &amp;&amp;</strong>
<strong class="bold">                         a.PassengerCount==b.PassengerCount</strong>
<strong class="bold">               );</strong>
<strong class="bold">    exp.ThrowOnMismatches = true;</strong>
<strong class="bold">  });</strong>
}</pre>
<p>That’s a lot of code, so let’s unpack everything here bit by bit.</p>
<p>First, the <code>Scientist.Science&lt;FlightManifest&gt;</code> line tells Scientist you’re starting a new experiment that will return <code>FlightManifest</code>. In this example, we’re ignoring this result value, but in <a id="_idIndexMarker583"/>a production scenario, you might assign the result to a variable and work with it after the call to the Scientist.</p>
<p>Scientist requires you to name every experiment in the first parameter to the <code>Science</code> call because you may be performing multiple experiments. This experiment is simply named “Manifest.”</p>
<p>Next, the Scientist requires an action to configure the experiment you’re about to perform. You might configure a few things, but here, we’re specifying four different things that we’ll talk about in sequence.</p>
<p>First, we call the <code>Use</code> method to tell the experiment what to use as the result of the call to the <code>Scientist.Science</code>. This should be the legacy implementation of the system you’re looking at replacing.</p>
<p>Next, we need to give Scientist one or more alternative implementations to consider and compare against the “control” version in the legacy system. We do this via a <code>Try</code> method that looks very similar to the <code>Use</code> method, but it represents the experimental version.</p>
<p>What Scientist does with these two versions is it makes the call to both implementations, compares<a id="_idIndexMarker584"/> the two results, and sends metrics on to something called a result publisher. This process is illustrated in <em class="italic">Figure 9</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 9.5 – Scientist .NET performing an experiment" src="img/B21324_09_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Scientist .NET performing an experiment</p>
<p>Scientist always returns the result of the legacy version defined during <code>Use</code>, so your new implementation will not impact the existing logic and you’ll be able to identify cases where the new and old implementations do not match. This allows you to verify your new logic’s behavior without risking<a id="_idIndexMarker585"/> any logic bugs impacting end users.</p>
<p>Once you are satisfied that your new implementation is without issues, you can remove Scientist and the legacy implementation from your code and use the new implementation in their place.</p>
<p>For Scientist to tell if two results are equivalent, it needs to know how to compare them. You can configure this with the <code>Compare</code> method, which takes in a function that will return a <code>bool</code> object indicating if the two objects should be considered equivalent.</p>
<p>Finally, our code sets <code>ThrowOnMismatches</code> to <code>true</code>. You can set this property in Scientist to have it throw an exception when the experiment and the control do not match for a given input. This is only intended for use in unit tests like our code here and is not intended for use if you’re using Scientist in a production application.</p>
<p>Instead, you would implement Scientist’s <code>IResultPublisher</code> interface and set <code>Scientist.ResultPublisher</code> equal to your custom result publisher. This would allow you to report mismatches to a database, App Insights on Azure, or some other mechanism you might consider using to capture these mismatches. Getting into result publishers is outside the scope of this book, but see the <em class="italic">Further reading</em> section in this chapter for more resources.</p>
<p>Scientist .NET is a complex solution you won’t use frequently, but it allows you to compare how two different implementations of an algorithm perform against a variety of inputs, either in a unit testing scenario or in a production application. I’ve personally seen Scientist .NET enable teams to collect the data they needed to successfully refactor highly complex code without impacting end users.</p>
<p class="callout-heading">Warning</p>
<p class="callout">It’s important to note that when you run an experiment in Scientist, both the original version in your <code>Use</code> statement and any experiments you defined in the <code>Try</code> calls will be called. This means that if your code has any side effects such as inserting into a database or sending an email, these things will occur twice. This might result in duplicate rows being inserted into a database or duplicate emails being sent.</p>
<p>You can potentially <a id="_idIndexMarker586"/>avoid this downside by providing the experimental versions of mock objects as their dependencies instead of real versions of a database client or an email provider.</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Summary</h1>
<p>In this chapter, we saw several different open-source libraries that can improve the readability and capabilities of your tests.</p>
<ul>
<li>Shouldly and FluentAssertions give you the readable syntax for writing assertions.</li>
<li>Bogus allows you to generate randomized test data for values that don’t matter.</li>
<li>Moq and NSubstitute help you isolate dependencies and provide alternative implementations for testing.</li>
<li>Snapper and Scientist .NET help catch issues where complex objects change in subtle ways.</li>
</ul>
<p>Not every project will benefit from each of these libraries. However, knowing the tools at your disposal will help you as you refactor and maintain your code and expand your tests.</p>
<p>While it’s possible to do all the things in this chapter without using these libraries, all of these libraries represent established community projects dedicated to solving specific technical concerns.</p>
<p>In the next chapter, we’ll close out this section of this book with a discussion of defensive coding practices using modern C#.</p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/>Questions</h1>
<ol>
<li>What areas of your test code could be more readable? Are there any libraries in this chapter that might help?</li>
<li>How do mocking libraries such as Moq and NSubstitute help in testing?</li>
<li>Do you see any areas of your code where the complexity is high enough that Snapper or Scientist .NET might be able to help?</li>
</ol>
<h1 id="_idParaDest-209"><a id="_idTextAnchor208"/>Further reading</h1>
<p>You can find more information about the libraries discussed in this chapter at these URLs:</p>
<ul>
<li><em class="italic">Shouldly</em>: <a href="https://github.com/shouldly/shouldly">https://github.com/shouldly/shouldly</a></li>
<li><em class="italic">FluentAssertions</em>: <a href="https://fluentassertions.com/">https://fluentassertions.com/</a></li>
<li><em class="italic">Bogus</em>: <a href="https://github.com/bchavez/Bogus">https://github.com/bchavez/Bogus</a><a href="https://github.com/bchavez/Bogus "/></li>
<li><em class="italic">Moq</em>: <a href="https://github.com/moq/moq">https://github.com/moq/moq</a></li>
<li><em class="italic">NSubstitute</em>: https://nsubstitute.github.io/</li>
<li><em class="italic">Snapper</em>: <a href="https://github.com/theramis/Snapper">https://github.com/theramis/Snapper</a></li>
<li><em class="italic">Scientist .</em><em class="italic">NET</em>: <a href="https://github.com/scientistproject/Scientist.net">https://github.com/scientistproject/Scientist.net</a></li>
</ul>
</div>
</body></html>