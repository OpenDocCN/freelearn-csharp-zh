<html><head></head><body>
		<div><h1 id="_idParaDest-181"><em class="italic"><a id="_idTextAnchor1040"/>Chapter 10</em>: Creating an ASP.NET Core 6 Web API</h1>
			<p>In recent times, web services have become an important part of web application development. With ever-changing requirements and increased business complexity, it is very important to loosely couple various components/layers involved in web application development, and there is nothing better than decoupling the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) part of the application with the core business logic. This is where the simplicity of web services using a RESTful approach (where <strong class="bold">REST</strong> stands for <strong class="bold">REpresentational State Transfer</strong>) helps us to develop scalable web applications.</p>
			<p>In this chapter, we will learn how to build RESTful services using an ASP.NET Core web <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>), and along the way, we will build all the required APIs for our e-commerce application.</p>
			<p>We'll be covering the following topics in detail:</p>
			<ul>
				<li>Introduction to REST </li>
				<li>Understanding the internals of an ASP.NET Core 6 web API</li>
				<li>Handling requests using controllers and actions</li>
				<li>Integration with the data layer</li>
				<li>Understanding <strong class="bold">Google Remote Procedure Call</strong> (<strong class="bold">gRPC</strong>)</li>
			</ul>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor1041"/><a id="_idTextAnchor1042"/>Technical requirements</h1>
			<p>For this chapter, you will require a basic knowledge of C#, .NET Core, web APIs, <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>), Azure, <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>), Postman, and the .NET <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>).</p>
			<p>The code for this chapter can be found here: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi</a>.</p>
			<p>For more code examples, refer to the following link: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application</a>.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor1043"/><a id="_idTextAnchor1044"/>Introduction to REST</h1>
			<p>REST is an <a id="_idTextAnchor1045"/><a id="_idIndexMarker839"/>architectural guideline for building a web service. Primarily, it defines a set of constraints that can be followed while designing a web service. One of the key principal REST approaches recommends that APIs should be designed around resources and should be media- and protocol-agnostic. The underlying implementation of the API is independent of the client consuming the API.</p>
			<p>Considering an example of our e-commerce application, let's say we are searching for a product on the UI using a product's search field. There should be an API that is created for products, and here, products are nothing but a resource in the context of an e-commerce<a id="_idIndexMarker840"/> application. The <code>GET</code> operation on product entities:</p>
			<pre class="source-code">GET http://ecommerce.packt.com/products</pre>
			<p>The response of the API should be independent of the client that is calling the API—that is, in this case, we are using a browser to load a list of products on the product search page. However, the same API can be consumed in a mobile application as well without any changes. Secondly, in this case, in order to retrieve product information internally, an application may be using one or more physical data stores; however, that complexity is hidden from the client application, and the API is exposed to the client as a single business entity—products. Although REST principles do not dictate the protocol to be HTTP, the majority of RESTful services are built over HTTP. Some key design principles/constraints/rul<a id="_idTextAnchor1047"/>es of HTTP-based RESTful APIs are outlined here:</p>
			<ul>
				<li>Identify the business entities of the system and design APIs around those resources. In the case of our e-commerce application, all our APIs would be around resources such as products, orders, payments, and users.</li>
				<li>REST APIs should have a uniform interface that assists in making them independent of the client. As all the APIs need to be resource-oriented, each resource is uniquely identified by a URI; additionally, various operations on resources are uniquely identified by HTTP verbs such as <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>. For example, <code>GET</code> (<code>http://ecommerce.packt.com/products/1</code>) should be used to retrieve a product with an<code>1</code>. Similarly, <code>DELETE</code> (<code>http://ecommerce.packt.com/products/1</code>) should be used to delete a product.</li>
				<li>As HTTP is stateless, REST dictates a number of things for RESTful APIs. What this means is that APIs should be atomic and conclude the processing of a request within<a id="_idIndexMarker841"/> the same call. Any subsequent request, even from the same client (same <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) address), is treated as a new request. For example, if an API accepts an authentication token, it should accept authentication for each request. One major advantage of statelessness is the scalability that servers can eventually achieve, as a client can make an API call to any of the available servers and still receive the same response.</li>
				<li>Apart from sendi<a id="_idTextAnchor1048"/>ng back a response, APIs should make use of HTTP status codes and response <a id="_idIndexMarker842"/>headers to send any additional information to the client. For example, if a response can be cached, an API should send the relevant response headers to the client so that it can<a id="_idTextAnchor1049"/> be <a id="_idIndexMarker843"/>cached. <code>1xx</code> for information, <code>2xx</code> for success, <code>3xx</code> for redirection, <code>4xx</code> for client errors, and <code>5xx</code> for server errors.</li>
				<li>APIs should give information about<a id="_idTextAnchor1050"/> the resource such that clients should be easily able to discover it without any prior information relating to the resource—that is, there <a id="_idIndexMarker844"/>should follow the principle of <strong class="bold">Hypermedia as the Engine of Application State</strong> (<strong class="bold">HATEOAS</strong>). For example, if there is an API to create a product, once a product is created, the API should respond with the URI of that resource so that the client can use that to retrieve the product later.</li>
			</ul>
			<p>Refer to the following response for an API that retrieves a list of all products (<code>GET /products</code>) and has information to retrieve further details regarding each product:</p>
			<pre>{
"Products": [
{
"Id": "1",
"Name": "Men's T-Shirt",
"Category": "Clothing"
"Uri": "http://ecommerce.packt.com/products/1"
}
{
"Id": "2",
"Name": "Mastering enterprise application development Book",
"Category": "books"
"Uri": "http://ecommerce.packt.com/products/2"
}
]
}</pre>
			<p>The preceding example is one way to impl<a id="_idTextAnchor1051"/>ement the <em class="italic">HATEOAS</em> principle, but it can be designed in <a id="_idIndexMarker845"/>a more descriptive way, such as a response containing information about accepted HTTP verbs and relationships.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor1052"/>The REST maturity model</h2>
			<p>These are v<a id="_idTextAnchor1053"/>arious<a id="_idIndexMarker846"/> guidelines that an API should follow in order for it to be RESTful. However, not all the principles need to be followed to make it perfectly RESTFUL; it's more important that an API should fulfill the business goal rather than being 100% REST-compliant. Leonard Richardson, an expert on RESTful API design, came up with the following model to categorize the maturity of an API:</p>
			<ul>
				<li><code>POST</code> URI to <a id="_idIndexMarker847"/>perform all operations will fall under this category. An example would be a <strong class="bold">Simple Object Access Protocol</strong> (<strong class="bold">SOAP</strong>)-based web service that has a single URI, and all operations are segregated based on the SOAP envelope.</li>
				<li><strong class="bold">Level 1—Resources</strong>: All resources are URI-driven, and APIs that have a dedicated URI pattern per resource fall under this maturity model.</li>
				<li><code>GET</code> and <code>DELETE</code> using the same URI with different HTTP verbs falls under this maturity model. Most enterprise application RESTful APIs fall under this category.</li>
				<li><strong class="bold">Level 3—HATEO<a id="_idTextAnchor1054"/>AS</strong>: APIs that are designed with all additional discovery information (the URI for the resources; various operations that the resource supports) fall under this maturity model. Very few APIs are compliant with this maturity level; however, as discussed earlier, it's important that our APIs fulfill the business objective and are as compliant as possible with RESTful principles, rather than 100% compliant but not fulfilling the business objective.</li>
			</ul>
			<p>The following diagram illustrates Richardson's maturity<a id="_idTextAnchor1055"/> model:</p>
			<div><div><img src="img/Figure_10.1_B18507.jpg" alt="Figure 10.1 – Richardson's maturity model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Richardson's maturity model</p>
			<p>Up to now, we have di<a id="_idTextAnchor1056"/>scussed various principles of REST architecture. In the next section, let's get into using an ASP.NET Core web API for which we will create various RESTful services in <a id="_idIndexMarker848"/>our e-commerce appl<a id="_idTextAnchor1057"/><a id="_idTextAnchor1058"/>ication.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor1059"/>Understanding the internals of an ASP.NET Core 6 web API</h1>
			<p><strong class="bold">ASP.NET C<a id="_idTextAnchor1060"/>ore</strong> is a unified<a id="_idIndexMarker849"/> framework that runs on top of .NET Core and is used to develop web applications (MVC/Razor), RESTful services (web API), and—most recently—web assembly-based client applications (Blazor apps). The fundamental design of ASP.NET Core applications is<a id="_idIndexMarker850"/> based on the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) patt<a id="_idTextAnchor1061"/>ern, which divides code into three primary categories, as follows:</p>
			<ul>
				<li><strong class="bold">Model</strong>: This is a <strong class="bold">plain old CLR object</strong> (<a id="_idTextAnchor1062"/><strong class="bold">POCO</strong>)<a id="_idTextAnchor1063"/> class <a id="_idIndexMarker851"/>that holds the data and is used to pass data between various layers of the application. Layers include passing data between the <em class="italic">repository</em> class and the <em class="italic">service</em> class or passing information back and forth between the <em class="italic">client</em> and <em class="italic">server</em>. The model primarily represents the resource state or the domain model of the application and contains information that you have requested. </li>
			</ul>
			<p>For example, if we wanted to store user profile information, this can be represented by the <code>UserInformation</code> POCO class and can contain all the profile information. This will be further used to pass between repositories and service classes and can also be serialized into <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>)/<strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>) <a id="_idTextAnchor1064"/>before being sent back to the client. In enterprise applications, we will encounter different types of models while creating models for our e-commerce application in the <em class="italic">Integration with the data layer</em> section.</p>
			<ul>
				<li><strong class="bold">View</strong>: These are the pages that represent UIs. All our models retrieved from controllers are bound to various <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) controls on views and are presented to users. Views are usually common in MVC/Razor applications; for web API applications, the process ends with serializing models as a response.</li>
				<li><code>Microsoft.AspNetCore.Mvc.ControllerBase</code> class to define controllers.</li>
			</ul>
			<p>So, in a web<a id="_idIndexMarker852"/> application developed using ASP.NET Core, whenever a request comes from a client (browser, mobile apps, and similar sources), it goes through the ASP.NET Core request pipeline and reaches a controller that interacts with the data store to populate models/view-models and send them back either as a response in the form of JSON/XML or to a view to further bind the response and present it to the user. </p>
			<p>As you can see, there is a clear <strong class="bold">separation of concerns</strong> (<strong class="bold">SOC</strong>) where a controller is not aware of any UI aspect and performs the business logic in the current context and responds via models; views, on the other hand, receive models and use them to present them to the user in HTML pages. This SOC easily helps to unit test the application, as well as maintain and scale it as needed. MVC patterns are not only applicable to web applications and can be used for any application that requires an SOC.</p>
			<p>As the focus of this chapter is to build RESTful services, we will focus on an ASP.NET Core web API in this chapter and discuss ASP.NET MVC and Razor Pages in <a href="B18507_11_Epub.xhtml#_idTextAnchor1228"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web Application</em>.</p>
			<p>To develop RESTful services, many frameworks are available, but here are a few <a id="_idTextAnchor1066"/>advantages<a id="_idIndexMarker853"/> of going with ASP.NET Core on .NET 6:</p>
			<ul>
				<li><strong class="bold">Cross-platform support</strong>: Unlike ASP.NET, which used to be part of the .NET Framework (which is coupled with the Windows operating system), ASP.NET Core is now part of the application, thereby eliminating platform dependency and making it compatible with all platforms.</li>
				<li><strong class="bold">Highly customizable request pipelines</strong>: Use middlewares and support to inject various out-of-the-box modules, such as logging and configuration.</li>
				<li><code>IIS</code> and <code>HTTP.sys</code>.<p class="callout-heading">Note</p><p class="callout">By default, Kestrel is the HTTP server used in ASP.NET Core templates; however, that can be overridden as required.</p></li>
				<li><strong class="bold">Strong tooling support</strong>: This comes in the form of <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), Visual Studio, and the DOTNET CLI, along with project templates, which means developers can start working on implementing the business logic with very little setup.</li>
				<li><strong class="bold">Open sourced</strong>: Finally, the entire framework is open sourced and is available at <a href="https://github.com/aspnet/AspNetCore">https://github.com/aspnet/AspNetCore</a>.</li>
			</ul>
			<p>So, we now know why we picked ASP.NET Core as our framework to develop RESTful services. Let's now look into some key components that assist in the execution of the request and create a sample web API by using the following command:</p>
			<pre class="source-code">dotnet new webapi -o TestApi</pre>
			<p>Once the preceding command is successfully executed, let's navigate to the <code>TestApi</code> folder and open it in VS Code to see the various files that are generated, as shown in the following<a id="_idTextAnchor1067"/> screenshot:</p>
			<div><div><img src="img/Figure_10.2_B18507.jpg" alt="Figure 10.2 – Test web API project in VS Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – Test web API project in VS Code</p>
			<p>Here, you can<a id="_idIndexMarker854"/> see a <code>Program</code> class used to bootstrap the application, and settings files, such as <code>appsettings.json</code>, that are used to run a web API project, and there is also <code>WeatherForecast</code>, which is a model class used in the controller class. Let's examine each of the components of <code>TESTAPI</code> in the follow<a id="_idTextAnchor1068"/><a id="_idTextAnchor1069"/>ing sections.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor1070"/>The Program class</h2>
			<p>The <code>Program</code> class <a id="_idIndexMarker855"/>is used to bootstrap web API<a id="_idIndexMarker856"/> projects in ASP.NET Core 6. Let's look at the activities perform<a id="_idTextAnchor1071"/>ed by this class in the following steps:</p>
			<ol>
				<li>The <code>Program</code> class is the entry point for our web API, and it tells ASP.NET Core to begin execution whenever someone executes the web API project. Primarily, this is the class that is used to bootstrap the application. Unlike earlier versions of ASP.NET Core applications, by default we don't have a <code>Startup</code> class—that is, the <code>Program</code> class has everything that we need—and to keep the code minimal, we further rely on C# 10's top-level statements and global using statements.</li>
				<li>Since this is the entry point, we need to ensure all components such as the web server, routing, and configuration, get initialized and loaded, and that is what the <code>CreateBuilder</code> method of the <code>WebApplication</code> class helps with. It primarily creates an object of <code>WebApplicationBuilder</code>, which can be used to configure the HTTP request pipeline.</li>
				<li><code>WebApplicationBuilder</code> is inherited from the <code>IApplicationBuilder</code> interface, which is nothing but t<a id="_idTextAnchor1072"/>he <code>Host</code> is nothing more than an object that encapsulates these components, such as the HTTP server defaulted to Kestrel, all the middleware components, and any additional services—such as logging—that are injected. Finally, the <code>B<a id="_idTextAnchor1073"/>uild()</code> method is called to run actions and initialize the <code>Host</code> object. The <code>Run()</code> method is called to keep the <code>Host</code> object running.</li>
			</ol>
			<p>Now that we <a id="_idIndexMarker857"/>have<a id="_idIndexMarker858"/> the <code>Host</code> object loaded with all the default components and it is up and running, let's examine whether we can inject additional ASP.NET Core classes/application-specific classes (repositories, services, options) and middlewares. Consider the follow<a id="_idTextAnchor1074"/>ing points: </p>
			<ul>
				<li>This <code>WebApplicationBuilder</code> object is used to inject any ASP.NET Core-provided services so that applications can use those services. A few common services that enterprise applications can inject are shown in the following code snippet:<pre>var builder = WebApplication.CreateBuilder(args);
builder.Services.AddAuthentication() // To enable 
//authentication.
builder.Services.AddControllers(); // To enable 
//controllers like web API.
builder.Services.AddControllersWithViews(); // To 
//enable controller with views.
builder.Services.AddDistributedMemoryCache(); // To enable distributed caching.
// App insights.
string appinsightsInstrumentationKey = builder.Configuration.GetValue&lt;string&gt;("ApplicationSettings:InstrumentationKey");
builder.Services.AddApplicationInsightsTelemetry(appInsightInstrumentKey); // To enable application insights 
//telemetry.</pre></li>
			</ul>
			<p>Apart<a id="_idIndexMarker859"/> from <a id="_idIndexMarker860"/>services provided by ASP.NET Core, we can also inject any custom services specific to our application—for example, <code>ProductService</code> can be mapped to <code>IProductService</code> and can be made available for the entire application. Primarily, this <a id="_idTextAnchor1075"/>is the place we can use to plumb anything into the DI container, as explained in <a href="B18507_05_Epub.xhtml#_idTextAnchor445"><em class="italic">Chapter 5</em></a>, <em class="italic">Dependency Injection in .NET 6</em>.</p>
			<p>Additionally, all services, including ASP.NET Core services and custom services, can be plumbed into the application and are available as extension methods of <code>IServiceCollection</code>.</p>
			<ul>
				<li>Next, we ha<a id="_idTextAnchor1076"/>ve an object of the <code>WebApplication</code> class that can be used to integrate all the middlewares required to be applied to the request pipeline. This object primarily controls how applications respond to HTTP requests—that is, how applications should respond to exceptions, how they should respond to static files, or how URI routing should happen. All can be configured using this object. </li>
			</ul>
			<p>Additionally, any specific handling on a request pipeline—such as calling a custom middleware or adding specific response headers, or even defining a specific endpoint—can be injected using the <code>WebApplication</code> object. So, apart from what we saw earlier, the following code snippet shows a few common additional <a id="_idIndexMarker861"/>configurations <a id="_idIndexMarker862"/>that can be integrated using the <code>WebApplication</code> object:</p>
			<pre>var app = builder.Build();
// Endpoint that responds to /subscribe route.
app.UseEndpoints(endpoints =&gt;
{
endpoints.MapGet("/subscribe", async context =&gt;
{   
  await context.Response.WriteAsync("subscribed");
});
});
// removing any unwanted headers.
app.Use(async (context, next) =&gt;
{
context.Response.Headers.Remove("X-Powered-By");
context.Response.Headers.Remove("Server");
await next().ConfigureAwait(false);
});</pre>
			<p>Here, <code>app.UseEndpoints</code> is configuring a response for a URI that matches <code>/subscribe</code>. <code>app.UseEndPoints</code> works alongside routing rules and is explained in the <em class="italic">Handling requests using controllers and actions</em> section, while <code>app.Use</code>, on the other hand, is used to add an inline middleware. In this case, we are removing <code>X-Powered-By</code> and <code>Server</code> response headers from the response.</p>
			<p>Since ASP.NET Core 6 supports something<a id="_idIndexMarker863"/> called <code>Program</code> class alone can be used to build a fully working API; however, for enterprise applications, it is good to segregate APIs for easier maintenance and better readability, hence in our enterprise applications, we will be using APIs with the controller, which is supported by <code>MapControllers</code> middleware and is configured by calling <code>app.</code> <code>MapControllers()</code>.</p>
			<p>To sum up, the <code>Program</code> class plays a vital role in bootstrapping the application and then customizing application services and HTTP request/response pipelines as needed.</p>
			<p>Let's now see<a id="_idIndexMarker864"/> how middlewares help in customizing the<a id="_idIndexMarker865"/> HTTP request/response pipeline.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">ASP.NET Core 6 still supports using the <code>Startup</code> class, and the <code>Configure</code> and <code>ConfigureServices</code> me<a id="_idTextAnchor1077"/><a id="_idTextAnchor1078"/>thods can be used as-is.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor1079"/>Understanding middleware</h2>
			<p>W<a id="_idTextAnchor1080"/>e have been<a id="_idIndexMarker866"/> referring to middleware for a while now, so <a id="_idIndexMarker867"/>let's understand what middlewares are and how we can we build one and use it in our enterprise application. Middlewares are classes that intercept incoming requests, perform some processing on the requests, and then hand them over to the next middleware or skip them as required. Middlewares are bidirectional, hence all middlewares intercept both requests and responses. Let's assume that an API retrieves product information and, in the process, it goes through various middlewares. Representing them in pictorial form would<a id="_idTextAnchor1081"/> look something like this:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.3_B18507.jpg" alt="Figure 10.3 – Middleware processing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – M<a id="_idTextAnchor1082"/>iddleware processing</p>
			<p>Each middleware has an instance of <code>Microsoft.AspNetCore.Http.RequestDelegate</code>. As a result of using this, the middleware invokes the next middleware. So, flows would typically process the request as per some processing logic that you want the middleware to perform on the request and then invoke <code>RequestDelegate</code> to hand the request over to the next middleware in the pipeline.</p>
			<p>If we take<a id="_idIndexMarker868"/> an <a id="_idIndexMarker869"/>analogy from manufacturing, it would be like an assembly line in a manufacturing process, where parts are added/modified from workstation to workstation until a final product is produced. In the previous diagram, let's consider each middleware as a workstation, so it will be going through the following steps: </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The following explanation of each middleware is just a hypothetical explanation for our understanding; the internal workings of these middlewares differ slightly from what is explained here. More details can be found here: <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&amp;viewFallbackFrom=aspnetcore-6.0">https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&amp;viewFallbackFrom=aspnetcore-6.0</a>.</p>
			<ol>
				<li value="1"><code>UseHttpsRedirection</code>: An HTTP request arrives for <code>GET/Products</code> and is inspected for the protocol. If the request is via HTTP, a redirect is sent back through the HTTP status code; if the request is on HTTPS, it's handed over to the next middle<a id="_idTextAnchor1084"/>ware.</li>
				<li><code>UseStaticFiles</code>: If the request is for a static file (usually detected based on the <a id="_idIndexMarker870"/>extension—the <strong class="bold">Multipurpose Media Extensions</strong> (<strong class="bold">MIME</strong>) type), this middleware processes the request and sends the response back, or else hands the request on to the next middleware. Here, as you can see, if the request is for a static file, the rest of the pipeline is not even executed as this middleware can process the complete request, thereby reducing the load on the server for any unwanted processing and also reducing the response time. This process is also known as <strong class="bold">short-circuiting</strong>, which <a id="_idIndexMarker871"/>every middlewar<a id="_idTextAnchor1085"/>e can support.</li>
				<li><code>UseRouting</code>: The request is inspected further, and the controller/action that can process the<a id="_idIndexMarker872"/> request is identified. If there<a id="_idIndexMarker873"/> isn't any match, this middleware usually responds with a <code>404</code> HTTP status <a id="_idTextAnchor1086"/>code.</li>
				<li><code>UseAuthorization</code>: Here, if the controller/action needs to be available for authenticated users, then this middleware will look for any valid token in the header and respond accordingly.</li>
			</ol>
			<p>Once the controller gets the data from services/repositories, the response goes through the same middlewares in reverse order—that is, <code>UseAuthorization</code> first, followed by <code>UseHttpsRedirection</code>—and the response is processed as needed.</p>
			<p>As mentioned earlier, all middlewares are installed using the <code>Program</code> class and are configured using the object of the <code>WebApplication</code> class. The order of middleware execution would precisely follow the way it is configured in the <code>Program</code> class.</p>
			<p>Armed with this understanding, let's create a middleware that will be used to handle exceptions across the RESTful services of our e-commerce application, so instead of adding <code>try…catch</code> blocks in the code, we will create a middleware that gets installed at the <a id="_idIndexMarker874"/>beginning of the request pipeline and then ca<a id="_idTextAnchor1087"/><a id="_idTextAnchor1088"/>tches any<a id="_idIndexMarker875"/> exceptions throughout.</p>
			<h3>Building a cust<a id="_idTextAnchor1089"/>om middleware</h3>
			<p>As the <a id="_idIndexMarker876"/>middleware is going to be<a id="_idIndexMarker877"/> reused across all RESTful services, we will add the middleware to the <code>Packt.Ecommerce.Common</code> project inside the <code>Middlewares</code> folder.</p>
			<p>Let's first create a POCO class that represents the response in case of errors. This model will typically hold an error message, a <code>ExceptionResponse</code> inside the <code>Models</code> folder of the <code>Packt.Ecommerce.Common</code> project and add the following code to it:</p>
			<pre class="source-code">public class ExceptionResponse</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    public string ErrorMessage { get; set; }</pre>
			<pre class="source-code">    public string CorrelationIdentifier { get; set; }</pre>
			<pre class="source-code">    public string InnerException { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>Now, create another POCO class that can hold the configuration to toggle the behavior of sending an inner exception in our response. This class will be populated using the <code>Options</code> pattern, which was discussed in <a href="B18507_06_Epub.xhtml#_idTextAnchor473"><em class="italic">Chapter 6</em></a>, <em class="italic">Configuration in .NET  6</em>. Since it needs to hold only one setting, it will have one property. Add a class file named <code>ApplicationSettings</code> in the <code>Options</code> folder and then add the following code to it:</p>
			<pre class="source-code">public class ApplicationSettings</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    public bool IncludeExceptionStackInResponse { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>This class will be extended further for any configuration that will be common across all our APIs<a id="_idTextAnchor1090"/>.</p>
			<p>Navigate to the <code>Middlewares</code> folder and create a class named <code>ErrorHandlingMiddleware</code>. As we discussed, one of the key properties in any middleware is a property of the <code>RequestDelegate</code> type. Additionally, we will add a property for <code>ILogger</code> to log the exception to our logging provider, and finally, we will add a property of the <code>bool</code> <code>includeExceptionDetailsInResponse</code> type to hold a flag that<a id="_idIndexMarker878"/> controls masking the inner<a id="_idIndexMarker879"/> exception. With this, here's what the <code>ErrorHandlingMiddleware</code> class will look like:</p>
			<pre class="source-code">public class ErrorHandlingMiddleware</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">private readonly RequestDelegate requestDelegate;</pre>
			<pre class="source-code">private readonly ILogger logger;</pre>
			<pre class="source-code">private readonly bool includeExceptionDetailsInResponse;</pre>
			<pre class="source-code">}</pre>
			<p>Add a <a id="_idIndexMarker880"/>parameterized constructor where we inject <code>RequestDelegate</code> and <code>ILogger</code> for our logging provider and <code>IOptions&lt;ApplicationSettings&gt;</code> for configuration and assign them to the properties created earlier. Here, again, we are relying on the constructor injection of ASP.NET Core to instantiate the respective objects. With this, here's what the constructor of <code>ErrorHandlingMiddleWare</code> will look like:</p>
			<pre class="source-code">public ErrorHandlingMiddleware(RequestDelegate, ILogger&lt;ErrorHandlingMiddleware&gt; logger, IOptions&lt;ApplicationSettings&gt; applicationSettings)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    NotNullValidator.ThrowIfNull(applicationSettings, </pre>
			<pre class="source-code">      nameof(applicationSettings));</pre>
			<pre class="source-code">    this.requestDelegate = requestDelegate;</pre>
			<pre class="source-code">    this.logger = logger;</pre>
			<pre class="source-code">    this.includeExceptionDetailsInResponse = applicationSettings.Value.IncludeExceptionStackInResponse;</pre>
			<pre class="source-code">}</pre>
			<p>Finally, add an <code>InvokeAsync</code> method that will have the logic to process the request and then call the next middleware using <code>RequestDelegate</code>. Since t<a id="_idTextAnchor1091"/>his is an exception-handling middleware as part of our logic, all we are going to do is wrap the request in a <code>try…catch</code> block. In the <code>catch</code> block, we will log it to the respective logging provider using <code>ILogger</code>, and finally send an object, <code>ExceptionResponse</code>, back as the<a id="_idIndexMarker881"/> response. With this, here's <a id="_idIndexMarker882"/>what <code>InvokeAsync</code> will look like:</p>
			<pre class="source-code">public async Task InvokeAsync(HttpContext context)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    try</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        if (this.requestDelegate != null)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            // invoking next middleware.</pre>
			<pre class="source-code">           this.requestDelegate.Invoke(context)</pre>
			<pre class="source-code">             .ConfigureAwait(false);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    catch (Exception innerException)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        this.logger.LogCritical(1001, innerException, </pre>
			<pre class="source-code">          "Exception captured in error handling </pre>
			<pre class="source-code">           middleware"); // logging.</pre>
			<pre class="source-code">        ExceptionResponse currentException = new </pre>
			<pre class="source-code">          ExceptionResponse()</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            ErrorMessage = Constants.ErrorMiddlewareLog, </pre>
			<pre class="source-code">         // Exception captured in error handling middleware</pre>
			<pre class="source-code">            CorrelationIdentifier = </pre>
			<pre class="source-code">              System.Diagnostics.Activity.Current?.RootId,</pre>
			<pre class="source-code">        };</pre>
			<pre class="source-code">        if (this.includeExceptionDetailsInResponse)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            currentException.InnerException = </pre>
			<pre class="source-code">              $"{innerException.Message} </pre>
			<pre class="source-code">                {innerException.StackTrace}";</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        context.Response.StatusCode = </pre>
			<pre class="source-code">          StatusCodes.Status500InternalServerError;</pre>
			<pre class="source-code">        context.Response.ContentType = "application/json";</pre>
			<pre class="source-code">  await context.Response.WriteAsync(JsonSerializer.Serialize(innerException)).ConfigureAwai<a id="_idTextAnchor1092"/>t(false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Now, we can<a id="_idIndexMarker883"/> inject this middleware into the <code>Program</code> class with the following code:</p>
			<pre class="source-code">app.UseMiddleware&lt;GlobalExceptionHandlingMiddleware&gt;();</pre>
			<p>Since this is an exception handler, it is recommended to configure it as early as possible in the <code>Program</code> class so that any exceptions in all subsequent middlewares are caught. Additionally, we need to ensure that we map the <code>ApplicationSettings</code> class to a configuration, so add the following code to the <code>Program</code> class:</p>
			<pre class="source-code">Builder.Services.Configure&lt;ApplicationSettings&gt;(this.Configuration.GetSection("ApplicationSettings"));</pre>
			<p>Add the relevant section to <code>appsettings.json</code>, as follows:</p>
			<pre class="source-code">"ApplicationSettings": {</pre>
			<pre class="source-code">    "IncludeExceptionStack<a id="_idTextAnchor1093"/>InResponse": true</pre>
			<pre class="source-code">  }</pre>
			<p>Now, if <a id="_idIndexMarker884"/>there is an error in any of our APIs, the<a id="_idIndexMarker885"/> response will look like the one shown in the following code snippet:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">"ErrorMessage": "Exception captured in error handling middleware",</pre>
			<pre class="source-code">"CorrelationIdentifier": "03410a51b0475843936943d3ae04240c ",</pre>
			<pre class="source-code">"InnerException": "No connection could be made because the target machine actively refused it.    at System.Net.Http.ConnectHelper.ConnectAsync(String host, Int32 port, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.ConnectAsync(HttpRequestMessage request, Boolean allowHttp2, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.CreateHttp11ConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.GetHttpConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)\r\n   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.DiagnosticsHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at Microsoft.Extensions.Http.Logging.LoggingHttpMessageHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at Microsoft.Extensions.Http.Logging.LoggingScopeHttpMessageHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts, CancellationToken callerToken, Int64 timeoutTime)\r\n   at Packt.Ecommerce.Product.Services.ProductsService.GetProductsAsync(String filterCriteria) in src\\platform-apis\\services\\Packt.Ecommerce.Product\\Services\\ProductsService.cs:line 82\r\n   at Packt.Ecommerce.Product.Controllers.ProductsController.GetProductsAsync(String filterCriteria) in src\\platform-apis\\services\\Packt.Ecommerce.Product\\Controllers\\ProductsController.cs:line 46\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ActionMethodExecutor.TaskOfIActionResultExecutor.Execute(IActionResultTypeMapper mapper, ObjectMethodExecutor executor, Object controller, Object[] arguments)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.&lt;InvokeActionMethodAsync&gt;g__Logged|12_1(ControllerActionInvoker invoker)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.&lt;InvokeNextActionFilterAsync&gt;g__Awaited|10_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Rethrow(ActionExecutedContextSealed context)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.&lt;InvokeInnerFilterAsync&gt;g__Awaited|13_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeFilterPipelineAsync&gt;g__Awaited|19_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Logged|17_1(ResourceInvoker invoker)\r\n   at Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)\r\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\r\n   at Packt.Ecommerce.Common.Middlewares.ErrorHandlingMiddleware.InvokeAsync(HttpContext context) in src\\platform-apis\\core\\Packt.Ecommerce.Common\\Middlewares\\Err<a id="_idTextAnchor1094"/>orHandlingMiddleware.cs:line 65"</pre>
			<pre class="source-code">}</pre>
			<p>From the <a id="_idIndexMarker886"/>preceding code snippet, we<a id="_idIndexMarker887"/> can take <code>CorrelationIdentifier</code>, which is <code>03410a51b0475843936943d3ae04240c</code>, search the value in our logging provider, <strong class="bold">Application Insights</strong>, and we can ascertain additional information regarding the exce<a id="_idTextAnchor1095"/>ption, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_10.4_B18507.jpg" alt="Figure 10.4 – Tracing CorrelationIdentifier in Application Insights&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Tracing CorrelationIdentifier in Application Insights</p>
			<p><code>CorrelationIdentifier</code> is extremely helpful in production environments where there is no inner exception.</p>
			<p>This concludes<a id="_idIndexMarker888"/> our discussion <a id="_idIndexMarker889"/>regarding middleware. In the next section, let's look at what <strong class="bold">controllers</strong> and <strong class="bold">actio<a id="_idTextAnchor1096"/><a id="_idTextAnchor1097"/>ns</strong> are and how they help in handling requests.</p>
			<h1 id="_idParaDest-188">Handling request<a id="_idTextAnchor1098"/>s using controllers and actions</h1>
			<p><strong class="bold">Controllers</strong> are <a id="_idIndexMarker890"/>the <a id="_idIndexMarker891"/>fundamental<a id="_idIndexMarker892"/> blocks <a id="_idIndexMarker893"/>for handling requests for designing RESTful servicers using an ASP.NET Core web API. These are the primary classes that hold the logic to process requests, which includes retrievi<a id="_idTextAnchor1099"/>ng data from a database, inserting a record into a database, and so on. Controllers are cl<a id="_idTextAnchor1100"/>asses where we define methods to process requests. These methods usually include validating the input, talking to a data store, applying busin<a id="_idTextAnchor1101"/>ess logic (in enterprise applications, controllers will also call service classes), and—finally—serializing the response and sending it back to the client using HTTP protocols in JSON/XML form. </p>
			<p>All these methods that hold the l<a id="_idTextAnchor1102"/>ogic to process requests are known as <strong class="bold">actions</strong>. All requests received by the HTTP server are handed over to action methods using a routing engine. However, a routing engine transfers requests to actions based on certain rules that can be defined in a request pipeline. These rules are what we define in routing. Let's see <a id="_idIndexMarker894"/>how<a id="_idIndexMarker895"/> a URI<a id="_idIndexMarker896"/> for handling request<a id="_idTextAnchor1103"/><a id="_idTextAnchor1104"/>s is<a id="_idIndexMarker897"/> mapped to a particular action in a controller.</p>
			<h2 id="_idParaDest-189">Understanding<a id="_idTextAnchor1105"/> ASP.NET Core routing</h2>
			<p>Up to now, we<a id="_idIndexMarker898"/> have seen that any HTTP request goes through the middleware and is finally handed over to the controller or an endpoint defined in the <code>configure</code> method, but who is responsible for this handover to a controller/endpoint, and how does ASP.NET Core know which controller and method inside the controller to trigger? That is what the routing engine is for, and this was injected when adding the following middlewares:</p>
			<pre class="source-code">app.UseRouting();</pre>
			<pre class="source-code">app.UseEndpoints(endpoints =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">     endpoints.MapControllers();</pre>
			<pre class="source-code">});</pre>
			<p>Here, <code>app.UseRouting()</code> injects <code>Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware</code>, which is used to make all routing decisions based on the URI. The primary job of this middleware is to set the instance of the <code>Microsoft.AspNetCore.Http.Endpoint</code> method with the value of the action that needs to be executed for a particular URI.</p>
			<p>For example, if we are trying to get the details of a product according to its ID and have a product controller that has the <code>GetProductById</code> method to fulfill this request, when we make an API call to the <code>api/products/1</code> URI, putting a breakpoint in a middleware after <code>EndpointRoutingMiddleware</code> shows you that an instance of the <code>Endpoint</code> class is available with information regarding the act<a id="_idTextAnchor1106"/>ion that matches the URI and should be <a id="_idTextAnchor1107"/>executed. We can see this in the following screenshot:</p>
			<div><div><img src="img/Figure_10.5_B18507.jpg" alt="Figure 10.5 – Routing middlewares&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Routing middlewares</p>
			<p>This object would be null if there wasn't any matching controller/action. Internally, <code>EndpointRoutingMiddleware</code> uses the URI, query string parameters, and HTTP verbs and request headers to find the correct match.</p>
			<p>Once the correct action method is identified, it's the job of <code>app.UseEndPoints</code> to hand over control to the action method identified by the <code>Endpoint</code> object and execute it. <code>UseEndPoints</code> injects <code>Microsoft.AspNetCore.Routing.EndpointMiddleware</code> to execute the appropriate method to fulfill a request. One important aspect of populating an appropriate <code>EndPoint</code> object is the various URIs that are configured inside <code>UseEndPoints</code> that can be achieved through the static extension methods available in ASP.NET Core. For <a id="_idIndexMarker899"/>example, if we want to configure just controllers, we can use <code>MapControllers</code> extension methods, which add endpoints for all actions in controllers for <code>UseRouting</code> to match further. If we are building RESTful APIs, it is recommended to use <code>MapControllers</code> extensions. However, there are many such extension methods for the following exten<a id="_idTextAnchor1108"/>sions that are commonly used:</p>
			<ul>
				<li><code>MapGet</code>/<code>MapP<a id="_idTextAnchor1109"/>ost</code>: These are extension methods that can match specific patterns for <code>GET</code>/<code>POST</code> verbs and execute the request. They accept two parameters, one being the pattern of the URI and the second being the request delegate that can be used to execute when the pattern is matched. For example, the following code can be used to match the <code>/aboutus</code> route and respond with the text <code>Welcome to default products route</code>:<pre>endpoints.MapGet("/aboutus", async context =&gt;
{
await context.Response.WriteAsync("Welc<a id="_idTextAnchor1110"/>ome to default products route");
});</pre></li>
				<li><code>MapRazorPages</code>: This extension method is used if we are using Razor Pages and need to route to app<a id="_idTextAnchor1111"/>ropriate pages based on routes.</li>
				<li><code>MapControllerRoute</code>: This extension method can be used to match controllers with a specific pattern; for example, the following code can be seen in the ASP.NET Core MVC template, which matches methods based on a pattern:<pre>endpoints.MapControllerRoute(
name: "default",
pattern: "{controller=Home}/{action=Index}/{id?}");</pre></li>
			</ul>
			<p>The request URI is split based on the forward slash (<code>/</code>) and is matched to the controller, action method, and ID. So, if you wanted to match a method in a controller, you need to pass the controller name (ASP.NET Core automatically suffixes the <code>controller</code> keyword) and<a id="_idIndexMarker900"/> method name in the URI. </p>
			<p>Optionally, the ID can be passed as a parameter to that method. For example, if I have <code>GetProducts</code> in <code>ProductsController</code>, you would be calling it using the absolute URI, <code>products/GetProducts</code>. This kind <a id="_idTextAnchor1112"/>of routing is known as <strong class="bold">conventional routing</strong> and is a<a id="_idIndexMarker901"/> good fit for UI-based web applications, and so can be seen in the ASP.NET Core MVC template.</p>
			<p>This concludes our discussion of the basics of routing; there are many such extension methods available in ASP.NET Core that can be plumbed into the request pipeline based on application requirements. Now, let's look at attribute-based routing, a routing technique recommended for RESTful services built using ASP.NET Core.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Another<a id="_idIndexMarker902"/> important aspect of routing, as with any other middleware sequence, is that injection is very impor<a id="_idTextAnchor1113"/><a id="_idTextAnchor1114"/>tant, and <code>UseRouting</code> should be called before <code>UseEndpoints</code>.<a id="_idTextAnchor1115"/></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor1116"/>Attribute-based routing</h2>
			<p>For RESTful <a id="_idIndexMarker903"/>services, conventional routing contravenes a few REST principles, especially the principle that states that the operation on entities performed by the action method should be based on HTTP verbs; so, ideally, in order to get products, the URI should be <code>GET api/products</code>. </p>
			<p>This is where attribute-based routing comes into play, in which routes are defined using attributes either at the controller level or at the action method level, or both. This is achieved using the <code>Microsoft.AspNetCore.Mvc.Route</code> attribute, which takes a string value as an input parameter and is used to map the controller and action. Let's take an example of <code>ProductsController</code>, which has the following code:</p>
			<pre class="source-code">[Route("api/[controller]")]</pre>
			<pre class="source-code">[ApiController]</pre>
			<pre class="source-code">public class ProductsController : ControllerBase</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    [HttpGet]</pre>
			<pre class="source-code">    [Route("{id}")]</pre>
			<pre class="source-code">    public IActionResult GetProductById(int id)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return Ok($"Product {id}");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    [HttpGet]</pre>
			<pre class="source-code">    public IActionResult GetProducts()</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return Ok("Products");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, in the <code>Route</code> attribute at the controller level, we are passing the value <code>api/[controller]</code>, which means that any URI matching <code>api/products</code> is mapped to this controller, where <code>products</code> is the name of the controller. Using the <code>controller</code> keyword inside square brackets is a specific way of telling ASP.NET Core to map the controller name automatically to the route. </p>
			<p>However, if you want to stick to a specific name irrespective of the controller name, this ca<a id="_idTextAnchor1117"/>n be used without square brackets. As a best practice, it is recommended to decouple controller names with routes. Hence, for our e-commerce application, we will go with exact values in routes—that is, <code>ProductsController</code> will have a route prefix of <code>[Route("api/products")]</code>.</p>
			<p>The <code>Route</code> attribute can also be added to action methods and can be used to additionally identify specific methods uniquely. Here, we are also passing a string that can be used to<a id="_idIndexMarker904"/> identify the method. For example, <code>[Route("GetProductById/{id}")]</code> would be matched to the <code>api/products/GetProductById/1</code> URI, and the value inside the curly brackets is a dynamic value that can be passed as a parameter to the action method and matched with the parameter name. </p>
			<p>What this means is that in the preceding code, there is an ID parameter, and the value inside the curly brackets should also be named <code>ID</code> so that ASP.NET Core can map values from the URI to the <code>method</code> parameter. Hence, for the <code>api/products/1</code> URI, the ID parameter in the <code>GetProductById</code> method will have a value of <code>1</code> if the route attribute looks like this: <code>[Route("{id}")]</code>.</p>
			<p>Finally, the HTTP verb is represented by attributes such as <code>[HttpG<a id="_idTextAnchor1118"/>et]</code>, which will be used to map the HTTP verb from the URI to the method. The following table shows various examples and possible matches, as<a id="_idTextAnchor1119"/>suming that <code>ProductsController</code> has <code>[Route("api/products")]</code>:</p>
			<div><div><img src="img/Table_10.1.jpg" alt="Table 10.1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 10.1</p>
			<p>As you can see, the <a id="_idIndexMarker905"/>name of the method is immaterial here and so is not part of the URI matching unless it is specified in the <code>Route</code> attribute.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">One important aspect is that the web API supports the reading of parameters from various locations within a request, be it in the request body, header, query string, or URI. The following documentation covers the various options available: <a href="https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference">https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference</a>.</p>
			<p>A summary of an entire A<a id="_idTextAnchor1121"/>PI routing in ASP.NET Core could be represented as follows:</p>
			<div><div><img src="img/Figure_10.6_B18507.jpg" alt="Figure 10.6 – ASP.NET Core API routing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure<a id="_idTextAnchor1122"/> 10.6 – ASP.NET Core API routing</p>
			<p>Attribute-based routing is more RESTful, and we will follow this kind of routing in our e-commerce services. Now, let's look at the various helper classes available in ASP.NET Core that can <a id="_idIndexMarker906"/>be used to simplify the building of RESTful services.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <code>{id}</code> expression in routing is <a id="_idIndexMarker907"/>known as a <strong class="bold">routing constraint</strong>, and ASP.NET Core comes with a varied set of such routing constraints that can also be found here: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0#route-constraint-reference">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0#route-constraint-reference</a>.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor1125"/>The ControllerBase class, the ApiController attribute, and the ActionResult class</h2>
			<p>If we go <a id="_idIndexMarker908"/>back<a id="_idIndexMarker909"/> to any of the controllers created <a id="_idIndexMarker910"/><a id="_idTextAnchor1126"/>hitherto, you can see that all the controllers are inherited from the <code>ControllerBase</code> class. In ASP.NET Core, <code>ControllerBase</code> is an abstract class that provides various helper methods that assist in handling requests and responses. For example, if I wanted to send an HTTP status code <code>400</code> (bad request), there is a <code>BadRequest</code> helper method in <code>ControllerBase</code> that can be used to send an HTTP status code of <code>400</code>; otherwise, we have to manually create an object and populate it with the HTTP status code <code>400</code>. There are many such helper methods in <code>ControllerBase</code> that are available out of the box; however, not every API controller needs to be inherited from the <code>ControllerBase</code> class. All helper methods from the <code>ControllerBase</code> class are mentioned here: <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&amp;viewFallbackFrom=aspnetcore-6.0">https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&amp;viewFallbackFrom=aspnetcore-6.0</a>.</p>
			<p>This brings us to a discussion as to what the return type of our controller methods should be because there could be at least two possible responses for any API in general, as follows:</p>
			<ul>
				<li>A successful response with a 2xx status code that possibly responds with a resource or a list of resources</li>
				<li>A validation failure case with a 4xx status code</li>
			</ul>
			<p>To <a id="_idIndexMarker911"/>handle<a id="_idIndexMarker912"/> such scenarios, we need to<a id="_idIndexMarker913"/> create a generic type that can be used to send different response types, and this is where ASP.NET Core's <code>IActionResult</code> and <code>ActionResult</code> types come into play, providing us<a id="_idTextAnchor1127"/> with derived response types for various scenarios. A few important response types that <code>IActionResult</code> supports are listed here:</p>
			<ul>
				<li><code>OkObjectResult</code>: This is a response type that sets the HTTP status code to <code>200</code> and adds the resource to the body of the response containing the details of the resource. This type is ideal for all APIs that respond with a resource or a list of resources—for example, get products.</li>
				<li><code>NotFoundResult</code>: This is a response type that sets the HTTP status code to <code>404</code> and has an empty body. This can be used if a particular resource is not found. However, in the case of a resource not found, we will use <code>NoContentResult</code> (<code>204</code>), as <code>404</code> will also be used for an API not found.</li>
				<li><code>BadRequestResult</code>: This is a response type that sets the HTTP status code to <code>400</code> and contains an error message in the response body. This is ideal for any validation failures.</li>
				<li><code>CreatedAtActionResult</code>: This is a response type that sets the HTTP status code to <code>201</code> and can add the newly created resource URI to the respons<a id="_idTextAnchor1128"/>e. This is ideal for APIs that create resources.</li>
			</ul>
			<p>All these response types are inherited from <code>IActionResult</code>, and there are methods available in the <code>ControllerBase</code> class that can create these objects; so, <code>IActionResult</code>, along with <code>ControllerBase</code>, would solve most of the business requirements, and this is what we will have as the return type for all our API controller methods.</p>
			<p>The final important class available in ASP<a id="_idTextAnchor1129"/>.NET Core that comes in handy is the <code>ApiController</code> class, which <a id="_idIndexMarker914"/>can be added as an attribute <a id="_idIndexMarker915"/>to the <a id="_idIndexMarker916"/>controller class or to an assembly, and adds the following behaviors to our controllers:</p>
			<ul>
				<li>It disables conventional routing and makes attribute-based routing mandatory.</li>
				<li>It validates models automatically, so we don't need to explicitly call <code>ModelState.IsValid</code> in every method. This behavior is very useful in the case of insert/update methods.</li>
				<li>It facilitates automatic parameter mapping from the body/route/header/query strings. What this means is that we don't specify whether a parameter of an API is going to be part of the body or route. For example, in the following code snippet, we don't need to explicitly say that the ID par<a id="_idTextAnchor1130"/>ameter is going<a id="_idTextAnchor1131"/> to be part of the route as <code>ApiController</code> automatically uses something known as <code>[FromRoute]</code>:<pre>[Route("{id}")]
public IActionResult GetProductById(int id)
{
  return Ok($"Product {id}");
}</pre></li>
				<li>Similarly, in the following code snippet, <code>ApiController</code> will automatically add <code>[FromBody]</code> based on the inference rules:<pre>public IActionResult CreateProduct(Product product)
{
//
}</pre></li>
				<li>A couple of other behaviors that <code>ApiController</code> adds are inferring request content to multipart/form data and more detailed error responses, as per <a href="https://tools.ietf.org/html/rfc7807.">https://tools.ietf.org/html/rfc7807.</a></li>
			</ul>
			<p>So, all in all, <code>ControllerBase</code>, <code>ApiController</code>, and <code>ActionResult</code> provide various helper methods and behaviors, thereby providing developers with all the tools needed to <a id="_idIndexMarker918"/>write <a id="_idIndexMarker919"/>RESTful APIs and allowing them to <a id="_idIndexMarker920"/>focus on business logic while writing APIs using ASP.NET Core.</p>
			<p>With this foundation, let<a id="_idTextAnchor1132"/><a id="_idTextAnchor1133"/>'s design various APIs for our e-commerce application in the ne<a id="_idTextAnchor1134"/>xt section.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor1135"/>Integration with the data layer</h1>
			<p>The response <a id="_idIndexMarker921"/>from our APIs may or may not look like our domain models. Instead, their structure can resemble the fields that the UI or Views need to bind; hence, it is recommended to create<a id="_idTextAnchor1136"/> a separate set of POCO classes that integrate with our UI. These POCOs are<a id="_idIndexMarker922"/> known as <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>).</p>
			<p>In this section, we will implement our DTOs' domain logic integrating with the data layer and integrate the cache services discussed in <a href="B18507_08_Epub.xhtml#_idTextAnchor714"><em class="italic">Chapter 8</em></a>, <em class="italic">All You Need to Know about Caching</em>, using the Cache-Aside pattern, and then—finally—implement th<a id="_idTextAnchor1137"/>e required RESTful APIs using controllers and actions. Along the way, we will use the <code>HTTPClient</code> factory for our service-to-service communication, and the <code>AutoMapper</code> library for mapping domain models to DTOs.</p>
			<p>We will pick a product service that is part of <code>Packt.Ecommerce.Product</code>, a web API project<a id="_idIndexMarker923"/> using .NET 6, and discuss its implementation in detail. By the end of this section, we<a id="_idTextAnchor1138"/> will have implemented the projects highlighted in the following scr<a id="_idTextAnchor1139"/>eenshot:</p>
			<p class="figure-caption"><img src="img/Figure_10.7_B18507.png" alt="Figure 10.7 – Product service and DTOs&#13;&#10;"/></p>
			<p class="figure-caption">Figure 10.7 – Product service and DTOs</p>
			<p>A similar implementation is replicated across all RESTful services with slight modifications in business logic, as required, but the high-level implementation remains the same across the following various services:</p>
			<ul>
				<li><code>Packt.Ecommerce.DataAccess</code></li>
				<li><code>Packt.Ecommerce.Invoice</code></li>
				<li><code>Packt.Ecommerce.Order</code></li>
				<li><code>Packt.Ecommerce.Payment</code></li>
				<li><code>Packt.Ecommerce.UserManagement</code></li>
			</ul>
			<p>To start with, we<a id="_idIndexMarker924"/> will have the corresponding section in <code>appsettings.json</code>, which is shown as follows:</p>
			<pre class="source-code">    "ApplicationSettings": {</pre>
			<pre class="source-code">    "UseRedisCache": false, // For in-memory</pre>
			<pre class="source-code">    "IncludeExceptionStackInResponse": true,</pre>
			<pre class="source-code">    "DataStoreEndpoint": "",</pre>
			<pre class="source-code">    "InstrumentationKey": <a id="_idTextAnchor1140"/>""</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  "ConnectionStrings": {</pre>
			<pre class="source-code">    "Redis": ""</pre>
			<pre class="source-code">  }</pre>
			<p>For the local development environment, we will use <strong class="bold">Manage User Secrets</strong> (as explained at <a href="https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&amp;tabs=windows">https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&amp;tabs=windows</a>) and set the following values. However, once the service is deployed, it will make use of Azure Key Vault, as explained in <a href="B18507_06_Epub.xhtml#_idTextAnchor473"><em class="italic">Chapter 6</em></a>, <em class="italic">Configuration in .NET 6</em>:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "ApplicationSettings:InstrumentationKey": "", //relevant </pre>
			<pre class="source-code">                                                //key</pre>
			<pre class="source-code">  "ConnectionStrings:Redis"<a id="_idTextAnchor1141"/><a id="_idTextAnchor1142"/>: "" //connection string</pre>
			<pre class="source-code">}</pre>
			<p>Let's b<a id="_idTextAnchor1143"/>egin<a id="_idIndexMarker925"/> by creating DTOs for the Products API.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor1144"/>Creating DTOs</h2>
			<p>The key <a id="_idIndexMarker926"/>requirements in terms of product services are to provide the ability to search for products, view additional details relating to the products, and then proceed with the purchase. Since a listing of products can have limited details, let's create a POCO (all DTOs are created in the <code>Packt.Ecommerce.DTO.Models</code> project) and name it <code>ProductListViewModel</code>. This class will have all the properties that we want to show on the product's list page, and it should look like this:</p>
			<pre class="source-code">public class ProductListViewModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        [JsonProperty(PropertyName = "id")]</pre>
			<pre class="source-code">        public string Id { get; set; }</pre>
			<pre class="source-code">        public string Name { get; set; }</pre>
			<pre class="source-code">        public int Price { get; set; }</pre>
			<pre class="source-code">        public Uri ImageUrl { get; set; }</pre>
			<pre class="source-code">        public double AverageRating { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, these are minimum fields that are usually displayed on any e-commerce application. Hence, we will go with these fields, but the idea is to extend as the application evolves. Here, the <code>Id</code> and <code>Name</code> properties are important properties as those will be used to query the database once the user wants to retrieve all further details regarding the product. We are annotating the <code>Id</code> property with the <code>JsonProperty(PropertyName = "id")</code> attribute to ensure that the property name remains as <code>Id</code> during serialization and deserialization. This is important because, in our Cosmos DB instance, we are using <code>Id</code> as the key for most of the containers. Let's now create another POCO that represents the details of a product, as shown in the following<a id="_idIndexMarker927"/> code snippet:</p>
			<pre class="source-code">public class ProductDetailsViewModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        public string Id { get; set; }</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        public string Name { get; set; }</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        public string Category { get; set; }</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        [Range(0, 9999)]</pre>
			<pre class="source-code">        public int Price { get; set; }</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        [Range(0, 999, ErrorMessage = "Large quantity, </pre>
			<pre class="source-code">         please reach out to support to process request.")]</pre>
			<pre class="source-code">        public int Quantity { get; set; }</pre>
			<pre class="source-code">        public DateTime CreatedDate { get; set; }</pre>
			<pre class="source-code">        public List&lt;string&gt; ImageUrls { get; set; }</pre>
			<pre class="source-code">        public List&lt;RatingViewModel&gt; Rating { get; set; }</pre>
			<pre class="source-code">        public List&lt;string&gt; Format { get; set; }</pre>
			<pre class="source-code">        public List&lt;string&gt; Authors { get; set; }</pre>
			<pre class="source-code">        public List&lt;int&gt; Size { get; set; }</pre>
			<pre class="source-code">        public List&lt;string&gt; Color { get; set; }</pre>
			<pre class="source-code">        public string Etag { get; set; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public class RatingViewModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        public int Stars { get; set; }</pre>
			<pre class="source-code">        public int Percentage { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>So, in this DTO, apart from <code>Id</code> and <code>Name</code>, one of the important properties is <code>Etag</code>, which will be used for entity tracking to avoid concurren<a id="_idTextAnchor1145"/>t overwrites on an entity. For example, if two users access a product and user A updates it before user B, using <code>Etag</code>, we can stop user B from overwriting user A's changes and force user B to take the latest copy of the product prior to updating. The <code>AddProductAsync(ProductDetailsViewModel product)</code> method in <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers</a> follows this pattern.</p>
			<p>Another<a id="_idIndexMarker928"/> important aspect is that we are using ASP.NET Core's built-in validation attributes on our model to define all constraints on the models. Primarily, we will be using the <code>[Required]</code> attribute and any relevant attributes, as per <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes">https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes</a>.</p>
			<p>All the DTOs would be part of the <code>Packt.Ecommerce.DTO.Models</code> project as they will be<a id="_idIndexMarker929"/> reused in our ASP.NET MVC application, which will be used to build the UI of our e-comme<a id="_idTextAnchor1146"/><a id="_idTextAnchor1147"/>rce application. Now, let's look at the contracts needed for the <code>Products</code> service.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor1148"/>Service-class contracts</h2>
			<p>Add <a id="_idTextAnchor1149"/>a <code>Contracts</code> folder <a id="_idIndexMarker930"/>to <code>Packt.Ecommerce.Product</code> and create a contract/interface of a product's service class, for which we will refer to our requirements and define methods as needed. To start with, it will have all the methods to <a id="_idIndexMarker931"/>perform <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations on products based on that interface, and these will look like this:</p>
			<pre class="source-code">public interface IProductService</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        Task&lt;IEnumerable&lt;ProductListViewModel&gt;&gt; </pre>
			<pre class="source-code">          GetProductsAsync(string filterCriteria = null);</pre>
			<pre class="source-code">        Task&lt;ProductDetailsViewModel&gt; </pre>
			<pre class="source-code">          GetProductByIdAsync(string productId, </pre>
			<pre class="source-code">            string productName);</pre>
			<pre class="source-code">        Task&lt;ProductDetailsViewModel&gt; </pre>
			<pre class="source-code">          AddProductAsync(ProductDetailsViewModel product);</pre>
			<pre class="source-code">        Task&lt;HttpResponseMessage&gt; </pre>
			<pre class="source-code">          UpdateProductAsync(ProductDetailsViewModel </pre>
			<pre class="source-code">            product);</pre>
			<pre class="source-code">        Task&lt;HttpResponseMessage&gt; DeleteProduct<a id="_idTextAnchor1150"/>Async(</pre>
			<pre class="source-code">          string productId, string productName);</pre>
			<pre class="source-code">    }</pre>
			<p>Here, you can<a id="_idIndexMarker932"/> see that we are returning <code>Task</code> in all methods, thereby sticking to our<a id="_idTextAnchor1151"/><a id="_idTextAnchor1152"/> asynchronous approach discussed in <a href="B18507_04_Epub.xhtml#_idTextAnchor205"><em class="italic">Chapter 4</em></a>, <em class="italic">Threading and Asynchronous Operations</em>.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor1153"/>The mapper class using AutoMapper</h2>
			<p>The next thing <a id="_idIndexMarker933"/>that we will need is a <a id="_idTextAnchor1154"/>way to transform our <a id="_idIndexMarker934"/>domain models to DTOs, and here, we will use a well-known library called <code>AutoMapper</code> (please refer to <a href="https://docs.automapper.org/en/stable/Getting-started.html">https://docs.automapper.org/en/stable/Getting-started.html</a> for more details) to configure and add the following packages:</p>
			<ul>
				<li><code>Automapper</code></li>
				<li><code>AutoMapper.Extensions.Microsoft.DependencyInjection</code></li>
			</ul>
			<p>To configure <code>AutoMapper</code>, we need to define a class that inherits from <code>AutoMapper.Profile</code> and then defines the mapping between various domain models and DTOs. Let's add an <code>AutoMapperProfile</code> class to the <code>Packt.Ecommerce.Product</code> project, as follows:</p>
			<pre class="source-code">    public class AutoMapperProfile : Profile</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        public AutoMapperProfile()</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<p><code>AutoMapper</code> comes with many inbuilt methods for mapping, one of these being <code>CreateMap</code>, which accepts source and destination classes and maps them based on the same property <a id="_idIndexMarker935"/>names. Any property that does not have the same<a id="_idIndexMarker936"/> name can be manually mapped using the <code>ForMember</code> method. Since <code>ProductDetailsViewModel</code> has a one-to-one mapping with our domain model, <code>CreateMap</code> should be good enough for their mapping. For <code>ProductListV<a id="_idTextAnchor1155"/>iewModel</code>, we have an additional field, <code>AverageRating</code>, for which we wanted to calculate the average of all the ratings given for a particular product. To keep it simple, we will use the <code>Average</code> method from <code>Linq</code> and then map it to the average rating. For modularization, we will have this in a separate method, <code>MapEntity</code>, which looks like this:</p>
			<pre class="source-code">private void MapEntity()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">            this.CreateMap&lt;Data.Models.Product, </pre>
			<pre class="source-code">              DTO.Models.ProductDetailsViewModel&gt;();</pre>
			<pre class="source-code">            this.CreateMap&lt;Data.Models.Rating, </pre>
			<pre class="source-code">              DTO.Models.RatingViewModel&gt;();</pre>
			<pre class="source-code">            this.CreateMap&lt;Data.Models.Product, </pre>
			<pre class="source-code">              DTO.Models.ProductListViewModel&gt;()</pre>
			<pre class="source-code">                .ForMember(x =&gt; x.AverageRating, o =&gt; </pre>
			<pre class="source-code">                  o.MapFrom(a =&gt; a.Rating != null ? </pre>
			<pre class="source-code">                  a.Rating.Average(y =&gt; y.Stars) : 0));</pre>
			<pre class="source-code">}</pre>
			<p>Now, modify the constructor to call this method. Refer to <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs</a> for the complete implementation.</p>
			<p>The final step involved in setting up <code>AutoMapper</code> is to inject it as one of the services, for which we will use the <code>WebApplicationBuilder</code> object of the <code>Program</code> class, using the following line of code:</p>
			<pre class="source-code">Builder.Services.AddAutoMapper(typeof(AutoMapperProfile));</pre>
			<p>As explained earlier, this will inject the <code>AutoMapper</code> library into our API, and this will then allow us <a id="_idIndexMarker937"/>to <a id="_idIndexMarker938"/>inject <code>AutoMapper</code> into various services and controllers. Let's now look at the <a id="_idTextAnchor1156"/><a id="_idTextAnchor1157"/>configuration of the <code>HttpClient</code> factory, which is used for calling th<a id="_idTextAnchor1158"/>e data access service.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor1159"/>HttpClient factory for service-to-service calls</h2>
			<p>To retrieve<a id="_idIndexMarker939"/> data, we must call APIs exposed by<a id="_idIndexMarker940"/> our data access service defined in <code>Packt.Ecommerce.DataAccess</code>. For this, we need a resilient library that can effectively use the available sockets, allowing us to define a circuit breaker as well as retry/timeout policies. <code>IHttpClientFactory</code> is ideal for such scenarios.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">One common issue with <code>HttpClient</code> is the potential <code>SocketException</code> error, which happens as <code>HttpClient</code> leaves<a id="_idIndexMarker941"/> the <code>HttpClient</code> as a static/singleton—which has its own overheads—while connecting to multiple services. These issues are summarized at <a href="https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests">https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests</a>, and these are all now addressed by <code>IhttpClientFactory</code>.</p>
			<p>To configure <code>IHttpClientFactory</code>, perform the following steps:</p>
			<ol>
				<li value="1">Install <code>Microsoft.Extensions.Http</code>.</li>
				<li>We will be configuring <code>IHttpClientFactory</code> using typed clients, so add a <code>Services</code> folder and a <code>ProductsService</code> class and inherit them from <code>IProductService</code>. For now, leave the implementation empty. Now, map <code>IProductService</code> and <code>ProductsService</code> in the <code>Program</code> class using the following code:<pre>builder.Services.AddHttpClient&lt;IProductService, ProductsService&gt;()
       .SetHandlerLifetime(TimeSpan.FromMinutes(5))
       .AddPolicyHandler(RetryPolicy()) // Retry 
                                        // policy.
       .AddPolicyHandler(CircuitBreakerPolicy()); 
       // Circuit breakerpo<a id="_idTextAnchor1160"/>licy</pre></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker942"/>are <a id="_idIndexMarker943"/>defining the timeout for <code>HttpClient</code> used by <code>ProductsService</code> as <code>5</code> minutes and additionally configuring a policy for retrie<a id="_idTextAnchor1161"/>s and a circuit breaker.</p>
			<h3>Implementing a circuit-breaker policy</h3>
			<p>To define<a id="_idIndexMarker944"/> these<a id="_idIndexMarker945"/> policies, we will use a library called <code>Polly</code> (refer to <a href="https://github.com/App-vNext/Polly">https://github.com/App-vNext/Polly</a> for the official documentation), which gives out-of-the-box resiliency and fault-handling capabilities. Install the <code>Microsoft.Extensions.Http.Polly</code> package and then add the following static method to the <code>Program</code> class that defines our circuit-breaker policy:</p>
			<pre class="source-code">static IAsyncPolicy&lt;HttpResponseMessage&gt; CircuitBreakerPolicy()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return HttpPolicyExtensions</pre>
			<pre class="source-code">        .HandleTransientHttpError()</pre>
			<pre class="source-code">        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30));</pre>
			<pre class="source-code">}</pre>
			<p>Here, we are saying that the circuit would be opened if there are 5 failures within 30 seconds. A circuit breaker assists in avoiding unnecessary HTTP calls where there is a <a id="_idTextAnchor1162"/>critical failure<a id="_idIndexMarker946"/> that<a id="_idIndexMarker947"/> cannot be fixed with a retry.</p>
			<h3>Implementing a retry policy</h3>
			<p>Now, let's add <a id="_idIndexMarker948"/>our <a id="_idIndexMarker949"/>retry policy, which is a bit smarter compared with the standard retries that retire within a specified timeframe. So, we define a policy that will affect a retry and HTTP service calls on five occasions, and each retry would have a time difference in seconds at a rate of power of two. The code is illustrated here: </p>
			<p>To add some randomness in terms of the time variation, we will use a <code>Random</code> class of C# to generate a random number and add it to the time gap. This random generation will be as shown in the following code:</p>
			<pre class="source-code">private static IAsyncPolicy&lt;HttpResponseMessage&gt; RetryPolicy()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    Random random = new Random();</pre>
			<pre class="source-code">    var retryPolicy = HttpPolicyExtensions</pre>
			<pre class="source-code">        .HandleTransientHttpError()</pre>
			<pre class="source-code">        .OrResult(msg =&gt; msg.StatusCode == </pre>
			<pre class="source-code">          System.Net.HttpStatusCode.NotFound)</pre>
			<pre class="source-code">        .WaitAndRetryAsync(</pre>
			<pre class="source-code">        5,</pre>
			<pre class="source-code">        retry =&gt; TimeSpan.FromSeconds(Math.Pow(2, retry))</pre>
			<pre class="source-code"><a id="_idTextAnchor1163"/>         + TimeSpan.FromMilliseconds(random.Next(0, 100)));</pre>
			<pre class="source-code">    return retryPolicy;</pre>
			<pre class="source-code">}</pre>
			<p>Here, <code>retry</code> is an integer that increments by one with every retry. With this, add a static method to the <code>Program</code> class that has the preceding logic.</p>
			<p>This completes our <code>HTTPClient</code> factory configuration, and <code>ProductsService</code> can use constructor injection to instantiate <code>IHttpClientFactory</code>, which can be further used to create <code>HttpClient</code>.</p>
			<p>With a<a id="_idTextAnchor1164"/><a id="_idTextAnchor1165"/>ll <a id="_idIndexMarker950"/>this<a id="_idIndexMarker951"/> configuration, we can now imp<a id="_idTextAnchor1166"/>lement our service class. Let's look at that in the next section.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor1167"/>Implementing service classes</h2>
			<p>Let's now <a id="_idIndexMarker952"/>implement <code>ProductsService</code>, starting by defining various properties that we have now built and instantiating them using constructor injections, as shown in the following code block:</p>
			<pre class="source-code">private readonly IOptions&lt;ApplicationSettings&gt; applicationSettings;</pre>
			<pre class="source-code">private readonly HttpClient httpClient;</pre>
			<pre class="source-code">private readonly IMapper autoMapper;</pre>
			<pre class="source-code">private readonly IDistributedCacheService cacheService;</pre>
			<pre class="source-code">public ProductsService(IHttpClientFactory httpClientFactory, IOptions&lt;ApplicationSettings&gt; applicationSettings, IMapper autoMapper, IDistributedCacheService cacheService)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    NotNullValidator.ThrowIfNull(applicationSettings, </pre>
			<pre class="source-code">      nameof(applicationSettings));</pre>
			<pre class="source-code">    IHttpClientFactory httpclientFactory = </pre>
			<pre class="source-code">      httpClientFactory;</pre>
			<pre class="source-code">    this.applicationSettings = applicationSettings;</pre>
			<pre class="source-code">    this.httpClient = httpclientFactory.CreateClient();</pre>
			<pre class="source-code">    this.autoMapper = autoMapper;</pre>
			<pre class="source-code">    this.cacheService = cacheService;</pre>
			<pre class="source-code">}</pre>
			<p>All our services are going to use the same exception-handling middleware we defined in this chapter, so during service-to-service calls, if there is a failure in another service, the response would be of the <code>ExceptionResponse</code> type. Hence, let's create a private method, so<a id="_idIndexMarker953"/> deserialize the <code>ExceptionResponse</code> class and raise it accordingly. This is required because <code>HttpClient</code> would represent success or failure while using the <code>IsSuccessStatusCode</code> and <code>StatusCode</code> properties, so if there is an exception, w<a id="_idTextAnchor1168"/>e need to check <code>IsSuccessStatusCode</code> and rethrow it. Let's call this method <code>ThrowServiceToServiceErrors</code> and refer to the following code snippet:</p>
			<pre class="source-code">private async Task ThrowServiceToServiceErrors(HttpResponseMessage response)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    var exceptionReponse = await response.Content.ReadFromJsonAsync&lt;ExceptionResponse&gt;().ConfigureAwait(false);</pre>
			<pre class="source-code">    throw new Exception(exceptionReponse.InnerException);</pre>
			<pre class="source-code">}</pre>
			<p>Let's now implement the <code>GetProductsAsync</code> method, in which we will use <code>CacheService</code> to retrieve data from the cache, and if it is not available in the cache, we will ca<a id="_idTextAnchor1169"/>ll the data access service using <code>HttpClient</code>, and finally map the <code>Product</code> domain's model to<a id="_idIndexMarker954"/> a DTO and return it asynchronously. The code will look like this:</p>
			<pre class="source-code">public async Task&lt;IEnumerable&lt;ProductListViewModel&gt;&gt; GetProductsAsync(string filterCriteria = null)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    var products = await this.cacheService</pre>
			<pre class="source-code">      .GetCacheAsync&lt;IEnumerable&lt;Packt.Ecommerce</pre>
			<pre class="source-code">      .Data.Models.Product&gt;&gt;($"products{filterCriteria}")</pre>
			<pre class="source-code">      .ConfigureAwait(false);</pre>
			<pre class="source-code">    if (products == null)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        using var productRequest = new </pre>
			<pre class="source-code">          HttpRequestMessage(HttpMethod.Get, </pre>
			<pre class="source-code">          $"{this.applicationSettings.Value</pre>
			<pre class="source-code">           .DataStoreEndpoint}api/products</pre>
			<pre class="source-code">           ?filterCriteria={filterCriteria}");</pre>
			<pre class="source-code">        var productResponse = await this.httpClient</pre>
			<pre class="source-code">         .SendAsync(productRequest).ConfigureAwait(false);</pre>
			<pre class="source-code">        if (!productResponse.IsSuccessStatusCode)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            await this.ThrowServiceToServiceErrors(</pre>
			<pre class="source-code">              productResponse).ConfigureAwait(false);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        products = await productResponse.Content</pre>
			<pre class="source-code">          .ReadFromJsonAsync&lt;IEnumerable&lt;Packt</pre>
			<pre class="source-code">          .Ecommerce.Data.Models.Product&gt;&gt;()</pre>
			<pre class="source-code">          .ConfigureAwait(false);</pre>
			<pre class="source-code">        if (products.Any())</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            await this.cacheService.AddOrUpdateCacheAsync</pre>
			<pre class="source-code">              &lt;IEnumerable&lt;Packt.Ecommerce.Data.Models</pre>
			<pre class="source-code">             .Product&gt;&gt;($"products{filterCriteria}", </pre>
			<pre class="source-code">             products).ConfigureAwait(false);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    var productList = t<a id="_idTextAnchor1170"/>his.autoMapper.Map&lt;List</pre>
			<pre class="source-code">      &lt;ProductListViewModel&gt;&gt;(products);</pre>
			<pre class="source-code">    return productList;</pre>
			<pre class="source-code">}</pre>
			<p>We will follow a similar pattern and implement <code>AddProductAsync</code>, <code>UpdateProductAsync</code>, <code>GetProductByIdAsync</code>, and <code>DeleteProductAsync</code>. The only difference in each of these methods would be to use the relevant <code>HttpClient</code> me<a id="_idTextAnchor1171"/><a id="_idTextAnchor1172"/>thod <a id="_idIndexMarker955"/>and handle them accordingly. Now that we have our service impl<a id="_idTextAnchor1173"/>emented, let's implement our controller.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor1174"/>Implementing action methods in the controller</h2>
			<p>Let's first inject<a id="_idIndexMarker956"/> the service created in the previous<a id="_idIndexMarker957"/> section into the ASP.NET Core 6 DI container so that we can use constructor injection to create an object of <code>ProductsService</code>. We will do this in the <code>Program</code> class using the following code:</p>
			<pre class="source-code">builder.Services.AddScoped&lt;IProductService, ProductsService&gt;();</pre>
			<p>Also, ensure that all the required framework components—such as <code>ApplicationSettings</code>, <code>CacheService</code>, and <code>AutoMapper</code>—are configured.</p>
			<p>Add a controller to the <code>Controllers</code> folder and name it <code>ProductsController</code> with the default route as <code>api/products</code>, and then add an <code>IProductService</code> property and inject it using constructor injection. The controller should implement five action methods, each calling one of the service methods, and use various out-of-the-box helper methods and attributes discussed in <em class="italic">The ControllerBase class, the</em> <em class="italic">ApiController attribute, and the ActionResult class</em> section of this chapter. The methods for retrieving<a id="_idIndexMarker958"/> specific products and <a id="_idIndexMarker959"/>creating a new product are shown in the following code block:</p>
			<pre class="source-code">[HttpGet]</pre>
			<pre class="source-code">[Route("{id}")]</pre>
			<pre class="source-code">public async Task&lt;IActionResult&gt; GetProductById(string id, [FromQuery][Required]string name)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    // FromQuery supports reading parameters from query </pre>
			<pre class="source-code">    // string, here the value of the query string parameter </pre>
			<pre class="source-code">    // 'name' will be mapped to name parameter.</pre>
			<pre class="source-code">    var product = await </pre>
			<pre class="source-code">      this.productService.GetProductByIdAsync(id, </pre>
			<pre class="source-code">      name).ConfigureAwait(false);</pre>
			<pre class="source-code">    if (product != null)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return this.Ok(product);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    else</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return this.NoContent();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">[HttpPost]</pre>
			<pre class="source-code">public async Task&lt;IActionResult&gt; AddProductAsync(ProductDetailsViewModel product)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    // Product null check is to avoid null attribute </pre>
			<pre class="source-code">    // validation error.</pre>
			<pre class="source-code">    if (product == null || product.Etag != null)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return this.BadRequest();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    var result = await this.productService</pre>
			<pre class="source-code">      .AddProductAsync(product).ConfigureAwait(false);</pre>
			<pre class="source-code">    return this.CreatedAtAction(nameof(</pre>
			<pre class="source-code">      th<a id="_idTextAnchor1175"/>is.GetProductById), new { id = result.Id, na<a id="_idTextAnchor1176"/>me = </pre>
			<pre class="source-code">      result.Name }, result); // HATEOS principle</pre>
			<pre class="source-code">}</pre>
			<p>The<a id="_idIndexMarker960"/> method<a id="_idIndexMarker961"/> implementation is self-explanatory and based purely on the fundamentals discussed in the <em class="italic">Handling requests using controllers and actions</em> section of this chapter. Similarly, we will implement all the other methods (<code>Delete</code>, <code>Update</code>, and <code>Get</code> all products) by calling the corresponding service method and returning the relevant <code>ActionResult</code>. Wit<a id="_idTextAnchor1177"/>h that, we will have APIs shown in the following table to handle various scenarios related to the product entity:</p>
			<div><div><img src="img/Table_10.2.jpg" alt="Table 10.2 &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 10.2 </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Another common scenario with APIs is to have an API that supports file upload/download. The upload scenario is achieved by passing <code>IFormFile</code> as an input parameter to the API. This serializes the uploaded file and can also save on the server. Similarly, for file downloading, <code>FileContentResult</code> is av<a id="_idTextAnchor1178"/>ailable and can stream files to any client. This is left to you as a<a id="_idTextAnchor1179"/>n activity to explore further.</p>
			<p>Fo<a id="_idTextAnchor1180"/>r the<a id="_idIndexMarker962"/> testing<a id="_idIndexMarker963"/> API, we will use Postman (<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a>). All Postman collections can be found under the <code>Solution Items</code> folder file, <code>Mastering enterprise application development Book.postman_collection.json</code>. To import a collection once Postman has been installed, perform the following steps:</p>
			<ol>
				<li value="1">Open Postman, and then click on <strong class="bold">File</strong>.</li>
				<li>Click <code>Mastering enterprise application development Book.postman_collection.json</code> file and then click on <strong class="bold">Import</strong>.</li>
			</ol>
			<p>A succe<a id="_idTextAnchor1181"/>ssful import will show the collection in the <strong class="bold">Collectio<a id="_idTextAnchor1182"/>ns</strong> menu of Postman, as depicted in the following <a id="_idTextAnchor1183"/>screenshot:</p>
			<div><div><img src="img/Figure_10.8_B18507.jpg" alt="Figure 10.8 – Collections in Postman&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – Collections in Postman</p>
			<p>This completes our <code>Products</code> RESTful service implementation. All the other services mentioned at the beginning of this section are implemented in a similar wa<a id="_idTextAnchor1184"/><a id="_idTextAnchor1185"/>y, where each of them is <a id="_idIndexMarker964"/>an <a id="_idIndexMarker965"/>individual web <a id="_idTextAnchor1186"/>API project and handles the relevant domain logic for that en<a id="_idTextAnchor1187"/>tity.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor1188"/>Understanding gRPC</h1>
			<p>As per <code>grpc.io</code>, gRPC is<a id="_idIndexMarker966"/> a high-performance, open source universal<a id="_idTextAnchor1189"/> RPC framework. Originally developed by Google, gRPC uses HTTP/2 for transport and a <strong class="bold">Protocol Buffer</strong> (<strong class="bold">protobuf</strong>) as the <a id="_idIndexMarker967"/>interface description language. gRPC is a contract-based binary communication system, and it is available across multiple ecosystems. The fol<a id="_idTextAnchor1190"/>lowing diagram from gRPC's official documentation (https://grpc.io) illustrates client<a id="_idTextAnchor1191"/>-server interaction using gRPC:</p>
			<div><div><img src="img/Figure_10.9_B18507.jpg" alt="Figure 10.9 – gRPC client-server interaction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – gRPC client-server interaction</p>
			<p>As with many distributed systems, gRPC is based on the idea of defining a service and specifying an interface with methods that can be invoked remotely, along with contracts. In gRPC, the server implements the interface and runs the gRPC server to handle client<a id="_idIndexMarker968"/> calls. The client side has the stub, which provides the same interface as defined by the server. The client calls the stub in the same way as it invokes methods in any other local object to invoke a method on the server.</p>
			<p>By default, data<a id="_idIndexMarker969"/> contracts use <code>.proto</code> extension. In a protobuf, the data is structured as a logical record of the information contained in fields. In the upcoming section, we will learn about how to d<a id="_idTextAnchor1192"/>efine a protobuf in Visual Studio for a .NET 6 application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to the official documentation to learn more about gRPC: <a href="https://grpc.io">https://grpc.io</a>. To learn more about <a id="_idIndexMarker970"/>protobufs, refer to <a href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a>.</p>
			<p>Given the benefits of high performance, language-agnostic implementation, and reduced network usage associated with the protobuf of gRPC, many teams are exploring the use of gRPC in<a id="_idIndexMarker971"/> th<a id="_idTextAnchor1193"/><a id="_idTextAnchor1194"/>eir endeavors to build microservices.<a id="_idTextAnchor1195"/></p>
			<p>In the next section, we will learn how to build a gRPC server a<a id="_idTextAnchor1196"/>nd client in .NET 6.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor1197"/>Building a gRPC server in .NET</h2>
			<p>After making<a id="_idIndexMarker972"/> its<a id="_idIndexMarker973"/> first appearance in .NET Core 3.0, gRPC has become a first-class citizen in the .NET ecosystem. Fully managed gRPC implementation is now available in .NET. Using Visual Studio 2022 and .NET 6, we can create gRPC server and client applications easily. Let's create a gRPC<a id="_idTextAnchor1198"/> service using the gRPC service template in Visual Studio, shown in the following screenshot, and name it <code>gRPCDemoService</code>:</p>
			<div><div><img src="img/Figure_10.10_B18507.jpg" alt="Figure 10.10 – gRPC Visual Studio 2022 project template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – gRPC Visual Studio 2022 project template</p>
			<p>This will create a solution with a sample gRPC service named <code>GreetService</code>. Let's now understand the solution created with the template. The solution created will have a package reference to <code>Grpc.AspNetCore</code>. This will have the libraries required to host the gRPC service and a code generator for the <code>.proto</code> files. This solution will have a proto file created for <code>GreetService</code> under the <code>Protos</code> solution folder. The following code defines the <code>Greeter</code> service:</p>
			<pre class="source-code">service Greeter {</pre>
			<pre class="source-code">  // Sends a greeting</pre>
			<pre class="source-code">  rpc SayHello (HelloRequest) returns (HelloReply);</pre>
			<pre class="source-code">}</pre>
			<p>The <code>Greeter</code> service has only one method named <code>SayHello</code>, which takes the input parameter as <code>HelloRequest</code> and returns a message of the <code>HelloReply</code> type. <code>HelloRequest</code> and <code>HelloReply</code> messages are defined in the same proto file, as shown in the followi<a id="_idTextAnchor1199"/>ng code snippet:</p>
			<pre class="source-code">message HelloRequest {</pre>
			<pre class="source-code">  string n<a id="_idTextAnchor1200"/>ame = 1;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">message HelloReply {</pre>
			<pre class="source-code">  string message = 1;</pre>
			<pre class="source-code">}</pre>
			<p><code>HelloRequest</code> has one field named <code>name</code>, and <code>HelloReply</code> has one field named <code>message</code>. The<a id="_idIndexMarker974"/> number<a id="_idIndexMarker975"/> next to the field shows the ordinal position of the field in the buffer. The proto files are compiled with the <code>Protobuf</code> compiler to generate stub classes with all the plumbing required. We can specify the kind of stub classes to generate from the properties of the proto file. Since this is a server, it will have the configuration set to <strong class="bold">Server only</strong>.</p>
			<p>Now, let's look at the <code>GreetService</code> implementation. This will appear as shown in the following code snippet:</p>
			<pre class="source-code">public class GreeterService : Greeter.GreeterBase</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    private readonly ILogger&lt;GreeterService&gt; _logger;</pre>
			<pre class="source-code">    public GreeterService(ILogger&lt;GreeterService&gt; logger)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        _logger = logger;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public override Task&lt;HelloReply&gt; SayHello(</pre>
			<pre class="source-code">      HelloRequest request, ServerCallContext context)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return Task.FromResult(new HelloReply</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            Message = "H<a id="_idTextAnchor1201"/>ello " + request.Name</pre>
			<pre class="source-code">        });</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p><code>GreetService</code> inh<a id="_idTextAnchor1202"/>erits from <code>Greeter.GreeterBase</code>, which is generated by the protobuf compiler. The <code>SayHello</code> method is overridden to provide the implementation so as to return a greeting to the caller by constructing <code>HelloReply</code>, as defined in the proto file.</p>
			<p>To expose gRPC services in a .NET 6 application, all the required gRPC services are to be added to the service collection by calling <code>AddGrpc</code> in the <code>Program</code> class. The <code>GreeterService</code> gRPC service is exposed by calling <code>MapGrpcService</code>, as illustrated in the following code snippet:</p>
			<pre class="source-code">app.MapGrpcService&lt;GreeterService&gt;();</pre>
			<p>That is<a id="_idIndexMarker976"/> everything<a id="_idIndexMarker977"/> that is required to ex<a id="_idTextAnchor1203"/><a id="_idTextAnchor1204"/>pose a gRPC service in a .NET 6 a<a id="_idTextAnchor1205"/>pplication. In the next section, we will implement a .NET 6 client to consume <code>GreeterServ<a id="_idTextAnchor1206"/>ice</code>.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor1207"/>Building a gRPC client in .NET</h2>
			<p>As specified<a id="_idIndexMarker978"/> at<a id="_idIndexMarker979"/> the start of this <em class="italic">Understanding gRPC</em> section, .NET 6 has very good tooling for building a gRPC client as well. In this section, we will be building a gRPC client in a console application. Here are the steps to follow for you to accomplish this:</p>
			<ol>
				<li value="1">Create a .NET 6 console application and name it <code>gRPCDemoClient</code>.</li>
				<li>Now, right-click on the project and cli<a id="_idTextAnchor1208"/>ck on the <strong class="bold">Add</strong> | <strong class="bold">Service reference…</strong> menu items. This will open the <strong class="bold">Connected Services</strong> tab, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_10.11_B18507.jpg" alt="Figure 10.11 – gRPC Connected Services tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – gRPC Connected Services tab</p>
			<ol>
				<li value="3">Select <strong class="bold">gRPC</strong> in<a id="_idIndexMarker980"/> the <strong class="bold">Add service reference</strong> dialog, and then<a id="_idIndexMarker981"/> click on <strong class="bold">Next</strong>.</li>
				<li>In the <code>greet.proto</code> file from <code>gRPC<a id="_idTextAnchor1209"/>DemoService</code>,<a id="_idTextAnchor1210"/> and then click on the <a id="_idTextAnchor1211"/><code>Client</code> stub classes:</li>
			</ol>
			<div><div><img src="img/Figure_10.12_B18507.jpg" alt="Figure 10.12 – Adding a gRPC service reference&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12 – Adding a gRPC service reference</p>
			<p>This will also add the required <code>Google.Protobuf</code>, <code>Grpc.Net.ClientFactory</code>, and <code>Grpc.Tools</code> NuGet packages to the project.</p>
			<ol>
				<li value="5">Now, add <a id="_idIndexMarker982"/>the <a id="_idIndexMarker983"/>following code to the <code>Program</code> class of the <code>gRPCDemoClient</code> project:<pre><strong class="bold">    var channel = GrpcChannel.ForAddress("https://localhost:5001");</strong>
<strong class="bold">    var client = new Greeter.GreeterClient(channel);</strong>
<strong class="bold">    HelloReply response = await client.SayHelloAsync(new HelloRequest { Name="Suneel" });</strong>
<strong class="bold">    Console.WriteLine(response.Message);</strong></pre></li>
			</ol>
			<p>In this code snippet, we are creating a gRPC channel to the <code>gRPCDemoService</code> endpoint<a id="_idTextAnchor1212"/>, and then instantiating <code>Greeter.GreeterClient</code>, which is a <a id="_idTextAnchor1213"/>stub to <code>gRPCDemoService</code>, by passing in the gRPC channel.</p>
			<ol>
				<li value="6">Now, to invoke the service, we just need to call the <code>SayHelloAsync</code> method on the stub by passing the <code>HelloRequest</code> message. This call will return <code>HelloReply</code> from the service.</li>
			</ol>
			<p>Up to now, we <a id="_idIndexMarker984"/>have<a id="_idIndexMarker985"/> created a simple gRPC service and a<a id="_idTextAnchor1214"/><a id="_idTextAnchor1215"/> console client for that service. In the next section, we <a id="_idTextAnchor1216"/>will learn about <code>grpcurl</code>, which is a generic client to test gRPC services.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor1217"/>Testing gRPC services</h2>
			<p>To test or invoke a <a id="_idIndexMarker986"/>REST service, we use tools such as Postman or Fiddler. <code>grpcurl</code> is a command-line utility that helps us to interact with gRPC services. Using <code>grpcurl</code>, we can test gRPC services without building client apps. <code>grpcurl</code> is available for download from <a href="https://github.com/fullstorydev/grpcurl">https://github.com/fullstorydev/grpcurl</a>.</p>
			<p>Once <code>grpcurl</code> is downloaded, we can call <code>GreeterService</code> u<a id="_idTextAnchor1218"/>sing the following command:</p>
			<pre class="source-code">grpcurl -d "{\"name\": \"World\"}" localhost:5001 greet.Greeter/SayHello</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Currently, gRPC <a id="_idIndexMarker987"/>applications can only be hosted in Azure App Service and <strong class="bold">Internet Information Services</strong> (<strong class="bold">IIS</strong>), hence we did not leverage gRPC in the demo e-commerce application that is hosted on Azure App Service. However, there is a version of the e-commerce a<a id="_idTextAnchor1219"/><a id="_idTextAnchor1220"/>pplication in this chapter demo, where obtaining a product according to its ID is exposed as a gRPC endpoint in a self-hosted service.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor1221"/>Summary</h1>
			<p>In this chapter, we covered the basic principles of REST and also designed enterprise-level RESTful services for our e-commerce application.</p>
			<p>Along the way, we got to grips with the various web API internals of an ASP.NET Core 6 web API—including routing and sample middleware—and became familiar with tools for testing our services, while learning how to handle requests using a controller and its actions, which we also learned to build. Also, we saw how to create and test basic gRPC client and server applications in .NET 6. You should now be able to confidently build RESTful services using an ASP.NET Core 6 web API.</p>
			<p>In the n<a id="_idTextAnchor1222"/><a id="_idTextAnchor1223"/>ext chapter, we will go through the fundamentals of ASP.NET MVC, build our UI layer using ASP.NET MVC, and integrate it with our APIs.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor1224"/>Questions</h1>
			<ol>
				<li value="1">Which of the following HTTP verbs is recommended for creating a resource?</li>
			</ol>
			<p>a. <code>GET</code></p>
			<p>b. <code>POST</code></p>
			<p>c. <code>DELETE</code></p>
			<p>d. <code>PUT</code></p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="2">Which of the following HTTP status codes represents <code>No Content</code>?</li>
			</ol>
			<p>a. <code>200</code></p>
			<p>b. <code>201</code></p>
			<p>c. <code>202</code></p>
			<p>d. <code>204</code></p>
			<p><strong class="bold">Answer: d</strong></p>
			<ol>
				<li value="3">Which of the following middlewares is used to configure routing?</li>
			</ol>
			<p>a. <code>UseDeveloperExceptionPage()</code></p>
			<p>b. <code>UseHttpsRedirection()</code></p>
			<p>c. <code>UseRouting()</code></p>
			<p>d. <code>UseAuthorization()</code></p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="4">If a controller is annotated with the <code>[ApiController]</code> attribute, do I need to class <code>ModelState.IsValid</code> explicitly in each action method?</li>
			</ol>
			<p>a. Yes—model validation isn't part of the <code>ApiController</code> attribute, hence you need to call <code>ModelState.Valid</code> in each action method.</p>
			<p>b. No—model validatio<a id="_idTextAnchor1225"/><a id="_idTextAnchor1226"/>n is handled as part of the <code>ApiController</code> attribute, hence <code>ModelState.Valid</code> is triggered automatically for all action items.</p>
			<p><strong class="bold">Answer: b</strong></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor1227"/>Further reading</h1>
			<ul>
				<li><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0</a></li>
				<li><a href="https://docs.microsoft.com/en-us/odata/overview">https://docs.microsoft.com/en-us/odata/overview</a></li>
			</ul>
		</div>
	</body></html>