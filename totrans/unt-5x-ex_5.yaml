- en: Chapter 5. Project C – a 2D Adventure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 项目 C – 二维冒险
- en: 'In this chapter, we will begin a completely new project; specifically, a 2D
    adventure game in which the player controls an alien character, exploring and
    navigating a dangerous world complete with quests and interactive elements. This
    project will incorporate elements and ideas from previous chapters as well as
    focus on new techniques, such as Complex Collisions, 2D Physics, Singletons and
    Statics, and more. In short, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始一个全新的项目；具体来说，是一个玩家控制外星角色的二维冒险游戏。在这个游戏中，玩家将探索和导航一个充满任务和交互元素的危险世界。该项目将结合前几章的元素和想法，并专注于新的技术，如复杂碰撞、2D
    物理学、单例和静态等。简而言之，我们将涵盖以下主题：
- en: 2D characters and player movement
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D 角色和玩家移动
- en: Assembling complex and multipart characters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组装复杂和多部分角色
- en: Level design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别设计
- en: 2D Physics and collision detection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D 物理和碰撞检测
- en: Note
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The starting project and assets can be found in the book companion files in
    the `Chapter05/Start` folder. You can start here and follow along with this chapter
    if you don't have your own project already.
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 起始项目和资源可以在书的配套文件中找到，位于`Chapter05/Start`文件夹中。如果您还没有自己的项目，可以从这里开始，并跟随本章内容进行操作。
- en: A 2D Adventure – getting started
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二维冒险之旅 – 开始
- en: Adventure games require the player to use their cunning, dexterity, mental sharpness,
    and acumen to make progress. Such games feature dangerous obstacles, challenging
    missions, and character interaction, as opposed to *all-out* action like many
    first-person shooter games. Our adventure game will be no exception. See *Figure
    5.1* for a glimpse of the game that we'll create. In this game, the player moves
    around using the keyboard arrows or *W*, *A*, *S*, *D* keys. Furthermore, they
    can jump with the spacebar and interact with characters simply by approaching
    them. During the game, the player will be tasked with a mission from an NPC character
    to collect an ancient gem hidden somewhere within a level. The player must then
    navigate dangerous obstacles in search of the gem, and then finally collect it
    before returning to the NPC, completing the game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 冒险游戏要求玩家运用他们的机智、敏捷、思维敏锐和洞察力来取得进展。这类游戏具有危险的障碍、挑战性的任务和角色互动，与许多第一人称射击游戏中的全面战斗形成对比。我们的冒险游戏也不例外。见*图
    5.1*，了解我们将要创建的游戏。在这个游戏中，玩家可以使用键盘上的箭头键或*W*、*A*、*S*、*D*键来移动。此外，他们可以按空格键跳跃，并通过接近角色与角色互动。在游戏中，玩家将接到来自NPC角色的任务，收集隐藏在关卡某个地方的古老宝石。然后，玩家必须穿越危险的障碍物寻找宝石，并在返回NPC之前最终收集它，完成游戏。
- en: '![A 2D Adventure – getting started](img/figure_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![二维冒险之旅 – 开始](img/figure_05_01.jpg)'
- en: 'Figure 5.1: The 2D adventure game to create'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：要创建的二维冒险游戏
- en: To get started with creating the adventure, create a completely new and empty
    Unity project, and then import the `Particles`, `Effects`, `Characters`, `2D`,
    `ParticleSystems`, and `CrossPlatformInput` packages. You can import these from
    the **Project Creation Wizard** or from the application menu via the **Assets**
    | **Import Packages** option. See *Figure 5.2*. Details on how to import standard
    assets are included in [Chapter 1](ch01.html "Chapter 1. The Coin Collection Game
    – Part 1"), *The Coin Collection Game – Part 1*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建冒险，请创建一个全新的空Unity项目，然后导入`Particles`、`Effects`、`Characters`、`2D`、`ParticleSystems`和`CrossPlatformInput`包。您可以从**项目创建向导**或从应用程序菜单通过**资产**
    | **导入包**选项导入这些包。见*图 5.2*。有关导入标准资产的详细信息包含在[第 1 章](ch01.html "第 1 章. 硬币收集游戏 – 第
    1 部分")，*硬币收集游戏 – 第 1 部分*中。
- en: '![A 2D Adventure – getting started](img/figure_05_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![二维冒险之旅 – 开始](img/figure_05_02.jpg)'
- en: 'Figure 5.2: Importing packages to a new project from the Project Creation screen'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：从项目创建屏幕导入包到新项目
- en: Importing assets
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产导入
- en: 'Starting from an empty project created in the previous section, let''s now
    import the texture assets we''ll be using, both for the player character and environment.
    The assets to import are included in the book companion files in the `Chapter05/Assets`
    folder. From here, select all textures together in Windows Explorer or Mac Finder,
    and drag and drop them to the Unity Project panel in a designated `Textures` folder.
    (Create one if you haven''t already!). This imports all relevant textures to the
    active Project. See *Figure 5.3*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节创建的空项目开始，现在让我们导入我们将要使用的纹理资产，包括玩家角色和环境。要导入的资产包含在本书配套文件中的`Chapter05/Assets`文件夹中。从这里，在Windows资源管理器或Mac
    Finder中一起选择所有纹理，并将它们拖放到指定的`Textures`文件夹中的Unity项目面板。 （如果您还没有创建，请创建一个！）这会将所有相关纹理导入到活动项目中。请参见*图5.3*：
- en: '![Importing assets](img/figure_05_03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![导入资产](img/figure_05_03.jpg)'
- en: 'Figure 5.3: Importing texture assets to the Project'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：将纹理资产导入项目
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you can always use the Thumbnail Size Slider (at the bottom right
    corner of the Project panel) to adjust the size of thumbnail previews in order
    to get an easier view of your texture assets.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您始终可以使用缩略图大小滑块（位于项目面板的右下角）来调整缩略图预览的大小，以便更容易查看您的纹理资产。
- en: 'By default, Unity assumes that all imported textures will eventually be used
    as regular textures applied to 3D models in the scene, such as cubes, spheres,
    and meshes. In most cases, this assumption is correct because most games are 3D.
    However, for 2D games like the one we''re making, the settings should be different.
    In our case, objects don''t recede in the distance, moving further away, but just
    remain at a constant offset from the camera. For this reason, we must adjust some
    crucial properties for all imported textures. Specifically, select all imported
    textures, and, from the **Object Inspector**, change the **Texture Type** field
    from **Texture** to **Sprite 2D and UI**. Then, remove the check mark from the
    **Generate Mip Maps** box. Then, click on the **Apply** button. When you do this,
    Unity flags the assets as having a *2D usage* internally. It allows transparent
    backgrounds to be applied where applicable (such as for PNG sprites) and also
    has important performance implications for graphics rendering, as we''ll see.
    See *Figure 5.4*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity 假设所有导入的纹理最终都将用作常规纹理，应用于场景中的3D模型，例如立方体、球体和网格。在大多数情况下，这个假设是正确的，因为大多数游戏都是3D的。然而，对于像我们正在制作的2D游戏，设置应该不同。在我们的案例中，对象不会随着距离的增加而退远，只是保持与摄像机的恒定偏移。因此，我们必须调整所有导入纹理的一些关键属性。具体来说，选择所有导入的纹理，从**对象检查器**中，将**纹理类型**字段从**纹理**更改为**2D精灵和UI**。然后，取消勾选**生成Mip贴图**框。然后，点击**应用**按钮。当您这样做时，Unity
    会将资产标记为具有内部*2D使用*。它允许在适用的地方应用透明背景（例如PNG精灵），并且对图形渲染的性能也有重要影响，我们将在后面看到。请参见*图5.4*：
- en: '![Importing assets](img/figure_05_04.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![导入资产](img/figure_05_04.jpg)'
- en: 'Figure 5.4: Configuring imported textures'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：配置导入的纹理
- en: 'Now that we''ve imported all essential textures for the project, let''s configure
    our main scene, game camera, and target resolution. Switch to the **Game** tab
    and set the resolution to **1024 x 600**; which works well across many devices.
    To do this, click on the **Free Aspect** button from the **Game** tab toolbar
    and pick **1024 x 600** from the drop-down menu, if it appears as an option. If
    not, click on the **+** button from the bottom of the list to add the new resolution.
    See *Figure 5.5*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了项目所需的所有基本纹理，让我们配置我们的主场景、游戏摄像机和目标分辨率。切换到**游戏**选项卡，将分辨率设置为**1024 x 600**；这在许多设备上都适用。为此，点击**游戏**选项卡工具栏中的**自由宽高比**按钮，从下拉菜单中选择**1024
    x 600**（如果它作为选项出现）。如果没有，点击列表底部的**+**按钮添加新的分辨率。请参见*图5.5*：
- en: '![Importing assets](img/figure_05_05.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![导入资产](img/figure_05_05.jpg)'
- en: 'Figure 5.5: Adding game resolutions'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：添加游戏分辨率
- en: 'To add a new resolution, enter a custom name in the **Name** field, select
    **Fixed Resolution** from the **Type** drop-down, and then type your resolution
    dimensions in the **Width & Height** fields. Once completed, click on **OK**.
    Your target resolution should then be added as a selectable option from the **Game**
    tab. See *Figure 5.6*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新的分辨率，请在**名称**字段中输入自定义名称，从**类型**下拉菜单中选择**固定分辨率**，然后在**宽度 & 高度**字段中输入您的分辨率尺寸。完成后，点击**确定**。您的目标分辨率应随后作为**游戏**选项卡中的一个可选选项添加。请参见*图5.6*：
- en: '![Importing assets](img/figure_05_06.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![导入资产](img/figure_05_06.jpg)'
- en: 'Figure 5.6: Creating a custom resolution'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：创建自定义分辨率
- en: 'Next, we''ll configure the scene camera for a 2D setup so that our textures,
    when added as sprites, will display onscreen at a 1:1 ratio, texel for pixel.
    To achieve this, select the **MainCamera** in the scene, either by clicking on
    it in the **Scene viewport** or selecting it in the **Scene Hierarchy**. Then,
    from the **Object Inspector**, change **Projection** to **Orthographic**. This
    ensures that the camera displays objects in true 2D with perspective and foreshortening
    effects removed. Then change the camera Size to `3`. The formula for this field
    is *Screen Height / 2 / Pixel to World*. In this case, the *Screen Height* is
    *600*. Thus, *600 / 2 = 300*. Then, *300 / 100 = 3*. *100* refers to the pixel
    to world ratio applied to sprite textures; this details how many pixels in the
    texture will be mapped to a square meter in the world. A value of `1` means *1
    pixel = 1 meter*. This value can be viewed and changed by selecting a sprite in
    the **Project** panel and changing the **Pixel to World ratio** field in the **Object
    Inspector**. See *Figure 5.7*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为2D设置配置场景相机，以便我们的纹理作为精灵添加到屏幕上时，将以1:1的比例显示，像素对应像素。为此，在场景中选择**主相机**，无论是通过在**场景视口**中单击它，还是在**场景层次结构**中选择它。然后，从**对象检查器**中，将**投影**更改为**正交**。这确保相机以真实2D显示对象，并移除了透视和缩短效果。然后，将相机大小更改为`3`。此字段的公式是*屏幕高度/2/像素到世界*。在这种情况下，*屏幕高度*是*600*。因此，*600/2=300*。然后，*300/100=3*。*100*指的是应用于精灵纹理的像素到世界比例；这详细说明了纹理中的多少像素将被映射到世界中的平方米。值为`1`表示*1像素=1米*。此值可以通过在**项目**面板中选择一个精灵并更改**对象检查器**中的**像素到世界比例**字段来查看和更改。参见*图5.7*：
- en: '![Importing assets](img/figure_05_07.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![导入资源](img/figure_05_07.jpg)'
- en: 'Figure 5.7: Configuring camera orthographic size'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：配置相机正交大小
- en: 'To test the camera and scene settings, simply drag and drop a background texture
    from the **Project** panel to the scene. The **Background** textures are sized
    at exactly 1024 x 600 to fit the scene background. Therefore, when added to a
    scene and when the camera is configured correctly, the background textures should
    fill the screen. See *Figure 5.8*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试相机和场景设置，只需将**项目**面板中的一个背景纹理拖放到场景中。**背景**纹理的大小正好为1024 x 600，以适应场景背景。因此，当添加到场景中并且相机配置正确时，背景纹理应该填满屏幕。参见*图5.8*：
- en: '![Importing assets](img/figure_05_08.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![导入资源](img/figure_05_08.jpg)'
- en: 'Figure 5.8: Testing the camera settings with a texture'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：使用纹理测试相机设置
- en: Creating an environment – getting started
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建环境 - 开始
- en: 'Our adventure game will feature three separate but connected scenes, which
    the player may explore, moving from one scene to the next. The player may travel
    between scenes, simply by walking off the edge of one and then moving into the
    next. Each scene consists primarily of platforms and ledges and, in some cases,
    dangers and obstacles. In terms of graphical assets, each scene is made from two
    textures or sprites: the background and foreground. An example for Scene 1 is
    shown in *Figures 5.9* and and *Figure 5.10*. *Figure 5.9* represents the background
    scene and *Figure 5.10* represents the foreground, which includes a complete layout
    of all the platforms and ledges that the player must traverse. These files are
    included in the book companion files in the `Chapter05/Assets` folder:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的冒险游戏将包含三个独立但相互关联的场景，玩家可以探索这些场景，从一个场景移动到下一个场景。玩家可以通过走出一个场景的边缘然后进入下一个场景来在场景之间旅行。每个场景主要由平台和凸起组成，在某些情况下，还有危险和障碍。在图形资源方面，每个场景由两个纹理或精灵组成：背景和前景。场景1的示例在*图5.9*和*图5.10*中展示。*图5.9*代表背景场景，*图5.10*代表前景，其中包括玩家必须穿越的所有平台和凸起的完整布局。这些文件包含在书的配套文件中，位于`Chapter05/Assets`文件夹：
- en: '![Creating an environment – getting started](img/figure_05_09.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![创建环境 - 开始](img/figure_05_09.jpg)'
- en: 'Figure 5.9: Scene background - tex_level01_bck.png'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：场景背景 - tex_level01_bck.png
- en: '![Creating an environment – getting started](img/figure_05_10.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![创建环境 - 开始](img/figure_05_10.jpg)'
- en: 'Figure 5.10: Scene foreground - tex_level01_design.png'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：场景前景 - tex_level01_design.png
- en: 'Let''s create the first level now, based on the sprites in *Figures 5.9* and
    *Figure 5.10*. To do this, use the existing empty scene, or create a new scene,
    ensuring that the scene camera is configured to display textures at their native
    size. Then, drag and drop both the background and foreground sprites from the
    **Project** panel to the scene. Both will be added to the scene as separate sprite
    objects. Then, position them both to the World Origin at (0,0,0). See *Figure
    5.11*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们根据 *图 5.9* 和 *图 5.10* 中的精灵创建第一个级别。为此，使用现有的空场景，或创建一个新的场景，确保场景相机配置为以原生大小显示纹理。然后，将背景和前景精灵从
    **项目** 面板拖放到场景中。它们都将作为单独的精灵对象添加到场景中。然后，将它们都放置在 World 原点（0,0,0）。见 *图 5.11*：
- en: '![Creating an environment – getting started](img/figure_05_11.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![创建环境 – 开始](img/figure_05_11.jpg)'
- en: 'Figure 5.11: Adding a scene background and foreground'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：添加场景背景和前景
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you drag and drop both the background and foreground textures together as
    one selection from the **Project** panel to the scene, Unity may ask you to create
    an Animation when you release your mouse. In such cases, Unity assumes that you
    want to create an animated sprite in which each selected texture becomes a frame
    of animation played in a sequence. You don't want to do this; instead, drag and
    drop each sprite to a separate **Hierarchy** panel, allowing both the foreground
    and background to be seen at the same time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将背景和前景纹理作为一个选择从 **项目** 面板拖放到场景中，当您释放鼠标时，Unity 可能会要求您创建一个动画。在这种情况下，Unity 假设您想要创建一个动画精灵，其中每个选定的纹理都成为动画序列中播放的一帧。您不想这样做；相反，将每个精灵拖放到单独的
    **层次结构** 面板中，这样就可以同时看到前景和背景。
- en: 'Both sprite objects are now added to the scene at the same world position (0,0,0).
    The question arises now as to which sprite Unity should display on top, given
    that both sprites overlap one another. Left as it is right now, there is a conflict
    and ambiguity about depth order, and we cannot rely on Unity consistently showing
    the correct sprite on top. We can solve this problem with two methods: one is
    to move the sprite forward in the *Z* axis, closer to the Orthographic camera;
    and the other is to change its **Order** setting from the **Object Inspector**.
    High values for **Order** result in the sprite appearing atop lower-order sprites.
    Here, I''ll use both methods and that''s fine too! See *Figure 5.12*. Note, however,
    that **Order** always takes precedence over **Position**. This means that higher-order
    objects will always appear on top of lower-order objects, even if higher-order
    objects are positioned behind lower-order objects.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 两个精灵对象现在都被添加到了场景中的相同世界位置（0,0,0）。现在的问题是，由于两个精灵相互重叠，Unity 应该显示哪个精灵在上方。目前的情况是，存在深度顺序的冲突和模糊性，我们无法依赖
    Unity 一致地显示正确的精灵在上方。我们可以用两种方法解决这个问题：一种是将精灵在 *Z* 轴上向前移动，靠近正交相机；另一种是将其 **Order**
    设置从 **对象检查器** 中更改。**Order** 的较高值会导致精灵出现在较低顺序的精灵之上。在这里，我将使用这两种方法，这也很好！见 *图 5.12*。然而，请注意，**Order**
    总是优先于 **Position**。这意味着较高顺序的对象将始终出现在较低顺序的对象之上，即使较高顺序的对象位于较低顺序的对象之后。
- en: '![Creating an environment – getting started](img/figure_05_12.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![创建环境 – 开始](img/figure_05_12.jpg)'
- en: 'Figure 5.12: Ordering sprite layers in a scene'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：在场景中排序精灵层
- en: 'Before moving further, let''s get organized in terms of scene hierarchy to
    prevent overcomplication and confusion happening later. Select each environment
    object and name them appropriately. I named the background `scene_background`
    and the foreground `scene_foreground`. Having done this, create a new, empty **GameObject**
    named `Env` (for Environment), which will be the ultimate parent or ancestor of
    all static (non-movable) objects in the environment. This lets us group together
    all related objects easily. To do this, choose **GameObject** | **Create Empty**
    from the application menu, position the created empty object to the world origin,
    and drag and drop both the background and foreground objects as its children.
    See *Figure 5.13*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们在场景层次结构方面进行组织，以防止以后发生过度复杂化和混淆。选择每个环境对象并适当地命名它们。我将背景命名为 `scene_background`，前景命名为
    `scene_foreground`。完成此操作后，创建一个新的空 **GameObject** 命名为 `Env`（代表环境），它将成为环境中所有静态（不可移动）对象的最终父对象或祖先。这使得我们可以轻松地将所有相关对象分组在一起。为此，从应用程序菜单中选择
    **GameObject** | **创建空对象**，将创建的空对象放置在世界原点，并将背景和前景对象作为其子对象拖放。见 *图 5.13*：
- en: '![Creating an environment – getting started](img/figure_05_13.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![创建环境 – 开始](img/figure_05_13.jpg)'
- en: 'Figure 5.13: Organizing the scene hierarchy'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：组织场景层次结构
- en: 'By switching to the Game tab, we can get an early preview of the level as it
    will appear to the gamer in terms of mood and emotional resonance. This feel can
    be enhanced further by adding some Camera Post-process Effects. These refer to
    pixel-based effects that can be applied to the camera in order to enhance the
    atmosphere of the final, rendered image on each frame. The **Image Effects** are
    included in the Effects package, which you should have imported during the project
    creation phase. If you did not import the package at that time, you can do so
    now by navigating to **Assets** | **Import Package** | **Effects**. The **Image
    Effects** assets are stored in the `Standard Assets/Effects` folder. Once imported,
    you can add Image Effects to the selected camera via the Application Menu by choosing
    **Component** | **Image Effects** and then choosing the effect to add. See *Figure
    5.14*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过切换到**游戏**标签，我们可以提前预览级别，从游戏玩家的情绪和情感共鸣角度来看它将如何呈现。这种感觉可以通过添加一些相机后处理效果进一步增强。这些效果是指可以应用于相机的基于像素的效果，以增强每帧最终渲染图像的气氛。**图像效果**包含在效果包中，你应在项目创建阶段导入该包。如果你当时没有导入该包，现在可以通过导航到**资产**
    | **导入包** | **效果**来导入。**图像效果**资产存储在`Standard Assets/Effects`文件夹中。一旦导入，你可以通过应用程序菜单选择**组件**
    | **图像效果**来向所选相机添加图像效果，然后选择要添加的效果。参见*图5.14*：
- en: '![Creating an environment – getting started](img/figure_05_14.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![创建环境 – 开始](img/figure_05_14.jpg)'
- en: 'Figure 5.14: Adding Image Effects to the selected camera'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：向所选相机添加图像效果
- en: 'For this level, and all other levels in the game, I''ll add the following two
    image effects: **Bloom Optimized** and **Noise and Grain**. Once added, you will
    typically need to adjust the sliders and settings in the **Inspector** to achieve
    the look you want, continually previewing the result in the **Game** tab. The
    **Scene** tab remains unaffected by image effects. The complete range of settings
    I''ve used for both image effects are included in *Figure 5.15*. In many cases,
    these settings will take some trial and error—tweak values and observe the effect.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个级别，以及游戏中所有其他级别，我将添加以下两种图像效果：**Bloom Optimized**和**Noise and Grain**。一旦添加，你通常需要调整**检查器**中的滑块和设置以达到你想要的外观，并在**游戏**标签中不断预览结果。**场景**标签不受图像效果的影响。我在两种图像效果中使用的完整设置范围包括在*图5.15*中。在许多情况下，这些设置可能需要一些尝试和错误——调整值并观察效果。
- en: '![Creating an environment – getting started](img/figure_05_15.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![创建环境 – 开始](img/figure_05_15.jpg)'
- en: 'Figure 5.15: Image Effects applied to the game camera'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15：应用于游戏相机的图像效果
- en: Good work. The scene so far features a background and foreground taken from
    texture files and enhancing special effects using the Image Effects assets package.
    This is a great start, but there's still much to do so let's move on!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。到目前为止的场景包括从纹理文件中获取的背景和前景，以及使用图像效果资产包增强特殊效果。这是一个很好的开始，但还有很多工作要做，所以让我们继续吧！
- en: Environment Physics
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境物理
- en: 'The main problem with our level as it stands is that it lacks interactivity.
    Specifically, if we dragged and dropped a player object to the level and pressed
    play on the toolbar, the player would drop through the floor and walls because
    the foreground texture isn''t recognized by Unity as a solid object. It''s just
    a texture and exists only in appearance and not in substance. In this section,
    we''ll correct this using Physics and Colliders. To get started, we''ll create
    a temporary player object (not the final version but just a temporary *White Box*
    version used only for testing purposes). To create this, generate a capsule object
    in the scene by navigating to **GameObject** | **3D Object** | **Capsule** from
    the application menu. Set the *Z* position of the transform to match the foreground
    texture (for me, this is `-2`). Once generated, remove **Capsule Collider** from
    the object. By default, the Capsule is assigned a 3D collider (such as the **Capsule
    Collider**), which is useful primarily for 3D physics, but our game will be 2D.
    To remove the Collider, click on the Cog icon on the **Capsule Collider** component
    in the **Object Inspector** and choose **Remove Component** from the menu. See
    *Figure 5.16*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们关卡的主要问题是缺乏交互性。具体来说，如果我们把玩家对象拖放到关卡中，并在工具栏上按下播放，玩家会因为前景纹理未被 Unity 识别为实体对象而穿过地板和墙壁。它只是一个纹理，只存在于外观上，而不存在于实质上。在本节中，我们将使用物理和碰撞体来纠正这个问题。要开始，我们将在场景中创建一个临时玩家对象（不是最终版本，而只是一个用于测试的临时
    *白色盒子* 版本）。为此，从应用程序菜单导航到 **GameObject** | **3D Object** | **Capsule** 来生成胶囊对象。将变换的
    *Z* 位置设置为与前景纹理匹配（对我来说，这是 `-2`）。一旦生成，从对象中移除 **Capsule Collider**。默认情况下，胶囊被分配了一个
    3D 碰撞体（如 **Capsule Collider**），这对于 3D 物理非常有用，但我们的游戏将是 2D。要移除碰撞体，点击 **Object Inspector**
    中 **Capsule Collider** 组件上的齿轮图标，并从菜单中选择 **Remove Component**。参见 *图 5.16*：
- en: '![Environment Physics](img/figure_05_16.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理](img/figure_05_16.jpg)'
- en: 'Figure 5.16: Removing a Capsule Collider component'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：移除胶囊碰撞体组件
- en: 'To make the object compatible with 2D Physics, add a Circle Collider component
    by choosing **Component** | **Physics 2D** | **Circle Collider** from the application
    menu. Once added, use the **Offset** and **Radius** settings on the Circle Collider
    component in the Inspector to adjust the size and position of the circle in relation
    to the capsule object in order to approximate the feet of a player character.
    To aid you in positioning the **Circle Collider** more easily, you can switch
    the **Scene** viewport mode to **Wireframe** and **2D**, if needed. To do this,
    use the **2D Toggle** button and the **Scene Render** mode drop-down button in
    the viewport toolbar. See *Figure 5.17*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使对象与 2D 物理兼容，通过应用程序菜单选择 **Component** | **Physics 2D** | **Circle Collider**
    来添加圆形碰撞体组件。一旦添加，使用检查器中圆形碰撞体组件的 **Offset** 和 **Radius** 设置来调整圆形的大小和位置，以便相对于胶囊对象来近似玩家角色的脚部。为了帮助您更容易地定位
    **Circle Collider**，如果需要，可以将 **Scene** 视图模式切换到 **Wireframe** 和 **2D**。为此，使用视口工具栏中的
    **2D Toggle** 按钮和 **Scene Render** 模式下拉按钮。参见 *图 5.17*：
- en: '![Environment Physics](img/figure_05_17.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理](img/figure_05_17.jpg)'
- en: 'Figure 5.17: Adjusting the Circle Collider for the player character'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：调整玩家角色的圆形碰撞体
- en: 'Next, to make the **Circle Collider** work with 2D Physics, add a RigidBody2D
    component to the Capsule. To do this, select **Component** | **Physics 2D** |
    **RigidBody2D** from the application menu. You can confirm that this has worked
    by previewing the game in Play mode. When you click on the play icon, the Capsule
    object should fall down and through the foreground floor under the effect of gravity.
    See *Figure 5.18*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了使 **Circle Collider** 与 2D 物理一起工作，向胶囊添加一个 RigidBody2D 组件。为此，从应用程序菜单选择
    **Component** | **Physics 2D** | **RigidBody2D**。您可以通过在 **Play** 模式下预览游戏来确认这已经生效。当您点击播放图标时，胶囊对象应该在重力作用下落并通过前景地板。参见
    *图 5.18*：
- en: '![Environment Physics](img/figure_05_18.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理](img/figure_05_18.jpg)'
- en: 'Figure 5.18: Adding a Rigidbody 2D component to a test character'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：向测试角色添加 Rigidbody 2D 组件
- en: 'Now, it''s time to configure the foreground texture to work as a unified whole
    with physics. Right now, our test player character falls through the floor and
    this is not what we want. To fix this, we''ll need to add a collider to the foreground
    environment. One method for this is to use Edge Collider 2D. This lets you draw
    out a low polygon mesh collider around your ground image manually, approximating
    the terrain. To get started, select the foreground in the scene and then choose
    **Component** | **Physics 2D** | **Edge Collider 2D** from the application menu.
    Doing this will add an Edge Collider 2D component to the foreground object. See
    *Figure 5.19*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候配置前景纹理，使其与物理效果作为一个统一的整体。目前，我们的测试玩家角色会穿过地板，这不是我们想要的效果。为了解决这个问题，我们需要在前景环境中添加一个碰撞体。一种方法是使用二维边碰撞体。这允许你手动在你的地面图像周围绘制一个低多边形网格碰撞体，从而近似地形。要开始，请在场景中选择前景，然后从应用程序菜单中选择
    **组件** | **物理 2D** | **二维边碰撞体**。这样做将为前景对象添加一个二维边碰撞体组件。参见 *图 5.19*：
- en: '![Environment Physics](img/figure_05_19.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理学](img/figure_05_19.jpg)'
- en: 'Figure 5.19: Adding an Edge Collider'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19：添加边碰撞体
- en: 'By default, adding an Edge Collider 2D appears to have little effect on the
    selected object or any other objects, except for a single horizontal line drawn
    across the width of the scene. This can be seen in the **Scene** tab when the
    **Foreground** object is selected and in the **Game** tab if the **Gizmos** tool
    button is enabled. If the player is positioned above the horizontal line and you
    press Play on the toolbar, the player character will fall downward and treat the
    horizontal edge as a solid platform. See *Figure 5.20*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，添加二维边碰撞体似乎对所选对象或任何其他对象影响很小，除了在场景宽度上绘制的一条单一直线。当选择 **前景** 对象时，可以在 **场景**
    选项卡中看到这一点，如果启用了 **Gizmos** 工具按钮，则可以在 **游戏** 选项卡中看到。如果玩家位于水平线之上，并在工具栏上按下播放，玩家角色将向下坠落，并将水平边缘视为一个实体平台。参见
    *图 5.20*：
- en: '![Environment Physics](img/figure_05_20.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理学](img/figure_05_20.jpg)'
- en: 'Figure 5.20: The Edge Collider is useful to approximate platforms and solid
    surfaces'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20：边碰撞体对于近似平台和实体表面非常有用
- en: 'Of course, our terrain isn''t simply a straight-edged surface. Rather, it has
    elevations, bumps, and platforms. These can be approximated closely with the Edge
    Collider 2D component using the **Collider Edit** mode. To access this mode, click
    on the **Edit Collider** button from the **Object Inspector**. See *Figure 5.21*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的地形不仅仅是直边表面。相反，它有高度、隆起和平台。这些可以使用 **碰撞体编辑** 模式与二维边碰撞体组件进行近似。要访问此模式，请从 **对象检查器**
    中点击 **编辑碰撞体** 按钮。参见 *图 5.21*：
- en: '![Environment Physics](img/figure_05_21.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理学](img/figure_05_21.jpg)'
- en: 'Figure 5.21: The Edit Collider mode lets you change the shape of an Edge Collider
    2D'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21：编辑碰撞体模式允许你更改二维边碰撞体的形状
- en: 'With the **Edit Collider** mode active, you can reshape the collider to conform
    to the terrain. Let''s focus on one area such as the bottom right-hand side of
    the terrain. By moving your mouse cursor over the edge points of the **Edge Collider**
    (the green line), you can click and drag to reposition it. To approximate the
    bottom right island of the terrain, click and drag the rightmost edge point to
    the right-hand side of the scene. See *Figure 5.22*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **编辑碰撞体** 模式激活时，你可以重新塑造碰撞体以符合地形。让我们关注地形的一个区域，比如地形的右下角。通过将鼠标光标移至 **边碰撞体** 的边缘点上（绿色线条），你可以点击并拖动以重新定位它。为了近似地形的右下岛屿，点击并拖动最右侧的边缘点到场景的右侧。参见
    *图 5.22*：
- en: '![Environment Physics](img/figure_05_22.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理学](img/figure_05_22.jpg)'
- en: 'Figure 5.22: Starting to reshape the Edge Collider to approximate the terrain'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：开始重新塑造边碰撞体以近似地形
- en: 'Next, click and drag the left point of the collider to match with the leftmost
    edge of the right-hand island. See *Figure 5.23*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击并拖动碰撞体的左侧点以与右手岛屿最左侧的边缘对齐。参见 *图 5.23*：
- en: '![Environment Physics](img/figure_05_23.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理学](img/figure_05_23.jpg)'
- en: 'Figure 5.23: Positioning the left-most of the right-hand island'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23：定位右手岛屿最左侧的位置
- en: 'Now that the left and right edge points are positioned, let''s add some additional
    points on the line between to reshape it, conforming to the right-hand island.
    Move your cursor anywhere on the line, click and drag to insert a new point, and
    reposition it to match the island. Repeat this process, adding additional points
    to reshape the line as needed. See *Figure 5.24*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在左右边缘点已经定位，让我们在线条之间添加一些额外的点来重塑它，使其符合右手岛屿。将光标移至线条上的任何位置，点击并拖动以插入一个新点，并将其重新定位以匹配岛屿。重复此过程，根据需要添加额外的点来重塑线条。参见*图
    5.24*：
- en: '![Environment Physics](img/figure_05_24.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理](img/figure_05_24.jpg)'
- en: 'Figure 5.24: Shaping the Edge Collider to the right-most island'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24：将边缘碰撞体塑形到最右侧的岛屿
- en: 'You now have a fully shaped line that matches the terrain''s right-most island.
    Having created this, exit the **Edit Collider** mode by simply clicking on the
    **Edit Collider** button again from the **Object Inspector**. To create colliders
    for the remaining islands of the terrain, add a new **Edge Collider** to the same
    object. You can then add any number of **Edge Colliders** to a single object,
    and each collider should be used to approximate the topology of a single, isolated
    island in the complete terrain. See *Figure 5.25*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经得到了一条完全塑形的线，与地形的最右侧岛屿相匹配。创建完成后，通过简单地再次点击**对象检查器**中的**编辑碰撞体**按钮退出**编辑碰撞体**模式。为了为地形的剩余岛屿创建碰撞体，向同一对象添加一个新的**边缘碰撞体**。你可以在单个对象上添加任意数量的**边缘碰撞体**，并且每个碰撞体都应该用来近似完整地形中单个、孤立的岛屿的拓扑结构。参见*图
    5.25*：
- en: '![Environment Physics](img/figure_05_25.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理](img/figure_05_25.jpg)'
- en: 'Figure 5.25: Multiple Edge Colliders on one object can be used to approximate
    complex terrain'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25：一个对象上的多个边缘碰撞体可以用来近似复杂的地形
- en: 'Multiple Edge Collider components are now added together to a single foreground
    object, approximating the complete terrain for the scene. We can now test play
    collisions against the **Player Capsule** object by pressing the play icon on
    the toolbar and seeing how the capsule reacts against the terrain. This time,
    the capsule will collide and interact with the ground as opposed to passing through.
    This confirms that the terrain is configured appropriately with the physics system.
    See *Figure 5.26*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经将多个边缘碰撞体组件添加到单个前景对象中，近似场景中的完整地形。我们可以通过在工具栏上按下播放图标来测试**玩家胶囊**对象与地形的碰撞，并观察胶囊如何与地形互动。这次，胶囊将碰撞并与地面互动，而不是穿过。这证实了地形已适当地配置了物理系统。参见*图
    5.26*：
- en: '![Environment Physics](img/figure_05_26.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![环境物理](img/figure_05_26.jpg)'
- en: 'Figure 5.26: Capsule Object interacting with a terrain made from Edge Colliders'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26：胶囊对象与由边缘碰撞体构成的地形交互
- en: Congratulations! In this section, we've created a complete terrain for a single
    scene using Edge Collider components. This terrain not only fits the screen and
    appears as intended, but acts as a physical obstacle for the player character
    and other physics-based objects. Of course, so far, we've been using a rough approximation
    for the player and now it's time to expand upon this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在本节中，我们使用边缘碰撞体组件创建了一个单个场景的完整地形。这个地形不仅适合屏幕并按预期显示，而且作为玩家角色和其他基于物理的对象的物理障碍。当然，到目前为止，我们一直在使用对玩家的大致近似，现在是时候扩展这一点了。
- en: Creating a player
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家
- en: 'The player character is a small, green alien-looking creature that can be controlled
    and guided by the gamer through a level using many conventional platform-game
    mechanics, such as walking, jumping, and interacting. In the previous section,
    we built a *White Box* (prototype) character to test physical interactions with
    the environment, but here, we''ll develop the player character in more depth.
    *Figure 5.27* illustrates our character texture imported earlier in the chapter,
    representing all limbs and parts for the player:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色是一个小型的绿色外星生物，可以通过游戏玩家使用许多传统的平台游戏机制（如行走、跳跃和互动）来控制和引导。在前一节中，我们构建了一个*白箱*（原型）角色来测试与环境的物理交互，但在这里，我们将更深入地开发玩家角色。*图
    5.27*展示了本章早期导入的角色纹理，代表玩家的所有肢体和部分：
- en: '![Creating a player](img/figure_05_27.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_27.jpg)'
- en: 'Figure 5.27: Character and his limbs in a consolidated texture'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27：在统一纹理中角色的特征和肢体
- en: 'The player texture, as shown in *Figure 5.27*, is called an **Atlas Texture**
    or **Sprite Sheet** because it contains all frames or parts of a character in
    a single texture space. The problem with this texture, as it stands, is that when
    dragged and dropped from the **Project** panel to the scene, it''ll be added as
    a single, self-contained sprite. This is because Unity recognizes all the separate
    parts as a single sprite. Rather, these should be separated into distinct units.
    See *Figure 5.28*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 5.27*所示，玩家纹理被称为**图集纹理**或**精灵表**，因为它在单个纹理空间中包含所有帧或角色的部分。这个纹理的问题在于，当从**项目**面板拖放到场景中时，它将被添加为一个单一的自包含精灵。这是因为
    Unity 将所有单独的部分识别为一个单一的精灵。相反，这些应该被分割成独立的单元。参见*图 5.28*：
- en: '![Creating a player](img/figure_05_28.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_28.jpg)'
- en: 'Figure 5.28: The player sprite texture needs to be divided into separate parts'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28：玩家精灵纹理需要被分割成单独的部分
- en: 'To divide the character texture into separate parts on a per-limb basis, we''ll
    use **Sprite Editor**. To access this tool, select the character texture in the
    **Project** panel. Then, from the **Object Inspector**, change **Sprite Mode**
    from **Single** to **Multiple**. Then, click on **Apply**. Next, click on the
    **Sprite Editor** button to open the **Sprite Editor** tool, allowing you cut
    apart the whole texture into specific slices. See *Figure 5.29*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在每条肢体上分别将角色纹理分割成单独的部分，我们将使用**精灵编辑器**。要访问此工具，请在**项目**面板中选择角色纹理。然后，从**对象检查器**中，将**精灵模式**从**单个**更改为**多个**。然后，点击**应用**。接下来，点击**精灵编辑器**按钮以打开**精灵编辑器**工具，允许你将整个纹理切割成特定的切片。参见*图
    5.29*：
- en: '![Creating a player](img/figure_05_29.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_29.jpg)'
- en: 'Figure 5.29: Specifying a sprite as Multiple'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29：指定精灵为多个
- en: 'With the **Sprite Editor** tool, you can separate different parts of a texture
    into discrete and separate units. One method to achieve this is by drawing a rectangle
    around each image area that should be separate, and simply clicking and dragging
    your mouse to draw a texture region. See *Figure 5.30*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**精灵编辑器**工具，你可以将纹理的不同部分分离成离散的单独单元。实现这一目标的一种方法是在每个应单独的图像区域周围绘制一个矩形，然后简单地点击并拖动鼠标来绘制纹理区域。参见*图
    5.30*：
- en: '![Creating a player](img/figure_05_30.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_30.jpg)'
- en: 'Figure 5.30: Drawing a sprite manually'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30：手动绘制精灵
- en: 'Now, although a sprite can be separated manually, as we''ve just seen, Unity
    can often cut apart the texture automatically, identifying isolated areas of pixels
    and saving us a lot of time. We''ll do that here for the player character. To
    do this, click on the **Slice** button listed at the top left corner of the **Sprite
    Editor** window. See *Figure 5.31*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管精灵可以像我们刚才看到的这样手动分离，但 Unity 通常可以自动切割纹理，识别像素的孤立区域，节省我们大量时间。我们将在这里为玩家角色执行此操作。要做到这一点，请点击位于**精灵编辑器**窗口左上角的**切片**按钮。参见*图
    5.31*：
- en: '![Creating a player](img/figure_05_31.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_31.jpg)'
- en: 'Figure 5.31: Accessing the Slice tool'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31：访问切片工具
- en: 'From the **Slice** tool window, ensure that **Type** is set to **Automatic**,
    which means that Unity will auto-detect the location of separate sprites. **Pivot**
    can be left at **Center**, determining the pivot point for each sprite. **Method**
    should be **Delete Existing**, meaning that any existing sprites or slices in
    the texture space will be erased and replaced entirely by the newly autogenerated
    slices. Then, click on the **Slice** button to confirm the operation and the texture
    will be sliced into separate sprites with a clear border drawn around each sprite.
    See *Figure 5.32*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在**切片**工具窗口中，确保**类型**设置为**自动**，这意味着 Unity 将自动检测单独精灵的位置。**中心点**可以保留在**中心**，这将确定每个精灵的旋转中心点。**方法**应该是**删除现有**，这意味着在纹理空间中任何现有的精灵或切片将被删除，并完全由新自动生成的切片替换。然后，点击**切片**按钮以确认操作，纹理将被切割成带有清晰边框的单独精灵。参见*图
    5.32*：
- en: '![Creating a player](img/figure_05_32.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_32.jpg)'
- en: 'Figure 5.32: A fully sliced sprite'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32：一个完全切片的精灵
- en: 'The texture is now divided into several sprites: head, body, arm, and leg.
    The final character in-scene will obviously have two arms and two legs but these
    will be formed from duplicated sprites. The final process now is to set the pivot
    point for each sprite—the point around which the sprite will rotate. This will
    be important later to animate the character correctly, as we''ll see. Let''s start
    by setting the pivot for the head. Select the head sprite in the editor and then
    click and drag the pivot handle (blue circle) to reposition the sprite''s center
    of rotation. Click and drag the handle to the bottom middle of the head, roughly
    where the head would connect to the neck. This makes sense because the head will
    rotate and hinge from around this point. As you move the pivot around, you should
    see the **X** and **Y** values change from the **Custom Pivot** field in the **Sprite
    Properties** dialog, shown in the bottom right-hand corner of the **Sprite Editor**
    window. See *Figure 5.33*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理现在被分割成几个精灵：头部、身体、手臂和腿部。场景中的最终角色显然有两只手臂和两条腿，但它们将由复制的精灵形成。现在的最终步骤是为每个精灵设置轴点——精灵将围绕这个点旋转的点。这将对我们稍后正确动画化角色非常重要，正如我们将看到的。让我们先设置头部的轴点。在编辑器中选择头部精灵，然后点击并拖动轴点句柄（蓝色圆圈）以重新定位精灵的旋转中心。点击并拖动句柄到头部的底部中间，大致是头部与颈部相连的地方。这很有意义，因为头部将围绕这个点旋转和铰接。当你移动轴点时，你应该会看到**X**和**Y**值从**精灵属性**对话框的**自定义轴点**字段中改变，该对话框显示在**精灵编辑器**窗口的右下角。见*图
    5.33*：
- en: '![Creating a player](img/figure_05_33.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_33.jpg)'
- en: 'Figure 5.33: Repositioning the sprite pivot'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.33：重新定位精灵轴点
- en: 'Next, position the pivot for the arm, which should be at the shoulder joint
    where the arm connects to a torso; then for the leg, which should be near the
    hip where the leg connects to a torso, and finally, the torso itself, whose pivot
    should be at the hip joint. See *Figure 5.34*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定位手臂的轴点，它应该在肩膀关节处，手臂与躯干相连的地方；然后是腿部，它应该在臀部附近，腿部与躯干相连的地方，最后是躯干本身，其轴点应该在臀部关节处。见*图
    5.34*：
- en: '![Creating a player](img/figure_05_34.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_34.jpg)'
- en: 'Figure 5.34: Positioning the pivot for the torso'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.34：定位躯干的轴点
- en: 'When completed, click on the **Apply** button to confirm changes and then close
    the **Sprite Editor**. On returning to the main Unity interface, the appearance
    of the character texture will have changed in the **Project** panel. Specifically,
    the character texture features a small arrow icon attached to the right-hand side.
    When you click this, the texture expands to review all the separate sprites in
    a row, which can be dragged and dropped individually to the scene. See *Figure
    5.35*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，点击**应用**按钮以确认更改，然后关闭**精灵编辑器**。返回主 Unity 界面后，**项目**面板中角色的纹理外观将已更改。具体来说，角色纹理特征是一个附在右侧的小箭头图标。当你点击它时，纹理会展开以查看一排所有单独的精灵，这些精灵可以单独拖放到场景中。见*图
    5.35*：
- en: '![Creating a player](img/figure_05_35.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_35.jpg)'
- en: 'Figure: 5.35: Previewing character sprites'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图：5.35：预览角色精灵
- en: 'Now that we''ve isolated all player sprite textures, we can start to build
    a game character in the scene. Start by creating an empty game object with the
    **GameObject** | **Create Empty** command from the application menu. Name the
    object `Player` and assign it a Player Tag from the Inspector. This object will
    act as the ultimate or topmost parent object for the player character. Existing
    beneath this object as children will be the character''s constituent parts: torso,
    arms, and legs. So, let''s drag and drop the Torso sprite from the **Project**
    panel to the **Hierarchy** panel as a child of the **Player** object. See *Figure
    5.36*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经隔离了所有玩家精灵纹理，我们可以在场景中开始构建游戏角色。首先，从应用程序菜单使用**GameObject** | **Create Empty**命令创建一个空的游戏对象。将对象命名为`Player`，并在检查器中分配一个玩家标签。此对象将作为玩家角色的最终或最顶层父对象。作为此对象的子对象将包含角色的各个部分：躯干、手臂和腿部。因此，让我们将**项目**面板中的躯干精灵拖放到**层次**面板中，作为**Player**对象的子对象。见*图
    5.36*：
- en: '![Creating a player](img/figure_05_36.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_36.jpg)'
- en: 'Figure 5.36: Starting the player character'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.36：开始创建玩家角色
- en: After the torso has been added, we can add legs and arms. The arms should be
    added as children of the torso because the torso determines where the arms will
    be. However, the legs should be added as children of the **Player** object and
    are therefore siblings of the torso, because the torso can rotate independently
    of the legs. See *Figure 5.37* for the complete hierarchical arrangement. As you
    add each limb, you'll want to offset its position so that it appears correctly
    in relation to other limbs—the head should appear above the feet and so on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了躯干之后，我们可以添加腿和手臂。手臂应该作为躯干的孩子添加，因为躯干决定了手臂的位置。然而，腿应该作为**玩家**对象的孩子添加，因此它们是躯干的兄弟，因为躯干可以独立于腿旋转。参见*图
    5.37*以了解完整的层次结构安排。当你添加每个肢体时，你希望偏移其位置，以便它在与其他肢体相对的位置上正确显示——头部应该位于脚部之上，依此类推。
- en: '![Creating a player](img/figure_05_37.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_37.jpg)'
- en: 'Figure 5.37: Building a character'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.37：构建角色
- en: 'The rendering order of body parts is probably not correct by default insofar
    as each item will have an identical order in the Sprite Renderer component. This
    means that Unity could potentially render each limb in any order, allowing arms
    to appear in front of the head, legs to appear in front of the body, and so on.
    To correct this, we''ll select each limb in turn and assign it an appropriate
    order value, taking care that it''s higher than the world background order and
    less than the world foreground order. I''ve assigned the body an order of `103`,
    the head `105`, left arm `102`, right arm `104`, left leg `100`, and right leg
    `101`. See *Figure 5.38*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 身体部分的渲染顺序默认可能不正确，因为每个项目在 Sprite Renderer 组件中都将具有相同的顺序。这意味着 Unity 可能会以任何顺序渲染每个肢体，使得手臂可能出现在头部之前，腿可能出现在身体之前，等等。为了纠正这一点，我们将依次选择每个肢体并分配适当的顺序值，注意确保它高于世界背景顺序且低于世界前景顺序。我已经将身体分配了顺序值`103`，头部`105`，左臂`102`，右臂`104`，左腿`100`，右腿`101`。参见*图
    5.38*：
- en: '![Creating a player](img/figure_05_38.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_38.jpg)'
- en: 'Figure 5.38: Ordering body parts'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.38：排序身体部分
- en: 'The rendering order for limbs is now configured successfully. Let''s set up
    collisions and physics for the player. To do this, add two colliders—a Circle
    Collider to approximate the character feet, allowing us to determine when the
    character is in contact with the ground, and a Box Collider that approximates
    most of the body including the head. These colliders can be added by selecting
    the **Player** object (the topmost object) and then navigating to **Component**
    | **Physics 2D** | **Circle Collider 2D** and **Component** | **Physics 2D** |
    **Box Collider 2D**. See *Figure 5.39*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 肢体的渲染顺序现在已成功配置。让我们为玩家设置碰撞和物理属性。为此，添加两个碰撞器——一个圆形碰撞器来近似角色脚部，使我们能够确定角色何时接触地面，以及一个近似身体大部分（包括头部）的盒子碰撞器。这些碰撞器可以通过选择**玩家**对象（最顶层的对象）然后导航到**组件**
    | **物理 2D** | **圆形碰撞器 2D**和**组件** | **物理 2D** | **盒子碰撞器 2D**来添加。参见*图 5.39*：
- en: '![Creating a player](img/figure_05_39.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_39.jpg)'
- en: 'Figure 5.39: Adding two colliders to the Player Object: Circle Collider and
    Box Collider'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.39：向玩家对象添加两个碰撞器：圆形碰撞器和盒子碰撞器
- en: 'The Circle Collider is of special importance because it''s the primary means
    to determine whether the character is touching the ground, and it''ll also be
    in contact with the ground as the character moves. For this reason, a Physics
    Material should be assigned to this collider to prevent friction effects from
    stopping or corrupting character motion as it moves around the scene. To achieve
    this, create a new Physics Material by right-clicking in the empty space in the
    **Project** panel and choose **Create** | **Physics2D Material** from the context
    menu. Name the material `Low Friction`. See *Figure 5.40*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形碰撞器特别重要，因为它是确定角色是否接触地面的主要手段，并且当角色移动时也会接触地面。因此，应为此碰撞器分配一个物理材质，以防止摩擦效果在角色在场景中移动时停止或破坏角色运动。为此，通过在**项目**面板中的空白区域右键单击并从上下文菜单中选择**创建**
    | **物理2D 材质**来创建一个新的物理材质。将材质命名为`低摩擦`。参见*图 5.40*：
- en: '![Creating a player](img/figure_05_40.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_40.jpg)'
- en: 'Figure 5.40: Creating a new Physics Material'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.40：创建新的物理材质
- en: Select the Physics2D material in the **Project** panel, and from the **Inspector**,
    change the Friction setting to `0.1`. Then, drag and drop the Physics2D material
    from the **Project** panel to the **Material** slot for the CircleCollider2D component
    on the **Player** object. See *Figure 5.41*. Using these settings, the character
    will behave more realistically.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在**项目**面板中选择Physics2D材质，并在**检查器**中，将摩擦设置更改为`0.1`。然后，将Physics2D材质从**项目**面板拖放到**玩家**对象上的CircleCollider2D组件的**材质**槽中。参见*图5.41*。使用这些设置，角色将表现得更加逼真。
- en: '![Creating a player](img/figure_05_41.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_41.jpg)'
- en: 'Figure 5.41: Assigning a Physics material to the player character'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.41：为玩家角色分配物理材质
- en: Then, finally assign RigidBody2D to the **Player** object and set both **Linear
    Drag** and **Gravity Scale** to `3`. In addition, set **Collison Detection** to
    **Continuous** for the most accurate collision detection and **Freeze Rotation**
    of the object on the *Z* axis because the player character should never rotate.
    Now, you have a fully completed physical object representing the player. See *Figure
    5.42*. Good work!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后将RigidBody2D分配给**玩家**对象，并将**线性阻尼**和**重力缩放**都设置为`3`。此外，将**碰撞检测**设置为**连续**以实现最精确的碰撞检测，并将对象的**Z**轴**冻结旋转**，因为玩家角色不应该旋转。现在，您已经拥有了一个代表玩家的完整物理对象。参见*图5.42*。做得好！
- en: '![Creating a player](img/figure_05_42.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家](img/figure_05_42.jpg)'
- en: 'Figure 5.42: Configuring the player character for Physics'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.42：为物理配置玩家角色
- en: Scripting the player movement
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本化玩家移动
- en: 'The game so far features an environment with collision data and a multipart
    player object that interacts and responds to this environment. The player, however,
    cannot yet be controlled, and this section explores controller functionality further.
    The user will have two main input mechanics, namely, movement (walking left and
    right) and jumping. This input can be read seamlessly and easily using `CrossPlatformInputManager`,
    which is a native Unity asset package. This package was imported at the project
    creation phase, but it can be imported now via the application menu with **Assets**
    | **Import Package** | **CrossPlatformInput**. Once imported, open the `Standard
    Assets` | `CrossPlatformInput` | `Prefabs` folder and drag and drop the **MobileTiltControlRig**
    prefab to the scene. This prefab lets you read input data across a range of devices,
    mapping directly to the horizontal and vertical axes that we''ve already seen
    in previous chapters. See *Figure 5.43*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，游戏包含一个具有碰撞数据的场景和一个多部分玩家对象，该对象与环境交互并对此做出响应。然而，玩家目前还不能被控制，本节将进一步探讨控制器功能。用户将有两个主要输入机制，即移动（左右走动）和跳跃。可以使用`CrossPlatformInputManager`无缝且轻松地读取这些输入，这是一个本地的Unity资产包。该包在项目创建阶段已导入，但现在可以通过应用程序菜单导入，即**资产**
    | **导入包** | **跨平台输入**。导入后，打开`Standard Assets` | `CrossPlatformInput` | `Prefabs`文件夹，并将**MobileTiltControlRig**预制件拖放到场景中。这个预制件允许您读取跨多种设备的输入数据，直接映射到我们在前几章中已经看到的水平和垂直轴。参见*图5.43*：
- en: '![Scripting the player movement](img/figure_05_43.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![脚本化玩家移动](img/figure_05_43.jpg)'
- en: 'Figure 5.43: Cross-platform input prefabs offer easy multidevice control'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.43：跨平台输入预制件提供多设备控制
- en: 'Let''s now script player controls. To do this, create a new C# script named
    `PlayerControl.cs` and attach it to the Player character. The full source code
    for this file is given in the *Code Sample 5.1*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写玩家控制脚本。为此，创建一个新的名为`PlayerControl.cs`的C#脚本，并将其附加到玩家角色上。此文件的完整源代码在*代码示例5.1*中给出：
- en: '[PRE0]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code Sample 5.1
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例5.1
- en: 'The following points summarize the code sample:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `PlayerControl` class is responsible for handling all player input, making
    the character move left and right and jump.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerControl` 类负责处理所有玩家输入，使角色左右移动和跳跃。'
- en: To achieve player movement, a reference to the RigidBody2D component is retained
    in the `ThisBody` variable, which is retrieved in the `Awake` function. The movement
    and motion of the player is set using the `RigidBody2D.Velocity` variable. More
    information on this variable can be found online at [http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html](http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实现玩家移动，需要在`ThisBody`变量中保留对RigidBody2D组件的引用，该引用在`Awake`函数中检索。使用`RigidBody2D.Velocity`变量设置玩家的移动和运动。有关此变量的更多信息，可以在网上找到[http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html](http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html)。
- en: The `FlipDirection` function is used to invert the horizontal scale of the sprite,
    turning it to face left or right as needed (reversing the image direction, for
    example, `1` and `-1`). From Unity 5.3 onward, the `Flip` property of the `SpriteRenderer`
    component can be used instead.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlipDirection` 函数用于反转精灵的水平缩放，使其根据需要面向左或右（例如，反转图像方向，`1` 和 `-1`）。从 Unity 5.3
    开始，可以使用 `SpriteRenderer` 组件的 `Flip` 属性来代替。'
- en: The `FixedUpdate` function is used instead of Update to update the movement
    of the player character because we're working with `RigidBody2D`—a physics-based
    component. All physics functionality should be updated in `FixedUpdate` that is
    invoked at a fixed interval each second as opposed to every frame. More information
    can be found at the Unity online documentation at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `FixedUpdate` 函数而不是 `Update` 来更新玩家角色的移动，因为我们正在使用 `RigidBody2D`——一个基于物理的组件。所有基于物理的功能都应该在
    `FixedUpdate` 中更新，它每秒以固定间隔调用，而不是每帧调用。更多信息可以在 Unity 在线文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html)。
- en: The `GetGrounded` function detects where any `CircleCollider` intersects and
    overlaps with any other collider in the scene on a specific layer. In short, this
    function indicates whether the player character is touching the ground at the
    position of the feet. If so, the player is able to jump; otherwise, the player
    cannot jump as they are already airborne. Double-jumping is not allowed in this
    game!
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetGrounded` 函数检测任何 `CircleCollider` 与场景中特定图层上的任何其他碰撞器相交和重叠的位置。简而言之，此函数指示玩家角色是否在脚部位置接触地面。如果是这样，玩家可以跳跃；否则，玩家不能跳跃，因为他们已经在空中。本游戏中不允许双跳！'
- en: 'For the preceding code to work correctly, a few tweaks must be made to both
    the scene and player character. Specifically, the `GetGrounded` function requires
    that the floor area of the level is grouped together on a single layer. This simply
    means that the level foreground should be on a distinctive layer from other objects.
    To achieve this, create a new layer named `Ground`, and then assign the foreground
    object to this layer. To create a new layer, select the foreground object and,
    from the **Object Inspector**, click on the drop-down named **Layer**. Then, select
    Add Layer from the context menu. See *Figure 5.44*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的代码正确运行，需要对场景和玩家角色进行一些调整。具体来说，`GetGrounded` 函数要求关卡的地板区域在单个图层上分组。这意味着关卡前景应该与其他对象在不同的图层上。为了实现这一点，创建一个名为
    `Ground` 的新图层，然后将前景对象分配到这个图层。要创建新图层，选择前景对象，然后从 **对象检查器** 中点击名为 **图层** 的下拉菜单。然后，从上下文菜单中选择添加图层。参见
    *图 5.44*：
- en: '![Code Sample 5.1](img/figure_05_44.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 5.1](img/figure_05_44.jpg)'
- en: 'Figure 5.44: Adding a new layer'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.44：添加新图层
- en: 'Then, add a new layer named `Ground` simply by entering `Ground` in an available
    type-in field. See *Figure 5.45*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在可用的输入字段中输入 `Ground` 来添加一个名为 `Ground` 的新图层。参见 *图 5.45*：
- en: '![Code Sample 5.1](img/figure_05_45.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 5.1](img/figure_05_45.jpg)'
- en: 'Figure 5.45: Creating a new ground layer'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.45：创建新的地面图层
- en: 'Now, assign the foreground object to the `Ground` layer. Simply select the
    foreground object, and then select the **Ground** layer from the **Layer** drop-down
    in the **Object Inspector**. After the foreground object is assigned to the ground
    layer, the `PlayerControl` script requires us to indicate which layer has been
    designated for the ground. To achieve this, select the **Player** object and,
    from the **Object Inspector**, select the **Ground** layer for the **Ground Layer**
    field. See *Figure 5.46*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将前景对象分配到 `Ground` 图层。只需选择前景对象，然后从 **对象检查器** 中的 **图层** 下拉菜单中选择 **Ground**
    图层。在前景对象分配到地面图层后，`PlayerControl` 脚本要求我们指出哪个图层被指定为地面。为此，选择 **Player** 对象，然后从 **对象检查器**
    中选择 **Ground** 图层作为 **地面图层** 字段。参见 *图 5.46*：
- en: '![Code Sample 5.1](img/figure_05_46.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 5.1](img/figure_05_46.jpg)'
- en: 'Figure 5.46: Selecting the Ground layer for collision detection'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.46：选择用于碰撞检测的地面图层
- en: 'In addition, the **Feet Collider** slot needs assignment too in order to indicate
    which collider object should be used for ground collision detection. For this
    field, you need to drag and drop the **CircleCollider** component to the **Feet
    Collider** slot. See *Figure 5.47*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**脚底碰撞器** 槽也需要分配，以指示应使用哪个碰撞器对象进行地面碰撞检测。对于此字段，您需要将 **CircleCollider** 组件拖放到
    **脚底碰撞器** 槽中。参见 *图 5.47*：
- en: '![Code Sample 5.1](img/figure_05_47.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例5.1](img/figure_05_47.jpg)'
- en: 'Figure 5.47: The Feet Collider detects when the character is in contact with
    the ground'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.47：脚部碰撞体检测角色是否接触地面
- en: 'Now, give the player character a test run. Simply click on the play icon on
    the toolbar and test out the controls of the player character. *W*, *A*, *S*,
    *D* (or the arrow keys) will move the player character around. The spacebar makes
    the character jump. See *Figure 5.48*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对玩家角色进行测试运行。只需在工具栏上单击播放图标，测试玩家角色的控制。*W*，*A*，*S*，*D*（或箭头键）可以移动玩家角色。空格键使角色跳跃。参见*图5.48*：
- en: '![Code Sample 5.1](img/figure_05_48.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例5.1](img/figure_05_48.jpg)'
- en: 'Figure 5.48: Play testing with the player character'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.48：玩家角色的游戏测试
- en: Optimization
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: Our work so far has produced an interesting environment and a controllable character
    within this environment. Before moving forward, let's turn our attention to optimization—an
    issue that should be considered early during development. Optimization refers
    to the tips and tricks that we can apply to improve runtime performance as well
    as our workflow generally. Here, we'll consider prefabs to improve our workflow
    and Sprite Packing to improve runtime performance. Let's start with prefabs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止的工作已经产生了一个有趣的环境和在这个环境中的可控角色。在继续前进之前，让我们将注意力转向优化——这是一个在开发早期就应该考虑的问题。优化指的是我们可以应用的技巧和窍门，以提高运行时性能以及我们的工作流程。在这里，我们将考虑预制件来改进我们的工作流程，以及精灵打包来提高运行时性能。让我们从预制件开始。
- en: 'A prefab is a Unity asset that lets you group together many objects in a scene
    and package them together as a single unit that can be added to the **Project**
    panel as an asset. From here, the prefab can be added as a complete unit to any
    other scene or environment as though it were a separate and complete *thing*.
    The player character is an ideal candidate for a prefab because it must feature
    in all the other scenes we create. Let''s create a prefab from the player. To
    do this, simply drag and drop the **Player** object to the **Project** panel in
    a separate folder called `Prefabs`. See *Figure 5.49*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件是一种Unity资源，允许你将场景中的多个对象组合在一起，并将它们打包成一个单独的单元，可以将其作为资产添加到**项目**面板中。从这里，预制件可以作为完整的单元添加到任何其他场景或环境中，就像它是一个独立且完整的**事物**。玩家角色是预制件的理想候选者，因为它必须出现在我们创建的所有其他场景中。让我们从玩家角色创建一个预制件。为此，只需将**玩家**对象拖放到名为`Prefabs`的单独文件夹中的**项目**面板即可。参见*图5.49*：
- en: '![Optimization](img/figure_05_49.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![优化](img/figure_05_49.jpg)'
- en: 'Figure 5.49: Generating a player prefab'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.49：生成玩家预制件
- en: 'After the **Prefab** is created, the **Player** object name in the hierarchy
    panel will turn blue, indicating that it''s connected to the Prefab asset. This
    means that if you select the **Prefab** in the **Project** panel and make changes
    in the Inspector, then the **Player** object in the scene will change automatically
    to match these changes. You can, however, break the connection between the **Player**
    in the scene and **Prefab** by selecting the **Player** object and choosing **GameObject**
    | **Break Prefab Instance** from the application menu. This converts the scene
    object into a separate and independent duplicate of the Prefab. See *Figure 5.50*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在**预制件**创建后，层次面板中的**玩家**对象名称将变为蓝色，表示它与预制件资产连接。这意味着如果你在**项目**面板中选择**预制件**并更改检查器中的内容，那么场景中的**玩家**对象将自动更改以匹配这些更改。然而，你可以通过选择场景中的**玩家**对象并从应用程序菜单中选择**GameObject**
    | **Break Prefab Instance**来断开**玩家**和**预制件**之间的连接。这会将场景对象转换为预制件的独立且独立的副本。参见*图5.50*：
- en: '![Optimization](img/figure_05_50.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![优化](img/figure_05_50.jpg)'
- en: 'Figure 5.50: Breaking a prefab instance'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.50：断开预制件实例
- en: 'Most of the time, however, you''ll want to keep the connection between objects
    and their prefabs. Sometimes, though, you may make changes to the object in the
    scene, and then want these changes to feedback to the **Prefab** asset in the
    **Project** panel, affecting all other linked instances if there are any. To do
    this, select the object to which changes have been made, and then select **GameObject**
    | **Apply Changes to Prefab** from the application menu. See *Figure 5.51*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数时候，你希望保持对象与其预制件之间的连接。有时，你可能会在场景中的对象上进行更改，然后希望这些更改反馈到**项目**面板中的**预制件**资产，如果存在其他链接实例，则影响所有其他链接实例。为此，选择已更改的对象，然后从应用程序菜单中选择**GameObject**
    | **Apply Changes to Prefab**。参见*图5.51*：
- en: '![Optimization](img/figure_05_51.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![优化](img/figure_05_51.jpg)'
- en: 'Figure 5.51: Applying changes to a prefab'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.51：应用预制件更改
- en: In addition to making Prefabs, you'll also want to optimize the render performance
    for your 2D games. Right now, when running the game, Unity will perform a unique
    and separate draw call for each and every unique texture or sprite onscreen at
    the time. A draw call simply refers to a step or process cycle that Unity must
    run through to properly display a graphic onscreen, such as a mesh, material,
    or texture. Draw calls represent a computational expense, and so it's a good idea
    to reduce them wherever possible.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了制作预制件外，你还希望优化 2D 游戏的渲染性能。目前，当运行游戏时，Unity 将为屏幕上每个独特的纹理或精灵执行独特的、独立的绘制调用。绘制调用简单来说就是
    Unity 必须运行的一个步骤或过程周期，以正确地在屏幕上显示图形，如网格、材质或纹理。绘制调用代表计算开销，因此最好尽可能减少它们。
- en: 'For 2D games, we can reduce draw calls by batching together related textures,
    such as all the props for a scene, all the enemies, or all the weapons. That is,
    by indicating to Unity that a group of textures belong together, Unity can perform
    internal optimizations that increase render performance. Specifically, Unity will
    paste all related textures in a single and larger internal texture that it uses
    instead. To achieve this optimization, select all *prop* textures. For our game,
    I will include the **Player**, **House**, **Platform**, and **Gem** as props.
    These textures are all featured in the **Project** panel, though not all are used
    in the game yet. Select these textures and, from the Inspector, assign them the
    same name for the **Packing Tag** field (Props). Then, click on **Apply**. See
    *Figure 5.52*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 2D 游戏，我们可以通过将相关的纹理批量在一起来减少绘制调用，例如场景中的所有道具、所有敌人或所有武器。也就是说，通过告诉 Unity 一组纹理属于一起，Unity
    可以执行内部优化，从而提高渲染性能。具体来说，Unity 将将所有相关纹理粘贴到一个更大的内部纹理中，而不是使用多个纹理。为了实现这种优化，选择所有 *道具*
    纹理。在我们的游戏中，我将包括 **玩家**、**房屋**、**平台** 和 **宝石** 作为道具。这些纹理都在 **项目** 面板中，尽管并非所有都已在游戏中使用。选择这些纹理，并在检查器中为
    **打包标签** 字段分配相同的名称（道具）。然后，点击 **应用**。见图 5.52：
- en: '![Optimization](img/figure_05_52.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![优化](img/figure_05_52.jpg)'
- en: 'Figure 5.52: Assigning multiple textures to the same Packing Tag'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.52：将多个纹理分配给相同的打包标签
- en: 'Now, repeat this process for the **Backgrounds**, selecting all backgrounds
    and assigning them to the **Background Packing** tag. Then, click on **Apply**.
    See *Figure 5.53*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重复此过程为 **背景**，选择所有背景并将它们分配给 **背景打包** 标签。然后，点击 **应用**。见图 5.53：
- en: '![Optimization](img/figure_05_53.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![优化](img/figure_05_53.jpg)'
- en: 'Figure 5.53: Creating a Background batch of textures'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.53：创建纹理批次的背景
- en: 'That''s it! Now, when you press on the play icon, Unity will automatically
    batch and organize the textures for optimal performance based on your groupings.
    This technique can significantly reduce draw calls. On pressing the play icon,
    you may see a loading bar or progress bar while Unity internally generates a new
    texture set. During Play Mode, you can view how Unity has organized the textures
    through the **Sprite Packer** window. To access this, select **Window** | **Sprite
    Packer**. See *Figure 5.54*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，当你点击播放图标时，Unity 将会根据你的分组自动批量组织和优化纹理，以实现最佳性能。这项技术可以显著减少绘制调用。在点击播放图标时，你可能会看到一个加载条或进度条，因为
    Unity 正在内部生成新的纹理集。在播放模式期间，你可以通过 **Sprite Packer** 窗口查看 Unity 如何组织纹理。要访问它，请选择 **窗口**
    | **Sprite Packer**。见图 5.54：
- en: '![Optimization](img/figure_05_54.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![优化](img/figure_05_54.jpg)'
- en: 'Figure 5.54: Unity organizes all similarly tagged textures into the same texture
    space as an Atlas'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.54：Unity 将所有具有相同标签的纹理组织到与 Atlas 相同的纹理空间中
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Superb work! We've come a long way in this chapter, from a blank project to
    an effective 2D game in which a player character can navigate a complete 2D environment
    with 2D Physics. The character can move left and right and jump, and the sprite
    texture will change to match the direction of travel as well. In addition, Sprite
    Packing has been used to optimize runtime performance, which is ideal for mobile
    devices. In the next chapter, we'll continue working by adding obstacles, collectable
    objects, and more!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 了不起的工作！在这一章中，我们已经取得了长足的进步，从空白项目到有效的 2D 游戏，玩家角色可以导航一个完整的 2D 环境，并使用 2D 物理进行游戏。角色可以左右移动和跳跃，精灵纹理也会根据移动方向改变。此外，精灵打包已被用于优化运行时性能，这对于移动设备来说非常理想。在下一章中，我们将继续添加障碍物、可收集物品等更多内容！
