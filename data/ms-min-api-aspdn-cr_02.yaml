- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Exploring Minimal APIs and Their Advantages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索最小API及其优势
- en: In this chapter of the book, we will introduce some of the basic themes related
    to minimal APIs in .NET 6.0, showing how they differ from the controller-based
    web APIs that we have written in the previous version of .NET. We will also try
    to underline both the pros and the cons of this new approach of writing APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一章中，我们将介绍一些与.NET 6.0中的最小API相关的基本主题，展示它们与我们之前在.NET的旧版本中编写的基于控制器的Web API有何不同。我们还将尝试强调这种新的API编写方法的优势和劣势。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Parameter binding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数绑定
- en: Exploring responses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索响应
- en: Controlling serialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制序列化
- en: Architecting a minimal API project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建最小API项目
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the descriptions in this chapter, you will need to create an ASP.NET
    Core 6.0 Web API application. You can either use one of the following options:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的描述，您需要创建一个ASP.NET Core 6.0 Web API应用程序。您可以选择以下任一选项：
- en: '**Option 1**: Click on the **New** | **Project** command in the **File** menu
    of Visual Studio 2022 – then, choose the **ASP.NET Core Web API** template. Select
    a name and the working directory in the wizard and be sure to uncheck the **Use
    controllers (uncheck to use minimal APIs)** option in the next step.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项1**：在Visual Studio 2022的**文件**菜单中点击**新建** | **项目**命令，然后，在向导中选择**ASP.NET
    Core Web API**模板。在向导中选择一个名称和工作目录，并确保在下一步中取消选中**使用控制器（取消选中以使用最小API）**选项。'
- en: '**Option 2**: Open your console, shell, or Bash terminal, and change to your
    working directory. Use the following command to create a new Web API application:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项2**：打开您的控制台、shell或Bash终端，切换到您的工作目录。使用以下命令创建一个新的Web API应用程序：'
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, open the project in Visual Studio by double-clicking the project file,
    or in Visual Studio Code, by typing the following command in the already open
    console:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过双击项目文件或在Visual Studio Code中在已打开的控制台中输入以下命令来打开项目：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, you can safely remove all the code related to the `WeatherForecast`
    sample, as we don’t need it for this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以安全地删除与`WeatherForecast`示例相关的所有代码，因为我们不需要它本章。
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter02](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter02).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的GitHub存储库[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter02](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter02)中找到。
- en: Routing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: 'According to the official Microsoft documentation available at [https://docs.microsoft.com/aspnet/core/fundamentals/routing](https://docs.microsoft.com/aspnet/core/fundamentals/routing),
    the following definition is given for routing:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方Microsoft文档[https://docs.microsoft.com/aspnet/core/fundamentals/routing](https://docs.microsoft.com/aspnet/core/fundamentals/routing)中的定义，路由如下所述：
- en: Routing is responsible for matching incoming HTTP requests and dispatching those
    requests to the app’s executable endpoints. Endpoints are the app’s units of executable
    request-handling code. Endpoints are defined in the app and configured when the
    app starts. The endpoint matching process can extract values from the request’s
    URL and provide those values for request processing. Using endpoint information
    from the app, routing is also able to generate URLs that map to endpoints.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 路由负责匹配传入的HTTP请求并将这些请求调度到应用程序的可执行端点。端点是应用程序的执行请求处理代码的单元。端点在应用程序中定义，并在应用程序启动时进行配置。端点匹配过程可以从请求的URL中提取值，并将这些值提供给请求处理。使用应用程序中的端点信息，路由还可以生成映射到端点的URL。
- en: In controller-based web APIs, routing is defined via the `UseEndpoints()` method
    in `Startup.cs` or using data annotations such as `Route`, `HttpGet`, `HttpPost`,
    `HttpPut`, `HttpPatch`, and `HttpDelete` right over the action methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于控制器的Web API中，路由通过`Startup.cs`中的`UseEndpoints()`方法或使用`Route`、`HttpGet`、`HttpPost`、`HttpPut`、`HttpPatch`和`HttpDelete`等数据注释直接在操作方法上定义。
- en: 'As mentioned in [*Chapter 1*](B17902_01.xhtml#_idTextAnchor014)*, Introduction
    to Minimal APIs* in minimal APIs, we define the route patterns using the `Map*`
    methods of the `WebApplication` object. Here’s an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第1章*](B17902_01.xhtml#_idTextAnchor014)中所述，在最小API的**介绍最小API**中，我们使用`WebApplication`对象的`Map*`方法定义路由模式。以下是一个示例：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, we have defined four endpoints, each with a different routing
    and method. Of course, we can use the same route pattern with different HTTP verbs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了四个端点，每个端点都有不同的路由和方法。当然，我们可以使用相同的路由模式与不同的HTTP动词。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As soon as we add an endpoint to our application (for example, using `MapGet()`),
    `UseRouting()` is automatically added at the start of the middleware pipeline
    and `UseEndpoints()` at the end of the pipeline.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将端点添加到我们的应用程序中（例如，使用`MapGet()`），`UseRouting()`将自动添加到中间件管道的起始处，而`UseEndpoints()`将添加到管道的末尾。
- en: 'As shown here, ASP.NET Core 6.0 provides `Map*` methods for the most common
    HTTP verbs. If we need to use other verbs, we can use the generic `MapMethods`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，ASP.NET Core 6.0为最常见的HTTP动词提供了`Map*`方法。如果我们需要使用其他动词，我们可以使用通用的`MapMethods`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the following sections, we will show in detail how routing works effectively
    and how we can control its behavior.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细展示路由如何有效工作以及我们如何控制其行为。
- en: Route handlers
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由处理程序
- en: 'Methods that execute when a route URL matches (according to parameters and
    constraints, as described in the following sections) are called **route handlers**.
    Route handlers can be a lambda expression, a local function, an instance method,
    or a static method, whether synchronous or asynchronous:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由URL匹配（根据参数和约束，如以下章节所述）时执行的方法称为**路由处理程序**。路由处理程序可以是lambda表达式、局部函数、实例方法或静态方法，无论是同步还是异步：
- en: 'Here’s an example of a lambda expression (inline or using a variable):'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面是一个lambda表达式的例子（内联或使用变量）：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s an example of a local function:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面是一个局部函数的例子：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is an example of an instance method:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个实例方法的例子：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we can see an example of a static method:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，我们可以看到一个静态方法的例子：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Route parameters
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由参数
- en: 'As with the previous versions of .NET, we can create route patterns with parameters
    that will be automatically captured by the handler:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与.NET的先前版本一样，我们可以创建带有参数的路由模式，这些参数将由处理程序自动捕获：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A route can contain an arbitrary number of parameters. When a request is made
    to this route, the parameters will be captured, parsed, and passed as arguments
    to the corresponding handler. In this way, the handler will always receive typed
    arguments (in the preceding sample, we are sure that the username is `string`
    and the product ID is `int`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个路由可以包含任意数量的参数。当对这个路由发出请求时，参数将被捕获、解析并作为参数传递给相应的处理程序。这样，处理程序将始终接收到类型化的参数（在先前的示例中，我们确信用户名是`string`，产品ID是`int`）。
- en: If the route values cannot be casted to the specified types, then an exception
    of the `BadHttpRequestException` type will be thrown, and the API will respond
    with a `400 Bad Request` message.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由值无法转换为指定的类型，则会抛出`BadHttpRequestException`类型的异常，并且API将以`400 Bad Request`消息响应。
- en: Route constraints
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由约束
- en: 'Route constraints are used to restrict valid types for route parameters. Typical
    constraints allow us to specify that a parameter must be a number, a string, or
    a GUID. To specify a route constraint, we simply need to add a colon after the
    parameter name, then specify the constraint name:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 路由约束用于限制路由参数的有效类型。典型的约束允许我们指定参数必须是数字、字符串或GUID。要指定路由约束，我们只需在参数名称后添加一个冒号，然后指定约束名称：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Minimal APIs support all the route constraints that were already available
    in the previous versions of ASP.NET Core. You can find the full list of route
    constraints at the following link: [https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference](https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最小API支持在ASP.NET Core的先前版本中已经可用的所有路由约束。您可以在以下链接中找到完整的路由约束列表：[https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference](https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference)。
- en: 'If, according to the constraints, no route matches the specified path, we don’t
    get an exception. Instead we obtain a `404 Not Found` message, because, in fact,
    if the constraints do not fit, the route itself isn’t reachable. So, for example,
    in the following cases we get 404 responses:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根据约束，没有路由与指定的路径匹配，我们不会得到异常。相反，我们获得一个`404 Not Found`消息，因为实际上，如果约束不匹配，路由本身是无法到达的。因此，例如，在以下情况下我们会得到404响应：
- en: '![Table 2.1 – Examples of an invalid path according to the route constraints
    ](img/Table_2.01_B17902.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![表2.1 – 根据路由约束的无效路径示例](img/Table_2.01_B17902.jpg)'
- en: Table 2.1 – Examples of an invalid path according to the route constraints
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 根据路由约束的无效路径示例
- en: 'Every other argument in the handler that is not declared as a route constraint
    is expected, by default, in the query string. For example, see the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器中未声明为路由约束的每个其他参数默认期望在查询字符串中。例如，参见以下：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the next section, *Parameter binding*, we’ll go deeper into how to use binding
    to further customize routing by specifying, for example, where to search for routing
    arguments, how to change their names, and how to have optional route parameters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节 *参数绑定* 中，我们将更深入地探讨如何使用绑定来进一步自定义路由，例如指定搜索路由参数的位置、更改它们的名称以及如何有可选的路由参数。
- en: Parameter binding
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数绑定
- en: '**Parameter binding** is the process that converts request data (i.e., URL
    paths, query strings, or the body) into strongly typed parameters that can be
    consumed by route handlers. ASP.NET Core minimal APIs support the following binding
    sources:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数绑定**是将请求数据（即 URL 路径、查询字符串或正文）转换为强类型参数的过程，这些参数可以被路由处理器消费。ASP.NET Core 最小
    API 支持以下绑定来源：'
- en: Route values
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由值
- en: Query strings
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询字符串
- en: Headers
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部
- en: The body (as JSON, the only format supported by default)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正文（作为 JSON，默认支持的唯一格式）
- en: A service provider (dependency injection)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务提供者（依赖注入）
- en: We’ll talk in detail about dependency injection in [*Chapter 4*](B17902_04.xhtml#_idTextAnchor061),
    *Implementing Dependency Injection*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 4 章*](B17902_04.xhtml#_idTextAnchor061) *实现依赖注入* 中详细讨论依赖注入。
- en: As we’ll see later in this chapter, if necessary, we can customize the way in
    which binding is performed for a particular input. Unfortunately, in the current
    version, binding from `Form` is not natively supported in minimal APIs. This means
    that, for example, `IFormFile` is not supported either.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章后面将要看到的，如果需要，我们可以自定义特定输入的绑定方式。不幸的是，在当前版本中，最小 API 中没有原生支持从 `Form` 进行绑定。这意味着，例如，`IFormFile`
    也不受支持。
- en: 'To better understand how parameter binding works, let’s take a look at the
    following API:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解参数绑定的工作原理，让我们看一下以下 API：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Parameters that are passed to the handler are resolved in the following ways:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给处理器的参数以以下方式解决：
- en: '![Table 2.2 – Parameter binding sources ](img/Table_2.02_B17902.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.2 – 参数绑定来源](img/Table_2.02_B17902.jpg)'
- en: Table 2.2 – Parameter binding sources
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 – 参数绑定来源
- en: As we can see, ASP.NET Core is able to automatically understand where to search
    for parameters for binding, based on the route pattern and the types of the parameters
    themselves. For example, a complex type such as the `Person` class is expected
    in the request body.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，ASP.NET Core 能够根据路由模式和参数本身的类型自动理解绑定参数的位置。例如，期望在请求体中有一个复杂类型，如 `Person`
    类。
- en: 'If needed, as in the previous versions of ASP.NET Core, we can use attributes
    to explicitly specify where parameters are bound from and, optionally, use different
    names for them. See the following endpoint:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，就像在 ASP.NET Core 的早期版本中一样，我们可以使用属性来显式指定参数绑定来源，并且可以选择性地使用不同的名称。参见以下端点：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The API can be invoked with `/search?q=text`. However, using `q` as the name
    of the argument isn’t a good idea, because its meaning is not self-explanatory.
    So, we can modify the handler using `FromQueryAttribute`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: API 可以通过 `/search?q=text` 来调用。然而，使用 `q` 作为参数名称不是一个好主意，因为它的含义不是不言自明的。因此，我们可以使用
    `FromQueryAttribute` 修改处理器：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this way, the API still expects a query string parameter named `q`, but in
    the handler its value is now bound to the `searchText` argument.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，API 仍然期望一个名为 `q` 的查询字符串参数，但在处理器中，其值现在绑定到 `searchText` 参数。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: According to the standard, the `GET`, `DELETE`, `HEAD`, and `OPTIONS` HTTP options
    should never have a body. If, nevertheless, you want to use it, you need to explicitly
    add the `[FromBody]` attribute to the handler argument; otherwise, you’ll get
    an `InvalidOperationException` error. However, keep in mind that this is a bad
    practice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据标准，`GET`、`DELETE`、`HEAD` 和 `OPTIONS` HTTP 选项不应有正文。如果无论如何你想使用它，你需要显式地将 `[FromBody]`
    属性添加到处理器参数中；否则，你会得到一个 `InvalidOperationException` 错误。然而，请记住，这是一个不好的做法。
- en: 'By default, all the parameters in route handlers are required. So, if, according
    to routing, ASP.NET Core finds a valid route, but not all the required parameters
    are provided, we will get an error. For example, let’s look at the following method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，路由处理程序中的所有参数都是必需的。因此，如果根据路由，ASP.NET Core 找到一个有效的路由，但不是所有必需的参数都提供，我们将得到一个错误。例如，让我们看看以下方法：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we call the endpoint without the `pageIndex` or `itemsPerPage` query string
    values, we will obtain a `BadHttpRequestException` error, and the response will
    be `400 Bad Request`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用端点时不包含 `pageIndex` 或 `itemsPerPage` 查询字符串值，我们将获得 `BadHttpRequestException`
    错误，并且响应将是 `400 Bad Request`。
- en: 'To make the parameters optional, we just need to declare them as nullable or
    provide a default value. The latter case is the most common. However, if we adopt
    this solution, we cannot use a lambda expression for the handler. We need another
    approach, for example, a local function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使参数可选，我们只需将它们声明为可空或提供默认值。后者是最常见的情况。然而，如果我们采用这种解决方案，我们无法使用 lambda 表达式作为处理程序。我们需要另一种方法，例如，局部函数：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, we are dealing with a query string, but the same rules apply to
    all the binding sources.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们处理的是查询字符串，但相同的规则适用于所有绑定源。
- en: 'Keep in mind that if we use `null`, we need to declare it as `BadHttpRequestException`
    error again. The following example correctly defines the `orderBy` query string
    parameter as optional:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果我们使用 `null`，我们需要再次将其声明为 `BadHttpRequestException` 错误。以下示例正确地将 `orderBy`
    查询字符串参数定义为可选的：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Special bindings
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊绑定
- en: 'In controller-based web APIs, a controller that inherits from `Microsoft.AspNetCore.Mvc.ControllerBase`
    has access to some properties that allows it to get the context of the request
    and response: `HttpContext`, `Request`, `Response`, and `User`. In minimal APIs,
    we don’t have a base class, but we can still access this information because it
    is treated as a special binding that is always available to any handler:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于控制器的 Web API 中，继承自 `Microsoft.AspNetCore.Mvc.ControllerBase` 的控制器可以访问一些属性，允许它获取请求和响应的上下文：`HttpContext`、`Request`、`Response`
    和 `User`。在最小 API 中，我们没有基类，但我们仍然可以访问这些信息，因为它们被视为始终可用的特殊绑定：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can also access all these objects using the `IHttpContextAccessor` interface,
    as we did in the previous ASP.NET Core versions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `IHttpContextAccessor` 接口访问所有这些对象，就像我们在之前的 ASP.NET Core 版本中所做的那样。
- en: Custom binding
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义绑定
- en: In some cases, the default way in which parameter binding works isn’t enough
    for our purpose. In minimal APIs, we don’t have support for the `IModelBinderProvider`
    and `IModelBinder` interfaces, but we have two alternatives to implement custom
    model binding.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，参数绑定的默认方式可能不足以满足我们的需求。在最小 API 中，我们没有 `IModelBinderProvider` 和 `IModelBinder`
    接口的支持，但我们可以通过两种替代方案来实现自定义模型绑定。
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The `IModelBinderProvider` and `IModelBinder` interfaces in controller-based
    projects allow us to define the mapping between the request data and the application
    model. The default model binder provided by ASP.NET Core supports most of the
    common data types, but, if necessary, we can extend the system by creating our
    own providers. We can find more information at the following link: [https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding](https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 基于控制器的项目中 `IModelBinderProvider` 和 `IModelBinder` 接口允许我们定义请求数据和应用程序模型之间的映射。ASP.NET
    Core 提供的默认模型绑定器支持大多数常见的数据类型，但如果需要，我们可以通过创建自己的提供者来扩展系统。更多信息请参阅以下链接：[https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding](https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding)。
- en: 'If we want to bind a parameter that comes from a route, query string, or header
    to a custom type, we can add a static `TryParse` method to the type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将来自路由、查询字符串或头部的参数绑定到自定义类型，我们可以在该类型中添加一个静态的 `TryParse` 方法：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `TryParse` method, we can try to split the input parameter and check
    whether it contains two decimal values: in this case, we parse the numbers to
    build the `Location` object and we return `true`. Otherwise, we return `false`
    because the `Location` object cannot be initialized.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TryParse` 方法中，我们可以尝试分割输入参数并检查它是否包含两个十进制值：在这种情况下，我们将数字解析为构建 `Location` 对象，并返回
    `true`。否则，我们返回 `false`，因为 `Location` 对象无法初始化。
- en: Important note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When the minimal API finds that a type contains a static `TryParse` method,
    even if it is a complex type, it assumes that it is passed in the route or the
    query string, based on the routing template. We can use the `[FromHeader]` attributes
    to change the binding source. In any case, `TryParse` will never be invoked for
    the body of the request.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当最小API发现一个类型包含一个静态的`TryParse`方法时，即使它是一个复杂类型，它也会假设它是根据路由模板传递进来的，或者是在查询字符串中。我们可以使用`[FromHeader]`属性来更改绑定源。在任何情况下，`TryParse`都不会被用于请求体。
- en: 'If we need to completely control how binding is performed, we can implement
    a static `BindAsync` method on the type. This isn’t a very common solution, but
    in some cases, it can be useful:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要完全控制绑定是如何执行的，我们可以在类型上实现一个静态的`BindAsync`方法。这不是一个非常常见的解决方案，但在某些情况下，它可能很有用：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see, the `BindAsync` method takes the whole `HttpContext` as an argument,
    so we can read all the information we need to create the actual `Location` object
    that is passed to the route handler. In this example, we read two query string
    parameters (`lat` and `lon`), but (in the case of `POST`, `PUT`, or `PATCH` methods)
    we can also read the entire body of the request and manually parse its content.
    This can be useful, for instance, if we need to handle requests that have a format
    other than JSON (which, as said before, is the only one supported by default).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`BindAsync`方法接受整个`HttpContext`作为参数，因此我们可以读取所有我们需要创建实际`Location`对象的信息，该对象被传递给路由处理程序。在这个例子中，我们读取了两个查询字符串参数（`lat`和`lon`），但在`POST`、`PUT`或`PATCH`方法的情况下），我们也可以读取整个请求体并手动解析其内容。这可能很有用，例如，如果我们需要处理格式不是JSON的请求（正如之前所说，这是默认支持的唯一格式）。
- en: If the `BindAsync` method returns `null`, while the corresponding route handler
    parameter cannot assume this value (as in the previous example), we will get an
    `HttpBadRequestException` error, which. as usual, will be wrapped in a `400 Bad
    Request` response.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`BindAsync`方法返回`null`，而相应的路由处理程序参数不能假设这个值（如前例所示），我们将得到一个`HttpBadRequestException`错误，通常，这个错误会被包裹在一个`400
    Bad Request`响应中。
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We shouldn’t define both the `TryParse` and `BindAsync` methods using a type;
    if both are present, `BindAsync` always has precedence (that is, `TryParse` will
    never be invoked).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该使用一个类型来定义`TryParse`和`BindAsync`方法；如果两者都存在，`BindAsync`总是有优先级（也就是说，`TryParse`永远不会被调用）。
- en: Now that we have looked at parameter binding and understood how to use it and
    customize its behavior, let’s see how to work with responses in minimal APIs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了参数绑定以及如何使用它和自定义其行为，让我们看看如何在最小API中处理响应。
- en: Exploring responses
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索响应
- en: 'As with controller-based projects, with route handlers of minimal APIs as well,
    we can directly return a string or a class (either synchronously or asynchronously):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基于控制器的项目一样，对于最小API的路由处理程序，我们也可以直接返回一个字符串或一个类（无论是同步还是异步）：
- en: If we return a string (as in the examples of the previous section), the framework
    writes the string directly to the response, setting its content type to `text/plain`
    and the status code to `200 OK`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们返回一个字符串（如前一部分的例子所示），框架会直接将字符串写入响应，将其内容类型设置为`text/plain`，状态码设置为`200 OK`
- en: If we use a class, the object is serialized into the JSON format and sent to
    the response with the `application/json` content type and a `200 OK` status code
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用一个类，对象将被序列化为JSON格式，并通过`application/json`内容类型和`200 OK`状态码发送到响应中
- en: 'However, in a real application, we typically need to control the response type
    and the status code. In this case, we can use the static `Results` class, which
    allows us to return an instance of the `IResult` interface, which in minimal APIs
    acts how `IActionResult` does for controllers. For instance, we can use it to
    return a `201 Created` response rather than a `400 Bad Request` or a`404 Not Found`
    message. L et’s look at some examples:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际应用中，我们通常需要控制响应类型和状态码。在这种情况下，我们可以使用静态的`Results`类，它允许我们返回`IResult`接口的一个实例，在最小API中，它表现得就像控制器中的`IActionResult`一样。例如，我们可以用它来返回`201
    Created`响应，而不是`400 Bad Request`或`404 Not Found`消息。让我们看看一些例子：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each method of the `Results` class is responsible for setting the response type
    and status code that correspond to the meaning of the method itself (e.g., the
    `Results.NotFound()` method returns a `404 Not Found` response). Note that even
    if we typically need to return an object in the case of a `200 OK` response (with
    `Results.Ok()`), it isn’t the only method that allows this. Many other methods
    allow us to include a custom response; in all these cases, the response type will
    be set to `application/json` and the object will automatically be JSON-serialized.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Results`类的每个方法都负责设置与该方法本身含义相对应的响应类型和状态码（例如，`Results.NotFound()`方法返回一个`404
    Not Found`响应）。请注意，即使我们通常需要在`200 OK`响应的情况下返回一个对象（使用`Results.Ok()`），这并不是唯一允许这样做的方法。许多其他方法允许我们包含自定义响应；在这些所有情况下，响应类型将设置为`application/json`，对象将自动进行JSON序列化。'
- en: The current version of minimal APIs does not support content negotiation. We
    only have a few methods that allow us to explicitly set the content type, when
    getting a file with `Results.Bytes()`, `Results.Stream()`, and `Results.File()`,
    or when using `Results.Text()` and `Results.Content()`. In all other cases, when
    we’re dealing with complex objects, the response will be in JSON format. This
    is a precise design choice since most developers rarely need to support other
    media types. By supporting only JSON without performing content negotiation, minimal
    APIs can be very efficient.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的最小API不支持内容协商。我们只有少数几个方法允许我们显式设置内容类型，当使用`Results.Bytes()`、`Results.Stream()`和`Results.File()`获取文件，或使用`Results.Text()`和`Results.Content()`时。在其他所有情况下，当我们处理复杂对象时，响应将以JSON格式。这是一个精确的设计选择，因为大多数开发者很少需要支持其他媒体类型。通过仅支持JSON而不执行内容协商，最小API可以非常高效。
- en: However, this approach isn’t enough in all scenarios. In some cases, we may
    need to create a custom response type, for example, if we want to return an HTML
    or XML response instead of the standard JSON. We can manually use the `Results.Content()`
    method (which allows us to specify the content as a simple string with a particular
    content type), but, if we have this requirement, it is better to implement a custom
    `IResult` type, so that the solution can be reused.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法并不适用于所有场景。在某些情况下，我们可能需要创建一个自定义响应类型，例如，如果我们想返回HTML或XML响应而不是标准的JSON。我们可以手动使用`Results.Content()`方法（它允许我们指定特定内容类型的简单字符串），但如果我们有这种需求，最好实现一个自定义的`IResult`类型，这样解决方案就可以重用。
- en: 'For example, let’s suppose that we want to serialize objects in XML instead
    of JSON. We can then define an `XmlResult` class that implements the `IResult`
    interface:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想以XML而不是JSON序列化对象。然后我们可以定义一个实现`IResult`接口的`XmlResult`类：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `IResult` interface requires us to implement the `ExecuteAsync` method,
    which receives the current `HttpContext` as an argument. We serialize the value
    using the `XmlSerializer` class and then write it to the response, specifying
    the correct response type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`IResult`接口要求我们实现`ExecuteAsync`方法，该方法接收当前的`HttpContext`作为参数。我们使用`XmlSerializer`类序列化值，然后将其写入响应，指定正确的响应类型。'
- en: 'Now, we can directly use the new `XmlResult` type in our route handlers. However,
    best practices suggest that we create an extension method for the `IResultExtensions`
    interface, as with the following one:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的路由处理程序中直接使用新的`XmlResult`类型。然而，最佳实践建议我们为`IResultExtensions`接口创建一个扩展方法，如下所示：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this way, we have a new `Xml` method available on the `Results.Extensions`
    property:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就在`Results.Extensions`属性上获得了一个新的`Xml`方法：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The benefit of this approach is that we can reuse it everywhere we need to deal
    with XML without having to manually handle the serialization and the response
    type (as we should have done using the `Result.Content()` method instead).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，我们可以在需要处理XML的地方重用它，而无需手动处理序列化和响应类型（正如我们应该使用`Result.Content()`方法所做的那样）。
- en: Tip
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we want to perform content validation, we need to manually check the `Accept`
    header of the `HttpRequest` object, which we can pass to our handlers, and then
    create the correct response accordingly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要执行内容验证，我们需要手动检查`HttpRequest`对象的`Accept`头，我们可以将其传递给我们的处理程序，然后根据需要创建正确的响应。
- en: After analyzing how to properly handle responses in minimal APIs, we’ll see
    how to control the way our data is serialized and deserialized in the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析如何正确处理最小API的响应之后，我们将在下一节中看到如何控制我们的数据在序列化和反序列化过程中的方式。
- en: Controlling serialization
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制序列化
- en: 'As described in the previous sections, minimal APIs only provide built-in support
    for the JSON format. In particular, the framework uses `System.Text.Json` for
    serialization and deserialization. In controller-based APIs, we can change this
    default and use JSON.NET instead. This is not possible when working with minimal
    APIs: we can’t replace the serializer at all.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，最小化 API 只提供对 JSON 格式的内置支持。特别是，框架使用 `System.Text.Json` 进行序列化和反序列化。在基于控制器的
    API 中，我们可以更改此默认设置并使用 JSON.NET。在最小化 API 的工作中这是不可能的：我们根本无法替换序列化器。
- en: 'The built-in serializer uses the following options:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 内置序列化器使用以下选项：
- en: Case-insensitive property names during serialization
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化期间不区分大小写的属性名称
- en: Camel case property naming policy
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驼峰式属性命名策略
- en: Support for quoted numbers (JSON strings for number properties)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持引号数字（数字属性的 JSON 字符串）
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We can find more information about the `System.Text.Json` namespace and all
    the APIs it provides at the following link: [https://docs.microsoft.com/dotnet/api/system.text.json](https://docs.microsoft.com/dotnet/api/system.text.json).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下链接中找到有关 `System.Text.Json` 命名空间及其提供的所有 API 的更多信息：[https://docs.microsoft.com/dotnet/api/system.text.json](https://docs.microsoft.com/dotnet/api/system.text.json)。
- en: 'In controller-based APIs, we can customize these settings by calling `AddJsonOptions()`
    fluently after `AddControllers()`. In minimal APIs, we can’t use this approach
    since we don’t have controllers at all, so we need to explicitly call the `Configure`
    method for `JsonOptions`. So, let’s consider this handler:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于控制器的 API 中，我们可以通过在 `AddControllers()` 后流畅地调用 `AddJsonOptions()` 来自定义这些设置。在最小化
    API 中，我们不能使用这种方法，因为我们根本没有任何控制器，因此我们需要显式调用 `Configure` 方法来配置 `JsonOptions`。所以，让我们考虑以下处理程序：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using the default JSON options, we get this result:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的 JSON 选项，我们得到以下结果：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s configure `JsonOptions`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置 `JsonOptions`：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Calling the `/product` endpoint again, we’ll now get the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用 `/product` 端点，我们现在将得到以下结果：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As expected, the `Description` property hasn’t been serialized because it is
    `null`, as well as `TotalPrice`, which isn’t included in the response because
    it is read-only.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`Description` 属性没有被序列化，因为它为 `null`，同样，`TotalPrice` 也没有包含在响应中，因为它只读。
- en: Another typical use case for `JsonOptions` is when we want to add converters
    that will be automatically applied for each serialization or deserialization,
    for example, `JsonStrinEnumConverter` to convert enumeration values into or from
    strings.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonOptions` 的另一个典型用例是我们想要添加将在每个序列化或反序列化过程中自动应用的转换器，例如，`JsonStringEnumConverter`
    将枚举值转换为字符串或从字符串转换。'
- en: Important note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be aware that the `JsonOptions` class used by minimal APIs is the one available
    in the `Microsoft.AspNetCore.Http.Json` namespace. Do not confuse it with the
    one that is defined in the `Microsoft.AspNetCore.Mvc` namespace; the name of the
    object is the same, but the latter is valid only for controllers, so it has no
    effect if set in a minimal API project.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最小化 API 使用的 `JsonOptions` 类是在 `Microsoft.AspNetCore.Http.Json` 命名空间中可用的。不要与在
    `Microsoft.AspNetCore.Mvc` 命名空间中定义的类混淆；对象的名称相同，但后者仅对控制器有效，因此在最小化 API 项目中设置时没有效果。
- en: 'Because of the JSON-only support, if we do not explicitly add support for other
    formats, as described in the previous sections (using, for example, the `BindAsync`
    method on a custom type), minimal APIs will automatically perform some validations
    on the body binding source and handle the following scenarios:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仅支持 JSON，如果我们没有明确添加对其他格式的支持，如前几节所述（例如，在自定义类型上使用 `BindAsync` 方法），最小化 API 将自动对正文绑定源执行一些验证并处理以下场景：
- en: '![Table 2.3 – The response status codes for body binding problems ](img/Table_2.03_B17902.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.3 – 正文绑定问题的响应状态码](img/Table_2.03_B17902.jpg)'
- en: Table 2.3 – The response status codes for body binding problems
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3 – 正文绑定问题的响应状态码
- en: In these cases, because body validation fails, our route handlers will never
    be invoked, and we will get the response status codes shown in the preceding table
    directly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，由于正文验证失败，我们的路由处理程序将永远不会被调用，我们将直接得到前面表格中显示的响应状态码。
- en: 'Now, we have covered all the pillars that we need to start developing minimal
    APIs. However, there is another important thing to talk about: the correct way
    to design a real project to avoid common mistakes within the architecture.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经涵盖了我们需要开始开发最小化 API 的所有支柱。然而，还有另一个重要的事情要讨论：正确设计真实项目的方法，以避免在架构中常见的错误。
- en: Architecting a minimal API project
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建最小化 API 项目架构
- en: 'Up to now, we have written route handlers directly in the `Program.cs` file.
    This is a perfectly supported scenario: with minimal APIs, we can write all our
    code inside this single file. In fact, almost all the samples show this solution.
    However, while this is allowed, we can easily imagine how this approach can lead
    to unstructured and therefore unmaintainable projects. If we have fewer endpoints,
    it is fine – otherwise, it is better to organize our handlers in separate files.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在 `Program.cs` 文件中直接编写了路由处理器。这是一个完全支持的场景：使用最小 API，我们可以在单个文件中编写所有代码。事实上，几乎所有示例都展示了这种解决方案。然而，虽然这是允许的，我们很容易想象这种方法如何导致项目无结构化和难以维护。如果我们有较少的端点，这没问题——否则，最好将我们的处理器组织在单独的文件中。
- en: 'Let’s suppose that we have the following code right in the `Program.cs` file
    because we have to handle CRUD operations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在 `Program.cs` 文件中直接有以下的代码，因为我们必须处理 CRUD 操作：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It’s easy to imagine that, if we have all the implementation here (even if
    we’re using `PeopleService` to extract the business logic), this file can easily
    explode. So, in real scenarios, the inline lambda approach isn’t the best practice.
    We should use the other methods that we have covered in the *Routing* section
    to define the handlers instead. So, it is a good idea to create an external class
    to hold all the route handlers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易想象，如果我们在这里有所有实现（即使我们使用 `PeopleService` 来提取业务逻辑），这个文件很容易变得庞大。因此，在实际场景中，内联
    lambda 方法并不是最佳实践。我们应该使用我们在 *路由* 部分中介绍的其他方法来定义处理器。因此，创建一个外部类来保存所有路由处理器是一个好主意：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have grouped all the endpoint definitions inside the `PeopleHandler.MapEndpoints`
    static method, which takes the `IEndpointRouteBuilder` interface as an argument,
    which in turn is implemented by the `WebApplication` class. Then, instead of using
    lambda expressions, we have created separate methods for each handler, so that
    the code is much cleaner. In this way, to register all these handlers in our minimal
    API, we just need the following code in `Program.cs`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将所有端点定义分组在 `PeopleHandler.MapEndpoints` 静态方法中，该方法接受 `IEndpointRouteBuilder`
    接口作为参数，该接口由 `WebApplication` 类实现。然后，我们不是使用 lambda 表达式，而是为每个处理器创建了单独的方法，这样代码就更加清晰。这样，为了在我们的最小
    API 中注册所有这些处理器，我们只需要在 `Program.cs` 中添加以下代码：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Going forward
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向前发展
- en: The approach just shown allows us to better organize a minimal API project,
    but still requires that we explicitly add a line to `Program.cs` for every handler
    we want to define. Using an interface and a bit of **reflection**, we can create
    a straightforward and reusable solution to simplify our work with minimal APIs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种刚刚展示的方法使我们能够更好地组织最小 API 项目，但仍然需要我们为每个要定义的处理器在 `Program.cs` 中显式添加一行。使用接口和一些
    **反射**，我们可以创建一个简单且可重用的解决方案，以简化我们对最小 API 的工作。
- en: 'So, let’s start by defining the following interface:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们先定义以下接口：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As the name implies, we need to make all our handlers (as with `PeopleHandler`
    previously) implement it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，我们需要让所有我们的处理器（就像之前的 `PeopleHandler` 一样）实现它：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `MapEndpoints` method isn’t static anymore, because now it is the implementation
    of the `IEndpointRouteHandler` interface.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapEndpoints` 方法不再静态，因为它现在是实现 `IEndpointRouteHandler` 接口的一个实现。'
- en: 'Now we need a new extension method that, using reflection, scans an assembly
    for all the classes that implement this interface and automatically calls their
    `MapEndpoints` methods:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个新扩展方法，它使用反射扫描程序集，查找实现此接口的所有类，并自动调用它们的 `MapEndpoints` 方法：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you want to go into further detail about reflection and how it works in
    .NET, you can start by browsing the following page: [https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/reflection](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/reflection).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解反射及其在 .NET 中的工作方式，你可以从浏览以下页面开始：[https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/reflection](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/reflection)。
- en: 'With all these pieces in place, the last thing to do is to call the extension
    method in the `Program.cs` file, before the `Run()` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些组件就绪之后，最后一步是在 `Program.cs` 文件中的 `Run()` 方法之前调用扩展方法：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this way, when we add new handlers, we should only need to create a new class
    that implements the `IEndpointRouteHandler` interface. No other changes will be
    required in `Program.cs` to add the new endpoints to the routing engine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们添加新的处理器时，我们只需要创建一个新的类来实现 `IEndpointRouteHandler` 接口。在 `Program.cs` 中添加新的端点不需要进行其他更改。
- en: Writing route handlers in external files and thinking about a way to automate
    endpoint registrations so that `Program.cs` won’t grow for each feature addition
    is the right way to architect a minimal API project.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部文件中编写路由处理程序，并思考一种自动化端点注册的方法，以便在添加每个功能时`Program.cs`文件不会增长，这是构建最小化API项目的正确方法。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: ASP.NET Core minimal APIs represent a new way of writing HTTP APIs in the .NET
    world. In this chapter, we covered all the pillars that we need to start developing
    minimal APIs, how to effectively approach them, and the best practices to take
    into consideration when deciding to follow this architecture.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core最小化API代表了在.NET世界中编写HTTP API的新方式。在本章中，我们涵盖了我们需要开始开发最小化API的所有支柱，如何有效地处理它们，以及决定遵循此架构时需要考虑的最佳实践。
- en: In the next chapter, we’ll focus on some advanced concepts such as documenting
    APIs with Swagger, defining a correct error handling system, and integrating a
    minimal API with a single-page application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注一些高级概念，例如使用Swagger记录API、定义正确的错误处理系统，以及将最小化API与单页应用程序集成。
