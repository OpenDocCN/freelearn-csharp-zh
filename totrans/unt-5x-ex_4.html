<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Continuing the Space Shooter</h1></div></div></div><p>This chapter continues from the previous one in creating a twin-stick space shooter game. At this stage, we have a working game. At least, the gamer can control a spaceship using two axes: movement and rotation. WASD keys on the keyboard control movement (up, down, left, and right) and the mouse cursor controls rotation—the spaceship always rotates to face the cursor. In addition to player controls, the level features enemy characters that spawn at regular intervals, fly around the level, and move toward the player with hostile intent. Finally, both the player and enemies support a Health component, which means both are susceptible to damage and can be destroyed. Right now, however, the player lacks two important features: it cannot fire a weapon and it cannot increase the score. This chapter tackles these issues and more. Firing weapons, as we'll see, represents a particularly interesting problem. Overall, this chapter covers the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Weapons and spawning ammo</li><li class="listitem" style="list-style-type: disc">Memory management and pooling</li><li class="listitem" style="list-style-type: disc">Sound and audio</li><li class="listitem" style="list-style-type: disc">Scoring</li><li class="listitem" style="list-style-type: disc">Debugging and testing</li><li class="listitem" style="list-style-type: disc">Building and distribution</li></ul></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>The completed project so far can be found in the book's companion files in the <code class="literal">Chapter04/Start</code> folder. You can start here and follow along with this chapter if you don't have your own project already.</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Guns and gun turrets</h1></div></div></div><p>Let's start tackling <a id="id235" class="indexterm"/>weapons in detail. Specifically, the level contains a <a id="id236" class="indexterm"/>player and enemy ships. The player must shoot enemies but, right now, cannot do so. See <em>Figure 4.1</em>. On thinking carefully about weapons, we identify three main concepts or things that need development. First, there's the spawner or generator—the object that actually fires ammo in the scene when the fire button is pressed. Second, there's the ammo itself that, once generated, travels through the level on its own. Third, there's the ability for ammo to collide with other objects and damage them.</p><div><img src="img/B05118_04_01.jpg" alt="Guns and gun turrets"/><div><p>Figure 4.1: The game so far</p></div></div><p>Tackling each area in order, we <a id="id237" class="indexterm"/>begin with turrets—the points where bullets are spawned and fired. For this game, the player will have only one turret, but ideally, the game should support the addition of more, if desired, allowing the player to dual-fire or <a id="id238" class="indexterm"/>more! To create the first turret, add a new empty game object to the scene by selecting <strong>GameObject</strong> | <strong>Create Empty</strong> from the application menu. Name this <code class="literal">Turret</code>. Then, position the <code class="literal">Turret</code> object to the front of the spaceship, making sure that the blue forward vector arrow is pointing ahead in the direction that ammo will be fired. Finally, make the turret a child of the spaceship by dragging and dropping it in the <strong>Hierarchy</strong> panel. See <em>Figure 4.2</em>:</p><div><img src="img/B05118_04_02.jpg" alt="Guns and gun turrets"/><div><p>Figure 4.2:Positioning a Turret object as a child of the spaceship</p></div></div><p>Creating a <code class="literal">Turret</code> object for the ammo as a spawn location is a splendid beginning, but for ammo to actually be <a id="id239" class="indexterm"/>fired, we'll need an ammo object. Specifically, we'll <a id="id240" class="indexterm"/>create an <code class="literal">Ammo</code> prefab that can be instantiated as ammo, when needed. We'll do this next.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Ammo prefabs</h1></div></div></div><p>When the player presses <a id="id241" class="indexterm"/>the fire button, the spaceship should shoot ammo objects in the scene. These objects will be based on an <code class="literal">Ammo</code> <a id="id242" class="indexterm"/>prefab. Let's create this prefab now. To start, we'll configure the texture to be used as an ammo graphic. Open the <code class="literal">Textures</code> folder in the <strong>Project</strong> panel, and select the <code class="literal">Ammo</code> texture. This texture features several different versions of an ammo sprite, aligned in a row side by side. See <em>Figure 4.3</em>. When ammo is fired, we don't want to show the complete texture; instead, we want to show either just one of the images or the images played as an animation sequence, frame by frame.</p><div><img src="img/B05118_04_03.jpg" alt="Ammo prefabs"/><div><p>Figure 4.3: Preparing to create an Ammo prefab</p></div></div><p>Presently, Unity recognizes the texture (and each ammo element) as a complete unit. We can use Sprite Editor, however, to separate each part. To do this, select the <strong>Texture</strong> in the project (if it's not already <a id="id243" class="indexterm"/>selected), and then (from the <strong>Object Inspector</strong>) change <a id="id244" class="indexterm"/>the <strong>Sprite Mode</strong> drop-down from <strong>Single</strong> to <strong>Multiple</strong>. This signifies that more than one sprite is contained within the texture space. See <em>Figure 4.4</em>:</p><div><img src="img/B05118_04_04.jpg" alt="Ammo prefabs"/><div><p>Figure 4.4: Select multiple sprites for textures featuring more than one sprite</p></div></div><p>Click on the <strong>Apply</strong> button, and then click on the <strong>Sprite Editor</strong> button from the <strong>Object Inspector</strong>. This opens the Sprite Editor, allowing you to separate each sprite. To do this, click and drag your mouse to select each sprite, making sure that the <strong>Pivot</strong> is aligned to the object <a id="id245" class="indexterm"/>
<strong>Center</strong>. See <em>Figure 4.5</em>. Then, click on <strong>Apply</strong> to accept the changes.</p><div><img src="img/B05118_04_05.jpg" alt="Ammo prefabs"/><div><p>Figure 4.5: Separating multiple sprites in the Sprite Editor</p></div></div><p>After accepting the changes in the Sprite Editor, Unity automatically cuts the relevant sprites into separate units, each of which can now be selected as a separate object in the <strong>Project</strong> panel. Click on the right arrow at the side of the texture, and all sprites within will expand outwards. See <em>Figure 4.6</em>:</p><div><img src="img/B05118_04_06.jpg" alt="Ammo prefabs"/><div><p>Figure 4.6: Expand all sprites within a texture</p></div></div><p>Now, drag and drop one of the sprites from the <strong>Project</strong> panel to the <strong>Scene</strong> via the <strong>Hierarchy</strong> panel. On doing this, it will be added as a sprite object. This represents the beginning of our <code class="literal">Ammo</code> prefab. The sprite itself may not initially be oriented to face upward at the game <a id="id246" class="indexterm"/>camera. If so, rotate the sprite by <strong>90</strong> degrees until it looks correct. See <em>Figure 4.7</em>:</p><div><img src="img/B05118_04_07.jpg" alt="Ammo prefabs"/><div><p>Figure 4.7: Aligning the ammo sprite</p></div></div><p>Now create a new, empty game object in the scene (<strong>GameObject</strong> | <strong>Create Empty</strong> from the application menu) and rename it <code class="literal">Ammo</code>. Make this new object a parent of <code class="literal">Ammo_Sprite</code> and ensure that its local forward vector is pointing in the direction that the ammo should travel. We'll soon reuse the <code class="literal">Mover</code> script (created in the previous chapter) on the ammo to make it move.</p><div><img src="img/B05118_04_08.jpg" alt="Ammo prefabs"/><div><p>Figure 4.8: Building an ammo object</p></div></div><p>Drag and drop the <code class="literal">Mover.cs</code> script from the <strong>Project</strong> panel to the <code class="literal">Ammo</code> parent object via the <strong>Hierarchy</strong> panel in order to add it as a component. Then, select the <code class="literal">Ammo</code> object and, from the <strong>Object Inspector</strong>, change the ammo's <strong>Max Speed</strong> in the <strong>Mover</strong> component to <code class="literal">7</code>. Finally, add a <strong>Box Collider</strong> to the object to approximate its volume (<strong>Component</strong> | <strong>Physics</strong> | <strong>Box Collider</strong> from the application menu), and then test this all in the viewport by pressing play on the <a id="id247" class="indexterm"/>toolbar. The <code class="literal">Ammo</code> object should shoot forward as though fired from a weapon. If it moves up or down incorrectly, then make sure that the parent object is rotated so that its blue forward vector really is pointing forward. See <em>Figure 4.9</em>:</p><div><img src="img/B05118_04_09.jpg" alt="Ammo prefabs"/><div><p>Figure 4.9: Moving forward with an Ammo prefab (Mover and Collider)</p></div></div><p>Next, add a <strong>Rigidbody</strong> component to the ammo to make it part of the Unity physics system. To do this, select the <code class="literal">Ammo</code> object and navigate to <strong>Component</strong> | <strong>Physics</strong> | <strong>Rigidbody</strong> from the application menu. Then, from the <strong>Rigidbody</strong> component in the <strong>Inspector</strong>, disable the <strong>Use Gravity</strong> checkbox to prevent the ammo from falling to the ground during gameplay. For our purposes, gravity need not apply to the ammo as it should simply travel along and eventually be destroyed. This highlights an important point in game <a id="id248" class="indexterm"/>development generally: real-world physics need not apply to every object accurately. We only need enough physics to make objects appear correct to the player when they're looking. See <em>Figure 4.10</em>:</p><div><img src="img/B05118_04_10.jpg" alt="Ammo prefabs"/><div><p>Figure 4.10: Removing gravity from the Ammo object</p></div></div><p>In addition to adding a <code class="literal">Mover</code> script and physics components, we also need the ammo to behave distinctly. Specifically, it should damage the objects with which it collides, and it should also destroy or disable itself on collision. To achieve this, a new script file must be created, <code class="literal">Ammo.cs</code>. The entire code for this is included in <em>Code Sample 4.1</em> as follows:</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class Ammo : MonoBehaviour
{
  public float Damage = 100f;
  public float LifeTime = 2f;
  //------------------------------
  void OnEnable()
  {
    CancelInvoke();
    Invoke("Die", LifeTime);
  }
  //------------------------------
  // Update is called once per frame
  void OnTriggerEnter(Collider Col)
  {
    //Get health component
      <strong>Health H = Col.gameObject.GetComponent&lt;Health&gt;();</strong>

    if(H == null)return;

    H.HealthPoints -= Damage;
  }
  //------------------------------
  void Die()
  {
    gameObject.SetActive(false);
  }

  //------------------------------
}
//------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>Code Sample 4-1</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Ammo</code> <a id="id249" class="indexterm"/>class should be attached to the <code class="literal">Ammo</code> prefab object and will be instantiated for all ammo objects created. Its main purpose is to damage any objects with which it collides.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">OnTriggerEnter</code> function is invoked for the ammo when it enters a trigger attached to a movable unit, such as the player or enemies. Specifically, it retrieves the <code class="literal">Health</code> component attached to the object, if it has one, and reduces its health by the <code class="literal">Damage</code> amount. The <code class="literal">Health</code> component was created in the previous chapter.</li><li class="listitem" style="list-style-type: disc">Notice that each ammo object will have a Lifetime. This represents the amount of time in seconds for which the ammo should remain alive and active after it is fired and generated in the scene. After the lifetime expires, the ammo should either be destroyed entirely or deactivated (more on this shortly).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Invoke</code> function is used to deactivate the ammo object after the <code class="literal">LifeTime</code> interval. This happens during the <code class="literal">OnEnable</code> event. This is called automatically by Unity each time an object is activated (that is, changed from being disabled to enabled).</li></ul></div><p>Now, drag and drop the <code class="literal">Ammo</code> script file from the <code class="literal">Scripts</code> folder in the <strong>Project</strong> panel to the <code class="literal">Ammo</code> object, and then finally, drag and drop the whole <code class="literal">Ammo</code> object in the <strong>Scene</strong> back to the <strong>Project</strong> panel in <a id="id250" class="indexterm"/>the <code class="literal">Prefabs</code> folder in order to create a new <code class="literal">Ammo</code> prefab. See <em>Figure 4.11</em>:</p><div><img src="img/B05118_04_11.jpg" alt="Code Sample 4-1"/><div><p>Figure 4.11: Creating an Ammo prefab</p></div></div><p>Congratulations! You've now created an <code class="literal">Ammo</code> prefab, which can be spawned from weapon points to attack enemies directly. This is good, but we've still not handled the spawning process itself and we'll address this next.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Ammo spawning</h1></div></div></div><p>The <code class="literal">Ammo</code> prefab created <a id="id251" class="indexterm"/>so far presents us with a technical problem that, if not taken seriously, has the potential to cause some serious performance <a id="id252" class="indexterm"/>penalties for our game. Specifically, when the spaceship weapon is fired, we'll need to generate ammo that launches into the scene and destroys the enemies on collision. This is fine in general, but the problem is that the player could potentially press the fire button many times in quick succession and could even hold down the fire button for long periods of time, and thereby spawn potentially hundreds of ammo prefabs. We could, of course, use the <code class="literal">Instantiate</code> function seen already to generate these prefabs dynamically, but this is problematic because instantiate is computationally expensive. When used to generate many items in succession, it will typically cause a nightmarish slowdown that'll reduce the FPS to unacceptable levels. We need to avoid this!</p><p>The solution is <a id="id253" class="indexterm"/>known as <strong>Pooling</strong>, <strong>Object Pooling</strong>, or <strong>Object Caching</strong>. In essence, it means <a id="id254" class="indexterm"/>that we must spawn a large and recyclable batch of ammo objects at <a id="id255" class="indexterm"/>the level startup (a pool of objects) that initially, begin hidden or deactivated, and we simply activate the objects as and when needed (when the player fires a weapon). When the ammo collides with an enemy or when its lifetime <a id="id256" class="indexterm"/>expires, we don't destroy the object entirely, we simply deactivate it again, returning it to the pool for reuse later if needed. In this way, we avoid all calls to <code class="literal">Instantiate</code> and simply recycle all ammo objects that we have. To get started with coding this functionality, we'll make an <code class="literal">AmmoManager</code> class. This class will be responsible for two features: first, generating a pool of ammo objects at scene startup, and second, giving us a valid and available ammo object from the pool on demand, such as on weapon-fire. Consider the following <code class="literal">AmmoManager</code> <em>Code Sample 4.2</em> to achieve this:</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
//------------------------------
public class AmmoManager : MonoBehaviour
{
  //------------------------------
  //Reference to ammo prefab
  public GameObject AmmoPrefab = null;

  //Ammo pool count
  public int PoolSize = 100;

  public Queue&lt;Transform&gt; AmmoQueue = new Queue&lt;Transform&gt;();

  //Array of ammo objects to generate
  private GameObject[] AmmoArray;

  public static AmmoManager AmmoManagerSingleton = null;
  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    if(AmmoManagerSingleton != null)
    {
      Destroy(GetComponent&lt;AmmoManager&gt;());
      return;
    }

    AmmoManagerSingleton = this;
    AmmoArray = new GameObject[PoolSize];

    for(int i=0; i&lt;PoolSize; i++)
    {
      AmmoArray[i] = Instantiate(AmmoPrefab, Vector3.zero, Quaternion.identity) as GameObject;
      Transform ObjTransform = AmmoArray[i].GetComponent&lt;Transform&gt;();
      ObjTransform.parent = GetComponent&lt;Transform&gt;();
      AmmoQueue.Enqueue(ObjTransform);
      AmmoArray[i].SetActive(false);
    }
  }
  //------------------------------
  public static Transform SpawnAmmo(Vector3 Position, Quaternion Rotation)
  {
    //Get ammo
    Transform SpawnedAmmo = AmmoManagerSingleton.AmmoQueue.Dequeue();

    SpawnedAmmo.gameObject.SetActive(true);
    SpawnedAmmo.position = Position;
    SpawnedAmmo.localRotation = Rotation;

    //Add to queue end
    AmmoManagerSingleton.AmmoQueue.Enqueue(SpawnedAmmo);

    //Return ammo
    return SpawnedAmmo;
  }
  //------------------------------
}
//------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Code Sample 4.2</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AmmoManager</code> <a id="id257" class="indexterm"/>features an <code class="literal">AmmoArray</code> member variable, which holds a complete list (sequential array of references) of all ammo objects to be generated at startup (during the <code class="literal">Awake</code> event).</li><li class="listitem" style="list-style-type: disc"><code class="literal">AmmoArray</code> will be sized to <code class="literal">PoolSize</code>. This refers to the total number of ammo objects to be generated. The <code class="literal">Awake</code> function generates the ammo objects at the beginning of the level, and these are added to the queue with <code class="literal">Enqueue</code>.</li><li class="listitem" style="list-style-type: disc">Once generated, each ammo object is deactivated with <code class="literal">SetActive(false)</code> and is held in the pool until needed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AmmoManager</code> uses the <code class="literal">Queue</code> class from the <code class="literal">Mono</code> library to manage how specific ammo objects are selected from the pool to be activated when fire is pressed. The queue works as a <strong>First-In-First-Out</strong> (<strong>FIFO</strong>) object. That is, ammo objects <a id="id258" class="indexterm"/>are added to the queue one at a time and can be removed when selected to be activated. The object removed from the queue is always the object at the front. More information on the <code class="literal">Queue</code> class can be found online at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx">https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Enqueue</code> function of the <code class="literal">Queue</code> object is called during <code class="literal">Awake</code> to add objects initially to the queue, one by one, as they are generated.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">SpawnAmmo</code> <a id="id259" class="indexterm"/>function should be called to generate a new item of ammo in the scene. This function does not rely on the <code class="literal">Instantiate</code> function but uses the <code class="literal">Queue</code> object instead. It removes the first ammo object from the queue, activates it, and then adds it to the end of the queue again behind all the other ammo objects. In this way, a cycle of generation and regeneration happens, allowing all ammo objects to be recycled.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AmmoManager</code> is coded as a singleton object, meaning that one, and only one, instance of the object should exist in the scene at any one time. This functionality is achieved through the static member, <code class="literal">AmmoManagerSingleton</code>. For more information on singleton objects, refer to <em>Mastering Unity Scripting</em> by <em>Packt Publishing</em> at <a class="ulink" href="https://www.packtpub.com/game-development/mastering-unity-5x-scripting">https://www.packtpub.com/game-development/mastering-unity-5x-scripting</a>.</li></ul></div><p>To use this class, create a new <code class="literal">GameObject</code> in the scene called <code class="literal">AmmoManager</code> by selecting <strong>GameObject</strong> | <strong>Create Empty</strong> from the application menu. Then, drag and drop the <code class="literal">AmmoManager</code> script from the <strong>Project</strong> panel to select the object in the scene. Once created, drag and drop the <code class="literal">Ammo</code> prefab from the <code class="literal">Prefabs</code> folder to the <strong>Ammo Prefab</strong> slot for the <strong>Ammo Manager</strong> component in the <strong>Object Inspector</strong>. See <em>Figure 4.12</em>:</p><div><img src="img/B05118_04_12.jpg" alt="Code Sample 4.2"/><div><p>Figure 4.12: Adding the Ammo Manager to an object</p></div></div><p>Now, the scene features an <code class="literal">AmmoManager</code> object to hold an ammo pool, offscreen and hidden. However, still nothing about our existing functionality actually connects a fire button press from the gamer with the generation of ammo in the scene. That is, we have no code to actually <a id="id260" class="indexterm"/>make the ammo visible and working! This connection should now be made via the <code class="literal">PlayerController</code> script that we started in the previous chapter. This class should now be amended to handle ammo generation. The recoded <code class="literal">PlayerController</code> class is included in the following <em>Code Sample 4.3</em>. The amendments are highlighted:</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class PlayerController : MonoBehaviour
{
  //------------------------------
  private Rigidbody ThisBody = null;
  private Transform ThisTransform = null;

  public bool MouseLook = true;
  public string HorzAxis = "Horizontal";
  public string VertAxis = "Vertical";
  <strong>public string FireAxis = "Fire1";</strong>

  public float MaxSpeed = 5f;
  <strong>public float ReloadDelay = 0.3f;</strong>
  <strong>public bool CanFire = true;</strong>

  <strong>public Transform[] TurretTransforms;</strong>
  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    ThisBody = GetComponent&lt;Rigidbody&gt;();
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void FixedUpdate ()
  {
    //Update movement
    float Horz = Input.GetAxis(HorzAxis);
    float Vert = Input.GetAxis(VertAxis);
    Vector3 MoveDirection = new Vector3(Horz, 0.0f, Vert);
    ThisBody.AddForce(MoveDirection.normalized * MaxSpeed);

    //Clamp speed
    ThisBody.velocity = new Vector3(Mathf.Clamp(ThisBody.velocity.x, -MaxSpeed, MaxSpeed),
    Mathf.Clamp(ThisBody.velocity.y, -MaxSpeed, MaxSpeed),
    Mathf.Clamp(ThisBody.velocity.z, -MaxSpeed, MaxSpeed));

    //Should look with mouse?
    if(MouseLook)
    {
      //Update rotation - turn to face mouse pointer
      Vector3 MousePosWorld = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, 0.0f));
      MousePosWorld = new Vector3(MousePosWorld.x, 0.0f, MousePosWorld.z);

      //Get direction to cursor
      Vector3 LookDirection = MousePosWorld - ThisTransform.position;

      //FixedUpdate rotation
      ThisTransform.localRotation = Quaternion.LookRotation(LookDirection.normalized,Vector3.up);
    }

    //Check fire control
    if(Input.GetButtonDown(FireAxis) &amp;&amp; CanFire)
    {
      foreach(Transform T in TurretTransforms)
        AmmoManager.SpawnAmmo(T.position, T.rotation);

      CanFire = false;
      Invoke ("EnableFire", ReloadDelay);
    }
  }
  //------------------------------
  <strong>void EnableFire()</strong>
  {
    CanFire = true;
  }
  //------------------------------
  public void Die()
  {
    Destroy(gameObject);
  }
}
//------------------------------</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Code Sample 4.3</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PlayerController</code> <a id="id261" class="indexterm"/>now features a <code class="literal">TurretTransform</code> array variable, listing all child empties being used as turret spawn locations.</li><li class="listitem" style="list-style-type: disc">During the <code class="literal">Update</code> function, <code class="literal">PlayerController</code> checks for fire button presses. If detected, the code cycles through all turrets and spawns one ammo object at each turret location.</li><li class="listitem" style="list-style-type: disc">Once ammo is fired, <code class="literal">ReloadDelay</code> is engaged (set to <code class="literal">true</code>). This means that the delay must first expire before new ammo can be fired again later.</li></ul></div><p>After adding this code to <code class="literal">PlayerController</code>, select the <code class="literal">Player</code> object in the scene and then drag and drop the <code class="literal">Turret</code> empty object on to the <code class="literal">TurretTransform</code> slot. This example uses only one turret, but you could add more if desired. See <em>Figure 4.13</em>:</p><div><img src="img/B05118_04_13.jpg" alt="Code Sample 4.3"/><div><p>Figure 4.13: Configuring TurretTransform for spawning ammo</p></div></div><p>Now you're ready to play test and fire ammo. By playing the scene and pressing fire on the keyboard or mouse (left-click), ammo will be generated. Excellent! However, on testing this, you may notice two main problems. First, the ammo appears too big or too small. Second, the ammo sometimes bounces, flips, or reacts to the player spaceship. Let's fix these in turn.</p><p>If the ammo appears <a id="id262" class="indexterm"/>wrongly-sized, you can simply change the scale of the prefab. Select the <code class="literal">Ammo</code> prefab in the <strong>Project</strong> panel, and from the <strong>Object Inspector</strong>, enter a new scale in the <strong>Transform</strong> component. See <em>Figure 4.14</em>:</p><div><img src="img/B05118_04_14.jpg" alt="Code Sample 4.3"/><div><p>Figure 4.14: Changing the Ammo prefab scale</p></div></div><p>If the ammo appears to bounce or react to the player spaceship, then we'll need to make the ammo immune or unresponsive to the player. To achieve this, we can use physics layers. In short, both the player spaceship and ammo should be added to a single layer, and all objects on <a id="id263" class="indexterm"/>this layer should be defined as immune to each other in terms of physical reactions. First, select the <code class="literal">Player</code> object in the scene. Then, from the <strong>Object Inspector</strong>, click on the <strong>Layer</strong> drop-down, and choose <strong>Add Layer</strong> from the context menu. See <em>Figure 4.15</em>:</p><div><img src="img/B05118_04_15.jpg" alt="Code Sample 4.3"/><div><p>Figure 4.15: Creating a new layer for Physics exclusions</p></div></div><p>Name the layer <code class="literal">Player</code>. This is to indicate that all objects attached to the layer are associated with the <code class="literal">Player</code>. See <em>Figure 4.16</em>:</p><div><img src="img/B05118_04_16.jpg" alt="Code Sample 4.3"/><div><p>Figure 4.16: Creating layers</p></div></div><p>Now, assign both the <code class="literal">Player</code> object in the scene and <code class="literal">Ammo</code> prefab in the <strong>Project</strong> panel to the newly created <strong>Player</strong> layer. Select each, and simply click on the <strong>Layer</strong> drop-down, selecting the <strong>Player</strong> <a id="id264" class="indexterm"/>option. See <em>Figure 4.17</em>. If prompted with a pop-up dialog, choose to change children also. This makes sure that all child objects are also associated with the same <strong>Layer</strong> as the parent.</p><div><img src="img/B05118_04_17.jpg" alt="Code Sample 4.3"/><div><p>Figure 4.17: Assigning Player and Ammo to the Player layer</p></div></div><p>Both <strong>Player</strong> and <strong>Ammo</strong> have now been assigned to the same layer. From here, we can make all objects in the same layer immune from each other insofar as <strong>Physics</strong> applies. To do this, navigate to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Physics</strong> from the application menu. See <em>Figure 4.18</em>:</p><div><img src="img/B05118_04_18.jpg" alt="Code Sample 4.3"/><div><p>Figure 4.18: Accessing Physics options</p></div></div><p>The global <strong>Physics</strong> settings appear in the <strong>Object Inspector</strong>. At the bottom of the <strong>Inspector</strong>, the <strong>Layer </strong>
<a id="id265" class="indexterm"/>
<strong>Collision Matrix</strong> displays how layers affect each other. Intersecting layers with a check mark can and will affect each other. For this reason, remove the check mark for the <strong>Player</strong> layer to prevent collisions occurring between objects on this layer. See <em>Figure 4.19</em>:</p><div><img src="img/B05118_04_19.jpg" alt="Code Sample 4.3"/><div><p>Figure 4.19: Setting the Layer Collision Matrix for improved collisions</p></div></div><p>With the <strong>Layer Collision Matrix</strong> set from the <strong>Object Inspector</strong>, test run the game so far by pressing play on the toolbar. When you do this and press fire, ammo will issue from the turrets and no longer react to the player spaceship. The ammo should, however, collide with, and <a id="id266" class="indexterm"/>destroy, the enemies. See <em>Figure 4.20</em>:</p><div><img src="img/B05118_04_20.jpg" alt="Code Sample 4.3"/><div><p>Figure 4.20: Destroying enemies by shooting guns!</p></div></div><p>Excellent work! We now have a spaceship that can fire weapons and destroy enemies, and the physics works as expected. Maybe you'd like to customize player controls a little or perhaps you want to <a id="id267" class="indexterm"/>use a gamepad. The next section will explore this issue further.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>User controls</h1></div></div></div><p>Maybe you don't like the <a id="id268" class="indexterm"/>default controls and key combinations associated with the input axes—<strong>Horizontal</strong>, <strong>Vertical</strong>, and <strong>Fire1</strong>. Maybe you want to change them. These input axes are read using the <code class="literal">Input.GetAxis</code> function (shown earlier) and are specified by human readable names, but it's not immediately clear how Unity maps specific input buttons and devices to these virtual axes. Here, we'll see briefly how to customize these. To get started, let's access the <strong>Input</strong> settings by navigating to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Input</strong> from the application menu. See <em>Figure 4.21</em>:</p><div><img src="img/B05118_04_21.jpg" alt="User controls"/><div><p>Figure 4.21: Accessing the Input menu</p></div></div><p>On selecting this option, a collection of custom-defined input axes appear as a list in the <strong>Object Inspector</strong>. See <em>Figure 4.22</em>. This defines all axes used by the input system. The <strong>Horizontal</strong> and <strong>Vertical</strong> axes should be listed here.</p><div><img src="img/B05118_04_22.jpg" alt="User controls"/><div><p>Figure 4.22: Exploring the input axes</p></div></div><p>By expanding each axis in the <strong>Object Inspector</strong>, you can easily customize how user input is mapped, that is, how specific keys and controls on hardware devices, such as a keyboard and mouse, will <a id="id269" class="indexterm"/>map to an axis. The <strong>Horizontal</strong> axis, for example, is defined twice. For the first definition, <strong>Horizontal</strong> is mapped to the <code class="literal">left</code>, <code class="literal">right</code>, and <em>A</em> and <em>D</em> keys on the keyboard. Right and <em>D</em> are mapped as <strong>Positive Button</strong> because, when pressed, they produce positive floating-point values from the <code class="literal">Input.GetAxis</code> function (0-1). Left and <em>A</em> are mapped as <strong>Negative Button</strong> because, when pressed, they result in negative floating-points values for <code class="literal">Input.GetAxis</code>. This makes it easy to move objects left and right using negative and positive numbers. See <em>Figure 4.23</em>:</p><div><img src="img/B05118_04_23.jpg" alt="User controls"/><div><p>Figure 4.23: Configuring an Input axis</p></div></div><p>Notice that <strong>Horizontal</strong> is defined twice in the <strong>Object Inspector</strong>—once near the top of the list and once near the bottom. These two definitions are accumulative and not contradictory—they stack atop one another. They allow you to map multiple devices to the same axis, giving you cross-platform and multidevice control over your games. By default, <strong>Horizontal</strong> is <a id="id270" class="indexterm"/>mapped in the first definition to the <code class="literal">left</code>, <code class="literal">right</code>, <em>A</em>, and <em>D</em> keys on the keyboard, and in the second definition, to joystick motion. Both definitions are valid and work together. You can have as many definitions for the same axis as you need, depending on the controls you need to support. See <em>Figure 4.24</em>:</p><div><img src="img/B05118_04_24.jpg" alt="User controls"/><div><p>Figure 4.24: Defining two horizontal axes</p></div></div><p>For this project, the controls will remain at their defaults, but go ahead and change or add additional controls if you <a id="id271" class="indexterm"/>want to support different configurations. More information on player input and customizing controls can be found in the <a id="id272" class="indexterm"/>online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/class-InputManager.html">http://docs.unity3d.com/Manual/class-InputManager.html</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Scores and scoring – UI and text objects</h1></div></div></div><p>Let's move on to the <a id="id273" class="indexterm"/>scoring system and, in creating this, we'll create <code class="literal">GameController</code>. <code class="literal">GameController</code> is simply a script or class that manages all game-wide and overarching behavior. This includes the score because, for this game, the score refers to one single and global number representing the achievements and progress of the player. Before jumping into the implementation, start by creating a simple GUI to display the game score. GUI <a id="id274" class="indexterm"/>is an acronym for Graphic User Interface, and this refers to all the 2D graphical elements that sit atop the game window and provide information to the player. To create this, create a new GUI canvas object by <a id="id275" class="indexterm"/>selecting <strong>GameObject</strong> | <strong>UI</strong> | <strong>Canvas</strong> from the application menu. See <em>Figure 4.25</em>. More details on GUIs can be found in the next two chapters.</p><div><img src="img/B05118_04_25.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.25: Adding a Canvas object to the scene</p></div></div><p>The <code class="literal">Canvas</code> object defines the total surface or area in which the GUI lives, including all buttons, text, and other widgets. On being generated in the scene, <code class="literal">Canvas</code> also features in the <strong>Hierarchy</strong> panel. Initially, the <code class="literal">Canvas</code> object may be too large or too small to be seen clearly in the viewport, so select the <code class="literal">Canvas</code> object in the <strong>Hierarchy</strong> panel and press the <em>F</em> key on the keyboard to <a id="id276" class="indexterm"/>focus the object. It should appear as a large <a id="id277" class="indexterm"/>vertically-aligned rectangle. See <em>Figure 4.26</em>:</p><div><img src="img/B05118_04_26.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.26: Examining the Canvas object in the viewport</p></div></div><p>The <code class="literal">Canvas</code> <a id="id278" class="indexterm"/>object is not visible itself in the <strong>Game</strong> tab. Rather, it acts simply as a container. Even so, it strongly influences how contained objects appear on the screen in terms of size, position, and scale. For this reason, before adding objects and refining the design of an interface, it's helpful to configure your <code class="literal">Canvas</code> object first. To do this, select the <code class="literal">Canvas</code> object in the scene, and from the <strong>Object Inspector</strong>, click on the <strong>UI Scale Mode</strong> drop-down option from the <strong>Canvas Scaler</strong> component. From the drop-down list, choose the <strong>Scale With Screen Size</strong> option and enter an HD resolution in the <strong>Reference Resolution</strong> field, that is, specify <code class="literal">1920</code> for the <strong>X</strong> field and <code class="literal">1080</code> for the <strong>Y</strong> field. See <em>Figure 4.27</em>:</p><div><img src="img/B05118_04_27.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.27: Adjusting the Canvas Scaler component</p></div></div><p>By adjusting the <strong>Canvas Scaler</strong> to <strong>Scale With Screen Size</strong>, the user interface for the game will automatically stretch and shrink (up- and down-scale) to fit the target resolution, ensuring that each element is scaled to the same proportions, maintaining the overall <a id="id279" class="indexterm"/>look and feel. This is a quick and easy method to create a UI once and have it adjust size to fit nearly any resolution. It may not always be the best solution to maintaining the highest quality graphical fidelity, but it's functional and suitable in many cases. In any case, before proceeding with the UI design, it's helpful to see both the <strong>Scene</strong> viewport and <strong>Game</strong> tab side by side in the interface (or across two monitors, if you have a multi-monitor configuration). This allows us to build the interface in the <strong>Scene</strong> viewport, and then preview its effects in the <strong>Game</strong> tab. You can rearrange the <strong>Scene</strong> and <strong>Game</strong> tabs simply by dragging and dropping the <strong>Game</strong> tab beside the <strong>Scene</strong> tab in the <strong>Unity Editor</strong>. See <em>Figure 4.28</em>:</p><div><img src="img/B05118_04_28.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.28: Docking the Scene and Game tabs side by side</p></div></div><p>Next, let's add the text widget to the GUI to display the game score. To do this, select the <code class="literal">Canvas</code> object in the <strong>Hierarchy</strong> panel, and then right-click on that object (in the <strong>Hierarchy</strong> panel) to display a context menu. From here, select <strong>UI</strong> | <strong>Text</strong>. This creates a new text object as a child of the <code class="literal">Canvas</code> object as opposed to a top-level object with no parent. See <em>Figure 4.29</em>. The <code class="literal">Text</code> object is useful to draw text onscreen with a specific color, size, and font setting.</p><div><img src="img/B05118_04_29.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.29: Creating a text object for the UI</p></div></div><p>By default, the <code class="literal">Text</code> object may not initially appear visible in either the scene or viewport, even though it's listed as an object in the <strong>Hierarchy</strong> panel. However, look more closely in the <a id="id280" class="indexterm"/>
<strong>Scene</strong> and you're likely to see very small and dark text, which appears both in the <strong>Canvas</strong> and <strong>Game</strong> tab. See <em>Figure 4.30</em>. By default, new text objects feature black text at a small font size. For this project, these settings will need to be changed.</p><div><img src="img/B05118_04_30.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.30: Newly created text objects can sometimes be difficult to see</p></div></div><p>Select the <code class="literal">Text</code> object in the <strong>Hierarchy</strong> panel, if it's not already selected, and from the <strong>Object Inspector</strong> (in the <strong>Text</strong> component), change the text <strong>Color</strong> to white and <strong>Font Size</strong> to <code class="literal">20</code>. See <em>Figure 4.31</em>:</p><div><img src="img/B05118_04_31.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.31: Changing text size and color</p></div></div><p>The text, however, still appears too small even after changing its size. If you increase the size further, however, the text may disappear from view. This happens because each <code class="literal">Text</code> object has a rectangular boundary defining its limits, and when the font size increases beyond what can fit in the boundary, the text is automatically hidden altogether. To fix this, we'll increase <a id="id281" class="indexterm"/>the text boundary. To do this, switch to the <strong>Rect Transform</strong> tool with <em>T</em> or select the tool from the toolbar. See <em>Figure 4.32</em>:</p><div><img src="img/B05118_04_32.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.32: Selecting the Rect Transform tool</p></div></div><p>On activating the <strong>Rect Transform</strong> tool, a clearly defined boundary will be drawn around the selected <code class="literal">Text</code> object in the <strong>Scene</strong> viewport, indicating its rectangular extents. Let's increase the boundary size to <a id="id282" class="indexterm"/>accommodate larger text. To do this, simply click and drag on the boundary edges with the mouse to extend them as needed. See <em>Figure 4.33</em>. This will increase the boundary size and now you can increase <strong>Font Size</strong> to improve text readability.</p><div><img src="img/B05118_04_33.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.33: Adjust the text rectangle to support larger font sizes</p></div></div><p>In addition to setting the text boundary size, the text can also be vertically aligned to the boundary center. Simply click on the center alignment button for the vertical group. For horizontal alignment, the text should remain left-aligned to allow for the score display. See <em>Figure 4.34</em>:</p><div><img src="img/B05118_04_34.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.34: Aligning text within the boundary</p></div></div><p>Although the text is <a id="id283" class="indexterm"/>now aligned vertically within its containing boundary, we'll still need to align it as a whole to the canvas container to ensure that it remains on screen at the same position and orientation, even if the <strong>Game</strong> window is resized and realigned. To do this, we'll use <strong>Anchors</strong>. To start, use the transform tool (<em>W</em>) to reposition the <code class="literal">Text</code> object to the top right corner of the screen at the location where the <strong>Score</strong> should appear. The object will automatically move within a 2D plane as opposed to 3D space. As you move the <code class="literal">Text</code> object in the <strong>Scene</strong> viewport, check its appearance in the <strong>Game</strong> tab to ensure that it looks correct and appropriate. See <em>Figure 4.35</em>:</p><div><img src="img/B05118_04_35.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.35: Positioning the Score text within the Game tab</p></div></div><p>To secure the position of the <code class="literal">Text</code> object on screen (preventing it from sliding or moving), even if the <a id="id284" class="indexterm"/>
<strong>Game</strong> tab is resized by the user, we can set the object's anchor position to the top right corner of the screen. This ensures that the text is always positioned as a constant, proportional offset from its anchor. To do this, click on the<strong> Anchor Presets</strong> button in the <strong>Rect Transform</strong> component in the <strong>Object Inspector</strong>. When you do this, a preset menu appears from which you can choose a range of alignment locations. Each preset is graphically presented as a small diagram, including a red dot at the location of anchor alignment. Select the top right preset. See <em>Figure 4.36</em>:</p><div><img src="img/B05118_04_36.jpg" alt="Scores and scoring – UI and text objects"/><div><p>Figure 4.36: Aligning the Text object to the screen</p></div></div><p>Excellent work! The <a id="id285" class="indexterm"/>
<code class="literal">Text</code> object is now created and ready to use. Of course, in play mode, the text remains unchanged and doesn't display a real score. That's because we need to add some code. However, overall, the <code class="literal">Text</code> object is in place and we can move on.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Working with scores – scripting with text</h1></div></div></div><p>To display a score in the <a id="id286" class="indexterm"/>GUI, we'll first need score functionality, that is, code to <a id="id287" class="indexterm"/>create a score system. Essentially, the score functionality will be added to a general, overarching <code class="literal">GameController</code> class, responsible for all game-wide logic and features. The code for <code class="literal">GameController</code> and its score feature set is included in <em>Code Sample 4.4</em>, as follows. This file should be added to the <code class="literal">Scripts</code> folder of the project.</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
<strong>using UnityEngine.UI;</strong>
//------------------------------
public class GameController : MonoBehaviour
{
  //Game score
  public static int Score;

  //Prefix
  public string ScorePrefix = string.Empty;

  //Score text object
  public Text ScoreText = null;

  //Game over text
  public Text GameOverText = null;

  public static GameController ThisInstance = null;
  //------------------------------
  void Awake()
  {
    ThisInstance = this;
  }
  //------------------------------
  void Update()
  {
    //Update score text
    if(ScoreText!=null)
      ScoreText.text = ScorePrefix + Score.ToString();
  }
  //------------------------------
  public static void GameOver()
  {
    if(ThisInstance.GameOverText!=null)
    ThisInstance.GameOverText.gameObject.SetActive(true);
  }
  //------------------------------
}</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Code Sample 4.4</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">GameController</code> class uses the <code class="literal">UnityEngine.ui</code> namespace. This is important <a id="id288" class="indexterm"/>because it includes access to all the UI classes and objects in Unity. If you don't include this namespace in your source files, then you cannot use UI objects from that script.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">GameController</code> class features two text public members, namely, <code class="literal">ScoreText</code> and <code class="literal">GameOverText</code>. These refer to two text objects, both of which are optional insofar as the <code class="literal">GameController</code> code will work just fine, even if the members are null. <code class="literal">ScoreText</code> is a reference to a text GUI object to display score text, and <code class="literal">GameOverText</code> is to display any message when a game-over condition occurs.</li></ul></div><p>To use the <code class="literal">GameController</code> code, create a new, empty object in the scene named <code class="literal">GameController</code>. Then, drag and drop the <code class="literal">GameController</code> script file to that object. Once added, drag and drop the <code class="literal">ScoreText</code> object to the <strong>Score Text</strong> field for <code class="literal">GameController</code> in the <strong>Object Inspector</strong>. See <em>Figure 4.37</em>. In the <strong>Score Prefix</strong> field, enter the text that should prefix the <code class="literal">Score</code> itself. The score, on its own, is simply a number (such as 1,000). The prefix allows you to add text to the front of this score, indicating to the player what the numbers mean.</p><div><img src="img/B05118_04_37.jpg" alt="Code Sample 4.4"/><div><p>Figure 4.37: Creating a GameController to maintain the game score</p></div></div><p>Now, take the game for a test run and you'll see the score display at the top right corner of the <code class="literal">Game</code> tab using the GUI text object. This is fine, but the score always remains at <code class="literal">0</code> right now. This is because we have no code, yet, to increase the score. For our game, the score should increase when an <code class="literal">Enemy</code> object is destroyed. To achieve this, we'll create a new script file, <code class="literal">ScoreOnDestroy</code>. This is included in <em>Code Sample 4.5</em>, as follows:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------
public class ScoreOnDestroy : MonoBehaviour
{
  //------------------------------
  public int ScoreValue = 50;
  //------------------------------
  void OnDestroy()
  {
    GameController.Score += ScoreValue;
  }
  //------------------------------
}
//------------------------------</pre></div><p>The script should be attached to any object that assigns you points when it's destroyed, such as the enemies. The total number of points assigned is specified by <code class="literal">ScoreValue</code>. To attach the script to the <a id="id289" class="indexterm"/>enemy prefab, select the <code class="literal">Prefabs</code> in the <strong>Project</strong> panel, and from the <strong>Object Inspector</strong>, click on the <strong>Add Component</strong> button. Then type <code class="literal">ScoreOnDestroy</code> in the search field to add the component to the prefab. Once added, specify the total number of points to be allocated for destroying an enemy. For this game, a value of 50 points is assigned. See <em>Figure 4.38</em>:</p><div><img src="img/B05118_04_38.jpg" alt="Code Sample 4.4"/><div><p>Figure 4.38: Adding a Score component to the Enemy prefab</p></div></div><p>Great work! You now have destroyable enemies that assign you points on destruction. This means that you can finally have an in-game score and could even extend gameplay to include high-score features and leaderboards. This also means that our game is almost finished and ready to build. Next, we'll add some final touches.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Polishing</h1></div></div></div><p>In this section, we'll <a id="id290" class="indexterm"/>add the final touches to the game. First on the agenda is to fix the game background! Until now, the background has simply displayed the default background color associated with the game camera. However, as the game is set in space, we should display a space background. To do this, create a new <strong>Quad</strong> object in the <strong>Scene</strong> that'll display a space image. Navigate to <strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Quad</strong> from the menu. Then rotate the object and move it downward so that it displays a flat, vertically-aligned backdrop. You may need to scale the object to look correct. See <em>Figure 4.39</em>:</p><div><img src="img/B05118_04_39.jpg" alt="Polishing"/><div><p>Figure 4.39: Creating a backdrop for the level and building a Quad</p></div></div><p>Now, drag and drop the space texture from the <strong>Project</strong> panel to <strong>Quad</strong> in the <strong>Scene</strong> to apply it as a material. Once assigned, select the <strong>Quad</strong> and change the <strong>Tiling</strong> settings from the material properties in the <strong>Object Inspector</strong>. Increase the <strong>X</strong> and <strong>Y</strong> tiling to <code class="literal">3</code>. See <em>Figure 4.40</em>:</p><div><img src="img/B05118_04_40.jpg" alt="Polishing"/><div><p>Figure 4.40: Configuring the texture tiling</p></div></div><p>If texture tiling seems broken for you, then be sure to check the Texture Importing settings. To do this, select the texture in the <strong>Project</strong> panel, and from the <strong>Object Inspector</strong>, ensure that <a id="id291" class="indexterm"/>
<strong>Texture Type</strong> is set to <strong>Texture</strong> and the <strong>Wrap Mode</strong> is set to <strong>Repeat</strong>. See <em>Figure 4.41</em>:</p><div><img src="img/B05118_04_41.jpg" alt="Polishing"/><div><p>Figure 4.41: Configuring a texture for seamless tiling</p></div></div><p>Now the level has a suitable background. Let's add some background music, which will play on a loop. To do this, first select the music track in the <strong>Project</strong> panel in the <code class="literal">Audio</code> folder. When selected, make sure that the music <strong>Load Type</strong>, from the <strong>Object Inspector</strong>, is set to <strong>Streaming</strong> and <strong>Preload Audio Data</strong> is disabled. See <em>Figure 4.42</em>. This improves loading times as Unity will not need to load all music data to memory as the scene begins.</p><div><img src="img/B05118_04_42.jpg" alt="Polishing"/><div><p>Figure 4.42: Configuring audio data ready for playback</p></div></div><p>Next, create a new, empty <strong>GameObject</strong> in the scene named <code class="literal">Music</code>, and then drag and drop the <code class="literal">Music</code> track from the <strong>Project</strong> panel to the <code class="literal">Music</code> object, adding it as an <strong>Audio Source</strong> component. <strong>Audio </strong>
<a id="id292" class="indexterm"/>
<strong>Source</strong> components play sound effects and music. See <em>Figure 4.43</em>:</p><div><img src="img/B05118_04_43.jpg" alt="Polishing"/><div><p>Figure 4.43: Creating a GameObject with an AudioSource component</p></div></div><p>From the <strong>Audio Source</strong> component in the <strong>Object Inspector</strong>, enable the <strong>Play On Awake</strong> and <strong>Loop</strong> checkboxes to ensure that the music is played from the level beginning and loops endlessly for as long as the game is running. The <strong>Spatial Blend</strong> field should be set to <code class="literal">0</code>, meaning 2D. In short, 2D sounds have a consistent volume throughout the level regardless of the player's position. This is because 2D sounds are not spatially located. 3D sounds, in contrast, are used for gunshots, footsteps, explosions, and other sounds that exist in 3D space and whose volume should change based on how close the player is standing to them when they play. See <em>Figure 4.44</em>:</p><div><img src="img/B05118_04_44.jpg" alt="Polishing"/><div><p>Figure 4.44: Looping a music track</p></div></div><p>Now, let's take the game for <a id="id293" class="indexterm"/>a test run! Click on the play button on the toolbar and test it out. If the music doesn't play, check that the <strong>Mute Audio</strong> button is not enabled from the <strong>Game</strong> tab. See <em>Figure 4.45</em>:</p><div><img src="img/B05118_04_45.jpg" alt="Polishing"/><div><p>Figure 4.45: Playing a game – disabling Mute Audio, if necessary</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Testing and diagnosis</h1></div></div></div><p>With practically all <a id="id294" class="indexterm"/>games, you'll need to spend considerable time testing and debugging heavily to reduce bugs and errors as much as humanly possible. With <a id="id295" class="indexterm"/>this sample program, very little debugging and testing has been required by you, but that's not because the game is simple. It's because I've already prechecked and pretested most of the code and functionality before presenting the material to you in this book, ensuring that you get a smooth learning experience. For your own projects, however, you'll need to do lots of testing. One way to get started is using the <strong>Stats</strong> panel. To open this, click on the <strong>Stats</strong> button on the <strong>Game</strong> tab. See <em>Figure 4.46</em>:</p><div><img src="img/B05118_04_46.jpg" alt="Testing and diagnosis"/><div><p>Figure 4.46: Viewing game performance information via the Stats panel</p></div></div><p>More details on the <a id="id296" class="indexterm"/>
<strong>Stats</strong> panel are included in <a class="link" href="ch02.html" title="Chapter 2. Project A – the Collection Game Continued">Chapter 2</a>, <em>Project A – the Collection Game Continued</em> of this book, and more information can be found online in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/RenderingStatistics.html">http://docs.unity3d.com/Manual/RenderingStatistics.html</a>.</p><p>Another debugging tool is the <strong>Profiler</strong>. This is useful when the <strong>Stats</strong> panel has already helped you identify a general problem, such as a low FPS, and you want to dig deeper to find where the problem might be located. More details on <strong>Profiler</strong> are included later in <a class="link" href="ch06.html" title="Chapter 6. Continuing the 2D Adventure">Chapter 6</a>, <em>Continuing the 2D Adventure</em> but a short introduction is worth including here. To access the <strong>Profiler</strong> tool, select <strong>Window</strong> | <strong>Profiler</strong> from the application menu. This displays the <strong>Profiler</strong> window. See <em>Figure 4.47</em>:</p><div><img src="img/B05118_04_47.jpg" alt="Testing and diagnosis"/><div><p>Figure 4.47: Accessing the Profiler window</p></div></div><p>With the <strong>Profiler</strong> window open, click on play on the toolbar to play test your game. When you do this, the <strong>Profiler</strong> window fills with color-coded performance data in a graph. See <em>Figure 4.48</em>. Green represents the performance of rendering (graphical) data. Reading and <a id="id297" class="indexterm"/>understanding the graph requires some experience, but as a <a id="id298" class="indexterm"/>general rule, watch out for mountains and peaks, that is, watch out for sharp fluctuations in the graph (sharp ups and downs) as this could indicate a problem, especially when it roughly coincides with frame rate drops.</p><div><img src="img/B05118_04_48.jpg" alt="Testing and diagnosis"/><div><p>Figure 4.48: During gameplay, the Profiler populates with data</p></div></div><p>If you want to investigate further, simply pause the game, and then click in the graph. The horizontal axis (<em>X</em> axis) represents the most recent frames, and the vertical axis represents workload. When <a id="id299" class="indexterm"/>you click in the graph, a line marker is added to indicate <a id="id300" class="indexterm"/>the frame under investigation. Beneath the graph, a list of all main processes for that frame are presented, typically ordered from top to bottom by the heaviness of their workload and proportion of frame time for which the process accounted. Heavier processes are listed at the top. See <em>Figure 4.49</em>:</p><div><img src="img/B05118_04_49.jpg" alt="Testing and diagnosis"/><div><p>Figure 4.49: Investigating performance data with the Profiler</p></div></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>More information on the <a id="id301" class="indexterm"/>
<strong>Profiler</strong> can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Profiler.html">http://docs.unity3d.com/Manual/Profiler.html</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Building</h1></div></div></div><p>Now, finally, we're <a id="id302" class="indexterm"/>ready to build our game to a standalone form ready to send off to friends, family, and testers! The process to do this is the same as detailed in <a class="link" href="ch02.html" title="Chapter 2. Project A – the Collection Game Continued">Chapter 2</a>, <em>Project A – the Collection Game Continued</em>, to build the coin collection game. From the application menu, choose <strong>File</strong> | <strong>Build Settings</strong>. From the build dialog, add our level to the level list by simply clicking on the <strong>Add Current</strong> button. Otherwise, drag and drop the level from the <strong>Project</strong> panel to the level list. See <em>Figure 4.50</em>:</p><div><img src="img/B05118_04_50.jpg" alt="Building"/><div><p>Figure 4.50: Preparing to build the space shooter</p></div></div><p>For this game, the target platform will be Windows. Consequently, select the <strong>PC, Mac &amp; Linux Standalone</strong> option from the <strong>Platform</strong> list, if it's not selected already. If the <strong>Switch Platform</strong> button (at the bottom left) is not disabled, then you will need to press this button, confirming to Unity that it should build for the selected platform as opposed to a different platform. Then, click on the <strong>Build And Run</strong> button. On clicking this, Unity prompts you to select a folder on your computer where the built file will be output and saved. Once generated, double-click the executable to run it and test. See <em>Figure 4.51</em>:</p><div><img src="img/B05118_04_51.jpg" alt="Building"/><div><p>Figure 4.51: Test running the game as a standard Windows executable</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Summary</h1></div></div></div><p>Great work! We're really on a roll now, having completed two solid Unity projects. The first project was a coin collection game and the second was a twin-stick shooter. Both are, ultimately, simple games in that they don't rely on advanced mechanics or display sophisticated features. However, even very sophisticated games, when boiled down to their fundamental ingredients, can be found to rest on a similar foundation of essential concepts such as the ones that we've covered so far. That's why our projects are so critical to understanding Unity in a deep way. Next, we'll move on to creating a more 2D-focused game, considering interfaces, sprites, and physics, and lots more!</p></div></body></html>