<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-61">
    <a id="_idTextAnchor061">
    </a>
    
     4
    
   </h1>
   <h1 id="_idParaDest-62">
    <a id="_idTextAnchor062">
    </a>
    
     Real-Time Interactions with SignalR
    
   </h1>
   <p>
    
     As part of ASP.NET Core 9, the web API is a framework for building HTTP services, which can be made available for both web page consumption and mobile applications.
    
    
     The structure provided by the .Net Core platform provides the development of APIs with high quality and performance.
    
    
     In this chapter, we will learn more about WebAPI, including the standards, conventions, and best practices for delivering solutions via
    
    
     
      a service.
     
    
   </p>
   <p>
    
     We will work on creating a real-time task management application where we will use various techniques available on the .NET platform and SignalR to learn about the concepts and implement an example of applications that use the Stream concept.
    
    
     We will also explore the premises for hosting SignalR applications on
    
    
     
      a server.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      What
     
     
      
       is SignalR?
      
     
    </li>
    <li>
     
      Understanding the concepts of server
     
     
      
       and clients
      
     
    </li>
    <li>
     
      Working
     
     
      
       with streaming
      
     
    </li>
    <li>
     
      Hosting the ASP.NET Core
     
     
      
       SignalR applications
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-63">
    <a id="_idTextAnchor063">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The code examples used in this chapter can be found in the book’s
    
    
     
      GitHub repository:
     
    
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter04">
     
      
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter04
      
     
    </a>
   </p>
   <h1 id="_idParaDest-64">
    <a id="_idTextAnchor064">
    </a>
    
     What is SignalR?
    
   </h1>
   <p>
    
     As we learned in previous chapters, web-based applications have two parts: the client and
    
    
     
      the Server.
     
    
   </p>
   <p>
    
     A
    
    <strong class="bold">
     
      browser
     
    </strong>
    
     generally represents the client, where the user interacts with the application.
    
    
     Applications have actions executed on a server to process information and return
    
    
     
      a response.
     
    
   </p>
   <p>
    
     This process is based on two phases, which are
    
    <strong class="bold">
     
      request
     
    </strong>
    
     and
    
    <strong class="bold">
     
      response
     
    </strong>
    
     .
    
    
     These phases happen in sequence.
    
    
     With each interaction between the client and the server, a new communication process
    
    
     
      is created.
     
    
   </p>
   <p>
    
     Most web applications have these features that are sufficient for most business contexts.
    
    
     However, there are scenarios where there is a need for a
    
    <strong class="bold">
     
      real-time communication model
     
    </strong>
    
     , where
    
    <a id="_idIndexMarker225">
    </a>
    
     the information processed by an application is constantly updated.
    
    
     This provides an immediate response to users, enriching usability and certain
    
    
     
      functional requirements.
     
    
   </p>
   <p>
    
     A good example of real-time applications would be, for example, a map application where users have traffic information on a given route, and are notified about any aspects that affect navigation.
    
    
     Furthermore, other types of applications such as games, social networks, or even collaborative web text editors depend on constant updates
    
    
     
      to users.
     
    
   </p>
   <p>
    
     To develop applications that contain real-time features, it would be necessary for the server and client to be able to communicate constantly on an
    
    
     
      active channel.
     
    
   </p>
   <p>
    
     The .NET platform has
    
    <a id="_idIndexMarker226">
    </a>
    
     SignalR.
    
    
     This is a library that adds the ability to build real-time solutions in a simplified way, instantly allowing constant communication between client
    
    
     
      and server.
     
    
   </p>
   <div><div><img alt="Figure 4.1 – SignalR components" src="img/B21788_04_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.1 – SignalR components
    
   </p>
   <p>
    
     As you can see,
    
    
     <em class="italic">
      
       Figure 4
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     demonstrates most of the SignalR components that abstract the communication model between the client and the server.
    
    
     Communication between the client and
    
    <a id="_idIndexMarker227">
    </a>
    
     the server occurs over an active connection, using a transport technique that transports JSON or binary messages.
    
    
     WebSockets is the standard communication technique used by SignalR.
    
    
     The other two options are used as fallback.
    
    
     In other words, if WebSockets is not supported, Server-sent events or long polling will be used immediately.
    
    
     The order of precedence for transport is the same as that established in the
    
    
     
      following list:
     
    
   </p>
   <ol>
    <li>
     <strong class="bold">
      
       WebSockets
      
     </strong>
     
      : It
     
     <a id="_idIndexMarker228">
     </a>
     
      provides the ability to establish a
     
     <em class="italic">
      
       full-duplex connection
      
     </em>
     
      , that is, allowing constant communication between client
     
     
      
       and server.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Server-sent events
      
     </strong>
     
      : It
     
     <a id="_idIndexMarker229">
     </a>
     
      establishes a
     
     <em class="italic">
      
       one-way connection
      
     </em>
     
      from the Server to the client.
     
     
      The client does not have the ability to send messages to the server over the same connection, requiring a separate
     
     
      
       HTTP request.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Long polling
      
     </strong>
     
      : It
     
     <a id="_idIndexMarker230">
     </a>
     
      is a more basic technique whereby the client sends a message to the server.
     
     
      Instead of sending an immediate message, the server then processes the information and only returns the response
     
     
      
       after finishing.
      
     
    </li>
   </ol>
   <p>
    
     SignalR abstracts
    
    <a id="_idIndexMarker231">
    </a>
    
     the choice of transport, making it possible to define the use of just WebSocket,
    
    
     
      if necessary.
     
    
   </p>
   <p>
    
     The connection between the client and the server depends on an important component called the Hub.
    
    
     The Hub is a special object.
    
    
     It’s a part of the SignalR API that acts as a proxy, allowing server-client communication, where the server can execute functions or methods on the client, remotely, through the use of
    
    <strong class="bold">
     
      RPC
     
    </strong>
    
     (
    
    <strong class="bold">
     
      Remote
     
    </strong>
    
     <strong class="bold">
      
       Procedure Call
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p class="callout-heading">
    
     RPC
    
   </p>
   <p class="callout">
    
     RPC is a
    
    <a id="_idIndexMarker232">
    </a>
    
     communication protocol that has existed since 1970 and serves as the basis for several innovations that currently exist, such as gRPC, a high-performance communication model developed by Google.
    
    
     You can find more information about RPC
    
    
     
      at
     
    
    <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">
     
      
       https://en.wikipedia.org/wiki/Remote_procedure_call
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     SignalR abstracts all the complexity of connection and communication management, in addition to bringing other capabilities, such as sending notifications to all connected clients, specific clients, or a group of clients.
    
    
     Additionally, APIs can be used in conjunction with .NET applications, even console, Java,
    
    
     
      and JavaScript.
     
    
   </p>
   <p>
    
     It is possible, for example, to have a server that communicates with a console application developed on the .NET or even
    
    
     
      Java platform.
     
    
   </p>
   <p>
    
     It may seem complex at first, but as we learn about the main concepts and good practices, we will come to understand how powerful the SignalR library is.
    
    
     Let’s explore some concepts, patterns, and good practices that involve SignalR and how to develop a real-time application using
    
    
     
      this library.
     
    
   </p>
   <h1 id="_idParaDest-65">
    <a id="_idTextAnchor065">
    </a>
    
     Understanding the concepts of Servers and Clients
    
   </h1>
   <p>
    
     As we learned earlier, SignalR is a powerful library that abstracts much of the complexity of creating
    
    
     
      real-time applications.
     
    
   </p>
   <p>
    
     However, it is important to know the concepts and standards related to using the SignalR library to benefit from
    
    
     
      its features.
     
    
   </p>
   <p>
    
     As we know, web applications basically have two main
    
    <a id="_idIndexMarker233">
    </a>
    
     components, the Client and the
    
    <a id="_idIndexMarker234">
    </a>
    
     Server.
    
    
     Likewise, real-time applications using SignalR require both client and server components.
    
    
     We will learn how these components interact with each other through a task
    
    
     
      management application.
     
    
   </p>
   <h2 id="_idParaDest-66">
    <a id="_idTextAnchor066">
    </a>
    
     Working with a task management application
    
   </h2>
   <p>
    
     The
    
    <a id="_idIndexMarker235">
    </a>
    
     task management application will be created
    
    <a id="_idIndexMarker236">
    </a>
    
     using
    
    <strong class="bold">
     
      Razor Pages
     
    </strong>
    
     technology and have the
    
    
     
      following functionalities:
     
    
   </p>
   <ul>
    <li>
     
      Implement concepts in
     
     
      
       real time
      
     
    </li>
    <li>
     
      
       Create tasks
      
     
    </li>
    <li>
     
      
       Complete tasks
      
     
    </li>
    <li>
     
      View
     
     
      
       created tasks
      
     
    </li>
    <li>
     
      View
     
     
      
       completed tasks
      
     
    </li>
   </ul>
   <p>
    
     All functionalities will be resolved using Visual Studio Code.
    
    
     JavaScript will be used to work with the functionalities on the Client side and C# will be used on the
    
    
     
      Server side.
     
    
   </p>
   <p>
    
     We can see an outline of the main components used in the application in
    
    
     <em class="italic">
      
       Figure 4
      
     </em>
    
    
     <em class="italic">
      
       .2
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 4.2 – TaskManager application components" src="img/B21788_04_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.2 – TaskManager application components
    
   </p>
   <p>
    
     As we
    
    <a id="_idIndexMarker237">
    </a>
    
     can see in
    
    
     <em class="italic">
      
       Figure 4
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     , we have some important components that will be used in
    
    
     
      the application.
     
    
   </p>
   <p>
    
     The Client will be implemented using Razor Pages, which will aim to allow user interaction in relation to the
    
    
     
      application’s functionalities:
     
    
   </p>
   <ul>
    <li>
     
      The
     
     <strong class="source-inline">
      
       index-page.js
      
     </strong>
     
      file will be responsible for managing interactions between the server and the application’s
     
     
      
       main page.
      
     
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       signalr.js
      
     </strong>
     
      file is part of the SignalR
     
     
      
       JavaScript SDK.
      
     
    </li>
    <li>
     
      The server is the Razor Page application that will act as an
     
     
      
       orchestrator server.
      
     
    </li>
    <li>
     
      The Hub implementation will be responsible for managing real-time communication between the server and
     
     
      
       the client.
      
     
    </li>
   </ul>
   <p>
    
     As we create
    
    <a id="_idIndexMarker238">
    </a>
    
     the project, we will explain how each component works and implementation details.
    
    
     For now, let’s start with creating
    
    
     
      the project.
     
    
   </p>
   <p>
    
     We will focus on the main activities for creating a task manager project.
    
    
     However, you can check the entire implementation of the solution in the book GitHub repository, mentioned in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section.
    
    
     Here are the steps we will
    
    
     
      be following:
     
    
   </p>
   <ol>
    <li>
     
      To create the project, open the terminal in a directory of your choice and run the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">dotnet new webapp -o TaskManager</strong></pre>
    </li>
    <li>
     
      A new folder called
     
     <strong class="source-inline">
      
       TaskManager
      
     </strong>
     
      will be created containing the entire project structure.
     
     
      Access this page with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">cd TaskManager</strong></pre>
    </li>
    <li>
     
      Now that the project has been created, we need to add the SignalR JavaScript SDK.
     
     
      It will not be necessary to add the SDK to the server, as it is automatically added when creating the project, as part of the .
     
     
      
       NET platform.
      
     
    </li>
   </ol>
   <p>
    
     As we are using Razor Pages, we will have the client and server in the same project.
    
    
     However, we can
    
    <a id="_idIndexMarker239">
    </a>
    
     create a
    
    <strong class="bold">
     
      Single-Page Application
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SPA
     
    </strong>
    
     ) solution and a WebAPI in Asp.NET Core 9 and perform the
    
    
     
      same procedures.
     
    
   </p>
   <p>
    
     We will continue with the Razor pages and go to the installation of the SignalR JavaScript SDK.
    
    
     We will use a tool
    
    <a id="_idIndexMarker240">
    </a>
    
     called
    
    <strong class="bold">
     
      LibMan
     
    </strong>
    
     , which
    
    <a id="_idIndexMarker241">
    </a>
    
     is a
    
    <strong class="bold">
     
      Command Line Interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CLI
     
    </strong>
    
     ) from Microsoft, responsible for managing client libraries.
    
    
     Its
    
    <a id="_idIndexMarker242">
    </a>
    
     operation is similar to
    
    <strong class="bold">
     
      Node Package
     
    </strong>
    
     <strong class="bold">
      
       Management
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       NPM
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     To use it, it is advisable to uninstall any previous version existing on your operating system.
    
    
     Therefore, we’ll follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Run the following commands in sequence to
     
     <a id="_idTextAnchor067">
     </a>
     
      install
     
     
      
       the tool:
      
     
     <pre class="source-code">
<strong class="bold">dotnet to LibraryManager.Cli ol uninstall -g Microsoft.Web.</strong>
<strong class="bold">dotnet tool install -g Microsoft.Web.LibraryManager.Cli</strong></pre>
    </li>
    <li>
     
      Next, we
     
     <a id="_idIndexMarker243">
     </a>
     
      will run the command to install the SignalR SDK.
     
     
      Run the following command and check in the application’s
     
     
      
       main directory:
      
     
     <pre class="source-code">
<strong class="bold">libman install @microsoft/signalr@latest -p unpkg -d wwwroot/js/signalr --files dist/browser/signalr.js</strong></pre>
     <p class="list-inset">
      
       The preceding command avoided installing the
      
      <strong class="source-inline">
       
        @microsoft/signalr@latest
       
      </strong>
      
       library and then only added the necessary scripts to the
      
      
       
        application directories.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     At this moment, the project is being created and prepared to receive implementations of real-time features.
    
    
     We must start by creating the Hub and configuring
    
    
     
      the application.
     
    
   </p>
   <h2 id="_idParaDest-67">
    <a id="_idTextAnchor068">
    </a>
    
     Creating the Hub
    
   </h2>
   <p>
    
     The Hub is one
    
    <a id="_idIndexMarker244">
    </a>
    
     of the most important components for implementing SignalR.
    
    
     It acts as a proxy that manages the connections of all clients to the server and allows both
    
    <a id="_idIndexMarker245">
    </a>
    
     the client and the server to talk to each other to execute methods in
    
    
     
      real time.
     
    
   </p>
   <p>
    
     For our
    
    <strong class="bold">
     
      TaskManager
     
    </strong>
    
     application, our first task will be to create a Hub and prepare it for communicating with clients.
    
    
     To do this, still in the terminal and the application directory, type the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
code .</pre>
   <p>
    
     This command will open an instance of VS Code in the
    
    
     
      application directory.
     
    
   </p>
   <p>
    
     At the root of the project, create a folder called
    
    <strong class="source-inline">
     
      Hubs
     
    </strong>
    
     and then a file
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       TaskManagerHub.cs
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The project
    
    <a id="_idIndexMarker246">
    </a>
    
     class will have two methods and will look like the code
    
    
     
      that follows:
     
    
   </p>
   <pre class="source-code">
public class TaskManagerHub : <strong class="bold">Hub</strong>
  {
    public async Task <strong class="bold">CreateTask</strong>(TaskModel taskModel)
    {
       // ..
    }
    public async Task <strong class="bold">CompleteTask</strong>(TaskModel taskModel)
    {
       // ..
    }
  }</pre>
   <p>
    
     The first detail to note is inherited from the
    
    <strong class="source-inline">
     
      Hub
     
    </strong>
    
     class.
    
    
     The
    
    <strong class="source-inline">
     
      Hub
     
    </strong>
    
     class is a superclass that abstracts all connection management and interaction with clients, available through the
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.SignalR
     
    </strong>
    
     package.
    
    
     All custom
    
    <strong class="source-inline">
     
      Hub
     
    </strong>
    
     classes must inherit from
    
    
     
      this class.
     
    
   </p>
   <p>
    
     Next, we have the
    
    <strong class="source-inline">
     
      CreateTask
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      CompleteTask
     
    </strong>
    
     methods.
    
    
     These methods will be invoked through clients and at the same time will invoke methods
    
    
     
      on clients.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      CreateTask
     
    </strong>
    
     method receives as a parameter a class called
    
    <strong class="source-inline">
     
      TaskModel
     
    </strong>
    
     .
    
    
     This class has been broken into the
    
    
     <strong class="source-inline">
      
       Model/TaskModel.cs
      
     </strong>
    
    
     
      directory:
     
    
   </p>
   <pre class="source-code">
public class TaskModel
  {
    public Guid Id { get;  } = Guid.NewGuid();
    public string Name { get; set; }
    public bool IsCompleted { get; set; }
    public TaskModel()
    {
       IsCompleted = false;
    }
    public TaskModel(string name) : this()
    {
      Name = name;
    }
    public TaskModel(string name, bool isCompleted)
    {
      Name = name;
      IsCompleted = isCompleted;
    }
  }</pre>
   <p>
    
     As we can see, the
    
    <strong class="source-inline">
     
      TaskModel
     
    </strong>
    
     class only has a few basic properties such as
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      IsCompleted
     
    </strong>
    
     , which represent
    
    
     
      a task.
     
    
   </p>
   <p>
    
     Communication
    
    <a id="_idIndexMarker247">
    </a>
    
     between the client and the server is done through a transport strategy, as mentioned previously, and WebSockets will generally be used.
    
    
     The information transmitted is serialized in JSON or binary.
    
    
     However, binary data, commonly used for audio, images, and videos, is not supported.
    
    
     Only text data will
    
    
     
      be transmitted.
     
    
   </p>
   <p>
    
     Now, let’s look at the complete implementation of the
    
    
     <strong class="source-inline">
      
       CreateTask
      
     </strong>
    
    
     
      method:
     
    
   </p>
   <pre class="source-code">
public async Task CreateTask(TaskModel taskModel)
  {
    <strong class="bold">_taskRepository</strong>.Save(taskModel);
    await <strong class="bold">Clients.All.SendAsync</strong>(ClientConstants
      .NOTIFY_TASK_MANAGER, taskModel);
  }</pre>
   <p>
    
     The preceding code performs
    
    <a id="_idIndexMarker248">
    </a>
    
     two
    
    
     
      basic procedures:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Persist a task
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       _taskRepository
      
     </strong>
     
      property is an interface that abstracts communication with a persistence layer.
     
     
      For this persistence project, it is being done in memory and the complete code for this implementation can be found in the book’s GitHub repository (see the
     
     <em class="italic">
      
       Technical
      
     </em>
     
      <em class="italic">
       
        requirements
       
      </em>
     
     
      
       section).
      
     
    </li>
    <li>
     <strong class="bold">
      
       Notify customers
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       Hub
      
     </strong>
     
      base class has a
     
     <strong class="source-inline">
      
       Client
      
     </strong>
     
      property with some functionality.
     
     
      In the code example, a notification is being made to all potential clients connected to
     
     <strong class="source-inline">
      
       Hub
      
     </strong>
     
      .
     
     
      The
     
     <strong class="source-inline">
      
       SendAsync
      
     </strong>
     
      method has 10 overloads of different variations.
     
     
      However, for the preceding code, two main parameters are being used.
     
     
      The first parameter concerns the name of the client method that will process the Hub’s response, while the second parameter is the task object itself that will be sent
     
     
      
       to clients.
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Constants are best practices
    
   </p>
   <p class="callout">
    
     As we noted in the
    
    <strong class="source-inline">
     
      SendAsync
     
    </strong>
    
     method, the first parameter references a constant.
    
    
     This is good practice as it is necessary to know the name of the method that will process the communication made through the server.
    
    
     Since it’s a string, it’s easy to make mistakes.
    
    
     Use constants whenever necessary to center strings containing method names.
    
    
     This will facilitate maintenance
    
    
     
      and improvements.
     
    
   </p>
   <p>
    
     With the Hub implemented, it will now be necessary to configure the application to handle communication
    
    
     
      through SignalR.
     
    
   </p>
   <h2 id="_idParaDest-68">
    <a id="_idTextAnchor069">
    </a>
    
     Preparing the server application
    
   </h2>
   <p>
    
     The
    
    <a id="_idIndexMarker249">
    </a>
    
     application needs to be configured to be able to handle connectivity between the client and the server.
    
    
     Without this step, the Hub will have
    
    
     
      no use.
     
    
   </p>
   <p>
    
     To do this, we
    
    <a id="_idIndexMarker250">
    </a>
    
     will need to change the code in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file and add some important lines
    
    
     
      of code.
     
    
   </p>
   <p>
    
     We must configure the SignalR services in the application container and map the Hub endpoint that will be used by the client to establish
    
    
     
      the connection.
     
    
   </p>
   <p>
    
     At the end of the changes, the file should be similar to the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
using TaskManager.Hubs;
using TaskManager.Service;
using TaskManager.Service.Contract;
var builder = WebApplication.CreateBuilder(args);
// Add Razor Page services to the container.
builder.Services.AddRazorPages();
//Add SignalR Services
<strong class="bold">builder.Services.AddSignalR();</strong>
// ..
var app = builder.Build();
// Some codes have been omitted to facilitate learning
app.MapRazorPages();
// Add Hub Endpoint
<strong class="bold">app.MapHub&lt;TaskManagerHub&gt;("/taskmanagerhub");</strong>
app.Run();</pre>
   <p>
    
     It is
    
    <a id="_idIndexMarker251">
    </a>
    
     very
    
    <a id="_idIndexMarker252">
    </a>
    
     important to follow the order in which the settings were made.
    
    
     The
    
    <strong class="source-inline">
     
      builder.Services.AddSignalR()
     
    </strong>
    
     method was added before the
    
    <strong class="source-inline">
     
      var app = builder.Build()
     
    </strong>
    
     line.
    
    
     Likewise, the Hub route mapping is added right after the
    
    
     <strong class="source-inline">
      
       app.MapRazorPages()
      
     </strong>
    
    
     
      statement.
     
    
   </p>
   <p>
    
     It is important to note the mapping of the Hub route, configured as
    
    <strong class="source-inline">
     
      /taskmanagerhub
     
    </strong>
    
     .
    
    
     The Hub route definition follows the same REST API pattern and this same route will be used so that client applications are able to establish connections with the server.
    
    
     The client will use the previously installed SignalR JavaScript SDK to connect to
    
    
     
      the Hub.
     
    
   </p>
   <p>
    
     The Hub is configured and ready to receive connections.
    
    
     Now, it’s time to configure
    
    
     
      the client.
     
    
   </p>
   <h2 id="_idParaDest-69">
    <a id="_idTextAnchor070">
    </a>
    
     Preparing the client application
    
   </h2>
   <p>
    
     With the
    
    <a id="_idIndexMarker253">
    </a>
    
     Hub configured, we must add the necessary features to the client application.
    
    
     To do this, we will use the
    
    <strong class="source-inline">
     
      Pages/index.cshtml
     
    </strong>
    
     page and
    
    <a id="_idIndexMarker254">
    </a>
    
     create the JavaScript that will orchestrate all interactions between the client and
    
    
     
      the server.
     
    
   </p>
   <p>
    
     Change the entire contents
    
    <a id="_idIndexMarker255">
    </a>
    
     of the
    
    <strong class="bold">
     
      Index.cshtml
     
    </strong>
    
     page to the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
@page
@model IndexModel
@{
    ViewData["Title"] = "Home page";
}
&lt;div class="text-center"&gt;
    &lt;h1 class="display-4"&gt;SignalR Task Manager&lt;/h1&gt;
&lt;/div&gt;
&lt;div class="task-form-container"&gt;
    &lt;h2&gt;Add a New Task&lt;/h2&gt;
    &lt;form method="post" class="task-form"&gt;
      &lt;input type="text" id="taskName"
        placeholder="Enter task name"
        class="task-input"/&gt;
      &lt;input type="button" value="Add Task"
        id="addTaskButton" class="task-submit"/&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;div class="tasks-container"&gt;
    &lt;h2&gt;Uncompleted Tasks&lt;/h2&gt;
    &lt;div class="tasks-list" id="uncompletedTaskList"&gt;
      &lt;/div&gt;
    &lt;h2&gt;Completed Tasks&lt;/h2&gt;
    &lt;div class="tasks-list" id="completedTaskList"&gt;
    &lt;/div&gt;
&lt;/div&gt;
<strong class="bold">@section Scripts {</strong>
<strong class="bold">    &lt;script src="img/signalr.js"</strong>
<strong class="bold">      asp-append-version="true"&gt;&lt;/script&gt;</strong>
<strong class="bold">    &lt;script src="img/index-page.js"</strong>
<strong class="bold">      asp-append-version="true"&gt;&lt;/script&gt;</strong>
<strong class="bold">}</strong></pre>
   <p>
    
     The HTML available is quite simple, just adding a form containing a field to name the task and a button that will be responsible for sending the new task to
    
    
     
      the server.
     
    
   </p>
   <p>
    
     Additionally, there
    
    <a id="_idIndexMarker256">
    </a>
    
     are two lists (completed tasks and uncompleted tasks) that will be displayed according to user interaction.
    
    
     We are not using any Razor Pages directives in the HTML elements, so it will not be necessary to make any changes to the
    
    
     <strong class="source-inline">
      
       Index.cshtml.cs
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     It is important
    
    <a id="_idIndexMarker257">
    </a>
    
     to note that to facilitate the understanding of the concepts of client and server, together with SignalR, we are using a Razor Pages application.
    
    
     However, it is possible to benefit from another approach called SPA, which makes it possible to use Frameworks such as Angular, React, or VueJS to create applications in JavaScript and HTML that run on the client and interact with
    
    
     
      the server.
     
    
   </p>
   <p class="callout-heading">
    
     SPA
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="bold">
     
      TaskManager
     
    </strong>
    
     application
    
    <a id="_idIndexMarker258">
    </a>
    
     uses Razor Pages to facilitate the explanation of SignalR concepts, concentrating the client and server in the same project.
    
    
     However, SignalR can be installed in a separate application that uses pure JavaScript, typescript, or any framework such as Angular, Vue.js, and so on.
    
    
     Furthermore, the SPA concept is a great practice for developing real-time functionalities.
    
    
     Otherwise, if there are several pages being loaded by the browser, with each new request, a new connection with the server is established.
    
    
     SPA makes it possible to render application pages dynamically while maintaining the same connection when
    
    
     
      using SignalR.
     
    
   </p>
   <p>
    
     Note that the HTML code uses a
    
    <strong class="source-inline">
     
      @section Scripts {}
     
    </strong>
    
     directive, where the previously installed SignalR libraries and the JavaScript file that we will create are added.
    
    
     This section was defined in the
    
    <strong class="source-inline">
     
      Pages/Shared/_Layout.cshtml
     
    </strong>
    
     file, as we learned in
    
    <a href="B21788_02.xhtml#_idTextAnchor031">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Create an
    
    <strong class="source-inline">
     
      index-page.js
     
    </strong>
    
     file in the
    
    <strong class="source-inline">
     
      wwwroot/js/index
     
    </strong>
    
     directory.
    
    
     The entire content of this file is available in the application’s source code in the
    
    
     
      book’s repository.
     
    
   </p>
   <p>
    
     Let’s focus on the most important points for establishing a connection with the Hub.
    
    
     To do this, we will basically need three
    
    
     
      main steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a
     
     
      
       connection object.
      
     
    </li>
    <li>
     
      Map
     
     
      
       the events.
      
     
    </li>
    <li>
     
      Start
     
     
      
       the connection.
      
     
    </li>
   </ol>
   <p>
    
     These three steps are defined in the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
var connection = new signalR.HubConnectionBuilder()
  .withUrl(HUB_URL).build();
connection.on(NOTIFY_TASK_MANAGER_EVENT, updateTaskList);
connection.start().then(function () {
     addTaskButton.disabled = false;
}).catch(function (err) {
     return console.error(err.toString());
});</pre>
   <p>
    
     In the
    
    <a id="_idIndexMarker259">
    </a>
    
     first line, we have the creation of the connection object using a SignalR object.
    
    
     Note that the
    
    <strong class="source-inline">
     
      withUrl(HUB_URL)
     
    </strong>
    
     method uses a
    
    <a id="_idIndexMarker260">
    </a>
    
     constant that must contain the value of the Hub URL.
    
    
     As we are using Razor Pages, the client and server will be available through the same address, and in this case, we can enter a relative URL such as
    
    <strong class="source-inline">
     
      /taskmanagerhub
     
    </strong>
    
     .
    
    
     This URL is exactly the endpoint that was previously mapped on
    
    
     
      the server.
     
    
   </p>
   <p>
    
     Next, we have the event implementation that will process the return from the server.
    
    
     In this case, we use the
    
    <strong class="source-inline">
     
      on
     
    </strong>
    
     method of the connection object.
    
    
     This method receives two parameters, the first being a string that represents the event.
    
    
     In this case, the
    
    <strong class="source-inline">
     
      NotifyTaskManager
     
    </strong>
    
     value was set to a constant.
    
    
     The
    
    <strong class="source-inline">
     
      updateTaskList
     
    </strong>
    
     method will process the return.
    
    
     We can use an inline function.
    
    
     However, to facilitate maintenance, we create a separate function that has the
    
    
     
      following signature:
     
    
   </p>
   <pre class="source-code">
function updateTaskList(taskModel) {
    //Code
}</pre>
   <p>
    
     This function could have any name and different types of parameters.
    
    
     However, the methods available in the Hub are sending the client a
    
    <strong class="source-inline">
     
      TaskModel
     
    </strong>
    
     object as a parameter.
    
    
     This object will be serialized in JSON or binary and SignalR will add it to the event corresponding to the processing of
    
    
     
      this return.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      updateTaskList
     
    </strong>
    
     function just gets the returned object and dynamically feeds the completed or incomplete task lists into the HTML
    
    
     
      using JavaScript.
     
    
   </p>
   <p class="callout-heading">
    
     Best practice
    
   </p>
   <p class="callout">
    
     It is good practice to use objects as method parameters, both on the client and on the server.
    
    
     This prevents us from having to change method signatures in applications if output and input parameters are modified.
    
    
     The use of objects simplifies information traffic between the client
    
    
     
      and server.
     
    
   </p>
   <p>
    
     It is
    
    <a id="_idIndexMarker261">
    </a>
    
     important to note that the name of the event must be the same both on the client and on the server, hence the use of constants to facilitate maintenance
    
    
     
      and writing.
     
    
   </p>
   <p>
    
     The third step is to
    
    <a id="_idIndexMarker262">
    </a>
    
     start the connection through the
    
    <strong class="source-inline">
     
      Start
     
    </strong>
    
     method of the connection object.
    
    
     The
    
    <strong class="source-inline">
     
      Start
     
    </strong>
    
     method delivers a promise that is triggered after the connection is established.
    
    
     Additionally, it is possible to implement the
    
    <strong class="source-inline">
     
      catch
     
    </strong>
    
     method, for mapping and any possible error when trying to connect with
    
    
     
      the Hub.
     
    
   </p>
   <p>
    
     Now it’s time to add the
    
    <strong class="source-inline">
     
      click
     
    </strong>
    
     event to the
    
    <strong class="bold">
     
      Add Task
     
    </strong>
    
     button, which will be responsible for requesting the addition of a new task, according to the code
    
    
     
      that follows:
     
    
   </p>
   <pre class="source-code">
var addTaskButton = document
  .getElementById("addTaskButton");
addTaskButton.addEventListener("click", function (event) {
    let taskName = document.getElementById(TASK_NAME_ID);
    connection.invoke(HUB_ADD_TASK_METHOD,
      { name: taskName.value }).catch(function (err) {
        return console.error(err.toString());
    });
    taskName.value = "";
    taskName.focus();
    event.preventDefault();
});</pre>
   <p>
    
     The
    
    <a id="_idIndexMarker263">
    </a>
    
     preceding code requests the server through the
    
    <strong class="source-inline">
     
      connection.Invoke()
     
    </strong>
    
     function, having the name of the method available in the Hub and a
    
    <strong class="source-inline">
     
      TaskModel
     
    </strong>
    
     object with the name defined through user input
    
    
     
      as parameters.
     
    
   </p>
   <p>
    
     We currently have
    
    <a id="_idIndexMarker264">
    </a>
    
     all the necessary requirements for the
    
    <strong class="bold">
     
      TaskManager
     
    </strong>
    
     application to have real-time functionality.
    
    
     Although it may seem complex, the approach is simple, requiring the client to be aware of the methods available on the server and the server to be aware of the events that can be executed on
    
    
     
      the client.
     
    
   </p>
   <p>
    
     Let’s analyze the application execution flow in
    
    
     
      more detail.
     
    
   </p>
   <h2 id="_idParaDest-70">
    <a id="_idTextAnchor071">
    </a>
    
     Understanding the client and server communication flow
    
   </h2>
   <p>
    
     With the
    
    <a id="_idIndexMarker265">
    </a>
    
     Hub and client properly configured, it’s time to understand how the communication flow will work.
    
    
     The flow for creating a task is represented according to
    
    
     <em class="italic">
      
       Figure 4
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 4.3 – Communication between the Client and Server using SignalR" src="img/B21788_04_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.3 – Communication between the Client and Server using SignalR
    
   </p>
   <p>
    
     The steps
    
    <a id="_idIndexMarker266">
    </a>
    
     shown in
    
    
     <em class="italic">
      
       Figure 4
      
     </em>
    
    <em class="italic">
     
      .3
     
    </em>
    
     simply illustrate the entire communication flow of the application.
    
    
     Let’s understand each of
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      After entering the task name, the user clicks the
     
     <strong class="bold">
      
       Add Task
      
     </strong>
     
      button.
     
     
      The button’s click event requests the
     
     <strong class="source-inline">
      
       CreateTask
      
     </strong>
     
      method, available on the server, through the Hub, passing a
     
     <strong class="source-inline">
      
       TaskModel
      
     </strong>
     
      object with the
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      property defined as a parameter.
     
     
      The invocation of the server-side method is done through the connection that was previously made to
     
     
      
       the Hub.
      
     
    </li>
    <li>
     
      Upon receiving a request for the
     
     <strong class="source-inline">
      
       CreateTask
      
     </strong>
     
      method, the Hub then processes the task, adding it to a list in memory through the
     
     <strong class="source-inline">
      
       Save
      
     </strong>
     
      method, which adds values to the
     
     <strong class="source-inline">
      
       Id
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        IsCompleted
       
      </strong>
     
     
      
       properties.
      
     
    </li>
    <li>
     
      Then, the Hub invokes the
     
     <strong class="source-inline">
      
       NotifyTaskManager
      
     </strong>
     
      method on the client, passing it as a parameter from the created
     
     
      <strong class="source-inline">
       
        TaskModel
       
      </strong>
     
     
      
       object.
      
     
    </li>
    <li>
     
      The client executes the method responsible for processing the server notification.
     
     
      This method was implemented in the SignalR connection object and updates the application screen, displaying the list of created tasks and the list of
     
     
      
       completed tasks.
      
     
    </li>
   </ol>
   <p>
    
     In this section, we
    
    <a id="_idIndexMarker267">
    </a>
    
     learned the main concepts of SignalR for implementing real-time communication between client and server.
    
    
     These concepts can be used in different types of applications, such as chat apps, order status updates in an online store, and so on.
    
    
     However, there are cases wherein we must work with a constant data-sending model between the client and server and this depends on another synchronization model that can be implemented with SignalR through the use of streaming.
    
    
     This concept is widely used in dashboards and applications such as news feeds.
    
    
     In the next section, we will understand how
    
    
     
      streaming works.
     
    
   </p>
   <h1 id="_idParaDest-71">
    <a id="_idTextAnchor072">
    </a>
    
     Working with streaming
    
   </h1>
   <p>
    
     In the context of SignalR, streaming is a
    
    <a id="_idIndexMarker268">
    </a>
    
     powerful way of sending data from the server to
    
    <a id="_idIndexMarker269">
    </a>
    
     the client and vice versa, in a continuous stream.
    
    
     Unlike traditional request/response models, where data is sent in a single batch, streaming allows for a constant flow of data, which is particularly useful for scenarios involving real-time updates, such as live feeds, dashboards, or even
    
    
     
      chat apps.
     
    
   </p>
   <p>
    
     Streaming on SignalR is characterized by several important features that make it an exceptional choice for real-time applications.
    
    
     Through a continuous flow, data is sent as soon as it becomes available, which is crucial to creating a real-time user experience.
    
    
     This means users receive updates immediately, keeping them
    
    
     
      constantly informed.
     
    
   </p>
   <p>
    
     Next, streaming operations in SignalR are inherently asynchronous, ensuring that the application remains responsive even when dealing with multiple streaming operations or large volumes of data.
    
    
     Lastly, SignalR supports bidirectional streaming, allowing not only server-to-client but also client-to-server
    
    
     
      data flows.
     
    
   </p>
   <p>
    
     This flexibility
    
    <a id="_idIndexMarker270">
    </a>
    
     opens up a wide range of possibilities for interactive applications where both the server and clients can initiate and participate in data exchanges, further enhancing the dynamic, real-time capabilities of applications built
    
    
     
      with SignalR.
     
    
   </p>
   <p>
    
     The streaming strategy is a powerful solution.
    
    
     However, it is important to keep some limitations and
    
    <a id="_idIndexMarker271">
    </a>
    
     challenges
    
    
     
      in mind:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Network dependency and stability
      
     </strong>
     
      : One of the main limitations of streaming on SignalR is its dependence on network quality.
     
     
      Since streaming involves a continuous flow of data, a stable and reliable network connection is crucial.
     
     
      Instabilities can cause a loss of connection, compromising the
     
     
      
       user experience.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Resource intensity
      
     </strong>
     
      : Streaming can be more resource-intensive than traditional request/response interactions.
     
     
      Since the server must maintain an open connection and continually process and send data, this can increase CPU and memory usage.
     
     
      In high-volume scenarios or with a large number of connected clients, this can become a significant challenge for resource management and
     
     
      
       expansion strategies.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Complexity in implementation and maintenance
      
     </strong>
     
      : Implementing streaming logic is generally more complex than dealing with standard request/response models due to the need to manage continuous connections and deal with asynchronous data streams.
     
     
      Additionally, it is challenging to debug streaming applications, especially when it comes to ensuring data integrity and dealing with
     
     
      
       network issues.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Scalability challenges
      
     </strong>
     
      : Scaling real-time streaming applications can be challenging as the number of concurrent users increases and the load on the server can
     
     
      
       increase quickly.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Limited browser support and compatibility issues
      
     </strong>
     
      : Although modern browsers generally support the technologies underlying SignalR, there may still be compatibility
     
     <a id="_idIndexMarker272">
     </a>
     
      issues, especially with
     
     
      
       older browsers.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Security considerations
      
     </strong>
     
      : With open and continuous connections, streaming applications may have different security considerations compared to traditional
     
     
      
       web applications.
      
     
    </li>
   </ul>
   <p>
    
     Understanding these limitations provides better strategy definition and application design to take advantage of the best benefits available
    
    
     
      in SignalR.
     
    
   </p>
   <h2 id="_idParaDest-72">
    <a id="_idTextAnchor073">
    </a>
    
     Implementing basic streaming
    
   </h2>
   <p>
    
     We already
    
    <a id="_idIndexMarker273">
    </a>
    
     understand the most important concepts of SignalR, such as how the Hub and the communication between the client and the server work.
    
    
     However, it is important to implement a simple application example to understand the
    
    
     
      streaming approach.
     
    
   </p>
   <p>
    
     There’s nothing better than making an application to capture the concepts we’re learning.
    
    
     Therefore, follow these steps to implement an application that
    
    
     
      uses streaming:
     
    
   </p>
   <ol>
    <li>
     
      Access your operating system’s terminal navigate to a directory of your choice and create a folder with the
     
     
      
       following instructions:
      
     
     <pre class="source-code">
<strong class="bold">mkdir SignalRStream</strong>
<strong class="bold">cd SignalRStream</strong></pre>
    </li>
    <li>
     
      Now, follow these steps to create
     
     
      
       the application:
      
     
     <ol>
      <li class="upper-roman">
       
        Run the following command to create
       
       
        
         the project:
        
       
       <pre class="source-code">
<strong class="bold">dotnet new webapp -o SignalRStreamingApp</strong></pre>
      </li>
      <li class="upper-roman">
       
        Then, access the created application directory and open Visual
       
       
        
         Studio code:
        
       
       <pre class="source-code"><strong class="bold">cd SignalRStreamingApp</strong>
<strong class="bold">code .</strong></pre>
      </li>
      <li class="upper-roman">
       
        In the same way as we did in
       
       <a id="_idIndexMarker274">
       </a>
       
        the
       
       <strong class="bold">
        
         TaskManager
        
       </strong>
       
        project, the first task will be to create a Hub.
       
       
        Create
       
       <a id="_idIndexMarker275">
       </a>
       
        a new folder called
       
       <strong class="source-inline">
        
         Hubs
        
       </strong>
       
        and then a class
       
       
        
         called
        
       
       
        <strong class="source-inline">
         
          StreamHub.cs
         
        </strong>
       
       
        
         :
        
       
       <pre class="source-code">using Microsoft.AspNetCore.SignalR;
using System.Threading.Channels;
namespace SignalRStream.Hubs;
public class StreamHub : Hub
{
    public ChannelReader&lt;int&gt; Countdown(int count)
    {
        var channel = Channel
          .CreateUnbounded&lt;int&gt;();
        _ = WriteItemsAsync(channel.Writer, count);
        return channel.Reader;
    }
    private async Task
      WriteItemsAsync(ChannelWriter&lt;int&gt;
      writer, int count)
    {
        for (int i = count; i &gt;= 0; i--)
        {
            await writer.WriteAsync(i);
            await Task.Delay(1000); // Simulates some delay
        }
        writer.TryComplete();
    }
}</pre>
      </li>
      <li class="upper-roman">
       
        This code has a
       
       <strong class="source-inline">
        
         Countdown
        
       </strong>
       
        method that returns a stream of integers counting down from a
       
       
        
         specified number.
        
       
      </li>
      <li class="upper-roman">
       
        Now
       
       <a id="_idIndexMarker276">
       </a>
       
        let’s change the
       
       <strong class="source-inline">
        
         Program.cs
        
       </strong>
       
        file by adding SignalR functionalities in the same way as we did in the
       
       <strong class="bold">
        
         TaskManager
        
       </strong>
       
        project.
       
       
        The class should look like the
       
       
        
         following code:
        
       
       <pre class="source-code">using TaskManager.Hubs;
using TaskManager.Service;
using TaskManager.Service.Contract;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorPages();
//Add SignalR
builder.Services.AddSignalR();
var app = builder.Build();
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.MapRazorPages();
// Add Hub Endpoint
app.MapHub&lt;StreamHub&gt;("/streamHub");
app.Run();</pre>
      </li>
      <li class="upper-roman">
       
        Add
       
       <a id="_idIndexMarker277">
       </a>
       
        the signalR client library using the
       
       
        <strong class="source-inline">
         
          libman
         
        </strong>
       
       
        
         application:
        
       
       <pre class="source-code"><strong class="bold">libman install @microsoft/signalr@latest -p unpkg -d wwwroot/js/signalr --files dist/browser/signalr.js</strong></pre>
      </li>
      <li class="upper-roman">
       
        Now we need to create a script to establish the connection to the Hub.
       
       
        To do this, create a file called
       
       <strong class="source-inline">
        
         index-stream.js
        
       </strong>
       
        in the
       
       <strong class="source-inline">
        
         wwwroo/js
        
       </strong>
       
        directory.
       
       
        This file must contain the
       
       
        
         following code:
        
       
       <pre class="source-code">const connection = new signalR.HubConnectionBuilder()
    .withUrl("/streamHub")
    .build();
connection.start().then(function () {
  <strong class="bold">connection.stream("Countdown", 10)</strong>.subscribe({
    <strong class="bold">next: (count)</strong> =&gt; {
      logStream(count);
    },
    <strong class="bold">complete: ()</strong> =&gt; {
      logStream("Stream completed");
    },
    <strong class="bold">error: (err)</strong> =&gt; {
      logStream(err);
    }
  });
}).catch(err =&gt; logStream(err.toString()));
function <strong class="bold">logStream(status)</strong> {
  let li = document.createElement("li");
  let ul = document.getElementById("ulLog");
  li.textContent = status;
  ul.appendChild(li);
}</pre>
      </li>
     </ol>
     <p class="list-inset">
      
       The
      
      <a id="_idIndexMarker278">
      </a>
      
       preceding code aims to connect the client application to the server, using the same approach learned in the previous session.
      
      
       In this example, first, there is the connection to the Hub.
      
      
       This is accomplished by creating the connection using the new
      
      <strong class="source-inline">
       
        SignalR.HubConnectionBuilder()
       
      </strong>
      
       line
      
      
       
        of code.
       
      
     </p>
     <p class="list-inset">
      
       Then, when starting the connection, the streaming approach is used, initiated by the
      
      <strong class="source-inline">
       
        connection.stream(..)
       
      </strong>
      
       method.
      
      
       The
      
      <strong class="source-inline">
       
        stream
       
      </strong>
      
       method depends on two arguments, the first being the name of the method that will be requested on the server, called
      
      <strong class="bold">
       
        Countdown
       
      </strong>
      
       , previously
      
      <a id="_idIndexMarker279">
      </a>
      
       created in the
      
      <strong class="source-inline">
       
        StreamHub.cs
       
      </strong>
      
       file.
      
      
       The second parameter is an integer value, where the countdown implemented in the server’s
      
      <strong class="source-inline">
       
        Countdown
       
      </strong>
      
       method will start.
      
      
       It is important to note that the number of parameters required by the stream method, in addition to the name of the function defined as a string, will vary according to the number of parameters implemented on
      
      
       
        the server.
       
      
     </p>
     <p class="list-inset">
      
       The
      
      <a id="_idIndexMarker280">
      </a>
      
       stream method has a nested method called
      
      <strong class="source-inline">
       
        subscribe
       
      </strong>
      
       , which has an implementation to obtain responses from the server.
      
      
       The
      
      <strong class="source-inline">
       
        subscribe
       
      </strong>
      
       method has an object that contains three main callback methods:
      
      <strong class="source-inline">
       
        next
       
      </strong>
      
       ,
      
      <strong class="source-inline">
       
        complete
       
      </strong>
      
       , and
      
      <strong class="source-inline">
       
        error
       
      </strong>
      
       .
      
      
       Each of these events is executed at a certain point in the streaming.
      
      
       The
      
      <strong class="source-inline">
       
        next
       
      </strong>
      
       method is used for the response sent from the server.
      
      
       The
      
      <strong class="source-inline">
       
        complete
       
      </strong>
      
       method is used when the streaming flow is finished and the error method is used if an error occurs.
      
      
       All three subscribe methods use a
      
      <strong class="source-inline">
       
        logStream
       
      </strong>
      
       javascript function implemented in the
      
      <strong class="source-inline">
       
        index-stream.js
       
      </strong>
      
       file that adds a list element to the HTML containing the response
      
      
       
        to events.
       
      
     </p>
     <ol>
      <li class="upper-roman" value="8">
       
        Next, we need to change the
       
       <strong class="source-inline">
        
         Pages/Index.cshtml
        
       </strong>
       
        file to the
       
       
        
         following code:
        
       
       <pre class="source-code">@page
@model IndexModel
@{
  ViewData["Title"] = "Home page";
}
&lt;div class="text-center"&gt;
  &lt;h1 class="display-4"&gt;Stream&lt;/h1&gt;
  &lt;ul id="ulLog"&gt;&lt;/ul&gt;
&lt;/div&gt;
@section Scripts {
  &lt;script src=
    "~/js/signalr/dist/browser/signalr.js"
    asp-append-version="true"&gt;
  &lt;/script&gt;
  &lt;script src="img/index-stream.js"
    asp-append-version="true"&gt;&lt;/script&gt;
}</pre>
      </li>
      <li class="upper-roman">
       
        Now, just run
       
       <a id="_idIndexMarker281">
       </a>
       
        the application using the
       
       
        
         following command:
        
       
       <pre class="source-code"><strong class="bold">dotnet run</strong></pre>
      </li>
     </ol>
    </li>
   </ol>
   <div><div><img alt="Figure 4.4 – SignalR streaming app" src="img/B21788_04_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.4 – SignalR streaming app
    
   </p>
   <p>
    
     As seen in
    
    
     <em class="italic">
      
       Figure 4
      
     </em>
    
    <em class="italic">
     
      .4
     
    </em>
    
     , we have a countdown starting from the number
    
    <strong class="bold">
     
      10
     
    </strong>
    
     and, at the end, there is a
    
    <strong class="bold">
     
      Stream Completed
     
    </strong>
    
     message, which determines the end of the streaming.
    
    
     In this example, the
    
    <strong class="source-inline">
     
      next
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      complete
     
    </strong>
    
     events from the
    
    <strong class="source-inline">
     
      subscribe
     
    </strong>
    
     method were used.
    
    
     This way, we can work with constant interaction between the client and the server using streaming, bringing greater power to
    
    
     
      our applications.
     
    
   </p>
   <p>
    
     The application
    
    <a id="_idIndexMarker282">
    </a>
    
     is very simple and basically generates a list of numbers obtained through the connection to the Hub, with a small delay to
    
    
     
      simulate latency.
     
    
   </p>
   <p>
    
     The stream approach is very interesting for transporting small blocks of information and allowing active processing in parts, ensuring a better
    
    
     
      user experience.
     
    
   </p>
   <p>
    
     We already understand the main features available in SignalR, but now let’s learn what is needed to host applications on
    
    
     
      a server.
     
    
   </p>
   <h1 id="_idParaDest-73">
    <a id="_idTextAnchor074">
    </a>
    
     Hosting the ASP.NET Core SignalR application
    
   </h1>
   <p>
    
     Like any
    
    <a id="_idIndexMarker283">
    </a>
    
     web-based application, we must make them available through a server after the development stage.
    
    
     Applications developed in ASP.NET Core SignalR have the same characteristics and with all the power of the .NET platform, there is the possibility of hosting on internal servers and different
    
    
     
      cloud providers.
     
    
   </p>
   <p>
    
     We will discuss more about hosting applications in
    
    <a href="B21788_10.xhtml#_idTextAnchor162">
     
      <em class="italic">
       
        Chapter 10
       
      </em>
     
    </a>
    
     .
    
    
     For now, we will just learn what is necessary to generate a hostable package for a
    
    
     
      SignalR application.
     
    
   </p>
   <h2 id="_idParaDest-74">
    <a id="_idTextAnchor075">
    </a>
    
     The basics of hosting a SignalR application
    
   </h2>
   <p>
    
     Hosting
    
    <a id="_idIndexMarker284">
    </a>
    
     an ASP.NET Core SignalR application isn’t drastically different from hosting a regular ASP.NET Core web app.
    
    
     However, due to the real-time nature of SignalR, there are specific considerations to keep
    
    
     
      in mind.
     
    
   </p>
   <p>
    
     It is important to define what the hosting model will be.
    
    
     In general, currently public clouds are selected, such as Azure, AWS, or GCP (Google).
    
    
     However, let’s understand each type of hosting available for ASP.NET Core
    
    
     
      9 applications:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Traditional hosting (IIS, Nginx, and Apache)
      
     </strong>
     
      : These are standard web servers that can also serve SignalR applications.
     
     
      They mainly act as reverse proxies, forwarding client requests to the
     
     
      
       SignalR application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Cloud hosting
      
     </strong>
     
      : Cloud platforms offer robust and scalable hosting environments.
     
     <strong class="bold">
      
       Azure App Service
      
     </strong>
     
      , for
     
     <a id="_idIndexMarker285">
     </a>
     
      example, provides an easy-to-use hosting model for ASP.NET Core applications, including those
     
     
      
       using SignalR.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Containers (Docker and Kubernetes)
      
     </strong>
     
      : For those looking for more control over their
     
     <a id="_idIndexMarker286">
     </a>
     
      hosting
     
     <a id="_idIndexMarker287">
     </a>
     
      environment, containerization offers a way to package the SignalR application with all its dependencies, ensuring consistency across
     
     
      
       different environments.
      
     
    </li>
   </ul>
   <p>
    
     After defining
    
    <a id="_idIndexMarker288">
    </a>
    
     the hosting server, the process of hosting the application follows approximately
    
    
     
      four steps:
     
    
   </p>
   <ol>
    <li>
     <strong class="bold">
      
       Publishing the application
      
     </strong>
     
      : Use Visual Studio or the .NET CLI to publish your application, generating a deployable unit.
     
     
      This task can be done by running the following command as an example that compiles the application in the
     
     <strong class="source-inline">
      
       Release
      
     </strong>
     
      mode and generates publication files in the
     
     
      <strong class="source-inline">
       
        Published
       
      </strong>
     
     
      
       folder:
      
     
     <pre class="source-code">
<strong class="bold">dotnet pubilish -c Release -o ./Published</strong></pre>
    </li>
    <li>
     <strong class="bold">
      
       Configuring the server
      
     </strong>
     
      : Whether it’s IIS, a Linux server with Nginx/Apache, or a cloud service, you will need to configure the server or service to host your application.
     
     
      This includes installing the necessary .NET runtimes, in the case of IIS or Nginex/Apache servers, and configuring the web server or
     
     
      
       cloud service.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Configuring reverse proxy (if necessary)
      
     </strong>
     
      : For IIS, Nginx, and Apache, ensure they are configured to correctly forward requests to your ASP.NET Core application.
     
     
      This is crucial for SignalR as it relies on
     
     
      
       persistent connections.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Deploying the application
      
     </strong>
     
      : Upload or deploy the published application to your hosting environment.
     
     
      This can be done via FTP, Web Deploy, or CI/CD pipelines if you are using cloud services
     
     
      
       or containerization.
      
     
    </li>
   </ol>
   <p>
    
     Hosting SignalR applications presents unique challenges due to their nature of maintaining persistent connections to clients and can significantly burden
    
    
     
      server resources.
     
    
   </p>
   <p>
    
     It is important to be aware of the connection limits of your server or hosting plan, as each will have a maximum number of simultaneous connections it can support.
    
    
     In environments where load balancing is employed, the use of sticky sessions is recommended to preserve the integrity of connections, ensuring that a client communicates consistently with the same
    
    
     
      server instance.
     
    
   </p>
   <p>
    
     Additionally, as
    
    <a id="_idIndexMarker289">
    </a>
    
     the number of concurrent connections increases, you may need to expand your application, involving deploying multiple instances of your application and distributing traffic between them.
    
    
     This would let you increase your ability to effectively manage a larger volume of concurrent connections.
    
    
     This approach helps maintain the optimal performance and reliability of your SignalR application under
    
    
     
      heavy load.
     
    
   </p>
   <p>
    
     However, we understand that SignalR applications add the option of developing real-time applications using ASP.NET Core 9 and their hosting does not present major differences from traditional
    
    
     
      web-based applications.
     
    
   </p>
   <p>
    
     In
    
    <a href="B21788_10.xhtml#_idTextAnchor162">
     
      <em class="italic">
       
        Chapter 10
       
      </em>
     
    </a>
    
     , we will explore in greater detail how we can host any type of web-based application dynamically, using the best
    
    
     
      practices available.
     
    
   </p>
   <h1 id="_idParaDest-75">
    <a id="_idTextAnchor076">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned vital skills for creating dynamic real-time applications.
    
    
     We learned about the powerful features of ASP.NET Core 9 SignalR, its architectural model and fundamentals, and supporting technologies, as well as creating a real-time task management application.
    
    
     Furthermore, we explained the concepts of streaming in SignalR and covered the main activities required to host SignalR applications
    
    
     
      on servers.
     
    
   </p>
   <p>
    
     In the next chapter, we will explore working with data and persistence by learning the aspects of data management and persistence in ASP.NET Core 9 applications, using technologies such as Entity Framework Core.
    
    
     We will delve deeper into your understanding of database interactions and state management.
    
    
     These are essential components for any
    
    
     
      web-based application.
     
    
   </p>
  </div>
 

  <div><h1 id="_idParaDest-76" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor077">
    </a>
    
     Part 2: Data and Security
    
   </h1>
   <p>
    
     When developing modern web solutions, we must deal with data persistence models and, of course, security.
    
    
     In this part, we will cover the principles, patterns, and best practices for connecting applications developed in ASP.NET Core 9 to databases such as SQL Server.
    
    
     We will learn about the entity-relational and NoSQL persistence models.
    
    
     We will learn how ASP.NET Core 9 provides powerful tools for interacting with data access layers and we will learn about the use of technologies such as EntityFramework Core and Dapper.
    
    
     In addition to interacting with data, we will learn about aspects related to application security, understanding the use of authorization and authentication, and how to implement applications that restrict access to information using ASP.NET
    
    
     
      Core Identity.
     
    
   </p>
   <p>
    
     This part has the
    
    
     
      following chapters:
     
    
   </p>
   <ul>
    <li>
     <a href="B21788_05.xhtml#_idTextAnchor078">
      <em class="italic">
       
        Chapter 5
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Working with Data and Persistence
      
     </em>
    </li>
    <li>
     <a href="B21788_06.xhtml#_idTextAnchor093">
      <em class="italic">
       
        Chapter 6
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Enhancing Security and Quality
      
     </em>
    </li>
   </ul>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
 </body></html>