- en: '*Chapter 6*: Integrating Audio and Video in a Unity Project'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have discussed how to use C# scripts to develop
    game logic in Unity, how to efficiently implement UI, how to implement animation,
    and how to integrate physics simulation into your game. However, one feature that
    is often overlooked in game development is sound. The proper use of sound effects
    can enhance the immersion of a game, and the background music that matches the
    background of the game can trigger the emotional resonance of the players. Sometimes,
    playing video in a game is also a way to increase the fun of a game. There is
    no doubt that adding video and audio to your game can make your game more lively
    and interesting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce the following key topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Concepts in Unity's audio system and video system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting with audio and video
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things to note when using Unity to develop web applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the performance of the audio system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to implement audio and video correctly
    and efficiently in Unity to add more realism and fun to your game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find complete code examples on GitHub in the following repository:
    [https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Concepts in Unity's audio system and video system
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity provides video and audio features, allowing your game to play videos on
    different platforms, and supports real-time mixing and full 3D spatial sound effects.
    In this section, we will introduce important concepts of the Unity audio system
    and video system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Audio clips
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to be able to play audio in Unity, we need to import an audio file
    into the Unity editor first. The audio data will be saved in an **audio clip**
    object in Unity. We can download and import the **Ultra Sci-Fi Game Audio Weapons
    Pack Vol. 1** from **Unity Asset Store** at the following link: [https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047](https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047).
    You can see this in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Ultra Sci-Fi Game Audio Weapons Pack Vol. 1'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B17146.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Ultra Sci-Fi Game Audio Weapons Pack Vol. 1
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the audio files contained in this pack is `.wav`. In addition
    to `.wav` files that can be imported into Unity, Unity also supports importing
    files in the following formats:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`.aif`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.mp3`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.ogg`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.xm`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.mod`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.it`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.s3m`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After importing these audio files, we can choose one of them to open the **Import**
    settings as shown in *Figure 6.2*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Import settings of audio'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B17146.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Import settings of audio
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the **Import** settings, Unity supports mono and multichannel
    audio assets, up to eight channels. Unity also provides a lot of import options.
    Let's introduce some important options.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Load Type
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity provides game developers with three different ways to load audio assets
    at runtime. We can determine how Unity loads this audio file by modifying the
    **Load Type** property in the **Import** settings window.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Load Type'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.03_B17146.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Load Type
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The three methods are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**Decompress On Load**: This is the default value for **Load Type**. If the
    audio file is small, such as UI sounds or footstep sounds, we should choose this
    option. This is because, in this way, the audio file will be decompressed and
    decoded into the memory at its original size. The advantage is that it will be
    ready for on-demand playing with minimal CPU usage.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compressed In Memory**: As a contrast with **Decompress On Load**, by choosing
    this method, Unity will store the compressed audio data in memory and require
    the CPU to decompress and decode it when playing the audio.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streaming**: This is completely different from the previous two. If we choose
    this method, Unity will not load the audio data into the memory, but instead will
    stream it from disk. This method uses the least memory, but at the cost of the
    highest CPU usage and disk usage.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression Format
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to the **Load Type** property just introduced, the **Compression
    Format** property is also very important for audio assets. Unity supports a variety
    of audio compression formats, and there are different formats available according
    to the different target platforms. For example, if the target platform is **Windows**,
    the following formats are available:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Compression Format on Windows'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.04_B17146.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Compression Format on Windows
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the target platform is **Android**, in addition to the
    previous formats, it also supports the MP3 format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Compression Format on Android'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.05_B17146.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Compression Format on Android
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the different compression formats here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**PCM**: **Pulse-code modulation** (**PCM**) is a lossless, uncompressed format
    and is the standard form of digital audio in computers. It offers high quality
    and has a very large file size. As you can see in *Figure 6.6*, when the **PCM**
    format is selected, the imported size of this audio file is equal to its original
    size.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The PCM format'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.06_B17146.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – The PCM format
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Vorbis**: This is the default value for **Compression Format**. **Vorbis**
    is a very effective audio compression format. Compared with **PCM** audio, this
    compression produces smaller files, but the quality is lower. If we choose the
    **Vorbis** option, the imported size of this audio file will be much smaller than
    its original size. There is a **Quality** slider that allows us to adjust the
    compression quality.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The Vorbis format'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.07_B17146.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – The Vorbis format
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**ADPCM**: **ADPCM** is short for **adaptive differential pulse-code modulation**.
    Although the name is similar to PCM, it is a lossy compression format. But unlike
    Vorbis, its compression ratio cannot be adjusted in Unity. The compressed file
    size will always be 3.5 times smaller than PCM.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The ADPCM format'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.08_B17146.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – The ADPCM format
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**MP3**: This is available on mobile platforms, such as Android. The MP3 format
    is similar to Vorbis, which is a very effective audio compression format. There
    is also a **Quality** slider that allows us to adjust the compression quality.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The MP3 format'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.09_B17146.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – The MP3 format
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: After we set the import settings for these audio files, they can be imported
    into the Unity editor as audio clips.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Audio clips'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B17146.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Audio clips
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 6.10*, we can find these audio clips in the **Project**
    window, and the icon of the audio clip will show its waveform.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Audio Sources
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to play the audio clip we just created in the game scene, we also need
    to set an **Audio Source**. Then this audio clip can be dragged to the Audio Source
    or used from a C# script.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to create an Audio Source first:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Create Empty** to create a new GameObject in the scene. As a reminder,
    the GameObject that is the Audio Source is not necessarily a static object. In
    many cases, the Audio Source needs to be moved, such as simulating the effect
    of firing a cannonball in a game. But for the sake of simplicity, we will not
    add movement logic to this GameObject here.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Create an Audio Source object'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B17146.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Create an Audio Source object
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Select this newly created GameObject and click the **Add Component** button
    to open the components list.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Audio** | **Audio Source** to add an **Audio Source** component to
    this GameObject.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Add an Audio Source component'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.12_B17146.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – Add an Audio Source component
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Now we have created a new **Audio Source** component in our game scene. The
    properties of this **Audio Source** component are shown in *Figure 6.13*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Properties of Audio Source'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.13_B17146.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Properties of Audio Source
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore some of them here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**AudioClip**: Here, we find the first property of **Audio Source** is a reference
    to **Audio Clip**. We can drag an **Audio Clip** asset to this field directly
    in the editor.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: We don''t have to set this property, because the output of this
    Audio Source will then be picked up by an Audio Listener in the scene by default.
    Set this property only when you want to output the sound to an Audio Mixer Group.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Play` method in a C# script.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the Audio Source, to emit the sound in the scene, an Audio Listener
    is also needed to receive the sound from the source. Next, we will discuss **Audio
    Listener**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Audio Listener
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally speaking, you don't need to worry about the absence of **Audio Listener**
    in the scene, because an Audio Listener will be attached to the main camera in
    the scene by default when a scene is created, as shown here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – An Audio Listener'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.14_B17146.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – An Audio Listener
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: In real life, sounds are heard by listeners, and **Audio Listener** is the representation
    of a listener in Unity. If you set **Audio Source** correctly in the game scene
    and the audio clip is available but you can't hear the sound when you run the
    game, then you can first check whether there is an Audio Listener in the scene.
    Usually, the listener is attached to the camera.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: To hear the sound, we need to make sure that an Audio Listener is available,
    but at the same time, it should be noted that there cannot be more than one Audio
    Listener in the scene, otherwise you will see the following warning message in
    the **Console** window. So, please ensure there is always exactly one Audio Listener
    in the scene.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Please ensure there is always exactly one audio listener in
    the scene'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B17146.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Please ensure there is always exactly one audio listener in the
    scene
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: After introducing a few important concepts about audio in Unity, let's discuss
    the concepts related to video in Unity next.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Video clips
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to audio clips, we also need to import external video files into the
    Unity editor to generate video clips. Unity supports typical file extensions for
    video files, such as the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`.mp4`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.mov`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.webm`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.wmv`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After importing a video file, we can choose to open **Import settings**, as
    shown in *Figure 6.16*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Import settings of a video clip'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.16_B17146.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – Import settings of a video clip
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: By default, the **Transcode** option is disabled, which means that Unity will
    use the default settings to import this video file. If we enable this option,
    Unity will allow us to modify these settings, as shown in *Figure 6.17*, and we
    will introduce a few of them. At the bottom of the **Import settings** window,
    we can also directly preview the video by clicking the play button.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's check and enable the **Transcode** option and explore some of these
    import settings.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Video import settings'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B17146.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – Video import settings
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Dimensions**: By default, Unity will not resize the original video, but if
    you want to resize the video file in Unity, you can change the **Dimensions**
    option. You will find a list of presets, such as **Half Res**, and you can also
    customize new sizes.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Dimensions option'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.18_B17146.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – Dimensions option
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**Codec**: Unity provides the option to transcode video clip assets into one
    of the following video codecs: **H264**, **H265**, and **VP8**, as shown in the
    following figure. **Auto** is the default value for **Codec**. Of course, you
    can also choose the video codec by yourself. **H264** is the best natively supported
    hardware-accelerated video codec.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Codec option'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.19_B17146.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.19 – Codec option
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep Alpha**: As you can see in *Figure 6.19*, **Keep Alpha** is not an option
    in this case. This is because this option can only be checked when the video file
    contains an alpha channel. If your video file contains an alpha channel and you
    want to keep the alpha channel when the video is played in the game, then check
    this option.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flip Horizontally**: As the name suggests, if this option is enabled, Unity
    will flip the video horizontally, switching the left side to the right side.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flip Vertically**: Similar to **Flip Horizontally**, if this option is enabled,
    Unity will flip the video vertically to make it upside down.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Import Audio**: If your original video file contains audio tracks, then you
    can decide whether to import the audio tracks of the video by checking this option.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After setting the import settings, we can click **Apply** to transcode the video.
    It may take some time to complete the transcoding process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Transcoding the video'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.20_B17146.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.20 – Transcoding the video
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Now we have imported the video file into the Unity editor, next we need to set
    up a video player to play the video clip.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Video Player
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a Video Player by following these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `VideoPlayer`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select this newly created GameObject and click the **Add Component** button
    to open the components list.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Video** | **Video Player** to add a **VideoPlayer** component to this
    GameObject.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Add a Video Player component'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.21_B17146.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – Add a Video Player component
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have created a new **Video Player** in our game scene. The properties
    of this **Video Player** are shown in *Figure 6.22*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Properties of Video Player component'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.22_B17146.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.22 – Properties of Video Player component
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will explore some of these properties:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '**Source**: In Unity, a **Video Player** can play videos from video clip assets
    or from a URL. By default, the **Video Player** needs a video clip asset as the
    video source, but we can also choose a URL as the source for video here.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Choose the type of video source'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.23_B17146.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – Choose the type of video source
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '`Play` method in a C# script to trigger the video playback at another point
    during the runtime.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playback Speed**: We can increase or decrease the playback speed by adjusting
    this slider. The default value is 1.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render Mode
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a very important setting, so we will explain it in detail. If you just
    set up the Video Player, drag a video clip asset to the **Source** property, and
    play the game, you will find that nothing will happen. This is because the default
    value for **Render Mode** in a Video Player is **Render Texture**, which means
    you should create and assign a render texture to the **Target Texture** property
    of the Video Player first. Then the Video Player will output the video to this
    render texture, as you can see in *Figure 6.24*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Set the Target Texture property'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.24_B17146.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.24 – Set the Target Texture property
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: However, at this stage, we only render the video to the render texture, and
    the video is not played in the game scene. In order to play this video in the
    game scene, we can create a new **Raw Image** UI element in the scene and assign
    this render texture to the **Raw Image** UI element.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – The Raw Image UI element'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.25_B17146.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.25 – The Raw Image UI element
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's play the game again and the video plays as expected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – Play the video'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.26_B17146.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.26 – Play the video
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change **Render Mode**. As you can see in *Figure 6.27*, the other
    options include the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Camera Far Plane**, which renders video content behind the camera''s scene,
    allows developers to change the value of the alpha channel to make video content
    transparent, and can be used as a background video player.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera Near Plane**, which renders video content in front of the camera''s
    scene, allows developers to change the value of the alpha channel to make video
    content transparent, and can be used as a foreground video player.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material Override**: In Unity, a material is used to describe the appearance
    of the surface of a model. If this mode is selected, the video content will be
    passed into a user-specified property of the target material instead of being
    drawn on the screen or in a render texture. This mode is often used when making
    360-degree panoramic videos in Unity.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Only**, which does not render the video content, but allows developers
    to access the video content via an API.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.27 – Render Mode List'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.27_B17146.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.27 – Render Mode List
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will choose **Camera Far Plane** for **Render Mode**. Instead
    of a render texture, we need to provide a camera here and, as you can see in the
    following figure, it allows us to modify the **Alpha** value as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Camera Far Plane'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.28_B17146.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.28 – Camera Far Plane
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: If we play the game, the video plays again this time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – Play the video'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.29_B17146.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.29 – Play the video
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about some concepts of Unity's audio and video systems.
    Now, let's explore how to write C# code in Unity to control audio and video.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Scripting with audio and video
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how to interact with the audio and video systems
    via C# scripts. Similar to the previous section, we will also introduce the C#
    methods for **Audio Source** and **Video Player** respectively. We first start
    with the C# methods for **Audio Source**.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: AudioSource.Play
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first function we will introduce is the `Play` function of `AudioSource`.
    The function signature of `Play` is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is very simple and straightforward to call this function to play an audio
    clip. However, if you need to deal with more complex scenarios, such as delaying
    the playback of an audio clip, you can call the `PlayDelayed` function, which
    will play the clip with a delay specified in seconds.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: There was an overloaded version of the `Play` function, which requires a `delay`
    parameter. However, it's deprecated now. Developers are advised to use the `PlayDelayed`
    function instead of the old `Play` (`delay`) function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the function signature of `PlayDelayed`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It requires a parameter, `delay`, which is specified in samples relative to
    the 44.1 kHz reference rate.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a new C# script to first obtain a reference to the Audio
    Source in the scene and play the audio clip assigned to it by calling the `Play`
    function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then we drag this newly created script onto the Audio Source GameObject in the
    scene to attach this script to the GameObject as a new component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30 – Attaching the script to the GameObject'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.30_B17146.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.30 – Attaching the script to the GameObject
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can manually drag the `GetComponent<AudioSource>()` function to get
    the **AudioSource** component in the code as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a UI button in the scene and bind the button with the `OnClickPlayAudioButton`
    function so that when the button is clicked, the **Audio Source** will play the
    audio clip.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31 – Create a button'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.31_B17146.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.31 – Create a button
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Now we can run the game and click the button to play the sound effect in the
    scene. This function is very useful when implementing audio effects; for example,
    when the player fires a gun, the sound of the bullet can be played, and so on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: AudioSource.Pause
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Audio Source can be used to play background music. In some cases, we would
    like the background music to be paused, such as when the player enters a different
    scene or triggers a new plot. At this point, we can consider using the `Pause`
    function to pause playing the background music clip.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The function signature of `Pause` is very simple, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can create another function for the `AudioPlayer` class we created earlier:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since the assets pack we downloaded earlier only contains sound effects with
    a short duration, in order to demonstrate the function of pausing background music,
    we can download and import **Free Music Tracks For Games** from the Unity Asset
    Store at the following link: [https://assetstore.unity.com/packages/audio/music/free-music-tracks-for-games-156413](https://assetstore.unity.com/packages/audio/music/free-music-tracks-for-games-156413).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32 – Free Music Tracks For Games'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.32_B17146.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.32 – Free Music Tracks For Games
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Then replace the sound effect clip referenced by `AudioSource` with a new background
    music clip. Next, we will create another UI button and bind the button with the
    newly created `OnClickPauseAudioButton` function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can run the game. If you click the first button, the background music
    will play; if you click the second button, we can pause the music.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`AudioSource` also provides an `UnPause` function to unpause the paused playback
    and an `isPlaying` property to check whether the current audio clip is playing.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the function signature of `UnPause`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use them to implement a more flexible function of pausing and continuing
    music playback as in the following code snippet:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this way, we can click the second button to pause the music playback, and
    click again to continue playing the music.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: AudioSource.Stop
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, you may want the background music of the game to stop and then
    start from the beginning, instead of pausing and continuing to play. The `Stop`
    function of `AudioSource` is a suitable solution here.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'The function signature of `Stop` is also very simple, as shown in the following
    code snippet:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s create another function in the C# script to stop the background music
    and start playing from the beginning:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And we will also create a third UI button and bind the button with the `OnClickStopAndPlayAudioButton`
    function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and click this button and the background music starts to play.
    Click again to stop the background music, and if you click for a third time, the
    background music will start to play from the beginning.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: VideoPlayer.clip
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, a `VideoPlayer` component will play the video clip it refers to.
    However, it''s a common requirement that we should be able to change the video
    when the game is running instead of creating many different Video Player instances.
    So, we can just modify the clip property of `VideoPlayer` via C# code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, we create a new C# script called `VideoManager`, which will get
    a reference to the target `VideoPlayer` component and a reference to the video
    clip asset. There is also a function called `OnClickChangeVideoClip`, which will
    later be bound to a UI button to change the video clip being played.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Compared to setting an Audio Source, setting a Video Player is slightly more
    complicated, because we also need to select a **Render Mode** option for **Video
    Player**. For simplicity, here we select the **Camera Near Plane** option and
    use **Main Camera** in the scene to render each frame of the video clip, as shown
    in *Figure 6.33*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33 – Video Player'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.33_B17146.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.33 – Video Player
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Then, we also need to assign the newly created script **VideoManager** to the
    same GameObject.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.34 – Video Manager'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.34_B17146.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.34 – Video Manager
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 6.34*, we not only assigned a reference to **Video
    Player** to the **VideoManager** script but also assigned a reference to a video
    clip asset to it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The third thing is to create a new UI button and bind the button with the `OnClickChangeVideoClip`
    function we mentioned earlier.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.35 – UI button'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.35_B17146.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.35 – UI button
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Let's play the game in the editor and click the button to change the video clip.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.36 – Change the video clip'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.36_B17146.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.36 – Change the video clip
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 6.36*, the video clip of the **Video Player** component
    is changed to the video clip asset we want it to play.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: VideoPlayer.url
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, playing videos from video clip assets is not a good idea. For example,
    we do not want to increase the size of the game due to the inclusion of video
    files, or we want to develop WebGL-based games, and WebGL does not support video
    clip assets. Then, the use of a URL to provide video resources becomes an obvious
    solution. So, let''s add another function called `OnClickSetVideoURL` to let the
    Video Player in the game scene play the video pointed to by the URL:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And we also need to create a new UI button and bind the button with the `OnClickSetVideoURL`
    function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.37 – Set Video URL'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.37_B17146.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.37 – Set Video URL
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and click the **Set Video URL** button to play the video from the
    URL, as shown in the preceding figure.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Unity does not support playing videos from YouTube, so you can host your video
    resources on other platforms, such as the Azure cloud.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: VideoPlayer.Play
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous two examples, whether we set the video clip asset or the video
    URL, the Video Player will automatically play the video. This is because we have
    enabled the **Play On Awake** option by default, as shown in *Figure 6.38*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.38 – Play On Awake'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.38_B17146.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.38 – Play On Awake
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, we prefer to be able to control when to play the video ourselves.
    Therefore, it is a good idea to disable this option and use C# code in a script
    to control playback, as shown in the following code block:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we will create the third UI button and bind the button with the `OnClickPlay`function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.39 – Play Video'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.39_B17146.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.39 – Play Video
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: This time, if we run the game and click the `Play` function of **Video Player**
    to play the video, as shown in *Figure 6.39*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: VideoPlayer.frame and VideoPlayer.frameCount
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Speaking of controlling video playback, the video progress bar is a useful feature.
    We can also implement a video progress bar in Unity. Next, let's discuss how to
    use the `frame` and `frameCount` properties of **Video Player** to implement a
    video progress bar.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The `frameCount` property is read-only and provides the number of frames in
    the current video content. On the other hand, the `frame` property can be modified
    and provides the frame index of the current frame. Therefore, we should first
    create a UI slider and then modify the value of the slider according to the value
    of `frame` and `frameCount` for a **VideoPlayer** component, as shown in *Figure
    6.40*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.40 – Create a slider'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.40_B17146.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.40 – Create a slider
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to modify the C# script to obtain a reference to the slider and
    update the value of the slider based on the value of `frame` and the value of
    `frameCount`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, we are using the `UnityEngine.UI` namespace because we need to
    access the UI slider from our code. And we implemented the `Update` function to
    update the value of the slider.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Let's run the game and play the video as before.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.41 – The progress bar'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.41_B17146.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.41 – The progress bar
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: We can see that as the video plays, the progress bar is also updated.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored and demonstrated the use of C# code to control
    audio and video, such as how to play audio and video, pause audio and video, and
    implement a progress bar via C# code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are using Unity to develop a web application, then you may encounter
    other problems. Let's continue to explore.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Things to note when using Unity to develop web applications
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity is a cross-platform game engine, which means that we can deploy games
    that use the same code base and resources on different platforms, including WebGL.
    However, if you are using Unity to develop games for the web platform, here are
    some notes about implementing a video player.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: URL
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, the `VideoPlayer.clip` property is not supported on WebGL, which
    means that you can implement your video player solution by playing the video content
    in the video clip assets in the editor. However, once you build and deploy your
    web application to the server and run it, the video will not be played, even if
    the required video assets are packaged and deployed together.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.42 – WebGL'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.42_B17146.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.42 – WebGL
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 6.42*, when we run the web app and click the **Play Video**
    button, nothing will happen.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have to provide a video source via the `VideoPlayer.url` property
    instead. If the video file has been hosted on another cloud platform, then we
    can directly use the method introduced in the previous section to play the video
    pointed to by the URL. In addition, `VideoPlayer.url` also supports local absolute
    or relative paths. Therefore, we can also build and deploy video files and other
    content of the game together. It should be noted that in this case, we no longer
    use Unity's video clip assets, but directly use the original video files, and
    put these video files in a folder called `StreamingAssets`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '**StreamingAssets** is a special folder name of a Unity project. Files in this
    folder are available in their original format.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can create a new folder in the root of the project, rename it **StreamingAssets**,
    then put the original video file in this folder.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.43 – StreamingAssets folder'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.43_B17146.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.43 – StreamingAssets folder
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 6.43*, the video file is in its original format and
    has not been converted into a Unity video clip asset.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create another C# script to demonstrate how to make **Video Player**
    load this video file and play it in the browser:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this script, we access the `Application.streamingAssetsPath` property to
    get the path to the folder at runtime and assign the path to the `url` property
    of `VideoPlayer`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Now, instead of running the game in the editor, we build and deploy it as a
    web application, and then run it in the browser.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.44 – Play the video in the broswer'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.44_B17146.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.44 – Play the video in the broswer
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: This time the video played as expected in the browser.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Frame rate
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing WebGL applications with Unity, another thing you should pay
    attention to is the **frame rate** of the video. In Unity, the frame rate is expressed
    as frames per second.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Let's print the video length, video frame count, and video frame rate information
    of the sample video we are using in the editor.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.45 – Frame rate'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.45_B17146.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.45 – Frame rate
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, the frame count of this video is 213, the video length
    is 7.1 seconds, and the frame rate is 30 FPS.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: However, since the underlying implementation on the WebGL platform, that is,
    the JavaScript API for `HTML5 <video>`, does not disclose frame rate information,
    the frame rate is always assumed to be 24 FPS, even if the real frame rate of
    the video is 30 FPS. Therefore, frames/second of a video is always 24, which should
    be paid attention to when implementing the video progress bar for WebGL.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the things that need to be paid attention to when
    using Unity to develop video functions due to some limitations of the web platform.
    Next, we will explore how to use the profiler tool provided by Unity to locate
    the performance problems caused by audio and how to solve them.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the performance of the audio system
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In game development, the importance of audio is often overlooked. Sometimes
    this is also reflected in performance optimization. Game developers usually invest
    more effort in other performance areas, such as performance optimization for graphics
    rendering. But as games become more and more complex, audio can also cause performance
    problems, such as greater memory usage and so on. In this section, we will explore
    how to optimize audio performance in Unity.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Profiler
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we should learn how to use the Unity Profiler tool to view and locate
    performance bottlenecks caused by the audio system in Unity:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Click **Window** | **Analysis** | **Profiler** or use the keyboard shortcut
    *Ctrl* + *7* (*command + 7* on macOS) to open the **Profiler** window.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Audio** module area in the **Profiler** window to view the performance
    data of the audio system. You can find out how many Audio Sources are playing,
    the number of audio clips being used, and the amount of memory being used for
    audio, and so on, as shown in *Figure 6.46*:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.46 – Audio Profiler'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.46_B17146.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.46 – Audio Profiler
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 6.46*, the value of **Total Audio Memory** is 38.9 MB, which
    is very bad because, currently, only one Audio Source is playing sound. Therefore,
    we can click on the drop-down menu labeled **Simple** and switch to the **Detailed**
    view.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.47 – Switch to the Detailed view'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.47_B17146.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.47 – Switch to the Detailed view
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: We can get more information about the audio system and identify the specific
    audio asset that occupies 38.9 MB of memory.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.48 – Detailed view'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.48_B17146.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.48 – Detailed view
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will introduce how to reduce the memory occupied by this audio resource.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Using Force To Mono to save memory
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we inspect this audio asset, we will find the audio asset is stereo, as shown
    in *Figure 6.49*.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.49 – The audio clip'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.49_B17146.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.49 – The audio clip
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: However, since there is only one Audio Source in the game scene, which means
    that the sound is emitted from one point, the effect of using stereo is lost here,
    but the memory consumption is twice that of mono. Therefore, if the game does
    not require stereo and needs to reduce memory overhead, we can just enable the
    **Force To Mono** option in the audio clip's import settings to convert the stereo
    audio clip to a mono audio clip.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.50 – Enable Force To Mono'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.50_B17146.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.50 – Enable Force To Mono
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Then let's play the audio again. This time we find that the memory consumption
    of this audio clip has dropped from 38.9 MB to 20.2 MB, which is almost halved.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.51 – Memory consumption has dropped'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.51_B17146.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.51 – Memory consumption has dropped
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced how to use Unity's Profiler tool to view the
    performance data of the audio system and explored how to optimize the performance
    of the audio system.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何使用Unity的Profiler工具查看音频系统的性能数据，并探讨了如何优化音频系统的性能。
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by introducing the audio and video features provided
    by Unity, then we explored some of the most important concepts in the Unity audio
    system and video system, such as **audio clip** assets, **Audio Source** components,
    **Audio Listener** components, **Video Player** components, and so on. We also
    discussed how to create a new script in Unity to interact with Unity's audio system
    and video system.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了Unity提供的音频和视频功能，然后探讨了Unity音频系统和视频系统中最重要的一些概念，例如**音频剪辑**资源、**音频源**组件、**音频监听器**组件、**视频播放器**组件等等。我们还讨论了如何在Unity中创建一个新的脚本以与Unity的音频系统和视频系统交互。
- en: Then we demonstrated how to implement a video for the web platform because WebGL
    does not support Unity's **video clip** assets and due to underlying implementation
    reasons, the video frame rate is always assumed to be 24 FPS. These need to be
    paid attention to.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们演示了如何为Web平台实现视频，因为WebGL不支持Unity的**视频剪辑**资源，并且由于底层实现原因，视频帧率始终假设为24 FPS。这些需要注意。
- en: Finally, we explored how to view and locate performance bottlenecks caused by
    the audio system in Unity.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何查看和定位由Unity音频系统引起的性能瓶颈。
- en: In the next chapter, we will introduce the mathematics of computer graphics
    in Unity.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Unity中计算机图形学的数学原理。
