<html><head></head><body>
		<div><h1 id="_idParaDest-105"><em class="italic"><a id="_idTextAnchor186"/>Chapter 13</em>: Managing Inputs with Custom ModelBinder</h1>
			<p>In the last chapter regarding <code>OutputFormatter</code>, we learned about sending data out to clients in different formats. In this chapter, we are going to do it the other way. This chapter is about data you get in your web API from outside; for instance, what to do if you get data in a special format, or if you get data you need to validate in a special way. <strong class="bold">Model Binders</strong> will help you to handle this.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Introducing <code>ModelBinder</code></li>
				<li>Preparing the test project</li>
				<li>Creating <code>PersonsCsvBinder</code></li>
				<li>Using <code>ModelBinder</code></li>
				<li>Testing <code>ModelBinder</code></li>
			</ul>
			<p>The topics in this chapter refer to the WebAPI layer of the ASP.NET Core architecture:</p>
			<div><div><img src="img/Figure_13.1_B17996.jpg" alt="Figure 13.1 – ASP.NET Core architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – ASP.NET Core architecture</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor187"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core MVC application. Open your console, shell, or Bash terminal, and change to your working directory. Use the following command to create a new MVC application:</p>
			<pre>dotnet new webapi -n ModelBinderSample -o ModelBinderSample</pre>
			<p>Now, open the project in Visual Studio by double-clicking the project file or, in VS Code, by typing the following command in the already open console:</p>
			<pre>cd ModelBinderSample
code .</pre>
			<p>All of the code samples in this chapter can be found in the GitHub repository for this book at: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter13">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter13</a>.</p>
			<h1 id="_idParaDest-107">I<a id="_idTextAnchor188"/><a id="_idTextAnchor189"/>ntroducing ModelBinder</h1>
			<p>Model Binders are responsible for binding the incoming data to specific action method parameters. They bind the data sent with the request to the parameters. The default binders <a id="_idIndexMarker194"/>are able to bind data that is sent via the <code>QueryString</code>, or sent within the request body. Within the body, the data can be sent in URL or JSON format.</p>
			<p>The model binding tries to find the values in the request by parameter names. The form values, route data, and query string values are stored as a key-value pair collection and the binding tries to find the parameter name in the keys of the collection.</p>
			<p>Let's demonstrate how this works with a test project.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor190"/><a id="_idTextAnchor191"/>Preparing the test data</h1>
			<p>In this section, we're going <a id="_idIndexMarker195"/>to see how to send CSV data to a web API method. We will reuse the CSV data we created in <a href="B17996_12_ePub.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>, <em class="italic">Content Negotiation Using a Custom OutputFormatter</em>.</p>
			<p>This is a snippet of the test data we want to use:</p>
			<pre>Id,FirstName,LastName,Age,EmailAddress,Address,City,Phone
48,Austin,Ward,49,Jake.Timms@live.com,"8814 Gravesend Neck Road ",Daly City,(620) 260-4410
2,Sierra,Smith,15,Elizabeth.Wright@hotmail.com,"1199 Marshall Street ",Whittier,(655) 379-4362
27,Victorina,Radcliff,40,Bryce.Sanders@rogers.ca,"2663 Sutton Street ",Bloomington,(255) 365-0521
78,Melissa,Brandzin,39,Devin.Wright@telus.net,"7439 Knight Court ",Tool,(645) 343-2144
89,Kathryn,Perry,87,Hailey.Jenkins@hotmail.com,"5283 Vanderbilt Street ",Carlsbad,(747) 369-4849</pre>
			<p>You can <a id="_idIndexMarker196"/>find the full CSV test data on GitHub at: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter13/testdata.csv">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter13/testdata.csv</a>.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor192"/>Preparing the test project</h1>
			<p>Let's prepare <a id="_idIndexMarker197"/>the project by following these steps:</p>
			<ol>
				<li>In the already created project (refer to the <em class="italic">Technical requirements</em> section), we will now create a new empty API controller with a small action inside:<pre>namespace ModelBinderSample.Controllers
{
    [Route("[controller]")]
    [ApiController]
    public class PersonsController : ControllerBase
    {
        public ActionResult&lt;object&gt; Post(
            IEnumerable&lt;Person&gt; persons)
        {
            return new
            {
                ItemsRead = persons.Count(),
                Persons = persons
            };
        }
    }
}</pre><p>This looks basically like any other action. It accepts a list of persons and returns an anonymous <a id="_idIndexMarker198"/>object that contains the number of persons as well as the list of persons. This action is pretty useless but helps us to debug <code>ModelBinder</code> using Postman.</p></li>
				<li>We also need the <code>Person</code> class:<pre>public class Person
{
    public int Id { get; set; }
    public string? FirstName { get; set; }
    public string? LastName { get; set; }
    public int Age { get; set; }
    public string? EmailAddress { get; set; }
    public string? Address { get; set; }
    public string? City { get; set; }
    public string? Phone { get; set; }
} </pre><p>This will actually work fine if we want to send JSON-based data to that action.</p></li>
				<li>As a last preparation step, we need to add the <code>CsvHelper</code> NuGet package to parse the <a id="_idIndexMarker199"/>CSV data more easily. The .NET CLI is also useful here:<pre><code>System.Linq.Async</code> package is needed to handle the <code>IAsyncEnumerable</code> that gets returned by the <code>GetRecordsAsync()</code> method.</p></li>
			</ol>
			<p>Now that this is all set up, we can try it out and create <code>PersonsCsvBinder</code> in the next sect<a id="_idTextAnchor193"/><a id="_idTextAnchor194"/>ion.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor195"/>Creating PersonsCsvBinder</h1>
			<p>Let's build a binder.</p>
			<p>To create <code>ModelBinder</code>, add a <a id="_idIndexMarker200"/>new class called <code>PersonsCsvBinder</code>, which implements <code>IModelBinder</code>. In the <code>BindModelAsync</code> method, we get <code>ModelBindingContext</code> with all the information in it that we need in order to get the data and deserialize it. The following code snippets show a generic binder that should work with any list of models. We have split it into sections so that you can clearly see how each part of the binder works:</p>
			<pre>public class PersonsCsvBinder : IModelBinder
{
    public async Task BindModelAsync(
        ModelBindingContext bindingContext)
    {
        if (bindingContext == null)
        {
            return;
        }
        var modelName = bindingContext.ModelName;
        if (String.IsNullOrEmpty(modelName))
        {
            modelName = bindingContext.OriginalModelName;
        }
        if (String.IsNullOrEmpty(modelName))
        {
            return;
        }</pre>
			<p>As you can see from the preceding code block, first, the context is checked against null. After that, we <a id="_idIndexMarker201"/>set a default argument name to the model, if none have already been specified. If this is done, we are able to fetch the value by the name we set previously:</p>
			<pre>        var valueProviderResult = 
          bindingContext.ValueProvider.GetValue(modelName);
        if (valueProviderResult == ValueProviderResult.None)
        {
            return;
        }</pre>
			<p>In the next part, if there's no value, we shouldn't throw an exception in this case. The reason is that the next configured <code>ModelBinder</code> might be responsible. If we throw an exception, the execution of the current request is canceled and the next configured <code>ModelBinder</code> doesn't have the opportunity to be executed:</p>
			<pre>        bindingContext.ModelState.SetModelValue(
            modelName, valueProviderResult);
        var value = valueProviderResult.FirstValue;
        // Check if the argument value is null or empty
        if (String.IsNullOrEmpty(value))
        {
            return;
        }</pre>
			<p>If we have the value, we <a id="_idIndexMarker202"/>can instantiate a new <code>StringReader</code> that needs to be passed to <code>CsvReader</code>: </p>
			<pre>        var stringReader = new StringReader(value);
        var reader = new CsvReader(
            stringReader, CultureInfo.InvariantCulture);</pre>
			<p>With <code>CsvReader</code>, we can deserialize the CSV string value into a list of <code>Persons</code>. If we have the list, we need to create a new, successful <code>ModelBindingResult</code> that needs to be assigned to the <code>Result</code> property of <code>ModelBindingContext</code>:</p>
			<pre>        var asyncModel = reader.GetRecordsAsync&lt;Person&gt;();
        var model = await asyncModel.ToListAsync();
        bindingContext.Result = 
           ModelBindingResult.Success(model);
    }
}</pre>
			<p>You might need to add the following <code>using</code> statements at the beginning of the file:</p>
			<pre>using Microsoft.AspNetCore.Mvc.ModelBinding;
using System.IO;
using CsvHelper
using System.Globalization;</pre>
			<p>Next, we'll <a id="_idIndexMarker203"/>put <code>ModelBinder</code> <a id="_idTextAnchor196"/><a id="_idTextAnchor197"/>to work.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor198"/>Using ModelBinder</h1>
			<p>The binder isn't used <a id="_idIndexMarker204"/>automatically because it isn't registered in the dependency injection container and is not configured to be used within the MVC framework.</p>
			<p>The easiest way to use this model binder is to use <code>ModelBinderAttribute</code> on the argument of the action where the model should be bound:</p>
			<pre>[HttpPost]
public ActionResult&lt;object&gt; Post(
    [ModelBinder(binderType: typeof(PersonsCsvBinder))]
    IEnumerable&lt;Person&gt; persons)
{
    return new
    {
        ItemsRead = persons.Count(),
        Persons = persons
    };
} </pre>
			<p>Here, the type of our <code>PersonsCsvBinder</code> is set as <code>binderType</code> to that attribute.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>ModelBinderProvider</code> to add the <code>ModelBinder</code> to the list of existing ones.</p>
			<p>I personally prefer the explicit declaration because most custom <code>ModelBinder</code> will be specific to an <a id="_idIndexMarker205"/>action or to a specific type, and it prevents hidden magic in the background.</p>
			<p>Now, let's test out what we<a id="_idTextAnchor199"/><a id="_idTextAnchor200"/>'ve built.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor201"/>Testing ModelBinder</h1>
			<p>To test it, we need to create <a id="_idIndexMarker206"/>a new request in Postman: </p>
			<ol>
				<li value="1">Start the application by running <code>dotnet run</code> in the console or by pressing <em class="italic">F5</em> in Visual Studio or VS Code.</li>
				<li>In Postman, we will then set the request type to <code>https://localhost:5001/api/persons</code> in the address bar. <p>The port number might vary on your side.</p></li>
				<li>Next, we need to add the CSV data to the body of the request. Select <code>form-data</code> as the body type, add the <code>persons</code> key, and paste the following value lines in the value field:<pre>Id,FirstName,LastName,Age,EmailAddress,Address,City,Phone
48,Austin,Ward,49,Jake.Timms@live.com,"8814 Gravesend Neck Road ",Daly City,(620) 260-4410
2,Sierra,Smith,15,Elizabeth.Wright@hotmail.com,"1199 Marshall Street ",Whittier,(655) 379-4362
27,Victorina,Radcliff,40,Bryce.Sanders@rogers.ca,"2663 Sutton Street ",Bloomington,(255) 365-0521</pre></li>
				<li>After pressing <strong class="bold">Send</strong>, we get the result, as shown in <em class="italic">Fi<a id="_idTextAnchor202"/>gure 13.2</em>:</li>
			</ol>
			<div><div><img src="img/Figure_13.2_B17996.jpg" alt="Figure 13.2 – A screenshot of CSV data in Postman&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – A screenshot of CSV data in Postman</p>
			<p>Now, the clients will <a id="_idIndexMarker207"/>be able to send CSV-based data to <a id="_idTextAnchor203"/>the server.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor204"/>Summary</h1>
			<p>This is a good way to transform the input in a way that the action needs. You could also use <code>ModelBinder</code> to do some custom validation against the database or whatever you need to do before the model gets passed to the action.</p>
			<p>In the next chapter, we will see what you can do with <code>Act<a id="_idTextAnchor205"/>ionFilter</code>.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor206"/>Further reading</h1>
			<p>To learn more about <code>ModelBinder</code>, you should have a look at the following reasonably detailed documentation:</p>
			<ul>
				<li>Steve Gordon, <em class="italic">Custom ModelBinding in ASP.NET MVC Core</em>: https://www.stevejgordon.co.uk/html-encode-string-aspnet-core-model-binding/</li>
				<li><em class="italic">Model Binding in ASP.NET Core</em>: https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding</li>
				<li><em class="italic">Custom Model Binding in ASP.NET Core</em>: https://docs.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding</li>
			</ul>
		</div>
	</body></html>