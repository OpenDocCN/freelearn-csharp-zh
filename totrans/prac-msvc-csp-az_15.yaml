- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Asynchronous Communication with Messages and Events
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用消息和事件进行异步通信
- en: 'In the previous chapter, we updated our services using binary communication.
    However, some services don’t need connected services: the client and the server
    do not need to be connected at the same time, which means communication can be
    done asynchronously. This communication can be done by sending messages to a queue
    or publishing events.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用二进制通信更新了我们的服务。然而，某些服务不需要连接的服务：客户端和服务器不需要同时连接，这意味着通信可以是异步的。这种通信可以通过向队列发送消息或发布事件来完成。
- en: In this chapter, we’ll use Azure services for asynchronous communication – that
    is, Azure Queue Storage and Azure Event Hubs. We’ll also use Apache Kafka as an
    alternative option.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Azure服务进行异步通信——也就是说，Azure队列存储和Azure事件中心。我们还将使用Apache Kafka作为替代选项。
- en: 'You’ll learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习以下内容：
- en: Differentiate message queues and events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分消息队列和事件
- en: Send and receive messages using a queue
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列发送和接收消息
- en: Publish and subscribe events with Azure Event Hubs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure事件中心发布和订阅事件
- en: Use Apache Kafka for event processing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Kafka进行事件处理
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, like the previous chapters, you’ll need an Azure subscription
    and Docker Desktop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章，就像前几章一样，你需要一个Azure订阅和Docker Desktop。
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/)。
- en: The `ch15` folder contains the projects for this chapter, along with their outputs.
    To add the functionality from this chapter, you can start with the source code
    from the previous chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch15`文件夹包含本章的项目及其输出。要添加本章的功能，可以从上一章的源代码开始。'
- en: 'We’ll be considering the following projects in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑以下项目：
- en: '`Codebreaker.AppHost`: The .NET Aspire host project. The app model has been
    enhanced by adding Azure Storage, Azure Event Hubs, and Apache Kafka services.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.AppHost`: 这是一个.NET Aspire宿主项目。通过添加Azure存储、Azure事件中心和Apache Kafka服务，增强了应用程序模型。'
- en: '`Codebreaker.BotQ`: This is a new project that contains nearly the same code
    as `Codebreaker.Bot`. However, instead of using a REST API to trigger gameplay,
    a message queue is used.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.BotQ`: 这是一个包含与`Codebreaker.Bot`几乎相同代码的新项目。然而，它不是使用REST API来触发游戏玩法，而是使用消息队列。'
- en: '`Codebreaker.GameAPIs`: This project has been updated so that it doesn’t forward
    completed games to `live-service` directly. Instead, it publishes events to Azure
    Event Hubs or Apache Kafka depending on the launch profile startup.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs`: 该项目已更新，不再直接将完成的游戏转发到`live-service`。相反，根据启动配置文件启动，它将事件发布到Azure事件中心或Apache
    Kafka。'
- en: '`Codebreaker.Live`: This project has been changed so that it subscribes to
    events from Azure Event Hubs using async streams. The SignalR implementation has
    also been changed so that it uses async streams.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Live`: 该项目已更改，以便使用异步流订阅Azure事件中心的事件。SignalR实现也已更改，以便使用异步流。'
- en: '`Codebreaker.Ranking`: This is a new project that receives events from Azure
    Event Hubs or Kafka, writes this information to an Azure Cosmos DB database, and
    offers a REST service to retrieve the rank of the day. With Event Hub, we have
    a different way to receive events than we do when using `live-service`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Ranking`: 这是一个新的项目，它从Azure事件中心或Kafka接收事件，将这些信息写入Azure Cosmos DB数据库，并提供一个REST服务来检索当天的排名。与使用`live-service`相比，使用事件中心我们有接收事件的不同方式。'
- en: Comparing messages and events
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较消息和事件
- en: 'In the previous chapter, we used connected network communication with all the
    services. First, we look into the communication between the bot and the game APIs
    as shown in *Figure 15**.1*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了与所有服务连接的网络通信。首先，我们来看看如图*图15.1*所示的机器人和游戏API之间的通信：
- en: '![Figure 15.1 - Synchronous communication between the bot and the game APIs](img/B21217_15_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 - 机器人和游戏API之间的同步通信](img/B21217_15_01.jpg)'
- en: Figure 15.1 - Synchronous communication between the bot and the game APIs
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 - 机器人和游戏API之间的同步通信
- en: The bot service can be accessed via REST. The bot service itself invokes the
    game APIs service via gRPC (all other clients use REST with the game APIs service).
    The bot service then continues communication with the game APIs service, sends
    moves until the game is complete, and continues with the next game until a specified
    number of games is played. The bot client invokes the bot service via REST which
    is (like gRPC) synchronous communication, with request/reply. The bot service
    here doesn’t have a synchronous implementation, as the bot client doesn’t need
    to wait until all the games are played – the HTTP protocol would timeout during
    this time. Instead, the bot service returns an HTTP `ACCEPTED` answer (status
    code 202) with a unique identifier which can be used by the client to check for
    a status. The protocol itself is synchronous, as the client waits for answer 202.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人服务可以通过REST访问。机器人服务本身通过gRPC调用游戏API服务（所有其他客户端都使用REST与游戏API服务通信）。然后，机器人服务继续与游戏API服务通信，发送移动操作直到游戏结束，并继续下一轮游戏，直到达到指定的游戏数量。机器人客户端通过REST调用机器人服务，这是（类似于gRPC）同步通信，具有请求/回复。这里的机器人服务没有同步实现，因为机器人客户端不需要等待所有游戏都进行——在此期间HTTP协议会超时。相反，机器人服务返回一个HTTP
    `ACCEPTED`响应（状态码202）和一个唯一标识符，客户端可以使用该标识符来检查状态。该协议本身是同步的，因为客户端等待响应202。
- en: When a game ends, the next part of the communication is shown with *Figure 15**.2*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，下一部分通信通过*图15.2*展示。
- en: '![Figure 15.2 - Synchronous communication initiated from the game APIs](img/B21217_15_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2 - 从游戏API发起的同步通信](img/B21217_15_02.jpg)'
- en: Figure 15.2 - Synchronous communication initiated from the game APIs
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 - 从游戏API发起的同步通信
- en: The game APIs service informs the ranking service and the live service using
    gRPC. The live service continues communication via SignalR to inform all connected
    clients about the game end. The ranking service will be implemented in this chapter
    to write all ended games to a new database. To simplify this image, some services
    that are used within the communication are not shown. There’s synchronous communication
    between the game APIs and Azure Cosmos DB, similar to the ranking service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏API服务使用gRPC通知排名服务和实时服务。实时服务通过SignalR继续通信，通知所有已连接的客户端游戏结束。排名服务将在本章实现，将所有结束的游戏写入新的数据库。为了简化此图，未显示在通信中使用的某些服务。游戏API和Azure
    Cosmos DB之间存在同步通信，类似于排名服务。
- en: With synchronous communication, if there’s a delay in one of the services, the
    delay goes back to the original caller. If there’s an error in one of the services,
    the client does not receive a successful response.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步通信中，如果其中一个服务延迟，延迟会返回到原始调用者。如果其中一个服务出现错误，客户端不会收到成功的响应。
- en: 'Microsoft Azure offers several services that can be used to create asynchronous
    communication: Azure Queue Storage, the Azure Service Bus, Azure Event Gird, and
    Azure Event Hub. Let’s have a look at a new version of the new sequence with the
    communication with the bot client and the bot service in *Figure 15**.3*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Azure提供了一些可以用于创建异步通信的服务：Azure队列存储、Azure服务总线、Azure事件网格和Azure事件中心。让我们看看与机器人客户端和机器人服务通信的*图15.3*的新版本。
- en: '![Figure 15.3 - Asynchronous communication between the bot client and the bot
    service](img/B21217_15_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3 - 机器人客户端与机器人服务之间的异步通信](img/B21217_15_03.jpg)'
- en: Figure 15.3 - Asynchronous communication between the bot client and the bot
    service
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 - 机器人客户端与机器人服务之间的异步通信
- en: With the new implementation the Azure Queue Storage comes into play. The bot
    service registers with the queue to receive messages. The bot client, instead
    of using HTTP to communicate with the bot service, sends a message to the queue.
    The bot client does not need to wait if anybody started to work on this message.
    For the client, the job is done. The bot service, because it registered to receive
    messages, receives the message from the queue and plays the games in the same
    way as before, this doesn’t change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的实现中，Azure队列存储开始发挥作用。机器人服务注册到队列以接收消息。机器人客户端，而不是使用HTTP与机器人服务通信，向队列发送消息。如果有人开始处理此消息，机器人客户端不需要等待。对于客户端来说，工作已经完成。由于机器人服务注册了接收消息，它从队列中接收消息，并以与之前相同的方式玩游戏，这不会改变。
- en: Next, we look at the asynchronous communication initiated by the game APIs service
    in *Figure 15**.4*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看游戏API服务在*图15.4*中启动的异步通信。
- en: '![Figure 15.4 – Asynchronous communication initiated from the game APIs](img/B21217_15_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4 – 从游戏API发起的异步通信](img/B21217_15_04.jpg)'
- en: Figure 15.4 – Asynchronous communication initiated from the game APIs
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 – 从游戏API发起的异步通信
- en: Here, the Azure Event Hub comes into play. The game APIs service, instead of
    doing synchronous communication both with the ranking and the live services, just
    communicates with the event hub. A game-ended event is pushed to this service.
    The game APIs doesn’t need to know who is interested in this event, who is receiving
    this event. Here, two subscribers, the ranking service and the live service are
    registered, and receive this event. From here on, communication is the same as
    before. The ranking service writes the received information to a database (which
    is not shown), and the live service forwards this information to clients that
    are subscribed to the live service – if they are subscribed to the same game type
    that is stored with the event.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Azure事件中心发挥了作用。游戏API服务，而不是与排名和实时服务都进行同步通信，只需与事件中心进行通信。一个游戏结束事件被推送到这个服务。游戏API不需要知道谁对这个事件感兴趣，谁接收这个事件。在这里，注册了两个订阅者，排名服务和实时服务，并接收这个事件。从现在开始，通信与之前相同。排名服务将接收到的信息写入数据库（此处未显示），实时服务将此信息转发给订阅实时服务的客户端
    – 如果他们订阅了与事件存储相同的游戏类型。
- en: The important difference between using message queues and events can be seen
    in this scenario. When sending a message to a queue, just one receiver deals with
    the message. Multiple readers can be connected to the same queue (for performance
    reasons), but only one reader processes the message. If the message is processed
    successfully, it’s removed from the queue. With events, multiple subscribers receive
    and process the same event.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息队列和事件之间的主要区别可以从以下场景中看出。当向队列发送消息时，只有一个接收者处理该消息。可以连接多个读取器到同一个队列（出于性能原因），但只有一个读取器处理消息。如果消息处理成功，它将从队列中删除。使用事件时，多个订阅者接收和处理相同的事件。
- en: Let’s look at the different options that are available with Microsoft Azure
    for messages and events.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Microsoft Azure为消息和事件提供的不同选项。
- en: Message queues
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列
- en: Microsoft Azure offers Azure Queue Storage (part of the Azure Storage Account)
    and Service Bus queues that can be used for queuing messages. Azure Queue Storage
    is the simpler and cheaper option to use, but Azure Service Bus offers a lot more
    features, such as ordering guarantees, atomic operations, sending messages in
    a batch, duplicate detection, and more. See [https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted](https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted)
    for details.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Azure提供Azure队列存储（Azure存储账户的一部分）和服务总线队列，可用于消息队列。Azure队列存储是更简单、更经济的选项，但Azure服务总线提供了更多功能，例如顺序保证、原子操作、批量发送消息、重复检测等。有关详细信息，请参阅[https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted](https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted)。
- en: Events
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'To publish and subscribe to events, you can use Azure Event Grid and Azure
    Event Hubs. **Azure Event Grid** is easy to use to subscribe to events with most
    Azure resources. In the Azure portal, with most resources, you can see the **Events**
    menu in the left bar. For example, when opening an Azure Storage Account, after
    clicking on **Events**, click **Event Subscription**. With a storage account,
    you’ll see event types such as **Blob Created**, **Blob Deleted**, **Blob Renamed**,
    **Directory Created**, **Directory Deleted**, **Directory Renamed**, **Blob Tier
    Changed**, and others, as shown in *Figure 15**.5*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布和订阅事件，您可以使用Azure事件网格和Azure事件中心。**Azure事件网格**易于使用，可以轻松订阅大多数Azure资源的事件。在Azure门户中，对于大多数资源，您可以在左侧栏中看到**事件**菜单。例如，当打开Azure存储账户时，点击**事件**后，点击**事件订阅**。使用存储账户，您将看到如图15.5所示的事件类型，例如**Blob创建**、**Blob删除**、**Blob重命名**、**目录创建**、**目录删除**、**目录重命名**、**Blob层变更**等：
- en: '![Figure 15.5 – Create Event Subscription](img/B21217_15_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5 – 创建事件订阅](img/B21217_15_05.jpg)'
- en: Figure 15.5 – Create Event Subscription
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – 创建事件订阅
- en: Event types are predefined by Azure resources. With event subscriptions, you
    can specify where the event should be fired. You can choose this with the endpoint,
    which can be an Azure function, a storage queue, a hybrid connection, a Webhook,
    and so on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类型由 Azure 资源预定义。使用事件订阅，您可以指定事件应在何处触发。您可以通过端点来选择，这可以是 Azure 函数、存储队列、混合连接、Webhook
    等。
- en: Event Grid also allows you to specify custom topics to be defined, high throughput
    with up to 10,000,000 events per second, and 100,000 operations a month for free.
    This service is available as a PaaS offering running on Azure with the name **Event
    Grid on Kubernetes with Azure Arc** on Kubernetes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 事件网格还允许您指定要定义的自定义主题，具有高达每秒 10,000,000 个事件的高吞吐量，并且每月免费提供 100,000 个操作。此服务作为在 Azure
    上运行的 PaaS 提供服务，名为 **Azure Arc 上的 Kubernetes 事件网格**。
- en: To support even more events, massive scaling with partitions, and a big data
    streaming platform with low latency, **Azure Event Hubs** can be used. This service
    offers reliable event delivery where events are stored for up to 7 days in case
    they have not been delivered. Event Hubs also has great integration with streaming
    analytics.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持更多的事件，使用分区进行大规模扩展，以及一个低延迟的大数据流平台，可以使用 **Azure Event Hubs**。此服务提供可靠的事件交付，如果事件尚未交付，则事件将存储最多
    7 天。事件网格还与流分析有很好的集成。
- en: Let’s update the Codebreaker solution with Azure Queues and Azure Event Hubs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Azure 队列和 Azure 事件网格更新 Codebreaker 解决方案。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, .NET Aspire has planned support with Azure Event Grid.
    Event Hubs, Queue Storage, and Azure Service Bus are already available.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，.NET Aspire 已计划支持 Azure 事件网格。事件网格、队列存储和 Azure 服务总线已经可用。
- en: Let’s start reading from Azure Queue Storage with the Codebreaker bot service.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 Codebreaker 机器人服务从 Azure 队列存储读取。
- en: Creating a service that reads from Azure Queue Storage
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个从 Azure 队列存储读取的服务
- en: 'The `Codebreaker.Bot` project we used previously offers a minimal API service.
    With the updates, a REST API isn’t needed – a simple console application will
    do. Just create a new console application (`dotnet new console -o Codebreaker.BotQ`)
    and copy the source code from `Codebreaker.Bot`. The new bot will also use gRPC
    for communication with the game APIs service. Because this isn’t an ASP.NET Core
    application, these NuGet packages are needed for gRPC:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的 `Codebreaker.Bot` 项目提供了一个最小化的 API 服务。随着更新，不再需要 REST API - 一个简单的控制台应用程序就足够了。只需创建一个新的控制台应用程序（`dotnet
    new console -o Codebreaker.BotQ`），并将 `Codebreaker.Bot` 的源代码复制过来。新的机器人也将使用 gRPC
    与游戏 API 服务进行通信。因为这不是 ASP.NET Core 应用程序，所以需要以下 NuGet 包来支持 gRPC：
- en: '`Google.Protobuf`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Google.Protobuf`'
- en: '`Grpc.Net.ClientFactory`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grpc.Net.ClientFactory`'
- en: '`Grpc.Tools`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grpc.Tools`'
- en: For the DI container, we also need `Microsoft.Extensions.Hosting`, and for the
    .NET Aspire Storage Queues component, we need `Aspire.Azure.Storage.Queues`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖注入容器，我们还需要 `Microsoft.Extensions.Hosting`，对于 .NET Aspire 存储队列组件，我们需要 `Aspire.Azure.Storage.Queues`。
- en: Next, we’ll update the app model.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新应用程序模型。
- en: Defining app-model for Azure Storage
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Azure 存储的应用程序模型
- en: With the AppHost project, reference the newly created project, `Codebreaker.BotQ`,
    and add the `Aspire.Hosting.Azure.Storage` NuGet package so that you can use the
    Azure Storage resource.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AppHost 项目，引用新创建的项目 `Codebreaker.BotQ`，并添加 `Aspire.Hosting.Azure.Storage`
    NuGet 包，以便您可以使用 Azure 存储资源。
- en: 'Invoke the `AddAzureStorage` method to specify Azure Storage with the app model:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AddAzureStorage` 方法通过应用程序模型指定 Azure 存储：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Azure Storage resource supports queues, tables, and blobs. This time, we’ll
    use queues, hence why we’re invoking the `AddQueues` extension method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 存储资源支持队列、表和块。这次，我们将使用队列，因此我们调用了 `AddQueues` 扩展方法。
- en: 'The project configuration references the queue:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 项目配置引用队列：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pay attention to using the new bot project instead of the old one. The new project
    references the queue to pass the connection string. In addition, we specify the
    `Loop` and `Delay` parameters, which are read from the configuration and set as
    environment variables on starting `bot-service`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用新的机器人项目而不是旧的项目。新项目引用队列以传递连接字符串。此外，我们指定了 `Loop` 和 `Delay` 参数，这些参数从配置中读取，并在启动
    `bot-service` 时设置为环境变量。
- en: 'These values are specified within the AppHost development configuration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值在 AppHost 开发配置中指定：
- en: Codebreaker.AppHost/appsettings.Development.json
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/appsettings.Development.json
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The new `bot-service` can read values from the storage queue in a loop – which
    is configured here. When published with Azure, the loop isn’t needed. This will
    be covered later in the *Deploying the solution to Microsoft* *Azure* section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `bot-service` 可以循环读取存储队列中的值——这在此处进行配置。当与 Azure 发布时，循环就不需要了。这将在后面的 *将解决方案部署到
    Microsoft* *Azure* 部分中介绍。
- en: Now that the app model has been specified, let’s continue with the new bot project.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经指定了应用程序模型，让我们继续新的机器人项目。
- en: Using the storage queue component
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用存储队列组件
- en: 'With the previous bot project, we received values so that we could start playing
    a sequence of games. The same information is needed with the new bot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的机器人项目中，我们接收了值以便我们可以开始玩一系列的游戏。新的机器人也需要相同的信息：
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Count` property is for the number of games to play, the `Delay` property
    is for the delay between games, and the `ThinkTime` property is for the value
    of the think time between game moves.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count` 属性用于要玩的游戏数量，`Delay` 属性用于游戏之间的延迟，`ThinkTime` 属性用于游戏移动之间的思考时间值。'
- en: 'The `BotQueueClientOptions` class is used to receive the configuration values
    that are passed from the AppHost:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`BotQueueClientOptions` 类用于接收从 AppHost 传递的配置值：'
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within the constructor of the `BotQueueClient` class, `options`, `logger`,
    the previously used `CodebreakerTimer`, and `QueueServiceClient` are injected:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BotQueueClient` 类的构造函数中，`options`、`logger`、之前使用的 `CodebreakerTimer` 和 `QueueServiceClient`
    被注入：
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `QueueService` client class is from the `Azure.Storage.Queues` namespace
    and communicates with the Azure Storage queue resources to get information about
    queues, as well as to create queues. With the implementation of `CodebreakerTimer`,
    a timer is used to play game after game. It uses the values we receive in the
    message from the queue.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueService` 客户端类来自 `Azure.Storage.Queues` 命名空间，并与 Azure 存储队列资源通信，以获取有关队列的信息，以及创建队列。通过实现
    `CodebreakerTimer`，使用计时器来一局接一局地玩游戏。它使用我们从队列中接收到的值。'
- en: 'The `RunAsync` method kicks off the work:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`RunAsync` 方法启动工作：'
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To read messages from the queue, we use the `QueueClient` class. The `QueueServiceClient`
    method, `GetQueueClient`, returns `QueueClient` to communicate with the queue
    named `botqueue`. With the app model we specified earlier, only the storage account
    is created, not the queue itself. We create the queue if it doesn’t already exist.
    Then – in a loop – we invoke `ProcessMessagesAsync`. If the loop isn’t set, messages
    are retrieved only once. This can be used when publishing Azure Container Apps
    jobs, as will be discussed in the *Deploying the solution to Microsoft* *Azure*
    section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要从队列中读取消息，我们使用 `QueueClient` 类。`QueueServiceClient` 方法 `GetQueueClient` 返回 `QueueClient`
    以与名为 `botqueue` 的队列通信。根据我们之前指定的应用程序模型，只创建了存储帐户，而不是队列本身。如果它不存在，我们创建队列。然后——在循环中——我们调用
    `ProcessMessagesAsync`。如果循环未设置，则只检索一次消息。这可以在 *将解决方案部署到 Microsoft* *Azure* 部分中讨论的发布
    Azure 容器应用作业时使用。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A dead letter queue can be checked to find out if there have been issues with
    messages. When a message cannot be successfully processed a few times, for example,
    when the receiver throws, the message is written to the dead letter queue.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可以检查死信队列以确定是否出现消息问题。例如，当消息无法成功处理几次时，例如，当接收者抛出异常时，消息将被写入死信队列。
- en: 'Next, `ProcessMessageAsync` reads a message from the queue:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`ProcessMessageAsync` 从队列中读取消息：
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, attributes of the queue are checked to see if there’s a message available
    using the `ApproximateMessagesCount` property. If this is the case, messages are
    retrieved using `ReceiveMessagesAsync`. This method reads the messages from the
    queue, at which point the messages can no longer be seen by others. The time the
    message is not visible can be set with the `visibilityTimeout` parameter. The
    default is 30 seconds. When successfully deserializing the message, it is deleted
    using `DeleteMessageAsync`. The `timer.Start` method starts a task to play the
    games asynchronously. So, if a game takes longer to play (with many games or with
    higher think times), this does not influence deleting the message. If the message
    returns to the queue, it can be processed again. The implementation checks for
    the dequeue count of the message that’s retrieved. If it’s read three times, the
    message goes to a dead-letter queue and can be manually checked for issues.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查队列的属性以查看是否可用消息，使用 `ApproximateMessagesCount` 属性。如果是这种情况，使用 `ReceiveMessagesAsync`
    获取消息。此方法从队列中读取消息，此时消息将不再对其他人可见。消息不可见的时间可以使用 `visibilityTimeout` 参数设置。默认值为 30 秒。成功反序列化消息后，使用
    `DeleteMessageAsync` 删除消息。`timer.Start` 方法启动一个异步玩游戏的任务。因此，如果游戏需要更长的时间来玩（有多个游戏或思考时间更长），这不会影响删除消息。如果消息返回到队列，它可以再次处理。实现检查获取的消息的出队计数。如果读取了三次，消息将进入死信队列，可以手动检查问题。
- en: 'Next, let’s configure the DI container:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置 DI 容器：
- en: Codebreaker.BotQ/ApplicationServices.cs
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.BotQ/ApplicationServices.cs
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `AddAzureQueueClient` method is defined with the `Aspire.Azure.Storage.Queues`
    NuGet package. This method configures the Aspire component and registers the `QueueService`
    client with the DI container. With the environment variables passed by the AppHost,
    these values are retrieved using `builder.Configuration.GetSection` and configured
    with the `BotQueueClientOptions` class, which defines the loop’s behavior. Other
    than this, the timer, game runner, and gRPC are configured in the same way as
    the previous bot service implementation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAzureQueueClient` 方法使用 `Aspire.Azure.Storage.Queues` NuGet 包定义。此方法配置 Aspire
    组件并将 `QueueService` 客户端注册到 DI 容器中。通过 AppHost 传递的环境变量，这些值使用 `builder.Configuration.GetSection`
    获取并使用 `BotQueueClientOptions` 类进行配置，该类定义了循环的行为。除此之外，计时器、游戏运行器和 gRPC 的配置与之前的机器人服务实现相同。'
- en: Now, we are ready to run the application and test queues.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备运行应用程序并测试队列。
- en: Running the application
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'You can set breakpoints within the new bot service project to verify the functionality
    of the queue. When you start the application, an Azure Storage Account is created.
    With the initialization of `BotQueueClient`, message queues are created. This
    can verified in the Azure portal, as shown in *Figure 15**.6*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在新的机器人服务项目中设置断点以验证队列的功能。当你启动应用程序时，会创建一个 Azure 存储帐户。随着 `BotQueueClient` 的初始化，消息队列被创建。这可以在
    Azure 门户中验证，如图 15.6* 所示：
- en: '![Figure 15.6 – Storage queues created](img/B21217_15_06.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 15.6 – 创建存储队列](img/B21217_15_06.jpg)'
- en: Figure 15.6 – Storage queues created
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6 – 创建存储队列
- en: 'The `botqueue` and `dead-letter` storage queues have been created. Now, open
    `botqueue` to pass a valid JSON message, as shown in *Figure 15**.7*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`botqueue` 和 `dead-letter` 存储队列已经创建。现在，打开 `botqueue` 并传递一个有效的 JSON 消息，如图 15.7*
    所示：'
- en: '![Figure 15.7 – Add message to queue](img/B21217_15_07.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 15.7 – 将消息添加到队列](img/B21217_15_07.jpg)'
- en: Figure 15.7 – Add message to queue
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7 – 将消息添加到队列
- en: '`BotMessage` class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`BotMessage` 类：'
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With a valid JSON message, you will see that the message is processed. After
    sending a message that’s not in JSON format, you’ll see the message in the dead-letter
    queue – after some retries.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有效的 JSON 消息，你会看到消息被处理了。发送一个非 JSON 格式的消息后，你会在死信队列中看到该消息——在经过一些重试之后。
- en: As the bot now starts playing games when we send messages, let’s get into the
    next enhancement – using Azure Event Hubs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于机器人现在在我们发送消息时开始玩游戏，让我们来看看下一个增强功能——使用 Azure Event Hubs。
- en: Publishing messages to Azure Event Hubs
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 Azure Event Hubs 发布消息
- en: To use Azure Event Hubs, we’ll implement the game APIs service so that we can
    publish events.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Azure Event Hubs，我们将实现游戏 API 服务，以便我们可以发布事件。
- en: Defining app-model for Event Hubs
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Event Hubs 的应用程序模型
- en: To use Azure Event Hubs with the AppHost project, the `Aspire.Hosting.Azure.EventHubs`
    NuGet package is required.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 AppHost 项目中使用 Azure Event Hubs，需要 `Aspire.Hosting.Azure.EventHubs` NuGet
    包。
- en: 'Here, Event Hubs needs to be added to the app model:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，需要将 Event Hubs 添加到应用程序模型中：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `AddAzureEventHubs` method, adds an Azure Event Hubs namespace, `AddEventHub`,
    as an event hub. A namespace is a management container with network endpoints
    and access control. The default Event Hub namespace that’s created is in the Standard
    tier. For development, you can change this to the Basic tier. Event hubs are created
    within namespaces. For scalability, event hubs use one or more partitions. By
    default, the event hub is created with four partitions. A partition contains an
    ordered stream of events. The number of partitions doesn’t change the price, but
    the number of throughput units does. With the number of throughput units, you
    specify a number of events per second. The number of partitions should be equal
    to or higher than the number of throughput units. Throughput units can be changed
    as needed; the number of partitions can only be changed in premium and dedicated
    tiers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAzureEventHubs` 方法添加了一个 Azure Event Hubs 命名空间，`AddEventHub` 作为事件中心。命名空间是一个管理容器，包含网络端点和访问控制。默认创建的事件中心命名空间位于标准层。对于开发，您可以将其更改为基本层。事件中心在命名空间内创建。为了可扩展性，事件中心使用一个或多个分区。默认情况下，事件中心创建时带有四个分区。分区包含一个有序的事件流。分区的数量不会改变价格，但吞吐量单位数会改变。吞吐量单位数指定每秒的事件数。分区的数量应等于或高于吞吐量单位数。吞吐量单位可以根据需要更改；分区的数量只能在高级和专用层中更改。'
- en: 'With the event hub specified, we can reference it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 指定事件中心后，我们可以引用它：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the game APIs service, we replace the referenced live service with the
    event hub. The reference to live service is no longer needed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用游戏 API 服务，我们用事件中心替换了引用的实时服务。对实时服务的引用不再需要。
- en: With this, we can look at the game APIs service.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看游戏 API 服务。
- en: Using the .NET Aspire Event Hubs component to produce events
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire Event Hubs 组件生成事件
- en: To use the .NET Aspire Event Hubs component, we must add the `Aspire.Azure.Messaging.EventHub`
    NuGet package.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 .NET Aspire Event Hubs 组件，我们必须添加 `Aspire.Azure.Messaging.EventHub` NuGet
    包。
- en: 'Using this package, we can configure the DI container:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此包，我们可以配置 DI 容器：
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/ApplicationServices.cs
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the game APIs service, to send information about completed games, in previous
    chapters, we created the `LiveReportClient` class to call a REST service and the
    `GrpcLiveReportClient` class to invoke a gRPC service. Now, we can implement the
    same interface we used earlier – `IGameReport` with the `EventHubReportProducer`
    class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从游戏 API 服务中，为了发送关于完成游戏的详细信息，在之前的章节中，我们创建了 `LiveReportClient` 类来调用 REST 服务和 `GrpcLiveReportClient`
    类来调用 gRPC 服务。现在，我们可以使用 `EventHubReportProducer` 类实现我们之前使用的相同接口 – `IGameReport`。
- en: 'Sending events can easily be done, as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 发送事件可以很容易地完成，如下所示：
- en: Codebreaker.GameAPIs/Services/EventHubReportProducer.cs
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/EventHubReportProducer.cs
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `EventHubReportProducer` class injects the `EventHubProducerClient` class
    to send events to the event hub. `GameSummary` is converted into `BinaryData`
    with `BinaryData.FromObjectAsJson`. The `EventData` class from the `Azure.Messaging.EventHubs`
    namespace allows us to pass a string, `BinaryData`, and `ReadOnlyMemory<byte>`.
    Then, the event is published by invoking the `SendAsync` method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventHubReportProducer` 类注入 `EventHubProducerClient` 类以向事件中心发送事件。使用 `BinaryData.FromObjectAsJson`
    将 `GameSummary` 转换为 `BinaryData`。`Azure.Messaging.EventHubs` 命名空间中的 `EventData`
    类允许我们传递一个字符串、`BinaryData` 和 `ReadOnlyMemory<byte>`。然后，通过调用 `SendAsync` 方法发布事件。'
- en: Now that we’ve published some events, let’s subscribe to them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发布了一些事件，让我们来订阅它们。
- en: Subscribing to Azure Event Hubs events
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅 Azure Event Hubs 事件
- en: The `Codebreaker.Live` project previously offered a gRPC service that was invoked
    by the game APIs service to publish completed games via SignalR. Instead of offering
    a gRPC service, we can subscribe to events.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Codebreaker.Live` 项目之前提供了一种由游戏 API 服务调用的 gRPC 服务，用于通过 SignalR 发布完成的游戏。我们不再提供
    gRPC 服务，而是可以订阅事件。'
- en: Create a new `Codebreaker.Ranking` project so that you can offer minimal APIs.
    This project will receive the same events as `Codebreaker.Live` but write them
    to a database to offer ranks for games based on days, weeks, and months.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `Codebreaker.Ranking` 项目，以便您可以提供最小化的 API。此项目将接收与 `Codebreaker.Live` 相同的事件，但将它们写入数据库以提供基于日、周和月的游戏排名。
- en: 'To create the `Codebreaker.Ranking` project, use the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `Codebreaker.Ranking` 项目，请使用以下命令：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Add the newly created project as a reference to `Codebreaker.AppHost`, and reference
    `Codebreaker.ServiceDefaults` to configure the service defaults. Now, we can update
    app model.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将新创建的项目作为引用添加到 `Codebreaker.AppHost`，并引用 `Codebreaker.ServiceDefaults` 以配置服务默认值。现在，我们可以更新应用模型。
- en: Defining app-model for Event Hubs subscribers
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义事件中心的订阅者应用模型
- en: 'With the AppHost project, the live and ranks projects reference the event hub,
    similar to the events publishing project:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AppHost 项目，直播和排名项目引用事件中心，类似于事件发布项目：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Subscribing to events can be done in two ways, either with the event hub consumer
    client or the event processor client. The event hub consumer client is simpler
    to use and supports async streams. The event processor client is more powerful
    and supports receiving from multiple partitions in parallel. The second option
    needs to save checkpoints in an Azure blob storage account. We use the same account
    that we already use for queues.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅事件可以通过两种方式完成，要么使用事件中心消费者客户端，要么使用事件处理器客户端。事件中心消费者客户端使用起来更简单，并支持异步流。事件处理器客户端功能更强大，并支持并行接收多个分区。第二种选项需要在
    Azure Blob 存储帐户中保存检查点。我们使用与队列相同的帐户。
- en: We will implement both versions. The Codebreaker live service uses async streams,
    and the event hub consumer client with the class `EventHubConsumerClient` fits
    its need. The Codebreaker ranking service makes use of the event processor client,
    using `EventProcessorClient`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现两种版本。Codebreaker 直播服务使用异步流，而具有 `EventHubConsumerClient` 类的事件中心消费者客户端符合其需求。Codebreaker
    排名服务利用事件处理器客户端，使用 `EventProcessorClient`。
- en: Using the Event Hubs component with async streaming
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步流式传输的 Event Hubs 组件
- en: 'When using the `Codebreaker.Live` project, references to the `Aspire.Azure.Messaging.EventHubs`
    NuGet package are required:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Codebreaker.Live` 项目时，需要引用 `Aspire.Azure.Messaging.EventHubs` NuGet 包：
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Codebreaker.Live` project was created in [*Chapter 13*](B21217_13.xhtml#_idTextAnchor317).
    Here, we’ll create a new SignalR hub to offer streaming.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Codebreaker.Live` 项目是在 [*第 13 章*](B21217_13.xhtml#_idTextAnchor317) 中创建的。在这里，我们将创建一个新的
    SignalR 中心以提供流式传输。'
- en: Codebreaker.Live/ApplicationServices.cs
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/ApplicationServices.cs
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `AddAzureEventHubConsumerClient` method configures the `EventHubConsumerClient`
    class as a singleton within the DI container.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAzureEventHubConsumerClient` 方法将 `EventHubConsumerClient` 类配置为 DI 容器中的单例。'
- en: 'Now, we must create a new SignalR hub to inject `EventHubConsumerClient`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个新的 SignalR 中心以注入 `EventHubConsumerClient`：
- en: Codebreaker.Live/Endpoints/StreamingLiveHub.cs
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Endpoints/StreamingLiveHub.cs
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By using the primary constructor, `EventHubConsumerClient` is injected to retrieve
    the events.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用主构造函数，`EventHubConsumerClient` 被注入以检索事件。
- en: 'Now, create the `SubscribeToGameCompletions` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建 `SubscribeToGameCompletions` 方法：
- en: Codebreaker.Live/Endpoints/StreamingLiveHub.cs
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Endpoints/StreamingLiveHub.cs
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: SignalR supports async streaming with methods returning `IAsyncEnumerable`.
    The `SubscribeToGameCompletions` method receives a game type parameter that only
    returns game completions of this game type. `EventHubConsumerClient` supports
    async streaming by invoking the `ReadEventsAsync` method. If the received game
    summary is of the requested game type, it’s returned to the client via the async
    stream.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 支持使用返回 `IAsyncEnumerable` 方法的异步流式传输。`SubscribeToGameCompletions` 方法接收一个游戏类型参数，仅返回此游戏类型的游戏完成情况。`EventHubConsumerClient`
    通过调用 `ReadEventsAsync` 方法支持异步流式传输。如果接收到的游戏摘要符合请求的游戏类型，它将通过异步流返回给客户端。
- en: 'At this point, the middleware needs to be configured so that it references
    the new hub:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，中间件需要配置以引用新的中心：
- en: Codebreaker.Live/ApplicationServices.cs
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/ApplicationServices.cs
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also need to update the client by using async streaming and the new link:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要通过异步流和新的链接更新客户端：
- en: LiveTestClient/StreamingLiveClient.cs
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: LiveTestClient/StreamingLiveClient.cs
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the same SignalR initialization configuration we created in [*Chapter 13*](B21217_13.xhtml#_idTextAnchor317),
    the client now uses the `StreamAsync` method from the SignalR `HubConnection`
    class to async stream the results that are returned from the service.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在 [*第 13 章*](B21217_13.xhtml#_idTextAnchor317) 中创建的相同的 SignalR 初始化配置，客户端现在使用
    SignalR `HubConnection` 类的 `StreamAsync` 方法异步流式传输服务返回的结果。
- en: With these changes, you can already test and run the solution, starting from
    the message queue up to the SignalR streaming client, to receive completed games.
    However, let’s add another Event Hubs client to process messages, this time with
    the Event Hubs processor.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，你现在已经可以测试和运行解决方案，从消息队列开始，直到SignalR流式客户端，以接收完成的游戏。然而，让我们添加另一个事件中心客户端来处理消息，这次使用事件中心处理器。
- en: Using the .NET Aspire Event Hubs component to process messages
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.NET Aspire事件中心组件处理消息
- en: 'The `Codebreaker.Ranking` project receives events, writes those events to an
    Azure Cosmos database, and offers minimal APIs to get ranking information from
    the players. This project references the .NET Aspire `Aspire.Azure.Messaging.EventHubs`
    and `Aspire.Azure.Storage.Blobs` components:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Codebreaker.Ranking` 项目接收事件，将这些事件写入Azure Cosmos数据库，并为玩家提供最小的API来获取排名信息。此项目引用了.NET
    Aspire的 `Aspire.Azure.Messaging.EventHubs` 和 `Aspire.Azure.Storage.Blobs` 组件：'
- en: Codebreaker.Ranking/ApplicationServices.cs
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Ranking/ApplicationServices.cs
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`AddAzureEventProcessorClient` registers a singleton instance of the `EventProcessorClient`
    class. We connect to the same namespace and event hub, so this configuration is
    the same. What’s different is that `AddKeyedAzureBlobClient` is a method from
    the .NET Aspire Blob Storage component. This method registers a singleton instance
    with the DI container to read and write blobs. The storage is connected to the
    event hub by setting `BlobClientServiceKey` to write checkpoints.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAzureEventProcessorClient` 注册了 `EventProcessorClient` 类的单例实例。我们连接到相同的命名空间和事件中心，因此此配置相同。不同之处在于
    `AddKeyedAzureBlobClient` 是.NET Aspire Blob存储组件的一个方法。此方法将单例实例注册到DI容器中，以读取和写入blob。通过设置
    `BlobClientServiceKey` 来写入检查点，将存储连接到事件中心。'
- en: You can also simplify the configuration by not registering a keyed configuration.
    The one default storage component that’s registered is automatically used from
    the event hub component.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过不注册键配置来简化配置。注册的一个默认存储组件会自动从事件中心组件中使用。
- en: Other than the event hub configuration, an EF Core context must be configured
    to write the received game summary information to an Azure Cosmos DB database.
    Check out [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063) for more details. Contrary
    to [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063), we register an EF Core context
    factory with the DI container, which allows us to inject this into a singleton
    object and create the context objects with a shorter lifetime.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了事件中心配置之外，还必须配置EF Core上下文以将接收到的游戏摘要信息写入Azure Cosmos DB数据库。查看[*第3章*](B21217_03.xhtml#_idTextAnchor063)以获取更多详细信息。与[*第3章*](B21217_03.xhtml#_idTextAnchor063)相反，我们在DI容器中注册了一个EF
    Core上下文工厂，这允许我们将它注入到单例对象中，并使用较短的生存周期创建上下文对象。
- en: 'The registered `GameSummaryEventProcessor` is our implementation for dealing
    with events:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注册的 `GameSummaryEventProcessor` 是我们处理事件的实现：
- en: Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The class injects `EventProcessorClient` and the EF Core context factory. This
    class implements methods to start and stop the processing of events.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该类注入 `EventProcessorClient` 和EF Core上下文工厂。此类实现了启动和停止事件处理的方法。
- en: 'The `StartProcessingAsync` method is shown in the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了 `StartProcessingAsync` 方法：
- en: Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you start processing events by invoking the `StartProcessingAsync` method,
    the `EventProcessorClient` class fires .NET events that are invoked when messages
    are received, and on errors: `ProcessEventAsync` and `ProcessErrorAsync`. A received
    message is converted from binary into a `GameSummary` object and written to the
    database. In addition to that, the checkpoint in the storage account is written
    so that we know which event message was processed last.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始通过调用 `StartProcessingAsync` 方法处理事件，`EventProcessorClient` 类就会触发.NET事件，这些事件在接收到消息时以及发生错误时被调用：`ProcessEventAsync`
    和 `ProcessErrorAsync`。接收到的消息被从二进制转换为 `GameSummary` 对象并写入数据库。此外，存储账户中的检查点也被写入，以便我们知道哪个事件消息是最后被处理的。
- en: 'When this is in place, start the application, open the Azure portal to send
    messages to the bot queue to let the bot play some games, and monitor how events
    are sent. *Figure 15**.8* shows the Azure portal showing Event Hub metrics:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一切就绪后，启动应用程序，打开Azure门户向机器人队列发送消息，让机器人玩一些游戏，并监控事件发送情况。*图15.8*显示了Azure门户显示的事件中心指标：
- en: '![Figure 15.8 – Event Hub metrics](img/B21217_15_08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8 – 事件中心指标](img/B21217_15_08.jpg)'
- en: Figure 15.8 – Event Hub metrics
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.8 – 事件中心指标
- en: Apart from checking the Event Hub metrics, verify the data that’s been written
    to the rankings database. Also, start the SignalR client application so that you
    can monitor event data with async streaming.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检查事件中心指标外，还要验证写入排名数据库的数据。此外，启动 SignalR 客户端应用程序，以便可以使用异步流监控事件数据。
- en: 'Open the Event Hub instance in the Azure portal and select **Configuration**
    within the **Settings** category (see *Figure 15**.9*):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 门户中打开事件中心实例，并在 **设置** 类别下选择 **配置**（见 *图 15**.9*）：
- en: '![Figure 15.9 – Event Hub configuration](img/B21217_15_09.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.9 – 事件中心配置](img/B21217_15_09.jpg)'
- en: Figure 15.9 – Event Hub configuration
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.9 – 事件中心配置
- en: Here, you can see the configured partition count and can disable the hub. Regarding
    `ranking-service` is not running on one day, there’s still enough time to process
    the games afterward.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到配置的分区数量，并且可以禁用中心。关于 `ranking-service` 在某一天没有运行，之后仍有足够的时间处理游戏。
- en: You can also configure how data is captured (**Features** | **Capture**) with
    an Azure Storage Account (**Avro** serialization format) or Azure Data Lake (**Parquet**
    or **Delta Lake** serialization format). Make sure you check out the pricing options
    before configuring capturing or other SKUs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以配置如何捕获数据（**功能** | **捕获**）使用 Azure 存储帐户（**Avro** 序列化格式）或 Azure 数据湖（**Parquet**
    或 **Delta Lake** 序列化格式）。在配置捕获或其他 SKU 之前，请确保查看定价选项。
- en: Mentioning prices, what do you need to be aware of when you’re deploying the
    solution to Microsoft Azure?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 提及价格，当你将解决方案部署到 Microsoft Azure 时，你需要注意哪些方面？
- en: Deploying the solution to Microsoft Azure
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将解决方案部署到 Microsoft Azure
- en: When using a low load, the complete solution is not expensive when it’s running
    on Microsoft Azure. CPU power typically results in higher cost. How many containers
    are running with Azure Container Apps? `bot-service`, the `game-apis` service,
    `live-service`, `ranking-service`, and the Redis container. The `game-apis` service
    should scale with the minimum value set to 1, which provides a fast response for
    the first user so that they get a fast first answer. If you scale to 1 when the
    service is idle, there’s an idle price that reduces the cost of the CPU considerably.
    `bot-service`, `live-service`, and `ranking-service` can scale down to 0, which
    means there’s no cost in terms of CPU and memory. However, be aware of custom
    health checks (covered in [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294)), which
    can play against scaling to 0\. With `live-service`, if there’s no listener to
    query for running games, you can’t subscribe to events. Thus, cost only applies
    if clients are connected.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用低负载时，当它在 Microsoft Azure 上运行时，完整的解决方案并不昂贵。CPU 功率通常会导致更高的成本。Azure 容器应用运行了多少个容器？`bot-service`、`game-apis`
    服务、`live-service`、`ranking-service` 和 Redis 容器。`game-apis` 服务应按最小值 1 进行扩展，这为第一个用户提供快速响应，以便他们能够得到快速的第一个答案。如果服务空闲时扩展到
    1，则会有一个空闲价格，这可以显著降低 CPU 成本。`bot-service`、`live-service` 和 `ranking-service` 可以缩减到
    0，这意味着在 CPU 和内存方面没有成本。然而，请注意自定义健康检查（在第 [*12章*](B21217_12.xhtml#_idTextAnchor294)
    中介绍），这可能会对缩减到 0 产生不利影响。对于 `live-service`，如果没有监听器查询正在运行的游戏，则无法订阅事件。因此，只有在客户端连接时才适用成本。
- en: The bot contains a loop that keeps running and checks the queue repeatedly.
    This is not necessary with the Azure Container Apps environment. Here, we can
    create an **Azure Container Apps job** resource. This resource is only started
    based on a trigger – for example, a cron time or an event such as a message available
    in a storage queue.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人包含一个持续运行的循环，并反复检查队列。在 Azure 容器应用环境中，这并不是必要的。在这里，我们可以创建一个 **Azure 容器应用作业**
    资源。此资源仅基于触发器启动——例如，cron 时间或存储队列中可用的消息等事件。
- en: 'Creating Azure Container Apps jobs is not yet supported with .NET Aspire out
    of the box. However, this is possible with some customization. Here’s what you
    need to do:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire 默认情况下不支持创建 Azure 容器应用作业。然而，通过一些定制可以实现这一点。以下是你需要做的：
- en: Initialize the project with `azd init`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `azd init` 初始化项目。
- en: Use `azd infra synth` to create Bicep files and manifest files.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `azd infra synth` 创建 Bicep 文件和清单文件。
- en: Create Azure resources using `azd provision`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `azd provision` 创建 Azure 资源。
- en: Change the manifest file of the project that should be deployed as a Container
    App Job instead of a Container App.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改应作为容器应用作业而不是容器应用部署的项目清单文件。
- en: Deploy the projects using `azd deploy` (you can deploy project by project using
    `azd deploy <service>` or deploy all).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `azd deploy` 部署项目（你可以通过 `azd deploy <service>` 逐个项目部署或部署所有项目）。
- en: Because of the quick updates that are made to .NET Aspire, check out the README
    file in this chapter’s GitHub repository for the latest updates.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于.NET Aspire的快速更新，请查看本章GitHub仓库中的README文件以获取最新更新。
- en: Next, let’s look at an alternative option to using Azure services.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看使用Azure服务的替代选项。
- en: Using Apache Kafka for event processing
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apache Kafka进行事件处理
- en: Apache Kafka can be an alternative to using Azure Queue Storage and Azure Event
    Hubs – especially when it comes to on-premises solutions. This technology is used
    by many companies in their on-premises environments for high performance application-to-application
    messaging, supports a scalable multiple producers and consumers environment (like
    Event Hub), and supports a read-only-once scenario like message queues.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka可以用作Azure队列存储和Azure事件中心的替代品——尤其是在本地解决方案方面。这项技术被许多公司在他们的本地环境中用于高性能的应用程序到应用程序的消息传递，支持可扩展的多生产者和消费者环境（如事件中心），并支持类似消息队列的只读一次场景。
- en: Starting the AppHost with the `OnPremises` launch profile will now use the previously
    created `Codebreaker.Bot`. This uses a REST API instead of message queues, replaces
    the event publishing mechanism of the `game-apis` service, and makes the event
    subscription from `ranking-service` use Apache Kafka.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`OnPremises`启动配置文件的AppHost启动现在将使用之前创建的`Codebreaker.Bot`。这使用REST API而不是消息队列，替换了`game-apis`服务的发布事件机制，并使`ranking-service`的事件订阅使用Apache
    Kafka。
- en: First, we’ll change `app-model`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更改`app-model`。
- en: Configuring Apache Kafka with app-model
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置app-model中的Apache Kafka
- en: 'To use the Apache Kafka resource with `app-model`, we must add the `Aspire.Hosting.Kafka`
    NuGet package:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`app-model`中的Apache Kafka资源，我们必须添加`Aspire.Hosting.Kafka` NuGet包：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `AddKafka` method adds a Docker container for local development. This resource
    is referenced from the `game-apis` service and `ranking-service` to forward the
    connection. `StartupMode` is configured with the launch profile and forwarded
    as an environment variable to both of these projects so that they can choose between
    Azure Event Hubs and Apache Kafka.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddKafka`方法为本地开发添加了一个Docker容器。这个资源被`game-apis`服务和`ranking-service`引用，用于转发连接。`StartupMode`与启动配置文件配置，并作为环境变量转发到这两个项目，以便它们可以在Azure事件中心和Apache
    Kafka之间进行选择。'
- en: Next, we’ll use an Aspire component to publish events.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Aspire组件来发布事件。
- en: Publishing Apache Kafka events
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布Apache Kafka事件
- en: 'When it comes to publishers and subscribers, the `Aspire.Confluent.Kafka` NuGet
    package is used. Within this package, in the `Confluent.Kafka` namespace, the
    `IProducer` interface is defined. An object of this type is injected with the
    `KafkaGameReportProducer` class to publish completed games:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到发布者和订阅者时，使用的是`Aspire.Confluent.Kafka` NuGet包。在这个包中，在`Confluent.Kafka`命名空间内，定义了`IProducer`接口。通过`KafkaGameReportProducer`类注入的对象实现了这个接口，用于发布完成的游戏：
- en: Codebreaker.GameAPIs/Services/KafkaGameReportProducer.cs
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/KafkaGameReportProducer.cs
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`KafkaGameReportProducer` implements the same interface that was used before
    – that is, `IGameReport`. The generic parameters of the `IProducer` interface
    define types for the key and the value. With Kafka, serializers can be specified,
    which allows for custom serialization. We can use simple strings that easily work
    across different platforms. With .NET, we can use the `System.Text.Json` serializer
    to serialize `GameSummary` objects to strings.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`KafkaGameReportProducer`实现了之前使用的相同接口——即`IGameReport`。`IProducer`接口的泛型参数定义了键和值的类型。使用Kafka时，可以指定序列化器，这允许自定义序列化。我们可以使用简单字符串，它们在不同平台上易于工作。使用.NET时，我们可以使用`System.Text.Json`序列化器将`GameSummary`对象序列化为字符串。'
- en: The `IProducer` interface defines the `ProduceAsync` method to publish messages.
    The first parameter names a topic. Upon invoking the `ProduceAsync` method, the
    message is sent to a Kafka broker service. The message is kept there until it
    is read by a subscriber for the topic – up to a retention period. The default
    retention period is 1 week. To send messages to multiple subscribers (`live-service`
    and `ranking-service`), a list of topics is used.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`IProducer`接口定义了`ProduceAsync`方法来发布消息。第一个参数命名了一个主题。在调用`ProduceAsync`方法时，消息被发送到Kafka代理服务。消息将保留在那里，直到被主题的订阅者读取——直到保留期结束。默认保留期是1周。要向多个订阅者（`live-service`和`ranking-service`）发送消息，使用一个主题列表。'
- en: The `ProduceAsync` method returns `DeliveryResult` when the message is delivered
    to the broker. We don’t wait for the message to be delivered; instead, we use
    a loop to send the same message with multiple topics. `Task.WhenAll` could be
    used to wait for all deliveries or the `Flush` method to wait until a timeout
    is reached. The `Flush` method returns the number of items in the queue. Before
    the producer gets disposed of, you need to make sure that all messages are delivered
    to the broker. Because the producer is configured as a singleton with the DI container,
    we can keep the flush for later.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息被发送到代理时，`ProduceAsync` 方法返回 `DeliveryResult`。我们不等待消息被发送；相反，我们使用循环发送具有多个主题的相同消息。可以使用
    `Task.WhenAll` 等待所有发送完成，或者使用 `Flush` 方法等待直到超时。`Flush` 方法返回队列中的项目数。在生产者被销毁之前，你需要确保所有消息都已发送到代理。因为生产者被配置为使用
    DI 容器的单例，我们可以稍后执行刷新操作。
- en: 'Now, we must configure the DI container:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须配置 DI 容器：
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/ApplicationServices.cs
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `AddKafkaProducer` method registers the `IProducer` interface as a singleton.
    `kafkamessaging` is the string that’s used with `app-model` to get the connection
    string to the Kafka server. With the `KafkaProducerSettings` parameter, telemetry
    configuration and producer settings can be configured. Here, the `AllowAutoCreateTopics`
    setting is set to `true` – which is the default with producers. With consumers,
    this value is `false` by default. The previously created `KafkaGameReportProducer`
    class is registered as a singleton as well. The `IGameReport` interface is already
    used by the `GameService` class to report completed games, regardless of how this
    reporting is implemented.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddKafkaProducer` 方法将 `IProducer` 接口注册为单例。`kafkamessaging` 是与 `app-model`
    一起使用的字符串，用于获取 Kafka 服务器的连接字符串。使用 `KafkaProducerSettings` 参数，可以配置遥测配置和生产者设置。在这里，`AllowAutoCreateTopics`
    设置被设置为 `true` – 这是生产者的默认值。对于消费者，此值默认为 `false`。之前创建的 `KafkaGameReportProducer`
    类也被注册为单例。`IGameReport` 接口已经被 `GameService` 类用于报告完成的游戏，无论这种报告是如何实现的。'
- en: Now, let’s subscribe to these events with the ranking service.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用排名服务订阅这些事件。
- en: Subscribing to Apache Kafka events
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅 Apache Kafka 事件
- en: 'Subscriber applications such as `Codebreaker.Ranking` need the same .NET Aspire
    component package to be referenced. When it comes to consumer classes, the `IConsumer`
    interface must be injected:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `Codebreaker.Ranking` 这样的订阅应用程序需要引用相同的 .NET Aspire 组件包。当涉及到消费者类时，必须注入 `IConsumer`
    接口：
- en: Codebreaker.Ranking/GameSummaryKafkaConsumer.cs
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Ranking/GameSummaryKafkaConsumer.cs
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The ranking service subscribes to messages with the `ranking` topic using the
    `Subscribe` method. The topic was used when publishing messages. If the topic
    doesn’t exist because a message hasn’t been written yet, the `Consume` method
    throws a `ConsumeException` error. This exception is caught, and the `Consume`
    method is repeated after a delay. A game might not be completed when the ranking
    service starts up and the Docker container of the Kafka service hasn’t been configured
    to keep state.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 排名服务使用 `Subscribe` 方法订阅 `ranking` 主题的消息。该主题在发布消息时使用过。如果由于尚未写入消息而导致主题不存在，`Consume`
    方法将抛出 `ConsumeException` 错误。该异常被捕获，并在延迟后重复执行 `Consume` 方法。当排名服务启动时，可能一个游戏尚未完成，并且
    Kafka 服务的 Docker 容器尚未配置为保持状态。
- en: When a message is received, it is written to the database, as we saw earlier
    with Azure Event Hubs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到消息时，它会写入数据库，正如我们之前在 Azure Event Hubs 中看到的。
- en: 'Now, we just need to configure the DI container:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要配置 DI 容器：
- en: Codebreaker.Ranking/ApplicationServices.cs
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Ranking/ApplicationServices.cs
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To register the `IConsumer` interface, we use the `AddKafkaConsumer` method.
    `GroupId` needs to be configured with a Kafka consumer client. Groups are used
    for scalability. Similar to Azure Event Hubs, Kafka makes use of partitions. Multiple
    subscribers using the same group ID receive messages from different partitions.
    This allows for high scalability.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册 `IConsumer` 接口，我们使用 `AddKafkaConsumer` 方法。`GroupId` 需要与 Kafka 消费者客户端一起配置。组用于可伸缩性。类似于
    Azure Event Hubs，Kafka 使用分区。使用相同组 ID 的多个订阅者从不同的分区接收消息。这允许实现高可伸缩性。
- en: 'Now, start the solution with the `OnPremises` launch profile. Start the Open
    API page of the bot to let it play some games and debug and monitor the services.
    *Figure 15**.10* shows metrics counts for the `game-apis` service with the bytes
    transmitted:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `OnPremises` 启动配置文件启动解决方案。启动机器人的 Open API 页面，让它玩一些游戏，并调试和监控服务。*图 15.10*
    显示了 `game-apis` 服务的指标计数，包括传输的字节数：
- en: '![Figure 15.10 – Kafka metrics](img/B21217_15_10.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.10 – Kafka 指标](img/B21217_15_10.jpg)'
- en: Figure 15.10 – Kafka metrics
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.10 – Kafka 指标
- en: Check the bytes, the messages that have been published and subscribed to, and
    the queue sizes for the publisher and the subscriber. Now is also a good time
    to take a break and play a few rounds of Codebreaker.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字节数、已发布和订阅的消息以及发布者和订阅者的队列大小。现在也是休息一下，玩几轮 Codebreaker 的好时机。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to decouple services by using asynchronous
    communication technologies, messages, and events. With Microsoft Azure, we used
    queues from an Azure Storage Account and events from Azure Event Hubs. Instead
    of using these PaaS services, you can also run Kafka within a Docker container
    in an Azure Container Apps environment, but you need to configure this with the
    app model.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过使用异步通信技术、消息和事件来解耦服务。使用 Microsoft Azure，我们使用了 Azure 存储账户中的队列和 Azure
    Event Hubs 中的事件。除了使用这些 PaaS 服务外，你还可以在 Azure Container Apps 环境中运行 Kafka，但需要使用应用程序模型进行配置。
- en: You also learned the differences between using message queues and a publish/subscribe
    event model with multiple subscribers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了使用消息队列与具有多个订阅者的发布/订阅事件模型之间的区别。
- en: Be sure to check out the .NET Aspire component for Azure Service Bus in the
    *Further reading* section. This service offers more features with message queues,
    and you’ll learn about some concepts you already know about from Apache Kafka.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必查看“进一步阅读”部分中关于 Azure Service Bus 的 .NET Aspire 组件。此服务提供了更多功能，包括消息队列，你将了解一些你已知的
    Apache Kafka 的概念。
- en: After all the different services, in the next chapter we’ll look into what more
    we should think about when deploying the application to the production environment,
    and we’ll deploy the solution to a Kubernetes cluster.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了所有不同的服务之后，在下一章中，我们将探讨在将应用程序部署到生产环境时应考虑的更多因素，并将解决方案部署到 Kubernetes 集群。
- en: Further reading
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were discussed in this chapter, please
    refer to the following links:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，请参阅以下链接：
- en: '*.NET Aspire Azure Blob Storage* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component](https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET Aspire Azure Blob Storage* *组件*: [https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component](https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component)'
- en: '*.NET Aspire Azure Queue Storage* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component](https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET Aspire Azure Queue Storage* *组件*: [https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component](https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component)'
- en: '*Azure Event Hubs* *documentation*: [https://learn.microsoft.com/en-us/azure/event-hubs/](https://learn.microsoft.com/en-us/azure/event-hubs/)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Azure Event Hubs* *文档*: [https://learn.microsoft.com/en-us/azure/event-hubs/](https://learn.microsoft.com/en-us/azure/event-hubs/)'
- en: '.*NET Aspire Azure Event Hubs* *component*: [https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs](https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '.*NET Aspire Azure Event Hubs* *组件*: [https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs](https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs)'
- en: '*.NET Aspire Azure Service Bus* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component](https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET Aspire Azure Service Bus* *组件*: [https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component](https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component)'
- en: '*.NET Aspire RabbitMQ* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component](https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET Aspire RabbitMQ* *组件*: [https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component](https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component)'
- en: '*.NET Aspire Apache Kafka* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component](https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET Aspire Apache Kafka* *组件*: [https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component](https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component)'
- en: '*Apache Kafka .NET* *Client*: [https://docs.confluent.io/kafka-clients/dotnet/current/overview.html](https://docs.confluent.io/kafka-clients/dotnet/current/overview.html)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apache Kafka .NET* *客户端*: [https://docs.confluent.io/kafka-clients/dotnet/current/overview.html](https://docs.confluent.io/kafka-clients/dotnet/current/overview.html)'
