- en: '*Chapter 3***: Improving the Developer Workflow**'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：改进开发者工作流程'
- en: When developing for **Augmented Reality** (**AR**), like any software development,
    it's important to understand your tools, learn how to troubleshoot when you get
    "stuck," and endeavor to make your overall developer workflow more efficient.
    In this chapter, we will consider some best practices, techniques, and advanced
    tools for troubleshooting and testing AR applications in development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发增强现实（**AR**）时，就像任何软件开发一样，了解你的工具、学习如何在遇到“卡住”时进行故障排除，并努力使你的整体开发者工作流程更加高效是非常重要的。在本章中，我们将探讨一些故障排除和测试开发中AR应用程序的最佳实践、技术和高级工具。
- en: Unity is generally quite friendly for developing for mobile devices. For example,
    you will normally use the Editor Play-mode to preview your scene in the Editor,
    allowing rapid*develop-test-update-repeat* cycles. And with an *editor remote
    tool*, you can run and test on your target mobile device without having to do
    builds each time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Unity通常对移动设备开发非常友好。例如，你通常使用编辑器播放模式在编辑器中预览你的场景，允许快速*开发-测试-更新-重复*循环。并且，使用*编辑器远程工具*，你可以在目标移动设备上运行和测试，而无需每次都进行构建。
- en: But Augmented Reality imposes unique challenges because it requires sensor input
    on the remote device, including a live camera feed and motion sensors. It also
    requires AR processing built into the mobile software (Android, iOS) that detects
    features in the environment (such as planes or faces) and tracks your physical
    device in the real world. Your app requires this data, but it's remote and not
    normally available to Unity in the Editor Play mode. In this chapter, we'll explore
    various techniques and tools to deal with this and improve AR development workflows.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，增强现实提出了独特的挑战，因为它需要在远程设备上获取传感器输入，包括实时摄像头流和运动传感器。它还需要在移动软件（Android、iOS）中集成的AR处理，以检测环境中的特征（如平面或人脸）并跟踪你的物理设备在现实世界中的位置。你的应用程序需要这些数据，但它们是远程的，并且在编辑器播放模式下通常不可用。在本章中，我们将探讨各种技术和工具来处理这些问题，并改善AR开发工作流程。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下内容：
- en: Troubleshooting with log messages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志消息进行故障排除
- en: Debugging with a debugger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试器进行调试
- en: Testing with an editor remote tool
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编辑器远程工具进行测试
- en: Simulating environments with the Unity project MARS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity项目MARS模拟环境
- en: If you're impatient and want to begin developing an AR project right away, you
    may skip this chapter and jump into [*Chapter 4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077),
    *Creating an AR User Framework*, where we start our first real project. If that's
    the case, go ahead but please plan to come back here as soon as you realize this
    chapter can help you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你急于开始开发一个AR项目，可以直接跳过本章，进入[*第4章*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)，*创建AR用户框架*，在那里我们将开始我们的第一个实际项目。如果这样做，请继续，但请计划一旦你意识到本章能帮助你，就尽快回来。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter does not have special technical requirements other than a working
    development system with Unity installed, a project set up with the XR Plugin and
    the AR Foundation package, and the ability to successfully build and run on your
    target device, as given in [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013),
    *Setting Up for AR Development*. The scripts and assets created in this chapter
    can be found in this book''s GitHub repository: [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章除了需要一个安装了Unity的工作开发系统、设置了XR插件和AR Foundation包的项目，以及能够在目标设备上成功构建和运行的能力之外，没有特殊的技术要求，这些要求在[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)，*为AR开发做准备*中已有说明。本章中创建的脚本和资源可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)。
- en: Troubleshooting with log messages
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日志消息进行故障排除
- en: If (and when) an error occurs while developing or running your Unity project,
    the first thing you must do is consult the **Console** window for messages. The
    **Console** window is where you'll find all kinds of messages including asset
    import warnings, compiler errors, runtime errors in play mode, build problems
    when you **Build And Run**, and others. Compiler errors (such as coding syntax
    errors) may prevent the scene from running at all (and the **Play** button will
    become disabled).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在开发或运行你的Unity项目时发生错误（并且当它发生时），你必须做的第一件事就是查看**控制台**窗口中的信息。**控制台**窗口是你会找到各种信息的地方，包括资产导入警告、编译器错误、播放模式中的运行时错误、当你**构建并运行**时的构建问题以及其他问题。编译器错误（如编码语法错误）可能会阻止场景运行（并且**播放**按钮将变为禁用状态）。
- en: 'There are three levels of console messages: **Info**, **Warning** (shown in
    orange), and **Error** (shown in red). You can filter the messages using the toggle
    buttons in the **Console** window toolbar, as highlighted in the following screen
    capture:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台信息有三个级别：**信息**、**警告**（以橙色显示）和**错误**（以红色显示）。你可以使用控制台窗口工具栏中的切换按钮来过滤信息，如下面的屏幕截图所示：
- en: '![Figure 3.1 – The Console window showing a null exception error'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 显示null异常错误的控制台窗口'
- en: '](img/Figure_3.01-ConsoleNullExceptionError.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01-ConsoleNullExceptionError.jpg)'
- en: Figure 3.1 – The Console window showing a null exception error
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 显示null异常错误的控制台窗口
- en: Runtime errors, such as the `null`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时错误，例如`null`。
- en: 'Tip: "Warning" messages can be extraneous'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：“警告”信息可能是多余的
- en: I generally ignore the warning messages in the Unity Editor's **Console** window,
    unless I'm deliberately looking for something, as they're often verbose, not relevant
    to my own problem solving, and thus become noise instead of information. You can
    hide warning messages by un-clicking the **Warning** button in the Console toolbar.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常忽略Unity编辑器**控制台**窗口中的警告信息，除非我故意在寻找某些东西，因为它们通常很冗长，与我自己的问题解决不相关，因此变成了噪音而不是信息。你可以通过在控制台工具栏中取消点击**警告**按钮来隐藏警告信息。
- en: In the `Assets/` folder. In the preceding screenshot, *Figure 3.1*, the null
    exception error occurred on line 27 of the `MyScript.cs` file when it was calling
    the C# `System.Int32.Parse` function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assets/`文件夹中。在前面的屏幕截图*图3.1*中，当调用C#的`System.Int32.Parse`函数时，`MyScript.cs`文件的第27行发生了null异常错误。
- en: 'Tip: Read your Console messages carefully'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：仔细阅读你的控制台信息
- en: A common mistake I often see by novice and experienced developers alike is not
    reading error messages carefully. When you're in the flow of things, it's often
    too easy to assume you know what the message is saying and not really read it,
    missing key clues needed for troubleshooting.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到新手和经验丰富的开发者都犯的一个常见错误就是没有仔细阅读错误信息。当你处于事情的处理流程中时，很容易假设你知道信息在说什么，而没有真正阅读它，从而错过了调试所需的关键线索。
- en: You can also write a message to the Console from your own scripts, using `Debug.Log`
    calls.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`Debug.Log`调用从你的脚本向控制台写入信息。
- en: Using Debug.Log
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Debug.Log
- en: When writing C# scripts, you can log your own messages to the Console using
    `Debug.Log()` function calls. This is the most common method of checking and understanding
    what is going on inside your code when it is running. `Debug.Log` messages appear
    as *Info* messages in the Console (you can also call `Debug.LogError()` to have
    them appear as *Error* messages instead).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写C#脚本时，你可以使用`Debug.Log()`函数调用将你的信息记录到控制台。这是检查和了解代码在运行时内部发生什么的最常见方法。`Debug.Log`信息在控制台中显示为*信息*消息（你也可以调用`Debug.LogError()`使它们显示为*错误*消息）。
- en: 'For example, suppose I''m trying to locate the root cause of an error in my
    project. And suppose there are several `MonoBehaviour` scripts that I''m developing
    related to this problem. I may place log statements at the entry of specific functions
    and other log statements to print out specific variables that I am suspicious
    of. Take the following code, for example, for a script named `MyScript.cs`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我正在尝试定位我项目中一个错误的根本原因。假设有几个与这个问题相关的`MonoBehaviour`脚本是我正在开发的。我可能会在特定函数的入口处放置日志语句，以及其他日志语句来打印出我怀疑的特定变量。以下是一个名为`MyScript.cs`的脚本的示例代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In C# you can combine (concatenate) text strings using the plus (`+`) operator.
    In our example, the integer `number` is concatenated to the message string (in
    `Update`), and C# automatically converts the number to a string value first.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，你可以使用加号（`+`）运算符组合（连接）文本字符串。在我们的例子中，整数`number`被连接到消息字符串（在`Update`中），C#自动将数字转换为字符串值。
- en: Add this script to your scene by creating an empty GameObject (**GameObject**
    | **Create Empty**) and dragging the script file from the **Project** window onto
    the GameObject. Then click **Play**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个空GameObject（**GameObject** | **创建空**）并将脚本文件从**项目**窗口拖放到GameObject上，将此脚本添加到场景中。然后点击**播放**。
- en: 'When this code runs, what I see in the **Console** window is shown in the following
    screen capture:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码运行时，我在**控制台**窗口中看到的内容如下所示：
- en: '![Figure 3.2 – Console messages about my Debug.Log statements'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 关于我的Debug.Log语句的控制台消息'
- en: '](img/Figure_3.02-ConsoleDoSomething.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02-ConsoleDoSomething.jpg)'
- en: Figure 3.2 – Console messages about my Debug.Log statements
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 关于我的Debug.Log语句的控制台消息
- en: This will reveal that `DoSomething` is only called once rather than 10 times
    as expected. Can you figure out why?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将揭示`DoSomething`只被调用了一次，而不是预期的10次。你能找出原因吗？
- en: Studying the code in `Update` does not explain why `DoSomething` was only called
    once. From there I can re-examine the logic to determine why and when `number`
    prematurely becomes less than zero. You can see the bug is in the `DoSomething`
    function itself where it "accidentally" sets `number = -1`, causing the condition
    in `Update` to never call `DoSomething` after the first time. You may have been
    stumped while fixated on the `Update` code, but then discovered the bug actually
    occurs deeper in the program.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 研究代码中的`Update`并不能解释为什么`DoSomething`只被调用了一次。从那里我可以重新检查逻辑，以确定为什么和何时`number`提前变成小于零。你可以看到错误实际上在`DoSomething`函数本身，它“意外地”将`number
    = -1`，导致`Update`中的条件在第一次之后永远不会再次调用`DoSomething`。你可能一直专注于`Update`代码，但后来发现错误实际上发生在程序更深的地方。
- en: 'Tip: Bug hunting? It''s probably not where you''re looking'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在寻找错误？可能不是你正在寻找的地方
- en: Here's a funny story. A man leaves a bar and sees a drunk guy walking around
    in circles near a lamppost, searching the sidewalk. "Hey pal, what's the matter?".
    The drunk replies, "I lost my keys." So together they keep looking. Finally, the
    man asks, "Are you sure you dropped them here?". The other responds, "Well, I
    dropped them over there. But the light's better here." Keep this in mind when
    you're trying to find a bug – it's often exactly *not* where you're looking, otherwise
    you probably would have found it already!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的故事。一个男人离开酒吧，看到一个男人在路灯附近绕着圈子，在人行道上寻找。 “嘿，伙计，怎么了？” 醉汉回答，“我丢了钥匙。” 于是他们一起继续寻找。最后，那个男人问，“你确定你在这里丢了吗？”
    另一个回答，“嗯，我是在那里丢的。但这里的光线更好。” 当你试图寻找错误时，请记住这一点——它通常**正好不是**你正在寻找的地方，否则你可能已经找到了它！
- en: So far, we've been using the **Console** window to log messages using the Unity
    Editor play mode. In fact, the Console is so useful for troubleshooting, you may
    also want to see your debug messages while running your project on your remote
    device. Next, let's consider how you can use the Console while running on a mobile
    device connected via USB.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用**控制台**窗口，通过Unity编辑器的播放模式来记录消息。实际上，控制台在故障排除方面非常有用，你可能还希望在运行远程设备上的项目时查看你的调试消息。接下来，让我们考虑一下如何在通过USB连接的移动设备上运行时使用控制台。
- en: Using the Console with a mobile device
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用控制台与移动设备
- en: 'You can use Console logs while running your app on your mobile device, provided
    the app was built with **Development Mode** enabled, and the device is attached
    to the Unity Editor via a USB cable (or equivalent). To set this up, use the following
    steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在移动设备上运行你的应用时使用控制台日志，前提是应用已启用**开发模式**，并且设备通过USB线（或等效设备）连接到Unity编辑器。要设置此环境，请按照以下步骤操作：
- en: Open the **Build Settings** window using **File** | **Build Settings**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **构建设置**打开**构建设置**窗口。
- en: Check the **Development Mode** checkbox.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中**开发模式**复选框。
- en: Click the **Build And Run** button.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建并运行**按钮。
- en: After the app successfully builds, installs on the device, launches, and starts
    to run, any `Debug.Log` calls will appear in the Console if you attach it to the
    application.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用成功构建、安装到设备、启动并开始运行后，如果你将控制台附加到应用上，任何`Debug.Log`调用都会出现在控制台。
- en: 'In the Unity **Console** window toolbar, select the **Editor** button and select
    the process running on your mobile device. For example, the following screenshot
    shows me attaching the **Editor Console** to my Android device:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Unity **控制台**窗口工具栏中，选择**编辑器**按钮并选择在移动设备上运行的进程。例如，以下截图显示我将**编辑器控制台**附加到我的Android设备上：
- en: '![Figure 3.3 – Console window attached to an Android device'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 连接到Android设备上的控制台窗口'
- en: '](img/Figure_3.03_-ConsoleAndroid.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_-ConsoleAndroid.jpg)'
- en: Figure 3.3 – Console window attached to an Android device
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 连接到 Android 设备的控制台窗口
- en: It's that easy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就这么简单。
- en: There are other kinds of logs provided by Unity and by your device's operating
    system. In the **Console** window, use the three-dot context menu at the top right
    to access the full Player logs and Editor logs files. On Android, you can also
    get more detailed messages from your Android device using *logcat*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 和您的设备操作系统还提供了其他类型的日志。在 **控制台** 窗口中，使用右上角的三点上下文菜单来访问完整的玩家日志和编辑器日志文件。在 Android
    上，您还可以使用 *logcat* 从您的 Android 设备获取更详细的消息。
- en: Using logcat with Android devices
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Android 设备的 logcat
- en: 'On Android mobile devices you can monitor any and all log messages from Android
    itself and any apps running on the device (including your own Unity one) using
    a tool called **logcat**. You can install and use *logcat* directly inside the
    Unity Editor from the Package Manager with the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 移动设备上，您可以使用名为 **logcat** 的工具监控 Android 本身以及设备上运行的任何应用程序的任何日志消息（包括您自己的
    Unity 应用程序）。您可以通过以下步骤直接在 Unity 编辑器中通过包管理器安装和使用 *logcat*：
- en: Use **Window** | **Package Manager** to open the **Package Manager** window.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **窗口** | **包管理器** 打开 **包管理器** 窗口。
- en: In the filter select list at the top left, choose **Unity Registry**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左上角的过滤器选择列表中，选择 **Unity 注册表**。
- en: Use the search input field at the top right to look for `logcat`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用右上角的搜索输入字段查找 `logcat`。
- en: Select the package and click the **Install** button.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择包并点击 **安装** 按钮。
- en: After the package installs, open the **Logcat** window using **Window** | **Analysis**
    | **Android Logcat**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装包之后，使用 **窗口** | **分析** | **Android Logcat** 打开 **Logcat** 窗口。
- en: 'With *logcat* installed and its window open, you can run your app on your connected
    mobile device. It now does not require being built in **Development Mode** enabled
    nor attached to the Editor Console. You''ll discover there is a lot going on inside
    your device; messages may be streaming from all the running tasks, not just your
    own application! The **Android Logcat** window offers ways to filter the messages
    to show only those coming from your app, while your app is running on the device:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 *logcat* 并打开其窗口后，您可以在连接的移动设备上运行您的应用程序。现在它不需要在 **开发模式** 下构建，也不需要连接到编辑器控制台。您会发现设备内部有很多活动；消息可能来自所有正在运行的任务，而不仅仅是您自己的应用程序！**Android
    Logcat** 窗口提供了过滤消息的方法，以仅显示在设备上运行的应用程序发出的消息：
- en: Use the filter drop-down list and choose your app.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器下拉列表并选择您的应用程序。
- en: Enter search expressions to filter the message stream.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入搜索表达式以过滤消息流。
- en: 'A screen capture of the **Android Logcat** window is shown in the following
    figure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 **Android Logcat** 窗口的屏幕截图：
- en: '![Figure 3.4 – Android Logcat window'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.4 – Android Logcat window'
- en: '](img/Figure_3.04-LogcatWindow.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.04-LogcatWindow.jpg]'
- en: Figure 3.4 – Android Logcat window
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Android Logcat 窗口
- en: I realize the text in this screen capture is probably too small to read here!
    This screenshot is intended to give you a feel of what the window provides.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到这个屏幕截图中的文本可能太小，在这里看不清楚！这个截图的目的是让您了解窗口提供的内容。
- en: 'Info: Using the Android adb command-line tool'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：使用 Android adb 命令行工具
- en: If you are developing for an Android device, I recommend you also install the
    Android **adb** (Android Debug Bridge) command-line tool. (This is what Unity
    uses internally for watching Console logs and running the Logcat window.) If you
    have installed the full *Android Studio* ([https://developer.android.com/studio](https://developer.android.com/studio)),
    it may already be present on your system. Otherwise, you can install just the
    command-line tools by navigating to [https://developer.android.com/studio#downloads](https://developer.android.com/studio#downloads)
    and scrolling down the page to the *Command line tools only* section to find the
    download link for your platform.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为 Android 设备开发，我建议您还安装 Android **adb**（Android 调试桥）命令行工具。（这是 Unity 用于监视控制台日志和运行
    Logcat 窗口的内部工具。）如果您已安装完整的 *Android Studio* ([https://developer.android.com/studio](https://developer.android.com/studio))，它可能已经存在于您的系统上。否则，您可以通过导航到
    [https://developer.android.com/studio#downloads](https://developer.android.com/studio#downloads)
    并滚动到页面底部的 *仅命令行工具* 部分来找到您平台的下载链接。
- en: With adb installed (and in your command path), you can run a variety of device
    actions. For more details, see [https://developer.android.com/studio/command-line/adb](https://developer.android.com/studio/command-line/adb).
    For example, the `adb devices` command will list the Android device it presently
    sees connected to your computer. `adb logcat` will show the internal device logs.
    To filter the logs for only Unity-related messages, use the `adb logcat -v time
    -s Unity command`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了adb（并在您的命令路径中）的情况下，您可以运行各种设备操作。有关更多详细信息，请参阅[https://developer.android.com/studio/command-line/adb](https://developer.android.com/studio/command-line/adb)。例如，`adb
    devices`命令将列出当前连接到您的计算机的Android设备。`adb logcat`将显示内部设备日志。要仅过滤Unity相关的消息，请使用`adb
    logcat -v time -s Unity command`。
- en: Using the Unity Editor `logcat` is great, but what can you do if you want to
    troubleshoot an app without the mobile device attached to your computer? This
    can certainly be the case with augmented reality applications that require moving
    within your environment. One solution is you could create a *virtual* console
    window, explained next.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unity编辑器的`logcat`很棒，但如果您想在未连接到计算机的移动设备上调试应用程序，您能做什么呢？这对于需要在你环境中移动的增强现实应用程序来说肯定是这样。一个解决方案是您可以创建一个*虚拟*控制台窗口，下面将进行解释。
- en: 'Info: Using the Xcode console for iOS devices'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：使用iOS设备的Xcode控制台
- en: If you're developing for iOS, there is no equivalent to logcat in Unity. However,
    you can view logs from your device using the Xcode log console. Open the console
    using **View** | **Debug Area** | **Activate Console**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为iOS开发，Unity中没有`logcat`的等效功能。但是，您可以使用Xcode日志控制台查看设备日志。使用**视图** | **调试区域**
    | **激活控制台**打开控制台。
- en: Simulating a Console window in your app
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的应用程序中模拟控制台窗口
- en: A strategy for capturing console logs, even when your device is detached from
    the development computer, is to provide a "virtual console" window in your application.
    This window would be for development, not production. The idea is to replace `Debug.Log`
    calls with a wrapper function, which optionally outputs to a text object on an
    in-app text area when running a development build.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获控制台日志的策略之一是在您的应用程序中提供一个“虚拟控制台”窗口，即使您的设备已从开发计算机断开连接。这个窗口用于开发，而不是生产。其想法是将`Debug.Log`调用替换为一个包装函数，在运行开发版本时，该函数可以选择性地将输出到应用程序文本区域上的文本对象。
- en: We will talk about Unity **Canvas** objects and UI components more in [*Chapter
    4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077), *Creating an AR User Framework*,
    so I offer the steps here with only limited explanation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第4章*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)中更详细地讨论Unity **Canvas**对象和UI组件，*创建AR用户框架*，因此在这里仅提供步骤，而不进行过多解释。
- en: 'To implement the wrapper function, use the following steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现包装函数，请按照以下步骤操作：
- en: In the `scripts/` folder (create one if you don't have one yet).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`scripts/`文件夹中（如果您还没有，请先创建一个）。
- en: '*Right-click* in the `scripts` folder, select `ScreenLog`.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`scripts`文件夹中*右键单击*，选择`ScreenLog`。
- en: 'Open the script for editing and replace the default code with the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本进行编辑，并将默认代码替换为以下内容：
- en: '[PRE1]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We implement `ScreenLog` as a `public static ScreenLog Instance` variable),
    ensuring there will only be one instance of `ScreenLog` in the scene and providing
    the ability to address the `Log` function as a class method. (We'll discuss *class*
    versus *instance* methods and the *singleton pattern* more in the next chapter.)
    This way, you're able to call `ScreenLog.Log()` from anywhere in your own code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ScreenLog`实现为一个`public static ScreenLog Instance`变量，确保场景中只有一个`ScreenLog`实例，并提供将`Log`函数作为类方法调用的能力。（我们将在下一章中更详细地讨论*类*与*实例*方法以及*单例模式*。）这样，您就可以从自己的代码中的任何地方调用`ScreenLog.Log()`。
- en: 'Next, we''ll add a text window to the app, and toggle its visibility with a
    *Debug* button in the UI. (As mentioned, we are going to cover the Unity UI in
    more detail in later chapters.) First, let''s assume your AR application will
    be used on a mobile device in portrait orientation with a screen space Canvas
    to contain the text area:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在应用程序中添加一个文本窗口，并通过UI中的*调试*按钮切换其可见性。（如前所述，我们将在后面的章节中更详细地介绍Unity UI。）首先，让我们假设您的AR应用程序将在纵向屏幕空间Canvas中用于移动设备，以包含文本区域：
- en: From the main menu, create a new Canvas by selecting `Debug Canvas`. This will
    also add an **Event System** game object to the scene if one is not already present.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中，通过选择`Debug Canvas`创建一个新的Canvas。如果场景中尚未存在，这将也会添加一个**事件系统**游戏对象。
- en: To edit the *Screen Space* Canvas, let's switch the **Scene** window to a 2D
    view by clicking the **2D** button in the **Scene** window toolbar.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编辑**屏幕空间**画布，让我们通过在**场景**窗口工具栏中单击**2D**按钮将**场景**窗口切换到2D视图。
- en: 'It''s also helpful to arrange the **Game** window and **Scene** window side
    by side. Because we''re developing for AR, set the **Game** window''s display
    to a fixed portrait aspect ratio, such as **2160x1080 Portrait** using the dimension
    select list in the **Game** window''s top toolbar. This layout can be seen in
    the following screenshot:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**游戏**窗口和**场景**窗口并排排列也很有用。因为我们正在为AR开发，所以将**游戏**窗口的显示设置为固定肖像宽高比，例如使用**游戏**窗口顶部工具栏中的尺寸选择列表的**2160x1080
    肖像**。此布局可以在以下屏幕截图中看到：
- en: '![Figure 3.5 – The Scene and Game windows side by side with the portrait device
    view set up'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 场景和游戏窗口并排显示，并设置了肖像设备视图'
- en: '](img/Figure_3.05-SceneGameSidebyside.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05-SceneGameSidebyside.jpg)'
- en: Figure 3.5 – The Scene and Game windows side by side with the portrait device
    view set up
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 场景和游戏窗口并排显示，并设置了肖像设备视图
- en: (This screenshot was captured after all these steps were completed; your Canvas
    does not have the scrolling text area yet.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: （此屏幕截图是在完成所有这些步骤之后捕获的；你的画布还没有滚动文本区域。）
- en: 'Next, we''ll add a scrolling text area where we''ll write the log messages:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个滚动文本区域，我们将在此处写入日志消息：
- en: In the **Hierarchy** window, select **Debug Canvas**. Then right-click, and
    select **UI** | **Scroll View**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**调试画布**。然后右键单击，并选择**UI** | **滚动视图**。
- en: Resize and place the `400`. The resulting `0, 0)`, `0`, `(0, 1)`, `(1, 1)`,
    and `(0.5, 1)`. The **Rect Transform** component and the location of the **Anchor
    Presets** menu button are shown in the following screenshot:![Figure 3.6 – The
    Rect Transform component with the Anchor Presets button highlighted
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整大小并放置 `400`。结果为 `(0, 0)`，`0`，`(0, 1)`，`(1, 1)`，和 `(0.5, 1)`。以下屏幕截图中显示了**矩形变换**组件和**锚点预设**菜单按钮的位置：![图
    3.6 – 带有锚点预设按钮高亮的矩形变换组件
- en: '](img/Figure_3.06-RectTransform.jpg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06-RectTransform.jpg)'
- en: Figure 3.6 – The Rect Transform component with the Anchor Presets button highlighted
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.6 – 带有锚点预设按钮高亮的矩形变换组件
- en: Allow only vertical scrolling by un-checking the **Scroll Rect** | **Horizontal**
    checkbox.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过取消选中**滚动矩形** | **水平**复选框，仅允许垂直滚动。
- en: Then double-click **Debug Canvas** in **Hierarchy** to bring it into focus (you
    might need to double-click it twice).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在**层次结构**中双击**调试画布**以将其聚焦（你可能需要双击两次）。
- en: In **Hierarchy**, unfold **Scroll View** (the triangle icon) and its **Viewport**.
    Select the child **Content** object and set its anchors and size by selecting
    **Rect Transform** | **Anchor Presets** | **Stretch-Stretch**, and *Shift* + *Alt*
    + click **Stretch-Stretch** to fill the Viewport.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中展开**滚动视图**（三角形图标）及其**视口**。选择子**内容**对象，通过选择**矩形变换** | **锚点预设** | **拉伸-拉伸**来设置其锚点和大小，并使用*Shift*
    + *Alt* + 点击**拉伸-拉伸**以填充视口。
- en: 'The **Inspector** window for **Scroll View** is shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**滚动视图**的**检查器**窗口如下截图所示：'
- en: '![Figure 3.7 – Scroll View property settings'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 滚动视图属性设置'
- en: '](img/Figure_3.07-ScrollViewInspector.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.07-ScrollViewInspector.jpg)'
- en: Figure 3.7 – Scroll View property settings
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 滚动视图属性设置
- en: 'Now we can work on the text element itself:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始处理文本元素本身：
- en: On the `Debug Text`. (Note, you may prefer to use *TextMesh Pro* text elements,
    which give you more control over the typography and padding without any performance
    costs—introduced in the next chapter.)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Debug Text` 上。 （注意，你可能更喜欢使用*TextMesh Pro*文本元素，它提供了对字体和填充的更多控制，而不会产生任何性能成本——将在下一章中介绍。）
- en: With the **Debug Text** game object selected, have it fill the **Content** area
    by using **Anchor Presets** | **Stretch-Stretch**, and *Shift* + *Alt* + click
    **Stretch-Stretch**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**调试文本**游戏对象，使用**锚点预设** | **拉伸-拉伸**使其填充**内容**区域，并使用*Shift* + *Alt* + 点击**拉伸-拉伸**。
- en: For reference, enter a placeholder string in the `[Log message]`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了参考，在 `[日志消息]` 中输入占位符字符串。
- en: Adjust `36`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 `36`。
- en: Set **Alignment** to **Bottom**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**对齐方式**设置为**底部**。
- en: Change **Vertical Overflow** to **Overflow** (instead of **Truncate**).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**垂直溢出**更改为**溢出**（而不是**截断**）。
- en: Personally, I like white text on a black background for the Console. If you
    agree, in `0` and `200`, and in `255`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我个人喜欢在控制台使用白色文本和黑色背景。如果你同意，在 `0` 和 `200`，以及 `255`。
- en: 'The resulting GameObject **Hierarchy** and **Inspector** settings for the **Debug
    Text** object are shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试文本**对象的最终**层次结构**和**检查器**设置如图所示：'
- en: '![Figure 3.8 – Debug Canvas Hierarchy and Debug Text settings'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 调试画布层次结构和调试文本设置'
- en: '](img/Figure_3.08-DebugTextInspector.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.08-DebugTextInspector.jpg)'
- en: Figure 3.8 – Debug Canvas Hierarchy and Debug Text settings
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 调试画布层次结构和调试文本设置
- en: 'Next, we will add our script to the scene:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把我们的脚本添加到场景中：
- en: With **Debug Canvas** selected in the **Hierarchy** window, locate the **ScreenLog**
    script in the **Project** window and drag the script file onto the **Debug Canvas**
    GameObject.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**调试画布**，在**项目**窗口中找到**ScreenLog**脚本，并将脚本文件拖放到**调试画布**游戏对象上。
- en: 'With **Debug Canvas** still selected, locate the **Debug Text** GameObject
    in the **Hierarchy** window, drag it into the **Inspector**, and drop it onto
    the **Log Text** slot on the **Screen Log** component, as shown in the following
    screenshot:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然选择**调试画布**，在**层次结构**窗口中找到**调试文本**游戏对象，将其拖入**检查器**，并将其放到**屏幕日志**组件上的**日志文本**槽位，如图所示：
- en: '![Figure 3.9 – Setting the Log Text reference to the Debug Text GameObject'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 – 将日志文本引用设置为调试文本游戏对象'
- en: '](img/Figure_3.09-CanvasScreenLogText.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.09-CanvasScreenLogText.jpg)'
- en: Figure 3.9 – Setting the Log Text reference to the Debug Text GameObject
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 将日志文本引用设置为调试文本游戏对象
- en: 'We can now add a Debug button to the UI to toggle the text panel, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在UI中添加一个调试按钮来切换文本面板，如下所示：
- en: '*Right-click* on `Debug Button`.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键点击* `调试按钮`。'
- en: Size and place the button on your screen. For example, set its `175, 175`),
    and anchor it to the lower left of the screen using `30, 30`).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上调整按钮的大小和位置。例如，设置其`175, 175`），并使用`30, 30`将其锚定到屏幕的左下角。
- en: In `Debug`. You can also adjust its font properties from here, such as setting
    `36`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`调试`。您也可以从这里调整其字体属性，例如设置`36`。
- en: To change the Debug button into a toggle button, replace the **Button** component
    with a **Toggle** component.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将调试按钮改为切换按钮，需要将**按钮**组件替换为**切换**组件。
- en: In **Hierarchy**, select the **Debug Button** object. In the **Inspector**,
    use the three-dot context menu icon on the **Button** component (or right-click
    on the component) and select **Remove Component**.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**调试按钮**对象。在**检查器**中，使用**按钮**组件上的三个点上下文菜单图标（或右键单击组件）并选择**移除组件**。
- en: Then click `toggle`, and add a **Toggle** component.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击`切换`，并添加一个**切换**组件。
- en: Now we'll configure the toggle to handle On Value Changed events. In the **Toggle**
    | **On Value Changed** properties, click the small **+** icon at the bottom right.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将配置切换以处理`On Value Changed`事件。在**切换** | **On Value Changed**属性中，点击右下角的小**+**图标。
- en: Drag the **Scroll View** object from the **Hierarchy** window onto the on-click
    event's **None (Object)** slot. Then, in the **Function** selector, choose **Game
    Object** | **Dynamic Bool** | **SetActive**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**滚动视图**对象从**层次结构**窗口拖放到点击事件的**无（对象**）槽位。然后在**函数**选择器中，选择**游戏对象** | **动态布尔值**
    | **SetActive**。
- en: 'The **Toggle** component now has the following settings:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**切换**组件现在有以下设置：'
- en: '![Figure 3.10 – Debug Button set up with a Toggle component'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.10 – 配置了切换组件的调试按钮'
- en: '](img/Figure_3.10-ButtonToggleInspector.jpg)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10-ButtonToggleInspector.jpg)'
- en: Figure 3.10 – Debug Button set up with a Toggle component
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.10 – 配置了切换组件的调试按钮
- en: Lastly, save this rig as a prefab that you can reuse in other scenes. Drag `Prefabs/`
    folder in the `Prefabs` folder, create one first. The folder name is not required,
    it's by convention.)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将这个设置保存为一个预制件，您可以在其他场景中重复使用。将`Prefabs/`文件夹从`Prefabs`文件夹拖动出来，首先创建一个。文件夹名称不是必需的，这是惯例。）
- en: And remember, if you make new changes to this Canvas (or children) in **Hierarchy**,
    save those changes to the prefab asset using **Overrides** | **Apply All**.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且记住，如果你在**层次结构**中对这个画布（或其子项）进行了新的更改，请使用**覆盖** | **应用全部**将那些更改保存到预制资产中。
- en: 'With this setup, we can now use the `ScreenLog.Log()` function instead of `Debug.Log()`
    anywhere you want to add an info message in your code, as shown in the following
    screen capture from my phone:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个设置，我们现在可以在代码中任何需要添加信息消息的地方使用`ScreenLog.Log()`函数代替`Debug.Log()`，如图所示：
- en: '![Figure 3.11 – Screenshot of my phone using the virtual console'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – 使用虚拟控制台的手机截图'
- en: '](img/Figure_3.11-VirtualConsoleOnPhone.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11-VirtualConsoleOnPhone.jpg)'
- en: Figure 3.11 – Screenshot of my phone using the virtual console
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 使用虚拟控制台的手机截图
- en: An advantage of this approach is you can modify it to selectively provide a
    status message log even for end users, not just your own development.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是您可以修改它，以便为最终用户选择性地提供状态消息日志，而不仅仅是自己的开发。
- en: 'Info: Third-party virtual consoles'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：第三方虚拟控制台
- en: Aside from rolling your own as we do in this chapter, there are third-party
    virtual console packages you can find in the Asset Store, with a range of features
    and costs. The *Lunar Mobile Console – Free* asset, for example, is easy to install
    and use – see [https://assetstore.unity.com/packages/tools/gui/lunar-mobile-console-free-82881](https://assetstore.unity.com/packages/tools/gui/lunar-mobile-console-free-82881).
    These tend to be strictly for development purposes and are not appropriate for
    exposing log messages to end users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像本章中我们这样做之外，您还可以在 Asset Store 中找到第三方虚拟控制台包，它们具有各种功能和成本。例如，*Lunar Mobile Console
    – Free* 资产易于安装和使用 – 请参阅[https://assetstore.unity.com/packages/tools/gui/lunar-mobile-console-free-82881](https://assetstore.unity.com/packages/tools/gui/lunar-mobile-console-free-82881)。这些通常仅用于开发目的，不适合向最终用户公开日志消息。
- en: To get a deeper insight into what their code is doing, many programmers like
    to use a debugger tool provided by **Integrated development environments** (**IDEs**)
    such as Visual Studio.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解他们的代码在做什么，许多程序员喜欢使用由**集成开发环境**（**IDEs**）如 Visual Studio 提供的调试器工具。
- en: Debugging with a debugger
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试器进行调试
- en: Professional software developers are familiar with code **debuggers**, used
    to test and debug programs by stopping the execution at specific lines of code
    and examining the state of the memory and other runtime conditions. In this section,
    I will give you an introduction to using the Visual Studio debugger with Unity
    projects. The debugger can be used in both the Unity Editor play mode, as well
    as in your builds running on the attached device.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 专业软件开发者熟悉代码**调试器**，用于通过在特定代码行停止执行来测试和调试程序，并检查内存和其他运行时状态。在本节中，我将向您介绍如何使用 Visual
    Studio 调试器与 Unity 项目。调试器可以在 Unity 编辑器的播放模式下使用，也可以在附加设备上运行的构建中使用。
- en: With a debugger, you can set a **breakpoint** at a specific line of code, where
    the execution will stop at that line, allowing you to query the values of variables,
    and wait for you to step through or continue the execution of the program.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器，您可以在特定代码行设置**断点**，执行将在该行停止，允许您查询变量的值，并等待您逐步执行或继续程序的执行。
- en: 'To use a debugger in the Editor play mode you do not need to make any special
    changes, provided you are already using Visual Studio for your code editor (or
    another supported **interactive development environment** (**IDE**) such as **VS
    Code** or **JetBrains Rider**). You can configure Unity for your preferred editor/debugger
    using **Edit** | **Preferences** | **External Tools**. For example, in the following
    screenshot, you can see my Unity install has **External Script Editor** set to
    a **Visual Studio Community** version:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在编辑器播放模式下使用调试器，您不需要进行任何特殊更改，前提是您已经使用 Visual Studio 作为您的代码编辑器（或另一个受支持的**交互式开发环境**（**IDE**）如
    **VS Code** 或 **JetBrains Rider**）。您可以使用**编辑** | **首选项** | **外部工具**来配置 Unity 以使用您首选的编辑器/调试器。例如，在以下屏幕截图中，您可以看到我的
    Unity 安装已将**外部脚本编辑器**设置为**Visual Studio Community**版本：
- en: '![Figure 3.12 – You can set your default code editor in the Unity Preferences
    window'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.12 – 您可以在 Unity 首选项窗口中设置您的默认代码编辑器'
- en: '](img/Figure_3.12-ExternalEditor.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.12-ExternalEditor.jpg]'
- en: Figure 3.12 – You can set your default code editor in the Unity Preferences
    window
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 您可以在 Unity 首选项窗口中设置您的默认代码编辑器
- en: 'With Visual Studio opened for your project (choose `MyScript.cs` script is
    open, and I''ve created a breakpoint on line 25, indicated in VS Code by a red
    dot on the screen:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在为您的项目打开 Visual Studio（选择`MyScript.cs`脚本已打开，我在第 25 行创建了一个断点，在 VS Code 中屏幕上以红色点表示）：
- en: '![Figure 3.13 – Setting a breakpoint in Visual Studio'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.13 – 在 Visual Studio 中设置断点'
- en: '](img/Figure_3.13-VSBreakpoint.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.13-VSBreakpoint.jpg]'
- en: Figure 3.13 – Setting a breakpoint in Visual Studio
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 在 Visual Studio 中设置断点
- en: 'To attach the debugger to your Unity Editor session, use the **Attach To Unity**
    button in the top toolbar. Back in Unity, if you have not yet enabled C# debugging,
    you will get a prompt like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要将调试器附加到您的 Unity 编辑器会话，请使用顶部工具栏中的**附加到 Unity**按钮。回到 Unity，如果您尚未启用 C# 调试，您将收到如下提示：
- en: '![Figure 3.14 – Unity prompt to enable debugging'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.14 – Unity 提示启用调试'
- en: '](img/Figure_3.14-EnableDebuggingDialog.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.14-EnableDebuggingDialog.jpg]'
- en: Figure 3.14 – Unity prompt to enable debugging
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – Unity 提示启用调试
- en: Click one of the **Enable** buttons.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 点击一个 **启用** 按钮。
- en: Note that Debug Mode can be toggled using the corresponding icon in the bottom-right
    corner of the Editor window.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以使用编辑器窗口右下角的相应图标切换调试模式。
- en: 'Once debugging is enabled and you click **Play** in the Editor, if and when
    a breakpoint line is reached in your code, execution will stop, and Visual Studio
    will be given focus on your desktop. The current line of code will be highlighted
    in yellow on your screen:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用调试并您在编辑器中点击 **播放**，如果您的代码中达到断点行，执行将停止，并且 Visual Studio 将在您的桌面上获得焦点。当前代码行将在您的屏幕上以黄色突出显示：
- en: '![Figure 3.15 – Debugging a line of code in the Visual Studio debugger'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.15 – 在 Visual Studio 调试器中调试一行代码'
- en: '](img/Figure_3.15-VSDebugging.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15-VSDebugging.jpg)'
- en: Figure 3.15 – Debugging a line of code in the Visual Studio debugger
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 在 Visual Studio 调试器中调试一行代码
- en: There are also debugging windows where you can examine the current values of
    variables in the script, the current call stack, and so on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些调试窗口，您可以在其中检查脚本中变量的当前值、当前的调用堆栈等。
- en: 'While debugging, the *debugger toolbar* is also active at the top of the window,
    depicted in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试过程中，*调试工具栏* 也将在窗口顶部活动，如下面的截图所示：
- en: '![Figure 3.16 – The debugger toolbar'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.16 – 调试工具栏'
- en: '](img/Figure_3.16-DebuggerToolbar.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16-DebuggerToolbar.jpg)'
- en: Figure 3.16 – The debugger toolbar
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 调试工具栏
- en: 'The **Continue** button (1) will continue running from here until it reaches
    another breakpoint. The **Stop** button (2) will disable the debugger mode, and
    the step buttons (3) do the following: **Step Into** follows the code into the
    body of a function call, **Step Over** will run to the next line of code in the
    current file, and **Step Up** takes you up the call stack one level.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**继续** 按钮（1）将从此处继续运行，直到达到另一个断点。**停止** 按钮（2）将禁用调试模式，而步骤按钮（3）执行以下操作：**进入** 将代码跟随到函数调用的主体中，**跳过**
    将运行到当前文件中的下一行代码，而**向上** 将您带到调用堆栈的一个级别。'
- en: You can also run the debugger on code running on your attached mobile device.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在连接的移动设备上运行的代码上运行调试器。
- en: Debugging on a remote device
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在远程设备上进行调试
- en: 'To run the debugger on your project running on your mobile device, you must
    first enable **Script Debugging** and **Development Build** in the project''s
    **Build Settings**. Use the following steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的移动设备上运行的项目中运行调试器，您必须首先在项目的 **构建设置** 中启用 **脚本调试** 和 **开发构建**。使用以下步骤：
- en: Open the **Build Settings** window using **File** | **Build Settings**.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **文件** | **构建设置** 打开 **构建设置** 窗口。
- en: Check the **Development Build** checkbox.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中 **开发构建** 复选框。
- en: Check the **Script Debugging** checkbox.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中 **脚本调试** 复选框。
- en: Optionally, check the **Wait For Managed Debugger** checkbox.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，选中 **等待托管调试器** 复选框。
- en: When you're ready, click **Build And Run**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您准备好时，点击 **构建并运行**。
- en: 'When the app is running on the device, attach your debugger to the remote process
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在设备上运行时，按照以下方式将调试器附加到远程进程：
- en: In Visual Studio, select from the main menu **Debug** | **Attach Unity Debugger**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，从主菜单选择 **调试** | **附加 Unity 调试器**。
- en: 'A dialog box will appear with a list of potential processes, as depicted in
    the following screenshot. Choose the process that you want to attach and click
    **OK**:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个对话框，其中包含潜在进程的列表，如下面的截图所示。选择您想要附加的进程并点击 **确定**：
- en: '![](img/Figure_3.17-ChooseUnityProcess.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.17-ChooseUnityProcess.jpg)'
- en: Figure 3.17 – Attaching the Visual Studio debugger to a Unity process on a mobile
    phone
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 将 Visual Studio 调试器附加到手机上的 Unity 进程
- en: You can now set and examine breakpoints in the app running on your device. Note,
    once you close the app on your phone, the debugger also stops in Visual Studio
    and detaches.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在设备上运行的应用程序中设置和检查断点。注意，一旦您在手机上关闭应用程序，调试器也会在 Visual Studio 中停止并断开连接。
- en: 'The **Wait For Managed Debugger** build option is useful if you need to start
    the debugger before Unity starts running. Since Visual Studio needs a process
    to attach to, the app will start up, then wait for you to attach the debugger,
    as shown in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待托管调试器** 构建选项在您需要在 Unity 开始运行之前启动调试器时很有用。由于 Visual Studio 需要一个进程来附加，应用程序将启动，然后等待您附加调试器，如下面的截图所示：'
- en: '![Figure 3.18 – Prompt on phone waiting for a debugger to be attached'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.18 – 手机上等待调试器连接的提示'
- en: '](img/Figure_3.18-AttachDebugger.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.18-AttachDebugger.jpg)'
- en: Figure 3.18 – Prompt on phone waiting for a debugger to be attached
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 手机上等待附加调试器的提示
- en: In fact, we need this in our little example because the `Update` function in
    `MyScript` will likely be called before I get a chance to attach the debugger.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在我们的这个小例子中，我们需要这个功能，因为`MyScript`中的`Update`函数可能会在我有机会附加调试器之前被调用。
- en: 'Info: Additional Unity debugging tools'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：额外的Unity调试工具
- en: Unity provides more windows and tools you can use to debug your projects and
    gain insight into what is going on under the hood. For troubleshooting Input System
    actions, see **Window** | **Analysis** | **Input Debugger**. For deep analysis
    and profiling, there is the **Profiler**, **Frame Debugger**, and **Physics Debugger**
    also under the **Window** | **Analysis** menu. For the UI, there's the **Immediate
    Mode GUI** (**IMGUI**) debugger at **Window** | **Analysis** | **IMGUI Debugger**,
    and when customizing the Unity Editor user interface, see the **Window** | **UI
    Toolkit** | **Debugger** (UI Toolkit is expected to be extended for use in your
    own apps in the future). There's even a **Window** | **Render Pipeline** | **Render
    Pipeline Debug** window.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了更多您可以使用来调试项目和深入了解底层发生情况的窗口和工具。要调试输入系统操作，请参阅**窗口** | **分析** | **输入调试器**。对于深入分析和性能分析，还有**性能分析器**、**帧调试器**和**物理调试器**，它们也位于**窗口**
    | **分析**菜单下。对于UI，有**即时模式GUI**（**IMGUI**）调试器，位于**窗口** | **分析** | **IMGUI调试器**，当自定义Unity编辑器用户界面时，请参阅**窗口**
    | **UI工具包** | **调试器**（UI工具包预计将在未来扩展以用于您自己的应用程序）。甚至还有一个**窗口** | **渲染管线** | **渲染管线调试**窗口。
- en: Wouldn't it also be good if you could click **Play** to run the project on your
    mobile device without having to **Build And Run** every time? Let's look at *editor
    remote tools* next.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能够点击**播放**在您的移动设备上运行项目而不必每次都进行**构建和运行**，那岂不是更好？让我们接下来看看*编辑器远程工具*。
- en: Testing with an editor remote tool
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编辑器远程工具进行测试
- en: Developers have been using Unity for many years to develop games and applications
    for iOS and Android devices. You want the ability to click **Play** in the Unity
    Editor and run the current scene remotely on your attached mobile device. Having
    an iterative *develop-test-update-repeat* cycle is key to more efficient and effective
    development.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者已经使用Unity多年为iOS和Android设备开发游戏和应用程序。您希望在Unity编辑器中点击**播放**，然后在您连接的移动设备上远程运行当前场景。拥有迭代性的*开发-测试-更新-重复*循环对于更高效和有效的开发至关重要。
- en: To facilitate this developer workflow, Unity provides an application called
    **Unity Remote 5** that you install on your phone and then connect to the Unity
    Editor. It is available for both Android ([https://play.google.com/store/apps/details?id=com.unity3d.mobileremote](https://play.google.com/store/apps/details?id=com.unity3d.mobileremote))
    and iOS ([https://apps.apple.com/us/app/unity-remote-4/id871767552](https://apps.apple.com/us/app/unity-remote-4/id871767552)).
    It allows you to use a mobile device to view and test your project live, inside
    the Unity Editor, without having to build each time. The device acts as a "remote
    control" for the scene running in the Editor Play-mode, including screen touch,
    accelerometer, gyroscope, and webcam input.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便这种开发工作流程，Unity提供了一个名为**Unity Remote 5**的应用程序，您可以在手机上安装它，然后将其连接到Unity编辑器。它适用于Android
    ([https://play.google.com/store/apps/details?id=com.unity3d.mobileremote](https://play.google.com/store/apps/details?id=com.unity3d.mobileremote))
    和iOS ([https://apps.apple.com/us/app/unity-remote-4/id871767552](https://apps.apple.com/us/app/unity-remote-4/id871767552))。它允许您使用移动设备在Unity编辑器中实时查看和测试您的项目，而不必每次都进行构建。该设备充当编辑器播放模式中运行的场景的“遥控器”，包括屏幕触摸、加速度计、陀螺仪和摄像头输入。
- en: Unfortunately, Remote 5 is not suitable for AR development. A remote tool from
    Unity compatible with AR Foundation has been long promised and is expected, but
    as I am writing this, it does not exist. Perhaps it will be available by the time
    you are reading this as a free core Unity feature, so try searching the Unity
    Forums ([https://forum.unity.com/?gq=AR%20Foundation%20Editor%20Play%20Mode](https://forum.unity.com/?gq=AR%20Foundation%20Editor%20Play%20Mode)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Remote 5不适合AR开发。一个与AR Foundation兼容的远程工具已经被长期承诺并预期，但现在我写这篇文章时，它还不存在。也许当您阅读这篇文章时，它将作为一个免费的Unity核心功能可用，所以请尝试在Unity论坛上搜索
    ([https://forum.unity.com/?gq=AR%20Foundation%20Editor%20Play%20Mode](https://forum.unity.com/?gq=AR%20Foundation%20Editor%20Play%20Mode)))。
- en: As is often the case in large developer communities, at least one talented individual
    has stepped up and produced a remote tool for AR Foundation, available on the
    Unity Asset Store. The *AR Foundation Editor Remote* tool by Kyrylo Kuzyk can
    be found at [https://assetstore.unity.com/packages/tools/utilities/ar-foundation-editor-remote-168773](https://assetstore.unity.com/packages/tools/utilities/ar-foundation-editor-remote-168773).
    It is not free and, at the present time, it does not support the new Input System,
    only the legacy Input Manager.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型开发者社区中，通常至少会有一个有才华的个人站出来，为 AR 基础库制作远程工具，并在 Unity 资产商店提供。Kyrylo Kuzyk 的 *AR
    Foundation Editor Remote* 工具可以在 [https://assetstore.unity.com/packages/tools/utilities/ar-foundation-editor-remote-168773](https://assetstore.unity.com/packages/tools/utilities/ar-foundation-editor-remote-168773)
    找到。该工具不是免费的，并且目前不支持新的输入系统，只支持传统的输入管理器。
- en: 'If you choose to purchase the package, you can install it using the Package
    Manager as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择购买该套餐，可以使用包管理器按照以下步骤进行安装：
- en: Open **Package Manager** using **Window** | **Package Manager**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **窗口** | **包管理器** 打开 **包管理器**。
- en: Filter the list for **My Assets** using the select list at the top left of the
    window.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用窗口左上角的选项列表过滤 **我的资产** 列表。
- en: Find the **AR Foundation Editor Remote** package, click **Download** (if necessary),
    then click **Import**. And then in the **Import** dialog box, click the **Import**
    button.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 **AR Foundation Editor Remote** 套件，如果需要，点击 **下载**，然后点击 **导入**。然后在 **导入**
    对话框中，点击 **导入** 按钮。
- en: The package is installed in the `Plugins/ARFoundationRemoteInstaller/` folder.
    The installer should run automatically. Note there is a `Documentation` file as
    well.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 套件安装在 `Plugins/ARFoundationRemoteInstaller/` 文件夹中。安装程序应该会自动运行。注意，还有一个 `Documentation`
    文件。
- en: 'To use the AR Foundation Editor Remote tool, take the following steps as outlined
    in the documentation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 AR 基础库编辑器远程工具，请按照文档中概述的以下步骤操作：
- en: Go to **Edit** | **Project Settings** | **XR Plug-in Management** | the **Desktop**
    tab.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **编辑** | **项目设置** | **XR 插件管理** | **桌面** 选项卡。
- en: Check the **AR Foundation Remote** checkbox.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **AR Foundation Remote** 复选框。
- en: Ensure your project is targeting your mobile device platform in **File** | **Build
    Settings**.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的项目针对您的移动设备平台在 **文件** | **构建设置** 中进行设置。
- en: In the `Plugins/ARFoundationRemoteInstaller`, select the **Installer** asset,
    and view the **Inspector** window as shown in the following screenshot:![Figure
    3.19 – The AR Foundation Remote Installer
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Plugins/ARFoundationRemoteInstaller` 中，选择 **Installer** 资产，并查看如下截图所示的 **Inspector**
    窗口：![图 3.19 – AR 基础库远程安装程序
- en: '](img/Figure_3.19-ARRemoteInstaller.jpg)'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.19-ARRemoteInstaller.jpg)'
- en: Figure 3.19 – The AR Foundation Remote Installer
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.19 – AR 基础库远程安装程序
- en: Click the **Install AR Companion App** button.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **安装 AR 配套应用程序** 按钮。
- en: Let it build and install the companion app on your device.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让它在您的设备上构建并安装配套应用程序。
- en: In the `Plugins/ARFoundationRemoteInstaller/Resources/` folder and select the
    **Settings** object.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Plugins/ARFoundationRemoteInstaller/Resources/` 文件夹中，选择 **Settings** 对象。
- en: Following the instructions on your phone screen and enter the given IP address
    in the **Settings** | **AR Companion App IP** field in the **Inspector** window.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照手机屏幕上的说明操作，并在 **设置** | **AR 配套应用程序 IP** 字段中输入提供的 IP 地址。
- en: You're now set up. When you want to use AR Foundation Remote, ensure the AR
    Companion app is running on your phone. Then, click **Play** to run your scene
    using the mobile device as a remote.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已设置好。当您想使用 AR Foundation Remote 时，确保 AR 配套应用程序在您的手机上正在运行。然后，点击 **播放** 以使用移动设备作为远程来运行您的场景。
- en: Using an editor remote tool lets you use the Unity Editor Play-mode with your
    mobile device. Camera and other sensing data is input into your **Game** window
    so you can test in your real-world environment without having to use **Build And
    Run**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编辑器远程工具可以让您使用移动设备上的 Unity 编辑器 Play 模式。摄像头和其他感应数据输入到您的 **游戏** 窗口中，这样您就可以在真实世界环境中进行测试，而无需使用
    **构建并运行**。
- en: What if, instead of playing your app on your mobile device, we inverted this
    approach by bringing your real-world environment into the Unity Editor? Unity
    is pioneering this innovative approach with Unity MARS.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是在移动设备上运行您的应用程序，而是将您的真实世界环境引入 Unity 编辑器，情况会怎样呢？Unity 正在通过 Unity MARS 探索这种创新的方法。
- en: Simulating with Unity MARS
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity MARS 进行模拟
- en: '**Unity MARS** (an acronym for *Mixed Augmented Reality Studio*) ([https://unity.com/products/unity-mars](https://unity.com/products/unity-mars))
    is a product solution from Unity Technologies that solves many of the issues with
    developing Augmented Reality applications discussed thus far in this chapter,
    and much more.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity MARS**（代表**混合增强现实工作室**）([https://unity.com/products/unity-mars](https://unity.com/products/unity-mars))是
    Unity Technologies 提供的解决方案，它解决了本章迄今为止讨论的许多开发增强现实应用程序的问题，以及更多。'
- en: What is MARS? With MARS you can author and test complex AR applications within
    the Unity Editor with runtime logic for a range of target physical world environments.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 MARS？使用 MARS，您可以在 Unity 编辑器内创建和测试复杂的 AR 应用程序，并为一系列目标物理世界环境提供运行时逻辑。
- en: 'Consider this one scenario: You are developing an AR application for museum
    visitors, where they point their mobile device at an exhibit or artwork and the
    app recognizes it and delivers additional information and infotainment, providing
    a much-enhanced learning experience. But you are at your desk, in your office,
    across town, or in a different city. How do you develop and test your app? Rather
    than making travel plans, you could use MARS to bring the target physical space
    into the Unity Editor and *develop-test-update-repeat* from the comfort of your
    own desk.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一个场景：您正在为博物馆参观者开发一个 AR 应用程序，他们可以将他们的移动设备指向展品或艺术品，应用程序识别它并提供额外的信息和娱乐，从而提供更丰富的学习体验。但您在办公桌前，在办公室，在城镇的另一边，或在不同的城市。您如何开发和测试您的应用程序？与其制定旅行计划，您可以使用
    MARS 将目标物理空间带入 Unity 编辑器，并在您自己的办公桌前**开发-测试-更新-重复**。
- en: With MARS you can capture and assemble real-world assets such as locations,
    objects, and props, then drag and drop them into Unity to test them. It supports
    tracking planes, images, faces, and many other kinds of semantically meaningful
    data, or *traits*. The MARS documentation can be found at [https://docs.unity3d.com/Packages/com.unity.mars@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.mars@1.0/manual/index.html).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MARS，您可以捕获和组装现实世界的资产，如位置、对象和道具，然后将它们拖放到 Unity 中进行测试。它支持跟踪平面、图像、面部以及许多其他具有语义意义的**特征**数据。MARS
    文档可以在[https://docs.unity3d.com/Packages/com.unity.mars@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.mars@1.0/manual/index.html)找到。
- en: 'The first step in this museum scenario may be to capture the museum''s physical
    environment sensor readings for use at your workstation. The MARS Companion app,
    described more in this section, can serve this purpose. Likewise, MARS includes
    a collection of sample environment templates you can use out of the box. The following
    image, for example, shows a **Simulation View** of a kitchen along with a **Device
    View** in the same space:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个博物馆场景中，第一步可能是捕获博物馆的物理环境传感器读数，以便在您的工作站上使用。本节中更详细描述的 MARS 伴侣应用程序可以用于此目的。同样，MARS
    包含一系列您可以直接使用的环境模板。以下图像，例如，显示了一个厨房的**模拟视图**以及同一空间中的**设备视图**：
- en: '![Figure 3.20 – MARS Simulation and Device views'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.20 – MARS 模拟和设备视图'
- en: '](img/Figure_3.20-MARSscreenshot.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.20-MARSscreenshot.jpg)'
- en: Figure 3.20 – MARS Simulation and Device views
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – MARS 模拟和设备视图
- en: 'With MARS you have environment simulations that can run either in Edit-mode
    or Play-mode. You can preview the execution of a scene in Edit-mode, where proxy
    objects of the real world are copied into the **Simulation** scene view, which
    is separate from the normal project **Scene** view. You can also start and stop
    a *continuous* **Simulation** view that is more analogous to the normal Play-mode
    in Unity. The data fed into the simulation can be synthetic, recorded, or live
    data. You can then test your project against a wide variety of indoor and outdoor
    spaces. For a more complete explanation of how MARS simulation works, I recommend
    this article: [https://blogs.unity3d.com/2020/08/14/a-look-at-how-simulation-works-in-unity-mars](https://blogs.unity3d.com/2020/08/14/a-look-at-how-simulation-works-in-unity-mars).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MARS，您有可以在编辑模式或播放模式下运行的环境模拟。您可以在编辑模式下预览场景的执行，其中真实世界的代理对象被复制到**模拟**场景视图中，该视图与正常的项目**场景**视图分开。您还可以启动和停止一个**连续**的**模拟**视图，这更类似于
    Unity 中的正常播放模式。输入模拟的数据可以是合成数据、记录数据或实时数据。然后您可以对各种室内和室外空间进行测试。关于 MARS 模拟如何工作的更完整解释，我推荐这篇文章：[https://blogs.unity3d.com/2020/08/14/a-look-at-how-simulation-works-in-unity-mars](https://blogs.unity3d.com/2020/08/14/a-look-at-how-simulation-works-in-unity-mars)。
- en: MARS provides additional high-level tools and intelligent components that address
    common challenges for AR developers. Physical environments are not always so predictable.
    The MARS procedural authoring framework simulates real-world objects, conditions,
    and actions including "fuzzy authoring" where you specify minimum and maximum
    measurements for physical features when the app is deciding where and when to
    let the user interact.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: MARS提供了额外的工具和智能组件，以解决AR开发者面临的常见挑战。物理环境并不总是那么可预测。MARS过程式创作框架模拟现实世界中的对象、条件和动作，包括“模糊创作”，在应用程序决定何时以及在哪里让用户交互时，您可以指定物理特征的最低和最高测量值。
- en: MARS is built on AR Foundation, so it works with all supported AR devices and
    platforms. Presently, there is a separate annual license fee to use Unity MARS
    after a trial period.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: MARS建立在AR Foundation之上，因此与所有支持的AR设备和平台兼容。目前，在试用期间之后，使用Unity MARS需要支付单独的年度许可费用。
- en: Using MARS you may still be faced with how to capture your target environment
    geometry and surface feature for use in simulations. That's where the MARS Companion
    app comes in.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MARS，您可能仍然面临如何捕获目标环境几何形状和表面特征以用于模拟的问题。这就是MARS Companion应用程序的用武之地。
- en: Capturing with the MARS Companion app
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MARS Companion应用程序进行捕获
- en: The MARS Companion app can be used to capture real-world data and bring it into
    the Unity Editor for use with Unity MARS.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: MARS Companion应用程序可用于捕获现实世界数据并将其带入Unity编辑器，以便与Unity MARS一起使用。
- en: Using the app, you can scan a room, take pictures, and record video, capturing
    and saving this data to the cloud. This data can then be made available to the
    Unity Editor using the MARS authoring studio.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该应用程序，您可以扫描房间、拍照和录制视频，将此数据捕获并保存到云端。然后，可以使用MARS创作室将这些数据提供给Unity编辑器。
- en: The app also has limited authoring features that let you create content and
    layout assets on your device. This could be useful, for example, troubleshooting
    edge cases where lighting or environment features are ambiguous or difficult to
    scan.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序还具有有限的创作功能，允许您在设备上创建内容和布局资产。例如，这可能有助于解决边缘情况，例如当照明或环境特征模糊或难以扫描时。
- en: At this time, the MARS Companion app is still in Beta ([https://forum.unity.com/threads/unity-mars-companion-app-open-beta-announcement.1037638/](https://forum.unity.com/threads/unity-mars-companion-app-open-beta-announcement.1037638/))
    and may eventually be decoupled from MARS for use as an editor remote tool (see
    the previous section in this chapter).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，MARS Companion应用程序仍处于Beta测试阶段([https://forum.unity.com/threads/unity-mars-companion-app-open-beta-announcement.1037638/](https://forum.unity.com/threads/unity-mars-companion-app-open-beta-announcement.1037638/))，并可能最终从MARS中分离出来，用作编辑器远程工具（参见本章前面的部分）。
- en: Unity MARS is a powerful new framework for augmented reality development. It
    represents Unity's long-term commitment to the AR industry, users, developers,
    and device manufacturers. Like most Unity packages and modules, it can also be
    extended with custom behaviors, data extensions, queries, and other add-on modules.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Unity MARS是用于增强现实开发的一个强大新框架。它代表了Unity对AR行业、用户、开发者和设备制造商的长期承诺。像大多数Unity包和模块一样，它也可以通过自定义行为、数据扩展、查询和其他附加模块进行扩展。
- en: I have not attempted to provide a tutorial for MARS in this chapter (it could
    be a whole separate book), and *we will not be using MARS in the projects in this
    book*. Nonetheless, you are more than welcome to improve your workflow using MARS
    with the projects in this book if you want.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中并未尝试提供MARS的教程（它可能是一本完全独立的书籍），并且*我们不会在本书的工程项目中使用MARS*。尽管如此，如果您愿意，完全可以使用MARS来改进本书中的项目工作流程。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By its nature, augmented reality mixes the physical and virtual worlds, and
    that presents unique challenges to AR developers. We develop on a desktop or laptop
    computer, but the target device for the application is an untethered mobile device.
    While running an app in Unity Play-mode, an AR scene still needs sensor inputs
    from the remote device.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 增强现实本质上混合了物理世界和虚拟世界，这对AR开发者提出了独特的挑战。我们在桌面或笔记本电脑上开发，但应用程序的目标设备是未连接的移动设备。在Unity
    Play模式下运行应用程序时，AR场景仍然需要从远程设备获取传感器输入。
- en: In this chapter, we covered a spectrum of tools and techniques that can help
    with developing and troubleshooting your augmented reality applications using
    Unity. We started with a basic, classic "print statement," using `Debug.Log()`
    where you can output log messages to the `ScreenLog.Log()` wrapper function to
    optionally let you view log messages on your device without being tethered to
    Unity at all.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一系列工具和技术，这些工具和技术可以帮助您使用Unity开发和调试增强现实应用程序。我们从基本的经典“打印语句”开始，使用`Debug.Log()`，您可以将日志消息输出到`ScreenLog.Log()`包装函数，这样您可以选择在您的设备上查看日志消息，而无需完全连接到Unity。
- en: For deeper understanding and to debug your applications, you can use a debugger
    like the one provided in Visual Studio. While debugging, you can set breakpoints,
    examine variable values, and step through the code. You can run the debugger both
    on Unity Play-mode and on applications built and running on your mobile device.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地理解并调试您的应用程序，您可以使用Visual Studio提供的调试器。在调试过程中，您可以设置断点、检查变量值并逐行执行代码。您可以在Unity的Play模式下以及构建并运行在您的移动设备上的应用程序上运行调试器。
- en: You could also use an editor remote tool—an app that runs on the mobile device
    and connects to the Unity Editor so you can use the Play-mode and receive input
    data from the attached device.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用编辑器远程工具——一个在移动设备上运行并连接到Unity编辑器的应用程序，这样您就可以使用Play模式并从连接的设备接收输入数据。
- en: Then we took a brief tour of Unity MARS. This AR development studio framework
    inverts the ordinary remote development paradigm. Rather than running your app
    on a remote device to capture environment sensor data, MARS lets you use environment
    sensor simulations directly in the Unity Editor. This provides the opportunity
    to greatly improve your development workflow and test your application for a wide
    range of physical environments without leaving your desk.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对Unity MARS进行了简要的浏览。这个AR开发工作室框架颠覆了常规的远程开发模式。而不是在远程设备上运行您的应用程序以捕获环境传感器数据，MARS允许您直接在Unity编辑器中使用环境传感器模拟。这为您提供了极大地改善您的开发工作流程和测试您的应用程序以适应广泛物理环境的机会，而无需离开您的办公桌。
- en: You are now ready to get started building AR applications. In the next chapter,
    we develop a framework for controlling user interaction in AR projects. This framework
    will be saved and used as a template for building and managing the user interfaces
    in each of the projects in this book.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以开始构建AR应用程序了。在下一章中，我们将开发一个用于控制AR项目中用户交互的框架。这个框架将被保存并用作构建和管理本书中每个项目中用户界面的模板。
