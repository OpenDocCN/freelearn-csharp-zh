<html><head></head><body>
<div><div><div></div>
</div>
<div><h1 id="_idParaDest-127"><a id="_idTextAnchor129"/>3. Delegates, Events, and Lambdas</h1>
</div>
<div><p class="callout-heading">Overview</p>
<p class="callout">In this chapter, you will learn how delegates are defined and invoked, and you will explore their wide usage across the .NET ecosystem. With this knowledge, you will move on to the inbuilt <code>Action</code> and <code>Func</code> delegates to discover how their usage reduces unnecessary boilerplate code. You will then see how multicast delegates can be harnessed to send messages to multiple parties, and how events can be incorporated into event-driven code. Along the way, you will discover some common pitfalls to avoid and best practices to follow that prevent a great application from turning into an unreliable one.</p>
<p class="callout">This chapter will demystify the lambda syntax style and show how it can be used effectively. By the end of the chapter, you will be able to use the lambda syntax comfortably to create code that is succinct, as well as easy to grasp and maintain.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Introduction</h1>
<p>In the previous chapter, you learned some of the key aspects of Object Oriented Programming (OOP). In this chapter, you will build on this by looking at the common patterns used specifically in C# that enable classes to interact.</p>
<p>Have you found yourself working with a code that has to listen to certain signals and act on them, but you cannot be sure until runtime what those actions should be? Maybe you have a block of code that you need to reuse or pass to other methods for them to call when they are ready. Or, you may want to filter a list of objects, but need to base how you would do that on a combination of user preferences. Much of this can be achieved using interfaces, but it is often more efficient to create chunks of code that you can then pass to other classes in a type-safe way. Such blocks are referred to as delegates and form the backbone of many .NET libraries, allowing methods or pieces of code to be passed as parameters.</p>
<p>The natural extension to a delegate is the event, which makes it possible to offer a form of optional behavior in software. For example, you may have a component that broadcasts live news and stock prices, but unless you provide a way to opt into these services, you may limit the usability of such a component.</p>
<p>User Interface (UI) apps often provide notifications of various user actions, for example, keypresses, swiping a screen, or clicking a mouse button; such notifications follow a standard pattern in C#, which will be discussed fully in this chapter. In such scenarios, the UI element detecting such actions is referred to as a publisher, whereas the code that acts upon those messages is called a subscriber. When brought together, they form an event-driven design referred to as the publisher-subscriber, or pub-sub, pattern. You will see how this can be used in all types of C#. Remember that its usage is not just the exclusive domain of UI applications.</p>
<p>Finally, you will learn about lambda statements and lambda expressions, collectively known as lambdas. These have an unusual syntax, which can initially take a while to become comfortable with. Rather than having lots of methods and functions scattered within a class, lambdas allow for smaller blocks of code that are often self-contained and located within close proximity to where they are used in the code, thereby offering an easier way to follow and maintain code. You will learn about lambdas in detail in the latter half of this chapter. First, you will learn about delegates.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor131"/>Delegates</h1>
<p>The .NET delegate is similar to function pointers found in other languages, such as C++; in other words, it is like a pointer to a method to be invoked at runtime. In essence, it is a placeholder for a block of code, which can be something as simple as a single statement or a full-blown multiline code block, complete with complex branches of execution, that you ask other code to execute at some point in time. The term delegate hints at some form of <strong class="bold">representative</strong>, which is precisely what this placeholder concept relates to.</p>
<p>Delegates allow for minimum coupling between objects, and much less code. There is no need to create classes that are derived from specific classes or interfaces. By using a delegate, you are defining what a compatible method should look like, whether it is in a class or struct, static, or instance-based. The arguments and return type define this calling compatibility.</p>
<p>Furthermore, delegates can be used in a callback fashion, which allows multiple methods to be wired up to a single publication source. They often require much less code and provide more features than found using an interface-based design.</p>
<p>The following example shows how effective delegates can be. Suppose you have a class that searches for users by surname. It would probably look like this:</p>
<pre><a id="_idTextAnchor132"/>public User FindBySurname(string name)
{
    foreach(var user in _users)
       if (user.Surname == name)
          return user;
    return null;
}</pre>
<p>You then need to extend this to include a search of the user's login name:</p>
<pre><a id="_idTextAnchor133"/>public User FindByLoginName(string name)
{
    foreach(var user in _users)
       if (user.LoginName == name)
          return user;
    return null;
}</pre>
<p>Once again, you decide to add yet another search, this time by location:</p>
<pre><a id="_idTextAnchor134"/>public User FindByLocation(string name)
{
    foreach(var user in _users)
       if (user.Location == name)
          return user;
    return null;
}</pre>
<p>You start the searches with code like this:</p>
<pre><a id="_idTextAnchor135"/>public void DoSearch()
{
  var user1 = FindBySurname("Wright");
  var user2 = FindByLoginName("JamesR");
  var user3 = FindByLocation("Scotland"); 
}</pre>
<p>Can you see the pattern that is occurring every time? You are repeating the same code that iterates through the list of users, applying a Boolean condition (also known as a predicate) to find the first matching user.</p>
<p>The only thing that is different is that the predicate decides whether a match has been found. This is one of the common cases where delegates are used at a basic level. The <code>predicate</code> can be replaced with a delegate, acting as a placeholder, which is evaluated when required.</p>
<p>Converting this code to a delegate style, you define a delegate named <code>FindUser</code> (this step can be skipped as .NET contains a delegate definition that you can reuse; you will come to this later).</p>
<p>All you need is a single helper method, <code>Find</code>, which is passed a <code>FindUser</code> delegate instance. Find knows how to loop through the users, invoking the delegate passing in the user, which returns true or false for a match:</p>
<pre>private delegate bool FindUser(User user);
private User Find(FindUser predicate)
{
  foreach (var user in _users)
    if (predicate(user))
      return user;
  return null;
}
public void DoSearch()
{
  var user4 = Find(user =&gt; user.Surname == "Wright");
  var user5 = Find(user =&gt; user.LoginName == "JamesR");
  var user6 = Find(user =&gt; user.Location == "Scotland");
}</pre>
<p>As you can see, the code is kept together and is much more concise now. There is no need to cut and paste code that loops through the users, as that is all done in one place. For each type of search, you simply define a delegate once and pass it to <code>Find</code>. To add a new type of search, all you need to do is define it in a single statement line, rather than copying at least eight lines of code that repeat the looping function.</p>
<p>The lambda syntax is a fundamental style used to define method bodies, but its strange syntax can prove to be an obstacle at first. At first glance, lambda expressions can look odd with their <code>=&gt;</code> style, but they do offer a cleaner way to specify a target method. The act of defining a lambda is similar to defining a method; you essentially omit the method name and use <code>=&gt;</code> to prefix a block of code.</p>
<p>You will now look at another example, using interfaces this time. Consider that you are working on a graphics engine and need to calculate the position of an image onscreen each time the user rotates or zooms in. Note that this example skips any complex math calculations.</p>
<p>Consider that you need to transform a <code>Point</code> class using the <code>ITransform</code> interface with a single method named <code>Move</code>, as shown in the following code snippet:</p>
<pre>public class Point
{
  public double X { get; set; } 
  public double Y { get; set; }
}
public interface ITransform
{
  Point Move(double height, double width);
}</pre>
<p>When the user rotates an object, you need to use <code>RotateTransform</code>, and for a zoom operation, you will use <code>ZoomTransform</code>, as follows. Both are based on the <code>ITransform</code> interface:</p>
<pre>public class RotateTransform : ITransform
{
    public Point Move(double height, double width)
    {
        // do stuff
        return new Point();
    }
}
public class ZoomTransform : ITransform
{
    public Point Move(double height, double width)
    {
        // do stuff
        return new Point();
    }
}</pre>
<p>So, given these two classes, a point can be transformed by creating a new <code>Transform</code> instance, which is passed to a method named <code>Calculate</code>, as shown in the following code. <code>Calculate</code> calls the corresponding <code>Move</code> method, and does some extra unspecified work on point, before returning point to the caller:</p>
<pre>public class Transformer
{
    public void Transform()
    {
        var rotatePoint = Calculate(new RotateTransform(), 100, 20);
        var zoomPoint = Calculate(new ZoomTransform(), 5, 5);
    }
    private Point Calculate(ITransform transformer, double height, double width)
    {
        var point = transformer.Move(height, width);
        //do stuff to point
        return point;
    }
}</pre>
<p>This is a standard class and interface-based design, but you can see that you have made a lot of effort to create new classes with just a single numeric value from a <code>Move</code> method. It is a worthwhile idea to have the calculations broken down into an easy-to-follow implementation. After all, it could have led to a future maintenance problem if implemented in a single method with multiple if-then branches.</p>
<p>By re-implementing a delegate-based design, you still have maintainable code, but much less of it to look after. You can have a <code>TransformPoint</code> delegate and a new <code>Calculate</code> function that can be passed a <code>TransformPoint</code> delegate.</p>
<p>You can invoke a delegate by appending brackets around its name and passing in any arguments. This is similar to how you would call a standard class-level function or method. You will cover this invocation in more detail later; for now, consider the following snippet:</p>
<pre>    private delegate Point TransformPoint(double height, double width);
    private Point Calculate(TransformPoint transformer, double height, double width)
    {
        var point = transformer(height, width);
        //do stuff to point
        return point;
    }</pre>
<p>You still need the actual target <code>Rotate</code> and <code>Zoom</code> methods, but you do not have the overhead of creating unnecessary classes to do this. You can add the following code:</p>
<pre>    private Point Rotate(double height, double width)
    {
        return new Point();
    }
    private Point Zoom(double height, double width)
    {
        return new Point();
    }</pre>
<p>Now, calling the method delegates is as simple as the following:</p>
<pre>    public void Transform()
    {
         var rotatePoint1 = Calculate(Rotate, 100, 20);
         var zoomPoint1 = Calculate(Zoom, 5, 5);
    }</pre>
<p>Notice how using delegates in this way helps eliminate a lot of unnecessary code.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/AcwZA">https://packt.link/AcwZA</a>.</p>
<p>In addition to invoking a single placeholder method, a delegate also contains extra plumbing that allows it to be used in a <strong class="bold">multicast</strong> manner, that is, a way to chain multiple target methods together, each being invoked one after the other. This is often referred to as an invocation list or delegate chain and is initiated by code that acts as a publication source.</p>
<p>A simple example of how this multicast concept applies can be seen in UIs. Imagine you have an application that shows the map of a country. As the user moves their mouse over the map, you may want to perform various actions, such as the following:</p>
<ul>
<li>Changing the mouse pointer to a different shape while over a building.</li>
<li>Showing a tooltip that calculates the real-world longitude and latitude coordinates.</li>
<li>Showing a message in a status bar that calculates the population of the area where the mouse is hovering.</li>
</ul>
<p>To achieve this, you would need some way to detect when the user moves the mouse over the screen. This is often referred to as the publisher. In this example, its sole purpose is to detect mouse movements and publish them to anyone who is listening.</p>
<p>To perform the three required UI actions, you would create a class that has a list of objects to notify when the mouse position changes, allowing each object to perform whatever activity it needs, in isolation from the others. Each of these objects is referred to as a subscriber.</p>
<p>When your publisher detects that the mouse has moved, you follow this pseudo code:</p>
<pre>MouseEventArgs args = new MouseEventArgs(100,200)
foreach(subscription in subscriptionList)
{
   subscription.OnMouseMoved(args)
} </pre>
<p>This assumes that <code>subscriptionList</code> is a list of objects, perhaps based on an interface with the <code>OnMouseMoved</code> method. It is up to you to add code that enables interested parties to subscribe to and unsubscribe from the <code>OnMouseMoved</code> notifications. It would be an unfortunate design if code that has previously subscribed has no way to unsubscribe and gets called repeatedly when there is no longer any need for it to be called.</p>
<p>In the preceding code, there is a fair amount of coupling between the publisher and subscribers, and you are back to using interfaces for a type-safe implementation. What if you then needed to listen for keypresses, both key down and key up? It would soon get quite frustrating having to repeatedly copy such similar code.</p>
<p>Fortunately, the delegate type contains all this as inbuilt behavior. You can use single or multiple target methods interchangeably; all you need to do is invoke a delegate and the delegate will handle the rest for you.</p>
<p>You will take an in-depth look at multicast delegates shortly, but first, you will explore the single-target method scenario.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor136"/>Defining a Custom Delegate</h2>
<p>Delegates are defined in a way that is similar to that of a standard method. The compiler does not care about the code in the body of a target method, only that it can be invoked safely at some point in time.</p>
<p>The <code>delegate</code> keyword is used to define a delegate, using the following format:</p>
<pre>public delegate void MessageReceivedHandler(string message, int size);</pre>
<p>The following list describes each component of this syntax:</p>
<ul>
<li>Scope: An access modifier, such as <code>public</code>, <code>private</code>, or <code>protected</code>, to define the scope of the delegate. If you do not include a modifier, the compiler will default to marking it as private, but it is always better to be explicit in showing the intent of your code.</li>
<li>The <code>delegate</code> keyword.</li>
<li>Return type: If there is no return type, <code>void</code> is used.</li>
<li>Delegate name: This can be anything that you like, but the name must be unique within the namespace. Many naming conventions (including Microsoft's) suggest adding <code>Handler</code> or <code>EventHandler</code> to your delegate's name.</li>
<li>Arguments, if required.<p class="callout-heading">Note</p><p class="callout">Delegates can be nested within a class or namespace; they can also be defined within the global namespace, although this practice is discouraged. When defining classes in C#, it is common practice to define them within a parent namespace, typically based on a hierarchical convention that starts with the company name, followed by the product name, and finally the feature. This helps to provide a more unique identity to a type.</p><p class="callout">By defining a delegate without a namespace, there is a high chance that it will clash with another delegate with the same name if it is also defined in a library without the protection of a namespace. This can cause the compiler to become confused as to which delegate you are referring to.</p></li>
</ul>
<p>In earlier versions of .NET, it was common practice to define custom delegates. Such code has since been replaced with various inbuilt .NET delegates, which you will look at shortly. For now, you will briefly cover the basics of defining a custom delegate. It is worthwhile know about this if you maintain any legacy C# code.</p>
<p>In the next exercise, you will create a custom delegate, one that is passed a <code>DateTime</code> parameter and returns a Boolean to indicate validity.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor137"/>Exercise 3.01: Defining and Invoking Custom Delegates</h2>
<p>Say you have an application that allows users to order products. While filling in the order details, the customer can specify an order date and a delivery date, both of which must be validated before accepting the order. You need a flexible way to validate these dates. For some customers, you may allow weekend delivery dates, while for others, it must be at least seven days away. You may also allow an order to be back-dated for certain customers.</p>
<p>You know that delegates offer a way to vary an implementation at runtime, so that is the best way to proceed. You do not want multiple interfaces, or worse, a complex jumble of <code>if-then</code> statements, to achieve this.</p>
<p>Depending on the customer's profile, you can create a class named <code>Order</code>, which can be passed different date validation rules. These rules can be validated by a <code>Validate</code> method:</p>
<p>Perform the following steps to do so:</p>
<ol>
<li>Create a new folder called <code>Chapter03</code>.</li>
<li>Change to the <code>Chapter03</code> folder and create a new console app, called <code>Exercise01</code>, using the CLI <code>dotnet</code> command, as follows:<pre>source\Chapter03&gt;dotnet new console -o Exercise01</pre></li>
</ol>
<p>You will see the following output:</p>
<pre>The template "Console Application" was created successfully.
Processing post-creation actions...
Running 'dotnet restore' on Exercise01\Exercise01.csproj...
  Determining projects to restore...
  Restored source\Chapter03\Exercise01\Exercise01.csproj (in 191 ms).
Restore succeeded.</pre>
<ol>
<li value="3">Open <code>Chapter03\Exercise01.csproj</code> and replace the contents with these settings:<pre>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre></li>
<li>Open <code>Exercise01\Program.cs</code> and clear the contents.</li>
<li>The preference for using namespaces to prevent a clash with objects from other libraries was mentioned earlier, so to keep things isolated, use <code>Chapter03.Exercise01</code> as the namespace.</li>
</ol>
<p>To implement your date validation rules, you will define a delegate that takes a single <code>DateTime</code> argument and returns a Boolean value. You will name it <code>DateValidationHandler</code>:</p>
<pre>using System;
namespace Chapter03.Exercise01 
{
    public delegate bool DateValidationHandler(DateTime dateTime);
}</pre>
<ol>
<li value="6">Next, you will create a class named <code>Order</code>, which contains details of the order and can be passed to two date validation delegates:<pre>   public class Order
    {
        private readonly DateValidationHandler _orderDateValidator;
        private readonly DateValidationHandler _deliveryDateValidator;</pre></li>
</ol>
<p>Notice how you have declared two read-only, class-level instances of <code>DateValidationHandler</code>, one to validate the order date and a second to validate the delivery date. This design assumes that the date validation rules are not going to be altered for this <code>Order</code> instance.</p>
<ol>
<li value="7">Now for the constructor, you pass the two delegates:<pre>       public Order(DateValidationHandler orderDateValidator,
            DateValidationHandler deliveryDateValidator)
        {
            _orderDateValidator = orderDateValidator;
            _deliveryDateValidator = deliveryDateValidator;
        }  </pre></li>
</ol>
<p>In this design, a different class is typically responsible for deciding which delegates to use, based on the selected customer's profile.</p>
<ol>
<li value="8">You need to add the two date properties that are to be validated. These dates may be set using a UI that listens to keypresses and applies user edits directly to this class:<pre>        public DateTime OrderDate { get; set; }
        public DateTime DeliveryDate { get; set; }</pre></li>
<li>Now add an <code>IsValid</code> method that passes <code>OrderDate</code> to the <code>orderDateValidator</code> delegate and <code>DeliveryDate</code> to the <code>deliveryDateValidator</code> delegate:<pre>        public bool IsValid() =&gt; 
            _orderDateValidator(OrderDate) &amp;&amp;
            _deliveryDateValidator(DeliveryDate);
    }</pre></li>
</ol>
<p>If both are valid, then this call will return <code>true</code>. The key here is that <code>Order</code> doesn't need to know about the precise implementation of an individual customer's date validation rules, so you can easily reuse <code>Order</code> elsewhere in a program. To invoke a delegate, you simply wrap any arguments in brackets, in this case passing the correct date property to each delegate instance:</p>
<ol>
<li value="10">To create a console app to test this, add a <code>static</code> class called <code>Program</code>:<pre>    public static class Program
    {</pre></li>
<li>You want to create two functions that validate whether the date passed to them is valid. These functions will form the basis of your delegate target methods:<pre>        private static bool IsWeekendDate(DateTime date)
        {
            Console.WriteLine("Called IsWeekendDate");
            return date.DayOfWeek == DayOfWeek.Saturday ||
                   date.DayOfWeek == DayOfWeek.Sunday;
        }
        private static bool IsPastDate(DateTime date)
        {
            Console.WriteLine("Called IsPastDate");
            return date &lt; DateTime.Today;
        }</pre></li>
</ol>
<p>Notice how both have the exact signature that the <code>DateValidationHandler</code> delegate is expecting. Neither is aware of the nature of the date that they are validating, as that is not their concern. They are both marked <code>static</code> as they do not interact with any variables or properties anywhere in this class.</p>
<ol>
<li value="12">Now for the <code>Main</code> entry point. Here, you create two <code>DateValidationHandler</code> delegate instances, passing <code>IsPastDate</code> to one and <code>IsWeekendDate</code> to the second. These are the target methods that will get called when each of the delegates is invoked:<pre>        public static void Main()
        {
           var orderValidator = new DateValidationHandler(IsPastDate);
           var deliverValidator = new DateValidationHandler(IsWeekendDate);</pre></li>
<li>Now you can create an <code>Order</code> instance, passing in the delegates and setting the order and delivery dates:<pre>          var order = new Order(orderValidator, deliverValidator)
            {
                OrderDate = DateTime.Today.AddDays(-10), 
                DeliveryDate = new DateTime(2020, 12, 31)
            };</pre></li>
</ol>
<p>There are various ways to create delegates. Here, you have assigned them to variables first to make the code clearer (you will cover different styles later).</p>
<ol>
<li value="14">Now it's just a case of displaying the dates in the console and calling <code>IsValid</code>, which, in turn, will invoke each of your delegate methods once. Notice that a custom date format is used to make the dates more readable:<pre>          Console.WriteLine($"Ordered: {order.OrderDate:dd-MMM-yy}");
          Console.WriteLine($"Delivered: {order.DeliveryDate:dd-MMM-yy }");
          Console.WriteLine($"IsValid: {order.IsValid()}");
        }
    }
}</pre></li>
<li>Running the console app produces output like this: <pre>Ordered: 07-May-22
Delivered: 31-Dec-20
Called IsPastDate
Called IsWeekendDate
IsValid: False</pre></li>
</ol>
<p>This order is <strong class="bold">not</strong> valid as the delivery date is a Thursday, not a weekend as you require:</p>
<p>You have learned how to define a custom delegate and have created two instances that make use of small helper functions to validate dates. This gives you an idea of how flexible delegates can be.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/cmL0s">https://packt.link/cmL0s</a>.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor138"/>The Inbuilt Action and Func Delegates</h2>
<p>When you define a delegate, you are describing its signature, that is, the return type and a list of input parameters. With that said, consider these two delegates:</p>
<pre>public delegate string DoStuff(string name, int age);
public delegate string DoMoreStuff(string name, int age);</pre>
<p>They both have the same signature but vary by name alone, which is why you can declare an instance of each and have them <strong class="bold">both</strong> point at the <strong class="bold">same</strong> target method when invoked:</p>
<pre>public static void Main()
{
    DoStuff stuff = new DoStuff(MyMethod);
    DoMoreStuff moreStuff = new DoMoreStuff(MyMethod);
    Console.WriteLine($"Stuff: {stuff("Louis", 2)}");
    Console.WriteLine($"MoreStuff: {moreStuff("Louis", 2)}");
}
private static string MyMethod(string name, int age)
{
    return $"{name}@{age}";
}</pre>
<p>Running the console app produces the same results in both calls:</p>
<pre>Stuff: Louis@2
MoreStuff: Louis@2</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/r6B8n">https://packt.link/r6B8n</a>.</p>
<p>It would be great if you could dispense with defining both <code>DoStuff</code> and <code>DoMoreStuff</code> delegates and use a more generalized delegate with precisely the same signature. After all, it does not matter in the preceding snippet if you create a <code>DoStuff</code> or <code>DoMoreStuff</code> delegate, since both make a call to the same target method.</p>
<p>.NET does, in fact, provide various inbuilt delegates that you can make use of directly, saving you the effort of defining such delegates yourself. These are the <code>Action</code> and <code>Func</code> delegates.</p>
<p>There are many possible combinations of <code>Action</code> and <code>Func</code> delegates, each allowing an increasing number of parameters. You can specify anywhere from zero to 16 different parameter types. With so many combinations available, it is extremely unlikely that you will ever need to define your own delegate type.</p>
<p>It is worth noting that <code>Action</code> and <code>Func</code> delegates were added in a later version of .NET and, as such, the use of custom delegates tends to be found in older legacy code. There is no need to create new delegates yourself.</p>
<p>In the following snippet, <code>MyMethod</code> is invoked using the three-argument <code>Func</code> variation; you will cover the odd-looking <code>&lt;string, int, string&gt;</code> syntax shortly:</p>
<pre>Func&lt;string, int, string&gt; funcStuff = MyMethod;
Console.WriteLine($"FuncStuff: {funcStuff("Louis", 2)}");</pre>
<p>This produces the same return value as the two earlier invocations:</p>
<pre>FuncStuff: Louis@2</pre>
<p>Before you continue exploring <code>Action</code> and <code>Func</code> delegates, it is useful to explore the <code>Action&lt;string, int, string&gt;</code> syntax a bit further. This syntax allows type parameters to be used to define classes and methods. These are known as generics and act as placeholders for a particular type. In <em class="italic">Chapter 4</em>, <em class="italic">Data Structures and LINQ</em>, you will cover generics in much greater detail, but it is worth summarizing their usage here with the <code>Action</code> and <code>Func</code> delegates.</p>
<p>The non-generic version of the <code>Action</code> delegate is predefined in .NET as follows:</p>
<pre>public delegate void Action()</pre>
<p>As you know from your earlier look at delegates, this is a delegate that does not take any arguments and does not have a return type; it is the simplest type of delegate available.</p>
<p>Contrast that with one of the generic <code>Action</code> delegates predefined in .NET:</p>
<pre>public delegate void Action&lt;T&gt;(T obj)</pre>
<p>You can see this includes a <code>&lt;T&gt;</code> and <code>T</code> parameter section, which means it accepts a <code>Action</code> that is constrained to a string, which takes a single string argument and returns no value, as follows:</p>
<pre>Action&lt;string&gt; actionA;</pre>
<p>How about an <code>int</code> constrained version? This also has no return type and takes a single <code>int</code> argument:</p>
<pre>Action&lt;int&gt; actionB;</pre>
<p>Can you see the pattern here? In essence, the type that you specify can be used to declare a type at compile time. What if you wanted two arguments, or three, or four…or 16? Simple. There are <code>Action</code> and <code>Func</code> generic types that can take up to <strong class="bold">16</strong> different argument types. You are very unlikely to be writing code that needs more than 16 parameters.</p>
<p>This two-argument <code>Action</code> takes <code>int</code> and <code>string</code> as parameters:</p>
<pre>Action&lt;int, string&gt; actionC;</pre>
<p>You can spin that around. Here is another two-argument <code>Action</code>, but this takes a <code>string</code> parameter and then an <code>int</code> parameter:</p>
<pre>Action&lt;string, int&gt; actionD;</pre>
<p>These cover most argument combinations, so you can see that it is very rare to create your own delegate types.</p>
<p>The same rules apply to delegates that return a value; this is where the <code>Func</code> types are used. The generic <code>Func</code> type starts with a single value type parameter:</p>
<pre>public delegate T Func&lt;T&gt;()</pre>
<p>In the following example, <code>funcE</code> is a delegate that returns a Boolean value and takes no arguments:</p>
<pre>Func&lt;bool&gt; funcE;</pre>
<p>Can you guess which is the return type from this rather long <code>Func</code> declaration?</p>
<pre>Func&lt;bool, int, int, DateTime, string&gt; funcF;</pre>
<p>This gives a delegate that returns a <code>string</code> . In other words, the last argument type in a <code>Func</code> defines the return type. Notice that <code>funcF</code> takes four arguments: <code>bool</code>, <code>int</code>, <code>int</code>, and <code>DateTime</code>.</p>
<p>In summary, generics are a great way to define types. They save a lot of duplicate code by allowing type parameters to act as placeholders.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor139"/>Assigning Delegates</h2>
<p>You covered creating custom delegates and briefly how to assign and invoke a delegate in <em class="italic">Exercise 3.01</em>. You then looked at using the preferred <code>Action</code> and <code>Func</code> equivalents, but what other options do you have for assigning the method (or methods) that form a delegate? Are there other ways to invoke a delegate?</p>
<p>Delegates can be assigned to a variable in much the same way that you might assign a class instance. You can also pass new instances or static instances around without having to use variables to do so. Once assigned, you can invoke the delegate or pass the reference to other classes so they can invoke it, and this is often done within the Framework API.</p>
<p>You will now look at a <code>Func</code> delegate, which takes a single <code>DateTime</code> argument and returns a <code>bool</code> value to indicate validity. You will use a <code>static</code> class containing two helper methods, which form the actual target:</p>
<pre>public static class DateValidators
{
    public static bool IsWeekend(DateTime dateTime)
        =&gt; dateTime.DayOfWeek == DayOfWeek.Saturday ||
           dateTime.DayOfWeek == DayOfWeek.Sunday;
    public static bool IsFuture(DateTime dateTime) 
      =&gt; dateTime.Date &gt; DateTime.Today;
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/mwmxh">https://packt.link/mwmxh</a>.</p>
<p>Note that the <code>DateValidators</code> class is marked as <code>static</code>. You may have heard the phrase <strong class="bold">statics are inefficient</strong>. In other words, creating an application with many static classes is a weak practice. Static classes are instantiated the first time they are accessed by running code and remain in memory until the application is closed. This makes it difficult to control their lifetime. Defining small utility classes as static is less of an issue, provided they do indeed remain stateless. Stateless means they do not set any local variables. Static classes that set local states are very difficult to unit test; you can never be sure that the variable set is from one test or another test.</p>
<p>In the preceding snippet, <code>IsFuture</code> returns <code>true</code> if the <code>Date</code> property of the <code>DateTime</code> argument is later than the current date. You are using the static <code>DateTime.Today</code> property to retrieve the current system date. <code>IsWeekend</code> is defined using an expression-bodied syntax and will return <code>true</code> if the <code>DateTime</code> argument's day of the week falls on a Saturday or Sunday.</p>
<p>You can assign delegates the same way that you would assign regular variables (remember you do <code>futureValidator</code> and <code>weekendValidator</code>. Each constructor is passed the actual target method, the <code>IsFuture</code> or <code>IsWeekend</code> instance, respectively:</p>
<pre><a id="_idTextAnchor140"/>var <a id="_idTextAnchor141"/>futureValidator = new Func&lt;DateTime, bool&gt;(DateValidators.IsFuture);
var weekendValidator = new Func&lt;DateTime, bool&gt;(DateValidators.IsWeekend);</pre>
<p>Note that it is not valid to use the <code>var</code> keyword to assign a delegate without wrapping in the <code>Func</code> prefix:</p>
<pre>var futureValidator = DateValidation.IsFuture;</pre>
<p>This results in the following compiler error:</p>
<pre>Cannot assign method group to an implicitly - typed variable</pre>
<p>Taking this knowledge of delegates, proceed to how you can invoke a delegate.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor142"/>Invoking a Delegate</h2>
<p>There are several ways to invoke a delegate. For example, consider the following definition:</p>
<pre>var futureValidator = new Func&lt;DateTime, bool&gt;(DateValidators.IsFuture);</pre>
<p>To invoke <code>futureValidator</code>, you must pass in a <code>DateTime</code> value, and it will return a <code>bool</code> value using any of these styles:</p>
<ul>
<li>Invoke with the null-coalescing operator:<pre>var isFuture1 = futureValidator?.Invoke(new DateTime(2000, 12, 31));</pre></li>
</ul>
<p>This is the preferred and safest approach; you should always check for a null before calling <code>Invoke</code>. If there is a chance that a delegate does not point to an object in memory, then you must perform a null reference check before accessing methods and properties. A failure to do so will result in <code>NullReferenceException</code> being thrown. This is the runtime's way of warning you that the object is not pointing at anything.</p>
<p>By using the null-coalescing operator, the compiler will add the null check for you. In the code, you explicitly declared <code>futureValidator</code>, so here it cannot be null. But what if you had been passed <code>futureValidator</code> from another method? How can you be sure that the caller had correctly assigned a reference?</p>
<p>Delegates have additional rules that make it possible for them to throw <code>NullReferenceException</code> when invoked. In the preceding example, <code>futureValidator</code> has a single target, but as you will see later, the <code>NullReferenceException</code>.</p>
<ul>
<li>Direct Invoke</li>
</ul>
<p>This is the same as the previous method, but without the safety of the null check. This is not recommended for the same reason; that is, the delegate can throw a <code>NullReferenceException</code>:</p>
<pre>var isFuture1 = futureValidator.Invoke(new DateTime(2000, 12, 31));</pre>
<ul>
<li>Without the <code>Invoke</code> prefix</li>
</ul>
<p>This looks more succinct as you simply call the delegate without the <code>Invoke</code> prefix. Again, this is not recommended due to a possible null reference:</p>
<pre>var isFuture2 = futureValidator(new DateTime(2050, 1, 20));</pre>
<p>Try assigning and safely invoking a delegate through an exercise by bringing them together.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor143"/>Exercise 3.02: Assigning and Invoking Delegates</h2>
<p>In this exercise, you are going to write a console app showing how a <code>Func</code> delegate can be used to extract numeric values. You will create a <code>Car</code> class that has <code>Distance</code> and <code>JourneyTime</code> properties. You will prompt the user to enter the distance traveled yesterday and today, passing this information to a <code>Comparison</code> class that is told how to extract values and calculate their differences.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <code>Chapter03</code> folder and create a new console app, called <code>Exercise02</code>, using the CLI <code>dotnet</code> command:<pre>source\Chapter03&gt;dotnet new console -o Exercise02</pre></li>
<li>Open <code>Chapter03\Exercise02.csproj</code> and replace the entire file with these settings:<pre>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre></li>
<li>Open <code>Exercise02\Program.cs</code> and clear the contents.</li>
<li>Start by adding a record called <code>Car</code>. Include the <code>System.Globalization</code> namespace for string parsing. Use the <code>Chapter03.Exercise02</code> namespace to keep code separate from the other exercises.</li>
<li>Add two properties, <code>Distance</code> and <code>JourneyTime</code>. They will have <code>init</code>-only properties, so you will use the <code>init</code> keyword:<pre>using System;
using System.Globalization;
namespace Chapter03.Exercise02
{
    public record Car
    {
        public double Distance { get; init; }
        public double JourneyTime { get; init; }
    }</pre></li>
<li>Next, create a class named <code>Comparison</code> that is passed a <code>Func</code> delegate to work with. The <code>Comparison</code> class will use the delegate to extract either the <code>Distance</code> or <code>JourneyTime</code> properties and calculate the difference for two <code>Car</code> instances. By using the flexibility of delegates, <code>Comparison</code> will not know whether it is extracting <code>Distance</code> or <code>JourneyTime</code>, just that it is using a double to calculate the differences. This shows that you can reuse this class should you need to calculate other <code>Car</code> properties in the future:<pre>    public class Comparison
    {
        private readonly Func&lt;Car, double&gt; _valueSelector;
        public Comparison(Func&lt;Car, double&gt; valueSelector)
        {
            _valueSelector = valueSelector;
        } </pre></li>
<li>Add three properties that form the results of the calculation, as follows:<pre>        public double Yesterday { get; private set; }
        public double Today { get; private set; }
        public double Difference { get; private set; }</pre></li>
<li>Now for the calculation, pass two <code>Car</code> instances, one for the car journey yesterday, <code>yesterdayCar</code>, and one for today, <code>todayCar</code>:<pre>        public void Compare(Car yesterdayCar, Car todayCar)
        {</pre></li>
<li>To calculate a value for <code>Yesterday</code>, invoke the <code>valueSelector</code> <code>Func</code> delegate, passing in the <code>yesterdayCar</code> instance. Again, remember that the <code>Comparison</code> class is unaware whether it is extracting <code>Distance</code> or <code>JourneyTime</code>; it just needs to know that when the <code>delegate</code> is invoked with a <code>Car</code> argument, it will get a double number back:<pre>            Yesterday = _valueSelector(yesterdayCar);</pre></li>
<li>Do the same to extract the value for <code>Today</code> by using the same <code>Func</code> delegate, but passing in the <code>todayCar</code> instance instead:<pre>            Today = _valueSelector(todayCar);</pre></li>
<li>Now it is just a case of calculating the difference between the two extracted numbers; you don't need to use the <code>Func</code> delegate to do that:<pre>            Difference = Yesterday - Today;
        }
     }</pre></li>
<li>So, you have a class that knows how to invoke a <code>Func</code> delegate to extract a certain <code>Car</code> property when it is told how to. Now, you need a class to wrap up the <code>Comparison</code> instances. For this, add a class called <code>JourneyComparer</code>:<pre>    public class JourneyComparer
    {
        public JourneyComparer()
        {</pre></li>
<li>For the car journey, you need to calculate the difference between the <code>Yesterday</code> and <code>Today</code> <code>Distance</code> properties. To do so, create a <code>Comparison</code> class that is told how to extract a value from a <code>Car</code> instance. You may as well use the same name for this <code>Comparison</code> class as you will extract a car's <code>Distance</code>. Remember that the <code>Comparison</code> constructor needs a <code>Func</code> delegate that is passed a <code>Car</code> instance and returns a double value. You will add <code>GetCarDistance()</code> shortly; this will eventually be invoked by passing <code>Car</code> instances for yesterday's and today's journeys:<pre>          Distance = new Comparison(GetCarDistance);</pre></li>
<li>Repeat the process as described in the preceding steps for a <code>JourneyTime</code> <code>Comparison</code>; this one should be told to use <code>GetCarJourneyTime()</code> as follows:<pre>          JourneyTime = new Comparison(GetCarJourneyTime);</pre></li>
<li>Finally, add another <code>Comparison</code> property called <code>AverageSpeed</code> as follows. You will see shortly that <code>GetCarAverageSpeed()</code> is yet another function:<pre>           AverageSpeed = new Comparison(GetCarAverageSpeed);</pre></li>
<li>Now for the <code>GetCarDistance</code> and <code>GetCarJourneyTime</code> local functions, they are passed a <code>Car</code> instance and return either <code>Distance</code> or <code>JourneyTime</code> accordingly:<pre>           static double GetCarDistance(Car car) =&gt; car.Distance; 
           static double GetCarJourneyTime(Car car) =&gt; car.JourneyTime;</pre></li>
<li><code>GetCarAverageSpeed</code>, as the name suggests, returns the average speed. Here, you have shown that the <code>Func</code> delegate just needs a compatible function; it doesn't matter what it returns as long as it is <code>double</code>. The <code>Comparison</code> class does not need to know that it is returning a calculated value such as this when it invokes the <code>Func</code> delegate:<pre>          static double GetCarAverageSpeed(Car car)             =&gt; car.Distance / car.JourneyTime;
       }</pre></li>
<li>The three <code>Comparison</code> properties should be defined like this:<pre>        public Comparison Distance { get; }
        public Comparison JourneyTime { get; }
        public Comparison AverageSpeed { get; }</pre></li>
<li>Now for the main <code>Compare</code> method. This will be passed two <code>Car</code> instances, one for <code>yesterday</code> and one for <code>today</code>, and it simply calls <code>Compare</code> on the three <code>Comparison</code> items passing in the two <code>Car</code> instances:<pre>        public void Compare(Car yesterday, Car today)
        {
            Distance.Compare(yesterday, today);
            JourneyTime.Compare(yesterday, today);
            AverageSpeed.Compare(yesterday, today);
        }
    }</pre></li>
<li>You need a console app to enter the miles traveled per day, so add a class called <code>Program</code> with a static <code>Main</code> entry point:<pre>    public class Program
    {
        public static void Main()
        {</pre></li>
<li>You can randomly assign journey times to save some input, so add a new <code>Random</code> instance and the start of a <code>do-while</code> loop, as follows:<pre>            var random = new Random();
            string input;
            do
            {</pre></li>
<li>Read for yesterday's distance, as follows:<pre>                Console.Write("Yesterday's distance: ");
                input = Console.ReadLine();
                double.TryParse(input, NumberStyles.Any,                    CultureInfo.CurrentCulture, out var distanceYesterday);</pre></li>
<li>You can use the distance to create yesterday's <code>Car</code> with a random <code>JourneyTime</code>, as follows:<pre>                var carYesterday = new Car
                {
                    Distance = distanceYesterday,
                    JourneyTime = random.NextDouble() * 10D
                };</pre></li>
<li>Do the same for today's distance:<pre>                Console.Write("    Today's distance: ");
                input = Console.ReadLine();
                double.TryParse(input, NumberStyles.Any,                    CultureInfo.CurrentCulture, out var distanceToday);
                var carToday = new Car
                {
                    Distance = distanceToday,
                    JourneyTime = random.NextDouble() * 10D
                };</pre></li>
<li>Now that you have two <code>Car</code> instances populated with values for yesterday and today, you can create the <code>JourneyComparer</code> instance and call <code>Compare</code>. This will then call <code>Compare</code> on your three <code>Comparison</code> instances:<pre>                var comparer = new JourneyComparer();
                comparer.Compare(carYesterday, carToday);</pre></li>
<li>Now, write the results to the console:<pre>                Console.WriteLine();
                Console.WriteLine("Journey Details   Distance\tTime\tAvg Speed");
                Console.WriteLine("-------------------------------------------------");</pre></li>
<li>Write out yesterday's results:<pre>                Console.Write($"Yesterday         {comparer.Distance.Yesterday:N0}   \t");
                Console.WriteLine($"{comparer.JourneyTime.Yesterday:N0}\t {comparer.AverageSpeed.Yesterday:N0}");</pre></li>
<li>Write out today's results:<pre>                Console.Write($"Today             {comparer.Distance.Today:N0}     \t");                 Console.WriteLine($"{comparer.JourneyTime.Today:N0}\t {comparer.AverageSpeed.Today:N0}");</pre></li>
<li>Finally, write the summary values using the <code>Difference</code> properties:<pre>                Console.WriteLine("=================================================");
                Console.Write($"Difference             {comparer.Distance.Difference:N0}     \t");                Console.WriteLine($"{comparer.JourneyTime.Difference:N0} \t{comparer.AverageSpeed.Difference:N0}");
               Console.WriteLine("=================================================");</pre></li>
<li><a id="_idTextAnchor144"/>Finish off the <code>do-while</code> loop, exiting if the user enters an empty string:<pre>            } 
            while (!string.IsNullOrEmpty(input));
        }
    }
}</pre></li>
</ol>
<p>Running the console and entering distances of <code>1000</code> and <code>900</code> produces the following results:</p>
<pre>Yesterday's distance: 1000
    Today's distance: 900
Journey Details   Distance      Time    Avg Speed
-------------------------------------------------
Yesterday         1,000         8       132
Today             900           4       242
=================================================
Difference        100           4       -109</pre>
<p>The program will run in a loop until you enter a blank value. You will notice a different output as the <code>JourneyTime</code> is set using a random value returned by an instance of <code>Random</code> class.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/EJTtS">https://packt.link/EJTtS</a>.</p>
<p>In this exercise, you have seen how a <code>Func&lt;Car, double&gt;</code> delegate is used to create general-purpose code that can be easily reused without the need to create extra interfaces or classes.</p>
<p>Now it is time to look at the second important aspect of deletes and their ability to chain multiple target methods together.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor145"/>Multicast Delegates</h2>
<p>So far, you have invoked delegates that have a single method assigned, typically in the form of a function call. Delegates offer the ability to combine a list of methods that are executed with a single invocation call, using the <code>+=</code> operator, any number of additional target methods can be added to the target list. Every time the delegate is invoked, each one of the target methods gets invoked too. But what if you decide you want to remove a target method? That is where the <code>-=</code> operator is used.</p>
<p>In the following code snippet, you have an <code>Action&lt;string&gt;</code> delegate named <code>logger</code>. It starts with a single target method, <code>LogToConsole</code>. If you were to invoke this delegate, passing in a string, then the <code>LogToConsole</code> method will be called once:</p>
<pre><a id="_idTextAnchor146"/>Action&lt;string&gt; logger = LogToConsole;
logger("1. Calculating bill");  </pre>
<p>If you were to watch the call stack, you would observe these calls:</p>
<pre>logger("1. Calculating bill")
--&gt; LogToConsole("1. Calculating bill")</pre>
<p>To add a new target method, you use the <code>+=</code> operator. The following statement adds <code>LogToFile</code> to the <code>logger</code> delegate's invocation list:</p>
<pre>logger += LogToFile;</pre>
<p>Now, every time you invoke <code>logger</code>, both <code>LogToConsole</code> and <code>LogToFile</code> will be called. Now invoke <code>logger</code> a second time:</p>
<pre>logger("2. Saving order"); </pre>
<p>The call stack looks like this:</p>
<pre>logger("2. Saving order")
--&gt; LogToConsole("2. Saving order")
--&gt; LogToFile("2. Saving order")</pre>
<p>Again, suppose you use <code>+=</code> to add a third target method called <code>LogToDataBase</code> as follows:</p>
<pre>logger += LogToDataBase</pre>
<p>Now invoke it once again:</p>
<pre>logger("3. Closing order"); </pre>
<p>The call stack looks like this:</p>
<pre>logger("3. Closing order")
--&gt; LogToConsole("3. Closing order")
--&gt; LogToFile("3. Closing order")
--&gt; LogToDataBase("3. Closing order")</pre>
<p>However, consider that you may no longer want to include <code>LogToFile</code> in the target method list. In such a case, simply use the <code>-=</code> operator to remove it, as follows:</p>
<pre>logger -= LogToFile</pre>
<p>You can again invoke the delegate as follows:</p>
<pre>logger("4. Closing customer"); </pre>
<p>And now, the call stack looks like this:</p>
<pre>logger("4. Closing customer")
--&gt; LogToConsole("4. Closing customer")
--&gt; LogToDataBase("4. Closing customer")</pre>
<p>As can be seen, this code resulted in just <code>LogToConsole</code> and <code>LogToDataBase</code>.</p>
<p>By using delegates in this way, you can decide which target methods get called based on certain criteria at runtime. This allows you to pass this configured delegate into other methods, to be invoked as and when needed.</p>
<p>You have seen that <code>Console.WriteLine</code> can be used to write messages to the console window. To create a method that logs to a file (as <code>LogToFile</code> does in the preceding example), you need to use the <code>File</code> class from the <code>System.IO</code> namespace. <code>File</code> has many static methods that can be used to read and write files. You will not go into full details about <code>File</code> here, but it is worth mentioning the <code>File.AppendAllText</code> method, which can be used to create or replace a text file containing a string value, <code>File.Exists</code>, which is used to check for the existence of a file, and <code>File.Delete</code>, to delete a file.</p>
<p>Now it is time to practice what you have learned through an exercise.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor147"/>Exercise 3.03: Invoking a Multicast Delegate</h2>
<p>In this exercise, you will use a multicast delegate to create a cash machine that logs details when a user enters their PIN and asks to see their balance. For this, you will create a <code>CashMachine</code> class that invokes a configured <strong class="bold">logging</strong> delegate, which you can use as a controller class to decide whether messages are sent to the file or to the console.</p>
<p>You will use an <code>Action&lt;string&gt;</code> delegate as you do not need any values to return. Using <code>+=</code>, you can control which target methods get called when your delegate is invoked by <code>CashMachine</code>.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <code>Chapter03</code> folder and create a new console app, called <code>Exercise03</code>, using the CLI <code>dotnet</code> command:<pre>source\Chapter03&gt;dotnet new console -o Exercise03</pre></li>
<li>Open <code>Chapter03\Exercise03.csproj</code> and replace the entire file with these settings:<pre>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre></li>
<li>Open <code>Exercise03\Program.cs</code> and clear the contents.</li>
<li>Add a new class called <code>CashMachine</code>. </li>
<li>Use the <code>Chapter03.Exercise03</code> namespace:<pre>using System;
using System.IO;
namespace Chapter03.Exercise03
{
    public class CashMachine
    {
        private readonly Action&lt;string&gt; _logger;
        public CashMachine(Action&lt;string&gt; logger)
        {
            _logger = logger;
        } </pre></li>
</ol>
<p>The <code>CashMachine</code> constructor is passed the <code>Action&lt;string&gt;</code> delegate, which you can assign to a <code>readonly</code> class variable called <code>_logger</code>.</p>
<ol>
<li value="6">Add a <code>Log</code> helper function that checks whether the <code>_logger</code> delegate is null before invoking:<pre>        private void Log(string message)
            =&gt; _logger?.Invoke(message);</pre></li>
<li>When the <code>VerifyPin</code> and <code>ShowBalance</code> methods are called, a message should be logged with some details. Create these methods as follows:<pre>        public void VerifyPin(string pin) 
            =&gt; Log($"VerifyPin called: PIN={pin}");
        public void ShowBalance() 
            =&gt; Log("ShowBalance called: Balance=999");
    }</pre></li>
<li>Now, add a console app that configures a <code>logger</code> delegate that you can pass into a <code>CashMachine</code> object. Note that this is a common form of usage: a class that is responsible for deciding how messages are logged by other classes. Use a constant, <code>OutputFile</code>, for the filename to be used for file logging, as follows:<pre>    public static class Program
    {
        private const string OutputFile = "activity.txt";
        public static void Main()
        {</pre></li>
<li>Each time the program runs, it should start with a <code>File.Delete</code> to delete the output file:<pre>            if (File.Exists(OutputFile))
            {
                File.Delete(OutputFile);
            }</pre></li>
<li>Create a delegate instance, <code>logger</code>, that starts with a single target method, <code>LogToConsole</code>:<pre>            Action&lt;string&gt; logger = LogToConsole;</pre></li>
<li>Using the <code>+=</code> operator, add <code>LogToFile</code> as a second target method to also be called whenever the delegate is invoked by <code>CashMachine</code>:<pre>            logger += LogToFile;</pre></li>
<li>You will implement the two target logging methods shortly; for now, create a <code>cashMachine</code> instance and get ready to call its methods, as follows:<pre>            var cashMachine = new CashMachine(logger);</pre></li>
<li>Prompt for a <code>pin</code> and pass it to the <code>VerifyPin</code> method:<pre>            Console.Write("Enter your PIN:");
            var pin = Console.ReadLine();
            if (string.IsNullOrEmpty(pin))
            {
                Console.WriteLine("No PIN entered");
                return;
            }
            cashMachine.VerifyPin(pin);
            Console.WriteLine();</pre></li>
</ol>
<p>In case you enter a blank value, then it is checked and a warning is displayed. This will then close the program using a <code>return</code> statement.</p>
<ol>
<li value="14">Wait for the <code>Enter</code> key to be pressed before calling the <code>ShowBalance</code> method:<pre>            Console.Write("Press Enter to show balance");
            Console.ReadLine();
            cashMachine.ShowBalance();
            Console.Write("Press Enter to quit");
            Console.ReadLine();</pre></li>
<li>Now for the logging methods. They must be compatible with your <code>Action&lt;string&gt;</code> delegate. One writes a message to the console and the other appends it to the text file. Add these two static methods as follows:<pre>            static void LogToConsole(string message)
                =&gt; Console.WriteLine(message);
            static void LogToFile(string message)
                =&gt; File.AppendAllText(OutputFile, message);
        }
     }
}</pre></li>
<li>Running the console app, you see that <code>VerifyPin</code> and <code>ShowBalance</code> calls are written to the console:<pre>Enter your PIN:12345
VerifyPin called: PIN=12345
Press Enter to show balance
ShowBalance called: Balance=999</pre></li>
<li>For each <code>logger</code> delegate invocation, the <code>LogToFile</code> method will also be called, so when opening <code>activity.txt</code>, you should see the following line:<pre>VerifyPin called: PIN=12345ShowBalance called: Balance=999</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/h9vic">https://packt.link/h9vic</a>.</p></li>
</ol>
<p>It is important to remember that delegates are immutable, so each time you use the <code>+=</code> or <code>-=</code> operators, you create a <strong class="bold">new</strong> delegate instance. This means that if you alter a delegate after you have passed it to a target class, you will not see any changes to the methods called from inside that target class.</p>
<p>You can see this in action in the following example:</p>
<pre>MulticastDelegatesAddRemoveExample.cs
using System;
namespace Chapter03Examples
{
    class MulticastDelegatesAddRemoveExample
    {
        public static void Main()
        {
            Action&lt;string&gt; logger = LogToConsole;
            Console.WriteLine($"Logger1 #={logger.GetHashCode()}");
            logger += LogToConsole;
            Console.WriteLine($"Logger2 #={logger.GetHashCode()}");
            logger += LogToConsole;
            Console.WriteLine($"Logger3 #={logger.GetHashCode()}");
You can find the complete code here: <a href="https://packt.link/vqZMF">https://packt.link/vqZMF</a>.</pre>
<p>All objects in C# have a <code>GetHashCode()</code> function that returns a unique ID. Running the code produces this output:</p>
<pre>Logger1 #=46104728
Logger2 #=1567560752
Logger3 #=236001992</pre>
<p>You can see that the <code>+=</code> call. This shows that the object reference is changing each time.</p>
<p>Now look at another example using an <code>Action&lt;string&gt;</code> delegate. Here, you will use the <code>+=</code> operator to add target methods and then use <code>-=</code> to remove the target methods:</p>
<pre>MulticastDelegatesExample.cs
using System;
namespace Chapter03Examples
{
    class MulticastDelegatesExample
    {
        public static void Main()
        {
            Action&lt;string&gt; logger = LogToConsole;
            logger += LogToConsole;
            logger("Console x 2");
             
            logger -= LogToConsole;
            logger("Console x 1");
            logger -= LogToConsole;
You can find the complete code here: <a href="https://packt.link/Xe0Ct">https://packt.link/Xe0Ct</a>.</pre>
<p>You start with one target method, <code>LogToConsole</code>, and then add the same target method a second time. Invoking the logger delegate using <code>logger("Console x 2")</code> results in <code>LogToConsole</code> being called twice.</p>
<p>You then use <code>-=</code> to remove <code>LogToConsole</code> <strong class="bold">twice</strong> such that had two targets and now you do not have any at all. Running the code produces the following output:</p>
<pre>Console x 2
Console x 2
Console x 1</pre>
<p>However, rather than <code>logger("logger is now null")</code> running correctly, you end up with an unhandled exception being thrown like so:</p>
<pre>System.NullReferenceException
  HResult=0x80004003
  Message=Object reference not set to an instance of an object.
  Source=Examples
  StackTrace:
   at Chapter03Examples.MulticastDelegatesExample.Main() in Chapter03\MulticastDelegatesExample.cs:line 16</pre>
<p>By removing the last target method, the <code>-=</code> operator returned a null reference, which you then assigned to the logger. As you can see, it is important to always check that a delegate is not null before trying to invoke it.</p>
<h3 id="_idParaDest-138"><a id="_idTextAnchor148"/>Multicasting with a Func Delegate</h3>
<p>So far, you have used <code>Action&lt;string&gt;</code> delegates within <code>Action</code> delegates.</p>
<p>You have seen that <code>Func</code> delegates are used when a return value is required from an invoked delegate. It is also perfectly legal for the C# complier to use <code>Func</code> delegates in multicast delegates.</p>
<p>Consider the following example where you have a <code>Func&lt;string, string&gt;</code> delegate. This delegate supports functions that are passed a string and return a formatted string is returned. This could be used when you need to format an email address by removing the <code>@</code> sign and dot symbols:</p>
<pre>using System;
namespace Chapter03Examples
{
    class FuncExample
    {
        public static void Main()
        {</pre>
<p>You start by assigning the <code>RemoveDots</code> string function to <code>emailFormatter</code> and invoke it using the <code>Address</code> constant:</p>
<pre>            Func&lt;string, string&gt; emailFormatter = RemoveDots;
            const string Address = "admin@google.com";
            var first = emailFormatter(Address);
            Console.WriteLine($"First={first}");</pre>
<p>Then you add a second target, <code>RemoveAtSign</code>, and invoke <code>emailFormatter</code> a second time:</p>
<pre>            emailFormatter += RemoveAtSign;
            var second = emailFormatter(Address);
            Console.WriteLine($"Second={second}");
            Console.ReadLine();
            static string RemoveAtSign(string address)
                =&gt; address.Replace("@", "");
            static string RemoveDots(string address)
                =&gt; address.Replace(".", "");
        }
    }
} </pre>
<p>Running the code produces this output:</p>
<pre>First=admin@googlecom
Second=admingoogle.com</pre>
<p>The first invocation returns the <code>admin@googlecom</code> string. The <code>RemoveAtSign</code> added to the target list, returns a value with only the <code>@</code> symbol removed.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/fshse">https://packt.link/fshse</a>.</p>
<p>Both <code>Func1</code> and <code>Func2</code> are invoked, but only the value from <code>Func2</code> is returned to both <code>ResultA</code> and <code>ResultB</code> variables, even though the correct arguments are passed in. When a <code>Func&lt;&gt;</code> delegate is used with multicast in this manner, all of the target <code>Func</code> instances are called, but the return value will be that of the last <code>Func&lt;&gt;</code> in the chain. <code>Func&lt;&gt;</code> is better suited in a single method scenario, although the compiler will still allow you to use it as a multicast delegate without any compilation error or warning.</p>
<h3 id="_idParaDest-139"><a id="_idTextAnchor149"/>What Happens When Things Go Wrong?</h3>
<p>When a delegate is invoked, all methods in the invocation list are called. In the case of single-name delegates, this will be one target method. What happens in the case of multicast delegates if one of those targets throws an exception?</p>
<p>Consider the following code. When the <code>logger</code> delegate is invoked, by passing in <code>try log this</code>, you may expect the methods to be called in the order that they were added: <code>LogToConsole</code>, <code>LogToError</code>, and finally <code>LogToDebug</code>:</p>
<pre>MulticastWithErrorsExample.cs
using System;
using System.Diagnostics;
namespace Chapter03Examples
{
    class MulticastWithErrorsExample
    {
            public static void Main()
            {
                <a id="_idTextAnchor150"/>Action&lt;string&gt; logger = LogToConsole;
                logger += LogToError;
                logger += LogToDebug;
                try
                {
                    logger("try log this");
You can find the complete code here: <a href="https://packt.link/Ti3Nh">https://packt.link/Ti3Nh</a>.</pre>
<p>If any target method throws an exception, such as the one you see in <code>LogToError</code>, then the remaining targets are <strong class="bold">not</strong> called.</p>
<p>Running the code results in the following output:</p>
<pre>Console: try log this
Caught oops!
All done</pre>
<p>You will see this output because the <code>LogToDebug</code> method wasn't called at all. Consider a UI with multiple targets listening to a mouse button click. The first method fires when a button is pressed and disables the button to prevent double-clicks, the second method changes the button's image to indicate success, and the third method enables the button.</p>
<p>If the second method fails, then the third method will not get called, and the button could remain in a disabled state with an incorrect image assigned, thereby confusing the user.</p>
<p>To ensure that all target methods are run regardless, you can enumerate through the invocation list and invoke each method manually. Take a look at the .NET <code>MulticastDelegate</code> type. You will find that there is a function, <code>GetInvocationList</code>, that returns an array of the delegate objects. This array contains the target methods that have been added:</p>
<pre>public abstract class MulticastDelegate : Delegate {
  public sealed override Delegate[] GetInvocationList();
}</pre>
<p>You can then loop through those target methods and execute each one inside a <code>try</code>/<code>catch</code> block. Now practice what you learned through this exercise.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor151"/>Exercise 3.04: Ensuring All Target Methods Are Invoked in a Multicast Delegate</h2>
<p>Throughout this chapter, you have been using <code>Action&lt;string&gt;</code> delegates to perform various logging operations. In this exercise, you have a list of target methods for a logging delegate and you want to ensure that "all" target methods are invoked even if earlier ones fail. You may have a scenario where logging to a database or filesystem fails occasionally, maybe due to network issues. In such a situation, you will want other logging operations to at least have a chance to perform their logging activity.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <code>Chapter03</code> folder and create a new console app, called <code>Exercise04</code>, using the CLI <code>dotnet</code> command:<pre>source\Chapter03&gt;dotnet new console -o Exercise04</pre></li>
<li>Open <code>Chapter03\Exercise04.csproj</code> and replace the entire file with these settings:<pre>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre></li>
<li>Open <code>Exercise04\Program.cs</code> and clear the contents.</li>
<li>Now add a static <code>Program</code> class for your console app, including <code>System</code> and, additionally, <code>System.IO</code> as you want to create a file:<pre>using System;
using System.IO;
namespace Chapter03.Exercise04
{
    public static class Program
    {</pre></li>
<li>Use a <code>const</code> to name the logging file. This file is created when the program executes:<pre>        private const string OutputFile = "Exercise04.txt";</pre></li>
<li>Now you must define the app's <code>Main</code> entry point. Here you delete the output file if it already exists. It is best to start with an empty file here, as otherwise, the log file will keep growing every time you run the app:<pre>        public static void Main()
        {
            if (File.Exists(OutputFile))
            {
                File.Delete(OutputFile);
            }</pre></li>
<li>You will start with <code>logger</code> having just one target method, <code>LogToConsole</code>, which you will add shortly:<pre>            Action&lt;string&gt; logger = LogToConsole;</pre></li>
<li>You use the <code>InvokeAll</code> method to invoke the delegate, passing in <code>"First call"</code> as an argument. This will not fail as <code>logger</code> has a single valid method and you will add <code>InvokeAll</code> shortly, too:<pre>            InvokeAll(logger, "First call"); </pre></li>
<li>The aim of this exercise is to have a multicast delegate, so add some additional target methods:<pre>            logger += LogToConsole;
            logger += LogToDatabase;
            logger += LogToFile; </pre></li>
<li>Try a second call using <code>InvokeAll</code> as follows:<pre>            InvokeAll(logger, "Second call"); 
            Console.ReadLine();</pre></li>
<li>Now for the target methods that were added to the delegate. Add the following code for this:<pre>            static void LogToConsole(string message)
                =&gt; Console.WriteLine($"LogToConsole: {message}");
            static void LogToDatabase(string message)
                =&gt; throw new ApplicationException("bad thing happened!");
            static void LogToFile(string message)
                =&gt; File.AppendAllText(OutputFile, message);
        </pre></li>
<li>You can now implement the <code>InvokeAll</code> method: <pre>            static void InvokeAll(Action&lt;string&gt; logger, string arg)
            {
                if (logger == null)
                     return;</pre></li>
</ol>
<p>It is passed an <code>Action&lt;string&gt;</code> delegate that matches the <code>logger</code> delegate type, along with an <code>arg</code> string to use when invoking each target method. Before that though, it is important to check that <code>logger</code> is not already null and there is nothing you can do with a null delegate.</p>
<ol>
<li value="13">Use the delegate's <code>GetInvocationList()</code> method to get a list of all the target methods:<pre>                var delegateList = logger.GetInvocationList();
                Console.WriteLine($"Found {delegateList.Length} items in {logger}"); </pre></li>
<li>Now, loop through each item in the list as follows:<pre>                foreach (var del in delegateList)
                {</pre></li>
<li>After wrapping each loop element in a <code>try</code>/<code>catch</code>, cast <code>del</code> into an <code>Action&lt;string&gt;</code>:<pre>                   try
                   {
                     var action = del as Action&lt;string&gt;; </pre></li>
</ol>
<p><code>GetInvocationList</code> returns each item as the base delegate type regardless of their actual type.</p>
<ol>
<li value="16">If it is the correct type and <strong class="bold">not</strong> null, then it is safe to try invoking:<pre>                      if (del is Action&lt;string&gt; action)
                      {
                          Console.WriteLine($"Invoking '{action.Method.Name}' with '{arg}'");
                          action(arg);
                      }
                      else
                      {
                          Console.WriteLine("Skipped null");
                      } </pre></li>
</ol>
<p>You have added some extra details to show what is about to be invoked by using the delegate's <code>Method.Name</code> property.</p>
<ol>
<li value="17">Finish with a <code>catch</code> block that logs the error message if an error was caught:<pre>                  }
                  catch (Exception e)
                  {
                      Console.WriteLine($"Error: {e.Message}");
                  }
                }
            }
        }
    }
}</pre></li>
<li>Running the code, creates a file called <code>Exercise04.txt</code> with the following results:<pre>Found 1 items in System.Action`1[System.String]
Invoking '&lt;Main&gt;g__LogToConsole|1_0' with 'First call'
LogToConsole: First call
Found 4 items in System.Action`1[System.String]
Invoking '&lt;Main&gt;g__LogToConsole|1_0' with 'Second call'
LogToConsole: Second call
Invoking '&lt;Main&gt;g__LogToConsole|1_0' with 'Second call'
LogToConsole: Second call
Invoking '&lt;Main&gt;g__LogToDatabase|1_1' with 'Second call'
Error: bad thing happened!
Invoking '&lt;Main&gt;g__LogToFile|1_2' with 'Second call'</pre></li>
</ol>
<p>You will see that it catches the error thrown by <code>LogToDatabase</code> and still allows <code>LogToFile</code> to be called.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/Dp5H4">https://packt.link/Dp5H4</a>.</p>
<p>It is now important to expand upon the multicast concept using events.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor152"/>Events</h2>
<p>In the previous sections, you have created delegates and invoked them directly in the same method or passed them to another method for it to invoke when needed. By using delegates in this way, you have a simple way for code to be notified when something of interest happens. So far, this has not been a major problem, but you may have noticed that there appears to be no way to prevent an object that has access to a delegate from invoking it directly.</p>
<p>Consider the following scenario: you have created an application that allows other programs to register for notifications when a new email arrives by adding their target method to a delegate that you have provided. What if a program, either by mistake or for malicious reasons, decides to invoke your delegate itself? This could quite easily overwhelm all the target methods in your invocation list. Such listener programs should never be allowed to invoke a delegate in this way—after all, they are meant to be passive listeners.</p>
<p>You could add extra methods that allow listeners to add or remove their target methods from the invocation list and shield the delegate from direct access, but what if you have hundreds of such delegates available in an application? That is a great deal of code to write.</p>
<p>The <code>event</code> keyword instructs the C# complier to add extra code to ensure that a delegate can <strong class="bold">only</strong> be invoked by the class or struct that it is declared in. External code can add or remove target methods but is prevented from invoking the delegate. Attempting to do so results in a compiler error.</p>
<p>This pattern is commonly known as the pub-sub pattern. The object raising an event is called the event sender or <strong class="bold">publisher</strong>; the object(s) receiving the event are called event handlers or <strong class="bold">subscribers</strong>.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor153"/>Defining an Event</h2>
<p>The <code>event</code> keyword is used to define an event and its associated delegates. Its definition looks similar to the way delegates are defined, but unlike delegates, you cannot use the global namespace to define events:</p>
<pre>public event EventHandler MouseDoubleClicked</pre>
<p>Events have four elements:</p>
<ul>
<li>Scope: An access modifier, such as <code>public</code>, <code>private</code>, or <code>protected</code>, to define the scope.</li>
<li>The <code>event</code> keyword.</li>
<li>Delegate type: The associated delegate, <code>EventHandler</code> in this example.</li>
<li>Event name: This can be anything you like, <code>MouseDoubleClicked</code>, for example. However, the name must be unique within the namespace.</li>
</ul>
<p>Events are typically associated with the inbuilt .NET delegates, <code>EventHandler</code>, or its generic <code>EventHandler&lt;&gt;</code> version. It is rare to create custom delegates for events, but you may find this in older legacy code created prior to the <code>Action</code> and generic <code>Action&lt;T&gt;</code> delegates.</p>
<p>The <code>EventHandler</code> delegate was available in early versions of .NET. It has the following signature, taking a sender <code>object</code> and an <code>EventArgs</code> parameter: </p>
<pre>public delegate void EventHandler(object sender, EventArgs e); </pre>
<p>The more recent generic-based <code>EventHandler&lt;T&gt;</code> delegate looks similar; it also takes a sender <code>object</code> and a parameter defined by the type <code>T</code>:</p>
<pre>public delegate void EventHandler&lt;T&gt;(object sender, T e); </pre>
<p>The <code>sender</code> parameter is defined as <code>object</code>, allowing any type of object to be sent to subscribers for them to identify the sender of the event. This can be useful in a situation where you have a centralized method that needs to work on various types of objects rather than specific instances.</p>
<p>For example, in a UI app, you may have one subscriber that listens for an OK button being clicked, and a second subscriber that listens for a <strong class="bold">Cancel</strong> button being clicked–each of these could be handled by two separate methods. In the case of multiple checkboxes used to toggle options on or off, you could use a single target method that simply needs to be told that a checkbox is the sender, and to toggle the setting accordingly. This allows you to reuse the same checkbox handler rather than creating a method for every checkbox on a screen.</p>
<p>It is not mandatory to include details of the sender when invoking an <code>EventHandler</code> delegate. Often, you may not want to divulge the inner workings of your code to the outside; in this case, it is common practice to pass a null reference to the delegate.</p>
<p>The second argument in both delegates can be used to provide extra contextual information about the event (for example, was it the left or right mouse button that was pressed?). Traditionally, this extra information was wrapped up using a class derived from <code>EventArgs</code>, but that convention has been relaxed in newer .NET versions.</p>
<p>There are two standard .NET delegates you should for your event definition?</p>
<ul>
<li><code>EventHandler</code>: This can be used when there is no extra information to describe the event. For example, a checkbox click event may not need any extra information, it was simply clicked. In this case, it is perfectly valid to pass null or <code>EventArgs.Empty</code> as the second parameter. This delegate can often be found in legacy apps that use a class derived from <code>EventArgs</code> to describe the event further. Was it a double-click of the mouse that triggered this event? In this case, a <code>Clicks</code> property may have been added to an <code>EventArgs</code> derived class to provide such extra details.</li>
<li><code>EventHandler&lt;T&gt;</code>: Since the inclusion of generics in C#, this has become the more frequently used delegate for events, simply because using generics requires fewer classes to be created.</li>
</ul>
<p>Interestingly, no matter what scope you give to your event (<code>public</code>, for example), the C# compiler will internally create a private member with that name. This is the key concept with events: only the class that defines the event may <strong class="bold">invoke it</strong>. Consumers are free to add or remove their interest, but they <strong class="bold">cannot</strong> invoke it themselves.</p>
<p>When an event is defined, the publisher class in which it is defined can simply invoke it as and when needed, in the same way that you invoke delegates. In the earlier examples, a point was made of always checking that the delegate is not null before invoking. The same approach should be taken with events, as you have little control over how or when a subscriber may add or remove their target methods.</p>
<p>When a publisher class is initially created, all events have an initial value of null. This will change to not null when any subscriber adds a target method. Conversely, as soon as a subscriber removes a target method, the event will revert to null if there are no methods left in the invocation list and all this is handled by the runtime. This is the standard behavior you saw earlier with delegates.</p>
<p>You can prevent an event from ever becoming null by adding an empty delegate to the end of the event definition:</p>
<pre>public event EventHandler&lt;MouseEventArgs&gt; MouseDoubleClicked = delegate {};</pre>
<p>Rather than having the default null value, you are adding your own default delegate instance—one that does nothing. Hence the blank between the <code>{}</code> symbols.</p>
<p>There is a common pattern often followed when using events within a publisher class, particularly in classes that may be subclassed further. You will now see this with the help of a simple example:</p>
<ol>
<li value="1">Define a class, <code>MouseClickedEventArgs</code>, that contains additional information about the event, in this case, the number of mouse clicks that were detected:<pre>using System;
namespace Chapter03Examples
{
    public class MouseClickedEventArgs 
    {
        public MouseClickedEventArgs(int clicks)
        {
            Clicks = clicks;
        }
        public int Clicks { get; }
    }</pre></li>
</ol>
<p>Observe the <code>MouseClickPublisher</code> class, This has a <code>MouseClicked</code> event defined using the generic <code>EventHandler&lt;&gt;</code> delegate.</p>
<ol>
<li value="2">Now add the <code>delegate { };</code> block to prevent <code>MouseClicked</code> from being null initially:<pre>    public class MouseClickPublisher
    {
     public event EventHandler&lt;MouseClickedEventArgs&gt; MouseClicked = delegate { };</pre></li>
<li>Add an <code>OnMouseClicked</code> virtual method that gives any further subclassed <code>MouseClickPublisher</code> classes a chance to suppress or change the event notification, as follows:<pre>        protected virtual void OnMouseClicked( MouseClickedEventArgs e)
        {
            var evt = MouseClicked;
            evt?.Invoke(this, e);
        }</pre></li>
<li>Now you need a method that tracks the mouse clicks. In this example, you will not actually show how mouse clicks are detected, but you will call <code>OnMouseClicked</code>, passing in <code>2</code> to indicate a double-click.</li>
<li>Notice how you have not invoked the <code>MouseClicked</code> event directly; you always go via the <code>OnMouseClicked</code> intermediary method. This provides a way for other implementations of <code>MouseClickPublisher</code> to override the event notification if they need to:<pre>        private void TrackMouseClicks()
        {
            OnMouseClicked(new MouseClickedEventArgs(2));
        }
    } </pre></li>
<li>Now add a new type of publisher that is based on <code>MouseClickPublisher</code>: <pre>    public class MouseSingleClickPublisher : MouseClickPublisher
    {
        protected override void OnMouseClicked(MouseClickedEventArgs e)
        {
            if (e.Clicks == 1)
            {
                OnMouseClicked(e);
            }
        }
    }
} </pre></li>
</ol>
<p>This <code>MouseSingleClickPublisher</code> overrides the <code>OnMouseClicked</code> method and only calls the base <code>OnMouseClicked</code> if a single click was detected. By implementing this type of pattern, you allow different types of publishers to control whether events are fired to subscribers in a customized manner.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/J1EiB">https://packt.link/J1EiB</a>.</p>
<p>You can now practice what you learned through the following exercise.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor154"/>Exercise 3.05: Publishing and Subscribing to Events</h2>
<p>In this exercise, you will create an alarm clock as an example of a publisher. The alarm clock will simulate a <code>Ticked</code> event. You will also add a <code>WakeUp</code> event that is published when the current time matches an alarm time. In .NET, <code>DateTime</code> is used to represent a point in time, so you will use that for the current time and alarm time properties. You will use <code>DateTime.Subtract</code> to get the difference between the current time and the alarm time and publish the <code>WakeUp</code> event when it is due.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <code>Chapter03</code> folder and create a new console app, called <code>Exercise05</code>, using the CLI <code>dotnet</code> command:<pre>dotnet new console -o Exercise05</pre></li>
<li>Open <code>Chapter03\Exercise05.csproj</code> and replace the entire file with these settings:<pre>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre></li>
<li>Open <code>Exercise05\Program.cs</code> and clear the contents.</li>
<li>Add a new class called <code>AlarmClock</code>. Here you need to use a <code>DateTime</code> class, so include the <code>System</code> namespace:<pre>using System;
namespace Chapter03.Exercise05
{
    public class AlarmClock
    {</pre></li>
</ol>
<p>You will offer two events for subscribers to listen to—<code>WakeUp</code>, based on the non-generic <code>EventHandler</code> delegate (since you will not pass any extra information in this event), and <code>Ticked</code>, which uses the generic <code>EventHandler</code> delegate with a <code>DateTime</code> parameter type. </p>
<ol>
<li value="5">You will use this to pass along the current time to display in the console. Notice that both have the initial <code>delegate {};</code> safety mechanism:<pre>        public event EventHandler WakeUp = delegate {};
        public event EventHandler&lt;DateTime&gt; Ticked = delegate {};</pre></li>
<li>Include an <code>OnWakeUp</code> override as an example, but do not do the same with <code>Ticked</code>; this is to show the different invocation approaches:<pre>        protected void OnWakeUp()
        {
            WakeUp.Invoke(this, EventArgs.Empty);
        }</pre></li>
<li>Now add two <code>DateTime</code> properties, the alarm and clock times, as follows:<pre>        public DateTime AlarmTime { get; set; }
        public DateTime ClockTime { get; set; }</pre></li>
<li>A <code>Start</code> method is used to start the clock. You simulate a clock ticking once every minute for <code>24 hours</code> using a simple loop as follows:<pre>        public void Start()
        {
            // Run for 24 hours
            const int MinutesInADay = 60 * 24;</pre></li>
<li>For each simulated minute, increment the clock using <code>DateTime.AddMinute</code> and publish the <code>Ticked</code> event, passing in <code>this</code> (the <code>AlarmClock</code> sender instance) and the clock time:<pre>            for (var i = 0; i &lt; MinutesInADay; i++)
            {
                ClockTime = ClockTime.AddMinutes(1);
                Ticked.Invoke(this, ClockTime);</pre></li>
</ol>
<p><code>ClockTime.Subtract</code> is used to calculate the difference between the click and alarm times. </p>
<ol>
<li value="10">You pass the <code>timeRemaining</code> value to the local function, <code>IsTimeToWakeUp</code>, calling the <code>OnWakeUp</code> method and break out of the loop if it is time to wake up:<pre>              var timeRemaining = ClockTime                 .Subtract(AlarmTime)                .TotalMinutes;
               if (IsTimeToWakeUp(timeRemaining))
                {
                    OnWakeUp();
                    break;
                }
            }</pre></li>
<li>Use the <code>IsTimeToWakeUp</code>, a relational pattern, to see whether there is less than one minute remaining. Add the following code for this:<pre>            static bool IsTimeToWakeUp(double timeRemaining) 
                =&gt; timeRemaining is (&gt;= -1.0 and &lt;= 1.0);
        }
    }   </pre></li>
<li>Now add a console app that subscribes to the alarm clock and its two events by starting from the static void <code>Main</code> entry point:<pre>         public static class Program
    {
        public static void Main()
        {</pre></li>
<li>Create the <code>AlarmClock</code> instance and use the <code>+=</code> operator to subscribe to the <code>Ticked</code> event and the <code>WakeUp</code> events. You will define <code>ClockTicked</code> and <code>ClockWakeUp</code> shortly. For now, just add the following code:<pre>            var clock = new AlarmClock();
            clock.Ticked += ClockTicked;
            clock.WakeUp += ClockWakeUp; </pre></li>
<li>Set the clock's current time, use <code>DateTime.AddMinutes</code> to add <code>120</code> minutes to the alarm time, and then start the clock, as follows:<pre>            clock.ClockTime = DateTime.Now;
            clock.AlarmTime = DateTime.Now.AddMinutes(120);
            Console.WriteLine($"ClockTime={clock.ClockTime:t}");
            Console.WriteLine($"AlarmTime={clock.AlarmTime:t}");
            clock.Start(); </pre></li>
<li>Finish off <code>Main</code> by prompting for the <code>Enter</code> key to be pressed:<pre>            Console.WriteLine("Press ENTER");
            Console.ReadLine();
        </pre></li>
<li>Now you can add the event subscriber local methods:<pre>            static void ClockWakeUp(object sender, EventArgs e)
            {
               Console.WriteLine();
               Console.WriteLine("Wake up");
            }</pre></li>
</ol>
<p><code>ClockWakeUp</code> is passed sender and <code>EventArgs</code> arguments. You don't use either of these, but they are required for the <code>EventHandler</code> delegate. When this subscriber's method is called, you write <code>"Wake up"</code> to the console.</p>
<ol>
<li value="17"><code>ClockTicked</code> is passed the <code>DateTime</code> argument as required by the <code>EventHandler&lt;DateTime&gt;</code> delegate. Here, you pass the current time, so you write that to the console using <code>:t</code> to show the time in a short format:<pre>             static void ClockTicked(object sender, DateTime e)
                =&gt; Console.Write($"{e:t}...");
        }
    }
} </pre></li>
<li>Running the app produces this output:<pre>ClockTime=14:59
AlarmTime=16:59
15:00...15:01...15:02...15:03...15:04...15:05...15:06...15:07...15:08...15:09...15:10...15:11...15:12...15:13...15:14...15:15...15:16...15:17...15:18...15:19...15:20...15:21...15:22...15:23...15:24...15:25...15:26...15:27...15:28...15:29...15:30...15:31...15:32...15:33...15:34...15:35...15:36...15:37...15:38...15:39...15:40...15:41...15:42...15:43...15:44...15:45...15:46...15:47...15:48...15:49...15:50...15:51...15:52...15:53...15:54...15:55...15:56...15:57...15:58...15:59...16:00...16:01...16:02...16:03...16:04...16:05...16:06...16:07...16:08...16:09...16:10...16:11...16:12...16:13...16:14...16:15...16:16...16:17...16:18...16:19...16:20...16:21...16:22...16:23...16:24...16:25...16:26...16:27...16:28...16:29...16:30...16:31...16:32...16:33...16:34...16:35...16:36...16:37...16:38...16:39...16:40...16:41...16:42...16:43...16:44...16:45...16:46...16:47...16:48...16:49...16:50...16:51...16:52...16:53...16:54...16:55...16:56...16:57...16:58...16:59...
Wake up
Press ENTER</pre></li>
</ol>
<p>In this example you see that the alarm clock simulates a tick every minute and publishes a <code>Ticked</code> event.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/GPkYQ">https://packt.link/GPkYQ</a>.</p>
<p>Now it is time to grasp the difference between events and delegates.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor155"/>Events or Delegates?</h1>
<p>On the face of it, events and delegates look remarkably similar:</p>
<ul>
<li>Events are an extended form of delegates.</li>
<li>Both offer <strong class="bold">late-bound</strong> semantics, so rather than calling methods that are known precisely at compile-time, you can defer a list of target methods when known at runtime.</li>
<li>Both are <code>Invoke()</code> or, more simply, the <code>()</code> suffix shortcut, ideally with a null check before doing so.</li>
</ul>
<p>The key considerations are as follows:</p>
<ul>
<li>Optionality: Events offer an optional approach; callers can decide to opt into events or not. If your component can complete its task without needing any subscriber methods, then it is preferable to use an event-based approach.</li>
<li>Return types: Do you need to handle return types? Delegates associated with events are always void.</li>
<li>Lifetime: Event subscribers typically have a shorter lifetime than their publishers, leaving the publisher to continue detecting new messages even if there are no active subscribers.</li>
</ul>
<h2 id="_idParaDest-145"><a id="_idTextAnchor156"/>Static Events Can Cause Memory Leaks</h2>
<p>Before you wrap up your look at events, it pays to be <strong class="bold">careful</strong> when using events, particularly those that are statically defined.</p>
<p>Whenever you add a subscriber's target method to a publisher's event, the publisher class will store a reference to your target method. When you have finished using a subscriber instance and it remains attached to a <code>static</code> publisher, it is possible that the memory used by your subscriber will not be cleared up.</p>
<p>These are often referred to as orphaned, phantom, or ghost events. To prevent this, always try to pair up each <code>+=</code> call with a corresponding <code>-=</code> operator.</p>
<p class="callout-heading">Note</p>
<p class="callout">Reactive Extensions (Rx) (<a href="https://github.com/dotnet/reactive">https://github.com/dotnet/reactive</a>) is a great library for leveraging and taming event-based and asynchronous programming using LINQ-style operators. Rx provides a way to time-shift, for example, buffering a very chatty event into manageable streams with just a few lines of code. What's more, Rx streams are very easy to unit test, allowing you to effectively take control of time.</p>
<p>Now read about the interesting topic of lambda expressions.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor157"/>Lambda Expressions</h1>
<p>Throughout the previous sections, you have mainly used class-level methods as targets for your delegates and events, such as the <code>ClockTicked</code> and <code>ClockWakeUp</code> methods, that were also used in <em class="italic">Exercise 3.05</em>:</p>
<pre><a id="_idTextAnchor158"/>var clock = new AlarmClock();
clock.Ticked += ClockTicked;
clock.WakeUp += ClockWakeUp;
static void ClockTicked(object sender, DateTime e)
  =&gt; <a id="_idTextAnchor159"/>Console.Write($"{e:t}...");
    
static void ClockWakeUp(object sender, EventArgs e)
{
    <a id="_idTextAnchor160"/>Console.WriteLine();
    Console.WriteLine("Wake up");
}</pre>
<p>The <code>ClockWakeUp</code> and <code>ClockTicked</code> methods are easy to follow and step through. However, by converting them into lambda expression syntax, you can have a more succinct syntax and closer proximity to where they are in code.</p>
<p>Now convert the <code>Ticked</code> and <code>WakeUp</code> events to use two different lambda expressions:</p>
<pre>clock.Ticked += (sender, e) =&gt;
{
    Console.Write($"{e:t}..."); 
};  
clock.WakeUp += (sender, e) =&gt;
{
    Console.WriteLine();
    Console.WriteLine("Wake up");
}; </pre>
<p>You have used the same <code>+=</code> operator, but instead of method names, you see <code>(sender, e) =&gt;</code> and identical blocks of code, as seen in <code>ClockTicked</code> and <code>ClockWakeUp</code>.</p>
<p>When defining a lambda expression, you can pass any parameters within parentheses, <code>()</code>, followed by <code>=&gt;</code> (this is often read as <strong class="bold">goes to</strong>), and then by your expression/statement block:</p>
<pre>(parameters) =&gt; expression-or-block</pre>
<p>The code block can be as complex as you need and can return a value if it is a <code>Func</code>-based delegate.</p>
<p>The compiler can normally infer each of the parameter types, so you do not even need to specify their types. Moreover, you can omit the parentheses if there is only one argument and the compiler can infer its type.</p>
<p>Wherever a delegate (remember that <code>Action</code>, <code>Action&lt;T&gt;</code>, and <code>Func&lt;T&gt;</code> are inbuilt examples of a delegate) needs to be used as an argument, rather than creating a class or local method or function, you should consider using a lambda expression. The main reason is that this often results in less code, and that code is placed closer to the location where it is used.</p>
<p>Now consider another example on Lambda. Given a list of movies, you can use the <code>List&lt;string&gt;</code> class to store these string-based names, as shown in the following snippet:</p>
<pre>using System;
using System.Collections.Generic;
namespace Chapter03Examples
{
    class LambdaExample
    {
        public static void Main()
        {
            var names = new List&lt;string&gt;
            {
                "The A-Team",
                "Blade Runner",
                "There's Something About Mary",
                "Batman Begins",
                "The Crow"
            };</pre>
<p>You can use the <code>List.Sort</code> method to sort the names alphabetically (the final output will be shown at the end of this example):</p>
<pre>            names.Sort();
            Console.WriteLine("Sorted names:");
            foreach (var name in names)
            {
                Console.WriteLine(name);
            }
            Console.WriteLine();</pre>
<p>If you need more control over how this sort works, the <code>List</code> class has another <code>Sort</code> method that accepts a delegate of this form: <code>delegate int Comparison&lt;T&gt;(T x, T y)</code>. This delegate is passed two arguments of the same type (<code>x</code> and <code>y</code>) and returns an <code>int</code> value. The <code>int</code> value can be used to define the sort order of items in the list without you having to worry about the internal workings of the <code>Sort</code> method.</p>
<p>As an alternative, you can sort the names to exclude <code>"The"</code> from the beginning of movie titles. This is often used as an alternative way to list names. You can achieve this by passing a lambda expression, using the <code>( )</code> syntax to wrap two strings, <code>x, y</code>, that will be passed by <code>Sort()</code> when it invokes your lambda.</p>
<p>If <code>x</code> or <code>y</code> starts with your noise word, <code>"The"</code>, then you use the <code>string.Substring</code> function to skip the first four characters. <code>String.Compare</code> is then used to return a numeric value that compares the resulting string values, as follows:</p>
<pre>            const string Noise = "The ";
            names.Sort( (x, y) =&gt;
            {
                if (x.StartsWith(Noise))
                {
                    x = x.Substring(Noise.Length);
                }
                if (y.StartsWith(Noise))
                {
                    y = x.Substring(Noise.Length);
                }
                return string.Compare(x , y);
            });</pre>
<p>You can then write out the sorted results to the console:</p>
<pre>            Console.WriteLine($"Sorted excluding leading '{Noise}':");
            foreach (var name in names)
            {
                Console.WriteLine(name);
            }
            Console.ReadLine();
         }
     }
} </pre>
<p>Running the example code produces the following output:</p>
<pre>Sorted names:
Batman Begins
Blade Runner
The A-Team
The Crow
There's Something About Mary
Sorted excluding leading 'The ':
The A-Team
Batman Begins
Blade Runner
The Crow
There's Something About Mary </pre>
<p>You can see that the second set of names is sorted with <code>"The"</code> is ignored.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="http://packt.link/B3NmQ">http://packt.link/B3NmQ</a>.</p>
<p>To see these lambda statements put into practice, try your hand at the following exercise.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor161"/>Exercise 3.06: Using a Statement Lambda to Reverse Words in a Sentence</h2>
<p>In this exercise, you are going to create a utility class that splits the words in a sentence and returns that sentence with the words in reverse order.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Change to the <code>Chapter03</code> folder and create a new console app, called <code>Exercise06</code>, using the CLI <code>dotnet</code> command:<pre>source\Chapter03&gt;dotnet new console -o Exercise06</pre></li>
<li><a id="_idTextAnchor162"/>Open <code>Chapter03\Exercise06.csproj</code> and replace the entire file with these settings:<pre>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre></li>
<li>Open <code>Exercise02\Program.cs</code> and clear the contents.</li>
<li>Add a new class named <code>WordUtilities</code> with a string function called <code>ReverseWords</code>. You need to include the <code>System.Linq</code> namespace to help with the string operations:<pre>using System;
using System.Linq;
namespace Chapter03.Exercise06
{
    public static class WordUtilities
    {
        public static string ReverseWords(string sentence)
        {</pre></li>
<li>Define a <code>Func&lt;string, string&gt;</code> delegate called <code>swapWords</code> that takes a string input and returns a string value:<pre>          Func&lt;string, string&gt; swapWords = </pre></li>
<li>You will accept a string input argument named <code>phrase</code>:<pre>            phrase =&gt;</pre></li>
<li>Now for the lambda statement body. Use the <code>string.Split</code> function to split the <code>phrase</code> string into an array of strings using a space as the splitting character:<pre>                  {
                    const char Delimit = ' ';
                    var words = phrase
                        .Split(Delimit)
                        .Reverse();
                    return string.Join(Delimit, words);
                };</pre></li>
</ol>
<p><code>String.Reverse</code> reverses the order of strings in the array, before finally joining the reversed words string array in a single string using <code>string.Join</code>.</p>
<ol>
<li value="8">You have defined the required <code>Func</code>, so invoke it by passing the sentence parameter and returning that as the result:<pre>            return swapWords(sentence);
         }
    }</pre></li>
<li>Now for a console app that prompts for a sentence to be entered, which is passed to <code>WordUtilities.ReverseWords</code>, with the result being written to the console:<pre>    public static class Program
    {
        public static void Main()
        {
            do
            {
                Console.Write("Enter a sentence:");
                var input = Console.ReadLine();
                if (string.IsNullOrEmpty(input))
                {
                    break;
                }
                var result = WordUtilities.ReverseWords(input);
                Console.WriteLine($"Reversed: {result}")</pre></li>
</ol>
<p>Running the console app produces results output similar to this:</p>
<pre>Enter a sentence:welcome to c#
Reversed: c# to welcome
Enter a sentence:visual studio by microsoft
Reversed: microsoft by studio visual</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/z12sR">https://packt.link/z12sR</a>.</p>
<p>You will conclude this look at lambdas with some of the less obvious issues that you might not expect to see when running and debugging.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor163"/>Captures and Closures</h2>
<p>Lambda expressions can <strong class="bold">capture</strong> any of the variables or parameters within the method where they are defined. The word capture is used to describe the way that a lambda expression captures or reaches up into the parent method to access any variables or parameters.</p>
<p>To grasp this better, consider the following example. Here you will create a <code>Func&lt;int, string&gt;</code> called <code>joiner</code> that joins words together using the <code>Enumerable.Repeat</code> method. The <code>word</code> variable (known as an <code>Outer Variables</code>) is captured inside the body of the <code>joiner</code> expression:</p>
<pre>var word = "hello";
Func&lt;int, string&gt; joiner = 
    input =&gt;
    {
        return string.Join(",", Enumerable.Repeat(word, input));
    };  
Console.WriteLine($"Outer Variables: {joiner(2)}"); </pre>
<p>Running the preceding example produces the following output:</p>
<pre>Outer Variables: hello,hello</pre>
<p>You invoked the <code>joiner</code> delegate by passing <code>2</code> as an argument. At that moment in time, the outer <code>word</code> variable has a value of <code>"hello"</code>, which is repeated twice.</p>
<p>This confirms that captured variables, from the parent method, were evaluated <code>Func</code> was invoked. Now change the value of <code>word</code> from <code>hello</code> to <code>goodbye</code> and invoke <code>joiner</code> once again, passing <code>3</code> as the argument:</p>
<pre>word = "goodbye";
Console.WriteLine($"Outer Variables Part2: {joiner(3)}");</pre>
<p>Running this example produces the following output:</p>
<pre>Outer Variables Part2: goodbye,goodbye,goodbye</pre>
<p>It is worth remembering that it does not matter where in the code you defined <code>joiner</code>. You could have changed the value of <code>word</code> to any number of strings before or after declaring <code>joiner</code>.</p>
<p>Taking captures one step further, if you define a variable with the same name inside a lambda, it will be scoped <code>word</code>, which will have no effect on the outer variable with the same name:</p>
<pre>Func&lt;int, string&gt; joinerLocal =
    input =&gt;
    {
        var word = "local";
        return string.Join(",", Enumerable.Repeat(word, input));
    };
Console.WriteLine($"JoinerLocal: {joinerLocal(2)}");
Console.WriteLine($"JoinerLocal: word={word}");   </pre>
<p>The preceding example results in the following output. Notice how the outer variable, <code>word</code>, remains unchanged from <code>goodbye</code>:</p>
<pre>JoinerLocal: local,local
JoinerLocal: word=goodbye</pre>
<p>Finally, you will look at the concept of closures that is a subtle part of the C# language and often leads to unexpected results.</p>
<p>In the following example, you have a variable, <code>actions</code>, that contains a <code>List</code> of <code>Action</code> delegates. You use a basic <code>for</code> loop to add five separate <code>Action</code> instances to the list. The lambda expression for each <code>Action</code> simply writes that value of <code>i</code> from the <code>for</code> loop to the console. Finally, the code simply runs through each <code>Action</code> in the <code>actions</code> list and invokes each one:</p>
<pre>var actions = new List&lt;Action&gt;();
for (var i = 0; i &lt; 5; i++)
{
    actions.Add( () =&gt; Console.WriteLine($"MyAction: i={i}")) ;
}
foreach (var action in actions)
{
    action();
}</pre>
<p>Running the example produces the following output:</p>
<pre>MyAction: i=5
MyAction: i=5
MyAction: i=5
MyAction: i=5
MyAction: i=5</pre>
<p>The reason why <code>MyAction: i</code> did not start from <code>0</code> is that the value of <code>i</code>, when accessed from inside a <code>Action</code> delegate, is only evaluated once the <code>Action</code> is invoked. By the time each delegate is invoked, the outer loop has already repeated five times over.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/vfOPx">https://packt.link/vfOPx</a>.</p>
<p>This is similar to the capture concept you observed, where the outer variables, <code>i</code> in this case, are only evaluated when invoked. You used <code>i</code> in the <code>for</code> loop to add each <code>Action</code> to the list, but by the time you invoked each action, <code>i</code> had its final value of <code>5</code>.</p>
<p>This can often lead to unexpected behavior, especially if you assume that an <code>i</code> is being used inside each action's loop variable. To ensure that the incrementing value of <code>i</code> is used inside each lambda expression, you need to introduce a <code>for</code> loop, one that takes a copy of the iterator variable.</p>
<p>In the following code snippet, you have added the <code>closurei</code> variable. It looks very subtle, but you now have a more locally scoped variable, which you access from inside the lambda expression, rather than the iterator, <code>i</code>:</p>
<pre>var actionsSafe = new List&lt;Action&gt;();
for (var i = 0; i &lt; 5; i++)
{
    var closurei = i;
    actionsSafe.Add(() =&gt; Console.WriteLine($"MyAction: closurei={closurei}"));
}
foreach (var action in actionsSafe)
{
    action();
}</pre>
<p>Running the example produces the following output. You can see that the incrementing value is used when each <code>Action</code> is invoked, rather than the value of <code>5</code> that you saw earlier:</p>
<pre>MyAction: closurei=0
MyAction: closurei=1
MyAction: closurei=2
MyAction: closurei=3
MyAction: closurei=4</pre>
<p>You have covered the key aspects of delegates and events in event-driven applications. You extended this by using the succinct coding style offered by lambdas, to be notified when events of interest occur.</p>
<p>You will now bring these ideas together into an activity in which you will use some of the inbuilt .NET classes with their own events. You will need to adapt these events to your own format and publish so they can be subscribed to by a console app.</p>
<p>Now it is time to practice all you have learned through the following activity.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor164"/>Activity 3.01: Creating a Web File Downloader</h2>
<p>You plan to investigate patterns in US storm events. To do this, you need to download storm event datasets from online sources for later analysis. The National Oceanic and Atmospheric Administration is one such source of data and can be accessed from <a href="https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles">https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles</a>.</p>
<p>You are tasked with creating a .NET Core console app that allows a web address to be entered, the contents of which are downloaded to a local disk. To be as user-friendly as possible, the application needs to use events that signal when an invalid address is entered, the progress of a download, and when it completes.</p>
<p>Ideally, you should try to hide the internal implementation that you use to download files, preferring to adapt any events that you use to ones that your caller can subscribe to. This form of adaption is often used to make code more maintainable by hiding internal details from callers.</p>
<p>For this purpose, the <code>WebClient</code> class in C# can be used for download requests. As with many parts of .NET, this class returns objects that implement the <code>IDisposable</code> interface. This is a standard interface and it indicates that the object you are using should be wrapped in a <code>using</code> statement to ensure that any resources or memory are cleaned away for you when you have finished using the object. <code>using</code> takes this format:</p>
<pre>using (IDisposable) { statement_block }</pre>
<p>Finally, the <code>WebClient.DownloadFileAsync</code> method downloads files in the background. Ideally, you should use a mechanism that allows one part of your code to <code>System.Threading.ManualResetEventSlim</code> is a class that has <code>Set</code> and <code>Wait</code> methods that can help with this type of signaling.</p>
<p>For this activity, you will need to perform the following steps:</p>
<ol>
<li value="1">Add a progress changed <code>EventArgs</code> class (an example name could be <code>DownloadProgressChangedEventArgs</code>) that can be used when publishing progress events. This should have <code>ProgressPercentage</code> and <code>BytesReceived</code> properties.</li>
<li>The <code>WebClient</code> class from <code>System.Net</code> should be used to download a requested web file. You should create an adapter class (a suggested name is <code>WebClientAdapter</code>) that hides your internal usage of <code>WebClient</code> from your callers.</li>
<li>Your adapter class should provide three events—<code>DownloadCompleted</code>, <code>DownloadProgressChanged</code>, and <code>InvalidUrlRequested</code>—that a caller can subscribe to.</li>
<li>The adapter class will need a <code>DownloadFile</code> method that calls the <code>WebClient</code> class's <code>DownloadFileAsync</code> method to start the download request. This requires converting a string-based web address into a Uniform Resource Identifier (URI) class. The <code>Uri.TryCreate()</code> method can create an absolute address from the string entered via the console. If the call to <code>Uri.TryCreate</code> fails, you should publish the <code>InvalidUrlRequested</code> event to indicate this failure.</li>
<li><code>WebClient</code> has two events—<code>DownloadFileCompleted</code> and <code>DownloadProgressChanged</code>. You should subscribe to these two events and republish them using your own similar events.</li>
<li>Create a console app that uses an instance of <code>WebClientAdapter</code> (as created in <em class="italic">Step 2</em>) and subscribe to the three events.</li>
<li>By subscribing to the <code>DownloadCompleted</code> event, you should indicate success in the console.</li>
<li>By subscribing to <code>DownloadProgressChanged</code>, you should report progress messages to the console showing the <code>ProgressPercentage</code> and <code>BytesReceived</code> values.</li>
<li>By subscribing to the <code>InvalidUrlRequested</code> event, you should show a warning on the console using a different console background color.</li>
<li>Use a <code>do</code> loop that allows the user to repeatedly enter a web address. This address and a temporary destination file path can be passed to <code>WebClientAdapter.DownloadFile()</code> until the user enters a blank address to quit.</li>
<li>Once you run the console app with various download requests, you should see an output similar to the following:<pre>Enter a URL:
https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles/StormEvents_details-ftp_v1.0_d1950_c20170120.csv.gz
Downloading https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles/StormEvents_details-ftp_v1.0_d1950_c20170120.csv.gz...
Downloading...73% complete (7,758 bytes)
Downloading...77% complete (8,192 bytes)
Downloading...100% complete (10,597 bytes)
Downloaded to C:\Temp\StormEvents_details-ftp_v1.0_d1950_c20170120.csv.gz
Enter a URL:
https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles/StormEvents_details-ftp_v1.0_d1954_c20160223.csv.gz
Downloading https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles/StormEvents_details-ftp_v1.0_d1954_c20160223.csv.gz...
Downloading...29% complete (7,758 bytes)
Downloading...31% complete (8,192 bytes)
Downloading...54% complete (14,238 bytes)
Downloading...62% complete (16,384 bytes)
Downloading...84% complete (22,238 bytes)
Downloading...93% complete (24,576 bytes)
Downloading...100% complete (26,220 bytes)
Downloaded to C:\Temp\StormEvents_details-ftp_v1.0_d1954_c20160223.csv.gz</pre></li>
</ol>
<p>By completing this activity, you have seen how to subscribe to events from an existing .NET event-based publisher class (<code>WebClient</code>), adapting them to your own specification before republishing them in your adapter class (<code>WebClientAdapter</code>), which were ultimately subscribed to by a console app.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor165"/>Summary</h1>
<p>In this chapter, you took an in-depth look at delegates. You created custom delegates and saw how they could be replaced with their modern counterparts, the inbuilt <code>Action</code> and <code>Func</code> delegates. By using null reference checks, you discovered the safe way to invoke delegates and how multiple methods can be chained together to form multicast delegates. You extended delegates further to use them with the <code>event</code> keyword to restrict invocation and followed the preferred pattern when defining and invoking events. Finally, you covered the succinct lambda expression style and saw how bugs can be avoided by recognising the use of captures and closures.</p>
<p>In the next chapter, you will look at LINQ and data structures, the fundamental parts of the C# language.</p>
</div>
<div><div></div>
</div>
</div>
</body></html>