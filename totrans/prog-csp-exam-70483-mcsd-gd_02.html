<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Understanding Classes, Structures, and Interfaces</h1>
                </header>
            
            <article>
                
<p>In <a href="ccec4122-6067-4279-843b-6123b1eff017.xhtml">Chapter 1</a>, <em>Learning the Basics of C#</em>, we looked at an overview of the very basic components of a C# application. All classes in a C# application are composed of attributes and methods. Using namespaces and assemblies, we can bundle related classes together.</p>
<p>To maintain structure and to reduce complexity, it's essential that only the required classes/functionality are exposed outside the scope of a class. In a C# program, this is achieved via access modifiers. While defining the attributes present in a class, we also need to be clear about the different data types of variables available in C#.</p>
<p>Using a code implementation of struct and class, we will look at how data and reference type variables differ in implementation and behavior during program execution. We will also be looking at some <span>good practices that we can follow to choose the right data type for our variables.</span></p>
<p>We will then look at interfaces and inheritance and how they are implemented in a C# application. Using examples, we will look at the different scenarios in which we should use each of them.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Different types of access modifiers in C#</li>
<li>Different types of data types in C#</li>
<li>Understanding the difference between a class and a struct</li>
<li>Understanding inheritance</li>
<li>Understanding interfaces and how they are different from inheritance</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>As in the previous chapters of this book, the programs explained in this chapter will be developed in Visual Studio 2017.</p>
<p>S<span>ample code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples">https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Access modifiers</h1>
                </header>
            
            <article>
                
<p>All classes, along with their respective attributes and functions, have an access modifier associated with them. An access modifier basically indicates how the respective element will be accessed in the application, both in its own assembly as well as in other assemblies. Collectively, attributes and functions in an application are referred to as class members.</p>
<p>In C#, a class and its class members can acquire the following access modifiers:</p>
<ul>
<li><strong>Public</strong><span>:</span> A class or a class member declared as <em>public</em> can be accessed by all classes in the same assembly as well as by classes in different assemblies present in the application.</li>
<li><strong>Private</strong>: <span>A class member declared as <em>private</em> can be accessed only in the same class but not outside it.</span></li>
<li><strong>Protected</strong><span>:</span> A class or a class member declared as <em>protected</em> can be accessed inside the class or by classes that inherit from the respective class.</li>
<li><strong>Internal</strong><span>:</span> A class or a class member declared as <em>internal</em> can only be accessed by classes in the same assembly but not by outside assemblies.</li>
<li><strong>Protected internal</strong><span>:</span> <span>A class or a class member declared as <em>protected</em> <em>internal</em> can only be accessed by classes in the same assembly or by classes present in the outside assembly that inherit from the respective class.</span></li>
<li><strong>Private protected</strong><span>:</span> A class or a class member declared as <em>private protected</em> can only be accessed in the same class or in classes present in the same assembly that inherit from the respective class.</li>
</ul>
<p>Let's look at the following image to summarize this knowledge about access modifiers. In the following example, we have <strong>Assembly A</strong> and <strong><span>Assembly</span> B</strong> in the application. <strong>Assembly A</strong> has <strong>Class A</strong>, which has different functions, each with a separate access modifier. Please refer to the comments against each of the functions to understand which classes under which assemblies can access the respective functions:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/57e02d6a-4e22-4590-83e2-cfad46d9ca71.png" style=""/></div>
<p>Based upon the accessibility level and the security that we wish to embed in the different class members, we can choose either of the previously mentioned access modifiers. To keep some structure and avoid introducing undue complexity, it's advisable to only expose class members to classes that require some information to be shared with the respective class.</p>
<p>In the next section, we will look at the different data types that a class member can acquire.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data types in C#</h1>
                </header>
            
            <article>
                
<p>In C#, a variable can acquire one of the following types:</p>
<ul>
<li>A value type</li>
<li>A reference type</li>
</ul>
<p>C# differentiates between these two types in terms of how these values are saved and maintained in the <strong>Global Assembly Cache</strong> (<strong><span>GAC</span></strong>) during the program execution. Value type variables are saved in the stack, while reference type variables are saved in a managed heap data structure.</p>
<p>There are other <strong>pointer types</strong> that allow us to access value in the memory location of a variable. In <a href="4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml"/><a href="4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml"/><a href="4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml">Chapter 8</a>, <em>Creating and Using of Types in C#</em>, we will explore those data types in detail. For now, let's look at these two data types and explore them in detail.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Value type variables</h1>
                </header>
            
            <article>
                
<p>In value types, the variables contain the data or the contents of the variable. This implies that if any change is made to a value type variable in a different scope of the program, the change will not be reflected back once the control shifts to the calling function.</p>
<p>The following are the different types of value types in C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simple types</h1>
                </header>
            
            <article>
                
<p>Following is the list of simple types:</p>
<ul>
<li><kbd>Int</kbd>: For example 1, 2, 4, and -100. They can be both signed and unsigned. A signed <kbd>int</kbd> type can be both positive and negative. An unsigned <kbd>int</kbd> type cannot be negative; its minimum value is <kbd>0</kbd>.</li>
<li><kbd>Float</kbd>: For example, 3.14.</li>
<li><kbd>Long</kbd>: Unlike <kbd>Int</kbd>, which is 32-bit, <kbd>Long</kbd> is a 64-bit integer value. It can also be both signed and unsigned.</li>
<li><kbd>Decimal</kbd>: Like <kbd>Float</kbd>, decimal data types also represent decimal digit numbers with the main difference being in terms of precision. For <kbd>Float</kbd> data members, the precision is 7; however, in the case of decimal data types, the precision is 28 digits.</li>
<li><kbd>Char</kbd>: Represents a single character sequence. It can acquire values such as <kbd>C</kbd>, <kbd>c</kbd>, or white-space, any special characters – such as % and # – and even a digit such as 1.</li>
<li><kbd>bool</kbd>: It can be used to represent variables that acquire a digital value such as true or false.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enum types</h1>
                </header>
            
            <article>
                
<p>Enum types are used to indicate an attribute that can acquire a constant set of values, for example, <kbd>enum Day {Sat, Sun, Mon, Tues, Wed, Thurs, Fri}</kbd>.</p>
<p class="mce-root"/>
<p>By default, the value of the first enumerator in the declaration starts from 0. It then increments the value of the subsequent enumerators by 1. For the preceding example, the following would be the value of the enumerators:</p>
<ul>
<li><kbd>Sat</kbd> – 0</li>
<li><kbd>Sun</kbd> – 1</li>
<li><kbd>Mon</kbd> – 2</li>
<li><kbd>Tues</kbd> – 3</li>
<li><kbd>Wed</kbd> – 4</li>
<li><kbd>Thurs</kbd> – 5</li>
<li><kbd>Fri</kbd> - 6</li>
</ul>
<p>We can also override the default values of the enumerators by explicitly defining the values in the declaration itself. For example, in the preceding example, if we do not want the enumerators to start from 0, we can use the following declaration:</p>
<pre>enum Day {Sat = 1, Sun, Mon, Tues, Wed, Thurs, Fri}</pre>
<p>For the preceding declaration, the enumerators will acquire the following values:</p>
<ul>
<li><kbd>Sat</kbd> – 1</li>
<li><kbd>Sun</kbd> – 2</li>
<li><kbd>Mon</kbd> – 3</li>
<li><kbd>Tues</kbd> – 4</li>
<li><kbd>Wed</kbd> – 5</li>
<li><kbd>Thurs</kbd> – 6</li>
<li><kbd>Fri</kbd> – 7</li>
</ul>
<p>Each Enumerator attribute also has an underlying data type that, by default, is of type <kbd>Int</kbd>. If required, we can also change the type of the enumerated values to long or short. However, it cannot take <kbd>char</kbd> as an underlying data type. Refer to the following <kbd>enum</kbd> declaration, in which we are setting the type of Enumerator value to <kbd>short</kbd>:</p>
<pre>enum Day : short {Sat = 1, Sun, Mon, Tues, Wed, Thurs, Fri}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Struct types</h1>
                </header>
            
            <article>
                
<p>Just like classes, structs in C# can be used to group together related data. Like classes, they can have constructors, fields, and methods. However, there are some differences between the implementation of structs and classes. The following are some of the key differences:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Feature</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Struct</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Class</strong></td>
</tr>
<tr>
<td>Type</td>
<td>Structs are managed as value type variables. This implies that the value assigned in their objects is not persisted in different scopes of the program.</td>
<td>Classes are managed as reference type variables. This implies that the value assigned in their objects is persisted across different scopes of the program.</td>
</tr>
<tr>
<td>Constructor</td>
<td>Unlike classes, no default constructor is managed by C#. When we go through <a href="4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml">Chapter 8</a>, <em>Creating and Using of Types in C#</em>, we will explore default constructors in detail.</td>
<td>When declaring a class, if no constructor is specified for the class, C# automatically creates a default constructor for the class.</td>
</tr>
<tr>
<td>Inheritance</td>
<td>A struct cannot inherit from another struct. This implies that code reuse could become a challenge if we use structs.</td>
<td>A class can inherit from other classes.</td>
</tr>
</tbody>
</table>
<div class="mce-root packt_infobox"><span>Being value type variables, when a struct object is created, the entire object – inclusive of attributes, methods, and so on – is saved in a stack. Therefore, from a performance perspective, it's essential that structs should only be used for creating lightweight objects with only a few members.</span></div>
<p><span>In the coming section, we will go through a code example to show how struct implementation is different from a similar implementation in classes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reference type variables</h1>
                </header>
            
            <article>
                
<p><span>In reference type variables, the data member contains the exact address of the variable in memory.</span> As the variable just contains a reference to the memory address, two separate reference type variables can point to the same memory address. <span>Therefore, if a change is made to a reference type variable, the change is directly done at the memory location of the variable. Due to the change being directly made at the memory location of the variable, both variables will reflect the updated value.</span></p>
<p class="mce-root"/>
<p>The following are the reference types available in C#:</p>
<ul>
<li><strong>Class</strong>: As discussed in <a href="ccec4122-6067-4279-843b-6123b1eff017.xhtml">Chapter 1</a>, <em>Learning the</em> <em>Basics of C#</em>, a class represents a collection of related properties and methods.</li>
<li><strong>Interface</strong>: An interface in C# represents a collection of related properties, events, and methods, with just a declaration and no definition. In this chapter, in upcoming sections, we will deep dive into interfaces and see how they are implemented in C#.</li>
<li><strong>Dynamic</strong>: A dynamic type variable avoids compile-time type checking. For example, if we declare a dynamics variable type and assign a variable to it, its type is defined at runtime when a value is assigned to it.</li>
</ul>
<p>For example, in the following code snippet, we are creating a dynamics type variable, assigning different variables to it and evaluating its type at runtime:</p>
<pre> dynamic typeVariable = 100;<br/> Console.WriteLine(typeVariable + " " + typeVariable.GetType().ToString());// Output 100 System.Int32<br/> typeVariable = "Hello";<br/> Console.WriteLine(typeVariable + " " + typeVariable.GetType().ToString());// Output Hello System.String<br/> typeVariable = true;<br/> Console.WriteLine(typeVariable + " " + typeVariable.GetType().ToString());// Output True System.Boolean<br/> Console.ReadLine();</pre>
<ul>
<li><strong>Object</strong>: When a new instance of a class is created using the <kbd>new</kbd> keyword, an object for the class is created in the memory.</li>
<li><strong>String</strong>: A <kbd>String</kbd> object is a sequence of <kbd>Char</kbd> objects whose value is immutable or read-only. This basically implies that, when we modify a variable of type <kbd>String</kbd>, it creates a new object in memory.</li>
</ul>
<p>In the next section, we will go through a code example to show how a reference type variable such as <kbd>Class</kbd> and a value type variable <span>such as</span> <span>s</span>truct are implemented in C# and how their behavior differs.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structs versus classes</h1>
                </header>
            
            <article>
                
<p>In the first chapter, we created a basic <kbd>Hello World</kbd> program. In this topic, we will extend that program and use it to implement a struct and a class. While doing so, we will analyze the difference between the implementation and use of reference and value type variables. As you are already aware by now, a struct is a value type variable and a class is a reference type variable:</p>
<ol>
<li>Open the <kbd>Console</kbd> project created in <a href="ccec4122-6067-4279-843b-6123b1eff017.xhtml">Chapter 1,</a> <em>Learning the Basic Structure of C#</em>, and declare a <kbd>CoordinatePoint</kbd> class with just two member attributes of <kbd>x</kbd> and <kbd>y</kbd> coordinates. Also create two constructors – one without any parameters and one with two parameters. Please refer to the following code implementation for this:</li>
</ol>
<pre style="padding-left: 60px">class CoordinatePoint<br/>{<br/>    public float xCoordinate;<br/>    public float yCoordinate;<br/>    public CoordinatePoint()<br/>    {<br/>    }<br/>    public CoordinatePoint(float x, float y)<br/>    {<br/>         this.xCoordinate = x; <br/>         this.yCoordinate = y;<br/>    }<br/>}</pre>
<div class="packt_infobox">Please note that, in the preceding code, the use of the <kbd>this</kbd> variable is optional. It is used to refer to the current instance of the class and can be used to differentiate between class members and method parameters if they have the same name.</div>
<ol start="2">
<li>Declare a similar structure. Notice that the compiler gives an error for the default constructor:</li>
</ol>
<pre style="padding-left: 60px">struct CoordinatePointStruct<br/>{<br/>     public float xCoordinate;<br/>     public float yCoordinate;<br/>     public CoordinatePointStruct()<br/>     {         <br/>        <strong>// This default constructor will give an error.</strong> <br/>     }<br/>     public CoordinatePointStruct(float x, float y)<br/>     {<br/>         this.xCoordinate = x;<br/>         this.yCoordinate = y;<br/>     }<br/> }</pre>
<p style="padding-left: 60px">As indicated in the preceding code, we will see a red label on the <kbd>struct</kbd> constructor. This is because, unlike classes, a struct cannot have an implementation of a default constructor. To remove the error, we need to remove the default constructor. On doing this, we will see that the compiler error goes away. The following would be the correct implementation of the struct:</p>
<pre style="padding-left: 60px">struct CoordinatePointStruct<br/>{<br/>     public float xCoordinate;<br/>     public float yCoordinate;<br/>     public CoordinatePointStruct(float x, float y)<br/>     {<br/>         this.xCoordinate = x;<br/>         this.yCoordinate = y;<br/>     }<br/> }</pre>
<ol start="3">
<li>In the <kbd>Main</kbd> class, we will now declare two functions, one for each class and struct, respectively. In both functions, we will be passing a parameter by the name of <kbd>obj</kbd>, which is an object of type class and struct, respectively. In the same function, we will change the values of the <kbd>x</kbd> and <kbd>y</kbd> coordinate variables in both the struct and the class to a default value of <kbd>0.5F</kbd>. The following is the code implementation for this:</li>
</ol>
<pre style="padding-left: 60px">static void ChangeValuesClass(CoordinatePoint obj)<br/>{<br/>     obj.xCoordinate = .5F;<br/>     obj.yCoordinate = .5F;<br/>}<br/>static void ChangeValuesStruct(CoordinatePointStruct obj)<br/>{<br/>     obj.xCoordinate = .5F;<br/>     obj.yCoordinate = .5F;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="4">
<li>Now, in the main function, declare the objects of both the class and the structure. Notice that, during the declaration of the respective objects, we are specifying the same values in the <kbd>xCoordinate</kbd> and <kbd>yCoordinate</kbd> member attributes.</li>
</ol>
<p style="padding-left: 60px">For the sake of explanation, we will write syntax that will output the values in the respective member attributes <span>to the console</span>. The following is the code implementation for this:</p>
<pre style="padding-left: 60px">Console.WriteLine("Hello World");<br/>CoordinatePoint classCoordinate = new CoordinatePoint(.82F, .34F);<br/>CoordinatePointStruct structCoordinate = new CoordinatePointStruct(.82F, .34F);<br/>Console.WriteLine("Initial Coordinates for Class are :" + classCoordinate.xCoordinate.ToString() + " " + classCoordinate.yCoordinate.ToString());<br/>Console.WriteLine("Initial Coordinates for Struct are :" + structCoordinate.xCoordinate.ToString() + " " + structCoordinate.yCoordinate.ToString()); </pre>
<ol start="5">
<li>Now write syntax to call the respective <kbd>ChangeValues</kbd> function for each of structure and class. After the call to the function, have another statement to print the current values in the attributes of the <kbd>struct</kbd> and <kbd>class</kbd> objects.</li>
</ol>
<p style="padding-left: 60px">Refer to the following code implementation for this:</p>
<pre style="padding-left: 60px">ChangeValuesClass(classCoordinate);<br/>ChangeValuesStruct(structCoordinate);<br/>Console.WriteLine("Initial Coordinates for Class are :" + classCoordinate.xCoordinate.ToString() + " " + classCoordinate.yCoordinate.ToString());<br/>Console.WriteLine("Initial Coordinates for Struct are :" + structCoordinate.xCoordinate.ToString() + " " + structCoordinate.yCoordinate.ToString()); </pre>
<ol start="6">
<li>Click on <span class="packt_screen">Build</span> | <span class="packt_screen">Build Solution</span> and ensure that there are no compile-time errors.</li>
<li>Click on <span class="packt_screen">Debug | Start Debugging</span>. Alternatively, the user can also click on the <em>F5</em> key or the triangular icon next to <span class="packt_screen">Start</span> to launch the debugger. Please refer to the following screenshots:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c28097a2-2eec-4160-94a0-8a6901ad53e5.png"/></div>
<p style="padding-left: 60px">Notice that the console shows the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/71aac2cf-d046-4d12-9d9c-ce9b41ab558a.png"/></div>
<p>Notice that, after calling the change function, the value of the <kbd>class</kbd> object gets modified. However, there is no change to the values in the struct.</p>
<p>This is due to the fact that <kbd>struct</kbd> is a value type variable. Therefore, any change in the object, outside the scope of the function, has no impact as the change happens at an entirely different object in memory.</p>
<p>On the other hand, <kbd>class</kbd> being a reference type variable is affected by changes happening outside the scope of the function as well. For this reason, changes are propagated back to the main object as well.</p>
<p class="mce-root"/>
<p>To summarize, the following table illustrates the main differences between a <kbd>struct</kbd> and a <kbd>class</kbd> type variable:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Feature</strong></td>
<td><strong>Class</strong></td>
<td><strong>Struct</strong></td>
</tr>
<tr>
<td>Default Constructor</td>
<td>If a class does not have a constructor, <span>then whenever an object is created for the class, the default constructor triggers and sets default values against the member variables present in the class. The default values are set in accordance with the default values of the type of those member variables.</span></td>
<td>In contrast to a class, a struct cannot have any default constructors. This means that the application doesn't assign a default value to the member variables of the struct.</td>
</tr>
<tr>
<td>Memory Implementation</td>
<td>As illustrated in the previous code example, a class is implemented as a reference type. This means that the value of an object of class is persisted across different scopes of the program execution.</td>
<td>As illustrated in the previous code example, a struct is implemented as a value type. This means that its value is not persisted across different scopes of the program.</td>
</tr>
<tr>
<td>Inheritance</td>
<td>We will be exploring inheritance in detail both in this chapter as well as in the next chapter. However, a class in C# can inherit from other classes.</td>
<td>In contrast to a class, a struct cannot inherit from other structs or classes. This implies that code reuse is slightly difficult in structs compared to in classes.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Based upon the preceding differences, depending upon the requirements, a developer can choose the right data type between a struct and a class.</p>
<p class="mce-root"><span>In the next section, we will look at how an interface is implemented in a C# application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interfaces and inheritance</h1>
                </header>
            
            <article>
                
<p>An interface is a collection of properties, methods, and events with just a declaration and no definition. We use them in programming to group together a set of functionalities that must be implemented in classes that, theoretically, are of the same basic type.</p>
<p>Let's look at an example of a car. In a real-world scenario, any implementation of the <kbd>Car</kbd> class must implement certain common basic features such as driving, stopping, and accelerating. Along with those, any object that is classified as a car will also have certain features specific to the make of the car, such as Honda or Nissan.</p>
<p>In the preceding example, an interface could help to promote code reuse and maintain structure across all types of <kbd>Car</kbd>. What we can do in this case is to declare <kbd>Car</kbd> as an interface that all car derivatives, such as Nissan or Honda must implement.</p>
<p>Similar to an interface, we can also implement <em>inheritance</em> in a C# application. In inheritance, we can define classes with certain methods and properties, which can then be inherited in a child class. In the next subsections, we will look at how interfaces and inheritance are implemented in a C# application.</p>
<div class="packt_infobox">Inheritance is one of the main pillars of OOP programming. In <a href="8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml">Chapter 3</a>, <em>Understanding Object-Oriented Programming</em>, we will look into more advanced features related to inheritance and understand how it works.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inheritance</h1>
                </header>
            
            <article>
                
<p>Inheritance is one of the main principles of any object-oriented programming. With inheritance, we can define attributes and functions that can be reused in child classes. In short, it helps us to reuse code written in the application across multiple modules. Let's go through an example to understand how inheritance helps us.</p>
<p>Let's consider two cars, <kbd>CarA</kbd> and <kbd>CarB</kbd>. From a very high-level perspective, we can think that both these classes will have similar features such as:</p>
<ul>
<li>A brake function</li>
<li>An accelerator function</li>
<li>A car type; that is, diesel/petrol and so on</li>
<li>Color</li>
<li>Gear type</li>
</ul>
<p>If we need to implement this in a C# application, one way would be to define them as two separate classes: <kbd>CarA</kbd> and <kbd>CarB</kbd> . However, the main concern with this approach is that both of these classes will need to have their own implementation of the shared features listed. Please refer the following code for how a possible implementation of <kbd>CarA</kbd> would look in C#:</p>
<pre>public class CarA<br/>{<br/>     public DateTime manufacturingDate;<br/>     public string bodyType;<br/>     public float fuelCapacity;<br/>     public void ImplementBrake()<br/>     {<br/>         Console.WriteLine("Inside Base Class Implement Brake");<br/>     }<br/>     public void ImplementAccelerator()<br/>     {<br/>         Console.WriteLine("Inside Base Class Implement Accelerator");<br/>     }<br/>     public void FoldableSeat()<br/>     {<br/>         Console.WriteLine("Inside Base Class Implement Accelerator");<br/>     }<br/> }</pre>
<p><span>Similarly, please refer to the following code for what a possible implementation of <kbd>CarB</kbd> would look like in C#:</span></p>
<pre>public class CarB<br/>{<br/>    public DateTime manufacturingDate;<br/>    public string bodyType;<br/>    public float fuelCapacity;<br/>    public void ImplementBrake()<br/>    {<br/>        Console.WriteLine("Inside Base Class Implement Brake");<br/>    }<br/>    public void ImplementAccelerator()<br/>    {<br/>        Console.WriteLine("Inside Base Class Implement Accelerator");<br/>    }<br/>    public void RoofTopExtendable()<br/>    {<br/>         Console.WriteLine("Inside Car B Foldable Seat");<br/>    }<br/> }</pre>
<p>This kind of implementation could have the following repercussions:</p>
<ul>
<li><strong>No code reuse</strong>: As you will understand from the preceding example, there are features that both <kbd>CarA</kbd> and <kbd>CarB</kbd> have in common. However, instead of maintaining common features separately, we are duplicating the code, which could cause maintenance issues as well.</li>
</ul>
<ul>
<li><strong>Scalability</strong>: From a business/implementation perspective, there could be millions of different types of cars. Thus, for every new <kbd>Car</kbd> or a new common feature added to the <kbd>Car</kbd> <span>implementation, we may face some scalability challenges in the application.</span></li>
</ul>
<p>As clearly illustrated, change management in such applications would be a nightmare and would be very difficult to carry out.</p>
<p>Now we will use the concept of inheritance and see how the preceding scenario could be implemented in a better way. From an implementation perspective, we will be creating a base class, <kbd>Car</kbd><span>, which will have all of the common member variables across different implementations of <kbd>Car</kbd>. We will then define individual types of <kbd>Car</kbd>, which will inherit from the base class, <kbd>Car</kbd></span>. Let's look at the <span>following</span> code example to understand this better:</p>
<ol>
<li>Create a base class, <kbd>Car</kbd>. The class will have all the member attributes that are common across <kbd>CarA</kbd> and <kbd>CarB</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public class Car<br/>{<br/>    public DateTime manufacturingDate;<br/>    public string bodyType;<br/>    public float fuelCapacity;<br/>    public void ImplementBrake()<br/>    {<br/>        Console.WriteLine("Inside Base Class Implement Brake");<br/>    }<br/>    public void ImplementAccelerator()<br/>    {<br/>        Console.WriteLine("Inside Base Class Implement Accelerator");<br/>    }<br/>}</pre>
<ol start="2">
<li>Create a class, <kbd>CarA</kbd>, which will inherit the base class. In C#, we use the<kbd>:</kbd> syntax to define inheritance:</li>
</ol>
<pre style="padding-left: 60px">public class CarA : Car<br/>{<br/>    public CarA()<br/>    {<br/>        this.bodyType = string.Empty;<br/>        this.manufacturingDate = DateTime.MinValue;<br/>        this.fuelCapacity = 0.0F;<br/>    }<br/>    public CarA(DateTime manufacturingDate, string bodyType, float fuelCapacity)<br/>    {<br/>        this.bodyType = bodyType;<br/>        this.manufacturingDate = manufacturingDate;<br/>        this.fuelCapacity = fuelCapacity;<br/>        Console.WriteLine("Inside Car A Constructor"); <br/>    }<br/>    public void FoldableSeat()<br/>    {<br/>        Console.WriteLine("Inside Car A Foldable Seat");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As indicated earlier, the attributes declared inside the parent class are automatically available in the derived class.</p>
<p style="padding-left: 60px">Please note that the attributes from the base class that will be available in the child class depend upon the access modifiers used against the corresponding attributes in the base class.</p>
<p style="padding-left: 60px">In our example, we have used <kbd>public</kbd> access modified in the base class. If it had been <kbd>private</kbd> or <kbd>protected internal</kbd>, its accessibility would have differed in the child class.</p>
<p style="padding-left: 60px">Let's consider a scenario wherein, for some reason, we also need to declare an attribute by the same name, <kbd>bodyType</kbd>, in <kbd>CarA</kbd>. In C#, we can differentiate between the attributes present in the base class and in the derived class by using the <kbd>base</kbd> keyword. Refer to the <span>following code</span> for this:</p>
<pre style="padding-left: 60px">public class CarA : Car<br/>{<br/>     string bodyType;<br/>     public CarA()<br/>     {<br/>         this.bodyType = string.Empty;<br/>         base.bodyType = string.Empty;<br/>         this.manufacturingDate = DateTime.MinValue;<br/>         this.fuelCapacity = 0.0F;<br/>     }</pre>
<p style="padding-left: 60px">If <kbd>base</kbd> is used, it refers to the attribute in the parent class and, if <kbd>this</kbd> is used, it refers to the attribute in the child class.</p>
<p class="mce-root"/>
<ol start="3">
<li>Similarly, declare a class for <kbd>CarB</kbd>:</li>
</ol>
<pre style="padding-left: 60px">class CarB : Car<br/>{<br/>    public CarB()<br/>    {<br/>        this.bodyType = string.Empty;<br/>        this.manufacturingDate = DateTime.MinValue;<br/>        this.fuelCapacity = 0.0F;<br/>    }<br/>    public CarB(DateTime manufacturingDate, string bodyType, float fuelCapacity)<br/>    {<br/>        this.bodyType = bodyType;<br/>        this.manufacturingDate = manufacturingDate;<br/>        this.fuelCapacity = fuelCapacity;<br/>        Console.WriteLine("Inside Car B Constructor");<br/>    }<br/>    public void RoofTopExtendable()<br/>    {<br/>        Console.WriteLine("Inside Car B Foldable Seat");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Please note that, in derived classes, we can also create member variables independent of the base classes. As indicated in the preceding screenshots, the <kbd>CarA</kbd> class has an implementation of <kbd>FoldableSeat</kbd>, which is not present in the base class.</p>
<p style="padding-left: 60px">Similarly, the <kbd>CarB</kbd> class has an implementation of <kbd>RoofTopExtendable</kbd>, which is not present in the base class.</p>
<ol start="4">
<li>In the main method, declare the <kbd>CarA</kbd> and <kbd>CarB</kbd> objects and call the respective methods:</li>
</ol>
<pre style="padding-left: 60px">CarA carA = new CarA();<br/>carA.ImplementAccelerator();<br/>carA.ImplementBrake();<br/>carA.FoldableSeat();<br/><br/>CarB carB = new CarB();<br/>carB.ImplementAccelerator();<br/>carB.ImplementBrake();<br/>carB.RoofTopExtendable();<br/>Console.ReadLine();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="5">
<li>Click on <span class="packt_screen">Build <span><span>|</span></span></span> <span class="packt_screen">Build Solution</span>. Notice that there are no compile-time errors. Now click on <span class="packt_screen">Debug</span> | <span class="packt_screen">Start Debugging</span>. Notice that the <span>following</span> output comes up in the console window:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e889716e-6f6f-40b2-adca-06de90d89a62.png"/></div>
<p><span>The following</span> provides a brief analysis of each of the output line items:</p>
<ul>
<li>The first method we call is <kbd>ImplementAccelerator</kbd>, which is present in the base class. As expected, it executes the method in the base class.</li>
<li>Similarly, the next method we call is <kbd>ImplementBrake</kbd>, which is also present in the base class. In this case also, the method in the base class is executed.</li>
<li>In the next call, we execute a method just present in <kbd>CarA</kbd>. In this case, the control executes the code present in that function.</li>
<li>The same thing applies to B as well.</li>
</ul>
<p>Thus, using inheritance, we can promote a greater degree of code reuse, along with making the maintenance activity quite scalable.</p>
<p>Once we move on to <a href="8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml">Chapter 3</a>, <em>Understanding Object-Oriented Programming</em>, we will cover more features in regard to inheritance, such as overriding sealed, abstract classes and so on. However, for now, we will go over how an interface helps us in C# code development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interfaces in C#</h1>
                </header>
            
            <article>
                
<p>In the preceding example, we illustrated how we can declare a base class with some member variables and have them inherited in a derived class. However, there could be some scenarios when we need to have a class inherited from two different classes. Moreover, if we are using a struct, we will not be able to inherit from another struct or class.</p>
<p>Unfortunately, using inheritance, we will not be able to achieve this in a C# application due to the <span>following</span> reasons:</p>
<ul>
<li>Multiple inheritance is not allowed in C#.</li>
<li>A struct data type in C# cannot inherit from other structs <span>or</span> <span>c</span>lass types.</li>
</ul>
<p>In such scenarios, interfaces come in handy. An interface defines a set of related methods, attributes which each class implementing the interface must implement. Please note that an interface must have just declarations.</p>
<div class="packt_infobox">In reference to interfaces, a declaration refers to the specification of the methods along with their signatures – that is, input and output parameters – while a definition refers to the actual implementation of the logic in the method body. While discussing the <span>following</span> code example, we will look further into this.</div>
<p>Let's look at the example we used for inheritance and see how we can use an interface in it:</p>
<ul>
<li>In the preceding example, wherein we created <kbd>CarA</kbd> and <kbd>CarB</kbd>, we can deduce that it is bound to have several other properties as well, such as color, weight, height, brand, logo, manufacturer, and so on.</li>
<li>From a data model perspective, we can classify them as attributes common to any <em>utility or product</em> rather than just a car.</li>
<li>So, when we are choosing a product, we can say that there are certain actions, such as <kbd>ImplementBrand</kbd>, <kbd>ImplementColor</kbd>, and so on that will be common across all the product implementations and not just for <kbd>CarA</kbd> and <kbd>CarB</kbd>.</li>
<li>Therefore, it means that the two classes must inherit from both <kbd>Car</kbd> and <kbd>Product</kbd> to function correctly.</li>
</ul>
<p class="mce-root"/>
<p>Let's try and create another base class of <kbd>Product</kbd> and try to implement multiple inheritance for <kbd>CarA</kbd>. Here's the <span>following</span> code implementation for the <kbd>Product</kbd> class:</p>
<pre>public class Product<br/>{<br/>    public void ImplementBrand()<br/>    {<br/>        Console.WriteLine("Inside Base Class Implement Brake");<br/>    }<br/>    public void ImplementColor()<br/>    {<br/>        Console.WriteLine("Inside Base Class Implement Accelerator");<br/>    }<br/>}</pre>
<p>However, when we try to implement multiple inheritance for the <kbd>CarA</kbd> class, the compiler gives us an error. The following screenshot shows the error we get from the compiler:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4ede8a7f-a14b-4e28-a3c9-66ecb6904c44.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>A solution would be to merge the implementations of <kbd>Car</kbd> and <kbd>Product</kbd> together; however, it's clear that from a data model perspective, these two entities are not related to each other.</p>
<p>To overcome the preceding dilemma, we will use an interface. When declaring an interface, we need to adhere to the following conventions:</p>
<ul>
<li>To declare an interface, we need to use the <kbd>interface</kbd> keyword.</li>
<li>An interface cannot have an access modifier for any function declaration.</li>
<li>An interface must also just have function declarations and no definitions.</li>
</ul>
<p><span>The following</span> is the code syntax of the <kbd>ICar</kbd> interface, wherein we are declaring the methods that should be in the interface:</p>
<pre>public interface ICar<br/>{<br/>     void ImplementBrake(); <br/>     void ImplementAccelerator();<br/>     void ImplementBrand();<br/>     void ImplementColor();<br/> }</pre>
<div class="packt_infobox">Please note that, in the preceding example, we have only specified the signature that the methods present in the interface should acquire. This is referred to as a declaration. The class implementing this interface – in our case, <kbd>Car</kbd>, will be responsible for providing complete implementation for the methods presents in the interface.</div>
<p>To implement an interface, we can use syntax similar to inheritance. The following is the screenshot for this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9c7acb08-c14f-42e6-9a75-9efc4f39209c.png" style=""/></div>
<p> </p>
<p><span>Review the compile-time error. The error indicates that the <kbd>Car</kbd> class must implement all the functions declared in the interface.</span> To overcome the preceding error, we must define all the functions in the interface. Similar to <kbd>ICar</kbd>, we can also create an interface for <kbd>IProduct</kbd>, which each of the <kbd>CarA</kbd> and <kbd>CarB</kbd> classes can then implement.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p> </p>
<p>While inheritance and interfaces can be used in similar scenarios, some of the differences between them are as follows:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Feature</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Inheritance</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Interface</strong></td>
</tr>
<tr>
<td>Multiple derivations</td>
<td>A class can only inherit from one class.</td>
<td>A class can implement multiple interfaces.</td>
</tr>
<tr>
<td>Data types</td>
<td>A class can inherit from another class. However, a struct cannot inherit from another class or struct.</td>
<td>Both classes and structs can implement interfaces.</td>
</tr>
<tr>
<td>Method definitions</td>
<td>In inheritance, a base class can define methods.</td>
<td>An interface cannot have any definitions<br/>
against methods.</td>
</tr>
<tr>
<td>Access modifiers</td>
<td>
<p class="mce-root">A base class and its member attributes can assume different access modifiers, such as <kbd>public</kbd>, <kbd>private</kbd>, <kbd>protected</kbd>, <kbd>protected internal</kbd>, and <kbd>private protected</kbd>.</p>
</td>
<td>The access modifier of an interface is always public.</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span>Based on these differences, a programmer can decide the right approach for their application and choose between creating an interface or managing through inheritance.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The topics covered in this chapter are the basics of programming in the C# language. Using access modifiers, we can control access to different properties and methods in different modules of an application. While writing the code, a very common mistake that people make is to declare all the properties and methods as public. This is not the recommended way of programming in C#. We must logically evaluate the need for different access modifiers for each of the properties and methods present in a class.</p>
<p>Similarly, we should analyze the data types that we need to associate with each property used in the class. We must also analyze if we need a reference data type variable, or whether we are fine with a value type variable as they have a different implementation in the compiler memory and functionality. We should also utilize inheritance as it helps us to reuse code and structure our programs in a very precise manner.</p>
<p>In the next chapter , we will go through OOP concepts, which are the main building blocks of any high-level programming language like C#. We will go over polymorphism, abstraction, encapsulation, and inheritance and understand each of these concepts in detail, and will also go over some code examples to see their implementation.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which of the <span>following</span> attributes declared in the <kbd>Car</kbd> class is not a <em>value type</em> variable?
<ol>
<li><kbd>public Decimal fuelCapacity;</kbd></li>
<li><kbd>public Enum carColor;</kbd></li>
<li><kbd>public String registrationNumber;</kbd></li>
<li><kbd>public Int numberOfSeats</kbd></li>
</ol>
</li>
<li>Which of the <span>following</span> is not a reference type variable?
<ol>
<li>Class</li>
<li>String</li>
<li>Struct</li>
<li>Interface</li>
</ol>
</li>
<li>In C#, a child class can inherit from multiple parent classes. Is this statement correct?
<ol>
<li>Yes</li>
<li>No</li>
</ol>
</li>
<li><span>Which of the following statements about interfaces and classes is not correct?</span>
<ol>
<li>A class can implement multiple interfaces.</li>
<li>An interface can have both function declarations and definitions.</li>
<li>A struct data variable cannot inherit from another struct.</li>
<li>In inheritance, if both the base class and the derived class have a function with the same name, we can use the <em>base</em> keyword to implicitly call the function of the base class.</li>
</ol>
</li>
<li>Which of the following statements about access modifiers is not correct?
<ol>
<li>If a member variable is declared as <kbd>public</kbd>, it can be accessed across the entire application.</li>
<li>If a member variable is declared as <kbd>private</kbd>, it can only be accessed in the same class.</li>
<li>If a member variable is declared as <kbd>protected</kbd>, it can be accessed throughout the namespace.</li>
<li>If a member variable is declared as <kbd>protected internal</kbd>, it can be accessed by classes in the name namespace and the classes that derive from it.</li>
</ol>
</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Answers</h1>
                </header>
            
            <article>
                
<ol>
<li><kbd>public String registrationNumber;</kbd>. String is a reference type variable. All others are value type variables.</li>
<li><strong>Struct</strong> is a value type variable unlike all others which are reference type variables.</li>
<li><strong>No</strong>, in C# we cannot have multiple inheritance. A class can only inherit from one base class.</li>
<li>In C#, an interface must only have function declarations and not definitions. All other statements are correct.</li>
<li>If a member variable is declared as <kbd>protected</kbd>, it can only be accessed in the classes that inherit from its base parent class.</li>
</ol>


            </article>

            
        </section>
    </body></html>