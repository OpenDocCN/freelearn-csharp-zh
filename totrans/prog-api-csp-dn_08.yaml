- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will examine a few advanced topics not covered elsewhere
    in the book. This includes Implementing an Advanced API using a more complex data
    structure, Storage Tables, and the very exciting new (at the time of this writing)
    Aspire feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an advanced API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Azure Storage Tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspire dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Aspire to existing projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Azure.Data.Tables** NuGet package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure account (you can get a free starter account at [https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)
    ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspire comes with Visual Studio 2022 (version 17.10 or higher) and requires
    . NET 8.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will need to install Docker Desktop (which is free and can be obtained at
    [https://www.docker.com/Products/docker-desktop/](https://www.docker.com/Products/docker-desktop/)
    ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found in the GitHub repository here:
    [https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter08](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an advanced API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we’ve been working with a very simple database, and implementing
    pretty straightforward APIs. From time to time, however, your client will ask
    for something more difficult or complex. Let’s take a look at one such requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client has asked for the ability to see a car with all its options. We’ll
    provide that in JSON for easy display on the web, phone, and so on. The JSON will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement this, we’ll need to add a table to the database: **Options** .'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to track various features (options) the user may select, such as a
    sunroof, the winter package, and so on. To do this, we will create a new table,
    **Options** , which will have four columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**car_id** : The ID of the car to which this option will be added'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**option_id** : The ID of the option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**option_name** : The name of the feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**option_price** : The MSRP for this feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a sample of the **Options** table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Sample rows from the Options table](img/B21998_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Sample rows from the Options table
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to create at least 10 rows using arbitrary values. Note that there
    is no table with the option names and values. This is a simple mostly non-relational
    database, though you are free to add such tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this table, we can create our one relationship; that is between the **car**
    table and the **Options** table. Add **car_id** to the **car** table, and create
    our **Select** statement with a join to the options table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like the **car** table, but has the options for each car appended
    to the end, as shown in *Figure 8* *.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Joined tables](img/B21998_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Joined tables
  prefs: []
  type: TYPE_NORMAL
- en: Note that your table will look a bit different as I’ve cut out the middle to
    make it fit the page.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the option values are appended to the **car** rows. This is
    just what we need.
  prefs: []
  type: TYPE_NORMAL
- en: For most applications, this would be sufficient, however, our client has asked
    for the JSON structure shown in the code under the *Implementing an advanced*
    *API* heading.
  prefs: []
  type: TYPE_NORMAL
- en: This will be a bit tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a class to represent the entire row, with the car and the options together.
    Each instance of the class will represent one full row in the table, as shown
    in *Figure 8* *.2* . Let’s call that class **carFlat** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that **CarFlat** inherits from **Car** , picking up all the properties
    of **Car** and adding the properties of **Options** (along with **car_id** ).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In my programming, I typically use Pascal case (initial cap) for properties.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need a class to represent the row without the options (representing
    the car) but each car will have a collection of options. Let’s call that class
    **carDto** as it will be our **data transfer object** ( **DTO** ) for the car.
  prefs: []
  type: TYPE_NORMAL
- en: We will be passing options around, so let’s create an **OptionsDto** class as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what they look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The important thing to note here is that **CarDto** has a property that is
    the list of all this car’s options; notice that the final property is a list of
    **OptionsDtos** . Let’s look at that class now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is **OptionsDto** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice the capitalization and absence of underscores in the DTO.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to link the DTO to the **Car** object. That is what profiles are
    for.
  prefs: []
  type: TYPE_NORMAL
- en: The profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll need a profile to map the various classes to one another. The DTO is used
    to transfer the object (hence the name) but it must be mapped to the original
    object. Thus, we want to map **Car.Dto** to the **Car** class.
  prefs: []
  type: TYPE_NORMAL
- en: This is the trickiest part, and mapping is what makes this all work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first map is pretty straightforward, mapping the **Car** to **CarDto**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We start by identifying the types in the map, and then for each member, we map
    using Lambda expressions. Note the last line, **.ReerseMap** – this saves us the
    trouble of re-writing the entire map going the other way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the heart of the program, mapping **CarFlat** to **CarDto** and
    mapping **OptionsDto** to **CarFlat** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The magic is performed by AutoMapper. If you have not installed AutoMapper yet,
    this is a good time to do so. AutoMapper will make this job infinitely easier.
    AutoMapper simplifies the mapping process between different object models, reducing
    the need for manual transformations. All we need to do is tell AutoMapper to map
    from one class to another, as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the profile written, we’ll go back to the controller. Here, we’re going
    to map **CarDto** to the car. Notice the next to last line of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Nothing new or special here, but note that at the bottom of the method, we use
    a mapper to turn our car into a DTO, which is what we return to the client application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only logic in **CarService** is to ensure we have a valid car ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings us to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The method is surprisingly simple. We set up and execute the query. Notice
    that we are using **QueryAsync** and **ToList** as if we were getting all the
    cars. Actually, what we are getting is a list of the options for a single car,
    as shown in the next listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Beautiful! This should look familiar, as it is what we specified at the beginning
    of the chapter. Each car has its options as a sub-set in the JSON. This will make
    it much easier to display the cars with their options (e.g., on a web page). Tuck
    this in your pocket; you don’t use it often, but when you need to make this kind
    of display, the technique is powerful but not obvious.
  prefs: []
  type: TYPE_NORMAL
- en: In this next section, we will introduce Azure Storage Tables, a powerful yet
    simple way to store data.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Storage Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Storage Tables** are a great way to persist relatively simple data structures.
    Creating and using storage tables is quick and easy.'
  prefs: []
  type: TYPE_NORMAL
- en: Azure offers a number of ways to store your data. The most popular are SQL Server,
    Cosmos, and storage tables. Storage tables are the most limited, but they are
    also the simplest generally speaking, and the fastest to create. They are very
    popular for keeping track of simple information. For example, you might use storage
    tables to record each time you send a message or each time something anomalous
    happens. For these examples, you would enter one row per incident, as described
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storage tables are not inherently relational. While you can index, it isn’t
    simple, and it isn’t particularly powerful. The reason behind all this is to keep
    storage tables simple. This makes them ideal for keeping lists, logging, creating
    progress entries, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a storage table that tracks exceptions thrown during the execution
    of our program. The table we create will look like this on Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The left portion of a storage table](img/B21998_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – The left portion of a storage table
  prefs: []
  type: TYPE_NORMAL
- en: Due to space concerns, I’m not showing the entire table here. There are columns
    for the exception type, the time of the exception, the message, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things as simple as possible, and to focus 100% on Table Storage, we’ll
    create a console application that simply throws exceptions and stores them in
    the table. To get started, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project and select **Console App** , as shown in *Figure 8* *.4*
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Selecting console app](img/B21998_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Selecting console app
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Next** and fill in your project name (I used **TableStorageConsoleApp**
    ), its location on your local disk, and the name of the solution (typically the
    same as your project). Click **Next** and select **.NET 8** (or later) and, most
    important, check **Do not use top-level statements** , as shown in the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Additional information](img/B21998_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Additional information
  prefs: []
  type: TYPE_NORMAL
- en: Click **Create** and your console app will be created, complete with a main
    entry point and a single line of code, writing the canonical “Hello, World” greeting.
    You can delete that line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To keep things simple, we’ll have **Main** call **ThrowException** , a method
    we’ll write that will throw a random exception every two seconds. Thus, **Main**
    is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see that **ThrowException** is enclosed in a forever loop and will continue
    until you close the program. Putting in a more sophisticated way to stop it is,
    as they say, left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The job of **ThrowException** is, as said earlier, to throw exceptions randomly.
    For this, I need nothing more than a **random** generator and a **switch** statement.
    We begin by enclosing the random generation of exceptions within a try statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we can catch each exception and write it to our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There’s quite a bit to see here. We begin by creating **TableModel** . We’ll
    create that data structure in just a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Within that model, we’ll have **PartitionKey** and **RowKey** . These are critical
    to **TableStorage** . Together, they make the unique identifier for each row in
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: All of the entries with the same **PartitionKey** are clustered, and in that
    cluster are all their **RowKeys** . This makes retrieval infinitely faster. Rather
    than having to scan through all the **RowKeys** , retrieval can be achieved by
    jumping to the right **PartitionKey** and searching from there.
  prefs: []
  type: TYPE_NORMAL
- en: We also store the exception’s message and the current time as a timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: '**TableServiceClient** is supplied by the NuGet package (see requirements at
    the beginning of this chapter). The address you’ll initialize with is supplied
    by Azure as shown later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: We then call **UpsertEntityAsync** , passing in the entity we created earlier,
    and go to sleep for two seconds (the amount of time you sleep is entirely up to
    you).
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you will need your own **AccountKey** and preferably your own
    **accountName** .
  prefs: []
  type: TYPE_NORMAL
- en: TableModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I promised earlier to show you the **TableModel** . It is quite simple, just
    enough to capture the essential information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that **ETag** must be in every table model. This is used for optimistic
    concurrency during updates. We won’t be doing updates and don’t care about this
    except that it must be there.
  prefs: []
  type: TYPE_NORMAL
- en: StorageTableService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The heart of the application is **StorageTableService** . Here is where **UpsertEntityAsync**
    lives, which does the work of interacting with our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started, we declare two member variables at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the second member is of type **Task<Response<TableItem>** . Both
    **Response** and **TableItem** are supplied by the Azure NuGet package. The constructor
    takes **TableServiceClient** (also supplied in the same NuGet package).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is here that we create the table if it doesn’t exist and name it **ExceptionsTable**
    (feel free to name yours whatever you like).
  prefs: []
  type: TYPE_NORMAL
- en: All the **Upsert** method needs to do is call **tableCreationTask** and wait
    to get back **Response<TableItem>** . With that in hand, it is ready to call **GetTableClient**
    on **TableServiceClient** , passing in the name of the table. Finally, we call
    **UpsertEntityAsync** on the table passing in **TableModel** .
  prefs: []
  type: TYPE_NORMAL
- en: Please make sure you understand the previous paragraph as it is the heart of
    working with **StorageTables** .
  prefs: []
  type: TYPE_NORMAL
- en: Populating the table in Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With what we’ve written, populating the table in Azure is automatic. Run the
    program; your output should look something like *Figure 8* *.6* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Generated exceptions](img/B21998_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Generated exceptions
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need an Azure account for this part. As noted earlier, you can get a
    free starter account at the link provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go to Azure and see what we’ve got:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to your account and click on **Home** and then on **Storage browser**
    , as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Storage browser](img/B21998_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Storage browser
  prefs: []
  type: TYPE_NORMAL
- en: From there, click on your **TableStorage** account. That will bring up a dashboard.
    Click on **Tables** , as shown in *Figure 8* *.8* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Selecting tables](img/B21998_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Selecting tables
  prefs: []
  type: TYPE_NORMAL
- en: You should be brought to a page where your tables should be listed as links.
    Click on the table we created. The entries that match what we saw in the application
    will pop up, as shown (in part) in *Figure 8* *.9* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The table on Azure](img/B21998_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – The table on Azure
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the entries are not in the order in which they were created. Rather,
    they are clustered by **PartitionKey** , as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Shockingly, that’s all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Microsoft Aspire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft has introduced Aspire, which it describes as *opinionated, cloud ready
    stack for building observable, Production-ready, distributed applications.* Say
    what?
  prefs: []
  type: TYPE_NORMAL
- en: In this case, *opinionated* means that there are conventions and templates to
    make life easier. With this and all things, you can customize, but the more you
    follow the conventions, the easier it is to write, and perhaps more important,
    to read your code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cloud-ready stack* indicates that you will be working locally but on code
    that can easily be moved to the cloud (read Azure). *Production-ready* indicates
    that what you build will be non-trivial and ready to roll out, and *distributed*
    means that you will be creating micro-services hosted in containers, in our case,
    Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Aspire provides you with a number of services that you could write yourself,
    but no longer have to. Instead, you get fully tested code *automagically* that
    provides, among other things, storage, messaging, and web services, and that can
    also provide interoperability with databases, caching, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can use Aspire with Visual Studio Code or even the .NET CLI, but we’ll stick
    with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Sample program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aspire is very powerful, but it can be tricky to get all the pieces in place.
    We *could* write our own sample program, but that would be silly since Microsoft
    supplies one that you can create with just a few keystrokes in Visual Studio.
    To get started, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project and select **.NET Aspire Starter Application** . Be sure
    to choose the one for C#, as shown in *Figure 8* *.10* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 - Choosing Aspire](img/B21998_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 - Choosing Aspire
  prefs: []
  type: TYPE_NORMAL
- en: Enter a project name (I’ll use **AspirePackt** ) and leave the rest of the values
    as their defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the next page, make sure you select **.NET 8** and **Use Redis for caching**
    , and while you always should create unit tests, we’ll skip that for now (in a
    “real” application, you want those unit tests), as shown in *Figure 8* *.11* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Selecting the frameworks](img/B21998_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Selecting the frameworks
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we’re going to see: a sample weather app that supports caching.
    It will get the weather through an API, using random, demonstration values.'
  prefs: []
  type: TYPE_NORMAL
- en: Start the app up and the first thing that will happen is that the .NET Aspire
    dashboard will open in your browser, as partly shown in *Figure 8* *.12* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Aspire dashboard](img/B21998_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Aspire dashboard
  prefs: []
  type: TYPE_NORMAL
- en: This was all created for you in the sample program, which also created a Blazor
    application that will be used to display the data retrieved by the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the third line’s project in *Figure 8* *.13* is **webfrontend**
    . Click on the URL and you are brought to the iconic **Hello, world!** page. On
    the left are three buttons, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – The running application](img/B21998_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – The running application
  prefs: []
  type: TYPE_NORMAL
- en: Now click on the **Weather** option and *voilà* ! The API is hit, and the weather
    data is displayed, as shown in *Figure 8* *.14* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – The displayed weather from the API](img/B21998_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – The displayed weather from the API
  prefs: []
  type: TYPE_NORMAL
- en: If you refresh the screen a few times, you’ll see that it is instantly responsive
    as it is using the cache. After about 10 seconds, it will generate new data.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Aspire dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going back to *Figure 8* *.12* , we see a number of useful features. Click on
    **Resources** , for example, to see a list of information for all the .NET projects
    in your application. These include the app state, endpoints, and environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Console** displays (surprise!) the console output from each project.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Structured** option displays logs as tables. You can filter and search
    (either free-form or filtered). You can expand the details for each entry by clicking
    on the **View** button on the far right.
  prefs: []
  type: TYPE_NORMAL
- en: The **Traces** button displays the request paths throughout your application.
    Locate a request for **Weather** and select **View** . The dashboard will display
    the request in stages.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **ApiService | View** and you’ll see the time it took to hit the API.
    Click on **View** on the right and the resources are displayed in detail. Scroll
    down to see more details.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the **Metrics** button will display instruments and meters, as they
    are available for your application.
  prefs: []
  type: TYPE_NORMAL
- en: What have you learned, Dorothy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, the sample application consists of a number of projects. The
    first, perhaps most essential is the app host, which acts as the orchestrator.
    It will automatically set **IsAspireHost** in the project file to true.
  prefs: []
  type: TYPE_NORMAL
- en: Pour through the **Program.cs** file and you’ll see what you’d expect as an
    API developer, along with Aspire in **APIService** (and a couple of things added
    for Blazor).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the first line creates **DistributedApplication** using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: A critical line in this file is **AspirePackt.ApiService** , which configures
    the service discovery and communication among the projects in your solution. The
    name ( **apiservice** ) identifies the project and is used by projects that want
    to communicate with it.
  prefs: []
  type: TYPE_NORMAL
- en: Another important and universal project is **ServiceDefaults** , which is a
    shared project that manages configurations so that they can be used across projects.
    This allows the application to have all the services share service discovery,
    telemetry, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Aspire to an existing app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all love green-field projects, but the reality is that most of the time we’re
    working with existing code. Aspire would not be very interesting if it only worked
    from scratch, but fortunately, you can add Aspire to existing applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could add Aspire to our car application, but once again, Microsoft assists,
    providing a reasonably complex application for us to work with. To get started,
    clone their application by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This sample consists of three projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Data Entities is a class library that defines the **Product** class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Products** is a web API that returns a list of all the Products in the store’s
    catalog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Store** is a Blazor web app that displays the products on a website'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we will not be focusing on Blazor. We will use it only as far as it
    is part of this example
  prefs: []
  type: TYPE_NORMAL
- en: Getting oriented with our new project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at what the new project (out of the box) looks like. To do
    so, follow these steps to create our “existing” project that we will add Aspire
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [eShopLite.sln](http://eShopLite.sln) . Right-click on the solution and
    select **Configure** **Startup Projects** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose multiple startup projects and in the **Action** column, select **S**
    **tart** for **Products and Store** , as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Setting the startup projects](img/B21998_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Setting the startup projects
  prefs: []
  type: TYPE_NORMAL
- en: Fire it up by pressing *F5* and note that two browser pages open. One page has
    the raw JSON and the second page is a simple browser application that lets you
    view that data (click on **Products** ), as shown in part in *Figure 8* *.15*
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.16 – The raw JSON](img/B21998_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – The raw JSON
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the JSON is a checkbox for pretty print. That will take this
    raw JSON and make it more readable, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Pretty print](img/B21998_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Pretty print
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor will give you a web-based view of that same data, as shown in *Figure
    8* *.18* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – The browser display of the products](img/B21998_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – The browser display of the products
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a working application, let’s refactor it to add Aspire. We’ll
    do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Aspire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a working API solution, let’s add Aspire. To do so, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on one of the projects (I’ll use **Store** ) and select **Add**
    | **.Net Aspire Orchestrator Support** . That brings up the dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **OK** and two new projects are added to your solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**eShopLiteAppHost**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eShopLite.ServiceDefaults**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Spend a few minutes exploring these projects. The first, **eShopLiteAppHost**
    , is an orchestrator project whose job is to connect (and configure) the various
    projects and services of your application. It is automatically set as the startup
    project. **eShopServiceDefaults** holds configurations that will be used across
    projects, especially service discovery and telemetry (more about these shortly).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open **Program.cs** in **AppHost** , where you will see this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This registers the store project in the orchestrator. We now need to register
    the **Products** project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on it and select **Add** | **.NET Aspire Orchestrator Support**
    . You’ll get a dialog saying the orchestrator already exists; just click **OK**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to **AppHost** / **Program.cs** and you can see that another line has
    been added, as you might expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now comes the fun part. **Store** needs to be able to find **Products** ’ backend
    address. Rather than doing this by hand, we turn that responsibility over to the
    orchestrator.
  prefs: []
  type: TYPE_NORMAL
- en: Discovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While both projects are registered with the orchestrator, **Store** needs to
    be able to discover the **Products** ’ backend address. To enable discovery, return
    to **Program.cs** and add a reference to the **Products** project. Your **program.cs**
    file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to deploy this application, you’ll need to call **WithExternalHttpEndpoints**
    to make sure it is public to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost done. We need to update **appsettings.json** in the **Store** project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The addresses for both endpoints now use the **Products** name. Note that these
    names are used to discover the address of the **Products** project.
  prefs: []
  type: TYPE_NORMAL
- en: Press *F5* to run it. You’ve added Aspire, with all its features and dashboard,
    to your existing API project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about three very powerful, advanced techniques.
    First, we looked at creating more complex APIs that return hierarchical data.
    We did this by adding and presenting options for each car type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at Azure Storage Tables, a lightweight way to store data on
    Azure, side-stepping the complexity of Entity Framework and Cosmos.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we went on to look at Microsoft’s Aspire dashboard, a very powerful
    and useful tool for working with APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at the critical issue of authentication and
    authorization, without which you cannot create an enterprise API.
  prefs: []
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating an Aspire dashboard is pretty straightforward out of the box, but
    creating hierarchical data is not. To take on a challenge, create a program that
    displays a few states and with them their principal cities. The result might look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to make up the longitude and latitude, or look it up online. You’ll
    want at least two to three cities and two to three states. Once you have your
    structure, save it as a flat file in an Azure Storage Table.
  prefs: []
  type: TYPE_NORMAL
