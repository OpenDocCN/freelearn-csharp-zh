<html><head></head><body>
		<div><h1 id="_idParaDest-175" class="chapter-number"><a id="_idTextAnchor197"/>8</h1>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor198"/>Adding Windows Notifications to WinUI Applications</h1>
			<p>The Windows App SDK provides<a id="_idIndexMarker602"/> developers with the ability to implement <strong class="bold">raw push notifications</strong> and <strong class="bold">app notifications</strong> in their WinUI apps. It’s important<a id="_idIndexMarker603"/> to understand the use case for each of these notification types. They have different implementations, and each has its own set of advantages and limitations. Push notifications<a id="_idIndexMarker604"/> can be surfaced to the user or received by the app to perform internal operations. App notifications, on the other hand, are used to communicate with the user. We’ll cover examples of when you would want to use a particular notification type and add an app notification to the <strong class="bold">My Media Collection</strong> sample application.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding the different notification types in the Windows App SDK and the use case for each type</li>
				<li>Discovering how to leverage push notifications in a WinUI application</li>
				<li>Exploring how to use app notifications with WinUI</li>
			</ul>
			<p>By the end of this chapter, you will understand the differences between push notifications and other app notifications exposed by the Windows App SDK. You will understand when to choose each notification type and how they are handled in a WinUI 3 projec<a id="_idTextAnchor199"/>t.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor200"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, the following software is required:</p>
			<ul>
				<li>Windows 10 version 1809 (build 17763) or newer</li>
				<li>Visual Studio 2022 or later with the .NET Desktop Development workload configured for Windows App SDK development</li>
			</ul>
			<p>The source code for this chapter is available on GitHub at this URL: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter08">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter08</a>.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor201"/>Overview of push notifications in the Windows App SDK</h1>
			<p>WinUI applications can leverage different<a id="_idIndexMarker605"/> types of notifications in the Windows App SDK. The notifications APIs were added in Windows App SDK 1.3 and can be either sent locally or through a cloud service, depending on the notification type. We most often associate notifications<a id="_idIndexMarker606"/> with the small, pop-up windows in the corner of the screen, called <strong class="bold">toast notifications</strong>, in Windows. However, a visual indicator isn’t required for all notifications. They can also be used to signal your app to activate and perform an action or sync data from a remote service without relying on a timer in the app.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor202"/>Raw push notifications</h2>
			<p>These internal<a id="_idIndexMarker607"/> notifications are known as <strong class="bold">raw push notifications</strong>. They require no<a id="_idIndexMarker608"/> user interaction<a id="_idIndexMarker609"/> and don’t signal the user with a <strong class="bold">toast notification</strong>. Push notifications leverage the <strong class="bold">Windows Push Notification Services</strong> (<strong class="bold">WNS</strong>), which is part of the <strong class="bold">Microsoft Store</strong> services. To publish an application <a id="_idIndexMarker610"/>in the Store or leverage<a id="_idIndexMarker611"/> any of its services, a Store account is required, and your app must be registered in the Store’s dashboard.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will discuss publishing apps to the Microsoft Store in <a href="B20908_14.xhtml#_idTextAnchor582"><em class="italic">Chapter 14</em></a>, <em class="italic">Packaging and Deploying WinUI Applications</em>. We won’t cover the Store registration process in this chapter, but you can skip ahead to review the process in <a href="B20908_14.xhtml#_idTextAnchor582"><em class="italic">Chapter 14</em></a> if it’s new to you.</p>
			<p>Push notifications from WNS can be received directly by the app to signal the app to perform some action. In fact, your app doesn’t need to be active to receive a notification. Windows will activate the app so it can process the notification and perform the requested action. Using notifications saves device resources and can reduce or eliminate the need for polling and timers.</p>
			<p>Notifications<a id="_idIndexMarker612"/> from WNS may<a id="_idIndexMarker613"/> also notify the user. This is one type of app notification.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor203"/>Cloud-based app notifications</h2>
			<p>App notifications involve notifying<a id="_idIndexMarker614"/> the user that some event has occurred or action<a id="_idIndexMarker615"/> is required. App notifications can be local or originate from the cloud. The cloud-based notifications, like raw notifications, leverage WNS.</p>
			<p>The process for creating and sending these app notifications is similar to creating raw push notifications. The header and content types will distinguish the app notifications and signal Windows to display a visible, transient notification. Any notifications that haven’t been dismissed or cleared by the user can be viewed in Windows settings in <strong class="bold">Notification Center</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Certain types of self-contained apps or apps running with admin privileges may not be eligible to receive notifications. To view more information about these limitations, you can review this section of the push notifications<a id="_idIndexMarker616"/> documentation on Microsoft Learn: <a href="https://learn.microsoft.com/windows/apps/windows-app-sdk/notifications/push-notifications/#limitations">https://learn.microsoft.com/windows/apps/windows-app-sdk/notifications/push-notifications/#limitations</a>.</p>
			<p>App notifications can also be local to the user’s PC. Let’s discuss this type of notification next.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor204"/>Local app notifications</h2>
			<p>Local app notifications <a id="_idIndexMarker617"/>do not involve the cloud and WNS is not involved in sending<a id="_idIndexMarker618"/> the notification. They originate from your app, are displayed to the user, and are handled by your app when the user acts on the toast notification. Users are familiar with these types of notifications from using Microsoft apps such as Outlook, Teams, and even the Microsoft Store app.</p>
			<p>Sometimes, these notifications are informational, such as when the Store app displays a message after an app has been updated. The notifications can also prompt the user to take an action, such as snoozing an Outlook calendar reminder. In this case, the notification window contains a drop-down control that allows the user to select the snooze duration.</p>
			<p>Later in this chapter, we’ll add a local app<a id="_idIndexMarker619"/> notification to the <strong class="bold">My Media Collection</strong> app to prompt<a id="_idIndexMarker620"/> our users to add a new book to their collection. Now, we’ll dive a little deeper into the implementation of raw push notifications and how they can be used to quietly receive a notification from the cloud.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor205"/>Using raw push notifications in WinUI applications</h1>
			<p>As we discussed in the previous section, push notifications<a id="_idIndexMarker621"/> that are handled by the app<a id="_idIndexMarker622"/> without notifying the user are generated through WNS and Azure. In this section, we will briefly examine how these notifications can be leveraged in WinUI applications. The Azure configuration needed to get started is somewhat lengthy and not very interesting. Because the Azure Notification Hubs configuration for WNS<a id="_idIndexMarker623"/> is already well documented in the Azure docs on Microsoft Learn, you should review them before we get started: <a href="https://learn.microsoft.com/azure/notification-hubs/notification-hubs-windows-store-dotnet-get-started-wns-push-notification">https://learn.microsoft.com/azure/notification-hubs/notification-hubs-windows-store-dotnet-get-started-wns-push-notification</a>. It’s also a good idea to familiarize yourself with the WNS overview<a id="_idIndexMarker624"/> in the Windows design documentation on Microsoft Learn: <a href="https://learn.microsoft.com/windows/apps/design/shell/tiles-and-notifications/windows-push-notification-services--wns--overview">https://learn.microsoft.com/windows/apps/design/shell/tiles-and-notifications/windows-push-notification-services--wns--overview</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Azure documentation was written for UWP apps, but the configuration instructions work just as well for a WinUI 3 application.</p>
			<p>Once the Azure configuration is complete, the steps to use notifications in a WinUI 3 app are similar to UWP but not exactly the same. For a detailed example of working with push notifications from the cloud, you can read this Microsoft Learn article: <a href="https://learn.microsoft.com/windows/apps/windows-app-sdk/notifications/push-notifications/push-quickstart">https://learn.microsoft.com/windows/apps/windows-app-sdk/notifications/push-notifications/push-quickstart</a>. In this chapter, we are focusing on app notifications, and will add those to our sample<a id="_idIndexMarker625"/> app in the next section. The high-level steps you will need to complete are as follows:</p>
			<ol>
				<li>Add the COM<a id="_idIndexMarker626"/> activation information<a id="_idIndexMarker627"/> to your <code>Package.appxmanifest</code> file. Here’s an example:<pre class="source-code">
&lt;Extensions&gt;
  &lt;!--Register COM activator--&gt;
  &lt;com:Extension Category="windows.comServer"&gt;
    &lt;com:ComServer&gt;
      &lt;com:ExeServer Executable="MyApp\MyApp.exe" DisplayName="My App" Arguments="----WindowsAppRuntimePushServer:"&gt;
        &lt;com:Class Id="[Azure AppId for App]" DisplayName="WinUI Push Notify" /&gt;
      &lt;/com:ExeServer&gt;
    &lt;/com:ComServer&gt;
  &lt;/com:Extension&gt;
&lt;/Extensions&gt;</pre></li>				<li>Register with <code>PushNotificationManager</code> in the <code>Microsoft.Windows.Push</code><code> Notifications</code> namespace and subscribe to <code>PushNotificationChannel</code> for the notification type.</li>
				<li>Add code to the <code>App</code> class to check whether the application was launched or activated from the background as a result of a push notification.</li>
				<li>Create a WNS channel and register that channel with the WNS service. These are the HTTP endpoints that will receive the notification data to be pushed to your app.</li>
				<li>Use a tool such as <code>POST</code> request<a id="_idIndexMarker628"/> with the push notification<a id="_idIndexMarker629"/> data. You will need to get an access token<a id="_idIndexMarker630"/> for the request with your Azure tenant ID, app ID, and client secret. For more information, see this page: <a href="https://learn.microsoft.com/azure/active-directory/develop/howto-create-service-principal-portal#get-tenant-and-app-id-values-for-signing-in">https://learn.microsoft.com/azure/active-directory/develop/howto-create-service-principal-portal#get-tenant-and-app-id-values-for-signing-in</a>.</li>
			</ol>
			<p>Those are the basic steps, but there’s much more to be learned. Make sure you read all of the articles linked in this section<a id="_idIndexMarker631"/> to learn about the nuances<a id="_idIndexMarker632"/> of using raw push notifications in a WinUI application.</p>
			<p>Now, let’s learn more about app notifications and adding send-and-receive capabilities to our sample application.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor206"/>Adding Windows app notifications with the Windows App SDK</h1>
			<p>In this section, we’re going<a id="_idIndexMarker633"/> to add some local app notifications to the <strong class="bold">My Media Collection</strong> project. The code we’ll add to the project is based on the Windows App SDK local app notification sample app created by the Microsoft Learn team. You can download the code for that project on GitHub: <a href="https://github.com/microsoft/WindowsAppSDK-Samples/tree/main/Samples/Notifications/App/CsUnpackagedAppNotifications">https://github.com/microsoft/WindowsAppSDK-Samples/tree/main/Samples/Notifications/App/CsUnpackagedAppNotifications</a>.</p>
			<p>We are adding two buttons to the MainPage in the app to trigger two types of notifications. One will have an image and some text. The second will add a text entry field to demonstrate how we can receive input from a user in the notification toast and act on it within our application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is a lot of configuration and code required to implement notification handling. If you would like to open the completed solution and follow along, the code is available on GitHub: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Complete">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Complete</a>.</p>
			<p>To get started, open your <strong class="bold">MyMediaCollection</strong> solution from the previous chapter or the starter solution for <a href="B20908_08.xhtml#_idTextAnchor197"><em class="italic">Chapter 8</em></a> on GitHub: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Start">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Start</a>:</p>
			<ol>
				<li>The first step is to add<a id="_idIndexMarker634"/> some configuration to the <code>Package.appxmanifest</code> file to enable notification handling in the app. Start by adding two namespace declarations to the <code>Package</code> element:<pre class="source-code">
xmlns:com="http://schemas.microsoft.com/appx/manifest/com/windows10"
xmlns:desktop="http://schemas.microsoft.com/appx/manifest/desktop/windows10"</pre></li>				<li>Next, add an <code>Extensions</code> section inside the <code>Application</code> node, immediately after the <code>uap:VisualElements</code> section:<pre class="source-code">
&lt;Extensions&gt;
  &lt;desktop:Extension Category="windows.toastNotificationActivation"&gt;
    &lt;desktop:ToastNotificationActivation ToastActivatorCLSID=<strong class="bold">"NEW GUID HERE"</strong> /&gt;
  &lt;/desktop:Extension&gt;
  &lt;com:Extension Category="windows.comServer"&gt;
    &lt;com:ComServer&gt;
      &lt;com:ExeServer Executable="MyMediaCollection\MyMediaCollection.exe" DisplayName="My Media Collection" Arguments="----AppNotificationActivated:"&gt;
        &lt;com:Class Id=<strong class="bold">"SAME NEW GUID HERE"</strong> /&gt;
      &lt;/com:ExeServer&gt;
    &lt;/com:ComServer&gt;
  &lt;/com:Extension&gt;
&lt;/Extensions&gt;</pre><p class="list-inset">Generate a new <code>Helpers</code>.</li>
				<li>Now create a new class named <code>NotificationShared</code> in the <code>Helpers</code> folder. Start by adding a constant and a struct to this class:<pre class="source-code">
public const string scenarioTag = "scenarioId";
public struct Notification
{
    public string Originator;
    public string Action;
    public bool HasInput;
    public string Input;
};</pre><p class="list-inset">The <code>Notification</code> struct will represent the data received in an app notification. <code>scenarioTag</code> is a constant that will be needed when each notification to send is being constructed.</p></li>				<li>Next, add the following static methods to the <code>NotificationShared</code> class. These will be used<a id="_idIndexMarker637"/> by the app to notify the UI when notifications are sent or received:<pre class="source-code">
public static void CouldNotSendToast()
{
    MainPage.Current.NotifyUser("Could not send toast", InfoBarSeverity.Error);
}
public static void ToastSentSuccessfully()
{
    MainPage.Current.NotifyUser("Toast sent successfully!", InfoBarSeverity.Success);
}
public static void AppLaunchedFromNotification()
{
    MainPage.Current.NotifyUser("App launched from notifications", InfoBarSeverity.Informational);
}
public static void NotificationReceived()
{
    MainPage.Current.NotifyUser("Notification received", InfoBarSeverity.Informational);
}
public static void UnrecognizedToastOriginator()
{
    MainPage.Current.NotifyUser("Unrecognized Toast Originator or Unknown Error", InfoBarSeverity.Error);
}</pre><p class="list-inset"><code>MainPage</code> doesn’t have a <code>Current</code> property, so this code won’t compile yet. We’ll take care<a id="_idIndexMarker638"/> of that soon. If Visual Studio didn’t add the necessary <code>using</code> statements, make sure these are present in <code>NotificationShared</code>:</p><pre class="source-code">using Microsoft.UI.Xaml.Controls;
using MyMediaCollection.Views;</pre></li>				<li>Now we are going to create two classes to represent the two types of notifications that the app will send and receive. First, create a new class named <code>ToastWithAvatar</code> and start by adding two constants to the class:<pre class="source-code">
using Microsoft.Windows.AppNotifications.Builder;
using Microsoft.Windows.AppNotifications;
using MyMediaCollection.Views;
namespace MyMediaCollection.Helpers
{
    public class ToastWithAvatar
    {
        public const int ScenarioId = 1;
        public const string ScenarioName = "Local Toast with Image";
    }
}</pre></li>				<li>Next, add a method named <code>SendToast</code> to the class. This method will construct and show a Windows notification toast containing some text, an avatar image, and a button to display our app:<pre class="source-code">
public static bool SendToast()
{
    var appNotification = new AppNotificationBuilder()
        .AddArgument("action", "ToastClick")
        .AddArgument(NotificationShared.scenarioTag, ScenarioId.ToString())
        .SetAppLogoOverride(new System.Uri($"file://{App.GetFullPathToAsset(" Square150x150Logo.scale-200.png")}"), AppNotificationImageCrop.Circle)
        .AddText(ScenarioName)
        .AddText("This is a notification message.")
        .AddButton(new AppNotificationButton("Open App")
            .AddArgument("action", "OpenApp")
            .AddArgument(NotificationShared.scenarioTag, ScenarioId.ToString()))
        .BuildNotification();
    AppNotificationManager.Default.Show(appNotification);
    // If notification is sent, it will have an Id. Success.
    return appNotification.Id != 0;
}</pre></li>				<li>Now add a <code>NotificationReceived</code> method, which will be invoked when this type of notification<a id="_idIndexMarker639"/> is received from Windows by our app. This method creates a <code>Notification</code> struct and calls a <code>NotificationReceived</code> method on <code>MainPage</code>, which we will create later in this section. We will also create the <code>ToForeground</code> method to bring our app to the front if it’s hidden behind other windows or minimized:<pre class="source-code">
public static void NotificationReceived(AppNotificationActivatedEventArgs notificationActivatedEventArgs)
{
    var notification = new NotificationShared.Notification
    {
        Originator = ScenarioName,
        Action = notificationActivatedEventArgs.Arguments["action"]
    };
    MainPage.Current.NotificationReceived(notification);
    App.ToForeground();
}</pre></li>				<li>The <code>ToastWithText</code> class will be similar to <code>ToastWithAvatar</code>, but it will add a call to <code>AddTextBox</code> in <code>AppNotificationBuilder</code> to create the input field in the Windows<a id="_idIndexMarker640"/> toast. It also adds the result of that user input to the <code>Notification</code> class created in <code>NotificationReceived</code>. To view the full code for this class, check out the completed solution on GitHub: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Complete/MyMediaCollection/Helpers/ToastWithText.cs">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Complete/MyMediaCollection/Helpers/ToastWithText.cs</a>.</li>
				<li>Now it’s time to create the <code>NotificationManager</code> class. This class will do exactly that – manage notifications. It will initialize and unregister notification receiving. It will do the actual sending and receiving of notifications. Create the <code>NotificationManager</code> class in the <code>Helpers</code> folder and start by adding the constructor and finalization code:<pre class="source-code">
using Microsoft.Windows.AppNotifications;
using System;
using System.Collections.Generic;
namespace MyMediaCollection.Helpers
{
    internal class NotificationManager
    {
        private bool isRegistered;
        private Dictionary&lt;int, Action&lt;AppNotificationActivatedEventArgs&gt;&gt; notificationHandlers;
        public NotificationManager()
        {
            isRegistered = false;
            notificationHandlers = new Dictionary&lt;int, Action&lt;AppNotificationActivatedEventArgs&gt;&gt;
            {
                { ToastWithAvatar.ScenarioId, ToastWithAvatar.NotificationReceived },
                { ToastWithText.ScenarioId, ToastWithText.NotificationReceived }
            };
        }
        ~NotificationManager()
        {
            Unregister();
        }
        public void Unregister()
        {
            if (isRegistered)
            {
                AppNotificationManager.Default.Unregister();
                isRegistered = false;
            }
        }
    }
}</pre></li>				<li>Next, add the <code>Init</code> method<a id="_idIndexMarker641"/> that we’ll call from the <code>App</code> class:<pre class="source-code">
public void Init()
{
    AppNotificationManager notificationManager = AppNotificationManager.Default;
    // Add handler before calling Register.
    notificationManager.NotificationInvoked += OnNotificationInvoked;
    notificationManager.Register();
    isRegistered = true;
}</pre></li>				<li><code>OnNotificationInvoked</code> is hooked up in the <code>Init</code> method. This will fire when notifications are received by the app. It makes different calls to <code>NotificationShared</code>, depending on whether the notification is recognized or not:<pre class="source-code">
public void OnNotificationInvoked(object sender, AppNotificationActivatedEventArgs notificationActivatedEventArgs)
{
    NotificationShared.NotificationReceived();
    if (!DispatchNotification(notificationActivatedEventArgs))
    {
        NotificationShared.UnrecognizedToastOriginator();
    }
}</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If you have any unhandled exceptions in your code that process incoming notifications, they will also trigger this call to <code>NotificationShared.UnrecognizedToastOriginator</code>.</p>
			<ol>
				<li value="13">Finally, create<a id="_idIndexMarker642"/> the <code>ProcessLaunchActivationArgs</code> and <code>DispatchNotification</code> methods in <code>NotificationManager</code>:<pre class="source-code">
public void ProcessLaunchActivationArgs(AppNotificationActivatedEventArgs notificationActivatedEventArgs)
{
    DispatchNotification(notificationActivatedEventArgs);
    NotificationShared.AppLaunchedFromNotification();
}
private bool DispatchNotification(AppNotificationActivatedEventArgs notificationActivatedEventArgs)
{
    var scenarioId = notificationActivatedEventArgs.Arguments[NotificationShared.scenarioTag];
    if (scenarioId.Length != 0)
    {
        try
        {
            notificationHandlers[int.Parse(scenarioId)](notificationActivatedEventArgs);
            return true;
        }
        catch
        {
            // No matching handler
            return false;
        }
    }
    else
    {
        // No scenarioId provided
        return false;
    }
}</pre></li>				<li>Now let’s add the code to <code>App.xaml.cs</code> to initialize <code>NotificationManager</code> and handle some<a id="_idIndexMarker643"/> of the common calls. Let’s start by adding the <code>using</code> statements that we’ll need for the new code:<pre class="source-code">
using Microsoft.Windows.AppLifecycle;
using Microsoft.Windows.AppNotifications;
using MyMediaCollection.Helpers;
using System.Runtime.InteropServices;
using WinRT.Interop;</pre></li>				<li>Next, add a private <code>notificationManager</code> object, add <code>DllImport</code> to help bring the window to the foreground, and make <code>m_window</code> static:<pre class="source-code">
[DllImport("user32.dll", SetLastError = true)]
static extern void SwitchToThisWindow(IntPtr hWnd, bool turnOn);
private NotificationManager notificationManager;
private <strong class="bold">static</strong> Window m_window;</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">Be careful when choosing which Win32 APIs to use in your production WinUI applications. The <code>SwitchToThisWindow</code> API is documented as “<em class="italic">not suitable for general use</em>,” but it works for our purposes<a id="_idIndexMarker644"/> in a sample app. There are other APIs you can explore, including <code>ShowWindow</code>: <a href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindow">https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindow</a>.</p>
			<ol>
				<li value="16">Next, add the following code to <code>OnLaunched</code> right before calling <code>m_window.Activate</code>. This gets the arguments<a id="_idIndexMarker645"/> passed to the app from the Windows notification:<pre class="source-code">
var currentInstance = AppInstance.GetCurrent();
if (currentInstance.IsCurrent)
{
    AppActivationArguments activationArgs = currentInstance.GetActivatedEventArgs();
    if (activationArgs != null)
    {
        ExtendedActivationKind extendedKind = activationArgs.Kind;
        if (extendedKind == ExtendedActivationKind.AppNotification)
        {
            var notificationActivatedEventArgs = (AppNotificationActivatedEventArgs)activationArgs.Data;
            notificationManager.ProcessLaunchActivationArgs(notificationActivatedEventArgs);
        }
    }
}</pre></li>				<li>Next, add some code to the <code>App</code> constructor to initialize <code>NotificationManager</code> and handle the <code>AppDomain.CurrentDomain.ProcessExit</code> event to unregister the manager when the app closes:<pre class="source-code">
public App()
{
    this.InitializeComponent();
<strong class="bold">    notificationManager = new NotificationManager();</strong>
<strong class="bold">    notificationManager.Init();</strong>
<strong class="bold">    AppDomain.CurrentDomain.ProcessExit += CurrentDomain_ProcessExit;</strong>
}
private void CurrentDomain_ProcessExit(object sender, EventArgs e)
{
    notificationManager.Unregister();
}</pre></li>				<li>The final items to be added to the <code>App</code> class are three static helper methods to get some application-related paths<a id="_idIndexMarker646"/> and the <code>ToForeground</code> method to bring the app to the front when it’s hidden or minimized:<pre class="source-code">
public static void ToForeground()
{
    if (m_window != null)
    {
        IntPtr handle = WindowNative.GetWindowHandle(m_window);
        if (handle != IntPtr.Zero)
        {
            SwitchToThisWindow(handle, true);
        }
    }
}
public static string GetFullPathToExe()
{
    var path = AppDomain.CurrentDomain.BaseDirectory;
    var pos = path.LastIndexOf("\\");
    return path.Substring(0, pos);
}
public static string GetFullPathToAsset(string assetName)
{
    return $"{GetFullPathToExe()}\\Assets\\{assetName}";
}</pre></li>				<li>Now let’s work on <code>MainPage</code>. Start in <code>MainPage.xaml</code>. We’re going to add two buttons to send notifications<a id="_idIndexMarker647"/> and an <code>InfoBar</code> control to display messages at the bottom of the page when notifications are sent or received. Add another <code>RowDefinition</code> to the outermost <code>Grid</code> control:<pre class="source-code">
&lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="Auto"/&gt;
    &lt;RowDefinition Height="*"/&gt;
    &lt;RowDefinition Height="Auto"/&gt;
<strong class="bold">    &lt;RowDefinition Height="Auto"/&gt;</strong>
&lt;/Grid.RowDefinitions&gt;</pre></li>				<li>Add two buttons to the beginning of <code>StackPanel</code> that contains the existing <code>Button</code> controls:<pre class="source-code">
&lt;StackPanel HorizontalAlignment="Right"
            Orientation="Horizontal"&gt;
    <strong class="bold">&lt;Button Command="{x:Bind ViewModel.SendToastCommand}"</strong>
<strong class="bold">            Content="Send Notification"</strong>
<strong class="bold">            Margin="8,8,0,8"/&gt;</strong>
<strong class="bold">    &lt;Button Command="{x:Bind ViewModel.SendToastWithTextCommand}"</strong>
<strong class="bold">            Content="Send Notification with Text"</strong>
<strong class="bold">            Margin="8,8,0,8"/&gt;</strong>
<strong class="bold">...</strong>
&lt;/StackPanel&gt;</pre></li>				<li>Add an <code>InfoBar</code> control just before the closing tag for the outer <code>Grid</code>:<pre class="source-code">
&lt;InfoBar x:Name="notifyInfoBar" Grid.Row="3"/&gt;</pre></li>				<li>Next, open the <code>MainPage.xaml.cs</code> file, in which we need<a id="_idIndexMarker648"/> to add some code to handle the incoming notifications. The first thing we’ll do is add a <code>using</code> statement for <code>MyMediaCollection.Helpers</code>.</li>
				<li>Next, add the code to expose the current instance of <code>MainPage</code> so the notifications can be routed properly:<pre class="source-code">
<strong class="bold">public static MainPage Current;</strong>
public MainPage()
{
    ViewModel = App.HostContainer.Services.GetService&lt;MainViewModel&gt;();
    this.InitializeComponent();
<strong class="bold">    Current = this;</strong>
    Loaded += MainPage_Loaded;
}</pre></li>				<li>Next, add some code to update <code>InfoBar</code> whenever notifications<a id="_idIndexMarker649"/> are sent or received. This is the code that will be called by the methods in the <code>NotificationShared</code> class:<pre class="source-code">
public void NotifyUser(string message, InfoBarSeverity severity, bool isOpen = true)
{
    if (DispatcherQueue.HasThreadAccess)
    {
        UpdateStatus(message, severity, isOpen);
    }
    else
    {
        DispatcherQueue.TryEnqueue(() =&gt;
        {
            UpdateStatus(message, severity, isOpen);
        });
    }
}
private void UpdateStatus(string message, InfoBarSeverity severity, bool isOpen)
{
    notifyInfoBar.Message = message;
    notifyInfoBar.IsOpen = isOpen;
    notifyInfoBar.Severity = severity;
}</pre><p class="list-inset">The <code>DispatcherQueue</code> methods check whether the code has access to the UI thread. If not, <code>TryEnqueue</code> is used to queue the work to be performed when the UI thread is available. Otherwise, errors will be encountered when accessing UI elements from a background thread.</p></li>				<li>Create a <code>NotificationReceived</code> method to handle incoming<a id="_idIndexMarker650"/> notification information. This method parses through the incoming data and builds a message string to display:<pre class="source-code">
public void NotificationReceived(NotificationShared.Notification notification)
{
    var text = $"{notification.Originator}; Action: {notification.Action}";
    if (notification.HasInput)
    {
        if (string.IsNullOrWhiteSpace(notification.Input))
            text += "; No input received";
        else
            text += $"; Input received: {notification.Input}";
    }
    if (DispatcherQueue.HasThreadAccess)
        DisplayMessageDialog(text);
    else
    {
        DispatcherQueue.TryEnqueue(() =&gt;
        {
            DisplayMessageDialog(text);
        });
    }
}</pre><p class="list-inset">The final code to add to <code>MainPage</code> is a simple<a id="_idIndexMarker651"/> method to display <code>ContentDialog</code> with the notification data:</p><pre class="source-code">private void DisplayMessageDialog(string message)
{
    ContentDialog notifyDialog = new()
    {
        XamlRoot = this.XamlRoot,
        Title = "Notification received",
        Content = message,
        CloseButtonText = "Ok"
    };
    notifyDialog.ShowAsync();
}</pre><p class="list-inset"><code>MainViewModel</code> is the final class to be updated. We need to create two command methods for the new buttons to invoke when sending app notifications. Create two methods named <code>SendToast</code> and <code>SendToastWithText</code>:</p><pre class="source-code">[RelayCommand]
private void SendToast()
{
    if (ToastWithAvatar.SendToast())
        NotificationShared.ToastSentSuccessfully();
    else
        NotificationShared.CouldNotSendToast();
}
[RelayCommand]
private void SendToastWithText()
{
    if (ToastWithText.SendToast())
        NotificationShared.ToastSentSuccessfully();
    else
        NotificationShared.CouldNotSendToast();
}</pre><p class="list-inset">Don’t forget to add <code>using MyMediaCollection.Helpers;</code> to the list of using statements in <code>MainViewModel</code>.</p></li>			</ol>
			<p>We’re ready to run the app<a id="_idIndexMarker652"/> and test the notifications. Start debugging and click the <strong class="bold">Send Notification</strong> button. You should see a toast appear in the lower-right portion of the main screen:</p>
			<div><div><img src="img/B20908_08_01.jpg" alt="Figure 8.1 – A Windows toast notification"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – A Windows toast notification</p>
			<p>Bring another window in front of <strong class="bold">My Media Collection</strong> and then click <strong class="bold">Open App</strong> on the toast. The app should be brought<a id="_idIndexMarker653"/> back to the front of the screen and <strong class="bold">ContentDialog</strong> will display a message with information about the notification received:</p>
			<div><div><img src="img/B20908_08_02.jpg" alt="Figure 8.2 – Receiving an app notification"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Receiving an app notification</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you click one of the buttons to send a notification multiple times without acknowledging the toast window, the toasts will not stack. The subsequent toasts will go straight to Windows’ <strong class="bold">Notifications Center</strong>. Once they go there, it’s not possible to use interactive fields such as a text box. In addition, if the user has <em class="italic">Do Not Disturb</em> or <em class="italic">Focus</em> mode enabled, all notifications will be suppressed and sent directly to <strong class="bold">Notifications Center</strong>.</p>
			<p>Now click the <strong class="bold">Send Notification with Text</strong> button. When this toast<a id="_idIndexMarker654"/> appears, it will have a text box where you can <strong class="bold">Enter </strong><strong class="bold">a reply</strong>:</p>
			<div><div><img src="img/B20908_08_03.jpg" alt="Figure 8.3 – Displaying a toast window with a text box"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Displaying a toast window with a text box</p>
			<p>Type <code>Hello world</code> and click the <strong class="bold">Reply</strong> button. Now, when <strong class="bold">My Media Collection</strong> displays <strong class="bold">ContentDialog</strong>, it will include the reply that was entered in the toast window:</p>
			<div><div><img src="img/B20908_08_04.jpg" alt="Figure 8.4 – Displaying the reply text from the toast window in our app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Displaying the reply text from the toast window in our app</p>
			<p>Now you’re ready to start building<a id="_idIndexMarker655"/> notifications into your own WinUI applications. Let’s wrap up the chapter and discuss what we’ve learned.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor207"/>Summary</h1>
			<p>In this chapter, we learned about the types of Windows notifications available to WinUI developers in the Windows App SDK. We discussed how notifications can be used to save Windows resources, reduce the need for timers, and prompt users to act. We explored how to configure raw push notifications and added a local app notification to the <strong class="bold">My Media Collection</strong> sample app. You should now feel prepared to add any of these types of notifications to your own WinUI applications.</p>
			<p>In the next chapter, we’ll explore the <strong class="bold">Windows Community Toolkit</strong> (<strong class="bold">WCT</strong>) and learn how, together with the .NET Community Toolkit, you can save development time by leveraging existing helpers, styles, and controls.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor208"/>Questions</h1>
			<ol>
				<li>What type of Windows notification can be used to initiate a data sync from the cloud?</li>
				<li>Which type of notification doesn’t rely on WNS?</li>
				<li>Where do you register your app before configuring notification services in Azure?</li>
				<li>Which Windows App SDK namespace contains the objects for working with app notifications?</li>
				<li>Which class has methods to register and unregister your app for handling app notifications?</li>
				<li>Which property can be set if you would like notifications from your app to disappear after a system reboot?</li>
				<li>Can notifications from WNS prompt the user with a toast notification?</li>
			</ol>
		</div>
	</body></html>