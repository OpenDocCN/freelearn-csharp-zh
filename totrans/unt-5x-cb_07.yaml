- en: Chapter 7. Controlling 3D Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。控制 3D 动画
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Configuring a character's Avatar and idle animation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置角色的 Avatar 和空闲动画
- en: Moving your character with root motion and Blend Trees
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用根运动和混合树移动你的角色
- en: Mixing animations with Layers and Masks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用层和遮罩混合动画
- en: Organizing States into Sub-State Machines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态组织到子状态机中
- en: Transforming the Character Controller via script
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过脚本转换角色控制器
- en: Adding rigid props to animated characters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将刚体道具添加到动画角色上
- en: Using Animation Events to throw an object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画事件抛掷一个对象
- en: Applying Ragdoll physics to a character
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Ragdoll 物理应用到角色上
- en: Rotating the character's torso to aim a weapon
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转角色的躯干以瞄准武器
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The **Mecanim** animation system has revolutionized how characters are animated
    and controlled within Unity. In this chapter, we will learn how to take advantage
    of its flexibility, power, and friendly and highly visual interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mecanim** 动画系统彻底改变了在 Unity 中对角色进行动画和控制的模式。在本章中，我们将学习如何利用其灵活性、强大功能和友好且高度可视化的界面。'
- en: The big picture
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整体图景
- en: Controlling a playable character with the Mecanim System might look like a complex
    task, but it is actually very straightforward.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mecanim 系统控制可玩角色可能看起来是一个复杂的任务，但实际上非常直接。
- en: '![The big picture](img/1362OT_07_00.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![整体图景](img/1362OT_07_00.jpg)'
- en: Hopefully, by the end of the chapter, you will have gained at least a basic
    understanding of the Mecanim system. For a more complete overview of the subject,
    consider taking a look at Jamie Dean's *Unity Character Animation* with Mecanim,
    also published by Packt Publishing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到本章结束时，你至少能对 Mecanim 系统有一个基本的了解。为了更全面地了解这个主题，可以考虑阅读 Jamie Dean 的 *Unity Character
    Animation with Mecanim*，这本书也由 Packt Publishing 出版。
- en: An additional note—all the recipes will make use of **Mixamo** motion packs.
    Mixamo is a complete solution for character production, rigging, and animation.
    In fact, the character in use was designed with Mixamo's character creation software
    called **Fuse**, and rigged with the Mixamo **Auto-rigger**. You can find out
    more about Mixamo and their products at Unity's Asset Store ([https://www.assetstore.unity3d.com/en/#!/publisher/150](https://www.assetstore.unity3d.com/en/#!/publisher/150))
    or their website at [https://www.mixamo.com/](https://www.mixamo.com/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 附加说明——所有的配方都将使用 **Mixamo** 动作包。Mixamo 是一个完整的角色制作、绑定和动画解决方案。实际上，正在使用的角色是用 Mixamo
    的角色创建软件 **Fuse** 设计的，并使用 Mixamo 的 **Auto-rigger** 进行绑定。你可以在 Unity 的 Asset Store
    ([https://www.assetstore.unity3d.com/en/#!/publisher/150](https://www.assetstore.unity3d.com/en/#!/publisher/150))
    或他们的网站 [https://www.mixamo.com/](https://www.mixamo.com/) 上了解更多关于 Mixamo 和他们的产品。
- en: Please note that although Mixamo offers Mecanim-ready characters and animation
    clips, we will use, for the recipes in this chapter, unprepared animation clips.
    The reason is to make you more confident when dealing with assets obtained by
    other methods and sources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管 Mixamo 提供了 Mecanim 准备好的角色和动画片段，但我们在本章的配方中将使用未准备的动画片段。这样做的原因是让你在处理通过其他方法和来源获得的资产时更有信心。
- en: Configuring a character's Avatar and idle animation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置角色的 Avatar 和空闲动画
- en: A feature that makes Mecanim so flexible and powerful is the ability of quickly
    reassigning animation clips from one character to another. This is made possible
    through the use of **Avatars**, which are basically a layer between your character's
    original rig and the Unity's **Animator** system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使 Mecanim 非常灵活和强大的一个特性是能够快速将动画片段从一个角色重新分配到另一个角色。这是通过使用 **Avatar** 实现的，它基本上是在你的角色的原始骨架和
    Unity 的 **Animator** 系统之间的一层。
- en: In this recipe, we will learn how to configure an Avatar skeleton on a rigged
    character.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在绑定的角色上配置 Avatar 骨架。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need the `MsLaser@T-Pose.fbx` and `Swat@rifle_aiming_idle.fbx`
    files, which are contained inside the `1362_07_code/character_and_clips/` folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要 `MsLaser@T-Pose.fbx` 和 `Swat@rifle_aiming_idle.fbx` 文件，这些文件包含在 `1362_07_code/character_and_clips/`
    文件夹中。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To configure an Avatar skeleton, follow these steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置一个 Avatar 骨架，请按照以下步骤操作：
- en: Import the `MsLaser@T-Pose.fbx` and `Swat@rifle_aiming_idle.fbx` files to your
    project.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MsLaser@T-Pose.fbx` 和 `Swat@rifle_aiming_idle.fbx` 文件导入到你的项目中。
- en: Select from the **Project** view, the `MsLaser@T-Pose` model.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **项目** 视图中选择 `MsLaser@T-Pose` 模型。
- en: In the **Inspector** view, under **MsLaser@T-Pose Import Settings**, activate
    the **Rig** section. Change **Animation Type** to **Humanoid**. Then, leave **Avatar
    Definition** as **Create From this Model**. Finally, click on the **Configure…**
    button.![How to do it...](img/1362OT_07_01.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**视图中，在**MsLaser@T-Pose导入设置**下，激活**骨架**部分。将**动画类型**更改为**人类**。然后，将**Avatar定义**保留为**从此模型创建**。最后，点击**配置…**按钮。![如何操作...](img/1362OT_07_01.jpg)
- en: '**Inspector** view will show the newly created Avatar. Observe how Unity correctly
    mapped the bones of our character into its structure, assigning, for instance,
    the **mixamoRig:LeftForeArm** bone as the Avatar''s **Lower Arm**. We could, of
    course, reassign bones if needed. For now, just click on the **Done** button to
    close the view.![How to do it...](img/1362OT_07_02.jpg)'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查器**视图将显示新创建的Avatar。观察Unity如何正确地将我们角色的骨骼映射到其结构中，例如，将**mixamoRig:LeftForeArm**骨骼分配为Avatar的**下臂**。当然，如果需要，我们可以重新分配骨骼。现在，只需点击**完成**按钮关闭视图。![如何操作...](img/1362OT_07_02.jpg)'
- en: Now that we have our Avatar ready, let's configure our animation for the **Idle**
    state. From the **Project** view, select the **Swat@rifle_aiming_idle** file.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的Avatar，让我们为**空闲**状态配置动画。从**项目**视图中，选择**Swat@rifle_aiming_idle**文件。
- en: Activate the **Rig** section, change **Animation Type** to **Humanoid** and
    **Avatar Definition** to **Create From This Model**. Confirm by clicking on **Apply**.![How
    to do it...](img/1362OT_07_03.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活**骨架**部分，将**动画类型**更改为**人类**，并将**Avatar定义**更改为**从此模型创建**。通过点击**应用**来确认更改。![如何操作...](img/1362OT_07_03.jpg)
- en: Activate the **Animations** section (to the right of the **Rig**). Select the
    **rifle_aiming_idle** clip (from the **Clips** list). The **Preview area** (at
    the bottom of the Inspector) will display the message as **No model is available
    for preview. Please** **drag a model into this Preview area**. Drag **MsLaser@T-Pose**
    to the **Preview** area to correct this.![How to do it...](img/1362OT_07_04.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活**动画**部分（位于**骨架**右侧）。从**剪辑**列表中选择**rifle_aiming_idle**剪辑。**预览区域**（检查器底部的底部）将显示消息**没有模型可用于预览。请**
    **将模型拖动到此预览区域**。将**MsLaser@T-Pose**拖动到**预览**区域以纠正此问题。![如何操作...](img/1362OT_07_04.jpg)
- en: With **rifle_aiming_idle** selected from the **Clips** list, check the **Loop
    Time** and **Loop Pose** options. Also, click on the **Clamp Range** button to
    adjust the timeline to the actual time of the animation clip. Then, under **Root
    Transform Rotation**, check **Bake Into Pose**, and select **Baked Upon** | **Original**.
    Under **Root Transform Position (Y)**, check **Bake Into Pose**, and select **Baked
    upon (at Start)** | **Original**. Under **Root Transform Position (XZ)**, leave
    **Bake Into Pose** unchecked, and select **Baked Upon (at Start)** | **Center
    of Mass**. Finally, click on **Apply** to confirm the changes.![How to do it...](img/1362OT_07_05.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**剪辑**列表中选择**rifle_aiming_idle**，勾选**循环时间**和**循环姿态**选项。同时，点击**限制范围**按钮调整时间线到动画剪辑的实际时间。然后，在**根变换旋转**下，勾选**烘焙到姿态**，并选择**基于**
    | **原始**。在**根变换位置（Y）**下，勾选**烘焙到姿态**，并选择**基于（在开始时）** | **原始**。在**根变换位置（XZ）**下，不勾选**烘焙到姿态**，并选择**基于（在开始时）**
    | **质心**。最后，点击**应用**以确认更改。![如何操作...](img/1362OT_07_05.jpg)
- en: In order to access animation clips and play them, we need to create a controller.
    Do this by clicking on the **Create** button from the **Project** view, and then
    selecting the **Animator Controller** option. Name it as `MainCharacter`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了访问动画剪辑并播放它们，我们需要创建一个控制器。通过从**项目**视图点击**创建**按钮，然后选择**动画控制器**选项来完成此操作。将其命名为`MainCharacter`。
- en: Double-click on the **Animator Controller** to open the **Animator** view.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**动画控制器**以打开**动画器**视图。
- en: From the **Animator** view, right-click on the grid to open a context menu.
    Then, select the **Create State** | **Empty** option**.** A new box named **New
    State** will appear. It will be in orange, indicating that it is the default state.![How
    to do it...](img/1362OT_07_06.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**动画器**视图，在网格上右键单击以打开上下文菜单。然后，选择**创建状态** | **空**选项**。**一个名为**新状态**的新框将出现。它将呈橙色，表示它是默认状态。![如何操作...](img/1362OT_07_06.jpg)
- en: Select **New State** and, in the **Inspector** view, change its name to `Idle`.
    Also, in the **Motion** field, choose **rifle_aiming_idle** by either selecting
    it from the list or dragging it from the **Project** view.![How to do it...](img/1362OT_07_07.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新状态**，在**检查器**视图中，将其名称更改为`Idle`。此外，在**运动**字段中，通过从列表中选择或从**项目**视图拖动来选择**rifle_aiming_idle**。![如何操作...](img/1362OT_07_07.jpg)
- en: Drag the `MsLaser@T-Pose` model from the **Project** view into the **Hierarchy**
    view and place it on the scene.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MsLaser@T-Pose`模型从**项目**视图拖到**层次结构**视图，并将其放置在场景中。
- en: Select **MsLaser@T-Pose** from the **Hierarchy** view and observe its **Animator**
    component in the **Inspector** view. Then, assign the newly created **MainCharacter
    controller** to its **Controller** field.![How to do it...](img/1362OT_07_08.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中选择**MsLaser@T-Pose**，并在**检查器**视图中观察其**动画器**组件。然后，将新创建的**MainCharacter控制器**分配给其**控制器**字段。![如何操作...](img/1362OT_07_08.jpg)
- en: Play your scene to see the character correctly animated.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的场景以查看角色正确地进行了动画处理。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Preparing our character for animation took many steps. First, we created its
    **Avatar**, based on the character model's original bone structure. Then, we set
    up the **animation clip** (which, as the character mesh, is stored in a `.fbx`
    file), using its own Avatar. After this, we adjusted the animation clip, clamping
    its size and making it a loop. We also baked its **Root Transform Rotation** to
    obey the original file's orientation. Finally, an **Animator Controller** was
    created, and the edited animation clip was made into its default **Animation state**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为角色制作动画需要许多步骤。首先，我们根据角色模型的原始骨骼结构创建了它的**虚拟形象**。然后，我们使用它自己的虚拟形象设置了**动画片段**（作为角色网格，存储在`.fbx`文件中），调整了动画片段，固定其大小并使其循环。我们还烘焙了其**根变换旋转**以遵守原始文件的方向。最后，创建了一个**动画控制器**，并将编辑后的动画片段设置为默认的**动画状态**。
- en: The concept of the Avatar is what makes Mecanim so flexible. Once you have a
    **Controller**, you can apply it to other humanoid characters, as long as they
    have an Avatar body mask. If you want to try it yourself, import `mascot.fbx`,
    which is also available inside the `charater_and_clips` folder, apply steps 3
    and 4 into this character, place it on the scene, and apply **MainCharacter**
    as its **Controller** in the **Animator** component. Then, play the scene to see
    the mascot playing the **rifle_aiming_idle** animation clip.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟形象的概念使得Mecanim非常灵活。一旦你有了**控制器**，你就可以将其应用于其他类人角色，只要它们有虚拟形象身体蒙版。如果你想亲自尝试，导入`mascot.fbx`文件，它也位于`charater_and_clips`文件夹内，将步骤3和4应用到这个角色上，将其放置在场景中，并在**动画器**组件中将**MainCharacter**设置为它的**控制器**。然后，播放场景以查看吉祥物正在播放**rifle_aiming_idle**动画片段。
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: To read more information about the Animator Controller, check out Unity's documentation
    at [http://docs.unity3d.com/Manual/class-AnimatorController.html](http://docs.unity3d.com/Manual/class-AnimatorController.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于动画控制器的信息，请查看Unity的文档[http://docs.unity3d.com/Manual/class-AnimatorController.html](http://docs.unity3d.com/Manual/class-AnimatorController.html)。
- en: Moving your character with root motion and Blend Trees
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用根运动和混合树移动你的角色
- en: The Mecanim animation system is capable of applying Root Motion to characters.
    In other words, it *actually* moves the character according to the animation clip,
    as opposed to arbitrarily translating the character model while playing an in-place
    animation cycle. This makes most of the Mixamo animation clips perfect for use
    with Mecanim.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Mecanim动画系统能够将根运动应用于角色。换句话说，它**实际上**根据动画片段移动角色，而不是在播放原地动画循环时任意转换角色模型。这使得大多数Mixamo动画片段非常适合与Mecanim一起使用。
- en: Another feature of the animation system is **Blend Trees**, which can blend
    animation clips smoothly and easily. In this recipe, we will take advantage of
    these features to make our character walk/run forward and backwards, and also
    strafe right and left at different speeds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 动画系统的另一个功能是**混合树**，它可以平滑且容易地混合动画片段。在这个配方中，我们将利用这些功能使我们的角色向前和向后行走/奔跑，并在不同速度下向右和向左横移。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity package named `Character_02`, containing
    a character and featuring a basic Animator Controller. The package can be found
    inside the `1362_07_02` folder, along with the `.fbx` files for the necessary
    animation clips.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们准备了一个名为`Character_02`的Unity包，其中包含一个角色和一个基本的动画控制器。该包位于`1362_07_02`文件夹中，包括必要的动画片段的`.fbx`文件。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To apply the Root Motion to your character using **Blend Trees**, follow these
    steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**混合树**将根运动应用于你的角色，请按照以下步骤操作：
- en: Import `Character_02.unityPackage` into a new project. Also, import `Swat@rifle_run,
    Swat@run_backwards, Swat@strafe, Swat@strafe_2, Swat@strafe_left, Swat@strafe_right,
    Swat@walking`, `and Swat@walking_backwards .fbx` files.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Character_02.unityPackage`导入到新项目中。同时导入`Swat@rifle_run, Swat@run_backwards,
    Swat@strafe, Swat@strafe_2, Swat@strafe_left, Swat@strafe_right, Swat@walking`,
    `和 Swat@walking_backwards .fbx`文件。
- en: We need to configure our animation clips. From the **Project view**, select
    **Swat@rifle_run**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置我们的动画剪辑。从**Project**视图下，选择**Swat@rifle_run**。
- en: Activate the **Rig** section. Change **Animation Type** to **Humanoid** and
    **Avatar Definition** to **Create From this Model**. Confirm by clicking on **Apply**.![How
    to do it...](img/1362OT_07_09.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活**Rig**部分。将**Animation Type**更改为**Humanoid**，将**Avatar Definition**更改为**Create
    From this Model**。通过点击**Apply**进行确认。![如何操作...](img/1362OT_07_09.jpg)
- en: Now, activate the **Animations** section (to the right of **Rig**). Select the
    **rifle_run** clip (from the **Clips** list). The **Preview area** (at the bottom
    of the **Inspector** view) will display the message as **No model is available
    for preview. Please drag a model into this Preview area**. Drag **MsLaser@T-Pose**
    onto the **Preview** area to correct this.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，激活**Animations**部分（位于**Rig**右侧）。从**Clips**列表中选择**rifle_run**剪辑。在**Inspector**视图底部的**Preview
    area**将显示消息**No model is available for preview. Please drag a model into this
    Preview area**。将**MsLaser@T-Pose**拖动到**Preview**区域以纠正此问题。
- en: With **rifle_run** selected from the **Clips** list, select the **rifle_run**
    clip (from the **Clips** list) and check the **Loop Time** and **Loop Pose** options.
    Also, click on the **Clamp Range** button to adjust the timeline to the actual
    time of the animation clip.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Clips**列表中选择**rifle_run**后，选择**rifle_run**剪辑（从**Clips**列表中），并勾选**Loop Time**和**Loop
    Pose**选项。同时，点击**Clamp Range**按钮以调整时间线到动画剪辑的实际时间。
- en: Then, under **Root Transform Rotation**, check **Bake Into Pose**, and select
    **Baked Upon (at Start)** | **Original**. Under **Root Transform Position (Y)**,
    check **Bake Into Pose**, and select **Baked Upon** | **Original**. Under **Root
    Transform Position (XZ)**, leave **Bake Into Pose** unchecked, and select **Baked
    Upon (at Start)** | **Center of Mass**. Finally, click on **Apply** to confirm
    the changes.![How to do it...](img/1362OT_07_10.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**Root Transform Rotation**下，勾选**Bake Into Pose**，并选择**Baked Upon (at Start)**
    | **Original**。在**Root Transform Position (Y)**下，勾选**Bake Into Pose**，并选择**Baked
    Upon** | **Original**。在**Root Transform Position (XZ)**下，不勾选**Bake Into Pose**，并选择**Baked
    Upon (at Start)** | **Center of Mass**。最后，点击**Apply**以确认更改。![如何操作...](img/1362OT_07_10.jpg)
- en: 'Repeat steps 3 to 6 for each one of the following animation clips: **Swat@run_backwards**,
    **Swat@strafe**, **Swat@strafe_2**, **Swat@strafe_left**, **Swat@strafe_right**,
    **Swat@walking**, and **Swat@walking_backwards**.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对以下每个动画剪辑重复步骤3到6：**Swat@run_backwards**，**Swat@strafe**，**Swat@strafe_2**，**Swat@strafe_left**，**Swat@strafe_right**，**Swat@walking**，和**Swat@walking_backwards**。
- en: From the **Project view**, select the **MsLaser** prefab and drag it onto the
    **Hierarchy** view, placing it on the scene.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Project**视图下，选择**MsLaser**预制体并将其拖动到**Hierarchy**视图，放置到场景中。
- en: 'From the **Hierarchy** view, select the **MsLaser** GameObject and attach a
    **Character Controller** component to it (**menu Component** | **Physics** | **Character
    Controller**). Then, set its **Skin Width** as `0.0001`, and its **Center** as
    **X**: **0**, **Y**: **0.9**, **Z**: **0**; also change its **Radius** to **0.34**
    and its **Height** to **1.79**.![How to do it...](img/1362OT_07_11.jpg)'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从**Hierarchy**视图下，选择**MsLaser**GameObject，并为其附加一个**Character Controller**组件（**menu
    Component** | **Physics** | **Character Controller**）。然后，将其**Skin Width**设置为`0.0001`，其**Center**设置为**X**:
    **0**，**Y**: **0.9**，**Z**: **0**；同时将其**Radius**更改为**0.34**，其**Height**更改为**1.79**。![如何操作...](img/1362OT_07_11.jpg)'
- en: In the **Project** **view**, open the **MainCharacter** controller.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Project**视图下，打开**MainCharacter**控制器。
- en: In the top-left corner of the **Animator** view, activate the **Parameters**
    section and use the **+** sign to create three new **Parameters (Float)** named
    `xSpeed`, `zSpeed`, and `Speed`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Animator**视图的右上角，激活**Parameters**部分，并使用**+**符号创建三个新的**Parameters (Float)**，分别命名为`xSpeed`，`zSpeed`和`Speed`。
- en: We do have an **Idle** state for our character, but we need the new ones. Right-click
    on the gridded area and, from the context menu, navigate to **Create State** |
    **From New Blend Tree**. Change its name, from the **Inspector** view, to `Move`.![How
    to do it...](img/1362OT_07_12.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确实为我们的角色提供了一个**Idle**状态，但我们需要新的状态。在网格区域上右键单击，从上下文菜单中导航到**Create State** |
    **From New Blend Tree**。从**Inspector**视图更改其名称为`Move`。![如何操作...](img/1362OT_07_12.jpg)
- en: Double-click on the **Move** state. You will see the empty blend tree that you
    have created. Select it and, in the **Inspector** view, rename it to `Move`. Then,
    change its **Blend Type** to **2D Freeform Directional**, also setting **xSpeed**
    and **zSpeed** in the **Parameters** tab. Finally, using the **+** sign from the
    bottom of the **Motion** list, add nine new **Motion Fields**.![How to do it...](img/1362OT_07_13.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**移动**状态。你会看到你创建的空混合树。选择它，在**检查器**视图中将其重命名为`Move`。然后，将其**混合类型**更改为**2D 自由形式方向**，也在**参数**选项卡中设置**xSpeed**和**zSpeed**。最后，使用**Motion**列表底部的**+**号添加九个新的**运动字段**。![如何做...](img/1362OT_07_13.jpg)
- en: 'Now, populate the **Motion** list with the following motion clips and respective
    **Pos X** and **Pos Y** values: **run_backwards**, `0`, `-1`; **walking_backwards**,
    `0`,`-0.5`; **rifle_aiming_idle**, `0`, `0`; **walking**, `0`, `0.5`; **rifle_run**,
    `0`, `1`; **strafe**, `-1`, `0`; **strafe_left**, -`0.5`, `0`; **strafe_right**,
    `0.5`, `0`; **strafe_2**, `1`, `0`. You can populate the **Motion** list by selecting
    it from the list or, if there are more than one clip with the same name, you can
    drag it from the **Project view** onto the slot (by expanding the appropriate
    model icon).![How to do it...](img/1362OT_07_14.jpg)'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下运动剪辑及其相应的**Pos X**和**Pos Y**值填充到**Motion**列表中：**run_backwards**，`0`，`-1`；**walking_backwards**，`0`，`-0.5`；**rifle_aiming_idle**，`0`，`0`；**walking**，`0`，`0.5`；**rifle_run**，`0`，`1`；**strafe**，`-1`，`0`；**strafe_left**，`-0.5`，`0`；**strafe_right**，`0.5`，`0`；**strafe_2**，`1`，`0`。你可以通过从列表中选择它来填充**Motion**列表，或者如果有多个具有相同名称的剪辑，你可以将其从**项目视图**拖动到槽位（通过展开相应的模型图标）上。![如何做...](img/1362OT_07_14.jpg)
- en: Double-click on the gridded area to go from the **Move** blend tree back to
    the **Base Layer**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击网格区域，从**移动**混合树回到**基础层**。
- en: Since we have the `rifle_aiming_idle` Motion clip within our **Move** blend
    tree, we can get rid of the original **Idle** state. Right-click on the **Idle**
    state box and, from the menu, select **Delete**. The **Move** blend state will
    become the new default state, turning orange.![How to do it...](img/1362OT_07_15.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在**移动**混合树中有`rifle_aiming_idle`运动剪辑，我们可以删除原始的**空闲**状态。右键单击**空闲**状态框，从菜单中选择**删除**。**移动**混合状态将成为新的默认状态，变为橙色。![如何做...](img/1362OT_07_15.jpg)
- en: Now, we must create the script that will actually transform the player's input
    into those variables that are created to control the animation.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个脚本，将玩家的输入转换为创建来控制动画的变量。
- en: From the **Project view**, create a new **C# Script** and name it as `BasicController`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目视图**创建一个新的**C# 脚本**，并将其命名为`BasicController`。
- en: 'Open your script and replace everything with the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的脚本，将其替换为以下代码：
- en: '[PRE0]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save your script and attach it to the **MsLaser** GameObject in the **Hierarchy**
    view. Then, add **Plane** (menu option **GameObject** | **3D Object** | **Plane**)
    and place it beneath the character.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并将其附加到**MsLaser**游戏对象上，在**层次结构**视图中。然后，添加**平面**（菜单选项**GameObject** | **3D
    Object** | **Plane**），并将其放置在角色下方。
- en: Play your scene and test the game. You will be able to control your character
    with the arrow keys (or *WASD* keys). Keeping the *Shift* key pressed will slow
    it down.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 演示你的场景并测试游戏。你可以使用箭头键（或*WASD*键）来控制你的角色。按住*Shift*键会减慢速度。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Whenever the `BasicController` script detects any directional keys in use, it
    sets the `Speed` variable of the **Animator** state to a value higher than 0,
    changing the **Animator** state from **Idle** to **Move**. The **Move** state,
    in its turn, blends the motion clips that it was populated with, according to
    the input values for `xSpeed` (obtained from **Horizontal Axis** input, typically
    *A* and *D* keys) and `zSpeed` (obtained from **Vertical Axis** input, typically
    *W* and *S* keys). Since Mecanim is capable of applying root motion to the characters,
    our character will actually move in the resulting direction.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当`BasicController`脚本检测到任何方向键被使用时，它会将**Animator**状态的`Speed`变量设置为大于0的值，将**Animator**状态从**空闲**变为**移动**。**移动**状态反过来会根据`xSpeed`（从**水平轴**输入获取，通常是*A*和*D*键）和`zSpeed`（从**垂直轴**输入获取，通常是*W*和*S*键）的输入值混合它所填充的运动剪辑。由于Mecanim能够将根运动应用于角色，我们的角色实际上会沿着结果方向移动。
- en: For instance, if *W* and *D* keys are pressed, `xSpeed` and `zSpeed` values
    will rise to 1.0\. From the **Inspector** view, it is possible to see that such
    combination will result in a blend between the motion clips called **rifle_run**
    and **strafe_2**, making the character run diagonally (front + right).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果按下*W*和*D*键，`xSpeed`和`zSpeed`值将增加到1.0。从**检查器**视图可以看到，这种组合将导致名为**rifle_run**和**strafe_2**的运动剪辑之间的混合，使角色以对角线（前+右）的方式奔跑。
- en: '![How it works...](img/1362OT_07_18.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1362OT_07_18.jpg)'
- en: 'Our **BasicController** includes three checkboxes for more options: **Move
    Diagonally**—set as **true**, by default, which allows for blends between forward/backward
    and left/right clips; **Mouse Rotate**—set as **true**, by default, which allows
    for rotating the character with the mouse, changing their direction while moving;
    **Keyboard Rotate**—set as **false**, by default, which allows for rotating the
    character through simultaneous use of left/right and forward/backwards directional
    keys.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**BasicController**包括三个复选框以提供更多选项：**对角移动**—默认设置为**true**，允许在向前/向后和向左/向右剪辑之间进行混合；**鼠标旋转**—默认设置为**true**，允许使用鼠标旋转角色，在移动时改变方向；**键盘旋转**—默认设置为**false**，允许通过同时使用左右和向前/向后方向键来旋转角色。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Our blend tree used the **2D Freeform Directional Blend Type**. However, if
    we had only four animation clips (forward, backwards, left, and right), **2D Simple
    Directional** would have been a better option. Learn more on the following links:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的混合树使用了**2D自由形式方向混合类型**。然而，如果我们只有四个动画剪辑（向前、向后、向左和向右），**2D简单方向**将是一个更好的选择。更多信息请查看以下链接：
- en: 'Learn more about Blend Trees and 2D blending from Unity''s Documentation at:
    [http://docs.unity3d.com/Manual/BlendTree-2DBlending.html](http://docs.unity3d.com/Manual/BlendTree-2DBlending.html).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity文档中了解更多关于混合树和2D混合的信息，请访问：[http://docs.unity3d.com/Manual/BlendTree-2DBlending.html](http://docs.unity3d.com/Manual/BlendTree-2DBlending.html)。
- en: 'Also, if you want to learn more about Mecanim Animation System, there are some
    links that you might want to check out, such as Unity''s documentation at: [http://docs.unity3d.com/Manual/AnimationOverview.html](http://docs.unity3d.com/Manual/AnimationOverview.html).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，如果您想了解更多关于Mecanim动画系统，有一些链接您可以查看，例如Unity的文档：[http://docs.unity3d.com/Manual/AnimationOverview.html](http://docs.unity3d.com/Manual/AnimationOverview.html)。
- en: 'Mecanim Example Scenes are available at Unity Asset Store at: [https://www.assetstore.unity3d.com/en/#!/content/5328](https://www.assetstore.unity3d.com/en/#!/content/5328).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mecanim示例场景可在Unity Asset Store中找到：[https://www.assetstore.unity3d.com/en/#!/content/5328](https://www.assetstore.unity3d.com/en/#!/content/5328)。
- en: 'Mecanim Video Tutorial are available at: [http://unity3d.com/pt/learn/tutorials/topics/animation](http://unity3d.com/pt/learn/tutorials/topics/animation).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mecanim视频教程可在：[http://unity3d.com/pt/learn/tutorials/topics/animation](http://unity3d.com/pt/learn/tutorials/topics/animation)找到。
- en: Mixing animations with Layers and Masks
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用层和遮罩混合动画
- en: Mixing animations is a great way of adding complexity to your animated characters
    without requiring a vast number of animated clips. Using **Layers** and **Masks**,
    we can combine different animations by playing specific clips for the specific
    body parts of the character. In this recipe, we will apply this technique to our
    animated character, triggering animation clips for firing a rifle, and throwing
    a grenade with the character's upper body. We will do this while keeping the lower
    body moving or idle, according to the player's input.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 混合动画是向您的动画角色添加复杂性的好方法，而无需大量动画剪辑。使用**层**和**遮罩**，我们可以通过播放特定身体部分的特定剪辑来组合不同的动画。在这个菜谱中，我们将应用这种技术到我们的动画角色上，触发发射步枪和投掷手榴弹的动画剪辑，同时根据玩家的输入保持下半身移动或空闲。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named `Mixing`, containing
    a basic scene that features an animated character. The package can be found inside
    the `1362_07_03` folder, along with the animation clips called `Swat@firing_rifle.fbx`
    and `Swat@toss_grenade.fbx`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们准备了一个名为`Mixing`的Unity包，其中包含一个具有动画角色的基本场景。该包位于`1362_07_03`文件夹中，包括名为`Swat@firing_rifle.fbx`和`Swat@toss_grenade.fbx`的动画剪辑。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To mix animations using layers and masks, follow these steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用层和遮罩混合动画，请按照以下步骤操作：
- en: Create a new project and import the `Mixing` Unity Package. Then, from the **Project
    view**, open the **mecanimPlayground** level.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并导入`Mixing`Unity包。然后，从**项目视图**中打开**mecanimPlayground**级别。
- en: Import the `Swat@firing_rifle.fbx` and `Swat@toss_grenade.fbx` files to the
    project.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Swat@firing_rifle.fbx`和`Swat@toss_grenade.fbx`文件导入到项目中。
- en: We need to configure the animation clips. From the **Project view**, select
    the **Swat@firing_rifle** animation clip.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置动画剪辑。从**项目视图**，选择**Swat@firing_rifle**动画剪辑。
- en: Activate the **Rig** section. Change **Animation Type** to **Humanoid**, and
    **Avatar Definition** to **Create From this Model**. Confirm this by clicking
    on **Apply**.![How to do it...](img/1362OT_07_09.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活**绑定**部分。将**动画类型**更改为**人类**，并将**头像定义**更改为**从此模型创建**。通过点击**应用**来确认更改。![如何操作...](img/1362OT_07_09.jpg)
- en: Now, activate the **Animations** section. Select the **firing_rifle** clip (from
    the **Clips** list), click on the **Clamp Range** button to adjust the timeline,
    and check the **Loop Time** and **Loop Pose** options. Under **Root Transform
    Rotation**, check **Bake Into Pose**, and select **Baked Upon** | **Original**.
    Under **Root Transform Position (Y)**, check **Bake Into Pose**, and select **Baked
    Upon (at Start)** | **Original**. Under **Root Transform Position (XZ)**, leave
    **Bake Into Pose** unchecked. Click on **Apply** to confirm the changes.![How
    to do it...](img/1362OT_07_19.jpg)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，激活**动画**部分。从**剪辑**列表中选择**firing_rifle**剪辑，点击**限制范围**按钮调整时间轴，并勾选**循环时间**和**循环姿态**选项。在**根变换旋转**下，勾选**烘焙到姿态**，并选择**烘焙于**|**原始**。在**根变换位置（Y）**下，勾选**烘焙到姿态**，并选择**烘焙于（起始处）**|**原始**。在**根变换位置（XZ）**下，取消勾选**烘焙到姿态**。点击**应用**以确认更改。![如何操作...](img/1362OT_07_19.jpg)
- en: Select the **Swat@toss_grenade** animation clip. Activate the **Rig** section.
    Then, change **Animation Type** to **Humanoid**, and **Avatar Definition** to
    **Create From this Model**. Confirm it by clicking on **Apply**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Swat@toss_grenade**动画剪辑。激活**绑定**部分。然后，将**动画类型**更改为**人类**，并将**头像定义**更改为**从此模型创建**。通过点击**应用**来确认更改。
- en: Now, activate the **Animations** section. Select the **toss_grenade** clip (from
    the **Clips** list), click on the button **Clamp Range** to adjust the timeline,
    and leave the **Loop Time** and **Loop Pose** options unchecked. Under **Root
    Transform Rotation**, check **Bake Into Pose**, and select **Baked Upon (at Start)**
    | **Original**. Under **Root Transform Position (Y)**, check **Bake Into Pose**,
    and select **Baked Upon (at Start)** | **Original)**. Under **Root Transform Position
    (XZ)**, leave **Bake Into Pose** unchecked. Click on **Apply** to confirm the
    changes.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，激活**动画**部分。从**剪辑**列表中选择**toss_grenade**剪辑，点击**限制范围**按钮调整时间轴，并取消选中**循环时间**和**循环姿态**选项。在**根变换旋转**下，勾选**烘焙到姿态**，并选择**烘焙于（起始处）**|**原始**。在**根变换位置（Y）**下，勾选**烘焙到姿态**，并选择**烘焙于（起始处）**|**原始**）。在**根变换位置（XZ）**下，取消勾选**烘焙到姿态**。点击**应用**以确认更改。
- en: Let's create a Mask. From the **Project** view, click on the **Create** button
    and add an **Avatar Mask** to the project. Name it as **BodyMask**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个面具。从**项目**视图，点击**创建**按钮，并将**头像面具**添加到项目中。将其命名为**BodyMask**。
- en: Select the **BodyMask** tab and, in the **Inspector** view, expand the **Humanoid**
    section to unselect the character's legs, base, and **IK** spots, turning their
    outline red.![How to do it...](img/1362OT_07_20.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**BodyMask**选项卡，并在**检查器**视图中展开**人类**部分以取消选择角色的腿部、基础和**IK**点，使它们的轮廓变红。![如何操作...](img/1362OT_07_20.jpg)
- en: From the **Hierarchy** view, select the **MsLaser** character. Then, from the
    **Animator** component in the **Inspector** view, double-click on the **MainCharacter**
    controller to open it.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图，选择**MsLaser**角色。然后，从**检查器**视图中的**动画器**组件，双击**MainCharacter**控制器以打开它。
- en: In the **Animator** view, create a new layer by clicking on the **+** sign at
    the top-left **Layers** tab, above the **Base Layer**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画器**视图中，通过点击左上角的**+**号在**图层**选项卡上创建一个新图层，位于**基础图层**上方。
- en: Name the new layer as **UpperBody** and click on the gear icon for the settings.
    Then, change its **Weight** to `1`, and select the **BodyMask** in the **Mask**
    slot. Also, change Blending to **Additive**.![How to do it...](img/1362OT_07_21.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新图层命名为**UpperBody**，并点击齿轮图标进行设置。然后，将其**权重**更改为`1`，并在**遮罩**槽中选择**BodyMask**。此外，将混合模式更改为**加法**。![如何操作...](img/1362OT_07_21.jpg)
- en: Now, in the **Animator** view, with the **UpperBody** layer selected, create
    three new empty states (by right-clicking on the gridded area and navigating to,
    from the menu, **Create State** | **Empty**). Name the default (orange) state
    **null**, and the other two as **Fire** and **Grenade**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**动画器**视图中，选择**UpperBody**层，创建三个新的空状态（通过右键点击网格区域并从菜单中选择**创建状态** | **空**）。将默认（橙色）状态命名为**null**，其他两个命名为**Fire**和**Grenade**。
- en: 'Now, access the **Parameters** tab and add two new parameters of the Boolean
    type: `Fire` and `Grenade`.![How to do it...](img/1362OT_07_22.jpg)'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问**参数**选项卡并添加两个布尔类型的新的参数：`Fire`和`Grenade`。![如何操作...](img/1362OT_07_22.jpg)
- en: Select the **Fire** state and, in the **Inspector** view, add the **firing_rifle**
    animation clip to the **Motion** field.![How to do it...](img/1362OT_07_23.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Fire**状态，并在**检查器**视图中将**firing_rifle**动画片段添加到**运动**字段。![如何操作...](img/1362OT_07_23.jpg)
- en: Now, select the **Grenade** state and, in the **Inspector** view, add the **toss_grenade**
    animation clip to the **Motion** field.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择**Grenade**状态，并在**检查器**视图中，将**toss_grenade**动画片段添加到**运动**字段。
- en: Right-click on the **null** state box and, from the menu, select **Make Transition**.
    Then, drag the white arrow onto the **Fire** box.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**null**状态框，然后从菜单中选择**创建转换**。接着，将白色箭头拖动到**Fire**框上。
- en: Select the arrow (it will turn blue). From the **Inspector** view, uncheck the
    **Has Exit Time** option. Then, access the **Conditions** list, click on the **+**
    sign to add a new condition, and set it as **Fire** and **true**.![How to do it...](img/1362OT_07_24.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择箭头（它将变为蓝色）。从**检查器**视图中取消勾选**Has Exit Time**选项。然后，访问**条件**列表，点击加号**+**添加一个新条件，并将其设置为**Fire**和**true**。![如何操作...](img/1362OT_07_24.jpg)
- en: Now, make a transition from **null** to **Grenade**. Select the arrow (it will
    turn blue). From the **Inspector** view, uncheck the **Has Exit Time** option.
    Then, access the **Conditions** list, click on the **+** sign to add a new condition,
    and set it as **Grenade** and **true**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**null**到**Grenade**创建转换。选择箭头（它将变为蓝色）。从**检查器**视图中取消勾选**Has Exit Time**选项。然后，访问**条件**列表，点击加号**+**添加一个新条件，并将其设置为**Grenade**和**true**。
- en: Now, create transitions from **Fire** to **null**, and from **Grenade** to **null**.
    Then, select the arrow that goes from **Fire** to **null** and, in the **Conditions**
    box, select the **Fire** and **false** options. Leave the **Has Exit Time** option
    checked.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**Fire**到**null**，以及从**Grenade**到**null**创建转换。然后，选择从**Fire**到**null**的箭头，并在**条件**框中选择**Fire**和**false**选项。保留**Has
    Exit Time**选项的勾选状态。
- en: Finally, select the arrow that goes from **Grenade** to **null**. In the Conditions
    box, select the options `Grenade`, `false`. Leave the **Has Exit Time** option
    checked.![How to do it...](img/1362OT_07_25.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择从**Grenade**到**null**的箭头。在**条件**框中，选择**Grenade**和**false**选项。保留**Has Exit
    Time**选项的勾选状态。![如何操作...](img/1362OT_07_25.jpg)
- en: From the **Hierarchy** view, select the **MsLaser** character. Locate, in the
    **Inspector** view, the **Basic Controller** component and open its script.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次**视图中，选择**MsLaser**角色。在**检查器**视图中找到**基本控制器**组件并打开其脚本。
- en: 'Immediately before the end of the `Update()` function, add the following code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update()`函数结束前立即添加以下代码：
- en: '[PRE1]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the script and play your scene. You will be able to trigger the **firing_rifle**
    and **toss_grenade** animations by clicking on the **fire** button and pressing
    the *F* key. Observe how the character's legs still respond to the **Move** animation
    state.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并播放场景。您可以通过点击**fire**按钮并按*F*键来触发**firing_rifle**和**toss_grenade**动画。观察角色的腿部仍然对**Move**动画状态做出反应。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the Avatar mask is created, it can be used as a way of filtering the body
    parts that would actually play the animation states of a particular layer. In
    our case, we have constrained our **fire_rifle** and **toss_grenade** animation
    clips to the upper body of our character, leaving the lower body free to play
    the movement-related animation clips, such as walking, running, and strafing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了Avatar面具，它可以用作过滤实际播放特定层动画状态的身体部分的方式。在我们的例子中，我们将**fire_rifle**和**toss_grenade**动画片段限制在角色的上半身，使下半身可以自由播放与运动相关的动画片段，例如行走、跑步和侧滑。
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might have noticed that the **UpperBody** layer has a parameter named **Blending**,
    which we have set to **Additive**. This means that animation states in this layer
    will be added to the ones from the lower layers. If changed to **Override**, the
    animation from this would override animation states from the lower layers when
    played. In our case, **Additive** helped in keeping the aim stable when firing
    while running.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 **UpperBody** 层有一个名为 **Blending** 的参数，我们将其设置为 **Additive**。这意味着该层的动画状态将添加到下层的状态中。如果将其更改为
    **Override**，则当播放时，该层的动画将覆盖下层的动画状态。在我们的例子中，**Additive** 有助于在跑步时保持瞄准稳定。
- en: For more information on **Animation Layers** and **Avatar Body Masks**, check
    out Unity's documentation at [http://docs.unity3d.com/Manual/AnimationLayers.html](http://docs.unity3d.com/Manual/AnimationLayers.html)
    and [http://docs.unity3d.com/Manual/class-AvatarMask.html](http://docs.unity3d.com/Manual/class-AvatarMask.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 **Animation Layers** 和 **Avatar Body Masks** 的信息，请查看 Unity 的文档，链接为 [http://docs.unity3d.com/Manual/AnimationLayers.html](http://docs.unity3d.com/Manual/AnimationLayers.html)
    和 [http://docs.unity3d.com/Manual/class-AvatarMask.html](http://docs.unity3d.com/Manual/class-AvatarMask.html)。
- en: Organizing States into Sub-state Machines
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将状态组织到子状态机中
- en: Whenever the Animator area gets too cluttered, you can always think of organizing
    your Animation States into Sub-State Machines. In this recipe, we will use this
    technique to organize animation states for turning the character. Also, since
    the provided animation clips do not include Root Motion, we will use the opportunity
    to illustrate how to overcome the lack of Root Motion via script, using it to
    turn the character 45 degrees to the left and right.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画区域变得过于杂乱时，你总是可以考虑将你的动画状态组织到子状态机中。在这个食谱中，我们将使用这种技术来组织角色的转向动画状态。此外，由于提供的动画剪辑不包括根运动，我们将利用这个机会通过脚本说明如何克服根运动的不足，使用它使角色向左和向右转动
    45 度。
- en: '![Organizing States into Sub-state Machines](img/1362OT_07_37.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![将状态组织到子状态机中](img/1362OT_07_37.jpg)'
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named `Turning`, containing
    a basic scene that features an animated character. The package can be found inside
    the `1362_07_04` folder, along with animation clips called `Swat@turn_right_45_degrees.fbx`
    and `Swat@turn_left.fbx`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们准备了一个名为 `Turning` 的 Unity 包，其中包含一个具有动画角色的基本场景。该包位于 `1362_07_04` 文件夹中，还包括名为
    `Swat@turn_right_45_degrees.fbx` 和 `Swat@turn_left.fbx` 的动画剪辑。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To apply Root Motion via script, please follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过脚本应用根运动，请按照以下步骤操作：
- en: Create a new project and import the `Turning` Unity Package. Then, from the
    **Project** view, open the **mecanimPlayground** level.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并导入 `Turning` Unity 包。然后，从 **Project** 视图打开 **mecanimPlayground** 级别。
- en: Import the `Swat@turn_right_45_degrees.fbx` and `Swat@turn_left.fbx` files in
    the project.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中导入 `Swat@turn_right_45_degrees.fbx` 和 `Swat@turn_left.fbx` 文件。
- en: We need to configure our animation clips. Select the **Swat@turn_left** file
    from the **Project** view.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置我们的动画剪辑。从 **Project** 视图中选择 **Swat@turn_left** 文件。
- en: Activate the **Rig** section. Change **Animation Type** to **Humanoid**, and
    **Avatar Definition** to **Create From this Model**. Confirm by clicking on **Apply**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活 **Rig** 部分。将 **Animation Type** 更改为 **Humanoid**，并将 **Avatar Definition**
    更改为 **Create From this Model**。通过点击 **Apply** 来确认。
- en: Now, activate the **Animations** section. Select the **turn_left** clip (from
    the **Clips** list), click on the **Clamp Range** button to adjust the timeline,
    and check the **Loop Time** option. Under **Root Transform Rotation**, check **Bake
    Into Pose**, and navigate to **Baked Upon (at Start)** | **Original**. Under **Root
    Transform Position (Y)**, check **Bake Into Pose**, and select **Baked Upon (at
    Start)** | **Original**. Under **Root Transform Position (XZ)**, leave **Bake
    Into Pose** unchecked. Click on **Apply** to confirm the changes.![How to do it...](img/1362OT_07_26.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，激活 **Animations** 部分。从 **Clips** 列表中选择 **turn_left** 剪辑，点击 **Clamp Range**
    按钮调整时间线，并勾选 **Loop Time** 选项。在 **Root Transform Rotation** 下，勾选 **Bake Into Pose**，并导航到
    **Baked Upon (at Start)** | **Original**。在 **Root Transform Position (Y)** 下，勾选
    **Bake Into Pose**，并选择 **Baked Upon (at Start)** | **Original**。在 **Root Transform
    Position (XZ)** 下，不勾选 **Bake Into Pose**。点击 **Apply** 以确认更改。![如何操作...](img/1362OT_07_26.jpg)
- en: Repeat steps 4 and 5 for **Swat@turning_right_45_degrees**.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 **Swat@turning_right_45_degrees**，重复步骤 4 和 5。
- en: From the **Hierarchy** view, select the **MsLaser** character. Then, from the
    **Animator** component in the **Inspector** view, open the **MainCharacter** controller.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 视图中选择 **MsLaser** 角色。然后，从 **Inspector** 视图中的 **Animator** 组件打开
    **MainCharacter** 控制器。
- en: From the top-left corner of the **Animator** view, activate the **Parameters**
    section and use the **+** sign to create the two new **Parameters (Boolean)**
    named `TurnLeft` and `TurnRight`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**动画器**视图的左上角激活**参数**部分，并使用**+**符号创建两个新的**参数（布尔值**）命名为`TurnLeft`和`TurnRight`。
- en: Right-click on the gridded area. From the context menu, select **Create Sub-State
    Machine**. From the **Inspector** view, rename it `Turn`.![How to do it...](img/1362OT_07_27.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击网格区域。从上下文菜单中选择**创建子状态机**。在**检查器**视图中，将其重命名为`Turn`。![如何操作...](img/1362OT_07_27.jpg)
- en: Double-click on the **Turn** sub-state machine. Right-click on the gridded area,
    select **Create State** | **Empty**, and add a new state. Rename it to `Turn Left`.
    Then, add another state named `Turn Right`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**向右转**子状态机。在网格区域上右键单击，选择**创建状态** | **空**，并添加一个新状态。将其重命名为`向左转`。然后，添加另一个名为`向右转`的状态。
- en: From the **Inspector** view, populate `Turn Left` with the **turn_left** motion
    clip. Then, populate `Turn Right` with **turning_right_45_degrees**.![How to do
    it...](img/1362OT_07_28.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**视图中，将`Turn Left`填充为**turn_left**动作剪辑。然后，将`Turn Right`填充为**turning_right_45_degrees**。![如何操作...](img/1362OT_07_28.jpg)
- en: Get out of the **Turn** sub-state machine back into the **Base Layer**. By right-clicking
    on each state and selecting the option **Make Transition**, create transitions
    between **Move** and **Turn Left**, and **Move** and **Turn Right**.![How to do
    it...](img/1362OT_07_29.jpg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**向右转**子状态机退出回到**基础层**。通过在每个状态上右键单击并选择**创建转换**选项，在**移动**和**向左转**，以及**移动**和**向右转**之间创建转换。![如何操作...](img/1362OT_07_29.jpg)
- en: Enter the **Turn** sub-state machine. Then, create transitions from **Turn Left**
    and **Turn Right** into the **Move** state.![How to do it...](img/1362OT_07_30.jpg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**向右转**子状态机。然后，从**向左转**和**向右转**创建到**移动**状态的转换。![如何操作...](img/1362OT_07_30.jpg)
- en: Select the arrow that goes form **Turn Right** to **(Up) Base Layer**. It will
    turn blue. From the **Inspector** view, uncheck the **Has Exit Time** option.
    Then, access the **Conditions** list, click the **+** sign to add a new condition,
    and set it as **TurnRight** and **false**.![How to do it...](img/1362OT_07_31.jpg)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择从**向右转**到**（向上）基础层**的箭头。它将变为蓝色。从**检查器**视图中取消选中**具有退出时间**选项。然后，访问**条件**列表，点击**+**符号添加一个新条件，并将其设置为**向右转**和**false**。![如何操作...](img/1362OT_07_31.jpg)
- en: Select the arrow that goes from **(Up) Base Layer** to **Turn Right**. From
    the **Inspector** view, uncheck the **Has Exit Time** option. Then, access the
    **Conditions** list, click the **+** sign to add a new condition, and set it as
    **TurnRight** and **true**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择从**（向上）基础层**到**向右转**的箭头。在**检查器**视图中，取消选中**具有退出时间**选项。然后，访问**条件**列表，点击**+**符号添加一个新条件，并将其设置为**向右转**和**true**。
- en: Repeat steps 14 and 15 with the arrows that go between **(Up) Base Layer** and
    **Turn Left**, using **TurnLeft** as a condition, this time.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**向左转**作为条件，重复步骤14和15，使用**（向上）基础层**和**向左转**之间的箭头。
- en: From the **Hierarchy** view, select the **MsLaser** character. Then, from the
    **Inspector** view, open the script from the **BasicController** component.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**视图中，选择**MsLaser**角色。然后，从**检查器**视图中打开**BasicController**组件的脚本。
- en: 'Immediately after the `if(controller.isGrounded){` line, add:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if(controller.isGrounded){`行之后立即添加：
- en: '[PRE2]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save your script. Then, select the **MsLaser** character and, from the **Inspector**
    view, access the **Basic Controller** component. Leave the **Move Diagonally**
    and **Mouse Rotate** options unchecked. Also, leave the **Keyboard Rotate** option
    checked. Finally, play the scene. You will be able to turn left and right by using
    the *Q* and *E* keys, respectively.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的脚本。然后，选择**MsLaser**角色，并从**检查器**视图中访问**基本控制器**组件。取消选中**对角移动**和**鼠标旋转**选项。同时，保留**键盘旋转**选项选中。最后，播放场景。您可以使用**Q**键向左转，使用**E**键向右转。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As it should be clear from the recipe, the sub-state machines work in a similar
    way to groups or folders, allowing you to encapsulate a series of state machines
    into a single entity for easier reference. States from the sub-state machines
    can be transitioned from external states, in our case, the **Move** state, or
    even from different sub-state machines.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如从配方中可以清楚地看出，子状态机的工作方式与组或文件夹类似，允许您将一系列状态机封装成一个单一实体，以便更容易引用。子状态机中的状态可以从外部状态转换，在我们的例子中，是**移动**状态，甚至可以从不同的子状态机转换。
- en: Regarding the character's rotation, we have overcome the lack of root motion
    by using the `transform.Rotate(Vector3.up * (Time.deltaTime * -45.0f), Space.World);`
    command to make the character actually turn around when the *Q* and *E* keys are
    being held down. This command was used in conjunction with `animator.SetBool("TurnLeft",
    true);`, which triggers the right animation clip.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于角色的旋转，我们通过使用`transform.Rotate(Vector3.up * (Time.deltaTime * -45.0f), Space.World);`命令来克服根运动的不足，使角色在按下*Q*和*E*键时实际上能够转身。这个命令与`animator.SetBool("TurnLeft",
    true);`一起使用，触发正确的动画剪辑。
- en: Transforming the Character Controller via script
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过脚本转换角色控制器
- en: Applying **Root Motion** to your character might be a very practical and accurate
    way to animate it. However, every now and then, you might need to manually control
    one or two aspects of the character movement. Perhaps you only have an in-place
    animation to work with, or maybe you want the character's movement to be affected
    by other variables. In these cases, you will need to override the root motion
    via script.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Root Motion**应用于你的角色可能是一种非常实用且准确的方式来动画化它。然而，时不时地，你可能需要手动控制角色运动的一两个方面。也许你只有原地动画可以操作，或者你可能想让角色的运动受到其他变量的影响。在这些情况下，你需要通过脚本覆盖根运动。
- en: To illustrate this issue, this recipe makes use of an animation clip for jumping,
    which originally moves the character only in the Y-axis. In order to make her
    move forward or backwards while jumping, we will learn how to access the character's
    velocity to inform the jump's direction via the script.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个问题，这个配方使用了一个跳跃动画剪辑，它最初只沿Y轴移动角色。为了让她在跳跃时向前或向后移动，我们将学习如何通过脚本访问角色的速度来通知跳跃的方向。
- en: '![Transforming the Character Controller via script](img/1362OT_07_38.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![通过脚本转换角色控制器](img/1362OT_07_38.jpg)'
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named `Jumping`, containing
    a basic scene that features an animated character. The package can be found inside
    the `1362_07_05` folder, along with the animation clip called `Swat@rifle_jump`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们准备了一个名为`Jumping`的Unity包，其中包含一个具有动画角色的基本场景。该包位于`1362_07_05`文件夹中，包括名为`Swat@rifle_jump`的动画剪辑。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To apply the Root Motion via script, please follow these steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过脚本应用根运动，请按照以下步骤操作：
- en: Create a new project and import the `Jumping` Unity Package. Then, from the
    **Project** view, open the **mecanimPlayground** level.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并导入`Jumping` Unity包。然后，从**Project**视图中打开**mecanimPlayground**级别。
- en: Import the `Swat@rifle_jump.fbx` file to the project.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Swat@rifle_jump.fbx`文件导入到项目中。
- en: We need to configure our animation clip. From the **Project** view, select the
    **Swat@rifle_jump** file.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置我们的动画剪辑。从**Project**视图中选择**Swat@rifle_jump**文件。
- en: Activate the **Rig** section. Change **Animation Type** to **Humanoid**, and
    **Avatar Definition** to **Create From this Model**. Confirm this by clicking
    on **Apply**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活**Rig**部分。将**Animation Type**更改为**Humanoid**，并将**Avatar Definition**设置为**Create
    From this Model**。通过点击**Apply**来确认这一设置。
- en: Now, activate the **Animations** section. Select the **rifle_jump** clip (from
    the **Clips** list), click on the **Clamp Range** button to adjust the timeline,
    and check the **Loop Time** and **Loop Pose** options. Under **Root Transform
    Rotation**, check **Bake Into Pose**, and select **Baked Upon (at Start)** | **Original**.
    Under **Root Transform Position (Y)**, leave **Bake into Pose** unchecked, and
    select **Baked Upon (at Start)** | **Original**. Under **Root Transform Position
    (XZ)**, leave **Bake Into Pose** unchecked. Click on **Apply** to confirm the
    changes.![How to do it...](img/1362OT_07_32.jpg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，激活**Animations**部分。从**Clips**列表中选择**rifle_jump**剪辑，点击**Clamp Range**按钮调整时间轴，并检查**Loop
    Time**和**Loop Pose**选项。在**Root Transform Rotation**下，检查**Bake Into Pose**，并选择**Baked
    Upon (at Start)** | **Original**。在**Root Transform Position (Y)**下，不勾选**Bake into
    Pose**，并选择**Baked Upon (at Start)** | **Original**。在**Root Transform Position
    (XZ)**下，不勾选**Bake Into Pose**。点击**Apply**以确认更改。![如何做到这一点...](img/1362OT_07_32.jpg)
- en: From the **Hierarchy** view, select the **MsLaser** character. Then, from the
    **Animator** component in the **Inspector** view, open the **MainCharacter** controller.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Hierarchy**视图中选择**MsLaser**角色。然后，从**Inspector**视图中的**Animator**组件，打开**MainCharacter**控制器。
- en: From the top-left corner of the **Animator** view, activate the **Parameters**
    section, and use the **+** sign to create a new **Parameters (Boolean)** named
    `Jump`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Animator**视图的左上角，激活**Parameters**部分，并使用**+**符号创建一个新的**Parameters (Boolean)**名为`Jump`。
- en: Right-click on the gridded area and, from the context menu, select **Create
    State** | **Empty**. Change its name, from the **Inspector** view, to `Jump`.![How
    to do it...](img/1362OT_07_33.jpg)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击网格区域，从上下文菜单中选择**创建状态** | **空**。从**检查器**视图更改其名称为`跳跃`。![如何操作...](img/1362OT_07_33.jpg)
- en: Select the **Jump** state. Then, from the **Inspector** view, populate it with
    the **rifle_jump** Motion clip.![How to do it...](img/1362OT_07_34.jpg)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**跳跃**状态。然后，从**检查器**视图填充它，使用**rifle_jump**运动剪辑。![如何操作...](img/1362OT_07_34.jpg)
- en: Find and right-click on the **Any State**. Then, selecting the **Make Transition**
    option, create a transition from **Any State** to **Jump**. Select the transition,
    uncheck **Has Exit Time**, and use the **Jump** variable as a condition (**true**).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到并右键单击**任何状态**。然后，从**检查器**视图中选择**创建转换**选项，从**任何状态**到**跳跃**创建一个转换。选择转换，取消选中**有退出时间**，并使用**跳跃**变量作为条件（**true**）。
- en: Now, create a transition from **Jump** to **Move**.![How to do it...](img/1362OT_07_35.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**跳跃**到**移动**创建一个转换。![如何操作...](img/1362OT_07_35.jpg)
- en: Configure the transitions between **Jump** and **Move**, leaving **Has Exit
    Time** checked, and use the **Jump** variable as a condition (**false**).![How
    to do it...](img/1362OT_07_36.jpg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置**跳跃**和**移动**之间的转换，保留**有退出时间**选中，并使用**跳跃**变量作为条件（**false**）。![如何操作...](img/1362OT_07_36.jpg)
- en: From the **Hierarchy** view, select the **MsLaser** character. Then, from the
    **Inspector** view, open the script from the **BasicController** component.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中选择**MsLaser**角色。然后，从**检查器**视图打开**BasicController**组件的脚本。
- en: 'Right before the `Start()` function, add the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`函数之前立即添加以下代码：
- en: '[PRE3]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the `Update()` function, find the line containing the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update()`函数内部，找到包含以下代码的行：
- en: '[PRE4]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And add the following lines immediatly after it:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在它之后立即添加以下行：
- en: '[PRE5]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, add a new function, following immediately before the final `}` of
    the code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在代码的最后一个`}`之前立即添加一个新函数：
- en: '[PRE6]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save your script and play the scene. You will be able to jump around using the
    *Space* key. Observe how the character's velocity affects the direction of the
    jump.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并播放场景。你将能够使用*空格*键跳跃。观察角色的速度如何影响跳跃的方向。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Observe that once this function is added to the script, the **Apply Root Motion**
    field, in the **Animator** component, changes from a checked box to **Handled
    by Script**. The reason is that in order to override the animation clip''s original
    movement, we have placed, inside Unity''s `OnAnimatorMove()` function, a series
    of commands to move our character controller while jumping. The line of code:
    `controller.Move (deltaPosition);` basically replaces the jump''s direction from
    the original animation with the `deltaPosition` 3D Vector, which is made of the
    character''s velocity at the instant before the jump (*x* and *z*-axis) and the
    calculation between the `jumpHeight` variable and gravity force overtime (*y*-axis).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦将此函数添加到脚本中，**Animator**组件中的**应用根运动**字段将从勾选框变为**由脚本处理**。原因是，为了覆盖动画剪辑的原始运动，我们在Unity的`OnAnimatorMove()`函数中放置了一系列命令来移动我们的角色控制器，使其在跳跃时移动。代码行：`controller.Move
    (deltaPosition);`基本上用`deltaPosition` 3D向量替换了跳跃的方向，该向量由跳跃前的瞬间角色的速度（*x*和*z*-轴）以及`jumpHeight`变量和重力力的计算（*y*-轴）组成。
- en: Adding rigid props to animated characters
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将刚体属性添加到动画角色中
- en: In case you haven't included a sufficient number of props to your character
    when modeling and animating it, you might want to give her the chance of collecting
    new ones at runtime. In this recipe, we will learn how to instantiate a GameObject
    and assign it to a character, respecting the animation hierarchy.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在建模和动画化角色时没有包含足够多的属性，你可能希望给她在运行时收集新属性的机会。在这个菜谱中，我们将学习如何实例化一个GameObject并将其分配给一个角色，同时尊重动画层次结构。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named `Props`, containing
    a basic scene that features an animated character and a prefab named **badge**.
    The package can be found inside the `1362_07_06` folder.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们准备了一个名为`Props`的Unity包，其中包含一个基本场景，该场景包含一个动画角色和一个名为**徽章**的预制件。该包位于`1362_07_06`文件夹中。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To add a rigid prop at runtime to an animated character, follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时将刚体属性添加到动画角色中，请按照以下步骤操作：
- en: Create a new project and import the `Props` Unity Package. Then, from the **Project**
    view, open the **mecanimPlayground** level.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并导入`Props` Unity包。然后，从**项目**视图打开**mecanimPlayground**级别。
- en: 'From the **Project** view, add the **badge** prop to the scene by dragging
    it onto the **Hierarchy** view. Then, make it a child of the **mixamorig:Spine2**
    transform (use the **Hierarchy** tree to navigate to **MsLaser** | **mixamorig:Hips**
    | **mixamorig:Spine** | **mixamorig:Spine1** | **mixamorig:Spine2**). Then, make
    the **badge** object visible above the character''s chest by changing its **Transform
    Position** to **X**: `-0.08`, **Y**: `0,` **Z**: `0.15`; and **Rotation** to **X**:
    `0.29`, **Y**: `0.14`, **Z**:`-13.29`.![How to do it...](img/1362OT_07_39.jpg)'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**视图，通过将其拖放到**层次结构**视图来将**徽章**道具添加到场景中。然后，将其设置为**mixamorig:Spine2**变换的子对象（使用**层次结构**树导航到**MsLaser**
    | **mixamorig:Hips** | **mixamorig:Spine** | **mixamorig:Spine1** | **mixamorig:Spine2**）。然后，通过将**变换位置**更改为**X**：`-0.08`，**Y**：`0`，**Z**：`0.15`；以及**旋转**更改为**X**：`0.29`，**Y**：`0.14`，**Z**：`-13.29`，使**徽章**对象在角色的胸部上方可见。![如何操作...](img/1362OT_07_39.jpg)
- en: Make a note of the **Position** and **Rotation** values, and delete the **badge**
    object from the scene.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录**位置**和**旋转**值，并从场景中删除**徽章**对象。
- en: 'Add a new **Cube** to the scene (drop-down **Create** | **3D Object** | **Cube**),
    rename it as **PropTrigger**, and change its Position to **X**: `0`, **Y**: `0.5`,
    **Z**: `2`.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个新的**立方体**（下拉**创建** | **3D 对象** | **立方体**），重命名为**PropTrigger**，并将其位置更改为**X**：`0`，**Y**：`0.5`，**Z**：`2`。
- en: From the **Inspector** view's **Box Collider** component, check the **Is Trigger**
    option.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**检查器**视图的**盒子碰撞器**组件中，勾选**是触发器**选项。
- en: From the **Project** view, create a new **C# Script** named `AddProp.cs`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**视图创建一个新的**C# 脚本**，命名为`AddProp.cs`。
- en: 'Open the script and add the following code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并添加以下代码：
- en: '[PRE7]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save and close the script.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭脚本。
- en: Attach the **AddProp.cs** script to the **PropTrigger** GameObject.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AddProp.cs**脚本附加到**PropTrigger**游戏对象。
- en: 'Select the **PropTrigger** textbox and check out its **Add Prop** component.
    First, populate the **Prop** field with the **badge** prefab. Then, populate **Target
    Bone** with the **mixamorig:Spine2** transform. Finally, assign the **Position**
    and **Rotation** values that we have previously made a note of to the **Position
    Offset** and **Rotation Offset** fields, respectively (**Position Offset**: **X**:
    `-0.08`, **Y**: `0,` **Z**: `0.15`; **Rotation Offset**: **X**: `0.29`, **Y**:
    `0.14`, **Z**:`-13.29`).![How to do it...](img/1362OT_07_40.jpg)'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**PropTrigger**文本框并查看其**添加道具**组件。首先，将**道具**字段填充为**徽章**预制体。然后，将**目标骨骼**填充为**mixamorig:Spine2**变换。最后，将我们之前记录的**位置**和**旋转**值分别分配给**位置偏移**和**旋转偏移**字段（**位置偏移**：**X**：`-0.08`，**Y**：`0`，**Z**：`0.15`；**旋转偏移**：**X**：`0.29`，**Y**：`0.14`，**Z**：`-13.29`）。![如何操作...](img/1362OT_07_40.jpg)
- en: Play the scene. Using the 'WASD' keyboard control scheme, direct the character
    to the **PropTrigger** textbox. Colliding with it will add a badge to the character.![How
    to do it...](img/1362OT_07_41.jpg)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 演示场景。使用“WASD”键盘控制方案，将角色引导到**PropTrigger**文本框。与之碰撞将为角色添加徽章。![如何操作...](img/1362OT_07_41.jpg)
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once it's been triggered by the character, the script attached to **PropTrigger**
    instantiates the assigned prefab, making it a child of the bones that they have
    been "placed into". The **Position Offset** and **Rotation Offset** can be used
    to fine-tune the exact position of the prop (relative to its parent transform).
    As the props become parented by the bones of the animated character, they will
    follow and respect its hierarchy and animation. Note that the script checks for
    the preexisting props of the same name before actually instantiating a new one.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦被角色触发，附加到**PropTrigger**的脚本将实例化指定的预制体，使其成为放置其中的骨骼的子对象。**位置偏移**和**旋转偏移**可用于微调道具的确切位置（相对于其父变换）。当道具成为动画角色的骨骼的父对象时，它们将跟随并尊重其层次结构和动画。请注意，脚本在实例化新对象之前会检查是否存在同名的前置道具。
- en: There's more...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'You can make a similar script to remove the props. In this case, the `OnTriggerEnter`
    function will contain only the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个类似的脚本以移除道具。在这种情况下，`OnTriggerEnter`函数将只包含以下代码：
- en: '[PRE8]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using Animation Events to throw an object
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画事件抛出对象
- en: Now that your animated character is ready, you might want to coordinate some
    of her actions with her animation states. In this recipe, we will exemplify this
    by making the character throw an object whenever the appropriate animation clip
    reaches the right time. To do so, we will make use of **Animation Events**, which
    basically trigger a function from the animation clip's timeline. This feature,
    recently introduced to the **Mecanim** system, should feel familiar to those experienced
    with the **Add Event** feature of the classic **Animation** panel.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在动画角色已经准备好了，你可能想协调她的一些动作与她的动画状态。在这个配方中，我们将通过使角色在适当的动画剪辑达到正确的时间时扔一个对象来举例说明这一点。为此，我们将利用**动画事件**，它基本上会从动画剪辑的时间线中触发一个函数。这个功能是最近添加到**Mecanim**系统中的，对于那些熟悉经典**动画**面板的**添加事件**功能的用户来说应该很熟悉。
- en: '![Using Animation Events to throw an object](img/1362OT_07_42.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![使用动画事件投掷对象](img/1362OT_07_42.jpg)'
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named `Throwing`, containing
    a basic scene that features an animated character and a prefab named **EasterEgg**.
    The package can be found inside the `1362_07_07` folder.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们准备了一个名为`Throwing`的Unity包，其中包含一个基本场景，包含一个动画角色和一个名为**EasterEgg**的预制件。该包位于`1362_07_07`文件夹中。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make an animated character throw an Easter egg (!), follow these steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要使动画角色扔一个复活节彩蛋(!)，请按照以下步骤操作：
- en: Create a new project and import the `Throwing` Unity Package. Then, from the
    **Project** view, open the **mecanimPlayground** level.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并导入`Throwing`Unity包。然后，从**项目**视图中，打开**mecanimPlayground**关卡。
- en: Play the level and press *F* on your keyboard. The character will move as if
    she is throwing something with her right hand.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放关卡并按键盘上的*F*键。角色将像用右手扔东西一样移动。
- en: From the **Project** view, create a new **C# Script** named `ThrowObject.cs.`
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**视图中，创建一个新的**C#脚本**，命名为`ThrowObject.cs`。
- en: 'Open the script and add the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并添加以下代码：
- en: '[PRE9]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save and close the script.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭脚本。
- en: Attach the **ThrowObject.cs** script to the character's GameObject named **MsLaser**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ThrowObject.cs**脚本附加到名为**MsLaser**的角色GameObject上。
- en: 'Select the **MsLaser** object. From the **Inspector** view, check out its **Throw
    Object** component. Then, populate the **Prop** field with a prefab named **EasterEgg**.
    Populate **Hand** with **mixamorig:RightHand**. Also, change **Pos Offset** to
    **X**: `0`; **Y**: `0.07`; **Z**: `0.04`. Finally, change **Force** to **X**:
    `0`; **Y**: `200`; **Z**: `500`.![How to do it...](img/1362OT_07_43.jpg)'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**MsLaser**对象。从**检查器**视图中，检查其**投掷对象**组件。然后，将名为**EasterEgg**的预制件填充到**道具**字段中。将**手**设置为**mixamorig:RightHand**。此外，将**位置偏移**更改为**X**：`0`；**Y**：`0.07`；**Z**：`0.04`。最后，将**力**更改为**X**：`0`；**Y**：`200`；**Z**：`500`。![如何操作...](img/1362OT_07_43.jpg)
- en: From the **Project** view, select the **Swat@toss_grenade** file. Then, from
    the **Inspector** view, access the **Animation** section and scroll down to the
    **Events** section.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**视图中，选择**Swat@toss_grenade**文件。然后，从**检查器**视图中，访问**动画**部分并滚动到**事件**部分。
- en: Expand the **Events** section. Drag the playhead to approximately **0:17 (017.9%)**
    of the animation timeline. Then, click on the button with the *marker +* icon
    to add an **Animation Event**. From the **Edit Animation Event** window, set **Function**
    as `Prepare`. Close the window.![How to do it...](img/1362OT_07_44.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**事件**部分。将播放头拖动到大约**0:17 (017.9%)**的动画时间轴上。然后，点击带有*marker +* 图标的按钮以添加一个**动画事件**。从**编辑动画事件**窗口，将**函数**设置为`Prepare`。关闭窗口。![如何操作...](img/1362OT_07_44.jpg)
- en: Add a new animation event at approximately **1:24 (057.1%)** of the animation
    timeline. This time, from the **Edit Animation Event** window, set **Function**
    as `Throw`. Close the window.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画时间轴的大约**1:24 (057.1%)**处添加一个新的动画事件。这次，从**编辑动画事件**窗口，将**函数**设置为`Throw`。关闭窗口。
- en: Click on the **Apply** button to save the changes.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**按钮以保存更改。
- en: Play your scene. Your character will now be able to throw an Easter egg when
    you press the *F* key.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的场景。现在，当你按下*F*键时，角色将能够扔一个复活节彩蛋。
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the **toss_grenade** animation reaches the moments that we have set our
    **Events** to, the `Prepare()` and `throw()` functions are called. The former
    instantiates a prefab, now named **projectile**, into the character's hand (**Projectile
    Offset** values are used to fine-tune its position), also making it respect the
    character's hierarchy. Also, it disables the prefab's collider and destroys its
    `Rigidbody` component, provided it has one. The latter function enables the projectile's
    collider, and adds a `Rigidbody` component to it, making it independent from the
    character's hand. Finally, it adds a relative force to the projectile's `Rigidbody`
    component, so it will behave as if thrown by the character. The **Compensation
    YAngle** can be used to adjust the direction of the grenade, if necessary.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当**toss_grenade**动画达到我们设置的事件时刻时，将调用`Prepare()`和`throw()`函数。前者将一个预制体实例化，现在命名为**projectile**，放置到角色的手中（使用**Projectile
    Offset**值来微调其位置），同时也使其尊重角色的层次结构。此外，它禁用了预制体的碰撞器并销毁了其`Rigidbody`组件（如果有的话）。后者函数启用了projectile的碰撞器，并为其添加了一个`Rigidbody`组件，使其独立于角色的手。最后，它向projectile的`Rigidbody`组件添加了一个相对力，使其表现得像被角色投掷出去。**Compensation
    YAngle**可以用来调整手榴弹的方向，如果需要的话。
- en: Applying Ragdoll physics to a character
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Ragdoll物理应用于角色
- en: Action games often make use of **Ragdoll physics** to simulate the character's
    body reaction to being unconsciously under the effect of a hit or explosion. In
    this recipe, we will learn how to set up and activate Ragdoll physics to our character
    whenever she steps in a landmine object. We will also use the opportunity to reset
    the character's position and animations a number of seconds after that event has
    occurred.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 动作游戏通常利用**ragdoll物理**来模拟角色在受到打击或爆炸无意识影响下的身体反应。在本教程中，我们将学习如何设置并激活ragdoll物理，以便角色在踏入地雷物体时触发。我们还将利用这个机会在事件发生后几秒钟重置角色的位置和动画。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named `Ragdoll`, containing
    a basic scene that features an animated character and two prefabs, already placed
    into the scene, named **Landmine** and **Spawnpoint**. The package can be found
    inside the `1362_07_08` folder.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们准备了一个名为`Ragdoll`的Unity包，其中包含一个基本场景，包含一个动画角色和两个预制体，已经放置在场景中，分别命名为**Landmine**和**Spawnpoint**。该包位于`1362_07_08`文件夹中。
- en: How to do it...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To apply Ragdoll physics to your character, follow these steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Ragdoll物理应用于你的角色，请按照以下步骤操作：
- en: Create a new project and import the `Ragdoll` Unity Package. Then, from the
    **Project** view, open the **mecanimPlayground** level.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并导入`Ragdoll`Unity包。然后，从**项目**视图中打开**mecanimPlayground**级别。
- en: 'You will see the animated MsLaser character and two discs: **Landmine** and
    **Spawnpoint**.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到动画的MsLaser角色和两个圆盘：**Landmine**和**Spawnpoint**。
- en: First, let's set up our **Ragdoll**. Access the **GameObject** | **3D Object**
    | **Ragdoll...** menu and the **Ragdoll wizard** will pop-up.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置我们的**Ragdoll**。访问**游戏对象** | **3D对象** | **Ragdoll...**菜单，**Ragdoll向导**将弹出。
- en: 'Assign the transforms as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式分配变换：
- en: '**Pelvis**: mixamorig:Hips'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨盆**：mixamorig:Hips'
- en: '**Left Hips**: mixamorig:LeftUpLeg'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左臀**：mixamorig:LeftUpLeg'
- en: '**Left Knee**: mixamorig:LeftLeg'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左膝**：mixamorig:LeftLeg'
- en: '**Left Foot**: mixamorig:LeftFoot'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左脚**：mixamorig:LeftFoot'
- en: '**Right Hips**: mixamorig:RightUpLeg'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右臀**：mixamorig:RightUpLeg'
- en: '**Right Knee**: mixamorig:RightLeg'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右膝**：mixamorig:RightLeg'
- en: '**Right Foot**: mixamorig:RightFoot'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右脚**：mixamorig:RightFoot'
- en: '**Left Arm**: mixamorig:LeftArm'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左臂**：mixamorig:LeftArm'
- en: '**Left Elbow**: mixamorig:LeftForeArm'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左肘**：mixamorig:LeftForeArm'
- en: '**Right Arm**: mixamorig:RightArm'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右臂**：mixamorig:RightArm'
- en: '**Right Elbow**: mixamorig:RightForeArm'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右肘**：mixamorig:RightForeArm'
- en: '**Middle Spine**: mixamorig:Spine1'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中脊**：mixamorig:Spine1'
- en: '**Head**: mixamorig:Head'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：mixamorig:Head'
- en: '**Total Mass**: 20'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总质量**：20'
- en: '**Strength**: 50'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力量**：50'
- en: '![How to do it...](img/1362OT_07_45.jpg)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1362OT_07_45.jpg)'
- en: From the **Project** view, create a new **C# Script** named `RagdollCharacter.cs`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**视图中，创建一个新的**C# 脚本**，命名为`RagdollCharacter.cs`。
- en: 'Open the script and add the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并添加以下代码：
- en: '[PRE10]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save and close the script.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭脚本。
- en: Attach the **RagdollCharacter.cs** script to the **MsLaser** GameObject. Then,
    select the **MsLaser** character and, from the top of the **Inspector** view,
    change its tag to **Player**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**RagdollCharacter.cs**脚本附加到**MsLaser**游戏对象上。然后，选择**MsLaser**角色，从**检查器**视图的顶部，将其标签更改为**Player**。
- en: From the **Project** view, create a new **C# Script** named `Landmine.cs`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**视图中，创建一个新的**C# 脚本**，命名为`Landmine.cs`。
- en: 'Open the script and add the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并添加以下代码：
- en: '[PRE11]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save and close the script.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭脚本。
- en: Attach the script to the **Landmine** GameObject.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本附加到 **Landmine** GameObject。
- en: Play the scene. Using the *WASD* keyboard control scheme, direct the character
    to the **Landmine** GameObject. Colliding with it will activate the character's
    Ragdoll physics and apply an explosion force to it. As a result, the character
    will be thrown away to a considerable distance and will no longer be in the control
    of its body movements, akin to a ragdoll.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 演示场景。使用 *WASD* 键盘控制方案，将角色引导至 **Landmine** GameObject。与之碰撞将激活角色的 Ragdoll 物理效果，并对其施加爆炸力。因此，角色将被抛出相当远的距离，并且将不再受其身体运动的控制，就像一个
    Ragdoll。
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Unity''s **Ragdoll Wizard** assigns, to selected transforms, the components
    `Collider`, `Rigidbody`, and `Character Joint`. In conjunction, those components
    make Ragdoll physics possible. However, those components must be disabled whenever
    we want our character to be animated and controlled by the player. In our case,
    we switch those components on and off using the `RagdollCharacter` script and
    its two functions: `ActivateRagdoll()` and `DeactivateRagdoll()`, the latter includes
    instructions to re-spawn our character in the appropriate place.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的 **Ragdoll Wizard** 将 `Collider`、`Rigidbody` 和 `Character Joint` 组件分配给选定的变换。这些组件共同作用，使得
    Ragdoll 物理成为可能。然而，当我们想要我们的角色被动画化和由玩家控制时，这些组件必须被禁用。在我们的例子中，我们使用 `RagdollCharacter`
    脚本及其两个函数：`ActivateRagdoll()` 和 `DeactivateRagdoll()` 来开关这些组件，后者包括将我们的角色重新生成到适当位置的指令。
- en: For the testing purposes, we have also created the `Landmine` script, which
    calls `RagdollCharacter` script's function named `ActivateRagdoll()`. It also
    applies an explosion force to our ragdoll character, throwing it outside the explosion
    site.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我们还创建了一个 `Landmine` 脚本，该脚本调用 `RagdollCharacter` 脚本中的 `ActivateRagdoll()`
    函数。它还将爆炸力应用到我们的 Ragdoll 角色上，将其抛出爆炸现场。
- en: There's more...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Instead of resetting the character's transform settings, you could have destroyed
    its GameObject and instantiated a new one over the respawn point using **Tags**.
    For more information on this subject, check Unity's documentation at [http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html](http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是重置角色的变换设置，你可以销毁其 GameObject，并在重生点使用 **Tags** 实例化一个新的 GameObject。有关此主题的更多信息，请参阅
    Unity 的文档：[http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html](http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)。
- en: Rotating the character's torso to aim a weapon
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将角色的躯干旋转以瞄准武器
- en: When playing a third-person character, you might want her to aim her weapon
    at some target that is not directly in front of her, without making her change
    her direction. In these cases, you will need to apply what is called a *procedural
    animation*, which does not rely on premade animation clips, but rather on the
    processing of other data, such as player input, to animate the character. In this
    recipe, we will use this technique to rotate the character's spine by moving the
    mouse, allowing for adjustments in the character's aim. We will also use this
    opportunity to cast a ray from the character's weapon and display a crosshair
    over the nearest object on target. Please note that this approach will work with
    the cameras standing behind the third-person controlled characters.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当扮演第三人称角色时，你可能希望她瞄准她前方不直接的目标，而不改变她的方向。在这些情况下，你需要应用所谓的 *过程动画*，它不依赖于预制的动画剪辑，而是依赖于对其他数据的处理，例如玩家输入，以动画化角色。在这个菜谱中，我们将使用这种技术通过移动鼠标来旋转角色的脊柱，从而调整角色的瞄准。我们还将利用这个机会从角色的武器发射一条射线，并在目标上最近的对象上显示一个准星。请注意，这种方法适用于站在第三人称控制角色背后的摄像机。
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: For this recipe, we have prepared a Unity Package named `AimPointer`, containing
    a basic scene that features a character armed with a laser pointer. The package,
    which also includes the `crossAim` sprite that is to be used as a crosshair for
    aiming, can be found inside the `1362_07_09` folder.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们准备了一个名为 `AimPointer` 的 Unity 包，其中包含一个基本场景，场景中有一个装备激光指示器的角色。该包还包括用作瞄准准星的
    `crossAim` 精灵，可以在 `1362_07_09` 文件夹中找到。
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Create a new project and import the `AimPointer` Unity Package. Then, from the
    **Project** view, open the **mecanimPlayground** level. You will see an animated
    character named **MsLaser** holding the **pointerPrefab** object.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并导入`AimPointer` Unity包。然后，从**项目**视图打开**mecanimPlayground**级别。你会看到一个名为**MsLaser**的动画角色，它手持**pointerPrefab**对象。
- en: From the **Project** view, create a new **C# Script** named `MouseAim.cs`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**视图创建一个新的**C# 脚本**，命名为`MouseAim.cs`。
- en: 'Open the script and add the following code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并添加以下代码：
- en: '[PRE12]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save and close the script.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭脚本。
- en: From the **Hierarchy** view, create a new **UI** | **Image** GameObject. Then,
    from the **Inspector** view, change its name to `crosshair`. Also, in **Rect**
    **Transform**, set its **Width** and **Height** to `16` and populate **Source
    Image** field with the **crossAim** sprite.![How to do it...](img/1362OT_07_46.jpg)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图创建一个新的**UI** | **Image**游戏对象。然后，从**检查器**视图，将其名称更改为`crosshair`。在**矩形**
    **变换**中，将**宽度**和**高度**设置为`16`，并在**源图像**字段中填充**crossAim**精灵。![如何操作...](img/1362OT_07_46.jpg)
- en: Attach the **MouseAim.cs** script to the **MsLaser** GameObject.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MouseAim.cs`脚本附加到**MsLaser**游戏对象上。
- en: Select the **MsLaser** GameObject and from the **Inspector** view's **Mouse
    Aim** component, populate the **Spine** field with **mixamorig:Spine**; the **Weapon**
    field with **pointerPrefab**; and the **Crosshair** field with the **crosshair**
    UI GameObject.![How to do it...](img/1362OT_07_47.jpg)
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**MsLaser**游戏对象，并从**检查器**视图的**鼠标瞄准**组件中，将**脊柱**字段填充为**mixamorig:Spine**；将**武器**字段填充为**pointerPrefab**；将**十字准线**字段填充为**crosshair**
    UI游戏对象。![如何操作...](img/1362OT_07_47.jpg)
- en: Play the scene. You will now be able to rotate the character's torso by moving
    the mouse. Even better, the crosshair GUI texture will be displayed at the top
    of the object that is being aimed at by the pointer.![How to do it...](img/1362OT_07_48.jpg)
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。现在，你可以通过移动鼠标来旋转角色的躯干。更好的是，十字准线GUI纹理将显示在指针所指向的对象顶部。![如何操作...](img/1362OT_07_48.jpg)
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You might have noticed that all the code for rotating the character's spine
    is inside the `LateUpdate` function, as opposed to the more common `Update` function.
    The reason for this is to make sure that all the transform manipulation will be
    executed after the original animation clip is played, overriding it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有旋转角色脊柱的代码都在`LateUpdate`函数内部，而不是更常见的`Update`函数中。这样做的原因是为了确保所有的变换操作都会在原始动画剪辑播放之后执行，从而覆盖它。
- en: Regarding the spine rotation, our script adds the horizontal and vertical speed
    of the mouse to the `xAxis` and `yAxis` float variables. These variables are then
    constrained within the specified limits, avoiding distortions to the character's
    model. Finally, the `spine` object transform rotation for *x* and *y* axes are
    set to `xAxis` and `yAxis` respectively. The *z*-axis is preserved from the original
    animation clip.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 关于脊柱旋转，我们的脚本将鼠标的水平速度和垂直速度添加到`xAxis`和`yAxis`浮点变量中。然后，这些变量被限制在指定的范围内，避免对角色模型的扭曲。最后，将`spine`对象变换旋转的*x*和*y*轴分别设置为`xAxis`和`yAxis`。*z*轴保留原始动画剪辑中的原始旋转。
- en: Additionally, our script uses a `Raycast` command to detect if there is any
    object's collider within the weapon's aim, in which case a crosshair will be drawn
    on the screen.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的脚本使用`Raycast`命令来检测武器瞄准范围内是否有任何对象的碰撞器，在这种情况下，屏幕上会绘制一个十字准线。
- en: There's more...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Since this recipe's script was tailored for cameras standing behind the third-person
    controlled characters, we have included a more generic solution to the problem—in
    fact, a similar approach to the one presented in *Unity 4.x Cookbook*, *Packt
    Publishing*. An alternate script named `MouseAimLokkAt`, which can be found inside
    the `1362_07_09` folder, starts by converting our bi-dimensional mouse cursor
    screen's coordinates to the three-dimensional world space coordinates (stored
    in a `point` variable). Then, it rotates the character's torso towards the *point*
    location, using the `LookAt()` command to do so. Additionally, it makes sure that
    the spine does not extrapolate `minY` and `maxY` angles, otherwise causing distortions
    to the character model. Also, we have included a `Compensation YAngle` variable
    that makes it possible for us to fine-tune the character's alignment with the
    mouse cursor. Another addition is the option to freeze the X-axis rotation, in
    case you just want the character to rotate the torso laterally, but not look up
    or down. Again, this script uses a `Raycast` command to detect objects in front
    of the weapon's aim, drawing a crosshair on the screen when they are present.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个菜谱的脚本是为站在第三人称控制角色背后的摄像机定制的，因此我们为这个问题提供了一个更通用的解决方案——实际上，与*Unity 4.x Cookbook*，*Packt
    Publishing*中提出的方法类似。一个名为`MouseAimLokkAt`的替代脚本，可以在`1362_07_09`文件夹中找到，它首先将我们的二维鼠标光标屏幕坐标转换为三维世界空间坐标（存储在一个`point`变量中）。然后，它使用`LookAt()`命令将角色的躯干旋转到*point*位置。此外，它确保脊柱不会外推`minY`和`maxY`角度，否则会导致角色模型变形。另外，我们还包含了一个`Compensation
    YAngle`变量，使我们能够微调角色与鼠标光标的对齐。另一个新增功能是冻结X轴旋转，以防你只想让角色横向旋转躯干，而不向上或向下看。同样，这个脚本使用`Raycast`命令来检测武器瞄准前的物体，当它们存在时在屏幕上绘制一个十字准星。
