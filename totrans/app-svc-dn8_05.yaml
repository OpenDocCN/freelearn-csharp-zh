- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Multitasking and Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多任务处理和并发
- en: This chapter is about allowing multiple actions to occur at the same time to
    improve performance, scalability, and user productivity for the applications that
    you build.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍允许多个操作同时发生，以提高您构建的应用程序的性能、可扩展性和用户生产力。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding processes, threads, and tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解进程、线程和任务
- en: Running tasks asynchronously
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步运行任务
- en: Synchronizing access to shared resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: Understanding `async` and `await`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`async`和`await`
- en: Understanding processes, threads, and tasks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解进程、线程和任务
- en: A **process**, with one example being each of the console applications we have
    created, has resources like memory and threads allocated to it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程**，例如我们创建的每个控制台应用程序，都分配了如内存和线程等资源。'
- en: A **thread** executes your code statement by statement. By default, each process
    only has one thread, and this can cause problems when we need to do more than
    one task at the same time. Threads are also responsible for keeping track of things
    like the currently authenticated user and any internationalization rules that
    should be followed for the current language and region.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**通过逐条执行代码语句来执行您的代码。默认情况下，每个进程只有一个线程，当我们需要同时执行多个任务时，这可能会导致问题。线程还负责跟踪诸如当前认证用户以及应遵循的任何针对当前语言和区域的国际化规则等事项。'
- en: Windows and most other modern operating systems use **preemptive multitasking**,
    which simulates the parallel execution of tasks. It divides the processor time
    among the threads, allocating a **time slice** to each thread one after another.
    The current thread is suspended when its time slice finishes. The processor then
    allows another thread to run for a time slice.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Windows和大多数其他现代操作系统使用**抢占式多任务处理**，它模拟任务的并行执行。它将处理器时间分配给线程，依次为每个线程分配一个**时间片**。当前线程的时间片结束时，它将被挂起。然后处理器允许另一个线程运行一个时间片。
- en: When Windows switches from one thread to another, it saves the context of the
    thread and reloads the previously saved context of the next thread in the thread
    queue. This takes both time and resources to complete.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当Windows从一个线程切换到另一个线程时，它会保存当前线程的上下文，并重新加载线程队列中下一个线程之前保存的上下文。这需要时间和资源来完成。
- en: As a developer, if you have a small number of complex pieces of work and you
    want complete control over them, then you could create and manage individual `Thread`
    instances. If you have one main thread and multiple small pieces of work that
    can be executed in the background, then you can use the `ThreadPool` class to
    add delegate instances that point to those pieces of work implemented as methods
    to a queue, and they will be automatically allocated to threads in the thread
    pool.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，如果您有一小部分复杂的工作，并且希望完全控制它们，那么您可以创建和管理单个`Thread`实例。如果您有一个主线程和多个可以在后台执行的小块工作，那么您可以使用`ThreadPool`类将指向作为方法实现的工作块的委托实例添加到队列中，它们将被自动分配到线程池中的线程。
- en: In this chapter, we will use the `Task` type to manage threads at a higher abstraction
    level.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`Task`类型在更高的抽象级别上管理线程。
- en: Threads may have to compete for and wait for access to shared resources, such
    as variables, files, and database objects. There are types for managing this that
    you will see in action later in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可能需要竞争并等待访问共享资源，例如变量、文件和数据库对象。您将在本章后面看到用于管理这些资源的类型。
- en: 'Depending on the task, doubling the number of threads (workers) to perform
    a task does not halve the number of seconds that it will take to complete that
    task. In fact, it can increase the duration of the task due to resource contention,
    as shown in *Figure 5.1*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据任务的不同，将执行任务的线程（工作者）数量加倍并不会将完成任务所需的时间减半。实际上，由于资源竞争，这可能会增加任务的持续时间，如图5.1所示：
- en: '![](img/B19587_05_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_05_01.png)'
- en: 'Figure 5.1: A tweet about tasks in the real world'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：关于现实世界中任务的推文
- en: '**Good Practice**: Never assume that more threads will improve performance!
    Run performance tests on a baseline code implementation without multiple threads,
    and then again on a code implementation with multiple threads. You should also
    perform performance tests in a staging environment that is as close as possible
    to the production environment.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：永远不要假设更多的线程会提高性能！在没有多个线程的基线代码实现上运行性能测试，然后再次在具有多个线程的代码实现上运行。您还应在尽可能接近生产环境的预发布环境中进行性能测试。'
- en: Running tasks asynchronously
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步运行任务
- en: To understand how multiple tasks can be run **simultaneously** (at the same
    time), we will create a console app that needs to execute three methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何**同时**（同时）运行多个任务，我们将创建一个需要执行三个方法的控制台应用程序。
- en: 'There will be three methods that need to be executed: the first takes 3 seconds,
    the second takes 2 seconds, and the third takes 1 second. To simulate that work,
    we can use the `Thread` class to tell the current thread to go to sleep for a
    specified number of milliseconds.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将需要执行三个方法：第一个方法需要3秒，第二个方法需要2秒，第三个方法需要1秒。为了模拟这项工作，我们可以使用 `Thread` 类来告诉当前线程暂停指定的毫秒数。
- en: Running multiple actions synchronously
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步运行多个操作
- en: 'Before we make the tasks run simultaneously, we will run them **synchronously**,
    that is, one after the other:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使任务同时运行之前，我们将以**同步**的方式运行它们，也就是说，一个接一个地：
- en: 'Use your preferred code editor to add a console app project, as defined in
    the following list:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器添加一个控制台应用程序项目，如下列所示：
- en: 'Project template: **Console App** / `console`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Solution file and folder: `Chapter05`'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter05`
- en: 'Project file and folder: `WorkingWithTasks`'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`WorkingWithTasks`
- en: '**Do not use top-level statements**: Cleared.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**：已清除。'
- en: '**Enable native AOT publish**: Cleared.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用原生AOT发布**：已清除。'
- en: In the `WorkingWithTasks` project, globally and statically import the `System.Console`
    class and treat warnings as errors.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithTasks` 项目中，全局和静态导入 `System.Console` 类，并将警告视为错误。
- en: In the `WorkingWithTasks` project, add a new class file named `Program.Helpers.cs`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithTasks` 项目中，添加一个名为 `Program.Helpers.cs` 的新类文件。
- en: 'In `Program.Helpers.cs`, delete any existing statements, and then define a
    partial `Program` class with methods to output a section title and a task title,
    and to output information about the current thread, each in different colors to
    make them easier to identify in output, as shown in the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Helpers.cs` 中，删除任何现有的语句，然后定义一个部分 `Program` 类，其中包含输出章节标题和任务标题的方法，以及输出关于当前线程的信息，每个方法使用不同的颜色以便在输出中更容易识别，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `WorkingWithTasks` project, add a new class file named `Program.Methods.cs`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithTasks` 项目中，添加一个名为 `Program.Methods.cs` 的新类文件。
- en: 'In `Program.Methods.cs`, delete any existing statements, and then add three
    methods that simulate work, as shown in the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Methods.cs` 中，删除任何现有的语句，然后添加三个模拟工作的方法，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    call the helper method to output information about the thread, define and start
    a stopwatch, call the three simulated work methods, and then output the milliseconds
    elapsed, as shown in the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，然后添加调用辅助方法以输出线程信息、定义并启动计时器、调用三个模拟工作方法以及输出经过的毫秒数的语句，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the code, wait for all three methods to finish executing, and then review
    the result, noting that when there is only one unnamed foreground thread doing
    the work, the total time required is just over 6 seconds, as shown in the following
    output:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，等待所有三个方法完成执行，然后查看结果，注意当只有一个未命名的前台线程执行工作时，所需的总时间略超过6秒，如下面的输出所示：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running multiple actions asynchronously using tasks
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用任务异步运行多个操作
- en: The `Thread` class has been available since the first version of .NET in 2002
    and can be used to create new threads and manage them, but it can be tricky to
    work with directly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 类自2002年.NET的第一个版本以来一直可用，可以用来创建新线程并管理它们，但直接与之交互可能会很棘手。'
- en: .NET Framework 4.0 introduced the `Task` class in 2010, which represents an
    asynchronous operation. A task is a high-level abstraction around the operating
    system thread that performs the operation, and the `Task` class enables easier
    creation and management of any underlying threads. Managing multiple threads wrapped
    in tasks will allow our code to execute at the same time, aka **asynchronously**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 4.0 在 2010 年引入了 `Task` 类，它表示一个异步操作。任务是对执行操作的操作系统线程的高级抽象，`Task`
    类使得创建和管理任何底层线程变得更加容易。管理被任务包装的多个线程将允许我们的代码同时执行，即 **异步**。
- en: Each `Task` has a `Status` property and a `CreationOptions` property. A `Task`
    has a `ContinueWith` method that can be customized with the `TaskContinuationOptions`
    enum, and it can be managed with the `TaskFactory` class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Task` 都有一个 `Status` 属性和一个 `CreationOptions` 属性。`Task` 有一个 `ContinueWith`
    方法，可以使用 `TaskContinuationOptions` 枚举进行自定义，并且可以使用 `TaskFactory` 类进行管理。
- en: Starting tasks
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动任务
- en: 'We will look at three ways to start the methods using `Task` instances. There
    are links in the GitHub repository to articles that discuss the pros and cons.
    Each has a slightly different syntax, but they all define a `Task` and start it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨三种使用 `Task` 实例启动方法的方式。GitHub 仓库中有链接到讨论优缺点的文章。它们的语法略有不同，但它们都定义了一个 `Task`
    并启动了它：
- en: 'In `Program.cs`, comment out the previous statements that call methods A to
    C, and then add statements to create and start three tasks, one for each method,
    as shown highlighted in the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，注释掉调用方法 A 到 C 的前一条语句，然后添加语句创建并启动三个任务，每个方法一个任务，如下面高亮显示的代码所示：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Instead of commenting out the previous statements, you could let them run, but
    then make sure to call the `timer.Restart()` method after outputting a new section
    title to reset the timings for each section.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是注释掉前面的语句，你可以让它们运行，但确保在输出新的部分标题后调用 `timer.Restart()` 方法来重置每个部分的计时。
- en: 'Run the code, view the result, and note that the elapsed milliseconds appear
    almost immediately. This is because each of the three methods is now being executed
    by three new background worker threads allocated from the **thread pool (TP)**,
    as shown in the following output:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意经过的毫秒数几乎立即出现。这是因为现在每个三个方法都由从 **线程池 (TP)** 分配的三个新的后台工作线程执行，如下面的输出所示：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is even likely that the console app will end before one or even all the tasks
    have a chance to start and write to the console!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可能控制台应用程序会在一个或所有任务有机会开始并写入控制台之前结束！
- en: Waiting for tasks
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待任务
- en: 'Sometimes, you need to wait for a task to complete before continuing. To do
    this, you can use the `Wait` method on a `Task` instance, or the `WaitAll` or
    `WaitAny` static methods on an array of tasks, as described in *Table 5.1*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在继续之前需要等待一个任务完成。为此，可以在 `Task` 实例上使用 `Wait` 方法，或者在任务数组上使用 `WaitAll` 或 `WaitAny`
    静态方法，如 *表 5.1* 中所述：
- en: '| **Method** | **Description** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `t.Wait()` | This waits for the task instance named `t` to complete execution.
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `t.Wait()` | 这将等待名为 `t` 的任务实例完成执行。 |'
- en: '| `Task.WaitAny(Task[])` | This waits for any of the tasks in the array to
    complete execution. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Task.WaitAny(Task[])` | 这将等待数组中任何任务的执行完成。 |'
- en: '| `Task.WaitAll(Task[])` | This waits for all the tasks in the array to complete
    execution. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Task.WaitAll(Task[])` | 这将等待数组中所有任务的执行完成。 |'
- en: 'Table 5.1: Task class Wait methods'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：Task 类的 Wait 方法
- en: Using wait methods with tasks
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用任务等待方法
- en: 'Let’s see how we can use these wait methods to fix the problem with our console
    app:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些等待方法来解决我们的控制台应用程序的问题：
- en: 'In `Program.cs`, after creating the three tasks and before outputting the elapsed
    time, add statements to combine references to the three tasks into an array and
    pass them to the `WaitAll` method, as shown in the following code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，在创建三个任务并在输出经过的时间之前，添加语句将三个任务的引用组合成一个数组，并将它们传递给 `WaitAll`
    方法，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the code and view the result, and note the original thread will pause on
    the call to `WaitAll`, waiting for all three tasks to finish before outputting
    the elapsed time, which is a little over 3 seconds, as shown in the following
    output:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，并注意原始线程会在 `WaitAll` 调用上暂停，等待所有三个任务完成，然后输出经过的时间，大约是 3 秒多，如下面的输出所示：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The three new threads execute their code simultaneously, and they can potentially
    start in any order. `MethodC` should finish first because it takes only 1 second,
    then `MethodB`, which takes 2 seconds, and finally, `MethodA`, because it takes
    3 seconds.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 三个新线程同时执行它们的代码，并且它们可以以任何顺序开始。`MethodC`应该首先完成，因为它只需要1秒，然后是`MethodB`，它需要2秒，最后是`MethodA`，因为它需要3秒。
- en: However, the actual CPU used has a big effect on the results. It is the CPU
    that allocates time slices to each process to allow them to execute their threads.
    You have no control over when the methods run.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际使用的CPU对结果有很大影响。是CPU为每个进程分配时间片，以便它们可以执行它们的线程。您无法控制方法何时运行。
- en: Continuing with another task
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续另一个任务
- en: If all three tasks can be performed at the same time, then waiting for all tasks
    to finish will be all we need to do. However, often, a task is dependent on the
    output from another task. To handle this scenario, we need to define **continuation
    tasks**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有三个任务可以同时执行，那么等待所有任务完成就是我们需要做的。然而，通常，一个任务依赖于另一个任务的输出。为了处理这种情况，我们需要定义**后续任务**。
- en: 'We will create some methods to simulate a call to a web service that returns
    a monetary amount, which then needs to be used to retrieve how many products cost
    more than that amount in a database. The result returned from the first method
    needs to be fed into the input of the second method. This time, instead of waiting
    for fixed amounts of time, we will use the `Random` class to wait for a random
    interval between 2 and 4 seconds for each method call to simulate the work:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一些方法来模拟调用返回货币金额的Web服务，然后需要使用该金额从数据库中检索出多少产品的价格高于该金额。第一个方法返回的结果需要输入到第二个方法的输入中。这次，我们不会等待固定的时间，而是将使用`Random`类等待每个方法调用之间的2到4秒的随机间隔来模拟工作：
- en: 'In `Program.Methods.cs`, add two methods that simulate calling a web service
    and a database-stored procedure, as shown in the following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Methods.cs`中，添加两个方法来模拟调用Web服务和数据库存储过程，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In `Program.cs`, comment out the statements for the previous three tasks, and
    then add statements to start a task to call the web service and then pass its
    return value to a task that starts the database-stored procedure, as shown highlighted
    in the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉前三个任务的语句，然后添加语句以启动一个任务来调用网络服务，然后将返回值传递给启动数据库存储过程的任务，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The currency symbol is culture-specific so on my computer it uses a £. On your
    computer it will use your culture. You will learn how to control cultures in *Chapter
    7*, *Handling Dates, Times, and Internationalization*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 货币符号是文化特定的，所以在我的电脑上它使用£。在您的电脑上它将使用您的文化。您将在*第7章*，*处理日期、时间和国际化*中学习如何控制文化。
- en: You might see two different threads running the web service and stored procedure
    calls as in the output above (for example, threads 4 and 6), or the same thread
    might be reused since it is no longer busy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到两个不同的线程在运行上面的网络服务和存储过程调用（例如，线程4和6），或者相同的线程可能会被重用，因为它不再忙碌。
- en: Nested and child tasks
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套和子任务
- en: As well as defining dependencies between tasks, you can define nested and child
    tasks. A **nested task** is a task that is created inside another task. A **child
    task** is a nested task that must finish before its parent task is allowed to
    finish.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义任务之间的依赖关系外，您还可以定义嵌套和子任务。**嵌套任务**是在另一个任务内部创建的任务。**子任务**是必须在其父任务允许完成之前完成的嵌套任务。
- en: 'Let’s explore how these types of tasks work:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些类型任务的工作方式：
- en: 'In `Program.Methods.cs`, add two methods, one of which starts a task to run
    the other, as shown in the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Methods.cs`中，添加两个方法，其中一个启动一个任务来运行另一个，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `Program.cs`, add statements to start a task to run the outer method and
    wait for it to finish before stopping, as shown in the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以启动一个任务来运行外部方法，并在它完成之前等待，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Although we wait for the outer task to finish, its inner task does not have
    to finish as well. In fact, the outer task might finish, and the console app could
    end before the inner task even starts, as shown in the following output:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然我们等待外部任务完成，但其内部任务不必也完成。事实上，外部任务可能已经完成，控制台应用程序可能在内部任务甚至开始之前就结束了，如下面的输出所示：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To link these nested tasks as parent and child, we must use a special option.
    In `Program.Methods.cs`, modify the existing code to add a `TaskCreationOption`
    value of `AttachedToParent`, as shown highlighted in the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将这些嵌套任务作为父任务和子任务链接起来，我们必须使用一个特殊选项。在`Program.Methods.cs`中，修改现有的代码以添加一个`TaskCreationOption`值为`AttachedToParent`，如下面高亮显示的代码所示：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the code, view the result, and note that the inner task must finish before
    the outer task can, as shown in the following output:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意内部任务必须在外部任务之前完成，如下面的输出所示：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, the outer method could finish before the inner method starts,
    as shown in the following output:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，外部方法可以在内部方法开始之前完成，如下面的输出所示：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `OuterMethod` can finish its work before the `InnerMethod`, as shown by
    what it writes to the console, but its task must wait, as shown by the console
    not stopping until both the outer and inner tasks finish.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`OuterMethod`可以在`InnerMethod`之前完成其工作，如它写入控制台所示，但它的任务必须等待，如控制台在内外任务都完成之前不会停止所示。'
- en: Wrapping tasks around other objects
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将任务包装在其他对象周围
- en: 'Sometimes you might have a method that you want to be asynchronous, but the
    result to be returned is not itself a task. You can wrap the return value in a
    successfully completed task, return an exception, or indicate that the task was
    canceled by using one of the `Task` static methods, as shown in *Table 5.2*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能有一个想要异步执行的方法，但返回的结果本身不是任务。你可以将返回值包装在一个成功完成的任务中，返回一个异常，或者使用`Task`的静态方法之一来指示任务已取消，如*表5.2*所示：
- en: '| **Method** | **Description** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `FromResult<TResult>(TResult)` | Creates a `Task<TResult>` object whose `Result`
    property is the non-task result and whose `Status` property is `RanToCompletion`.
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `FromResult<TResult>(TResult)` | 创建一个`Task<TResult>`对象，其`Result`属性是非任务结果，其`Status`属性是`RanToCompletion`。|'
- en: '| `FromException<TResult>(Exception)` | Creates a `Task<TResult>` that’s completed
    with a specified exception. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `FromException<TResult>(Exception)` | 创建一个由于指定异常而完成的`Task<TResult>`。|'
- en: '| `FromCanceled<TResult>(CancellationToken)` | Creates a `Task<TResult>` that’s
    completed due to cancellation with a specified cancellation token. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `FromCanceled<TResult>(CancellationToken)` | 创建一个由于指定取消令牌而完成的`Task<TResult>`。|'
- en: 'Table 5.2: Methods to create a Task in various scenarios'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2：在各种场景下创建Task的方法
- en: 'These methods are useful when you need to:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要以下情况时，这些方法很有用：
- en: Implement an interface that has asynchronous methods, but your implementation
    is synchronous. This is common for websites and services.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个具有异步方法但实现是同步的接口。这在网站和服务中很常见。
- en: Mock asynchronous implementations during unit testing.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试期间模拟异步实现。
- en: 'Imagine that you need to create a method to validate XML input and the method
    must conform to an interface that requires a `Task<T>` to be returned, as shown
    in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要创建一个用于验证XML输入的方法，并且该方法必须符合一个要求返回`Task<T>`的接口，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code in this section is for illustration only. You do not need to enter
    it in your project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码仅用于说明。你不需要将其输入到你的项目中。
- en: 'We could use these helpful `FromX` methods to return the results wrapped in
    a task, as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些有用的`FromX`方法来返回包装在任务中的结果，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the method you need to implement returns a `Task` (equivalent to `void`
    in a synchronous method), then you can return a predefined completed `Task` object,
    as shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要实现的方法返回一个`Task`（在同步方法中相当于`void`），那么你可以返回一个预定义的已完成`Task`对象，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When running tasks in parallel, the code will often need to access resources,
    and those resources are sometimes shared between tasks and threads. We, therefore,
    need to learn how to safely access those shared resources.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当并行运行任务时，代码通常会需要访问资源，而这些资源有时在任务和线程之间是共享的。因此，我们需要学习如何安全地访问这些共享资源。
- en: Synchronizing access to shared resources
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: When you have multiple threads executing at the same time, there is a possibility
    that two or more of the threads may access the same variable or another resource
    at the same time, and as a result, may cause a problem. For this reason, you should
    carefully consider how to make your code **thread-safe**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当有多个线程同时执行时，存在两个或更多线程可能同时访问相同变量或资源的可能性，这可能导致问题。因此，您应该仔细考虑如何使您的代码**线程安全**。
- en: The simplest mechanism for implementing thread safety is to use an object variable
    as a flag or traffic light to indicate when a shared resource has an exclusive
    lock applied.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实现线程安全的最简单机制是使用对象变量作为标志或交通灯，以指示共享资源是否已应用了独占锁。
- en: In William Golding’s *Lord of the Flies*, Piggy and Ralph find a conch shell
    and use it to call a meeting. The boys impose a “rule of the conch” on themselves,
    deciding that no one can speak unless they’re holding the conch.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在威廉·戈尔丁的 *《蝇王》* 中，皮格和拉尔夫找到一个海螺壳，并用它来召集会议。男孩们对自己实施了一个“海螺规则”，即除非他们拿着海螺，否则没有人可以发言。
- en: I like to name the object variable I use for implementing thread-safe code the
    “conch.” When a thread has the conch, no other thread should access the shared
    resource(s) represented by that conch. Note that I say *should*. Only code that
    respects the conch enables synchronized access. A conch is *not* a lock.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将用于实现线程安全代码的对象变量命名为“海螺”。当一个线程拥有海螺时，其他任何线程都不应该访问由该海螺表示的共享资源。请注意，我说的是“应该”。只有尊重海螺的代码才能实现同步访问。海螺**不是**一个锁。
- en: 'We will explore a couple of types that can be used to synchronize access to
    shared resources:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一些可以用来同步访问共享资源的类型：
- en: '`Monitor`: An object that can be used by multiple threads to check if they
    should access a shared resource within the same process.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Monitor`：一个可以被多个线程用来检查它们是否应该访问同一进程中的共享资源。'
- en: '`Interlocked`: An object for manipulating simple numeric types at the CPU level.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interlocked`：一个用于在CPU级别操作简单数值类型的对象。'
- en: Accessing a resource from multiple threads
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个线程访问资源
- en: 'Let’s create a console app to explore sharing resources between multiple threads:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个控制台应用程序来探索多个线程之间的资源共享：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    to the `Chapter05` solution named `SynchronizingResourceAccess`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将一个新的**控制台应用程序**/ `console` 项目添加到名为 `SynchronizingResourceAccess`
    的 `Chapter05` 解决方案中。
- en: Globally and statically import the `System.Console` class and treat warnings
    as errors.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局和静态导入 `System.Console` 类，并将警告视为错误。
- en: Add a new class file named `SharedObjects.cs`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `SharedObjects.cs` 的新类文件。
- en: 'In `SharedObjects.cs`, delete any existing statements and then define a static
    class with a field to store a message that is a shared resource, as shown in the
    following code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedObjects.cs` 中，删除任何现有的语句，然后定义一个静态类，其中包含一个字段用于存储共享资源的消息，如下所示代码：
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add a new class file named `Program.Methods.cs`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Program.Methods.cs` 的新类文件。
- en: 'In `Program.Methods.cs`, delete any existing statements and then define two
    methods that both loop five times, waiting for a random interval of up to two
    seconds and appending either `A` or `B` to the shared message resource, as shown
    in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Methods.cs` 中，删除任何现有的语句，然后定义两个方法，这两个方法都循环五次，等待最多两秒的随机间隔，并将 `A` 或
    `B` 追加到共享消息资源中，如下所示代码：
- en: '[PRE22]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `Program.cs`, delete the existing statements. Add statements to import the
    namespace for diagnostic types like `Stopwatch`, and statements to execute both
    methods on separate threads using a pair of tasks, and wait for them to complete
    before outputting the elapsed milliseconds, as shown in the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句。添加导入诊断类型（如 `Stopwatch`）的命名空间语句，以及使用一对任务执行两个方法并在输出经过的毫秒数之前等待它们完成的语句，如下所示代码：
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This shows that both threads were modifying the message concurrently. In an
    actual application, this could be a problem. But we can prevent concurrent access
    by applying a mutually exclusive lock to a conch object, as well as adding code
    to the two methods to voluntarily check the conch before modifying the shared
    resource, which we will do in the following section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明两个线程都在并发地修改消息。在实际应用中，这可能会成为一个问题。但我们可以通过将互斥锁应用于海螺对象，以及向两个方法中添加代码以在修改共享资源之前自愿检查海螺，来防止并发访问，我们将在下一节中这样做。
- en: Applying a mutually exclusive lock to a conch
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将互斥锁应用于 conch
- en: 'Now, let’s use a conch to ensure that only one thread accesses the shared resource
    at a time:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 conch 来确保一次只有一个线程访问共享资源：
- en: 'In `SharedObjects.cs`, declare and instantiate an `object` variable to act
    as a conch, as shown in the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SharedObjects.cs` 中，声明并实例化一个 `object` 变量来作为 conch，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In `Program.Methods.cs`, in both `MethodA` and `MethodB`, add a `lock` statement
    for the conch around the `for` statements, as shown highlighted in the following
    code for `MethodB`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Methods.cs` 中，在 `MethodA` 和 `MethodB` 中，在 `for` 语句周围添加一个 `lock` 语句，如下面
    `MethodB` 的代码所示，高亮显示：
- en: '[PRE26]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Good Practice**: Note that since checking the conch is voluntary, if you
    only use the `lock` statement in one of the two methods, the shared resource will
    continue to be accessed by both methods. Make sure that all methods that access
    a shared resource respect the conch by calling `lock` on it before trying to use
    any shared resources.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：请注意，由于检查 conch 是自愿的，如果您只在两个方法中的一个中使用 `lock` 语句，共享资源将继续被两个方法访问。确保所有访问共享资源的方法在尝试使用任何共享资源之前都通过在它上面调用
    `lock` 来尊重 conch。'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Although the time elapsed was longer, only one method at a time could access
    the shared resource. Either `MethodA` or `MethodB` can start first. Once a method
    has finished its work on the shared resource, then the conch gets released, and
    the other method has the chance to do its work.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然经过的时间更长，但一次只能有一个方法访问共享资源。`MethodA` 或 `MethodB` 可以先开始。一旦一个方法完成了对共享资源的操作，conch
    就会被释放，其他方法就有机会进行其工作。
- en: Understanding the lock statement
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `lock` 语句
- en: 'You might wonder what the `lock` statement does when it “locks” an object variable
    (hint: it does not lock the object!), as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道 `lock` 语句在“锁定”对象变量时做了什么（提示：它并没有锁定对象！），如下面的代码所示：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The C# compiler changes the `lock` statement into a `try`-`finally` statement
    that uses the `Monitor` class to *enter* and *exit* the conch object (I like to
    think of it as *take* and *release* the conch object), as shown in the following
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器将 `lock` 语句转换为使用 `Monitor` 类来 *进入* 和 *退出* conch 对象（我喜欢将其视为 *拿起* 和 *放下*
    conch 对象）的 `try`-`finally` 语句，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When a thread calls `Monitor.Enter` on a reference type, it checks to see if
    some other thread has already taken the conch. If it has, the thread waits. If
    it has not, the thread takes the conch and gets on with its work on the shared
    resource. Once the thread has finished its work, it calls `Monitor.Exit`, releasing
    the conch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程对一个引用类型调用 `Monitor.Enter` 时，它会检查是否有其他线程已经拿起了 conch。如果有，线程会等待。如果没有，线程会拿起
    conch 并开始对其共享资源进行工作。一旦线程完成了其工作，它会调用 `Monitor.Exit`，释放 conch。
- en: If another thread was waiting, it could now take the conch and do its work.
    This requires all threads to respect the conch by calling `Monitor.Enter` and
    `Monitor.Exit` appropriately.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个线程正在等待，它现在可以拿起 conch 并进行其工作。这要求所有线程都通过适当地调用 `Monitor.Enter` 和 `Monitor.Exit`
    来尊重 conch。
- en: '**Good Practice**: You cannot use value types (`struct` types) as a conch.
    `Monitor.Enter` requires a reference type because it locks the memory address.
    Any internal data structures for that object are *not* locked.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：您不能使用值类型（`struct` 类型）作为 conch。`Monitor.Enter` 需要引用类型，因为它锁定内存地址。该对象的任何内部数据结构
    *不会* 被锁定。'
- en: Avoiding deadlocks
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免死锁
- en: Knowing how the `lock` statement is translated by the compiler to method calls
    on the `Monitor` class is also important because using the `lock` statement can
    cause a deadlock.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 了解编译器如何将 `lock` 语句转换为对 `Monitor` 类的方法调用也很重要，因为使用 `lock` 语句可能会导致死锁。
- en: 'Deadlocks can occur when there are two or more shared resources (each with
    a conch to monitor which thread is currently doing work on each shared resource),
    and the following sequence of events happens:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在两个或更多共享资源（每个资源都有一个 conch 来监控哪个线程正在对每个共享资源进行工作）时，可能会发生死锁，以下事件序列会发生：
- en: Thread X “locks” conch A and starts working on shared resource A.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程 X “锁定” conch A 并开始对共享资源 A 进行工作。
- en: Thread Y “locks” conch B and starts working on shared resource B.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程 Y “锁定” conch B 并开始对共享资源 B 进行工作。
- en: While still working on resource A, thread X needs to also work with resource
    B, and so it attempts to “lock” conch B but is blocked because thread Y already
    has conch B.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当线程 X 仍在处理资源 A 时，它还需要与资源 B 一起工作，因此它尝试“锁定”conch B，但由于线程 Y 已经拿起了 conch B，所以它被阻塞了。
- en: While still working on resource B, thread Y needs to also work with resource
    A, and so it attempts to “lock” conch A but is blocked because thread X already
    has conch A.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当线程Y仍在处理资源B时，它还需要与资源A一起工作，因此它尝试“锁定”海螺A，但由于线程X已经拥有海螺A，所以它被阻塞了。
- en: 'One way to prevent deadlocks is to specify a timeout when attempting to get
    a lock. To do this, you must manually use the `Monitor` class instead of using
    the `lock` statement. Let’s see how:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 防止死锁的一种方法是在尝试获取锁时指定超时。为此，你必须手动使用`Monitor`类而不是使用`lock`语句。让我们看看如何：
- en: 'In `Program.Methods.cs`, modify your code to replace the `lock` statements
    with code that tries to enter the conch with a timeout, outputs an error, and
    then exits the monitor, allowing other threads to enter the monitor, as shown
    highlighted in the following code for `MethodB`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Methods.cs`中，修改你的代码，将`lock`语句替换为尝试带超时进入海螺的代码，输出错误，然后退出监视器，允许其他线程进入监视器，如下面的代码中突出显示的`MethodB`所示：
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the code and view the result, which should return the same results as before
    (although either A or B could grab the conch first) but is better code because
    it will prevent potential deadlocks.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，结果应该与之前相同（尽管A或B可能先拿到海螺）但代码更好，因为它将防止潜在的死锁。
- en: '**Good Practice**: Only use the `lock` keyword if you can write your code such
    that it avoids potential deadlocks. If you cannot avoid potential deadlocks, then
    always use the `Monitor.TryEnter` method instead of `lock`, in combination with
    a `try`-`finally` statement, so that you can supply a timeout and one of the threads
    will back out of a deadlock if it occurs. You can read more about good threading
    practices at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：只有在你能够编写避免潜在死锁的代码时才使用`lock`关键字。如果你无法避免潜在的死锁，那么始终使用`Monitor.TryEnter`方法而不是`lock`，并结合`try`-`finally`语句，这样你就可以提供一个超时，如果发生死锁，其中一个线程将退出。你可以在以下链接中了解更多关于良好线程实践的信息：[https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)。'
- en: Synchronizing events
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步事件
- en: .NET events are not thread-safe, so you should avoid using them in multi-threaded
    scenarios.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: .NET事件不是线程安全的，所以在多线程场景中你应该避免使用它们。
- en: 'After learning that .NET events are not thread-safe, some developers attempt
    to use exclusive locks when adding and removing event handlers or when raising
    an event, as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解到.NET事件不是线程安全之后，一些开发者在添加和删除事件处理器或引发事件时尝试使用独占锁，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Good Practice**: Is it good or bad that some developers use locks in event
    handling? Well, it is complicated. It depends on complex factors so I cannot give
    a value judgement. You can read more about events and thread safety at the following
    link: [https://learn.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://learn.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful).
    But it is complicated, as explained by Stephen Cleary in the following blog post:
    [https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：一些开发者在事件处理中使用锁是好事还是坏事？嗯，这很复杂。它取决于复杂的因素，所以我不能给出价值判断。你可以在以下链接中了解更多关于事件和线程安全的信息：[https://learn.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://learn.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)。但正如Stephen
    Cleary在以下博客文章中解释的那样，这很复杂：[https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)。'
- en: Making CPU operations atomic
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使CPU操作原子化
- en: Atomic is from the Greek word **atomos**, which means *undividable*. It is important
    to understand which operations are atomic in multithreading because if they are
    not atomic, then they could be interrupted by another thread partway through their
    operation. Is the C# increment operator atomic, as shown in the following code?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '"Atomic"这个词来自希腊语**atomos**，意思是*不可分割的*。理解在多线程中哪些操作是原子的非常重要，因为如果不是原子的，它们在操作过程中可能会被另一个线程中断。下面的代码中C#的增量操作符是原子的吗？'
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*It is not atomic!* Incrementing an integer requires the following three CPU
    operations:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*这不是原子的!* 增加一个整数的值需要以下三个CPU操作：'
- en: Load a value from an instance variable into a register.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例变量中的值加载到寄存器中。
- en: Increment the value.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加值。
- en: Store the value in the instance variable.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值存储在实例变量中。
- en: A thread could be interrupted after executing the first two steps. A second
    thread could then execute all three steps. When the first thread resumes execution,
    it will overwrite the value in the variable, and the effect of the increment or
    decrement performed by the second thread will be lost!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程在执行前两个步骤后可能会被中断。然后第二个线程可以执行所有三个步骤。当第一个线程恢复执行时，它将覆盖变量中的值，第二个线程执行的递增或递减的效果将丢失！
- en: 'There is a type named `Interlocked` that can perform atomic actions like `Add`,
    `Increment`, `Decrement`, `Exchange`, `CompareExchange`, `And`, `Or`, and `Read`
    on the integer types in the following list:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`Interlocked`的类型，可以对以下列表中的整数类型执行原子操作，如`Add`、`Increment`、`Decrement`、`Exchange`、`CompareExchange`、`And`、`Or`和`Read`：
- en: '`System.Int32` (`int`), `System.UInt32` (`uint`)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Int32` (`int`), `System.UInt32` (`uint`)'
- en: '`System.Int64` (`long`), `System.UInt64` (`ulong`)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Int64` (`long`), `System.UInt64` (`ulong`)'
- en: '`Interlocked` does not work on numeric types like `byte`, `sbyte`, `short`,
    `ushort`, and `decimal`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Interlocked`不适用于像`byte`、`sbyte`、`short`、`ushort`和`decimal`这样的数值类型。'
- en: '`Interlocked` can perform atomic operations like `Exchange` and `CompareExchange`
    that swap values in memory on the following types:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Interlocked`可以在以下类型上执行原子操作，如`Exchange`和`CompareExchange`，这些操作在内存中交换值：'
- en: '`System.Single` (`float`), `System.Double` (`double`)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Single` (`float`), `System.Double` (`double`)'
- en: '`nint`, `nuint`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nint`, `nuint`'
- en: '`System.Object` (`object`)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Object` (`object`)'
- en: 'Let’s see it in action:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际效果：
- en: 'Declare another field in the `SharedObjects` class that will count how many
    operations have occurred, as shown in the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedObjects`类中声明另一个字段，该字段将计算发生的操作数量，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `Program.Methods.cs`, in both methods A and B, inside the `for` statement
    and after modifying the `string` value, add a statement to safely increment the
    counter, as shown in the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Methods.cs`中，在方法A和B中，在`for`语句内修改`string`值之后，添加一个语句来安全地增加计数器，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In `Program.cs`, before outputting the elapsed time, write the current value
    of the counter to the console, as shown in the following code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在输出经过的时间之前，将计数器的当前值写入控制台，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the code and view the result, as shown highlighted in the following output:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示的高亮输出：
- en: '[PRE36]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Observant readers will realize that the existing conch object protects all shared
    resources accessed within a block of code locked by the conch, and therefore,
    it is unnecessary to use `Interlocked` in this specific example. But if we had
    not already been protecting another shared resource like `Message`, then using
    `Interlocked` would be necessary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意力敏锐的读者会意识到现有的conch对象保护了在由conch锁定的代码块中访问的所有共享资源，因此在这个特定示例中不需要使用`Interlocked`。但如果我们还没有保护像`Message`这样的另一个共享资源，那么使用`Interlocked`将是必要的。
- en: Applying other types of synchronization
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用其他类型的同步
- en: '`Monitor` and `Interlocked` are mutually exclusive locks that are simple and
    effective, but sometimes, you need more advanced options to synchronize access
    to shared resources, as shown in *Table 5.3*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monitor`和`Interlocked`是互斥锁，简单且有效，但有时你需要更高级的选项来同步对共享资源的访问，如下表5.3所示：'
- en: '| **Type** | **Description** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **描述** |'
- en: '| `ReaderWriterLock`, `ReaderWriterLockSlim` | These allow multiple threads
    to be in **read mode**, one thread to be in **write mode** with exclusive ownership
    of the write lock, and one thread that has read access to be in **upgradeable
    read mode**, from which the thread can upgrade to write mode without having to
    relinquish its read access to the resource. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `ReaderWriterLock`, `ReaderWriterLockSlim` | 这些允许多个线程处于**读取模式**，一个线程处于**写入模式**并拥有写入锁的独占所有权，还有一个线程具有读取访问权限，可以处于**可升级读取模式**，从该模式中线程可以升级到写入模式，而无需放弃对资源的读取访问。|'
- en: '| `Mutex` | Like `Monitor`, this provides exclusive access to a shared resource,
    except it is used for inter-process synchronization. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `Mutex` | 与`Monitor`类似，它提供对共享资源的独占访问，但它用于进程间同步。|'
- en: '| `Semaphore`, `SemaphoreSlim` | These limit the number of threads that can
    access a resource or pool of resources concurrently by defining slots. This is
    known as **resource throttling** rather than **resource locking**. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `Semaphore`, `SemaphoreSlim` | 这些通过定义槽位来限制可以并发访问资源或资源池的线程数量。这被称为**资源节流**而不是**资源锁定**。|'
- en: '| `AutoResetEvent`, `ManualResetEvent` | Event wait handles allow threads to
    synchronize activities by signaling each other and by waiting for each other’s
    signals. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `AutoResetEvent`, `ManualResetEvent` | 事件等待句柄允许线程通过相互信号和等待对方的信号来同步活动。 |'
- en: 'Table 5.3: Synchronization types'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.3：同步类型
- en: Now that we’ve explored the importance of synchronizing access to shared resources
    in multi-threaded applications, it’s time to delve into how some new keywords
    introduced in C# 5 make writing asynchronous code easier.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经探讨了在多线程应用程序中同步访问共享资源的重要性，那么现在是时候深入了解C# 5中引入的一些新关键字如何使编写异步代码变得更加容易。
- en: Understanding async and await
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异步和await
- en: 'C# 5 introduced two C# keywords when working with the `Task` type. They are
    especially useful for the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Task`类型时，C# 5引入了两个C#关键字。它们在以下方面特别有用：
- en: Implementing multitasking for a **graphical user interface** (**GUI**)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现图形用户界面（**GUI**）的多任务处理
- en: Improving the scalability of web applications and web services
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高Web应用程序和Web服务的可伸缩性
- en: In *Chapter 16*, *Building Mobile and Desktop Apps Using .NET MAUI*, we will
    see how the `async` and `await` keywords can implement multitasking for a GUI.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16章*使用.NET MAUI构建移动和桌面应用程序*中，我们将看到`async`和`await`关键字如何实现GUI的多任务处理。
- en: But for now, let’s learn the theory of why these two C# keywords were introduced,
    and then later, you will see them used in practice.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，让我们先学习为什么引入这两个C#关键字的理论，然后稍后你将看到它们在实际中的应用。
- en: Improving responsiveness for console apps
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高控制台应用程序的响应性
- en: 'One of the limitations with console apps is that you can only use the `await`
    keyword inside methods that are marked as `async`, but C# 7 and earlier do not
    allow the `Main` method to be marked as `async`! Luckily, a new feature introduced
    in C# 7.1 was support for `async` in `Main`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序的一个限制是，你只能在标记为`async`的方法中使用`await`关键字，但C# 7及之前版本不允许将`Main`方法标记为`async`！幸运的是，C#
    7.1引入了一个新功能，支持在`Main`中使用`async`：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    to the `Chapter05` solution named `AsyncConsole`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器，将一个新的**控制台应用程序**/`console`项目添加到名为`Chapter05`的解决方案中，命名为`AsyncConsole`。
- en: 'In `Program.cs`, delete the existing statements, statically import `Console`,
    and then add statements to create an `HttpClient` instance, make a request for
    Apple’s home page, and output how many bytes it has, as shown in the following
    code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，静态导入`Console`，然后添加语句创建一个`HttpClient`实例，对苹果的主页发起请求，并输出其字节大小，如下所示代码：
- en: '[PRE37]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Build the project and note that it builds successfully. In .NET 5 and earlier,
    the project template created an explicit `Program` class with a non-async `Main`
    method, so you would have seen an error message, as shown in the following output:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并注意它构建成功。在.NET 5及之前版本中，项目模板创建了一个具有非异步`Main`方法的显式`Program`类，因此你会看到如下所示的错误消息：
- en: '[PRE38]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You would have had to add the `async` keyword to the `Main` method and change
    its return type to `Task`. With .NET 6 and later, the console app project template
    uses the top-level program feature to automatically define the `Program` class
    with an asynchronous `<Main>$` method for you.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须将`async`关键字添加到`Main`方法中，并将其返回类型更改为`Task`。在.NET 6及以后版本中，控制台应用程序项目模板使用顶级程序功能自动为你定义具有异步`<Main>$`方法的`Program`类。
- en: 'Run the code and view the result, which is likely to have a different number
    of bytes since Apple changes its home page frequently, as shown in the following
    output:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，由于苹果公司经常更改其主页，因此字节数量可能不同，如下所示输出：
- en: '[PRE39]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Working with async streams
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步流
- en: With .NET Core 3, Microsoft introduced the asynchronous processing of streams.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core 3中，微软引入了流的异步处理。
- en: 'You can complete a tutorial about async streams at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中完成关于异步流的教程：[https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream)。
- en: Before C# 8 and .NET Core 3, the `await` keyword only worked with tasks that
    return scalar values. Async stream support in .NET Standard 2.1 allows an `async`
    method to return one value after another asynchronously.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8和.NET Core 3之前，`await`关键字仅适用于返回标量值的任务。.NET Standard 2.1中的异步流支持允许异步方法依次返回一个值。
- en: 'Let’s see a simulated example that returns three random integers as an async
    stream:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个模拟的例子，它返回一个异步流，包含三个随机整数：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    to the `Chapter05` solution named `AsyncEnumerable`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器向`Chapter05`解决方案中添加一个名为`AsyncEnumerable`的新**控制台应用程序**/ `console`项目。
- en: Globally and statically import the `System.Console` class and treat warnings
    as errors.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局和静态导入`System.Console`类，并将警告视为错误。
- en: Add a new file named `Program.Methods.cs`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Program.Methods.cs`的新文件。
- en: 'In `Program.Methods.cs`, delete any existing statements and then define a method
    that uses the `yield` keyword to return a random sequence of three numbers asynchronously,
    as shown in the following code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.Methods.cs`中，删除任何现有的语句，然后定义一个使用`yield`关键字异步返回三个随机数字序列的方法，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    enumerate the sequence of numbers, as shown in the following code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后添加语句来枚举数字序列，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE42]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Improving responsiveness for GUI apps
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高GUI应用程序的响应性
- en: So far in this book, we have only built console apps. Life for a programmer
    gets more complicated when building web applications, web services, and apps with
    GUIs such as Windows desktop and mobile apps.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们只构建了控制台应用程序。当构建Web应用程序、Web服务和具有GUI（如Windows桌面和移动应用程序）的应用程序时，程序员的生涯会变得更加复杂。
- en: 'One reason for this is that for a GUI app, there is a special thread: the **user
    interface** (**UI**) thread.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 原因之一是对于GUI应用程序，有一个特殊的线程：**用户界面**（**UI**）线程。
- en: 'There are two rules for working in GUIs:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI中工作有两个规则：
- en: Do not perform long-running tasks on the UI thread.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在UI线程上执行长时间运行的任务。
- en: Do not access UI elements on any thread except the UI thread.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了UI线程之外，不要在任何线程上访问UI元素。
- en: To handle these rules, programmers used to have to write complex code to ensure
    that long-running tasks were executed by a non-UI thread, but once complete, the
    results of the task were safely passed to the UI thread to present to the user.
    It could quickly get messy!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些规则，程序员过去不得不编写复杂的代码来确保长时间运行的任务由非UI线程执行，但一旦完成，任务的结果就会被安全地传递到UI线程以展示给用户。这可能会很快变得混乱！
- en: Luckily, with C# 5 and later, you have the use of `async` and `await`. They
    allow you to continue to write your code as if it is synchronous, which keeps
    your code clean and easy to understand, but underneath, the C# compiler creates
    a complex state machine and keeps track of running threads. It’s kind of magical!
    The combination of these two keywords makes the asynchronous method run on a worker
    thread and, when it’s complete, return the results on the UI thread.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，从C# 5及以后版本开始，您可以使用`async`和`await`。它们允许您继续以同步方式编写代码，这使代码保持整洁且易于理解，但底层，C#编译器创建了一个复杂的状态机并跟踪运行中的线程。这有点神奇！这两个关键字的组合使得异步方法在工作者线程上运行，并在完成时将结果返回到UI线程。
- en: Let’s see an example. We will build a Windows desktop app using **Windows Presentation
    Foundation** (**WPF**) that gets employees from the Northwind database in a SQL
    Server database using low-level types like `SqlConnection`, `SqlCommand`, and
    `SqlDataReader`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。我们将使用**Windows Presentation Foundation**（**WPF**）构建一个Windows桌面应用程序，该应用程序使用低级类型如`SqlConnection`、`SqlCommand`和`SqlDataReader`从SQL
    Server数据库中的Northwind数据库获取员工信息。
- en: The Northwind database has medium complexity and a decent number of sample records.
    You used it extensively in *Chapter 2*,*Managing Relational Data Using SQL Server*,
    where it was introduced and set up.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Northwind数据库具有中等复杂性和相当数量的样本记录。您在*第2章*，*使用SQL Server管理关系数据*中广泛使用了它，其中介绍了并设置了该数据库。
- en: '**Warning!** You will only be able to complete this task if you have Microsoft
    Windows and the Northwind database stored in Microsoft SQL Server. This is the
    only section in this book that is not cross-platform and modern (WPF is 17 years
    old!). You can use either Visual Studio 2022 or Visual Studio Code.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 只有在您拥有Microsoft Windows和存储在Microsoft SQL Server中的Northwind数据库的情况下，您才能完成此任务。这是本书中唯一一个不是跨平台和现代（WPF已经17岁了！）的部分。您可以使用Visual
    Studio 2022或Visual Studio Code。'
- en: At this point, we are focusing on making a GUI app responsive. You will learn
    about XAML and building cross-platform GUI apps in *Chapter 16*, *Building Mobile
    and Desktop Apps Using .NET MAUI*. Since this book does not cover WPF elsewhere,
    I thought this task would be a good opportunity to at least see an example app
    built using WPF even if we do not look at it in detail. Let’s go!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们专注于使 GUI 应用程序响应。你将在第 16 章“使用 .NET MAUI 构建移动和桌面应用程序”中了解 XAML 和构建跨平台 GUI
    应用程序。由于本书没有在其他地方涵盖 WPF，我认为这是一个很好的机会，至少可以看到一个使用 WPF 构建的应用程序示例，即使我们不详细查看它。让我们开始吧！
- en: 'If you are using Visual Studio 2022, add a new **WPF Application [C#]** project
    named `WpfResponsive` to the `Chapter05` solution. If you are using Visual Studio
    Code, use the following command: `dotnet new wpf`. If you are using JetBrains
    Rider, select **Desktop Application** and then select a **Type** of **WPF Application**.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Visual Studio 2022，请在 `Chapter05` 解决方案中添加一个名为 `WpfResponsive` 的新 **WPF
    应用程序 [C#]** 项目。如果你使用的是 Visual Studio Code，请使用以下命令：`dotnet new wpf`。如果你使用的是 JetBrains
    Rider，请选择 **桌面应用程序**，然后选择 **类型** 为 **WPF 应用程序**。
- en: Add a package reference for `Microsoft.Data.SqlClient` to the project.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加 `Microsoft.Data.SqlClient` 的包引用。
- en: 'In the project file, note the output type is a Windows EXE, the target framework
    is .NET for Windows (it will not run on other platforms, like macOS and Linux),
    and the project uses WPF, as shown in the following markup:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，请注意输出类型是 Windows EXE，目标框架是 .NET for Windows（它将在其他平台，如 macOS 和 Linux 上运行），并且项目使用
    WPF，如下面的标记所示：
- en: '[PRE43]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Build the `WpfResponsive` project to restore packages.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `WpfResponsive` 项目以恢复包。
- en: 'In `MainWindow.xaml`, in the `<Grid>` element, add elements to define two buttons,
    a text box and a list box, laid out vertically in a stack panel, as shown in the
    following markup:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml` 中，在 `<Grid>` 元素中，添加元素以定义两个按钮、一个文本框和一个列表框，它们在堆叠面板中垂直排列，如下面的标记所示：
- en: '[PRE44]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Visual Studio 2022 has good support for building WPF apps and will provide IntelliSense
    as you edit code and XAML markup. Visual Studio Code does not.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Visual Studio 2022 对构建 WPF 应用程序有良好的支持，并在你编辑代码和 XAML 标记时提供 IntelliSense。Visual
    Studio Code 不提供。
- en: 'In `MainWindow.xaml.cs`, import namespaces to work with ADO.NET and the stopwatch,
    as shown in the following code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml.cs` 中，导入命名空间以使用 ADO.NET 和计时器，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `MainWindow` class, in the constructor, define two `string` fields for
    the database connection string and SQL statement, as shown in the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类的构造函数中，定义两个 `string` 字段用于数据库连接字符串和 SQL 语句，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The SQL has two statements. The first waits for five seconds to simulate a long-running
    query.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQL 有两个语句。第一个等待五秒钟以模拟长时间运行的查询。
- en: 'In the `MainWindow` class, in the constructor, after the call to `InitializeComponent`,
    use an `SqlConnectionStringBuilder` to set the database connection string, as
    shown in the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类的构造函数中，在调用 `InitializeComponent` 之后，使用 `SqlConnectionStringBuilder`
    设置数据库连接字符串，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create event handlers for clicking on the two buttons. They must use the `string`
    constants to open a connection to the Northwind database and then populate the
    list box with the IDs and names of all employees, as shown in the following code:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个按钮点击的事件处理程序。它们必须使用 `string` 常量来打开与 Northwind 数据库的连接，然后使用所有员工的 ID 和名称填充列表框，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note the following:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下事项：
- en: Defining an `async void` method is generally bad practice because it is “fire
    and forget.” You will not be notified when it is completed and there is no way
    to cancel it because it does not return a `Task` or `Task<T>` that can be used
    to control it.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个 `async void` 方法通常是不良实践，因为它“发射并遗忘”。当你完成时，你将不会收到通知，并且无法取消它，因为它不返回一个 `Task`
    或 `Task<T>`，这可以用来控制它。
- en: The SQL statement uses the SQL Server `WAITFOR DELAY` command to simulate processing
    that takes five seconds. It then selects three columns from the `Employees` table.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 语句使用 SQL Server 的 `WAITFOR DELAY` 命令来模拟需要五秒钟的处理。然后它从 `Employees` 表中选择三个列。
- en: The `GetEmployeesSyncButton_Click` event handler uses synchronous methods to
    open a connection and fetch the employee rows.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetEmployeesSyncButton_Click` 事件处理程序使用同步方法打开连接并获取员工行。'
- en: The `GetEmployeesAsyncButton_Click` event handler is marked as `async` and uses
    asynchronous methods with the `await` keyword to open a connection and fetch the
    employee rows.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetEmployeesAsyncButton_Click` 事件处理程序被标记为 `async`，并使用带有 `await` 关键字的异步方法打开连接并获取员工行。'
- en: Both event handlers use a stopwatch to record the number of milliseconds the
    operation takes and add it to the list box.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个事件处理器都使用计时器来记录操作所需的毫秒数，并将其添加到列表框中。
- en: Start the WPF app without debugging.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动 WPF 应用程序。
- en: Click in the text box, enter some text, and note that the GUI is responsive.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本框中点击，输入一些文本，并注意 GUI 仍然响应。
- en: Click the **Get Employees Synchronously** button.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **同步获取员工** 按钮。
- en: Try to click in the text box, and note the GUI is not responsive.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在文本框中点击，并注意 GUI 不再响应。
- en: Wait for at least five seconds until the list box is filled with employees.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待至少五秒钟，直到列表框中填充了员工信息。
- en: Click in the text box, enter some text, and note the GUI is responsive again.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本框中点击，输入一些文本，并注意 GUI 再次变得响应。
- en: Click the **Get Employees Asynchronously** button.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **异步获取员工** 按钮。
- en: 'Click in the text box, enter some text, and note that the GUI is still responsive
    while it performs the operation. Continue typing until the list box is filled
    with the employees, as shown in *Figure 5.2*:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本框中点击，输入一些文本，并注意在执行操作时 GUI 仍然响应。继续输入，直到列表框中填充了员工信息，如图 5.2 所示：
- en: '![](img/B19587_05_02.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_05_02.png)'
- en: 'Figure 5.2: Loading employees into a WPF app synchronously and asynchronously'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：同步和异步将员工加载到 WPF 应用程序中
- en: Note the difference in timings for the two operations. The UI is blocked when
    fetching data synchronously, while the UI remains responsive when fetching data
    asynchronously.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意两个操作的时间差异。在同步获取数据时，UI 被阻塞，而在异步获取数据时，UI 保持响应。
- en: Close the WPF app.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 WPF 应用程序。
- en: Improving scalability for web applications and web services
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高网络应用程序和网络服务的可扩展性
- en: The `async` and `await` keywords can also be applied on the server side when
    building websites, applications, and services. From the client application’s point
    of view, nothing changes (or they might even notice a small increase in the time
    taken for a request to return). So, from a single client’s point of view, the
    use of `async` and `await` to implement multitasking on the server side makes
    their experience worse!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建网站、应用程序和服务时，`async` 和 `await` 关键字也可以应用于服务器端。从客户端应用程序的角度来看，没有任何变化（或者他们甚至可能注意到请求返回所需时间的小幅增加）。因此，从单个客户端的角度来看，使用
    `async` 和 `await` 在服务器端实现多任务处理会使他们的体验变得更差！
- en: On the server side, additional, cheaper worker threads are created to wait for
    long-running tasks to finish so that expensive I/O threads can handle other client
    requests instead of being blocked. This improves the overall scalability of a
    web application or service. More clients can be supported simultaneously.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，创建额外的、成本更低的工作线程来等待长时间运行的任务完成，以便昂贵的 I/O 线程可以处理其他客户端请求而不是被阻塞。这提高了网络应用程序或服务的整体可扩展性。可以同时支持更多的客户端。
- en: Common types that support multitasking
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多任务处理的常见类型
- en: 'There are many common types that have asynchronous methods that you can await,
    as shown in *Table 5.4*:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多常见的类型具有可以等待的异步方法，如图 5.4 表所示：
- en: '| **Type** | **Methods** |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **方法** |'
- en: '| `DbContext<T>` | `AddAsync`, `AddRangeAsync`, `FindAsync`, and `SaveChangesAsync`
    |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `DbContext<T>` | `AddAsync`、`AddRangeAsync`、`FindAsync` 和 `SaveChangesAsync`
    |'
- en: '| `DbSet<T>` | `AddAsync`, `AddRangeAsync`, `ForEachAsync`, `SumAsync`, `ToListAsync
    ToDictionaryAsync`, `AverageAsync`, and `CountAsync` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `DbSet<T>` | `AddAsync`、`AddRangeAsync`、`ForEachAsync`、`SumAsync`、`ToListAsync`、`ToDictionaryAsync`、`AverageAsync`
    和 `CountAsync` |'
- en: '| `HttpClient` | `GetAsync`, `PostAsync`, `PutAsync`, `DeleteAsync`, and `SendAsync`
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `HttpClient` | `GetAsync`、`PostAsync`、`PutAsync`、`DeleteAsync` 和 `SendAsync`
    |'
- en: '| `StreamReader` | `ReadAsync`, `ReadLineAsync`, and `ReadToEndAsync` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `StreamReader` | `ReadAsync`、`ReadLineAsync` 和 `ReadToEndAsync` |'
- en: '| `StreamWriter` | `WriteAsync`, `WriteLineAsync`, and `FlushAsync` |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `StreamWriter` | `WriteAsync`、`WriteLineAsync` 和 `FlushAsync` |'
- en: 'Table 5.4: Common types with asynchronous methods'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.4：具有异步方法的常见类型
- en: '**Good Practice**: Any time you see a method that ends in the `Async` suffix,
    check to see whether it returns `Task` or `Task<T>`. If it does return `Task`
    or `Task<T>`, then you could use it instead of the synchronous non-`Async` suffixed
    method. Remember to call it using `await` and decorate your method with `async`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：每次看到以 `Async` 后缀结尾的方法时，检查它是否返回 `Task` 或 `Task<T>`。如果它确实返回 `Task` 或
    `Task<T>`，则可以使用它代替同步的非 `Async` 后缀方法。记得使用 `await` 调用它，并使用 `async` 装饰你的方法。'
- en: Using await in catch blocks
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 catch 块中使用 await
- en: When `async` and `await` were first introduced in C# 5, it was only possible
    to use the `await` keyword in a `try` block, but not in a `catch` block. In C#
    6 and later, it is now possible to use `await` in both `try` and `catch` blocks.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当`async`和`await`首次在C# 5中引入时，只能在`try`块中使用`await`关键字，但不能在`catch`块中使用。在C# 6及以后版本中，现在可以在`try`和`catch`块中同时使用`await`。
- en: Practicing and exploring
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作和深入探索本章的主题来测试你的知识和理解。
- en: Exercise 5.1 – Test your knowledge
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What information can you find out about a process?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以了解到关于一个进程的哪些信息？
- en: How accurate is the `Stopwatch` class?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stopwatch`类的准确性如何？'
- en: By convention, what suffix should be applied to a method that returns `Task`
    or `Task<T>`?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照惯例，应该给返回`Task`或`Task<T>`的方法添加什么后缀？
- en: To use the `await` keyword inside a method, what keyword must be applied to
    the method declaration?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在方法内部使用`await`关键字，方法声明必须应用什么关键字？
- en: How do you create a child task?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个子任务？
- en: Why should you avoid the `lock` keyword?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你应该避免使用`lock`关键字？
- en: When should you use the `Interlocked` class?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在什么时候使用`Interlocked`类？
- en: When should you use the `Mutex` class instead of the `Monitor` class?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在什么时候使用`Mutex`类而不是`Monitor`类？
- en: What is the benefit of using `async` and `await` in a website or web service?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网站或Web服务中使用`async`和`await`的好处是什么？
- en: Can you cancel a task? If so, how?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以取消一个任务吗？如果是的话，应该如何操作？
- en: Exercise 5.2 – Explore topics
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.2 – 探索主题
- en: 'Use the links on the following web page to learn more about the topics covered
    in this chapter:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下网页上的链接了解更多关于本章涵盖的主题：
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-5---multitasking-and-concurrency](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-5---multitasking-and-concurrency)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-5---multitasking-and-concurrency](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-5---multitasking-and-concurrency)'
- en: Exercise 5.3 – Read more about parallel programming
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.3 – 了解更多关于并行编程
- en: 'Packt has a book that goes deeper into the topics in this chapter, *Parallel
    Programming and Concurrency with C# 10 and .NET 6: A modern approach to building
    faster, more responsive, and asynchronous .NET applications using C#*, by Alvin
    Ashcroft:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Packt有一本书深入探讨了本章的主题，*《使用C# 10和.NET 6进行并行编程和并发：一种现代方法，用于构建更快、更响应和异步的.NET应用程序》*，作者Alvin
    Ashcroft：
- en: '[https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672](https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672](https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672)'
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you learned:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了：
- en: How to define and start a task.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义和启动一个任务。
- en: How to wait for one or more tasks to finish.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何等待一个或多个任务完成。
- en: How to control task completion order.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何控制任务完成顺序。
- en: How to synchronize access to shared resources.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何同步访问共享资源。
- en: The magic behind `async` and `await`.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`和`await`背后的魔法。'
- en: In the next chapter, you will learn how to use some popular third-party libraries.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用一些流行的第三方库。
