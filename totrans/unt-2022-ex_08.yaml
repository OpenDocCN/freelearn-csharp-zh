- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Continuing the Adventure Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续冒险游戏
- en: In [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), we covered the larger scope
    of the adventure game by extending the **Game Design Document** (**GDD**) for
    the game and explored the level and environment design while also considering
    new principles to guide the player. We also imported and prepped artwork for use
    with additional 2D tooling that will bring the game to life.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18347_04.xhtml#_idTextAnchor079)中，我们通过扩展游戏的设计文档（**GDD**）来覆盖冒险游戏更广泛的范围，同时探索关卡和环境设计，并考虑新的原则来引导玩家。我们还导入并准备了艺术作品，以便与将游戏带入生命的额外2D工具一起使用。
- en: We also challenged the player by exploring and adding moving platforms and interactive
    elements in the level design, immersing the player with a parallax effect on a
    layered background, and optimizing the sprite draw calls to keep things performant.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在关卡设计中探索并添加了移动平台和交互元素，通过在分层背景上的视差效果沉浸玩家，并优化精灵绘制调用以保持性能。
- en: With the game level and environment established, we can now move on to creating
    our player character using the 2D Animation package.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏关卡和环境建立之后，我们现在可以继续使用2D动画包创建我们的玩家角色。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up the player character with PSD Importer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PSD导入器设置玩家角色
- en: Using an Input Action Map
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入动作图
- en: Moving the player with a player controller script
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用玩家控制器脚本移动玩家
- en: Animating the character with Mecanim
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mecanim进行角色动画
- en: By the end of this chapter, you’ll be able to set up a 2D sprite-based character
    rigged for animation and driven by player input. You’ll also be able to assign
    and transition between different animations required for the player’s current
    state.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够设置一个2D基于精灵的、为动画而设置的、由玩家输入驱动的角色。您还将能够为玩家的当前状态分配和切换所需的动画。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along in this chapter and use the same artwork that was created for
    the project in this book, download the adventure game 2D art assets from the following
    GitHub link: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容并使用本书项目中创建的相同艺术作品，请从以下GitHub链接下载冒险游戏2D艺术资源：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets)。
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop or use a graphics program that can export layered PSD/PSB
    files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自己的艺术作品进行跟随，您需要使用Adobe Photoshop创建类似的艺术作品，或者使用可以导出分层PSD/PSB文件的图形程序（例如Gimp、MediBang
    Paint、Krita和Affinity Photo）。
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub下载完整的项目，链接为[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Setting up the player character with PSD Importer
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PSD导入器设置玩家角色
- en: Creating our player character for the 2D adventure game will be a multi-step
    process. In this section, we’ll cover all the steps required to make an animated
    2D character controlled by the player.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为2D冒险游戏创建我们的玩家角色将是一个多步骤的过程。在本节中，我们将介绍制作由玩家控制的动画2D角色所需的全部步骤。
- en: We’ll start with the import settings for the artwork and setting up the character
    bones that will allow us to animate. You’ll repeat these actions many times throughout
    a project while importing artwork and assets. **PSD Importer** is an asset importer
    that can work with multilayered PSB/PSD files to create a Prefab of sprites based
    on the source layers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从导入艺术作品的设置开始，并设置允许我们进行动画的玩家角色骨骼。在导入艺术作品和资产的过程中，您将多次重复这些操作。**PSD导入器**是一个资产导入器，它可以与多层的PSB/PSD文件一起工作，根据源图层创建基于源图层的精灵Prefab。
- en: The import options allow Unity to generate both a sprite sheet and a character
    rig that arranges the sprites according to their original position and layer order,
    significantly simplifying the creation of a sprite-based animated character.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 导入选项允许Unity生成精灵图集和角色骨架，根据精灵的原始位置和图层顺序排列精灵，显著简化了基于精灵的动画角色的创建。
- en: 'Let’s go ahead and import the artwork for the player character. Here, we will
    set up the source file so that it uses PSD Importer to create the actor (the Prefab
    created based on the multilayered Photoshop file is called an **actor**):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续导入玩家角色的艺术作品。在这里，我们将设置源文件，使其使用 PSD 导入器创建演员（基于多层 Photoshop 文件创建的预制件称为**演员**）：
- en: Create a new folder in the `Assets/Sprites/Character` directory.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Sprites/Character`目录中创建一个新的文件夹。
- en: Import `PlayerCharacter1.psd` into the newly created folder.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PlayerCharacter1.psd`导入到新创建的文件夹中。
- en: Select the imported file and, in the **Inspector** window, change **Importer**
    to **UnityEditor.U2D.PSD.PSDImporter** in the dropdown list.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择导入的文件，在**检查器**窗口中，在下拉列表中将**导入器**更改为**UnityEditor.U2D.PSD.PSDImporter**。
- en: '**PSD Importer** provides two new options that appear as tabs once it’s selected
    as the importer:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**PSD 导入器**提供了两个新选项，一旦选择为导入器，就会作为标签出现：'
- en: '**Settings**: This is where you will set the properties for how the file will
    be imported. The fields under **Settings** are similar to the default texture
    importer, with the addition of the **Layer Import** (when **Texture Type** is
    set to **Multiple**) and **Character** **Rig** sections'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：这是您将设置文件导入属性的地方。**设置**下的字段与默认纹理导入器类似，增加了**层导入**（当**纹理类型**设置为**多个**）和**角色****绑定**部分'
- en: '**Layer Management**: This is where you can customize which layers from the
    Photoshop file are imported'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层管理**：这是您可以自定义从 Photoshop 文件中导入哪些层的部分'
- en: With the default import settings, we are already in good shape to continue with
    the player character setup since we’ll be using all the layers. The importer will
    keep the layer positions and sorting order from Photoshop so that our character
    sprites are arranged correctly for our actor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的导入设置，我们已经处于良好的状态，可以继续进行玩家角色设置，因为我们将会使用所有层。导入器将保留 Photoshop 中的层位置和排序顺序，以便我们的角色精灵能够正确地排列在我们的演员上。
- en: We won’t have to recreate the player character in Unity from the individual
    sprites that make up the character – arms, torso, legs, head, and so on. So, we
    are ready for the next step – rigging the character by adding bones.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在 Unity 中从构成角色的单个精灵中重新创建玩家角色——手臂、躯干、腿部、头部等等。因此，我们准备好进行下一步——通过添加骨骼来绑定角色。
- en: Additional reading | Unity documentation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'Preparing and importing artwork: [https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 准备和导入艺术作品：[https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/PreparingArtwork.xhtml).
- en: 'PSD Importer Inspector properties: [https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PSD 导入器检查器属性：[https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@8.0/manual/PSD-importer-properties.xhtml).
- en: Rigging the actor
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定演员
- en: With the actor (the player character PSD file) still selected in the **Project**
    window, click the **Open Sprite Editor** button in the **Inspector** window. The
    default view is the sliced sprite shape representing our Photoshop layers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在**项目**窗口中仍然选中演员（玩家角色 PSD 文件）的情况下，在**检查器**窗口中点击**打开精灵编辑器**按钮。默认视图是代表我们的 Photoshop
    层的切片精灵形状。
- en: 'Don’t worry – as I said, we won’t have to work with our character in a dismembered
    way, as shown in *Figure 5**.1*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '别担心——正如我说的，我们不需要以分解的方式处理我们的角色，就像*图 5**.1*所示。:'
- en: '![Figure 5.1 – Actor sprite sheet](img/B18347_05_1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 演员精灵图](img/B18347_05_1.jpg)'
- en: Figure 5.1 – Actor sprite sheet
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 演员精灵图
- en: If the artwork is shown with the individual sprites representing the Photoshop
    layers, then we need to switch to **Sprite Skinning Editor** (part of the 2D Animation
    package), where we’ll continue setting up the animation rig for the actor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果艺术作品以代表 Photoshop 层的单独精灵显示，那么我们需要切换到**精灵皮肤编辑器**（2D 动画包的一部分），在那里我们将继续设置演员的动画绑定。
- en: From the **Sprite Editor** dropdown, select **Skinning Editor** – the sprites
    should now represent the character, as seen in the original Photoshop source file.
    Sweet!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从**精灵编辑器**下拉菜单中选择**皮肤编辑器**——精灵现在应该代表角色，正如原始 Photoshop 源文件中看到的那样。太棒了！
- en: 'The entire workflow of setting up the actor for animations looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 设置演员以进行动画的整个工作流程看起来像这样：
- en: '**Create a rig**: A skeleton made up of individual bones.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个骨架**：由单个骨骼组成的骨骼结构。'
- en: '**Generate mesh geometry**: This will influence the sprite’s position, rotation,
    and, optionally, deformation.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成网格几何形状**：这将影响精灵的位置、旋转，以及可选的变形。'
- en: '**Adjust bone influence**: Change the attributes of a sprite to specify which
    bone or bones affect it.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调整骨骼影响**：更改精灵的属性以指定哪些骨骼或骨骼影响它。'
- en: '**Adjust weights**: How much a bone, or bones, influence a given sprite (the
    entire sprite, or just part(s) of it).'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调整权重**：骨骼或骨骼对给定精灵（整个精灵或只是部分）的影响程度。'
- en: '**Preview pose**: Test, test, and test again regarding the rig and sprite bone,
    geometry, and weight assignments until everything is looking and working correctly
    when bones are moved or rotated; this is a cyclical process.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预览姿势**：测试，测试，再测试关于骨架和精灵骨骼、几何形状和权重分配，直到在移动或旋转骨骼时一切看起来和工作正常；这是一个循环过程。'
- en: '**Inverse kinematics** (**IK**): You can apply IK to a chain of bones to automatically
    calculate positions and rotations that make it much easier to animate the actor’s
    limbs.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反向运动学**（**IK**）：您可以将IK应用于一系列骨骼，以自动计算位置和旋转，这使得动画演员的肢体变得容易得多。'
- en: Additional reading | Inverse kinematics (IK)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | 反向运动学（IK）
- en: IK is a technique that’s used in computer animation and robotics to control
    the position and orientation of limbs. It calculates the joint angles required
    to place the end effector in a given position and orientation – endpoints such
    as hands and feet. It’s useful for creating natural and realistic human motion,
    especially for complex poses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: IK是一种在计算机动画和机器人技术中使用的技巧，用于控制肢体位置和方向。它计算放置末端执行器在给定位置和方向所需的关节角度——例如手和脚这样的末端。这对于创建自然和逼真的人类动作非常有用，尤其是对于复杂的姿势。
- en: You can read more at [https://docs.unity3d.com/Manual/InverseKinematics.xhtml](https://docs.unity3d.com/Manual/InverseKinematics.xhtml).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.unity3d.com/Manual/InverseKinematics.xhtml](https://docs.unity3d.com/Manual/InverseKinematics.xhtml)了解更多信息。
- en: '**Animate**: Create animations for the actor’s different gameplay states, such
    as idle, walking, jumping, and attacking.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画**：为演员的不同游戏状态创建动画，例如空闲、行走、跳跃和攻击。'
- en: Game development is a multidisciplinary craft that combines both technical and
    artistic skills. Creating a character rig with individual bones to affect individual
    sprites combines both skill sets. Thankfully, the rigging process is non-destructive,
    so we’ll be able to go back and make changes at any time to adjust and fix anything
    that doesn’t seem to be working well or look correct.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发是一种多学科工艺，结合了技术和艺术技能。通过创建具有单个骨骼的骨架来影响单个精灵，结合了这两种技能集。幸运的是，绑定过程是非破坏性的，因此我们可以在任何时间返回并调整任何看起来工作不正常或看起来不正确的部分。
- en: The general creation process we’ll follow when creating the rig is to start
    with the pelvic bone – this bone will represent the *true center* of the character.
    Moving or rotating this bone will affect all child bones in the rig, moving the
    entire actor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建骨架时将遵循的一般创建过程是从骨盆骨开始——这个骨骼将代表角色的**真实中心**。移动或旋转这个骨骼将影响骨架中的所有子骨骼，移动整个演员。
- en: This first bone we’ll create can be seen in *Figure 5**.2* as the small red
    bone pointing upwards in the pelvic area of the character. In the bone hierarchy
    (as shown in the `bone_1`, is the root bone.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的第一个骨骼可以在*图5*.2*中看到，它是位于角色骨盆区域向上指的小红色骨骼。在骨骼层次结构中（如图`bone_1`所示），它是根骨骼。
- en: 'Let’s create our bones! Perform the following steps to develop the whole character
    rig:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的骨骼！按照以下步骤开发整个角色骨架：
- en: We should already be in **Skinning Editor**; if not, select it from the **Sprite**
    **Editor** dropdown.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该已经在**皮肤编辑器**中；如果不是，从**精灵****编辑器**下拉菜单中选择它。
- en: To view the hierarchy of the bones being created (or to manage the visibility
    of the sprites you’re working with), toggle on the **Visibility** panel (the top
    right of the window next to **Revert** and **Apply**).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看正在创建的骨骼的层次结构（或管理您正在使用的精灵的可见性），请切换到**可见性**面板（窗口右上角，紧邻**还原**和**应用**）。
- en: Now, under the **Bones** section (the left-hand side of the window), select
    the **Create Bone** button – your cursor should now have a red dot at the tip.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**骨骼**部分（窗口的左侧），选择**创建骨骼**按钮——您的光标现在应该在尖端有一个红色圆点。
- en: Start at the character’s pelvis and click to start creating the root bone. Click
    again slightly above the first click point to make the small red root bone – refer
    to *Figure 5**.2* for the general size and orientation.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从角色的骨盆开始，点击以开始创建根骨骼。在第一次点击点稍上方再次点击以创建一个小红色根骨骼——参见图5.2.2以了解大致大小和方向。
- en: Continue by clicking again to create a bone that will represent the lower portion
    of the torso (yellow bone) and again to make a bone for the upper part of the
    torso (green bone); this will allow us to bend the character’s torso (for example,
    arching forward or backward).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过再次点击来创建一个代表躯干下半部分的骨骼（黄色骨骼）和再次创建一个代表躯干上半部分的骨骼（绿色骨骼）；这将使我们能够弯曲角色的躯干（例如，向前或向后弯曲）。
- en: Moving up the spine, create two additional bones – a small bone for the neck
    and another for the head (refer to *Figure 5**.2*).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沿着脊柱向上移动，创建两个额外的骨骼——一个用于脖子的细小骨骼和另一个用于头部的骨骼（参见图5.2.2）。
- en: Right-click or press the *Esc* key to stop creating bones.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击或按*Esc*键停止创建骨骼。
- en: 'Our actor now has a spine (if you’ll forgive the pun). Creating the limbs will
    follow a similar process, but the critical difference in creating bones for limbs
    is to first select the bone that will parent the limb bones. Follow these steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的角色现在有了脊柱（如果你能原谅这个双关语）。创建肢体将遵循类似的过程，但创建肢体骨骼的关键区别是首先选择将作为肢体骨骼父级的骨骼。按照以下步骤操作：
- en: With **Create Bone** still selected, click on the upper torso bone (green).
    You should now see a semi-transparent bone coming from the bone that was just
    clicked (this indicates parenting; you can also see this in the **Visibility**
    window’s **Bone** **Hierarchy** view).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择**创建骨骼**的情况下，点击上胸骨（绿色）。你现在应该看到一个半透明的骨骼从刚刚点击的骨骼延伸出来（这表示父级关系；你也可以在**可见性**窗口的**骨骼**
    **层次结构**视图中看到这一点）。
- en: We’ll start by creating a limb for the character’s left arm (the arm behind
    the torso), so click where the left shoulder joint should be to begin making bones.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先为角色的左臂（躯干后面的手臂）创建一个肢体，因此点击左肩关节应该放置骨骼的位置开始创建骨骼。
- en: Note that to make placing bones easier for sprites behind others, you can toggle
    the visibility off for the sprites in front by using the **Visibility** panel.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，为了使放置在其他精灵后面的精灵更容易放置骨骼，你可以使用**可见性**面板关闭前面精灵的可见性。
- en: Keep clicking to create bones for the upper arm, lower arm, and hand (refer
    to *Figure 5**.2*).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续点击以创建上臂、下臂和手的骨骼（参见图5.2.2）。
- en: Right-click or press the *Esc* key to stop creating bones.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击或按*Esc*键停止创建骨骼。
- en: Continue creating the other limb bones for the right arm and both legs by selecting
    the parent bone again – for the legs, parent to the pelvic bone (the red root
    bone we started creating the rig from).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过再次选择父骨骼来继续创建右臂和其他两条腿的其他肢体骨骼——对于腿，将父级设置为骨盆骨（我们从它开始创建绑定的红色根骨骼）。
- en: 'Your actor’s entire skeleton rig should look similar to the rig shown in *Figure
    5**.2*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你的角色的整个骨骼绑定应该看起来与图5.2.2中显示的绑定相似：
- en: '![Figure 5.2 – The actor rig and Auto Geometry with Weights](img/B18347_05_2.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 角色绑定和带权重的自动几何](img/B18347_05_2.jpg)'
- en: Figure 5.2 – The actor rig and Auto Geometry with Weights
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 角色绑定和带权重的自动几何
- en: If you want to have your bones named more intelligibly – making it easier for
    you to know which bones you are working with – you can easily rename them while
    using the `bone_14` to `foot_right`).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将骨骼命名得更有意义——以便于你更容易知道你正在处理哪块骨骼——你可以在使用 `bone_14` 到 `foot_right` 时轻松地重命名它们（注意，这个动作并不明显）。
- en: Creating the rig is just the first step in making a fully animatable character.
    Let’s take the next step by assigning the sprite’s mesh geometry to the rig’s
    bones – as you continue to work with the rig, it may help to know that the sprite
    mesh geometry a bone influences will be the same color as the bone.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建绑定只是制作一个完全可动画角色的第一步。让我们通过将精灵的网格几何形状分配给绑定的骨骼来继续下一步——随着你继续与绑定工作，了解骨骼影响的精灵网格几何形状将与骨骼颜色相同可能会有所帮助。
- en: Generating the sprite mesh geometry
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成精灵网格几何形状
- en: 'Perform the following steps to create the sprite mesh geometry and apply default
    bone weights that will influence the sprites that we’ll start with:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建精灵网格几何形状并应用默认骨骼权重，这将影响我们将要开始的精灵：
- en: First, double-click in the checkered area to unselect all sprites (noting that
    this action is not apparent).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在棋盘格区域双击以取消选择所有精灵（请注意，这个动作并不明显）。
- en: Select the **Auto Geometry** button under the **Geometry** section (the left-hand
    side of the window).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**几何形状**部分下选择**自动几何**按钮（窗口的左侧）。
- en: In the **Geometry** panel at the window’s bottom-right section, ensure **Weights**
    is enabled; this will automatically generate bone weights along with the mesh
    geometry, saving a step.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口底部右侧的**几何**面板中，确保**权重**已启用；这将自动生成骨骼权重，与网格几何形状一起，节省了一步。
- en: Finish up by clicking the **Generate For All** **Visible** button.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**为所有可见对象生成**按钮。
- en: Additional reading | Unity documentation
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '2D Animation | Editor tools and shortcuts: [https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 2D 动画 | 编辑工具和快捷键：[https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/SkinEdToolsShortcuts.xhtml)。
- en: After clicking the **Generate For All Visible** button for the geometry, all
    your sprites will have taken on coloring from the associated bones. You’ll notice
    that it does not look like the solid colors seen in *Figure 5**.2* since the generated
    weights were distributed across adjacent bones; instead, the coloring will be
    a gradient of the adjoining bone colors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在几何图形上点击**为所有可见对象生成**按钮后，所有精灵都将从关联的骨骼中获取颜色。你会注意到它看起来不像*图 5.2*中看到的实色，因为生成的权重分布在相邻骨骼上；相反，着色将是相邻骨骼颜色的渐变。
- en: This is due to both the overlapping sprites and Unity wanting to blend the sprite
    deformation across the bones, which is desired in some cases. We’ll be addressing
    this shortly in the *Editing sprite bone weights* section for the torso and neck
    sprites. For the remainder of the sprites, we only want one bone to influence
    a sprite (represented by the solid color) for this particular character.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为重叠的精灵和 Unity 希望在骨骼之间混合精灵变形，这在某些情况下是期望的。我们将在*编辑精灵骨骼权重*部分中稍后解决此问题，针对胸和颈的精灵。对于其余的精灵，我们只想让一个骨骼影响一个精灵（用实色表示）来表示这个特定的角色。
- en: We’ll fix this by adjusting the bone influence for each sprite.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调整每个精灵的骨骼影响来解决这个问题。
- en: Adjusting the bone influence
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整骨骼影响
- en: The process we’re going to follow is to remove – or set – bones in the **Bone
    Influences** property of the sprites. This will ensure that our character’s sprites
    are not deformed or distorted while positioned or rotated by only assigning a
    single bone.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要遵循的过程是在精灵的**骨影响**属性中移除或设置骨骼。这将确保我们的角色精灵在仅通过分配单个骨骼定位或旋转时不会变形或扭曲。
- en: For a different style character, we may very well want a single sprite to be
    deformed by multiple bones (as we will do shortly with the torso and neck), but
    that is not what we want for the style character we’re building here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同风格的字符，我们可能非常希望单个精灵被多个骨骼变形（正如我们将在胸和颈上做的那样），但这里构建的风格角色不是这样。
- en: 'Perform the following steps to assign the correct bone influence for all of
    the sprites (again, except for the torso and neck):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以为所有精灵（再次，除了胸和颈）分配正确的骨骼影响：
- en: Select the **Bone Influence** button under the **Weights** section (the left-hand
    side of the window).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**权重**部分下选择**骨影响**按钮（窗口的左侧）。
- en: Double-click on a sprite. For example, in *Figure 5**.3*, we’ll double-click
    on the *wing* for the right foot.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击一个精灵。例如，在*图 5.3*中，我们将双击右脚的*翅膀*。
- en: The panel in the bottom right of the window will now show the selected sprite
    and the bones influencing it.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.3 – 骨影响编辑](img/B18347_05_3.jpg)'
- en: Since we only want one bone to influence the sprite, we’ll select `bone_13`
    (the yellow bone) in the list and then click the minus (**-**) button on the small
    tab below the list to remove it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们只想让一个骨骼影响精灵，我们将在列表中选择`bone_13`（黄色骨骼），然后点击列表下方的小标签上的减号（**-**）按钮来删除它。
- en: 'The sprite will turn the same color as the remaining assigned bone, which is
    green in this case, as seen in *Figure 5**.3*:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 精灵将变成与剩余分配的骨骼相同的颜色，在这个例子中是绿色，如*图 5.3*所示：
- en: '![Figure 5.3 – Bone Influence editing](img/B18347_05_3.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: 窗口右下角的面板现在将显示所选精灵及其影响的骨骼。
- en: Figure 5.3 – Bone Influence editing
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 骨影响编辑
- en: Note that if there is more than one bone to remove, you can select multiple
    bones by holding the *Ctrl*/*Cmd* key down while clicking and then clicking the
    minus (**-**) button.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果有多个骨骼需要删除，你可以在点击的同时按住*Ctrl*/*Cmd*键，然后点击减号（**-**）按钮来选择多个骨骼。
- en: This workflow was for assigning a single bone to a sprite. Next, we’ll learn
    how to use multiple bones to influence the deformation of a sprite.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流程是分配单个骨骼到精灵。接下来，我们将学习如何使用多个骨骼来影响精灵的变形。
- en: Editing sprite bone weights
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑精灵骨骼权重
- en: 'We’ll use two weight tools to assign the bones and adjust the weight influence
    each bone has over the sprite: **Weight Slider** and **Weight Brush**.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个权重工具来分配骨骼并调整每个骨骼对精灵的权重影响：**权重滑块**和**权重笔刷**。
- en: We’ll start with **Weight Slider** to adjust the overall influence of the bones
    and then perform any fine-tuning with **Weight Brush**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从**权重滑块**开始调整骨骼的整体影响，然后使用**权重笔刷**进行任何精细调整。
- en: 'The **Auto Weights** generation may have already performed an excellent job
    but let’s examine the results and make some adjustments, starting with the neck
    sprite:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动权重**生成可能已经做得很好，但让我们检查结果并进行一些调整，从颈部精灵开始：'
- en: Double-click on the neck sprite (note that you can use the mouse scroll wheel
    to zoom in on a sprite to work with it).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击颈部精灵（请注意，您可以使用鼠标滚轮放大精灵以进行操作）。
- en: '**Auto Weights** assigned three bones with influence over the neck sprite,
    so this sprite should have a color gradient representing the color of the three
    bones: the (green) upper torso, (cyan) neck, and (blue) head bone (see *Figure
    5**.4*).'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自动权重**为具有对颈部精灵影响的三个骨骼分配了权重，因此这个精灵应该有一个颜色渐变来表示三个骨骼的颜色：上躯干（绿色）、颈部（青色）和头部骨骼（蓝色）（见*图5.4*）。'
- en: Select the **Weight Slider** button under the **Weights** section (the left-hand
    side of the window).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**权重**部分下选择**权重滑块**按钮（窗口的左侧）。
- en: In the **Weight Slider** panel in the window’s lower-right corner, you can now
    adjust the amount of influence a selected bone has over the sprite; drag the **Amount**
    slider left or right to increase or decrease the influence.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口右下角的**权重滑块**面板中，您现在可以调整所选骨骼对精灵的影响量；将**数量**滑块向左或向右拖动以增加或减少影响。
- en: 'Preview the effect of weight changes to see how the mesh deforms by rotating
    the bones:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过旋转骨骼来预览权重变化的效果，以查看网格如何通过旋转骨骼变形：
- en: 'You can rotate and move bones by simply clicking and dragging on them (the
    mouse cursor will show a rotate or move icon, depending on where you are hovering
    on the bone). Adjust the **Weight Slider** amount until you get overall pleasing
    results – this operation is a lot more artistic than technical:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过简单地点击并拖动骨骼来旋转和移动它们（鼠标光标将显示旋转或移动图标，具体取决于您在骨骼上的悬停位置）。调整**权重滑块**的数值，直到得到整体令人满意的结果——这个操作更多的是艺术性的，而不是技术性的：
- en: '![Figure 5.4 – Editing weights with Weight Brush](img/B18347_05_4.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 使用权重笔刷编辑权重](img/B18347_05_4.jpg)'
- en: Figure 5.4 – Editing weights with Weight Brush
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 使用权重笔刷编辑权重
- en: You may find it challenging to get good results using **Weight Slider** alone.
    In this case, continue to fine-tune the bone influence for any problem areas using
    **Weight Brush**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现仅使用**权重滑块**难以获得良好的结果。在这种情况下，继续使用**权重笔刷**对任何问题区域进行精细调整，以调整骨骼的影响。
- en: With the sprite still selected, select the **Weight Brush** button under the
    **Weights** section (the left-hand side of the window).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在精灵仍然被选中的情况下，在窗口左侧的**权重**部分下选择**权重笔刷**按钮。
- en: Click on the bone you want to paint weights for.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您想要绘制权重的骨骼。
- en: You can now adjust the **Weight Brush** properties in the **Weight Brush** panel
    in the window’s lower-right corner or start painting weights. The sprite mesh
    geometry will update in real time as you paint.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以在窗口右下角的**权重笔刷**面板中调整**权重笔刷**的属性，或者开始绘制权重。当您绘制时，精灵网格几何形状将实时更新。
- en: Continue to rotate the bones by hovering your mouse over the bone to show the
    rotate icon. Then, click and drag to rotate the bone to test the weight painting
    and adjust it until you’ve achieved the desired results.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将鼠标悬停在骨骼上以显示旋转图标来继续旋转骨骼。然后，点击并拖动以旋转骨骼以测试权重绘制并调整它，直到您达到期望的结果。
- en: Note that you can undo bone rotations using *Ctrl*/*Cmd* + *Z*. If you’ve made
    many bone rotations and aren’t sure how much influence is being applied, then
    you can use the **Reset Pose** button under the **Pose** section (the top-left
    corner of the window) to start over.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以使用*Ctrl*/*Cmd* + *Z*撤销骨骼旋转。如果您已经进行了许多骨骼旋转并且不确定应用了多少影响，那么您可以使用**姿态**部分下的**重置姿态**按钮（窗口的左上角）重新开始。
- en: Continue to repeat this process for the actor’s torso. Once you’re finished
    with the torso, this is probably a great time to think about saving your work.
    Use the **Apply** button in the toolbar on the right-hand side.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 继续重复此过程为演员的躯干。一旦完成躯干，这可能是考虑保存您的工作的绝佳时机。使用右侧工具栏上的**应用**按钮。
- en: When you’re relatively satisfied with the bone weights and want to see how things
    are progressing, you can do some pose tests! Doing some pose tests allows you
    to test the range of motion and see if the sprites are associated with only the
    correct bones that influence the sprite weights without undesirable distortion.
    This provides you with the first indication of how the character may look when
    animated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对骨骼权重相对满意并想看看事情进展如何时，你可以进行一些姿势测试！进行一些姿势测试可以让你测试运动范围并查看精灵是否仅与影响精灵权重的正确骨骼相关联，而不产生不希望的扭曲。这为你提供了关于角色在动画中可能看起来如何的第一个提示。
- en: '*Figure 5**.5* represents an example of a test pose for the actor:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5**.5*表示演员的一个测试姿势示例：'
- en: '![Figure 5.5 – Pose test for the actor](img/B18347_05_5.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 演员的姿势测试](img/B18347_05_5.jpg)'
- en: Figure 5.5 – Pose test for the actor
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 演员的姿势测试
- en: Being able to pose our character is great, but for the limbs, in particular,
    it can be time-consuming and challenging to get good results by rotating all the
    bones individually. Thankfully, there is a better way – using **IK**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 能够摆出我们的角色姿势是很好的，但对于肢体来说，特别是通过单独旋转所有骨骼来获得良好的结果可能既耗时又具有挑战性。幸运的是，有一种更好的方法——使用**IK**。
- en: Setting up inverse kinematics (IK)
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置反向运动学（IK）
- en: 'We’ve now finished working with **Skinning Editor** and will continue working
    with the actor in the scene to add IK. So, let’s create a Prefab from the actor
    for our player character:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了与**皮肤编辑器**的工作，并将继续在场景中与演员一起工作以添加IK。因此，让我们从演员创建一个Prefab作为我们的玩家角色：
- en: Drag the `PlayerCharacter1` asset from the **Project** window into the **Hierarchy**
    window or **Scene** view (optionally, you can create a new empty scene to work
    in).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PlayerCharacter1`资产从**项目**窗口拖动到**层次结构**窗口或**场景**视图（可选，您可以创建一个新的空场景进行工作）。
- en: Parent the actor to a new empty GameObject and name it `Player`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将演员附加到一个新的空GameObject上，并将其命名为`Player`。
- en: Then, drag the GameObject into the `Assets/Prefabs` folder to create the Prefab.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将GameObject拖动到`Assets/Prefabs`文件夹中创建Prefab。
- en: Since we’ll be using an IK setup to position our actor for animation, we’ll
    want to change the actor’s rig to make posing the limbs – in particular, the legs
    – much better. We could have done this when we first created the actor’s rig,
    but it’s easier to show the reason for this change while implementing IK, and
    it shows that we can go back and make changes to the bone structure at any time
    and make corrections where necessary.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用IK设置来定位演员进行动画，因此我们希望更改演员的rig，以便更好地摆姿势——特别是腿部。我们可以在最初创建演员的rig时这样做，但在实现IK时展示这种更改的原因更容易，并且这表明我们可以在任何时间返回并修改骨骼结构，并在必要时进行纠正。
- en: 'Next, we’ll be adding a new root bone to the rig using the same **Create Bone**
    workflow we used to create the actor’s complete skeleton rig:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用与创建演员完整骨骼rig相同的**创建骨骼**工作流程在rig中添加一个新的根骨骼：
- en: Start a new bone at the feet of the actor and name it `root_bone`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在演员的脚部开始一个新的骨骼，并将其命名为`root_bone`。
- en: Change the color to gray (just as an indication to us that no sprites are being
    influenced by it).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将颜色更改为灰色（仅作为提示，表示没有精灵受到其影响）。
- en: 'Now, click and drag the existing rig (`bone_1`) to parent it to the new root
    bone, as shown in *Figure 5**.6*:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击并拖动现有的rig（`bone_1`）以将其父级设置为新的根骨骼，如图*图5**.6*所示：
- en: '![Figure 5.6 – Adding root_bone for IK and the parent existing rig](img/B18347_05_6.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 为IK添加root_bone以及父级现有rig](img/B18347_05_6.jpg)'
- en: Figure 5.6 – Adding root_bone for IK and the parent existing rig
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 为IK添加root_bone以及父级现有rig
- en: Be patient with me – this will all make sense in a bit when we add **IK Limb
    Solvers** for the legs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对我耐心一点——当我们为腿部添加**IK肢体求解器**时，所有这些都会变得有道理。
- en: Adding IK Solvers
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加IK求解器
- en: We will make IK-constrained limbs for the arms and legs, starting with the right
    arm (the arm in front of the actor).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为手臂和腿部创建IK约束肢体，从演员前面的右臂（演员前面的手臂）开始。
- en: 'First, let’s add GameObjects that act as our IK Effectors (the transform the
    IK Solver solves for) and work in tandem with the limb solver’s Target:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加充当我们的IK效应器（IK求解器解决的变换）的GameObject，并与肢体求解器的目标协同工作：
- en: Select the forearm bone of the arm in front of the character’s torso – `bone_7`
    in my case.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择角色躯干前手臂的尺骨——在我的例子中是`bone_7`。
- en: Right-click on it in the **Inspector** window and click **Create Empty** to
    add a child GameObject – this will make the new object a sibling of the hand bone.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中右键单击它，然后单击**创建空对象**以添加子GameObject——这将使新对象成为手骨的兄弟对象。
- en: Rename it `IK Effector` and then position it at the tip of the forearm bone.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`IK Effector`，然后将其放置在前臂骨的尖端。
- en: Using the red arrow of the position tool gizmo, drag it down, extending it past
    the hand just a bit. Positioning the effector outside of the sprites will make
    them more visible and easier to click on to manipulate (this step is purely personal
    preference; you may also leave it at the tip of the forearm bone).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置工具gizmo的红箭头，将其向下拖动，稍微超出手部。将效应器放置在精灵之外将使它们更明显，更容易点击来操作（这一步完全是个人偏好；你也可以将其留在前臂骨的尖端）。
- en: Repeat these steps for the other arm (the arm behind the actor) and both legs.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对其他手臂（演员后面的手臂）和两条腿重复这些步骤。
- en: With our effectors in place, add the `IK Manager 2D` component to the root bone
    and start adding **IK Solvers** for the limbs by clicking the plus (**+**) button
    in the tab and then selecting **Limb**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的效应器就位后，将`IK Manager 2D`组件添加到根骨上，并通过在选项卡中单击加号（**+**）按钮并选择**肢体**来开始为肢体添加**IK求解器**。
- en: We’re making this selection because it’s meant for posing joints specifically
    for arms and legs (also known as a **two-bone Solver**).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行这个选择是因为它专门用于摆姿势的关节，特别是手臂和腿部的关节（也称为**双骨求解器**）。
- en: Additional reading | Unity documentation
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'IK Solvers: [https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers](https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: IK求解器：[https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers](https://docs.unity3d.com/Packages/com.unity.2d.animation@9.0/manual/2DIK.xhtml#ik-solvers)。
- en: Adding an `LimbSolver2D` component added.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了`LimbSolver2D`组件。
- en: 'Perform the following steps to complete the IK limb setup for the front arm:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成前手臂的IK肢体设置：
- en: Rename `New LimbSovler2D` to `Front Arm LimbSolver2D` and keep it selected so
    that the `LimbSolver2D` component is visible in the **Inspector** window.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`New LimbSovler2D`重命名为`Front Arm LimbSolver2D`并保持选中状态，以便在**检查器**窗口中可见`LimbSolver2D`组件。
- en: Click and drag the `IK Effector` object for the front forearm to the `LimbSolver2D`
    component.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动前臂的`IK Effector`对象到`LimbSolver2D`组件。
- en: Once this `_Target` child GameObject for the limb solver that we can now manipulate
    the position of in the **Scene** view to pose the limb.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这个用于肢体求解器的`_Target`子GameObject现在可以在**场景视图**中操纵其位置来摆姿势肢体。
- en: Click and drag the circle icon that has now appeared on the **Target** transform
    in the **Scene** view to test out the IK limb.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动现在出现在**场景视图**中**目标**变换上的圆形图标来测试IK肢体。
- en: Note that the default value for **Flip** is disabled, which may work just fine
    for how the target was created, but if the limb is bending backward as you drag
    the target around, then enable **Flip** to solve this issue.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，**翻转**的默认值是禁用的，这可能对目标的创建方式工作得很好，但如果你在拖动目标时肢体向后弯曲，则启用**翻转**以解决这个问题。
- en: '*Figure 5**.7* illustrates the results of these steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5**.7*展示了这些步骤的结果：'
- en: '![Figure 5.7 – IK Effector and limb solver setup](img/B18347_05_7.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – IK效应器和肢体求解器设置](img/B18347_05_7.jpg)'
- en: Figure 5.7 – IK Effector and limb solver setup
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – IK效应器和肢体求解器设置
- en: The `Front Arm LimbSolver2D_Target` object’s transform position is what is keyframed
    during animation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画过程中，`Front Arm LimbSolver2D_Target`对象的变换位置是关键帧。
- en: Important note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Once the IK Solvers have been set up, we can no longer scale the player character
    with the **Pixels Per Unit** value in the **PSD Importer** settings – this is
    due to the IK targets being based on the transform local positions, which won’t
    update when the sprite’s PPU is scaled. Instead, change the transform scale on
    the parented **PlayerCharacter1** object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了IK求解器，我们就不能再使用**PSD导入器**设置中的**每单位像素**值来缩放玩家角色——这是由于IK目标基于变换局部位置，当精灵的PPU缩放时，它们不会更新。相反，更改父对象**PlayerCharacter1**上的变换缩放。
- en: You can now follow these steps any time you need to create an IK limb on a skinned
    actor rig. Go ahead and make IK limbs for the back arm and both legs. With that,
    we’re ready to animate!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在需要为蒙皮演员骨架创建IK肢体时遵循这些步骤。现在就为后手臂和两条腿创建IK肢体。有了这些，我们就准备好动画了！
- en: Reminder
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Don’t forget to apply changes to the **Player** Prefab!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将更改应用到**Player** Prefab！
- en: Additional resources | 2D characters
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其他资源 | 2D角色
- en: 'Another option for getting a head start on creating your rigged and animated
    2D characters is to work with existing example characters from either the Dagon
    Crashers or Lost Crypt sample projects that Unity provides on the Asset Store:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在创建有骨架和动画的2D角色时取得先机的选项是使用Unity在Asset Store上提供的现有示例角色，这些角色来自Dagon Crashers或Lost
    Crypt样本项目：
- en: 'Dragon Crashers: [https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721](https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Dragon Crashers：[https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721](https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721).
- en: 'Lost Crypt: [https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673](https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 失落的密室：[https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673](https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673).
- en: Creating actor animations
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建演员动画
- en: '**Actor animation** is the process of repositioning or rotating the actor’s
    bones at different times on the timeline of the **Animation** window, which is
    recorded as keyframes that hold the transform data. In [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079),
    we performed a simpler version of this process when we animated the vines.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**演员动画**是将演员的骨骼在不同时间在**动画**窗口的时间轴上重新定位或旋转的过程，这被记录为关键帧，并包含变换数据。在[*第4章*](B18347_04.xhtml#_idTextAnchor079)中，当我们对藤蔓进行动画制作时，我们执行了这个过程的简化版本。'
- en: 'Let’s start animating the actor:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始对演员进行动画制作：
- en: First, we’ll make an idle animation by opening the **Animation** window by going
    to **Window** | **Animation** | **Animation**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过转到**窗口** | **动画** | **动画**来打开**动画**窗口，制作一个空闲动画。
- en: Select `PlayerCharacter1` in the hierarchy (not the root `Player` object; we
    want to animate the *graphics*, which can be later switched out with a different
    actor that may not have the same skeletal rig) and click the **Create** button.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`PlayerCharacter1`（不是根`Player`对象；我们想要动画化的是*图形*，这可以在以后用可能没有相同骨骼结构的不同演员替换）并点击**创建**按钮。
- en: This will create an animation asset file (`.anim`) that we’ll name `Player Idle`
    and save to the `Assets/Animation` folder.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建一个动画资产文件（`.anim`），我们将命名为`Player Idle`并将其保存到`Assets/Animation`文件夹中。
- en: Now, put your animator hat on again, because it’s time to animate!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次戴上你的动画师帽子，因为现在是时候进行动画制作了！
- en: The first thing to note while animating with IK limbs is why we added the new
    root bone in the *Setting Up inverse kinematics (IK)* section. Select the `bone_1`,
    our *original* root bone).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用IK肢体进行动画制作时，首先要注意的是为什么我们在*设置逆运动学（IK）*部分添加了新的根骨骼。选择`bone_1`，我们的*原始*根骨骼）。
- en: You’ll notice that a square outline has appeared at the larger end of the bone
    (the base) and that hovering the mouse pointer within this square will show a
    move icon. Hovering over the part of the bone outside of the square will show
    a rotate icon. Click and hold the left-mouse button within the square and slowly
    drag it down.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在骨骼（基座）的较大端出现了一个方形轮廓，将鼠标指针悬停在方形内部将显示移动图标。将鼠标指针悬停在方形之外的骨骼部分将显示旋转图标。在方形内点击并按住左键，然后慢慢向下拖动。
- en: The whole actor will start to move down except for the feet – they will remain
    firmly grounded in place. This would not be possible without IK and the new root
    bone we added. Yay!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 整个演员将开始向下移动，除了脚部——它们将坚定地保持在原地。没有IK和新增的根骨骼，这是不可能的。太好了！
- en: 'One more thing to note with the IK limbs before letting you lose to create
    your idle animation – you can position the limbs in two ways:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始创建空闲动画之前，还有一点需要注意关于IK肢体：你可以通过两种方式定位肢体：
- en: By clicking and dragging the IK circular targets in the **Scene** view
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在**场景**视图中点击并拖动IK圆形目标
- en: By selecting the `… LimbSolver2D_Target` objects in the **Hierarchy** window
    and using the **Move** tool in the **Scene** view (or entering **Transform** values
    in the **Inspector** window)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在**层次结构**窗口中选择`… LimbSolver2D_Target`对象，并在**场景**视图中使用**移动**工具（或在**检查器**窗口中输入**变换**值）。
- en: 'Do not try to keyframe individual bones in the IK chains, the IK Effector objects,
    or the objects with the `LimbSolver2D` components! Create your idle animation
    by following these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试在 IK 链中的单个骨骼、IK 效应对象或具有 `LimbSolver2D` 组件的对象上创建关键帧！通过以下步骤创建你的站立动画：
- en: Click the red record button (the **Animation** window; **Keyframe Recording**
    mode) to start recording keyframes (any time a bone is rotated or repositioned,
    a key will be created).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击红色记录按钮（**动画**窗口；**关键帧记录**模式）以开始记录关键帧（每当骨骼旋转或重新定位时，都会创建一个关键点）。
- en: Pose your actor into a nice starting position for a simple idling in place.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的演员摆放到一个简单站立不动的起始位置。
- en: Scrub the timeline ahead about 1.5 seconds and make a second pose by lowering
    the torso bending into the knees, bending the arms, and tilting down the head
    slightly – something like that.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将时间轴向前拖动约 1.5 秒，然后通过降低躯干弯曲到膝盖、弯曲手臂和轻微倾斜头部来制作第二个姿势——类似这样。
- en: Now, to animate between these two poses, click and drag a rectangle around the
    starting frame’s keys – press *Ctrl*/*Cmd* + *C* to copy those keys.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了在这两个姿势之间进行动画，点击并拖动一个矩形围绕起始帧的关键点——按 *Ctrl*/*Cmd* + *C* 复制这些关键点。
- en: Scrub the timeline to 3 seconds and press *Ctrl*/*Cmd* + *V* to paste the keys.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将时间轴拖到 3 秒处，然后按 *Ctrl*/*Cmd* + *V* 粘贴这些关键点。
- en: Click the red record button again to stop recording, then use the **Play** button
    to check the results.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击红色记录按钮以停止记录，然后使用 **播放** 按钮检查结果。
- en: 'You know the drill – animation is more art than technical, so fiddle with the
    poses and timing until you get good results. *Figure 5**.8* illustrates a completed
    actor idle animation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道该怎么做——动画更多的是艺术而不是技术，所以调整姿势和时机，直到你得到满意的结果。*图 5*.8* 展示了一个完成的演员站立动画：
- en: '![Figure 5.8 – Actor keyframe idle animation](img/B18347_05_8.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 演员关键帧站立动画](img/B18347_05_8.jpg)'
- en: Figure 5.8 – Actor keyframe idle animation
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 演员关键帧站立动画
- en: Note that in *Figure 5**.8*, I’ve changed the color of the IK Solvers (the `IKManager2D`
    component on the `root_bone` object) to give the limb bones their own color –
    another way to visually organize the different components that make up the actor
    and make it a bit easier to work with.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 *图 5*.8* 中，我已经将 IK 求解器（`root_bone` 对象上的 `IKManager2D` 组件）的颜色更改，以给肢体骨骼赋予自己的颜色——这是组织构成演员的不同组件的另一种视觉方式，使其更容易处理。
- en: With our base idle animation added to the character, let’s look at how to drive
    animation and apply movement to our character from player input.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在将基本站立动画添加到角色后，让我们看看如何通过玩家输入来驱动动画并将动作应用到我们的角色上。
- en: Using an Input Action Map
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输入动作图
- en: 'We’ll continue to use the new `Input System` package installed:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用新安装的 `Input System` 包：
- en: Open **Package Manager** by going to **Window** | **Package Manager**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **窗口** | **包管理器** 来打开 **包管理器**。
- en: The default **Packages** location is **In Project**, so if you see **Input System**
    in the list under the **Package – Unity** section, then we’re all set!
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的 **包** 位置是 **项目内**，所以如果你在 **包 – Unity** 部分的列表中看到 **输入系统**，那么我们就准备好了！
- en: If you can’t find **Input System**, then switch the **Packages** dropdown to
    **Unity Registry**, select **Input System** from the list, and click **Install**
    (the bottom-right corner of the window). See [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041),
    section *New Input System* for a refresher.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找不到 **输入系统**，则将 **包** 下拉菜单切换到 **Unity 注册表**，从列表中选择 **输入系统**，然后点击 **安装**（窗口的右下角）。参见
    [*第 2 章*](B18347_02.xhtml#_idTextAnchor041)，*新输入系统* 节以获取复习。
- en: For the collection game, we received input directly from **Input Device**; this
    time, we will use the **Input Action** approach. For that, we’re going to need
    an **Action** **Map** asset.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于收集游戏，我们直接从 **输入设备** 接收输入；这次，我们将使用 **输入动作** 方法。为此，我们需要一个 **动作** **映射** 资产。
- en: Thankfully, creating a default action map for the player character is quite
    trivial – with most of the device inputs we’ll need for the keyboard and a game
    controller already made!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，为玩家角色创建默认动作图相当简单——我们需要的键盘和游戏控制器的大部分设备输入已经准备好了！
- en: 'Follow these steps to accomplish this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此操作：
- en: The magic happens via the `Player Input` component. So, add it to the root object
    of the `Player` Prefab by using the **Add Component** button in the **Inspector**
    window.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 魔法是通过 `Player Input` 组件实现的。因此，通过在 **检查器** 窗口中使用 **添加组件** 按钮将其添加到 `Player` 预制件的根对象。
- en: Important note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can work with the **Player** Prefab by adding it to a scene or working on
    it directly by double-clicking the Prefab in the **Project** window.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将其添加到场景或通过在 **项目** 窗口中双击 Prefab 直接在它上工作来使用 **玩家** Prefab。
- en: 'Once the `Player Input` component has been added, click the **Create Actions…**
    button, as shown in the following screenshot. This will create a default set of
    **Input Action Maps**, **Input Actions**, and **Input Bindings**:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加了 `Player Input` 组件，点击下面的截图所示的 **创建动作…** 按钮。这将创建一组默认的 **输入动作映射**、**输入动作**
    和 **输入绑定**：
- en: '![Figure 5.9 – Player Input | Create Actions](img/B18347_05_9.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 玩家输入 | 创建动作](img/B18347_05_9.jpg)'
- en: Figure 5.9 – Player Input | Create Actions
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 玩家输入 | 创建动作
- en: You will be prompted to save the new `.inputactions` asset. Select the `Assets/Settings`
    folder and use `Player Input` as the name for it. This asset will then be connected
    to the `Player Input` component and bring up the **Input** **Actions editor**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被提示保存新的 `.inputactions` 资产。选择 `Assets/Settings` 文件夹，并将其命名为 `Player Input`。然后，该资产将与
    `Player Input` 组件连接，并打开 **输入** **动作编辑器**。
- en: Here, we can see all of the actions pre-populated for the player action map,
    as shown in *Figure 5**.10* – everything we need plus more!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到为玩家动作映射预先填充的所有动作，如图 *图 5.10* 所示 – 我们所需的一切以及更多！
- en: '![Figure 5.10 – Player Input Action Maps (Input Actions)](img/B18347_05_10.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 玩家输入动作映射（输入动作）](img/B18347_05_10.jpg)'
- en: Figure 5.10 – Player Input Action Maps (Input Actions)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 玩家输入动作映射（输入动作）
- en: Additional reading | Unity documentation
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多 | Unity 文档
- en: 'Input System: [https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输入系统：[https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/QuickStartGuide.xhtml).
- en: 'Editing Input Actions Assets: [https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑输入动作资产：[https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/ActionAssets.xhtml#editing-input-actionassets).
- en: The `Player Input` component also provides everything we need to respond to
    input from the player. *Figure 5**.10* sets the `SendMessage()` on the GameObject
    to which the `Player Input` component belongs, calling the name on every component
    (`MonoBehaviour`) added to the GameObject. As shown in *Figure 5**.10*, the relevant
    method names will be called as listed in the box just below the **Behavior** field.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player Input` 组件也为我们提供了响应玩家输入所需的一切。*图 5.10* 将 `SendMessage()` 设置在 `Player
    Input` 组件所属的 GameObject 上，调用添加到 GameObject 上的每个组件 (`MonoBehaviour`) 的名称。如图 *图
    5.10* 所示，相关的方法名称将按照在 **行为** 字段下方方框中列出的顺序被调用。'
- en: Additional reading | Unity documentation
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多 | Unity 文档
- en: 'Notification behaviors: [https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通知行为：[https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.4/manual/Components.xhtml#notification-behaviors).
- en: For simplicity’s sake, we’ll stick with the `SendMessage()`, which is slower
    due to having to use **Reflection**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将坚持使用 `SendMessage()`，因为它需要使用 **反射**，所以速度较慢。
- en: Reflection | C#
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 反射 | C#
- en: '**SendMessage()** heavily relies on **Reflection** to find the method to call
    at runtime. **Reflection** is slow (supposedly 3x slower than calling the method
    directly) because it requires managed code to read (search) its metadata to find
    assemblies.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**SendMessage()** 严重依赖 **反射** 来在运行时找到要调用的方法。**反射** 慢（据说比直接调用方法慢 3 倍），因为它需要托管代码读取（搜索）其元数据以找到程序集。'
- en: With our input set up and we know how to respond to the inputs we’ve defined,
    we’re ready to write our player controller code!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好输入并知道如何响应我们定义的输入后，我们就可以编写玩家控制器代码了！
- en: Moving the player with a player controller script
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用玩家控制器脚本移动玩家
- en: We’ll need more than just input to move our player character around the level.
    We’ll have to configure the `Player` object to work with the **Physics** system
    so that it interacts with our level’s ground and platforms and interactivity trigger
    volumes, and then applies the movement force.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的不只是输入来移动玩家角色在关卡中的位置。我们还需要配置`Player`对象与**物理**系统协同工作，以便它与我们的关卡地面、平台和交互触发体积交互，并应用移动力。
- en: 'Configure the `Player` Prefab’s root GameObject with the following components
    while referring to *Figure 5**.11*:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在参考*图5.11*的同时，配置`Player`预制件的根GameObject以下组件：
- en: 'Add a `Rigidbody2D` component (by pressing the `1`: We’ll add some drag to
    the player’s movement to provide additional constraints on the move to help the
    player feel more grounded and not very floaty.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按`1`添加`Rigidbody2D`组件。我们将为玩家的移动添加一些阻力，以提供额外的移动约束，帮助玩家感觉更加脚踏实地，而不是太飘。
- en: '**Constraints** | **Freeze Rotation Z** enabled: We want to prevent the player
    from spinning around and have them always stand vertically (perpendicular to the
    ground plane).'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**约束** | **冻结旋转Z**已启用：我们希望防止玩家旋转，并使他们始终垂直站立（垂直于地面平面）。'
- en: Add `CapsuleCollider2D` (by pressing the **Add Component** button). Use the
    **Edit bounding volume** button and modify the collider’s shape until it encompasses
    the actor.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按**添加组件**按钮添加`CapsuleCollider2D`。使用**编辑边界体积**按钮并修改碰撞器的形状，直到它包围了演员。
- en: 'This represents the player’s hitbox, which may need to be adjusted over time
    as you playtest:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这代表玩家的击中区域，随着你进行游戏测试，可能需要调整：
- en: '![Figure 5.11 – Player physics setup](img/B18347_05_11.jpg)'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图5.11 – 玩家物理设置](img/B18347_05_11.jpg)'
- en: Figure 5.11 – Player physics setup
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 玩家物理设置
- en: With the required `Player Input` component is only responsible for reading the
    device input and invoking the assigned action.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 仅负责读取设备输入并调用分配的动作的`Player Input`组件。
- en: Processing Player Input
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理玩家输入
- en: 'While we could use the device input directly, as we did in the *Player controller
    script* section of [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041), it’s essential
    to understand the value of using **Input Action Map**. Here are a few examples:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以在*玩家控制器脚本*部分的[*第2章*](B18347_02.xhtml#_idTextAnchor041)中使用设备输入，就像我们做的那样，但理解使用**输入动作映射**的价值是至关重要的。以下是一些示例：
- en: Multiple device inputs can be simultaneously configured without the need to
    change the input handling code
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以同时配置多个设备输入，而无需更改输入处理代码。
- en: A different action map can be switched to, depending on the current input actions
    required
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以根据当前所需的输入操作切换到不同的动作映射。
- en: Key rebinding can be implemented without changing the input handling code
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在不更改输入处理代码的情况下实现按键重绑定。
- en: Armed with this knowledge, you can determine the best approach for different
    use cases (are you prototyping? Are you engineering a flexible solution for a
    commercial title?).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，你可以确定针对不同用例的最佳方法（你是在原型设计吗？你是在为商业游戏设计一个灵活的解决方案吗？）。
- en: 'Previously, we continuously polled the `isPressed` key state directly on the
    input device in the `Update()` loop to control the player movement, like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在`Update()`循环中直接对输入设备上的`isPressed`键状态进行连续轮询，以控制玩家移动，如下所示：
- en: '[PRE0]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since we’re receiving our input handling from `SendMessage()` now, we’ll need
    to make some changes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在从`SendMessage()`接收输入处理，我们需要做一些更改。
- en: '`SendMessage()` is called anytime there is input. Input is not continuously
    polled! It behaves like an event whenever an input action occurs, which means
    that for the *Move* action, `OnMove()` will be called when a key is pressed and
    when it’s released.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有输入时都会调用`SendMessage()`。输入不是连续轮询的！它每次输入操作发生时都表现得像事件，这意味着对于*移动*操作，当按键按下和释放时，都会调用`OnMove()`。
- en: The `SendMessage()` method names that were invoked for the defined input actions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 调用用于定义输入操作的`SendMessage()`方法名称。
- en: '`SendMessage()` will also pass an `InputValue` parameter representing the `Vector2`
    in the case of *Move*, which holds the horizontal and vertical input values.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在*移动*的情况下，`SendMessage()`还将传递一个表示`Vector2`的`InputValue`参数，它包含水平和垂直输入值。
- en: We’ll use the horizontal (X-axis) value to determine if a **move left/right**
    button was pressed or released since we want to move our player while the button
    is being held down (or while holding a game controller’s stick in a certain direction).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用水平（X轴）值来确定是否按下了**移动左右**按钮，因为我们希望在按钮被按下时（或握住游戏控制器棒子朝某个方向时）移动我们的玩家。
- en: Our `move` method (`OnMove()`) will be called with a `Vector2` X-axis value
    for a horizontal input of `-1` and `1` for left and right, respectively, when
    a button is pressed, and a value of `0` when the button is released.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`move`方法（`OnMove()`）将在按下按钮时，使用`Vector2` X轴值来表示水平输入，当输入为`-1`时表示向左，输入为`1`时表示向右，而当按钮释放时，值为`0`。
- en: Now that we have all this information, we can begin to code our input handler!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有这些信息，我们可以开始编写我们的输入处理代码了！
- en: Creating the PlayerController script
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建PlayerController脚本
- en: Let’s start by creating a new C# script named `PlayerController` in the `Assets/Scripts`
    folder.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`Assets/Scripts`文件夹中创建一个名为`PlayerController`的新C#脚本开始。
- en: We can now add our input handler method for the *move* action – `OnMove()` –
    and assign the `InputValue` parameter’s `Vector2` value to a private member variable
    named `_movementInput`. We’ll use this later when we calculate the movement to
    be applied to the player’s **Rigidbody2D** velocity.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加我们的移动动作输入处理方法`OnMove()`，并将`InputValue`参数的`Vector2`值分配给名为`_movementInput`的私有成员变量。我们将在稍后使用它来计算应用于玩家`Rigidbody2D`速度的移动。
- en: 'Here’s what our initial code looks like:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们初始代码的样子：
- en: '[PRE1]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We read the input values of the input using the `Get()` method of the `value`
    parameter variable. We’re only interested in the horizontal movement here and
    will set the `_movementInput` value depending on the input state: pressed or released.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`value`参数变量的`Get()`方法读取输入值。我们在这里只对水平移动感兴趣，并将`_movementInput`值根据输入状态设置：按下或释放。
- en: So, if `move.x` equals `0`, then the button key was released (think of it as
    `IsPressed == false`). Then, using a ternary operator (`?:`), we’ll assign `Vector2.zero`
    to make sure that any/all input is ignored.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`move.x`等于`0`，那么按钮键被释放（可以将其视为`IsPressed == false`）。然后，使用三元运算符（`?:`），我们将`Vector2.zero`赋值以确保忽略任何/所有输入。
- en: 'When `move.x` is not equal to zero, we have a button key press input value
    that represents the direction (`-1`: *left*, `1`: *right*) and assign it to `_movementInput`
    with a new `Vector2` of the direction and no vertical value: `new` `Vector2(move.x,
    0f)`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当`move.x`不等于零时，我们有一个按钮按键输入值，它表示方向（`-1`：*左*，`1`：*右*），并将其分配给`_movementInput`，使用一个新的`Vector2`表示方向，没有垂直值：`new`
    `Vector2(move.x, 0f)`。
- en: With this approach, we can still respond to vertical input later, such as one
    for a jetpack! Now that we have a direction, we can apply force (in the form of
    velocity) to move the player character in that direction.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们仍然可以稍后响应垂直输入，例如喷射背包的输入！现在我们有了方向，我们可以应用力（以速度的形式）来移动玩家角色。
- en: 'Let’s add the following code to handle this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加以下代码来处理这种情况：
- en: '[PRE2]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break this code down item by item:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐项分析这段代码：
- en: 'The `_rb` variable: This private member variable will hold a reference to the
    `Rigidbody2D` component that we previously added, and we’ll be setting the velocity
    here to move the player. We once made this a `public` field that could be assigned
    in the **Inspector** window, but we’ll keep it private this time to encapsulate
    it.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_rb`变量：这个私有成员变量将保存我们之前添加的`Rigidbody2D`组件的引用，并且我们将在这里设置速度以移动玩家。我们曾经将其设置为`public`字段，可以在**检查器**窗口中分配，但这次我们将保持它为私有以封装它。'
- en: 'The `Awake()` method (expression body): Since our `Rigidbody2D` variable is
    private, we’re only using this Unity message event to get the reference to the
    `Rigidbody2D` component on this object at runtime using `GetComponent()`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Awake()`方法（表达式体）：由于我们的`Rigidbody2D`变量是私有的，我们只使用这个Unity消息事件在运行时使用`GetComponent()`获取这个对象上的`Rigidbody2D`组件的引用。'
- en: Additional reading | Unity documentation
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**GameObject.GetComponent**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**GameObject.GetComponent**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.GetComponent.xhtml).'
- en: 'The `FixedUpdate()` method (expression body): This Unity message event is called
    at every `UpdateVelocity()` method.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedUpdate()`方法（表达式体）：这是Unity消息事件，在每次`UpdateVelocity()`方法调用时都会被调用。'
- en: 'The `UpdateVelocity()` method: This method will calculate and apply the velocity
    vector to the Player’s `Rigidbody2D` component.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateVelocity()`方法：此方法将计算并应用速度向量到玩家的`Rigidbody2D`组件。'
- en: '`var velocity`: This holds the current value of the `Rigidbody2D` component’s
    velocity that we’ll modify and assign back.'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var velocity`：这保存了我们将要修改并重新分配的`Rigidbody2D`组件当前速度的值。'
- en: 'The `velocity` calculation: This adds the movement input vector multiplied
    by `fixedDeltaTime` to the velocity variable. Multiplying by `fixedDeltaTime`
    ensures frame rate independence.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度计算：这会将移动输入向量乘以`fixedDeltaTime`后添加到速度变量中。乘以`fixedDeltaTime`确保帧率无关性。
- en: 'The `_rb.velocity` assignment: Here, we simply assign the calculated velocity
    back to the `Rigidbody2D` component, which moves the player. Remember that `FixedUpdate`
    should always be used for executing physics-related code, especially for applying
    force to a `Rigidbody` component!'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_rb.velocity`赋值：在这里，我们只是将计算出的速度重新赋值给`Rigidbody2D`组件，从而移动玩家。记住，`FixedUpdate`应该始终用于执行与物理相关的代码，特别是对`Rigidbody`组件应用力时！'
- en: Author’s note
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 作者注记
- en: I’ve read discussions on whether it’s necessary to apply **deltaTime** in **FixedUpdate**
    because it runs at a consistent framerate. Anyway, I err on the side of knowing
    that the **FixedUpdate** interval is always relative to the in-game time. Also,
    the Unity-provided example code always includes **deltaTime**, and being consistent
    in including it will ensure we achieve frame rate independence across all devices.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我阅读了关于是否需要在**FixedUpdate**中应用**deltaTime**的讨论，因为它的运行帧率是恒定的。无论如何，我倾向于知道**FixedUpdate**的间隔始终相对于游戏时间。此外，Unity提供的示例代码总是包含**deltaTime**，保持一致地包含它将确保我们在所有设备上实现帧率无关性。
- en: Additional reading | Unity documentation
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**Time.fixedDeltaTime**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time.fixedDeltaTime**：[https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-fixedDeltaTime.xhtml)。'
- en: 'Time and Frame Rate Management: [https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 时间和帧率管理：[https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/TimeFrameManagement.xhtml)。
- en: Multiplying by zero always gives zero, so `Vector2.zero` with `_movementInput`
    will assign a velocity value of zero, stopping the player’s movement.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 乘以零总是得到零，所以`Vector2.zero`与`_movementInput`一起将速度值赋为零，停止玩家的移动。
- en: We’ve applied velocity to the player, but don’t get too excited. This will likely
    have no net effect on moving the player because the velocity value is too small!
    Let’s fix that by applying an acceleration multiplier to the velocity.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经给玩家应用了速度，但不要过于兴奋。这很可能会对移动玩家没有净效果，因为速度值太小！让我们通过给速度应用一个加速度乘数来解决这个问题。
- en: 'Add the following member variables and make the changes that are shown here
    to the `UpdateVelocity()` method:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UpdateVelocity()`方法中添加以下成员变量，并按照以下所示进行更改：
- en: '[PRE3]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s break down these changes:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这些更改：
- en: 'We’ve added two new variables, `_acceleration` and `_speedMax`, which we’ve
    set to private but made available to assign in the `[SerializeField]` attribute
    to decorate a private accessor field, we’re telling Unity to serialize it and
    make it available for assignment in the `_acceleration`: This applies our overall
    velocity amount (force) for how quickly we’ll reach the maximum speed value.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了两个新变量`_acceleration`和`_speedMax`，我们将它们设置为私有，但通过`[SerializeField]`属性将其公开，我们告诉Unity序列化它并使其可用于赋值，`_acceleration`：这应用于我们的整体速度量（力），以确定我们达到最大速度值所需的时间。
- en: '`_speedMax`: The maximum speed of the player character’s movement.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_speedMax`：玩家角色移动的最大速度。'
- en: 'In the `UpdateVelocity()` method, we’ve made the following changes:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`UpdateVelocity()`方法中，我们进行了以下更改：
- en: We’ve modified the line that adds to the velocity vector by multiplying by the
    `_acceleration` value.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过乘以`_acceleration`值修改了增加速度向量的行。
- en: We’ve ensured that `velocity.x` will be clamped to the maximum speed value by
    using the `Mathf.Clamp()` method.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经确保使用`Mathf.Clamp()`方法将`velocity.x`限制在最大速度值。
- en: Additional reading | Unity documentation
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**SerializeField**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**SerializeField**：[https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/SerializeField.xhtml)。'
- en: You can now add the `PlayerController` script to the root of the `Player` Prefab,
    add your player to a scene with some ground (don’t forget to add a collider),
    and playtest. You can move the player with the *A* and *D* keys, left and right
    arrow keys, or a game controller’s left stick. You can adjust values for acceleration,
    max speed, and the **Rigidbody2D** properties for mass and linear drag.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将`PlayerController`脚本添加到`Player`预制件的根目录，将玩家添加到一个带有地面的场景中（别忘了添加碰撞器），并进行游戏测试。您可以使用*A*和*D*键、左右箭头键或游戏控制器的左摇杆来移动玩家。您可以调整加速度、最大速度以及**Rigidbody2D**属性的质量和线性阻力值。
- en: PlayerController.cs code
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerController.cs代码
- en: 'To view the completed code for the **PlayerController** class, visit the following
    GitHub repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看**PlayerController**类的完整代码，请访问以下GitHub仓库：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts)。
- en: Playtesting means tweaking these movement variables repeatedly until the player
    control *feels right* to you. I’ve currently settled on values of `30` for acceleration
    and `8` for max speed. As you build out the game, you’ll find yourself going back
    and tweaking these values many, many more times – game feel is crucial to player
    satisfaction.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏测试意味着反复调整这些移动变量，直到您觉得玩家控制*感觉正确*。我目前将加速度设置为`30`，最大速度设置为`8`。随着您构建游戏，您将发现自己需要多次返回并调整这些值
    – 游戏感觉对玩家满意度至关重要。
- en: Physics materials
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理材质
- en: While playtesting, you may notice that the player may slide for a bit when you
    release the key (or controller stick). This can be corrected by freezing the player
    in place when the key is released, but I believe a better way is to change the
    properties of the ground the player is currently standing on. By adjusting the
    friction of the ground, we can provide different types of ground, including ice,
    where the player would slide when input is released.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行游戏测试时，您可能会注意到，当您释放按键（或控制器摇杆）时，玩家可能会滑动一小段时间。这可以通过在释放按键时将玩家冻结在原地来纠正，但我认为更好的方法是改变玩家当前站立地面的属性。通过调整地面的摩擦力，我们可以提供不同类型的地面，包括冰面，当玩家释放输入时，玩家会在冰面上滑动。
- en: We’re going to add a **physics material** to the ground to provide *higher default
    friction*. That way, we can have areas with less friction later to change up the
    gameplay, and so on.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在地面上添加一种**物理材质**以提供*更高的默认摩擦力*。这样，我们就可以在游戏后期拥有摩擦力较小的区域，以改变游戏玩法等。
- en: 'Follow these steps to create a new physics material and apply it to the ground
    objects in your level:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个新的物理材质并将其应用于您关卡中的地面对象：
- en: In the `Assets/Settings` folder, create a new folder and name it `Physics Materials`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Settings`文件夹中创建一个新的文件夹，并将其命名为`Physics Materials`。
- en: Right-click within the new folder, select `Default Friction`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹内右键单击，选择`Default Friction`。
- en: Select the newly created physics material and, in the `10` (this, like all other
    gameplay variables, is subject to change with playtesting).
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新创建的物理材质，在`10`（这，像所有其他游戏变量一样，可能会在游戏测试中改变）。
- en: 'Now, assign the physics material to your ground objects by dragging it into
    the `Collider` component, as seen in the following figure:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过拖动它到`Collider`组件中，将物理材质分配给您的地面对象，如图所示：
- en: '![Figure 5.12 – Assigning a physics material to the ground collider](img/B18347_05_12.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12 – 将物理材质分配给地面碰撞器](img/B18347_05_12.jpg)'
- en: Figure 5.12 – Assigning a physics material to the ground collider
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 将物理材质分配给地面碰撞器
- en: Continue to playtest and adjust these values.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行游戏测试并调整这些值。
- en: We’ll finish up the initial player controller next by adding a run animation
    and having the player always face the direction of movement.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过添加跑步动画并使玩家始终面向移动方向来完成初始玩家控制器的设置。
- en: Animating the character with Mecanim
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mecanim动画角色
- en: In the *Creating actor animations* section, we added an `PlayerCharacter1` object
    when we created the idle animation for the actor. The `Animator` component allows
    us to assign animation to a GameObject in the **Scene** view – it’s the interface
    responsible for controlling Unity’s **Mecanim** animation system (on the actor
    or any other GameObject you’d like to animate).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建演员动画*部分，当我们为演员创建空闲动画时，我们添加了`PlayerCharacter1`对象。`Animator`组件允许我们将动画分配给**场景**视图中的GameObject
    – 它是负责控制Unity的**Mecanim**动画系统（在演员或任何其他你想要动画化的GameObject上）的接口。
- en: An `Animator` component. This controller asset defines what animations to use
    and when and how to transition and blend them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Animator`组件。这个控制器资产定义了使用哪些动画以及何时以及如何过渡和混合它们。
- en: Additional reading | Unity documentation
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'Animator: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'Animator: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-Animator.xhtml).'
- en: To continue setup in the `Animator` component, we’ll need a second animation
    to transition to when our player character moves or, let’s say, runs.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`Animator`组件中继续设置，我们需要第二个动画，当我们的玩家角色移动或，比如说，跑步时过渡到。
- en: 'Follow these steps to create an additional animation for the actor:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为演员创建额外的动画：
- en: Open the `PlayerCharacter1` object in the **Scene** view.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**视图中打开`PlayerCharacter1`对象。
- en: 'Now, in the **Animation** window, click the **Animation Clips** list dropdown
    (the top left of the window just under the playback controls), then click **Create
    New Clip…**, as seen in the following figure:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**动画**窗口中，点击**动画剪辑**列表下拉菜单（窗口左上角，位于播放控制下方），然后点击**创建新剪辑…**，如图所示：
- en: '![Figure 5.13 – Create New Clip…](img/B18347_05_13.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13 – 创建新剪辑…](img/B18347_05_13.jpg)'
- en: Figure 5.13 – Create New Clip…
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 创建新剪辑…
- en: Save the new clip as `Player Run` in the `Assets/Animation` folder.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Animation`文件夹中将新剪辑保存为`Player Run`。
- en: Animate a run cycle. You’ve got this!
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动画跑步周期。你做到了！
- en: Seriously though, animation is a skill you’ll need to grow into. While I can
    create animations, I still need lots of practice in this area to get better at
    it (I’ll likely employ a skilled character animator for the final actor animations
    in the finished project files for this book, and these will be available for you
    to use and learn from as well).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 说真的，动画是一项你需要逐渐掌握的技能。虽然我可以创建动画，但我仍然需要在这个领域进行大量练习才能变得更好（我可能会在本书的最终项目文件中使用熟练的角色动画师，这些动画将可供你使用和学习）。
- en: Additional resources | 2D character animation
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 额外资源 | 2D角色动画
- en: Another option for getting a head start on character animations is to work with
    existing example characters from either the Dragon Crashers or Lost Crypt sample
    projects that Unity provides on the Asset Store.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个快速入门角色动画的选项是与Unity在Asset Store上提供的现有示例角色一起工作，这些角色来自龙之冲击者或失落的密室示例项目。
- en: 'Dragon Crashers: [https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721](https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '龙之冲击者: [https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721](https://assetstore.unity.com/packages/essentials/tutorial-projects/dragon-crashers-2d-sample-project-190721).'
- en: 'Lost Crypt: [https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673](https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '失落的密室: [https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673](https://assetstore.unity.com/packages/essentials/tutorial-projects/lost-crypt-2d-sample-project-158673).'
- en: We can now move on to wiring up the transition for the *idle to* *run* animation.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续设置从*空闲到* *跑步*动画的过渡。
- en: Transitioning animation states
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画状态过渡
- en: To open the `Animator` component on the `PlayerCharacter1` object or double-click
    on the `PlayerCharacter1` asset in the `Assets/Animation` folder in the **Project**
    window.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`PlayerCharacter1`对象上打开`Animator`组件或双击**项目**窗口中`Assets/Animation`文件夹中的`PlayerCharacter1`资产。
- en: 'With the **Animator** window open (you may want to dock it so that you can
    still see all the Editor windows clearly), you should see the default states (**Any
    State**, **Entry**, **Exit**) as well as states for the animation clips currently
    on the actor (**Player Idle**, **Player Run**):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开**Animator**窗口（你可能希望将其停靠以便仍然可以清楚地看到所有编辑器窗口）时，你应该看到默认状态（**任何状态**、**进入**、**退出**）以及当前在演员上的动画剪辑状态（**玩家空闲**、**玩家跑步**）：
- en: '![Figure 5.14 – Actor animation transition with Mecanim](img/B18347_05_14.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 使用 Mecanim 的角色动画过渡](img/B18347_05_14.jpg)'
- en: Figure 5.14 – Actor animation transition with Mecanim
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 使用 Mecanim 的角色动画过渡
- en: Note that you can navigate the **Animator** window using the mouse scroll wheel
    to zoom in/out and use the *Alt* + left-mouse button/*Option* + left-mouse button
    shortcut to pan the view. Click and drag on any State Node to reposition it in
    an orderly fashion.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以使用鼠标滚轮在**Animator**窗口中导航以放大/缩小视图，并使用*Alt* + 左键按钮/*Option* + 左键按钮快捷键来平移视图。点击并拖动任何状态节点以有序地重新定位它。
- en: Additional reading | Unity documentation
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'The **Animator** window: [https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**Animator**窗口：[https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/AnimatorWindow.xhtml)。'
- en: 'Follow these steps to create a **Transition** from the **Player Idle** to **Player**
    **Run** states:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从**玩家空闲**状态转换为**玩家跑步**状态创建一个**过渡**：
- en: 'First, create a Boolean parameter for whether we are running or not by executing
    the following steps:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过执行以下步骤创建一个布尔参数来表示我们是否在跑步：
- en: First, select the `Running` – we want a Boolean parameter to hold the state
    for if the player is running (`true`) or not running (`false`).
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，选择`Running` – 我们需要一个布尔参数来保存玩家是否跑步的状态（`true`表示跑步，`false`表示不跑步）。
- en: Right-click on the **Player Idle** node and select **Make Transition** from
    the popup menu.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**玩家空闲**节点，从弹出菜单中选择**创建过渡**。
- en: With the **Transition** arrow attached to the mouse pointer, click on the **Player**
    **Run** node.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**过渡**箭头附加到鼠标指针上，然后单击**玩家跑步**节点。
- en: Now, click on the newly created transition line (*B* in *Figure 5**.14*) to
    view its properties in the **Inspector** window.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，单击新创建的过渡线（*图 5.14*中的*B*）以在**检查器**窗口中查看其属性。
- en: Within the `true`; meaning, transition to the assigned node when the `true`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`true`；意味着，当`true`时，过渡到指定的节点。
- en: Go back to *step 2* and repeat the instructions to transition back to `false`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到*步骤 2*并重复指令以将过渡回`false`。
- en: The last step is to disable **Has Exit Time** (*D* in *Figure 5**.14*) for both
    transitions. We want the state to exit (the animation to stop) as soon as the
    condition is met and not wait for the animation to play completely.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是禁用两个过渡的**Has Exit Time**（*图 5.14*中的*D*）。我们希望状态在条件满足时立即退出（动画停止），而不是等待动画播放完毕。
- en: Since we haven’t wired up the animation states to the player input yet, you
    can test manually to make sure the transition is working well by entering **Play
    Mode** and, while viewing both the **Game view** and **Animator** windows, toggling
    the **Running** parameter on/off. The player should change from an *idle* to *run*
    animation and back every time you toggle the parameter. Yay!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有将动画状态连接到玩家输入，你可以通过进入**播放模式**并同时在**游戏视图**和**Animator**窗口中切换**Running**参数来手动测试以确保过渡工作良好。每次切换参数时，玩家应该从*空闲*动画切换到*跑步*动画，然后再切换回来。太棒了！
- en: Now, let’s make this transition based on the player’s input.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据玩家的输入来创建这个过渡。
- en: Changing the animation state with code
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码更改动画状态
- en: The first thing we’ll need is a variable to hold the reference to the `Animator`
    component (assignable in the `Running` parameter to `true`, and when the player
    stops moving the character, we will set the `Running` parameter to `false`. We’ll
    make quick work of this and accomplish it with only one line of code!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一个变量来保存对`Animator`组件的引用（在`Running`参数中可分配，当玩家停止移动角色时，我们将`Running`参数设置为`false`。我们将迅速完成这项工作，只用一行代码就能完成！）
- en: 'Add the following code to the `PlayerController` script:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`PlayerController`脚本中：
- en: '[PRE4]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `_animator` variable declaration is our reference to the `Animator` component
    in the `Player` object. We marked it as `private` so that no other class can modify
    it but decorated it with the `[SerializeField]` attribute so that it’s serialized
    and assignable in the **Inspector** window.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`_animator`变量声明是我们对`Player`对象中`Animator`组件的引用。我们将其标记为`private`，以便没有其他类可以修改它，但用`[SerializeField]`属性装饰，以便在**Inspector**窗口中进行序列化和赋值。'
- en: In the `UpdateVelocity()` method, we added a call to `_animator.SetBool()` and
    passed in the `Running` string to identify the bool parameter we’d like to set.
    We’ll pass in the evaluation result of the `_movementInput.x != 0f` expression
    for the bool value.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UpdateVelocity()`方法中，我们添加了对`_animator.SetBool()`的调用，并传入`Running`字符串以标识我们想要设置的布尔参数。我们将传入`_movementInput.x
    != 0f`表达式的评估结果作为布尔值。
- en: What this means is that if our player is receiving movement input (value is
    not zero), then we are moving (`Running` equals `true`); otherwise, (that is,
    `if _movementInput.x == 0f`), we are standing still (`Running` equals `false`).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们的玩家正在接收移动输入（值不为零），那么我们正在移动（`Running`等于`true`）；否则，（即`if _movementInput.x
    == 0f`），我们正静止不动（`Running`等于`false`）。
- en: Once you’ve added and saved this code, drag the child `PlayerCharacter1` object
    to the `PlayerController` component’s **Animator** field using the **Hierarchy**
    and **Inspector** windows in the **Editor** view.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加并保存此代码，请使用**Editor**视图中的**Hierarchy**和**Inspector**窗口将子对象`PlayerCharacter1`拖动到`PlayerController`组件的**Animator**字段。
- en: Enter **Play Mode** and move the player left and right to test that the animation
    is transitioning from idle to run and back. You’ll likely notice that even though
    the animation is transitioning, the actor is facing the wrong direction while
    moving to the left!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**Play Mode**，左右移动玩家以测试动画是否从空闲状态过渡到奔跑状态并返回。你可能会注意到，尽管动画正在过渡，但在向左移动时，演员的朝向是错误的！
- en: We’ll address this next to finish up the player movement.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一部分处理完玩家移动。
- en: Flipping the player character
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻转玩家角色
- en: While the `PlayerController` script to ensure the player is always facing the
    direction of movement.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在**PlayerController**脚本中确保玩家始终面向移动方向。
- en: 'Open the `PlayerController` script and, at the end of the `OnMove()` method,
    add a call to a new method named `UpdateDirection`. Create the `UpdateDirection()`
    method with the following code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`PlayerController`脚本，在`OnMove()`方法的末尾添加对新方法`UpdateDirection`的调用。使用以下代码创建`UpdateDirection()`方法：
- en: '[PRE5]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The simple trick we’re employing to flip the direction the player character
    is facing is to set the `localScale X` value to `-1` for the player object’s **Transform**
    if the movement input value is less than zero (that is, input indicating moving
    to the left).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来翻转玩家角色朝向的简单技巧是将玩家对象的**Transform**的`localScale X`值设置为`-1`，如果移动输入值小于零（即表示向左移动的输入）。
- en: The first `if` statement in `UpdateDirection()` checks if we have any input
    for moving the player. Remember, a value of zero means that the player released
    the direction key (or game controller stick).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateDirection()`中的第一个`if`语句检查是否有移动玩家的输入。记住，零值表示玩家释放了方向键（或游戏控制器摇杆）。'
- en: If the movement’s input horizontal value is not zero, we first set a default
    scale for facing right (an `X` value of `1`). If it turns out that the movement
    input is for facing left (an `X` value of `-1`), then we set `localScale` to `Vector3`
    with an X-axis value of `-``1`. Easy-peasy.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移动的输入水平值不为零，我们首先为面向右侧设置一个默认缩放（`X`值为`1`）。如果移动输入是面向左侧（`X`值为`-1`），则将`localScale`设置为具有X轴值为`-1`的`Vector3`。简单易行。
- en: Bonus activity
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 附加活动
- en: Based on the techniques learned in this chapter for processing player input,
    moving the player via its **Rigidbody2D** component and animating the player using
    the **Animator** all within the **PlayerController** script, add the ability for
    the player character to jump. Might as well jump, go ahead and jump!
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 基于本章学到的处理玩家输入的技术，通过**Rigidbody2D**组件移动玩家，并使用**Animator**在**PlayerController**脚本中为玩家动画添加功能，使玩家角色能够跳跃。不妨跳起来，大胆地跳吧！
- en: 'I didn’t necessarily leave you hanging here. If you’re looking for a lifeline
    to solve this problem, you can view instructions for completing this jumping bonus
    activity by visiting the following GitHub link: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是真的让你在这里卡住。如果你在寻找解决问题的救命稻草，你可以通过访问以下GitHub链接查看完成这个跳跃奖励活动的说明：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Scripts/Jumping)
- en: In this section, you learned how to create animations and apply them to the
    player, as well as how to transition and change the animation state with code,
    all while using Mecanim. We finished off by learning how to flip the facing direction
    of the player character.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何创建动画并将其应用到玩家身上，以及如何使用代码进行动画转换和状态改变，所有这些都是在使用Mecanim的过程中完成的。我们最后学习了如何翻转玩家角色的面向方向。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter walked us through the complete setup of an animated 2D player character,
    including importing art and setting up an animatable rig via PSD Importer, setting
    up IK Solvers, and creating and applying animations to the player using Mecanim.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带我们了解了如何完整设置一个动画2D玩家角色，包括通过PSD导入器导入艺术资源，设置可动画的绑定，配置IK求解器，以及使用Mecanim为玩家创建和应用动画。
- en: We continued by adding movement ability from player input by using an Input
    Action Map asset with the new Input System, coding a simple player controller
    script, processing input, and changing animations based on the current player
    action, also using Mecanim.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续通过使用新的输入系统中的Input Action Map资产添加玩家输入的移动能力，编写一个简单的玩家控制器脚本，处理输入，并根据当前玩家动作更改动画，同样使用Mecanim。
- en: In the next chapter, we’ll add a weapon for the player so that they can shoot
    projectiles efficiently.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为玩家添加武器，以便他们能够高效地射击投射物。
