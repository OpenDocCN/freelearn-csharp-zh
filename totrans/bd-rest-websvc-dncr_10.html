<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building a Web Client (Consuming Web Services)</h1>
                </header>
            
            <article>
                
<p>So far in this book, we have created RESTful services so that we can call or consume these services either within or from outside the project. In this chapter, we will discuss some use cases of these services, as well as the techniques and approaches for consuming RESTful web services.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Consuming RESTful web services</li>
<li>Building a REST web client</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming RESTful web services</h1>
                </header>
            
            <article>
                
<p>Until now, we have created RESTful services and discussed server-side code with the help of code examples. We have consumed these services using external third-party tools, such as Postman and Advanced RESTClient. We have also consumed these services using fake objects and during unit testing. While helpful, these examples of consumption have not shown the true strength of RESTful services, as they have either tested their functionality or verified its output.</p>
<p>There may be situations where you will need to consume or use these services within another application similar to a controller, or even your own application itself. These applications can be any of the following:</p>
<ul>
<li>Console based</li>
<li>Web based</li>
<li>Mobile or any other device based</li>
</ul>
<p>Let's take a look at one of the applications we've already discussed: let's say you need some mechanism to implement or consume an external API (in this case, PayPal) while integrating an online payment system. In this case, the external tools we've already covered, such as Postman and Advanced RESTClient can’t help; to meet your needs, you require a REST client.</p>
<p>The following diagram illustrates how services can be consumed using a REST client with the help of an HTTP client. In the following diagram, the REST client is interacting (request, response) with both external and network services that have been developed in ASP.NET Core or are located on either the same or a different server.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/a80a5a5f-efbd-4d42-a85e-16b910703271.png" style="width:22.17em;height:30.50em;"/></div>
<p><strong>Web</strong>, <strong>Console</strong>, <strong>Mobile</strong>, and so on, are the clients consuming these services with the help of the REST client.</p>
<p>We will now discuss how to build a REST client that we can use to consume other RESTful web services (that is, APIs) in our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a REST web client</h1>
                </header>
            
            <article>
                
<p>RESTful services may or may not be a part of a web application. A web application may call or consume external APIs or services from the same application. The program that enables the interaction or communication (request, response) between the services and the application consuming those services is called a <strong>client</strong>.</p>
<div class="packt_infobox">
<p>A client helps applications to communicate (Request, Response) with APIs.</p>
</div>
<p>In this section, we will create a web client. A web client is an application or program written in ASP.NET Core.</p>
<p>Before we build a test web client, we need to discuss what we have to call.</p>
<p>Continuing our example of the FlixOne BookStore, the following table lists the produces and services that we will call and consume:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>API resource</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET /api/product</kbd></p>
</td>
<td>
<p>Gets a list of products.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET /api/product{id}</kbd></p>
</td>
<td>
<p>Gets a product.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT /api/product{id}</kbd></p>
</td>
<td>
<p>Updates an existing product.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE /api/product{id}</kbd></p>
</td>
<td>
<p>Deletes an existing product.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST /api/product</kbd></p>
</td>
<td>
<p>Adds a new product.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Our FlixOne product service is designed for the following tasks:</p>
<ul>
<li>Adding a new product</li>
<li>Updating an existing product</li>
<li>Deleting an existing product</li>
<li>Retrieving a product</li>
</ul>
<p>We have already ensured Swagger support for our product APIs (please refer to the previous chapters for more information), so let's get going. To start with this project, follow these steps:</p>
<ol>
<li>First, run <span class="packt_screen">Visual Studio 2017</span></li>
<li>Select <span class="packt_screen"><span>File |</span> <span class="packt_screen">Open</span></span></li>
<li>Select the project <span class="packt_screen">FlixOne.BookStore.ProductService</span></li>
<li>Run the project by pressing <em>F5</em> or clicking directly from the menu</li>
<li>Enter the following URL: <kbd>http://localhost:10065/swagger/</kbd></li>
</ol>
<p>You should now see Swagger documentation for your <span class="packt_screen">Product APIs</span>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4202f70f-415a-491c-affe-7cf9831b0210.png" style="width:36.42em;height:30.25em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Product APIs documentation</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cooking the web client</h1>
                </header>
            
            <article>
                
<p>We have already discussed what APIs need to consume and which resource returns what, so now it's time to cook our web client so we can consume and call our product APIs. To do so, follow these steps:</p>
<ol>
<li>To create an entirely new solution for our new project, go to <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Project</span> (or press <em>Ctrl</em> + <em>Shift</em> + <em>N</em>) as shown in the following screenshot.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7f232c75-ae75-41b4-84b9-5ff7b5735f92.png" style="width:45.92em;height:30.83em;"/></div>
<ol start="2">
<li>From <span class="packt_screen">New Project,</span> select <span class="packt_screen">ASP.NET Core Web Application</span>.</li>
<li>Name the project <kbd>FlixOne.BookStore.WebClient</kbd> and then click <span class="packt_screen">OK</span> as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4dd65c06-4f52-43fd-9c75-68a654d22aae.png" style="width:51.67em;height:31.50em;"/></div>
<ol start="4">
<li>From the <span class="packt_screen">ASP.NET Core</span> template window, select <span class="packt_screen">Web Application</span> and click <span class="packt_screen">OK</span> as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b8014e2a-003d-4805-8349-e71cb4fc5e87.png" style="width:44.75em;height:29.00em;"/></div>
<ol start="5">
<li>Now run the project <span class="packt_screen">Debug</span> | <span class="packt_screen">Start Debugging</span> or hit the <em>F5</em> key.</li>
<li>You should now see a default website template.</li>
<li>We will now create a web client using <strong>RestSharp</strong>. We need to add the support of RestSharp to get the facility to make a call over the HTTP protocol for our API resources.</li>
</ol>
<div class="packt_tip">
<p>RestSharp is a lightweight HTTP client library. You can make changes to suit your needs, as it is an open source library. You can find the complete repository at <a href="https://github.com/restsharp/RestSharp">https://github.com/restsharp/RestSharp</a></p>
</div>
<ol start="8">
<li>Add a NuGet package using <span class="packt_screen">Open Package Manager</span> (right-click on <span class="packt_screen">Solution</span> from <span class="packt_screen">Solution Explorer</span>), as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c88554eb-4b19-480f-8597-e0b8d2645b0c.png" style="width:37.83em;height:36.67em;"/></div>
<ol start="9">
<li>Search for <span class="packt_screen">RestSharp</span> and check the checkbox saying <span class="packt_screen">include</span> <span class="packt_screen">prerelease</span>, and then click <span class="packt_screen">Install</span> as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/64ac9dd2-1ba4-409d-a422-2104d598a3f1.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Selecting the RestSharp NuGet package</div>
<ol start="10">
<li>The required packages will now be installed, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/65a1722d-161f-4ab7-a8d5-0e24d31e113d.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Installing the RestSharp package</div>
<p>Before going forward, let's first make sure that our product APIs are working correctly. Run the product API project, open Swagger, and hit a <kbd>GET /api/product/productlist</kbd> resource as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d2bd41c1-e23c-40be-805d-0fefb43d419d.png" style="width:37.17em;height:3.08em;"/></div>
<p>After executing the previous resource, you should see a complete list of products, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dbc16f11-5f14-4aa5-bbf3-a41d6d6c9cc6.png" style="width:51.08em;height:33.42em;"/></div>
<div class="packt_infobox"><span>Try all available resources to make sure that your product APIs are working correctly.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing code</h1>
                </header>
            
            <article>
                
<p>So far, we have cooked the things required for writing code for our REST web client; in this section, we will be writing actual code:</p>
<ol>
<li>Add a simple code to call or consume your product APIs.</li>
</ol>
<div class="packt_tip">
<p>If you created a new project in the same solution (refer to <em>step 1</em> of the section <em>Cooking the web client</em>), please make sure that the project Product API is running before you start your web client project.</p>
</div>
<ol start="2">
<li>Add a new class (<em>Ctrl</em> + <em>Shift</em> + <em>C</em>) in the <kbd>Client</kbd> folder and name it <kbd>RestSharpWebClient</kbd>.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2981769f-110c-479f-a737-834a493a847b.png" style="width:20.08em;height:18.50em;"/></div>
<ol start="3">
<li>Now open the <kbd>RestSharpWebClient</kbd> class and add the following code:</li>
</ol>
<pre style="padding-left: 60px">private readonly RestClient _client = new RestClient("http://localhost:10065/api/");</pre>
<p style="padding-left: 60px">The preceding code initializes RestClient of RestSharp and accepts the base URL as a string or a URI.</p>
<div class="packt_tip">
<p>URI stands for Uniform Resource Identifier and is a representation of a string used to identify resources.</p>
</div>
<p>You may come across a scenario where there are multiple environments; in this case, you should store a URI where you point it as per your environment. For example, you can have the URI <kbd>http://devserver:10065/api/</kbd> for your development environment or the <span>URI <kbd>http://testenv:10068/api/</kbd> for your QA environment. You should store these keys in the <kbd>config</kbd> file or somewhere similar so that the values are easily accessible. We recommend using </span><kbd>new RestClient(somevariableforURI);</kbd>.</p>
<div class="packt_infobox">In our application, product APIs are running on localhost and the listening port <kbd>10065</kbd>. This may be different in your case.</div>
<p>Let's discuss the following code snippet to call or consume the <kbd>GET /api/product<br/>
/productlist</kbd> resource and populate the complete product list, as follows:</p>
<pre>public List&lt;ProductViewModel&gt; GetProducts()<br/>{<br/>  var request = new RestRequest("product/productlist", Method.GET);<br/>  var response = _client.Execute&lt;List&lt;ProductViewModel&gt;&gt;(request);<br/>  return response.Data ?? new List&lt;ProductViewModel&gt; {new<br/>  ProductViewModel()};<br/>}</pre>
<p>Here, we are making a <kbd>GET</kbd> request using <kbd>RestRequest</kbd>, where we passed a resource and method.</p>
<p>To get a particular product using <kbd>productid</kbd>, enter the following code:</p>
<pre>public ProductViewModel GetProductDetails(string productId)<br/>{<br/>  var request = new RestRequest("product/{productid}", Method.GET);<br/>  request.AddParameter("productid", productId);<br/>  var response = _client.Execute&lt;ProductViewModel&gt;(request);<br/>  return response.Data ?? new ProductViewModel();<br/>}</pre>
<p>In the preceding code block, the <kbd>GetProductDetails</kbd> method does a similar thing to the method <kbd>GetProducts</kbd>. The difference is that it accepts the parameter <kbd>productId</kbd>.</p>
<p>The following is the complete code of our REST client:</p>
<pre>public class RestSharpWebClient<br/>{<br/>  private readonly RestClient _client = new<br/>  RestClient("http://localhost:10065/api/");<br/>  public List&lt;ProductViewModel&gt; GetProducts()<br/>  {<br/>    var request = new RestRequest("product/productlist", <br/>    Method.GET);<br/>    var response = _client.Execute&lt;List&lt;ProductViewModel&gt;&gt;<br/>    (request);<br/>    //To avoid any exception lets return an empty view model<br/>    //On production environment return exact exception or your <br/>    custom code<br/>    return response.Data ?? new List&lt;ProductViewModel&gt; {new<br/>    ProductViewModel()};<br/>  }<br/>  public ProductViewModel GetProductDetails(string productId)<br/>  {<br/>    var request = new RestRequest("product/{productid}", <br/>    Method.GET);<br/>    request.AddParameter("productid", productId);<br/>    var response = _client.Execute&lt;ProductViewModel&gt;(request);<br/>    //To avoid any exception lets return an empty view model<br/>    //On production environment return exact exception or your <br/>    custom code<br/>    return response.Data ?? new ProductViewModel();<br/>  }<br/>  public bool AddProduct(ProductViewModel product)<br/>  {<br/>    var request = new RestRequest("product/addproduct", <br/>    Method.POST);<br/>    request.AddBody(product);<br/>    var response = _client.Execute(request);<br/>    return response.StatusCode == HttpStatusCode.OK;<br/>  }<br/>  public bool UpdateProduct(string id, ProductViewModel product)<br/>  {<br/>    var request = new RestRequest("updateproduct", Method.PUT);<br/>    request.AddQueryParameter("productid", id);<br/>    request.AddBody(product);<br/>    var response = _client.Execute(request);<br/>    return response.StatusCode == HttpStatusCode.NoContent;<br/>  }<br/>  public bool DeleteProduct(string id, ProductViewModel product)<br/>  {<br/>    var request = new RestRequest("deleteproduct", Method.DELETE);<br/>    request.AddQueryParameter("productid", id);<br/>    request.AddBody(product);<br/>    var response = _client.Execute(request);<br/>    return response.StatusCode == HttpStatusCode.NoContent;<br/>  }<br/>}</pre>
<p>With the preceding code snippet, you have now added the functionality that will call and consume your product APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a REST web client</h1>
                </header>
            
            <article>
                
<p>RESTful services may or may not be a part of your web application, but we still need to understand how to implement them.</p>
<p>So, now it's time to do some real work. Add <kbd>ProductController</kbd> to the project, as well as the following action:</p>
<pre>public ActionResult Index()<br/>{<br/>  var webClient = new RestSharpWebClient();<br/>  var products = webClient.GetProducts();<br/>  return View("ProductList", products);<br/>}<br/><br/></pre>
<p>Take a look at the preceding code snippet. We have called the <kbd>GetProducts</kbd> method of <kbd>RestSharpWebClient</kbd> and populated our <kbd>Index.cshtml</kbd> view with a complete list of products.</p>
<p>To add another action method, enter the following complete code of our <kbd>ProductController</kbd>. The following code snippet contains the <kbd>Index</kbd> action method and gives us a list of products:</p>
<pre>public class ProductController : Controller<br/>{<br/>  public ActionResult Index()<br/>  {<br/>    var webClient = new RestSharpWebClient();<br/>    var products = webClient.GetProducts();<br/>    return View("ProductList", products);<br/>  }<br/>  public ActionResult Details(string id)<br/>  {<br/>    var webClient = new RestSharpWebClient();<br/>    var products = webClient.GetProductDetails(id);<br/>    return View(products);<br/>  }</pre>
<p>Let's now look at two<span> <kbd>Create</kbd></span> <span>action methods: </span><kbd>HttpGet</kbd> <span>and</span> <kbd>HttpPost</kbd>. <span>The first one provides us with an entry screen for input and the second posts all the data (the input values) using</span> the <kbd>HttpPost</kbd> <span>method. On the server side, you can receive all data in an </span><kbd>IFormCollection</kbd> parameter, <span>and you can also easily write logic to get all of your values in </span><kbd>ProductViewModel</kbd><span>.</span></p>
<pre>  public IActionResult Create()<br/>  {<br/>    return View();<br/>  }<br/>  [HttpPost]<br/>  [ValidateAntiForgeryToken]<br/>  public IActionResult Create(IFormCollection collection)<br/>  {<br/>    try<br/>    {<br/>      var product = new ProductViewModel<br/>      {<br/>        ProductId = Guid.NewGuid(),<br/>        ProductName = collection["ProductName"],<br/>        ProductDescription = collection["ProductDescription"],<br/>        ProductImage = collection["ProductImage"],<br/>        ProductPrice = Convert.ToDecimal(collection["ProductPrice"]),<br/>        CategoryId = new Guid("77DD5B53-8439-49D5-9CBC-DC5314D6F190"),<br/>        CategoryName = collection["CategoryName"],<br/>        CategoryDescription = collection["CategoryDescription"]<br/>      };<br/>      var webClient = new RestSharpWebClient();<br/>      var producresponse = webClient.AddProduct(product);<br/>      if (producresponse)<br/>      return RedirectToAction(nameof(Index));<br/>      throw new Exception();<br/>    }<br/>    catch<br/>    {<br/>      return View();<br/>    }<br/>  }</pre>
<div class="packt_infobox">You can also write a <kbd>HttpPost</kbd> method that accepts a parameter of the type <kbd>ProductViewModel</kbd>.</div>
<p class="mce-root">The following code snippet shows us the code for the <kbd>Edit</kbd> action method, which is similar to the <kbd>Create</kbd> action method but except that it updates existing data rather than inserting new data:</p>
<pre><br/>  public ActionResult Edit(string id)<br/>  {<br/>    var webClient = new RestSharpWebClient();<br/>    var product = webClient.GetProductDetails(id);<br/>    return View(product);<br/>  }<br/>  [HttpPost]<br/>  [ValidateAntiForgeryToken]<br/>  public ActionResult Edit(string id, IFormCollection collection)<br/>  {<br/>    try<br/>    {<br/>      var product = new ProductViewModel<br/>      {<br/>        ProductId = new Guid(collection["ProductId"]),<br/>        ProductName = collection["ProductName"],<br/>        ProductDescription = collection["ProductDescription"],<br/>        ProductImage = collection["ProductImage"],<br/>        ProductPrice = Convert.ToDecimal(collection["ProductPrice"]),<br/>        CategoryId = new Guid(collection["CategoryId"]),<br/>        CategoryName = collection["CategoryName"],<br/>        CategoryDescription = collection["CategoryDescription"]<br/>      };<br/>      var webClient = new RestSharpWebClient();<br/>      var producresponse = webClient.UpdateProduct(id, product);<br/>      if (producresponse)<br/>      return RedirectToAction(nameof(Index));<br/>      throw new Exception();<br/>    }<br/>    catch<br/>    {<br/>      return View();<br/>    }<br/>  }</pre>
<p class="mce-root">The <kbd>Delete</kbd> action method is meant to remove a specific record or data from a database or collection. The action method <kbd>Delete</kbd> of <kbd>HttpGet</kbd> fetches a record based on a given ID and displays the data ready for modification. Another <kbd>Delete</kbd> action of <kbd>HttpPost</kbd> sends modified data to the server for further processing. This means the system can delete data and records.</p>
<pre><br/>  public ActionResult Delete(string id)<br/>  {<br/>    var webClient = new RestSharpWebClient();<br/>    var product = webClient.GetProductDetails(id);<br/>    return View(product);<br/>  }<br/>  [HttpPost]<br/>  [ValidateAntiForgeryToken]<br/>  public ActionResult Delete(string id, IFormCollection collection)<br/>  {<br/>    try<br/>    {<br/>      var product = new ProductViewModel<br/>      {<br/>        ProductId = new Guid(collection["ProductId"]),<br/>        ProductName = collection["ProductName"],<br/>        ProductDescription = collection["ProductDescription"],<br/>        ProductImage = collection["ProductImage"],<br/>        ProductPrice = Convert.ToDecimal(collection["ProductPrice"]),<br/>        CategoryId = new Guid(collection["CategoryId"]),<br/>        CategoryName = collection["CategoryName"],<br/>        CategoryDescription = collection["CategoryDescription"]<br/>      };<br/>      var webClient = new RestSharpWebClient();<br/>      var producresponse = webClient.DeleteProduct(id, product);<br/>      if (producresponse)<br/>      return RedirectToAction(nameof(Index));<br/>      throw new Exception();<br/>    }<br/>    catch<br/>    {<br/>      return View();<br/>    }<br/>  }<br/>}</pre>
<p>Now let's open <kbd>_Layout.cshtml</kbd> from the <kbd>Shared</kbd> folder and add the following line to add a link to our newly added <kbd>ProductController</kbd>:</p>
<pre>&lt;li&gt;&lt;<strong>a</strong> <strong>asp-area</strong>="" <strong>asp-controller</strong>="Product" <strong>asp-action</strong>="Index"&gt;Web Client&lt;/<strong>a</strong>&gt;&lt;/li&gt;</pre>
<p>You should see a new menu named <span class="packt_screen">Web Client</span> when you run the project, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0860e52c-5016-46d2-a6df-d0812d31377e.png" style="width:52.33em;height:25.83em;"/></div>
<p>We are now ready to see some results. Click on the <span class="packt_screen">Web Client</span> menu, and you will see the following screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1626a7e2-dcdc-4ad2-983c-4410f4e9784a.png" style="width:53.42em;height:20.83em;"/></div>
<p>From the preceding screen, you can perform other operations, as well as call and consume your product APIs—namely, <span class="packt_screen">Create</span>, <span class="packt_screen">Edit</span>, and <span class="packt_screen">Delete</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The creation of RESTful services is important for any project, but these services are of no use if there is no way of using them. In this chapter, we looked at how to add RestSharp support to our web project and consume our pre-developed product APIs. We also created a web client that could consume web services by rendering output on our web pages using ASP.NET Core.</p>
<p>In the next chapter, we will discuss the hot topic of microservices, the next level of the separation of services. We will discuss how microservices communicate, what their advantages are, and why we require them.</p>


            </article>

            
        </section>
    </body></html>