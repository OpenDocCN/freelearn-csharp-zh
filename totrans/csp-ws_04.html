<html><head></head><body>
<div id="sbo-rt-content"><div>
<div class="Content" id="_idContainer113">
</div>
</div>
<div class="Content" id="_idContainer114">
<h1 id="_idParaDest-151"><a id="_idTextAnchor166"/>4. Data Structures and LINQ</h1>
</div>
<div class="Content" id="_idContainer121">
<p class="callout-heading">Overview</p>
<p class="callout">In this chapter, you will learn about the main collections and their primary usage in C#. You will then see how Language-Integrated Query (LINQ) can be used to query collections in memory using code that is efficient and succinct. By the end of this chapter, you will be well versed in using LINQ for operations such as sorting, filtering, and aggregating data.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor167"/>Introduction</h1>
<p>Throughout the previous chapters, you have used variables that refer to a single value, such as the <strong class="source-inline">string</strong> and <strong class="source-inline">double</strong> system types, system <strong class="source-inline">class</strong> instances, and your own class instances. .NET has a variety of data structures that can be used to store multiple values. These structures are generally referred to as collections. This chapter builds on this concept by introducing collection types from the <strong class="source-inline">System.Collections.Generic</strong> namespace.</p>
<p>You can create variables that can store multiple object references using collection types. Such collections include lists that resize to accommodate the number of elements and dictionaries that offer access to the elements using a unique key as an identifier. For example, you may need to store a list of international dialing codes using the codes as unique identifiers. In this case, you need to be certain that the same dialing code is not added to the collection twice.</p>
<p>These collections are instantiated like any other classes and are used extensively in most applications. Choosing the correct type of collection depends primarily on how you intend to add items and the way you would like to access such items once they are in a collection. The commonly used collection types include <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">HashSet</strong>, which you will cover in detail shortly.</p>
<p>LINQ is a technology that offers an expressive and concise syntax for querying objects. Much of the complexities around filtering, sorting, and grouping objects can be removed using the SQL-like language, or if you prefer, a set of extension methods that can be chained together to produce collections that can be enumerated with ease.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor168"/>Data Structures</h1>
<p>.NET provides various types of in-built data structures, such as the <strong class="source-inline">Array</strong>, <strong class="source-inline">List</strong>, and <strong class="source-inline">Dictionary</strong> types. At the heart of all data structures are the <strong class="source-inline">IEnumerable</strong> and <strong class="source-inline">ICollection</strong> interfaces. Classes that implement these interfaces offer a way to enumerate through the individual elements and to manipulate their items. There is rarely a need to create your own classes that derive directly from these interfaces, as all the required functionality is covered by the built-in collection types, but it is worth knowing the key properties as they are heavily used throughout .NET.</p>
<p>The generic version of each collection type requires a single type parameter, which defines the type of elements that can be added to a collection, using the standard <strong class="source-inline">&lt;T&gt;</strong> syntax of the generic types.</p>
<p>The <strong class="source-inline">IEnumerable</strong> interface has a single property, that is, <strong class="source-inline">IEnumerator&lt;T&gt; GetEnumerator()</strong>. This property returns a type that provides methods that allow the caller to iterate through the elements in the collection. You do not need to call the <strong class="source-inline">GetEnumerator()</strong> method directly, as the compiler will call it whenever you use a <strong class="source-inline">foreach</strong> statement, such as <strong class="source-inline">foreach(var book in books)</strong>. You will learn more about using this in the upcoming sections.</p>
<p>The <strong class="source-inline">ICollection</strong> interface has the following properties:</p>
<ul>
<li><strong class="source-inline">int Count { get; }</strong>: Returns the number of items in the collection.</li>
<li><strong class="source-inline">bool IsReadOnly { get; }</strong>: Indicates if the collection is read-only. Certain collections can be marked as read-only to prevent callers from adding, deleting, or moving elements in the collection. C# will not prevent you from amending the properties of individual items in a read-only collection.</li>
<li><strong class="source-inline">void Add(T item)</strong>: Adds an item of type <strong class="source-inline">&lt;T&gt;</strong> to the collection.</li>
<li><strong class="source-inline">void Clear()</strong>: Removes all items from the collection.</li>
<li><strong class="source-inline">bool Contains(T item)</strong>: Returns <strong class="source-inline">true</strong> if the collection contains a certain value. Depending on the type of item in the collection, this can be value-equality, where an object is similarly based on its members, or reference-equality, where the object points to the same memory location.</li>
<li><strong class="source-inline">void CopyTo(T[] array, int arrayIndex)</strong>: Copies each element from the collection into the target array, starting with the first element at a specified index position. This can be useful if you need to skip a specific number of elements from the beginning of the collection.</li>
<li><strong class="source-inline">bool Remove(T item)</strong>: Removes the specified item from the collection. If there are multiple occurrences of the instance, then only the first instance is removed. This returns <strong class="source-inline">true</strong> if an item was successfully removed.</li>
</ul>
<p><strong class="source-inline">IEnumerable</strong> and <strong class="source-inline">ICollection</strong> are interfaces that all collections implement:</p>
<p> </p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<img alt="Figure 4.1: ICollection and IEnumerable class diagram " height="802" src="image/B16835_04_01.jpg" width="750"/>
</div>
</div>
<p class="figure-caption">Figure 4.1: ICollection and IEnumerable class diagram</p>
<p>There are further interfaces that some collections implement, depending on how elements are accessed within a collection.</p>
<p>The <strong class="source-inline">IList</strong> interface is used for collections that can be accessed by index position, starting from zero. So, for a list that contains two items, <strong class="source-inline">Red</strong> and <strong class="source-inline">Blue</strong>, the element at index zero is <strong class="source-inline">Red</strong> and the element at index one is <strong class="source-inline">Blue</strong>.</p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<img alt="Figure 4.2: IList class diagram " height="598" src="image/B16835_04_02.jpg" width="725"/>
</div>
</div>
<p class="figure-caption">Figure 4.2: IList class diagram</p>
<p>The <strong class="source-inline">IList</strong> interface has the following properties:</p>
<ul>
<li><strong class="source-inline">T this[int index] { get; set; }</strong>: Gets or sets the element at the specified index position.</li>
<li><strong class="source-inline">int Add(T item)</strong>: Adds the specified item and returns the index position of that item in the list.</li>
<li><strong class="source-inline">void Clear()</strong>: Removes all items from the list.</li>
<li><strong class="source-inline">bool Contains(T item)</strong>: Returns <strong class="source-inline">true</strong> if the list contains the specified item.</li>
<li><strong class="source-inline">int IndexOf(T item)</strong>: Returns the index position of the item, or <strong class="source-inline">-1</strong> if not found.</li>
<li><strong class="source-inline">void Insert(int index, T item)</strong>: Inserts the item at the index position specified.</li>
<li><strong class="source-inline">void Remove(T item)</strong>: Removes the item if it exists within the list.</li>
<li><strong class="source-inline">void RemoveAt(int index)</strong>: Removes the item at the specified index position.</li>
</ul>
<p>You have now seen the primary interfaces common to collections. So, now you will now take a look at the main collection types that are available and how they are used.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor169"/>Lists</h2>
<p>The <strong class="source-inline">List&lt;T&gt;</strong> type is one of the most extensively used collections in C#. It is used where you have a collection of items and want to control the order of items using their index position. It implements the <strong class="source-inline">IList</strong> interface, which allows items to be inserted, accessed, or removed using an index position:</p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<img alt="Figure 4.3: List class diagram " height="761" src="image/B16835_04_03.jpg" width="806"/>
</div>
</div>
<p class="figure-caption">Figure 4.3: List class diagram</p>
<p>Lists have the following behavior:</p>
<ul>
<li>Items can be inserted at any position within the collection. Any trailing items will have their index position incremented.</li>
<li>Items can be removed, either by index or value. This will also cause trailing items to have their index position updated.</li>
<li>Items can be set using their index value.</li>
<li>Items can be added to the end of the collection.</li>
<li>Items can be duplicated within the collection.</li>
<li>The position of items can be sorted using the various <strong class="source-inline">Sort</strong> methods.</li>
</ul>
<p>One example of a list might be the tabs in a web browser application. Typically, a user may want to drag a browser tab amongst other tabs, open new tabs at the end, or close tabs anywhere in a list of tabs. The code to control these actions can be implemented using <strong class="source-inline">List</strong>.</p>
<p>Internally, <strong class="source-inline">List</strong> maintains an array to store its objects. This can be efficient when adding items to the end, but it may be inefficient when inserting items, particularly near the beginning of the list, as the index position of items will need to be recalculated.</p>
<p>The following example shows how the generic <strong class="source-inline">List</strong> class is used. The code uses the <strong class="source-inline">List&lt;string&gt;</strong> type parameter, which allows <strong class="source-inline">string</strong> types to be added to the list. Attempts to add any other type will result in a compiler error. This will show the various commonly used methods of the <strong class="source-inline">List</strong> class.</p>
<ol>
<li>Create a new folder called <strong class="source-inline">Chapter04</strong> in your source code folder.</li>
<li>Change to the <strong class="source-inline">Chapter04</strong> folder and create a new console app, called <strong class="source-inline">Chapter04</strong>, using the following .NET command:<p class="source-code">source\Chapter04&gt;dotnet new console -o Chapter04</p><p class="source-code">The template "Console Application" was created successfully.</p></li>
<li>Delete the <strong class="source-inline">Class1.cs</strong> file.</li>
<li>Add a new folder called <strong class="source-inline">Examples</strong>.</li>
<li>Add a new class file called <strong class="source-inline">ListExamples.cs</strong>.</li>
<li>Add the <strong class="source-inline">System.Collections.Generic</strong> namespace to access the <strong class="source-inline">List&lt;T&gt;</strong> class and declare a new variable called <strong class="source-inline">colors</strong>:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    class ListExamples</p><p class="source-code">    {     </p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var colors = new List&lt;string&gt; {"red", "green"};</p><p class="source-code">            colors.Add("orange");</p></li>
</ol>
<p>The code declares the new <strong class="source-inline">colors</strong> variable, which can store multiple color names as <strong class="source-inline">strings</strong>. Here, the collection initialization syntax is used so that <strong class="source-inline">red</strong> and <strong class="source-inline">green</strong> are added as part of the initialization of the variable. The <strong class="source-inline">Add</strong> method is called, adding <strong class="source-inline">orange</strong> to the list.</p>
<ol>
<li value="7">Similarly, <strong class="source-inline">AddRange</strong> adds <strong class="source-inline">yellow</strong> and <strong class="source-inline">pink</strong> to the end of the list:<p class="source-code">            colors.AddRange(new [] {"yellow", "pink"});</p></li>
<li>At this point, there are five colors in the list, with <strong class="source-inline">red</strong> at index position <strong class="source-inline">0</strong> and <strong class="source-inline">green</strong> at position <strong class="source-inline">1</strong>. You can verify this using the following code:<p class="source-code">            Console.WriteLine($"Colors has {colors.Count} items");</p><p class="source-code">            Console.WriteLine($"Item at index 1 is {colors[1]}");</p></li>
</ol>
<p>Running the code produces the following output:</p>
<p class="source-code">Colors has 5 items</p>
<p class="source-code">Item at index 1 is green</p>
<ol>
<li value="9">Using <strong class="source-inline">Insert</strong>, <strong class="source-inline">blue</strong> can be inserted at the beginning of the list, that is, at index <strong class="source-inline">0</strong>, as shown in the following code. Note that this moves <strong class="source-inline">red</strong> from index <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> and all other colors will have their index incremented by one:<p class="source-code">            Console.WriteLine("Inserting blue at 0");</p><p class="source-code">            colors.Insert(0, "blue");</p><p class="source-code">            Console.WriteLine($"Item at index 1 is now {colors[1]}");</p></li>
</ol>
<p>You should see the following output on running this code:</p>
<p class="source-code">Inserting blue at 0</p>
<p class="source-code">Item at index 1 is now red</p>
<ol>
<li value="10">Using <strong class="source-inline">foreach</strong> you can iterate through the strings in the list, writing each string to the console, as follows:<p class="source-code">            Console.WriteLine("foreach");</p><p class="source-code">            foreach (var color in colors)</p><p class="source-code">                Console.Write($"{color}|");</p><p class="source-code">            Console.WriteLine();</p></li>
</ol>
<p>You should get the following output:</p>
<p class="source-code">foreach</p>
<p class="source-code">blue|red|green|orange|yellow|pink|</p>
<ol>
<li value="11">Now, add the following code to reverse the array. Here, each <strong class="source-inline">color</strong> string is converted into an array of <strong class="source-inline">char</strong> type using <strong class="source-inline">ToCharArray</strong>:<p class="source-code">            Console.WriteLine("ForEach Action:");</p><p class="source-code">            colors.ForEach(color =&gt;</p><p class="source-code">            {</p><p class="source-code">                var characters = color.ToCharArray();</p><p class="source-code">                Array.Reverse(characters);</p><p class="source-code">                var reversed = new string(characters);</p><p class="source-code">                Console.Write($"{reversed}|");</p><p class="source-code">            });</p><p class="source-code">            Console.WriteLine();</p></li>
</ol>
<p>This does not affect any of the values in the <strong class="source-inline">colors</strong> List, as <strong class="source-inline">characters</strong> refers to a different object. Note that <strong class="source-inline">foreach</strong> iterates through each string, whereas <strong class="source-inline">ForEach</strong> defines an Action delegate to be invoked using each string (recall that in <em class="italic">Chapter 3</em>, <em class="italic">Delegates, Events, and Lambdas</em>, you saw how lambda statements can be used to create <strong class="source-inline">Action</strong> delegates).</p>
<ol>
<li value="12">Running the code leads to this output:<p class="source-code">ForEach Action:</p><p class="source-code">eulb|der|neerg|egnaro|wolley|knip|</p></li>
<li>In the next snippet, the <strong class="source-inline">List</strong> constructor accepts a source collection. This creates a new list containing a copy of the <strong class="source-inline">colors</strong> strings in this case, which is sorted using the default <strong class="source-inline">Sort</strong> implementation:<p class="source-code">            var backupColors = new List&lt;string&gt;(colors);</p><p class="source-code">            backupColors.Sort();</p></li>
</ol>
<p>The string type uses value-type semantics, which means that the <strong class="source-inline">backupColors</strong> list is populated with a <strong class="bold">copy</strong> of each source string value. Updating a string in one list will <strong class="bold">not</strong> affect the other list. Conversely, classes are defined as reference-types so passing a list of class instances to the constructor will still create a new list, with independent element indexes, but each element will point to the same shared reference in memory rather than an independent copy.</p>
<ol>
<li value="14">In the following snippet, prior to removing all colors (using <strong class="source-inline">colors.Clear</strong>), each value is written to the console (the list will be repopulated shortly):<p class="source-code">            Console.WriteLine("Foreach before clearing:");</p><p class="source-code">            foreach (var color in colors)</p><p class="source-code">                Console.Write($"{color}|");</p><p class="source-code">            Console.WriteLine();</p><p class="source-code">            colors.Clear();</p><p class="source-code">            Console.WriteLine($"Colors has {colors.Count} items");</p></li>
</ol>
<p>Running the code produces this output:</p>
<p class="source-code">Foreach before clearing:</p>
<p class="source-code">blue|red|green|orange|yellow|pink|</p>
<p class="source-code">Colors has 0 items</p>
<ol>
<li value="15">Then, <strong class="source-inline">AddRange</strong> is used again, to add the full list of colors back to the <strong class="source-inline">colors</strong> list, using the sorted <strong class="source-inline">backupColors</strong> items as a source:<p class="source-code">            colors.AddRange(backupColors);</p><p class="source-code">            Console.WriteLine("foreach after addrange (sorted items):");</p><p class="source-code">            foreach (var color in colors)</p><p class="source-code">                Console.Write($"{color}|");</p><p class="source-code">            Console.WriteLine();</p></li>
</ol>
<p>You should see the following output:</p>
<p class="source-code">foreach after addrange (sorted items):</p>
<p class="source-code">blue|green|orange|pink|red|yellow|</p>
<ol>
<li value="16">The <strong class="source-inline">ConvertAll</strong> method is passed a delegate that can be used to return a new list of any type:<p class="source-code">            var indexes = colors.ConvertAll(color =&gt;                      $"{color} is at index {colors.IndexOf(color)}");</p><p class="source-code">            Console.WriteLine("ConvertAll:");</p><p class="source-code">            Console.WriteLine(string.Join(Environment.NewLine, indexes));</p></li>
</ol>
<p>Here, a new <strong class="source-inline">List&lt;string&gt;</strong> is returned with each item being formatted using its value and the item's index in the list. As expected, running the code produces this output:</p>
<p class="source-code">ConvertAll:</p>
<p class="source-code">blue is at index 0</p>
<p class="source-code">green is at index 1</p>
<p class="source-code">orange is at index 2</p>
<p class="source-code">pink is at index 3</p>
<p class="source-code">red is at index 4</p>
<p class="source-code">yellow is at index 5</p>
<ol>
<li value="17">In the next snippet, two <strong class="source-inline">Contains()</strong> methods are used to show string value-equality in action:<p class="source-code">            Console.WriteLine($"Contains RED: {colors.Contains("RED")}");</p><p class="source-code">            Console.WriteLine($"Contains red: {colors.Contains("red")}");</p></li>
</ol>
<p>Note that the uppercase <strong class="source-inline">RED</strong> is <strong class="bold">not</strong> in the list, but the lowercase <strong class="source-inline">red</strong> will be. Running the code produces this output:</p>
<p class="source-code">Contains RED: False</p>
<p class="source-code">Contains red: True</p>
<ol>
<li value="18">Now, add the following snippet: <p class="source-code">            var existsInk = colors.Exists(color =&gt; color.EndsWith("ink"));</p><p class="source-code">            Console.WriteLine($"Exists *ink: {existsInk}");</p></li>
</ol>
<p>Here, the <strong class="source-inline">Exists</strong> method is passed a Predicate delegate, which returns <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> if the test condition is met. Predicate is an inbuilt delegate, which returns a boolean value. In this case, <strong class="source-inline">True</strong> will be returned if any item exists where the string value ends with the letters <strong class="source-inline">ink</strong> (<strong class="source-inline">pink</strong>, for example).</p>
<p>You should see the following output:</p>
<p class="source-code">Exists *ink: True</p>
<ol>
<li value="19">You know there is already a <strong class="source-inline">red</strong> color, but it will be interesting to see what happens if you insert <strong class="source-inline">red</strong> again, twice, at the very beginning of the list:<p class="source-code">            Console.WriteLine("Inserting reds");</p><p class="source-code">            colors.InsertRange(0, new [] {"red", "red"});</p><p class="source-code">            foreach (var color in colors)</p><p class="source-code">                Console.Write($"{color}|");</p><p class="source-code">            Console.WriteLine();</p></li>
</ol>
<p>You will get the following output:</p>
<p class="source-code">Inserting reds</p>
<p class="source-code">red|red|blue|green|orange|pink|red|yellow|</p>
<p>This shows that it is possible to insert the same item more than once into a list.</p>
<ol>
<li value="20">The next snippet shows you how to use the <strong class="source-inline">FindAll</strong> method. <strong class="source-inline">FindAll</strong> is similar to the <strong class="source-inline">Exists</strong> method, in that it is passed a <strong class="source-inline">Predicate</strong> condition. All items that match that rule will be returned. Add the following code:<p class="source-code">            var allReds = colors.FindAll(color =&gt; color == "red");</p><p class="source-code">            Console.WriteLine($"Found {allReds.Count} red");</p></li>
</ol>
<p>You should get an output as follows. As expected, there are three <strong class="source-inline">red</strong> items returned:</p>
<p class="source-code">Found 3 red</p>
<ol>
<li value="21">Finishing the example, the <strong class="source-inline">Remove</strong> method is used to remove the first <strong class="source-inline">red</strong> from the list. There are still two <strong class="bold">reds</strong> left. You can use <strong class="source-inline">FindLastIndex</strong> to get the index of the last <strong class="source-inline">red</strong> item:<p class="source-code">            colors.Remove("red");</p><p class="source-code">            var lastRedIndex = colors.FindLastIndex(color =&gt; color == "red");</p><p class="source-code">            Console.WriteLine($"Last red found at index {lastRedIndex}");</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Running the code produces this output:</p>
<p class="source-code">Last red found at index 5</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/dLbK6">https://packt.link/dLbK6</a>.</p>
<p>With the knowledge of how the generic <strong class="source-inline">List</strong> class is used, it is time for you to work on an exercise.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor170"/>Exercise 4.01: Maintaining Order within a List</h2>
<p>At the beginning of the chapter, web browser tabs were described as an ideal example of lists. In this exercise, you will put this idea into action, and create a class that controls the navigation of the tabs within an app that mimics a web browser.</p>
<p>For this, you will create a <strong class="source-inline">Tab</strong> class and a <strong class="source-inline">TabController</strong> app that allows new tabs to be opened and existing tabs to be closed or moved. The following steps will help you complete this exercise:</p>
<ol>
<li value="1">In VSCode, select your <strong class="source-inline">Chapter04</strong> project.</li>
<li>Add a new folder called <strong class="source-inline">Exercises</strong>.</li>
<li>Inside the <strong class="source-inline">Exercises</strong> folder, add a folder called <strong class="source-inline">Exercise01</strong> and add a file called <strong class="source-inline">Exercise01.cs</strong>.</li>
<li>Open <strong class="source-inline">Exercise01.cs</strong> and define a <strong class="source-inline">Tab</strong> class with a string URL constructor parameter as follows:<p class="source-code">using System;</p><p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">namespace Chapter04.Exercises.Exercise01</p><p class="source-code">{</p><p class="source-code">    public class Tab </p><p class="source-code">    {</p><p class="source-code">        public Tab()</p><p class="source-code">        {}</p><p class="source-code">        public Tab(string url) =&gt; (Url) = (url);</p><p class="source-code">        public string Url { get; set; }</p><p class="source-code">        public override string ToString() =&gt; Url;</p><p class="source-code">    }   </p></li>
</ol>
<p>Here, the <strong class="source-inline">ToString</strong> method has been overridden to return the current URL to help when logging details to the console.</p>
<ol>
<li value="5">Create the <strong class="source-inline">TabController</strong> class as follows:<p class="source-code">    public class TabController : IEnumerable&lt;Tab&gt;</p><p class="source-code">    {</p><p class="source-code">        private readonly List&lt;Tab&gt; _tabs = new();</p></li>
</ol>
<p>The <strong class="source-inline">TabController</strong> class contains a List of tabs. Notice how the class inherits from the <strong class="source-inline">IEnumerable</strong> interface. This interface is used so that the class provides a way to iterate through its items, using a <strong class="source-inline">foreach</strong> statement. You will provide methods to open, move, and close tabs, which will directly control the order of items in the <strong class="source-inline">_tabs</strong> list, in the next steps. Note that you could have exposed the <strong class="source-inline">_tabs</strong> list directly to callers, but it would be preferable to limit access to the tabs through your own methods. Hence, it is defined as a <strong class="source-inline">readonly</strong> list.</p>
<ol>
<li value="6">Next, define the <strong class="source-inline">OpenNew</strong> method, which adds a new tab to the end of the list:<p class="source-code">        public Tab OpenNew(string url)</p><p class="source-code">        {</p><p class="source-code">            var tab = new Tab(url);</p><p class="source-code">            _tabs.Add(tab);</p><p class="source-code">            Console.WriteLine($"OpenNew {tab}");</p><p class="source-code">            return tab;</p><p class="source-code">        }</p></li>
<li>Define another method, <strong class="source-inline">Close</strong>, which removes the tab from the list if it exists. Add the following code for this:<p class="source-code">        public void Close(Tab tab)</p><p class="source-code">        {</p><p class="source-code">            if (_tabs.Remove(tab))</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"Removed {tab}");</p><p class="source-code">            }</p><p class="source-code">        }</p></li>
<li>To move a tab to the start of the list, add the following code:<p class="source-code">        public void MoveToStart(Tab tab)</p><p class="source-code">        {</p><p class="source-code">            if (_tabs.Remove(tab))</p><p class="source-code">            {</p><p class="source-code">                _tabs.Insert(0, tab);</p><p class="source-code">                Console.WriteLine($"Moved {tab} to start");</p><p class="source-code">            }</p></li>
</ol>
<p>Here, <strong class="source-inline">MoveToStart</strong> will try to remove the tab and then insert it at index <strong class="source-inline">0</strong>.</p>
<ol>
<li value="9">Similarly, add the following code to move a tab to the end:<p class="source-code">        public void MoveToEnd(Tab tab)</p><p class="source-code">        {</p><p class="source-code">            if (_tabs.Remove(tab))</p><p class="source-code">            {</p><p class="source-code">                _tabs.Add(tab);</p><p class="source-code">                Console.WriteLine($"Moved {tab} to end. Index={_tabs.IndexOf(tab)}");</p><p class="source-code">            }</p><p class="source-code">        }</p></li>
</ol>
<p>Here, calling <strong class="source-inline">MoveToEnd</strong> removes the tab first, and then adds it to the end, logging the new index position to the console.</p>
<p>Finally, the <strong class="source-inline">IEnumerable</strong> interface requires that you implement two methods, <strong class="source-inline">IEnumerator&lt;Tab&gt; GetEnumerator()</strong> and <strong class="source-inline">IEnumerable.GetEnumerator()</strong>. These allow the caller to iterate through a collection using either a generic of type <strong class="source-inline">Tab</strong> or using the second method to iterate via an object-based type. The second method is a throwback to earlier versions of C# but is needed for compatibility. </p>
<ol>
<li value="10">For the actual results for both methods, you can use the <strong class="source-inline">GetEnumerator</strong> method of the <strong class="source-inline">_tab</strong> list, as that contains the tabs in list form. Add the following code to do so:<p class="source-code">        public IEnumerator&lt;Tab&gt; GetEnumerator() =&gt; _tabs.GetEnumerator();</p><p class="source-code">        IEnumerator IEnumerable.GetEnumerator() =&gt; _tabs.GetEnumerator();</p><p class="source-code">    }</p></li>
<li>You can now create a console app that tests the controller's behavior. Start by opening three new tabs and logging the tab details via <strong class="source-inline">LogTabs</strong> (this will be defined shortly):<p class="source-code">    static class Program</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var controller = new TabController();</p><p class="source-code">            Console.WriteLine("Opening tabs...");</p><p class="source-code">            var packt = controller.OpenNew("packtpub.com");</p><p class="source-code">            var msoft = controller.OpenNew("microsoft.com");</p><p class="source-code">            var amazon = controller.OpenNew("amazon.com");</p><p class="source-code">            controller.LogTabs();</p></li>
<li>Now, move <strong class="source-inline">amazon</strong> to the start and <strong class="source-inline">packt</strong> to the end, and log the tab details:<p class="source-code">            Console.WriteLine("Moving...");</p><p class="source-code">            controller.MoveToStart(amazon);</p><p class="source-code">            controller.MoveToEnd(packt);</p><p class="source-code">            controller.LogTabs();</p></li>
<li>Close the <strong class="source-inline">msoft</strong> tab and log details once more:<p class="source-code">            Console.WriteLine("Closing tab...");</p><p class="source-code">            controller.Close(msoft);</p><p class="source-code">            controller.LogTabs();</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p></li>
<li>Finally, add an extension method that helps log the URL of each tab in <strong class="source-inline">TabController</strong>. Define this as an extension method for <strong class="source-inline">IEnumerable&lt;Tab&gt;</strong>, rather than <strong class="source-inline">TabController</strong>, as you simply need an iterator to iterate through the tabs using a <strong class="source-inline">foreach</strong> loop. </li>
<li>Use <strong class="source-inline">PadRight</strong> to left-align each URL, as follows:<p class="source-code">        private static void LogTabs(this IEnumerable&lt;Tab&gt; tabs)</p><p class="source-code">        {</p><p class="source-code">            Console.Write("TABS: |");</p><p class="source-code">            foreach(var tab in tabs)</p><p class="source-code">                Console.Write($"{tab.Url.PadRight(15)}|");</p><p class="source-code">            Console.WriteLine();</p><p class="source-code">        }    </p><p class="source-code">   } </p><p class="source-code">}</p></li>
<li>Running the code produces the following output:<p class="source-code">Opening tabs...</p><p class="source-code">OpenNew packtpub.com</p><p class="source-code">OpenNew microsoft.com</p><p class="source-code">OpenNew amazon.com</p><p class="source-code">TABS: |packtpub.com   |microsoft.com  |amazon.com     |</p><p class="source-code">Moving...</p><p class="source-code">Moved amazon.com to start</p><p class="source-code">Moved packtpub.com to end. Index=2</p><p class="source-code">TABS: |amazon.com     |microsoft.com  |packtpub.com   |</p><p class="source-code">Closing tab...</p><p class="source-code">Removed microsoft.com</p><p class="source-code">TABS: |amazon.com     |packtpub.com   |</p><p class="callout-heading">Note</p><p class="callout">Sometimes Visual Studio might report a non-nullable property error the first time you execute the program. This is a helpful reminder that you are attempting to use a string value that may have a null value at runtime.</p></li>
</ol>
<p>The three tabs are opened. <strong class="source-inline">amazon.com</strong> and <strong class="source-inline">packtpub.com</strong> are then moved before <strong class="source-inline">microsoft.com</strong> is finally closed and removed from the tab list.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/iUcIs">https://packt.link/iUcIs</a>.</p>
<p>In this exercise, you have seen how lists can be used to store multiple items of the same type while maintaining the order of items. The next section covers the <strong class="source-inline">Queue</strong> and <strong class="source-inline">Stack</strong> classes, which allow items to be added and removed in a predefined sequence.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor171"/>Queues</h2>
<p>The Queue class provides a first-in, first-out mechanism. Items are added to the end of the queue using the <strong class="source-inline">Enqueue</strong> method and are removed from the front of the queue using the <strong class="source-inline">Dequeue</strong> method. Items in the queue cannot be accessed via an index element.</p>
<p>Queues are typically used when you need a workflow that ensures items are processed in the order in which they are added to the queue. A typical example might be a busy online ticketing system selling a limited number of concert tickets to customers. To ensure fairness, customers are added to a queuing system as soon as they log on. The system would then dequeue each customer and process each order, in full, either until all tickets have been sold or the customer queue is empty.</p>
<p>The following example creates a queue containing five <strong class="source-inline">CustomerOrder</strong> records. When it is time to process the orders, each order is dequeued using the <strong class="source-inline">TryDequeue</strong> method, which will return <strong class="source-inline">true</strong> until all orders have been processed. The customer orders are processed in the order that they were added. If the number of tickets requested is more than or equal to the tickets remaining, then the customer is shown a success message. An apology message is shown if the number of tickets remaining is less than the requested amount.</p>
<div>
<div class="IMG---Figure" id="_idContainer118">
<img alt="Figure 4.4: The Queue's Enqueue() and Dequeue() workflow " height="1051" src="image/B16835_04_04.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 4.4: The Queue's Enqueue() and Dequeue() workflow</p>
<p>Perform the following steps to complete this example:</p>
<ol>
<li value="1">In the <strong class="source-inline">Examples</strong> folder of your <strong class="source-inline">Chapter04</strong> source folder, add a new class called <strong class="source-inline">QueueExamples.cs</strong> and edit it as follows:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    class QueueExamples</p><p class="source-code">    {      </p><p class="source-code">        record CustomerOrder (string Name, int TicketsRequested)</p><p class="source-code">        {}</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var ticketsAvailable = 10;</p><p class="source-code">            var customers = new Queue&lt;CustomerOrder&gt;();</p></li>
<li>Add five orders to the queue using the <strong class="source-inline">Enqueue</strong> method as follows:<p class="source-code">            customers.Enqueue(new CustomerOrder("Dave", 2));</p><p class="source-code">            customers.Enqueue(new CustomerOrder("Siva", 4));</p><p class="source-code">            customers.Enqueue(new CustomerOrder("Julien", 3));</p><p class="source-code">            customers.Enqueue(new CustomerOrder("Kane", 2));</p><p class="source-code">            customers.Enqueue(new CustomerOrder("Ann", 1));</p></li>
<li>Now, use a <strong class="source-inline">while</strong> loop that repeats until <strong class="source-inline">TryDequeue</strong> returns <strong class="source-inline">false</strong>, meaning all current orders have been processed:<p class="source-code">            // Start processing orders...</p><p class="source-code">            while(customers.TryDequeue(out CustomerOrder nextOrder))</p><p class="source-code">            {</p><p class="source-code">                if (nextOrder.TicketsRequested &lt;= ticketsAvailable)</p><p class="source-code">                {</p><p class="source-code">                    ticketsAvailable -= nextOrder.TicketsRequested;   </p><p class="source-code">                    Console.WriteLine($"Congratulations {nextOrder.Name}, you've purchased {nextOrder.TicketsRequested} ticket(s)");</p><p class="source-code">                }</p><p class="source-code">                else</p><p class="source-code">                {</p><p class="source-code">                    Console.WriteLine($"Sorry {nextOrder.Name}, cannot fulfil {nextOrder.TicketsRequested} ticket(s)");</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">            Console.WriteLine($"Finished. Available={ticketsAvailable}");</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Running the example code produces the following output:<p class="source-code">Congratulations Dave, you've purchased 2 ticket(s)</p><p class="source-code">Congratulations Siva, you've purchased 4 ticket(s)</p><p class="source-code">Congratulations Julien, you've purchased 3 ticket(s)</p><p class="source-code">Sorry Kane, cannot fulfil 2 ticket(s)</p><p class="source-code">Congratulations Ann, you've purchased 1 ticket(s)</p><p class="source-code">Finished. Available=0</p><p class="callout-heading">Note</p><p class="callout">The first time you run this program, Visual Studio might show a non-nullable type error. This error is a reminder that you are using a variable that could be a null value.</p></li>
</ol>
<p>The output shows that <strong class="source-inline">Dave</strong> requested two tickets. As there are two or more tickets available, he was successful. Both <strong class="source-inline">Siva</strong> and <strong class="source-inline">Julien</strong> were also successful, but by the time <strong class="source-inline">Kane</strong> placed his order of two tickets, there was only one ticket available, so he was shown the apology message. Finally, <strong class="source-inline">Ann</strong> requested one ticket and was successful in her order.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/Zb524">https://packt.link/Zb524</a>.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor172"/>Stacks</h2>
<p>The <strong class="source-inline">Stack</strong> class provides the opposite mechanism to the <strong class="source-inline">Queue</strong> class; items are processed in last-in, first-out order. As with the <strong class="source-inline">Queue</strong> class, you cannot access elements via their index position. Items are added to the stack using the <strong class="source-inline">Push</strong> method and removed using the <strong class="source-inline">Pop</strong> method.</p>
<p>An application's <strong class="source-inline">Undo</strong> menu can be implemented using a stack. For example, in a word processor, as the user edits a document, an <strong class="source-inline">Action</strong> delegate is created, which can reverse the most recent change whenever the user presses <strong class="source-inline">Ctrl</strong> + <strong class="source-inline">Z</strong>. The most recent action is popped off the stack and the change is undone. This allows multiple steps to be undone.</p>
<div>
<div class="IMG---Figure" id="_idContainer119">
<img alt="Figure 4.5: The Stack's Push() and Pop() workflow " height="796" src="image/B16835_04_05.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 4.5: The Stack's Push() and Pop() workflow</p>
<p>The following example shows this in practice.</p>
<p>You will start by creating an <strong class="source-inline">UndoStack</strong> class that supports multiple undo operations. The caller decides what action should run each time the <strong class="source-inline">Undo</strong> request is called.</p>
<p>A typical undoable operation would be storing a copy of text prior to the user adding a word. Another undoable operation would be storing a copy of the current font prior to a new font being applied. You can start by adding the following code, where you are creating the <strong class="source-inline">UndoStack</strong> class and defining a <strong class="source-inline">readonly Stack of Action</strong> delegates, named <strong class="source-inline">_undoStack</strong>:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new class called <strong class="source-inline">StackExamples.cs</strong> and edit it as follows:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    class UndoStack</p><p class="source-code">    {</p><p class="source-code">        private readonly Stack&lt;Action&gt; _undoStack = new Stack&lt;Action&gt;();</p></li>
<li>When the user has done something, the same action can be undone. So push an <strong class="bold">undoable</strong> <strong class="source-inline">Action</strong> to the front of <strong class="source-inline">_undoStack</strong>:<p class="source-code">        public void Do(Action action)</p><p class="source-code">        {</p><p class="source-code">            _undoStack.Push(action);</p><p class="source-code">        }</p></li>
<li>The <strong class="source-inline">Undo</strong> method checks to see if there are any items to undo, then calls <strong class="source-inline">Pop</strong> to remove the most recent <strong class="source-inline">Action</strong> and invoke it, thus undoing the change that was just applied. The code for this can be added as follows:<p class="source-code">        public void Undo()</p><p class="source-code">        {</p><p class="source-code">            if (_undoStack.Count &gt; 0)</p><p class="source-code">            {</p><p class="source-code">                var undo = _undoStack.Pop();</p><p class="source-code">                undo?.Invoke();</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>Now, you can create a <strong class="source-inline">TextEditor</strong> class that allows edits to be added to <strong class="source-inline">UndoStack</strong>. This constructor is passed <strong class="source-inline">UndoStack</strong> as there could be multiple editors that need to add various <strong class="source-inline">Action</strong> delegates to the stack:<p class="source-code">    class TextEditor</p><p class="source-code">    {</p><p class="source-code">        private readonly UndoStack _undoStack;</p><p class="source-code">        public TextEditor(UndoStack undoStack)</p><p class="source-code">        {</p><p class="source-code">            _undoStack = undoStack;</p><p class="source-code">        }</p><p class="source-code">        public string Text {get; private set; }</p></li>
<li>Next, add the <strong class="source-inline">EditText</strong> command, which takes a copy of the <strong class="source-inline">previousText</strong> value and creates an <strong class="source-inline">Action</strong> delegate that can revert the text to its previous value, if invoked:<p class="source-code">        public void EditText(string newText)</p><p class="source-code">        {</p><p class="source-code">            var previousText = Text;</p><p class="source-code">            _undoStack.Do( () =&gt;</p><p class="source-code">            {</p><p class="source-code">                Text = previousText;</p><p class="source-code">                Console.Write($"Undo:'{newText}'".PadRight(40));</p><p class="source-code">                Console.WriteLine($"Text='{Text}'");</p><p class="source-code">            });</p></li>
<li>Now, the <strong class="source-inline">newText</strong> value should be appended to the <strong class="source-inline">Text</strong> property, using the <strong class="source-inline">+=</strong> operator. The details for this are logged to the console, using <strong class="source-inline">PadRight</strong> to improve the format:<p class="source-code">            Text += newText;</p><p class="source-code">            Console.Write($"Edit:'{newText}'".PadRight(40));</p><p class="source-code">            Console.WriteLine($"Text='{Text}'");</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>Finally, it is time to create a console app that tests <strong class="source-inline">TextEditor</strong> and <strong class="source-inline">UndoStack</strong>. Four edits are initially made, followed by two <strong class="bold">undo operations</strong>, and finally two more text edits:<p class="source-code">    class StackExamples</p><p class="source-code">    {</p><p class="source-code">        </p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var undoStack = new UndoStack();</p><p class="source-code">            var editor = new TextEditor(undoStack);</p><p class="source-code">            editor.EditText("One day, ");</p><p class="source-code">            editor.EditText("in a ");</p><p class="source-code">            editor.EditText("city ");</p><p class="source-code">            editor.EditText("near by ");</p><p class="source-code">            undoStack.Undo(); // remove 'near by'</p><p class="source-code">            undoStack.Undo(); // remove 'city'</p><p class="source-code">            editor.EditText("land ");</p><p class="source-code">            editor.EditText("far far away ");</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p><p class="source-code">    }    </p><p class="source-code">}</p></li>
<li>Running the console app produces the following output:<p class="source-code">Edit:'One day, '                        Text='One day, '</p><p class="source-code">Edit:'in a '                            Text='One day, in a '</p><p class="source-code">Edit:'city '                            Text='One day, in a city '</p><p class="source-code">Edit:'near by '                         Text='One day, in a city near by '</p><p class="source-code">Undo:'near by '                         Text='One day, in a city '</p><p class="source-code">Undo:'city '                            Text='One day, in a '</p><p class="source-code">Edit:'land '                            Text='One day, in a land '</p><p class="source-code">Edit:'far far away '                    Text='One day, in a land far far away '</p><p class="callout-heading">Note</p><p class="callout">Visual Studio may show non-nullable property error the first time the code is executed. This is because Visual Studio notices that the <strong class="source-inline">Text</strong> property can be a null value at runtime so offers a suggestion to improve the code.</p></li>
</ol>
<p>The left-hand output shows the text edits and undoes operations as they are applied and the resulting <strong class="source-inline">Text</strong> value on the right-hand side. The two <strong class="source-inline">Undo</strong> calls result in <strong class="source-inline">near by</strong> and <strong class="source-inline">city</strong> being removed from the <strong class="source-inline">Text</strong> value, before <strong class="source-inline">land </strong>and <strong class="source-inline">far far away</strong> are finally added to the <strong class="source-inline">Text</strong> value.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/tLVyf">https://packt.link/tLVyf</a>.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor173"/>HashSets</h2>
<p>The <strong class="source-inline">HashSet</strong> class provides mathematical set operations with collections of objects in an efficient and highly performant manner. <strong class="source-inline">HashSet</strong> does not allow duplicate elements and items are not stored in any particular order. Using the <strong class="source-inline">HashSet</strong> class is ideal for high-performance operations, such as needing to quickly find where two collections of objects overlap.</p>
<p>Typically, <strong class="source-inline">HashSet</strong> is used with the following operations:</p>
<ul>
<li><strong class="source-inline">public void UnionWith(IEnumerable&lt;T&gt; other)</strong>: Produ<a id="_idTextAnchor174"/>ces a set union. This modifies <strong class="source-inline">HashSet</strong> to include the items present in the current <strong class="source-inline">HashSet</strong> instance, the other collection, or both.</li>
<li><strong class="source-inline">public void IntersectWith(IEnumerable&lt;T&gt; other)</strong>: Produces a set intersect. This modifies <strong class="source-inline">HashSet</strong> to include items present in the current <strong class="source-inline">HashSet</strong> instance and the other collection.</li>
<li><strong class="source-inline">public void ExceptWith(IEnumerable&lt;T&gt; other)</strong>: Produces a set subtraction. This removes items from the <strong class="source-inline">HashSet</strong> that are present in the current <strong class="source-inline">HashSet</strong> instance and the other collection.</li>
</ul>
<p><strong class="source-inline">HashSet</strong> is useful when you need to include or exclude certain elements from <strong class="bold">collections</strong>. As an example, consider that an agent manages various celebrities and has been asked to find three sets of stars:</p>
<ul>
<li>Those that can act <strong class="bold">or</strong> sing.</li>
<li>Those that can act <strong class="bold">and</strong> sing.</li>
<li>Those that can act <strong class="bold">only</strong> (no singers allowed).</li>
</ul>
<p>In the following snippet, a list of actors' and singers' names is created:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new class called <strong class="source-inline">HashSetExamples.cs</strong> and edit it as follows:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    class HashSetExamples</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var actors = new List&lt;string&gt; {"Harrison Ford", "Will Smith", </p><p class="source-code">                                           "Sigourney Weaver"};</p><p class="source-code">            var singers = new List&lt;string&gt; {"Will Smith", "Adele"};</p></li>
<li>Now, create a new <strong class="source-inline">HashSet</strong> instance that initially contains singers only and then use <strong class="source-inline">UnionWith</strong> to modify the set to contain a distinct set of those that can act <strong class="bold">or</strong> sing:<p class="source-code">            var actingOrSinging = new HashSet&lt;string&gt;(singers);</p><p class="source-code">            actingOrSinging.UnionWith(actors);</p><p class="source-code">            Console.WriteLine($"Acting or Singing: {string.Join(", ", </p><p class="source-code">                              actingOrSinging)}");</p></li>
<li>For those that can act <strong class="bold">and</strong> sing, start with a <strong class="source-inline">HashSet</strong> instance of singers, and modify the <strong class="source-inline">HashSet</strong> instance using <strong class="source-inline">IntersectWith</strong> to contain a distinct list of those that are in both collections:<p class="source-code">            var actingAndSinging = new HashSet&lt;string&gt;(singers);</p><p class="source-code">            actingAndSinging.IntersectWith(actors);</p><p class="source-code">            Console.WriteLine($"Acting and Singing: {string.Join(", ", </p><p class="source-code">                              actingAndSinging)}");</p></li>
<li>Finally, for those that can <strong class="bold">act only</strong>, start with the actor collection, and use <strong class="source-inline">ExceptWith</strong> to remove those from the <strong class="source-inline">HashSet</strong> instance that can also sing:<p class="source-code">            var actingOnly = new HashSet&lt;string&gt;(actors);</p><p class="source-code">            actingOnly.ExceptWith(singers);</p><p class="source-code">            Console.WriteLine($"Acting Only: {string.Join(", ", actingOnly)}");</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Running the console app produces the following output:<p class="source-code">Acting or Singing: Will Smith, Adele, Harrison Ford, Sigourney Weaver</p><p class="source-code">Acting and Singing: Will Smith</p><p class="source-code">Acting Only: Harrison Ford, Sigourney Weaver</p></li>
</ol>
<p>From the output, you can see that out of the given list of actors and singers, only <strong class="source-inline">Will Smith</strong> can act and sing.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/ZdNbS">https://packt.link/ZdNbS</a>.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor175"/>Dictionaries</h2>
<p>Another commonly used collection type is the generic <strong class="source-inline">Dictionary&lt;TK, TV&gt;</strong>. This allows multiple items to be added, but a unique <strong class="bold">key</strong> is needed to identify an item instance.</p>
<p>Dictionaries are commonly used to look up values using known keys. The key and value type parameters can be of any type. A value can exist in a <strong class="source-inline">Dictionary</strong> more than once, provided that its key is <strong class="bold">unique</strong>. Attempting to add a key that already exists will result in a runtime exception being thrown.</p>
<p>A common example of a <strong class="source-inline">Dictionary</strong> might be a registry of known countries that are keyed by their ISO country code. A customer service application may load customer details from a database and then use the ISO code to look up the customer's country from the country list, rather than having the extra overhead of creating a new country instance for each customer.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on standard ISO country codes at <a href="https://www.iso.org/iso-3166-country-codes.xhtml">https://www.iso.org/iso-3166-country-codes.xhtml</a>.</p>
<p>The main methods used in the <strong class="source-inline">Dictionary</strong> class are as follows:</p>
<ul>
<li><strong class="source-inline">public TValue this[TKey key] {get; set;}</strong>: Gets or sets a value associated with the key. An exception is thrown if the key does not exist.</li>
<li><strong class="source-inline">Dictionary&lt;TKey, TValue&gt;.KeyCollection Keys { get; }</strong>: Returns a <strong class="source-inline">KeyCollection</strong> dictionary instance that contains all keys.</li>
<li><strong class="source-inline">Dictionary&lt;TKey, TValue&gt;.ValueCollection Values { get; }</strong>: Returns a <strong class="source-inline">ValueCollection</strong> dictionary instance that contains all values.</li>
<li><strong class="source-inline">public int Count { get; }</strong>: Returns the number of elements in the <strong class="source-inline">Dictionary</strong>.</li>
<li><strong class="source-inline">void Add(TKey key, TValue value)</strong>: Adds the key and associated value. If the key already exists, an exception is thrown.</li>
<li><strong class="source-inline">void Clear()</strong>: Clears all keys and values from the <strong class="source-inline">Dictionary</strong>.</li>
<li><strong class="source-inline">bool ContainsKey(TKey key)</strong>: Returns <strong class="source-inline">true</strong> if the specified key exists.</li>
<li><strong class="source-inline">bool ContainsValue(TValue value)</strong>: Returns <strong class="source-inline">true</strong> if the specified value exists.</li>
<li><strong class="source-inline">bool Remove(TKey key)</strong>: Removes a value with the associated key.</li>
<li><strong class="source-inline">bool TryAdd(TKey key, TValue value)</strong>: Attempts to add the key and value. If the key already exists, an exception is "not" thrown. Returns <strong class="source-inline">true</strong> if the value was added.</li>
<li><strong class="source-inline">bool TryGetValue(TKey key, out TValue value)</strong>: Gets the value associated with the key, if it is available. Returns <strong class="source-inline">true</strong> if it was found.</li>
</ul>
<p>The following code shows how a <strong class="source-inline">Dictionary</strong> can be used to add and navigate <strong class="source-inline">Country</strong> records:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new class called <strong class="source-inline">DictionaryExamples.cs</strong>.</li>
<li>Start by defining a <strong class="source-inline">Country</strong> record, which is passed a <strong class="source-inline">Name</strong> parameter:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    public record Country(string Name)</p><p class="source-code">    {}</p><p class="source-code">    class DictionaryExamples</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p></li>
<li>Use the <strong class="source-inline">Dictionary</strong> initialization syntax to create a <strong class="source-inline">Dictionary</strong> with five countries, as follows:<p class="source-code">            var countries = new Dictionary&lt;string, Country&gt;</p><p class="source-code">            {</p><p class="source-code">                {"AFG", new Country("Afghanistan")},</p><p class="source-code">                {"ALB", new Country("Albania")},</p><p class="source-code">                {"DZA", new Country("Algeria")},</p><p class="source-code">                {"ASM", new Country("American Samoa")},</p><p class="source-code">                {"AND", new Country("Andorra")}</p><p class="source-code">            };</p></li>
<li>In the next code snippet, <strong class="source-inline">Dictionary</strong> implements the <strong class="source-inline">IEnumerable</strong> interface, which allows you to retrieve a key-value pair representing the key and value items in the <strong class="source-inline">Dictionary</strong>:<p class="source-code">            Console.WriteLine("Enumerate foreach KeyValuePair");</p><p class="source-code">            foreach (var kvp in countries)</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"\t{kvp.Key} = {kvp.Value.Name}");</p><p class="source-code">            }</p></li>
<li>Running the example code produces the following output. By iterating through each item in <strong class="source-inline">countries</strong>, you can see the five country codes and their names:<p class="source-code">Enumerate foreach KeyValuePair</p><p class="source-code">        AFG = Afghanistan</p><p class="source-code">        ALB = Albania</p><p class="source-code">        DZA = Algeria</p><p class="source-code">        ASM = American Samoa</p><p class="source-code">        AND = Andorra</p></li>
<li>There is an entry with the <strong class="source-inline">AFG</strong> key, so using the <strong class="source-inline">set indexer</strong> passing in <strong class="source-inline">AFG</strong> as a key allows a new <strong class="source-inline">Country</strong> record to be set that replaces the previous item with the <strong class="source-inline">AGF</strong> key. You can add the following code for this:<p class="source-code">            Console.WriteLine("set indexor AFG to new value");</p><p class="source-code">            countries["AFG"] = new Country("AFGHANISTAN");</p><p class="source-code">            Console.WriteLine($"get indexor AFG: {countries["AFG"].Name}");</p></li>
<li>When you run the code, adding a key for <strong class="source-inline">AFG</strong> allows you to get a value using that key:<p class="source-code">set indexor AFG to new value</p><p class="source-code">get indexor AFG: AFGHANISTAN</p><p class="source-code">ContainsKey AGO: False</p><p class="source-code">ContainsKey and: False</p></li>
<li>Key comparisons are case-sensitive with string keys, so <strong class="source-inline">AGO</strong> is present but <strong class="source-inline">and</strong> is not as the corresponding country (<strong class="source-inline">Andorra</strong>) is defined with the uppercase <strong class="source-inline">AND</strong> key. You can add the following code to check this:<p class="source-code">            Console.WriteLine($"ContainsKey {"AGO"}:                          {countries.ContainsKey("AGO")}");</p><p class="source-code">            Console.WriteLine($"ContainsKey {"and"}:                          {countries.ContainsKey("and")}"); // Case sensitive</p></li>
<li>Using <strong class="source-inline">Add</strong> to add a new entry will throw an exception if the key already exists. This can be seen by adding the following code:<p class="source-code">            var anguilla = new Country("Anguilla");</p><p class="source-code">            Console.WriteLine($"Add {anguilla}...");</p><p class="source-code">            countries.Add("AIA", anguilla);</p><p class="source-code">            try</p><p class="source-code">            {</p><p class="source-code">                var anguillaCopy = new Country("Anguilla");</p><p class="source-code">                Console.WriteLine($"Adding {anguillaCopy}...");</p><p class="source-code">                countries.Add("AIA", anguillaCopy);</p><p class="source-code">            }</p><p class="source-code">            catch (Exception e)</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"Caught {e.Message}");</p><p class="source-code">            }</p></li>
<li>Conversely, <strong class="source-inline">TryAdd</strong> does <strong class="bold">not</strong> throw an exception if you attempt to add a duplicate key. There already exists an entry with the <strong class="source-inline">AIA</strong> key, so using <strong class="source-inline">TryAdd</strong> simply returns a <strong class="source-inline">false</strong> value rather than throwing an exception:<p class="source-code">            var addedAIA = countries.TryAdd("AIA", new Country("Anguilla"));</p><p class="source-code">            Console.WriteLine($"TryAdd AIA: {addedAIA}");</p></li>
<li>As the following output shows, adding <strong class="source-inline">Anguilla</strong> once using the <strong class="source-inline">AIA</strong> key is valid but attempting to add it again using the <strong class="source-inline">AIA</strong> key results in an exception being caught:<p class="source-code">Add Country { Name = Anguilla }...</p><p class="source-code">Adding Country { Name = Anguilla }...</p><p class="source-code">Caught An item with the same key has already been added. Key: AIA</p><p class="source-code">TryAdd AIA: False</p></li>
<li><strong class="source-inline">TryGetValue</strong>, as the name suggests, allows you to try to get a value by key. You pass in a key that may be missing from the <strong class="source-inline">Dictionary</strong>. Requesting an object whose key is missing from the <strong class="source-inline">Dictionary</strong> will ensure that an exception is not thrown. This is useful if you are unsure whether a value has been added for the specified key:<p class="source-code">            var tryGet = countries.TryGetValue("ALB", out Country albania1);</p><p class="source-code">            Console.WriteLine($"TryGetValue for ALB: {albania1}                              Result={tryGet}");</p><p class="source-code">            countries.TryGetValue("alb", out Country albania2);</p><p class="source-code">            Console.WriteLine($"TryGetValue for ALB: {albania2}");</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>You should see the following output upon running this code:<p class="source-code">TryGetValue for ALB: Country { Name = Albania } Result=True</p><p class="source-code">TryGetValue for ALB:</p><p class="callout-heading">Note</p><p class="callout">Visual Studio might report the following warning: <strong class="source-inline">Warning CS8600: Converting null literal or possible null value to non-nullable type</strong>. This is a reminder from Visual Studio that a variable may have a null value at runtime.</p></li>
</ol>
<p>You have seen how the <strong class="source-inline">Dictionary</strong> class is used to ensure that only unique identities are associated with values. Even if you do not know which keys are in the <strong class="source-inline">Dictionary</strong> until runtime, you can use the <strong class="source-inline">TryGetValue</strong> and <strong class="source-inline">TryAdd</strong> methods to prevent runtime exceptions.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/vzHUb">https://packt.link/vzHUb</a>.</p>
<p>In this example, a string key was used for the <strong class="source-inline">Dictionary</strong>. However, any type can be used as a key. You will often find that an integer value is used as a key when source data is retrieved from relational databases, as integers can often be more efficient in memory than strings. Now it is time to use this feature through an exercise.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor176"/>Exercise 4.02: Using a Dictionary to Count the Words in a Sentence</h2>
<p>You have been asked to create a console app that asks the user to enter a sentence. The console should then split the input into individual words (using a space character as a word delimiter) and count the number of times that each word occurs. If possible, simple forms of punctuation should be removed from the output, and you are to ignore capitalized words so that, for example, <strong class="source-inline">Apple</strong> and <strong class="source-inline">apple</strong> both appear as a single word.</p>
<p>This is an ideal use of a <strong class="source-inline">Dictionary</strong>. The <strong class="source-inline">Dictionary</strong> will use a string as the key (a unique entry for each word) with an <strong class="source-inline">int</strong> value to count the words. You will use <strong class="source-inline">string.Split()</strong> to split a sentence into words, and <strong class="source-inline">char.IsPunctuation</strong> to remove any trailing punctuation marks. </p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Exercises</strong> folder, create a new folder called <strong class="source-inline">Exercise02</strong>.</li>
<li>Inside the <strong class="source-inline">Exercise02</strong> folder, add a new class called <strong class="source-inline">Program.cs</strong>.</li>
<li>Start by defining a new class called <strong class="source-inline">WordCounter</strong>. This can be marked as <strong class="source-inline">static</strong> so that it can be used without needing to create an instance:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">namespace Chapter04.Exercises.Exercise02</p><p class="source-code">{</p><p class="source-code">    static class WordCounter </p><p class="source-code">    {</p></li>
<li>Define a <strong class="source-inline">static</strong> method called <strong class="source-inline">Process</strong>: <p class="source-code">        public static IEnumerable&lt;KeyValuePair&lt;string, int&gt;&gt; Process(            string phrase)</p><p class="source-code">        {</p><p class="source-code">            var wordCounts = new Dictionary&lt;string, int&gt;();</p></li>
</ol>
<p>This is passed a phrase and returns <strong class="source-inline">IEnumerable&lt;KeyValuePair&gt;</strong>, which allows the caller to enumerate through a <strong class="source-inline">Dictionary</strong> of results. After this definition, the <strong class="source-inline">Dictionary</strong> of <strong class="source-inline">wordCounts</strong> is keyed using a <strong class="source-inline">string</strong> (each word found) and an <strong class="source-inline">int</strong> (the number of times that a word occurs).</p>
<ol>
<li value="5">You are to ignore the case of words with capital letters, so convert the string into its lowercase equivalent before using the <strong class="source-inline">string.Split</strong> method to split the phrase. </li>
<li>Then you can use the <strong class="source-inline">RemoveEmptyEntries</strong> option to remove any empty string values. Add the following code for this:<p class="source-code">             var words = phrase.ToLower().Split(' ',                        StringSplitOptions.RemoveEmptyEntries);</p></li>
<li>Use a simple <strong class="source-inline">foreach</strong> loop to iterate through the individual words found in the phrase:<p class="source-code">            foreach(var word in words)</p><p class="source-code">            {</p><p class="source-code">                var key = word;</p><p class="source-code">                if (char.IsPunctuation(key[key.Length-1]))</p><p class="source-code">                {</p><p class="source-code">                    key = key.Remove(key.Length-1);</p><p class="source-code">                }</p></li>
</ol>
<p>The <strong class="source-inline">char.IsPunctuation</strong> method is used to remove punctuation marks from the end of the word.</p>
<ol>
<li value="8">Use the <strong class="source-inline">TryGetValue</strong> method to check if there is a <strong class="source-inline">Dictionary</strong> entry with the current word. If so, update the <strong class="source-inline">count</strong> by one:<p class="source-code">                if (wordCounts.TryGetValue(key, out var count))</p><p class="source-code">                {</p><p class="source-code">                    wordCounts[key] = count + 1;</p><p class="source-code">                }</p><p class="source-code">                else</p><p class="source-code">                {</p><p class="source-code">                    wordCounts.Add(key, 1);</p><p class="source-code">                }</p><p class="source-code">            }</p></li>
</ol>
<p>If the word does not exist, add a new word key with a starting value of <strong class="source-inline">1</strong>.</p>
<ol>
<li value="9">Once all the words in the phrase have been processed, return the <strong class="source-inline">wordCounts Dictionary</strong>:<p class="source-code">            return wordCounts;</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>Now, write the console app that allows the user to enter a phrase:<p class="source-code">    class Program</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            string input;</p><p class="source-code">            do</p><p class="source-code">            {</p><p class="source-code">                Console.Write("Enter a phrase:");</p><p class="source-code">                input = Console.ReadLine();</p></li>
</ol>
<p>The <strong class="source-inline">do</strong> loop will end once the user enters an empty string; you will add the code for this in an upcoming step.</p>
<ol>
<li value="11">Call the <strong class="source-inline">WordCounter.Process</strong> method to return a key-value pair that can be enumerated through. </li>
<li>For each <strong class="source-inline">key</strong> and <strong class="source-inline">value</strong>, write the word and its count, padding each word to the right: <p class="source-code">                if (!string.IsNullOrEmpty(input))</p><p class="source-code">                {</p><p class="source-code">                    var countsByWord = WordCounter.Process(input);</p><p class="source-code">                    var i = 0;</p><p class="source-code">                    foreach (var (key, value) in countsByWord)</p><p class="source-code">                    {</p><p class="source-code">                        Console.Write($"{key.PadLeft(20)}={value}\t");</p><p class="source-code">                        i++;</p><p class="source-code">                        if (i % 3 == 0)</p><p class="source-code">                        {</p><p class="source-code">                            Console.WriteLine();</p><p class="source-code">                        }</p><p class="source-code">                    }</p><p class="source-code">                    Console.WriteLine();</p></li>
</ol>
<p>A new line is started after every third word (using <strong class="source-inline">i % 3 = 0</strong>) for improved output formatting.</p>
<ol>
<li value="13">Finish off the <strong class="source-inline">do-while</strong> loop:<p class="source-code">                    }</p><p class="source-code">            } while (input != string.Empty);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Running the console using the opening text from <em class="italic">The Gettysburg Address</em> of 1863 produces this output:<p class="source-code">Enter a phrase: Four score and seven years ago our fathers brought forth, upon this continent, a new nation, conceived in liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived, and so dedicated, can long endure.</p><p class="source-code">                four=1                 score=1                 and=3</p><p class="source-code">               seven=1                 years=1                 ago=1</p><p class="source-code">                 our=1               fathers=1             brought=1</p><p class="source-code">               forth=1                  upon=1                this=1</p><p class="source-code">           continent=1                     a=2                 new=1</p><p class="source-code">              nation=3             conceived=2                  in=2</p><p class="source-code">             liberty=1             dedicated=2                  to=1</p><p class="source-code">                 the=1           proposition=1                that=2</p><p class="source-code">                 all=1                   men=1                 are=2</p><p class="source-code">             created=1                 equal=1                 now=1</p><p class="source-code">                  we=1               engaged=1               great=1</p><p class="source-code">               civil=1                   war=1             testing=1</p><p class="source-code">             whether=1                    or=1                 any=1</p><p class="source-code">                  so=2                   can=1                 long=1</p><p class="source-code">              endure=1</p><p class="callout-heading">Note</p><p class="callout">You can search online for The Gettysburg Address or visit <a href="https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm">https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm</a>.</p></li>
</ol>
<p>From the results, you can see that each word is displayed only once and that certain words, such as <strong class="source-inline">and</strong> and <strong class="source-inline">that</strong>, appear more than once in the speech. The words are listed in the order they appear in the text, but this is not always the case with the <strong class="source-inline">Dictionary</strong> class. It should be assumed that the order will <strong class="bold">not</strong> remain fixed this way; dictionaries' values should be accessed using a key.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/Dnw4a">https://packt.link/Dnw4a</a>.</p>
<p>So far, you have learned about the main collections commonly used in .NET. It is now time to look at LINQ, which makes extensive use of collections based on the <strong class="source-inline">IEnumerable</strong> interface.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor177"/>LINQ</h1>
<p>LINQ (pronounced <strong class="bold">link</strong>) is short for Language Integrated Query. LINQ is a general-purpose language that can be used to query objects in memory by using a syntax that is similar to Structured Query Language (SQL), that is, it is used to query databases. It is an enhancement of the C# language that makes it easier to interact with objects in memory using SQL-like Query Expressions or Query Operators (implemented through a series of extension methods).</p>
<p>Microsoft's original idea for LINQ was to bridge the gap between .NET code and data sources, such as relational databases and XML, using LINQ providers. LINQ providers form a set of building blocks that can be used to query various sources of data, using a similar set of Query Operators, without the caller needing to know the intricacies of how each data source works. The following is a list of providers and how they are used:</p>
<ul>
<li>LINQ to Objects: Queries applied to objects in memory, such as those defined in a list.</li>
<li>LINQ to SQL: Queries applied to relational databases such as SQL Server, Sybase, or Oracle.</li>
<li>LINQ to XML: Queries applied to XML documents.</li>
</ul>
<p>This chapter will cover LINQ to Objects. This is, by far, the most common use of LINQ providers and offers a flexible way to query collections in memory. In fact, when talking about LINQ, most people refer to LINQ to Objects, mainly due to its ubiquitous use throughout C# applications.</p>
<p>At the heart of LINQ is the way that collections can be converted, filtered, and aggregated into new forms using a concise and easy-to-use syntax. LINQ can be used in two interchangeable styles:</p>
<ul>
<li>Query Operators</li>
<li>Query Expressions</li>
</ul>
<p>Each style offers a different syntax to achieve the same result, and which one you use often comes down to personal preference. Each style can be interwoven in code easily.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor178"/>Query Operators</h2>
<p>These are based on a series of core extension methods. The results from one method can be chained together into a programming style, which can often be easier to grasp than their expression-based counterparts.</p>
<p>The extension methods typically take an <strong class="source-inline">IEnumerable&lt;T&gt;</strong> or <strong class="source-inline">IQueryable&lt;T&gt;</strong> input source, such as a list, and allow a <strong class="source-inline">Func&lt;T&gt;</strong> predicate to be applied to that source. The source is generic-based, so Query Operators work with all types. It is just as easy to work with <strong class="source-inline">List&lt;string&gt;</strong> as it is with <strong class="source-inline">List&lt;Customer&gt;</strong>, for example.</p>
<p>In the following snippet, <strong class="source-inline">.Where</strong>, <strong class="source-inline">.OrderBy</strong>, and <strong class="source-inline">.Select</strong> are the extension methods being called:</p>
<p class="source-code">books.Where(book =&gt; book.Price &gt; 10)</p>
<p class="source-code">     .OrderBy(book =&gt; book.Price)</p>
<p class="source-code">     .Select(book =&gt; book.Name)</p>
<p>Here, you are taking the results from a <strong class="source-inline">.Where</strong> extension method to find all books with a unit price greater than <strong class="source-inline">10</strong>, which is then sorted using the <strong class="source-inline">.OrderBy</strong> extension method. Finally, the name of each book is extracted using the <strong class="source-inline">.Select</strong> method. These methods could have been declared as single lines of code, but chaining in this way provides a more intuitive syntax. This will be covered in more detail in the upcoming sections.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor179"/>Query Expressions</h2>
<p>Query Expressions are an enhancement of the C# language and resemble SQL syntax. The C# compiler compiles Query Expressions into a sequence of Query Operator extension method calls. Note that not all Query Operators are available with an equivalent Query Expression implementation.</p>
<p>Query Expressions have the following rules:</p>
<ul>
<li>They start with a <strong class="source-inline">from</strong> clause.</li>
<li>They can contain at least one or more optional <strong class="source-inline">where</strong>, <strong class="source-inline">orderby</strong>, <strong class="source-inline">join</strong>, <strong class="source-inline">let</strong>, and additional <strong class="source-inline">from</strong> clauses.</li>
<li>They end with either a <strong class="source-inline">select</strong> or a <strong class="source-inline">group</strong> clause.</li>
</ul>
<p>The following snippet is functionally equivalent to the Query Operator style defined in the previous section:</p>
<p class="source-code">from book in books where book.Price &gt; 10 orderby book.Price select book.Name</p>
<p>You will take a more in-depth look at both styles as you learn about the standard Query Operators shortly.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor180"/>Deferred Execution</h2>
<p>Whether you choose to use Query Operators, Query Expressions, or a mixture of the two, it is important to remember that for many operators, the query that you define is not executed when it is defined, but only when it is enumerated over. This means that it is not until a <strong class="source-inline">foreach</strong> statement or a <strong class="source-inline">ToList</strong>, <strong class="source-inline">ToArray</strong>, <strong class="source-inline">ToDictionary</strong>, <strong class="source-inline">ToLookup</strong>, or <strong class="source-inline">ToHashSet</strong> method is called that the actual query is executed.</p>
<p>This allows queries to be constructed elsewhere in code with additional criteria included, and then used or even reused with a different collection of data. Recall that in <em class="italic">Chapter 3</em>, <em class="italic">Delegates, Lambdas, and Events</em>, you saw similar behavior with delegates. Delegates are not executed where they are defined, but only when they are invoked.</p>
<p>In the following short Query Operator example, the output will be <strong class="source-inline">abz</strong> even though <strong class="source-inline">z</strong> is added <strong class="bold">after</strong> the query is defined but <strong class="bold">before</strong> it is enumerated through. This demonstrates that LINQ queries are evaluated on demand, rather than at the point where they are declared:</p>
<p class="source-code">var letters = new List&lt;string&gt; { "a", "b"}</p>
<p class="source-code">var query = letters.Select(w =&gt; w.ToUpper());</p>
<p class="source-code">letters.Add("z");</p>
<p class="source-code">foreach(var l in query) </p>
<p class="source-code">  Console.Write(l);</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor181"/>Standard Query Operators</h2>
<p>LINQ is driven by a core set of extension methods, referred to as standard Query Operators. These are grouped into operations based on their functionality. There are many standard Query Operators available, so for this introduction, you will explore all the main operators that you are likely to use regularly.</p>
<h3 id="_idParaDest-166"><a id="_idTextAnchor182"/>Projection Operations</h3>
<p>Projection operations allow you to convert an object into a new structure using only the properties that you need. You can create a new type, apply mathematical operations, or return the original object:</p>
<ul>
<li><strong class="source-inline">Select</strong>: Projects each item in the source into a new form.</li>
<li><strong class="source-inline">SelectMany</strong>: Projects all items in the source, flattens the result, and optionally projects them to a new form. There is no Query Expression equivalent for <strong class="source-inline">SelectMany</strong>.</li>
</ul>
<h3 id="_idParaDest-167"><a id="_idTextAnchor183"/>Select</h3>
<p>Consider the following snippet, which iterates through a <strong class="source-inline">List&lt;string&gt;</strong> containing the values <strong class="source-inline">Mon</strong>, <strong class="source-inline">Tues</strong>, and <strong class="source-inline">Wednes</strong>, outputting each with the word day appended.</p>
<p>In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqSelectExamples.cs</strong> and edit it as follows:</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Collections.Generic;</p>
<p class="source-code">using System.Linq;</p>
<p class="source-code">namespace Chapter04.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class LinqSelectExamples</p>
<p class="source-code">    {</p>
<p class="source-code">        public static void Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            var days = new List&lt;string&gt; { "Mon", "Tues", "Wednes" };</p>
<p class="source-code">            var query1 = days.Select(d =&gt; d + "day");</p>
<p class="source-code">            foreach(var day in query1)</p>
<p class="source-code">                Console.WriteLine($"Query1: {day}");         </p>
<p>Looking at the Query Operator syntax first, you can see that <strong class="source-inline">query1</strong> uses the <strong class="source-inline">Select</strong> extension method and defines a <strong class="source-inline">Func&lt;T&gt;</strong> like this: </p>
<p class="source-code"><strong class="source-inline">d =&gt; d + "day"</strong></p>
<p>When executed, the variable <strong class="source-inline">d</strong> is passed to the lambda statement, which appends the word <strong class="source-inline">day</strong> to each string in the <strong class="source-inline">days</strong> list: <strong class="source-inline">"Mon"</strong>, <strong class="source-inline">"Tues"</strong>, <strong class="source-inline">"Wednes"</strong>. This returns a new <strong class="source-inline">IEnumerable&lt;string&gt;</strong> instance, with the original values inside the source variable, <strong class="source-inline">days</strong>, remaining unchanged.</p>
<p>You can now enumerate through the new <strong class="source-inline">IEnumerable</strong> instance using <strong class="source-inline">foreach</strong>, as follows:</p>
<p class="source-code">            var query2 = days.Select((d, i) =&gt; $"{i} : {d}day");</p>
<p class="source-code">            foreach (var day in query2)</p>
<p class="source-code">                Console.WriteLine($"Query2: {day}");</p>
<p>Note that the <strong class="source-inline">Select</strong> method has another overload that allows the index position in the source and value to be accessed, rather than just the value itself. Here, <strong class="source-inline">d</strong> (the string value) and <strong class="source-inline">i</strong> (its index) are passed, using the <strong class="source-inline">( d , i ) =&gt;</strong> syntax and joined into a new string. The output will be displayed as <strong class="source-inline">0 : Monday</strong>, <strong class="source-inline">1 : Tuesday</strong>, and so on.</p>
<h3 id="_idParaDest-168"><a id="_idTextAnchor184"/>Anonymous Types</h3>
<p>Before you continue looking at <strong class="source-inline">Select</strong> projections, it is worth noting that C# does not limit you to just creating new strings from existing strings. You can project into any type.</p>
<p>You can also create anonymous types, which are types created by the compiler from the properties that you name and specify. For example, consider the following example, which results in a new type being created that represents the results of the <strong class="source-inline">Select</strong> method:</p>
<p class="source-code">            var query3 = days.Select((d, i) =&gt; new</p>
<p class="source-code">            {</p>
<p class="source-code">                Index = i, </p>
<p class="source-code">                UpperCaseName = $"{d.ToUpper()}DAY"</p>
<p class="source-code">            });</p>
<p class="source-code">            foreach (var day in query3)</p>
<p class="source-code">                Console.WriteLine($"Query3: Index={day.Index},                                             UpperCaseDay={day.UpperCaseName}");</p>
<p>Here, <strong class="source-inline">query3</strong> results in a new type that has an Index and <strong class="source-inline">UpperCaseName</strong> property; the values are assigned using <strong class="source-inline">Index = i</strong> and <strong class="source-inline">UpperCaseName = $"{d.ToUpper()}DAY"</strong>.</p>
<p>These types are scoped to be available within your local method and can then be used in any local statements, such as in the previous <strong class="source-inline">foreach</strong> block. This saves you from having to create classes to temporarily store values from a <strong class="source-inline">Select</strong> method.</p>
<p>Running the code produces output in this format:</p>
<p class="source-code">Index=0, UpperCaseDay=MONDAY</p>
<p>As an alternative, consider how the equivalent Query Expression looks. In the following example, you start with the from <strong class="source-inline">day in days</strong> expression. This assigns the name <strong class="source-inline">day</strong> to the string values in the <strong class="source-inline">days</strong> list. You then use <strong class="source-inline">select</strong> to project that to a new string, appending <strong class="source-inline">"day"</strong> to each.</p>
<p>This is functionally equivalent to the example in <strong class="source-inline">query1</strong>. The only difference is the code readability:</p>
<p class="source-code">            var query4 = from day in days</p>
<p class="source-code">                         select day + "day";</p>
<p class="source-code">            foreach (var day in query4)</p>
<p class="source-code">                Console.WriteLine($"Query4: {day}");</p>
<p>The following example snippet mixes a Query Operator and Query Expressions. The <strong class="source-inline">select</strong> Query Expression cannot be used to select a value and index, so the <strong class="source-inline">Select</strong> extension method is used to create an anonymous type with a <strong class="source-inline">Name</strong> and <strong class="source-inline">Index</strong> property:</p>
<p class="source-code">                       var query5 = from dayIndex in </p>
<p class="source-code">                         days.Select( (d, i) =&gt; new {Name = d, Index = i})</p>
<p class="source-code">                         select dayIndex;</p>
<p class="source-code">            foreach (var day in query5)</p>
<p class="source-code">                Console.WriteLine($"Query5: Index={day.Index} : {day.Name}");</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Running the full example produces this output:</p>
<p class="source-code">Query1: Monday</p>
<p class="source-code">Query1: Tuesday</p>
<p class="source-code">Query1: Wednesday</p>
<p class="source-code">Query2: 0 : Monday</p>
<p class="source-code">Query2: 1 : Tuesday</p>
<p class="source-code">Query2: 2 : Wednesday</p>
<p class="source-code">Query3: Index=0, UpperCaseDay=MONDAY</p>
<p class="source-code">Query3: Index=1, UpperCaseDay=TUESDAY</p>
<p class="source-code">Query3: Index=2, UpperCaseDay=WEDNESDAY</p>
<p class="source-code">Query4: Monday</p>
<p class="source-code">Query4: Tuesday</p>
<p class="source-code">Query4: Wednesday</p>
<p class="source-code">Query5: Index=0 : Mon</p>
<p class="source-code">Query5: Index=1 : Tues</p>
<p class="source-code">Query5: Index=2 : Wednes</p>
<p>Again, it largely comes down to personal choice as to which you prefer using. As queries become longer, one form may require less code than the other.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/wKye0">https://packt.link/wKye0</a>.</p>
<h3 id="_idParaDest-169"><a id="_idTextAnchor185"/>SelectMany</h3>
<p>You have seen how <strong class="source-inline">Select</strong> can be used to project values from each item in a source collection. In the case of a source that has enumerable properties, the <strong class="source-inline">SelectMany</strong> extension method can extract the multiple items into a single list, which can then be optionally projected into a new form.</p>
<p>The following example creates two <strong class="source-inline">City</strong> records, each with multiple <strong class="source-inline">Station</strong> names, and uses <strong class="source-inline">SelectMany</strong> to extract all stations from both cities:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqSelectManyExamples.cs</strong> and edit it as follows:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    record City (string Name, IEnumerable&lt;string&gt; Stations);</p><p class="source-code">    class LinqSelectManyExamples</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var cities = new List&lt;City&gt;</p><p class="source-code">            {</p><p class="source-code">                new City("London", new[] {"Kings Cross KGX",                                           "Liverpool Street LVS",                                           "Euston EUS"}),</p><p class="source-code">                new City("Birmingham", new[] {"New Street NST"})</p><p class="source-code">            };</p><p class="source-code">            Console.WriteLine("All Stations: ");</p><p class="source-code">            <strong class="bold">foreach (var station in cities.SelectMany(city =&gt; city.Stations))</strong></p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine(station);</p><p class="source-code">            }</p></li>
</ol>
<p>The <strong class="source-inline">Func</strong> parameter, which is passed to <strong class="source-inline">SelectMany</strong>, requires you to specify an enumerable property, in this case, the <strong class="source-inline">City</strong> class's <strong class="source-inline">Stations</strong> property, which contains a list of string names (see the highlighted code).</p>
<p>Notice how a shortcut is used here, by directly integrating the query into a <strong class="source-inline">foreach</strong> statement. You are not altering or reusing the query variable, so there is no benefit in defining it separately, as done earlier.</p>
<p><strong class="source-inline">SelectMany</strong> extracts all the station names from all of the items in the <strong class="source-inline">List&lt;City&gt;</strong> variable. Starting with the <strong class="source-inline">City</strong> class at element <strong class="source-inline">0</strong>, which has the name <strong class="source-inline">London</strong>, it will extract the three station names <strong class="source-inline">("Kings Cross KGX"</strong>, <strong class="source-inline">"Liverpool Street LVS"</strong>, and <strong class="source-inline">"Euston EUS"</strong>). It will then move on to the second <strong class="source-inline">City</strong> element, named <strong class="source-inline">Birmingham</strong>, and extract the single station, named <strong class="source-inline">"New Street NST"</strong>.</p>
<ol>
<li value="2">Running the example produces the following output:<p class="source-code">All Stations:</p><p class="source-code">Kings Cross KGX</p><p class="source-code">Liverpool Street LVS</p><p class="source-code">Euston EUS</p><p class="source-code">New Street NST</p></li>
<li>As an alternative, consider the following snippet. Here, you revert to using a query variable, <strong class="source-inline">stations</strong>, to make the code easier to follow:<p class="source-code">            Console.Write("All Station Codes: ");</p><p class="source-code">            var stati<a id="_idTextAnchor186"/>ons = cities</p><p class="source-code">                .Sele<a id="_idTextAnchor187"/>ctMany(city =&gt; city.Stations.Select(s =&gt; s[^3..]));</p><p class="source-code">            foreach (var station in stations)</p><p class="source-code">            {</p><p class="source-code">                Console.Write($"{station} ");</p><p class="source-code">            }</p><p class="source-code">            Console.WriteLine();</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Rather than just returning each <strong class="source-inline">Station</strong> string, this example uses a nested <strong class="source-inline">Select</strong> method and a <strong class="source-inline">Range</strong> operator to extract the last three characters from the station name using <strong class="source-inline">s[^3..]</strong>, where <strong class="source-inline">s</strong> is a string for each station name and <strong class="source-inline">^3</strong> indicates that the <strong class="source-inline">Range</strong> operator should extract a string that starts at the last three characters in the string.</p>
<ol>
<li value="4">Running the example produces the following output:<p class="source-code">All Station Codes: KGX LVS EUS NST</p></li>
</ol>
<p>You can see the last three characters of each station name are shown in the output.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/g8dXZ">https://packt.link/g8dXZ</a>.</p>
<p>In the next section you will read about the filtering operations that filter a result as per a condition.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor188"/>Filtering Operations</h2>
<p>Filtering operations allow you to filter a result to return only those items that match a condition. For example, consider the following snippet, which contains a list of orders:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqWhereExample.cs</strong> and edit it as follows:<p class="source-code-heading">LinqWhereExamples.cs</p><p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    record Order (string Product, int Quantity, double Price);</p><p class="source-code">    class LinqWhereExamples</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var orders = new List&lt;Order&gt;</p><p class="source-code">            {</p><p class="source-code">                new Order("Pen", 2, 1.99),</p><p class="source-code">                new Order("Pencil", 5, 1.50),</p><p class="source-code">                new Order("Note Pad", 1, 2.99),</p></li>
</ol>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/ZJpb5">https://packt.link/ZJpb5</a>.</p>
<p>Here, some order items are defined for various stationery products. Suppose you want to output all orders that have a quantity greater than five (this should output the <strong class="source-inline">Ruler</strong> and <strong class="source-inline">USB Memory Stick</strong> orders from the source). </p>
<ol>
<li value="2">For this, you can add the following code:<p class="source-code">            Console.WriteLine("Orders with quantity over 5:");</p><p class="source-code">            foreach (var order in orders.Where(o =&gt; o.Quantity &gt; 5))</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine(order);</p><p class="source-code">            }</p></li>
<li>Now, suppose you extend the criteria to find all products where the product is <strong class="source-inline">Pen</strong> or <strong class="source-inline">Pencil</strong>. You can chain that result into a <strong class="source-inline">Select</strong> method, which will return each order's total value; remember that <strong class="source-inline">Select</strong> can return anything from a source, even a simple extra calculation like this:<p class="source-code">            Console.WriteLine("Pens or Pencils:");</p><p class="source-code">            foreach (var orderValue in orders</p><p class="source-code">                .Where(o =&gt; o.Product == "Pen"  || o.Product == "Pencil")</p><p class="source-code">                .Select( o =&gt; o.Quantity * o.Price))</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine(orderValue);</p><p class="source-code">            }</p></li>
<li>Next, the Query Expression in the following snippet uses a <strong class="source-inline">where</strong> clause to find the orders with a price less than or equal to <strong class="source-inline">3.99</strong>. This projects them into an anonymous type that has <strong class="source-inline">Name</strong> and <strong class="source-inline">Value</strong> properties, which you enumerate through using a <strong class="source-inline">foreach</strong> statement:<p class="source-code">            var query = from order in orders</p><p class="source-code">               where order.Price &lt;= 3.99</p><p class="source-code">               select new {Name=order.Product, Value=order.Quantity*order.Price};</p><p class="source-code">            Console.WriteLine("Cheapest Orders:");</p><p class="source-code">            foreach(var order in query)</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"{order.Name}: {order.Value}");</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Running the full example produces this result:<p class="source-code">Orders with quantity over 5:</p><p class="source-code">Order { Product = Ruler, Quantity = 10, Price = 0.5 }</p><p class="source-code">Order { Product = USB Memory Stick, Quantity = 6, Price = 20 }</p><p class="source-code">Pens or Pencils:</p><p class="source-code">3.98</p><p class="source-code">7.5</p><p class="source-code">Cheapest Orders:</p><p class="source-code">Pen: 3.98</p><p class="source-code">Pencil: 7.5</p><p class="source-code">Note Pad: 2.99</p><p class="source-code">Stapler: 3.99</p><p class="source-code">Ruler: 5</p></li>
</ol>
<p>Now you have seen Query Operators in action, it is worth returning to deferred execution to see how this affects a query that is enumerated multiple times over.</p>
<p>In this next example, you have a collection of journeys made by a vehicle, which are populated via a <strong class="source-inline">TravelLog</strong> record. The <strong class="source-inline">TravelLog</strong> class contains an <strong class="source-inline">AverageSpeed</strong> method that logs a console message each time it is executed, and, as the name suggests, returns the average speed of the vehicle during that journey:</p>
<ol>
<li value="1">In your Chapter04\Examples folder, add a new file called <strong class="source-inline">LinqMultipleEnumerationExample.cs</strong> and edit it as follows:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    record TravelLog (string Name, int Distance, int Duration)</p><p class="source-code">    {</p><p class="source-code">        public double AverageSpeed()</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine($"AverageSpeed() called for '{Name}'");</p><p class="source-code">            return Distance / Duration;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    class LinqMultipleEnumerationExample</p><p class="source-code">    {</p></li>
<li>Next, define the console app's <strong class="source-inline">Main</strong> method, which populates a <strong class="source-inline">travelLogs</strong> list with four <strong class="source-inline">TravelLog</strong> records. You will add the following code for this:<p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var travelLogs = new List&lt;TravelLog&gt;</p><p class="source-code">            {</p><p class="source-code">                new TravelLog("London to Brighton", 50, 4),</p><p class="source-code">                new TravelLog("Newcastle to London", 300, 24),</p><p class="source-code">                new TravelLog("New York to Florida", 1146, 19),</p><p class="source-code">                new TravelLog("Paris to Berlin", 546, 10)</p><p class="source-code">            };</p></li>
<li>You will now create a <strong class="source-inline">fastestJourneys</strong> query variable, which includes a <strong class="source-inline">Where</strong> clause. This <strong class="source-inline">Where</strong> clause will call each journey's <strong class="source-inline">AverageSpeed</strong> method when enumerated. </li>
<li>Then, using a <strong class="source-inline">foreach</strong> loop, you enumerate through the items in <strong class="source-inline">fastestJourneys</strong> and write the name and distance to the console (note that you do <strong class="bold">not</strong> access the <strong class="source-inline">AverageSpeed</strong> method inside the <strong class="source-inline">foreach</strong> loop):<p class="source-code">            var fastestJourneys = travelLogs.Where(tl =&gt; tl.AverageSpeed() &gt; 50);</p><p class="source-code">            Console.WriteLine("Fastest Distances:");</p><p class="source-code">            foreach (var item in fastestJourneys)</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"{item.Name}: {item.Distance} miles<a id="_idTextAnchor189"/>");</p><p class="source-code">            }</p><p class="source-code">            Console.WriteLine();</p></li>
<li>Running the code block will produce the following output, the <strong class="source-inline">Name</strong> and <strong class="source-inline">Distance</strong> for each journey:<p class="source-code">Fastest Distances:</p><p class="source-code">AverageSpeed() called for 'London to Brighton'</p><p class="source-code">AverageSpeed() called for 'Newcastle to London'</p><p class="source-code">AverageSpeed() called for 'New York to Florida'</p><p class="source-code">New York to Florida: 1146 miles</p><p class="source-code">AverageSpeed() called for 'Paris to Berlin'</p><p class="source-code">Paris to Berlin: 546 miles</p></li>
<li>You can see that <strong class="source-inline">AverageSpeed</strong> was called <strong class="bold">four</strong> times, once for each journey as part of the <strong class="source-inline">Where</strong> condition. This is as expected so far, but now, you can reuse the same query to output the <strong class="source-inline">Name</strong> and, alternatively, the <strong class="source-inline">Duration</strong>:<p class="source-code">            Console.WriteLine("Fastest Duration:");</p><p class="source-code">            foreach (var item in fastestJourneys)</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"{item.Name}: {item.Duration} hours");</p><p class="source-code">            }</p><p class="source-code">            Console.WriteLine();</p></li>
<li>Running this block produces the same <strong class="bold">four</strong> calls to the <strong class="source-inline">AverageSpeed</strong> method:<p class="source-code">Fastest Duration:</p><p class="source-code">AverageSpeed() called for 'London to Brighton'</p><p class="source-code">AverageSpeed() called for 'Newcastle to London'</p><p class="source-code">AverageSpeed() called for 'New York to Florida'</p><p class="source-code">New York to Florida: 19 hours</p><p class="source-code">AverageSpeed() called for 'Paris to Berlin'</p><p class="source-code">Paris to Berlin: 10 hours</p></li>
</ol>
<p>This shows that whenever a query is enumerated, the full query is <strong class="bold">re-evaluated every time</strong>. This might not be a problem for a fast method such as <strong class="source-inline">AverageSpeed</strong>, but what if a method needs to access a database to extract some data? That would result in multiple database calls and, possibly, a very slow application.</p>
<ol>
<li value="8">You can use methods such as <strong class="source-inline">ToList</strong>, <strong class="source-inline">ToArray</strong>, <strong class="source-inline">ToDictionary</strong>, <strong class="source-inline">ToLookup</strong>, or <strong class="source-inline">ToHashSet</strong> to ensure that a query that could be enumerated many times is <strong class="bold">executed once only</strong> rather than being re-evaluated repeatedly. Continuing with this example, the following block uses the same <strong class="source-inline">Where</strong> clause but includes an extra <strong class="source-inline">ToList</strong> call to immediately execute the query and ensure it is not re-evaluated:<p class="source-code">            Console.WriteLine("Fastest Duration Multiple loops:");</p><p class="source-code">            var fastestJourneysList = travelLogs</p><p class="source-code">                  .Where(tl =&gt; tl.AverageSpeed() &gt; 50)</p><p class="source-code">                  .ToList();</p><p class="source-code">            for (var i = 0; i &lt; 2; i++)</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"Fastest Duration Multiple loop iteration {i+1}:");</p><p class="source-code">                foreach (var item in fastestJourneysList)</p><p class="source-code">                {</p><p class="source-code">                    Console.WriteLine($"{item.Name}: {item.Distance} in {item.Duration} hours");</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Running the block produces the following output. Notice how <strong class="source-inline">AverageSpeed</strong> is called <strong class="bold">four times only</strong> and is called prior to either of the two <strong class="source-inline">Fastest Duration Multiple loop iteration</strong> messages:<p class="source-code">Fastest Duration Multiple loops:</p><p class="source-code">AverageSpeed() called for 'London to Brighton'</p><p class="source-code">AverageSpeed() called for 'Newcastle to London'</p><p class="source-code">AverageSpeed() called for 'New York to Florida'</p><p class="source-code">AverageSpeed() called for 'Paris to Berlin'</p><p class="source-code">Fastest Duration Multiple loop iteration 1:</p><p class="source-code">New York to Florida: 1146 in 19 hours</p><p class="source-code">Paris to Berlin: 546 in 10 hours</p><p class="source-code">Fastest Duration Multiple loop iteration 2:</p><p class="source-code">New York to Florida: 1146 in 19 hours</p><p class="source-code">Paris to Berlin: 546 in 10 hours</p></li>
</ol>
<p>Notice that from the collection of journeys made by a vehicle, the code returns the average speed of the vehicle during the journeys.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/CIZJE">https://packt.link/CIZJE</a>.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor190"/>Sorting Operations</h2>
<p>There are five operations to sort items in a source. Items are primarily sorted and that can be followed by an optional secondary sort, which sorts the items within their primary group. For example, you can use a primary sort to sort a list of people firstly by the <strong class="source-inline">City</strong> property and then use a secondary sort to further sort them by the <strong class="source-inline">Surname</strong> property:</p>
<ul>
<li><strong class="source-inline">OrderBy</strong>: Sorts values into ascending order.</li>
<li><strong class="source-inline">OrderByDescending</strong>: Sorts values into descending order.</li>
<li><strong class="source-inline">ThenBy</strong>: Sorts values that have been primarily sorted into a secondary ascending order.</li>
<li><strong class="source-inline">ThenByDescending</strong>: Sorts values that have been primarily sorted into a secondary descending order.</li>
<li><strong class="source-inline">Reverse</strong>: Simply returns a collection where the order of elements in the source is reversed. There is no expression equivalent.</li>
</ul>
<h3 id="_idParaDest-172"><a id="_idTextAnchor191"/>OrderBy and OrderByDescending</h3>
<p>In this example, you will use the <strong class="source-inline">System.IO</strong> namespace to query files in the host machine's <strong class="source-inline">temp</strong> folder, rather than creating small objects from lists.</p>
<p>The static <strong class="source-inline">Directory</strong> class offers methods that can query the filesystem. <strong class="source-inline">FileInfo</strong> retrieves details about a specific file, such as its size or creation date. The <strong class="source-inline">Path.GetTempPath</strong> method returns the system's <strong class="source-inline">temp</strong> folder. To illustrate the point, in the Windows operating system, this can typically be found at <strong class="source-inline">C:\Users\username\AppData\Local\Temp</strong>, where <strong class="source-inline">username</strong> is a specific Windows login name. This will be different for other users and other systems:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqOrderByExamples.cs</strong> and edit it as follows:<p class="source-code">using System;</p><p class="source-code">using System.IO;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    class LinqOrderByExamples</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p></li>
<li>Use the <strong class="source-inline">Directory.EnumerateFiles</strong> method to find all filenames with the <strong class="source-inline">.tmp</strong> extension in the <strong class="source-inline">temp</strong> folder:<p class="source-code">            var fileInfos = Directory.EnumerateFiles(Path.GetTempPath(), "*.tmp")</p><p class="source-code">                .Select(filename =&gt; new FileInfo(filename))</p><p class="source-code">                .ToList();</p></li>
</ol>
<p>Here, each filename is projected into a <strong class="source-inline">FileInfo</strong> instance and chained into a populated collection using <strong class="source-inline">ToList</strong>, which allows you to further query the resulting <strong class="source-inline">fileInfos</strong> details.</p>
<ol>
<li value="3">Next, the <strong class="source-inline">OrderBy</strong> method is used to sort the earliest files by comparing the <strong class="source-inline">CreationTime</strong> property of the file:<p class="source-code">            Console.WriteLine("Earliest Files");</p><p class="source-code">            foreach (var fileInfo in fileInfos.OrderBy(fi =&gt; fi.CreationTime))</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"{fileInfo.CreationTime:dd MMM yy}: {fileInfo.Name}");</p><p class="source-code">            }</p></li>
<li>To find the largest files, re-query <strong class="source-inline">fileInfos</strong> and sort each file by its <strong class="source-inline">Length</strong> property using <strong class="source-inline">OrderByDescending</strong>:<p class="source-code">            Console.WriteLine("Largest Files");</p><p class="source-code">            foreach (var fileInfo in fileInfos                                        .OrderByDescending(fi =&gt; fi.Length))</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"{fileInfo.Length:N0} bytes: \t{fileInfo.Name}");</p><p class="source-code">            }</p></li>
<li>Finally, use <strong class="source-inline">where</strong> and <strong class="source-inline">orderby</strong> descending expressions to find the largest files that are less than <strong class="source-inline">1,000</strong> bytes in length:<p class="source-code">            Console.WriteLine("Largest smaller files");</p><p class="source-code">            foreach (var fileInfo in</p><p class="source-code">                from fi in fileInfos</p><p class="source-code">                where fi.Length &lt; 1000</p><p class="source-code">                orderby fi.Length descending</p><p class="source-code">                select fi)</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"{fileInfo.Length:N0} bytes: \t{fileInfo.Name}");</p><p class="source-code">            }</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Depending on the files in your <strong class="source-inline">temp</strong> folder, you should see an output like this:<p class="source-code">Earliest Files</p><p class="source-code">05 Jan 21: wct63C3.tmp</p><p class="source-code">05 Jan 21: wctD308.tmp</p><p class="source-code">05 Jan 21: wctFE7.tmp</p><p class="source-code">04 Feb 21: wctE092.tmp</p><p class="source-code">Largest Files</p><p class="source-code">38,997,896 bytes:       wctE092.tmp</p><p class="source-code">4,824,572 bytes:        cb6dfb76-4dc9-494d-9683-ce31eab43612.tmp</p><p class="source-code">4,014,036 bytes:        492f224c-c811-41d6-8c5d-371359d520db.tmp</p><p class="source-code">Largest smaller files</p><p class="source-code">726 bytes:      wct38BC.tmp</p><p class="source-code">726 bytes:      wctE239.tmp</p><p class="source-code">512 bytes:      ~DF8CE3ED20D298A9EC.TMP</p><p class="source-code">416 bytes:      TFR14D8.tmp</p></li>
</ol>
<p>With this example, you have queried files in the host machine's <strong class="source-inline">temp</strong> folder, rather than creating small objects from lists.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/mWeVC">https://packt.link/mWeVC</a>.</p>
<h3 id="_idParaDest-173"><a id="_idTextAnchor192"/>ThenBy and ThenByDescending</h3>
<p>The following example sorts popular quotes, based on the number of words found in each.</p>
<p>In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqThenByExamples.cs</strong> and edit it as follows:</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.IO;</p>
<p class="source-code">using System.Linq;</p>
<p class="source-code">namespace Chapter04.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class LinqThenByExamples</p>
<p class="source-code">    {</p>
<p class="source-code">        public static void Main()</p>
<p class="source-code">        {</p>
<p>You start by declaring a string array of quotes as follows:</p>
<p class="source-code">            var quotes = new[]</p>
<p class="source-code">            {</p>
<p class="source-code">                "Love <a id="_idTextAnchor193"/>for all hatred for none",</p>
<p class="source-code">                "Change the world by being yourself",</p>
<p class="source-code">                "Every moment is a fresh beginning",</p>
<p class="source-code">                "Never regret anything that made you smile",</p>
<p class="source-code">                "Die with memories not dreams",</p>
<p class="source-code">                "Aspire to inspire before we expire"</p>
<p class="source-code">            };</p>
<p>In the next snippet, each of these string quotes is projected into a new anonymous type based on the number of words in the quote (found using <strong class="source-inline">String.Split()</strong>). The items are first sorted in descending order to show those with the most words and then sorted in alphabetical order:</p>
<p class="source-code">            forea<a id="_idTextAnchor194"/>ch (var item in quotes</p>
<p class="source-code">                .Select(q =&gt; new {Quote = q, Words = q.Split(" ").Length})</p>
<p class="source-code">                .OrderByDescending(q =&gt; q.Words)</p>
<p class="source-code">                .ThenBy(q =&gt; q.Quote))</p>
<p class="source-code">            {</p>
<p class="source-code">                Console.WriteLine($"{item.Words}: {item.Quote}");</p>
<p class="source-code">            }</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Running the code lists the quotes in word count order as follows: </p>
<p class="source-code">7: Never regret anything that made you smile</p>
<p class="source-code">6: Aspire to inspire before we expire</p>
<p class="source-code">6: Change the world by being yourself</p>
<p class="source-code">6: Every moment is a fresh beginning</p>
<p class="source-code">6: Love for all hatred for none</p>
<p class="source-code">5: Die with memories not dreams</p>
<p>Note how the quotes with six words are shown alphabetically.</p>
<p>The following (highlighted code) is the equivalent Query Expression with <strong class="source-inline">orderby quote.Words descending</strong> followed by the <strong class="source-inline">quote.Words</strong> ascending clause:</p>
<p class="source-code"><strong class="bold">var query = from quote in </strong></p>
<p class="source-code"><strong class="bold">            (quotes.Select(q =&gt; new {Quote = q, Words = q.Split(" ").Length}))</strong></p>
<p class="source-code"><strong class="bold">            orderby quote.Words descending, quote.Words ascending </strong></p>
<p class="source-code"><strong class="bold">            select quote;</strong></p>
<p class="source-code">foreach(var item in query)        </p>
<p class="source-code">            {</p>
<p class="source-code">                Console.WriteLine($"{item.Words}: {item.Quote}");</p>
<p class="source-code">            }</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/YWJRz">https://packt.link/YWJRz</a>.</p>
<p>Now you have sorted popular quotes based on the number of words found in each. It is time to apply the skills learnt in the next exercise.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor195"/>Exercise 4.03: Filtering a List of Countries by Continent and Sorting by Area</h2>
<p>In the preceding examples, you have looked at code that can select, filter, and sort a collection source. You will now combine these into an exercise that filters a small list of countries for two continents (South America and Africa) and sorts the results by geographical size.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Exercises</strong> folder, create a new <strong class="source-inline">Exercise03</strong> folder.</li>
<li>Add a new class called <strong class="source-inline">Program.cs</strong> in the <strong class="source-inline">Exercise03</strong> folder.</li>
<li>Start by adding a <strong class="source-inline">Country</strong> record that will be passed the <strong class="source-inline">Name</strong> of a country, the <strong class="source-inline">Continent</strong> to which it belongs, and its <strong class="source-inline">Area</strong> in square miles:<p class="source-code">using System;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace Chapter04.Exercises.Exercise03</p><p class="source-code">{</p><p class="source-code">    class Program</p><p class="source-code">    {</p><p class="source-code">        record Country (string Name, string Continent, int Area);</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p></li>
<li>Now create a small subset of country data defined in an array, as follows:<p class="source-code">            var countries = new[]</p><p class="source-code">            {</p><p class="source-code">                new Country("Seychelles", "Africa", 176),</p><p class="source-code">                new Country("India", "Asia", 1_269_219),</p><p class="source-code">                new Country("Brazil", "South America",3_287_956),</p><p class="source-code">                new Country("Argentina", "South America", 1_073_500),</p><p class="source-code">                new Country("Mexico", "South America",750_561),</p><p class="source-code">                new Country("Peru", "South America",494_209),</p><p class="source-code">                new Country("Algeria", "Africa", 919_595),</p><p class="source-code">                new Country("Sudan", "Africa", 668_602)</p><p class="source-code">            };</p></li>
</ol>
<p>The array contains the name of a country, the continent it belongs to, and its geographical size in square miles.</p>
<ol>
<li value="5">Your search criteria must include <strong class="source-inline">South America</strong> or <strong class="source-inline">Africa</strong>. So define them in an array rather than hardcoding the <strong class="source-inline">where</strong> clause with two specific strings:<p class="source-code">            var requiredContinents = new[] {"South America", "Africa"};</p></li>
</ol>
<p>This offers extra code flexibility should you need to alter it.</p>
<ol>
<li value="6">Build up a query by filtering and sorting by continent, sorting by area, and using the <strong class="source-inline">.Select</strong> extension method, which returns the <strong class="source-inline">Index</strong> and <strong class="source-inline">item</strong> value: <p class="source-code">            var filteredCountries = countries</p><p class="source-code">                .Where(c =&gt; requiredContinents.Contains(c.Continent))</p><p class="source-code">                .OrderBy(c =&gt; c.Continent)</p><p class="source-code">                .ThenByDescending(c =&gt; c.Area)</p><p class="source-code">                .Select( (cty, i) =&gt; new {Index = i, Country = cty});</p><p class="source-code">                </p><p class="source-code">            foreach(var item in filteredCountries)</p><p class="source-code">                Console.WriteLine($"{item.Index+1}: {item.Country.Continent}, {item.Country.Name} = {item.Country.Area:N0} sq mi");</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>You finally project each into a new anonymous type to be written to the console. </p>
<ol>
<li value="7">Running the code block produces the following result:<p class="source-code">1: Africa, Algeria = 919,595 sq mi</p><p class="source-code">2: Africa, Sudan = 668,602 sq mi</p><p class="source-code">3: Africa, Seychelles = 176 sq mi</p><p class="source-code">4: South America, Brazil = 3,287,956 sq mi</p><p class="source-code">5: South America, Argentina = 1,073,500 sq mi</p><p class="source-code">6: South America, Mexico = 750,561 sq mi</p><p class="source-code">7: South America, Peru = 494,209 sq mi</p></li>
</ol>
<p>Notice that <strong class="source-inline">Algeria</strong> has the largest area in <strong class="source-inline">Africa</strong>, and <strong class="source-inline">Brazil</strong> has the largest area in <strong class="source-inline">South America</strong> (based on this small subset of data). Notice how you add <strong class="source-inline">1</strong> to each <strong class="source-inline">Index</strong> for readability (since starting at zero is less user-friendly).</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/Djddw">https://packt.link/Djddw</a>.</p>
<p>You have seen how LINQ extension methods can be used to access items in a data source. Now, you will learn about partitioning data, which can be used to extract subsets of items.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor196"/>Partitioning Operations</h2>
<p>So far, you have looked at filtering the items in a data source that match a defined condition. Partitioning is used when you need to divide a data source into two distinct sections and return either of those two sections for subsequent processing.</p>
<p>For example, consider that you have a list of vehicles sorted by value and want to process the five least expensive vehicles using some method. If the list is sorted in ascending order, then you could partition the data using the <strong class="source-inline">Take(5)</strong> method (defined in the following paragraphs), which will extract the first five items and discard the remaining.</p>
<p>There are six partitioning operations that are used to split a source, with either of the two sections being returned. There are no partitioning Query Expressions:</p>
<ul>
<li><strong class="source-inline">Skip</strong>: Returns a collection that skips items up to a specified numeric position in the source sequence. Used when you need to skip the first N items in a source collection.</li>
<li><strong class="source-inline">SkipLast</strong>: Returns a collection that skips the last N items in the source sequence.</li>
<li><strong class="source-inline">SkipWhile</strong>: Returns a collection that skips items in the source sequence that match a specified condition.</li>
<li><strong class="source-inline">Take</strong>: Returns a collection that contains the first N items in the sequence.</li>
<li><strong class="source-inline">TakeLast</strong>: Returns a collection that contains the last N items in the sequence.</li>
<li><strong class="source-inline">TakeWhile</strong>: Returns a collection that contains only those items that match the condition specified.</li>
</ul>
<p>The following example demonstrates various <strong class="source-inline">Skip</strong> and <strong class="source-inline">Take</strong> operations on an unsorted list of exam grades. Here, you use <strong class="source-inline">Skip(1)</strong> to ignore the highest grade in a sorted list.</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqSkipTakeExamples.cs</strong> and edit it as follows:<p class="source-code">using System;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    class LinqSkipTakeExamples</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var grades = new[] {25, 95, 75, 40, 54, 9, 99};</p><p class="source-code">            Console.Write("Skip: Highest Grades (skipping first):");</p><p class="source-code">            foreach (var grade in grades</p><p class="source-code">                .OrderByDescending(g =&gt; g)</p><p class="source-code">                .Skip(1))</p><p class="source-code">            {</p><p class="source-code">                Console.Write($"{grade} ");</p><p class="source-code">            }</p><p class="source-code">            Console.WriteLine();</p></li>
<li>Next, the relational <strong class="source-inline">is</strong> operator is used to exclude those less than <strong class="source-inline">25</strong> or greater than <strong class="source-inline">75</strong>:<p class="source-code">            Console.Write("SkipWhile@ Middle Grades (excluding 25 or 75):");</p><p class="source-code">            foreach (var grade in grades</p><p class="source-code">                .OrderByDescending(g =&gt; g)</p><p class="source-code">                .SkipWhile(g =&gt; g is &lt;= 25 or &gt;=75))</p><p class="source-code">            {</p><p class="source-code">                Console.Write($"{grade} ");</p><p class="source-code">            }</p><p class="source-code">            Console.WriteLine();</p></li>
<li>By using <strong class="source-inline">SkipLast</strong>, you can show the bottom half of the results. Add the code for this as follows:<p class="source-code">            Console.Write("SkipLast: Bottom Half Grades:");</p><p class="source-code">            foreach (var grade in grades</p><p class="source-code">                .OrderBy(g =&gt; g)</p><p class="source-code">                .SkipLast(grades.Length / 2))</p><p class="source-code">            {</p><p class="source-code">                Console.Write($"{grade} ");</p><p class="source-code">            }</p><p class="source-code">            Console.WriteLine();</p></li>
<li>Finally, <strong class="source-inline">Take(2)</strong> is used here to show the two highest grades:<p class="source-code">            Console.Write("Take: Two Highest Grades:");</p><p class="source-code">            foreach (var grade in grades</p><p class="source-code">                .OrderByDescending(g =&gt; g)</p><p class="source-code">                .Take(2))</p><p class="source-code">            {</p><p class="source-code">                Console.Write($"{grade} ");</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Running the example produces this output, which is as expected:<p class="source-code">Skip: Highest Grades (skipping first):95 75 54 40 25 9</p><p class="source-code">SkipWhile Middle Grades (excluding 25 or 75):54 40 25 9</p><p class="source-code">SkipLast: Bottom Half Grades:9 25 40 54</p><p class="source-code">Take: Two Highest Grades:99 95</p></li>
</ol>
<p>This example demonstrated the various <strong class="source-inline">Skip</strong> and <strong class="source-inline">Take</strong> operations on an unsorted list of exam grades.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/TsDFk">https://packt.link/TsDFk</a>.</p>
<h2 id="_idParaDest-176">Group<a id="_idTextAnchor197"/>ing Operations</h2>
<p><strong class="source-inline">GroupBy</strong> groups elements that share the same attribute. It is often used to group data or provide a count of items grouped by a common attribute. The result is an enumerable <strong class="source-inline">IGrouping&lt;K, V&gt;</strong> type collection, where <strong class="source-inline">K</strong> is the key type and <strong class="source-inline">V</strong> is the value type specified. <strong class="source-inline">IGrouping</strong> itself is enumerable as it contains all items that match the specified key.</p>
<p>For example, consider the next snippet, which groups a <strong class="source-inline">List</strong> of customer orders by name. In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqGroupByExamples.cs</strong> and edit it as follows:</p>
<p class="source-code-heading">LinqGroupByExamples.cs</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Collections.Generic;</p>
<p class="source-code">using System.Linq;</p>
<p class="source-code">namespace Chapter04.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    record CustomerOrder(string Name, string Product, int Quantity);</p>
<p class="source-code">    class LinqGroupByExamples</p>
<p class="source-code">    {</p>
<p class="source-code">        public static void Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            var orders = new List&lt;CustomerOrder&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                new CustomerOrder("Mr Green", "LED TV", 4),</p>
<p class="source-code">                new CustomerOrder("Mr Smith", "iPhone", 2),</p>
<p class="source-code">                new CustomerOrder("Mrs Jones", "Printer", 1),</p>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/GbwF2">https://packt.link/GbwF2</a>.</p>
<p>In this example, you have a list of <strong class="source-inline">CustomerOrder</strong> objects and want to group them by the <strong class="source-inline">Name</strong> property. For this, the <strong class="source-inline">GroupBy</strong> method is passed a <strong class="source-inline">Func</strong> delegate, which selects the <strong class="source-inline">Name</strong> property from each <strong class="source-inline">CustomerOrder</strong> instance.</p>
<p>Each item in the <strong class="source-inline">GroupBy</strong> result contains a <strong class="source-inline">Key</strong> (in this case, the customer's <strong class="source-inline">Name</strong>). You can then sort the grouping item to show the <strong class="source-inline">CustomerOrders</strong> items sorted by <strong class="source-inline">Quantity</strong>, as follows:</p>
<p class="source-code">                foreach (var item in grouping.OrderByDescending(i =&gt; i.Quantity))</p>
<p class="source-code">                {</p>
<p class="source-code">                    Console.WriteLine($"\t{item.Product} * {item.Quantity}");</p>
<p class="source-code">                }</p>
<p class="source-code">            }</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Running the code produces the following output:</p>
<p class="source-code">Customer Mr Green:</p>
<p class="source-code">        LED TV * 4</p>
<p class="source-code">        MP3 Player * 1</p>
<p class="source-code">        Microwave Oven * 1</p>
<p class="source-code">Customer Mr Smith:</p>
<p class="source-code">        PC * 5</p>
<p class="source-code">        iPhone * 2</p>
<p class="source-code">        Printer * 2</p>
<p class="source-code">Customer Mrs Jones:</p>
<p class="source-code">        Printer * 1</p>
<p>You can see the data is first grouped by customer <strong class="source-inline">Name</strong> and then ordered by order <strong class="source-inline">Quantity</strong> within each customer grouping. The equivalent Query Expression is written like this:</p>
<p class="source-code">            var query = from order in orders</p>
<p class="source-code">                        group order by order.Name;</p>
<p class="source-code">            foreach (var grouping in query)</p>
<p class="source-code">            {</p>
<p class="source-code">                Console.WriteLine($"Customer {grouping.Key}:");</p>
<p class="source-code">                foreach (var item in from item in grouping </p>
<p class="source-code">                                     orderby item.Quantity descending </p>
<p class="source-code">                                     select item)</p>
<p class="source-code">                {</p>
<p class="source-code">                    Console.WriteLine($"\t{item.Product} * {item.Quantity}");</p>
<p class="source-code">                }</p>
<p class="source-code">            }</p>
<p>You have now seen some of the commonly used LINQ operators. You will now bring them together in an exercise.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor198"/>Exercise 4.04: Finding the Most Commonly Used Words in a Book</h2>
<p>In <em class="italic">Chapter 3</em>, <em class="italic">Delegates, Events, and Lambdas</em>, you used the <strong class="source-inline">WebClient</strong> class to download data from a website. In this exercise, you will use data downloaded from <em class="italic">Project Gutenberg</em>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Project Gutenberg is a library of 60,000 free eBooks. You can search online for Project Gutenberg or visit <a href="https://www.gutenberg.org/">https://www.gutenberg.org/</a>.</p>
<p>You will create a console app that allows the user to enter a URL. Then, you will download the book's text from the Project Gutenberg URL and use various LINQ statements to find the most frequent words in the book's text.</p>
<p>Additionally, you want to exclude some common stop-words; these are words such as <strong class="source-inline">and</strong>, <strong class="source-inline">or</strong>, and <strong class="source-inline">the</strong> that appear regularly in English, but add little to the meaning of a sentence. You will use the <strong class="source-inline">Regex.Split</strong> method to help split words more accurately than a simple space delimiter. Perform the following steps to do so:</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on Regex can be found at <a href="https://packt.link/v4hGN">https://packt.link/v4hGN</a>.</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Exercises</strong> folder, create a new <strong class="source-inline">Exercise04</strong> folder.</li>
<li>Add a new class called <strong class="source-inline">Program.cs</strong> in the <strong class="source-inline">Exercise04</strong> folder.</li>
<li>First, define the <strong class="source-inline">TextCounter</strong> class. This will be passed the path to a file, which you will add shortly. This should contain common English stop-words:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.IO;</p><p class="source-code">using System.Linq;</p><p class="source-code">using System.Net;</p><p class="source-code">using System.Text;</p><p class="source-code">using System.Text.RegularExpressions;</p><p class="source-code">namespace Chapter04.Exercises.Exercise04</p><p class="source-code">{</p><p class="source-code">    class TextCounter</p><p class="source-code">    {</p><p class="source-code">        private readonly HashSet&lt;string&gt; _stopWords;</p><p class="source-code">        public TextCounter(string stopWordPath)</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine($"Reading stop word file: {stopWordPath}");</p></li>
<li>Using <strong class="source-inline">File.ReadAllLines</strong>, add each word into the <strong class="source-inline">_stopWords</strong> <strong class="source-inline">HashSet</strong>.<p class="source-code">          _stopWords = new HashSet&lt;string&gt;(File.ReadAllLines(stopWordPath));</p><p class="source-code">        }</p></li>
</ol>
<p>You have used a <strong class="source-inline">HashSet</strong>, as each stop-word is unique.</p>
<ol>
<li value="5">Next, the <strong class="source-inline">Process</strong> method is passed a string that contains the book's text and the maximum number of words to show. </li>
<li>Return the result as a <strong class="source-inline">Tuple&lt;string, int&gt;</strong> collection, which saves you from having to create a class or record to hold the results:<p class="source-code">        public IEnumerable&lt;Tuple&lt;string, int&gt;&gt; Process(string text,                                                        int maximumWords)</p><p class="source-code">        {</p></li>
<li>Now perform the query part. Use <strong class="source-inline">Regex.Split</strong> with the pattern <strong class="source-inline">@"\s+"</strong> to split all the words. </li>
</ol>
<p>In its simplest form, this pattern splits a string into a list of words, typically using a space or punctuation marks to identify word boundaries. For example, the string <strong class="source-inline">Hello Goodbye</strong> would be split into an array that contains two elements, <strong class="source-inline">Hello</strong> and <strong class="source-inline">Goodbye</strong>. The returned string items are filtered via <strong class="source-inline">where</strong> to ensure all stop-words are ignored using the <strong class="source-inline">Contains</strong> method. The words are then grouped by value, <strong class="source-inline">GroupBy(t=&gt;t)</strong>, projected to a <strong class="source-inline">Tuple</strong> using the word as a <strong class="source-inline">Key</strong>, and the number of times it occurs using <strong class="source-inline">grp.Count</strong>. </p>
<ol>
<li value="8">Finally, you sort by <strong class="source-inline">Item2</strong>, which for this <strong class="source-inline">Tuple</strong> is the word count, and then take only the required number of words:<p class="source-code">            var words = Regex.Split(text.ToLower(), @"\s+")</p><p class="source-code">                .Where(t =&gt; !_stopWords.Contains(t))</p><p class="source-code">                .GroupBy(t =&gt; t)</p><p class="source-code">                .Select(grp =&gt; Tuple.Create(grp.Key, grp.Count()))</p><p class="source-code">                .OrderByDescending(tup =&gt; tup.Item2) //int</p><p class="source-code">                .Take(maximumWords);</p><p class="source-code">            return words;</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>Now start creating the main console app:<p class="source-code">    class Program</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p></li>
<li>Include a text file called <strong class="source-inline">StopWords.txt</strong> in the <strong class="source-inline">Chapter04</strong> source folder:<p class="source-code">            const string StopWordFile = "StopWords.txt";</p><p class="source-code">            var counter = new TextCounter(StopWordFile);</p><p class="callout-heading">Note</p><p class="callout">You can find <strong class="source-inline">StopWords.txt</strong> on GitHub at <a href="https://packt.link/Vi8JH">https://packt.link/Vi8JH</a>, or you can download any standard stop-word file, such as NLTK's <a href="https://packt.link/ZF1Tf">https://packt.link/ZF1Tf</a>. This file should be saved in the <strong class="source-inline">Chapter04\Exercises</strong> folder.</p></li>
<li>Once <strong class="source-inline">TextCounter</strong> has been created, prompt the user for a URL:<p class="source-code">            string address;</p><p class="source-code">            do</p><p class="source-code">            {</p><p class="source-code">                //https://www.gutenberg.org/files/64333/64333-0.txt</p><p class="source-code">                Console.Write("Enter a Gutenberg book URL: ");</p><p class="source-code">                address = Console.ReadLine();</p><p class="source-code">                if (string.IsNullOrEmpty(address)) </p><p class="source-code">                    continue;</p></li>
<li>Enter a valid address and create a new <strong class="source-inline">WebClient</strong> instance and download the data file into a temporary file. </li>
<li>Perform extra processing to the text file before passing its contents to <strong class="source-inline">TextCounter</strong>:<p class="source-code">                using var client = new WebClient();</p><p class="source-code">                var tempFile = Path.GetTempFileName();</p><p class="source-code">                Console.WriteLine("Downloading...");</p><p class="source-code">                client.DownloadFile(address, tempFile);</p></li>
</ol>
<p>The Gutenberg text files contain extra details such as the author and title. These can be read by reading each line in the file. The actual text of the book doesn't begin until finding a line that starts <strong class="source-inline">*** START OF THE PROJECT GUTENBERG EBOOK</strong>, so you need to read each line looking for this start message too:</p>
<p class="source-code">                Console.WriteLine($"Processing file {tempFile}");</p>
<p class="source-code">                const string StartIndicator = "*** START OF THE PROJECT GUTENBERG EBOOK";</p>
<p class="source-code">                //Title: The Little Review, October 1914(Vol. 1, No. 7)</p>
<p class="source-code">                //Author: Various</p>
<p class="source-code">                var title = string.Empty;</p>
<p class="source-code">                var author = string.Empty;</p>
<ol>
<li value="14">Next, append each line read into a <strong class="source-inline">StringBuilder</strong> instance, which is efficient for such string operations:<p class="source-code">                var bookText = new StringBuilder();</p><p class="source-code">                var isReadingBookText = false;</p><p class="source-code">                var bookTextLineCount = 0;</p></li>
<li>Now parse each line inside <strong class="source-inline">tempFile</strong>, looking for the <strong class="source-inline">Author</strong>, <strong class="source-inline">Title</strong>, or the <strong class="source-inline">StartIndicator</strong>:<p class="source-code">                foreach (var line in File.ReadAllLines(tempFile))</p><p class="source-code">                {</p><p class="source-code">                    if (line.StartsWith("Title"))</p><p class="source-code">                    {</p><p class="source-code">                        title = line;</p><p class="source-code">                    }</p><p class="source-code">                    else if (line.StartsWith("Author"))</p><p class="source-code">                    {</p><p class="source-code">                        author = line;</p><p class="source-code">                    }</p><p class="source-code">                    else if (line.StartsWith(StartIndicator))</p><p class="source-code">                    {</p><p class="source-code">                        isReadingBookText = true;</p><p class="source-code">                    }</p><p class="source-code">                    else if (isReadingBookText)</p><p class="source-code">                    {</p><p class="source-code">                        bookText.Append(line);</p><p class="source-code">                        bookTextLineCount++;</p><p class="source-code">                    }</p><p class="source-code">                }</p></li>
<li>If the book text is found, provide a summary of lines and characters read before calling the <strong class="source-inline">counter.Process</strong> method. Here, you want the top <strong class="source-inline">50</strong> words:<p class="source-code">                if (bookTextLineCount &gt; 0)</p><p class="source-code">                {</p><p class="source-code">                    Console.WriteLine($"Processing {bookTextLineCount:N0} lines ({bookText.Length:N0} characters)..");</p><p class="source-code">                  var wordCounts = counter.Process(bookText.ToString(), 50);</p><p class="source-code">                  Console.WriteLine(title);</p><p class="source-code">                  Console.WriteLine(author);</p></li>
<li>Once you have the results, use a <strong class="source-inline">foreach</strong> loop to output the word count details, adding a blank line to the output after every third word:<p class="source-code">                    var i = 0;</p><p class="source-code">                    //deconstruction</p><p class="source-code">                    foreach (var (word, count) in wordCounts)</p><p class="source-code">                    {</p><p class="source-code">                        Console.Write($"'{word}'={count}\t\t");</p><p class="source-code">                        i++;</p><p class="source-code">                        if (i % 3 == 0)</p><p class="source-code">                        {</p><p class="source-code">                            Console.WriteLine();</p><p class="source-code">                        }</p><p class="source-code">                    }</p><p class="source-code">                    Console.WriteLine();</p><p class="source-code">                }</p><p class="source-code">                else</p><p class="source-code">                {</p></li>
<li>Running the console app, using <strong class="source-inline">https://www.gutenberg.org/files/64333/64333-0.txt</strong> as an example URL produces the following output:<p class="source-code">Reading stop word file: StopWords.txt</p><p class="source-code">Enter a Gutenberg book URL: https://www.gutenberg.org/files/64333/64333-0.txt</p><p class="source-code">Downloading...</p><p class="source-code">Processing file C:\Temp\tmpB0A3.tmp</p><p class="source-code">Processing 4,063 lines (201,216 characters)..</p><p class="source-code">Title: The Little Review, October 1914 (Vol. 1, No. 7)</p><p class="source-code">Author: Various</p><p class="source-code">'one'=108               'new'=95                'project'=62</p><p class="source-code">'man'=56                'little'=54             'life'=52</p><p class="source-code">'would'=51              'work'=50               'book'=42</p><p class="source-code">'must'=42               'people'=39             'great'=37</p><p class="source-code">'love'=37               'like'=36               'gutenberg-tm'=36</p><p class="source-code">'may'=35                'men'=35                'us'=32</p><p class="source-code">'could'=30              'every'=30              'first'=29</p><p class="source-code">'full'=29               'world'=28              'mr.'=28</p><p class="source-code">'old'=27                'never'=26              'without'=26</p><p class="source-code">'make'=26               'young'=24              'among'=24</p><p class="source-code">'modern'=23             'good'=23               'it.'=23</p><p class="source-code">'even'=22               'war'=22                'might'=22</p><p class="source-code">'long'=22               'cannot'=22             '_the'=22</p><p class="source-code">'many'=21               'works'=21              'electronic'=21</p><p class="source-code">'always'=20             'way'=20                'thing'=20</p><p class="source-code">'day'=20                'upon'=20               'art'=20</p><p class="source-code">'terms'=20              'made'=19</p><p class="callout-heading">Note</p><p class="callout">Visual Studio might show the following when the code is run for the first time: <strong class="source-inline">warning SYSLIB0014: 'WebClient.WebClient()' is obsolete: 'WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.</strong></p><p class="callout">This is a recommendation to use the newer <strong class="source-inline">HttpClient</strong> class instead of the <strong class="source-inline">WebClient</strong> class. Both are, however, functionally equivalent.</p></li>
</ol>
<p>The output shows a list of words found amongst the <strong class="source-inline">4,063</strong> lines of text downloaded. The counter shows that <strong class="source-inline">one</strong>, <strong class="source-inline">new</strong>, and <strong class="source-inline">project</strong> are the most popular words. Notice how <strong class="source-inline">mr.</strong>, <strong class="source-inline">gutenberg-tm</strong>, <strong class="source-inline">it.</strong>, and <strong class="source-inline">_the</strong> appear as words. This shows that the Regex expression used is not completely accurate when splitting words.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/Q7Pf8">https://packt.link/Q7Pf8</a>.</p>
<p>An interesting enhancement to this exercise would be to sort the words by count, include a count of the stop words found, or find the average word length.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor199"/>Aggregation Operations</h2>
<p>Aggregation operations are used to compute a single value from a collection of values in a data source. An example could be the maximum, minimum, and average rainfall from data collected over a month:</p>
<ul>
<li><strong class="source-inline">Average</strong>: Calculates the average value in a collection.</li>
<li><strong class="source-inline">Count</strong>: Counts the items that match a predicate.</li>
<li><strong class="source-inline">Max</strong>: Calculates the maximum value.</li>
<li><strong class="source-inline">Min</strong>: Calculates the minimum value.</li>
<li><strong class="source-inline">Sum</strong>: Calculates the sum of values.</li>
</ul>
<p>The following example uses the <strong class="source-inline">Process.GetProcess</strong> method from the <strong class="source-inline">System.Diagnostics</strong> namespace to retrieve a list of processes currently running on the system:</p>
<p>In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqAggregationExamples.cs</strong> and edit it as follows:</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Diagnostics;</p>
<p class="source-code">using System.Linq;</p>
<p class="source-code">namespace Chapter04.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class LinqAggregationExamples</p>
<p class="source-code">    {</p>
<p class="source-code">        public static void Main()</p>
<p class="source-code">        {</p>
<p>First, <strong class="source-inline">Process.GetProcesses().ToList()</strong> is called to retrieve a list of the active processes running on the system:</p>
<p class="source-code">            var processes = Process.GetProcesses().ToList();</p>
<p>Then, the <strong class="source-inline">Count</strong> extension method obtains a count of the items returned. Count has an additional overload, which accepts a <strong class="source-inline">Func</strong> delegate used to filter each of the items to be counted. The <strong class="source-inline">Process</strong> class has a <strong class="source-inline">PrivateMemorySize64</strong> property, which returns the number of bytes of memory the process is currently consuming, so you can use that to count the <strong class="bold">small</strong> processes, that is, those using less than <strong class="source-inline">1,000,000</strong> bytes of memory:</p>
<p class="source-code">            var allProcesses = processes.Count;</p>
<p class="source-code">            var smallProcesses = processes.Count(proc =&gt;                                        proc.PrivateMemorySize64 &lt; 1_000_000);</p>
<p>Next, the <strong class="source-inline">Average</strong> extension method returns the overall average of a specific value for all items in the <strong class="source-inline">processes</strong> list. In this case, you use it to calculate the average memory consumption, using the <strong class="source-inline">PrivateMemorySize64</strong> property again:</p>
<p class="source-code">            var average = processes.Average(p =&gt; p.PrivateMemorySize64);</p>
<p>The <strong class="source-inline">PrivateMemorySize64</strong> property is also used to calculate the maximum and minimum memory used for all processes, along with the total memory, as follows:</p>
<p class="source-code">            var max = processes.Max(p =&gt; p.PrivateMemorySize64);</p>
<p class="source-code">            var min = processes.Min(p =&gt; p.PrivateMemorySize64);</p>
<p class="source-code">            var sum = processes.Sum(p =&gt; p.PrivateMemorySize64);</p>
<p>Once you have calculated the statistics, each value is written to the console:</p>
<p class="source-code">            Console.WriteLine("Process Memory Details");</p>
<p class="source-code">            Console.WriteLine($"  All Count: {allProcesses}");</p>
<p class="source-code">            Console.WriteLine($"Small Count: {smallProcesses}");</p>
<p class="source-code">            Console.WriteLine($"    Average: {FormatBytes(average)}");</p>
<p class="source-code">            Console.WriteLine($"    Maximum: {FormatBytes(max)}");</p>
<p class="source-code">            Console.WriteLine($"    Minimum: {FormatBytes(min)}");</p>
<p class="source-code">            Console.WriteLine($"      Total: {FormatBytes(sum)}");</p>
<p class="source-code">        }</p>
<p>In the preceding snippet, the <strong class="source-inline">Count</strong> method returns the number of all processes and, using the <strong class="source-inline">Predicate</strong> overload, you <strong class="source-inline">Count</strong> those where the memory is less than 1,000,000 bytes (by examining the <strong class="source-inline">process.PrivateMemorySize64</strong> property). You can also see that <strong class="source-inline">Average</strong>, <strong class="source-inline">Max</strong>, <strong class="source-inline">Min</strong>, and <strong class="source-inline">Sum</strong> are used to calculate statistics for process memory usage on the system.</p>
<p class="callout-heading">Note</p>
<p class="callout">The aggregate operators will throw <strong class="source-inline">InvalidOperationException</strong> with the error <strong class="source-inline">Sequence contains no elements</strong> if you attempt to calculate using a source collection that contains no elements. You should check the <strong class="source-inline">Count</strong> or <strong class="source-inline">Any</strong> methods prior to calling any aggregate operators.</p>
<p>Finally, <strong class="source-inline">FormatBytes</strong> formats the amounts of memory into their megabyte equivalents:</p>
<p class="source-code">        private static string FormatBytes(double bytes)</p>
<p class="source-code">        {</p>
<p class="source-code">            return $"{bytes / Math.Pow(1024, 2):N2} MB";</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Running the example produces results similar to this:</p>
<p class="source-code">Process Memory Details</p>
<p class="source-code">  All Count: 305</p>
<p class="source-code">Small Count: 5</p>
<p class="source-code">    Average: 38.10 MB</p>
<p class="source-code">    Maximum: 1,320.16 MB</p>
<p class="source-code">    Minimum: 0.06 MB</p>
<p class="source-code">      Total: 11,620.03 MB</p>
<p>From the output you will observe how the program retrieves a list of processes currently running on the system.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/HI2eV">https://packt.link/HI2eV</a>.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor200"/>Quantifier Operations</h2>
<p>Quantifier operations return a <strong class="source-inline">bool</strong> that indicates whether <strong class="bold">all</strong> or <strong class="bold">some</strong> elements in a sequence match a <strong class="source-inline">Predicate</strong> condition. This is often used to verify any elements in a collection match some criteria, rather than relying on <strong class="source-inline">Count</strong>, which enumerates <strong class="bold">all</strong> items in the collection, even if you need just one result.</p>
<p>Quantifier operations are accessed using the following extension methods:</p>
<ul>
<li><strong class="source-inline">All</strong>: Returns <strong class="source-inline">true</strong> if <strong class="bold">all</strong> elements in the source sequence match a condition.</li>
<li><strong class="source-inline">Any</strong>: Returns <strong class="source-inline">true</strong> if <strong class="bold">any</strong> element in the source sequence matches a condition.</li>
<li><strong class="source-inline">Contains</strong>: Returns <strong class="source-inline">true</strong> if the source sequence contains the specified item.</li>
</ul>
<p>The following card-dealing example selects three cards at random and returns a summary of those selected. The summary uses the <strong class="source-inline">All</strong> and <strong class="source-inline">Any</strong> extension methods to determine whether any of the cards were clubs or red and whether all cards were diamonds or an even number:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqAllAnyExamples.cs</strong>.</li>
<li>Start by declaring an <strong class="source-inline">enum</strong> that represents each of the four suits in a pack of playing cards and a <strong class="source-inline">record</strong> class that defines a playing card:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    enum PlayingCardSuit</p><p class="source-code">    {</p><p class="source-code">        Hearts,</p><p class="source-code">        Clubs,</p><p class="source-code">        Spades,</p><p class="source-code">        Diamonds</p><p class="source-code">    }</p><p class="source-code">    record PlayingCard (int Number, PlayingCardSuit Suit)</p><p class="source-code">    {</p></li>
<li>It is common practice to override the <strong class="source-inline">ToString</strong> method to provide a user-friendly way to describe an object's state at runtime. Here, the card's number and suit are returned as a string:<p class="source-code">        public override string ToString()</p><p class="source-code">        {</p><p class="source-code">            return $"{Number} of {Suit}";</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>Now create a class to represent a deck of cards (for ease, only create cards numbered one to 10). The deck's constructor will populate the <strong class="source-inline">_cards</strong> collection with <strong class="source-inline">10</strong> cards for each of the suits:<p class="source-code">    class Deck</p><p class="source-code">    {</p><p class="source-code">        private readonly List&lt;PlayingCard&gt; _cards = new();</p><p class="source-code">        private readonly Random _random = new();</p><p class="source-code">        public Deck()</p><p class="source-code">        {</p><p class="source-code">            for (var i = 1; i &lt;= 10; i++)</p><p class="source-code">            {</p><p class="source-code">                _cards.Add(new PlayingCard(i, PlayingCardSuit.Hearts));</p><p class="source-code">                _cards.Add(new PlayingCard(i, PlayingCardSuit.Clubs));</p><p class="source-code">                _cards.Add(new PlayingCard(i, PlayingCardSuit.Spades));</p><p class="source-code">                _cards.Add(new PlayingCard(i, PlayingCardSuit.Diamonds));</p><p class="source-code">            }</p><p class="source-code">        }</p></li>
<li>Next, the <strong class="source-inline">Draw</strong> method randomly selects a card from the <strong class="source-inline">_cards</strong> List, which it removes before returning to the caller:<p class="source-code">        public PlayingCard Draw()</p><p class="source-code">        {</p><p class="source-code">            var index = _random.Next(_cards.Count);</p><p class="source-code">            var drawnCard = _cards.ElementAt(index);</p><p class="source-code">            _cards.Remove(drawnCard);</p><p class="source-code">            return drawnCard;</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>The console app selects three cards using the deck's <strong class="source-inline">Draw</strong> method. Add the code for this as follows:<p class="source-code">    class LinqAllAnyExamples</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var deck = new Deck();</p><p class="source-code">            var hand = new List&lt;PlayingCard&gt;();</p><p class="source-code">            </p><p class="source-code">            for (var i = 0; i &lt; 3; i++)</p><p class="source-code">            {</p><p class="source-code">                hand.Add(deck.Draw());</p><p class="source-code">            }</p></li>
<li>To show a summary, use the <strong class="source-inline">OrderByDescending</strong> and <strong class="source-inline">Select</strong> operations to extract the user-friendly <strong class="source-inline">ToString</strong> description for each <strong class="source-inline">PlayingCard</strong>. This is then joined into a single delimited string as follows:<p class="source-code">            var summary = string.Join(" | ", </p><p class="source-code">                hand.OrderByDescending(c =&gt; c.Number)</p><p class="source-code">                    .Select(c =&gt; c.ToString()));</p><p class="source-code">            Console.WriteLine($"Hand: {summary}");</p></li>
<li>Using <strong class="source-inline">All</strong> or <strong class="source-inline">Any</strong>, you can provide an overview of the cards and their score using the <strong class="source-inline">Sum</strong> of the card numbers. By using <strong class="source-inline">Any</strong>, you determine whether <strong class="bold">any</strong> of the cards in the hand are a club (the suit is equal to <strong class="source-inline">PlayingCardSuit.Clubs</strong>):<p class="source-code">            Console.WriteLine($"Any Clubs: {hand.Any(card =&gt; card.Suit == PlayingCardSuit.Clubs)}");</p></li>
<li>Similarly, <strong class="source-inline">Any</strong> is used to see if <strong class="bold">any</strong> of the cards belong to the <strong class="source-inline">Hearts</strong> or <strong class="source-inline">Diamonds</strong> suits, and therefore, are <strong class="source-inline">Red</strong>:<p class="source-code">            Console.WriteLine($"Any Red: {hand.Any(card =&gt; card.Suit == PlayingCardSuit.Hearts || card.Suit == PlayingCardSuit.Diamonds)}");</p></li>
<li>In the next snippet, the <strong class="source-inline">All</strong> extension looks at every item in the collection and returns <strong class="source-inline">true</strong>, in this case, if <strong class="bold">all</strong> cards are <strong class="source-inline">Diamonds</strong>:<p class="source-code">            Console.WriteLine($"All Diamonds: {hand.All(card =&gt; card.Suit == PlayingCardSuit.Diamonds)}");</p></li>
<li>All is used again to see if all card numbers can be divided by two without a remainder, that is, whether they are even:<p class="source-code">            Console.WriteLine($"All Even: {hand.All(card =&gt; card.Number % 2 == 0)}");</p></li>
<li>Conclude by using the <strong class="source-inline">Sum</strong> aggregation method to calculate the value of the cards in the hand:<p class="source-code">            Console.WriteLine($"Score :{hand.Sum(card =&gt; card.Number)}");</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Running the console app produces output like this:<p class="source-code">Hand: 8 of Spades | 7 of Diamonds | 6 of Diamonds</p><p class="source-code">Any Clubs: False</p><p class="source-code">Any Red: True</p><p class="source-code">All Diamonds: False</p><p class="source-code">All Even: False</p><p class="source-code">Score :21</p></li>
</ol>
<p>The cards are randomly selected so you will have different hands each time you run the program. In this example, the score was <strong class="source-inline">21</strong>, which is often a winning hand in card games.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/xPuTc">https://packt.link/xPuTc</a>.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor201"/>Join Operations</h2>
<p>Join operations are used to join two sources based on the association of objects in one data source with those that share a common attribute in a second data source. If you are familiar with database design, this can be thought of as a primary and foreign key relationship between tables.</p>
<p>A common example of a join is one where you have a one-way relationship, such as <strong class="source-inline">Orders</strong>, which has a property of type <strong class="source-inline">Products</strong>, but the <strong class="source-inline">Products</strong> class does not have a collection property that represents a backward relationship to a collection of <strong class="source-inline">Orders</strong>. By using a <strong class="source-inline">Join</strong> operator, you can create a backward relationship to show <strong class="source-inline">Orders</strong> for <strong class="source-inline">Products</strong>.</p>
<p>The two join extension methods are the following:</p>
<ul>
<li><strong class="source-inline">Join</strong>: Joins two sequences using a key selector to extract pairs of values.</li>
<li><strong class="source-inline">GroupJoin</strong>: Joins two sequences using a key selector and groups the resulting items.</li>
</ul>
<p>The following example contains three <strong class="source-inline">Manufacturer</strong> records, each with a unique <strong class="source-inline">ManufacturerId</strong>. These numeric IDs are used to define various <strong class="source-inline">Car</strong> records, but to save memory, you will not have a direct memory reference from <strong class="source-inline">Manufacturer</strong> back to <strong class="source-inline">Car</strong>. You will use the <strong class="source-inline">Join</strong> method to create an association between the <strong class="source-inline">Manufacturer</strong> and <strong class="source-inline">Car</strong> instances:</p>
<ol>
<li value="1">In your <strong class="source-inline">Chapter04\Examples</strong> folder, add a new file called <strong class="source-inline">LinqJoinExamples.cs</strong>.</li>
<li>First, declare the <strong class="source-inline">Manufacturer</strong> and <strong class="source-inline">Car</strong> records as follows:<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Linq;</p><p class="source-code">namespace Chapter04.Examples</p><p class="source-code">{</p><p class="source-code">    record Manufacturer(int ManufacturerId, string Name);</p><p class="source-code">    record Car (string Name, int ManufacturerId);</p></li>
<li>Inside the <strong class="source-inline">Main</strong> entry point, create two lists, one for the manufacturers and the other to represent the <strong class="source-inline">cars</strong>:<p class="source-code-heading">LinqJoinExamples.cs</p><p class="source-code">    class LinqJoinExamples</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var manufacturers = new List&lt;Manufacturer&gt;</p><p class="source-code">            {</p><p class="source-code">                new(1, "Ford"),</p><p class="source-code">                new(2, "BMW"),</p><p class="source-code">                new(3, "VW")</p><p class="source-code">            };</p><p class="source-code">            var cars = new List&lt;Car&gt;</p><p class="source-code">            {</p><p class="source-code">                new("Focus", 1),</p><p class="source-code">                new("Galaxy", 1),</p><p class="source-code">                new("GT40", 1),</p></li>
</ol>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/Ue7Fj">https://packt.link/Ue7Fj</a>.</p>
<ol>
<li value="4">At this point, there is no direct reference, but as you know, you can use <strong class="source-inline">ManufacturerId</strong> to link the two together using the <strong class="source-inline">int</strong> IDs. You can add the following code for this:<p class="source-code">            var joinedQuery = manufacturers.Join(</p><p class="source-code">                cars,</p><p class="source-code">                manufacturer =&gt; manufacturer.ManufacturerId,</p><p class="source-code">                car =&gt; car.ManufacturerId,</p><p class="source-code">                (manufacturer, car) =&gt; new                        {ManufacturerName = manufacturer.Name,                         CarName = car.Name});</p><p class="source-code">            foreach (var item in joinedQuery)</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine($"{item}");</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>In the preceding snippet, the <strong class="source-inline">Join</strong> operation has various parameters. You pass in the <strong class="source-inline">cars</strong> list and define which properties in the <strong class="source-inline">manufacturer</strong> and <strong class="source-inline">car</strong> classes should be used to create the join. In this case, <strong class="source-inline">manufacturer.ManufacturerId = car.ManufacturerId</strong> determines the correct join.</p>
<p>Finally, the <strong class="source-inline">manufacturer</strong> and <strong class="source-inline">car</strong> arguments return a new anonymous type that contains the <strong class="source-inline">manufacturer.Name</strong> and <strong class="source-inline">car.Name</strong> properties.</p>
<ol>
<li value="5">Running the console app produces the following output:<p class="source-code">{ ManufacturerName = Ford, CarName = Focus }</p><p class="source-code">{ ManufacturerName = Ford, CarName = Galaxy }</p><p class="source-code">{ ManufacturerName = Ford, CarName = GT40 }</p><p class="source-code">{ ManufacturerName = BMW, CarName = 1 Series }</p><p class="source-code">{ ManufacturerName = BMW, CarName = 2 Series }</p><p class="source-code">{ ManufacturerName = VW, CarName = Golf }</p><p class="source-code">{ ManufacturerName = VW, CarName = Polo }</p></li>
</ol>
<p>As you can see, each of the <strong class="source-inline">Car</strong> and <strong class="source-inline">Manufacturer</strong> instances has been joined correctly using <strong class="source-inline">ManufacturerId</strong>.</p>
<ol>
<li value="6">The equivalent Query Expression would be as follows (note that in this case, it is a more concise format than the Query Operator syntax):<p class="source-code">var query = from manufacturer in manufacturers</p><p class="source-code">            join car in cars</p><p class="source-code">              on manufacturer.ManufacturerId equals car.ManufacturerId</p><p class="source-code">              select new</p><p class="source-code">              {</p><p class="source-code">                ManufacturerName = manufacturer.Name, CarName = car.Name</p><p class="source-code">              };</p><p class="source-code">foreach (var item in query)</p><p class="source-code">{</p><p class="source-code">  Console.WriteLine($"{item}");</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this example at <a href="http://packt.link/Wh8jK">http://packt.link/Wh8jK</a>.</p></li>
</ol>
<p>Before you finish exploring LINQ, there is one more area related to LINQ Query Expressions—the <strong class="source-inline">let</strong> clause.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor202"/>Using a let Clause in Query Expressions</h2>
<p>In earlier Query Expressions, you are often required to repeat similar-looking code in various clauses. Using a <strong class="source-inline">let</strong> clause, you can introduce new variables inside an Expression Query and reuse the variable's value throughout the rest of the query. For example, consider the following query:</p>
<p class="source-code">var stations = new List&lt;string&gt;</p>
<p class="source-code">{</p>
<p class="source-code">    "Kings Cross KGX", </p>
<p class="source-code">    "Liverpool Street LVS", </p>
<p class="source-code">    "Euston EUS", </p>
<p class="source-code">    "New Street NST"</p>
<p class="source-code">};</p>
<p class="source-code">var query1 = from station in stations</p>
<p class="source-code">             where station[^3..] == "LVS" || station[^3..] == "EUS" || </p>
<p class="source-code">                   station[0..^3].Trim().ToUpper().EndsWith("CROSS")</p>
<p class="source-code">             select new { code= station[^3..],                           name= station[0..^3].Trim().ToUpper()};</p>
<p>Here, you are searching for a station with the <strong class="source-inline">LVS</strong> or <strong class="source-inline">EUS</strong> code or a name ending in <strong class="source-inline">CROSS</strong>. To do this, you must extract the last three characters using a range, <strong class="source-inline">station[^3..]</strong>, but you have duplicated that in two <strong class="source-inline">where</strong> clauses and the final projection.</p>
<p>The station code and station names could both be converted into local variables using the <strong class="source-inline">let</strong> clause:</p>
<p class="source-code">var query2 = from station in stations</p>
<p class="source-code">             let code = station[^3..]</p>
<p class="source-code">             let name = station[0..^3].Trim().ToUpper()</p>
<p class="source-code">             where code == "LVS" || code == "EUS" || </p>
<p class="source-code">                   name.EndsWith("CROSS") </p>
<p class="source-code">             select new {code, name};</p>
<p>Here, you have defined <strong class="source-inline">code</strong> and <strong class="source-inline">name</strong> using a <strong class="source-inline">let</strong> clause and reused them throughout the query. This code looks much neater and is also easier to follow and maintain.</p>
<p>Running the code produces the following output:</p>
<p class="source-code">Station Codes: </p>
<p class="source-code">KGX : KINGS CROSS</p>
<p class="source-code">LVS : LIVERPOOL STREET</p>
<p class="source-code">EUS : EUSTON</p>
<p class="source-code">Station Codes (2):</p>
<p class="source-code">KGX : KINGS CROSS</p>
<p class="source-code">LVS : LIVERPOOL STREET</p>
<p class="source-code">EUS : EUSTON</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/b2KiG">https://packt.link/b2KiG</a>.</p>
<p>By now you have seen the main parts of LINQ. Now you will now bring these together into an activity that filters a set of flight records based on a user's criteria and provides various statistics on the subset of flights found.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor203"/>Activity 4.01: Treasury Flight Data Analysis</h2>
<p>You have been asked to create a console app that allows the user to download publicly available flight data files and apply statistical analysis to the files. This analysis should be used to calculate a count of the total records found, along with the average, minimum, and maximum fare paid within that subset.</p>
<p>The user should be able to enter a number of commands and each command should add a specific filter based on the flight's class, origin, or destination properties. Once the user has entered the required criteria, the <strong class="source-inline">go</strong> command must be entered, and the console should run a query and output the results.</p>
<p>The data file you will use for this activity contains details of flights made by the UK's HM Treasury department between January 1 to December 31, 2011 (there are 714 records.) You will need to use <strong class="source-inline">WebClient.DownloadFile</strong> to download the data from the following URL: <a href="https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv">https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv</a></p>
<p class="callout-heading">Note</p>
<p class="callout">The website might open differently for Internet Explorer or Google Chrome. This depends on how IE or Chrome are configured on your machine. Using <strong class="source-inline">WebClient.DownloadFile</strong>, you can download the data as suggested.</p>
<p>Ideally, the program should download data once and then reread it from the local filesystem each time it is started.</p>
<div>
<div class="IMG---Figure" id="_idContainer120">
<img alt="Figure 4.6: Preview of HM Treasury traffic data in Excel " height="874" src="image/B16835_04_06.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 4.6: Preview of HM Treasury traffic data in Excel</p>
<p>Once downloaded, the data should then be read into a suitable record structure before being added to a collection, which allows various queries to be applied. The output should show the following aggregate values for all rows that match the user's criteria:</p>
<ul>
<li>Record count</li>
<li>Average fare</li>
<li>Minimum fare</li>
<li>Maximum fare</li>
</ul>
<p>The user should be able to enter the following console commands:</p>
<ul>
<li><strong class="source-inline">Class c</strong>: Adds a class filter, where <strong class="source-inline">c</strong> is a flight class to search for, such as <strong class="source-inline">economy</strong> or <strong class="source-inline">Business class</strong>.</li>
<li><strong class="source-inline">Origin o</strong>: Adds an <strong class="source-inline">origin</strong> filter, where o is the flight origin, such as <strong class="source-inline">dublin</strong>, <strong class="source-inline">london</strong>, or <strong class="source-inline">basel</strong>.</li>
<li><strong class="source-inline">Destination d</strong>: Adds a destination filter, where <strong class="source-inline">d</strong> is the flight destination, such as <strong class="source-inline">delhi</strong>.</li>
<li><strong class="source-inline">Clear</strong>: Clears all filters.</li>
<li><strong class="source-inline">go</strong>: Applies the current filters.</li>
</ul>
<p>If a user enters multiple filters of the same type, then these should be treated as an <strong class="source-inline">OR</strong> filter.</p>
<p>An <strong class="source-inline">enum</strong> can be used to identify the filter criteria type entered, as shown in the following line of code:</p>
<p class="source-code">enum FilterCriteriaType {Class, Origin, Destination}</p>
<p>Similarly, a record can be used to store each filter type and comparison operand, as follows:</p>
<p class="source-code">record FilterCriteria(FilterCriteriaType Filter, string Operand)</p>
<p>Each filter specified should be added to a <strong class="source-inline">List&lt;FilterCriteria&gt;</strong> instance. For example, if the user enters two origin filters, one for <strong class="source-inline">dublin</strong> and another for <strong class="source-inline">london</strong>, then the list should contain two objects, each representing an origin type filter.</p>
<p>When the user enters the <strong class="source-inline">go</strong> command, a query should be built that performs the following steps:</p>
<ul>
<li>Extracts all <strong class="source-inline">class</strong> filter values into a list of strings (<strong class="source-inline">List&lt;string&gt;</strong>).</li>
<li>Extracts all <strong class="source-inline">origin</strong> filter values into <strong class="source-inline">List&lt;string&gt;</strong>.</li>
<li>Extracts all <strong class="source-inline">destination</strong> filter values into <strong class="source-inline">List&lt;string&gt;</strong>.</li>
<li>Uses a <strong class="source-inline">where</strong> extension method to filter the fight records for each criteria type specified using the <strong class="source-inline">List&lt;string&gt;</strong>. It contains a method to perform a case-insensitive search.</li>
</ul>
<p>The following steps will help you complete this activity:</p>
<ol>
<li value="1">Create a new folder called <strong class="source-inline">Activities</strong> in the <strong class="source-inline">Chapter04</strong> folder.</li>
<li>Add a new folder called <strong class="source-inline">Activity01</strong> to that new folder.</li>
<li>Add a new class file called <strong class="source-inline">Flight.cs</strong>. This will be a <strong class="source-inline">Record</strong> class with fields that match those in the flight data. A <strong class="source-inline">Record</strong> class should be used as it offers a simple type purely to hold data rather than any form of behavior.</li>
<li>Add a new class file called <strong class="source-inline">FlightLoader.cs</strong>. This class will be used for downloading or importing data. <strong class="source-inline">FlightLoader</strong> should include a list of the field index positions within the data file, to be used when reading each line of data and splitting the contents into a string array, for example:<p class="source-code">public const int Agency = 0;</p><p class="source-code">public const int PaidFare = 1; </p></li>
<li>Now for the <strong class="source-inline">FlightLoader</strong> implementation, use a <strong class="source-inline">static</strong> class to define the index of known field positions in the data file. This will make it easier to handle any future changes in the layout of the data.</li>
<li>Next, a <strong class="source-inline">Download</strong> method should be passed a URL and destination file. Use <strong class="source-inline">WebClient.DownloadFile</strong> to download the data file and then defer to <strong class="source-inline">Import</strong> to process the downloaded file.</li>
<li>An <strong class="source-inline">Import</strong> method is to be added. This is passed the name of the local file to import (downloaded using the <strong class="source-inline">Import</strong> method) and will return a list of <strong class="source-inline">Flight</strong> records.</li>
<li>Add a class file called <strong class="source-inline">FilterCriteria.cs</strong>. This should contain a <strong class="source-inline">FilterCriteriaType</strong> <strong class="source-inline">enum</strong> definition. You will offer filters based on the flight's class, origin, and destination properties, so <strong class="source-inline">FilterCriteriaType</strong> should represent each of these.</li>
<li>Now, for the main filtering class, add a new class file called <strong class="source-inline">FlightQuery.cs</strong>. The constructor will be passed a <strong class="source-inline">FlightLoader</strong> instance. Within it, create a list named <strong class="source-inline">_flights</strong> to contain the data imported via <strong class="source-inline">FlightLoader</strong>. Create a <strong class="source-inline">List&lt;FilterCriteria&gt;</strong> instance named <strong class="source-inline">_filters</strong> that represent each of the criteria items that are added, each time the user specifies a new filter condition.</li>
<li>The <strong class="source-inline">Import</strong> and <strong class="source-inline">Download</strong> methods of <strong class="source-inline">FlightLoader</strong> should be called by the console at startup, allowing previously downloaded data to be processed, via the <strong class="source-inline">_loader</strong> instance.</li>
<li>Create a <strong class="source-inline">Count</strong> variable that returns the number of flight records that have been imported.</li>
<li>When the user specifies a filter to add, the console will call <strong class="source-inline">AddFilter</strong>, passing an <strong class="source-inline">enum</strong> to define the criteria type and the string value being filtered for.</li>
<li><strong class="source-inline">RunQuery</strong> is the main method that returns those flights that match the user's criteria. You need to use the built-in <strong class="source-inline">StringComparer.InvariantCultureIgnoreCase</strong> comparer to ensure string comparison ignores any case differences. You define a query variable that calls <strong class="source-inline">Select</strong> on the flights; at the moment, this would result in a filtered result set.</li>
<li>Each of the types of filter available is string-based, so you need to extract all the string items. If there are any items to filter, you add an extra <strong class="source-inline">Where</strong> call to the query for each type (<strong class="source-inline">Class</strong>, <strong class="source-inline">Destination</strong>, or <strong class="source-inline">Origin</strong>). Each <strong class="source-inline">Where</strong> clause uses a <strong class="source-inline">Contains</strong> predicate, which examines the associated property.</li>
<li>Next, add the two helper methods used by <strong class="source-inline">RunQuery</strong>. <strong class="source-inline">GetFiltersByType</strong> is passed each of the <strong class="source-inline">FilterCriteriaType</strong> enums that represent a known type of criteria type and finds any of these in the list of filters using the <strong class="source-inline">.Where</strong> method. For example, if the user added two <strong class="source-inline">Destination</strong> criteria such as India and Germany, this would result in the two strings <strong class="source-inline">India</strong> and <strong class="source-inline">Germany</strong> being returned.</li>
<li><strong class="source-inline">FormatFilters</strong> simply joins a list of <strong class="source-inline">filterValues</strong> strings into a user-friendly string with the word <strong class="source-inline">OR</strong> between each item, such as <strong class="source-inline">London OR Dublin</strong>.</li>
<li>Now create the main console app. Add a new class called <strong class="source-inline">Program.cs</strong>, which will allow the user to input requests and process their commands.</li>
<li>Hardcode the download URL and destination filename.</li>
<li>Create the main <strong class="source-inline">FlightQuery</strong> class, passing in a <strong class="source-inline">FlightLoader</strong> instance. If the app has been run before, you can <strong class="source-inline">Import</strong> the local flight data, or use <strong class="source-inline">Download</strong> if not.</li>
<li>Show a summary of the records imported and the available commands.</li>
<li>When the user enters a command, there might also be an argument, such as <strong class="source-inline">destination united kingdom</strong>, where <strong class="source-inline">destination</strong> is the command and <strong class="source-inline">united kingdom</strong> is the argument. To determine this, use the <strong class="source-inline">IndexOf</strong> method to find the location of the first space character in the input, if any.</li>
<li>For the <strong class="source-inline">go</strong> command, call <strong class="source-inline">RunQuery</strong> and use various aggregation operators on the results returned.</li>
<li>For the remaining commands, clear or add filters as requested. If the <strong class="source-inline">Clear</strong> command is specified, call the query's <strong class="source-inline">ClearFilters</strong> method, which will clear the list of criteria items.</li>
<li>If a <strong class="source-inline">class</strong> filter command is specified, call <strong class="source-inline">AddFilter</strong> specifying the <strong class="source-inline">FilterCriteriaType.Class enum</strong> and the string <strong class="source-inline">Argument</strong>.</li>
<li>The same pattern should be used for <strong class="source-inline">Origin</strong> and <strong class="source-inline">Destination</strong> commands. Call <strong class="source-inline">AddFilter</strong>, passing in the required <strong class="source-inline">enum</strong> value and the argument.</li>
</ol>
<p>The console output should be similar to the following, here listing the commands available to the user:</p>
<p class="source-code">Commands: go | clear | class value | origin value | destination value</p>
<ol>
<li value="26">The user should be able to add two class filters, for <strong class="source-inline">economy</strong> or <strong class="source-inline">Business Class</strong> (all string comparisons should be case-insensitive), as shown in the following snippet:<p class="source-code">Enter a command:class economy</p><p class="source-code">Added filter: Class=economy</p><p class="source-code">Enter a command:class Business Class</p><p class="source-code">Added filter: Class=business class</p></li>
<li>Similarly, the user should be able to add an origin filter as follows (this example is for <strong class="source-inline">london</strong>):<p class="source-code">Enter a command:origin london</p><p class="source-code">Added filter: Origin=london</p></li>
<li>Adding the destination filter should look like this (this example is for <strong class="source-inline">zurich</strong>):<p class="source-code">Enter a command:destination zurich</p><p class="source-code">Added filter: Destination=zurich</p></li>
<li>Entering <strong class="source-inline">go</strong> should show a summary of all filters specified, followed by the results for flights that match the filters:<p class="source-code">Enter a command:go</p><p class="source-code">Classes: economy OR business class</p><p class="source-code">Destinations: zurich</p><p class="source-code">Origins: london</p><p class="source-code">Results: Count=16, Avg=266.92, Min=-74.71, Max=443.49</p><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p></li>
</ol>
<h1 id="_idParaDest-183"><a id="_idTextAnchor204"/>Summary</h1>
<p>In this chapter, you saw how the <strong class="source-inline">IEnumerable</strong> and <strong class="source-inline">ICollection</strong> interfaces form the basis of .NET data structures, and how they can be used to store multiple items. You created different types of collections depending on how each collection is meant to be used. You learned that the <strong class="source-inline">List</strong> collection is most extensively used to store collections of items, particularly if the number of elements is not known at compile time. You saw that the <strong class="source-inline">Stack</strong> and <strong class="source-inline">Queue</strong> types allow the order of items to be handled in a controlled manner, and how the <strong class="source-inline">HashSet</strong> offers set-based processing, while the <strong class="source-inline">Dictionary</strong> stores unique values using a key identifier.</p>
<p>You then further explored data structures by using LINQ Query Expressions and Query Operators to apply queries to data, showing how queries can be altered at runtime depending on filtering requirements. You sorted and partitioned data and saw how similar operations can be achieved using both Query Operators and Query Expressions, each offering a preference and flexibility based on context.</p>
<p>In the next chapter, you will see how parallel and asynchronous code can be used to run complex or long-running operations together.</p>
</div>
<div>
<div class="Content" id="_idContainer122">
</div>
</div>
</div>
</body></html>