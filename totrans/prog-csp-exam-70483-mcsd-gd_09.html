<html><head></head><body>
        

                            
                    <h1 class="header-title">Managing the Object Life Cycle</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">C# is a managed language. Unlike other languages, such as C++, where we need to explicitly manage memory cleanup, in C# we do not need to worry about it. The garbage collector in the .NET Framework manages the allocation and release of memory for us. </p>
<p>The garbage collector ensures that, as long as we use managed types, that is, value and reference type variables, then we don't have to explicitly destroy an object in order to free its memory. However, as we discovered in <a href="4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml">Chapter 8</a>, <em>Creating and Using Types in C#</em>, C# also gives us the freedom to utilize the capabilities of pointer object types in it. In C#, we must declare that code using the unsafe syntax. Apart from that, for variables declared in unsafe code, we also need to manage the release of memory.</p>
<p>In this chapter, as well as looking into memory management for unsafe code we will delve into the following topics:</p>
<ul>
<li>The differences between managed and unmanaged code in C#</li>
<li>How garbage collection works in C#</li>
<li>How a garbage collector uses a managed heap to allocate memory to objects during application execution</li>
<li>Understanding the mark-compact algorithm used by the garbage collector</li>
<li>How to manage unmanaged resources in C#</li>
<li>Understanding finalization and the performance implications of using the finalize method</li>
<li>Understanding the <kbd>IDisposable</kbd> interface and how it helps overcome the shortcomings of the finalize method</li>
<li>Understanding how we can combine the <kbd>Dispose</kbd> method with the finalize method to ensure the best performance of our applications</li>
<li>Understanding using the <kbd>using</kbd> block for all classes that implement the <kbd>IDisposable</kbd> interface</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>As with the previous chapters in this book, the programs explained here will be developed in VS 2017.</p>
<p>The example code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples">https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managed code versus unmanaged code</h1>
                
            
            
                
<p>In this section, we will understand the difference between managed and unmanaged code. Recall that we also studied this in <a href="ccec4122-6067-4279-843b-6123b1eff017.xhtml">Chapter 1</a>, <em>Learning the Basics of C#</em>. Therefore, for a quick recap, we will just revise the concepts that we covered there. </p>
<p>These concepts apply not just to the C# language, they are also relevant to all languages written in the .NET Framework. The following are some of the differences between managed and unmanaged code:</p>
<ul>
<li>Managed code is executed by the <strong>Common Language Runtime</strong> (<strong>CLR</strong>). Due to this, the code is independent of the underlying OS. On the other hand, unmanaged code is code that is executed by the OS directly. </li>
<li>In the case of managed code, the code is independent of the underlying framework or the OS. CLR compiles the code into an <strong>Intermediate Language</strong> (<strong>IL</strong>) code, which is then compiled to machine code. IL code consists of an underlying system or the OS on which the program is executing. On the other hand, in the case of unmanaged code, the code is directly compiled to the underlying machine code. </li>
<li>As managed code is executed by the CLR, the .NET Framework provides several built-in capabilities such as garbage collection and type checking exceptions. However, for unmanaged code, as we will learn in this chapter, a programmer needs to explicitly manage memory cleanup activities, which are otherwise done by the garbage collector. </li>
</ul>
<p>Now, before we learn how a programmer can manage memory for unmanaged code, let's first understand how garbage collection works in C# and how useful it is.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Garbage collection</h1>
                
            
            
                
<p>Garbage collection is a functionality, provided by CLR in .NET, which helps us to clean up the memory occupied by managed objects. It is a thread that executes in the .NET Framework and, at regular intervals, checks whether there is any unused memory in the application. If it does find memory, then it reclaims that memory and destroys the underlying object. </p>
<p>Suppose we have implemented a .NET web application in C#. Now, let's assume that during any interval of time, there are several people who are trying to access this .NET application. The following is one particular scenario that will give us an idea of why garbage collection is a very important part of C# or, for that matter, any .NET application:</p>
<ul>
<li>When a user browses the application, they can execute a number of functionalities, such as accessing their profile or executing operations (for example, creating, updating, and deleting information).</li>
<li>This information can be stored in different sources such as SQL, Oracle, or more.</li>
<li>To access this information and to execute these operations, the application will require the creation of different objects during the application runtime.</li>
<li>Assuming a scenario where memory is just being allocated to different objects but is not being cleaned up, over the course of time we will end up with a system that has too much unused memory. Memory cleanup is logical when the object declared in the memory is no longer required. For example, suppose that a user, after performing the intended operations in the application, logs out. In this case, the memory that was allocated for the operations of that particular user is no longer required. Therefore, that memory can be reclaimed.</li>
<li>A the memory allocated to the application could be limited, this will lead to performance degradation over time. </li>
</ul>
<p>Garbage collection in the .NET Framework ensures that such situations never arise for managed code. This thread runs in the background of the application and, at set intervals, reclaims the memory. </p>
<p>Please note that garbage collection can only reclaim the unused memory of managed code. For unmanaged code, which we will learn about later, we need to explicitly write code to ensure that no memory leaks occur in the application.</p>
<p>The garbage collector in .NET executes the following tasks in an application:</p>
<ul>
<li><strong>Allocation of memory</strong>: Each application running on .NET maintains a memory block required for its execution in a managed heap. The garbage collection manages the allocation of memory from this heap structure to the objects used in the program. In upcoming sections, we will learn more about managed heaps.</li>
<li><strong>Deallocation of memory</strong>: The garbage collector runs at set time periods during the application runtime and looks for objects that are no longer required by the application. It then destroys those objects and reclaims the memory for future use.<br/>
The garbage collector reclaims the memory when one of the following three conditions occurs during the execution of a program:
<ul>
<li><strong>The application has low memory</strong>: Each application running in .NET requires memory for its successful execution. If CLR determines that the application is getting free low memory from the OS, it tells the garbage collector to free any unused memory.</li>
<li><strong>The relocation of memory</strong>: Garbage collection in C# is based on generations. Generations are simply divisions in the managed heap used by the application. In C#, we can have three generations: generation 0, generation 1, and generation 2. In upcoming sections, we will learn how generations are classified. The garbage collector tries to optimize the performance of the system by classifying the objects used in the application among the three generations of a managed heap. In generation 0, it keeps the newly created objects in the application run. In comparison, in successive runs it identifies the objects that are being used for a longer period in the application execution. It classifies them as generation 1 and generation 2 and then loops through these generations less extensively than it does for generation 0. This, therefore, results in better performance.</li>
<li><strong>When the</strong> <strong>Collect</strong> <strong>method is called</strong>: As programmers, we hardly need to call the garbage collector method explicitly, as .NET is smart enough to ensure that garbage collection occurs at regular intervals. However, there could be certain scenarios where we would need to call this method explicitly. In such cases, we can do it by calling the <kbd>GC.Collect</kbd> method. In this chapter, we will look at a program implementation in which we do this.</li>
</ul>
</li>
</ul>
<p>Now, let's go through some of the basic structures that garbage collection works with in C#. We will start with a managed heap, which we will explore in the next section.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Managed heap</h1>
                
            
            
                
<p>When an application is executed in the .NET Framework, the garbage collector allocates a section of memory to store and manage the objects declared during the application execution. </p>
<p>This memory is referred to as the managed heap. It's called "managed" because it's used to save the managed variables. The following diagram illustrates what a typical heap structure looks like:</p>
<div><img src="img/fb6be0e3-aaa6-48a7-b1fb-cfff26f5889a.png" style=""/></div>
<p>The preceding diagram is a typical example of what a heap structure looks like. At the top of the structure, we have a root node. Each node can have two child nodes. The address of the child node is saved in the parent node itself.</p>
<p>The garbage collector allocates and deallocates memory on this managed heap. The heap is referred to as the managed heap. When an object is allocated in the application, the object is stored in the heap. The object then saves the reference to the next object in the heap.</p>
<p>While allocating the memory, the CLR checks whether any free memory is available in the heap. If memory is available, it allocates it from the heap. However, every so often, the garbage collector performs a check on all of the objects present in the managed heap and checks whether the object is being used in the application. The garbage collector loops through the heap and finds out which objects are not associated with the application root as well as those that are not referred to anywhere in the heap. These objects are classified as dead objects. The garbage collector then removes such dead objects from the heap. </p>
<p>Before we can begin to understand the phases in which the garbage collector works, let's understand how the garbage collector segregates the managed heap into different divisions called <strong>generations</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generations</h1>
                
            
            
                
<p>The garbage collector segregates the managed heap into three divisions or generations:</p>
<ul>
<li>Generation 0</li>
<li>Generation 1</li>
<li>Generation 2</li>
</ul>
<p>The idea behind this is to optimize the application by handling long-lived and short-lived objects in memory separately. For example, if we have determined that object <kbd>a</kbd> is a long-term object used during the application execution, then, ideally, the garbage collector would not want to check through this object on every occasion in order to see whether it is still valid. </p>
<p>Instead, the garbage collector classifies short-term objects in generation 0 and long-term objects in generation 1 or 2. Only objects present in generation 0 are checked during every run of the garbage collection. </p>
<p>On the other hand, the objects present in higher generations are not checked as frequently. Therefore, this avoids unnecessary checks and improves the performance of the overall application.</p>
<p>Generation 0 is the youngest generation and all new objects are allocated to generation 0. Generation 1 objects contain objects that live longer. Similarly, generation 2 consists of the longest living objects in the application execution. Let's go through the following example to see how generations help in optimizing application performance.</p>
<p>Let's say we have an application, <em>A</em>, which is declaring different objects during execution. The square brackets indicate the different divisions or generations maintained by the garbage collector. Each of the following steps indicates a particular stage during the application execution.</p>
<p>Please note that the following example is just for explanation purposes only. The garbage collection calls will depend on different factors and are not necessarily be based upon the scope of the function execution.</p>
<p>Let's take a look at the following code example and see how it works. In the code example, we have declared a private <kbd>ReturnResult</kbd> function, which does not have any input parameter and returns an output parameter of the <kbd>object</kbd> type. In this function, just for the sake of explanation, we have declared some variables and are returning back one variable, <kbd>a</kbd>, to the calling function. Now, let's execute the code as follows:</p>
<pre>static void Main(string[] args)<br/>{<br/>    object a = ReturnResult();<br/>}<br/><br/>static private object ReturnResult()<br/>{<br/>    object a = new object();<br/>    object b = new object();<br/>    object c = new object();<br/>    object d = new object();<br/>    object e = new object();<br/>    return a;    <br/>}</pre>
<p>When the application execution begins, the application calls the <kbd>ReturnResult</kbd> function. Then, in the function, when the execution encounters the <kbd>new</kbd> keyword, the garbage collector gets triggered. As all the variables are newly created variables, these variables will be added to generation 0:</p>
<div><img src="img/5a8fd323-914d-4cdc-9611-1863f0c0e418.png" style=""/></div>
<p>Now, suppose that in the next statement, we return the execution to the main function and pass object <kbd>a</kbd>. By doing so, the program execution shifts to the main operation. However, as we are just returning <kbd>a</kbd>, all the other <kbd>b</kbd>, <kbd>c</kbd>, <kbd>d</kbd>, and <kbd>e</kbd> objects will no longer be required in the application.</p>
<p>Additionally, we are also declaring new objects, <kbd>f</kbd>, <kbd>g</kbd>, and <kbd>h</kbd>, in the main program.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>If the garbage collector is called during this time, it will identify that object <kbd>a</kbd> is still required in the program execution but all other objects can be released. Therefore, the garbage collector will reclaim the memory in the variables <kbd>b</kbd>, <kbd>c</kbd>, <kbd>d</kbd>, and <kbd>e</kbd>. The new objects, <kbd>f</kbd>, <kbd>g</kbd>, and <kbd>h</kbd>, will be added to generation 0. For object <kbd>a</kbd>, the garbage collector will assume that it's a long-lived object and this will be moved to the generation 1 division.</p>
<p>This is what the generations now look like:</p>
<div><img src="img/0752b5d9-b10d-412c-8b7a-d4ef0e66a77f.png" style=""/></div>
<p>Now, let's suppose that, again, the main program calls for another <kbd>ReturnResultFinal</kbd> function passing object <kbd>a</kbd>. The newly added program does not return anything back. The following is the code implementation for this:</p>
<pre>static void Main(string[] args)<br/>{<br/>     object a = ReturnResult();<br/>     ReturnResultFinal(a);<br/>}<br/>static private object ReturnResult()<br/>{<br/>     object a = new object();<br/>     object b = new object();<br/>     object c = new object();<br/>     object d = new object();<br/>     object e = new object();<br/>     return a;<br/>}<br/>static private void ReturnResultFinal(object a)<br/>{ <br/>}</pre>
<p>At this stage, the garbage collector can determine that all the other variables can be removed from the memory except <kbd>a</kbd>. During this time, it can also determine that this object can be promoted to generation 2. This is what the generations now look like:</p>
<p class="mce-root"/>
<div><img src="img/1e35c0c3-1b89-4ece-82eb-6b7be517598f.png" style=""/></div>
<p>Before we move on to the next topic, let's briefly go through the mark-compact algorithm, used by the garbage collector.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The mark-compact algorithm</h1>
                
            
            
                
<p>The mark-compact algorithm is used by the garbage collector to maintain the memory. Essentially, it can be classified into three phases:</p>
<ul>
<li><strong>The mark phase</strong>: In the mark phase, the garbage collector loops through the different objects in the heap and identifies the one that is being referenced by a root item. A root item can be either the starting point of the program execution or a particular function. If the element is being referenced, it marks the object. All other objects, which are not referenced, are then classified as <strong>dead</strong> objects.</li>
<li><strong>The relocating phase</strong>: In the relocating phase, the garbage collector moves all the objects that are being referenced, groups them together, and then updates the memory address for each of the next objects in the memory heap.<br/>
In addition to this, the garbage collector also classifies objects that are being used in the application to one of the different generations.</li>
<li><strong>The compacting phase</strong>: In the compacting phase, the garbage collector destroys the dead objects classified in the previous phase and reclaims their memory. </li>
</ul>
<p>The entire process that the garbage collector undertakes can lead to a performance impact on the application. This is due to the fact that during the program execution, the garbage collector needs to make sure that the references in the heap are not changed during its run. This means that all the other threads of the application are paused while the run is in progress. </p>
<p class="mce-root"/>
<p>Fortunately, this situation does not arise often as the garbage collector starts cleaning only when the memory available for the application execution is low. Therefore, while the memory is high, the collection algorithm does not kick in. Additionally, as explained while we were discussing generations, when the garbage collection starts, it first checks the generation 0 heap objects. If they survive the cleanup, they are promoted to the next generation. For objects in the higher generations, the garbage collector assumes that the objects in higher generations will probably be used in the application for a longer period of time.</p>
<p>In the next section, we will look at how we can explicitly call the garbage collection method in C#.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling garbage collection</h1>
                
            
            
                
<p>Although it's not recommended, and we hardly find any reason or circumstance where we seldom need to call the garbage collector explicitly during the program execution, we can use the following syntax to execute the <kbd>Collect</kbd> method in garbage collection. The following is the code implementation for this:</p>
<pre>GC.Collect();<br/>GC.WaitForPendingFinalizers();</pre>
<p><kbd>GC</kbd> is present in the system namespace. The <kbd>Collect</kbd> method executes the mark-compact algorithm, which we discussed in the previous section. The <kbd>WaitForPendingFinalizers</kbd> method pauses or suspends the current thread until the garbage collector finishes its execution. </p>
<p>Now that we have a fair understanding of how garbage collection works in C#, we will look at how we can perform memory management for unmanaged objects or unmanaged code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing unmanaged resources</h1>
                
            
            
                
<p>The garbage collection provided by the .NET Framework is good enough when we are dealing with managed objects. However, there are several instances in which we need to use unmanaged resources in our code. Some of these instances include the following:</p>
<ul>
<li>When we need to access OS memory using pointers</li>
<li>When we are doing I/O operations related to file objects</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In each of these circumstances, the garbage collector does not explicitly free up the memory. We need to explicitly manage the release of such resources. If we do not release such resources, then we may end up with problems related to memory leaks in the application, locks on OS files, leaks on connection threads to resources such as databases, and more. </p>
<p>To avoid these situations, C# provides finalization. Finalization allows us to cleanup unmanaged code in a class before the garbage collector is invoked.</p>
<p>Please note that when using finalization, we cannot control when the code specified in finalization will be called. It's up to the garbage collector to determine when the object is no longer required. However, what we are sure of is that the finalization code will be called before the object gets cleaned up by the garbage collector. </p>
<p>To declare a finalizer in a class, we use the <kbd>~</kbd> syntax. The following is the code implementation we use to declare a finalizer for a particular class in C#:</p>
<pre>public class SampleFinalizerClass<br/>{<br/>     ~SampleFinalizerClass()<br/>     {<br/><br/>     }<br/>}</pre>
<p>In the preceding code example, we have declared a <kbd>SampleFinalizerClass</kbd> syntax. In order to clean up unmanaged resources in the class, we have declared a finalizer. The name of the finalizer is the same as that of the class but is appended with a <kbd>~</kbd>.</p>
<p>In Finalizer, we can do things such as destroying pointer objects, releasing connections on files, releasing connection threads to databases, and more.</p>
<p>Now, although using the <kbd>Finalizer</kbd> keyword does clean up  unmanaged code before the object is destroyed by the garbage collector, it does introduce some extra overhead for the garbage collector. Let's examine the following example in order to understand the reason behind this overhead.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The finalization mechanism</h1>
                
            
            
                
<p>In this section, we will understand how the garbage collector performs finalization in the .NET Framework. To do finalization, it maintains two queues in the system:</p>
<ul>
<li><strong>The finalization queue</strong>: The finalization queue is a data structure maintained by the garbage collector, which contains a reference to all the objects in a managed heap that have implemented the finalize method. Using this queue, the garbage collector essentially identifies all the objects that it needs to call the finalize method for in order to clean up the unmanaged code before the object can itself be destroyed. </li>
<li><strong>The</strong> <strong>fReachable queue</strong>: The <kbd>fReachable</kbd> queue is a data structure maintained by the garbage collector. It contains a reference to all the objects in the managed heap, which, even though they don't have any reference with the application root, can be deleted. However, before deleting them, it must call the finalize method to clean up the unmanaged code. </li>
</ul>
<p>Let's try and understand this with the following example. Suppose we have an application wherein we have declared an object class, <kbd>A</kbd>, which has the finalize method. All other objects don't have the finalize method.</p>
<p>Please refer to the following representational diagram of the different structures that could be in the garbage collector:</p>
<div><img src="img/2dedb77c-e354-4a23-a698-642ff8bf6778.png" style=""/></div>
<p class="mce-root"/>
<p>These structures can be described as follows:</p>
<ul>
<li><strong>Program Scope</strong>: This represents the different objects that may be in the scope of the application root or, in other words, are being used in the particular block of the program.</li>
<li><strong>Managed Heap</strong>: This represents the heap memory structure maintained by the garbage collector to allocate memory to the objects present in the program scope. There are two divisions in the managed heap. One is <strong>Generation 0</strong>, which is used for newly created short-lived objects, and another is <strong>Generation 1</strong>, which is used to save long-lived objects.</li>
<li><strong>Finalization Queue</strong>: As indicated previously, this will contain a reference to all the objects in a managed heap that have an implementation of the finalize method.</li>
<li><strong>fReachable Queue</strong>: As indicated previously, this will contain a reference to all the objects in a managed heap for which, although they are not used in the program scope, the garbage collector needs to call the finalize method before their memory can be reclaimed.</li>
</ul>
<p>Take a look at the following steps:</p>
<ol>
<li>Declare the following two classes: <kbd>SampleFinalizeClass</kbd> and <kbd>SampleNoFinalizeClass</kbd>. Please note that the <kbd>SampleFinalizeClass</kbd> class has a finalize method:</li>
</ol>
<pre style="padding-left: 60px">public class SampleFinalizerClass<br/>{<br/>     ~SampleFinalizerClass()<br/>     {<br/>     }<br/>}<br/>public class SampleNoFinalizeClass<br/>{<br/>}</pre>
<ol start="2">
<li>Create three objects; one for <kbd>SampleFinalizerClass</kbd> and two for <kbd>SampleNoFinalizerClass</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">SampleFinalizerClass b = new SampleFinalizerClass();<br/>SampleNoFinalizeClass c = new SampleNoFinalizeClass();<br/>SampleNoFinalizeClass d = new SampleNoFinalizeClass();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root" style="padding-left: 60px">As objects <kbd>b</kbd>, <kbd>c</kbd>, and <kbd>d</kbd> are newly created objects, they will be added to generation 0 in the managed heap. While doing so, the garbage collector will also recognize that object <kbd>b</kbd> needs to have an additional call of the finalize method before it can be cleared. It will make this entry in the finalization queue by adding a reference to object <kbd>b</kbd>. The following diagram indicates what this would look like: </p>
<div><img src="img/129f5e99-00bb-45ef-b767-9b1276a74486.png" style=""/></div>
<ol start="3">
<li>Pass the execution to another function by passing it to object <kbd>c</kbd>. The following is the code snippet for this:</li>
</ol>
<pre style="padding-left: 60px">GarbageCollectorFinalize(c);<br/>// Please note that in the example cs file, these two lines will be in the different blocks of the program<br/>static private void GarbageCollectorFinalize(SampleNoFinalizeClass a)<br/>{<br/>}</pre>
<p>Now, suppose that, during program execution when the control is at the <kbd>GarbageCollectorFinalize</kbd> function, the garbage collector gets called. The garbage collector will identify that object <kbd>d</kbd> is no longer required and, therefore, its memory can be reclaimed. However, object <kbd>c</kbd> is being still referenced. Therefore, it will make an assumption that this could be a long-lived object and will thus promote the object to generation 1. </p>
<p>For object <kbd>b</kbd>, it will recognize that it's not referenced now; however, it does have a finalize method and so cannot be cleaned. Therefore, it keeps object <kbd>b</kbd> in memory for now. However, it removes the entry in the <strong>Finalization Queue</strong> and adds an entry in the <strong>fReachable Queue</strong> so that the variable can be cleared later.</p>
<p class="mce-root"/>
<p>Object <kbd>b</kbd>, as it cannot be removed from memory in the same way as object <kbd>c</kbd>, will also be promoted to <strong>Generation 1</strong>. The following shows this:</p>
<div><img src="img/de4ee592-6c98-4834-900d-ae02780f3f3b.png" style=""/></div>
<p>This illustrates the following:</p>
<ul>
<li>Even though object <kbd>b</kbd> may not still be required, it will be persisted for a longer period of time in the memory.</li>
<li>As in the previous example, the garbage collector will need to execute another iteration in order to clear these objects from the memory.</li>
<li>Unused objects that are implementing finalize may be moved to a higher generation.</li>
</ul>
<p>Due to these reasons, it's highly advisable that whenever we need to declare an object that has the finalize method, we must implement the <kbd>IDisposable</kbd> interface.</p>
<p>Before we go on to look at the <kbd>IDisposable</kbd> interface, let's take a look at the following code implementation illustrating how the <kbd>Finalizer</kbd> function works in C#:</p>
<ol>
<li>Consider the following code implementation, in which we declare a <kbd>Finalizer</kbd> class and then add a <kbd>Finalizer</kbd> function to it:</li>
</ol>
<pre style="padding-left: 60px">public class Finalizer<br/>{<br/>     public Finalizer()<br/>     {<br/>         Console.WriteLine("Creating object of Finalizer");<br/>     }<br/>     ~Finalizer()<br/>     {<br/>         Console.WriteLine("Inside the finalizer of class Finalizer");<br/>     }<br/> }</pre>
<p style="padding-left: 60px">Note that we have added text in both the <kbd>Finalizer</kbd> class constructor and in the <kbd>Finalizer</kbd> method.</p>
<ol start="2">
<li>Use the following code snippet to create an object of this class. Additionally, note that we have set a <kbd>null</kbd> value to the object. Setting a <kbd>null</kbd> value signifies that the object is no longer required in the application: </li>
</ol>
<pre style="padding-left: 60px">Finalizer f = new Finalizer();<br/>f = null;<br/>Console.ReadLine(); </pre>
<p style="padding-left: 60px">Note that, by using the <kbd>Console.ReadLine()</kbd> syntax, we are preventing the application from terminating. We have done this to analyze the output coming from the program. When we execute <kbd>.exe</kbd>, we get the following output:</p>
<div><img src="img/a53d7d64-7390-42c8-8af3-05d901e498b3.png"/></div>
<p style="padding-left: 60px">In the preceding output, we are only getting the message from the constructor of the <kbd>Finalizer</kbd> class. Even though the object has been set as <kbd>null</kbd>, the finalizer of object <kbd>f</kbd> has not been executed yet.</p>
<p style="padding-left: 60px">This is due to the fact that we cannot specify when the garbage collector kicks in. Now, press <em>Enter</em> in the <kbd>.exe</kbd> execution. Notice that the program stops the execution; however, before it terminates, the finalizer is called to reclaim the memory of object <kbd>f</kbd>:</p>
<div><img src="img/6e03c708-2376-4ed3-9868-a081b3e63723.png"/></div>
<p style="padding-left: 60px">This proves we were right about finalizers, which we discussed earlier in this section. Even though object <kbd>f</kbd> was no longer needed in the application, it was still kept in the managed heap memory until the garbage collector executed the <kbd>Finalizer</kbd> method. </p>
<p class="mce-root"/>
<ol start="3">
<li>Now, add the following code to implicitly call the garbage collector and note that the finalize method is called immediately:</li>
</ol>
<pre style="padding-left: 60px">Finalizer f = new Finalizer();<br/>f = null;<br/>GC.Collect();<br/>Console.ReadLine();</pre>
<p>If we execute the program now, we will see the output from the finalizer of the <kbd>Finalizer</kbd> class, illustrating that the garbage collector immediately reclaimed the memory:</p>
<div><img src="img/42ecd167-1a77-40a3-a227-2845fd6b2624.png" style=""/></div>
<p>When we call the <kbd>GC.Collect()</kbd> method, internally, it calls the finalizers for all the objects that are no longer required. Thus we get the message, Inside the finalizer of class Finalizer.</p>
<p>In the preceding code example, we discovered that if we use <kbd>Finalizer</kbd>, we may have some performance implications in the program. Although we can use the <kbd>GC.Collect()</kbd> command to implicitly call the garbage collector, even that can cause some lag in the program. To overcome these issues, C# is capable of using the <kbd>IDisposable</kbd> interface in such circumstances. In the next section, we will understand how we can implement this interface and how it helps us achieve better performance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The IDisposable interface</h1>
                
            
            
                
<p>The finalize method, which we examined in the preceding section, has some performance implications for the system. With the <kbd>Finalizer</kbd> method, we are not sure of when the memory will be reclaimed by the garbage collector even after the object is no longer required. This implies that there is a possibility that unused memory will be persisted in a managed heap for longer than the desired amount of time. </p>
<p>With the <kbd>IDisposable</kbd> interface, we can assume control over when the memory is reclaimed for unmanaged resources in the application. The <kbd>IDisposable</kbd> interface in C# only has one method, which is <kbd>Dispose()</kbd>.</p>
<p class="mce-root"/>
<p>In this method, we can perform the same cleanup of unmanaged resources that we did in the <kbd>Finalizer</kbd> method. The following is the code implementation of the <kbd>IDisposable</kbd> interface:</p>
<pre>public class DisposeImplementation : IDisposable<br/>{<br/>     public DisposeImplementation()<br/>     {<br/>         Console.WriteLine("Creating object of DisposeImplementation");<br/>     }<br/>     ~DisposeImplementation()<br/>     {<br/>         Console.WriteLine("Inside the finalizer of class <br/>                            DisposeImplementation");<br/>     }<br/>     public void Dispose()<br/>     {<br/>     }<br/> }</pre>
<p>Notice that in the preceding example, we have declared a <kbd>DisposeImplementation</kbd> class and have implemented a <kbd>IDisposable</kbd> interface in this class. </p>
<p>As we are implementing the <kbd>IDisposable</kbd> interface, we have defined a <kbd>Dispose</kbd> function in the same class. </p>
<p>With the <kbd>Dispose</kbd> method, we need to clear all the unmanaged resources we are using in this class. While this approach is reliable in terms of when the resources will be reclaimed, there are some points we need to understand:</p>
<ul>
<li>It's the programmer's responsibility is to ensure that the <kbd>Dispose</kbd> method is called to reclaim the memory.</li>
<li>If the programmer misses calling the <kbd>Dispose</kbd> method, there is a chance that the unmanaged resources will not be cleared.</li>
</ul>
<p>Therefore, as a good programming practice, we should use both the <kbd>Finalize</kbd> and <kbd>Dispose</kbd> methods together in any implementation related to unmanaged resources. This will ensure that if the programmer has missed calling the <kbd>Dispose</kbd> method, then the <kbd>Finalize</kbd> method will always be there to reclaim the memory of the unmanaged resources. </p>
<p>Additionally, in order to ensure that we do not duplicate the work in <kbd>Finalize</kbd> and <kbd>Dispose</kbd>, we can use the approach illustrated in the following example.</p>
<p class="mce-root"/>
<p>For the same class that we used in the preceding implementation, we will declare an <kbd>isDisposed</kbd> field. The value of this field is set to <kbd>false</kbd>. In the <kbd>Dispose</kbd> method, we will reset its value to <kbd>true</kbd> to indicate that the cleanup for the unmanaged resources has occurred. </p>
<p>Now, to make sure that we do not do a cleanup of the resources a second time, we will check the value of this property in the <kbd>Finalize</kbd> method. If the <kbd>Dispose</kbd> property is set to <kbd>true</kbd>, indicating that cleanup has already occurred, then nothing will happen. If the <kbd>Dispose</kbd> property is set to <kbd>false</kbd>, indicating that cleanup has not occurred, then finalize will do a cleanup of the resources just as before. The following is the code implementation for this:</p>
<pre>public class DisposeImplementation : IDisposable<br/>{<br/>     private bool isDisposed = false;<br/>     public DisposeImplementation()<br/>     {<br/>         Console.WriteLine("Creating object of DisposeImplementation");<br/>     }<br/>     ~DisposeImplementation()<br/>     {<br/>         if(!isDisposed)<br/>         {<br/>             Console.WriteLine("Inside the finalizer of class <br/>                                DisposeImplementation");<br/>             this.Dispose();<br/>         }<br/>     }<br/>     public void Dispose()<br/>     {<br/>         isDisposed = true;<br/>         Console.WriteLine("Inside the dispose of class <br/>                            DisposeImplementation");<br/>         /// Reclaim memory of unmanaged resources<br/>     }<br/> }</pre>
<p>Now, let's demonstrate these classes in two ways. First, we will call the <kbd>Dispose</kbd> method before calling the <kbd>GC.Collect()</kbd> method.</p>
<p class="mce-root"/>
<p>Call the <kbd>Dispose</kbd> method as follows:</p>
<pre>DisposeImplementation d = new DisposeImplementation();<br/>d.Dispose();<br/>d = null;<br/>GC.Collect();<br/>Console.ReadLine(); </pre>
<p>In the preceding code, in the <kbd>Dispose</kbd> method we are setting the value in the flag to <kbd>true</kbd>. Apart from setting the flag, we will also be reclaiming memory from unmanaged resources. Therefore, when we call the finalize method, as the value in the flag is already set to <kbd>true</kbd>, the block inside the finalize method does not get executed.</p>
<p>The following is the output:</p>
<div><img src="img/b3a46fce-6a6a-480c-8b1a-7c0a823b814b.png" style=""/></div>
<p>Now, let's consider another scenario in which the programmer forgets to call the <kbd>Dispose</kbd> method explicitly. The following is the code snippet for this:</p>
<pre>DisposeImplementation d = new DisposeImplementation();<br/>//d.Dispose();<br/>d = null;<br/>GC.Collect();<br/>Console.ReadLine();</pre>
<p>In the preceding code, we are not calling the <kbd>Dispose</kbd> method, so the value in the flag is set to <kbd>false</kbd>. Therefore, when the garbage collector executes the finalize method in object <kbd>d</kbd>, it also executes the code block to explicitly call the <kbd>Dispose</kbd> method for the same object. </p>
<p>The following is the output for this:</p>
<div><img src="img/a52c72d8-0acc-43dd-ae4e-40a8a00a9e4d.png" style=""/></div>
<p class="mce-root"/>
<p>There is also a property that we can use to suppress calling the finalize method in the <kbd>Dispose</kbd> method. We can use this when we are sure that we don't need to verify the resources in the finalize method. The following is the syntax we can use to suppress calling the finalize method:</p>
<pre>public void Dispose()<br/>{<br/>     isDisposed = true;<br/>     GC.SuppressFinalize(this);<br/>     Console.WriteLine("Inside the dispose of class <br/>                        DisposeImplementation");<br/>     /// Reclaim memory of unmanaged resources<br/>}</pre>
<p>In the preceding code block, we have used <kbd>GC.SupressFinalize()</kbd> for the current object. This will remove the references from the finalization queue, ensuring that the finalize method is never triggered for the current object. Therefore, if we execute the same input, we get the following output:</p>
<div><img src="img/7fc6532b-860d-4595-821f-bd9f4c922543.png"/></div>
<p>Using this pattern, we can ensure that unmanaged resources are released from memory without compromising the performance of the application.</p>
<p class="mce-root">In the next section, we will look at using the <kbd>using</kbd> block as a good practice for when we are dealing with any classes implementing the <kbd>IDisposable</kbd> interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The using block</h1>
                
            
            
                
<p>Any program is bound to have errors. There could be several unforeseen circumstances where our written logic will throw exceptions. </p>
<p>If we are using unmanaged resources, then unhandled exceptions can be very harmful. They can lead to issues related to dangling memory, unclosed connections to file objects, and more. </p>
<p>For example, consider the preceding example, where we have written a <kbd>Dispose</kbd> method to free up the memory. Let's say we have a scenario in which the application throws an exception before the <kbd>Dispose</kbd> method is called. In this case, the application will never have a chance to reclaim the memory occupied by the unmanaged resources. </p>
<p class="mce-root"/>
<p>To avoid such scenarios, C# lets us use the <kbd>using</kbd> block in our code. When we use the <kbd>using</kbd> block, no matter what happens inside the <kbd>using</kbd> block, the <kbd>Dispose</kbd> method is always called. Let's understand this with the following code implementation:</p>
<pre>using (DisposeImplementation d = new DisposeImplementation())<br/>{<br/> <br/>}<br/>Console.ReadLine();<br/>GC.Collect();<br/>Console.ReadLine();</pre>
<p>Note that in the preceding code block, we are using the same <kbd>DisposeImplementation</kbd> class but are using it inside the <kbd>using</kbd> block. We are not explicitly nullifying the <kbd>d</kbd> object, to indicate to the garbage collector that it's no longer needed. Additionally, we are not explicitly calling the <kbd>Dispose</kbd> method to free up the unmanaged resources. Yet, when we run the program, we get the following output:</p>
<div><img src="img/87a2f90f-36bc-42ff-a009-a13b405708e1.png" style=""/></div>
<p>The <kbd>using</kbd> block handles it automatically. The <kbd>using</kbd> block ensures that as soon as the control is out of the <kbd>using</kbd> block, it will call the <kbd>Dispose</kbd> method for the object. </p>
<p>Now, let's consider a scenario in which we get an error in the <kbd>using</kbd> block. For the sake of explanation, we will introduce an error manually by throwing an exception.</p>
<p>The following is the code snippet for this:</p>
<pre>using (DisposeImplementation d = new DisposeImplementation())<br/>{<br/>     throw new Exception("in here");<br/>}</pre>
<p>If we execute the code, we get the following result:</p>
<div><img src="img/83163c92-bfb7-450a-afb7-afed5615d21b.png"/></div>
<p class="mce-root"/>
<p>Now, in the code, we have thrown an exception that is not being handled. However, even then, the <kbd>Dispose</kbd> method of the <kbd>DisposeImplementation</kbd> object is called before the application errors out due to the exception. If we don't use the <kbd>using</kbd> block, this will not happen. To illustrate this, remove the <kbd>using</kbd> block and throw the same exception in the application. The following is the code implementation for this:</p>
<pre>DisposeImplementation d = new DisposeImplementation();<br/>throw new Exception("in here");</pre>
<p>In the preceding block, we have removed the <kbd>using</kbd> statement and are throwing an unhandled exception after the object is created. If we execute the code, we get the following output:</p>
<div><img src="img/50af78a9-ada0-4830-85a2-ed16a9417456.png"/></div>
<p>As you can see in the preceding screenshot, during the program execution the <kbd>Dispose</kbd> method is never called for the <kbd>DisposeImplementation</kbd> object. This illustrates that, as a best practice, we must always use a <kbd>using</kbd> block for classes implementing the <kbd>IDisposable</kbd> interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned about memory management for unmanaged resources in C#. We revised the differences between managed code and unmanaged code in C#. We then looked at garbage collectors and delved into how they work. We learned about the memory storage structure of a managed heap, which it uses internally to allocate memory to different objects created during program execution. We learned about the internal divisions of generations, which the garbage collector uses internally to improve the performance of the system. We also learned about the mark-compact algorithm, which the garbage collector uses. We then explored how we can invoke garbage collection implicitly.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Following this, we went on to understand concepts about memory management for unmanaged objects. We learned about the <kbd>Finalize</kbd> method and how it facilitates memory management of an unmanaged object. We learned about the performance implications of using the <kbd>Finalize</kbd> method, and then we went on to understand how the <kbd>IDisposable</kbd> interface helps overcome its shortcomings. We learned about how we implement the <kbd>IDisposable</kbd> interface in a class and how we can combine both the <kbd>Dispose</kbd> and <kbd>Finalize</kbd> methods to improve the performance of the system. Finally, we learned about using the <kbd>using</kbd> block for classes that implement the <kbd>IDisposable</kbd> interface.</p>
<p>In the next chapter, we will look at how reflection works in C#. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>A garbage collector can reclaim memory for unmanaged resources used in C# code.
<ol type="a">
<li>True</li>
<li>False</li>
</ol>
</li>
<li>Which of the following can be used to make sure the <kbd>Finalize</kbd> method is not called?<br/>
<ol type="a">
<li><kbd>GC.Collect();</kbd></li>
<li><kbd>GC.SupressFinalize(this);</kbd></li>
<li><kbd>GC.WaitForPendingFinalizers();</kbd></li>
<li>None of these</li>
</ol>
</li>
</ol>
<p>                3. Which one of the following statements is incorrect?</p>
<ul>
<li style="list-style-type: none">
<ol type="a">
<li><kbd>Finalize</kbd> can lead to performance implications due to the object remaining in memory longer than required.</li>
<li>Generation 0 is used to save objects that are short-lived.</li>
<li>Even if we use the <kbd>IDisposable</kbd> interface, we will not be able to suppress the calls that the garbage collector performs to execute the code in the <kbd>Finalize</kbd> method.</li>
<li>The <kbd>using</kbd> block ensures that the <kbd>Dispose</kbd> method is called by the garbage collector automatically.</li>
</ol>
</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Answers</h1>
                
            
            
                
<ol>
<li><strong>b</strong></li>
<li><strong>b</strong></li>
<li><strong>c, using SupressFinalize method we will be able to remove the reference from the finalize queue thus the finalize method will not be executed.</strong></li>
</ol>


            

            
        
    </body></html>