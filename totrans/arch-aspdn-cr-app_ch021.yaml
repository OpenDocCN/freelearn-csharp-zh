- en: 20 Modular Monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file172.png)'
  prefs: []
  type: TYPE_IMG
- en: In the ever-evolving software development landscape, choosing the right architecture
    is like laying the foundation for a building. The architecture dictates how the
    software is structured, impacting its scalability, maintainability, and overall
    success. Traditional monolithic architecture and microservices have long been
    the dominant paradigms, each with advantages and challenges.However, a new architectural
    style has been gaining traction—Modular Monoliths. This approach aims to offer
    the best of both worlds by combining the simplicity of monoliths with the flexibility
    of microservices. It serves as a middle ground that addresses some of the complexities
    associated with microservices, making it particularly appealing for small to medium-sized
    projects or teams transitioning from a traditional monolithic architecture.
  prefs: []
  type: TYPE_NORMAL
- en: I wrote an article about this in 2017 entitled *Microservices Aggregation*.
    I recently read the name *Modular Monolith* and loved it better. This architectural
    style is gaining traction, yet it is not entirely new. The Modular Monolith style
    is a way to modularize and organize an application, lowering our chances of creating
    a big ball of mud.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This chapter aims to provide a comprehensive understanding of Modular Monoliths.
    We delve into its core principles, advantages, and key components and explore
    when and how to implement this architecture. We build upon our nano e-commerce
    application to get hands-on insights into Modular Monoliths'' practical applications.
    Additionally, we discuss how they compare with other architectural styles to help
    you make informed decisions for your next projects.By the end of this chapter,
    you should have a solid grasp of Modular Monoliths, why they might be the right
    choice for your project, and how to implement them.In this chapter, we cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Modular Monolith?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of Modular Monoliths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key Components of a Modular Monolith
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Modular Monolith
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project—Modular Monolith
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning to Microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges and Pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by exploring what is a Modular Monolith.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Modular Monolith?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Modular Monolith is an architectural style that aims to combine the best
    aspects of traditional monolithic architectures and microservices. It organizes
    the software application into well-defined, loosely coupled modules. Each is responsible
    for a specific business capability. However, unlike microservices, all these modules
    are deployed as a single unit like a monolith.The core principles of a Modular
    Monolith are:'
  prefs: []
  type: TYPE_NORMAL
- en: Treat each module as a microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the application as a single unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the fundamental principles of a successful microservice as studied
    in *Chapter 19*, *Introduction to Microservices Architecture*:'
  prefs: []
  type: TYPE_NORMAL
- en: Each microservice should be a cohesive unit of business.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each microservice should own its data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each microservice should be independent of the others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a nutshell, we get the best of both worlds. Yet, understanding how a Modular
    Monolith compares with other architectural styles is crucial for making informed
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: What are traditional Monoliths?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a traditional monolithic architecture, we build the application as a single,
    indivisible unit. This leads to the functionalities being tightly coupled together,
    making it difficult to make changes or scale specific features. This approach
    makes creating a big ball of mud easier, particularly when the team invests little
    effort in domain modeling and analysis before and during development.On top of
    that, while this approach is simple and straightforward, it lacks the flexibility
    and scalability of more modern architectures.
  prefs: []
  type: TYPE_NORMAL
- en: A monolith does not have to be indivisible, yet most end up this way because
    it is easy to create tight coupling in a single application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s look at microservices next.
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microservices architecture, on the other hand, takes modularity to the extreme.
    Each service is a completely independent unit, running in its own environment.
    Microservices architecture allows for high scalability and flexibility but comes
    at the cost of increased operational complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 19*, *Introduction to Microservices Architecture*, covers this topic
    more in-depth.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The following sections delve deeper into this emerging architectural style,
    starting with its advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Modular Monoliths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the best things about Modular Monoliths is that they are easy to manage.
    You don't have to worry about many moving parts like with microservices. Everything
    is in one place but still separated into modules. This makes it easier for us
    to keep track of things and to work with them.With Modular Monoliths, each module
    is like its own small project. We can test, fix, or improve a module without affecting
    the others. This is great because it lets us focus on one thing at a time, which
    improves productivity by lowering the cognitive load required to work on that
    feature.When it's time to release the software, we only have one application to
    deploy. Even though it has many modules, we treat them like one deployable unit.
    This makes managing deployments much more straightforward as we don’t have to
    juggle multiple services like we would with microservices.Modular Monoliths can
    save us money because we don't need as many resources since we deploy a single
    monolith. Because of that, we don't need a team to manage and run complicated
    infrastructure. We don't need to worry about distributed tracing between our services,
    which reduces the upfront monitoring cost. This deployment style is highly beneficial
    when starting a project with a small team or if the team is not proficient with
    microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Modular Monoliths can still be valuable even if you are part of a large team,
    part of a larger organization, or have experience with microservices architecture.
    It is not one or the other kind of scenario.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As we just explored, Modular Monoliths bring many advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The reduced operational complexity makes deploying a complex application as
    a single unit easier than microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve our development and testing experience because of their simplicity,
    improving our efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are easier to manage than most traditional monoliths because modules are
    well segregated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are more cost-effective than microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following section looks at what makes up a Modular Monolith.
  prefs: []
  type: TYPE_NORMAL
- en: Key Components of a Modular Monolith
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to know about Modular Monoliths is that they are composed of
    different parts called **modules**. Each module is like a mini-app that performs
    a specific job. This job is related to a particular business capability. A business
    capability comes from the business domain and aims at a cohesive group of scenarios.
    Such a group is called a bounded context in DDD. Think of each module as a microservice
    or a well-defined chunk of the domain.That separation means everything we need
    to complete a specific task is in one module, which makes it easier for us to
    understand and work on the software because we don’t have to jump from one place
    to another to get things done. So, if one module needs an update or has a problem,
    we can fix it without touching the others. This segregation is also perfect for
    testing since we can test each module in isolation to ensure it works well. For
    example, one module might handle a shopping cart while another takes care of the
    shipping, but we piece all modules together in a final aggregated application.
  prefs: []
  type: TYPE_NORMAL
- en: We can create the modular monolith as a single project. However, in a .NET-specific
    environment, when each module comprises one or more assemblies, it is harder to
    create unwanted coupling between modules. We explore this in the project we are
    about to build.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The **module aggregator**—the monolith—is responsible for loading and serving
    the modules as if they were just one application.Even though each module is independent,
    they still need to talk to each other sometimes. For example, the product catalog
    module might need to tell the shopping cart module that an employee has added
    a new product to the catalog. There are many ways to make this communication happen.
    One of the best ways to keep a low coupling level between the modules is to leverage
    event-driven architecture. On top of loose coupling, this opens doors like scaling
    the Modular Monolith by migrating one or more modules to a microservices architecture;
    more on that later.Here''s a diagram that represents these relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.1: Diagram representing the relationships between the module aggregator,
    the modules, and an event broker.](img/file173.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.1: Diagram representing the relationships between the module aggregator,
    the modules, and an event broker.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the key components of a Modular Monolith, the next
    section discusses planning and implementing one.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Modular Monolith
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Planning is essential before building a Modular Monolith. We must consider
    what each module does and how modules work together. A good plan helps us avoid
    problems later on.Choosing the right tools to create a lean stack is also essential.
    The good news is that we don''t need to define a large shared stack since each
    module is independent. Like a slice in Vertical Slice architecture, each module
    can determine its patterns and data sources. Yet, we must define a few common
    elements to assemble a Modular Monolith successfully. Here are a few items to
    consider to improve the chances of success of a Modular Monolith:'
  prefs: []
  type: TYPE_NORMAL
- en: The modules share a URL space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules share the configuration infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules share a single dependency injection object graph (one container).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules share the inter-module communication infrastructure (event broker).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can mitigate the first two elements using the module name as a discriminator.
    For example, using the `/{module name}/{module space}` URI space would yield the
    following results (`products`, `baskets`, and `customers` are modules):'
  prefs: []
  type: TYPE_NORMAL
- en: '`/products`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/products/123`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/baskets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/customers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the module name as the top-level key of the configuration also makes
    it easy to avoid conflicts, like `{module name}:{key}`, or like the following
    JSON (say from the `appsettings.json` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can mitigate the last two elements by managing the shared code in a certain
    way. For example, limiting the amount of shared code reduces the chances of conflict
    between the modules. Yet, multiple modules globally configuring ASP.NET Core or
    a third-party library can result in conflicts; centralizing those configurations
    into the aggregator instead and treating them as a convention will help mitigate
    most issues. Cross-cutting concerns like exception handling, JSON serialization,
    logging, and security are great candidates for this.Lastly, sharing a single way
    to communicate between modules and configuring it in the aggregator will help
    mitigate the communication issues.Let's start planning the project next.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Planning is a crucial part of any software. Without a plan, you increase your
    chances of building the wrong thing. A plan does not guarantee success, but it
    improves your chances. Overplanning is the other side of this coin. It can lead
    to **analysis paralysis**, which means you may never even deliver your project
    or that it will take you so long to deliver it that it will be the wrong product
    because the needs changed along the way and you did not adapt.Here''s a high-level
    way to accomplish planning a Modular Monolith. You don''t have to execute all
    the steps in order. You can perform many of them iteratively, or multiple people
    or teams can even work on them in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyse and model the domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify and design the modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the interactions between modules and design the integration events
    that cover those interactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we are done planning, we can develop and operate the application. Here
    are a few high-level steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build and test the modules in isolation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and test the module aggregator application that integrates one or more
    modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy, operate, and monitor the monolith.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implementing a Modular Monolith, like any program, is a step-by-step process.
    We plan, build, test, and then deploy it. Each part is simple enough on its own,
    and when we piece all of them together, we get an easy-to-maintain system. Even
    if continuously improving the application and refining the analysis and the model
    over time should yield the best results, having a good idea of the high-level
    domain—the modules—and at least a vague view of their interactions before starting
    will help avoid mistakes and potentially significant refactoring further down
    the road. Here’s a general representation of this process:'
  prefs: []
  type: TYPE_NORMAL
- en: ∞
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 20.2: A partial Agile and DevOps view of the Modular Monolith phases'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we plan our nano e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the domain
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we continue to iterate over the nano e-commerce application we built in
    *Chapter 18* and *Chapter 19*, the domain analysis will be very short. Moreover,
    we are not expanding the application further than products and baskets because
    the application is already too large to fit in a single chapter. Of course, this
    time, we are making it a Modular Monolith. Here are the high-level entities and
    their relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.3: The high-level entities of our nono e-commerce app and their
    relationships](img/file174.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.3: The high-level entities of our nono e-commerce app and their relationships'
  prefs: []
  type: TYPE_NORMAL
- en: As the diagram shows, we have a `Product` entity that could benefit from more
    details like categories, hence the `...` box. We also have the `BasketItem` entity
    we use for people to save their shopping baskets to the database. Finally, a `Customer`
    entity represents the person to whom a shopping basket belongs.
  prefs: []
  type: TYPE_NORMAL
- en: We did not implement a `Customer` class, yet the customer is conceptually present
    through the `CustomerId` property.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we split this subset of the domain into modules.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have identified the entities, it is time to map them into modules.
    Let’s start with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.4: Modules (bounded context) separation and entities relationships.](img/file175.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.4: Modules (bounded context) separation and entities relationships.'
  prefs: []
  type: TYPE_NORMAL
- en: As expected, we have a product catalog, a shopping basket, and a customer management
    modules. What’s new here is the relationships between the entities. The catalog
    mainly manages the `Product` entity, yet the shopping basket needs to know about
    it to operate. The same logic applies to the `Customer` entity. In this case,
    the shopping basket only needs to know the unique identifier of each entity, but
    another module could need more information.Based on that high-level view, we need
    to create three modules. In our case, we continue with only two modules. In an
    actual application, we’d have more than three modules since we’d have to manage
    the purchases, the shipping, the inventory, and more.Let’s look at the interactions
    between the modules.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the interactions between modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Based on our analysis and limited to the two modules we are building, the shopping
    basket module needs to know about the products. Here’s our `BasketItem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class shows that we only need to know about the unique product
    identifier. So, with an event-driven mindset, the shopping basket module wants
    to be notified when:'
  prefs: []
  type: TYPE_NORMAL
- en: A product is created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A product is deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With those two events, the basket module can manage its cache of products and
    only allow customers to add existing items to their shopping basket. It can also
    remove items from customers’ shopping baskets when unavailable. Here’s a diagram
    representing these flows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.5: The integration event flows between the catalog and the basket
    modules.](img/file176.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.5: The integration event flows between the catalog and the basket
    modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have analyzed the domain and the modules, before building anything,
    let's define our stack.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know we are using ASP.NET Core and C#. We continue leveraging minimal APIs,
    yet MVC could achieve the same. We also continue to leverage *EF Core*, *ExceptionMapper*,
    *FluentValidation*, and *Mapperly*. But what about the modules and the other shared
    aspects of the project? Let's have a look.
  prefs: []
  type: TYPE_NORMAL
- en: The module structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are using a flexible yet straightforward module structure. You can organize
    your projects however you like; this is not a prescriptive approach. For example,
    you can get inspired by other architectural styles, like Clean Architecture, or
    invent your own based on your own experience, context, and work environment.In
    our case, I opted for the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `applications` directory contains the deployable applications, like the
    aggregator. We could add user interfaces in this directory or other deployable
    applications, like the BFF we built in Chapter 19\. Each application is contained
    within its own subdirectory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `modules` directory contains the modules, each within its own subdirectory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `shared` directory contains the shared projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In real-world software, we could extend this setup and add `infrastructure`,
    `docs`, and `pipelines` directories to store our Infrastructure as Code (IaC),
    documentation, and CI/CD pipelines next to our code.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What I like about this mono-repo-inspired structure is that each module and
    application is self-contained. For example, the aggregator’s API, contracts, and
    tests are next to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.6: The aggregator’s directory and project hierarchy.](img/file177.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.6: The aggregator’s directory and project hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The modules are organized similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.7: The modules'' subdirectories and catalog’s project hierarchy.](img/file178.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.7: The modules'' subdirectories and catalog’s project hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: I kept the REPR prefix since it’s based on Chapter 18’s code, but I changed
    the code structure a bit. In this version, I got rid of the nested classes and
    created one class per file. This follows a more classic .NET convention and allows
    us to extract the API contracts to another assembly. If you remember, in Chapter
    19, the BFF project referenced the two APIs to reuse their `Query`, `Command`,
    and `Response` contracts. We fix this problem through the `Contracts` class library
    projects in this solution.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it a problem? The BFF depends on all the microservices, including their
    logic and dependencies. This is a recipe to introduce unwanted coupling. Moreover,
    since it inherits all the dependencies transitively, it increases its deployment
    size and vulnerability surface; more dependencies and more code means more possibilities
    for a malicious actor to find an exploitable hole.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On top of the API contracts, the `Contracts` projects also contain the integration
    events. We could have separated the API contracts and the integration events if
    the application was larger; in this case, we only have two integration events.
    Design choices must be taken relative to the current project and context.Let’s
    explore the URI space next.
  prefs: []
  type: TYPE_NORMAL
- en: The URI space
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The modules of this application follow the previously discussed URI space:
    `/{module name}/{module space}`. Each module has a `Constants` file at its root
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `ModuleName` constant in the `{module name}ModuleExtensions` files
    to set the URI prefix and tag the endpoints like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, both modules self-register themselves in the correct URI
    space.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply these types of conventions in many different ways. In this case,
    we opted for simplicity, which is the most error-prone, leaving the responsibility
    to the mercy of each module. With a more framework-oriented mindset, we could
    create a strongly typed module contract that gets loaded automatically, like an
    `IModule` interface. The aggregator could also create the root groups and enforce
    the URI space.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we explore the data space.
  prefs: []
  type: TYPE_NORMAL
- en: The data space
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we are following the microservices architecture tenets and each module
    should own its data, we must find a way to ensure our data contexts do not conflict.The
    project uses the EF Core in-memory provider to develop locally. For production,
    we plan on using SQL Server. One excellent way to ensure our `DbContext` classes
    do not conflict with each other is to create one database schema per context.
    Each module has one context, so one schema per module. We don’t have to overthink
    this; we can reuse the same idea as the URI and leverage the module name. So,
    each module will group its tables under the `{module name}` schema instead of
    `dbo` (the default SQL Server schema).
  prefs: []
  type: TYPE_NORMAL
- en: We can apply different security rules and permissions to each schema in SQL
    Server, so we could craft a very secure database model by expanding this. For
    instance, we could employ multiple users possessing minimal privileges, utilize
    different connection strings within the modules, etc.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In code, doing this is reflected by setting the default schema name in the
    `OnModelCreating` method of each `DbContext`. Here’s the `ProductContext` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code makes all `ProductContext`’s tables part of the `products`
    schema. We then apply the same for the basket module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code makes all `BasketContext`’s tables part of the `baskets`
    schema.Due to the schema, both contexts are safe from hindering the other. But
    wait! Both contexts have a `Products` table; what happens then? The catalog module
    uses the `products.products` table, while the basket module uses the `baskets.products`
    table. Different schema, different tables, case closed!
  prefs: []
  type: TYPE_NORMAL
- en: We can apply these notions to more than Modular Monolith as it is general SQL
    Server and EF Core knowledge.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you are using another relational database engine that does not offer schema
    or a NoSQL database, you must also think about this. Each NoSQL database has different
    ways to think about the data, and it would be impossible to cover them all here.
    The important piece is to find a discriminator that segregates the data of your
    modules. At the limit, it can even be one different database per module; however,
    this increases the operational complexity of the application.Next, we explore
    the message broker.
  prefs: []
  type: TYPE_NORMAL
- en: The message broker
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To handle the integration events between the catalog and the basket modules,
    I decided to pick MassTransit. To quote their GitHub project:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MassTransit is a free, open-source distributed application framework for .NET.
    MassTransit makes it easy to create applications and services that leverage message-based,
    loosely-coupled asynchronous communication for higher availability, reliability,
    and scalability.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I picked MassTransit because it is a popular project with 5,800 GitHub stars
    as of 2023 and supports many providers, including in-memory. Moreover, it offers
    many features that are way above our needs. Once again, we could have used anything.
    For example, MediatR could have also done the job.The `REPR.API` project—the aggregator—and
    the modules depend on the following NuGet package to use MassTransit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our usage is very simple; the aggregator registers and configures MassTransit
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted line delegates the registration of event consumers to the basket
    module. The `AddBasketModuleConsumers` method is part of the `BasketModuleExtensions`
    class and contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductEventsConsumers` class manages the two events. The `AddConsumers`
    method is part of MassTransit. We explore the `ProductEventsConsumers` class in
    the project section.
  prefs: []
  type: TYPE_NORMAL
- en: We would register the event consumers of other modules here if we had more.
    Yet the delegation of that registration to each module makes it modular.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we write some C# code to transform our microservices application into
    a Modular Monolith.
  prefs: []
  type: TYPE_NORMAL
- en: Project—Modular Monolith
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project has the same building block as *Chapter 18* and *Chapter 19*, but
    we use the Modular Monolith approach. On top of the previous versions, we leverage
    events to enable the shopping basket to validate the existence of a product before
    allowing customers to add it to their shopping basket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete source code is available on GitHub: [https://adpg.link/gyds](https://adpg.link/gyds)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The test projects in the solution are empty. They only exist for the organizational
    aspect of the solution. As an exercise, you can migrate the tests from *Chapter
    18* and adapt them to this new architectural style.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s start with the communication piece.
  prefs: []
  type: TYPE_NORMAL
- en: Sending events from the catalog module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the catalog to communicate the events that the basket module needs, it
    must define the following new operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Create products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the API contracts we must create in the `REPR.Products.Contracts`
    project to support those two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The API contracts should look very familiar by now and are similar to those
    from previous chapters. We then need the following two event contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The two event classes are also very straightforward, but their name is in the
    past tense because an event happened in the past. So, the module creates the product
    and then notifies its subscribers that a product was created (in the past). Exactly
    like we studied in *Chapter 19*, *Introduction to Microservices Architecture*.
    Moreover, the events are simple data containers, like an API contract—a DTO—is.How
    do we send those events? Let’s have a look at the `CreateProductHandler` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we inject an `IBus` interface from MassTransit in the
    `CreateProductHandler` class. We also inject an object mapper and an EF Core `ProductContext`.
    The `HandleAsync` method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates the product and saves it to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publishes a `ProductCreated` event (highlighted code).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns a `CreateProductResponse` instance based on the new product.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Publish` method sends the event to the configured pipe, which is in memory
    in our case. The code passes a `CancellationToken.None` argument here because
    we don’t want this operation to be canceled by any external force because the
    change is already saved in the database.Because of the mapping code, the publishing
    code may be hard to understand in a book. The `MapToIntegrationEvent` method converts
    a `Product` object to a `ProductCreated` instance, so the `productCreated` variable
    is of type `ProductCreated`. Here’s the *Mapperly* mapper class with that method
    highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `DeleteProductHandler` class follows a similar pattern but publishes the
    `ProductDeleted` event instead.Now, let’s explore how the basket module consumes
    those events.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the events from the basket module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basket module wants to cache existing products. We can achieve this in
    different ways. In this case, we create the following `Product` class that we
    persist in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To make use of it, we must expose the following property from the `BasketContext`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can start to leverage this cache. Firstly, we must populate it when
    the catalog module creates a product and remove that product when deleted. The
    `ProductEventsConsumers` class handles both events. Here’s the skeleton of this
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code represents the two event handlers. The `IConsumer<TMessage>`
    interface contains the `Consume` method. Implementing the interface twice with
    a different `TMessage` generic parameter prescribes implementing the two `Consume`
    methods in the `ProductEventsConsumers` class. Each method handles its own event.When
    a product is created in the product module, the following method is executed in
    the basket module (I removed the logging code for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds a new product to the database if it does not exist.
    If it does exist, it does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: We could add telemetry here to log and flag the conflict and explore how to
    solve it. If the product already exists, the event was received twice, which may
    indicate an issue with our system.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here’s the flow of what happens when an employee creates a new product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.8: A diagram showcasing the sequence of operations when someone
    adds a product to the system.](img/file179.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.8: A diagram showcasing the sequence of operations when someone adds
    a product to the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the operations:'
  prefs: []
  type: TYPE_NORMAL
- en: A client sends a POST request to the API (the aggregator application). The catalog
    module receives the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The catalog creates the product and adds it to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The catalog then publishes the `ProductCreated` event using MassTransit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the basket module, the `Consume` method of the `ProductEventsConsumers` class
    gets called by MassTransit in reaction to the `ProductCreated` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The basket module adds the product's identifier to the database to its materialized
    view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we know how the `ProductEventsConsumers` class handles the `ProductCreated`
    events, let’s explore the `ProductDeleted` events (logging code omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `Consume` method removes the products from people’s shopping baskets
    and the materialized view. If the product does not exist, the method does nothing
    because there’s nothing to handle.A similar flow happens when an employee deletes
    a product from the catalog and publishes a `ProductDeleted` event. The basket
    module then reacts to the event and updates its cache (materialized view).Now
    that we have explored this exciting part of the project, let’s look at the aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the aggregator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The aggregator application is like an empty shell that loads the other assemblies
    and configures the cross-cutting concerns. It references the modules, then assembles
    and boots the application. Here’s the first part of the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code registers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*FluentValidation*; it also scans the assemblies for validators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IWebClient` interface that we use to seed the database (the `AddApiHttpClient`
    method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ExceptionMapper*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules' dependencies (highlighted)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MassTransit*; it also registers the consumers from the basket module (highlighted).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The container we register those dependencies into is also used for and by the
    modules because the aggregator is the host. Those dependencies are shared across
    the modules.The second part of the `Program.cs` file is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code registers the `ExceptionMapper` middleware, then the modules.
    It also adds a seeding endpoint (highlighted). If you remember, we were seeding
    the database using the `DbContext` in the previous versions. However, since the
    basket module needs to receive the events from the catalog to build a materialized
    view, it is more convenient to seed the database through the catalog module. In
    this version, the program seeds the database when a client hits the `/` endpoint.
    By default, when starting the application, Visual Studio should open a browser
    at that URL, which will seed the database.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding the database by sending a GET request to the `/` endpoint is very convenient
    for an academic scenario where we use in-memory databases. However, this could
    be disastrous in a production environment because it would reseed the database
    whenever someone hits that endpoint.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s explore the `IWebClient`, next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the REST API HttpClient
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `shared` directory, the `REPR.API.HttpClient` project contains the REST
    API client code. The code is very similar to the previous project, but the `IProductsClient`
    now exposes a create and delete method (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On top of this, the project only references the `Contracts` projects, limiting
    its dependencies to the classes it needs. It does not reference the complete modules
    anymore. This makes this project easy to reuse. For example, we could build another
    project, like a user interface (UI), then reference and use this typed client
    to query the API (modular monolith) from that .NET UI.Since we created this client
    for a microservices application, we have two base downstream service URLs—one
    for the product microservice and one for the basket microservice. This nuance
    suits us well since we may want to migrate our monolith to microservices later.
    In the meantime, all we have to do is set the two keys to the same host, like
    the following `appsettings.json` file from the aggregator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With these configurations, the `AddApiHttpClient` method configures two `HttpClient`
    with the same `BaseAddress` value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And voilà, we have a functional typed client we can reuse and a working modular
    monolith. Let’s test this out next.
  prefs: []
  type: TYPE_NORMAL
- en: Sending HTTP requests to the API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a working modular monolith, we can reuse similar HTTP requests
    than the previous versions.At the root of the REPR.API project, we can use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `API-Products.http` file contains requests to the product module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `API-Baskets.http` file contains requests to the basket module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A new outcome in this API compared to the previous versions is when we try
    to add a product that does not exist in the catalog to our basket, like the following
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the product `5` does not exist, the API returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That error confirms that the validation works as expected. But how are we validating
    this?
  prefs: []
  type: TYPE_NORMAL
- en: Validating the existence of a product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the *add item* feature, the `AddItemValidator` class ensures the product
    exists while validating the `AddItemCommand` object. To achieve this, we leverage
    the `MustAsync` and `WithMessage` methods from FluentValidation. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code implements the same rules as the previous versions but also
    calls the `ProductExistsAsync` method that fetches the requested product from
    the cache. If the result is `false`, the validation fails with the message “*The
    Product does not exist.*”.Here’s the resulting flow of this change:'
  prefs: []
  type: TYPE_NORMAL
- en: The client calls the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The validation middleware calls the validator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The validator fetches the record from the database and validates its existence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the product does not exist, the request is short-circuited here and returned
    to the client. Otherwise, it continues to the `AddItemHandler` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this in place, we covered all new scenarios from this project. We also
    explored how the aggregator connects the modules together and how easy it is to
    keep our modules independent.Next, we get the BFF back into the project and explore
    how to transition our modular monolith to a microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to Microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t have to transition your monolith to microservices; deploying a monolith
    is fine if it fits your needs. However, if ever you need to, you could shield
    your aggregator with a gateway or a reverse proxy so you can extract modules into
    their own microservices and reroute the requests without impacting the clients.
    This would also allow you to gradually transfer the traffic to the new service
    while keeping the monolith intact in case of an unexpected failure.In a modular
    monolith, the aggregator registers most dependencies, so when migrating, you must
    also migrate this shared setup. One way to not duplicate code would be to create
    and reference a shared assembly containing those registrations. This makes it
    easier to manage the dependencies and shared configurations, but it is also coupling
    between the microservices and the aggregator. Leveraging the code of this shared
    assembly is even easier when the microservices are part of the same mono-repo;
    you can reference the project directly without managing a NuGet package. Yet,
    when you update the library, it updates all microservices and the monolith, voiding
    the deployment independence of each application.Once again, consider keeping the
    monolith intact versus the operational complexity that deploying microservices
    would bring.In the solution, the `REPR.BFF` project is a migration of *Chapter
    19* code. The code and the logic are almost the same. It leverages the `REPR.API.HttpClient`
    project and configures the downstream base addresses in its `appsettings.Development.json`
    file. The `REPR.BFF.http` file at the root of the project contains a few requests
    to test the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is available on GitHub: [https://adpg.link/bn1F](https://adpg.link/bn1F).
    I suggest playing with the live application, which will yield a better result
    than copying the code in the book a second time. The relationships between the
    projects are also more evident in Visual Studio than written in a book. Feel free
    to refactor the projects, add tests, or add features. The best way to learn is
    to practice!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, let’s have a look at challenges and pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges and Pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is a misconception that monoliths are only suitable for small projects or
    small teams. A well-built monolith can go a long way, which is what a modular
    structure and a good analysis bring. Modular Monoliths can be very powerful and
    work well for different sizes of projects. It is essential to consider the pros
    and cons of each approach when selecting the application pattern for a project.
    Maybe a cloud-native, serverless, microservices application is what your next
    project needs, but perhaps a well-designed Modular Monolith would achieve the
    same performance at a tremendously lower cost.To help you make those decisions,
    here are some potential challenges and how to avoid or mitigate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Too much complexity within a module:** One risk is making the modules too
    complex. Like any piece of code, it becomes harder to manage a module if it does
    too many things. Moreover, the bigger the piece of software, the more chance the
    shiny initial design starts to bleed into a big ball of mud. We can avoid this
    by keeping each module focused on a specific part of the domain and by applying
    the SRP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poorly defined module boundaries:** If the boundaries between modules are
    unclear, it can create problems. For example, if two modules do similar things,
    it can confuse developers and lead to one part of the system depending on the
    wrong module. Another example is when two modules that should be part of the same
    bounded context are separated. In that case, the chances are that the two modules
    will interact a lot with each other, creating chattiness and significantly increasing
    the coupling between them. We avoid this with good planning, domain analysis,
    and ensuring each module has a specific job (SRP).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling:** Even though Modular Monoliths are easier to manage, they carry
    the monolith issues when they must scale up. We must deploy the whole application,
    so we can''t scale modules independently. Moreover, even if modules own their
    data, they probably share one database, which must also be scaled as a whole.
    If scaling the whole system is impossible, we can migrate specific modules to
    microservices. We can also extract in-memory services to distributed ones, like
    using a distributed cache instead of a memory cache, leveraging a cloud-based
    event broker instead of an in-memory one, or even having compute or data-intensive
    modules start using their own database so they partially scale independently.
    However, these solutions make the deployment and the infrastructure more complex,
    gradually moving towards complex infrastructure, which defeats the monolith’s
    benefits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eventual consistency:** Keeping data in sync between modules can be challenging.
    We can handle this using event-driven architecture. Using an in-memory message
    broker is low-latency and high-fidelity (no network involved), which is a good
    first step towards learning and dealing with eventual consistency and breaking
    the monolith into microservices (if the transition is ever needed). However, a
    more resilient transport is recommended for production, so the system resists
    to failures, increasing the synchronization latency. You do not have to use events
    if you prefer to remove this complexity; a well-designed relational database can
    do the trick.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transition to microservices:** Moving an application to microservices architecture
    after the fact can be a significant undertaking. However, starting with an event-powered
    Modular Monolith should make the journey less painful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While Modular Monoliths offer many benefits, they can also pose challenges.
    The key is to plan well, keep things simple, and be ready to adapt as the program
    evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned about the Modular Monolith architectural style,
    which blends the simplicity of monolithic architectures with the flexibility of
    microservices. This architectural style organizes software applications into distinct,
    loosely coupled modules, each responsible for a specific business capability.
    Unlike microservices, we deploy these modules as a single unit, like a monolith.
    We discussed the benefits of Modular Monoliths, including easier overall management,
    sound development and testing experiences, cost-effectiveness, and a simplified
    deployment model.We saw that a Modular Monolith comprises modules, a module aggregator,
    and an inter-module communication infrastructure—event-driven in this case.We
    learned that analyzing the domain, designing the modules, and identifying the
    interactions between modules before starting the development improves the chances
    of success of the product.We touched on transitioning from a Modular Monolith
    to a microservices architecture, which involves extracting modules into separate
    microservices and rerouting requests.We also highlighted the importance of knowing
    potential challenges and pitfalls. These include module complexity, poorly defined
    module boundaries, scaling limitations, and eventual consistency caused by an
    asynchronous communication model.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the core principles of a Modular Monolith?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of Modular Monoliths?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are traditional Monoliths?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are poorly defined module boundaries indeed beneficial to a Modular Monolith?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that transitioning an application to microservices architecture can
    be a significant undertaking?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a link to build upon what we learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices Aggregation (Modular Monolith): [https://adpg.link/zznM](https://adpg.link/zznM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When (modular) monolith is the better way to build software: [https://adpg.link/KBGB](https://adpg.link/KBGB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source code: [https://adpg.link/gyds](https://adpg.link/gyds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An end is simply a new beginning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This may be the end of the book, but it is also the continuation of your journey
    into software architecture and design. I hope you found this to be a refreshing
    view of design patterns and how to design SOLID apps.Depending on your goals and
    current situation, you may want to explore one or more application-scale design
    patterns in more depth, start your next personal project, start a business, apply
    for a new job, or all of those. No matter your goals, keep in mind that designing
    software is technical but also an art. There is rarely one way to implement a
    feature but multiple acceptable ways. Every decision has trade-offs, and experience
    is your best friend, so keep programming, learn from your mistakes, become better,
    and continue. The path to mastery is a never-ending continuous learning loop.
    Remember that we are all born knowing next to nothing, so not knowing something
    is expected; we need to learn. Please ask questions, read, experiment, learn,
    and share your knowledge with others. Explaining a concept to someone is extremely
    rewarding and reinforces your own learning and knowledge.Now that this book is
    complete, you may find interesting articles on my blog ([https://adpg.link/blog](https://adpg.link/blog)).
    Feel free to reach out on Discord, Twitter `@CarlHugoM` ([https://adpg.link/twit](https://adpg.link/twit)),
    or LinkedIn ([https://adpg.link/edin](https://adpg.link/edin)). I hope you found
    the book educational and approachable and that you learned many things. I wish
    you success in your career.
  prefs: []
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must treat each module as a microservice and deploy the application as a
    single unit—a monolith.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A few moving parts make the application simpler. Each module is independent,
    making modules loosely coupled. Its simple deployment model leads to cost-effective
    hosting and ease of deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traditional monolithic architectures build the application as a single, indivisible
    unit, often resulting in tightly coupled functionalities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False. Poorly defined module boundaries hinder the health of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True. Even if a well-conceived Modular Monolith can help, the transition will
    be a journey.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
