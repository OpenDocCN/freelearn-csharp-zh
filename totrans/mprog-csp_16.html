<html><head></head><body>
		<div id="_idContainer062">
			<h1 id="_idParaDest-178" class="chapter-number"><a id="_idTextAnchor272"/>16</h1>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor273"/>Generating Code</h1>
			<p>So far in the book, we’ve looked at how powerful metaprogramming can be in .NET at runtime. Doing everything at runtime has the benefit of the flexibility to adapt to things that occur at runtime. The downside of doing this at runtime is that it has a performance impact. This is where the C# Roslyn compiler really shines. We had the capability to generate code in the past with commercial products such as PostSharp (<a href="https://www.postsharp.net/">https://www.postsharp.net/</a>) or <strong class="bo d">Intermediate Language</strong> (<strong class="bo d">IL</strong>) weaving, using projects such as Fody (<a href="https://github.com/Fody/Fody">https://github.com/Fody/Fody</a>) But with Roslyn, code generation has truly been democratized and made easy for anyone <span class="No-Break">to do.</span></p>
			<p>Personally, I’ve worked with all the techniques throughout the years, and finally, with Roslyn, I can realize a lot of the metaprogramming I like to do without sacrificing performance. And I can do so in a more consistent way <span class="No-Break">than before.</span></p>
			<p>The C# Roslyn compiler enables this by allowing developers to be part of its compilation pipeline through a set of APIs. With the APIs, we can investigate the code that’s there and reason about it and then generate new code, which will then be compiled and incorporated into the <span class="No-Break">final binary.</span></p>
			<p>In this chapter, we’ll explore how to leverage Roslyn compiler extensions for generating code, taking a deep dive into the specifics of generating code at compile time. We’ll learn how to examine syntax trees and generate additional code, and even look at how to use Roslyn to generate text reports from your code <span class="No-Break">via metadata.</span></p>
			<p>We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Generating additional code for the <span class="No-Break">Roslyn compiler</span></li>
				<li>(Ab)using the compiler to generate not just <span class="No-Break">C# code</span></li>
				<li>Improving the <span class="No-Break">developer experience</span></li>
			</ul>
			<p>By the end of this chapter, you’ll have a strong grasp of how to use Roslyn to generate code at compile time, and you’ll have a toolkit of techniques and best practices for implementing metaprogramming techniques in C# that leverage the power of the Roslyn compiler platform. So, let’s <span class="No-Break">dive in!</span></p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor274"/>Technical requirements</h1>
			<p>The source code specific to this chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter16">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter16</a>) and builds on top of the <strong class="source-in ine">Fundamentals</strong> code, which can also be found on <span class="No-Break">GitHub (</span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</span></a><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor275"/>Generating additional code for the Roslyn compiler</h1>
			<p>One of the most <a id="_idIndexMarker648"/>powerful capabilities of the Roslyn compiler platform is the ability to generate additional code at compile time. This means that we can create new C# code during the compilation process and have it compiled alongside the rest of <span class="No-Break">our code.</span></p>
			<p>We will look into how you can leverage Roslyn to generate additional code for the compiler. This is super helpful and can help increase your and your team’s productivity by removing the need for repetitive tasks. Since you’re working inside the compiler, you’ll have to work with the language the compiler understands and how it represents code – <strong class="bo d">Abstract Syntax </strong><span class="No-Break"><strong class="bo d">Trees</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bo d">ASTs</strong></span><span class="No-Break">).</span><a id="_idTextAnchor276"/></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor277"/>ASTs</h2>
			<p>An <strong class="bo d">AST</strong> is a data <a id="_idIndexMarker649"/>structure used to represent the structure <a id="_idIndexMarker650"/>of source code. You can compare it to what you already find in the .NET Expression APIs, as we saw in <span class="No-Break"><em class="ita ic">Chapter 7</em></span>, <em class="ita ic">Reasoning about Expressions</em>. It is a hierarchy consisting of nodes that represent the code elements found in the language, such as classes, methods, fields, and properties. The outcome from the compiler from the AST is in its final stage of the binary IL code. While Expressions do this at runtime and are mutatable at runtime, ASTs are static when entering the final stage of the compiler pipeline. However, until the final stage, the AST can be reasoned about <span class="No-Break">and changed.</span></p>
			<p>The AST is constructed by parsing the source code, interpreting all the keywords and variables, and breaking it down into nodes, which then sit together in a tree-like structure. ASTs are used as an intermediate representation of code within compilers or code analysis tools. Once the source code has been converted into an AST, it becomes much easier to analyze and manipulate the code. For example, a tool might use an AST to identify potential bugs or transform the code in <span class="No-Break">some way.</span></p>
			<p>One of the key benefits of Roslyn is its extensibility. Because Roslyn is open source and provides a rich set of APIs for working with the AST, developers can easily create their own code analysis tools that leverage the compiler’s AST. For example, a developer might create a tool that analyzes code for security vulnerabilities, or a tool that automatically generates documentation for a <span class="No-Break">code base.</span></p>
			<p>To make it easy for developers to extend Roslyn, the platform provides a number of extensibility points, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bo d">Syntax trees</strong>: Developers <a id="_idIndexMarker651"/>can create their own syntax trees to represent code, and use them with the <span class="No-Break">Roslyn APIs</span></li>
				<li><strong class="bo d">Syntax rewriters</strong>: Developers can create syntax rewriters that transform the AST in various ways, such as renaming variables or <span class="No-Break">extracting methods</span></li>
				<li><strong class="bo d">Diagnostics</strong>: Developers can create their own diagnostics that identify issues with code, such as potential bugs or <span class="No-Break">style violations</span></li>
				<li><strong class="bo d">Code fix providers</strong>: Developers can create code fix providers that automatically fix any issues identified <span class="No-Break">by diagnostics</span></li>
			</ul>
			<p>With these extensibility points, Roslyn makes it easy for developers to create extensions that<a id="_idIndexMarker652"/> can improve the quality of the code written <a id="_idIndexMarker653"/>or improve productivity by automatically generating <span class="No-Break">plumbing <a id="_idTextAnchor278"/>code.</span></p>
			<p>Compiler theory and how ASTs work is a big topic on its own, something that is outside the scope of this book. Instead, let's get our hands dirty and get a glimpse of what can <span class="No-Break">be done.</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor279"/>Application metrics</h2>
			<p>An important <a id="_idIndexMarker654"/>aspect of running systems in production is observability. By observability, I mean the ability to observe important aspects of an application. Logging is one of these aspects, where you instrument your code with log messages that get written and captured by a log search indexer. Logging can be very verbose, so it is not ideal for simple measurement values, such as counters, gauges, <span class="No-Break">or histograms.</span></p>
			<p>With the release of .NET 6, Microsoft introduced a namespace called <strong class="source-in ine">System.Diagnostics.Metrics</strong>. The classes in this new namespace are perfect for when you want to observe values that change over time. In addition to this, there are packages out there that <a id="_idIndexMarker655"/>support <strong class="bo d">OpenTelemetry</strong> (<a href="https://opentelemetry.io">https://opentelemetry.io</a>), enabling you to capture the different values in popular collectors such as Prometheus, Azure AppInsight, and more. For our sample, we will just be using the <span class="No-Break">console viewer.</span></p>
			<p>With how Microsoft has built support for metrics, it’s very easy to use while it lacks the nice and structured approach Microsoft built for logging. To see the issue, we’ll start by using the metrics as intended from the out-of-the-box experience and then improve on it. Let’s <span class="No-Break">get started!</span></p>
			<ol>
				<li>Let’s start by creating a new project for the chapter. You should create this new project next to the <strong class="source-in ine">Fundamentals</strong> project you have been using throughout the book and also the <strong class="source-in ine">Roslyn.Extensions</strong> project that was established in <a href="B19418_15.xhtml#_idTextAnchor250"><span class="No-Break"><em class="ita ic">Chapter 15</em></span></a>, <em class="ita ic">Roslyn </em><span class="No-Break"><em class="ita ic">Compiler Extensions</em></span><span class="No-Break">.</span></li>
			</ol>
			<p>Create a folder called <strong class="source-in ine">Chapter16</strong>, change into this folder on your command line, and create<a id="_idIndexMarker656"/> a new web project:</p>
			<pre class="console">
<strong class="bo d">dotnet new web</strong></pre>
			<ol>
				<li value="2">You should know the basics of a web project. Let’s change it so that we can use controllers. Change the <strong class="source-in ine">Program.cs</strong> file to look like <span class="No-Break">the following:</span><pre class="console">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
var app = builder.Build();
app.UseRouting();
app.MapControllers();
app.Run();</pre></li>
			</ol>
			<p>This code adds the controllers to <strong class="source-in ine">builder.Services</strong> and then maps all the controllers in your application before running the app.</p>
			<ol>
				<li value="3">Since the goal is to capture metrics, you’re going to need what is called a <strong class="source-in ine">Meter</strong>, which is used for the values you want to track. You can have multiple <strong class="source-in ine">Meter</strong> classes for different areas of your system if you want, but it is common to have one per application. Add a file called <strong class="source-in ine">Metrics.cs</strong> and make it look like <span class="No-Break">the following:</span><pre class="console">
using System.Diagnostics.Metrics;
namespace Chapter16;
public static class Metrics
{
    public static readonly Meter Meter =
        new("Chapter16");
}</pre></li>
			</ol>
			<p>The code <a id="_idIndexMarker657"/>pulls in the <strong class="source-in ine">System.Diagnostics.Metrics</strong> namespace and then exposes a global <strong class="source-in ine">Meter</strong> called <strong class="source-in ine">Chapter16</strong>. This can then be used by any code in the application.</p>
			<ol>
				<li value="4">You now want to add something that creates values within the meter. Add a file called <strong class="source-in ine">EmployeesController.cs</strong> and make it look like <span class="No-Break">the following:</span><pre class="console">
using Microsoft.AspNetCore.Mvc;
namespace Chapter16;
[Route("/api/employees")]
public class EmployeesController : Controller
{
    [HttpGet]
    public IActionResult Register()
    {
        return Ok();
    }
}</pre></li>
			</ol>
			<p>The code introduces a web API controller with a single action that lives in the <strong class="source-in ine">/api/employees</strong> route. The action only returns <strong class="source-in ine">Ok()</strong> – an HTTP 200 status.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">For this chapter, we’re not focused on the functionality of what we’re building but rather focused on the technical problem we’re trying to solve. For this reason, we also make it accept an HTTP <strong class="source-in ine">GET</strong>. Normally, it would be an HTTP <strong class="source-in ine">POST</strong> and also include a payload with details about the employee <span class="No-Break">to register.</span></p>
			<ol>
				<li value="5">Let’s instrument <a id="_idIndexMarker658"/>the code with a counter for counting the number of registered employees. To do this, you’ll need to add a couple of <strong class="source-in ine">using</strong> statements at the top of the <span class="No-Break"><strong class="source-in ine">EmployeeController.cs</strong></span><span class="No-Break"> file:</span><pre class="console">
using System.Diagnostics;
using System.Diagnostics.Metrics;</pre></li>
				<li>Now you can add a counter in the <strong class="source-in ine">EmployeesController</strong> class. Add the following at the top of <span class="No-Break">the class:</span><pre class="console">
static Counter&lt;int&gt; _registeredEmployees =
  Metrics.Meter.CreateCounter&lt;int&gt;("Registered
    Employees", "# of registered employees");</pre></li>
			</ol>
			<p>This code introduces a counter that is created using the global meter. It is created statically so that we don’t create multiple instances of the same counter in the same application.</p>
			<ol>
				<li value="7">To use the <a id="_idIndexMarker659"/>counter, change the <strong class="source-in ine">Register()</strong> method to look like <span class="No-Break">the following:</span><pre class="console">
[HttpGet]
public IActionResult Register()
{
    var now = DateTimeOffset.UtcNow;
    var tags = new TagList(new ReadOnlySpan
       &lt;KeyValuePair&lt;string, object?&gt;&gt;(new
          KeyValuePair&lt;string, object?&gt;[]
    {
        new("Year", now.Year),
        new("Month", now.Month),
        new("Day", now.Day),
    }));
    _registeredEmployees.Add(1, tags);
    return Ok();
}</pre></li>
			</ol>
			<p>The code uses the <strong class="source-in ine">_registeredEmployees</strong> counter by calling the <strong class="source-in ine">Add()</strong> method on it. It also passes along tags, which it sets up before calling <strong class="source-in ine">Add()</strong>. Tags are a way to group values being added. The counter, from a top level, will then aggregate all values tagged, while you can monitor each individual tagged value on its own. This is super helpful for breaking down the metrics you want to monitor. The <strong class="source-in ine">Register()</strong> method breaks down the values by year, month, and day.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Tag values are <strong class="source-in ine">object</strong>. You could pass it a <strong class="source-in ine">DateOnly</strong> instance instead, but this illustrates the use of <span class="No-Break">multiple tags.</span></p>
			<ol>
				<li value="8">With the first counter in place, it is time to see what this actually looks like. To do so, you need to install a tool called <strong class="source-in ine">dotnet-counters</strong>. This is done by running the following in <span class="No-Break">your terminal:</span><pre class="console">
<strong class="bo d">dotnet tool install --global dotnet-counters</strong></pre></li>
				<li>Then. you can start your application by <span class="No-Break">running this:</span><pre class="console">
<strong class="bo d">dotnet run</strong></pre></li>
			</ol>
			<p>You should see an <a id="_idIndexMarker660"/>output similar to the following:</p>
			<pre class="console">
<strong class="bo d">Building...</strong>
<strong class="bo d">info: Microsoft.Hosting.Lifetime[14]</strong>
<strong class="bo d">      Now listening on: http://localhost:5000</strong>
<strong class="bo d">info: Microsoft.Hosting.Lifetime[0]</strong>
<strong class="bo d">      Application started. Press Ctrl+C to shut down.</strong>
<strong class="bo d">info: Microsoft.Hosting.Lifetime[0]</strong>
<strong class="bo d">      Hosting environment: Development</strong>
<strong class="bo d">info: Microsoft.Hosting.Lifetime[0]</strong>
<strong class="bo d">      </strong><strong class="bo d">Content root path: /Users/einari/Projects/Metaprogramming-in-C/Chapter16</strong></pre>
			<ol>
				<li value="10">In another terminal, you can start the metrics monitor by running <span class="No-Break">the following:</span><pre class="console">
<strong class="bo d">dotnet counters monitor --name Chapter16 --counters</strong>
<strong class="bo d">Chapter16</strong></pre></li>
			</ol>
			<p>You should then see something like the following:</p>
			<pre class="console">
<strong class="bo d">Press p to pause, r to resume, q to quit.</strong>
<strong class="bo d">    Status: Running</strong></pre>
			<p>Since there haven’t been any requests yet to the API endpoint, the value won’t show up yet. Keep the monitor running and open a browser and navigate to the endpoint (for example, <strong class="source-in ine">http://localhost:5000/api/employees</strong>); you should then see something like the following:</p>
			<pre class="console">
<strong class="bo d">Press p to pause, r to resume, q to quit.</strong>
<strong class="bo d">    Status: Running</strong>
<strong class="bo d">[Chapter16]</strong>
<strong class="bo d">    RegisteredEmployees (# of registered employees / 1</strong>
<strong class="bo d">      sec)</strong>
<strong class="bo d">        </strong><strong class="bo d">Day=1,Month=5,Year=2023   0</strong></pre>
			<p>The value will be sampled once per second. If you hit your browser multiple times, you should see <strong class="source-in ine">0</strong> at the end of the line increase and then fall back to <strong class="source-in ine">0</strong>. This is expected as it just shows the current measurements and not an aggregate over time.</p>
			<p>Even though the<a id="_idIndexMarker661"/> metrics API in .NET is simple and easy to use, it can quite easily become very verbose, especially when you have tags you want <a id="_idTextAnchor280"/><span class="No-Break">to associate.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor281"/>Improving the developer experience</h2>
			<p>In your business <a id="_idIndexMarker662"/>code, it looks strange to have the setup code for metrics on every method. It is also very verbose and cumbersome. Imagine an evolved application with a lot of metrics you want to collect; it kinda becomes messy. You can obviously clean this up by encapsulating the metrics, either with methods in the classes that need metrics or pulled out into their <span class="No-Break">own classes.</span></p>
			<p>However, I quite like the approach Microsoft has to logs, as we saw in <a href="B19418_14.xhtml#_idTextAnchor219"><span class="No-Break"><em class="ita ic">Chapter 14</em></span></a>, <em class="ita ic">Aspect-Oriented Programming</em>. For its approach to logging, it relies on a code generator that runs at compile time and puts in code that gets included in the <span class="No-Break">finished binary.</span></p>
			<p>Let’s mimic this and create an improved <span class="No-Break">developer experience:</span></p>
			<ol>
				<li>Within the <strong class="source-in ine">Fundamentals</strong> project, create a folder called <strong class="source-in ine">Metrics</strong>. In this folder, add a<a id="_idIndexMarker663"/> file called <strong class="source-in ine">CounterAttribute.cs</strong> and make it look like <span class="No-Break">the following:</span><pre class="console">
namespace Fundamentals.Metrics;
[AttributeUsage(AttributeTargets.Method)]
public sealed class CounterAttribute&lt;T&gt; : Attribute
{
    public CounterAttribute(string name, string
        description)
    {
        Name = name;
        Description = description;
    }
    public string Name { get; }
    public string Description { get; }
}</pre></li>
			</ol>
			<p>This code introduces an attribute that represents a counter. Counters can have a name and description associated with them. It is a generic attribute, allowing you to specify the type used for the counter.</p>
			<ol>
				<li value="2">In the <strong class="source-in ine">Metrics</strong> folder in the <strong class="source-in ine">Fundamentals</strong> project, add a file called <strong class="source-in ine">GlobalMetrics.cs</strong> and make it look like <span class="No-Break">the following:</span><pre class="console">
using System.Diagnostics.Metrics;
namespace Fundamentals.Metrics;
public static class GlobalMetrics
{
    public static Meter Meter = new("Global");
}</pre></li>
				<li>This introduces<a id="_idIndexMarker664"/> a globally accessible <strong class="source-in ine">Meter</strong> instance, which will make it predictable for the code generator you’ll be building, as it will need access to this. However, it defaults to a meter called <strong class="source-in ine">Global</strong>, which we want to override. Open the <strong class="source-in ine">Program.cs</strong> file within <strong class="source-in ine">Chapter16</strong> and add the following at the top of the file after the <span class="No-Break"><strong class="source-in ine">using</strong></span><span class="No-Break"> statements:</span><pre class="console">
GlobalMetrics.Meter = new Meter("Chapter16");</pre></li>
			</ol>
			<p>The goal of this chapter is to provide a simpler way of doing metrics. This will be done through the technique of creating a partial class providing method signatures without implementations. The source code generator will create an implementation of the partial class and provide implementations for each of the methods.</p>
			<ol>
				<li value="4">Let’s add the metrics file for <strong class="source-in ine">EmployeesController</strong>. Add a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-in ine">Employees</strong></span><strong class="source-in ine">
ControllerMetrics.cs</strong> and add the following <span class="No-Break">to it:</span><pre class="console">
using System.Diagnostics.Metrics;
using Fundamentals.Metrics;
namespace Chapter16;
public static partial class EmployeesControllerMetrics
{
    [Counter&lt;int&gt;("RegisteredEmployees", "# of
        registered employees")]
    public static partial void
        RegisteredEmployees(DateOnly date);
}</pre></li>
			</ol>
			<p>The code sets up a static partial class, which is important as this will be a criterion for finding which classes to generate source code for. All counters are then represented as methods with a given name and a <strong class="source-in ine">[Counter]</strong> attribute with details. Every parameter on the method will be used as a tag.</p>
			<p>You’ve now prepared<a id="_idIndexMarker665"/> the basics needed for the source code generator to<a id="_idTextAnchor282"/> be able <span class="No-Break">to work.</span></p>
			<h3>Setting up the code template</h3>
			<p>The code generator<a id="_idIndexMarker666"/> will generate the code that will implement partial classes. To do this, you’ll use a template file that represents the source code to generate. As a template language, you’re going to be using something called <strong class="bo d">Handlebars</strong> (<a href="https://handlebarsjs.com">https://handlebarsjs.com</a>). There<a id="_idIndexMarker667"/> is a .NET implementation <span class="No-Break">of this.</span></p>
			<p>Open the <strong class="source-in ine">Roslyn.Extensions.csproj</strong> file in the <strong class="source-in ine">Roslyn.Extensions</strong> folder and add the following package reference in an <strong class="source-in ine">ItemGroup</strong> with the other <span class="No-Break">package references:</span></p>
			<pre class="source-code">
&lt;PackageReference Include="handlebars.net" Version="2.1.4"
  GeneratePathProperty="true" PrivateAssets="all" /&gt;</pre>
			<p>The <strong class="source-in ine">PrivateAssets="all"</strong> attribute instructs it to be a reference only for this project and only be used with the extension itself, meaning that any assemblies from <strong class="source-in ine">Handlebars</strong> will not be included in any projects referencing this project. In addition, you have to set <strong class="source-in ine">GeneratePathProperty="true"</strong>. This will create a variable specific to the package and allow us to instruct which specific assembly of <strong class="source-in ine">Handlebars</strong> to use; otherwise, the compiler will <span class="No-Break">say </span><span class="No-Break"><strong class="source-in ine">FileNotFoundError</strong></span><span class="No-Break">.</span></p>
			<p>To specify the correct assembly, add the following to <strong class="source-in ine">Roslyn.Extensions.csproj</strong> in the <strong class="source-in ine">Roslyn.Extensions</strong> folder at the end of the file, within<a id="_idIndexMarker668"/> the <span class="No-Break"><strong class="source-in ine">Project</strong></span><span class="No-Break"> tag:</span></p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
    &lt;GetTargetPathDependsOn&gt;$(GetTargetPathDependsOn);
       GetDependencyTargetPaths&lt;/GetTargetPathDependsOn&gt;
&lt;/PropertyGroup&gt;
&lt;Target Name="GetDependencyTargetPaths"&gt;
    &lt;ItemGroup&gt;
        &lt;TargetPathWithTargetPlatformMoniker
        Include="$(PKGHandlebars_Net)\lib\netstandard2.0\
        Handlebars.dll" IncludeRuntimeDependency="false" /&gt;
    &lt;/ItemGroup&gt;
&lt;/Target&gt;</pre>
			<p>With <strong class="source-in ine">Handlebars</strong> properly installed, you’re ready to create the template you need for generating the code. Before you create the template, you’ll need to set up all the types of data you’ll pass to <span class="No-Break">the template.</span></p>
			<p>In the <strong class="source-in ine">Roslyn.Extensions</strong> folder, create a folder called <strong class="source-in ine">Metrics</strong>. Add a file called <strong class="source-in ine">MetricsTemplateData.cs</strong> and add the following <span class="No-Break">to it:</span></p>
			<pre class="source-code">
namespace Roslyn.Extensions.Metrics;
public class MetricsTemplateData
{
    public string Namespace { get; set; } = string.Empty;
    public string ClassName { get; set; } = string.Empty;
    public IEnumerable&lt;CounterTemplateData&gt; Counters { get;
       set; } = Enumerable.Empty&lt;CounterTemplateData&gt;();
}</pre>
			<p><strong class="source-in ine">MetricsTemplateData</strong> will be the root object being passed to the template. It contains the namespace for the generated code and then the class name for the class that will be generated. It then goes on to hold a collection of all the counters it will <span class="No-Break">generate for.</span></p>
			<p>For the counter <a id="_idIndexMarker669"/>definitions, add a file called <strong class="source-in ine">CounterTemplateData.cs</strong> and add the following <span class="No-Break">to it:</span></p>
			<pre class="source-code">
namespace Roslyn.Extensions.Metrics;
public class CounterTemplateData
{
    public string Type { get; set; } = string.Empty;
    public string MethodName { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public IEnumerable&lt;CounterTagTemplateData&gt; Tags { get;
      set; } = Enumerable.Empty&lt;CounterTagTemplateData&gt;();
}</pre>
			<p>The <strong class="source-in ine">CounterTemplateData</strong> type holds information about the type of counter, the method name representing it, the name of the counter, and a description to be used with the counter. Lastly, it holds all the tags associated with the counter <span class="No-Break">when called.</span></p>
			<p>For the tag definition, add a file called <strong class="source-in ine">CounterTagTemplateData.cs</strong> and make it look like <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker670"/></span><span class="No-Break"> following:</span></p>
			<pre class="source-code">
namespace Roslyn.Extensions.Metrics;
public class CounterTagTemplateData
{
    public string Type { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
}</pre>
			<p>The tag contains a type, which will be reflected in the signature of the method being called and then <span class="No-Break">the name.</span></p>
			<p>With the object definitions for the parameters for the template, it’s time to add <span class="No-Break">the template.</span></p>
			<p>In the <strong class="source-in ine">Roslyn.Extensions</strong> folder, create a folder called <strong class="source-in ine">Templates</strong>, and within the <strong class="source-in ine">Templates</strong> folder, add a file called <strong class="source-in ine">Metrics.hbs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using System.Diagnostics;
using System.Diagnostics.Metrics;
using Fundamentals.Metrics;
namespace {{Namespace}};
#nullable enable
public static partial class {{ClassName}}
{
    {{#Counters}}
    static readonly Counter&lt;{{Type}}&gt; {{MethodName}}Metric
      = GlobalMetrics.Meter.CreateCounter&lt;{{Type}}&gt;
         ("{{Name}}", "{{Description}}");
    {{/Counters}}
    {{#Counters}}
    public static partial void {{MethodName}}({{#Tags}}
      {{Type}} {{Name}}{{#unless @last}}, {{/unless}}
          {{/Tags}})
    {
        var tags = new TagList(new ReadOnlySpan
          &lt;KeyValuePair&lt;string, object?&gt;&gt;(new KeyValuePair
             &lt;string, object?&gt;[]
        {
            {{#Tags}}
            new("{{Name}}", {{name}}){{#unless @last}},
              {{/unless}}
            {{/Tags}}
        }));
        {{MethodName}}Metric.Add(1, tags);
    }
    {{/Counters}}
}</pre>
			<p>Within the template, there is data context. The top-level item will be the <strong class="source-in ine">MetricsTemplateData</strong> instance. This is where the <strong class="source-in ine">{{Namespace}}</strong> and <strong class="source-in ine">{{ClassName}}</strong> values are inserted. The use of <strong class="source-in ine">{{}}</strong> with text represents values that can be replaced, and the text itself is then a property that exists in the current context it’s in. When the value in the quotes starts with a <strong class="source-in ine">#</strong> symbol, it uses a function to resolve it. Handlebars have some automatic magic and recognize enumerables, such as <strong class="source-in ine">Counters</strong>. Handlebars will loop through these and anything within its scope will be output for each instance. The template uses these techniques throughout to replace all the values found in the objects passed <span class="No-Break">to it.</span></p>
			<p>The end <a id="_idIndexMarker671"/>result for <strong class="source-in ine">EmployeesControllerMetrics</strong> will end up rendered like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using System.Diagnostics;
using System.Diagnostics.Metrics;
using Fundamentals.Metrics;
namespace Chapter16;
#nullable enable
public static partial class EmployeesControllerMetrics
{
    static readonly Counter&lt;int&gt; RegisteredEmployeesMetric
      = GlobalMetrics.Meter.CreateCounter&lt;int&gt;
      ("RegisteredEmployees", "# of registered employees");
    public static partial void RegisteredEmployees(DateOnly
      date)
    {
        var tags = new TagList(new ReadOnlySpan
        &lt;KeyValuePair&lt;string, object?&gt;&gt;(new KeyValuePair
        &lt;string, object?&gt;[]
        {
            new("date", date)
        }));
        RegisteredEmployeesMetric.Add(1, tags);
    }
}</pre>
			<p>With the template in place, we need a way to programmatically access it in the code generator. To<a id="_idIndexMarker672"/> enable that, you want to embed any template files into the assembly at <span class="No-Break">compile time.</span></p>
			<p>Open <strong class="source-in ine">Roslyn.Extensions.csproj</strong> and add an <strong class="source-in ine">ItemGroup</strong> within the <strong class="source-in ine">Project</strong> tag that looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;EmbeddedResource Include="$(MSBuildThisFileDirectory)
      /Templates/**/*.hbs" /&gt;
&lt;/ItemGroup&gt;</pre>
			<p>The <strong class="source-in ine">EmbeddedResource</strong> tag instructs the compiler to include all <strong class="source-in ine">hbs</strong> files within the <strong class="source-in ine">Templates</strong> folder and make them embedded resources of <span class="No-Break">the assembly.</span></p>
			<p>Embedded resources are part of the assembly and are referred to as resources. They can be accessed directly on the assembly they <span class="No-Break">belong to.</span></p>
			<p>Let’s create a helper class to get access to the template and future templates you’ll be adding. In the <strong class="source-in ine">Templates</strong> folder of the <strong class="source-in ine">Roslyn.Extensions</strong> project, add a file called <strong class="source-in ine">TemplateTypes.cs</strong>. Make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using HandlebarsDotNet;
namespace Roslyn.Extensions.Templates;
public static class TemplateTypes
{
    public static readonly HandlebarsTemplate&lt;object,
      object&gt; Metrics = Handlebars.Compile
        (GetTemplate("Metrics"));
    static string GetTemplate(string name)
    {
        var rootType = typeof(TemplateTypes);
        var stream = rootType.Assembly.GetManifest
        ResourceStream($"{rootType.Namespace}.{name}.hbs");
        if (stream != default)
        {
            using var reader = new StreamReader(stream);
            return reader.ReadToEnd();
        }
        return string.Empty;
    }
}</pre>
			<p>The code introduces <a id="_idIndexMarker673"/>a private method called <strong class="source-in ine">GetTemplate()</strong> on the <strong class="source-in ine">TemplateTypes</strong> class. It leverages <strong class="source-in ine">GetManifestResourceStream()</strong> on the assembly instance. The compiler will by convention make namespaces of the folder and any subfolder of the embedded resource. Accessing the resources will then be like accessing types in it. Since the template sits in the <strong class="source-in ine">Templates</strong> folder, it will be in the same folder and then the same namespace as the <strong class="source-in ine">TemplateTypes</strong> class. This is therefore used as the prefix for the name of the template before the name of the template. The code then uses a <strong class="source-in ine">StreamReader</strong> to read the resource stream to the end, giving you a string holding <span class="No-Break">the template.</span></p>
			<p>At the top <a id="_idIndexMarker674"/>of the <strong class="source-in ine">TemplateTypes</strong> class sits a property representing the <span class="No-Break"><strong class="source-in ine">Metrics</strong></span><span class="No-Break"> template.</span></p>
			<p>Now we have the template and code for accessing it, you can move on to cr<a id="_idTextAnchor283"/>eating the <span class="No-Break">code generator.</span></p>
			<h3>Building the source code generator</h3>
			<p>In order for the <a id="_idIndexMarker675"/>code generator to generate code only for classes that match the criteria, you need a syntax receiver that gets called on every node from the source code <span class="No-Break">being compiled.</span></p>
			<p>Add a file called <strong class="source-in ine">MetricsSyntaxReceiver.cs</strong> in the <strong class="source-in ine">Metrics</strong> folder within the <strong class="source-in ine">Roslyn.Extensions</strong> project. Add the following code <span class="No-Break">to it:</span></p>
			<pre class="source-code">
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
namespace Roslyn.Extensions.Metrics;
public class MetricsSyntaxReceiver : ISyntaxReceiver
{
    readonly List&lt;ClassDeclarationSyntax&gt; _candidates =
      new();
    internal IEnumerable&lt;ClassDeclarationSyntax&gt; Candidates
      =&gt; _candidates;
    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not ClassDeclarationSyntax
          classSyntax) return;
        if (classSyntax.Modifiers.Any(modifier =&gt;
          modifier.IsKind(SyntaxKind.PartialKeyword)) &amp;&amp;
            classSyntax.Modifiers.Any(modifier =&gt;
              modifier.IsKind(SyntaxKind.StaticKeyword)))
        {
            if (classSyntax.Members.Any(member =&gt;
             member.IsKind(SyntaxKind.MethodDeclaration) &amp;&amp;
                member.Modifiers.Any(modifier =&gt;
                  modifier.IsKind
                    (SyntaxKind.PartialKeyword)) &amp;&amp;
                member.Modifiers.Any(modifier =&gt; modifier
                  .IsKind(SyntaxKind.StaticKeyword))))
            {
                _candidates.Add(classSyntax);
            }
        }
    }
}</pre>
			<p>The code <a id="_idIndexMarker676"/>implements the <strong class="source-in ine">ISyntaxReceiver</strong> interface with the <strong class="source-in ine">OnVisitSyntaxNode()</strong> method, which will be called on every AST node from the compiler. The purpose of <strong class="source-in ine">MetricsSyntaxReceiver</strong> is to narrow down what classes are of interest for code generation. First, it filters down by requiring it to be a <strong class="source-in ine">class</strong>, then it looks as if the class is partial and static. The last filter is to look for any members of the class, looking for static partial methods. If all of the criteria are met, it will add the class to a <span class="No-Break">candidate list.</span></p>
			<p>With the receiver filtering down, it’s time for the generator itself to be set up. Next to the <strong class="source-in ine">MetricsSyntaxReceiver.cs</strong> file, add a file called <strong class="source-in ine">MetricsSourceGenerator.cs</strong>. Add <a id="_idIndexMarker677"/>the following code <span class="No-Break">to it:</span></p>
			<pre class="source-code">
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Roslyn.Extensions.Templates;
namespace Roslyn.Extensions.Metrics;
[Generator]
public class MetricsSourceGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
    }
    public void Initialize(GeneratorInitializationContext
      context)
    {
        context.RegisterForSyntaxNotifications(() =&gt; new
          MetricsSyntaxReceiver());
    }
}</pre>
			<p>The code creates a class called <strong class="source-in ine">MetricsSourceGenerator</strong>, which implements the <strong class="source-in ine">ISourceGenerator</strong> interface with its <strong class="source-in ine">Execute()</strong> and <strong class="source-in ine">Initialize()</strong> methods. For the generator to work, you also have to add the <strong class="source-in ine">[Generator]</strong> attribute. In the <strong class="source-in ine">Initialize()</strong> method, the code registers the syntax receiver you <span class="No-Break">put in.</span></p>
			<p>In the <strong class="source-in ine">Execute()</strong> method is where all the magic will happen. Let’s start by adding the following to the <a id="_idIndexMarker678"/>body of the <span class="No-Break"><strong class="source-in ine">Execute()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
if (context.SyntaxReceiver is not MetricsSyntaxReceiver
  receiver) return;
var counterAttribute = context.Compilation
    .GetTypeByMetadataName("Fundamentals
      .Metrics.CounterAttribute`1");
foreach (var candidate in receiver.Candidates)
{
    var templateData = new MetricsTemplateData
    {
        Namespace = (candidate.Parent as
          BaseNamespaceDeclarationSyntax)!.Name.ToString(),
        ClassName = candidate.Identifier.ValueText
    };
    var semanticModel = context.Compilation
      .GetSemanticModel(candidate.SyntaxTree);
    foreach (var member in candidate.Members)
    {
        if (member is not MethodDeclarationSyntax method)
          continue;
        var methodSymbol = semanticModel
          .GetDeclaredSymbol(method);
        if (methodSymbol is not null)
        {
            var attributes = methodSymbol.GetAttributes();
            var attribute = attributes.FirstOrDefault(_ =&gt;
            SymbolEqualityComparer.Default.Equals
             (_.AttributeClass?.OriginalDefinition,
             counterAttribute));
            if (attribute is not null)
            {
                // Generate
            }
        }
    }
    if (templateData.Counters.Count &gt; 0)
    {
        var source = TemplateTypes.Metrics(templateData);
        context.AddSource($"{candidate.Identifier
          .ValueText}.g.cs", source);
    }
}</pre>
			<p>The code is expecting <strong class="source-in ine">SyntaxReceiver</strong> to be <strong class="source-in ine">MetricsSyntaxReceiver</strong>; if it’s not, it’s just returned. Then, it goes on to get an instance of the type definition for the <strong class="source-in ine">CounterAttribute</strong> type. Notice the name is a little strange; <strong class="source-in ine">CounterAttribute'1</strong>. This is because the type is a generic type and internally in .NET, the type will get the postfix with a number of saying the number of generic arguments <span class="No-Break">it has.</span></p>
			<p>For all the candidates <strong class="source-in ine">MetricsSyntaxReceiver</strong> has found, the code loops through and sets up a <strong class="source-in ine">MetricsTemplateData</strong> instance for the class. It then gets what is known as the semantic model based on the syntax tree of the class. The semantic model in Roslyn provides a deeper understanding of the meaning of code beyond its syntax. It can be used for tasks such as name binding, type checking, error checking, and <span class="No-Break">automated refactoring.</span></p>
			<p>Classes have members and the code walks through all the members and filters and skips those that are not methods. From the semantic model, it gets the declared symbol of the method, which lets us nicely access the attributes on it. It then looks <span class="No-Break">for </span><span class="No-Break"><strong class="source-in ine">CounterAttribute</strong></span><span class="No-Break">.</span></p>
			<p>At the very end, it<a id="_idIndexMarker679"/> generates the source code from the template, but only if there are any counters to generate for. It provides the source code by using the <strong class="source-in ine">AddSource()</strong> method provided by <strong class="source-in ine">GeneratorExecutionContext</strong>. The convention for generated files is to include the type name and then postfix it <span class="No-Break">with </span><span class="No-Break"><strong class="source-in ine">.g.cs</strong></span><span class="No-Break">.</span></p>
			<p>For the generator to kick in, it needs the counters. Add the following code to the <strong class="source-in ine">Execute()</strong> method, replacing the <strong class="source-in ine">// </strong><span class="No-Break"><strong class="source-in ine">Generate</strong></span><span class="No-Break"> comment:</span></p>
			<pre class="source-code">
var tags = method.ParameterList.Parameters.Select(parameter
  =&gt; new CounterTagTemplateData
{
    Name = parameter.Identifier.ValueText,
    Type = parameter.Type!.ToString()
});
var type = attribute.AttributeClass!.TypeArguments[0]
     .ToString();
var name = attribute.ConstructorArguments[0].Value!
    .ToString();
var description = attribute.ConstructorArguments[1].Value!
    .ToString();
templateData.Counters.Add(
        new CounterTemplateData
        {
            Name = name,
            Description = description,
            Type = type,
            MethodName = method.Identifier.ValueText,
            Tags = tags
        });</pre>
			<p>The code gathers the information from the attribute and method information to provide the data the <span class="No-Break">template needs.</span></p>
			<p>That is pretty <a id="_idIndexMarker680"/>much it for the generator to work. Since we’re leaning on the setup done in <a href="B19418_15.xhtml#_idTextAnchor250"><span class="No-Break"><em class="ita ic">Chapter 15</em></span></a>, <em class="ita ic">Roslyn Compiler Extensions</em>, all we n<a id="_idTextAnchor284"/>ow need to do is start <span class="No-Break">using it.</span></p>
			<h3>Test driving the source generator</h3>
			<p>To get the <strong class="source-in ine">Chapter16</strong> code<a id="_idIndexMarker681"/> compiled and working, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>First, you need to add a reference to the <span class="No-Break"><strong class="source-in ine">Fundamentals</strong></span><span class="No-Break"> project:</span><pre class="console">
<strong class="bo d">dotnet add reference ../Fundamentals/Fundamentals.csproj</strong></pre></li>
				<li>Then, you need a reference to the <strong class="source-in ine">Roslyn.Extensions</strong> project. This needs to be a little bit different since you want it to automatically use the generator. Add a <strong class="source-in ine">ProjectReference</strong> in the <strong class="source-in ine">Chapter16.csproj</strong> file next to the reference to the <strong class="source-in ine">Fundamentals</strong> project, looking like <span class="No-Break">the following:</span><pre class="console">
&lt;ProjectReference Include="..\Roslyn.Extensions\
  Roslyn.Extensions.csproj" OutputItemType="Analyzer"
    ReferenceOutputAssembly="false" /&gt;</pre></li>
			</ol>
			<p>This instructs the reference to use the analyzer and not include any of its assemblies in the output of <strong class="source-in ine">Chapter16</strong>.</p>
			<ol>
				<li value="3">To start using the new way of doing metrics, you’ll need to change the <strong class="source-in ine">EmployeeController</strong> class. Open the <strong class="source-in ine">EmployeeController.cs</strong> file in the <strong class="source-in ine">Chapter16</strong> folder <a id="_idIndexMarker682"/>and change the <strong class="source-in ine">Register()</strong> method to look like <span class="No-Break">the following:</span><pre class="console">
[HttpGet]
public IActionResult Register()
{
    EmployeesControllerMetrics.RegisteredEmployees
      (DateOnly.FromDateTime(DateTime.UtcNow));
    return Ok();
}</pre></li>
			</ol>
			<p>The code now uses the new partial class instead of dealing with the counter and tags itself.</p>
			<ol>
				<li value="4">Perform a build on the <span class="No-Break"><strong class="source-in ine">Chapter16</strong></span><span class="No-Break"> project:</span><pre class="console">
<strong class="bo d">dotnet build</strong></pre></li>
			</ol>
			<p>Within the <strong class="source-in ine">obj</strong> folder, you can now see the result of the source generator:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B19418_16_01.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 – Generated file in the filesystem</p>
			<ol>
				<li value="5">Open <strong class="source-in ine">EmployeesControllerMetrics.g.cs</strong> and confirm you have the <span class="No-Break">expected </span><span class="No-Break"><a id="_idIndexMarker683"/></span><span class="No-Break">result:</span><pre class="console">
using System.Diagnostics;
using System.Diagnostics.Metrics;
using Fundamentals.Metrics;
namespace Chapter16;
#nullable enable
public static partial class EmployeesControllerMetrics
{
    static readonly Counter&lt;int&gt; RegisteredEmployees
  Metric = GlobalMetrics.Meter.CreateCounter
    &lt;int&gt;("RegisteredEmployees", "# of registered
       employees");
    public static partial void RegisteredEmployees
      (DateOnly date)
    {
        var tags = new TagList(new ReadOnlySpan
          &lt;KeyValuePair&lt;string, object?&gt;&gt;(new
            KeyValuePair&lt;string, object?&gt;[]
        {
            new("date", date)
        }));
        RegisteredEmployeesMetric.Add(1, tags);
    }
}</pre></li>
				<li>Run your project and then start the monitor by <span class="No-Break">running this:</span><pre class="console">
<strong class="bo d">dotnet counters monitor -n Chapter16 --counters</strong>
<strong class="bo d">Chapter16</strong></pre></li>
				<li>And then trigger<a id="_idIndexMarker684"/> the API by using a browser and navigating to the endpoint (for example, <strong class="source-in ine">http://localhost:5000/api/employees</strong>). You should see an output similar to <span class="No-Break">the following:</span><pre class="console">
<strong class="bo d">Press p to pause, r to resume, q to quit.</strong>
<strong class="bo d">    </strong><strong class="bo d">Status: Running</strong>
<strong class="bo d">[Chapter16]</strong>
<strong class="bo d">    RegisteredEmployees (# of registered employees / 1</strong>
<strong class="bo d">      sec)</strong>
<strong class="bo d">        date=5/1/2023              0</strong></pre></li>
			</ol>
			<p>This technique can be very powerful. More types of metrics can be supported and extended, giving you a more intuitive and simple way of working with metric values.</p>
			<p>Adding source code that gets compiled is very powerful and you are not limited to adding just partial classes; you can in fact add anything you want, which can be super useful. That <a id="_idIndexMarker685"/>being said, you’re not just limited to outputting source files for the compiler. You <a id="_idTextAnchor285"/>can produce other artifacts <span class="No-Break">as well.</span></p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor286"/>(Ab)using the compiler to generate not just C# code</h1>
			<p>Since you can <a id="_idIndexMarker686"/>basically do anything within the<a id="_idIndexMarker687"/> code generator, you could go and generate anything else. One of the things we use it for in my day-to-day work is to generate TypeScript files from our C# code. This is super useful and we save a lot of time and gain consistency in the TypeScript, in line with the REST APIs <span class="No-Break">in C#.</span></p>
			<p>Let’s go and do something that doesn’t end up in a C# file. Based on the <strong class="source-in ine">Fundamentals</strong> project in the GitHub repository and what you have built so far in the book, you should have a namespace called <strong class="source-in ine">Fundamentals.Compliance.GDPR</strong> and an attribute called <strong class="source-in ine">PersonalIdentifiableInformation</strong>, which was introduced in <a href="B19418_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="ita ic">Chapter 5</em></span></a>, <span class="No-Break"><em class="ita ic">Leveraging Attributes</em></span><span class="No-Break">.</span></p>
			<p>This attribute is great for marking types that collect <strong class="bo d">Personally Identifiable Information</strong> (<strong class="bo d">PII</strong>) as <a id="_idIndexMarker688"/>well as the reason for collecting PII. In <a href="B19418_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="ita ic">Chapter 5</em></span></a>, <em class="ita ic">Leveraging Attributes</em>, we used it at runtime to create a runtime report. What we could instead do is create this report at <span class="No-Break">compile time.</span></p>
			<p>Add a file in the <strong class="source-in ine">Chapter16</strong> folder called <strong class="source-in ine">Employee</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using Fundamentals.Compliance.GDPR;
namespace Chapter16;
public record Employee(
    [PersonalIdentifiableInformation("Needed for
      registration")]
    string FirstName,
    [PersonalIdentifiableInformation("Needed for
      registration")]
    string LastName,
    [PersonalIdentifiableInformation("Needed for uniquely
      identifying an employee")]
    string SocialSecurityNumber);</pre>
			<p>The <strong class="source-in ine">Employee</strong> type has its properties annotated with the <strong class="source-in ine">[PersonalIdentifiableInformation]</strong> attribute, declaring the specific reason for <a id="_idIndexMarker689"/>collecting the information. This<a id="_idIndexMarker690"/> is what we want to output in a GDPR report sayin<a id="_idTextAnchor287"/>g which types have members that <span class="No-Break">hold PII.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor288"/>Building the generator</h2>
			<p>In order for our<a id="_idIndexMarker691"/> generator to know where to output the<a id="_idIndexMarker692"/> resulting file, it will need a configurable property. The current directory when running in the context of the compiler will be the path where the compiler sits and typically a place you don’t have write access to write to. Besides, it is not very useful to write files at a <span class="No-Break">random location.</span></p>
			<p>Generators can have properties that get configured in the <strong class="source-in ine">.csproj</strong> files. For them to be visible to the generator, you need to tell the compiler that the property should be visible. To do this, open the <strong class="source-in ine">Roslyn.Extensions.props</strong> file, which you should have in the <strong class="source-in ine">Roslyn.Extensions</strong> folder, and add an <strong class="source-in ine">ItemGroup</strong> within the <strong class="source-in ine">Project</strong> tag that looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;CompilerVisibleProperty Include="GDPRReport"/&gt;
&lt;/ItemGroup&gt;</pre>
			<p>Then, in the <strong class="source-in ine">Chapter16.csproj</strong> file in the <strong class="source-in ine">Chapter16</strong> folder, you will need to add a reference to the <strong class="source-in ine">props</strong> file. Add the following at the top of the file within the <span class="No-Break"><strong class="source-in ine">Project</strong></span><span class="No-Break"> tag:</span></p>
			<pre class="source-code">
&lt;Import Project="$(MSBuildThisFileDirectory)../
  Roslyn.Extensions/Roslyn.Extensions.props"/&gt;</pre>
			<p>Then, within <strong class="source-in ine">PropertyGroup</strong>, you need to add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&lt;GDPRReport&gt;$(MSBuildThisFileDirectory)GDPRReport.txt&lt;/GDPR
  Report&gt;</pre>
			<p>This configures the <strong class="source-in ine">GDPRReport</strong> variable to point to the folder of the <strong class="source-in ine">Chapter16.csproj</strong> file and then adds <strong class="source-in ine">GDPRReport.txt</strong> to <span class="No-Break">the path.</span></p>
			<p>As you did with the metrics source generator, you’ll need a syntax receiver for filtering <span class="No-Break">the candidates.</span></p>
			<p>Create a<a id="_idIndexMarker693"/> folder <a id="_idIndexMarker694"/>called <strong class="source-in ine">GDPR</strong> in the <strong class="source-in ine">Roslyn.Extensions</strong> project and add a file called <strong class="source-in ine">GDPRSyntaxReceiver.cs</strong>. Make the file look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
namespace Roslyn.Extensions.GDPR;
public class GDPRSyntaxReceiver : ISyntaxReceiver
{
    readonly List&lt;TypeDeclarationSyntax&gt; _candidates =
      new();
    internal IEnumerable&lt;TypeDeclarationSyntax&gt; Candidates
       =&gt; _candidates;
    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not TypeDeclarationSyntax
          typeSyntax) return;
        _candidates.Add(typeSyntax);
    }
}</pre>
			<p>The filter for this syntax receiver is a simple one. It’s interested in syntax nodes that are types. This would include classes <span class="No-Break">and records.</span></p>
			<p>Now you <a id="_idIndexMarker695"/>need the source generator. Add a file called <strong class="source-in ine">GDPRSourceGenerator.cs</strong> alongside<a id="_idIndexMarker696"/> the <strong class="source-in ine">GDPRSyntaxReceiver.cs</strong> file and add the following <span class="No-Break">to it:</span></p>
			<pre class="source-code">
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
namespace Roslyn.Extensions.GDPR;
[Generator]
public class GDPRSourceGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not
          GDPRSyntaxReceiver receiver) return;
        context.AnalyzerConfigOptions.GlobalOptions
          .TryGetValue("build_property.GDPRReport", out var
            filename);
        var writer = File.CreateText(filename);
        writer.AutoFlush = true;
        var piiAttribute = context.Compilation
        .GetTypeByMetadataName("Fundamentals.Compliance
        .GDPR.PersonalIdentifiableInformationAttribute");
    }
    public void Initialize(GeneratorInitializationContext
      context)
    {
        context.RegisterForSyntaxNotifications(() =&gt; new
          GDPRSyntaxReceiver());
    }
}</pre>
			<p>The code sets up the <a id="_idIndexMarker697"/>basics <a id="_idIndexMarker698"/>for the source generator and also sets up the initials for the <strong class="source-in ine">Execute()</strong> method. It will only perform the job if <strong class="source-in ine">SyntaxReceiver</strong> is <strong class="source-in ine">GDPRSyntaxReceiver</strong>. Next, it goes and gets the <strong class="source-in ine">GDPRReport</strong> variable from config. All values are prefixed with <strong class="source-in ine">build_property</strong> for the ones coming from the build. It then goes on to create the report file before it gets the <strong class="source-in ine">PersonalIdentifiableInformationAttribute</strong> type for <span class="No-Break">filtering later.</span></p>
			<p>Continue the <strong class="source-in ine">Execute()</strong> method with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
foreach (var candidate in receiver.Candidates)
{
    var semanticModel = context.Compilation
      .GetSemanticModel(candidate.SyntaxTree);
    var symbols = new List&lt;ISymbol&gt;();
    if (candidate is RecordDeclarationSyntax record)
    {
        foreach (var parameter in record.ParameterList!
          .Parameters)
        {
            var parameterSymbol = semanticModel
              .GetDeclaredSymbol(parameter);
            if (parameterSymbol is not null)
            {
                symbols.Add(parameterSymbol);
            }
        }
    }
    foreach (var member in candidate.Members)
    {
        if (member is not PropertyDeclarationSyntax
          property) continue;
        var propertySymbol = semanticModel
          .GetDeclaredSymbol(property);
        if (propertySymbol is not null)
        {
            symbols.Add(propertySymbol);
        }
    }
}</pre>
			<p>The code looks at the candidates from the syntax receiver. If the candidate is a record, it enumerates the parameters of it and adds them as a symbol of interest. It then goes on to walk through the members of the candidate, adding them as a symbol <span class="No-Break">of interest.</span></p>
			<p>Now that you’ve collected all symbols of interest, it’s time to filter down only the symbols that<a id="_idIndexMarker699"/> are <a id="_idIndexMarker700"/>annotated with the <span class="No-Break"><strong class="source-in ine">PersonalIdentifiableInformation</strong></span><span class="No-Break"> attribute.</span></p>
			<p>Within the candidates <strong class="source-in ine">foreach</strong> loop, add the following at <span class="No-Break">the end:</span></p>
			<pre class="source-code">
var memberNamesAndReasons = new List&lt;(string MemberName, string Reason)&gt;();
foreach (var symbol in symbols)
{
    var attributes = symbol.GetAttributes();
    var attribute = attributes.FirstOrDefault(_ =&gt;
      SymbolEqualityComparer.Default.Equals(
        _.AttributeClass?.OriginalDefinition,
          piiAttribute));
    if (attribute is not null)
    {
        memberNamesAndReasons.Add((symbol.Name,
          attribute.ConstructorArguments[0].Value!
           .ToString()));
    }
}
if (memberNamesAndReasons.Count &gt; 0)
{
    var @namespace = (candidate.Parent as
      BaseNamespaceDeclarationSyntax)!.Name.ToString();
    writer.WriteLine($"Type: {@namespace}
      .{candidate.Identifier.ValueText}");
    writer.WriteLine("Members:");
    foreach (var (memberName, reason) in
      memberNamesAndReasons)
    {
        var reasonText = string.IsNullOrEmpty(reason) ? "No
          reason provided" : reason;
        writer.WriteLine($"  {memberName}: {reasonText}");
    }
    writer.WriteLine(string.Empty);
}</pre>
			<p>The code<a id="_idIndexMarker701"/> iterates<a id="_idIndexMarker702"/> the symbols by looking at any attributes. If the symbol has <span class="No-Break">the </span><span class="No-Break"><strong class="source-in ine">[Personal</strong></span><strong class="source-in ine">
IdentifiableInformation]</strong> attribute, it’s added to the <span class="No-Break"><strong class="source-in ine">memberNamesAndReason</strong></span><span class="No-Break"> list.</span></p>
			<p>If there are members in the <strong class="source-in ine">memberNamesAndReason</strong> list, it outputs the type and the members with <span class="No-Break">the reason.</span></p>
			<p>Now, you can build your application (in the <span class="No-Break"><strong class="source-in ine">Chapter16</strong></span><span class="No-Break"> folder):</span></p>
			<pre class="console">
dotnet build</pre>
			<p>You should now see a file called <strong class="source-in ine">GDPRReport.txt</strong> in your project folder. Open it and confirm that you’re seeing something similar to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Type: Chapter16.Employee
Members:
  FirstName: Needed for registration
  LastName: Needed for registration
  SocialSecurityNumber: Needed for uniquely identifying an
    employee</pre>
			<p>Having this level of transparency in your code and the ability to show it to official auditors is great. It shows you have control over compliance and this will ultimately help you in the long run. You could also version this file by simply adding it to your source code repository and then during release builds, you could commit any changes <span class="No-Break">to it.</span></p>
			<p>It is different to work with extending the compiler itself, it is a somewhat different runtime environment from what you’d expect in normal application development. You’ve<a id="_idIndexMarker703"/> probably<a id="_idIndexMarker704"/> already started asking how to debug and might have experi<a id="_idTextAnchor289"/>enced your code not working even though it <span class="No-Break">should have.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor290"/>Improving the developer experience</h1>
			<p>Working with the <a id="_idIndexMarker705"/>Roslyn compiler can be hard. After all, it’s running inside the context of the compiler. One way to ease the pain is to do unit testing and actually test all your code from tests, something we <a id="_idTextAnchor291"/>will look into more in <a href="B19418_17.xhtml#_idTextAnchor299"><span class="No-Break"><em class="ita ic">Chapter 17</em></span></a>, <em class="ita ic">Static </em><span class="No-Break"><em class="ita ic">Code Analysis</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor292"/>Debugging</h2>
			<p>However, sometimes, you<a id="_idIndexMarker706"/> just simply need to see things with your bare eyes through the debugger. The technique I use for this is to add the following code into my Roslyn <span class="No-Break">extension code:</span></p>
			<pre class="source-code">
while (!System.Diagnostics.Debugger.IsAttached)
Thread.Sleep(10);</pre>
			<p>Then, I can put breakpoints for the places at which I want to break and then attach the debugger. You want to attach it to the compiler and it typically shows up like <span class="No-Break">the<a id="_idTextAnchor293"/> following:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B19418_16_02.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – Compiler process to attach to caching</p>
			<p>Another thing that can be painful is if you’re doing changes in the extension and these are not reflected. There are a couple of reasons why this might be the case. One is that it doesn’t see any changes during an incremental build in the project using the extension. You can clean the build output by doing <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet clean</pre>
			<p>Otherwise, you can run the build telling it to not perform an incremental build <span class="No-Break">as follows:</span></p>
			<pre class="console">
dotnet build --no-incremental</pre>
			<p>Another condition that could occur is that compiler holds a build server in memory that caches things and optimizes the developer experience. Sometimes, you need to shut it down. You do tha<a id="_idTextAnchor294"/>t by issuing <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet build-server shutdown</pre>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor295"/>Optimization</h2>
			<p>A form of optimization <a id="_idIndexMarker707"/>that can be applied to source generators is to use the incremental source generator approach. It combines the syntax receiver and generator and runs consistently while the build server is running, providing code generation as you type in the editor (for editors that <span class="No-Break">support it).</span></p>
			<p>Working with the compiler can be a bit tedious,<a id="_idTextAnchor296"/> but is totally worth it when you get <span class="No-Break">everything </span><span class="No-Break"><a id="_idIndexMarker708"/></span><span class="No-Break">working.</span></p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor297"/>Summary</h1>
			<p>In this chapter, we explored how to leverage Roslyn compiler extensions for generating code at compile time. We looked at the basics of generating additional code for the compiler. We also looked at how you can leverage the Roslyn source generators to generate files other than C#, which is a powerful technique that can increase productivity and also provide true <span class="No-Break">business value.</span></p>
			<p>You should now have an understanding of what C# code generators are and how you can implement one. And hopefully, you also have a few ideas brewing of what you can use <span class="No-Break">it for.</span></p>
			<p>As I mentioned in the chapter, we use the compiler’s extensibility and ability to generate code to actually generate TypeScript code. This has proven to be a major productivity boost for our developers. There are some code generators already out there that take OpenAPI definitions and convert them into JavaScript or TypeScript, but they’re then limited to what this standard supports. And if you want it to be in a certain shape, or support a specific frontend framework, that might not be enough. We had these requirements and then decided on building an extension that supports <span class="No-Break">our needs.</span></p>
			<p>In the next chapter, we’ll take things a step further and explore how to use Roslyn compiler extensions for static code analysis. As you might have picked up thus far, I tend to focus on code quality. Coming up, we’ll explore how to build custom code analyzers and code fixes, and we’ll see how these tools can be used to automatically detect and correct <span class="No-Break">coding issues.</span></p>
		</div>
	</body></html>