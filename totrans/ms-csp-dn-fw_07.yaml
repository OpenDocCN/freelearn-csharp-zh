- en: Chapter 7. NoSQL Database Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：NoSQL 数据库编程
- en: In this chapter, we're going to review an emerging database paradigm that totally
    remodels the structure of data, **NoSQL databases**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一个新兴的数据库范式，它完全改变了数据结构，**NoSQL 数据库**。
- en: 'In brief, I will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我将涵盖以下主题：
- en: A historical context about NoSQL databases and their role in current development
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 NoSQL 数据库及其在当前开发中的作用的历史背景
- en: Available offers in this area and their main advantages and disadvantages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该领域的可用方案及其主要优缺点
- en: The architectural model followed by the distinct flavors of NoSQL databases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的 NoSQL 数据库所遵循的架构模型
- en: MongoDB as the NoSQL database of choice and its foundations and main features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 作为首选的 NoSQL 数据库及其基础和主要特性
- en: CRUD operations in MongoDB
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 中的 CRUD 操作
- en: We'll end with a review on how to integrate and use MongoDB from Visual Studio
    and manage CRUD operations within the IDE
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将以如何在 Visual Studio 中集成和使用 MongoDB 以及在 IDE 内管理 CRUD 操作的回顾结束
- en: In the last few years, companies such as Google, eBay, Facebook, Bosch, Forbes,
    LinkedIn, Marriot, PayPal, Ryan Air, Symantec, or Yammer have solutions that use
    these databases, to name just a few.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，谷歌、易贝、Facebook、博世、福布斯、领英、万豪、贝宝、瑞安航空、赛门铁克或 Yammer 等公司都有使用这些数据库的解决方案，仅举几个例子。
- en: 'If we take a look at the statistics published by the specialized site DB-Engines,
    results showing utilization rates are pretty clear, where some no-SQL databases
    appear among the top 10 in use today (especially MongoDB):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看专业网站 DB-Engines 发布的统计数据，显示使用率的成果非常清晰，其中一些非关系型数据库出现在目前使用的前十名中（尤其是 MongoDB）：
- en: '![NoSQL Database Programming](img/image00554.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![NoSQL 数据库编程](img/image00554.jpeg)'
- en: Therefore, there's a growing trend around these database systems, and it's especially
    meaningful that MongoDb shows up in the fourth position. The first five companies
    mentioned earlier use MongoDb for different purposes and scenarios.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，围绕这些数据库系统出现了一种日益增长的趋势，MongoDb 出现在第四位尤其有意义。前面提到的前五家公司使用 MongoDb 用于不同的目的和场景。
- en: A brief historical context
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要的历史背景
- en: Until the second half of the nineties, nobody would doubt that SQL and Relational
    Model databases were the *de facto* standard and a large majority of commercial
    implementations in use those days were based on this assumption.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 90 年代中叶，没有人会怀疑 SQL 和关系型数据库是 *事实上的* 标准，当时大多数商业实现都是基于这个假设。
- en: Historical examples are IBM, Oracle, SQL Server, Watcom, Gupta SQLBase, and
    so on. However, with time, some voices started to claim against what was already
    called *impedance mismatch*, the different representations of data and source
    code that happen when programming in object-oriented languages to these databases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上的例子包括 IBM、Oracle、SQL Server、Watcom、Gupta SQLBase 等。然而，随着时间的推移，一些声音开始质疑当时已被称为
    *阻抗不匹配* 的问题，即当在面向对象的语言中编程到这些数据库时，数据和源代码的不同表示形式。
- en: This is something that's clearly revealed when objects or class definitions
    have to be mapped in some fashion to databases (either tables or relational schemas).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这在对象或类定义必须以某种方式映射到数据库（无论是表还是关系模式）时明显表现出来。
- en: Other problems arose from the different data types supported by both worlds,
    especially in scalar types and their operation semantics (for example, collations
    for different string interpretations), although OOP languages only consider this
    aspect in sort routines and strings are not treated as fixed, such as in RDBMS
    systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个世界支持的不同数据类型，特别是标量类型及其操作语义（例如，不同字符串解释的排序规则），出现了其他问题，尽管面向对象的语言只考虑这个方面在排序例程中，字符串也不像在
    RDBMS 系统中那样被视为固定。
- en: Besides, there were structural and integrity differences between both, not to
    mention other operational dissimilarities in manipulation and transactions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，两者之间在结构和完整性上存在差异，更不用说在操作和事务中的其他操作差异了。
- en: So, new proposals were made about object-oriented databases, in which information
    would be stored in a such a way that it becomes simple and straightforward to
    make the correspondence between the two worlds. However, these proposals didn't
    reach the commercial arena, and actually, only some niche areas, such as engineering
    and spatial databases, high energy physics, some telecommunications projects,
    and molecular biology solutions, were actually using this approach.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，提出了关于面向对象数据库的新建议，其中信息将以一种方式存储，使得在两个世界之间建立对应关系变得简单直接。然而，这些提议并没有进入商业领域，实际上，只有一些利基领域，如工程和空间数据库、高能物理、一些电信项目和分子生物学解决方案，实际上使用了这种方法。
- en: One of the problems, in the words of Martin Fowler, was that people were doing
    a lot of integration in classical databases, making it really hard to change this
    paradigm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Martin Fowler的话说，问题之一是人们在经典数据库中做了大量的集成，这使得改变这种范式变得非常困难。
- en: The NoSQL world
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL世界
- en: As social media became huge, data requirements increased too. The need to store
    and retrieve large amounts of data immediately, led to some companies involved
    in the problem to think about possible alternatives.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着社交媒体的巨大发展，数据需求也增加了。立即存储和检索大量数据的需要，导致一些参与该问题的公司开始考虑可能的替代方案。
- en: 'So, projects such as BigTable (Google) and Dynamo (Amazon) were among the first
    few attempts to find a solution to this problem. These projects encouraged a new
    movement that we now know as the NoSQL initiative, the term being proposed by
    Johan Oskarsson in a conference in California about these topics, for which he
    created the Twitter hashtag #NoSQL.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像BigTable（谷歌）和Dynamo（亚马逊）这样的项目是解决这个问题的首批尝试之一。这些项目激发了一场新的运动，我们现在称之为NoSQL运动，这个术语是由Johan
    Oskarsson在加利福尼亚州关于这些主题的会议上提出的，为此他创建了Twitter话题标签#NoSQL。
- en: We can define the NoSQL movement as a broad class of system-management databases
    that differ from the classical model of relational databases (RDBMS) in important
    facets, the most noticeable one being that they are not using SQL as the primary
    query language.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将NoSQL运动定义为一种广泛的管理数据库类别，它在重要方面与关系数据库的经典模型（RDBMS）不同，最显著的一点是它们不使用SQL作为主要的查询语言。
- en: Stored data does not require fixed structures such as tables. The result? They
    don't support JOIN operations, and they do not fully guarantee **ACID** (**atomicity**,
    **consistency**, **isolation**, and **durability**) features, which are the soul
    of the relational model. Besides, they usually scale horizontally in a very efficient
    manner.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的数据不需要固定的结构，如表。结果？它们不支持JOIN操作，并且不全面保证**ACID**（**原子性**、**一致性**、**隔离性**和**持久性**）特性，这些是关系模型的核心。此外，它们通常以非常有效的方式水平扩展。
- en: 'As a reminder: the four ACID features are defined as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下：四个ACID特性定义如下：
- en: '**Atomicity**: This is key to the Relational Model; an operation consisting
    of more than one action shall not fail in the middle. Otherwise, data will be
    left in an inconsistent state. The whole set of operations is considered a unit.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：这是关系模型的关键；由多个动作组成的操作不应在中间失败。否则，数据将处于不一致的状态。整个操作集被视为一个单元。'
- en: '**Consistency**: This extends to the previous and posterior state of the database
    after any action.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：这扩展到任何动作之后数据库的前后状态。'
- en: '**Isolation**: Along with the previous considerations, no collateral effects
    should be noticed after a transaction has finished in the database.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：除了之前的考虑，数据库中事务完成后不应注意到任何副作用。'
- en: '**Durability**: If an operation ends correctly, it will not be reversed by
    the system.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：如果一个操作正确结束，系统将不会将其撤销。'
- en: NoSQL systems are sometimes called *not only SQL* in order to underline the
    fact that they can also support query languages such as SQL, although this characteristic
    depends on the implementation and the type of database.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL系统有时被称为*不仅SQL*，以强调它们也可以支持SQL等查询语言，尽管这一特性取决于实现和数据库类型。
- en: Academic researchers refer to these databases as structured storage databases,
    a term that also covers classical relational databases. Often, NoSQL databases
    are classified according to how they store data and include categories such as
    Key-Value (Redis), BigTable/Column Family (Cassandra, HBase), Document Databases
    (MongoDb, Couch DB, Raven DB), and Graph Oriented Databases (Neo4j).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 学术研究人员将这些数据库称为结构化存储数据库，这个术语也涵盖了经典的关系数据库。通常，NoSQL数据库根据它们存储数据的方式分类，包括如键值（Redis）、BigTable/列族（Cassandra、HBase）、文档数据库（MongoDb、Couch
    DB、Raven DB）和面向图数据库（Neo4j）等类别。
- en: With the growth of real-time websites, it became clear that an increase in processing
    power for large volumes of data was required. And the solution of organizing data
    in similar horizontal structures reached corporative consensus, since it can support
    millions of requests per second.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着实时网站的兴起，很明显，需要提高处理大量数据的能力。将数据组织在类似水平结构中的解决方案得到了企业共识，因为它可以支持每秒数百万个请求。
- en: 'Many attempts have been made to categorize the different offers now found in
    the NoSQL world according to various aspects: Scalability, Flexibility, Functionality,
    and so on. One of these divisions, established by Scofield and Popescu ([http://NoSQL.mypopescu.com/post/396337069/presentation-NoSQL-codemash-an-interesting](http://NoSQL.mypopescu.com/post/396337069/presentation-NoSQL-codemash-an-interesting)),
    categorizes NoSQL databases according to the following criteria:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人尝试根据不同的方面（如可扩展性、灵活性、功能性等）对现在在NoSQL世界中发现的多种不同提供方案进行分类。Scofield和Popescu（[http://NoSQL.mypopescu.com/post/396337069/presentation-NoSQL-codemash-an-interesting](http://NoSQL.mypopescu.com/post/396337069/presentation-NoSQL-codemash-an-interesting)）提出的这些分类之一，根据以下标准对NoSQL数据库进行分类：
- en: '|   | Performance | Scalability | Flexibility | Complexity | Functionality
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|   | 性能 | 可扩展性 | 灵活性 | 复杂性 | 功能性 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **Key-value stores** | High | High | High | None | Variable (none) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **键值存储** | 高 | 高 | 高 | 无 | 可变（无） |'
- en: '| **Column stores** | High | High | Moderate | Low | Minimal |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **列存储** | 高 | 高 | 中等 | 低 | 最小 |'
- en: '| **Document stores** | High | Variable (high) | High | Low | Variable (low)
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **文档存储** | 高 | 可变（高） | 高 | 低 | 可变（低） |'
- en: '| **Graph databases** | Variable | Variable | High | High | Graph theory |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **图数据库** | 可变 | 可变 | 高 | 高 | 图论 |'
- en: '| **Relational databases** | Variable | Variable | Low | Moderate | Relational
    algebra |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **关系数据库** | 可变 | 可变 | 低 | 中等 | 关系代数 |'
- en: Architectural changes with respect to RDBMS
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与RDBMS相关的架构变化
- en: 'So, the first point to clarify at the time of using one of these models is
    to identify clearly which model suits our needs better. Let''s quickly review
    these unequal approaches in architecture:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用这些模型之一时，首先要明确的是清楚地识别哪个模型更适合我们的需求。让我们快速回顾这些不平等的架构方法：
- en: The key/value proposal is similar to other lightweight storage systems used
    today on the Web, especially the `localStorage` and `sessionStorage` APIs. They
    allow read/write operations for a web page in the local system's dedicated area.
    Storage is structured in pairs, the left-hand side being the key we'll use later
    on to retrieve the associated value.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键/值提议类似于今天在网络上使用的其他轻量级存储系统，特别是`localStorage`和`sessionStorage`API。它们允许在本地系统的专用区域对网页进行读写操作。存储以成对的形式组织，左侧是我们稍后用于检索相关值的键。
- en: These databases don't care about the type of information being saved as the
    value type (either numbers, documents, multimedia, and so on), although there
    might be some limitations.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些数据库不关心存储的信息类型（无论是数字、文档、多媒体等），尽管可能存在一些限制。
- en: 'The document offer is made of simple documents, where a document can be a complex
    data structure:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档提供方案由简单的文档组成，其中文档可以是复杂的数据结构：
- en: Normally, such data is represented using a JSON format, the most common format
    in use today, especially in web contexts.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，此类数据使用JSON格式表示，这是目前使用最广泛的格式，尤其是在网络环境中。
- en: The architecture allows you to read even fragments of a document or change or
    insert other fragments without being constrained by any schema.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构允许你读取文档的片段或更改或插入其他片段，而不会受到任何模式的约束。
- en: The absence of a schema, which—for many—is considered one of the best features
    of NoSQL databases, has a few drawbacks.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式的缺失，对于许多人来说，被认为是NoSQL数据库的最好特性之一，但也存在一些缺点。
- en: One of the drawbacks is that when we recover some data, let's say from a person
    (a name or an account), you're assuming an *implicit schema*, as Fowler names
    it. It's taken for granted that a person has a name field or an account field.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个缺点是，当我们从某人（例如，一个名字或一个账户）恢复一些数据时，你是在假设一个*隐式模式*，正如Fowler所命名的那样。人们默认认为一个人有一个名字字段或账户字段。
- en: Actually, most of implementations rely on the existence of an ID, which works
    like the key in a key/value store in practice.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，大多数实现都依赖于ID的存在，这在实践中就像键/值存储中的键一样工作。
- en: So, we can think of these two approaches as similar and belonging to a type
    of aggregate oriented structure.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们可以将这些两种方法视为相似，并且属于一种面向聚合的结构类型。
- en: In the Column family model, the structure defines a single key (named a row
    key), and associated with it, you can store families of columns where each one
    is a set of related information.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列族模型中，结构定义了一个单一键（称为行键），与之相关联，你可以存储列族，其中每个列都是一个相关信息的集合。
- en: Thus, in this model, the way to access information is using the row key and
    the column family name, so you need two values for data access, but still, the
    model reminds the idea of the aggregated model.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，在这个模型中，访问信息的方式是使用行键和列族名称，因此你需要两个值来访问数据，但模型仍然保留了聚合模型的想法。
- en: Finally, the graph-oriented model fragments information in even smaller units
    and relates those units in a very rich, connected manner.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，图导向模型将信息分解成更小的单元，并以非常丰富、紧密的方式将这些单元联系起来。
- en: They define a special language to allow complex interweaving to take place in
    a way that would be difficult to express in other types of databases, including
    RDBMs.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们定义了一种特殊语言，允许以在其他类型数据库（包括RDBMS）中难以表达的方式复杂交织。
- en: As we mentioned earlier, most NoSQL databases don't have the capacity of performing
    joins in queries. Consequently, the database schema needs to be designed in another
    way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，大多数NoSQL数据库没有在查询中执行连接的能力。因此，数据库模式需要以另一种方式设计。
- en: This has led to several techniques when relational data has to be managed in
    a NoSQL database.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了在关系数据需要在NoSQL数据库中管理时出现几种技术。
- en: Querying multiple queries
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询多个查询
- en: This idea relies on the fast response feature typical of these databases. In
    lieu of getting all data in a simple request, several queries are chained in order
    to get the desired information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法依赖于这些数据库典型的快速响应特性。为了在简单请求中获取所有数据，通常会链式执行多个查询以获取所需的信息。
- en: If the performance penalty is not acceptable, other approaches are possible.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能损失不可接受，其他方法也是可能的。
- en: The problem of nonnormalized data
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非规范化数据的问题
- en: 'The issue in this case is solved with a distinct approach: instead of storing
    foreign keys, the corresponding foreign values are stored together with the model''s
    data.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，问题通过一种独特的方法得到解决：不是存储外键，而是将相应的外值与模型数据一起存储。
- en: Let's imagine blog entries. Each one can also relate and save both username
    and user ID, so we can read the username without requiring an extra query.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下博客条目。每个条目也可以关联并保存用户名和用户ID，因此我们可以读取用户名而不需要额外的查询。
- en: The shortcoming is that when the username changes, the modification will have
    to be stored in more than one place in the database. So, this kind of approach
    is handy when the average of reads (with respect to write operations) is fairly
    substantial.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，当用户名更改时，修改将不得不在数据库中的多个地方存储。因此，当读操作（相对于写操作）的平均值相当大时，这种方法很方便。
- en: Data nesting
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据嵌套
- en: As we will see in the practices with MongoDB, a common practice is based on
    placing more data in a smaller number of collections. Translated into practice,
    this means that in the blogging application we imagined earlier, we could store
    comments in the same document as the blog's post document.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在MongoDB的实践中看到的那样，一种常见的做法是基于将更多数据放在更少的集合中。在实践中，这意味着在之前想象的博客应用程序中，我们可以在博客帖子文档中存储评论。
- en: In this way, a single query gets all the related comments. In this methodology,
    there's only a single document that contains all the data you need for a specific
    task.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，一个查询就可以获取所有相关的评论。在这种方法中，只有一个文档包含执行特定任务所需的所有数据。
- en: Actually, this practice has become a de facto practice given the absence of
    a fixed schema in these databases.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于这些数据库中没有固定的模式，这种做法已经变成了一个事实上的实践。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In other words, the philosophy followed here is more or less *save your data
    in such a way that the number of storage units implied in a query is minimum*
    (optimally, only one).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这里遵循的哲学是尽可能地将数据保存得使查询所需的存储单元数量最小（理想情况下，只有一个）。
- en: 'The terminology that''s used changes as well. The following table succinctly
    explains the equivalence in terms of relations between SQL and NoSQL databases:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的术语也会发生变化。以下表格简要说明了SQL和NoSQL数据库之间在关系方面的等价性：
- en: '| SQL | MongoDB |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| SQL | MongoDB |'
- en: '| --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Database | Database |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | 数据库 |'
- en: '| Table | Collection |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 表 | 集合 |'
- en: '| Row | Document or BSON document |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 行 | 文档或BSON文档 |'
- en: '| Column | Field |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 字段 |'
- en: '| Index | Index |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 索引 |'
- en: '| Table joins | Embedded documents (with linking) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 表连接 | 嵌入式文档（带链接） |'
- en: '| Primary key (unique column or column combinations) | Primary key (automatically
    set to the `_id` field in MongoDB) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 主键（唯一列或列组合） | 主键（在MongoDB中自动设置为`_id`字段） |'
- en: '| Aggregation (for example, by group) | Aggregation pipeline |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 聚合（例如，按组） | 聚合管道 |'
- en: About CRUD operations
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于CRUD操作
- en: In the case of MongoDB, which we'll use in this chapter, a read operation is
    a query that targets a specific collection of documents. Queries specify criteria
    (conditions) that identify which documents MongoDB has to return to the client.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将使用的MongoDB的情况下，一个读取操作是对特定文档集合的查询。查询指定了（条件）标准，以确定MongoDB必须返回给客户端的文档。
- en: 'Any query needs to express the fields required in the output. This is solved
    using a projection: a syntax expression that enumerates the fields indicating
    the matching documents. The behavior of MongoDB follows these rules:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 任何查询都需要表达输出中所需的字段。这通过投影来解决：一个语法表达式，列出了指示匹配文档的字段。MongoDB的行为遵循以下规则：
- en: Any query is aimed for a single collection
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何查询都是针对单个集合的
- en: The query syntax allows you to establish filters, ordering, and other related
    limitations
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询语法允许您建立过滤器、排序和其他相关限制
- en: No predefined order is used unless the `sort()` method forms a part of the query
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非`sort()`方法成为查询的一部分，否则不使用预定义的顺序
- en: All CRUD operations use the same syntax, with no difference between reading
    and modification operations
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有CRUD操作使用相同的语法，在读取和修改操作之间没有区别
- en: Queries with a statistical character (aggregation queries) use the $match pipeline
    to allow access to the queries' structure
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有统计特性的查询（聚合查询）使用$match管道来允许访问查询的结构
- en: Traditionally, even in the relational model, those operations that change information
    (create, update, or delete) have their own syntax (DDL or DML in que SQL world).
    In MongoDB, they are noted as data modification operations, since they modify
    data in a single collection. However, for update operations, a conceptual division
    is usually made in order to distinguish punctual updates (modifications) from
    totally changing updates (replacements). In this case, only the `_id` field is
    preserved.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，即使在关系型模型中，那些改变信息（创建、更新或删除）的操作也有它们自己的语法（在SQL世界中是DDL或DML）。在MongoDB中，它们被称为数据修改操作，因为它们在一个单独的集合中修改数据。然而，对于更新操作，通常会有一个概念上的划分，以区分点更新（修改）和完全更改的更新（替换）。在这种情况下，只有`_id`字段被保留。
- en: 'To summarize, the operational offer can be resumed in this way:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，操作提供可以概括如下：
- en: Adding information is performed with insert operations (either with new data
    to an existing collection or by adding a new document)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加信息是通过插入操作完成的（要么是将新数据添加到现有集合中，要么是添加新文档）
- en: 'Changes adopt two forms: while updates modify the existing data, remove operations
    totally delete data from a given collection'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更采用两种形式：更新修改现有数据，删除操作则完全从给定的集合中删除数据
- en: These three operations don't affect more than one document in a single process
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个操作在单个过程中不会影响超过一个文档
- en: 'As mentioned earlier, update and remove can use different criteria to establish
    which documents are updated or removed:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，更新和删除可以使用不同的标准来确定哪些文档被更新或删除：
- en: There is a clear similarity in the syntax used for these operations and the
    one used in pure reading queries
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些操作使用的语法与纯读取查询使用的语法有明显的相似性
- en: Actually, some of these operations are piped, that is, linked to the previous
    query by chained calls
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，其中一些操作是管道化的，也就是说，通过链式调用与前面的查询相链接
- en: 'So, in the case of MongoDB, we would have a schema like what is shown in below:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在MongoDB的情况下，我们会有一个如下所示的架构：
- en: '![About CRUD operations](img/image00555.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![关于CRUD操作](img/image00555.jpeg)'
- en: MongoDB on Windows
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB on Windows
- en: Of course, if we want to follow the samples in this chapter, an installation
    of MongoDB is required on our local machine. You can do this from the official
    site ([https://www.mongodb.com](https://www.mongodb.com)), where you'll find the
    installation software for the most popular operating systems (Windows, Mac, Linux,
    and Solaris).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们想遵循本章中的示例，需要在我们的本地机器上安装MongoDB。你可以从官方网站([https://www.mongodb.com](https://www.mongodb.com))进行安装，那里提供了适用于最流行操作系统的安装软件（Windows、Mac、Linux和Solaris）。
- en: You'll also find different editions of the product, including an Enterprise
    version for different flavors of Mongo. For the purpose of this topic, we can
    use the popular Community Edition Server version and download and install it using
    the `.msi` file resulting from the process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会找到产品的不同版本，包括针对Mongo不同版本的Enterprise版本。为了本主题的目的，我们可以使用流行的Community Edition
    Server版本，并使用过程生成的`.msi`文件下载和安装它。
- en: 'As the documentation indicates, the installer includes all other software dependencies
    and will automatically upgrade any older version of MongoDB that''s previously
    been installed. The current version (at the time of writing this) is 3.2.6, and
    it changes periodically. The process only takes a few seconds:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档说明，安装程序包括所有其他软件依赖项，并将自动升级之前安装的任何旧版MongoDB。当前版本（在撰写本文时）是3.2.6，并且会定期更新。这个过程只需几秒钟：
- en: '![MongoDB on Windows](img/image00556.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![MongoDB on Windows](img/image00556.jpeg)'
- en: File structure and default configuration
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件结构和默认配置
- en: As a result of the installation, a set of files will appear in the `Program
    Files/MongoDB` directory, containing a number of utilities and tools, plus the
    server itself. The main files to keep track of are `mongod.exe`, which is the
    server executable, and the command-line utility (`mongo.exe`), which provides
    a set of interactive options and allows data operations as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 安装的结果，一组文件将出现在`Program Files/MongoDB`目录中，包含许多实用程序和工具，以及服务器本身。需要关注的主要文件是`mongod.exe`，它是服务器可执行文件，以及命令行实用程序（`mongo.exe`），它提供了一套交互式选项，并允许数据操作。
- en: 'If you launch the server, a command window will show up, presenting some default
    configuration parameters:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动服务器，将弹出一个命令窗口，显示一些默认配置参数：
- en: It creates a default data directory in `c:\data\db`, which is the default physical
    location of its internal data as well as the user's. Within this directory, a
    journal data file is created by default. It can be changed with a `mondod –dbpath
    U:\datapath` command.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在`c:\data\db`创建一个默认的数据目录，这是其内部数据以及用户的默认物理位置。在此目录中，默认创建一个日志数据文件。可以使用`mondod
    –dbpath U:\datapath`命令进行更改。
- en: Another storing location is initialized in `c:\data\db\diagnostic.data`, especially
    dedicated to activity monitoring.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个存储位置在`c:\data\db\diagnostic.data`初始化，专门用于活动监控。
- en: Port `27017` is assigned to start listening for connections via TCP. You can
    change it in the configuration or by calling `Mongod.exe` with the `--port` [number]
    argument.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口`27017`被分配用于通过TCP监听连接。你可以在配置中更改它，或者通过带有`--port` [number] 参数调用`Mongod.exe`。
- en: At this point, you can start interacting with the database. To do this, in a
    command-line fashion, you should use `mongo.exe`. Once launched, you can ask for
    help, and an initial list of commands will be presented.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以开始与数据库交互。为此，在命令行方式下，你应该使用`mongo.exe`。一旦启动，你可以请求帮助，并将显示初始命令列表。
- en: 'A simple `show dbs` command will output, in my case, two databases that are
    present (previous databases of prior installations are not deleted, since they
    are located at another directory):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`show dbs`命令将输出，在我的情况下，有两个现有的数据库（之前安装的数据库不会删除，因为它们位于另一个目录）：
- en: '![File structure and default configuration](img/image00557.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![文件结构和默认配置](img/image00557.jpeg)'
- en: In order to connect to a given database, we can type `use <db_name>` as the
    capture shows. This command also allows the creation of a new database. Hence,
    if the database exists, MongoDB switches to it; otherwise, it creates a new one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到特定的数据库，我们可以像截图所示那样输入`use <db_name>`。此命令还允许创建一个新的数据库。因此，如果数据库存在，MongoDB将切换到它；否则，它将创建一个新的数据库。
- en: 'A more useful feature allows you to ask for help on a concrete database. For
    example, if our `Personal` database contains a `People` collection, we can ask
    for specific help with a commands such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有用的功能允许你请求对具体数据库的帮助。例如，如果我们的`Personal`数据库包含一个`People`集合，我们可以使用以下命令请求具体帮助：
- en: '[PRE0]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another helpful utility is `mongoimport.exe`, which allows you to import data
    from a physical file we might have. We''ll use this tool to import a flat JSON
    file obtained from the Union Cicliste International ([http://www.uci.ch/road/ranking/](http://www.uci.ch/road/ranking/))
    with the stats for 2016\. Once we move the file to the `c:\data\db` directory
    (this can be done from another location anyway), we can use the following command
    to import this data into a new database:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的实用工具是 `mongoimport.exe`，它允许您从可能拥有的物理文件中导入数据。我们将使用此工具导入从国际自行车联盟（[http://www.uci.ch/road/ranking/](http://www.uci.ch/road/ranking/））获得的2016年统计数据扁平JSON文件。一旦我们将文件移动到
    `c:\data\db` 目录（无论如何都可以从另一个位置完成），我们就可以使用以下命令将此数据导入到新的数据库中：
- en: '[PRE1]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After this, we can start querying the database once we switch into it and find
    the first document in our collection:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换到数据库后，我们可以开始查询数据库并找到我们集合中的第一个文档：
- en: '![File structure and default configuration](img/image00558.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![文件结构和默认配置](img/image00558.jpeg)'
- en: As you can see, the first command tells us the number of documents inserted,
    and the next one retrieves the first document. There's something to point out
    here, and that is the `_id` element in the document. It is automatically inserted
    by the importing process in order to uniquely identify each document in the collection.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第一个命令告诉我们插入的文档数量，下一个命令检索第一个文档。这里有一点需要指出，那就是文档中的 `_id` 元素。它是导入过程自动插入的，以便在集合中唯一标识每个文档。
- en: Some useful commands
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些有用的命令
- en: 'Usually, we can use the big collection of commands provided by Mongo to query
    the database in different ways. For example, if I want to list all cyclists from
    Great Britain, I can write the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以使用Mongo提供的庞大命令集以不同的方式查询数据库。例如，如果我想列出所有来自大不列颠的自行车手，我可以编写以下代码：
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, in order to filter information, the `find()` method expects a criteria
    written using the object notation syntax, which is typical of JavaScript. However,
    we can also select one from the total number of results, indicating it with an
    array syntax:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了过滤信息，`find()` 方法期望使用对象表示法语法编写的标准，这是JavaScript的典型语法。然而，我们也可以使用数组语法从总数中选择一个：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can imagine, other options allow the projection of the required elements
    in a document instead of retrieving the whole one. For instance, we can ask for
    the names and ages of all the cyclists from Spain in this list using the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，其他选项允许在文档中投影所需元素，而不是检索整个文档。例如，我们可以使用以下代码请求列表中所有来自西班牙的自行车手的姓名和年龄：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The numbers associated with the fields to be retrieved only indicate presence
    required (we want them in the output list) if they're bigger than 0 or absence
    if they are 0.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与要检索的字段相关的数字仅表示需要存在（我们希望在输出列表中）如果它们大于0，或者如果它们是0则表示不存在。
- en: 'Let''s say we need the list of Italian cyclists with their names and teams
    and no other field. We can type the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要意大利自行车手的列表，包括他们的姓名和车队，而不需要其他字段。我们可以输入以下内容：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Other combinations allow you to use JavaScript declarations to retrieve partial
    information that can be used later to get another result set. Here, we load the
    query into a variable and call it directly:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 其他组合允许您使用JavaScript声明来检索可以用于获取另一个结果集的部分信息。在这里，我们将查询加载到变量中并直接调用它：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Operators
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作符
- en: 'The list of available operators in MongoDB is quite large, and they can be
    categorized according to the purpose in three main categories, as the official
    documentation shows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB中可用的操作符列表相当庞大，根据官方文档的说明，它们可以根据用途分为三个主要类别：
- en: Query and projection
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询和投影
- en: Update
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: Aggregation pipeline
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合管道
- en: 'Each of these categories contains a large number of options, so you can refer
    to the official documentation for more details ([https://docs.mongodb.com/manual/reference/operator/](https://docs.mongodb.com/manual/reference/operator/)).
    For the purpose of this chapter, we''ll use a few of the most common operators
    that appear in everyday work with MongoDB. The following table lists the most
    used operators:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些类别都包含大量的选项，因此您可以参考官方文档以获取更多详细信息（[https://docs.mongodb.com/manual/reference/operator/](https://docs.mongodb.com/manual/reference/operator/)）。为了本章的目的，我们将使用在MongoDB日常工作中出现的一些最常见的操作符。以下表格列出了最常用的操作符：
- en: '| Operator | Description |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$eq` | Matches values that are equal to a specified value |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `$eq` | 匹配等于指定值的值 |'
- en: '| `$gt` | Matches values that are greater than a specified value |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `$gt` | 匹配大于指定值的值 |'
- en: '| `$gte` | Matches values that are greater than or equal to a specified value
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `$gte` | 匹配大于或等于指定值的值 |'
- en: '| `$lt` | Matches values that are less than a specified value |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `$lt` | 匹配小于指定值的值 |'
- en: '| `$lte` | Matches values that are less than or equal to a specified value
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `$lte` | 匹配小于或等于指定值的值 |'
- en: '| `$ne` | Matches all values that are not equal to a specified value |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `$ne` | 匹配所有不等于指定值的值 |'
- en: '| `$in` | Matches any of the values specified in an array |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `$in` | 匹配数组中指定的任何值 |'
- en: '| `$nin` | Matches none of the values specified in an array |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `$nin` | 匹配数组中指定的所有值 |'
- en: 'Note that you can find some of these operators in different contexts or domain
    queries: for instance, most of the operators in the preceding table are also present
    in the set of operators linked to the Aggregation pipeline.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以在不同的上下文或域查询中找到一些这些运算符：例如，前面表格中的大多数运算符也存在于与聚合管道相关的运算符集中。
- en: 'Another important clue is that these areas provide mechanisms to deal with
    information in many ways depending on the context. Actually, many of the operators
    that we find available in the SQL Server or Oracle RDBMS have an equivalent here,
    always preceded by the `$` sign. For example, you can use the arithmetic operators
    in the Aggregation pipeline to create calculated fields, or you can use some mathematical
    operators defined as MongoDB commands, that remind, even syntactically, those
    that we can find in the Math static class in C# or JavaScript: `$abs`, `$ceil`,
    `$log`, `$sqrt`, and so on.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的线索是，这些区域提供了根据上下文以多种方式处理信息的机制。实际上，我们在 SQL Server 或 Oracle RDBMS 中找到的许多运算符在这里都有等效项，总是以
    `$` 符号开头。例如，您可以使用聚合管道中的算术运算符来创建计算字段，或者您可以使用作为 MongoDB 命令定义的一些数学运算符，这些运算符甚至在语法上都与我们在
    C# 或 JavaScript 中的 Math 静态类中可以找到的运算符相似：`$abs`、`$ceil`、`$log`、`$sqrt` 等等。
- en: 'This happens with other typical RDBMS operators, such as the aggregation operators
    commonly used in statistical queries: `$sum`, `$avg`, `$first`, and so on. Other
    common families of operators that facilitate management operations are Date operators,
    String operators, Array operators, and Set operators.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这在其他典型的 RDBMS 运算符中也会发生，例如在统计查询中常用到的聚合运算符：`$sum`、`$avg`、`$first` 等等。其他常见的运算符家族，有助于管理操作，包括日期运算符、字符串运算符、数组运算符和集合运算符。
- en: The way to use them always depends on the context of the operation to be performed.
    In queries, we can embed them as part of the expressions that serve as the filtering
    criteria. However, keep in mind that the operand and operator form an object expression
    criteria. Also, remember that several of these expressions can be indicated with
    comma separation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们的方式始终取决于要执行的操作的上下文。在查询中，我们可以将它们嵌入为作为过滤标准的表达式的一部分。然而，请记住，操作数和运算符形成一个对象表达式标准。此外，请记住，这些表达式中的几个可以用逗号分隔表示。
- en: 'Let''s imagine that we want the list of cyclists with more than 1,000 points
    and less than 1,300 points. We could express it as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们想要一个拥有超过 1,000 分且少于 1,300 分的自行车手的列表。我们可以这样表达：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Observe that there's an implicit AND operator in the way we express the points
    limits (the minimum and maximum) separated by commas.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在用逗号分隔的值（最小值和最大值）表达分数限制时隐含了一个 AND 运算符。
- en: 'The OR operator can also be expressed in this manner (`$or`), but the syntax
    for some cases requires careful separation of concerns. Let''s imagine a case
    where we need to find a cyclist belonging to Commonwealth, for example. We need
    an `$or` operator to express this condition according to this syntax (we''re omitting
    other nations not present on the list for brevity):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: OR 运算符也可以用这种方式表达（`$or`），但某些情况下的语法需要仔细分离关注点。让我们想象一个需要找到属于英联邦的自行车手的案例，例如。我们需要一个
    `$or` 运算符来根据这种语法表达这个条件（为了简洁，我们省略了列表上没有的其他国家）：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Effectively, the results of such query would be as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，此类查询的结果如下：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Altering data – the rest of CRUD operations
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改数据——CRUD 操作的其余部分
- en: 'The operations that modify the contents of our database are represented by
    three methods:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 修改我们数据库内容的行为由三个方法表示：
- en: '**Add**: `insert()`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加**：`insert()`'
- en: '**Delete**: `remove()`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：`remove()`'
- en: '**Modify**: `update()`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改**：`update()`'
- en: 'For example, in the first case, we can express the insertion in a JavaScript
    variable and use that variable to pass it to to the `insert()` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第一种情况下，我们可以将插入操作表示为一个JavaScript变量，并使用该变量将其传递给`insert()`方法：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that there's an extra line from Mongo, indicating that a new document
    has been inserted (also, an array can be passed for a multiple insertion).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Mongo多了一行，这表明已经插入了一个新的文档（此外，也可以传递一个数组进行多个插入）。
- en: Besides, there's another important factor we already mentioned, which has to
    do with flexibility. Let's say we want to include another important runner from
    the US, such as Tejay Van Garderen, but in this case, we have some extra information
    related to the details of his nation, such as `State` (`Washington`) and `City`
    (`Tacoma`) he was born in. We want to include this information in the collection.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个我们之前提到的重要因素，这与灵活性有关。假设我们想包括来自美国的另一位重要跑步者，比如Tejay Van Garderen，但在这个情况下，我们有一些与他国家细节相关的额外信息，比如他出生的`State`（华盛顿）和`City`（塔科马）。我们希望将这些信息包含在集合中。
- en: 'We will proceed in the same way, only assigning to the `Nation` value a complex
    value made of three fields: `Name`, `State`, and `City`. We can proceed in exactly
    the same way as earlier but with these changes included.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照相同的方式进行，只是将一个由三个字段组成的复杂值分配给`Nation`值：`Name`、`State`和`City`。我们可以像之前一样进行，但包括这些更改。
- en: 'After the process, a look at the content will show the information structure
    inserted, along with its new values:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程之后，查看内容将显示插入的信息结构及其新的值：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The insertion went fine, but I made a (copy/paste) mistake and didn't change
    the name of the runner properly (the rest of the data is fine, but the name has
    to be modified). So, we can use the `update()` command in order to achieve this
    goal.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 插入过程很顺利，但我犯了一个（复制/粘贴）错误，没有正确更改跑步者的名字（其余数据都正常，但名字必须修改）。因此，我们可以使用`update()`命令来实现这个目标。
- en: 'It''s simple; we just have to localize the target document as the first parameter
    and indicate the new data as the second parameter:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；我们只需要将目标文档作为第一个参数本地化，并将新数据作为第二个参数指示：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The results: one document found and one modified.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：找到一份文档并修改了一份。
- en: Text indexes
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本索引
- en: 'Now, we want to list all the cyclists from the United States in our collection.
    MongoDB provides an interesting possibility: create a text index to be used later
    in text searches. At creation time, we can indicate which text fields (along with
    their data types) need to be included in the index; for example, take a look at
    the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要列出我们集合中所有来自美国的自行车手。MongoDB提供了一个有趣的选项：创建一个文本索引，稍后用于文本搜索。在创建时，我们可以指定需要包含在索引中的文本字段（及其数据类型）；例如，看看以下内容：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the previous code, we have indexed two fields, and the total number of
    indexes now is two (remember that the `_id` index is created automatically). This
    is perfect for practical usage, since we now can write the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的代码，我们已经索引了两个字段，现在索引总数为两个（记住`_id`索引是自动创建的）。这对于实际使用来说很完美，因为我们现在可以编写以下内容：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the search was made without indicating the position of the string
    in the field. The output shows both documents with their different data structures
    for the `Nation` field.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，搜索时没有指定字符串在字段中的位置。输出显示了具有不同`Nation`字段数据结构的两个文档。
- en: 'If we don''t have any indexes, it is also possible to use other operators for
    search, such as `$in`, which uses the following syntax prototype:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有索引，也可以使用其他运算符进行搜索，例如`$in`，它使用以下语法原型：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we can rewrite a similar query containing all cyclists from France and
    Spain as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将包含所有来自法国和西班牙的自行车手的类似查询重写如下：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For deletion, the procedure is pretty straightforward. Just remember that deletions
    affect one or more documents depending on the criteria defined for the operation.
    In this case, remember that there is no equivalent to the cascade behavior we
    might configure in the relational model.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除，程序相当直接。只需记住，删除根据操作定义的标准会影响一个或多个文档。在这种情况下，请记住，在关系型模型中可能配置的级联行为在MongoDB中是没有等效的。
- en: MongoDB from Visual Studio
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB from Visual Studio
- en: You can find plenty of drivers for MongoDB directly on the MongoDB official
    site, including several versions for the C# language, which currently stands for
    version 2.2.3\. This driver provides support for the version of MongoDB I'm using
    in this book (v. 3.2).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在MongoDB官方网站上找到许多MongoDB驱动程序，包括几个C#语言的版本，目前代表版本2.2.3。此驱动程序支持我在本书中使用的MongoDB版本（v.
    3.2）。
- en: Actually, this version was created and tested in Visual Studio 2015, so that's
    another reason to use it here. You can find a whole page with explanations, links
    to other resources, videos, articles, community supported tools, presentations,
    and so on at the [https://docs.mongodb.com/ecosystem/drivers/csharp/](https://docs.mongodb.com/ecosystem/drivers/csharp/)
    address. This driver is the officially supported driver for MongoDB.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个版本是在Visual Studio 2015中创建和测试的，这也是在这里使用它的另一个原因。您可以在[https://docs.mongodb.com/ecosystem/drivers/csharp/](https://docs.mongodb.com/ecosystem/drivers/csharp/)地址找到一个包含解释、其他资源链接、视频、文章、社区支持工具、演示文稿等内容的一整页。此驱动程序是MongoDB的官方支持驱动程序。
- en: 'First demo: a simple query from Visual Studio'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首次演示：从Visual Studio执行简单查询
- en: There are several approaches for driver's installation, but you can install
    it using NuGet from Visual Studio, so we'll start by building a new Console project
    (ConsoleMongo1), and after that, select the NuGet Window interactive. Once there,
    typing `MongoDB` will show a bunch of libraries, including the official driver
    in the first position.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于驱动程序的安装，有几种方法，但您可以使用Visual Studio中的NuGet来安装它，因此我们将首先构建一个新的控制台项目（ConsoleMongo1），然后选择NuGet窗口交互。一旦进入，键入`MongoDB`将显示一系列库，包括位于首位的官方驱动程序。
- en: 'As you can see in the following screenshot, three libraries are installed:
    two versions of MongoDB driver (core and standard) and Mongo.BSon, which contains
    a serialization infrastructure that you can use to build high-performance serializers:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在下面的屏幕截图中所见，安装了三个库：两个版本的MongoDB驱动程序（核心和标准）以及包含序列化基础设施的Mongo.BSon，您可以使用它来构建高性能序列化器：
- en: '![First demo: a simple query from Visual Studio](img/image00559.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![首次演示：从Visual Studio执行简单查询](img/image00559.jpeg)'
- en: To work with MongoDB from C#, the driver offers a set of convenient objects,
    which in great part, represent those we have been using in the Mongo Command Window
    to perform previous operations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用C#与MongoDB交互，驱动程序提供了一组方便的对象，其中大部分代表我们在Mongo Command Window中执行先前操作时所使用的内容。
- en: Before any operation, it's important to remember that NoSQL structures are flexible,
    but in order to work properly from the C# side, it's more useful to have a structure
    for our data (a data model or contract). To do this, we can copy and paste a single
    document from our database and use the **Paste as JSON** option, which will convert
    the structure to a set of classes containing the keys defined in the document
    as classes' fields.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何操作之前，重要的是要记住，NoSQL结构是灵活的，但为了从C#端正确工作，拥有一个数据结构（数据模型或合约）更有用。为此，我们可以从我们的数据库中复制并粘贴单个文档，并使用**粘贴为JSON**选项，这将结构转换为包含文档中定义的键作为类字段的类集。
- en: 'For the demos in this part, I''ve opted for another database source, which
    is more similar to what we would use in a real application. For this purpose,
    a possible source is the NorthWind JSON website, which offers JSON versions of
    the popular NorthWind database used for years in Microsoft Access and SQL Server
    as the demo database. You can find the database at [http://northwind.servicestack.net/customers?format=json](http://northwind.servicestack.net/customers?format=json).
    I''ve downloaded two tables from here: `Customers` and `Orders`. Remember that
    through the import process, a new field named `_id` will be generated.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本部分的演示，我选择了另一个数据库源，它更类似于我们会在实际应用中使用的内容。为此目的，一个可能的数据源是NorthWind JSON网站，它提供了多年来在Microsoft
    Access和SQL Server中用作演示数据库的流行NorthWind数据库的JSON版本。您可以在[http://northwind.servicestack.net/customers?format=json](http://northwind.servicestack.net/customers?format=json)找到这个数据库。我从这里下载了两个表：`Customers`和`Orders`。请记住，在导入过程中，将生成一个名为`_id`的新字段。
- en: 'When you use the **Paste as JSON** option, its `_id` field will be assigned
    to a string, but internally, it is really an `ObjectId` type. To avoid problems
    later, you can change it manually to have a definition like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用**粘贴为JSON**选项时，其`_id`字段将被分配为一个字符串，但内部实际上是一个`ObjectId`类型。为了避免以后出现问题，您可以手动将其更改为如下定义：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let''s make a simple query that we can list in the Console window. To achieve
    this, we need to reference the previously mentioned libraries and follow the basic
    steps: connect to the NorthWind database, get a reference to a collection, define
    the query (we can use Linq and/or a generic functionality for this purpose), and
    present the results.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们做一个简单的查询，我们可以在控制台窗口中列出。为了实现这一点，我们需要引用前面提到的库并遵循基本步骤：连接到 NorthWind 数据库，获取集合的引用，定义查询（我们可以为此使用
    Linq 和/或泛型功能），并展示结果。
- en: 'An initial, simple approach would be as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个初始的简单方法如下：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you launch the application, a Console window will show the requested set
    of customers:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您启动应用程序，控制台窗口将显示请求的客户集：
- en: '![First demo: a simple query from Visual Studio](img/image00560.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![第一次演示：从 Visual Studio 的简单查询](img/image00560.jpeg)'
- en: So, let's quickly review the process here. MongoClient represents a connection
    to the MongoDB server. It follows a reference to the required database. Once there,
    we get the Customers collection, but since we already know the customers type
    and its members, we can use generics to express that, indicating that the result
    of calling `GetCollection<Customer>("Customers")` is of that type (note that the
    collection is a plural name).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们快速回顾一下这个过程。`MongoClient` 代表与 MongoDB 服务器的连接。它遵循对所需数据库的引用。一旦到达那里，我们获取 `Customers`
    集合，但由于我们已经知道客户类型及其成员，我们可以使用泛型来表示这一点，表明调用 `GetCollection<Customer>("Customers")`
    的结果就是那种类型（注意，集合是复数名称）。
- en: When the collection variable is ready, it can be used as any other generic collection,
    so we can use lambda expressions, LINQ, and all other resources just the same
    as we did in previous chapters.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合变量准备好后，它可以像任何其他泛型集合一样使用，因此我们可以使用 lambda 表达式、LINQ 以及所有其他资源，就像我们在前面的章节中所做的那样。
- en: Note, though, that we've run a query in a synchronous mode. When the amount
    of data available (to search for) is high, asynchronous operations are recommended.
    Therefore, let's make the query a bit more complex and run it this way.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们已经以同步模式运行了一个查询。当可用的数据量（要搜索的）很大时，建议使用异步操作。因此，让我们使查询更加复杂，并以这种方式运行它。
- en: 'For example, let''s assume that we need to know which customers from the United
    States or the United Kingdom are owners as well (the `CustomerTitle` field values
    `Owner`). So, we need a bit more complex filter. And we also want the process
    to be asynchronous, to avoid blocking errors or unresponsive user interfaces.
    Thus, we''ll use the `async`/`await` operators to build a method in this manner:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要知道来自美国或英国的哪些客户同时也是所有者（`CustomerTitle` 字段的值是 `Owner`）。因此，我们需要一个更复杂的过滤器。我们还希望这个过程是异步的，以避免阻塞错误或无响应的用户界面。因此，我们将使用
    `async`/`await` 操作符以这种方式构建一个方法：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, now we perform the query asynchronously (in a non-blocking fashion), with
    just a few changes, getting a couple of entries:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在以异步方式（非阻塞方式）执行查询，只需进行一些更改，就可以获取几个条目：
- en: '![First demo: a simple query from Visual Studio](img/image00561.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![第一次演示：从 Visual Studio 的简单查询](img/image00561.jpeg)'
- en: Note that besides using the `async`/`await` operators, the end of the query
    varies a little. We now call the `toListAsync()` method from the `Result` object
    in order to get the final collection. The rest is like what is done in the previous
    (synchronous) method.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了使用 `async`/`await` 操作符之外，查询的结尾略有变化。我们现在从 `Result` 对象中调用 `toListAsync()`
    方法以获取最终的集合。其余的就像在先前的（同步）方法中所做的那样。
- en: CRUD operations
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRUD 操作
- en: As you can imagine, CRUD operations are fully supported, especially when using
    this new version of the driver, which includes various new possibilities.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，CRUD 操作完全受支持，尤其是在使用此新版本的驱动程序时，它包括各种新的可能性。
- en: Most of these operations are presented in two main families depending on whether
    you want to deal with only one or many documents in the collection. Consequently,
    we find methods such as `DeleteOne`/`DeleteMany, InsertOne`/`InsertMany`, `ReplaceOne`/`ReplaceMany`,
    and so on. In turn, they present synchronous and asynchronous versions for each
    one.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作中的大多数都根据您是否只想处理集合中的一个或多个文档分为两大类。因此，我们发现方法如 `DeleteOne`/`DeleteMany`、`InsertOne`/`InsertMany`、`ReplaceOne`/`ReplaceMany`
    等。反过来，它们为每个方法提供同步和异步版本。
- en: Deletion
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除
- en: 'For instance, in order to delete a single customer, we can use the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了删除单个客户，我们可以使用以下方法：
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see that we're using a very convenient method, which allows us to find
    and delete a single document in a sole (atomic) operation (`FindOneAndDeleteAsync`).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们使用了一种非常方便的方法，它允许我们在单一（原子）操作中找到并删除单个文档（`FindOneAndDeleteAsync`）。
- en: 'Also, we''ve changed the `BasicQuery` method to receive a string with the country
    to be listed, and we call that method again just after the deletion to check whether
    everything was okay. Now there''s only one customer from that country:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将 `BasicQuery` 方法更改为接收一个包含要列出国家的字符串，并在删除后立即再次调用该方法以检查一切是否正常。现在该国只有一个客户：
- en: '![Deletion](img/image00562.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![删除](img/image00562.jpeg)'
- en: As a note, remember that if no document is found, any possible exception thrown
    by the application, should be handled in the usual manner.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作为备注，请记住，如果没有找到文档，应用程序抛出的任何可能的异常都应该按照常规方式处理。
- en: Insertion
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入
- en: 'Insertion follows a similar pattern. We create a new customer following the
    contract definition and insert it asynchronously using a simple, straightforward
    code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 插入遵循类似的模式。我们根据合同定义创建一个新客户，并使用简单直接的方式异步插入：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If everything''s okay, we''ll be shown an output like what is shown in the
    following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们将看到以下截图所示的输出：
- en: '![Insertion](img/image00563.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![插入](img/image00563.jpeg)'
- en: Modifications and replacements
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改和替换
- en: Working with document collections, it's common to distinguish between updates
    and replacements. In the first case, we're managing something similar to the `UPDATE`
    clause in standard SQL language.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文档集合时，通常区分更新和替换。在第一种情况下，我们管理的是类似于标准 SQL 语言中 `UPDATE` 子句的内容。
- en: The second situation deals with a total replacement of a document, with an exception
    made of the `_id` field, which is immutable. In this case, since there's no fixed
    model to follow, the information replaced could be totally different from the
    previous one.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况涉及文档的完全替换，但 `_id` 字段除外，它是不可变的。在这种情况下，由于没有固定的模型可以遵循，替换的信息可能与之前的信息完全不同。
- en: To replace content, it's handy to use static methods of the `Builders` class,
    which provides the C# driver. We can define a generic `Builder` class for our
    customers and use the `Filter` and `Update` methods to locate and replace a given
    document.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换内容，使用 `Builders` 类的静态方法很方便，该类提供了 C# 驱动。我们可以为我们的客户定义一个通用的 `Builder` 类，并使用
    `Filter` 和 `Update` 方法定位和替换指定的文档。
- en: 'The following code does exactly that: it locates the previously inserted company
    and changes the `CompanyName` field to another string:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码正是如此：它定位之前插入的公司并将 `CompanyName` 字段更改为另一个字符串：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note I have included another version of the `BasicQuery` method, called `BasicQueryByCompany`,
    in order to allow the returning of the modified field in the output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我包含了一个名为 `BasicQueryByCompany` 的 `BasicQuery` 方法版本，以便允许在输出中返回修改后的字段：
- en: '![Modifications and replacements](img/image00564.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![修改和替换](img/image00564.jpeg)'
- en: In the case of replacements, you can use the `ReplaceOneAsync` and `ReplaceManyAsync`
    methods, just like what we did for the update.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换的情况下，您可以使用 `ReplaceOneAsync` 和 `ReplaceManyAsync` 方法，就像我们为更新所做的那样。
- en: 'In addition, most typical operations you might be used to in SQL databases
    are present here as well: grouping, statistical results, security configuration,
    and so on.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SQL 数据库中您可能习惯的大多数典型操作也在这里：分组、统计结果、安全配置等等。
- en: 'Adoption of NoSQL databases is another story: scalability, availability, previous
    knowledge of NoSQL, and the learning curve are only a few of the considerations
    you might ponder at the time of selecting one of these databases in a new project.
    Whatever the case may be, support from most of the available NoSQL databases from
    the .NET platform is guaranteed for the majority of implementations, so that shouldn''t
    be an issue.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 数据库的采用是另一回事：可扩展性、可用性、对 NoSQL 的先前知识以及学习曲线只是你在选择新项目中这些数据库之一时可能考虑的几个因素。无论如何，大多数可用的
    NoSQL 数据库从 .NET 平台的支持对于大多数实现都是保证的，因此这不应该是一个问题。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Along the course of this chapter, we went through the foundations and basics
    of NoSQL databases, starting with their historical evolution and the several types
    of architectures and peculiarities linked to this storage approach and a list
    of the most typical implementations we can find today.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们了解了 NoSQL 数据库的基础和基本知识，从它们的历史演变开始，到与这种存储方法相关的多种架构和特性，以及我们今天可以找到的最典型实现列表。
- en: We also explored the correct manner in which the CRUD operations should be managed
    in these contexts from a general-purpose point of view.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从通用角度探讨了在这些环境中如何正确管理CRUD操作。
- en: Then, we moved on to MongoDB, analyzing the details of its installation and
    management in a Windows system, prior to starting the use of a MongoDB instance
    by means of its default (command-line) tools in order to operate and import, manipulate,
    list, and modify its contents without any external tool in order to study the
    low-level mechanisms behind its usage.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向MongoDB，分析其在Windows系统中的安装和管理细节，在开始使用MongoDB实例的默认（命令行）工具操作和导入、操作、列出和修改其内容之前，无需任何外部工具以研究其使用背后的底层机制。
- en: Finally, we used the C# driver available on the official MongoDB website in
    order to accomplish the same CRUD operations from a Console application, including
    the most typical actions required in LOB applications.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了在官方MongoDB网站上可用的C#驱动程序，从控制台应用程序中完成相同的CRUD操作，包括在LOB应用程序中所需的最典型操作。
- en: In the next chapter, we'll look at how to use some of the—many—resources and
    projects available as Open Source, which are monitored and actively supported
    by Microsoft these days, and that includes the Roselyn services, the new TypeScript
    language, and others.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用一些——众多——作为开源资源可用的项目和工具，这些资源和项目如今由微软监控并积极支持，包括Roselyn服务、新的TypeScript语言以及其他。
