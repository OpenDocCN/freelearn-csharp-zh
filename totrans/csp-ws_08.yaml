- en: 8\. Creating and Using Web API Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will step into the world of HTTP practice by making calls
    to Web APIs. You will interact with Web APIs in a variety of ways using a web
    browser, your own HTTP client, and NuGet packages. You will learn the basics of
    security involved in Web APIs, use PayPal to make sandbox payments, and explore
    cloud services such as Azure Text Analytics and Azure Blob storage.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to read HTTP requests and response
    messages, make calls to any Web API, and create your own HTTP client to simplify
    your work with complex APIs. You will also be able to dissect and learn both incoming
    HTTP requests and outgoing HTTP responses in any form and use development tools
    in the Chrome browser to inspect traffic moving back and forth when browsing your
    favorite websites.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The World Wide Web (WWW) (or just the web) is a big store of all sorts of documents
    (XML, JSON, HTML, MP3, JPG, etc.) accessible through Uniform Resource Locators
    (URLs). A document in the context of the web is often called a resource. Some
    resources do not change. They are stored somewhere, and with every request, the
    same resource will be returned. Such resources are called static. Other resources
    are dynamic, which means they will be generated on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Communication on the web happens through protocols. In the context of retrieving
    documents, you use Hypertext Transfer Protocol (HTTP). Hypertext is a special
    text that holds a link to a resource on the web. Clicking on it opens the resource
    it points to. HTTP is based on a client-server architecture. In simple terms,
    a client sends requests, and the server responds. An example of this in practice
    is the communication between a browser (client) and a website (hosted on a server).
    Usually, a single server serves many clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Client-server architecture ](img/B16835_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Client-server architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you navigate to a website, you send an `HTTP GET` request, and the server
    responds by displaying the relevant site content in the browser. `GET` is an HTTP
    verb—a method identifying how a request should be treated. Common HTTP verbs are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Get a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Create a resource or send a complex query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Update all resource fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: Update a single field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Remove a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A modern browser is more than just a tool to access content on the internet.
    It includes tools to dissect elements of a website, inspect traffic, and even
    execute code. This side of a browser is called developer tools. The exact key
    binds may vary but pressing `F12` or `Control + Shift + I` should call up the
    Developer Tools tab. Perform the following steps to get to know it better:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Google Chrome or any other browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to [google.com](http://google.com). Press the keys `Control + Shift
    + I`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `Network` (`1`). The following window should be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2: Chrome with developer tools open with google.com loaded ](img/B16835_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Chrome with developer tools open with google.com loaded'
  prefs: []
  type: TYPE_NORMAL
- en: Select the first entry, [www.google.com](http://www.google.com) (`2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Headers` (`3`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `General` (`4`) section, you can observe the effects when you navigated
    to [google.com](http://google.com). The first thing that happened was `HTTP GET`
    request was sent to [https://www.google.com/](https://www.google.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Request Headers` section (`5`), you can see the metadata sent with the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see how Google responded, click the `Response` section (`6`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This flow is called the client-server architecture, and the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The client is the Chrome browser that sends a request to [google.com](http://google.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server is a machine(s) hosting [google.com](http://google.com) that responds
    with [google.com](http://google.com) website contents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Application Programming Interface (API) is an interface through which you
    can call some functionality using code. It could be a class or an interface in
    C#, or a browser (you can interact with it through code provided by its own interface),
    but in the context of HTTP, it is a web service. A web service is an API hosted
    on a remote machine that is accessible through HTTP. An access point used to invoke
    a single piece of functionality on a Web API is called an endpoint. The most commonly
    used Web API type is RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Representational State Transfer (REST) API is an API built on the following
    six principles. Four principles are a given whatever framework you use implementing
    a RESTful API, and, as a client, they should be expected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Client-server: A connection is made between a client and server. The client
    sends a request in order to get a response from a server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stateless: The server will be able to process requests regardless of prior
    requests. This means that each request should contain all the information, rather
    than relying on a server to remember what happened before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cacheable: The ability to specify which requests can be cached using HTTP methods
    or headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code on demand (optional): REST allows scripts to be downloaded and executed
    on the client side. Back when the internet was made mostly of static pages, this
    was useful, but nowadays it is either not needed or is seen as a security risk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the other two principles (Client-server and Stateless) depend on you,
    and thus you will want to pay more attention to them. A layered system is a system
    made of layers, and each layer communicates only with the layer directly below
    it. A typical example of this is a three-tier architecture, where you separate
    presentation, business logic, and the data store. From a practical point of view,
    this means that a RESTful API (business logic layer) should not send HTML as a
    response because the responsibility for rendering output lies with the client
    (the presentation layer).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last principle is called a uniform interface. It defines a set of rules
    for an API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identification of resources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some examples of these are get all instances of a resource (`/resource`), create
    a resource (`/resource`), get a single resource (`/resource/id`), and get all
    instances of a subresource in a resource (`/resource/subresource/`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Manipulation of resources through these representations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources are manipulated using HTTP verbs representing Create, Read, Update,
    and Delete (CRUD)—`GET`, `UPDATE`, `PUT`, `PATCH`, `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Self-descriptive messages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A response that includes all the required information, without any extra documentation,
    and indicates how the message should be processed (headers, mime type, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: 'Hypermedia as the engine of application state (HATEOAS):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperlinks are included in response to all the related resources so that you
    can navigate to them. This guideline is usually ignored.
  prefs: []
  type: TYPE_NORMAL
- en: REST is not the same as HTTP. REST is a set of guidelines, while HTTP is a protocol.
    The two might be confused because HTTP constraints heavily overlap with REST constraints
    (methods, headers, etc.). However, a RESTful API does not have to use HTTP to
    be RESTful, and at the same time HTTP can violate REST constraints by using a
    session or query parameters to provide actions to perform. A RESTful API can work
    with both XML and JSON data formats. However, almost all scenarios involve JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Postman is one of the most popular tools used for testing different kinds of
    Web APIs. It is easy to set up and use. Postman, just like a browser, acts as
    an HTTP client. In order to download Postman, go to [https://www.postman.com/](https://www.postman.com/).
    You will need to sign up and then download the installer. Once you have installed
    Postman, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your workspace by clicking `Workspaces` and then click on `Create Workspace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new window, go to the `Collections` tab (`2`) and click the `Create new
    Collection` (`+`) button (`3`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `New Collection` (`4`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on `Add a request` (`5`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3: New Postman collection without requests ](img/B16835_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: New Postman collection without requests'
  prefs: []
  type: TYPE_NORMAL
- en: A new request window will open.
  prefs: []
  type: TYPE_NORMAL
- en: Click the edit symbol beside `New Request` and name the new request `Users` (`6`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `GET` HTTP verb and copy-paste the URL [https://api.github.com/users/github-user](https://api.github.com/users/github-user)
    (`7`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, and in all places that follow, replace `github-user` with your own GitHub
    username.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the `Send` button (`8`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now scroll down to see the response result returned (`9`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4: GET GitHub user request in Postman ](img/B16835_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: GET GitHub user request in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: Postman is superior to a browser when it comes to acting as an HTTP client.
    It is focused on forming HTTP requests and displays response information compactly,
    offering multiple output formats. In Postman, you can use multiple environments,
    set up pre-and post-conditions for requests, automated calls, and a lot more,
    but going through those advanced features is beyond the scope of this chapter.
    For now, it is enough to learn that Postman is a go-to tool for testing Web APIs
    by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST requires communication between a client and a server. In the previous examples,
    the client role was taken by either a browser or Postman. However, neither a browser
    nor Postman can replace a client in your code. Instead, you'll need to create
    an HTTP request using C#.
  prefs: []
  type: TYPE_NORMAL
- en: Popular Web APIs often have a client created for you (in most common languages
    as well). The purpose of a Web API client is to simplify interactions with the
    underlying API. For example, instead of sending a `DELETE` request on an endpoint
    that does not support it and getting the response `Method Not Allowed`, you won't
    even have such an option on a custom client.
  prefs: []
  type: TYPE_NORMAL
- en: Octokit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Octokit is a GitHub API client. It exposes a C# class through which you can
    pass objects to make calls to GitHub. The benefit of such a client is that you
    don't need to worry about which headers to pass or how to name things so that
    they are properly serialized. An API client handles all that for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the Octokit client in your project by running the following
    command in the VS Code terminal or command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the Octokit client installed, you can use it to create a GitHub
    client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, you needed a new `ProductHeaderValue` because GitHub
    expects a `UserAgent` header. As mentioned earlier, custom HTTP clients prevent
    a mistake from happening before you can even make a request. In this case, not
    providing a `UserAgent` header (through `ProductHeaderValue`) is not an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see whether the client works, try to get information on the username `github-user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In GitHub, `github-user` is displayed as `Almantask`. It is better to change
    it to your individual GitHub username for the code to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the date when the user was created, type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Every method available on the GitHub API is also available on **GitHub client
    Octokit**. You don't need to worry about the endpoint, mandatory headers, a response,
    or the request format; it is all defined by the strongly typed client.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/DK2n2](https://packt.link/DK2n2).
  prefs: []
  type: TYPE_NORMAL
- en: API Key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With many public free APIs, you may be faced with concerns such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How can you control an overwhelming number of requests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At what point should which client be charged?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all these public APIs offered only anonymous access, you would not be able
    to identify the clients or determine how many calls each of them has made. An
    API key serves as the most basic means of authentication (identifying the client)
    and authorization (granting them access to do something with an API). Simply put,
    an API key allows you to call an API. Without it, you would have little to no
    access to an API.
  prefs: []
  type: TYPE_NORMAL
- en: To help you grasp the use of API keys better, the next section will look at
    a Web API that requires one, that is, Azure Text Analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Text Analytics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Azure Text Analytics is an Azure API used to analyze text in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify named entities (people, events, organizations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpret the mood of the text (positive, negative, neutral)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce a summary of a document or highlight key phrases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process unstructured medical data, such as recognizing people, classifying diagnoses,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to demonstrate the Azure Text Analytics API, you will focus on sentimental
    analysis. This is the process of evaluating text according to a positive, negative,
    or neutral confidence score:'
  prefs: []
  type: TYPE_NORMAL
- en: The score of 1, which means 100%, is the probability that the prediction (negative,
    positive, neutral) is correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The score of 0, which means 0%, is an impossible prediction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Azure Text Analytics is free until you analyze more than 5,000 words per
    30 days.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before you begin coding, you'll need to set up Azure Text Analytics on the Azure
    cloud. After all, you need both an endpoint and an API key to make a call to this
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have set up an Azure subscription. If you don't have one, go to
    [https://azure.microsoft.com/en-gb/free/search](https://azure.microsoft.com/en-gb/free/search)
    and follow the instructions there to create a **free** subscription. An Azure
    free trial offers many services for free. Some of those services will remain free
    even after a year. A student subscription is an option for getting Azure credits
    and free services for a longer period. A credit or debit card is required to create
    an Azure subscription; however, you won't be charged unless you exceed the given
    Azure credits of the free service limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way in which Azure Text Analytics could be used to sort positive and negative
    feedback is by determining whether what you wrote sounds passive-aggressive or
    friendly. To see this in action, follow the steps to create a small application
    that analyzes any text you input into a console:'
  prefs: []
  type: TYPE_NORMAL
- en: First, go to [https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics](https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click `Continue to create your resource` without using any additional features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5: Azure Text Analytics resource creation ](img/B16835_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Azure Text Analytics resource creation'
  prefs: []
  type: TYPE_NORMAL
- en: In the Create text analytics window, click the `Basics` tab. This is the first
    tab opened at the start of the creation of a new resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select an option in the `Subscription` and `Resource group` fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.6: Entering the project details for new resource creation ](img/B16835_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Entering the project details for new resource creation'
  prefs: []
  type: TYPE_NORMAL
- en: Then, select the region, for example, `North Europe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name, for example, `Packt-Test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, select the `Free F0` pricing tier and click the `Review + create` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7: Azure Text Analytics pricing tier ](img/B16835_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Azure Text Analytics pricing tier'
  prefs: []
  type: TYPE_NORMAL
- en: A new window gets displayed confirming your input.
  prefs: []
  type: TYPE_NORMAL
- en: Click the `Create` option. The Text Analytics API will start deploying. After
    the deployment of the service is done, a new window will open saying `Your deployment
    is complete`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the `Go to resource` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.8: The Text Analytics API showing the deployment as complete ](img/B16835_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: The Text Analytics API showing the deployment as complete'
  prefs: []
  type: TYPE_NORMAL
- en: The Text Analytics resource window gets displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `Keys and Endpoint` option. You will see the `Endpoint` option along
    with `KEY 1` and `KEY 2` to make calls to this API. You can choose from either
    of the keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9: Azure Text Analytics quick start window with API key hyperlink
    ](img/B16835_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Azure Text Analytics quick start window with API key hyperlink'
  prefs: []
  type: TYPE_NORMAL
- en: Keep track of `KEY 1` (an API key). An API key is a secret and should not be
    exposed in plain text. You will once again be using the environment variables
    to store it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an environment variable with key and value pair. The value will be the
    endpoint API key required to connect to Azure Text Analytics. To help identify
    the missing environment variable, use a helper class. The `GetOrThrow` method
    will get a user environment variable, and if it doesn''t exist, will throw an
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Keep track of the `Endpoint` option. You will use it in the upcoming exercise
    to call the API you have just deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This section helped you to set up Azure Text Analytics on the Azure cloud, in
    addition to setting both an endpoint and an API key to make a call to the API.
    In the following exercise, you will be using the Azure Text Analytics client to
    make calls to the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.01: Performing Sentimental Text Analysis on Any Text'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Text Analytics is just another REST API. Once again, you make HTTP calls
    to it and get a response. This time, you will send over a text to get its sentimental
    analysis. Do another practice run of using a strongly typed client and make calls
    to a RESTful API from C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a recently deployed Azure Text Analytics service (`Pack-Test`, in this
    case), perform sentimental analysis on any text you want. Perform the following
    steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `Azure.AI.TextAnalytics` NuGet package to get an Azure Text Analytics
    API client as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `TextAnalysisApiKey` environmental variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then add the `TextAnalysisEndpoint` environmental variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `Demo` class and add references to the two environmental variables
    that you have recently added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These properties are used to hide sensitive values of the API key and endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `BuildClient` method to build an API client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The API client requires both a base URL—a kind of Unified Resource Identifier
    (URI)—and an API key to operate, both of which are passed to it during initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the client, create the `PerformSentimentalAnalysis` method to analyze
    the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you are using the configuration object `AnalyzeSentimentOptions` to extract
    targets and opinions on them. The client has both the `AnalyzeSentimentAsync`
    and `AnalyzeSentiment` methods. For public client libraries, exposing both async
    and non-async versions of the same method is a very common scenario. After all,
    not everyone will be comfortable with an async API. However, when making calls
    to another machine (DB, API, and similar) it's best to use an async API. This
    is because an async call will not block the thread on which the call is made while
    it is waiting for a response from an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a `DisplaySentenceSymmary` function to display the sentence''s overall
    evaluation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `DisplaySentenceOpinions` function to display the message `Opinions`
    for every target in a sentence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The target of a sentence is a subject that has an opinion (grammatical modifier)
    applied to it. For example, with the sentence, **a beautiful day**, **day** would
    be a target and **beautiful** an opinion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a sentimental analysis on text typed in a console, create a `SentimentAnalysisExample`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The analysis text, in the preceding code snippet, evaluates the overall text's
    sentiment and then breaks it down into sentences, evaluating each.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how your code works, create a static `Demo.Run` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the environment variable set correctly, the following output should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You did not hardcode the value of an API key here because an API key, exposed
    publicly, poses a risk of being used not the way it was intended to. If stolen,
    it could have disastrous consequences (for example, being overused, creating a
    false resource, leaking data, deleting data, etc.). That is why when dealing with
    secrets, use the minimal possible countermeasures, that is, environmental variables.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of environment variables is the ability to have a different
    value in different environments (local, integration, system test, production,
    etc.). Different environments often use different resources. So, pointing to those
    resources through environment variables will not require any changes to the code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to run this exercise, go to [https://packt.link/GR27A](https://packt.link/GR27A)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `await Exercises.Exercise01.Demo.Run();`. Similarly, uncomment the respective
    exercises'/examples'/activities' code lines in `Program.cs` before executing each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/y1Bqy](https://packt.link/y1Bqy).
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is just one of the many in which you consumed a public Web API.
    Azure is full of services like this. Calling an API using a strongly typed client
    is simple; however, not all APIs have one. In the next section, you will learn
    how to create your own Web API client.
  prefs: []
  type: TYPE_NORMAL
- en: Your Own Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you've only used a premade client to consume a Web API. However, for
    less popular APIs, there will not be any client for you to use. In those cases,
    you will have to make HTTP calls yourself. In .NET, the way of making calls has
    evolved quite a lot. If you don't want any third-party libraries, you can use
    the `HttpClient` class.
  prefs: []
  type: TYPE_NORMAL
- en: HttpClient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you''ll repeat the GitHub `Users` example (from the *Postman*
    section), but this time using `HttpClient`. The flow for this is quite simple
    and is described for you in detail in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `GitHttp` static class, create the `GetUser` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `GitExamples` method, first, create a client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a client almost always involves specifying a specific base URL. Often,
    Web APIs require mandatory headers to be passed, or else they will invalidate
    the request (`400 Bad Request`). For GitHub, you need to send the `User-Agent`
    header identifying the client that calls the API. Adding the `Packt` user agent
    header to default headers will send that header with every request to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'You then create a request as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember to replace `github-user` with your own GitHub username. Here, you've
    specified that you want to create a `GET` request. You did not specify a full
    path, but rather only the endpoint you want to hit; therefore, you had to flag
    `UriKind` as `Relative`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, send a request using the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is only an async version of sending an HTTP request message, so you need
    to wait for it. The result of sending `HttpRequestMessage` is `HttpResponseMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, deserialize the content to a usable object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deserializing is the act of converting a structured text such as JSON into
    in-memory objects. For this, you need to convert the content to a string and then
    deserialize it. You could use a user model from Octokit NuGet. Since you are already
    making custom calls, you might as well use a custom model. For the bare minimum
    (only the fields you use), your model could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The line `[JsonProperty("created_at")]`, above `public DateTime CreatedAt {
    get; set; }`, binds the JSON field to the C# property. This binding is needed
    because the names don't match.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create your own client (for making GitHub calls), it's your responsibility
    to expose all data that the API returns and not just the data you may need for
    a particular scenario by letting the consumer choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the message from a previous call from Postman to get the GitHub user response
    body to generate models to deserialize to. In this case, the response message
    is as follows (message truncated for clarity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are many tools available that can convert JSON to the C# model.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, use [https://json2csharp.com/](https://json2csharp.com/) to convert
    JSON to the C# model code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the response (`GET github/user`) and go to [https://json2csharp.com/](https://json2csharp.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Paste the response into the textbox on the left and click the `Convert` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10: Converting JSON to the C# model code ](img/B16835_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Converting JSON to the C# model code'
  prefs: []
  type: TYPE_NORMAL
- en: The left side displays a model for the JSON, while the right side displays the
    code (C# class) that is generated from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the content on the right and paste it into your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is your model. Observe in the preceding code that `Root` is an unreadable
    class name. This is because the converter didn't have a way to know what class
    JSON represents. The `Root` class represents a user; therefore, rename it `User`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the converter was probably created prior to .NET 5, which is why it
    didn''t have a feature for records. A record is a great class for serialization
    purposes and a great candidate for a data transfer object (DTO). A DTO is a class
    that has no logic but simply data, and sometimes attributes for binding serialization.
    The benefits you get are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Value equality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToString` will return properties and their values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to define them with a less verbose syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, use a record for defining DTOs in your applications whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the (`Root` to `User`) and change the type from `class` to `record`.
    The code line looks like this with no changes needed to the properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, run the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output gets displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In order to run this exercise, go to [https://packt.link/GR27A](https://packt.link/GR27A)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `await Examples.GitHttp.Demo.Run();`. Similarly, uncomment the respective exercises'/examples'/activities'
    code lines in `Program.cs` before execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/UPxmW](https://packt.link/UPxmW).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen the benefits of using the `HttpClient` class in lieu
    of third-party libraries, you can now explore the `IDisposable` pattern in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: HttpClient and IDisposable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`HttpClient` implements the `IDisposable` pattern. In general, right after
    you are done using an object that implements `IDisposable`, you should clean up
    and call the `Dispose` method or wrap the calls within a `using` block. However,
    `HttpClient` is special in that you should not frequently create and dispose of
    it all over again. The problem with disposing and re-initializing `HttpClient`
    is that `HttpClient` manages connections it makes to other APIs and disposing
    of `HttpClient` does not properly close those connections (or sockets).'
  prefs: []
  type: TYPE_NORMAL
- en: The most dangerous part about that is that you will not notice any difference
    in developing your application locally, due to the massive number of connections
    available. However, when deploying an application to a live environment, you risk
    running out of free socket connections. Once again, avoid calling a `Dispose`
    method and reinitializing `HttpClient`. If you must, use `HttpClientFactory`.
    Not only does `HttpClientFactory` manage the lifetime of socket connections by
    managing `HttpClientMessageHandler` (the component responsible for sending the
    HTTP request and receiving the response) but it also provides logging capability,
    allows centralized management of clients' configuration, supports injecting middleware
    to clients, etc. The mentioned benefits are important if you use `HttpClient`
    in an enterprise setting. You can learn more about `HttpClientFactory` in *Chapter
    9*, *Creating API Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you should have one static `HttpClient`, which you can reuse for calls
    to Web APIs throughout your application. However, you should not have a single
    `HttpClient` for everything. The point about not disposing of `HttpClient` and
    having a static one is not a hard rule. If you call many different APIs, they
    will have their own base addresses, mandatory headers, and so on. Having a single
    object for all is not a viable scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The requests you've handled so far were publicly accessible and did not have
    security. However, expensive or private operations in Web APIs are usually protected.
    Typically, protection is set up using an Authorization header. In many cases,
    an Authorization header involves some sort of an ID and secret. In the case of
    the GitHub API, it involves a client ID and client secret. But to get them, you
    will need to create an OAuth app.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can do this though, you need to get familiar with OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OAuth is an open-standard authorization protocol that allows delegating access
    on behalf of a user. This section will explore two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-life analogy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API analogy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-life Analogy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine a child at school. The teacher of that child is organizing a trip to
    another city. A permission slip from the parents is needed. The parents give a
    note: *It''s okay for my child to go to place X.* The child gives the note to
    the teacher and gets permission to travel to a field trip to destination X.'
  prefs: []
  type: TYPE_NORMAL
- en: API Analogy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many applications are interconnected, with integrations to each other. For example,
    the famous social platform Discord allows you to display whatever accounts you
    have on other social media. But to do that, you need to connect to the platform
    of social media you want to display. For example, when you are on Discord and
    try to link a Twitter account, you will be required to log in on Twitter. A login
    will require a certain scope of access (your profile name, in this case). A successful
    login is proof that access is given, and Discord will be able to display your
    profile information on Twitter on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth App for GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Returning to the subject of GitHub, what is an OAuth app? It is a registration
    for a single point of security. It acts as your application identity. A GitHub
    user might have zero or more applications. As mentioned before, an OAuth app includes
    a client ID and secret. Through them, you can use the GitHub API. In other words,
    you can set it up to request access to secure features of GitHub, such as changing
    your personal data on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub has an interesting API limitation. If more than 60 unauthenticated requests
    come from the same IP, it will block subsequent requests for up to an hour. However,
    the rate limitation can be removed by authorizing requests. That is the prime
    reason why you will be using authorization for an otherwise public endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth usually involves two client applications:'
  prefs: []
  type: TYPE_NORMAL
- en: One that requests permission on behalf of someone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another that grants that permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, when setting up OAuth, you will most likely be required to create
    a URL to return to after the permission is granted from the client that can grant
    access. Setting up an OAuth app on GitHub involves these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top-right corner, click on your profile picture and click `Settings`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11: Account settings in GitHub ](img/B16835_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Account settings in GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left side, scroll down almost to the bottom of the menu and click the
    `Developer settings` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12: Developer settings in GitHub ](img/B16835_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Developer settings in GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now select the `Oauth Apps` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.13: Selecting OAuth apps in Developer settings in GitHub ](img/B16835_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Selecting OAuth apps in Developer settings in GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then click the `Register a new application` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.14: Creating a new OAuth app in GitHub ](img/B16835_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Creating a new OAuth app in GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you have previously created an OAuth app, then this window will display all
    those listed. In order to create a new one, you will have to click `New OAuth
    App`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next window, you will complete the form. Start by filling in `Application
    name` (`5`). Avoid using special characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, fill in `Homepage URL` (`6`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This URL usually points to a website that describes the use of OAuth for a particular
    case and why it is required. Even if you don't have a website that describes such
    a case, you can type a placeholder URL (in this case, `myapp.com`). The field
    accepts anything as long as it is a valid URL.
  prefs: []
  type: TYPE_NORMAL
- en: Fill in the `Authorization callback URL` (`7`) field. This can be whatever you
    want. Here, `myapp.com/home` is used. Use a valid callback URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click `Register application` (`8`):![Figure 8.15: New OAuth app window in GitHub
    ](img/B16835_08_15.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.15: New OAuth app window in GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new window, you will see `Client ID` and `Client secrets`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.16: Details of a new OAuth app on GitHub with app  credentials—Client
    ID and Client secrets ](img/B16835_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: Details of a new OAuth app on GitHub with app credentials—Client
    ID and Client secrets'
  prefs: []
  type: TYPE_NORMAL
- en: It is best to store a client secret in a safe place for future reference because
    you will see it only once on GitHub. If you forget it, you will have to create
    a new secret and delete the old one.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have successfully created an OAuth app on GitHub. The client secret
    is partly hidden in this screenshot for a reason. You should never expose it publicly.
    In order to use it in a demo, you will use environmental variables first to hide
    them.
  prefs: []
  type: TYPE_NORMAL
- en: So, store the values in environmental variables `GithubClientId` and `GithubSecret`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then expose the two through static properties in `Demo.cs` (explained earlier)
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This section covered the steps to set up an OAuth app in GitHub that can be
    used to request access to secure features of GitHub, such as changing your personal
    data. With this knowledge, you can now use a client ID and client secret to create
    authorized calls on the GitHub API, as demonstrated in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authorization headers come in three forms—basic, API key (or personal access
    token), and third-party authentication. The GitHub API does not allow an unlimited
    number of calls from the same source. Like the Azure Text Analytics client, it
    uses an API key as well. However, in this case, the API key is used for rate limiting
    (how many calls you can make in an hour). For anonymous calls, it only allows
    60 calls an hour. However, by using a valid Authorization header, the amount is
    increased to 5,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you''ll make one more call than the rate limit allows
    (60 + 1 = 61). That way, you will get user information 61 times. For that to happen,
    you will also make sure that the `CacheControl` header is set to `NoCache` because
    you don''t want a request to be ignored after 60 consecutive calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This block of code is an adaptation of the `GetUser` method from the *HttpClient*
    section. There are three main adjustments here:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is that everything in a loop runs 61 times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have also added an error handler, which means if a response is not a success,
    you will print an error message returned by the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, you add a `CacheControl` header to ignore caching (because you do want
    61 calls to the server).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running this code results in an error message on the sixty-first call, which
    proves the API rate limitation (the error message has been truncated for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this, you will need to add an `Authorization` header (you will add it
    just under the `CacheControl` header):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Due to GitHub's limitations on anonymous calls (for example, the fact that you
    can make only 60 requests per hour to get user profile information), you will
    find it more efficient to provide an Authorization header so that you are identified
    and therefore released from such strict constraints. In the examples that follow,
    you will get an authorization token that you will feed to this method, thus showing
    how authorization will help you overcome the rate limit.
  prefs: []
  type: TYPE_NORMAL
- en: When running the demo code placed at [https://packt.link/Uz2BL](https://packt.link/Uz2BL),
    it is recommended that you run one example at a time (i.e., uncomment one line
    and comment the rest within the `Run` method). This is because the `Demo.cs` file
    is a mix of authorized and anonymous calls, and you might get unexpected results.
    However, keep the line where you get a token as it may be required by individual
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this section, you should have grasped the logic behind the Authorization
    header and its three forms—basic, API key (or personal access token), and third-party
    authentication—and learned that, like the Azure Text Analytics client, the GitHub
    API uses an API key. Now you can move on to basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basic authentication involves a username and password. The two are usually
    combined in a single string and encoded using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code used to generate an authorization taken for basic authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a username and password to get a basic token. Then pass it to the `GetUser61Times`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Calling `GetUser61Times` no longer displays an error because the rate limitation
    is avoided by supplying an Authorization header.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/Uz2BL](https://packt.link/Uz2BL)
    and [https://packt.link/UPxmW](https://packt.link/UPxmW).
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover the more specialized API key and personal access
    token, which are similar as they both grant access to otherwise protected data.
  prefs: []
  type: TYPE_NORMAL
- en: API Key and Personal Access Token
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A personal access token is limited to personal data. However, an API key can
    be used for the whole API. Other than the scope of what can be accessed, the two
    have no difference in how they are used. You can add an API key or a personal
    access token to an Authorization header as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, of course, to use an access token of a certain API, you first need to
    create it. You can do this through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to GitHub's `Developer settings` option under `Settings` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `Personal access tokens` (`1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `Generate new token` button (`2`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.17: Creating a new personal access token ](img/B16835_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: Creating a new personal access token'
  prefs: []
  type: TYPE_NORMAL
- en: Next, enter your GitHub password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a note (this can be anything) and scroll down. This screen will help you
    to modify user data, so check the `user` checkbox (`4`) to get access to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the `Generate token` button (`5`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.18: Scope of access configured for a personal access token ](img/B16835_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.18: Scope of access configured for a personal access token'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new window, you will see all the personal access tokens, along with
    the newly added ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19: A new personal access token created on GitHub ](img/B16835_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: A new personal access token created on GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you will see the value of a token only once. So, make sure you
    copy and store it securely. Also, be aware that the personal access token expires
    after a month, at which point you need to regenerate it.
  prefs: []
  type: TYPE_NORMAL
- en: Create an environmental variable called `GitHubPersonalAccess`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the personal access token to `Demo.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will observe that calling the `GetUser61Times` method does not fail.
  prefs: []
  type: TYPE_NORMAL
- en: Access tokens, authorization tokens, API keys, and JWTs (which will be further
    covered in the following sections) are different means to prove to an API that
    you have been granted access to it and have rights to a resource you want. But
    regardless of which specific kind of authorization you use, they will usually
    all go to the same place—that is, the Authorization header.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will detail an authorization protocol called OAuth2.
  prefs: []
  type: TYPE_NORMAL
- en: Third-Party Authentication—OAuth2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitHub is an example of an authorization server. It allows access to a resource
    or functionality in the name of the owner. For example, updating the user's employment
    status is only available to a logged-in user. However, this can be done directly
    given the user has been granted the access to do so. A program getting access
    on behalf of someone is what OAuth2 is all about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to modify the user''s employment status:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to this URL or send an HTTP `GET` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `{{ClientId}}` and `{{RedirectUrl}}` are the values that you have set
    in the OAuth2 GitHub app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Replace the placeholders `{{ClientId}}` and `{{RedirectUrl}}` with the ones
    from your GitHub OAuth app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screen prompts you to log in to your GitHub app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20: Signing in to OAuth2 GitHub app ](img/B16835_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.20: Signing in to OAuth2 GitHub app'
  prefs: []
  type: TYPE_NORMAL
- en: Complete `Username` and `Password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click the `Sign in` button to log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a successful login, you will be redirected to a URL specified in your
    OAuth2 app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a request for the token by sending an HTTP `POST` request to a URI in
    the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code for it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the redirect URL was [https://www.google.com](https://www.google.com).
    The URI you ended up with was [https://www.google.com/?code=a681b5126b4d0ba160ba](https://www.google.com/?code=a681b5126b4d0ba160ba).
    The `code=` part is the code needed to get the `OAuth` access token. The token
    is returned in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Before this token can be used, you need to parse it from the response. So,
    create a function to parse the token response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This takes every `=` property and puts it into a dictionary. The string before
    `=` is a key and the string after `=` is a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `GetToken` function to create and send a request and parse a response,
    then format the token and return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, you created a request, sent it to a client, parsed the response as a
    token, and then returned it. `ValidateNoError` is commented out for now. You will
    come back to it later. The returned token should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This token is a bearer token, which is a token generated by an authorization
    server (in this case, GitHub) that grants access to GitHub on behalf of you (or
    any other username used for logging in to GitHub). You can use it to send requests
    that require special access. For example, update the employment status of a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the employment status of a user, use the `UpdateEmploymentStatus`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This block of code sets the user's property `isHireable` to `true` and prints
    the updated user information. The important part here is content; when sending
    `PUT`, `PATCH`, or a `POST` request, you often need a body with a request (or
    content in other words).
  prefs: []
  type: TYPE_NORMAL
- en: The act of converting an in-memory object into structured text (for example,
    JSON) is called serialization. In this case, a body is a user update. You send
    a `PATCH` request because you only want to change the updated values. If a value
    is not provided in the content, it should not change. That's the key difference
    between a `PATCH` and `POST` request—a successful request overrides all values
    (even if you don't provide them).
  prefs: []
  type: TYPE_NORMAL
- en: You used `new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore
    }` in order to avoid providing `null` values. This is because you do not want
    to update all the fields; just the ones you have supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating HTTP content, you also need to supply a MIME type (a type of
    media sent over with the request). It is needed so that the server has a hint
    for how it is expected to process the request. A MIME type follows this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `application/json` means that the client should expect JSON from
    a server. `application` is the most common MIME type, which means binary data.
  prefs: []
  type: TYPE_NORMAL
- en: There is also `StringContent`, which is a type of serialized content, usually
    as JSON or XML. Alternatively, you could use `StreamContent` or `ByteContent`,
    but those are slightly rarer and are used when performance or the volume of data
    is of concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the full demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `GetToken` method (used in *Step 6* of the *Third-Party Authentication
    (OAuth2)* section), there was one commented line of code, `ValidateNoError`. Uncomment
    it and implement the `GetToken` method, because you won''t always get a successful
    response, and parsing a token in that case will fail (i.e., it won''t exist).
    Therefore, it is always a good idea to validate the server response and throw
    an exception when the unexpected happens. Look at the following GitHub error format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not very readable. `ValidateNoError` will format the response and throw
    that as an exception, instead of letting it fail silently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the code again and it fails for the same reasons, the error message
    will now read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This section covered the basics of how to send HTTP requests with some sort
    of security in place. In the sections that follow (*Restsharp* and *Refit*), you
    will create clients using third-party libraries to remove some of the boilerplate
    code required by `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/UPxmW](https://packt.link/UPxmW).
  prefs: []
  type: TYPE_NORMAL
- en: Request Idempotency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An idempotent HTTP request is a request that always results in the same outcome.
    Only `GET`, `PUT`, and `PATCH` requests are idempotent because they either make
    no change or make the same change all over again, but that change does not ever
    cause an error and results in the same data. `DELETE` is not idempotent because
    deleting an already deleted item will produce an error. `POST` may or may not
    be idempotent, but that solely depends on the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: PUT, PATCH, or POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The difference between `PUT`, `PATCH`, and `POST` can be summed up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT` is used for overriding fields in a model. Even if a single value is explicitly
    provided, the whole model will have the unprovided values (or at least that''s
    the expectation). For example, if you wanted to update user details by first getting
    the old details and then sending a modified version, you would use `PUT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH` is used for updating only a single value that was provided explicitly.
    For example, if you wanted to update a username, it would make sense to send `PATCH`
    over a `PUT` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` is used for creating items or sending a complex query. Either way, the
    default expectation of this verb is to have side effects. For example, if you
    wanted to create a user, you would use a `POST` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 8.02: HttpClient Calling a Star Wars Web API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be familiar with Star Wars. There are movies, games, and TV series.
    However, did you know that it also has multiple APIs to retrieve data? The upcoming
    exercise will introduce you to a different format of an API and will make you
    familiar with deserializing slightly more complex responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a strongly typed API client that will, under
    the hood, use `HttpClient`. The client will be used to return Star Wars movies.
    You will be using Star Wars API (SWAPI) ([https://swapi.dev/](https://swapi.dev/)).
    The required endpoint is [https://swapi.dev/api/films/](https://swapi.dev/api/films/).
    Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class to hold `HttpClient` with a base URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will act as a strongly typed API client.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `/` at the end of the URI indicates that more text will be appended to the
    URI (after `api` rather than after `dev`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a type for representing a movie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is a class you will use for deserializing movies within a response. The
    `ReleaseDate` property has `[JsonProperty("release_date")]` above it to specify
    that the `"release_date"` JSON field will map to the `ReleaseDate` C# property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a type for storing results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is also a type for deserializing a movie response; however, the Star Wars
    API returns results in paginated format. It contains `Previous` and `Next` properties
    pointing to previous and next pages. For example, if you don't provide the page
    you want, it will return a value of `null`. However, the next property will point
    to the next page only if there are any elements left (otherwise it will also be
    `null`). Querying the API using next or previous as a URI will return the resources
    of that page. You used the `JsonProperty` attribute above `T Data` to provide
    JSON-to-property mapping because the property and JSON names do not match (the
    JSON field name is `results` while `Data` is the property name).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You could have changed `ApiResult` to have the `Results` property instead of
    `Data`. However, `ApiResult.Results` is a bit confusing. When writing code, instead
    of ease of automation (in this case, serialization), choose ease of maintainability
    and readability. For this reason, the name chosen in *Step 3* is different but
    clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a method to get multiple films:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You've returned a task so that others can await this method. Almost all HTTP
    calls will be `async Task`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an HTTP request to get all movies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The URI is relative because you're calling it from `HttpClient` that already
    has a base URI set.
  prefs: []
  type: TYPE_NORMAL
- en: 'To query the Star Wars API for movies, send this request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It returns `HttpResponseMessage`. There are two important parts to this: status
    code and response body. C# has a method to determine whether there were any errors
    based on the status code. To handle errors, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Error handling is important because a failed HTTP request will often result
    in an error status code rather than an exception. It's recommended you do something
    similar before trying to deserialize the response body as, if it fails, you might
    get an unexpected body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, call the `ReadAsStringAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The response has content that is more likely to be a kind of stream. To convert
    `HttpContent` to a string, call the `ReadAsStringAsync` method. This returns a
    string (JSON), which allows you to convert JSON to a C# object and deserialize
    the results. Lastly, you get the results by deserializing the response content
    body and converting it all to `ApiResult<Film>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a demo, create the client and use it to get all the Star Wars films, then
    print them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If everything is fine, you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This exercise illustrates how to create strongly typed HTTP clients for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/2CHpb](https://packt.link/2CHpb).
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that sending an HTTP request and using an HTTP client
    is very similar to the way a simple text file is sent to the GitHub API. Even
    if it was different, endpoints throughout the same API usually share the same
    requirements. However, if you manually craft an HTTP request every time you need
    to call an API, you are not being very efficient. A better way is to create something
    reusable. A common approach is to create `BaseHttpClient`. You will put this into
    practice in the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.01: Reusing HttpClient for the Rapid Creation of API Clients'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem with `HttpClient` is that you still have to manage many things
    by yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing and deserializing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mandatory headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working in a team or on a bigger project, you are likely to be making more
    than just one HTTP call. The consistency and same requirements between different
    calls need to be managed.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to show one of many ways you can simplify working
    with repetitive HTTP calls. You will be using the `BaseHttpClient` class, which
    you will create first. The class will generalize error handling and deserializing
    responses and requests, which will significantly simplify different HTTP calls
    that you make. Here, you will learn how to implement a base client by rewriting
    `StarWarsClient` using `BaseHttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a base `HttpClient` class. A base client wraps `HttpClient`. Therefore,
    you will hold a private reference to it and allow it to be created from a URL.
    The inner `HttpClient` often also includes base headers, but they are not required
    in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a way to create requests for every method. For brevity, stick to a `GET`
    request. Within a `GET` request, it is a common practice to define the default
    headers, but once again, it is not mandatory in this example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method to send requests and include error handling and deserialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In SWAPI, if you are querying multiple results, you get back `ApiResult<IEnumerable<T>>`
    for pagination. Create a `SendGetManyRequest` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the base client you have created and simplify the client from *Exercise
    8.02*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code through the same demo code but using the new version of `StarWarsClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you run the demo once again with the new `StarWarsClient`, you should see
    the same films returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to run this activity, go to [https://packt.link/GR27A](https://packt.link/GR27A)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `await Activities.Activity01.Demo.Run();`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  prefs: []
  type: TYPE_NORMAL
- en: 'Reusing `HttpClient` like that is very useful because it removes code duplication.
    However, calling a Web API and removing duplicate code is a common problem and
    is likely to be solved in some way by some libraries. The following section will
    explore how to simplify calls to a Web API using two popular NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: RestSharp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RestSharp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea behind RestSharp is very similar to the base `HttpClient`—reducing
    code duplicity. It simplifies the creation of a request and provides a lot of
    the utility for making HTTP calls. Redo `StarWarsClient` using `RestSharp`, but
    first, you''ll install the `RestSharp` NuGet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a client that is very similar to the one you created in *Activity
    8.01*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Having `RestSharp` created gives you a response serialization out of the box.
    It is also able to guess which HTTP method you will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You passed the minimum required information to make an HTTP request (calling
    films, returning `ApiResult<IEnumerable<Film>>`) and the rest is done. This is
    very much like the base client you wrote previously.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`ApiResult` is the same type used in *Exercise 8.02*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you run this code against your demo, you will notice that the `Data`
    property (on JSON) comes back as `null`. This is because you had a `JsonProperty`
    attribute on the `response` and `film` classes. RestSharp uses a different serializer,
    which does not know about those attributes. To make it work, you could either
    change all the attributes to what RestSharp comprehends or use the same serializer
    as before. You are using `Newtonsoft.Json` and, in order to use that in RestSharp,
    you need to call the `UseSerializer` method, selecting `JsonNetSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the demo, the following output gets displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The results are the same as those in *Exercise 8.02*; however, the difference
    is using the `Newtonsoft` serializer in the preceding example. `RestSharp` is
    probably the best abstraction for `HttpClient` as it minimizes the amount of code
    you need to write to make HTTP calls even while keeping its similarities with
    `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/f5vVG](https://packt.link/f5vVG).
  prefs: []
  type: TYPE_NORMAL
- en: The example aims to communicate with Web APIs using HTTP requests. Even though
    the demo files look the same, they are using either a different library or design
    pattern. In the following activity, you will practice consuming more APIs using RestSharp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.02: The Countries API Using RestSharp to List all Countries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The address [https://restcountries.com/v3/](https://restcountries.com/v3/) is
    a public web API that provides a list of all existing countries. Suppose that
    using that API, you need to get a list of all countries, find a country by its
    capital city (for example, Vilnius), and find all the countries that speak in
    a given language (for example, Lithuanian). You need to print only the first two
    country names, their regions, and their capitals, and implement a strongly typed
    client to access this API using `RestSharp`.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to make you feel more comfortable using third-party
    libraries (`RestSharp`) when making HTTP calls. Using third-party libraries often
    saves a lot of time. It allows you to reuse something that is already available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a base client class using the URL [https://restcountries.com/v3/](https://restcountries.com/v3/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigating to [https://restcountries.com/v3/](https://restcountries.com/v3/)
    will return the HTTP status code `404` with a `Page Not Found` message. This is
    because the base API URI doesn't contain any information on a resource; it is
    yet to be completed and is just the beginning of a full URI for a resource.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create models for serialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the example [https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)
    to get a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the response and then use a class generator, such as [https://json2csharp.com/](https://json2csharp.com/),
    to make models out of JSON (response).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the client, create the following methods: `Get`, `GetByCapital`, and
    `GetByLanguage`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a demo calling all three methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the countries within each response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  prefs: []
  type: TYPE_NORMAL
- en: You now know that RestSharp simplifies the creation of a request and provides
    a lot of the utilities for making HTTP calls. The next section will help you practice
    using Refit, which is another way to consume an API.
  prefs: []
  type: TYPE_NORMAL
- en: Refit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refit is the smartest client abstraction because it generates a client from
    an interface. All you have to do is provide an abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `Refit` library, first install the `Refit` NuGet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a client in Refit, first create an interface with HTTP methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please note that the endpoint here is `/films` rather than `films`. If you run
    the code with `films`, you will get an exception suggesting that you change the
    endpoint with a preceding `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve the client, simply run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On running the demo, the following output gets displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The results are the same as the ones you saw in *Exercise 8.02*; however, the difference
    is in the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/cqkH5](https://packt.link/cqkH5).
  prefs: []
  type: TYPE_NORMAL
- en: Use Refit only when your scenarios are trivial. Though Refit might seem like
    the easiest solution, it comes with its own complications when you need custom
    authorization for more complex scenarios. You will simplify the solution further
    in the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.03: The Countries API Using Refit to List all Countries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The more different ways you know of doing the same thing, the easier you can
    make a choice and pick the best tool for the job. Different teams may use different
    tools and Refit is quite a unique, minimalistic approach that you may encounter.
    Others may say it complicates work because there is too much hidden in the client
    interface (less code often does not mean that you can grasp the code easily).
    It doesn't matter whether you are for Refit or against it; it's good to have practiced
    things first-hand and formed your own opinion. This activity will help you do
    exactly that. Here, you will access the Countries API to display all countries,
    countries by their language, and by their capital city.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this activity is to show how practical Refit can be for rapid prototyping
    when it comes to consuming simple APIs. The steps for this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create models for serialization. For that, use the example [https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)
    to get a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now copy the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then use a class generator, such as [https://json2csharp.com/](https://json2csharp.com/),
    to make models out of JSON (response).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define an interface with methods: `Get`, `GetByCapital`, and `GetByLanguage`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a demo printing a country name, region, and country status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  prefs: []
  type: TYPE_NORMAL
- en: .NET has a few other native ways of creating HTTP requests, and for that, you
    can use `HttpWebRequest` or `WebClient`. The two are not deprecated and it is
    fine to use them, but they are older alternatives compared to the newer `HttpClient`.
    The next section covers all these.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you'll find out about other libraries that solve the
    problem of code duplication when using `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Other Ways of Making HTTP Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refit and RestSharp are just two of many libraries solving the problem of code
    duplication when using `HttpClient`. Flurl and TinyRest are another two popular
    alternatives. New libraries are created every year and they are ever evolving.
    There is no one best way that suits all scenarios. To be sure you make the right
    choice, you'll want to do a little research first as there are some pitfalls to
    these alternatives to consider.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClient` was designed for the lowest-level HTTP calls in .NET. It is the
    safest option because it is well-documented, tested, and allows the most freedom.
    Though there are many libraries that are much simpler to use than `HttpClient`,
    they often target basic scenarios (no authorization, no dynamically set headers).
    When it comes to creating advanced HTTP calls, they often turn out to be quite
    complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to choosing which client to use, first go for the one provided
    natively by the API. If there is no client for the API, think about the complexity
    and scope of your project. For simple, small-scope projects, use whatever NuGet
    `HttpClient` alternative you find the most convenient. But if the scope of a project
    is big and the calls are complex, use the native `HttpClient` offered by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will implement an example where using Refit will turn
    it into a complication. To fix that complication, you will use both `HttpClient`
    and RestSharp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.03: A Strongly Typed HTTP Client for Testing Payments in a PayPal
    Sandbox'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common scenario in programming is making payments. However, during the development
    stage, you don't want to use a real bank account and thus look for ways to process
    payments in a test environment—that is, a sandbox. In this exercise, you will
    learn how to call a payments sandbox API. You will use PayPal's sandbox API ([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/))
    to create an order and get the order that you have created.
  prefs: []
  type: TYPE_NORMAL
- en: 'This exercise will use `Refit` for the client interface and the implementation
    resolution. It will also use `HttpClient` to provide a way of getting `auth` headers
    for Refit. Lastly, you will use RestSharp to get an access token from within `HttpClient`.
    Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a PayPal account (either personal or business).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your location and click the `Get Started` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide your mobile number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Next` button and enter the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up your profile by entering an email address and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide your address details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now link your credit or debit card. You can also do this for free by following
    the instructions given at [https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating an account on PayPal is free. The linking of credit (or debit) card
    requirement is just a part of account creation, and it doesn't charge you. The
    payment gets refunded as soon as the authentication is confirmed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now log out of the account and go to [https://developer.paypal.com/developer/accounts/](https://developer.paypal.com/developer/accounts/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the `Log in to Dashboard` button and proceed ahead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.21: Log in to the PayPal dashboard to manage both sandbox and live
    environments ](img/B16835_08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.21: Log in to the PayPal dashboard to manage both sandbox and live
    environments'
  prefs: []
  type: TYPE_NORMAL
- en: Then enter the requested credentials and proceed to the next screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the `Accounts` option under the `Sandbox` option. You will see two test
    accounts created for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.22: Sandbox PayPal accounts for testing ](img/B16835_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.22: Sandbox PayPal accounts for testing'
  prefs: []
  type: TYPE_NORMAL
- en: You will use these accounts to do testing in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The PayPal sandbox is free.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://developer.paypal.com/developer/applications](https://developer.paypal.com/developer/applications)
    to get your client ID and secret. Just like the GitHub example, PayPal uses an
    OAuth app to provide you with a client ID and a secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For one of the default accounts, PayPal also generates a default OAuth app.
    So, click the `Sandbox` tab and select `Default Application`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.23: OAuth app creation for PayPal ](img/B16835_08_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.23: OAuth app creation for PayPal'
  prefs: []
  type: TYPE_NORMAL
- en: In the new window, inspect both `Client ID` and `Secret`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take note of both and store them in environmental variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.24: Default application details displaying Client ID and Secret
    ](img/B16835_08_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.24: Default application details displaying Client ID and Secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create properties for accessing the PayPal client ID and secret in a new empty
    class, `Exercise03.AuthHeaderHandler.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `EnvironmentVariable.GetOrThrow` helper methods are used to get the
    user's environment variable or throw it if it doesn't exist. You will use these
    properties to make a connection to the sandbox PayPal API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for environment variables at [https://packt.link/y2MCy](https://packt.link/y2MCy).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Demo.cs` class, add a `const` variable for the `BaseAddress` of a PayPal sandbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`BaseAddress` will be used for initializing different clients (RestSharp and
    Refit) with the PayPal URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `Refit` to create a client with `CreateOrder` and `GetOrder` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get a sample request, refer to the documentation of the API that you want
    to call. Usually, they have an example request. In this case, the PayPal `CreateOrder`
    request can be found at [https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 8.25: PayPal CreateOrder example request with highlighted body ](img/B16835_08_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.25: PayPal CreateOrder example request with highlighted body'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.25*, `-d` is an argument and does not belong to the request body.
  prefs: []
  type: TYPE_NORMAL
- en: Use [https://json2csharp.com/](https://json2csharp.com/) and generate C# classes
    out of the JSON. The corresponding C# classes will be generated for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename `RootObject` to `Order` and change all classes to the `record` type
    because it''s a more suitable type for DTO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same PayPal docs ([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/)),
    copy the example response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use [https://json2csharp.com/](https://json2csharp.com/) and generate C# classes
    out of the JSON. Here, you will get classes very similar to the ones from request
    JSON. The only difference is the response (simplified for brevity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `AuthHeaderHandler` to fetch an access token when you make a request and
    make sure it inherits `DelegatingHandler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make calls to PayPal, you will need an `auth` header with every request.
    The `auth` header value is retrieved from yet another endpoint. Refit cannot just
    add a header on a whim. You can, however, set up Refit using a custom `HttpClient`
    with a custom `HttpMessageHandler` that fetches an access token whenever you make
    a request. The `AuthHeaderHandler` is used for that reason.
  prefs: []
  type: TYPE_NORMAL
- en: '`DelegatingHandler` is a class that allows intercepting `HttpRequest` when
    it''s being sent and doing something before or after it. In this case, before
    you send an HTTP request, you will fetch an `auth` header and add it to the request sent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, override `SendRequest` by adding a bearer token to `AuthenticationHeader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get an access token, you first need to get an OAuth token using basic `auth`
    (the client ID and secret):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting an access token will require an `auth` token. Use the `RestSharp` client
    and add an `Authorization` header to the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, set `content-type` to `application/x-www-form-urlencoded` as per the PayPal
    API spec.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the body content `grant_type=client_credentials` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the preceding request and return the response using the private nested
    class `Response` to simplify your work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why is the nested class needed? Here, the access token is nested within the
    response. It's not just a string that it returns, but rather an object. To parse
    it yourself from JSON would be a little complicated. However, you already know
    how to deserialize objects. So, even if it's just one property, deserializing
    still helps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create `RestClient` for the `GetAccessToken` method. Do so in the `AuthHandler`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Demo` class, create the method `Run`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Resolve a `Refit` client with a custom `AuthHeaderHandler` provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assuming that a payment was made by creating an `Order` object, run the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, call PayPal API and create an order endpoint with the order you've just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the created order to see if it works and print the retrieved order payment information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the environment variables set correctly, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, this is a sandbox API. However, a switch to a live environment
    with real money would just be a matter of setting up new PayPal accounts in that
    environment and calling a different endpoint: [https://api-m.paypal.com](https://api-m.paypal.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You won't be able to access [https://api-m.paypal.com](https://api-m.paypal.com)
    because it is for production PayPal use and is paid. However, that should be the
    only change in code (a different base URI) when you are ready to move on to real
    integration with PayPal.
  prefs: []
  type: TYPE_NORMAL
- en: Please make sure you have the environment variables set and are using your own
    client and secret. Otherwise, some unhandled exception errors may be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/cFRq6](https://packt.link/cFRq6).
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to do simple CRUD operations with Web APIs. However, you have
    only worked with text so far. So, will calling an API with an image be any different?
    Find that out in the next activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.04: Using an Azure Blob Storage Client to Upload and Download Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Blob Storage is a cloud service on Azure for storing different files (logs,
    images, music, and whole drives). Before you can use any Azure Storage services,
    you will need a storage account. Blobs are just files, but they cannot be directly
    stored within an account; instead, they need a container.
  prefs: []
  type: TYPE_NORMAL
- en: An Azure Storage Container is like a directory where other files are stored.
    However, unlike a directory, a container cannot contain other containers. Use
    an Azure Storage Account to create two containers, upload an image and a text
    file, and then download the uploaded files locally. All this will be done in your
    own client, which wraps around the Azure Blob storage client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this activity is to familiarize yourself with working on files through
    cloud storage while putting all that you have learned so far to the test. Perform
    the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `Azure Storage Accounts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Azure Storage Account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store a blob storage access key in environmental variables with the name `BlobStorageKey`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Azure Blob Storage` client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `FilesClient` class for storing fields for blobs client and default
    container client (where blobs will be stored by default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a constructor to initialize the two clients (to support access to different containers).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a method to create a container or get an existing one if it already exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method to upload a file to a specific container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method to download a file from a specific container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Demo` class with paths to download and upload directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add test data, namely the two files—that is, an image and a text file (*Figure
    8.26*, *Figure 8.27*, and *Figure 8.28*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.26: Two Azure Storage containers, exercise04 and exercise04b,  in
    your storage account ](img/B16835_08_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.26: Two Azure Storage containers, exercise04 and exercise04b, in your
    storage account'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27: Test1.txt file uploaded in exercise04 container ](img/B16835_08_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.27: Test1.txt file uploaded in exercise04 container'
  prefs: []
  type: TYPE_NORMAL
- en: 'Image file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28: Morning.jpg file uploaded in exercise04b container ](img/B16835_08_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.28: Morning.jpg file uploaded in exercise04b container'
  prefs: []
  type: TYPE_NORMAL
- en: Create the method `Run` to upload a text file and then download it locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code. If you did everything correctly, you should see the following
    output with both files downloaded locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.29: Morning.jpg and Test1.txt files downloaded from the two containers  after
    the demo code execution ](img/B16835_08_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.29: Morning.jpg and Test1.txt files downloaded from the two containers
    after the demo code execution'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  prefs: []
  type: TYPE_NORMAL
- en: It is near impossible to create a perfect client that is suitable for everyone.
    Therefore, even when there is a solution for some problem given to you, you will
    often still need to further abstract it away, adapting it to solve exactly the
    problem you have. The problem you had was in uploading and downloading a file
    from and to a specific folder. To solve the problem, you abstracted away layers
    of clients exposing just two functions—one for uploading a file and another for
    downloading a file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter the kind of programmer you are, there will be many scenarios in which
    you will have to consume a web service. There are different kinds of services
    online, but the most common type is RESTful. REST is just a set of guidelines
    and should therefore not be mixed up with HTTP. REST APIs are simple, self-documented,
    well-structured, and are currently a golden standard of Web APIs. However, in
    most cases in the context of RESTful APIs, a request is sent over HTTP and your
    message contains JSON.
  prefs: []
  type: TYPE_NORMAL
- en: The main tool for making HTTP calls using C# is `HttpClient`, however, before
    you try to implement HTTP calls yourself, you should look for a NuGet package
    of the Web API you're trying to consume. Azure Blob storage, Azure Text Analytics,
    PayPal, and GitHub are just a few examples of Web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about a lot of functionality on the web that is
    done for you. It's not hard to consume; all you need to know now is how to communicate
    with the third-party RESTful Web APIs. In the next chapter, you will learn how
    to create your own RESTful web services using the ASP.NET Core Web API template
    as well as being introduced to Azure Functions and the special tools Swagger and
    NuGet.
  prefs: []
  type: TYPE_NORMAL
