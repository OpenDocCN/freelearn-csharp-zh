- en: Shader Graphs and Video Players
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shader Graphs和Video Players
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Playing videos by manually adding a VideoPlayer component to a GameObject
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过手动将VideoPlayer组件添加到GameObject来播放视频
- en: Using scripting to control video playback on scene textures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本控制场景纹理上的视频播放
- en: Using scripting to play a sequence of videos back-to-back
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本连续播放一系列视频
- en: Creating and using a simple Shader Graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用简单的Shader Graph
- en: Using a Shader Graph to create a color glow effect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Shader Graph创建颜色发光效果
- en: Toggling a Shader Graph color glow effect through C# code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过C#代码切换Shader Graph颜色发光效果
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Two powerful recent additions to Unity have been the Video Player component
    (and API), and the Shader Graph tool. Between them, they offer easier and more
    configurable ways to work with visual content in games. For example, they help
    with the loading and playing of videos on different visible objects, and provide
    a comprehensive way for non-shader programmers to construct sophisticated shader
    transformations using a visual graphing approach.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity最近增加的两个强大功能是视频播放器组件（和API）以及Shader Graph工具。它们共同提供了更简单、更可配置的方式来处理游戏中的视觉内容。例如，它们有助于在不同可见对象上加载和播放视频，并为非着色器程序员提供了一种使用可视化图形方法构建复杂着色器转换的全面方式。
- en: The big picture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体情况
- en: The two core new Unity features discussed in this chapter are **Shader Graphs**
    and the **Video Player**. Each has its own section below.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的两个核心新Unity功能是**Shader Graphs**和**视频播放器**。每个功能都有其自己的部分。
- en: The new Shader Graph tool
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的Shader Graph工具
- en: In 2018, Unity published details about the exciting new **Shader Graph** feature.
    **Shader Graph** is a tool that allows **visual** building of shaders, by creating
    and connecting inputs and output of nodes. Currently, it only works with the Lightweight
    Scriptable Render Pipeline, but should eventually work with many pipelines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，Unity发布了关于令人兴奋的新**Shader Graph**功能的详细信息。**Shader Graph**是一个工具，允许通过创建和连接节点的输入和输出进行**可视化**的着色器构建。目前，它仅与轻量级可脚本渲染管线一起工作，但最终应该与许多管线一起工作。
- en: Unity's **Scriptable Render Pipeline** allow different, and customizable, rending
    pipelines, that can be efficiently targeted for specific projects and hardware
    settings (for example, exploiting GPUs in powerful desktop computers, or reducing
    performance requirements for less powerful mobile devices).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**可脚本渲染管线**允许不同的、可定制的渲染管线，这些管线可以针对特定项目和硬件设置高效地使用（例如，利用功能强大的桌面计算机中的GPU，或降低性能要求以适应功能较弱的移动设备）。
- en: 'Some great **Shader Graph** features include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些优秀的**Shader Graph**功能包括以下内容：
- en: An instant, visual preview of each node in the graph, so that you can see how
    different nodes are contributing to the final **Master** output node.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图中每个节点的即时、可视预览，以便您可以看到不同的节点是如何贡献给最终的**主**输出节点的。
- en: Properties can be publicly exposed in the graph (via the **Blackboard**), so
    that they become customizable values in the **Inspector** for the **Material**
    using the **Shader Graph**.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性可以在图中公开暴露（通过**黑板**），因此它们成为使用**Shader Graph**的**材质**在**检查器**中的可定制值。
- en: Publicly exposed properties can also be accessed and changed via scripts.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开暴露的属性也可以通过脚本访问和更改。
- en: 'The output of one node can become one of the inputs to another node, so a sophisticated
    shader can be created from many combined, simple component nodes:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个节点的输出可以成为另一个节点的输入之一，因此可以通过许多组合的简单组件节点创建复杂的着色器：
- en: '![](img/190af154-9f0f-4288-95be-c62117a37765.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/190af154-9f0f-4288-95be-c62117a37765.png)'
- en: This screenshot illustrates how Shader Graphs are composed of a graph of connected
    nodes, where the output of one node becomes the input to another node. Node input/outputs
    can be numeric values, Textures, noise, Boolean true/false values, Colors etc.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图说明了Shader Graph是如何由一个连接节点的图组成，其中一个节点的输出成为另一个节点的输入。节点输入/输出可以是数值、纹理、噪声、布尔真/假值、颜色等。
- en: '**Shader Graph** files are created in the Project panel, and can be selected
    as a graph shader in the `Shader` property of a **Material**.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shader Graph**文件在项目面板中创建，可以在**材质**的**Shader**属性中选择为图状着色器。'
- en: Several recipes are presented in this chapter to introduce some of the powerful
    **Shader Graph** features and workflow.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提供了几个配方，以介绍一些强大的**Shader Graph**功能和工作流程。
- en: Playing videos with the new Video Player
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的视频播放器播放视频
- en: In 2017, Unity replaced the old `MovieTexture` with the VideoPlayer component
    (as well as the associated VideoClip asset file type). Playing videos is as simple
    as manually adding a VideoPlayer component in the Inspector to a GameObject at
    design time, and associating a VideoClip asset file from the Project panel, or
    providing the URL of a online resource.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2017 年，Unity 用 VideoPlayer 组件（以及相关的 VideoClip 资产文件类型）替换了旧的 `MovieTexture`。播放视频就像在设计时在检查器中手动添加一个
    VideoPlayer 组件到 GameObject，并从项目面板关联一个 VideoClip 资产文件，或者提供在线资源的 URL。
- en: Videos can be played on the camera's far plane (appearing behind the scene content),
    or near plane (appearing in front of content – often with semi-transparency).
    Video content can also be directed to a `RenderTexture` asset, which can then
    (via a Material) be displayed on a 2D or 3D object in the scene. The internal
    texture used by a VideoPlayer can also be mapped to a texture on screen – such
    as UI Raw Image.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 视频可以在摄像机的远平面（看起来在场景内容之后）或近平面（看起来在内容之前——通常具有半透明性）上播放。视频内容也可以指向一个 `RenderTexture`
    资产，然后（通过一个材质）可以在场景中的二维或三维对象上显示。VideoPlayer 使用的内部纹理也可以映射到屏幕上的纹理——例如 UI Raw Image。
- en: Scripting can be used to manage video playback for single and arrays (sequence)
    of video clips. Several recipes are presented in this chapter to introduce these
    different ways to work with the VideoPlayer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用脚本管理单个视频剪辑和视频剪辑数组（序列）的播放。本章介绍了使用 VideoPlayer 的不同方法，并提供了几个示例。
- en: Online references materials
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线参考资料
- en: The following are useful sources of information for the topics of this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于本章主题的有用信息来源。
- en: Shader Graph online resources
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shader Graph 在线资源
- en: 'Unity documentation and third-party articles about the Shader Graphs can be
    found online at the following links:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中可以找到关于 Shader Graph 的 Unity 文档和第三方文章：
- en: 'The Shader Graph blog introduction: [https://blogs.unity3d.com/2018/02/27/introduction-to-shader-graph-build-your-shaders-with-a-visual-editor/](https://blogs.unity3d.com/2018/02/27/introduction-to-shader-graph-build-your-shaders-with-a-visual-editor/)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shader Graph 博客介绍：[https://blogs.unity3d.com/2018/02/27/introduction-to-shader-graph-build-your-shaders-with-a-visual-editor/](https://blogs.unity3d.com/2018/02/27/introduction-to-shader-graph-build-your-shaders-with-a-visual-editor/)
- en: 'The Unity Shader Graph overview: [https://unity3d.com/shader-graph](https://unity3d.com/shader-graph)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity Shader Graph 概述：[https://unity3d.com/shader-graph](https://unity3d.com/shader-graph)
- en: 'The Unity GitHub Shader Graph wiki: [https://github.com/Unity-Technologies/ShaderGraph/wiki](https://github.com/Unity-Technologies/ShaderGraph/wiki)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity GitHub Shader Graph 维基：[https://github.com/Unity-Technologies/ShaderGraph/wiki](https://github.com/Unity-Technologies/ShaderGraph/wiki)
- en: 'The Shader Graph example library on GitHub: [https://github.com/UnityTechnologies/ShaderGraph_ExampleLibrary](https://github.com/UnityTechnologies/ShaderGraph_ExampleLibrary)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 上的 Shader Graph 示例库：[https://github.com/UnityTechnologies/ShaderGraph_ExampleLibrary](https://github.com/UnityTechnologies/ShaderGraph_ExampleLibrary)
- en: 'Great video tutorial of Shader Graph from Unity Technology''s Andy Tough at
    GDC 2018: [https://www.youtube.com/watch?v=NsWNRLD-FEI](https://www.youtube.com/watch?v=NsWNRLD-FEI)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity Technology 的 Andy Tough 在 GDC 2018 上的优秀 Shader Graph 视频教程：[https://www.youtube.com/watch?v=NsWNRLD-FEI](https://www.youtube.com/watch?v=NsWNRLD-FEI)
- en: 'Unity''s manual page about the Scriptable Render Pipeline: [https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html](https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 关于 Scriptable Render Pipeline 的手册页面：[https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html](https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html)
- en: Video Player online resources
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频播放器在线资源
- en: 'Unity documentation and third-party articles about the Video Player can be
    found online at the following links:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中可以找到关于视频播放器的 Unity 文档和第三方文章：
- en: 'The Unity Video Player manual page: [https://docs.unity3d.com/Manual/class-VideoPlayer.html](https://docs.unity3d.com/Manual/class-VideoPlayer.html)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity Video Player 手册页面：[https://docs.unity3d.com/Manual/class-VideoPlayer.html](https://docs.unity3d.com/Manual/class-VideoPlayer.html)
- en: 'The Unity Scripting reference for the VideoPlayer class: [https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html](https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity VideoPlayer 类的脚本参考：[https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html](https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html)
- en: 'Creative Chris'' blog post about the Video Player: [https://creativechris.me/2017/02/07/unitys-new-video-playback-component/](https://creativechris.me/2017/02/07/unitys-new-video-playback-component/)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Creative Chris 关于视频播放器的博客文章：[https://creativechris.me/2017/02/07/unitys-new-video-playback-component/](https://creativechris.me/2017/02/07/unitys-new-video-playback-component/)
- en: Playing videos by manually adding a VideoPlayer component to a GameObject
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过手动将 VideoPlayer 组件添加到 GameObject 中来播放视频
- en: TV sets, projectors, monitors.... If you want complex animated materials in
    your level, you can play video files as texture maps. In this recipe, we will
    learn how to add and use VideoPlayer components on the main camera.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 电视、投影仪、显示器……如果你想在你的级别中添加复杂的动画材质，你可以播放视频文件作为纹理图。在这个菜谱中，我们将学习如何在主相机上添加和使用 VideoPlayer
    组件。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you need a video file so that you can follow this recipe, please use the
    `videoTexture.mov` file included in the `13_01` folder.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个视频文件以便遵循这个菜谱，请使用包含在 `13_01` 文件夹中的 `videoTexture.mov` 文件。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To place videos manually with a VideoPlayer component, follow these steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 VideoPlayer 组件手动放置视频，请按照以下步骤操作：
- en: Import the provided `videoTexture.mov` file.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的 `videoTexture.mov` 文件。
- en: 'Add a 3D Cube to the scene by choosing menu: GameObject | 3D Object | Cube.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：GameObject | 3D Object | Cube 添加一个 3D 立方体到场景中。
- en: 'Select the Main Camera GameObject, and in the Inspector, add a Video Player
    component by clicking Add Component, and choosing Video | Video Player. Unity
    will have noticed that we are adding the Video Player component to a camera, and
    so should have set up the default properties correctly for us:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择主相机 GameObject，然后在检查器中，通过点击添加组件，选择 Video | Video Player。Unity 会注意到我们正在将 VideoPlayer
    组件添加到相机，因此应该已经为我们正确设置了默认属性：
- en: Play On Awake (Checked)
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在唤醒时播放（已勾选）
- en: Wait For First Frame (Checked)
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待第一帧（已勾选）
- en: 'Render Mode: Camera Far Plane'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染模式：相机远平面
- en: 'Camera: Main Camera (Camera)'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机：主相机（Camera）
- en: 'Drag the video clip asset file videoTexture from the Project panel into the
    Video Clip property slot in the Inspector, like so:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目面板中的视频剪辑资产文件 videoTexture 拖动到检查器中的 Video Clip 属性槽中，如下所示：
- en: '![](img/94eec315-4dc5-4382-afce-fd3a7e7575e1.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94eec315-4dc5-4382-afce-fd3a7e7575e1.png)'
- en: Test your scene. You should be able to see the movie being played behind the
    scene content.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试你的场景。你应该能够看到在场景内容后面的电影正在播放。
- en: You can choose whether to stretch the video content by changing the Aspect Ratio
    property in the Inspector (for example, you can change it to Stretch in order
    to fill in the complete background of the screen).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过在检查器中更改 Aspect Ratio 属性来选择是否拉伸视频内容（例如，你可以将其更改为 Stretch 以填充屏幕的完整背景）。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We gave the Video Player component a reference to a Video Clip asset file. Since
    we added the Video Player component to a Camera (the Main Camera, in this example),
    it automatically chose the Camera Far Play Render Mode linked to the Main Camera.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 Video Player 组件提供了一个指向 Video Clip 资产文件的引用。由于我们已将 Video Player 组件添加到相机（在这个例子中是主相机），它自动选择了与主相机链接的
    Camera Far Plane 渲染模式。
- en: The default setting is Play On Awake, so as soon as the first frame has loaded
    (since Wait For First Frame is also checked by default), the video will start
    playing. The video is displayed behind all main camera content (the far plane).
    Because of this, we see our 3D Cube in the scene, with the video playing in the
    background.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置是在唤醒时播放，所以一旦第一帧加载完成（因为 Wait For First Frame 也默认勾选），视频就会开始播放。视频显示在所有主相机内容（远平面）之后。正因为如此，我们在场景中看到了我们的
    3D 立方体，视频在背景中播放。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here are some additional ways to work with the Video Player component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用 VideoPlayer 组件的额外方法。
- en: Semi-transparent video and Camera Near Plane
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 半透明视频和相机近平面
- en: Sometimes, we may want to play a video so that it's the user's main focus, but
    allow them to see scene objects in the background.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能想播放视频，使其成为用户的主要焦点，但允许他们看到背景中的场景对象。
- en: 'To achieve this with the Video Player component, we just need to make two changes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 VideoPlayer 组件实现这一点，我们只需要进行两个更改：
- en: Change the Render Mode to Near Camera Plane (so that the video content is played
    in front of the scene content).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将渲染模式更改为近相机平面（这样视频内容就会在场景内容之前播放）。
- en: To allow the user to partially see through the video, we need to make the Video
    Player semi-transparent. Change its Alpha property to 0.5.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要允许用户部分看到视频，我们需要使 Video Player 半透明。将它的 Alpha 属性更改为 0.5。
- en: Now, when you run the scene, you'll see the video playing in front of scene
    content, but now you will be able to see the 3D cube in the background.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行场景时，你将看到视频在场景内容之前播放，但现在你将能够看到背景中的 3D 立方体。
- en: Audio issues and AudioSource solution
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频问题及 AudioSource 解决方案
- en: At the time of writing this book, there seem to be issues with the Direct option
    for Audio Output Mode audio playback for some non-Apple systems. One solution
    is to add an AudioSource component to the same GameObject that has the VideoPlayer
    component, and to set the Audio Output Mode to AudioSource.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，似乎有一些非苹果系统在使用音频输出模式音频播放的Direct选项时存在问题。一个解决方案是将AudioSource组件添加到具有VideoPlayer组件的同一GameObject中，并将音频输出模式设置为AudioSource。
- en: Using scripting to control video playback on scene textures
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本控制场景纹理上的视频播放
- en: While the last recipe demonstrated how we can plan videos using the Video Player
    component that's set up at design time, much more is possible when controlling
    video playback through scripting.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上一个示例展示了如何使用设计时设置的Video Player组件来规划视频，但通过脚本控制视频播放时，还有更多可能。
- en: 'In this recipe, we''ll using scripting to play/pause the playback of a video
    rendered onto a 3D cube:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用脚本播放/暂停渲染到3D立方体上的视频的播放：
- en: '![](img/d4333282-1119-4ece-94ac-4daf280a1f0d.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4333282-1119-4ece-94ac-4daf280a1f0d.png)'
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you need a video file to follow this recipe, please use the `videoTexture.mov` file
    included in the `13_01` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要视频文件来遵循这个示例，请使用包含在`13_01`文件夹中的`videoTexture.mov`文件。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To use scripting to control video playback, follow these steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用脚本控制视频播放，请按照以下步骤操作：
- en: Import the provided `videoTexture.mov` file.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的`videoTexture.mov`文件。
- en: 'Create a 3D cube by choosing menu: Create | 3D | Cube.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：创建 | 3D | 立方体来创建一个3D立方体。
- en: 'Create a C# script class named `PlayPauseMainTexture`, and attach an instance
    object as a component to your 3D cube GameObject:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PlayPauseMainTexture`的C#脚本类，并将实例对象作为组件附加到你的3D立方体GameObject上：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ensure that your 3D cube is selected in the Project panel. Then, drag the Video
    Clip asset file `videoTexture` from the Project panel into the Video Clip property
    slot of the `PlayPauseMainTexture` component (script) in the Inspector.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目面板中选择你的3D立方体。然后，将项目面板中的视频剪辑资产文件`videoTexture`拖放到检查器中`PlayPauseMainTexture`组件（脚本）的视频剪辑属性槽中。
- en: Run your scene. Pressing the spacebar should play/pause playback of the video
    on the surfaces of the 3D cube. You should also hear the beeping audio for video.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的场景。按下空格键应该会在3D立方体的表面上播放/暂停视频的播放。你也应该听到视频的蜂鸣声。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We added the instance object of our scripted class to the 3D cube, and dragged
    a reference to a Video Clip asset file to the public slot. In our code, we are
    telling the VideoPlayer component to override the Material of the object it is
    a component of (in this case, the 3D cube) so that the Video Player will render
    (display) onto the main texture of the 3D cube:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的脚本类的实例对象添加到3D立方体中，并将视频剪辑资产文件的引用拖放到公共插槽中。在我们的代码中，我们正在告诉VideoPlayer组件覆盖它所附着的对象（在这种情况下，是3D立方体）的材料，以便Video
    Player将在3D立方体的主纹理上渲染（显示）：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The basics to using scripting and the VideoPlayer is as follows. As well as
    defining and setting up where the Video Player will render, we also need to do
    the following each time:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用脚本和VideoPlayer的基本方法如下。除了定义和设置Video Player的渲染位置外，我们还需要每次都执行以下操作：
- en: 'Create or get references to the VideoPlayer and AudioSource components (we
    will automatically have both components for this recipe since we have the `RequireComponent(...)`
    script instructions immediately before our class declaration):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或获取VideoPlayer和AudioSource组件的引用（由于我们在类声明之前立即有`RequireComponent(...)`脚本指令，因此我们将自动拥有这两个组件）：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set their Play On Awake to `true`/`false`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置它们的Play On Awake为`true`/`false`：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define where the Video Player will find a reference to the Video Clip to play:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义Video Player将找到要播放的视频剪辑的引用的位置：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the audio settings (so that you can output to the AudioSource component):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义音频设置（以便你可以输出到AudioSource组件）：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Here are some additional ways to work with Video Player scripting.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用Video Player脚本的其他方法。
- en: Ensuring that a movie's prepared before playing it with the prepareCompleted
    event
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保在播放电影之前使用prepareCompleted事件准备电影。
- en: In the preceding recipe, the movie has time to prepare since the game waits
    until we press the jumo/space key. If we are using scripting to set up a Video
    Player for a video clip, we need to do some initial work before the video is ready
    to play. Unity provides the `prepareCompleted` event, which allows us to register
    a method to be invoked once a VideoPlayer is ready to play.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，由于游戏等待我们按下jumo/space键，电影有准备时间。如果我们使用脚本为视频剪辑设置视频播放器，我们需要在视频准备好播放之前做一些初始工作。Unity提供了`prepareCompleted`事件，允许我们注册一个方法，在VideoPlayer准备好播放时调用。
- en: 'Do the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: 'Add a UI Raw Image to the scene by choosing menu: Create | UI | Raw Image.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：创建 | UI | 原始图像，将UI原始图像添加到场景中。
- en: Create a new empty GameObject named video-object.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为video-object的新空GameObject。
- en: 'Create a C# script class named `PrepareCompleted`, and attach an instance object
    as a component to GameObject''s video-object:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PrepareCompleted`的C#脚本类，并将其作为组件附加到GameObject的video-object实例上：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ensure that video-object is selected in the Project panel. Now, drag the Raw
    Image from the Hierarchy into the Raw Image slot. Then, drag the Video Clip asset
    file `videoTexture` from the Project panel into the Video Clip property slot of
    the `PrepareCompleted` component (script) in the Inspector.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目面板中选择video-object。现在，将层次结构中的原始图像拖动到原始图像槽中。然后，将项目面板中的视频剪辑资产文件`videoTexture`拖动到检查器中`PrepareCompleted`组件（脚本）的视频剪辑属性槽中。
- en: Test your scene. You should be able to see the movie being played behind the
    scene content.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试您的场景。您应该能够在场景内容后面看到正在播放的电影。
- en: 'You can see that, in the `Start()` method, we first register a method named `PlayVideoWhenPrepared`
    with the `videoPlayer.prepareCompleted` event, before invoking the `Prepare()`
    method of the `videoPlayer` component:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在`Start()`方法中，我们首先将名为`PlayVideoWhenPrepared`的方法注册到`videoPlayer.prepareCompleted`事件，然后调用`videoPlayer`组件的`Prepare()`方法：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `PlayVideoWhenPrepared(...)` method has to accept a parameter as a reference
    to a VideoPlayer object. We first directly assign the VideoPlayer's texture property
    to the Raw Image's texture. Then, we send the `Play()` message.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayVideoWhenPrepared(...)`方法必须接受一个参数，作为VideoPlayer对象的引用。我们首先直接将VideoPlayer的纹理属性分配给原始图像的纹理。然后，我们发送`Play()`消息。'
- en: Directly working with the VideoPlayer texture works for this example, but usually
    setting up a separate Render Texture is more reliable and flexible - see the following
    subsection for how to do this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用VideoPlayer纹理在这个例子中是可行的，但通常设置一个单独的渲染纹理更可靠、更灵活——请参阅以下小节了解如何操作。
- en: You can track progress of clip preparation and so on through the Log messages
    in the Console panel.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过控制台面板中的日志消息跟踪剪辑准备进度等。
- en: Outputting video playback to a Render Texture asset
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将视频播放输出到渲染纹理资产
- en: A flexible way to work with Video Players is to output their playback to a Render
    Texture asset file. A Material can be created to get input from the Render Texture,
    and GameObjects using that Material will display the video. Also, some GameObjects
    can directly have the Render Texture assigned as their texture.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视频播放器的一种灵活方法是将其播放输出到渲染纹理资产文件。可以创建一个材质来从渲染纹理获取输入，并使用该材质的GameObject将显示视频。此外，一些GameObject可以直接将渲染纹理分配为其纹理。
- en: 'Do the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: 'In the Project panel, create a new Render Texture asset file named `myRenderTexture`
    (menu: Create | Render Texture).'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为`myRenderTexture`的新渲染纹理资产文件（菜单：创建 | 渲染纹理）。
- en: Select the UI Raw Image in the Hierarchy, and assign its Raw Image (Script) texture
    property to the `myRenderTexture` asset file.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择UI原始图像，并将其原始图像（脚本）纹理属性分配给`myRenderTexture`资产文件。
- en: In the Project panel, create a new Material asset file named `m_video`. For
    this Material, in the Inspector, set its Albedo Texture property to `myRenderTexture`
    (drag it from the Project panel into the Inspector).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为`m_video`的新材质资产文件。对于此材质，在检查器中，将其Albedo Texture属性设置为`myRenderTexture`（从项目面板拖动到检查器中）。
- en: Create a new 3D capsule in the scene, and assign it the Material m_video.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个新的3D胶囊，并分配给其材质m_video。
- en: 'Edit the C# script class `PrepareCompleted` by replacing the public `rawImage` variable
    with a public `renderTexture` variable:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将公共`rawImage`变量替换为公共`renderTexture`变量来编辑C#脚本类`PrepareCompleted`：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Edit the C# script class `PrepareCompleted` by adding the following statements
    at the end of the `SetupVideoAudioPlayers()` method to output video to `RenderTexture`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 C# 脚本类 `PrepareCompleted`，在 `SetupVideoAudioPlayers()` 方法的末尾添加以下语句以将视频输出到
    `RenderTexture`：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Edit the C# script class PrepareCompleted in the `PlayVideoWhenPrepared()` method.
    Remove the statement that directly assigns the VideoPlayer''s texture property
    to the Raw Image''s Texture:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 C# 脚本类 `PrepareCompleted` 中的 `PlayVideoWhenPrepared()` 方法。删除直接将 VideoPlayer
    的 texture 属性分配给 Raw Image 的 Texture 的语句：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ensure that the GameObject video-object is selected in the Project panel. Now,
    drag the `myRenderTexture` asset from the Project panel into the Render Texture
    public property of the Prepare Completed (Script) in the Inspector.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目面板中选择 GameObject video-object。现在，将项目面板中的 `myRenderTexture` 资产拖动到检查器中 Prepare
    Completed (Script) 的 Render Texture 公共属性。
- en: 'Run the scene. You should now see the video playing both in the UI Raw Image and
    also rendered over the 3D Capsule object:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。你现在应该看到视频在 UI Raw Image 中播放，并且渲染在 3D 圆柱对象上：
- en: '![](img/cd64a526-f7d8-4f1a-97b7-073c95a49bdb.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd64a526-f7d8-4f1a-97b7-073c95a49bdb.png)'
- en: Ensuring that the movie is prepared before playing with coroutines
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保在协程中播放电影之前准备就绪
- en: Many Unity programmers are very used to working with coroutines, so instead
    of using the `prepareCompleted` event, we can rewrite the preceding script by
    using a coroutine.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Unity 程序员非常习惯于使用协程，因此我们可以通过使用协程来重写前面的脚本，而不是使用 `prepareCompleted` 事件。
- en: 'Do the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: Remove the `PlayVideoWhenPrepared()` method.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `PlayVideoWhenPrepared()` 方法。
- en: 'Add a new using statement at the top of the script (so that we can refer to IEnumerator
    interface):'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部添加一个新的 using 语句（这样我们就可以引用 IEnumerator 接口）：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Replace the existing `Start()` method with the following:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `Start()` 方法替换为以下内容：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, our `Start()` method has become a coroutine (returning an IEnumerator),
    which means that it can yield control back to Unity during its execution. In the
    next frame, it will resume execution at that same statement.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的 `Start()` 方法已经变成了一个协程（返回一个 IEnumerator），这意味着它在执行过程中可以交回控制权给 Unity。在下一次帧中，它将在相同的位置恢复执行。
- en: There is a while loop that will continue running until the isPrepared property
    is true for VideoPlayer. So, each frame of Unity will return to this while loop,
    and if the VideoPlayer is still not prepared, it enters the loop again and yields
    execution until the next frame. When VideoPlayer isPrepared is finally true, the
    loop condition is false, so the statement after the loop is executed (`videoPLayer.Play()`),
    and the method finally completes its execution.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个 while 循环，它将一直运行，直到 VideoPlayer 的 isPrepared 属性为 true。因此，Unity 的每一帧都会返回到这个
    while 循环，如果 VideoPlayer 仍然没有准备好，它将再次进入循环并交回执行，直到下一帧。当 VideoPlayer 的 isPrepared
    最终为 true 时，循环条件为假，因此循环之后的语句将被执行（`videoPLayer.Play()`），方法最终完成执行。
- en: For a single video, there is little to choose from between the `isPrepared`
    event and the preceding coroutine. However, for a sequence of videos, the use
    of the `isPrepared` and `loopPointReached` events helps us make much simpler logic
    for preparing and then waiting to play the next video in a sequence (see the next
    recipe for more information).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个视频，在 `isPrepared` 事件和前面的协程之间选择余地很小。然而，对于一系列视频，使用 `isPrepared` 和 `loopPointReached`
    事件可以帮助我们为准备和等待播放序列中的下一个视频创建更简单的逻辑（有关更多信息，请参阅下一道菜谱）。
- en: Downloading an online video (rather than a clip)
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载在线视频（而不是剪辑）
- en: Rather than dragging an existing Video Clip asset file to specify which video
    to play, the Video Player can also download Video Clips from an online source.
    We need to assign a string URL to the Video Player's URL property.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将现有的视频剪辑资产文件拖动到指定要播放的视频，视频播放器还可以从在线源下载视频剪辑。我们需要将一个字符串 URL 分配给视频播放器的 URL 属性。
- en: 'Do the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: 'Declare a public array of strings, in which one or more URLs can be defined:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个公共字符串数组，可以在其中定义一个或多个 URL：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Declare a new method that returns one URL string, randomly chosen from the
    array:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的方法，该方法返回一个 URL 字符串，从数组中随机选择：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, in the `SetupVideoAudioPlayers()` method, we need to get the random
    URL string, and assign it to the Video Player''s `url` property:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `SetupVideoAudioPlayers()` 方法中，我们需要获取随机的 URL 字符串，并将其分配给视频播放器的 `url` 属性：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using scripting to play a sequence of videos back-to-back
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本连续播放一系列视频
- en: One of the advantages of scripting is that it allows us to easily work with
    multiple items through loops and arrays, and so on. In this recipe, we'll work
    with an array of Video Clip assets and use scripting to play them back-to-back
    (one starts as soon as the previous clip finishes), illustrating the use of the isPrepared
    and loopPointReached events to avoid complicated loops and coroutines.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的一个优点是它允许我们通过循环和数组等轻松地处理多个项目。在这个食谱中，我们将使用视频剪辑资产数组，并使用脚本连续播放它们（一个在先前的剪辑完成后立即开始），展示了使用
    isPrepared 和 loopPointReached 事件来避免复杂的循环和协程的使用。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you need video files in order to follow this recipe, please use the `videoTexture.mov`
    file included in the `13_01` folder.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要视频文件来遵循此食谱，请使用包含在 `13_01` 文件夹中的 `videoTexture.mov` 文件。
- en: '**NOTE:** The Standalone Installer website provides a good online source of
    test videos: http://standaloneinstaller.com/blog/big-list-of-sample-videos-for-testers-124.html.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 独立安装器网站提供了一个很好的在线测试视频资源：http://standaloneinstaller.com/blog/big-list-of-sample-videos-for-testers-124.html。'
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To play a sequence of videos using scripting, follow these steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用脚本播放一系列视频，请按照以下步骤操作：
- en: Import the provided `videoTexture.mov` file, and perhaps a second video clip,
    so that we can have a sequence of two different videos to test (although you can
    run the same one twice if you wish).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的 `videoTexture.mov` 文件，也许还有一个第二个视频剪辑，以便我们可以测试两个不同视频的序列（尽管如果你愿意，你也可以运行相同的两次）。
- en: 'In the Project panel, create a new Render Texture asset file named myRenderTexture
    (menu: Create | Render Texture).'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为 myRenderTexture 的新渲染纹理资产文件（菜单：创建 | 渲染纹理）。
- en: 'Add a UI Raw Image to the scene by choosing menu: Create | UI | Raw Image.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：创建 | UI | 原始图像将 UI 原始图像添加到场景中。
- en: Select the UI Raw Image in the Hierarchy, and assign its Raw Image (Script)
    Texture property to the myRenderTexture asset file.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 UI 原始图像，并将其原始图像（脚本）纹理属性分配给 myRenderTexture 资产文件。
- en: In the Project panel, create a new Material asset file named m_video. For this
    Material, in the Inspector, set its Albedo Texture property to myRenderTexture
    (drag it from the Project panel into the Inspector).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为 m_video 的新材质资产文件。对于此材质，在检查器中，将其 Albedo 纹理属性设置为 myRenderTexture（从项目面板拖动到检查器）。
- en: 'Create a 3D cube by choosing menu: Create | 3D | Cube. Assign the m_video Material
    to your 3D cube.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：创建 | 3D | 立方体创建一个 3D 立方体。将 m_video 材质分配给你的 3D 立方体。
- en: Create a new empty GameObject named video-object.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 video-object 的新空 GameObject。
- en: 'Create a C# script class named VideoSequenceRenderTexture, and attach an instance
    object as a component to the GameObject''s video-object:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 VideoSequenceRenderTexture 的 C# 脚本类，并将一个实例对象作为组件附加到 GameObject 的 video-object
    上：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Ensure that the GameObject video-object is selected in the Project panel. Now,
    drag the myRenderTexture asset from the Project panel into the Render Texture
    public property of the PrepareCompleted (Script) in the Inspector. For the Video
    Clips property, set the size to 2 – you should now see two video clip elements
    (elements 0 and 1). From the Project panel, drag in a video clip to each slot.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目面板中选择 GameObject video-object。现在，将 myRenderTexture 资产从项目面板拖动到检查器中 PrepareCompleted（脚本）的渲染纹理公共属性。对于视频剪辑属性，设置大小为
    2 – 你现在应该看到两个视频剪辑元素（元素 0 和 1）。从项目面板中拖入一个视频剪辑到每个槽位。
- en: Run the scene. You should now see the first video clip playing both for the
    UI Raw Image and the 3D cube surface. Once the the first video clip has finished
    playing, the second video clip should immediately start playing.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。你现在应该看到第一个视频剪辑在 UI 原始图像和 3D 立方体表面上播放。一旦第一个视频剪辑播放完毕，第二个视频剪辑应立即开始播放。
- en: You can track the progress of clip preparation and so on through the Log messages
    in the Console panel.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过控制台面板中的日志消息跟踪剪辑准备进度等。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This script class makes the Video Player objects output their videos to Render
    Texture's asset file, myRenderTexture. This is used by both 3D cube and the UI
    Raw Image for their surface display.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本类使视频播放器对象将它们的视频输出到渲染纹理的资产文件 myRenderTexture。这被 3D 立方体和 UI 原始图像用于其表面显示。
- en: The videoClips variable is a public array of video clip references.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: videoClips 变量是一个公共数组，包含视频 clip 引用。
- en: The instance object of the C# script class VideoSequenceRenderTexture was added
    as a component to GameObject's video-object. This script will create child GameObjects
    of GameObject video-object, each containing a VideoPlayer and AudioSource component,
    ready to play each of the video clips assigned in the public array's videoClips
    variables.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将C#脚本类`VideoSequenceRenderTexture`的实例对象添加为GameObject的`video-object`的组件。此脚本将创建GameObject
    `video-object`的子GameObject，每个子GameObject都包含一个VideoPlayer和AudioSource组件，准备播放公共数组变量`videoClips`中分配的每个视频片段。
- en: The `SetupObjectArrays()` method initializes videoPlayers to be an array the
    same length as videoClips. It then loops for each item, invoking `SetupVideoAudioPlayers(...)` by
    passing the current integer index.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupObjectArrays()`方法初始化`videoPlayers`为数组，其长度与`videoClips`相同。然后它循环遍历每个项目，通过传递当前整数索引调用`SetupVideoAudioPlayers(...)`。'
- en: The `SetupVideoAudioPlayers(...)` method creates a new child GameObject for
    GameObject's video-object, and adds VideoPlayer and AudioSource components to
    that GameObject. It sets the Video Player clip property to the corresponding element
    in the public videoClips array variable. It also adds a reference to the new VideoPlayer
    component to the appropriate location in the videoPlayers array. It then sets
    the Video Player to output audio to the new AudioSource component, and to output
    its video to the renderTexture public variable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupVideoAudioPlayers(...)`方法为GameObject的`video-object`创建一个新的子GameObject，并将VideoPlayer和AudioSource组件添加到该GameObject中。它将视频播放器的clip属性设置为公共`videoClips`数组变量中的相应元素。它还在`videoPlayers`数组中的适当位置添加了对新VideoPlayer组件的引用。然后它设置视频播放器将音频输出到新的AudioSource组件，并将视频输出到公共`renderTexture`变量。'
- en: 'The `Start()` method does the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法执行以下操作：'
- en: It invokes `SetupObjectArrays()`
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用`SetupObjectArrays()`
- en: It sets the currentVideoIndex variable to 0 (for the first item in the arrays)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将`currentVideoIndex`变量设置为0（用于数组的第一个项目）
- en: It registers `PlayNextVideo` method for the prepareCompleted event of the first
    videoPlayers object (currentVideoIndex = 0)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为第一个`videoPlayers`对象的`prepareCompleted`事件注册`PlayNextVideo`方法（当前`currentVideoIndex`
    = 0）
- en: It invokes the `Prepare()` method for the videoPlayers object (currentVideoIndex
    = 0)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为`videoPlayers`对象调用`Prepare()`方法（当前`currentVideoIndex` = 0）
- en: Finally, it logs a debug message stating that the item is preparing
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它记录一条调试信息，说明项目正在准备中
- en: 'The `PlayNextVideo(...)` method does the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayNextVideo(...)`方法执行以下操作：'
- en: It gets a reference to the Video Player element of the videoPlayers array that
    corresponds to the currentVideoIndex variable
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它获取了与`currentVideoIndex`变量对应的`videoPlayers`数组中的视频播放器元素
- en: This method ignores the reference to the videoPlayer argument it receives –
    this parameter is required in the method declaration since it is the required
    signature to allow this method to register for the prepareCompleted and loopPointReached
    events.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法忽略它接收到的视频播放器引用参数——此参数在方法声明中是必需的，因为它是允许此方法注册`prepareCompleted`和`loopPointReached`事件的必需签名。
- en: It sends a `Play()` message to the current Video Player
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它向当前视频播放器发送`Play()`消息
- en: It then increments the value of currentVideoIndex, and tests whether there are
    any remaining video clips in the array
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它增加`currentVideoIndex`的值，并检查数组中是否还有剩余的视频片段
- en: If there are remaining clips, then it gets a reference to the next clip, and
    sends it a `Prepare()` message; also the currently playing Video Player has its
    loopPointReached event registered for the PlayNextVideo method
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果还有剩余的片段，则获取下一个片段的引用，并发送它一个`Prepare()`消息；同时，当前正在播放的视频播放器的`loopPointReached`事件注册为`PlayNextVideo`方法
- en: (If there are no videos left, then a simple debug log message is printed and
    the method ends)
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （如果没有剩余的视频，则打印一条简单的调试日志消息并结束方法）
- en: The clever bit is when the currently playing Video Player has its loopPointReached
    event registered for the PlayNextVideo method. The loopPointReached event occurs
    when a video clip has finished playing, and will start to look again (if its loop
    property is true). What we are doing with this script is say that when the current
    Video Player video clip has finished, the `PlayNextVideo(...)` method should be
    invoked again – once again using the value of currentVideoIndex to send a `Play()`
    message to the next Video Player, and then testing for any remaining Video Players,
    and so on until the end of the array has been reached.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 智巧之处在于当前播放的Video Player已为PlayNextVideo方法注册了loopPointReached事件。当视频剪辑播放完毕时，loopPointReached事件发生，并开始再次播放（如果其loop属性为true）。我们在这个脚本中所做的是，当当前Video
    Player的视频剪辑播放完毕时，再次调用`PlayNextVideo(...)`方法——再次使用currentVideoIndex的值向下一个Video
    Player发送`Play()`消息，然后检查是否有剩余的Video Player，以此类推，直到达到数组的末尾。
- en: This is a good example of conditions (if statements) being used with events,
    rather than coroutine while loops. As long as you're happy with how methods can
    be registered with C# events, then this approach allows our code to be less complex
    by avoiding loops and coroutine yield null statements.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用事件（if语句）而不是协程while循环来使用条件的良好示例。只要你对方法如何与C#事件注册感到满意，那么这种方法就可以通过避免循环和协程yield
    null语句来简化我们的代码。
- en: 'In the following screenshot, we can see how our video-object GameObject, at
    runtime, ends up with videoPlayer_&lt;n&gt; child GameObjects – one for each element
    in the array. This allows one VideoPlayer to be playing while the next is preparing,
    and so on:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到我们的视频对象GameObject在运行时最终变成了videoPlayer_&lt;n&gt;子GameObject，每个元素一个。这允许一个VideoPlayer播放时，下一个正在准备，以此类推：
- en: '![](img/4a699930-958c-44a4-a501-da55667644ec.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a699930-958c-44a4-a501-da55667644ec.png)'
- en: Creating and using a simple Shader Graph
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用简单的Shader Graph
- en: 'The new Shader Graph feature in Unity 2018 is a powerful and exciting feature,
    opening up shader creation and editing to everyone, without any need for complex
    mathematics or coding skills. In this recipe, we''ll create a simple Shader Graph
    to generate a checkerboard pattern, and create a Material that uses that shader,
    and apply it to a 3D cube. The end result will be as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 2018中的新Shader Graph功能是一个强大且令人兴奋的功能，它将着色器的创建和编辑向每个人开放，无需任何复杂的数学或编码技能。在这个菜谱中，我们将创建一个简单的Shader
    Graph来生成棋盘图案，并创建一个使用该着色器的材料，并将其应用于3D立方体。最终结果如下：
- en: '![](img/e3659fae-9246-4166-b56f-ec293e82a3f3.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3659fae-9246-4166-b56f-ec293e82a3f3.png)'
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create and use a simple Shader Graph, follow these steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和使用简单的Shader Graph，请按照以下步骤操作：
- en: First, we need to set up the Lightweight Rendering Pipeline. Use the Package
    Manager to import the Lightweight Rendering Pipeline package.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要设置轻量级渲染管线。使用包管理器导入轻量级渲染管线包。
- en: 'In the Project panel, create a new Lightweight Pipeline Asset file named myLightweightAsset.
    Choose menu: Create | Rendering | Lightweight Pipeline Asset.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个新的轻量级管线资产文件，命名为myLightweightAsset。选择菜单：创建 | 渲染 | 轻量级管线资产。
- en: 'In the Inspector, display the project''s graphics settings by choosing menu:
    Edit | Project Settings | Graphics. Then, drag myLightweightAsset from the Project
    panel into the Scriptable Render Pipeline Settings property:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，通过选择菜单：编辑 | 项目设置 | 图形来显示项目的图形设置。然后，将myLightweightAsset从项目面板拖到可脚本渲染管线设置属性：
- en: '![](img/29679a07-63e1-4157-8965-841f8d891138.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29679a07-63e1-4157-8965-841f8d891138.png)'
- en: Use the Package Manager to import the Shader Graph package.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用包管理器导入Shader Graph包。
- en: 'In the Project panel, create a new Physically-Based Rendering (PBR) Shader
    Graph, named myShaderGraph. Choose menu: Create | Shader | PBR Graph.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个新的基于物理渲染（PBR）Shader Graph，命名为myShaderGraph。选择菜单：创建 | 着色器 | PBR图形。
- en: 'In the Project panel, create a new Material named m_cube. Choose menu: Create
    | Material.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个新的名为m_cube的材料。选择菜单：创建 | 材料。
- en: 'With the m_cube selected, in the Inspector, set its Shader property to myShaderGraph.
    For the Material''s Shader property, choose menu: graphs | myShaderGraph:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择m_cube后，在检查器中，将其Shader属性设置为myShaderGraph。对于材料的Shader属性，选择菜单：图形 | myShaderGraph：
- en: '![](img/016a978c-ae54-4e8f-ac9b-294a86f8b7a9.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/016a978c-ae54-4e8f-ac9b-294a86f8b7a9.png)'
- en: 'Add a 3D cube to the scene (menu: GameObject | 3D Object | Cube). Set the Material
    for this 3D Cube to m_Cube.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将3D立方体添加到场景中（菜单：游戏对象 | 3D对象 | 立方体）。将这个3D立方体的材料设置为m_Cube。
- en: 'In the Project panel, double click myShaderGraph to open the Shader Graph editing
    panel. A new PRB Shader Graph will open with three components: (1) the BlackBoard
    (for publically exposing parameters); (2) the Master PRB node; (3) the output
    previewer node:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，双击myShaderGraph以打开Shader Graph编辑面板。一个新的PRB Shader Graph将打开，包含三个组件：（1）黑板（用于公开暴露参数）；（2）主PRB节点；（3）输出预览器节点：
- en: It is easiest, when editing a Shader Graph, to maximize the Shader Graph panel.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑Shader Graph时，最大化Shader Graph面板是最容易的。
- en: '![](img/f836663f-0dfa-4550-b7e5-d8e519d5972e.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f836663f-0dfa-4550-b7e5-d8e519d5972e.png)'
- en: 'Right-click the output previewer, and select Cube:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击输出预览器，并选择立方体：
- en: You can zoom and rotate the preview mesh. You can also choose a custom mesh
    from within your project, allowing a preview of the Shader Graph on the intended
    destination's 3D object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以缩放和旋转预览网格。您还可以从您的项目中选择自定义网格，以便在目标3D对象上预览Shader Graph。
- en: '![](img/a07de4f3-176a-4c94-a72a-552cccc7a5e4.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a07de4f3-176a-4c94-a72a-552cccc7a5e4.png)'
- en: Let's flood the shader with a red color. Choose red from the color picker for
    the top property of the PRB Master node Albedo.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在着色器中填充红色。从颜色选择器中选择红色作为PRB Master节点Albedo属性的最高属性。
- en: 'Create a new graph node by right-clicking the mouse and choosing menu: Create
    Node | Procedural | Checkerboard. You''ll see the checkerboard patter in the preview
    for this node. Set the X property to 2, and the Y property to 3.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击鼠标并选择菜单：创建节点 | 程序 | 棋盘格来创建一个新的图节点。您将在该节点的预览中看到棋盘格图案。将X属性设置为2，Y属性设置为3。
- en: 'Now, drag a link from the checkerboard note output Out(3), to the Emission
    (3) input for the PRB Master node. You should now see a red/pink checkerboard
    patter in the PBR Master node preview, and you''ll also see the following output
    applied to the Cube mesh in the output previewer node:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从棋盘格节点输出Out(3)拖动一个链接到PRB Master节点的Emission (3)输入。现在，您应该在PRB Master节点预览中看到一个红色/粉红色的棋盘格图案，您也会在输出预览器节点中看到以下输出应用于立方体网格：
- en: '![](img/0a3af4a4-8c12-4c7d-ab3c-0d772d2968dd.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a3af4a4-8c12-4c7d-ab3c-0d772d2968dd.png)'
- en: You must save the changes to your Shader Graph before you can see them applied
    to the scene. Click the Save Asset button on the top-left of the Shader Graph
    panel.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您能够看到它们应用于场景之前，您必须保存对Shader Graph的更改。在Shader Graph面板的左上角点击保存资产按钮。
- en: Save and run your scene. You should see a red/pink checkerboard 3D cube being
    displayed.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行您的场景。您应该看到一个红色/粉红色的棋盘格3D立方体正在显示。
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You enabled the Lightweight Rending Pipeline by installing the package, creating
    an asset, and choosing that asset for the Project's Scriptable Rending Pipeline
    Graphics property.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过安装包、创建资产并选择该资产作为项目的可脚本渲染管线图形属性，您启用了轻量级渲染管线。
- en: You then created a new Shader Graph asset file, and a new Material that uses
    your shader.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您随后创建了一个新的着色器图资产文件，以及一个使用您着色器的新的材质。
- en: Your Shader Graph feeds a procedurally generated checkerboard into the Emission
    property of the PBR Master output node, and also tints the output by choosing
    a red Color value for the Albedo property. You saved the changes to your Shader
    Graph asset so that they will be available when the scene runs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Shader Graph将一个程序生成的棋盘格图案输入到PBR Master输出节点的Emission属性中，并且通过为Albedo属性选择红色颜色值来着色输出。您已保存对Shader
    Graph资产的更改，以便在场景运行时可用。
- en: Creating a glow effect with Shader Graph
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Shader Graph创建发光效果
- en: 'In the previous recipe, a simple Shader Graph was created by using a Material
    for a primitive 3D Cube mesh. In this recipe, we''ll take things further, creating
    a Shader Graph that applies a parameterized glow effect to a 3D object. The end
    result will look as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，通过使用原始3D立方体网格的材质创建了一个简单的Shader Graph。在这个配方中，我们将更进一步，创建一个将参数化发光效果应用于3D对象的Shader
    Graph。最终结果将如下所示：
- en: '![](img/c62fbcaf-c6c6-447a-814c-575c4dbab0d6.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c62fbcaf-c6c6-447a-814c-575c4dbab0d6.png)'
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds on the previous one, so make a copy of that project and use
    the copy for this recipe.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于之前的配方，因此请复制该项目并使用副本为此配方。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a glow effect with a Shader Graph, follow these steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用着色器图创建发光效果，请按照以下步骤操作：
- en: 'In the Project panel, create a new Physically-Based Rendering (PBR) Shader
    Graph, named glowShaderGraph. Choose menu: Create | Shader | PBR Graph.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为glowShaderGraph的新基于物理渲染（PBR）Shader Graph。选择菜单：创建 | 着色器 | PBR图。
- en: 'In the Project panel, create a new Material named `m_glow`. Choose menu: Create
    | Material.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为`m_glow`的新材质。选择菜单：创建 | 材质。
- en: '3\. With the m_glow selected, in the Inspector, set its Shader property to
    glowShaderGraph. For the Material''s Shader property, choose menu: graphs | glowShaderGraph.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 选择m_glow，在检查器中设置其Shader属性为glowShaderGraph。对于材质的Shader属性，选择菜单：graphs | glowShaderGraph。
- en: 'We now need a 3D mesh object in the scene that uses `m_glow`. While we could
    just use a 3D Cube again, it''s more fun to add a low-polygon textured character
    to the scene. For this recipe, we''ve used the free Unity Asset Store character
    pack Fantasy Mushroom Mon(ster) from AmusedArt. Once the package has been added,
    drag the Mushroom Monster Prefab into the scene from Project panel folder: amusedART
    | Mushroom Monster | Prefab:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要在场景中添加一个使用`m_glow`的3D网格对象。虽然我们可以再次使用3D立方体，但添加一个低多边形纹理角色更有趣。为此配方，我们使用了来自AmusedArt的免费Unity
    Asset Store角色包Fantasy Mushroom Mon(ster)。一旦添加了包，从项目面板文件夹：amusedART | Mushroom
    Monster | Prefab中将蘑菇怪物Prefab拖入场景。
- en: '![](img/b9aa2515-d5dc-4aec-8a50-c8df9d2206d8.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9aa2515-d5dc-4aec-8a50-c8df9d2206d8.png)'
- en: In the Project panel, double click glowShaderGraph to open the Shader Graph
    editing panel.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，双击glowShaderGraph以打开Shader Graph编辑面板。
- en: Right-click the output previewer, select Custom Mesh, and choose MushroomMon
    from the selection dialog.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击输出预览器，选择自定义网格，并在选择对话框中选择MushroomMon。
- en: Add a new **Texture** exposed property to your **Shader Graph** by creating
    a new property texture in the **Shader Graph** Blackboard. Click the plus + button
    and choose property type Texture.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**Shader Graph**黑板上创建一个新的属性纹理，向你的**Shader Graph**添加一个新的**纹理**公开属性。点击加号+按钮，选择属性类型纹理。
- en: In the Blackboard, change the Default value of the property Texture from None
    to Mushroom Green.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在黑板上，将属性纹理的默认值从None更改为Mushroom Green。
- en: 'To use a publically exposed Blackboard property in our **Shader Graph**, we
    need to drag a reference to the property from the Blackboard into the Graph area.
    Drag the Blackboard property Texture into the Graph area. You should see a new
    node with the title Property, and value Texture (T):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在我们的**Shader Graph**中使用公开的Blackboard属性，我们需要将属性的引用从Blackboard拖到图区域。将Blackboard属性纹理拖到图区域。你应该会看到一个标题为Property，值为Texture
    (T)的新节点：
- en: '![](img/ac0e71ae-d4d4-4c3a-89e8-73b48b600156.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac0e71ae-d4d4-4c3a-89e8-73b48b600156.png)'
- en: 'There is no **Texture** input to the Master PDB Node, so we need to add a converter
    node that can take (sample) data from a **2D Texture** image, and turn it into
    RBG values that can be sent to the Albedo input of the **PBR Master Node**. Create
    a new Sample Texture 2D node in your **Shader Graph** by right-clicking the mouse, then
    choose menu: Create Node | Input | Texture | Sample Texture 2D.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主PDB节点没有**纹理**输入，因此我们需要添加一个转换节点，可以从**2D纹理**图像中获取（样本）数据，并将其转换为可以发送到**PBR主节点**的Albedo输入的RGB值。通过在**Shader
    Graph**中鼠标右键单击，然后选择菜单：创建节点 | 输入 | 纹理 | Sample Texture 2D来在你的**Shader Graph**中创建一个新的Sample
    Texture 2D节点。
- en: Now, let's send the **Texture** Mushroom Green into the Master PRB Node via
    the Sample Texture 2D converter node. Link the Texture (T) output from the Property
    node to the Texture (T) input of the Sample Texture 2D node. You should now see
    the Mushroom Green Texture image appear in the 2D rectangular preview at the bottom
    of the Sample Texture 2D node.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过Sample Texture 2D转换节点将**纹理**蘑菇绿发送到主PRB节点。将属性节点输出的纹理（T）连接到Sample Texture
    2D节点的纹理（T）输入。你现在应该能在Sample Texture 2D节点底部的2D矩形预览中看到蘑菇绿纹理图像。
- en: 'Next, link the RGBA (4) output of the Sample Texture 2D node to the Albedo
    (3) input of the Master PRB node (Unity will intelligently just ignore the 4th
    Alpha (A) values). You should now see the Mushroom Green Texture image appear
    in the preview at the bottom of the Master PRB node. You should also see the Mushroom
    Green Texture being applied to the 3D Mushroom Monster Mesh in the **Shader Graph**
    output previewer node:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将Sample Texture 2D节点的RGBA（4）输出连接到主PRB节点的Albedo（3）输入（Unity将智能地忽略第4个Alpha（A）值）。你现在应该能在主PRB节点底部的预览中看到蘑菇绿纹理图像。你也应该能在**Shader
    Graph**输出预览器节点中看到蘑菇绿纹理被应用到3D蘑菇怪物网格上：
- en: '![](img/135b7f81-4e15-4b0e-a312-6c7fd035e885.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/135b7f81-4e15-4b0e-a312-6c7fd035e885.png)'
- en: One way to create a glow effect is by applying a Fresnel Effect. Create a new
    Fresnel Effect node in our **Shader Graph**. Link the Out (3) output from the Fresnel
    Effect node to the Emission (3) input of the**PRB Master** node. You should now
    see a brighter glow outline effect in the **Shader Graph** output previewer node.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建发光效果的一种方法是通过应用菲涅耳效应。在我们的**着色器图**中创建一个新的菲涅耳效应节点。将菲涅耳效应节点的输出（3）连接到**PRB主**节点的发射（3）输入。现在你应该在**着色器图**输出预览器节点中看到一个更亮的发光轮廓效果。
- en: Augustin-Jean Fresnel (1788-1827) studied and documented how an object's reflection
    depends on the viewing angle – for example, looking straight down into still water,
    there is little sunlight reflected and we can see into the water clearly. But
    if our eyes are closer to the level of the water (for example, if we are swimming),
    then much more light is reflected by the water. Simulating this effect in a digital
    shader is a way to make the edges of an object lighter, since light is glancing
    off the edges of the object and reflected to our game camera.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 奥古斯丁-让·菲涅耳（1788-1827）研究了并记录了物体的反射如何依赖于观察角度——例如，直接向下看静止的水，很少有阳光反射，我们可以清楚地看到水。但如果我们眼睛靠近水面（例如，如果我们正在游泳），那么水会反射更多的光。在数字着色器中模拟这种效果是一种使物体边缘变亮的方法，因为光线是沿着物体的边缘掠过的，并反射到我们的游戏摄像机上。
- en: Let's tint our Fresnel Effect by combining it with a publicly exposed Color
    property, which can be set by game designers either in the Inspector or through
    C# code.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过结合公开的着色属性来着色我们的菲涅耳效应，该属性可以通过检查器或C#代码由游戏设计师设置。
- en: First, delete the link from the Out (3) output from the Fresnel Effect node
    to the Emission (3) input of the PBR Master node.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从菲涅耳效应节点到PBR主节点发射（3）输入的链接中删除链接。
- en: Add a new Color exposed property to your **Shader Graph** by creating a new
    property Color in the **Shader Graph** Blackboard. Click the plus + button and
    choose the Color property type.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**着色器图**黑板中创建一个新的属性颜色来向你的**着色器图**添加一个新的公开颜色属性。点击加号+按钮并选择颜色属性类型。
- en: In the Blackboard, set the Default value of the Color property to red (using
    the Color picker).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在黑板中，将颜色属性的默认值设置为红色（使用颜色选择器）。
- en: Drag the Blackboard's Color property into the Graph area. You should see a new
    node with the title Property and a value of  **Color(4)**.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将黑板上的颜色属性拖动到图区域。你应该会看到一个标题为属性且值为**颜色（4）**的新节点。
- en: 'Create a new **Multiply** node in your **Shader Graph** by right-clicking the
    mouse and then choosing menu: Create Node | Math | Basic | Multiply.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的**着色器图**中通过右键单击鼠标并选择菜单：创建节点 | 数学 | 基本操作 | 乘法来创建一个新的**乘法**节点。
- en: The mathematical Multiply node is an easy way to combine values from two nodes,
    which are then to be passed to a single input of a third node.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 数学乘法节点是一种简单的方法，可以将两个节点的值组合起来，然后将这些值传递给第三个节点的单个输入。
- en: 'Let''s combine the Color and Fresnel Effect by making both inputs to the Multiply
    node. Link the Color (4) output from the Property (Color) node to the A (4) input
    of the Multiply node. Next, link the Out (3) output from the Fresnel Effect node
    to the B (4) input of the Multiply node. Finally, link the Out (3) output from
    the Fresnel Effect node to the Emission (3) input of the PRB Master node. You
    should now see a red tinted glow outline effect in the **Shader Graph** output
    previewer node: The overview screenshot below shows these node connections completed
    for our Shader Graph'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将颜色和菲涅耳效应结合起来，使乘法节点的两个输入都有效。将属性（颜色）节点的颜色（4）输出连接到乘法节点的A（4）输入。接下来，将菲涅耳效应节点的输出（3）连接到乘法节点的B（4）输入。最后，将菲涅耳效应节点的输出（3）连接到PRB主节点的发射（3）输入。现在你应该在**着色器图**输出预览器节点中看到一个带有红色着色的发光轮廓效果：下面的概述截图显示了为我们的着色器图完成这些节点连接。
- en: '![](img/aec5981c-5feb-4025-a7a2-c4c7bdabd1c3.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aec5981c-5feb-4025-a7a2-c4c7bdabd1c3.png)'
- en: Save your updated **Shader Graph** by clicking the Save Asset button at the
    top-right of the **Shader Graph** panel.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**着色器图**面板右上角的保存资产按钮来保存你的更新后的**着色器图**。
- en: Save and run your Scene. You should see a red glow around the character.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行你的场景。你应该会在角色周围看到红色的发光效果。
- en: 'In the Project panel, locate the **Material** that your 3D GameObject uses
    (for the Green Mushroom Monster, it is folder: Project | amusedART | Mushroom_Monster
    | Materials | MusroomMonGreen). The publicly exposed properties of the **Shader
    Graph** Blackboard should appear in the **Inspector** as customizable properties.
    Change the Color property to blue. Run the scene again. The glow effect around
    the 3D GameObject should now be blue:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，找到您的3D GameObject使用的**材质**（对于绿蘑菇怪物，它是文件夹：项目 | amusedART | Mushroom_Monster
    | Materials | MusroomMonGreen）。**Shader Graph**黑板上的公开暴露属性应作为可自定义属性出现在**检查器**中。将颜色属性更改为蓝色。再次运行场景。现在3D
    GameObject周围的发光效果应该是蓝色：
- en: '![](img/6a7a69b0-5269-4459-becb-ca27edd6f3a2.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a7a69b0-5269-4459-becb-ca27edd6f3a2.png)'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a new **Shader Graph**, which has several connected nodes. The output(s)
    of one node become the input(s) of another node.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个新的**Shader Graph**，其中包含几个连接的节点。一个节点的输出成为另一个节点的输入。
- en: You created publicly exposed properties for Color and Texture using the **Shader
    Graph** Blackboard, and introduced those properties as inputs in your Graph.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用**Shader Graph**黑板创建了公开暴露的颜色和纹理属性，并将这些属性作为图中的输入。
- en: You used a Sample Texture 2D node to convert the **2D Texture** image into RBG
    values suitable for the **Albedo** input for the **PBR Master** node.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用了一个Sample Texture 2D节点将**2D纹理**图像转换为适合**PBR Master**节点的Albedo输入的RGB值。
- en: You created a Fresnel Effect node, and combined this, via a Multiply node, with
    the publicly exposed Color property, sending the output into the Emission input
    of the PRB Master node.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个Fresnel Effect节点，并通过乘法节点将其与公开暴露的颜色属性结合，将输出发送到PRB Master节点的Emission输入。
- en: You then learned how to change the publicly exposed property for Color in the
    Inspector via the Material's properties.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了如何在检查器中通过材质的属性更改公开暴露的Color属性。
- en: Toggling a Shader Graph color glow effect through C# code
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过C#代码切换Shader Graph颜色发光效果
- en: Effects such as the glow effect from the previous recipe are often features
    we wish to toggle on and off under different circumstances. The effect could be
    turned on or off during a game to visually communicate the status of a GameObject—for
    example, an *angry* character might glow red, while a *happy* monster might glow
    green, and so on.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个配方中的发光效果之类的效果通常是我们在不同情况下希望切换开启和关闭的功能。在游戏中，效果可以开启或关闭，以视觉上传达GameObject的状态——例如，一个*愤怒*的角色可能会发光红色，而一个*快乐*的怪物可能会发光绿色，等等。
- en: We'll add to the previous recipe to create a new publicly exposed **Shader Graph**
    Blackboard property named Power, and write code that can be used to set this value
    to zero or five in order to turn the glow effect on and off. We'll also access
    the Color property so that we're able to set what color the glow effect displays.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在之前的配方基础上添加新的公开暴露的**Shader Graph**黑板属性，命名为Power，并编写代码来设置此值为零或五，以便开启和关闭发光效果。我们还将访问颜色属性，以便能够设置发光效果显示的颜色。
- en: Getting ready
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds on the previous one, so make a copy of that project and use
    the copy for this recipe.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于之前的配方，因此请复制该项目并使用副本进行此配方。
- en: How to do it...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To toggle the glow effect from the Shader Graph, follow these steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Shader Graph中切换发光效果，请按照以下步骤操作：
- en: First, delete the link from the Out (3) output from the Multiply node to the
    Emission (3) input of the PBR Master node. We are doing this because the output
    of this Multiply node will become an input for a second Multiple node that we
    are about to create.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，删除从乘法节点的Out (3)输出到PBR Master节点的Emission (3)输入的链接。我们这样做是因为这个乘法节点的输出将成为我们即将创建的第二个乘法节点的输入。
- en: 'Create a new Multiply node in your **Shader Graph** by right-clicking the mouse
    and then choosing menu: Create Node | Math | Basic | Multiply.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Shader Graph**中通过右键单击鼠标并选择菜单：创建节点 | 数学 | 基本操作 | 乘法来创建一个新的乘法节点。
- en: Link the Out (4) output from the original Multiply node to the A (4) input of
    your new Multiply node. Also, link the Out (3) output from the new Multiply node
    to the Emission (3) input of the PBR Master node.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始乘法节点的Out (4)输出链接到您新乘法节点的A (4)输入。同时，将新乘法节点的Out (3)输出链接到PBR Master节点的Emission
    (3)输入。
- en: Add a new `float` (decimal number), exposed to the Power property, to your **Shader
    Graph** by creating a new property in the **Shader Graph** Blackboard. Click the
    plus + button and choose property type `Vector 1`, and rename this `Power`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **Shader Graph** 黑板中创建一个新的属性来将一个新的 `float`（十进制数）添加到你的 **Shader Graph**，使其公开于功率属性。点击加号
    + 按钮并选择属性类型 `Vector 1`，并将此重命名为 `Power`。
- en: In the Blackboard, set the Default value of the Power property to `5`. Also,
    set the display Mode to Slider with the values of Min 0 and Max 5.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在黑板上，将功率属性的默认值设置为 `5`。同时，将显示模式设置为带有值 Min 0 和 Max 5 的滑块。
- en: Drag the Blackboard Power property into the Graph area. You should see a new
    node with the title Property, and a value of Power(1).
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将黑板的功率属性拖动到图形区域。你应该会看到一个标题为属性的新节点，值为 Power(1)。
- en: 'Finally, link the Power(1) output from Property node (Power) to the B (4) input
    of the new Multiply node:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将属性节点（功率）的 Power(1) 输出链接到新乘法节点的 B (4) 输入：
- en: '![](img/05d4056a-9c21-44ab-99cb-16c4d235c537.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05d4056a-9c21-44ab-99cb-16c4d235c537.png)'
- en: Save your updated **Shader Graph** by clicking the Save Asset button at the
    top-right of the **Shader Graph** panel.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **Shader Graph** 面板右上角的保存资产按钮来保存你的更新后的 **Shader Graph**。
- en: 'Create a new C# script class named `GlowManager` containing the following:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为 `GlowManager` 的 C# 脚本类，包含以下内容：
- en: '[PRE17]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Select **Shader Graph** glowShaderGraph in the Project panel, and view its
    properties in the Inspector:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中选择 **Shader Graph** glowShaderGraph，并在检查器中查看其属性：
- en: '![](img/513e2e16-bfd0-4367-8b45-7d0a1294baa9.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/513e2e16-bfd0-4367-8b45-7d0a1294baa9.png)'
- en: 'Find the internal IDs of the publicly exposed properties Power and Color –
    they will be something like Vector1_AA07C639 and Color_466BE55E. Copy these IDs
    into C# script statements by setting the ID strings:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找公开暴露的属性 Power 和 Color 的内部 ID – 它们可能是类似 Vector1_AA07C639 和 Color_466BE55E 的内容。将这些
    ID 复制到 C# 脚本语句中，通过设置 ID 字符串：
- en: '[PRE18]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At the time of writing this book, the current version of **Shader Graph** doesn't
    provide a convenient way to access exposed properties using the names chosen in
    the Shader Graph Blackboard, hence the need to look up the internal ID needed
    for the `material.SetFloat(powerId, power)` statement when changing the value.
    It is likely that Unity will soon update the **Shader Graph** scripting API to
    make this action more straightforward.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，当前版本的 **Shader Graph** 没有提供一种方便的方法来使用在 Shader Graph 黑板上选择的名称访问公开属性，因此需要查找用于
    `material.SetFloat(powerId, power)` 语句所需的内部 ID。Unity 很可能很快就会更新 **Shader Graph**
    脚本 API，使这一操作更加直接。
- en: In the Hierarchy, locate the component of your 3D GameObject that contains the
    Mesh Renderer component (for our Mushroom Monster example, this is the Mushroom
    Mon child of the Mushroom Monster GameObject). Add an instance object of the `GlowManager` script
    class as a component to this **GameObject**.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，找到包含网格渲染器组件的 3D GameObject 的组件（对于我们的蘑菇怪物示例，这是蘑菇怪物 GameObject 的蘑菇怪物子项）。将
    `GlowManager` 脚本类的实例对象作为组件添加到这个 **GameObject**。
- en: Save and run your Scene. Pressing the *1* key should turn on the red glow effect,
    pressing the *2* key should turn on the blue glow effect, and pressing the *0*
    key should turn off the glow effect.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行你的场景。按下 *1* 键应该开启红色发光效果，按下 *2* 键应该开启蓝色发光效果，按下 *0* 键应该关闭发光效果。
- en: How it works...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a new Power exposed property for your **Shader Graph** that combined
    with the Fresnel color effect so that a value of zero will turn off the effect.
    You looked up the internal IDs of the Power and Color exposed properties, and
    updated the C# script so that it can update these properties.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你为你的 **Shader Graph** 创建了一个新的 Power 公开属性，它与菲涅耳颜色效果结合，使得零值会关闭效果。你查看了 Power 和
    Color 公开属性的内部 ID，并更新了 C# 脚本，使其能够更新这些属性。
- en: The scriptclass checks for the 0/1/2 keys, and correspondingly turns the effect
    off/to a red glow/to a blue glow.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本类会检查 0/1/2 键，并相应地关闭效果/变为红色发光/变为蓝色发光。
- en: By combining publicly exposed properties with code, you are able to change **Shader
    Graph** values at runtime through events detected by code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合公开暴露的属性和代码，你能够在运行时通过代码检测到的事件来更改 **Shader Graph** 的值。
- en: There's more...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some ways to take your **Shader Graph** features even further.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些方法可以将你的 **Shader Graph** 功能进一步扩展。
- en: Using Sine Time to create a pulsating glow effect
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正弦时间创建脉冲发光效果
- en: You could make the glow effect *pulse* by creating a Time node, and linking
    the Sine Time (1) output to the Fresnel Effect input Power (1). As the Sine Time
    value changes between - 1/0/+1, it will influence how strong the Fresnel Effect
    is, changing the brightness of the glow effect.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个时间节点，并将正弦时间（1）输出链接到菲涅耳效果输入功率（1），使发光效果*脉冲*。当正弦时间值在-1/0/+1之间变化时，它将影响菲涅耳效果的强度，从而改变发光效果的亮度。
- en: Using the Compile and Show Code button as another way to find exposed property
    IDs
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“编译并显示代码”按钮作为查找公开属性ID的另一种方式
- en: When you are viewing the properties of a **Shader Graph** asset in the **Inspector**,
    you'll see a button entitled Compile and Show Code. If you click this, you'll
    then see a generated ShaderLab code file in your script editor.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在**检查器**中查看**着色器图**资产属性时，你会看到一个名为“编译并显示代码”的按钮。如果你点击这个按钮，你将在脚本编辑器中看到一个生成的ShaderLab代码文件。
- en: 'It isn''t the actual code used by Unity, but it provides a good idea of the
    code that is generated from your **Shader Graph**. The internal IDs for your publicly
    exposed Blackboard properties are listed in the Properties section, which is at
    the beginning of the generated code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是Unity实际使用的代码，但它为你从**着色器图**生成的代码提供了一个很好的概念。你公开暴露的黑板属性内部ID列在属性部分，这是生成代码的开头：
- en: '[PRE19]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
