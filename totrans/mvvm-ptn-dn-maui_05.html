<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-86"><a id="_idTextAnchor086"/>5</h1>
<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Community Toolkits</h1>
<p>In this chapter, we will explore some of the popular <strong class="bold">Community Toolkits</strong> that have been developed to assist<a id="_idIndexMarker352"/> developers in using data binding and the MVVM pattern more efficiently and effectively in .NET MAUI. These toolkits offer valuable components and utilities that can greatly enhance your development experience and help you build robust and maintainable applications. There are numerous large and small frameworks or toolkits that facilitate data binding and the application of the MVVM pattern in your projects. Some of them have a significant overall impact on your code, while others are more focused on providing developers with a set of helpers or components that you typically rewrite for each new project.</p>
<p>Every existing toolkit or framework is the product of dedicated developers investing their time and expertise, and each one provides value to its users, whether or not it suits your particular coding style. In this book, I don’t want to favor any specific framework or toolkit over others but rather showcase community-driven efforts that can be beneficial to developers. For this reason, we’ll be exploring two Community Toolkits that provide some helpers and base classes that you can build upon but don’t have a large impact on your code.</p>
<p>In this chapter, we will be discussing the following:</p>
<ul>
<li>The MVVM Toolkit</li>
<li>The .NET MAUI Community Toolkit</li>
<li>Other popular frameworks</li>
<li>Contributing to the community</li>
</ul>
<p>These toolkits were chosen as examples because they offer tools and components that can be integrated into your projects as needed, without imposing a specific architectural style or coding paradigm. This feature makes these toolkits particularly flexible and adaptable to a variety of coding styles and project requirements. Being part of the .NET Community Toolkits, they benefit from a wide community of contributors, including both Microsoft employees and independent developers. This collaboration ensures the toolkits remain up to date, reliable, and effective for developers across the board.</p>
<p>These toolkits aim to simplify many common tasks you will encounter when building .NET MAUI applications. The features they provide are often things we’ve covered in earlier chapters, but now, they’ve been conveniently implemented for you. It’s important to understand that these toolkits are not magical entities; they encapsulate strategies and techniques that you could implement yourself. However, their true value lies in offering a ready-made, community-approved solution, saving you significant time and effort. By knowing what’s available in these toolkits, you can make informed decisions about when to leverage them and when to customize your solutions. So, without further ado, let’s dive in and see what they have to offer!</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Technical requirements</h1>
<p>Throughout this chapter, we will be updating some code from the <em class="italic">Recipes!</em> app. The updated code can be found on GitHub at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05</a> for reference and comparison.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>The MVVM Toolkit</h1>
<p>The <strong class="bold">MVVM Toolkit</strong> (<strong class="bold">CommunityToolkit.Mvvm</strong>) is a comprehensive library that’s designed to simplify<a id="_idIndexMarker353"/> and streamline the implementation of the MVVM pattern in your applications. Developed and maintained by the .NET community, this toolkit provides a robust set of framework-independent tools, components, and utilities that help you build applications using the MVVM pattern. It’s important to note that this toolkit isn’t .NET MAUI-specific; it’s UI framework-agnostic.</p>
<p>Here are some of the key features<a id="_idIndexMarker354"/> of the MVVM Toolkit:</p>
<ul>
<li><code>INotifyPropertyChanged</code> interface, simplifying the process of raising the <code>PropertyChanged</code> event. Its <code>SetProperty</code> method streamlines setting property values and automatically raises the <code>PropertyChanged</code> event when needed. By using this class, developers can reduce the boilerplate code associated with checking for property updates and triggering the <code>PropertyChanged</code> event accordingly.</li>
<li><code>ObservableValidator</code> extends the <code>ObservableObject</code> class and includes<a id="_idIndexMarker356"/> built-in validation logic. This means that any object that inherits from <code>ObservableValidator</code> will have both observable and validating features.</li>
<li><code>ICommand</code> interface. <code>RelayCommand</code> handles synchronous operations, while <code>AsyncRelayCommand</code> is designed for asynchronous tasks. Both support optional <code>CanExecute</code> logic.</li>
<li><code>WeakReferenceMessenger</code> is a messaging system that enables<a id="_idIndexMarker359"/> communication between loosely coupled components. It uses weak references to manage message subscriptions, which helps you avoid memory leaks and unintended strong dependencies between objects in your application. Messaging will be discussed in more depth in <a href="B20941_07.xhtml#_idTextAnchor119"><em class="italic">Chapter 7</em></a>, <em class="italic">Dependency Injection, Services, </em><em class="italic">and Messaging</em>.</li>
<li><code>ObservablePropertyAttribute</code> simplifies the implementation of properties that trigger the <code>PropertyChanged</code> event, and <code>RelayCommandAttribute</code> automates<a id="_idIndexMarker361"/> the creation of commands, respectively.</li>
</ul>
<p>These are only a few examples of the components of an MVVM Toolkit. The idea here was to let you know what the MVVM library has to offer. Now, let’s look into how to effectively use it in our project.</p>
<p>Adding the MVVM Toolkit to your project<a id="_idIndexMarker362"/> is very easy:</p>
<ol>
<li>Right-click the <code>Recipes.Client.Core</code> project and select <strong class="bold">Manage </strong><strong class="bold">Nuget Packages</strong>.</li>
<li>Search for <code>MVVM Toolkit</code> and select <strong class="bold">CommunityToolkit.Mvvm</strong> from the list. <em class="italic">Figure 5</em><em class="italic">.1</em> shows the NuGet package we are searching for:</li>
</ol>
<div><div><img alt="Figure 5.1: CommunityToolkit.Mvvm NuGet package" height="116" src="img/B20941_05_01.jpg" width="1198"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: CommunityToolkit.Mvvm NuGet package</p>
<ol>
<li value="3">Hit <code>Recipes.Client.Core</code> project.</li>
</ol>
<p>In the following example, we will be updating <code>RecipeDetailViewModel</code> and <code>IngredientsListViewModel</code> so that they<a id="_idIndexMarker363"/> use <code>ObservableObject</code> from the MVVM Toolkit.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>ObservableObject</h2>
<p>Implementing the <code>INotifyPropertyChanged</code> interface<a id="_idIndexMarker364"/> in each ViewModel can become<a id="_idIndexMarker365"/> tedious and repetitive. That’s why developers often create a base class that takes care of this task. The MVVM Toolkit provides such a base class for free in the form of <code>ObservableObject</code>.</p>
<p>By inheriting from <code>ObservableObject</code>, your ViewModel classes can automatically notify the View of property changes, keeping the UI synchronized with the underlying data. <code>ObservableObject</code> also provides the <code>SetProperty</code> method, which allows developers to set a property’s value. As a result, if the value has changed, it automatically triggers the <code>PropertyChanged</code> event to update the UI.</p>
<p>Let’s update our code so that our ViewModels inherit from <code>ObservableObject</code> instead of each one having its own implementation of the <code>INotifyPropertyChanged</code> interface:</p>
<ol>
<li>Head over to <code>IngredientsListViewModel</code> and let this class inherit from <code>ObservableObject</code> instead of implementing the <code>INotifyPropertyChanged</code> interface, as seen here:<pre class="source-code">
<strong class="bold">using CommunityToolkit.Mvvm.ComponentModel;</strong>
namespace Recipes.Client.Core.ViewModels;
public class IngredientsListViewModel :
  <strong class="bold">ObservableObject</strong>
{
    private int _numberOfServings = 4;
    public int NumberOfServings
    {
        ...
    }
    //ToDo: add list of Ingredients
}</pre></li> <li>By inheriting <code>ObservableObject</code>, we can remove the <code>OnPropertyChanged</code> method and the <code>PropertyChanged</code> event that we had before.</li>
<li>Next, we can update<a id="_idIndexMarker366"/> the setter of the <code>NumberOfServings</code> property<a id="_idIndexMarker367"/> so that it uses the <code>SetProperty</code> method of <code>ObservableObject</code>:<pre class="source-code">
public int NumberOfServings
{
    get =&gt; _numberOfServings;
    set =&gt; SetProperty(ref _numberOfServings, value);
}</pre><p class="list-inset">The <code>SetProperty</code> method eases the implementation of calling the <code>PropertyChanged</code> event when the value is being updated. This method will update the provided backing field (<code>_numberOfServings</code>) and trigger the <code>PropertyChanged</code> event automatically when the value is being updated.</p></li> </ol>
<p>We can start doing <a id="_idIndexMarker368"/>the same thing<a id="_idIndexMarker369"/> for <code>RecipeDetailViewModel</code> as well:</p>
<ol>
<li>Inherit from <code>ObservableObject</code>.</li>
<li>Remove the <code>OnPropertyChanged</code> method and the <code>PropertyChanged</code> event.</li>
<li>Update the setter of <code>HideAllergenInformation</code> so that it uses the <code>SetProperty</code> method, as shown in the following snippet:<pre class="source-code">
private bool _hideAllergenInformation = true;
public bool HideAllergenInformation
{
    get =&gt; _hideAllergenInformation;
    set =&gt; <strong class="bold">SetProperty(ref _hideAllergenInformation, value);</strong>
}</pre></li> </ol>
<p>By ensuring our ViewModels inherit from <code>ObservableObject</code> and utilize the <code>SetProperty</code> method, we can eliminate excessive boilerplate code. This would benefit us by reducing a significant amount of ceremony. This helps maintain the conciseness and clarity of our ViewModels, allowing them to stay focused on their core responsibilities. Unless you are being paid by lines of code, I think you would agree that these updated classes look a lot better with a lot less boilerplate code!</p>
<p>One of the most helpful features<a id="_idIndexMarker370"/> in the MVVM Toolkit is the <a id="_idIndexMarker371"/>different <code>ICommand</code> implementations. Let’s take a look!</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>RelayCommand</h2>
<p>The MVVM Toolkit provides<a id="_idIndexMarker372"/> several robust implementations of the <code>ICommand</code> interface. Each implementation serves a unique purpose, addressing varied needs for communication between the ViewModel and View in different scenarios. These implementations<a id="_idIndexMarker373"/> help streamline command operations:</p>
<ul>
<li><code>RelayCommand</code>: This straightforward implementation of <code>ICommand</code> allows you to specify <code>Execute</code> and <code>CanExecute</code> methods using delegates, tailoring what the command does and whether it can be executed at a given time. This implementation is similar to <code>Microsoft.Maui.Controls.Command</code>, which we used earlier. However, the <code>Command</code> implementation had the <code>ChangeCanExecute</code> method, which we can call to trigger the re-evaluation of the <code>CanExecute</code> method. On the <code>RelayCommand</code> class, a method with this behavior is called <code>NotifyCanExecuteChanged</code>.</li>
<li><code>RelayCommand&lt;T&gt;</code>: This is a variant of <code>RelayCommand</code> that adds support for a parameter that can be passed to the <code>Execute</code> and <code>CanExecute</code> methods. The type of the parameter is determined by the generic type parameter. This implementation is similar to <code>Microsoft.Maui.Controls.Command&lt;T&gt;</code>.</li>
<li><code>AsyncRelayCommand</code>: An async variant of <code>ICommand</code>, <code>AsyncRelayCommand</code> returns a <code>Task</code>, making it ideal for managing asynchronous operations such as network data fetches.</li>
<li><code>AsyncRelayCommand&lt;T&gt;</code>: A parameter-supporting version of <code>AsyncRelayCommand</code>, this allows you to pass an argument to the asynchronous <code>Execute</code> and <code>CanExecute</code> methods, providing additional versatility for async operations.</li>
</ul>
<p>Let’s see how we can update our command so that it leverages the <code>RelayCommand</code> and <code>RelayCommand&lt;T&gt;</code> classes:</p>
<ol>
<li>The following code block shows how we can initialize the commands in the constructor by updating their type from <code>Microsoft.Maui.Controls.Command</code> to <code>CommunityToolkit.Mvvm.Input.RelayCommand</code> and from <code>Microsoft.Maui.Controls.Command&lt;T&gt;</code> to <code>CommunityToolkit.Mvvm.Input.RelayCommand&lt;T&gt;</code>:<pre class="source-code">
public RecipeDetailViewModel()
{
    AddAsFavoriteCommand =
        <strong class="bold">new RelayCommand(AddAsFavorite,</strong>
<strong class="bold">          CanAddAsFavorite);</strong>
    RemoveAsFavoriteCommand =
        <strong class="bold">new RelayCommand(RemoveAsFavorite,</strong>
          <strong class="bold">CanRemoveAsFavorite);</strong>
    SetFavoriteCommand =
           <strong class="bold">new RelayCommand&lt;bool&gt;(SetFavorite,</strong>
             <strong class="bold">CanSetFavorite);</strong>
}</pre><p class="list-inset">This updated code will instantiate<a id="_idIndexMarker374"/> the three commands<a id="_idIndexMarker375"/> with a new <code>RelayCommand</code>, passing in the methods that should be triggered when calling the command’s <code>Execute</code> and <code>CanExecute</code> methods.</p></li> <li>While we are at it, we can also go ahead and update the types of the commands in this class. While <code>RelayCommand</code> implements the <code>ICommand</code> interface, it also implements the <code>IRelayCommand</code> interface:<pre class="source-code">
public <strong class="bold">IRelayCommand</strong> AddAsFavoriteCommand
{
    get;
}
public <strong class="bold">IRelayCommand</strong> RemoveAsFavoriteCommand
{
    get;
}
public <strong class="bold">IRelayCommand</strong> SetFavoriteCommand
{
    get;
}</pre><p class="list-inset">By updating the type of our commands, as shown in the preceding snippet, we can avoid additional castings later on.</p></li> <li>The setter of <code>IsFavorite</code> can now be<a id="_idIndexMarker376"/> updated<a id="_idIndexMarker377"/> to this:<pre class="source-code">
public bool? IsFavorite
{
    get =&gt; _isFavorite;
    private set
    {
        <strong class="bold">if(SetProperty(ref _isFavorite, value))</strong>
        {
            <strong class="bold">AddAsFavoriteCommand</strong>
<strong class="bold">                .NotifyCanExecuteChanged()</strong>;
            <strong class="bold">RemoveAsFavoriteCommand</strong>
<strong class="bold">                .NotifyCanExecuteChanged()</strong>;
            <strong class="bold">SetFavoriteCommand</strong>
<strong class="bold">                .NotifyCanExecuteChanged()</strong>;
        }
    }
}</pre><p class="list-inset">The <code>SetProperty</code> method returns <code>true</code> if the property was changed. This allows us to do additional things when the property is changed (or not). For example, in this case, we want to re-evaluate the <code>CanExecute</code> method of the commands when the <code>IsFavorite</code> property changes its value by calling each command’s <code>NotifyCanExecuteChanged</code> method.</p></li> </ol>
<p class="callout-heading">Adhering to the best practices of MVVM</p>
<p class="callout">Because we don’t use <code>Microsoft.Maui.Control.Command</code> anymore, we can also remove the MAUI dependency<a id="_idIndexMarker378"/> that we currently have on this project. Click on the <code>Recipes.Client.Core</code> project so that the project’s <code>.csproj</code> file opens and remove the <code>&lt;UseMaui&gt;</code> tag. Now, the ViewModels (and the <code>Recipes.Client.Core</code> project) are platform-agnostic again, adhering to the best practices of MVVM.</p>
<p>In <a href="B20941_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, it was apparent that applying the MVVM pattern involves a lot more code compared to writing everything in code-behind. Mostly, that’s because of all of the ceremony in the ViewModels. While classes such as <code>ObservableObject</code> already abstract away some of the boilerplate<a id="_idIndexMarker379"/> code, we could even go one step further and look at the Source Generators<a id="_idIndexMarker380"/> that are available in the MVVM Toolkit.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Source Generators</h2>
<p>Source Generators <a id="_idIndexMarker381"/>are a compiler feature in .NET that allows developers <a id="_idIndexMarker382"/>to generate new code during the compilation process. This has the potential to greatly reduce manual coding and the likelihood of errors.</p>
<p>The MVVM Toolkit provides <code>ObservablePropertyAttribute</code> and <code>RelayCommandAttribute</code>, which are used by the Source Generators to create properties that notify the UI of changes and commands that handle user interactions, respectively. Additionally, other attributes such as <code>NotifyPropertyChangedForAttribute</code> and <code>NotifyCanExecuteChangedForAttribute</code> can be used in combination with <code>ObservablePropertyAttribute</code> to add even more functionality through code generation.</p>
<p>Given how Source Generators work, the class on which these attributes are applied must be declared as a partial class. In C#, partial classes allow you to split a class across multiple files using the <code>partial</code> keyword. At compile time, the different files are combined into one class. This feature is integral to source generators, which generate additional source code during compilation. Therefore, when you wish to use any of these attributes, remember to declare your ViewModel as <code>partial</code>:</p>
<pre class="source-code">
public <strong class="bold">partial</strong> class RecipeDetailViewModel :
  ObservableObject</pre> <p>Now that the ViewModel has been<a id="_idIndexMarker383"/> declared as partial, we can begin to adapt our code<a id="_idIndexMarker384"/> to take advantage of these attributes. Let’s see how this can be done.</p>
<h3>Using the ObservableProperty attribute</h3>
<p>Typically, we need<a id="_idIndexMarker385"/> to write some boilerplate <a id="_idIndexMarker386"/>code when implementing a property that triggers the <code>PropertyChanged</code> event. By using <code>ObservablePropertyAttribute</code>, we can let Source Generators generate this code for us.</p>
<p>This attribute can be applied to a field; at build time, a public property will be generated, with the annotated field as the backing field.</p>
<p>As an example, we can take a look at <code>RecipeDetailViewModel</code>. The <code>HideExtendedAllergenList</code> property can be deleted and <code>ObservablePropertyAttribute</code> can be added to the <code>_hideExtendedAllergenList</code> field:</p>
<pre class="source-code">
<strong class="bold">[ObservableProperty]</strong>
private bool _hideExtendedAllergenList = true;</pre> <p>With this <code>ObservableProperty</code> attribute in place, a full-fledged public property named <code>HideExtendedAllergenList</code> will be generated at build time.</p>
<p>The generated property’s set method will contain logic that checks whether the value is updated and triggers the <code>PropertyChanged</code> event accordingly. The setter will also call a handful of partial methods that are being generated, allowing us to add some custom code<a id="_idIndexMarker387"/> while the property<a id="_idIndexMarker388"/> value is being updated.</p>
<p class="callout-heading">Note</p>
<p class="callout">It’s very important to note that the <code>ObservableProperty</code> attribute generates a public property for us. When binding this value to the UI, make sure you bind to this generated property (<code>HideExtendedAllergenList</code>, in this case) and not try to bind to the field you’ve set the attribute on. Also, when assigning a value, always assign it to the generated property to make sure the <code>PropertyChanged</code> event gets triggered!</p>
<p>But what about the <code>IsFavorite</code> property of <code>RecipeDetailViewModel</code>?</p>
<p>In this setter, we call the <code>NotifyCanExecuteChanged</code> method of our commands. Can we make this work on a generated property as well? Yes; for those cases, we have the <code>NotifyCanExecuteChangedFor</code> attribute, which accepts the name of the command whose <code>NotifyCanExecuteChanged</code> method needs to be triggered when the value of the property is updated. This means that the entire <code>IsFavorite</code> property could be rewritten like this:</p>
<pre class="source-code">
[ObservableProperty]
[NotifyCanExecuteChangedFor(nameof(AddAsFavoriteCommand))]
[NotifyCanExecuteChangedFor(nameof(RemoveAsFavoriteCommand))]
[NotifyCanExecuteChangedFor(nameof(SetFavoriteCommand))]
private bool? _isFavorite = false;</pre> <p>The first attribute, <code>ObservableProperty</code>, will generate a property that will trigger the <code>PropertyChanged</code> event when its value is being updated. The next three <code>NotifyCanExecuteChangedFor</code> attributes will make sure that the <code>NotifyCanExecuteChanged</code> method of the three commands of the <code>IRelayCommand</code> type will be invoked when the property updates.</p>
<p>Speaking of commands, there’s a Source<a id="_idIndexMarker389"/> Generator<a id="_idIndexMarker390"/> for generating a <code>RelayCommand</code> as well. Let’s take a look.</p>
<h3>Using the RelayCommand attribute</h3>
<p>You can apply the <code>RelayCommand</code> attribute to a method<a id="_idIndexMarker391"/> that you intend to use as the execution<a id="_idIndexMarker392"/> action for a command. At build time, this will generate a public <code>RelayCommand</code> property with the same name as the method, suffixed with “Command.” When calling the <code>Execute</code> method of the generated <code>RelayCommand</code>, the method on which the attribute was applied will be invoked. This essentially simplifies the process of declaring a public <code>IRelayCommand</code> command, making a method to be invoked, and creating an instance of the command tied to that method, in the following simplified form:</p>
<pre class="source-code">
<strong class="bold">[RelayCommand]</strong>
private void RemoveAsFavorite() =&gt; IsFavorite = false;</pre> <p>This will generate a <code>RemoveAsFavoriteCommand</code> public property of type <code>IRelayCommand</code> that will call the <code>RemoveAsFavorite</code> method when the command is being executed.</p>
<p>When applying this attribute to a method that accepts one parameter, the resulting command will be a generic <code>RelayCommand&lt;T&gt;</code>, where <code>T</code> corresponds to the type of the parameter.</p>
<p>Alternatively, we can also pass in a string parameter called <code>CanExecute</code> that points to a method, which should be invoked when calling the command’s <code>CanExecute</code> method. This is essential if we want to update <code>RecipeDetailViewModel</code> and let <code>AddAsFavoriteCommand</code>, <code>RemoveAsFavoriteCommand</code>, and <code>SetFavoriteCommand</code> be generated by Source Generators. Let’s see how we can achieve that:</p>
<ol>
<li>Delete the public <code>AddAsFavoriteCommand</code>, <code>RemoveAsFavoriteCommand</code>, and <code>SetFavoriteCommand</code> properties of type <code>IRelayCommand</code>.</li>
<li>Delete the instantiation of these commands in the constructor of <code>RecipeDetailViewModel</code>.</li>
<li>Add the <code>RelayCommand</code> attribute to the <code>AddAsFavorite</code>, <code>RemoveAsFavorite</code>, and <code>SetFavorite</code> methods, as shown here:<pre class="source-code">
<strong class="bold">[RelayCommand(CanExecute = nameof(CanSetFavorite))]</strong>
private void SetFavorite(bool isFavorite)
    =&gt; IsFavorite = isFavorite;
<strong class="bold">[RelayCommand(CanExecute = nameof(CanAddAsFavorite))]</strong>
private void AddAsFavorite() =&gt; IsFavorite = true;
<strong class="bold">[RelayCommand(CanExecute = nameof</strong>
<strong class="bold">  (CanRemoveAsFavorite))]</strong>
private void RemoveAsFavorite() =&gt; IsFavorite = false;</pre><p class="list-inset">At build time, the public command will be generated thanks to the <code>RelayCommand</code> attributes. In this example, all of the attributes also point to a method that gets invoked when calling the generated command’s <code>CanExecute</code> method.</p></li> </ol>
<p>While Source Generators<a id="_idIndexMarker393"/> can greatly simplify code bases and improve<a id="_idIndexMarker394"/> productivity by automating boilerplate code, I choose not to use them for a couple of reasons.</p>
<p>Firstly, they can obscure some of the underlying implementation details. This might make it challenging for newcomers or less experienced developers to fully understand the code and its intrinsic patterns.</p>
<p>Secondly, employing the MVVM Toolkit’s Source Generators may require adjusting your coding style to match the “prescribed” style inherent to the toolkit. This may not appeal to all developers who prefer more flexibility in their coding approach.</p>
<p>However, it’s essential to note that these are personal preferences, and many developers find great value in using Source Generators. They can significantly streamline your ViewModel development process, and if you find them beneficial and conducive to your coding style, I wholeheartedly recommend their usage!</p>
<p>At the end of the day, Source Generators are a tool. Like any tool, it’s crucial to consider when and where they add the most value. Balancing the benefits of automation and simplicity with understanding, flexibility, and individual style in your code is always an important consideration in software development.</p>
<p>This covers most of the essentials<a id="_idIndexMarker395"/> of the MVVM Toolkit. Now, let’s see how the .NET MAUI Community Toolkit<a id="_idIndexMarker396"/> can make our lives easier when applying the MVVM pattern.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>The .NET MAUI Community Toolkit</h1>
<p>The .<strong class="bold">NET MAUI Community Toolkit</strong> is a collection of useful components, controls, and utilities designed<a id="_idIndexMarker397"/> to enhance the development experience with .NET MAUI. Although its primary focus is not on enabling or facilitating MVVM, the toolkit does provide features that can greatly assist developers in implementing the MVVM pattern in their .NET MAUI projects:</p>
<ul>
<li><strong class="bold">Behaviors</strong>: These are reusable pieces of functionality<a id="_idIndexMarker398"/> that can be attached to certain types of controls. By encapsulating code in behaviors, you can keep your views clean and easy to understand.</li>
<li><strong class="bold">Converters</strong>: As we’ve seen before, converters<a id="_idIndexMarker399"/> help transform data from one type into another, making it easier to bind data from your ViewModel to your View. The toolkit has a lot of converters for a huge range of common scenarios.</li>
</ul>
<p>There is much more to the .NET MAUI Community Toolkit, but in the context of MVVM, these are the relevant bits. Please note that this is a toolkit that should only be added to MAUI projects and not to the core project that houses your ViewModels, for example. Why? Because the .NET MAUI Community is .NET MAUI-dependent and therefore it should not be referenced to projects that are agnostic of UI frameworks.</p>
<p>By offering these additional features and helpers, the .NET MAUI Community Toolkit contributes to a more efficient and streamlined development process when working with MVVM in .NET MAUI.</p>
<p>Installing the .NET MAUI Community Toolkit is just like installing any other NuGet package:</p>
<ol>
<li>Right-click the <code>Recipes.Mobile</code> project<a id="_idIndexMarker400"/> and select <strong class="bold">Manage </strong><strong class="bold">NuGet Packages</strong>.</li>
<li>Search for <code>Maui Community</code> and select <strong class="bold">CommunityToolkit.Maui</strong> from the list. <em class="italic">Figure 5</em><em class="italic">.2</em> shows the NuGet package we should download:</li>
</ol>
<div><div><img alt="Figure 5.2: CommunityToolkit.Maui NuGet package" height="120" src="img/B20941_05_02.jpg" width="1528"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: CommunityToolkit.Maui NuGet package</p>
<ol>
<li value="3">Hit <code>Recipes.Mobile</code> project.</li>
<li>Once installed, head over to <code>MauiProgram.cs</code> and make sure you call <code>UseMauiCommunityToolkit</code> on <code>MauiAppBuilder</code>:<pre class="source-code">
builder.UseMauiCommunityToolkit();</pre></li> <li>To use components from the toolkit in XAML, you will need to add the namespace to the XAML pages where you want to use the toolkit:<pre class="source-code">
</pre><p class="list-inset">Once all of this is in place, we can start using the .NET MAUI Community Toolkit.</p></li> </ol>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Converters</h2>
<p>In <a href="B20941_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Binding in .NET MAUI</em>, we discussed what value converters<a id="_idIndexMarker401"/> are and how to create them. The .NET MAUI Community Toolkit comes packed with a whole lot of ready-to-use value converters. One such converter is <code>ListToStringConverter</code>, which can be very handy for displaying a list of items as a single string. Let’s use it to display the allergen information of the recipe:</p>
<ol>
<li>To start, let’s add an array of strings called <code>Allergens</code> to <code>RecipeDetailViewModel</code>:<pre class="source-code">
public string[] Allergens { get; }
    = new string[]{ "Milk", "Eggs", "Nuts", "Sesame" };</pre><p class="list-inset">This property holds a list of all allergens that the recipe contains. For now, we’re hardcoding some values here.</p></li> <li>On <code>RecipeDetailPage</code>, add the toolkit’s namespace:<pre class="source-code">
xmlns:toolkit=http://schemas.microsoft.com/dotnet/2022
  /maui/toolkit</pre><p class="list-inset">This will allow us to access the Community Toolkit<a id="_idIndexMarker402"/> library in XAML using the <code>toolkit</code> prefix.</p></li> <li>Add an instance of <code>ListToStringConverter</code> to the page’s <code>Resources</code>:<pre class="source-code">
&lt;ContentPage.Resources&gt;
    ...
    &lt;toolkit:ListToStringConverter
      x:Key="listToStringConverter" Separator=", " /&gt;
&lt;/ContentPage.Resources&gt;</pre><p class="list-inset"><code>ListToStringConverter</code> has a property called <code>Separator</code> that we set to ",".</p></li> <li>Finally, we can update the label that should display the allergen information:<pre class="source-code">
&lt;Label IsVisible="{Binding HideAllergenInformation,
  Mode=OneWay, Converter={StaticResource
    inverseBoolConverter}}"
   <strong class="bold">Text="{Binding Allergens, Converter={StaticResource</strong>
<code>ListToStringConverter</code>, we can bind the <code>Allergens</code> property of the ViewModel to the <code>Text</code> property of the label. This converter will take the items from the <code>Allergens</code> array and concatenate them to show them as one string value.</p></li> </ol>
<p>This value converter and some other converters in the toolkit aren’t exactly rocket science. It’s something you could write yourself. However, in my opinion, why reinvent the wheel when someone has already done the hard work for you? Utilizing these ready-made tools can certainly<a id="_idIndexMarker403"/> make your coding life easier!</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Behaviors</h2>
<p>Behaviors allow you to add functionality to <a id="_idIndexMarker404"/>UI controls without the need to build custom controls from scratch. This greatly helps in constructing rich and intuitive user interfaces tailored to your specific requirements. By encapsulating UI-specific actions within the View layer, behaviors help reduce the complexity of ViewModels, adhering to the separation of concerns principle central to MVVM. The .NET MAUI Community Toolkit comes with a variety of ready-to-use behaviors, saving you time and effort in enhancing your UI.</p>
<p>One of the behaviors provided by the .NET MAUI Community Toolkit is <code>EventToCommand</code>, which allows you to map events to commands. This allows you to further enhance the decoupling of your UI and business logic. This behavior is particularly useful when dealing with events that do not directly support binding to commands.</p>
<p>As a very simple example, let’s imagine that we want to collect some user behavior throughout the app. One of the things we might be interested in is whether the user scrolls on a recipe page or not, as that might indicate some level of interest in that particular recipe. <code>ScrollView</code> has a <code>Scrolled</code> event, but no corresponding command. In such a use case, <code>EventToCommandBehavior</code> can be very helpful, as I will show you in the next steps:</p>
<ol>
<li>Create a <code>RelayCommand</code> on <code>RecipeDetailViewModel</code>, which needs to be invoked when the user scrolls on the page:<pre class="source-code">
[RelayCommand]
private void UserIsBrowsing()
{
    //Do Logging
}
RelayCommand</strong> attribute is used to generate <code>UserIsBrowsingCommand</code>, but you could <a id="_idIndexMarker405"/>write a <code>RelayCommand</code> yourself as well, of course.</pre></li> <li>Next, we can add <code>EventToCommandBehavior</code> to <code>ScrollView</code>:<pre class="source-code">
&lt;ScrollView&gt;
    &lt;ScrollView.Behaviors&gt;
        &lt;toolkit:EventToCommandBehavior
          Command="{Binding UserIsBrowsingCommand}"
            EventName="Scrolled" /&gt;
    &lt;/ScrollView.Behaviors&gt;
    ...
&lt;/ScrollView&gt;</pre><p class="list-inset">The <code>Command</code> property of <code>EventToCommandBehavior</code> is bound to the <code>UserIsBrowsingCommand</code> property that we just created on the ViewModel. By setting the <code>EventName</code> property to <code>"Scrolled"</code>, we define that we want this command to be invoked on the <code>Scrolled</code> event of <code>ScrollView</code>.</p></li> </ol>
<p>As a final example to demonstrate<a id="_idIndexMarker406"/> how helpful this toolkit can be by combining behaviors and converters, imagine the following: a heart icon should always be shown on the screen, but only when the user has marked the recipe as a favorite, and it should be red. We can write this without adding a single line of C# code and without working with multiple icons! Let’s see how this is done:</p>
<ol>
<li>Until now, in our <em class="italic">Recipes!</em> app, the favorite icon was a little misplaced. Let’s start by placing the favorite icon next to the recipe title. You can accomplish this by replacing the label that displays the recipe’s title with the following XAML code:<pre class="source-code">
&lt;Grid ColumnDefinitions="*, Auto"&gt;
    &lt;Label
        FontAttributes="Bold" FontSize="22"
        Text="{Binding Path=Title, Mode=OneTime}"
        VerticalOptions="Center" /&gt;
    &lt;Image
        x:Name="favoriteIcon"
        Grid.Column="1" Margin="5"
        HeightRequest="35" Source="favorite.png"
        VerticalOptions="Center" WidthRequest="35"&gt;
    &lt;/Image&gt;
&lt;/Grid&gt;</pre><p class="list-inset">Now, the favorite icon will permanently appear right next to the recipe’s title.</p></li> <li>The .NET MAUI Community Toolkit<a id="_idIndexMarker407"/> offers <code>IconTintColorBehavior</code>, which we can apply to change the color of <code>favoriteIcon</code>. We can add this behavior to our image:<pre class="source-code">
&lt;Image
    x:Name="favoriteIcon"
    ...&gt;
    &lt;Image.Behaviors&gt;
        &lt;toolkit:IconTintColorBehavior
            TintColor="#E9E9E9E9" /&gt;
    &lt;/Image.Behaviors&gt;
&lt;/Image&gt;</pre><p class="list-inset">After adding this behavior, the icon will take on the specified <code>TintColor</code>.</p></li> <li>Now, we need<a id="_idIndexMarker408"/> to set the <code>TintColor</code> value based on the <code>IsFavorite</code> property of <code>RecipeDetailViewModel</code>. Conveniently, the toolkit provides <code>BoolToObjectConverter</code>, which we can utilize to convert a <code>boolean</code> value into another value. We can add an instance of it to <code>RecipeDetailPage</code>:<pre class="source-code">
&lt;toolkit:BoolToObjectConverter
    x:Key="isFavoriteToColorConverter"
    x:TypeArguments="Color"
    FalseObject="#E9E9E9E9"
    TrueObject="#FF0000" /&gt;</pre></li> <li>By setting this instance’s <code>TypeArguments</code> to <code>"Color"</code>, we specify that we want to convert a <code>bool</code> value into a <code>Color</code> value. The <code>FalseObject</code> and <code>TrueObject</code> properties set the values that the converter should return for false and true, respectively.</li>
<li>The last step is to update <code>IconTintColorBehavior</code> on the image. The challenge is binding the <code>TintColor</code> property of the behavior to the <code>IsFavorite</code> property of <code>RecipeDetailViewModel</code>. Since behaviors do not inherit their <code>BindingContext</code> from the controls they’re defined on, we’ll use <code>ElementBinding</code> to access <code>RecipeDetailViewModel</code> through the <code>BindingContext</code> of the <code>favoriteIcon</code>:<pre class="source-code">
&lt;toolkit:IconTintColorBehavior <strong class="bold">TintColor="{Binding</strong>
<strong class="bold">  Source={x:Reference favoriteIcon},</strong>
<strong class="bold">    Path=BindingContext.IsFavorite,</strong>
<strong class="bold">      Converter={StaticResource</strong>
<code>TintColor</code> is effectively bound to the <code>IsFavorite</code> property on the ViewModel and <code>isFavoriteToColorConverter</code> determines the color to use.</p></li> </ol>
<p>The .NET MAUI Community Toolkit is an invaluable resource that streamlines the development process. It offers a wide variety of reusable building blocks, reducing the necessity for duplicative work and allowing you to focus on creating unique application features. With components such as behaviors, converters, and more, the toolkit empowers developers to build rich and interactive user experiences with less effort and complexity. Although the toolkit isn’t focused on MVVM, it helps in implementing the MVVM pattern by offering handy <a id="_idIndexMarker409"/>features such as behaviors, converters, and more.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Other popular frameworks</h1>
<p>As mentioned earlier, there are numerous MVVM frameworks available, each with its unique characteristics and advantages. Throughout this chapter, we’ve explored the MVVM Toolkit and .NET MAUI Community Toolkit. These toolkits, being community-driven and highly accessible, offer a variety of useful tools to simplify your MVVM code.</p>
<p>However, the landscape of MVVM frameworks is vast, so it might be worth seeing what other frameworks can provide. Here’s a list<a id="_idIndexMarker410"/> of some of the most<a id="_idIndexMarker411"/> popular<a id="_idIndexMarker412"/> third-party<a id="_idIndexMarker413"/> MVVM frameworks<a id="_idIndexMarker414"/> that are compatible with .NET MAUI:</p>
<ul>
<li>ReactiveUI: <a href="https://www.reactiveui.net/">https://www.reactiveui.net/</a></li>
<li>Prism Library: <a href="https://prismlibrary.com/">https://prismlibrary.com/</a></li>
<li>TinyMvvm: <a href="https://github.com/dhindrik/TinyMvvm">https://github.com/dhindrik/TinyMvvm</a></li>
<li>FreshMvvm: <a href="https://github.com/XAM-Consulting/FreshMvvm.Maui">https://github.com/XAM-Consulting/FreshMvvm.Maui</a></li>
</ul>
<p>Whether you are seeking a simple toolkit for the basics or a comprehensive framework with advanced capabilities, you will soon discover a framework that would best suit your specific needs and align with your coding style. However, it’s important to remember that using an MVVM framework is not a prerequisite for effective MVVM. It is entirely possible to implement the MVVM pattern effectively without a dedicated framework. Ultimately, the choice of whether to use a framework – and if so, which one – should depend on your project’s requirements, your team’s familiarity with the framework, and your personal coding preferences.<em class="italic"> Remember, tools are there to assist you, not dictate how </em><em class="italic">you code.</em></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Contributing to the community</h1>
<p>As we wrap up this chapter, it’s important<a id="_idIndexMarker415"/> to recognize that these third-party toolkits and frameworks are, at their core, community contributions. They’re the result of someone else’s hard work, thought, and passion. All this code is accessible to you on platforms such as GitHub, and it’s maintained by community-minded individuals who are always open to suggestions, improvements, and bug reports.</p>
<p>Remember, contributing to the community isn’t limited to creating a new project or toolkit of your own. It can be as simple as reporting a bug, suggesting a feature, or even making a small code improvement on an open source project. This open source ethos is one of the key strengths of the .NET ecosystem.</p>
<p>So, if you’re using these frameworks and see something that can be improved or a bug that needs fixing, don’t hesitate to contribute. By doing so, you’ll not only improve the tool for yourself but also for other developers who use it. This way, you can give back to the community and maybe learn a thing or two in the process.</p>
<p>In conclusion, never forget that these open source MVVM frameworks are not just tools for you to use, but they’re also opportunities<a id="_idIndexMarker416"/> for you to grow as a developer and contribute to the broader .NET community.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Summary</h1>
<p>To summarize, both the MVVM Toolkit and .NET MAUI Community Toolkit offer a comprehensive collection of components that facilitate the implementation of the MVVM pattern in your applications. By using these toolkits, you can avoid the need to build everything from scratch or reinvent existing solutions, ultimately saving time and effort, and allowing you to focus on building your application.</p>
<p>Throughout the rest of the code samples in this book, we’ll be using the MVVM Toolkit and make use of classes such as <code>ObservableObject</code> and <code>RelayCommand</code>. These classes are quite straightforward to understand. Even if you choose not to use this toolkit, you should still find the code samples clear and comprehensible as the underlying concepts are not overly complex.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Introduction to the MVVM Toolkit: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/</a></li>
<li>.NET MAUI Community Toolkit documentation: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/">https://learn.microsoft.com/dotnet/communitytoolkit/maui/</a></li>
<li>.NET MAUI Community Toolkit converters: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/">https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/</a></li>
<li>.NET MAUI Community Toolkit behaviors: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/">https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/</a></li>
<li><code>ObservablePropertyAttribute</code>: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty</a></li>
<li><code>RelayCommandAttribute</code>: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand</a></li>
</ul>
</div>
</div></body></html>