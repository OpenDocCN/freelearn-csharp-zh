- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Honest Functions, Null, and Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discuss the art and science of honest functions, the intricacies
    of null, and the C# tools tailored to address them. But before we dive deep, let’s
    lay out the roadmap:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding honest functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problems with hidden nulls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing honesty with nullable reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beyond null: Option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you navigate through this chapter, be on the lookout for practical advice
    and evidence-backed guidelines. Come with a curious mind, and by the end, you’ll
    possess the know-how to write more transparent and resilient C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did in our previous chapters, let’s assess where you stand. Here,
    there are three tasks for you. If you’re unsure about tackling them, dive into
    this chapter right away. But, if you feel confident in your skills, perhaps you
    might skim through and jump to the sections that challenge you the most. Ready?
    Let’s go!
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – Refactor for honest return types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s a function in Steve’s tower defense game that retrieves a tower based
    on its ID. Refactor it to return an honest type indicating potential nullability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Task 2 – Guard against null inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refactor the following function to guard against null inputs using preconditions
    and throw appropriate exceptions if the precondition isn’t met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Task 3 – Pattern matching with nullable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the following classes, write a method that receives an enemy and returns
    a string with its description using pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Again, if you are sure you know the right answers to all three tasks, you can
    skip this chapter. Of course, you can always come back if you have any questions.
    Now let’s discuss honest functions and their benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Honest functions – definition and understanding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few days after his conversation with Julia about pure functions and side effects,
    Steve was eager to learn more. He called Julia to ask what he should study next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Let’s talk about honest functions,* `null`*, and* `Option` *types,’
    she suggested. ‘These concepts are crucial for writing clear,* *predictable code.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Sounds great! But what exactly are* *honest functions?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *An honest function provides a clear, unambiguous contract between the
    function and its callers, resulting in code that’s more robust, less prone to
    bugs, and easier to* *reason about.*'
  prefs: []
  type: TYPE_NORMAL
- en: So what exactly is an honest function?
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest terms, an honest function is one where its type signature fully
    and accurately describes its behavior. If a function claims that it will take
    an integer and return another integer, then that’s precisely what it will do.
    There are no hidden gotchas, no exceptions thrown out of the blue, and no subtle
    changes to global or static state that aren’t reflected in the function’s signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C# function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this function seems to fulfill its promise. It takes two integers
    and returns their quotient. However, what happens when we pass zero as the denominator?
    `DivideByZeroException` is thrown. The function was not entirely honest with us;
    its signature did not warn us about this potential pitfall. An honest version
    of this function would explicitly signal the potential for failure in its signature.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this concept of honesty tie into the broader context of functional
    programming and the software development industry? In functional programming,
    functions are the building blocks of your code. The more clearly and honestly
    these functions describe their behavior, the easier it is to build larger, more
    complex programs. Each function serves as a reliable component that behaves just
    as its signature describes, allowing developers to confidently compose and reuse
    these functions.
  prefs: []
  type: TYPE_NORMAL
- en: As Julia explained honest functions, Steve’s eyes lit up with understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *So it’s like when I tell my teammates I’ll deliver a feature by Friday,
    I should actually* *do it?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Exactly! In programming, our functions should be just* *as reliable.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s dive deeper into the benefits of using honest functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved readability**: Honest functions make the code more straightforward
    to read and understand. There’s no need to dive into the implementation to grasp
    what the function is doing. The function’s signature is a contract that accurately
    describes its behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced predictability**: With honest functions, surprises are drastically
    minimized. The function’s behavior is precisely what is described in the signature,
    leading to fewer unexpected bugs and exceptions at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased reliability**: By minimizing surprises and explicitly handling
    potential error scenarios, honest functions result in a more robust code base
    that can withstand the rigors of real-world usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a code base where every function is honest. Any developer, familiar
    or not with the code, could look at a function signature and know immediately
    what it does, what it needs, and what it might return, including any potential
    error conditions. It’s like having a well-documented code base without the need
    for verbose documentation. That’s the power and promise of honest functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll explore how to implement honest functions in
    C# and how to deal with potential dishonesty, such as nulls or exceptions. Fasten
    your seatbelts, because our journey into the world of honest and dishonest functions
    is just beginning!
  prefs: []
  type: TYPE_NORMAL
- en: The problems with hidden nulls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steve recalled a recent bug in his tower defense game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *I think I’ve run into this problem. My game crashed when trying to
    upgrade a tower that* *didn’t exist.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *That’s a classic example, let’s look at how we can prevent that using
    what we’re* *learning today.*'
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever felt confused trying to figure out why your program stopped working?
    Most times, the problem comes from a well-known `NullReferenceException`. This
    section looks at the tricky connection between C# and null, pointing out the problems
    many developers face.
  prefs: []
  type: TYPE_NORMAL
- en: A quick look back – C# and null
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand our current problem, let’s look back a bit. Tony Hoare, an important
    computer expert, called the null reference a “huge mistake.” The idea was to provide
    developers with a tool to show when a value was missing. At first, it seemed like
    a good plan, but it ended up causing many problems and mistakes in languages –
    C# included.
  prefs: []
  type: TYPE_NORMAL
- en: When C# was introduced, it used this idea from older programming methods, letting
    developers use null to show something was missing. But over time, this simple
    choice caused a lot of errors and mix-ups.
  prefs: []
  type: TYPE_NORMAL
- en: Common mistakes and the troubling NullReferenceException
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All C# developers, whether new or experienced, have come across `NullReferenceException`.
    This error happens when you try to use something that isn’t there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about a program that gets user information. You might expect to always
    find a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Oops! If `FindUserById` can’t find a user, the second line will give `NullReferenceException`,
    which, if not caught, will terminate the whole execution of the thread. This mistake
    happens because we thought a user would always be there. This shows how hidden
    nulls can cause unexpected problems in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Many programs are much bigger than this example, which makes these kinds of
    mistakes hard to find and fix. These hidden problems can stay hidden for a long
    time, causing errors when you least expect them.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden nulls can be thought of as unseen traps. They can catch out both new
    and experienced programmers. Plus, they go against the main idea of functional
    programming, which values clear and expected outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Not all bad – the value of null
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s easy to blame null for these problems. But the real issue is how it’s used.
    Null can be helpful if used in a clear way to show something is missing. The problem
    comes when its use is unclear, leading to many potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: The journey of C# with null has had its ups and downs. But, as we’ll learn in
    the next sections, C# now has multiple ways to handle null, making our code clearer
    and more straightforward. And one of these ways is to use nullable reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing honesty with nullable reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling null in C# has always been quite a challenge. Many software developers
    (me included) advocate doing a check for `NullReferenceException`s as a mandatory
    task in a code review checklist. In most cases, it is really easy to check for
    possible null values just by looking at the pull request, even without an IDE.
    Recently, we received help when Microsoft introduced nullable reference types.
    So, now, the compiler will join us in the search of possible disasters caused
    by null.
  prefs: []
  type: TYPE_NORMAL
- en: What are nullable reference types?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the simplest terms, **Nullable Reference Types** (or **NRTs** for short)
    are a feature in C# that allows developers to clearly indicate whether a reference
    type can be null or not. With this, C# gives us a tool to make our intentions
    clear right from the start. Think of it as a signpost, guiding other developers
    (and even our future selves) about what to expect from our code.
  prefs: []
  type: TYPE_NORMAL
- en: Without NRTs, every reference type in C# could potentially be `null`. This would
    create a guessing game. Is this variable going to have a value or is it going
    to be `null`? Now, with NRTs, we don’t have to guess anymore. The code itself
    tells the story.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a basic example to grasp the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `notNullable` variable is a regular string that
    can’t be assigned `null` (if you try, the compiler will warn you). On the other
    hand, since C# 8.0, nullable is explicitly marked with `?`, indicating that it
    can be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you might want to assign `null` to a variable that is not marked
    as nullable. In this case, to suppress warnings, you can use the `!` sign to let
    the compiler know that you are aware of what you are doing and everything is going
    according to plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: One of the biggest advantages of NRTs is that the C# compiler will warn you
    if you’re potentially doing something risky with null values. It’s like having
    a friendly guide always looking over your shoulder, ensuring you don’t fall into
    the common traps of null misuse.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you try to access properties or methods on a nullable reference
    without checking for `null`, the compiler will give you a heads-up.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to NRTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For those with existing C# projects, you might be wondering: *Will my project
    be littered with warnings if I enable NRTs?* The answer is no. By default, NRTs
    are turned off. You can opt into this feature, file by file, allowing for a smooth
    transition.'
  prefs: []
  type: TYPE_NORMAL
- en: NRTs are a good answer to the long-standing challenge posed by null references.
    By making the potential presence of null explicit in our code, we take a giant
    leap toward clarity, safety, and functional honesty. In the end, embracing NRTs
    not only makes our code more resilient but also ensures that our intentions, as
    developers, are transparent.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling nullable reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable NRTs, we need to tell the C# compiler that we’re ready for its guidance.
    This is done using a simple directive: `#``nullable enable`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this at the start of your `.``cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: From this point onward in the file, the compiler creates a specific nullable
    context and assumes that all reference types are non-nullable by default. If you
    want a type to be nullable, you’ll have to mark it explicitly with `?`.
  prefs: []
  type: TYPE_NORMAL
- en: With NRTs enabled, the C# compiler becomes your safety net, pointing out potential
    issues with nulls in your code. Whenever you try to assign null to a reference
    type without the `?` marker or when you attempt to access a potentially null variable
    without checking it, the compiler will warn you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Disabling nullable reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While transitioning a project to use NRTs, there may be sections of your code
    where you’d prefer to delay the transition. You can turn off NRTs for those specific
    sections using the `#nullable` `disable` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This tells the compiler to revert to the old behavior, treating all reference
    types as potentially nullable.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why C# chose to use directives for this feature. The reason
    is flexibility. By using directives, developers can gradually introduce NRTs into
    their projects, one file or even one section of code at a time. This phased approach
    makes it easier to adapt existing projects.
  prefs: []
  type: TYPE_NORMAL
- en: Warnings and annotations options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Speaking of a phased approach, there are two more options to set our nullable
    contexts: `warnings` and `annotations`. You can use them by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The main purpose of these options is to ease the migration of your existing
    code from a fully disabled null context to a fully enabled one. In short, we want
    to start with the `warnings` option in order to get dereference warnings. When
    all warnings are fixed, we can switch to `annotations`. This option will not give
    us any warnings, but it will start to treat our variables as non-nullable unless
    declared with the `?` mark.
  prefs: []
  type: TYPE_NORMAL
- en: To get more information about these options and nullable context in generated
    files, and to find out more about three nullabilities – oblivious, nullable, and
    non-nullable, I recommend you read the article *Nullable reference types* ([https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references)).
    You might also want to read the article “Update a codebase with nullable reference
    types to improve null diagnostic warnings” ([https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies)).
  prefs: []
  type: TYPE_NORMAL
- en: The bigger picture – project-wide settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While directives are great for granular control, you can also enable NRTs for
    an entire project. In the project settings, or directly in the `.csproj` file,
    set the `<Nullable>` element to enable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This setting treats every file in the project as if it started with the `#nullable
    enable` directive. When you turn on a nullable context for the whole project,
    you might want to keep some parts of the code from generating warnings, but use
    the project-wide nullable context after it. In that case, you can use the `restore`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Enabling nullable reference types is like turning on a light in a previously
    dim room. It reveals potential pitfalls and ensures that we write safer, clearer
    code. With the tools C# provides, we have both granular and broad control over
    this feature, making the transition to a more transparent coding style both manageable
    and rewarding.
  prefs: []
  type: TYPE_NORMAL
- en: Returning with intention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of functional programming, a function’s primary aim is to be transparent.
    By transparent, we mean that the function should not just do what its name implies,
    but also, its return type should offer a clear contract of what to expect. Let’s
    dive deep into crafting honest return types in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'A seasoned developer knows that a function’s name or signature alone might
    not depict the entire story. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On the surface, this function seems to promise that it’ll fetch a user profile
    given a user ID. However, questions linger. What if the user doesn’t exist? What
    if there’s an error retrieving the profile?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider an alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By simply introducing `?` to the return type, the function becomes more transparent
    about its intention. It suggests: *I’ll try to fetch a user profile for this ID.
    But there’s a possibility you might get* *a null*.'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between UserProfile and UserProfile?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the distinction might seem minute, the implications are vast:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserProfile?`, you immediately know there’s a possibility of not getting a
    user profile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defensive coding**: Knowing the return can be null, you’ll naturally write
    safer code to handle such cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: Instead of exceptions or error codes to signify missing
    data, a nullable return type provides a clear, type-safe way to express the possibility
    of absence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see this in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with the help of NRTs, we can understand code more clearly and
    process its results correctly. And all we did to achieve it was just tweaking
    the method’s signature a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Honoring a function’s contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An honest function goes beyond just indicating potential null returns. It creates
    a mindset of “return with intention.” When returning with intention, you’re not
    merely returning data; you’re communicating a state.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: '`null` checks and avoids potential `NullReferenceException`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Fetching data**: When retrieving data that might not exist, instead of exceptions,
    a nullable type paints a clearer picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Transparent return types result in fewer surprises and more robust code. By
    clearly communicating what a function can return, you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduce errors**: Because developers will handle scenarios they might have
    overlooked otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Promote clarity**: Developers spend less time digging into function implementations,
    relying on return types to guide behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Foster trust**: A clear contract ensures that the function lives up to its
    promise, creating a sense of reliability in the code base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we continue to explore honest functions, always remember: your functions
    are both performers and communicators. Let them not just do their task, but also
    communicate their intent and potential outcomes transparently. In doing so, you
    build resilient systems, create clear contracts, and encourage a safer, more predictable
    coding environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Demanding honesty from function inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A truly robust system is not just about what you return; it’s also about what
    you accept. Guarding your functions against potentially misleading or harmful
    inputs is paramount in creating predictable, error-resistant applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this common scenario: You have a function that expects a certain type
    of input. However, when a `null` value sneaks its way in, your function breaks
    down, leading to the infamous `NullReferenceException`. To mitigate this, C# provides
    a way to demand honesty from function inputs using nullable reference types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you define a function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The intention is clear: the function expects `UserProfile`. However, what’s
    stopping a developer from passing in `null`?'
  prefs: []
  type: TYPE_NORMAL
- en: Nullable reference types to the rescue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed earlier, with C# 8.0, nullable reference types add another
    layer of protection. By turning on nullable reference types using `#nullable enable`,
    the compiler becomes your guardian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, if any developer tries to pass a nullable `UserProfile` to the function,
    the compiler will raise a warning. This nudges developers in the right direction
    and prevents potential runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, warnings do not guarantee that `null` will not be used, so let’s look
    at another approach. Here, we defend the method with the simplest guard in a straightforward
    null check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This check ensures that if the function is ever provided `null`, it’ll immediately
    halt execution and provide a clear reason.
  prefs: []
  type: TYPE_NORMAL
- en: Using preconditions and contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contracts and preconditions take the idea of guarding to a new level. By defining
    a set of rules that must hold true before a function can proceed, you’re making
    the function’s expectations explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the CodeContracts ([https://github.com/Microsoft/CodeContracts](https://github.com/Microsoft/CodeContracts))
    library provided by Microsoft. With this, you can ensure your function’s preconditions
    with a more expressive syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This code is much more concise, however, it guards our method from `null` values
    in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C# 6.0, we received a new way to guard against null values – `ArgumentNullException.ThrowIfNull`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this code looks even cleaner and easier to read. Also, a more enhanced
    method for strings appeared in C# 7.0: `ArgumentException.ThrowIfNullOrEmpty`.
    It not only checks for null but also ensures that the string is not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The power of explicit non-null inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By demanding non-null arguments, you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improve predictability**: Functions behave as expected since rogue nulls
    don’t derail them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boost developer confidence**: With clear contracts, developers can invoke
    functions without second-guessing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduce debugging time**: Catching potential issues at compile time is always
    faster than runtime debugging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to write good functional code, ensuring clarity in what you accept
    is just as crucial as being transparent in what you return. By demanding honesty
    from function inputs, you’re laying a solid foundation for code that’s both reliable
    and resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching and nullable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is a powerful tool in the C# arsenal, serving as a mechanism
    to make the code not only more expressive but also clearer and safer. When combined
    with nullable types, pattern matching helps us guard our code against potential
    pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching, introduced in C# 7.0 and enhanced in subsequent versions,
    is a feature that allows you to test a value against a pattern, providing a way
    to extract information from the value when it conforms to the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the classic `switch` statement, evolved with pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ArcherTower` and `CannonTower` are types. If `tower` is of type `ArcherTower`,
    it not only enters the respective case block but also casts it to the `ArcherTower`
    type, allowing you to access its properties directly.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with nullable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pattern matching truly shines when dealing with nullable types. Let’s consider
    a situation where we fetch a user profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How do we handle this potential null in a type-safe, clear manner? Enter pattern
    matching.
  prefs: []
  type: TYPE_NORMAL
- en: Using the “is” pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ideally, our code should be easy to read, and what could be easier than using
    plain English? The “is” pattern is designed to assist with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This immediately makes the code more readable, drawing a clear distinction between
    the scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Switch expressions with property patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Introduced in C# 8.0, the `switch` expression paired with property patterns
    provides an even more concise way to handle complex conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, not only do we check for null, but we also examine specific properties
    of the `Book` object, making decisions based on their values.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring clarity with nullable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The amalgamation of pattern matching and nullable types ensures the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safety**: By handling potential nulls explicitly, you reduce the risk of
    runtime errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expressiveness**: Patterns allow you to condense complex conditional logic
    into concise, readable constructs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readability**: Clear distinctions between different conditions and outcomes
    enable developers to understand the flow effortlessly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching, when combined with nullable types, is a formidable tool for
    any C# developer. It not only streamlines code but also strengthens it, allowing
    you to write applications that are more resilient to unexpected scenarios. Use
    it and your code will be both a joy to write and a model of reliability.
  prefs: []
  type: TYPE_NORMAL
- en: The null object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The null object pattern is a design pattern that provides an object as a surrogate
    for the lack of an object of a given interface. Essentially, it provides default
    behavior in the absence of meaningful data or behavior. This pattern is particularly
    useful in scenarios where you’d expect an object but don’t have one, and don’t
    want to constantly check for `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with null checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you’re developing a system where you have a series of operations to
    perform on a `User` object. Now, not every user might be initialized in the system,
    which often leads to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This might seem innocent for a single check. But when your code base is littered
    with such null checks, the code becomes verbose and less readable. The proliferation
    of null checks can also obscure the primary business logic, making the code base
    harder to maintain and understand.
  prefs: []
  type: TYPE_NORMAL
- en: The null object solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The null object pattern provides an elegant solution to this problem. Instead
    of using a null reference to convey the absence of an object, you create an object
    that implements the expected interface but does nothing – a “null object.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In situations where a user isn’t available, instead of returning `null`, you’d
    return an instance of `NullUser`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you want to perform an operation, you can confidently do so without
    checking for `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of whether `user` is `RealUser` or `NullUser`, the code won’t throw
    `Null``ReferenceException`.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing the null object pattern offers several key advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduction of conditional statements**: You can decrease the number of explicit
    null checks, leading to cleaner and more readable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safety**: The risk of null reference exceptions gets drastically reduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism**: By treating the null object the same as other objects, you
    can leverage the power of polymorphism, which can simplify and clarify the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clarity in intent**: Null objects can have meaningful names, making it clear
    when a “do-nothing” or default behavior is intentional'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations and considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the null object pattern has its benefits, it’s not always the best solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overhead**: For very large systems or deeply nested structures, introducing
    null objects everywhere can add overhead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**: If the interface or base class changes frequently, maintaining
    a corresponding null object can become tedious'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obscured errors**: If you’re not careful, using null objects can potentially
    mask problems in the system, since they provide default behavior that might hide
    issues that would have otherwise been exposed by a null reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The null object pattern is a powerful tool in the arsenal of a C# developer.
    It’s not a one-size-fits-all solution, but when applied judiciously, it can greatly
    improve code clarity and robustness. Like all design patterns, understanding when
    and where to apply it is crucial. So don’t hurry to use it everywhere, and let’s
    look at a more functional approach – the `Option` type.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond null – using Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Nullable<T>`, which is embedded in C#, is a great tool to work with `null`
    values, but there is a better and more straightforward construct for the handling
    of null values. `Option` is a type that provides more expressive tools for conveying
    the presence or absence of a value, serving as a richer alternative to nullable
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to Option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At its core, the `Option` type can be thought of as a container that may or
    may not contain a value. Typically, it’s represented as either `Some` (which wraps
    a value) or `None` (indicating the absence of a value).
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the implementation of `Option` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While C# doesn’t have a built-in `Option` type, you can use the one above or
    use a library such as LanguageExt ([https://github.com/louthy/language-ext](https://github.com/louthy/language-ext)),
    which provides this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at how we can leverage the `Option` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to use `Option` is to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code is more straightforward, however, the code before it is more concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when calling this function, we can handle the result in a more expressive
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This approach makes the handling of potential missing values explicit and clear.
  prefs: []
  type: TYPE_NORMAL
- en: As Steve delved into `Option` types, he thought “This reminds me of how we handle
    power-ups in our games, sometimes they’re there, sometimes they’re not.”
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the Option type over nullable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to handling values that might be absent, opting for the `Option`
    type presents distinct advantages in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Some` and `None` constructs makes the code’s intention unmistakable. There’s
    a clear distinction between having a value and lacking one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Option` type forces you to handle both `Some` and `None` scenarios, reducing
    potential oversights in your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Option` types often work together with other functional methods, enabling
    powerful and concise transformations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interplay of Option and nullable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s worth noting that while the `Option` type provides a robust mechanism
    for managing optional values, it doesn’t entirely replace nullable types. Instead,
    consider them as tools in your toolbox, each with its strengths:'
  prefs: []
  type: TYPE_NORMAL
- en: Use nullable reference types when working with native C# constructs or when
    interfacing with libraries/frameworks expecting them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopt the `Option` type in scenarios requiring richer functional operations
    or when building libraries with a functional flavor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Option` type brings a taste of pure functional programming to the C# world,
    offering a sophisticated toolset for handling optional values. By integrating
    these constructs into your applications, you elevate the clarity, robustness,
    and expressiveness of your code. While the learning curve might be steeper than
    with nullable types, the rewards in terms of code quality and resilience are well
    worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Practical scenarios – handling nulls effectively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you must have already seen, dealing with nulls isn’t just a theoretical concern;
    it’s a daily challenge. By examining real-world scenarios, we can better appreciate
    the need for clear strategies in managing nulls and ensuring robust, reliable
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – managing YouTube videos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scenario**: A system retrieves video details from a database. Not every video
    ID queried will have a corresponding video entry.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traditional approach**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Option approach**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: By returning `Video?`, we’re signaling the potential absence of a video explicitly.
    Calling functions can then use pattern matching or direct null checks to handle
    the absence gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – managing different video types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scenario**: As YouTube started supporting various video formats and sources
    (e.g., live streams, 360-degree videos, standard uploads), the backend systems
    had to correctly identify and process each video type. With the platform’s increasing
    complexity and new video formats being introduced, using traditional if-else statements
    to handle these became cumbersome and less maintainable. Pattern matching emerged
    as an efficient solution to this challenge.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traditional approach**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Pattern** **matching approach**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching provided a more elegant, concise, and readable approach to
    handling different video types. As YouTube introduces new video formats or features,
    they can be seamlessly integrated into the `GetVideoDetails` function. This modern
    approach reduces potential errors, simplifies the code, and enhances maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – working with non-existing objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scenario**: As YouTube expanded globally, it was increasingly common to encounter
    incomplete or missing data due to various reasons, such as network hiccups, data
    migration issues, or regional content restrictions. Using traditional null checks
    became increasingly cumbersome, leading to scattered logic throughout the code
    base. The null object pattern offered a systematic approach to provide a default
    object instead of a null reference.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traditional approach**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And when displaying the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Null object** **pattern approach**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a default object for videos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then modify the fetching method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then display the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: By adopting the null object pattern, YouTube’s Video Management System managed
    to encapsulate the behavior associated with null or missing data within the default
    “null object,” leading to more unified and predictable system behavior. It removed
    numerous null checks scattered throughout the code base, reducing the chances
    of null reference exceptions, and enhancing the system’s robustness and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: The impact of handling nulls in real-world scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In real-life situations, how we deal with null values in our code can have
    a big impact. Let’s explore how handling nulls can make a difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NullReferenceException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clearer intention**: Using tools such as nullable reference types and pattern
    matching, our code more transparently communicates potential outcomes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developer confidence**: When the system’s behavior is predictable, developers
    can integrate and extend it with greater confidence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In real-world scenarios, the unknowns and uncertainties are plentiful. By incorporating
    clear and transparent handling of potential nulls, we ensure that our applications
    are both resilient and maintainable. Whether you’re managing video data, processing
    forms, or integrating with third-party services, a deliberate approach to null
    management can make all the difference.
  prefs: []
  type: TYPE_NORMAL
- en: The reality of honesty in C# – why there will never be truly honest functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is a multi-paradigm language, offering a lot of features, each designed with
    various considerations in mind. As we venture into the topic of “honest functions,”
    we must also acknowledge that C#’s design, while powerful, has some trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: The compromises of the C# language design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C#’s design involves certain trade-offs. Let’s examine them and understand
    their impact:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Historical baggage**: C# has evolved over the years, adding new features
    while ensuring backward compatibility. This means that older, less “honest” ways
    of doing things will always remain a part of the language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance versus safety**: Offering both low-level performance-oriented
    features and high-level safety features is not easy. Sometimes, the requirements
    of performance might lead developers away from purely “honest” constructs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broad audience**: C# is designed for a vast range of developers, from those
    writing system-level code to high-level enterprise applications. As a result,
    the language can’t be too opinionated in favor of any single paradigm, including
    functional programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OutOfMemoryException`, for example. Although, we might think that if we are
    the creators of our code it will do as we wish, don’t forget that the **Common
    Language Runtime** (**CLR**) is the true master here and it can interfere with
    our intentions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# offers a rich variety of features, enabling developers to craft solutions
    across different paradigms. In our pursuit of honesty and clarity, we should recognize
    and respect the trade-offs intrinsic to the language’s design. Additionally, we
    need to remember that our code does not run in an ideal world and that the environment
    also impacts the way our programs work.
  prefs: []
  type: TYPE_NORMAL
- en: Practical tips and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we navigate the nuances of functional programming in C# and its approach
    to handling nulls, some practical strategies emerge. These strategies ensure that
    our applications remain robust while benefiting from the enhanced clarity and
    predictability that functional paradigms provide.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies for migrating existing code bases to adopt nullable reference types
    and Option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider strategies for migrating your existing code bases to adopt nullable
    reference types and `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#nullable` `enable` directive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Use of analysis tools**: Tools such as Roslyn analyzers ([https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview](https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview))
    can help identify potential nullability issues in code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Option` type, ensure you understand the implications of the calling code.
    Functions may return different types, requiring adjustments to the calling logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common pitfalls and how to navigate them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at common pitfalls and discover how to effectively
    navigate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assuming non-null values prematurely**: Even with nullable reference types
    enabled, always validate inputs, especially if they come from external sources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Option` type is powerful, it might not be suitable for every scenario. For
    simple cases where nullability is self-explanatory, nullable reference types might
    be more appropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forgetting legacy code**: Older parts of the code base may not adhere to
    new paradigms. When integrating new and old code, be cautious of potential mismatches
    in expectations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing strategies for null and Option handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s talk about how to test your code when it deals with null and `Option`
    in a functional programming way. It’s important to test that your code works correctly,
    and now we’ll explore how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing with null values**: Ensure unit tests cover scenarios where
    null values are passed to functions. This helps catch potential null-related issues
    before they reach production:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Option` types, tests should cover both `Some` and `None` scenarios to ensure
    all code paths are verified:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Integration testing**: Beyond unit tests, integration tests should be employed
    to validate interactions between different components, especially when dealing
    with databases, APIs, or other external systems that might return unexpected null
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about functional programming in C# might not be an easy thing, but
    you have already started this venture and continued it right up to the current
    lines. You are doing great, so keep it up, and let’s reinforce the knowledge you’ve
    acquired with our traditional three exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that Steve has learned about honest functions, null, and Option types, Julia
    has prepared some challenges to help him apply these concepts to his tower defense
    game. Let’s see if you can help Steve solve them!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steve’s game needs to fetch tower information reliably. Refactor this function
    to use an honest return type that clearly indicates when a tower might not be
    found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the game players can apply power-ups to towers. Refactor this function to
    ensure it handles null inputs gracefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steve wants to provide players with detailed information about the enemies
    they’re facing. Using the enemy classes from his game, implement a function that
    generates descriptive strings for each enemy type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Incorporate the `Option` return type to signify that a user may or may not
    be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Utilize a built-in check for null inputs that will throw an exception if the
    user profile is `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Employ pattern matching to address potential null values elegantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: These exercises and their solutions provide an applied understanding of the
    concepts covered, guiding you toward a functional and robust approach to handling
    nulls and honest functions in C#. Keep experimenting, keep iterating, and always
    lean into the principles of functional programming to craft clearer, more resilient
    C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our journey through honest functions and the intricacies of null handling
    in C# draws to a close, let’s reflect on our discoveries and look to the future.
  prefs: []
  type: TYPE_NORMAL
- en: We have traversed the history and implications of `null` in C#. We’ve understood
    its nuances, its dangers, and its power. By now, the infamous `NullReferenceException`
    should be less of a nemesis and more of an old acquaintance you nod at from across
    the room, acknowledging its presence but never letting it disrupt your day.
  prefs: []
  type: TYPE_NORMAL
- en: Honest functions – or functions that explicitly state their intentions, inputs,
    and outputs – represent a paradigm shift toward predictability, clarity, and resilience.
    Embracing honesty in functions is not merely about avoiding pitfalls but about
    embracing a philosophy of transparency. In doing so, we create code that other
    developers can trust, understand, and build upon.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve dived deep into the realms of nullable reference types and pattern matching
    and even touched upon the null object pattern and the `Option` type, all of which
    present us with powerful tools to express our intentions with precision and grace.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, as with all tools, it’s essential to remember that their strength lies
    in their appropriate application. The world of C# is vast, and while functional
    programming principles offer much value, they are but one aspect of a rich tapestry.
    It’s up to you, the developer, to discern when to employ these concepts and when
    to lean into other paradigms. As we add a functional paradigm to our habitual
    way of coding, it may cause different errors and we’d better be ready to work
    with them. That’s why I invite you to read the next chapter, about error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Advanced Functional Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on the foundations established in Part I, we now delve into more advanced
    functional programming techniques. We’ll start by exploring functional approaches
    to error handling, moving beyond traditional try-catch blocks to more elegant
    solutions. Next, we’ll cover higher-order functions and delegates, unlocking the
    power of functions as first-class citizens. The section concludes with an in-depth
    look at functors and monads, advanced concepts that provide powerful tools for
    managing complexity in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21069_05.xhtml#_idTextAnchor221)*, Error Handling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21069_06.xhtml#_idTextAnchor270)*, Higher-Order Functions and
    Delegates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21069_07.xhtml#_idTextAnchor332)*, Functors and Monads*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
