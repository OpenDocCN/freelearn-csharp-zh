<html><head></head><body>
<div id="_idContainer053">
<h1 class="chapter-number" id="_idParaDest-53"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.2.1">The .NET Observability Ecosystem</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we explored .NET observability features included into the platform and frameworks, but there are more instrumentations covering other libraries </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and environments.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’ll learn how to find and evaluate instrumentations and then take a closer look at instrumentations for a few specific libraries: StackExchange.Redis, Azure, and AWS SDKs. </span><span class="koboSpan" id="kobo.5.2">We’ll also explore tracing and metrics coming from infrastructure using </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Dapr </span></strong><span class="koboSpan" id="kobo.7.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">distributed application runtime</span></strong><span class="koboSpan" id="kobo.9.1">) as an example. </span><span class="koboSpan" id="kobo.9.2">Finally, we’ll see how to configure tracing in serverless environments where we have less control, but observability is even </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">more important.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Through this chapter, </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">you’ll learn:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">How to find, evaluate, and enable </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">OpenTelemetry instrumentations</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">What Dapr and service meshes are capable of when it comes </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">to observability</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">How to enable tracing in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">serverless environments</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">By the end of this chapter, you’ll get hands-on experience with different kinds of instrumentations and you will be able to configure and use distributed tracing for a wide range of backend applications. </span><span class="koboSpan" id="kobo.19.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">get started!</span></span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">In this chapter, we’re going to evolve our meme application and use a cloud object store, Amazon S3 or Azure Blob Storage, along with a local Redis cache. </span><span class="koboSpan" id="kobo.22.2">The code for this chapter is available in the book’s GitHub repository at </span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter3"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter3</span></a><span class="koboSpan" id="kobo.24.1">, which has the following </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">folder structure:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">libraries</span></strong><span class="koboSpan" id="kobo.27.1">: Contains library instrumentation sample app for the first section of </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">this chapter</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">dapr</span></strong><span class="koboSpan" id="kobo.30.1">: Contains Dapr instrumentation sample for the </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">second section</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">serverless</span></strong><span class="koboSpan" id="kobo.33.1">: Contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">aws</span></strong><span class="koboSpan" id="kobo.35.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">azure</span></strong><span class="koboSpan" id="kobo.37.1"> folders with examples of AWS Lambda and Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Functions instrumentations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.39.1">To run these applications, you would need the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">following tools:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.41.1">.NET SDK 7.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">or later</span></span></li>
<li><span class="koboSpan" id="kobo.43.1">Visual Studio or VS Code, but any text editor </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">would work</span></span></li>
<li><span class="koboSpan" id="kobo.45.1">Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">docker-compose</span></strong></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.48.1">Dapr CLI</span></span></li>
<li><span class="koboSpan" id="kobo.49.1">An Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">subscription (optional):</span></span><ul><li><span class="koboSpan" id="kobo.51.1">We’re going to use Blob Storage and </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">Application Insights.</span></span></li><li><span class="koboSpan" id="kobo.53.1">With Blob Storage, we’re going to stay well within free-tier limits. </span><span class="koboSpan" id="kobo.53.2">Application Insights does not have a free tier, but you can still try it out with Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">promotional credits.</span></span></li><li><span class="koboSpan" id="kobo.55.1">We’ll use Azure Function Tools v4 and (optionally) </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">Azure CLI.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.57.1">An AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">subscription (optional):</span></span><ul><li><span class="koboSpan" id="kobo.59.1">We’re going to use S3, Lambda, and X-Ray. </span><span class="koboSpan" id="kobo.59.2">We’ll stay well within free-tier limits for each </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">of them.</span></span></li><li><span class="koboSpan" id="kobo.61.1">We’ll need AWS toolkit for VS or Lambda .NET CLI and (optionally) </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">AWS CLI.</span></span></li></ul></li>
</ul>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.63.1">Configuring cloud storage</span></h2>
<p><span class="koboSpan" id="kobo.64.1">If you don’t want to create an Azure</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.65.1"> or AWS subscription, you can still run </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">libraries</span></strong><span class="koboSpan" id="kobo.67.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">dapr</span></strong><span class="koboSpan" id="kobo.69.1"> samples locally by setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">CloudStorage.Type</span></strong><span class="koboSpan" id="kobo.71.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">Local</span></strong><span class="koboSpan" id="kobo.73.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">storage/appsettings.json</span></strong><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">There is no local setup for </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">serverless demos.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Otherwise, set </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">CloudStorage.Type</span></strong><span class="koboSpan" id="kobo.79.1"> to the storage of your choice, </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">AwsS3</span></strong><span class="koboSpan" id="kobo.81.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">AzureBlob</span></strong><span class="koboSpan" id="kobo.83.1">, and let’s see how to </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">configure them.</span></span></p>
<h3><span class="koboSpan" id="kobo.85.1">AWS S3</span></h3>
<p><span class="koboSpan" id="kobo.86.1">Create a new bucket</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.87.1"> using AWS console</span><a id="_idIndexMarker151"/> <span class="No-Break"><span class="koboSpan" id="kobo.88.1">or CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.89.1">
$ aws s3api create-bucket –bucket &lt;name&gt; --region &lt;region&gt;</span></pre>
<p><span class="koboSpan" id="kobo.90.1">Then, add bucket info </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">libraries/storage/appsettings.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">We’ll also need credentials to access blob storage and we’re going to use the credentials file where we can. </span><span class="koboSpan" id="kobo.94.2">You can generate one using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">aws configure</span></strong><span class="koboSpan" id="kobo.96.1"> command. </span><span class="koboSpan" id="kobo.96.2">Applications would search for AWS credentials file </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">${HOME}/.aws/credentials</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">HOME</span></strong><span class="koboSpan" id="kobo.102.1"> environment variable in </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.104.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">libraries/</span></strong><span class="koboSpan" id="kobo.106.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">serverless/aws</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.108.1"> folders.</span></span></p>
<h3><span class="koboSpan" id="kobo.109.1">Azure Blob Storage</span></h3>
<p><span class="koboSpan" id="kobo.110.1">Create a new storage</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.111.1"> account. </span><span class="koboSpan" id="kobo.111.2">You can use Azure portal</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.112.1"> or Azure CLI and then obtain a </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">connection string:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.114.1">
$ az storage account create –-resource-group &lt;group&gt; --name
&lt;account&gt;
$ az storage account show-connection-string -–resource-
group &lt;group&gt; --name &lt;account&gt;</span></pre>
<p><span class="koboSpan" id="kobo.115.1">Add the connection string to </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">.env</span></strong><span class="koboSpan" id="kobo.117.1"> file next to </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">libraries/docker-compose.yml</span></strong><span class="koboSpan" id="kobo.119.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">following format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
AZURE_BLOB_CONNECTION_STRING="DefaultEndpointsProtocol=
  https;...."</span></pre>
<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.122.1">Using instrumentations for popular libraries</span></h1>
<p><span class="koboSpan" id="kobo.123.1">In the previous chapter, we saw how to enable</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.124.1"> tracing for the .NET</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.125.1"> platform, ASP.NET Core, and Entity Framework to cover the basics, but anyone can create instrumentation for a popular library and share it with the community. </span><span class="koboSpan" id="kobo.125.2">Also, with tracing and metrics primitives being part of .NET and OpenTelemetry to collect data in a vendor-agnostic way, libraries</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.126.1"> can add </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">native</span></span><span class="No-Break"><a id="_idIndexMarker157"/></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1"> instrumentation.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">There are multiple terms that describe different kinds </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">of instrumentations:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.131.1">Auto-instrumentation</span></strong> <em class="italic"><span class="koboSpan" id="kobo.132.1">sometimes</span></em><span class="koboSpan" id="kobo.133.1"> implies that instrumentation</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.134.1"> can be enabled without </span><em class="italic"><span class="koboSpan" id="kobo.135.1">any</span></em><span class="koboSpan" id="kobo.136.1"> modification of application code, but is sometimes used to describe any shared instrumentation that is easy </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">to enable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.138.1">Instrumentation library</span></strong><span class="koboSpan" id="kobo.139.1"> means that you can enable instrumentation</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.140.1"> by installing the corresponding NuGet package and configuring it with a few lines of code at </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">startup time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.142.1">Native instrumentation</span></strong><span class="koboSpan" id="kobo.143.1"> implies that instrumentation code</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.144.1"> is a part of the library, so no additional NuGet package is necessary, but you may still need to </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">enable instrumentation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.146.1">Manual instrumentation</span></strong><span class="koboSpan" id="kobo.147.1"> is the one that you write yourself</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.148.1"> as a part of your </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">application code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.150.1">The boundaries between automatic, native, and instrumentation libraries are blurry. </span><span class="koboSpan" id="kobo.150.2">For example, the HTTP client contains native instrumentation starting with .NET 7.0, but you might still enable it in a more convenient way with the corresponding instrumentations. </span><span class="koboSpan" id="kobo.150.3">Or, with some bytecode rewrite that configures OpenTelemetry, we can enable library instrumentations without changing any of the application code. </span><span class="koboSpan" id="kobo.150.4">In this book, we use a relaxed version of the auto-instrumentation term (for the lack of a better one) to describe all non-manual instrumentations, but we mention a specific kind when </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">it’s relevant.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">There are several sources</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.153.1"> where we can find </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">available instrumentations:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.155.1">OpenTelemetry registry</span></strong><span class="koboSpan" id="kobo.156.1"> (</span><a href="https://opentelemetry.io/registry):"><span class="koboSpan" id="kobo.157.1">https://opentelemetry.io/registry):</span></a><span class="koboSpan" id="kobo.158.1"> You can filter the instrumentations</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.159.1"> by language</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.160.1"> and component. </span><span class="koboSpan" id="kobo.160.2">Many instrumentations are not added to the registry though. </span><span class="koboSpan" id="kobo.160.3">It lists all kinds of instrumentation regardless of </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">their kind.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.162.1">OpenTelemetry .NET repo</span></strong><span class="koboSpan" id="kobo.163.1"> (</span><a href="https://github.com/open-telemetry/opentelemetry-dotnet):"><span class="koboSpan" id="kobo.164.1">https://github.com/open-telemetry/opentelemetry-dotnet):</span></a><span class="koboSpan" id="kobo.165.1"> Contains library instrumentation</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.166.1"> for .NET frameworks and libraries. </span><span class="koboSpan" id="kobo.166.2">The ASP.NET Core</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.167.1"> and HTTP client instrumentations we used in the previous chapter live here along with SQL, gRPC, and exporters for OSS backends. </span><span class="koboSpan" id="kobo.167.2">These are </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">instrumentation libraries.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.169.1">OpenTelemetry Contrib repo</span></strong><span class="koboSpan" id="kobo.170.1"> (</span><a href="https://github.com/open-telemetry/opentelemetry-dotnet-contrib):"><span class="koboSpan" id="kobo.171.1">https://github.com/open-telemetry/opentelemetry-dotnet-contrib):</span></a><span class="koboSpan" id="kobo.172.1"> Contains different OpenTelemetry components: instrumentation libraries, </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.173.1">exporters, and other</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.174.1"> utilities. </span><span class="koboSpan" id="kobo.174.2">You can find instrumentations for AWS SDK, ElasticSearch, WCF, StackExchange.Redis, and more there. </span><span class="koboSpan" id="kobo.174.3">The Entity Framework instrumentation we used in the previous chapter also lives in </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">this repo.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.176.1">OpenTelemetry instrumentation repo</span></strong><span class="koboSpan" id="kobo.177.1"> (</span><a href="https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation):"><span class="koboSpan" id="kobo.178.1">https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation):</span></a><span class="koboSpan" id="kobo.179.1"> Contains fully codeless auto-instrumentations</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.180.1"> that work via different</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.181.1"> mechanism - .NET profiling API. </span><span class="koboSpan" id="kobo.181.2">You can find GraphGL and MongoDB instrumentation there. </span><span class="koboSpan" id="kobo.181.3">In addition to auto-instrumentations for specific libraries; it provides a mechanism to configure OpenTelemetry in a codeless way that includes a set of common </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">instrumentation libraries.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.183.1">Other sources</span></strong><span class="koboSpan" id="kobo.184.1">: If you didn’t find what you’re looking for in the registry or the OpenTelemetry repos, search for issues in OpenTelemetry repos and don’t forget to check your library repo. </span><span class="koboSpan" id="kobo.184.2">For example, you can find MongoDB instrumentation at </span><a href="https://github.com/jbogard/MongoDB.Driver.Core.Extensions.DiagnosticSources"><span class="koboSpan" id="kobo.185.1">https://github.com/jbogard/MongoDB.Driver.Core.Extensions.DiagnosticSources</span></a><span class="koboSpan" id="kobo.186.1">, which is leveraged in the </span><em class="italic"><span class="koboSpan" id="kobo.187.1">instrumentation</span></em><span class="koboSpan" id="kobo.188.1"> repo but can be used as a standalone </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">instrumentation</span></span><span class="No-Break"><a id="_idIndexMarker171"/></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1"> library.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.191.1">When adding</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.192.1"> instrumentations, pay attention to their stability</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.193.1"> and maturity. </span><span class="koboSpan" id="kobo.193.2">Instrumentations in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">opentelemetry-dotnet</span></strong><span class="koboSpan" id="kobo.195.1"> repo are widely used but are not yet stable (it could have changed by the time you </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">read this).</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">Instrumentations in the </span><em class="italic"><span class="koboSpan" id="kobo.198.1">contrib</span></em><span class="koboSpan" id="kobo.199.1"> repo have different statuses; for example, AWS is stable, while MySQL is in alpha and works for relatively old versions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">MySQL.Data</span></strong><span class="koboSpan" id="kobo.201.1"> package at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">of writing.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.203.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.204.1">If you decide to take dependency on a less common preview package, make sure to test it well. </span><span class="koboSpan" id="kobo.204.2">Compatibility with your version of the client library, stability, and performance should be the main concerns. </span><span class="koboSpan" id="kobo.204.3">All of them should be covered with integration and stress-testing—just make sure to </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">enable instrumentation!</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">It’s good to get a basic idea of how the instrumentation works and check whether the mechanism behind it satisfies your performance requirements. </span><span class="koboSpan" id="kobo.206.2">For example, native instrumentations rely on </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.208.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">DiagnosticSource</span></strong><span class="koboSpan" id="kobo.210.1">, and MongoDB and AWS instrumentations rely on hooks in corresponding libraries. </span><span class="koboSpan" id="kobo.210.2">All of these methods should work reasonably well, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">MySQL.Data</span></strong><span class="koboSpan" id="kobo.212.1"> instrumentation relies on </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">System.Diagnostics.TraceListener</span></strong><span class="koboSpan" id="kobo.214.1">, which is not thread-safe by default, and, when configured to be thread-safe, is </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">not performant.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">Even the most efficient instrumentations come with some performance hit. </span><span class="koboSpan" id="kobo.216.2">You should expect throughput to drop a few percent compared to non-instrumented code. </span><span class="koboSpan" id="kobo.216.3">Specific numbers heavily depend on your </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.217.1">scenarios and OpenTelemetry </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.218.1">configuration, such </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">as sampling.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.220.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.221.1">Many developers consider auto-instrumentations to be magical and avoid them for this reason. </span><span class="koboSpan" id="kobo.221.2">By learning the mechanisms behind instrumentation, you can identify areas for additional testing, understand limitations, and gain confidence to use it (</span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">or not).</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">So, let’s instrument the new version of the meme service and dig deep into each instrumentation we’re going </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">to use.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.225.1">Instrumenting application</span></h2>
<p><span class="koboSpan" id="kobo.226.1">Our new demo application</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.227.1"> stores memes in Azure Blob Storage or AWS S3 and caches them in Redis, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.228.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.229.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.231.1"><img alt="Figure 3.1 – Meme service with configurable cloud storage" src="image/B19423_03_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.232.1">Figure 3.1 – Meme service with configurable cloud storage</span></p>
<p><span class="koboSpan" id="kobo.233.1">You can also set it up to store memes in Redis if you don’t want to configure a </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">cloud subscription.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">There are no changes on </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">frontend</span></strong><span class="koboSpan" id="kobo.237.1"> from the previous chapter—we already enabled OpenTelemetry with HTTP instrumentations there. </span><span class="koboSpan" id="kobo.237.2">On </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">storage</span></strong><span class="koboSpan" id="kobo.239.1">, though we still need to add a few more instrumentations for AWS, Redis, and </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">Azure SDK.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">First, we need to install </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">OpenTelemetry.Contrib.Instrumentation.AWS</span></strong><span class="koboSpan" id="kobo.243.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">OpenTelemetry.Instrumentation.StackExchangeRedis</span></strong><span class="koboSpan" id="kobo.245.1"> and then </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">configure them:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.247.1">libraries\storage\Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
builder.Services.AddOpenTelemetry()
  .WithTracing(tracerProviderBuilder =&gt;
        tracerProviderBuilder.
</span><strong class="bold"><span class="koboSpan" id="kobo.249.1">      .AddRedisInstrumentation(redisConnection, o =&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.250.1">            o.SetVerboseDatabaseStatements = true)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.251.1">      .AddAWSInstrumentation(o =&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.252.1">            o.SuppressDownstreamInstrumentation = false)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.253.1">     ...);</span></strong></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/libraries/storage/Program.cs"><span class="koboSpan" id="kobo.254.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/libraries/storage/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.255.1">Let’s unpack it and explore instrumentations one </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">by one.</span></span></p>
<h3><span class="koboSpan" id="kobo.257.1">Redis</span></h3>
<p><span class="koboSpan" id="kobo.258.1">Redis instrumentation</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.259.1"> is available</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.260.1"> via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">OpenTelemetry.Instrumentation.StackExchangeRedis</span></strong><span class="koboSpan" id="kobo.262.1"> package and comes from the </span><em class="italic"><span class="koboSpan" id="kobo.263.1">contrib</span></em><span class="koboSpan" id="kobo.264.1"> repo—documentation and examples are </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">available there.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Let’s see how we can evaluate this instrumentation. </span><span class="koboSpan" id="kobo.266.2">While any details about it might change, the approach can be applied to any other </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">instrumentation library.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">Redis instrumentation is not stable at the time of writing but it has a fair number of downloads on NuGet and no bugs reported. </span><span class="koboSpan" id="kobo.268.2">If we investigate how it works, we’ll see that it leverages the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">StackExchange.Redis</span></strong><span class="koboSpan" id="kobo.270.1"> profiling APIs—hooks allowing the start of a profiling session and recording events that happen during its execution. </span><span class="koboSpan" id="kobo.270.2">Despite the name, it doesn’t need the </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">profiler attached.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">It’s a relatively complex instrumentation—a profiling API is not designed for distributed tracing, so instrumentation must cover the gaps by maintaining an internal cache of sessions and cleaning </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">them up.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">To enable instrumentation, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">AddRedisInstrumentation</span></strong><span class="koboSpan" id="kobo.276.1"> extension method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">TracerProviderBuilder</span></strong><span class="koboSpan" id="kobo.278.1"> and pass the connection instance. </span><span class="koboSpan" id="kobo.278.2">If you have more than one connection, you’ll have to enable instrumentation for each </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">We also passed instrumentation options and enabled verbose database statements to collect additional data including Redis keys and scripts by setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">SetVerboseDatabaseStatements</span></strong><span class="koboSpan" id="kobo.282.1"> flag </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
AddRedisInstrumentation(redisConnection, o =&gt;
  o.SetVerboseDatabaseStatements = true)</span></pre>
<p><span class="koboSpan" id="kobo.287.1">It’s a good idea to check how this configuration might affect application performance and the verbosity of the output before deploying it to production. </span><span class="koboSpan" id="kobo.287.2">If we look into the Redis instrumentation code, this flag guards reflection-based (but efficient) calls to obtain the command key </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">and script.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">Depending on what we store in Redis, we should also make sure it does not record any secrets or </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">sensitive data.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">You probably noticed that instrumentations follow a common pattern, but unlike Redis ones, most of them are global and don’t require a per-client </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">instance setup.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">There are other options that control tracing on Redis: you can specify callback to enrich activities, disable events with additional timings, and configure intervals to clean up completed </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">profiling sessions.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">If we start the application now and upload</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.296.1"> and download several memes on http://localhost:5051/, we’d see traces</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.297.1"> like the one shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.298.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.299.1">.2</span></em><span class="koboSpan" id="kobo.300.1"> for meme </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">download flow:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.302.1"><img alt="Figure 3.2 – Meme download with Redis span" src="image/B19423_03_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.303.1">Figure 3.2 – Meme download with Redis span</span></p>
<p><span class="koboSpan" id="kobo.304.1">You can see the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">net.peer.*</span></strong><span class="koboSpan" id="kobo.306.1"> attributes describing generic network endpoint and </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">db.*</span></strong><span class="koboSpan" id="kobo.308.1"> attributes describing database call with </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">db.statement</span></strong><span class="koboSpan" id="kobo.310.1"> matching Redis command and key. </span><span class="koboSpan" id="kobo.310.2">We only see the key (</span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">this_is_fine</span></strong><span class="koboSpan" id="kobo.312.1">) since we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">SetVerboseDatabaseStatements</span></strong><span class="koboSpan" id="kobo.314.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">true</span></strong><span class="koboSpan" id="kobo.316.1">, otherwise </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">db.statement</span></strong><span class="koboSpan" id="kobo.318.1"> would match the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">command </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">HMGET</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">You can also see three logs (span events in Jaeger) describing additional timings for the Redis command. </span><span class="koboSpan" id="kobo.322.2">Since Redis</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.323.1"> is quite fast, you might find these events to be not very useful and disable</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.324.1"> them by setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">EnrichActivityWithTimingEvents</span></strong><span class="koboSpan" id="kobo.326.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">false</span></strong><span class="koboSpan" id="kobo.328.1">, which should decrease your observability bill and slightly </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">improve performance.</span></span></p>
<h3><span class="koboSpan" id="kobo.330.1">AWS SDK</span></h3>
<p><span class="koboSpan" id="kobo.331.1">AWS SDK</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.332.1"> instrumentation</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.333.1"> is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">OpenTelemetry.Contrib.Instrumentation.AWS</span></strong><span class="koboSpan" id="kobo.335.1"> NuGet package with the code residing in the </span><em class="italic"><span class="koboSpan" id="kobo.336.1">contrib</span></em><span class="koboSpan" id="kobo.337.1"> repo. </span><span class="koboSpan" id="kobo.337.2">Let’s try to evaluate it using the </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">same approach.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">It is stable and relies on a global tracing handler that applies to all AWS clients and instances, not just S3. </span><span class="koboSpan" id="kobo.339.2">This handler in turn leverages .NET tracing primitives: </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Activity</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.341.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">ActivitySource</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">To enable AWS instrumentation, just call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">AddAWSInstrumentation</span></strong><span class="koboSpan" id="kobo.346.1"> extension method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">TracerProviderBuilder</span></strong><span class="koboSpan" id="kobo.348.1">. </span><span class="koboSpan" id="kobo.348.2">At this moment, there’s just one configurable option that controls whether nested HTTP calls should </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">be traced:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
AddAWSInstrumentation(o =&gt; o
  .SuppressDownstreamInstrumentation = false)</span></pre>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.351.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.352.1">.3</span></em><span class="koboSpan" id="kobo.353.1"> shows the meme upload trace: </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">frontend</span></strong><span class="koboSpan" id="kobo.355.1"> calls </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">storage</span></strong><span class="koboSpan" id="kobo.357.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.358.1">storage</span></strong><span class="koboSpan" id="kobo.359.1"> calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">PutObject</span></strong><span class="koboSpan" id="kobo.361.1"> that in turn makes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">HTTP PUT</span></strong><span class="koboSpan" id="kobo.363.1"> request to S3. </span><span class="koboSpan" id="kobo.363.2">After the meme is uploaded, it’s cached </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">on Redis:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.365.1"><img alt="Figure 3.3 – Upload meme to S3" src="image/B19423_03_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">Figure 3.3 – Upload meme to S3</span></p>
<p><span class="koboSpan" id="kobo.367.1">The nested HTTP span is coming from the HTTP Client instrumentation, and we only see it because </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">SuppressDownstreamInstrumentation</span></strong><span class="koboSpan" id="kobo.369.1"> is set </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">If we expand </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">S3.PutObject</span></strong><span class="koboSpan" id="kobo.375.1">, we’ll see attributes</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.376.1"> that describe this operation</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.377.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.378.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.379.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">:</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.381.1"><img alt="Figure 3.4 – AWS S3 span attributes" src="image/B19423_03_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.382.1">Figure 3.4 – AWS S3 span attributes</span></p>
<h3><span class="koboSpan" id="kobo.383.1">Azure SDK</span></h3>
<p><span class="koboSpan" id="kobo.384.1">Azure SDK instrumentation</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.385.1"> is native—it’s baked</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.386.1"> into modern libraries—and you don’t need to install any additional packages. </span><span class="koboSpan" id="kobo.386.2">Tracing code for all client libraries is available in the </span><a href="https://github.com/Azure/azure-sdk-for-net/"><span class="koboSpan" id="kobo.387.1">https://github.com/Azure/azure-sdk-for-net/</span></a><span class="koboSpan" id="kobo.388.1"> repo. </span><span class="koboSpan" id="kobo.388.2">Still, it’s not stable because of tracing semantic conventions being experimental. </span><span class="koboSpan" id="kobo.388.3">For example, attribute names, types, and relationships between activities may change in </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">You can enable it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">AppContext</span></strong><span class="koboSpan" id="kobo.392.1"> switch either in </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">csproj</span></strong><span class="koboSpan" id="kobo.394.1"> or by adding the following code before Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">clients’ initialization:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
AppContext.SetSwitch(
  "Azure.Experimental.EnableActivitySource",
  true)</span></pre>
<p><span class="koboSpan" id="kobo.397.1">Instrumentation uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.399.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">Activity</span></strong><span class="koboSpan" id="kobo.401.1"> directly, so all we need to enable it is to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">AddSource("Azure.*")</span></strong><span class="koboSpan" id="kobo.403.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">TracerProviderBuilder</span></strong><span class="koboSpan" id="kobo.405.1">. </span><span class="koboSpan" id="kobo.405.2">It enables all sources that start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">Azure</span></strong><span class="koboSpan" id="kobo.407.1">, but you can also enable </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">individual sources.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.409.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.410.1">.5</span></em><span class="koboSpan" id="kobo.411.1"> shows the Azure SDK blob</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.412.1"> upload trace—logical upload operation</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.413.1"> and nested HTTP request. </span><span class="koboSpan" id="kobo.413.2">We see one there, but for chunked downloads, complex calls, or in case of retries, we’d see multiple nested </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">HTTP calls:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.415.1"><img alt="Figure 3.5 –  Azure Blob upload" src="image/B19423_03_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.416.1">Figure 3.5 –  Azure Blob upload</span></p>
<p><span class="koboSpan" id="kobo.417.1">We explored tracing for several libraries</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.418.1"> and learned how to discover and evaluate</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.419.1"> instrumentations. </span><span class="koboSpan" id="kobo.419.2">Let’s now discover what we can get </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">from infrastructure.</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.421.1">Leveraging infrastructure</span></h1>
<p><span class="koboSpan" id="kobo.422.1">In this section, we’ll explore</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.423.1"> Dapr for microservices. </span><span class="koboSpan" id="kobo.423.2">Dapr provides service discovery, component bindings, secret management, locking, state management, observability, and more building blocks helping developers to focus on application logic. </span><span class="koboSpan" id="kobo.423.3">We’ll focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">distributed tracing.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">In our demo application, we’re going to handle all network calls with Dapr and enable tracing and metrics on it. </span><span class="koboSpan" id="kobo.425.2">We’ll also keep telemetry enabled on the microservices. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.426.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.427.1">.6</span></em><span class="koboSpan" id="kobo.428.1"> shows the new </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">application layout:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.430.1"><img alt="Figure 3.6 – Meme application with Dapr runtime" src="image/B19423_03_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.431.1">Figure 3.6 – Meme application with Dapr runtime</span></p>
<p><span class="koboSpan" id="kobo.432.1">Dapr runs as a sidecar—a separate process wrapping each application instance. </span><strong class="bold"><span class="koboSpan" id="kobo.433.1">Frontend</span></strong><span class="koboSpan" id="kobo.434.1"> in our setup calls into </span><strong class="bold"><span class="koboSpan" id="kobo.435.1">storage</span></strong><span class="koboSpan" id="kobo.436.1"> via Dapr, which handles service discovery, error handling, encryption, load balancing, and more. </span><strong class="bold"><span class="koboSpan" id="kobo.437.1">Storage</span></strong><span class="koboSpan" id="kobo.438.1">, in turn, uses Dapr output </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">binding</span></strong><span class="koboSpan" id="kobo.440.1"> to communicate to Azure, AWS, or store </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">memes locally.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">Dapr integrates well with Kubernetes, but we’ll use self-hosted mode and </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">docker-compose</span></strong><span class="koboSpan" id="kobo.444.1"> to keep </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">things simple.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Dapr supports distributed</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.447.1"> tracing and metrics for incoming and outgoing calls that applications make through Dapr. </span><span class="koboSpan" id="kobo.447.2">Let’s see what it means </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">in practice.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.449.1">Configuring secrets</span></h2>
<p><span class="koboSpan" id="kobo.450.1">Dapr secrets configuration</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.451.1"> needs a different approach than we used for the libraries demo. </span><span class="koboSpan" id="kobo.451.2">We’ll need to update </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">darp/configs/dapr/storage-components/secrets.json</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.453.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.454.1">For AWS, put your access keys in </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">{"awsKey": &lt;key&gt;, "</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">awsSecret": &lt;secret&gt;}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.458.1">For Azure, set </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">{"azStorageAccount": &lt;account&gt;, "azStorageKey": &lt;key&gt;}. </span></strong><span class="koboSpan" id="kobo.460.1">If you don't have Azure credentials, remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">binding-azure.yaml</span></strong><span class="koboSpan" id="kobo.462.1"> file from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">dapr/configs/dapr/storage-components</span></strong><span class="koboSpan" id="kobo.464.1"> folder, otherwise samples will </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">not work.</span></span></li>
<li><span class="koboSpan" id="kobo.466.1">For local runs, set </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">CloudStorage.Type</span></strong><span class="koboSpan" id="kobo.468.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Local</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.470.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">storage/appsettings.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">.</span></span></li>
</ul>
<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.473.1">Configuring observability on Dapr</span></h2>
<p><span class="koboSpan" id="kobo.474.1">To enable tracing</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.475.1"> and metrics, let’s add corresponding</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.476.1"> sections to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">Configuration spec</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.479.1">./dapr/configs/dapr/config.yml</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
spec:
  metric:
    enabled: true
  tracing:
    samplingRate: "1"
    zipkin:
      endpointAddress: "http://otelcollector:9412/
        api/v2/spans"</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/dapr/configs/dapr/config.yml"><span class="koboSpan" id="kobo.481.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/dapr/configs/dapr/config.yml</span></a></p>
<p><span class="koboSpan" id="kobo.482.1">We also added Dapr sidecars to </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.484.1">, enabled the Zipkin trace receiver on the OpenTelemetry collector, and added Dapr metrics endpoints to Prometheus targets</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.485.1"> to scrape from. </span><span class="koboSpan" id="kobo.485.2">As a result, we receive traces and metrics</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.486.1"> from the application and Dapr at the same time. </span><span class="koboSpan" id="kobo.486.2">Let’s check </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">them out.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.488.1">Tracing</span></h2>
<p><span class="koboSpan" id="kobo.489.1">Let’s run the application</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.490.1"> now with </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">docker-compose up --build</span></strong><span class="koboSpan" id="kobo.492.1">, hit </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">frontend</span></strong><span class="koboSpan" id="kobo.494.1"> at http://localhost:5051, and upload some memes. </span><span class="koboSpan" id="kobo.494.2">If you open Jaeger at </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">http://localhost:16686</span></strong><span class="koboSpan" id="kobo.496.1"> and find some upload requests, you should see something like the trace shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.497.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.498.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.500.1"><img alt="Figure 3.7 – Trace from the application and Dapr " src="image/B19423_03_07.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><span class="koboSpan" id="kobo.501.1">Figure 3.7 – Trace from the application and Dapr</span></p>
<p><span class="koboSpan" id="kobo.502.1">The first two spans coming from </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">frontend</span></strong><span class="koboSpan" id="kobo.504.1"> didn’t really change as compared to the trace we saw in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.505.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.506.1">.2</span></em><span class="koboSpan" id="kobo.507.1"> when the application didn't use Dapr—they are still coming from it directly. </span><span class="koboSpan" id="kobo.507.2">Then we see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">frontend /memes/d8…</span></strong><span class="koboSpan" id="kobo.509.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">CallLocal/storage/memes/d8…</span></strong><span class="koboSpan" id="kobo.511.1"> spans—they are new and are coming </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">from Dapr.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">If we expand them as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.514.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.515.1">.8</span></em><span class="koboSpan" id="kobo.516.1">, we’ll also see the attributes </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">it set:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.518.1"><img alt="Figure 3.8 – Dapr spans and attributes " src="image/B19423_03_08.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><span class="koboSpan" id="kobo.519.1">Figure 3.8 – Dapr spans and attributes</span></p>
<p><span class="koboSpan" id="kobo.520.1">You would probably wonder</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.521.1"> if we still need distributed tracing on the service—let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">check it.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">Stop containers and comment out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">OTEL_EXPORTER_OTLP_ENDPOINT</span></strong><span class="koboSpan" id="kobo.525.1"> environment variable in </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.527.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.528.1">frontend</span></strong><span class="koboSpan" id="kobo.529.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">storage</span></strong><span class="koboSpan" id="kobo.531.1">; we don’t enable OpenTelemetry if the endpoint is </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">not provided.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">Then, restart the application and upload some memes again, and the result is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.534.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.535.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.537.1"><img alt="Figure 3.9 – Dapr tracing without OpenTelemetry enabled in the application" src="image/B19423_03_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.538.1">Figure 3.9 – Dapr tracing without OpenTelemetry enabled in the application</span></p>
<p><span class="koboSpan" id="kobo.539.1">So, we see the spans coming from Dapr, but the trace does not look right—upload to Azure Blob is not a child of an incoming request represented with </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">CallLocal/storage</span></strong><span class="koboSpan" id="kobo.541.1"> span. </span><span class="koboSpan" id="kobo.541.2">What </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">happened there?</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">In </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.544.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.545.1">, </span><em class="italic"><span class="koboSpan" id="kobo.546.1">Native Monitoring in .NET</span></em><span class="koboSpan" id="kobo.547.1">, we have shown that ASP.NET Core and </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">HttpClient</span></strong><span class="koboSpan" id="kobo.549.1"> in .NET create activities regardless of OpenTelemetry presence. </span><span class="koboSpan" id="kobo.549.2">This is what happened here—</span><strong class="bold"><span class="koboSpan" id="kobo.550.1">frontend</span></strong><span class="koboSpan" id="kobo.551.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.552.1">storage</span></strong><span class="koboSpan" id="kobo.553.1"> created all the spans we saw previously in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.554.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.555.1">.7</span></em><span class="koboSpan" id="kobo.556.1">, but they are not recorded anywhere. </span><span class="koboSpan" id="kobo.556.2">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">CallLocal</span></strong><span class="koboSpan" id="kobo.558.1"> is a grandparent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">/v1.0/bindings/azureblob</span></strong><span class="koboSpan" id="kobo.560.1">, but the span between them is not recorded and causation </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">is lost.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">Similarly, if you use Dapr on an application that does not enable distributed tracing by default, the context will not be propagated within the </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">storage</span></strong><span class="koboSpan" id="kobo.564.1"> service and any correlation between </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">CallLocal</span></strong><span class="koboSpan" id="kobo.566.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">/v1.0/bindings/azureblob</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.568.1">would disappear.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.569.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.570.1">Dapr or service mesh, such as Istio, can trace network calls, but they cannot propagate trace context within the application process and rely on applications to do it. </span><span class="koboSpan" id="kobo.570.2">They also can’t stamp context on the logs if your application does not </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">do it.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">If you can’t instrument your application, traces coming from Dapr or service mesh are still handy, despite </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">being semi-correlated.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">If you use Dapr for reasons</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.575.1"> beyond observability and your application is instrumented, then Dapr tracing gives you observability into Dapr itself to see how it handles requests, so you can compare latencies, debug configuration issues, and </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">so on.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.577.1">Metrics</span></h2>
<p><span class="koboSpan" id="kobo.578.1">Dapr reports extensive metrics </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.579.1">about application communication and bindings such as HTTP and gRPC request count, duration, and request and response size histograms. </span><span class="koboSpan" id="kobo.579.2">You could also find Go runtime stats for the </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">Dapr itself.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">These metrics look quite promising but by default they use the HTTP request path as an attribute on metrics, which has high cardinality. </span><span class="koboSpan" id="kobo.581.2">While they allow to reduce cardinality with a regular expression and convert path to an API route, it would be a problem in high-scale production application. </span><span class="koboSpan" id="kobo.581.3">Once they become production ready, they could be a great alternative to many in-process metrics covering </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">network communication.</span></span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.583.1">Instrumenting serverless environments</span></h1>
<p><span class="koboSpan" id="kobo.584.1">Serverless environments</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.585.1"> need observability more than other systems—they are frequently used to integrate different services with little-to-no user code, making debugging and local testing difficult. </span><span class="koboSpan" id="kobo.585.2">With load balancing, scaling, and other common infrastructure pieces handled for us, we still need to understand what’s going on when things don’t work </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">In addition, as users, we are very limited with telemetry collection options—we can’t install agents, configure runtime, or run something in privileged mode—we can only use what cloud providers expose. </span><span class="koboSpan" id="kobo.587.2">At the same time, cloud providers have a great opportunity to instrument code for us. </span><span class="koboSpan" id="kobo.587.3">Let’s see what AWS Lambda and Azure Functions provide out of the box and what we can do on top </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">of it.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.589.1">AWS Lambda</span></h2>
<p><span class="koboSpan" id="kobo.590.1">AWS Lambda</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.591.1"> supports invocation</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.592.1"> tracing with X-Ray out of the box; you just need to enable active tracing via console or CLI to trace incoming calls to your function and see basic </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">invocation metrics:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.594.1"><img alt="Figure 3.10 – AWS X-Ray service map showing default Lambda instrumentation" src="image/B19423_03_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.595.1">Figure 3.10 – AWS X-Ray service map showing default Lambda instrumentation</span></p>
<p><span class="koboSpan" id="kobo.596.1">To go further than this and trace what happens in your code, you’d need to use X-Ray SDK as a stable solution or OpenTelemetry, which is in beta at this point. </span><span class="koboSpan" id="kobo.596.2">We’re going to play with OpenTelemetry in </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">this demo.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">The configuration around OpenTelemetry is likely to change. </span><span class="koboSpan" id="kobo.598.2">So, we will kindly</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.599.1"> ask you to check out the latest instructions for </span><strong class="bold"><span class="koboSpan" id="kobo.600.1">ADOT Collector</span></strong><span class="koboSpan" id="kobo.601.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.602.1">AWS Distro for OpenTelemetry Collector</span></strong><span class="koboSpan" id="kobo.603.1">), available </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">at </span></span><a href="https://aws-otel.github.io/docs/getting-started/lambda/lambda-dotnet"><span class="No-Break"><span class="koboSpan" id="kobo.605.1">https://aws-otel.github.io/docs/getting-started/lambda/lambda-dotnet</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.606.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.607.1">ADOT Collector is based on OpenTelemetry Collector; it’s also compatible with AWS environments and comes with a preselected set of community components. </span><span class="koboSpan" id="kobo.607.2">We’re going to send traces to X-Ray, which is a default configuration</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.608.1"> for ADOT Collector, but you can configure it to send data</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.609.1"> to your </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">observability backend.</span></span></p>
<p><span class="koboSpan" id="kobo.611.1">Now we’re ready to explore the tracing experience </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">in Lambda.</span></span></p>
<h3><span class="koboSpan" id="kobo.613.1">Enabling additional tracing</span></h3>
<p><span class="koboSpan" id="kobo.614.1">Tracing configuration</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.615.1"> in Lambda is like any other service. </span><span class="koboSpan" id="kobo.615.2">First, we need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">OpenTelemetry.Instrumentation.AWSLambda</span></strong><span class="koboSpan" id="kobo.617.1"> NuGet package and then configure it along with the exporter and </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">other instrumentations:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.619.1">Function.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.620.1">
static Function()
{
</span><strong class="bold"><span class="koboSpan" id="kobo.621.1">  Sdk.SetDefaultTextMapPropagator(new</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.622.1">      AWSXRayPropagator());</span></strong><span class="koboSpan" id="kobo.623.1">
    TracerProvider = Sdk.CreateTracerProviderBuilder()
</span><strong class="bold"><span class="koboSpan" id="kobo.624.1">      .AddAWSLambdaConfigurations()</span></strong><span class="koboSpan" id="kobo.625.1">...;
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs"><span class="koboSpan" id="kobo.626.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs</span></a></p>
<p><span class="koboSpan" id="kobo.627.1">Let’s unpack what happens here. </span><span class="koboSpan" id="kobo.627.2">First, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">AWSXRayPropagator</span></strong><span class="koboSpan" id="kobo.629.1"> as a default context propagator—it enables context propagation over the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">X-Amzn-Trace-Id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.631.1"> header.</span></span></p>
<p><span class="koboSpan" id="kobo.632.1">Then, we enabled Lambda instrumentation with </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">AddAWSLambdaConfigurations</span></strong><span class="koboSpan" id="kobo.634.1">. </span><span class="koboSpan" id="kobo.634.2">If we look under the hood, this method does a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">of things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.636.1">Detects and configures resource attributes such as cloud provider, region, function name, </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">and version</span></span></li>
<li><span class="koboSpan" id="kobo.638.1">Enables </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.640.1"> that reports Lambda invocations and </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">stitches context</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.642.1">Note that we do it in the static constructor to optimize performance and reduce costs. </span><span class="koboSpan" id="kobo.642.2">Despite being serverless, Lambda uses one process for </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">multiple invocations.</span></span></p>
<p><span class="koboSpan" id="kobo.644.1">As the last step, we need</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.645.1"> to implement the tracing handler that wraps our </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">Lambda logic:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.647.1">Function.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.648.1">
async Task&lt;APIGatewayProxyResponse&gt; TracingHandler(
  APIGatewayHttpApiV2ProxyRequest req, ILambdaContext ctx)
    =&gt;
    await AWSLambdaWrapper.TraceAsync(TracerProvider,
      MemeHandler, req, ctx);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs"><span class="koboSpan" id="kobo.649.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/aws/memefunc/Function.cs</span></a></p>
<p><span class="koboSpan" id="kobo.650.1">Note that we configured Lambda to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">TracingHandler</span></strong><span class="koboSpan" id="kobo.652.1"> instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">inner </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">MemeHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">If we get back to the configuration, the rest enables AWS SDK and HTTP Client instrumentation. </span><span class="koboSpan" id="kobo.656.2">We also configured the OTLP exporter without parameters—it uses the default endpoint (</span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">localhost:4317</span></strong><span class="koboSpan" id="kobo.658.1">) and the default </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">protocol (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">gRPC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">We also configured </span><strong class="bold"><span class="koboSpan" id="kobo.663.1">frontend</span></strong><span class="koboSpan" id="kobo.664.1"> to send data to ADOT with the X-Ray exporter, so we get all traces in the </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">same place.</span></span></p>
<p><span class="koboSpan" id="kobo.666.1">If you didn’t deploy your Lambda function yet, deploy it now, for example, with AWS Toolkit for Visual Studio or Lambda tools for .</span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">NET CLI.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">Make sure to configure the function URL on </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">frontend</span></strong><span class="koboSpan" id="kobo.670.1"> as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">Storage__Endpoint</span></strong><span class="koboSpan" id="kobo.672.1"> environment variable—you can set it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">./frontend/docker-compose.yml</span></strong><span class="koboSpan" id="kobo.674.1">. </span><span class="koboSpan" id="kobo.674.2">We don’t use authorization in the demo, but make sure to secure your </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">real-life applications.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">Now, let’s start </span><strong class="bold"><span class="koboSpan" id="kobo.677.1">frontend</span></strong><span class="koboSpan" id="kobo.678.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">docker-compose up --build</span></strong><span class="koboSpan" id="kobo.680.1">, then upload and download some memes </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">http://localhost:5051</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">Let’s switch to AWS X-Ray and check out the traces. </span><span class="koboSpan" id="kobo.684.2">You should see something similar to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.685.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.686.1">.11</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.688.1"><img alt="Figure 3.11 – Lambda tracing with OpenTelemetry" src="image/B19423_03_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.689.1">Figure 3.11 – Lambda tracing with OpenTelemetry</span></p>
<p><span class="koboSpan" id="kobo.690.1">If you check the service</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.691.1"> map, it now shows S3 in addition to </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">Lambda nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">Now that you know how to enable tracing for AWS Lambda, let’s see what Azure Functions are </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">capable of.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.695.1">Azure Functions</span></h2>
<p><span class="koboSpan" id="kobo.696.1">Azure Functions</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.697.1"> support distributed tracing</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.698.1"> with Azure Monitor (Application Insights) out-of-the-box. </span><span class="koboSpan" id="kobo.698.2">It includes triggers and most bindings. </span><span class="koboSpan" id="kobo.698.3">If you use in-process functions, tracing covers user code too, with isolated workers, you need to enable and configure tracing in the worker </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">process yourself.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">Azure Functions rely on the instrumentations in client SDKs used for triggers and bindings. </span><span class="koboSpan" id="kobo.700.2">For example, they reuse ASP.NET Core Activities in HTTP Trigger and Azure SDK instrumentation for Azure Blob Storage inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">and outputs.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">The Azure Functions runtime does not support OpenTelemetry for in-process functions yet, but your observability vendor may provide an extension that covers </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">this gap.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">In our sample, Azure Functions host automatically reports triggers and binding calls to Application Insights – this auto-collection lights up in presence of the  </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">APPLICATIONINSIGHTS_CONNECTION_STRING</span></strong><span class="koboSpan" id="kobo.706.1"> environment variable, which we can set in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">local.settings.json</span></strong><span class="koboSpan" id="kobo.708.1"> file, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">this example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.710.1">./serverless/azure/memefunc/local.settings.json</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.711.1">
"Values": {
  ...
</span><span class="koboSpan" id="kobo.711.2">  "APPLICATIONINSIGHTS_CONNECTION_STRING":
       "InstrumentationKey=&lt;key&gt;;IngestionEndpoint=
           &lt;endpoint&gt;"
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/local.settings.json"><span class="koboSpan" id="kobo.712.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/local.settings.json</span></a></p>
<p><span class="koboSpan" id="kobo.713.1">We also need to enable OpenTelemetry for the worker</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.714.1"> process with the </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">following</span></span><span class="No-Break"><a id="_idIndexMarker216"/></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1"> code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.717.1">./serverless/azure/memefunc/Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.718.1">
var host = new HostBuilder()
  .ConfigureFunctionsWorkerDefaults
  .ConfigureServices(services =&gt; services
    .AddOpenTelemetry()
    .WithTracing(builder =&gt; builder
</span><strong class="bold"><span class="koboSpan" id="kobo.719.1">      .AddSource("Microsoft.Azure.Functions.Worker")</span></strong><span class="koboSpan" id="kobo.720.1">
      ...)
    )
  .Build();</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/Program.cs"><span class="koboSpan" id="kobo.721.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter3/serverless/azure/memefunc/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.722.1">Here we use a familiar way to enable OpenTelemetry, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">the Microsoft.Azure.Functions.Worker</span></strong><span class="koboSpan" id="kobo.724.1"> activity source is new. </span><span class="koboSpan" id="kobo.724.2">The source is part of Azure Functions Worker and propagates trace context from the host to isolated worker. </span><span class="koboSpan" id="kobo.724.3">It creates an activity representing </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">worker invocation.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">On the </span><strong class="bold"><span class="koboSpan" id="kobo.727.1">frontend</span></strong><span class="koboSpan" id="kobo.728.1"> side, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">Azure.Monitor.OpenTelemetry.Exporter</span></strong><span class="koboSpan" id="kobo.730.1"> to send data to Application Insights endpoint directly. </span></p>
<p><span class="koboSpan" id="kobo.731.1">To run the sample, we’ll need an Application Insights resource. </span><span class="koboSpan" id="kobo.731.2">You can create one with the following command: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.732.1">
$ az monitor app-insights component create --app &lt;resource-
  name&gt; --location &lt;region&gt; -g &lt;resource-group&gt;</span></pre>
<p><span class="koboSpan" id="kobo.733.1">It will return JSON</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.734.1"> output containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">connectionString</span></strong><span class="koboSpan" id="kobo.736.1">, which we’ll need to configure</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.737.1"> Functions. </span><span class="koboSpan" id="kobo.737.2">Let’s now set Azure Blob Storage and Application Insights connection strings in </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">memefunc/local.setting.json</span></strong><span class="koboSpan" id="kobo.739.1"> and we’re ready to run </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">the application:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.741.1">
serverless/azure/frontend$ dotnet run
serverless/azure/memefunc$ func start --port 5050</span></pre>
<p><span class="koboSpan" id="kobo.742.1">Hit </span><strong class="bold"><span class="koboSpan" id="kobo.743.1">frontend</span></strong><span class="koboSpan" id="kobo.744.1"> at </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">http://localhost:5051</span></strong><span class="koboSpan" id="kobo.746.1"> to upload and download some memes, and then go to your Application Insights resource and search for recent requests. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.747.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.748.1">.12</span></em><span class="koboSpan" id="kobo.749.1"> shows an example of </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">captured trace:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.751.1"><img alt="Figure 3.12 – Azure Functions trace " src="image/B19423_03_12.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><span class="koboSpan" id="kobo.752.1">Figure 3.12 – Azure Functions trace</span></p>
<p><span class="koboSpan" id="kobo.753.1">We traced this call from </span><strong class="bold"><span class="koboSpan" id="kobo.754.1">frontend</span></strong><span class="koboSpan" id="kobo.755.1"> and into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">storage-download</span></strong><span class="koboSpan" id="kobo.757.1"> function that in turn downloaded a blob. </span><span class="koboSpan" id="kobo.757.2">We used Azure Blob Storage bindings, so all the communication with blob storage was handled by Azure Functions host and outside of the worker process. </span><span class="koboSpan" id="kobo.757.3">As a result, the Azure Functions invocation span (</span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">storage-download</span></strong><span class="koboSpan" id="kobo.759.1">) and all spans related to blobs are reported by the </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">Functions host.</span></span></p>
<p><span class="koboSpan" id="kobo.761.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">Invoke</span></strong><span class="koboSpan" id="kobo.763.1"> span is recorded by </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">Microsoft.Azure.Functions.Worker</span></strong><span class="koboSpan" id="kobo.765.1"> activity source; it represents function invocation on the worker side. </span><span class="koboSpan" id="kobo.765.2">If we had any nested operations done inside worker, we’d see them reported as children of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">Invoke</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.767.1"> span.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">Even though most of the application</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.769.1"> logic happened outside of the application</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.770.1"> code, we can see what happened under the hood because </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">of tracing.</span></span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.772.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.773.1">In this chapter, we explored instrumentations in the .NET ecosystem. </span><span class="koboSpan" id="kobo.773.2">You learned how to evaluate and configure different kinds of instrumentation libraries, how to enable and use tracing on Dapr, and what serverless environments can provide with different levels </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">of configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.775.1">Client library auto-instrumentations can be found in OpenTelemetry repositories or registries, while some libraries don’t need instrumentations, providing tracing natively. </span><span class="koboSpan" id="kobo.775.2">Instrumentations’ maturity and stability levels vary, so it’s important to review and test them as a part of your normal integration and stress testing. </span><span class="koboSpan" id="kobo.775.3">Instrumentations usually provide configuration options to control the amount of details they capture, allowing you to find the right cost-value ratio for your system. </span><span class="koboSpan" id="kobo.775.4">Client libraries and frameworks are not the only sources of traces—your infrastructure such as service meshes, web servers, load balancers, and proxies can emit them. </span><span class="koboSpan" id="kobo.775.5">We checked out the tracing story in Dapr and confirmed that it provides insights into Dapr itself but can’t propagate the context and stamp it on the logs and other signals in the application. </span><span class="koboSpan" id="kobo.775.6">So, infrastructure traces complement but cannot substitute </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">in-process tracing.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">Serverless environments provide integration with tracing and monitoring tools; it’s critical for them since users are limited in the configuration of </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">serverless runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.779.1">We explored AWS Lambda, which supports OpenTelemetry, with ADOT Collector and in-code configuration, and Azure Functions that supports vendor-specific codeless instrumentation for in-process mode, while out-of-the-box OpenTelemetry support is yet </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">to come.</span></span></p>
<p><span class="koboSpan" id="kobo.781.1">Now that you know how to discover and use third-party instrumentations in different environments, you should be able to get observability into a broad spectrum of distributed applications. </span><span class="koboSpan" id="kobo.781.2">However, to debug in-process issues such as deadlocks, memory leaks, or inefficient code, we’ll need lower-level telemetry—this is what we’re going to explore in the </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">next chapter.</span></span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.783.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.784.1">How would you find instrumentation for a popular library you use? </span><span class="koboSpan" id="kobo.784.2">When you find one, what would you </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">check for?</span></span></li>
<li><span class="koboSpan" id="kobo.786.1">What is a typical mechanism behind OpenTelemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">tracing instrumentations?</span></span></li>
<li><span class="koboSpan" id="kobo.788.1">What service mesh can and cannot do in terms </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">of tracing?</span></span></li>
</ol>
</div>
<div>
<div class="Content" id="_idContainer054">
</div>
</div>
</body></html>