- en: Implementing Design Patterns - .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现设计模式 - .NET Core
- en: The previous chapter continued the building of the FlixOne inventory management
    application by incorporating additional patterns. More of the Gang of Four patterns
    were used, including the Singleton and Factory patterns. The Singleton pattern
    was used to illustrate the Repository pattern that was used to maintain the FlixOne
    collection of books. The Factory pattern was used to further explore the **dependency
    injection** (**DI**). The .Net Core framework was used to complete the initial
    inventory management console application, in order to facilitate an **inversion
    of control** (**IoC**) container.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章通过引入额外的模式继续构建 FlixOne 库存管理应用程序。使用了更多的设计模式，包括 Singleton 和工厂模式。Singleton 模式被用来展示用于维护
    FlixOne 书籍集合的 Repository 模式。工厂模式被用来进一步探索**依赖注入（DI**）。使用 .Net Core 框架完成初始的库存管理控制台应用程序，以便方便地使用**控制反转（IoC**）容器。
- en: This chapter will continue building upon the inventory management console application,
    while also exploring features of .Net Core. The Singleton pattern, which was covered
    in the previous chapter, will be revisited and created, using the Singleton service
    lifetime built into the .Net Core framework. Using the framework's DI, the Configuration
    pattern will be shown, as well as **constructor injection (CI)** explained, using
    different examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续构建库存管理控制台应用程序，同时探索 .Net Core 的功能。Singleton 模式，在上一章中已介绍，将重新审视并创建，使用 .Net
    Core 框架内置的 Singleton 服务生命周期。使用框架的依赖注入（DI），将展示配置模式，并解释**构造函数注入（CI**），使用不同的示例。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: .Net Core service lifetimes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .Net Core 服务生命周期
- en: Implementation factory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现工厂
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples that are used to explain the concepts.
    The code is kept simple, and is just for demonstration purposes. Most of the examples
    involve a .NET Core console application written in C#.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，用于解释概念。代码保持简单，仅用于演示目的。大多数示例涉及使用 C# 编写的 .NET Core 控制台应用程序。
- en: 'To run and execute the code, you need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，你需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017
    Version 3 or later).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（你也可以使用 Visual Studio 2017 版本 3 或更高版本来运行应用程序）。
- en: Setting up .NET Core.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 .NET Core。
- en: SQL server (express edition is used in this chapter).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 服务器（本章中使用的是 SQL Server Express 版本）。
- en: Installing Visual Studio
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Visual Studio
- en: 'To run these code examples, you need to install Visual Studio 2010, or later.
    You can use your preferred IDE. To do this, follow these instructions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，你需要安装 Visual Studio 2010 或更高版本。你可以使用你喜欢的 IDE。为此，请按照以下说明操作：
- en: 'Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载 Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions included. Multiple versions are available
    for Visual Studio installation. In this chapter, we are using Visual Studio for
    Windows.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循包含的安装说明。Visual Studio 安装提供了多个版本。在本章中，我们使用 Windows 版本的 Visual Studio。
- en: Setting up .NET Core
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 .NET Core
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 .NET Core，你需要按照以下说明操作：
- en: 'Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载 .NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: 'The installation instructions and the related library can be found at the following
    link: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装说明和相关库可以在以下链接找到：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: The complete source code is available in the GitHub repository. The source code
    shown in the chapter might not be complete, so it is advisable to retrieve the
    source in order to run the examples. Please refer to [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5.](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在 GitHub 仓库中找到。章节中显示的源代码可能不完整，因此建议检索源代码以运行示例。请参阅 [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5)。
- en: .Net Core service lifetimes
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .Net Core 服务生命周期
- en: 'A fundamental concept to understand when working with .Net Core''s DI, is service
    lifetimes. A service lifetime defines how a dependency is managed in regards to
    how often it is created. As an illustration of this process, think of DI as managing
    a container of dependencies. Dependency is just a class that the DI knows about,
    because the class was *registered* with it. For .Net Core''s DI, this is done
    with the following three methods of `IServiceCollection`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 .Net Core 的 DI 时，理解一个基本概念是服务生命周期。服务生命周期定义了依赖项是如何根据其创建频率进行管理的。为了说明这个过程，可以将
    DI 视为管理依赖项容器。依赖项只是一个 DI 知道的类，因为该类已与它 *注册*。对于 .Net Core 的 DI，这是通过 `IServiceCollection`
    的以下三种方法完成的：
- en: '`AddTransient<TService, TImplementation>()`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTransient<TService, TImplementation>()`'
- en: '`AddScoped<TService, TImplementation>()`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddScoped<TService, TImplementation>()`'
- en: '`AddSingleton<TService, TImplementation>()`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddSingleton<TService, TImplementation>()`'
- en: The `IServiceCollection` interface is a collection of registered service descriptions,
    basically containing the dependency, and when the DI should supply the dependency.
    For example, when `TService` is requested, `TImplementation` is supplied (that
    is, injected).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`IServiceCollection` 接口是一个已注册服务描述的集合，基本上包含依赖项，以及 DI 应何时提供依赖项。例如，当请求 `TService`
    时，提供 `TImplementation`（即注入）。'
- en: In this section, we will look at the three service lifetimes, and provide an
    illustration of the different lifetimes via unit tests. We will also look at how
    implementation factories can be used to create instances of the dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨三种服务生命周期，并通过单元测试提供不同生命周期的示例。我们还将探讨如何使用实现工厂创建依赖项的实例。
- en: Transient
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时
- en: A `transient` dependency means each time the DI receives a request for a dependency,
    then a new instance of the dependency will be created. In most situations, this
    is the service lifetime that makes the most sense to use, as most classes should
    be designed to be lightweight, stateless services. In situations where the state
    needs to be persisted between references and/or if there is considerable effort
    in instantiating a new instance, then another service lifetime might make more
    sense.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `临时` 依赖意味着每次依赖项被 DI 接收到请求时，都会创建一个新的依赖项实例。在大多数情况下，这是最合理使用的服务生命周期，因为大多数类应该被设计成轻量级、无状态的服务。在需要在不同引用之间持久化状态或创建新实例需要相当大的努力的情况下，则可能需要另一种服务生命周期。
- en: Scoped
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: In .Net Core, there is the concept of a scope, which can be thought of as a
    context or boundary for the executing process. In some .Net Core implementations,
    the scope is implicitly defined, so you might not be aware that it is being put
    in place. For example, in ASP.Net Core, a scope is created for each web request
    that is received. This means that, if a dependency has a Scoped lifetime, then
    it will only be constructed once per web request, so, if the same dependency is
    used multiple times for the same web request, it will be shared.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .Net Core 中，存在作用域的概念，可以将其视为执行过程的上下文或边界。在某些 .Net Core 实现中，作用域是隐式定义的，因此你可能不会意识到它在被设置。例如，在
    ASP.Net Core 中，对于收到的每个网络请求都会创建一个作用域。这意味着，如果依赖项具有作用域生命周期，那么它将仅在每次网络请求中构建一次，因此，如果同一依赖项在同一个网络请求中被多次使用，它将被共享。
- en: Later in this chapter, we will explicitly create a scope in order to illustrate
    a Scoped lifetime, and the same concept applies in the unit test as it will in
    an ASP.Net Core application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将显式创建一个作用域，以说明作用域生命周期，并且这个概念在单元测试中与在 ASP.Net Core 应用程序中相同。
- en: Singleton
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: In .Net Core, the Singleton pattern is implemented so that dependency is only
    ever instantiated once, just like the Singleton pattern that was implemented in
    the previous chapter. Similar to the Singleton pattern in the previous chapter,
    the `singleton` class needs to be thread safe, and only the factory method that
    is used to create the singleton class is guaranteed to be called only once by
    a single thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core中，单例模式实现的方式是依赖项仅被实例化一次，就像前一章中实现的单例模式一样。类似于前一章中的单例模式，`singleton`类需要是线程安全的，并且只有用于创建单例类的工厂方法可以保证由单个线程调用一次。
- en: Back to FlixOne
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回 FlixOne
- en: 'To illustrate .Net Core''s DI, we need to make some modifications to the FlixOne
    inventory management application. The first thing to do will be to update the
    `InventoryContext` class, which was defined earlier, in order to no longer implement
    the Singleton pattern (as we will do this using .Net Core''s DI):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明.NET Core的DI，我们需要对FlixOne库存管理应用程序进行一些修改。首先要做的事情将是更新之前定义的`InventoryContext`类，以便不再实现单例模式（因为我们将使用.NET
    Core的DI来完成这项工作）：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The detail of the `AddBook` and `UpdateQuantity` methods are shown in the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddBook`和`UpdateQuantity`方法的详细信息如下所示：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are a couple of things to note. The constructor has been changed from
    protected to public. This will allow the class to be instantiated by objects outside
    of the class. Also, note that the static `Instance` property and the private static
    `_instance` field have been removed, while the private `_lock` field remains.
    Similar to the Singleton pattern defined in the previous chapter, this only guarantees
    how the class is instantiated; it does not prevent methods from being accessed
    in parallel.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意。构造函数已被从受保护的改为公开的。这将允许类被类外部的对象实例化。此外，请注意，静态`Instance`属性和私有静态`_instance`字段已被移除，而私有`_lock`字段仍然保留。类似于前一章中定义的单例模式，这仅保证了类的实例化方式；它并不能防止方法并行访问。
- en: Both the `IInventoryContext` interface and the `InventoryContext` and `Book`
    classes were made public, as our DI is being defined in an external project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的依赖注入（DI）定义在外部项目中，因此`IInventoryContext`接口以及`InventoryContext`和`Book`类都被设置为公开。
- en: 'Subsequently, the `InventoryCommandFactory` class, which is used to return
    commands, has been updated to have an instance of the `InventoryContext` injected
    into its constructor:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，用于返回命令的`InventoryCommandFactory`类已被更新，以便在其构造函数中注入`InventoryContext`的实例：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `GetCommand` method uses the input provided to determine the specific command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCommand` 方法使用提供的输入来确定特定的命令：'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As noted, the `IInventoryContext` interface will now be supplied by the DI
    container that is defined in the client project. The console application now has
    an additional line to create a Singleton of the `IInventoryContext` interface
    using the `InventoryContext` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`IInventoryContext`接口将由客户端项目中定义的DI容器提供。控制台应用程序现在有一行额外的代码来创建`InventoryContext`类的单例：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The console application can now be run with the same manual test as that performed
    in the previous chapter, but unit tests are a great way to understand what is
    being achieved using .Net Core's DI.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序现在可以使用与上一章中执行的手动测试相同的测试运行，但单元测试是理解使用.NET Core的DI所实现的内容的绝佳方式。
- en: The example code provided for this chapter shows the completed project. The
    following section concentrates on the `InventoryContext` tests. The `InventoryCommandFactory`
    tests were also modified, but, as the changes are trivial, they will not be covered
    here.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的示例代码展示了完成的项目。接下来的部分将专注于对`InventoryContext`的测试。`InventoryCommandFactory`的测试也被修改了，但由于更改是微不足道的，所以这里不会涉及。
- en: Unit tests
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'With the changes to the `InventoryContext` class, we no longer have a convenient
    property for getting the only instance of the class. This means that `InventoryContext.Instance`
    will need to be replaced, and, as a first attempt, let''s create a method to return
    a new instance of `InventoryContext`, and use `GetInventoryContext()` instead
    of `InventoryContext.Instance`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对`InventoryContext`类的更改，我们不再有方便的属性来获取类的唯一实例。这意味着需要替换`InventoryContext.Instance`，作为一个初步尝试，让我们创建一个返回`InventoryContext`新实例的方法，并使用`GetInventoryContext()`代替`InventoryContext.Instance`：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As expected, the unit tests fail with an error message: *The given key was
    not present in the dictionary*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，单元测试失败，并显示错误消息：“给定的键不在字典中”：
- en: '![](img/270f856b-e1dc-475a-8a82-22e9288276cb.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/270f856b-e1dc-475a-8a82-22e9288276cb.png)'
- en: As we saw in the previous chapter, this is because the `InventoryContext` list
    of books is empty each time the `InventoryContext` class is created. This is why
    we need to create a context using a Singleton.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，这是因为每次创建`InventoryContext`类时，`InventoryContext`的书籍列表都是空的。这就是为什么我们需要使用单例创建上下文的原因。
- en: 'Let''s update the `GetInventoryContext()` method to now supply an instance
    of the `IInventoryContext` interface using .Net Core''s DI:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`GetInventoryContext()`方法，现在使用.NET Core的DI来提供一个`IInventoryContext`接口的实例：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the updated method, an instance of the `ServiceCollection` class is created,
    which will be used to contain all the registered dependencies. The `InventoryContext`
    class is registered as a Singleton to be supplied when the `IInventoryContext`
    dependency is requested. A `ServiceProvider` instance is then generated, which
    will actually perform the DI based on the registrations in the `IServiceCollection`
    interface. The final step is to supply the `InventoryContext` class when the `IInventoryContext`
    interface is requested.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新的方法中，创建了一个`ServiceCollection`类的实例，该实例将用于包含所有已注册的依赖项。`InventoryContext`类被注册为单例（Singleton），以便在请求`IInventoryContext`依赖项时提供。然后生成一个`ServiceProvider`实例，该实例将根据`IServiceCollection`接口中的注册执行实际的依赖注入（DI）。最后一步是在请求`IInventoryContext`接口时提供`InventoryContext`类。
- en: The `Microsoft.Extensions.DependencyInjection` library will need to be added
    to the `InventoryManagementTests` project in order to be able to reference the
    .Net Core DI components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够引用.NET Core的DI组件，需要将`Microsoft.Extensions.DependencyInjection`库添加到`InventoryManagementTests`项目中。
- en: 'Unfortunately, the unit test still does not pass, and results in the same error:
    *The given key was not present in the dictionary.* This is because we are creating
    a new instance of the DI framework each time `IInventoryContext` is requested.
    This means that even though our dependency is a Singleton, each instance of `ServiceProvider`
    will supply a new instance of the `InventoryContext` class. To get around this,
    we will create `IServiceCollection` when the test first starts up, and then we
    will use the same reference during the test:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，单元测试仍然没有通过，并导致相同的错误：*给定的键不在字典中*。这是因为每次请求`IInventoryContext`时，我们都在创建一个新的DI框架实例。这意味着尽管我们的依赖项是单例，但每个`ServiceProvider`实例都将提供`InventoryContext`类的新实例。为了解决这个问题，我们将在测试首次启动时创建`IServiceCollection`，然后在测试期间使用相同的引用：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the `TestInitialize` attribute is a great way to separate the functionality
    required by multiple `TestMethod` tests within a `TestClass` class. The method
    will be run before every test is run.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TestInitialize`属性是分离`TestClass`类中多个`TestMethod`测试所需功能的好方法。该方法将在每个测试运行之前执行。
- en: 'Now that there is a reference to the same `ServiceProvider` instance, we can
    update to retrieve the dependency. The following illustrates how the `AddBook()`
    method has been updated:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了对相同`ServiceProvider`实例的引用，我们可以更新以检索依赖项。以下说明了`AddBook()`方法是如何更新的：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our unit test now passes successfully, as only one instance of the `InventoryContext`
    class is created during the execution of the test:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试现在成功通过，因为在测试执行过程中只创建了一个`InventoryContext`类的实例：
- en: '![](img/1c92dd81-8d8c-466a-982e-ab7862dcab15.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c92dd81-8d8c-466a-982e-ab7862dcab15.png)'
- en: The Singleton pattern is relatively easy to implement using the built-in DI,
    as illustrated in this section. Understanding when to use the pattern is an important
    concept. The next section will explore the concept of scope in more detail, in
    order to gain a further understanding of service lifetimes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的DI实现单例模式相对简单，如本节所示。理解何时使用该模式是一个重要的概念。下一节将更详细地探讨范围的概念，以便进一步了解服务生命周期。
- en: Scope
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: In applications that have multiple processes executing simultaneously, understanding
    service lifetime is very important to both functional and non-functional requirements.
    As illustrated in the previous unit test without the correct service lifetime,
    `InventoryContext` did not function as desired, and led to an invalid situation.
    Likewise, the incorrect use of service lifetimes could lead to applications that
    do not scale well. In general, the use of a lock-and-shared state should be avoided
    in multi-process solutions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有多个同时执行进程的应用中，理解服务生命周期对于功能和非功能需求都非常重要。正如前一个单元测试所示，如果没有正确设置服务生命周期，`InventoryContext`
    没有按预期工作，并导致了一个无效的状态。同样，服务生命周期的错误使用可能导致扩展性不佳的应用。一般来说，在多进程解决方案中应避免使用锁和共享状态。
- en: To illustrate this concept, imagine the FlixOne inventory management application
    was supplied to multiple staff members. The challenge now is how to perform a
    lock across multiple applications, and how to have a single collected state. In
    our terms, this would be a single `InventoryContext` class shared by multiple
    applications. Of course, this is where changing our solution to use a shared repository
    (for example, a database) would make sense, and/or changing our solution to a
    web application. We will cover databases and web application patterns in later
    chapters, but, as we are discussing service lifetimes, it does make sense to describe
    these in terms of a web application in more detail now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，想象一下 FlixOne 库存管理应用被提供给多个员工。现在的挑战是如何在多个应用之间执行锁定，以及如何拥有一个单一收集的状态。用我们的术语来说，这将是多个应用共享的单个
    `InventoryContext` 类。当然，这就是为什么将我们的解决方案改为使用共享存储库（例如，数据库）或改为 Web 应用程序是有意义的，并且/或者现在详细描述这些内容在
    Web 应用程序中的意义。
- en: 'The following diagram depicts a web app receiving two requests:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了一个 Web 应用接收两个请求：
- en: '![](img/a28f0bf1-4c7f-43ab-9cc4-3de7694fdf4c.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a28f0bf1-4c7f-43ab-9cc4-3de7694fdf4c.png)'
- en: In terms of service lifetimes, a Singleton service lifetime will be available
    to both requests, while each request receives its own Scope lifetime. The important
    thing to note is around garbage collection. Dependencies that are created with
    a Transient service lifetime are marked to be released once the object is no longer
    referenced, while dependencies created with a Scope service lifetime are not marked
    to be released until the web request completes. And, dependencies created with
    a Singleton service lifetime are not marked to be released until the application
    ends.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务生命周期的方面，Singleton 服务生命周期将适用于所有请求，而每个请求都会收到它自己的作用域生命周期。需要注意的是，关于垃圾回收。使用 Transient
    服务生命周期创建的依赖项被标记为在对象不再被引用时释放，而使用 Scope 服务生命周期创建的依赖项则不会被标记为释放，直到 Web 请求完成。此外，使用
    Singleton 服务生命周期创建的依赖项则不会被标记为释放，直到应用程序结束。
- en: 'Also, as shown in the following diagram, it is important to remember that dependencies
    in .Net Core are not shared between server instances in a web garden or web farm:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如以下图示所示，重要的是要记住，.Net Core 中的依赖项在 Web 园或 Web 农场中的服务器实例之间不是共享的：
- en: '![](img/13d3bc5b-0273-488b-9db0-f87daf198604.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13d3bc5b-0273-488b-9db0-f87daf198604.png)'
- en: In the following chapters, different approaches to the shared state will be
    shown, including using a shared cache, databases, and other forms of repositories.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，将展示不同的共享状态方法，包括使用共享缓存、数据库和其他形式的存储库。
- en: Implementation factory
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现工厂
- en: 'The .Net Core DI supports the ability to specify an *implementation factory*
    when registering a dependency. This allows for control over the creation of the
    dependency that is supplied by the service provided. This is done when registering
    by using the following extension of the `IServiceCollection` interface:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: .Net Core DI 支持在注册依赖项时指定 *实现工厂* 的能力。这允许控制由服务提供者提供的依赖项的创建。这是通过使用 `IServiceCollection`
    接口的以下扩展来完成的：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `AddSingleton` extension receives both a class to be registered as well
    as the class to be supplied when the dependency is required. An interesting thing
    to note is the .Net Core DI framework will maintain the registered services and
    either deliver the implementation when requested, or as part of instantiating
    one of the dependencies. This automatic instantiation is called **constructor
    injection** (**CI**). We will see examples of both in the following sections.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSingleton`扩展接收要注册的类以及当需要依赖项时提供的类。值得注意的是，.Net Core DI框架将维护已注册的服务，并在请求时提供实现，或者作为实例化依赖项之一的部分。这种自动实例化被称为**构造函数注入**（**CI**）。我们将在接下来的章节中看到这两个示例。'
- en: IInventoryContext
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IInventoryContext
- en: 'As an example, let''s revisit the `InventoryContext` class that is used to
    manage the inventory of books, by segregating the read and the write operations
    performed on our collection of books. `IInventoryContext` is split into `IInventoryReadContext`
    and `IInventoryWriteContext`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回顾一下用于管理书籍库存的`InventoryContext`类，通过分离对我们的书籍集合执行的读取和写入操作。`IInventoryContext`被拆分为`IInventoryReadContext`和`IInventoryWriteContext`：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: IInventoryReadContext
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IInventoryReadContext
- en: The `IInventoryReadContext` interface contains the operation to read the books,
    while `IInventoryWriteContext` contains the operations that modify the collection
    of books. The original `IInventoryContext` interface was created for convenience
    for when a class requires both dependency types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`IInventoryReadContext`接口包含读取书籍的操作，而`IInventoryWriteContext`包含修改书籍集合的操作。原始的`IInventoryContext`接口是为了方便当某个类需要这两种依赖类型时创建的。'
- en: In later chapters, we will cover patterns that take advantage of splitting the
    context, including the **Command and** **Query Responsibility Segregation** (**CQRS**)
    pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将介绍利用分割上下文的优势的模式，包括**命令和查询责任分离**（**CQRS**）模式。
- en: 'With this refactor, some changes are required. First classes only requiring
    to read the collection of books have their constructor updated with the `IInventoryReadContext`
    interface, as illustrated in the `GetInventoryCommand` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次重构，需要进行一些更改。首先，仅需要读取书籍集合的类，其构造函数被更新为`IInventoryReadContext`接口，如`GetInventoryCommand`类所示：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: IInventoryWriteContext
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IInventoryWriteContext
- en: 'Likewise, classes requiring to modify the collection of books are updated to
    the `IInventoryWriteContext` interface, as illustrated with `AddInventoryCommand`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，需要修改书籍集合的类也被更新为`IInventoryWriteContext`接口，如`AddInventoryCommand`所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following shows the detail of the `GetParameters` and `InternalCommand`
    methods:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了`GetParameters`和`InternalCommand`方法的详细信息：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the `InternalCommand` method, where the book is added to the inventory
    with the given name of the book held in the `InventoryName` parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`InternalCommand`方法，其中通过`InventoryName`参数提供的书籍名称将书籍添加到库存中。
- en: Next, we will look at the factory for the inventory commands.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看库存命令的工厂。
- en: InventoryCommandFactory
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommandFactory
- en: 'The `InventoryCommandFactory` class is an implementation of the Factory pattern
    using .Net classes, which requires both readings of, and writing to, the collection
    of books:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactory`类是使用.Net类实现的工厂模式，它需要读取和写入书籍集合：'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An interesting thing to note, is that the class actually did not require modifying
    from the previous chapter's version, as polymorphism handles the casting from
    `IInventoryContext` to the `IInventoryReadContext` and `IInventoryWriteContext`
    interfaces.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，该类实际上并不需要从上一章的版本中进行修改，因为多态处理了从`IInventoryContext`到`IInventoryReadContext`和`IInventoryWriteContext`接口的转换。
- en: 'With these changes, we need to change the registration of the dependencies
    that are related to `InventoryContext`, in order to use an implementation factory:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些更改，我们需要更改与`InventoryContext`相关的依赖项的注册，以便使用实现工厂：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For all three interfaces, the same instance of `InventoryContext` will be used,
    and this is instantiated once using the implementation factory extension. This
    is supplied when a `IInventoryReadContext`, `IInventoryWriteContext`, or `IInventoryContext`
    dependency is requested.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这三个接口，将使用相同的`InventoryContext`实例，并且这个实例是通过实现工厂扩展一次性实例化的。当请求`IInventoryReadContext`、`IInventoryWriteContext`或`IInventoryContext`依赖项时，会提供这个实例。
- en: InventoryCommand
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommand
- en: '`InventoryCommandFactory` was useful to illustrate how the Factory pattern
    could be achieved using .Net, but let''s revisit this now that we are using the
    .Net Core framework. Our requirement is given a string value; we want to return
    a particular implementation of `InventoryCommand`. This can be achieved in several
    ways, and, in this section, three examples will be given:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactory` 有助于说明如何使用 .Net 实现工厂模式，但现在我们使用 .Net Core 框架，让我们重新审视这个问题。我们的需求是给定一个字符串值；我们希望返回
    `InventoryCommand` 的特定实现。这可以通过几种方式实现，在本节中，将给出三个示例：'
- en: Implementation factory using a function
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数实现的实现工厂
- en: Using services
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务
- en: Using third-party containers
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方容器
- en: Implementation factory using a function
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数实现的实现工厂
- en: 'The implementation factory of the `GetService()` method can be used to determine
    the type of `InventoryCommand` class to be returned. For this example, a new static
    method is created in the `InventoryCommand` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetService()` 方法的实现工厂可以用来确定要返回的 `InventoryCommand` 类型的类型。对于这个例子，在 `InventoryCommand`
    类中创建了一个新的静态方法：'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a little tricky to read if you are not familiar with lambda expression
    bodies, so we will explain the code in a bit of detail. First of all, let''s revisit
    the syntax of the `AddSingleton`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉 lambda 表达式体，这可能会有些难以阅读，所以我们将详细解释一下代码。首先，让我们回顾一下 `AddSingleton` 的语法：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This shows that the parameter of the `AddSingleton` extension is a function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `AddSingleton` 扩展方法的参数是一个函数：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This means that the following code is equivalent:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下代码是等价的：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `GetInventoryContext` method is defined as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInventoryContext` 方法定义如下：'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our particular example, the specific `InventoryCommand` types have been
    marked as internal to the `FlixOne.InventoryManagement` project, so the `FlixOne.InventoryManagementClient`
    project is not able to access them directly. This is why a new static method was
    created in the `FlixOne.InventoryManagement.InventoryCommand` class that returned
    the following type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定例子中，特定的 `InventoryCommand` 类型已被标记为 `FlixOne.InventoryManagement` 项目的内部类型，因此
    `FlixOne.InventoryManagementClient` 项目无法直接访问它们。这就是为什么在 `FlixOne.InventoryManagement.InventoryCommand`
    类中创建了一个新的静态方法，该方法返回以下类型：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What this means is, when the service is requested, a string will be supplied
    to determine the specific type. Because the dependency changed, this means the
    `CatalogService` constructor requires updating:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，当请求服务时，将提供一个字符串以确定特定类型。由于依赖项已更改，这意味着 `CatalogService` 构造函数需要更新：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the service is requested, a string will be supplied to determine the specific.
    Because the dependency changed, the `CatalogueService` constructor requires updating:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求服务时，将提供一个字符串以确定特定类型。由于依赖项已更改，`CatalogueService` 构造函数需要更新：
- en: 'Now when the string the user has entered is supplied to the `CommandFactory`
    dependency, the correct command is supplied:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当用户输入的字符串被提供给 `CommandFactory` 依赖项时，将提供正确的命令：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The unit tests associated with the command factory were also updated. As a
    comparison, a new `test` class was created from the existing `InventoryCommandFactoryTests`
    class, and named `InventoryCommandFunctionTests`. The initialization step is shown
    in the following code, with the changes highlighted:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令工厂相关的单元测试也进行了更新。作为比较，从现有的 `InventoryCommandFactoryTests` 类创建了一个新的 `test`
    类，并命名为 `InventoryCommandFunctionTests`。初始化步骤如下所示，其中变化被突出显示：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The individual tests were also updated to supply the string as part of the
    get service call, as shown in the following code with `QuitCommand`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 单个测试也被更新，以在获取服务调用中提供字符串，如下面的代码所示，使用 `QuitCommand`：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two tests verify that the services that are returned are of the `QuitCommand`
    type, when the service provider is given `"q"` or `"quit"`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试验证了当服务提供者被赋予 `"q"` 或 `"quit"` 时，返回的服务是 `QuitCommand` 类型。
- en: Using services
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务
- en: The `ServiceProvider` class provides a `Services` method that can be used to
    determine the appropriate service, when there are multiple dependencies registered
    for the same type. This example will take a different tack with `InventoryCommands`,
    and, because of the extent of the refactor, this will be done with new classes
    that will be created just to illustrate this approach.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当为同一类型注册了多个依赖项时，`ServiceProvider` 类提供了一个 `Services` 方法，可以用来确定适当的服务。本例将采用不同的方法处理
    `InventoryCommands`，由于重构的范围较大，这将通过创建新的类来实现，以展示这种方法。
- en: 'In the unit test project, a new folder, `ImplementationFactoryTests`, was created,
    to contain the classes for this section. In the folder, a new base class for `InventoryCommand`
    was created:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试项目中，创建了一个新的文件夹 `ImplementationFactoryTests`，用于包含本节中的类。在文件夹中，为 `InventoryCommand`
    创建了一个新的基类：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The concept behind this new class is that child classes will define the strings
    that they respond to. For example, `QuitCommand` will respond to the `"q"` and
    `"quit"` strings:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类背后的概念是子类将定义它们响应的字符串。例如，`QuitCommand` 将响应 `"q"` 和 `"quit"` 字符串：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following shows the `GetInventoryCommand`, `AddInventoryCommand`, `UpdateQuantityCommand`,
    and `HelpCommand` classes, which follow a similar approach:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了 `GetInventoryCommand`、`AddInventoryCommand`、`UpdateQuantityCommand` 和
    `HelpCommand` 类，它们遵循类似的方法：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `UnknownCommand` class, though, will be used as a default, so it will always
    evaluate to true, by overriding the `IsCommandFor` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `UnknownCommand` 类将被用作默认，但它将通过覆盖 `IsCommandFor` 方法始终评估为真：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Because the `UnknownCommand` class is being treated as a default, the order
    of registration is important, and is shown below in the initialization of the
    unit `test` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `UnknownCommand` 类被当作默认处理，注册顺序很重要，如下所示在单元测试类的初始化中：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For convenience, a new method has been created in order to return an instance
    of the `InventoryCommand` class when given a matching input string:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，已创建了一个新方法，以便在给定匹配的输入字符串时返回 `InventoryCommand` 类的实例：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method will traverse the collection of dependencies that are registered
    for the `InventoryCommand` service, until a match is found by using the `IsCommandFor()`
    method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将遍历为 `InventoryCommand` 服务注册的依赖项集合，直到使用 `IsCommandFor()` 方法找到匹配项。
- en: 'The unit test then uses the `GetCommand()` method to determine the dependency,
    as shown below for `UpdateQuantityCommand`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试随后使用 `GetCommand()` 方法来确定依赖关系，以下为 `UpdateQuantityCommand` 的示例：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using third-party containers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方容器
- en: The .Net Core framework provides great flexibility and functionality, but some
    features might not be supported, and a third-party container might be a more appropriate
    choice. Fortunately .Net Core is extensible and allows for the built-in service
    container to be replaced by a third-party container. To provide an example, we
    will use `Autofac` as our IoC container of the .Net Core DI.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: .Net Core 框架提供了极大的灵活性和功能性，但某些功能可能不受支持，第三方容器可能是一个更合适的选择。幸运的是，.Net Core 是可扩展的，允许用第三方容器替换内置的服务容器。为了提供一个示例，我们将使用
    `Autofac` 作为 .Net Core DI 的 IoC 容器：
- en: '`Autofac` has a ton of great features, and is shown here as an example; but
    of course, there are other IoC containers that could have been used. For example,
    Castle Windsor and Unit are great alternatives that should also be considered.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Autofac` 有许多出色的功能，这里作为一个示例；但当然，还有其他 IoC 容器可以使用。例如，Castle Windsor 和 Unit 是很好的替代品，也应予以考虑。'
- en: 'The first step is to add the required `Autofac` package to the project. Using
    the package manager console, add the package using the following command (only
    required on the test project):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将所需的 `Autofac` 包添加到项目中。使用包管理器控制台，使用以下命令添加包（仅在测试项目中需要）：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example will again support our `InventoryCommand` factory by using an `Autofac`
    feature of naming registered dependencies. These named dependencies will be used
    to retrieve the correct `InventoryCommand` instance, based on the supplied input.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将再次通过使用 `Autofac` 的命名注册依赖项功能来支持我们的 `InventoryCommand` 工厂。这些命名依赖项将被用于根据提供的输入检索正确的
    `InventoryCommand` 实例：
- en: 'Similar to the previous example, the registration of dependencies will be done
    in the `TestInitialize` method. The registrations will be named based on the command
    that will be used to determine the command. The following shows the `Startup`
    method structure that creates the `ContainerBuilder` object which will build the
    `Container` instance:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例类似，依赖项的注册将在 `TestInitialize` 方法中完成。注册将基于将用于确定命令的命令进行命名。以下展示了创建 `ContainerBuilder`
    对象的 `Startup` 方法结构，该对象将构建 `Container` 实例：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The commands are registered as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的注册方式如下：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unlike the previous example, the container that is generated is an instance
    of `Autofac.IContainer`. This will be used to retrieve each registered dependency.
    `QuitCommand`, for example, will be named both `"q"` and `"quit"`, which indicates
    the two commands that can be used to execute the command. Also, note the last
    registered type is not named, and belongs to `UnknownCommand`. This will act as
    a default if no command is found by name.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例不同，生成的容器是`Autofac.IContainer`的一个实例。这将用于检索每个已注册的依赖项。例如，`QuitCommand`将被命名为`"q"`和`"quit"`，这表示可以使用这两个命令来执行命令。此外，请注意最后一个注册的类型没有命名，属于`UnknownCommand`。如果没有找到按名称的命令，它将作为默认值。
- en: 'To determine a dependency, a new method will be used to retrieve the dependency
    by name:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定一个依赖项，将使用一个新的方法通过名称检索依赖项：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `Autofac.IContainer` interface has a `ResolveOptionalNamed<*T*>(*string*)`
    method name, which will return the dependency with the given name, or null, if
    no matching registrations are found. If the dependency is not registered with
    the given name, then an instance of the `UnknownCommand` class will be returned.
    This is done by using the null-coalescing operation, `??`, and the `IContainer.Resolve<*T*>`
    method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Autofac.IContainer`接口有一个名为`ResolveOptionalNamed<*T*>(*string*)`的方法，它将返回具有给定名称的依赖项，如果没有找到匹配的注册项，则返回null。如果依赖项没有使用给定的名称注册，则返回`UnknownCommand`类的实例。这是通过使用空合并操作`??`和`IContainer.Resolve<*T*>`方法实现的。'
- en: '`Autofac.IContainer.ResolveNamed<*T*>(*string*)` will throw a `ComponentNotRegisteredException`
    exception if the dependency resolution fails.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Autofac.IContainer.ResolveNamed<*T*>(*string*)`如果依赖解析失败，将抛出`ComponentNotRegisteredException`异常。'
- en: 'A test method is written for each command in order to ensure that the commands
    are resolved correctly. Again, using `QuitCommand` as an example, we can see the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个命令编写一个测试方法，以确保命令被正确解析。再次以`QuitCommand`为例，我们可以看到以下内容：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Please view the `InventoryCommandAutofacTests` class in the source for the other
    `InventoryCommand` examples.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请在源代码中查看`InventoryCommandAutofacTests`类以了解其他`InventoryCommand`示例。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The goal of this chapter was to explore the .Net Core framework in more detail,
    and, in particular, the .Net Core DI. Three types of service lifetimes are supported:
    Transient, Scoped, and Singleton. A Transient service will create a new instance
    of a registered dependency for each request. A Scoped service will be generated
    once with a defined scope, while a Singleton service will be performed once for
    the lifetime of the DI service collection.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是更详细地探讨.Net Core框架，特别是.Net Core DI。支持三种服务生命周期：Transient、Scoped和Singleton。Transient服务将为每个请求创建一个已注册依赖项的新实例。Scoped服务将根据定义的作用域生成一次，而Singleton服务将为DI服务集合的整个生命周期执行一次。
- en: As the .Net Core DI is central to confidently building .Net Core applications,
    it is important to understand its capabilities and its limitations. It is important
    to use the DI effectively, as well as to avoid duplicating functionality that
    is already supplied. Just as crucial, it is also wise to know the limits of the
    .Net Core DI framework, as well as the strengths of other DI frameworks, for situations
    where replacing the basic .Net Core DI framework with a third-party DI framework
    could be beneficial for an application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于.Net Core DI对于自信地构建.Net Core应用程序至关重要，因此了解其功能和限制非常重要。有效地使用DI以及避免重复已提供的功能同样重要。同样关键的是，了解.Net
    Core DI框架的局限性以及其他DI框架的优势也很明智，因为在某些情况下，用第三方DI框架替换基本的.Net Core DI框架可能对应用程序有益。
- en: The next chapter will build upon the previous chapters and explore, common patterns
    in .Net Core ASP.Net web applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在前几章的基础上构建，并探讨.Net Core ASP.Net web应用程序中的常见模式。
- en: Questions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章包含的信息：
- en: If you are not sure what type of service lifetime to use, which type is it best
    to register a class as? Why?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不确定要使用哪种服务生命周期，哪种类型最适合注册一个类？为什么？
- en: In .Net Core ASP.Net solutions, is a Scope defined per web request, or per session?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.Net Core ASP.Net解决方案中，Scope是按每个web请求定义，还是按每个会话定义？
- en: Does registering a class as a Singleton in the .Net Core DI framework make it
    thread-safe?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.Net Core DI框架中将一个类注册为Singleton是否使其线程安全？
- en: Is it true that the .Net Core DI framework can only be replaced with other Microsoft-supplied
    DI frameworks?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .Net Core DI框架只能用其他Microsoft提供的DI框架替换，这是真的吗？
