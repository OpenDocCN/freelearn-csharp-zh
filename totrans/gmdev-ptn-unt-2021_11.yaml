- en: Decoupling Components with the Observer Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: A common challenge in Unity development is to find elegant ways to decouple
    components from each other. It's a significant hurdle to overcome when writing
    code in the engine as it offers us so many ways to reference components through
    the API and the Inspector directly. But this flexibility can come with a price,
    and it can make your code fragile since, in some instances, it can take a single
    missing reference to break your game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: So, in this chapter, we will use the Observer pattern to set up relationships
    with core components. These relationships will be mapped by assigning objects
    the role of the Subject or Observer. This approach will not altogether remove
    coupling between our components but will loosen it up and organize it logically.
    It will also establish an event handling system with a one-to-many structure,
    which is precisely what we need to implement in the use case presented in this
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for a way to decouple objects from each other with events
    in a many-to-many relationship, please check out [Chapter 6](75ba1c8b-0c32-4001-ae33-d9d79e276408.xhtml), *Managing
    Game Events with the Event Bus*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Observer pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling core components with the Observer pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Observer pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [https://bit.ly/3xDlBDa](https://bit.ly/3xDlBDa).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Observer pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core purpose of the Observer pattern is to establish a one-to-many relationship
    between objects in which one acts as the subject while the others take the role
    of observers. The subject then assumes the responsibility of notifying the observers
    when something inside itself changes and might concern them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: It's somewhat similar to a publisher and subscriber relationship, in which objects
    subscribe and listen for specific event notifications. The core difference is
    that the subject and observers are aware of each other in the Observer pattern,
    so they are still lightly coupled together.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a UML diagram of a typical implementation of the Observer pattern
    to see how this might work when implemented in code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03b549cd-caed-4ef5-a6f2-951802a723de.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – UML diagram of the Observer pattern
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the Subject and the Observer both have respective interfaces
    that they implement, but the most important one to analyze is `ISubject`, which
    includes the following methods:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`AttachObserver()`: This method allows you to add an observer object to the
    list of observers to notify.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DetachObserver()`: This method removes an observer from the list of observers.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotifyObservers()`: This method notifies all the objects that have been added
    to the subject''s list of observers.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object that takes the role of Observer must implement a public method called
    `Notify()`, which will be used by the subject to notify it when it changes states.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks of the Observer pattern
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are some of the benefits of the Observer pattern:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamism**: The Observer permits the Subject to add as many objects as it
    necessitates as Observers. But it can also remove them dynamically at runtime.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-to-Many**: The main benefit of the Observer pattern is that it elegantly
    solves the problem of implementing an event handling system in which there''s
    a one-to-many relationship between objects.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some potential drawbacks of the Observer pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Disorder**: The Observer pattern doesn''t guarantee the order in which Observers
    get notified. So, if two or more Observer objects share dependencies and must
    work together in a specific sequence, the Observer pattern, in its native form,
    is not designed to handle that type of execution context.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaking**:The Observer can cause memory leaks as the subject holds strong
    references to its observers. If it''s implemented incorrectly and the Observer
    objects are not correctly detached and disposed of when they are not needed anymore,
    it could cause issues with garbage collection, and some resources will not be
    liberated.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand the potential memory leaking drawback indicated here, I recommend
    reading the following Wikipedia article on the subject matter: [https://en.wikipedia.org/wiki/Lapsed_listener_problem](https://en.wikipedia.org/wiki/Lapsed_listener_problem).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: But take into account that, like anything related to optimization, it's contextual,
    so you should profile your code before optimizing for potential performance issues.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Observer pattern
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The advantage of the Observer pattern is that it solves specific problems related
    to one-to-many relationships between objects. So, if you have a core component
    that often changes states and has many dependencies that need to react to those
    changes, then the Observer pattern permits you to define a relationship between
    those entities and a mechanism that enables them to be notified.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you are unsure when to use the Observer pattern, you should analyze
    the relationship between your objects to determine if this pattern is well-suited
    for the problem you are trying to solve.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling core components with the Observer pattern
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core ingredient of our game is the racing bike. It's the entity in our scene
    that changes states and updates its properties the most often as it's under the
    player's control while traveling around the world and interacting with other entities.
    It has several dependencies to manage, such as the main camera that follows it
    and the HUD that displays its current speed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The racing bike is the main subject of our game, and many systems must observe
    it so that they can update themselves when it changes states. For instance, every
    time the bike collides with an obstacle, the HUD must update the current value
    of the shield's health, and the camera displays a full screen shader that darkens
    the edges of the screen to showcase the diminishing endurance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: This type of behavior is easy to implement in Unity. We could have `BikeController`
    tell `HUDController` and `CameraController` what to do when it takes damage. But
    for this approach to work, `BikeController` must be aware of the public methods
    to call on each controller.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, this doesn't scale well since as the complexity of `BikeController`
    grows, the more calls to its dependencies we will have to manage. But with the
    Observer pattern, we are going to break this coupling between the controllers.
    First, we will give each component a role; `BikeController` will become a subject
    and be responsible for managing a list of dependencies and notifying them when
    necessary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The HUD and Camera controllers will act as observers of `BikeController`. Their
    core responsibility will be to listen for notifications coming from `BikeController`
    and act accordingly. `BikeController` doesn't tell them what to do; it just tells
    them something has changed and lets them react to it at their discretion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the concept we just reviewed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da2d43e3-3686-46c3-aafa-57d46f4aaa09.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Illustration of the controllers observing a subject
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we can have as many controllers observing the bike (subject)
    as we need. In the next section, we will take these concepts and translate them
    into code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Observer pattern
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s implement the Observer pattern in a simple way that can be reused
    in various contexts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start this code example by implementing the two elements of
    the pattern. Let''s begin with the `Subject` class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Subject` abstract class has three methods. The first two, `Attach()` and
    `Detach()`, are responsible for adding or removing an observer object from a list
    of observers, respectively. The third method, `NotifyObservers()` has the responsibility
    of looping through the list of observer objects and calling their public method,
    called `Notify()`. This will make sense when we implement concrete observer classes
    in the upcoming steps.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `Observer` abstract class:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Classes that wish to become observers have to inherit this `Observer` class
    and implement the abstract method named `Notify()`, which receives the subject
    as a parameter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our core ingredients, let''s write a skeleton `BikeController`
    class that will act as our subject. However, because it''s so long, we will split
    it into three segments. The first segment is just initialization code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following segment is important because we are attaching our observers when
    `BikeController` is enabled but also detaching them when it''s disabled; this
    avoids us having to hold on to references we don''t need anymore:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And for the final part, we have some basic implementations of core behaviors.
    Note that we only notify the observers when the bike''s parameters get updated
    when it takes damage, or when its turbocharger is activated:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`BikeController` never calls `HUDController` or `CameraController` directly;
    it only notifies them that something has changed – it never tells them what to
    do. This is important because the observers can independently choose how to behave
    when being notified.  Therefore, they have been decoupled from the subject to
    a certain degree.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement some observers and see how they behave when the subject
    signals them. We''ll begin with `HUDController`, which has the responsibility
    of displaying the user interface:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Notify()` method of `HUDController` receives a reference to the subject
    that notified it. Therefore, it can access its properties and choose which one
    to display in the interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we are going to implement `CameraController`. The expected behavior
    of the camera is to start shaking when the turbo booster of the bike is activated:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`CameraController` checks the public Boolean property of the subject that just
    notified it and if it''s true, it starts shaking the camera until it gets notified
    again by `BikeController` and confirms that the turbo toggle is off.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway of this implementation to keep in mind is that `BikeController`
    (**subject**) is not aware of how the HUD and Camera controller (**observers**)
    will behave once they are notified. Hence, it's at the discretion of the observers
    to choose how they will react as the subject alerts them of a change.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: This approach decouples these controller components from each other. Therefore,
    it's way easier to implement and debug them individually.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Observer pattern implementation
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test our implementation, we have to do the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Open an empty Unity scene but make sure it includes at least one camera and
    one light.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a 3D GameObject, such as a cube, to the scene and make it visible to the
    camera.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the `BikeController` script as a component to the new 3D object.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the `CameraController` script to the main scene camera.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an empty GameObject, add the following `ClientObserver` script to it,
    and then start the scene:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We should see GUI buttons and labels on the screen, similar to the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/168bc28d-38b6-45bb-b13c-e144af66e6ba.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The GUI elements in a running Unity scene
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: If we press the Toggle Turbo button, we will see the camera shake and the HUD
    display the status of the turbo booster.  The Damage Bike button will reduce the
    health of the bike.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways you can implement the Observer pattern, each with
    its intrinsic benefits. I can't cover them all in this chapter. Due to this, I
    wrote the code example in this chapter for educational purposes in mind. Hence,
    it's not the most optimized approach but one that's easy to understand.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实现观察者模式有许多不同的方法，每种方法都有其固有的优点。我无法在本章中涵盖所有这些方法。因此，出于教育目的，我编写了本章中的代码示例。因此，这并不是最优化方法，但是一种易于理解的方法。
- en: Reviewing alternative solutions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查替代解决方案
- en: An alternative to the Observer pattern is the native C# event system. One of
    the significant advantages of this event system is that it's more granular than
    the Observer pattern because objects can listen to specific events that another
    emits, instead of getting a general notification from a subject.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式的替代方案是本地的 C# 事件系统。这个事件系统的一个显著优点是它比观察者模式更细粒度，因为对象可以监听另一个对象发出的特定事件，而不是从主体获得一般通知。
- en: A native event system should always be considered if you need to have components
    interact through events, especially if you don't need to establish a specific
    relationship between them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要组件通过事件进行交互，尤其是如果您不需要在它们之间建立特定关系时，应始终考虑使用本地事件系统。
- en: Unity has its own native event system; it's very similar to the C# version but
    with added engine features, such as the ability to wire events and actions through
    the Inspector. To learn more, go to [https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html](https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 有自己的本地事件系统；它与 C# 版本非常相似，但增加了引擎功能，例如通过检查器连接事件和动作的能力。要了解更多信息，请访问 [https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html](https://docs.unity3d.com/2021.2/Documentation/Manual/UnityEvents.html)。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the Observer pattern to decouple `BikeController`
    from its dependencies by assigning them the roles of subject or observer. Our
    code is now easier to manage and extend as we can easily have `BikeController`
    interact with other controllers with minimal coupling.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过将它们分配为主体或观察者的角色来使用观察者模式将`BikeController`与其依赖项解耦。现在我们的代码更容易管理和扩展，因为我们能够轻松地将`BikeController`与其他控制器进行交互，而耦合度最小。
- en: In the next chapter, we will explore the Visitor pattern, one of the most challenging
    patterns to learn. We will use it to build power-ups, a core mechanic and ingredient
    of our game.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨访问者模式，这是最难学习的一种模式。我们将使用它来构建增强功能，这是我们游戏的核心机制和成分。
