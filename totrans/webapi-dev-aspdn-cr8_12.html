<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-251"><a id="_idTextAnchor484"/>12</h1>
<h1 id="_idParaDest-252"><a id="_idTextAnchor485"/>Getting Started with GraphQL</h1>
<p>In <a href="B18971_11.xhtml#_idTextAnchor438"><em class="italic">Chapter 11</em></a>, we explored how to create a gRPC service in ASP.NET Core. gRPC is a high-performance RPC framework that facilitates communication between services. We discussed the field types used in protobuf messages, and how to define four types of gRPC services: unary, server streaming, client streaming, and bidirectional streaming. Additionally, we learned how to configure gRPC services in ASP.NET Core and how to call gRPC services from a client application.</p>
<p>Next, we will explore another shape of web APIs: GraphQL. GraphQL is a query-based API that allows clients to specify the data they need, which solves the problem of over-fetching and under-fetching data. Besides, GraphQL supports <strong class="bold">mutations</strong>, which allow clients to <a id="_idIndexMarker1194"/>modify data. In this chapter, we will learn about some basic concepts of GraphQL and how to create a GraphQL API in ASP.NET Core. We will cover the following topics in this chapter:</p>
<ul>
<li>Recap of GraphQL</li>
<li>Setting up a GraphQL API using HotChocolate</li>
<li>Adding mutations</li>
<li>Using variables in queries</li>
<li>Defining a GraphQL schema</li>
<li>Retrieving related objects using resolvers</li>
<li>Using data loaders</li>
<li>Dependency injection</li>
<li>Interfaces and union types</li>
<li>Filtering, sorting, and paging</li>
<li>Visualizing the GraphQL schema</li>
</ul>
<p>After reading this chapter, you will be able to understand the basic concepts of GraphQL and how to create a GraphQL API in ASP.NET Core. You will also learn how to use Apollo Federation to build a microservices-based GraphQL API.<a id="_idTextAnchor486"/></p>
<h1 id="_idParaDest-253"><a id="_idTextAnchor487"/>Technical requirements</h1>
<p>The code examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12</a>. You can use VS 2022 or VS Code to open the solutions.<a id="_idTextAnchor488"/></p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor489"/>Recap of GraphQL</h1>
<p>GraphQL <a id="_idIndexMarker1195"/>offers a flexible way to query and mutate data. The main difference between GraphQL and REST is that GraphQL allows clients to specify the data they need, whereas REST APIs return a fixed set of data. GraphQL treats data as a graph, and it uses a query language to define the shape of the data. This addresses the issues of over-fetching and under-fetching data by enabling clients to specify their data requirements. Additionally, it supports mutations, empowering clients to modify data as needed.</p>
<p>While REST APIs have multiple endpoints for different resources, GraphQL is typically served over a single endpoint, usually <code>/graphql</code>, which exposes a schema that describes the data. All queries and mutations are sent to this endpoint. The schema is defined using a GraphQL Schema Definition Language, which is the contract between the client and the server. The schema defines the types of data and the operations that can be performed on the data. The client can use the schema to validate the query and mutation requests.</p>
<p>GraphQL can solve the problem of over-fetching and under-fetching data for clients. However, the backend development is more complex than REST APIs. GraphQL uses resolvers to fetch data from different levels of the graph. If the implementation of the resolvers is not efficient, it can lead to performance issues. GraphQL also has a steep learning curve for developers who are not familiar with it.</p>
<p>ASP.NET Core does not have built-in support for GraphQL. However, several third-party libraries can be used to create GraphQL APIs:</p>
<ul>
<li><strong class="bold">HotChocolate</strong>: HotChocolate is<a id="_idIndexMarker1196"/> an open-source GraphQL server for .NET. It is built on top of ASP.NET Core and supports the newest GraphQL October 2021 specification. It is supported by ChilliCream, a company that provides GraphQL tooling and consulting services. ChilliCream also provides other products, such as Banana Cake Pop, which is a GraphQL IDE to create and test GraphQL queries, and Strawberry Shake, which is a GraphQL client library for .NET. You can find more<a id="_idIndexMarker1197"/> information about HotChocolate at <a href="https://chillicream.com/docs/hotchocolate/">https://chillicream.com/docs/hotchocolate/</a>.</li>
<li><strong class="bold">GraphQL.NET</strong>: GraphQL.NET is<a id="_idIndexMarker1198"/> another open-source GraphQL implementation for .NET. It provides a set of libraries that can be used to create GraphQL APIs and clients. You <a id="_idIndexMarker1199"/>can find more information about GraphQL.NET at <a href="https://graphql-dotnet.github.io/">https://graphql-dotnet.github.io/</a>.</li>
</ul>
<p>In this chapter, we will use HotChocolate to create a GraphQL API in ASP.NET <a id="_idTextAnchor490"/>Core.</p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor491"/>Setting up a GraphQL API using HotChocolate</h1>
<p>To begin<a id="_idIndexMarker1200"/> with, you can download the code example named <code>SchoolManagement</code> for this chapter from the <code>chapter12\start</code> folder. This sample project has some basic code for an <code>AppDbContext</code> class and a <code>Teacher</code> class, as well as some seed data. The <code>Teacher</code> class has<a id="_idIndexMarker1201"/> the following properties:</p>
<pre class="source-code">
public class Teacher{
    public Guid Id { get; set; }
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string? Phone { get; set; }
    public string? Bio { get; set; }
}</pre>
<p>You can open the project in VS Code or VS 2022. We will integrate <code>HotChocolate</code> into the project <a id="_idIndexMarker1202"/>to create a GraphQL API following <a id="_idIndexMarker1203"/>these steps:</p>
<ol>
<li>Add the <code>HotChocolate.AspNetCore</code> NuGet package to the project. This package contains the ASP.NET Core integration for HotChocolate. It also contains the GraphQL IDE, which is a GraphQL client that can be used to create and test GraphQL queries. You can use the following command to add the package to the project:<pre class="source-code">
<code>Query</code>, in the <code>GraphQL/Queries</code> folder, as shown here:<pre class="source-code">
public class Query{    public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachers([Service] AppDbContext context) =&gt;        await context.Teachers.ToListAsync();}</pre><p class="list-inset">The <code>Query</code> class will be used to define the queries that can be executed by the client. It has one method named <code>GetTeachers()</code>, which returns a list of teachers.</p></li> <li>Then, we need to register the query root type in the <code>Program.cs</code> file. Add the following code after the <code>AddDbContext()</code> method:<pre class="source-code">
<code>Query</code> type to the schema.</p></li> <li>Next, we <a id="_idIndexMarker1204"/>need to map the GraphQL <a id="_idIndexMarker1205"/>endpoint to expose the GraphQL schema. Add the following code to the <code>Program.cs</code> file:<pre class="source-code">
<code>/</code><code>graphql</code> URL.</p></li> <li>Run the project using <code>dotnet run</code> and open the GraphQL IDE at <code>https://localhost:7208/graphql/</code>. You should see the following screen:</li>
</ol>
<div><div><img alt="Figure 12.1 – The Banana Cake Pop GraphQL IDE" src="img/B18971_12_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The Banana Cake Pop GraphQL IDE</p>
<p class="list-inset">The GraphQL IDE allows you to create and test GraphQL queries.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The default launch URL is <code>swagger</code> for ASP.NET Core web API projects. You can change the launch URL in the <code>launchSettings.json</code> file to <code>graphql</code> to open the GraphQL IDE directly.</p>
<ol>
<li value="6">Click the <strong class="bold">Browse Schema</strong> button, then click the <strong class="bold">Schema Definition</strong> tab to view the <a id="_idIndexMarker1206"/>GraphQL schema. You <a id="_idIndexMarker1207"/>should see the following schema:<pre class="source-code">
type Query {  teachers: [Teacher!]!}type Teacher {  id: UUID!  firstName: String!  lastName: String!  email: String!  phone: String  bio: String}</pre><p class="list-inset">The preceding schema defines a query root type, <code>Query</code>, and a <code>Teacher</code> type. The <code>Query</code> type has one field named <code>teachers</code>, which returns a <code>[Teacher!]! </code>object. GraphQL uses <code>!</code> to indicate that the field is non-nullable. By default, all fields are nullable. <code>[Teacher!]!</code> means that this field is a non-nullable array of non-nullable <code>Teacher</code> objects. When there is no data, the field will return an empty array.</p><p class="list-inset">The <code>Teacher</code> type has a few fields: <code>id</code>, <code>firstName</code>, <code>lastName</code>, <code>email</code>, <code>phone</code>, and <code>bio</code>. The <code>id</code> field is of the <code>UUID</code> type, which is a scalar type that represents <a id="_idIndexMarker1208"/>a 128-bit <code>firstName</code>, <code>lastName</code>, <code>email</code>, <code>phone</code>, and <code>bio</code> fields are of the <code>String</code> type. The client can specify which fields to be returned in the query.</p></li> <li>Let us try<a id="_idIndexMarker1209"/> to query the data. Click the <strong class="bold">Create Document</strong> button to create a new query. You can use the following <a id="_idIndexMarker1210"/>query to get all teachers:<pre class="source-code">
query {    teachers {        id        firstName        lastName        email        phone        bio    }}</pre><p class="list-inset">The preceding query will return all teachers in the database, as follows:</p></li> </ol>
<div><div><img alt="Figure 12.2 – Querying all teachers" src="img/B18971_12_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Querying all teachers</p>
<ol>
<li value="8">You <a id="_idIndexMarker1211"/>can add or remove fields in the<a id="_idIndexMarker1212"/> query to specify the data to be returned. For example, to show a list of teachers on a web page, we do not need to return the <code>id</code> field and the <code>bio</code> field. We can remove the <code>bio</code> field from the query as follows:<pre class="source-code">
query {    teachers {        firstName        lastName        email        phone    }}</pre><p class="list-inset">The preceding query will return those four fields only, which reduces the payload size.</p></li> </ol>
<p>So far, we have created a GraphQL API using HotChocolate. We have also learned how to query data using GraphQL queries. Next, we will learn how to modify data <a id="_idTextAnchor492"/>using mutations.</p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor493"/>Adding mutations</h1>
<p>In the previous section, we <a id="_idIndexMarker1213"/>learned how to create a GraphQL API using HotChocolate. We added a query root type to query data. In this section, we will discuss how to modify data using mutations.</p>
<p>Mutations are used to modify data in GraphQL. A mutation consists of three parts:</p>
<ul>
<li><code>Input</code> suffix following the convention, such as <code>AddTeacherInput</code>.</li>
<li><code>Payload</code> suffix following the convention, such as <code>AddTeacherPayload</code>.</li>
<li><code>AddTeacherAsync</code>.</li>
</ul>
<p>Let us add a<a id="_idIndexMarker1216"/> mutation to create a new teacher. We will use the following steps:</p>
<ol>
<li>Create an <code>AddTeacherInput</code> class in the <code>GraphQL/Mutations</code> folder, as shown here:<pre class="source-code">
public record AddTeacherInput(    string FirstName,    string LastName,    string Email,    string? Phone,    string? Bio);</pre><p class="list-inset">The <code>AddTeacherInput</code> class is a record type that defines the input data for the <code>AddTeacherAsync</code> mutation. The <code>Id</code> property is not included in the input data because it will be generated by the code.</p></li> <li>Add <a id="_idIndexMarker1217"/>an <code>AddTeacherPayload</code> class in the <code>GraphQL/Mutations</code> folder, as follows:<pre class="source-code">
public class AddTeacherPayload{    public Teacher Teacher { get; }    public AddTeacherPayload(Teacher teacher)    {        Teacher = teacher;    }}</pre><p class="list-inset">The <code>AddTeacherPayload</code> class defines the data that will be returned after the mutation is executed. It has a <code>Teacher</code> property of the <code>Teacher</code> type.</p></li> <li>Next, we need to add the actual mutation to execute the operation. Add the <code>Mutation</code> class to the <code>GraphQL/Mutations</code> folder, as shown here:<pre class="source-code">
public class Mutation{    public async Task&lt;AddTeacherPayload&gt; AddTeacherAsync(        AddTeacherInput input,        [Service] AppDbContext context)    {        var teacher = new Teacher        {            Id = Guid.NewGuid(),            FirstName = input.FirstName,            LastName = input.LastName,            Email = input.Email,            Phone = input.Phone,            Bio = input.Bio        };        context.Teachers.Add(teacher);        await context.SaveChangesAsync();        return new AddTeacherPayload(teacher);    }}</pre><p class="list-inset">The <code>Mutation</code> class<a id="_idIndexMarker1218"/> has one method named <code>AddTeacherAsync</code>, which takes an <code>AddTeacherInput</code> object as the input data and returns an <code>AddTeacherPayload</code> object. The <code>AddTeacherAsync()</code> method creates a new <code>Teacher</code> object and adds it to the database. Then, it returns an <code>AddTeacherPayload</code> object that contains the newly created <code>Teacher</code> object.</p></li> <li>Next, we need to register the mutation in the <code>Program.cs</code> file. Add the <code>AddMutationType</code> method after the <code>AddQueryType()</code> method, as follows:<pre class="source-code">
builder.Services    .AddGraphQLServer()    .AddQueryType&lt;Query&gt;()    .AddMutationType&lt;Mutation&gt;();</pre></li> <li>Run the project using <code>dotnet run</code> and open the GraphQL IDE. Check the schema<a id="_idIndexMarker1219"/> definition and you should see the following mutation:<pre class="source-code">
type Mutation {  addTeacher(input: AddTeacherInput!): AddTeacherPayload!}input AddTeacherInput {  firstName: String!  lastName: String!  email: String!  phone: String  bio: String}type AddTeacherPayload {  teacher: Teacher!}</pre><p class="list-inset">The preceding schema defines a mutation named <code>addTeacher</code>, which reflects the types and methods we defined in the <code>Mutation</code> class. Note that the <code>AddTeacherInput</code> type is an input type, so it uses the <code>input</code> keyword instead of <code>type</code>.</p></li> <li>Click the <strong class="bold">Create Document</strong> button to create a new query. You can use the following mutation to create a new teacher:<pre class="source-code">
mutation addTeacher {  addTeacher(    input: {      firstName: "John"      lastName: "Smith"      email: "john.smith@sampleschool.com"      phone: "1234567890"      bio: "John Smith is a math teacher."    }  ) {    teacher {      id    }  }}</pre><p class="list-inset">The <a id="_idIndexMarker1220"/>preceding mutation will create a new teacher and return the <code>id</code> property of the newly created teacher, as follows:</p></li> </ol>
<div><div><img alt="Figure 12.3 – Creating a new teacher" src="img/B18971_12_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Creating a new teacher</p>
<p>Then, you can <a id="_idIndexMarker1221"/>query the data to verify that the new teacher has bee<a id="_idTextAnchor494"/>n added to the database.</p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor495"/>Using variables in queries</h1>
<p>In the<a id="_idIndexMarker1222"/> previous section, we learned how to query data and modify data using GraphQL queries and mutations. In this section, we will discuss how to use variables in queries.</p>
<p>GraphQL allows<a id="_idIndexMarker1223"/> you to use variables in queries. This is useful when you want to pass parameters to the query. We can create a query that accepts an <code>id</code> parameter and returns the teacher with the specified ID. Follow these steps to create the query:</p>
<ol>
<li>Add a <code>GetTeacher()</code> method in the <code>Query</code> class, as follows:<pre class="source-code">
public async Task&lt;Teacher?&gt; GetTeacher(Guid id, [Service] AppDbContext context) =&gt;    await context.Teachers.FindAsync(id);</pre><p class="list-inset">The preceding code adds a <code>GetTeacher()</code> method to the <code>Query</code> class. It takes an <code>id</code> parameter and returns the teacher with the specified ID.</p></li> <li>Now, you <a id="_idIndexMarker1224"/>can use the <code>$</code> sign to define a variable in the query. For example, you can use the following query to get a teacher by ID:<pre class="source-code">
query getTeacher($id: UUID!) {  teacher(id: $id) {    id    firstName    lastName    email    phone  }}</pre><p class="list-inset">The<a id="_idIndexMarker1225"/> preceding query defines a variable named <code>id</code> of the <code>UUID!</code> type. The <code>!</code> sign indicates that the variable is non-nullable. The <code>teacher</code> field takes the <code>id</code> variable as the parameter and returns the teacher with the specified ID. In the <code>id</code> variable to pass the value to the query, as follows:</p><pre class="source-code">{  "id": "00000000-0000-0000-0000-000000000401"}</pre></li> </ol>
<p>You can define multiple variables in the query. Note that variables must be scalars, e<a id="_idTextAnchor496"/>nums, or input object types.</p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor497"/>Defining a GraphQL schema</h1>
<p>Usually, a <a id="_idIndexMarker1226"/>system has multiple types of data. For example, a school management system has teachers, students, departments, and courses. A department has multiple courses, and a course has multiple students. A teacher can teach multiple courses, and a course can be taught by multiple teachers as well. In this section, we will discuss how to define a GraphQL schema<a id="_idTextAnchor498"/> with multiple types of data.</p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor499"/>Scalar types</h2>
<p>Scalar types <a id="_idIndexMarker1227"/>are<a id="_idIndexMarker1228"/> the primitive types in GraphQL. The following table lists the scalar types in GraphQL:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-9">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Scalar type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">.</strong><strong class="bold">NET type</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Int</code></p>
</td>
<td class="No-Table-Style">
<p>Signed 32-bit integer</p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Float</code></p>
</td>
<td class="No-Table-Style">
<p>Signed double-precision floating-point value specified in IEEE 754</p>
</td>
<td class="No-Table-Style">
<p><code>float</code> or <code>double</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>String</code></p>
</td>
<td class="No-Table-Style">
<p>UTF‐8 character sequence</p>
</td>
<td class="No-Table-Style">
<p><code>string</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Boolean</code></p>
</td>
<td class="No-Table-Style">
<p><code>true</code> or <code>false</code></p>
</td>
<td class="No-Table-Style">
<p><code>bool</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ID</code></p>
</td>
<td class="No-Table-Style">
<p>A unique identifier, serialized as a string</p>
</td>
<td class="No-Table-Style">
<p><code>string</code></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1 – Scalar types in GraphQL</p>
<p>Besides the preceding scalar types, <code>HotChocolate</code> also supports the following scalar types:</p>
<ul>
<li><code>Byte</code>: Unsigned 8-bit integer</li>
<li><code>ByteArray</code>: Byte array that is encoded as a Base64 string</li>
<li><code>Short</code>: Signed 16-bit integer</li>
<li><code>Long</code>: Signed 64-bit integer</li>
<li><code>Decimal</code>: Signed decimal value</li>
<li><code>Date</code>: ISO-8601 date</li>
<li><code>TimeSpan</code>: ISO-8601 time duration</li>
<li><code>DateTime</code>: A custom GraphQL scalar defined by the community at <a href="https://www.graphql-scalars.com/">https://www.graphql-scalars.com/</a>. It is based on RFC3339. Note that this <code>DateTime</code> scalar uses an offset to UTC instead of a time zone</li>
<li><code>Url</code>: URL</li>
<li><code>Uuid</code>: GUID</li>
<li><code>Any</code>: A special type that is used to represent any literal or output type</li>
</ul>
<p>There are<a id="_idIndexMarker1229"/> more <a id="_idIndexMarker1230"/>scalar types that are not listed here. You can find more information about the scalar types at <a href="https://chillicream.com/docs/hotchocolate/v13/defining-a-schema/scalars">https://chillicream.com/docs/hotchocolate/v13/defining-a-schema/scalars</a>.</p>
<p>GraphQL supports enumerations as well. Enumeration types in GraphQL are a special kind of scalar type. They are used to represent a fixed set of values. .NET supports enumeratiopn types very well so that you can use the .NET <code>enum</code> type directly in GraphQL. You can define an enumeration type as follows:</p>
<pre class="source-code">
public enum CourseType{
    Core,
    Elective,
    Lab
}</pre>
<p>The preceding code defines an enumeration type named <code>CourseType</code> with three values: <code>Core</code>, <code>Elective</code>, and <code>Lab</code>. The generated GraphQL schema is as follows:</p>
<pre class="source-code">
enum CourseType {  CORE
  ELECTIVE
  LAB
}</pre>
<p>HotChocolate <a id="_idIndexMarker1231"/>automatically converts the enumeration values to uppercase according to the GraphQL specificatio<a id="_idTextAnchor500"/>n.</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor501"/>Object types</h2>
<p>The<a id="_idIndexMarker1232"/> object type is the most common type in GraphQL. It <a id="_idIndexMarker1233"/>can contain simple scalar types such as <code>Int</code>, <code>String</code>, and <code>Boolean</code>, as well as other object types. For example, a <code>Teacher</code> type can contain the <code>Department</code> type, as shown here:</p>
<pre class="source-code">
public class Teacher{
    public Guid Id { get; set; }
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public Guid DepartmentId { get; set; }
    public Department Department { get; set; } = default!;
}
public class Department
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    // other properties
}</pre>
<p>The preceding code defines a <code>Teacher</code> type and a <code>Department</code> type. The <code>Teacher</code> type has a <code>Department</code> property of the <code>Department</code> type. HotChocolate will generate <a id="_idIndexMarker1234"/>the schema as follows:</p>
<pre class="source-code">
type Teacher {  id: UUID!
  firstName: String!
  lastName: String!
  departmentId: UUID!
  department: Department!
}
type Department {
  id: UUID!
  name: String!
  description: String
}</pre>
<p>As we <a id="_idIndexMarker1235"/>mentioned in the previous section, all the fields in GraphQL are nullable by default. If we want to make a field non-nullable, we can use the <code>!</code> sign.</p>
<p>The object type can contain a list of other object types. For example, a <code>Department</code> type can contain a list of <code>Teacher</code> objects, as shown here:</p>
<pre class="source-code">
public class Department{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public List&lt;Teacher&gt; Teachers { get; set; } = new();
}</pre>
<p>The generated schema is as follows:</p>
<pre class="source-code">
type Department {  id: UUID!
  name: String!
  description: String
  teachers: [Teacher!]!
}</pre>
<p>The <code>teachers</code> field<a id="_idIndexMarker1236"/> is a non-nullable array of non-nullable <code>Teacher</code> objects. If we want to make the <code>teachers</code> field nullable, we can <a id="_idIndexMarker1237"/>use the <code>?</code> sign as follows:</p>
<pre class="source-code">
public class Department{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public List&lt;Teacher&gt;? Teachers { get; set; }
}</pre>
<p>The generated schema is as follows:</p>
<pre class="source-code">
type Department {  id: UUID!
  name: String!
  description: String
  teachers: [Teacher!]
}</pre>
<p>The preceding schema means that the <code>teachers</code> field is a nullable array of non-nullable <code>Teacher</code> objects. When there is no data, the <code>teachers</code> field will return <code>null</code>.</p>
<p>Let's look<a id="_idIndexMarker1238"/> back at the <code>Query</code> type and the <code>Mutation</code> type we defined in the previous sections:</p>
<pre class="source-code">
type Query {  teachers: [Teacher!]!
  teacher(id: UUID!): Teacher
}
type Mutation {
  addTeacher(input: AddTeacherInput!): AddTeacherPayload!
}</pre>
<p>These<a id="_idIndexMarker1239"/> two types look like regular object types, but they have special meanings in GraphQL. The <code>Query</code> type and the <code>Mutation</code> type are two special object types in GraphQL, as they define the entry points of the GraphQL API. Every GraphQL service must have a <code>Query</code> type, but may or may not have a <code>Mutation</code> type. So the <code>teachers</code> query is actually a field of the <code>Query</code> type, just like the <code>department</code> field in the <code>teacher</code> type. Mutations work in the same way.</p>
<p>So far, the GraphQL types are similar to C# types. If you are familiar with object-oriented programming, you should be able to understand the GraphQL types easily. Similar to C#, GraphQL supports interfaces as well. But before we delve into interfaces, Let's discuss how to retrieve the <code>Department</code> object when querying the <code>Teach<a id="_idTextAnchor502"/>er</code> object.</p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor503"/>Retrieving related objects using resolvers</h1>
<p>In the <a id="_idIndexMarker1240"/>previous section, we defined a <code>Teacher</code> type and a <code>Department</code> type. The <code>Teacher</code> type has a <code>Department</code> property of the <code>Department</code> type. When querying the <code>Teacher</code> object, we may also want to retrieve the <code>Department</code> object. How can we do that?</p>
<p>You may think that we can use the <code>Include()</code> method to retrieve the <code>Department</code> object, as follows:</p>
<pre class="source-code">
public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachers([Service] AppDbContext context) =&gt;    await context.Teachers.Include(x =&gt; x.Department).ToListAsync();</pre>
<p>Then, you can <a id="_idIndexMarker1241"/>query the <code>Department</code> object as follows:</p>
<pre class="source-code">
query{  teachers{
    id
    firstName
    lastName
    department{
      id
      name
      description
    }
  }
}</pre>
<p>It does work and you will see the following result:</p>
<pre class="source-code">
{  "data": {
    "teachers": [
      {
        "id": "00000000-0000-0000-0000-000000000401",
        "firstName": "John",
        "lastName": "Doe",
        "department": {
          "id": "00000000-0000-0000-0000-000000000001",
          "name": "Mathematics",
          "description": "Mathematics Department"
        }
      },
      {
        "id": "00000000-0000-0000-0000-000000000402",
        "firstName": "Jane",
        "lastName": "Doe",
        "department": {
          "id": "00000000-0000-0000-0000-000000000001",
          "name": "Mathematics",
          "description": "Mathematics Department"
        }
      }
    ]
  }
}</pre>
<p>But this is not <a id="_idIndexMarker1242"/>the best way to do it. Remember that GraphQL allows clients to specify the data they need. If the query does not specify the <code>department</code> field, the <code>Department</code> object will still be retrieved from the database. This is not efficient. We should only retrieve the <code>Department</code> object when the <code>department</code> field is specified in the query. That leads us to the concept of resolvers.</p>
<p>A resolver is a function that is used to retrieve data from somewhere for a specific field. The resolver is<a id="_idIndexMarker1243"/> executed when the field is requested in the query. The resolver can fetch data from a database, a web API, or any other data source. It will drill down the graph to retrieve the data for the field. For example, when the <code>department</code> field is requested in the <code>teachers</code> query, the resolver will retrieve the <code>Department</code> object from the database. But when the query does not specify the <code>department</code> field, the resolver will not be executed. This can avoid unnecessary dat<a id="_idTextAnchor504"/>abase queries.</p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor505"/>Field resolvers</h2>
<p>HotChocolate supports<a id="_idIndexMarker1244"/> three ways to define schemas:</p>
<ul>
<li><code>Get</code> prefix or an <code>Async</code> suffix, these prefixes or suffixes will be removed from the name.</li>
<li><strong class="bold">Code-first</strong>: This <a id="_idIndexMarker1246"/>approach allows you to define the schema using explicit types and resolvers. It uses the Fluent API to define the details of the schema. This approach is more flexible when you need to customize the schema.</li>
<li><strong class="bold">Schema-first</strong>: This <a id="_idIndexMarker1247"/>approach allows you to define the schema using the GraphQL schema definition language. If you are familiar with GraphQL, you can use this approach to define the schema directly.</li>
</ul>
<p>As you, our <a id="_idIndexMarker1248"/>readers, are mostly .NET developers, we will use the code-first approach to define the schema in the rest of this chapter, so we can benefit from the Fluent API to fine-tune the schema.</p>
<p>Let us look back at the <code>teacher</code> query we defined in the previous section:</p>
<pre class="source-code">
public async Task&lt;Teacher?&gt; GetTeacher(Guid id, [Service] AppDbContext context) =&gt;   await context.Teachers.FindAsync(id);</pre>
<p>The preceding is the annotation-based approach. HotChocolate automatically converts the <code>GetTeacher()</code> method to a resolver named <code>teacher</code>. Next, we want to retrieve the <code>Department</code> object when the <code>department</code> field is requested. Let us make some changes by following <a id="_idIndexMarker1249"/>these steps:</p>
<ol>
<li>First, we need to define <code>TeacherType</code> class as a GraphQL object. Create a <code>TeacherType</code> class in the <code>Types</code> folder. The code is shown here:<pre class="source-code">
public class TeacherType : ObjectType&lt;Teacher&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Teacher&gt; descriptor)    {        descriptor.Field(x =&gt; x.Department)            .Name("department")            .Description("This is the department to which the teacher belongs.")            .Resolve(async context =&gt;            {                var department = await context.Service&lt;AppDbContext&gt;().Departments.FindAsync(context.   Parent&lt;Teacher&gt;().DepartmentId);                return department;            });    }}</pre><p class="list-inset">The <code>TeacherType</code> class inherits from the <code>ObjectType&lt;Teacher&gt;</code> class, which <a id="_idIndexMarker1250"/>has a <code>Configure()</code> method to configure the GraphQL object and specify how to resolve the fields. In the preceding code, we use the code-first approach to define the <code>Department</code> field of <code>TeacherType</code>. The <code>Name</code> method is used to specify the name of the field. If the name of the field is the same as the name of the property following the convention, we can omit the <code>Name</code> method. By convention, the <code>Department</code> field will be converted to the <code>department</code> field in the schema. Then, we use the <code>Description</code> method to define the description of the field. The description will be shown in the GraphQL IDE.</p><p class="list-inset">Then, we<a id="_idIndexMarker1251"/> use the <code>Resolve()</code> method to define the resolver. The<a id="_idIndexMarker1252"/> resolver retrieves the <code>Department</code> object from the database using the <code>DepartmentId</code> property of the <code>Teacher</code> object. Note that we use the <code>context.Parent&lt;Teacher&gt;()</code> method to get the <code>Teacher</code> object because the <code>Teacher</code> object is the parent object of the <code>Department</code> object.</p></li> <li>As we know the <code>Query</code> type is a special object type, we will create a <code>QueryType</code> class as well. Create a new <code>Types</code> folder in the <code>GraphQL</code> folder and move the <code>Query.cs</code> file to this <code>Types</code> folder.</li>
<li>Remove the <code>GetTeacher()</code> method and add a property as follows:<pre class="source-code">
public class Query{    // Omitted for brevity    public TeacherType? Teacher { get; set; } = new();}</pre></li> <li>Create a new class named <code>QueryType</code>, as follows:<pre class="source-code">
public class QueryType : ObjectType&lt;Query&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Query&gt; descriptor)    {        descriptor.Field(x =&gt; x.Teacher)            .Name("teacher")            .Description("This is the teacher in the school.")            .Type&lt;TeacherType&gt;()            .Argument("id", a =&gt; a.Type&lt;NonNullType&lt;UuidType&gt;&gt;())            .Resolve(async context =&gt;            {                var id = context.ArgumentValue&lt;Guid&gt;("id");                var teacher = await context.Service&lt;AppDbContext&gt;().Teachers.FindAsync(id);                return teacher;            });    }}</pre><p class="list-inset">The <a id="_idIndexMarker1253"/>preceding code defines the root query type. In this <a id="_idIndexMarker1254"/>query type, we specify the type of the field to be <code>TeacherType</code>. Next, we use the <code>Argument()</code> method to define the <code>id</code> argument, which is a non-nullable <code>UUID</code> type. Then, we use the <code>Resolve()</code> method to define the resolver. The resolver takes the <code>id</code> argument and retrieves the <code>Teacher</code> object from the database. Note that <code>AppDbContext</code> is injected into the resolver from the <code>context</code> object.</p></li> <li>Next, we need to update the <code>Program.cs</code> file to register <code>QueryType</code>. Update the <code>Program.cs</code> file as follows:<pre class="source-code">
builder.Services    .AddGraphQLServer()    .AddQueryType&lt;QueryType&gt;()    .AddMutationType&lt;Mutation&gt;();</pre><p class="list-inset">We use <code>QueryType</code> to replace the <code>Query</code> type we defined previously so that we can use the resolver to retrieve the <code>Department</code> object when the <code>department</code> field is requested.</p></li> <li>Now, we <a id="_idIndexMarker1255"/>can test the resolvers. Run the application<a id="_idIndexMarker1256"/> using <code>dotnet run</code> and send the following request to query a teacher.<p class="list-inset">This is the GraphQL request:</p><pre class="source-code">
query ($id: UUID!) {  teacher(id: $id) {    firstName    lastName    email    department {      name      description    }  }}
{  "id": "00000000-0000-0000-0000-000000000401"}</pre><p class="list-inset">You will see the department information in the response. Also, if you check the log, you will see that the <code>Department</code> object is retrieved from the database. If you remove the <code>department</code> field from the query, you will only see one database query in the log, which means that GraphQL does not fetch the <code>Department</code> object from the database.</pre></li> </ol>
<p>In this example, we <a id="_idIndexMarker1257"/>defined a resolver using a delegate method. We can also<a id="_idIndexMarker1258"/> define a resolver in a separate class. For example, we can define a <code>TeacherResolver</code> class as follows:</p>
<pre class="source-code">
public class TeacherResolvers{
    public async Task&lt;Department&gt; GetDepartment([Parent] Teacher teacher, [Service] IDbContextFactory&lt;AppDbContext&gt; dbContextFactory)
    {
        await using var dbContext = await dbContextFactory.CreateDbContextAsync();
        var department = await dbContext.Departments.FindAsync(teacher.DepartmentId);
        return department;
    }
}</pre>
<p>The preceding code defines a <code>GetDepartment()</code> method that takes a <code>Teacher</code> object as the parent object and returns the <code>Department</code> object. Then, we can use the <code>ResolveWith</code><code>()</code> method to define the resolver in the <code>TeacherType</code> class, as follows:</p>
<pre class="source-code">
descriptor.Field(x =&gt; x.Department)    .Description("This is the department to which the teacher belongs.")
    .ResolveWith&lt;TeacherResolvers&gt;(x =&gt; x.GetDepartment(default, default));</pre>
<p>Now, the logic of the resolver is moved to a separate class. This approach is more flexible when the resolver is complex. But for simple resolvers, we can use the delegate method directly.</p>
<p>So far, it works well. Let us try to update the <code>GetTeachers</code> method using the same <a id="_idTextAnchor506"/>approach in the next section.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor507"/>Resolver for a list of objects</h2>
<p>Similarly, we<a id="_idIndexMarker1259"/> can use <code>ListType&lt;TeacherType&gt;</code> to define the <code>teachers</code> field and then use the <code>Resolve()</code> method to define the resolver. The <code>ListType</code> class is a wrapper type for the fluent code-first API. It is used to define a list of objects. Remove the <code>GetTeachers()</code> method in the <code>Query</code> class and add a <code>Teachers</code> field, as shown here:</p>
<pre class="source-code">
public class Query{
    // Omitted for brevity
    public List&lt;TeacherType&gt; Teachers { get; set; } = new();
}</pre>
<p>Then, configure the <code>Teachers</code> field in the <code>QueryType</code> class as follows:</p>
<pre class="source-code">
public class QueryType : ObjectType&lt;Query&gt;{
    protected override void Configure(IObjectTypeDescriptor&lt;Query&gt; descriptor)
    {
        descriptor.Field(x =&gt; x.Teachers)
            .Name("teachers") // This configuration can be omitted if the name of the field is the same as the name of the property.
            .Description("This is the list of teachers in the school.")
            .Type&lt;ListType&lt;TeacherType&gt;&gt;()
            .Resolve(async context =&gt;
            {
                var teachers = await context.Service&lt;AppDbContext&gt;().Teachers.ToListAsync();
                return teachers;
            });
        // Omitted for brevity
    }
}</pre>
<p>The <a id="_idIndexMarker1260"/>preceding code defines the <code>Teachers</code> field of <code>QueryType</code>. It uses <code>ListType&lt;TeacherType&gt;</code> to define a list of <code>TeacherType</code>. Then, it uses the <code>Resolve()</code> method to define the resolver. The resolver retrieves all the <code>Teacher</code> objects from the database. This code is similar to the <code>teacher</code> field we defined previously. However, it retrieves a list of <code>TeacherType</code> objects instead of a single <code>TeacherType</code> object. As <code>TeacherType</code> has a resolver for the <code>Department</code> field, we can retrieve the <code>Department</code> object for each <code>TeacherType</code> object.</p>
<p>Now, we can test the <code>teachers</code> field using the following query:</p>
<pre class="source-code">
query{  teachers{
    id
    firstName
    lastName
    department{
      id
      name
      description
    }
  }
}</pre>
<p>However, you may encounter an error in the response. Some teachers can be retrieved correctly, but <a id="_idIndexMarker1261"/>some may not. The error message is like this:</p>
<pre class="source-code">
{  "errors": [
    {
      "message": "Unexpected Execution Error",
      "locations": [
        {
          "line": 6,
          "column": 5
        }
      ],
      "path": [
        "teachers",
        7,
        "department"
      ],
      "extensions": {
        "message": "A second operation was started on this context instance before a previous operation completed. This is usually caused by different threads concurrently using the same instance of DbContext. For more information on how to avoid threading issues with DbContext, see https://go.microsoft.com/fwlink/?linkid=2097913.",
        ...
      }
    },
  ]
}</pre>
<p>This is because we have multiple resolvers that execute database queries concurrently. However, <code>AppDbContext</code> is registered as a scoped service, and the <code>AppDbContext</code> class is not thread-safe. When multiple resolvers try to query the database in parallel, they will use the same <code>AppDbContext</code> instance, which causes the error.</p>
<p>To fix this issue, we <a id="_idIndexMarker1262"/>need to make sure that the resolvers do not access the same <code>AppDbContext</code> instance concurrently. There are two ways to do that. One is to execute the resolvers sequentially, and the other is to use separate <code>AppDbContext</code> instances for each resolver. HotChocolate provides a <code>RegisterDbContext&lt;TDbContext&gt;()</code> method to manage <code>DbContext</code> for resolvers. In order to use this feature, we need to install a NuGet package named <code>HotChocolate.Data.EntityFramework</code> using the following command:</p>
<pre class="source-code">
<code>Program.cs</code> file to register the <code>AppDbContext</code> class, as follows:</p>
<pre class="source-code">
builder.Services    .AddGraphQLServer()
    .RegisterDbContext&lt;AppDbContext&gt;()
    // Omitted for brevity</pre>
<p>The preceding code allows HotChocolate to manage the lifetime of <code>AppDbContext</code> for resolvers.</p>
<p>The <code>RegisterDbContext&lt;TDbContext&gt;()</code> method can specify how <code>DbContext</code> should be injected. There are three options:</p>
<ul>
<li><code>DbContextKind.Synchronized</code>: This is to ensure that <code>DbContext</code> is never used concurrently. <code>DbContext</code> is still injected as a scoped service.</li>
<li><code>DbContextKind.Resolver</code>: This way will resolve the scoped <code>DbContext</code> for each resolver. This option is the default configuration. From the perspective of the resolver, <code>DbContext</code> is a transient service, so HotChocolate can execute multiple resolvers concurrently without any issues.</li>
<li><code>DbContextKind.Pooled</code>: This mechanism will create a pool of <code>DbContext</code> instances. It leverages the <code>DbContextPool</code> feature of EF Core. HotChocolate will resolve <code>DbContext</code> from the pool for each resolver. When the resolver is completed, <code>DbContext</code> will be returned to the pool. In this way, <code>DbContext</code> is also like a transient service for each resolver, so HotChocolate can parallelize the resolvers as well.</li>
</ul>
<p>To demonstrate <a id="_idIndexMarker1263"/>how to benefit from the pooled <code>DbContext</code>, we will use the <code>DbContextKind.Pooled</code> option. This approach requires a couple of additional steps:</p>
<ol>
<li>First, we need to register <code>DbContext</code> using the <code>AddPooledDbContextFactory()</code> method instead of the <code>AddDbContext()</code> method. Update the <code>Program.cs</code> file as follows:<pre class="source-code">
builder.Services.AddPooledDbContextFactory&lt;AppDbContext&gt;(options =&gt;    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));// Register the GraphQL servicesbuilder.Services    .AddGraphQLServer()    .RegisterDbContext&lt;AppDbContext&gt;(DbContextKind.Pooled)    // Omitted for brevity</pre><p class="list-inset">The preceding code registers <code>AppDbContext</code> as a pooled service using the <code>AddPooledDbContextFactory()</code> method. Then, we use the <code>RegisterDbContext()</code> method to register <code>AppDbContext</code> as a pooled service for HotChocolate resolvers.</p></li> <li>Update the <code>Configure()</code> method in the <code>QueryType</code> file to use the pooled <code>DbContext</code>:<pre class="source-code">
descriptor.Field(x =&gt; x.Teachers)    // Omitted for brevity    .Type&lt;ListType&lt;TeacherType&gt;&gt;()    .Resolve(async context =&gt;    {        var dbContextFactory = context.Service&lt;IDbContextFactory&lt;AppDbContext&gt;&gt;();        await using var dbContext = await dbContextFactory.CreateDbContextAsync();        var teachers = await dbContext.Teachers.ToListAsync();        return teachers;    });</pre><p class="list-inset">The <a id="_idIndexMarker1264"/>preceding code uses <code>IDbContextFactory&lt;TDbContext&gt;</code> to create a new <code>AppDbContext</code> instance for each resolver. Then, it retrieves the <code>Teacher</code> objects from the database using the new <code>AppDbContext</code> instance.</p><p class="list-inset">One thing to note is that we need to use the <code>await using</code> statement to dispose of the <code>AppDbContext</code> instance after the resolver is completed in order to return the <code>AppDbContext</code> instance to the pool.</p></li> <li>Update the other resolvers as well. For example, the resolver of the <code>Teacher</code> type looks like this:<pre class="source-code">
descriptor.Field(x =&gt; x.Department)    .Description("This is the department to which the teacher belongs.")    .Resolve(async context =&gt;    {        var dbContextFactory = context.Service&lt;IDbContextFactory&lt;AppDbContext&gt;&gt;();        await using var dbContext = await dbContextFactory.CreateDbContextAsync();        var department = await dbContext.Departments            .FindAsync(context.Parent&lt;Teacher&gt;().DepartmentId);        return department;    });</pre><p class="list-inset">Now, we<a id="_idIndexMarker1265"/> can test the <code>teachers</code> field again. You will see that all the teachers with the department information can be retrieved correctly.</p></li> </ol>
<p>So, everything looks good. But wait. If you check the logs, you will find that there are many database queries for each <code>Department</code> object:</p>
<div><div><img alt="Figure 12.4 – Database queries for each Department object" src="img/B18971_12_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Database queries for each Department object</p>
<p>What is the reason behind this? L<a id="_idTextAnchor508"/>et us <a id="_idIndexMarker1266"/>find out in the next section.</p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor509"/>Using data loaders</h1>
<p>In the <a id="_idIndexMarker1267"/>previous section, we learned how to integrate HotChocolate with EF Core. We also learned how to use the <code>DbContextPool</code> feature to fetch data in multiple resolvers. However, we found that there are many database queries for each <code>Department</code> object in the <code>Teacher</code> list. That is because the resolvers for each <code>Department</code> object are executed separately, querying the database by each <code>DepartmentId</code> property in the list. This is similar to the <em class="italic">N+1</em> problem we discussed in <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a>. The difference is that the <em class="italic">N+1</em> problem occurs on the client side in REST APIs, while it occurs on the server side in GraphQL. To solve this problem, we need to find a way to load the batch data efficiently.</p>
<p>HotChocolate provides a <code>DataLoader</code> mechanism to solve the <em class="italic">N+1</em> problem. The data loader fetches data in batches from the data source. Then, the resolver can retrieve the data from the data loader, rather than querying the data source directly. The data loader will cache the data for the current request. If the same data is requested again, the resolver can retrieve the data from the data loader directly. This can avoid unnecessary database queries.</p>
<p>Before we learn how to use the data loader to solve the <em class="italic">N+1</em> problem, let's prepare the examples. We already have a <code>Teachers</code> query to query the list of teachers, and each teacher has a <code>Department</code> object. Now, we want to add a <code>Departments</code> query to query the <a id="_idIndexMarker1268"/>list of departments, and each department has a list of teachers. We will use the following steps to add the <code>Departments</code> query:</p>
<ol>
<li>The <code>Department</code> type is defined as follows:<pre class="source-code">
public class Department{    public Guid Id { get; set; }    public string Name { get; set; } = string.Empty;    public string? Description { get; set; }    public List&lt;Teacher&gt; Teachers { get; set; } = new();}</pre></li> <li>The <code>Department</code> class has a list of <code>Teacher</code> objects. Following the convention, we can define a <code>DepartmentType</code> class as follows:<pre class="source-code">
public class DepartmentType : ObjectType&lt;Department&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Department&gt; descriptor)    {        descriptor.Field(x =&gt; x.Teachers)            .Description("This is the list of teachers in the department.")            .Type&lt;ListType&lt;TeacherType&gt;&gt;()            .ResolveWith&lt;DepartmentResolvers&gt;(x =&gt; x.GetTeachers(default, default));    }}public class DepartmentResolvers{    public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachers([Parent] Department department,        [Service] IDbContextFactory&lt;AppDbContext&gt; dbContextFactory)    {        await using var dbContext = await dbContextFactory.CreateDbContextAsync();        var teachers = await dbContext.Teachers.Where(x =&gt; x.DepartmentId == department.Id).ToListAsync();        return teachers;    }}</pre><p class="list-inset">The <a id="_idIndexMarker1269"/>preceding code is similar to <code>TeacherType</code>, which we defined previously. <code>DepartmentType</code> has a <code>Teachers</code> field of the <code>ListType&lt;TeacherType&gt;</code> type. Then, we use the <code>ResolveWith()</code> method to define the resolver. The resolver retrieves the <code>Teacher</code> objects from the database using the <code>DepartmentId</code> property of the <code>Department</code> object.</p></li> <li>Add a new field in the <code>Query</code> class, as follows:<pre class="source-code">
public class Query{    // Omitted for brevity    public List&lt;DepartmentType&gt; Departments { get; set; } = new();}</pre></li> <li>Then, configure <a id="_idIndexMarker1270"/>the <code>Departments</code> field in the <code>QueryType</code> as follows:<pre class="source-code">
descriptor.Field(x =&gt; x.Departments)    .Description("This is the list of departments in the school.")    .Type&lt;ListType&lt;DepartmentType&gt;&gt;()    .Resolve(async context =&gt;    {        var dbContextFactory = context.Service&lt;IDbContextFactory&lt;AppDbContext&gt;&gt;();        await using var dbContext = await dbContextFactory.CreateDbContextAsync();        var departments = await dbContext.Departments.ToListAsync();        return departments;    });
query{   departments{    id    name    description    teachers{      id      firstName      lastName      bio    }   }}</pre><p class="list-inset">If you <a id="_idIndexMarker1271"/>check the logs, you will find that the following database queries are executed multiple times:</pre><pre class="source-code">info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (3ms) [Parameters=[@__department_Id_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']      SELECT [t].[Id], [t].[Bio], [t].[DepartmentId], [t].[Email], [t].[FirstName], [t].[LastName], [t].[Phone]      FROM [Teachers] AS [t]      WHERE [t].[DepartmentId] = @__department_Id_0</pre></li> </ol>
<p>The preceding query is executed for each <code>Department</code> object. This is also an <em class="italic">N+1</em> problem, as we discussed previously. Next, we will use the<a id="_idTextAnchor510"/> data loader to solve these <em class="italic">N+1</em> problems.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor511"/>Batch data loader</h2>
<p>First, let's <a id="_idIndexMarker1272"/>optimize the <code>teachers</code> query. To retrieve the <code>teachers</code> data with the department information, we want to execute two SQL queries only. One is to retrieve the <code>teachers</code> data, and the other is to retrieve the department data. Then, HotChocolate should be able to map the <code>department </code>data to the teachers in memory, instead of executing a SQL query for each teacher.</p>
<p>Follow these steps to use the data loader:</p>
<ol>
<li>Create a folder named <code>DataLoaders</code> in the <code>GraphQL</code> folder, then create a new <code>DepartmentByTeacherIdBatchDataLoader</code> class, as follows:<pre class="source-code">
public class DepartmentByTeacherIdBatchDataLoader(       IDbContextFactory&lt;AppDbContext&gt; dbContextFactory,       IBatchScheduler batchScheduler,       DataLoaderOptions? options = null)       : BatchDataLoader&lt;Guid, Department&gt;(batchScheduler, options){    protected override async Task&lt;IReadOnlyDictionary&lt;Guid, Department&gt;&gt; LoadBatchAsync(IReadOnlyList&lt;Guid&gt;    keys,        CancellationToken cancellationToken)    {        await using var dbContext = await dbContextFactory.CreateDbContextAsync(cancellationToken);        var departments = await dbContext.Departments.Where(x =&gt; keys.Contains(x.Id))            .ToDictionaryAsync(x =&gt; x.Id, cancellationToken);        return departments;    }}</pre><p class="list-inset">The preceding code defines a data loader to fetch the batch data for the <code>Department</code> object. The parent resolver, which is the <code>teachers</code> query, will get a list of <code>Teacher</code> objects. Each <code>Teacher</code> object has a <code>DepartmentId</code> property. <code>DepartmentByTeacherIdBatchDataLoader</code> will fetch the <code>Department</code> objects for the <code>DepartmentId</code> values in the list. The list of the <code>Department</code> objects will be converted to a dictionary. The key of the dictionary is the <code>DepartmentId</code> property and the value is the <code>Department</code> object. Then, the parent resolver can map the <code>Department</code> object to the <code>Teacher</code> object in memory.</p></li> <li>Update the <code>TeacherResolvers</code> class as follows:<pre class="source-code">
public class TeacherResolvers{    public async Task&lt;Department&gt; GetDepartment([Parent] Teacher teacher,        DepartmentByTeacherIdBatchDataLoader departmentByTeacherIdBatchDataLoader, CancellationToken cancellationToken)    {        var department = await departmentByTeacherIdBatchDataLoader.LoadAsync(teacher.DepartmentId,    cancellationToken);        return department;    }}</pre><p class="list-inset">Instead of querying the database directly, the resolver uses <code>DepartmentByTeacherIdBatchDataLoader</code> to fetch the <code>Department</code> object for the <code>DepartmentId</code> property of the <code>Teacher</code> object. The <code>DepartmentByTeacherIdBatchDataLoader</code> will be injected by HotChocolate automatically.</p></li> <li>Run the <a id="_idIndexMarker1273"/>application and test the <code>teachers</code> query <a id="_idIndexMarker1274"/>again. Now, you will see only two SQL queries are executed:<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (108ms) [Parameters=[], CommandType='Text', CommandTimeout='30']      SELECT [t].[Id], [t].[Bio], [t].[DepartmentId], [t].[Email], [t].[FirstName], [t].[LastName], [t].   [Phone]      FROM [Teachers] AS [t]info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (73ms) [Parameters=[@__keys_0='?' (Size = 4000)], CommandType='Text',    CommandTimeout='30']      SELECT [d].[Id], [d].[Description], [d].[Name]      FROM [Departments] AS [d]      WHERE [d].[Id] IN (          SELECT [k].[value]          FROM OPENJSON(@__keys_0) WITH ([value] uniqueidentifier '$') AS [k]      )</pre><p class="list-inset">As we see, the first query is to get the list of the teachers, and the second query is to use the <code>IN</code> clause <a id="_idIndexMarker1275"/>to query the departments that match the <code>DepartmentId</code> values in the list. This is much more efficient than the previous approach.</p></li> </ol>
<p>As it fetches<a id="_idIndexMarker1276"/> the batch data for the <code>Department</code> object, it is<a id="_idIndexMarker1277"/> called a batch data loader. This data loader is often used for one-to-one relationships, such as one <code>Teacher</code> object has one <code>Department</code> object. Note that this one-to-one relationship is not the same as the one-to-one relationship in the database. In GraphQL, the one-to-one relations<a id="_idTextAnchor512"/>hip means that one object has one child object.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor513"/>Group data loader</h2>
<p>Next, let's <a id="_idIndexMarker1278"/>optimize the <code>departments</code> query. In this case, one <code>Department</code> object has a list of <code>Teacher</code> objects. We can use the group data loader<a id="_idIndexMarker1279"/> to fetch the <code>Teacher</code> objects for each <code>Department</code> object. The group data loader is similar to the batch data loader. The difference is that the group data loader fetches a list of objects for each key. The batch data loader fetches a single object for each key.</p>
<p>Follow these <a id="_idIndexMarker1280"/>steps to use the group data loader:</p>
<ol>
<li>Create a <code>TeachersByDepartmentIdDataLoader</code> class in the <code>DataLoaders</code> folder, and add the following code:<pre class="source-code">
public class TeachersByDepartmentIdDataLoader(       IDbContextFactory&lt;AppDbContext&gt; dbContextFactory,       IBatchScheduler batchScheduler,       DataLoaderOptions? options = null)       : GroupedDataLoader&lt;Guid, Teacher&gt;(batchScheduler, options){    protected override async Task&lt;ILookup&lt;Guid, Teacher&gt;&gt; LoadGroupedBatchAsync(IReadOnlyList&lt;Guid&gt; keys,        CancellationToken cancellationToken)    {        await using var dbContext = await dbContextFactory.CreateDbContextAsync(cancellationToken);        var teachers = await dbContext.Teachers.Where(x =&gt; keys.Contains(x.DepartmentId))            .ToListAsync(cancellationToken);        return teachers.ToLookup(x =&gt; x.DepartmentId);    }}</pre><p class="list-inset">The <a id="_idIndexMarker1281"/>preceding code defines a group data loader, which returns an <code>ILookup&lt;Guid, Teacher&gt;</code> object in the <code>LoadGroupedBatchAsync()</code> method. The <code>ILookup&lt;Guid, Teacher&gt;</code> object is similar to a dictionary. The key of the dictionary is the <code>DepartmentId</code> property and the value is a list of <code>Teacher</code> objects. The parent resolver can map the <code>Teacher</code> objects to the <code>Department</code> object in memory.</p></li> <li>Update <a id="_idIndexMarker1282"/>the <code>DepartmentResolvers</code> class as follows:<pre class="source-code">
public class DepartmentResolvers{    public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachers([Parent] Department department,        TeachersByDepartmentIdDataLoader teachersByDepartmentIdDataLoader, CancellationToken cancellationToken)    {        var teachers = await teachersByDepartmentIdDataLoader.LoadAsync(department.Id, cancellationToken);        return teachers.ToList();    }}</pre><p class="list-inset">The <a id="_idIndexMarker1283"/>preceding code uses <code>TeachersByDepartmentIdDataLoader</code> to fetch the <code>Teacher</code> objects for the <code>Department</code> object. <code>TeachersByDepartmentIdDataLoader</code> will be injected by HotChocolate automatically.</p></li> <li>Run the <a id="_idIndexMarker1284"/>application and test the <code>departments</code> query again. Now, you will see only two SQL queries are executed:<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (38ms) [Parameters=[], CommandType='Text', CommandTimeout='30']      SELECT [d].[Id], [d].[Description], [d].[Name]      FROM [Departments] AS [d]info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (36ms) [Parameters=[@__keys_0='?' (Size = 4000)], CommandType='Text',    CommandTimeout='30']      SELECT [t].[Id], [t].[Bio], [t].[DepartmentId], [t].[Email], [t].[FirstName], [t].[LastName], [t].[Phone]      FROM [Teachers] AS [t]      WHERE [t].[DepartmentId] IN (          SELECT [k].[value]          FROM OPENJSON(@__keys_0) WITH ([value] uniqueidentifier '$') AS [k]      )</pre><p class="list-inset">That is<a id="_idIndexMarker1285"/> exactly what we want. The first query is <a id="_idIndexMarker1286"/>to get the list of the departments, and the second query is to use the <code>IN</code> clause to query the teachers that match the <code>DepartmentId</code> values in the list. This approach reduces the number of database queries significantly.</p></li> </ol>
<p>In this case, each <code>Department</code> object has a list of <code>Teacher</code> objects, so this kind of data loader is called a group data loader. It is often used for one-to-many relationships, such as one <code>Department</code> object has a list of <code>Teacher</code> objects.</p>
<p>HotChocolate supports cache data loader as well. It also supports using multiple data loaders in a resolver. As they are not used often, we will not discuss them in this chapter. You can refer to the documentation for more details: <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12/start">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12/start</a>.</p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor514"/>Dependency injection</h1>
<p>In the previous code examples, we use <code>IDbContextFactory&lt;AppDbContext&gt;</code> and <code>AppDbContext</code> directly in the resolvers. In order to encapsulate our data access logic, we can add a service layer to implement our business logic. HotChocolate supports <a id="_idIndexMarker1287"/>dependency injection for resolvers. In this section, we will learn how to inject other services into the resolvers.</p>
<p>To demonstrate how to use dependency injection in HotChocolate, we will add an interface <a id="_idIndexMarker1288"/>named <code>ITeacherService</code> and a class named <code>TeacherService</code>, as follows:</p>
<pre class="source-code">
public interface ITeacherService{
    Task&lt;Department&gt; GetDepartmentAsync(Guid departmentId);
    Task&lt;List&lt;Teacher&gt;&gt; GetTeachersAsync();
    Task&lt;Teacher&gt; GetTeacherAsync(Guid teacherId);
    // Omitted for brevity
}
public class TeacherService(IDbContextFactory&lt;AppDbContext&gt; contextFactory) : ITeacherService
{
    public async Task&lt;Department&gt; GetDepartmentAsync(Guid departmentId)
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var department = await dbContext.Departments.FindAsync(departmentId);
        return department ?? throw new ArgumentException("Department not found", nameof(departmentId));
    }
    public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachersAsync()
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var teachers = await dbContext.Teachers.ToListAsync();
        return teachers;
    }
    public async Task&lt;Teacher&gt; GetTeacherAsync(Guid teacherId)
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var teacher = await dbContext.Teachers.FindAsync(teacherId);
        return teacher ?? throw new ArgumentException("Teacher not found", nameof(teacherId));
    }
    // Omitted for brevity
}</pre>
<p>The<a id="_idIndexMarker1289"/> preceding code encapsulates the data access logic in the <code>TeacherService</code> class. Then, we need to register <code>ITeacherService</code> in the <code>Program.cs</code> file, as follows:</p>
<pre class="source-code">
builder.Services.AddScoped&lt;ITeacherService, TeacherService&gt;();</pre> <p>HotChocolate uses the same approach to register the services as ASP.NET Core, but injecting the services is a little different. In ASP.NET Core, we can inject the services into the controller constructor, while HotChocolate does not recommend constructor injection. Instead, HotChocolate recommends using the method-level injection. First, the GraphQL type <a id="_idIndexMarker1290"/>definitions are singleton objects. If we use constructor injection, the services will be injected as singleton objects as well. This is not what we want. Second, sometimes HotChocolate needs to synchronize the resolvers to avoid concurrency issues. If we use constructor injection, HotChocolate cannot control the lifetime of the services. Note that this applies to the HotChocolate GraphQL types and resolvers only. For other services, we can still use constructor <a id="_idTextAnchor515"/>injection.</p>
<p>Let us see how to <a id="_idIndexMarker1291"/>use the method-level injection.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor516"/>Using the Service attribute</h2>
<p>We can <a id="_idIndexMarker1292"/>use <code>HotChocolate.ServiceAttribute</code> to inject services into the resolvers. For example, we can add a <code>GetTeachersWithDI</code> method in the <code>Query</code> class as follows:</p>
<pre class="source-code">
public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachersWithDI([Service] ITeacherService teacherService) =&gt;    await teacherService.GetTeachersAsync();</pre>
<p>Note that the <code>Service</code> attribute is from the <code>HotChocolate</code> namespace, not the <code>Microsoft.AspNetCore.Mvc</code> namespace. With this attribute, <code>ITeacherService</code> will be injected into the <code>teacherService</code> parameter automatically.</p>
<p>If we have many services in the project, using the attribute for each service is tedious. HotChocolate provides a <code>RegisterServices()</code> method to simplify the injection. We can update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
builder.Services    .AddGraphQLServer()
    .RegisterDbContext&lt;AppDbContext&gt;(DbContextKind.Pooled)
    .RegisterService&lt;ITeacherService&gt;()
    .AddQueryType&lt;QueryType&gt;()
    .AddMutationType&lt;Mutation&gt;();</pre>
<p>Now, we can remove the <code>Service</code> attribute from the <code>GetTeachersWithDI()</code> method. HotChocolate<a id="_idIndexMarker1293"/> can still inject <code>ITeacherService</code> automatically, as shown here:</p>
<pre class="source-code">
public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachersWithDI(ITeacherService teacherService) =&gt;    await teac<a id="_idTextAnchor517"/>herService.GetTeachersAsync();</pre>
<p>This will save us a lot of time.</p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor518"/>Understanding the lifetime of the injected services</h2>
<p>We have<a id="_idIndexMarker1294"/> learned that, in ASP.NET Core, we can inject the services as singleton, scoped, or transient services. HotChocolate offers more options for the lifetime of the injected services. When we use the <code>Service</code> attribute or the <code>RegisterService()</code> method to inject the services, we can specify the <code>ServiceKind</code> property to control the lifetime of the services. The <code>ServiceKind</code> has the following options:</p>
<ul>
<li><code>ServiceKind.Default</code>: This is the default option. The service will be injected as the same lifetime in the registered service in the DI container.</li>
<li><code>ServiceKind.Synchronized</code>: This option is similar to the synchronized <code>DbContext</code>. The resolver using the service will be executed sequentially. The synchronization only happens in the same request scope.</li>
<li><code>ServiceKind.Resolver</code>: This option is to resolve the service for each resolver scope. The service will be disposed of after the resolver is completed.</li>
<li><code>ServiceKind.Pooled</code>: This option is similar to the pooled <code>DbContext</code>. The service needs to be registered as an <code>ObjectPool&lt;T&gt;</code> instance in the ASP.NET Core DI container. The resolver will get the service from the pool and return it to the pool after the resolver is completed.</li>
</ul>
<p>To specify the <code>ServiceKind</code> for the injected services, we can add a <code>ServiceKind</code> parameter in the <code>Service</code> attribute or the <code>RegisterService()</code> method. For example, we can update the <code>GetTeachersWithDI()</code> method as follows:</p>
<pre class="source-code">
public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachersWithDI([Service(ServiceKind.Resolver)] ITeacherService teacherService) =&gt;    await teacherService.GetTeachersAsync();</pre>
<p>The<a id="_idIndexMarker1295"/> preceding code specifies the <code>ServiceKind</code> as <code>ServiceKind.Resolver</code>. So, <code>ITeacherService</code> will be resolved for each resolver scope.</p>
<p>If we use the <code>RegisterServices()</code> method to register the services, we can specify the <code>ServiceKind</code> in the <code>RegisterServices()</code> method, as follows:</p>
<pre class="source-code">
builder.Services    .AddGraphQLServer()
    .RegisterDbContext&lt;AppDbContext&gt;(DbContextKind.Pooled)
    .RegisterService&lt;ITeacherService&gt;(ServiceKind.Resolver)
    .AddQueryType&lt;QueryType&gt;()
    .AddMutationType&lt;Mutation&gt;();</pre>
<p>To inject the services in the <code>Resolve()</code> method, we can get the service from the <code>context</code> object, as follows:</p>
<pre class="source-code">
descriptor.Field(x =&gt; x.Teachers)    .Description("This is the list of teachers in the school.")
    .Type&lt;ListType&lt;TeacherType&gt;&gt;()
    .Resolve(async context =&gt;
    {
        var teacherService = context.Service&lt;ITeacherService&gt;();
        var teachers = await teacherService.GetTeachersAsync();
        return teachers;
    });</pre>
<p>The <a id="_idIndexMarker1296"/>preceding code uses the <code>context.Service&lt;T&gt;()</code> method to get <code>ITeacherService</code> from the <code>context</code> object, which is similar to i<a id="_idTextAnchor519"/>njecting <code>IDbContextFactory&lt;AppDbContext&gt;</code> in the previous examples.</p>
<h1 id="_idParaDest-270"><a id="_idTextAnchor520"/>Interface and union types</h1>
<p>HotChocolate supports the use of interfaces and union types in GraphQL. In this section, we will explore how to incorporate these features into your GraphQL schema. Interfaces provide a way to group types that share common fields, while union types allow for the creation of a single type that can return different object types. With HotChocolate, you can easily implement t<a id="_idTextAnchor521"/>hese features to enhance the functionality of your GraphQL schema.</p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor522"/>Interfaces</h2>
<p>To prepare <a id="_idIndexMarker1297"/>the examples of GraphQL interfaces, we have an <code>ISchoolRoom</code> interface <a id="_idIndexMarker1298"/>and two classes that implement the interface, as follows:</p>
<pre class="source-code">
public interface ISchoolRoom{
    Guid Id { get; set; }
    string Name { get; set; }
    string? Description { get; set; }
    public int Capacity { get; set; }
}
public class LabRoom : ISchoolRoom
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public int Capacity { get; set; }
    public string Subject { get; set; } = string.Empty;
    public string Equipment { get; set; } = string.Empty;
    public bool HasChemicals { get; set; }
}
public class Classroom : ISchoolRoom
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public int Capacity { get; set; }
    public bool HasComputers { get; set; }
    public bool HasProjector { get; set; }
    public bool HasWhiteboard { get; set; }
}</pre>
<p>The two classes both implement <a id="_idIndexMarker1299"/>the <code>ISchoolRoom</code> interface, but they have some different properties. You can find the model classes and the model configurations in the sample code.</p>
<p>The service layer is defined in <a id="_idIndexMarker1300"/>the <code>ISchoolRoomService</code> interface and the <code>SchoolRoomService</code> class, as follows:</p>
<pre class="source-code">
public interface ISchoolRoomService{
    Task&lt;List&lt;ISchoolRoom&gt;&gt; GetSchoolRoomsAsync();
    Task&lt;List&lt;LabRoom&gt;&gt; GetLabRoomsAsync();
    Task&lt;List&lt;Classroom&gt;&gt; GetClassroomsAsync();
    Task&lt;LabRoom&gt; GetLabRoomAsync(Guid labRoomId);
    Task&lt;Classroom&gt; GetClassroomAsync(Guid classroomId);
}
public class SchoolRoomService(IDbContextFactory&lt;AppDbContext&gt; contextFactory) : ISchoolRoomService
{
    public async Task&lt;List&lt;ISchoolRoom&gt;&gt; GetSchoolRoomsAsync()
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var labRooms = await dbContext.LabRooms.ToListAsync();
        var classrooms = await dbContext.Classrooms.ToListAsync();
        var schoolRooms = new List&lt;ISchoolRoom&gt;();
        schoolRooms.AddRange(labRooms);
        schoolRooms.AddRange(classrooms);
        return schoolRooms;
    }
    // Omitted for brevity
}</pre>
<p>The <code>GetSchoolRoomsAsync()</code> method retrieves a list of <code>LabRoom</code> objects and a list of <code>Classroom</code> objects from the database. Then, it combines the two lists into a single list of <code>ISchoolRoom</code> objects.</p>
<p>We also need to <a id="_idIndexMarker1301"/>register <code>ISchoolRoomService</code> in the <code>Program.cs</code> file, as follows:</p>
<pre class="source-code">
builder.Services.AddScoped&lt;ISchoolRoomService, SchoolRoomService&gt;();</pre> <p>To define an<a id="_idIndexMarker1302"/> interface in HotChocolate, we need to use the <code>InterfaceType&lt;T&gt;</code> class. The <code>InterfaceType&lt;T&gt;</code> class is used to define an interface type in the schema. Follow these steps to define an interface type using the code-first API:</p>
<ol>
<li>Create a class named <code>SchoolRoomType</code> in the <code>Types</code> folder:<pre class="source-code">
public class SchoolRoomType : InterfaceType&lt;ISchoolRoom&gt;{    protected override void Configure(IInterfaceTypeDescriptor&lt;ISchoolRoom&gt; descriptor)    {        descriptor.Name("SchoolRoom");    }}</pre><p class="list-inset">The preceding code defines an interface type for the <code>ISchoolRoom</code> interface.</p></li> <li>Create two new classes for <code>LabRoom</code> and <code>Classroom</code>, as follows:<pre class="source-code">
public class LabRoomType : ObjectType&lt;LabRoom&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;LabRoom&gt; descriptor)    {        descriptor.Name("LabRoom");        descriptor.Implements&lt;SchoolRoomType&gt;();    }}public class ClassroomType : ObjectType&lt;Classroom&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Classroom&gt; descriptor)    {        descriptor.Name("Classroom");        descriptor.Implements&lt;SchoolRoomType&gt;();    }}</pre><p class="list-inset">In the <a id="_idIndexMarker1303"/>preceding code, we use the <code>Implements()</code> method to specify the interface implemented by the object type.</p></li> <li>Add a query field in the <code>Query</code> class:<pre class="source-code">
public List&lt;SchoolRoomType&gt; SchoolRooms { get; set; } = new();</pre></li> <li>Configure the <code>SchoolRooms</code> field in the <code>QueryType</code> class:<pre class="source-code">
descriptor.Field(x =&gt; x.SchoolRooms)    .Description("This is the list of school rooms in the school.")    .Type&lt;ListType&lt;SchoolRoomType&gt;&gt;()    .Resolve(async context =&gt;    {        var service = context.Service&lt;ISchoolRoomService&gt;();        var schoolRooms = await service.GetSchoolRoomsAsync();        return schoolRooms;    });</pre><p class="list-inset">In the <a id="_idIndexMarker1304"/>preceding code, we use the <code>Service()</code> method to get <code>ISchoolRoomService</code> from the <code>context</code> object. Then, we use the <code>GetSchoolRoomsAsync()</code> method to retrieve the list of <code>ISchoolRoom</code> objects. The result includes both <code>LabRoom</code> and <code>Classroom</code> objects.</p></li> <li>Next, we need to explicitly register <code>LabRoomType</code> and <code>ClassroomType</code> in <code>SchemaBuilder</code>. Update the <code>Program.cs</code> file as follows:<pre class="source-code">
builder.Services    .AddGraphQLServer()    .RegisterDbContext&lt;AppDbContext&gt;(DbContextKind.Pooled)    .RegisterService&lt;ITeacherService&gt;(ServiceKind.Resolver)    .AddQueryType&lt;QueryType&gt;()    .AddType&lt;LabRoomType&gt;()    .AddType&lt;ClassroomType&gt;()    .AddMutationType&lt;Mutation&gt;();</pre></li> <li>Run the application and check the generated schema. You will find the interface definition<a id="_idIndexMarker1305"/> and its implementations, as shown here:<pre class="source-code">
type Query {  """  This is the list of school rooms in the school.  """  schoolRooms: [SchoolRoom]}type LabRoom implements SchoolRoom {  id: UUID!  name: String!  description: String  capacity: Int!  subject: String!  equipment: String!  hasChemicals: Boolean!}type Classroom implements SchoolRoom {  id: UUID!  name: String!  description: String  capacity: Int!  hasComputers: Boolean!  hasProjector: Boolean!  hasWhiteboard: Boolean!}</pre></li> <li>Next, we can use the <code>SchoolRoom</code> interface to query both the <code>LabRoom</code> and <code>Classroom</code> objects. For<a id="_idIndexMarker1306"/> example, we can use the following query to retrieve the <code>LabRoom</code> objects:<pre class="source-code">
query {  schoolRooms {    __typename    id    name    description    capacity    ... on LabRoom {      subject      equipment      hasChemicals    }    ... on Classroom {      hasComputers      hasProjector      hasWhiteboard    }  }}
{  "data": {    "schoolRooms": [      {        "__typename": "LabRoom",        "id": "00000000-0000-0000-0000-000000000501",        "name": "Chemistry Lab",        "description": "Chemistry Lab",        "capacity": 20,        "subject": "Chemistry",        "equipment": "Chemicals, Beakers, Bunsen Burners",        "hasChemicals": true      },      {        "__typename": "Classroom",        "id": "00000000-0000-0000-0000-000000000601",        "name": "Classroom 1",        "description": "Classroom 1",        "capacity": 20,        "hasComputers": true,        "hasProjector": false,        "hasWhiteboard": true      },      ...    ]  }}</pre><p class="list-inset">In the<a id="_idIndexMarker1308"/> response, you can see that the <code>LabRoom</code> object has the <code>subject</code>, <code>equipment</code>, and <code>hasChemicals</code> properties, while the <code>Classroom</code> object has the <code>hasComputers</code>, <code>hasProjector</code>, and <code>hasWhiteboard</code> properties. This can be helpful when we want to query complex objects with different properties.</pre></li> </ol>
<p>Although interfaces provide flexibility for querying objects with different properties, we need to note that interfaces can be used<a id="_idTextAnchor523"/> for output types only. We cannot use interfaces for input types or arguments.</p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor524"/>Union types</h2>
<p>Union types<a id="_idIndexMarker1309"/> are similar to interfaces. The difference is that union types do not need to define any common fields. Instead, union types can combine multiple object types into a single type.</p>
<p>Follow the same approach as the previous section to prepare the models for union types. You can find an <code>Equipment</code> class and a <code>Furniture</code> class in the <code>Models</code> folder, as follows:</p>
<pre class="source-code">
public class Equipment{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public string Condition { get; set; } = string.Empty;
    public string Brand { get; set; } = string.Empty;
    public int Quantity { get; set; }
}
public class Furniture
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public string Color { get; set; } = string.Empty;
    public string Material { get; set; } = string.Empty;
    public int Quantity { get; set; }
}</pre>
<p>The <code>Equipment</code> class <a id="_idIndexMarker1310"/>and the <code>Furniture</code> class have some different properties. You can find the model configurations in the sample code. We also need to add the services for both classes. You can find the following code in the <code>Services</code> folder.</p>
<p>Here is the code for the <code>IEquipmentService</code> interface and the <code>EquipmentService</code> class:</p>
<pre class="source-code">
public interface IEquipmentService{
    Task&lt;List&lt;Equipment&gt;&gt; GetEquipmentListAsync();
    Task&lt;Equipment&gt; GetEquipmentAsync(Guid equipmentId);
}
public class EquipmentService(IDbContextFactory&lt;AppDbContext&gt; contextFactory) : IEquipmentService
{
    public async Task&lt;List&lt;Equipment&gt;&gt; GetEquipmentListAsync()
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var equipment = await dbContext.Equipment.ToListAsync();
        return equipment;
    }
    public async Task&lt;Equipment&gt; GetEquipmentAsync(Guid equipmentId)
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var equipment = await dbContext.Equipment.FindAsync(equipmentId);
        return equipment ?? throw new ArgumentException("Equipment not found", nameof(equipmentId));
    }
}</pre>
<p>Here is the code<a id="_idIndexMarker1311"/> for the <code>IFurnitureService</code> interface and the <code>FurnitureService</code> class:</p>
<pre class="source-code">
public interface IFurnitureService{
    Task&lt;List&lt;Furniture&gt;&gt; GetFurnitureListAsync();
    Task&lt;Furniture&gt; GetFurnitureAsync(Guid furnitureId);
}
public class FurnitureService(IDbContextFactory&lt;AppDbContext&gt; contextFactory) : IFurnitureService
{
    public async Task&lt;List&lt;Furniture&gt;&gt; GetFurnitureListAsync()
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var furniture = await dbContext.Furniture.ToListAsync();
        return furniture;
    }
    public async Task&lt;Furniture&gt; GetFurnitureAsync(Guid furnitureId)
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var furniture = await dbContext.Furniture.FindAsync(furnitureId);
        return furniture ?? throw new ArgumentException("Furniture not found", nameof(furnitureId));
    }
}</pre>
<p>The preceding code <a id="_idIndexMarker1312"/>should be straightforward. Do not forget to register the services in the <code>Program.cs</code> file, as follows:</p>
<pre class="source-code">
builder.Services.AddScoped&lt;IEquipmentService, EquipmentService&gt;();builder.Services.AddScoped&lt;IFurnitureService, FurnitureService&gt;();</pre>
<p>Next, let's create<a id="_idIndexMarker1313"/> the union types following these steps:</p>
<ol>
<li>Create two classes named <code>EquipmentType</code> and <code>FurnitureType</code>, as follows:<pre class="source-code">
public class EquipmentType : ObjectType&lt;Equipment&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Equipment&gt; descriptor)    {        descriptor.Name("Equipment");    }}public class FurnitureType : ObjectType&lt;Furniture&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Furniture&gt; descriptor)    {        descriptor.Name("Furniture");    }}</pre><p class="list-inset">The preceding code defines the <code>EquipmentType</code> and <code>FurnitureType</code> object types. These two object types are just normal object types.</p></li> <li>Create a <a id="_idIndexMarker1314"/>new class named <code>SchoolItemType</code>, as follows:<pre class="source-code">
public class SchoolItemType : UnionType{    protected override void Configure(IUnionTypeDescriptor descriptor)    {        descriptor.Name("SchoolItem");        descriptor.Type&lt;EquipmentType&gt;();        descriptor.Type&lt;FurnitureType&gt;();    }}</pre><p class="list-inset">The preceding code defines a union type named <code>SchoolItem</code>. A union type must inherit from the <code>UnionType</code> class. Then, we use the <code>Type</code> method to specify the object types that are included in the union type. In this case, the <code>SchoolItem</code> union type includes the <code>EquipmentType</code> and <code>FurnitureType</code> object types.</p><p class="list-inset">As we already registered these two types in the union type, we do not need to register them again in the <code>Program.cs</code> file.</p></li> <li>Add a <a id="_idIndexMarker1315"/>query field in the <code>Query</code> class:<pre class="source-code">
public List&lt;SchoolItemType&gt; SchoolItems { get; set; } = new();</pre></li> <li>Configure the resolver for the <code>SchoolItems</code> field in the <code>QueryType</code> class, as shown here:<pre class="source-code">
descriptor.Field(x =&gt; x.SchoolItems)    .Description("This is the list of school items in the school.")    .Type&lt;ListType&lt;SchoolItemType&gt;&gt;()    .Resolve(async context =&gt;    {        var equipmentService = context.Service&lt;IEquipmentService&gt;();        var furnitureService = context.Service&lt;IFurnitureService&gt;();        var equipmentTask = equipmentService.GetEquipmentListAsync();        var furnitureTask = furnitureService.GetFurnitureListAsync();        await Task.WhenAll(equipmentTask, furnitureTask);        var schoolItems = new List&lt;object&gt;();        schoolItems.AddRange(equipmentTask.Result);        schoolItems.AddRange(furnitureTask.Result);        return schoolItems;    });</pre><p class="list-inset">We retrieve a list of <code>Equipment</code> and <code>Furniture</code> objects from the database. We then combine these two lists into a single list of objects, as the object type is the base type of all types in C#. This allows us to use the object type to effectively combine the two lists.</p></li> <li>Run the <a id="_idIndexMarker1316"/>application and check the generated schema. You will find the union type defined as follows:<pre class="source-code">
union SchoolItem = Equipment | Furnituretype Equipment {  id: UUID!  name: String!  description: String  condition: String!  brand: String!  quantity: Int!}type Furniture {  id: UUID!  name: String!  description: String  color: String!  material: String!  quantity: Int!}</pre><p class="list-inset">A union type is represented as a union of a list of object types using the <code>|</code> symbol. In this case, the <code>SchoolItem</code> union type includes the <code>Equipment</code> and <code>Furniture</code> object types.</p></li> <li>Then, we<a id="_idIndexMarker1317"/> can query the <code>SchoolItem</code> union type, as follows:<pre class="source-code">
query {  schoolItems {    __typename    ... on Equipment {      id      name      description      condition      brand      quantity    }    ... on Furniture {      id      name      description      color      material      quantity    }  }}
{  "data": {    "schoolItems": [      {        "__typename": "Equipment",        "id": "00000000-0000-0000-0000-000000000701",        "name": "Bunsen Burner",        "description": "Bunsen Burner",        "condition": "Good",        "brand": "Bunsen",        "quantity": 10      },      {        "__typename": "Furniture",        "id": "00000000-0000-0000-0000-000000000801",        "name": "Desk",        "description": "Desk",        "color": "Brown",        "material": "Wood",        "quantity": 20      },      ...    ]  }}</pre><p class="list-inset">In the<a id="_idIndexMarker1319"/> response, you can see that the <code>Equipment</code> object has the <code>condition</code> and <code>brand</code> properties, while the <code>Furniture</code> object has the <code>color</code> and <code>material</code> properties. However, even though the <code>Equipment</code> and <code>Furniture</code> objects have some of the same properties (such as <code>Id</code>, <code>Name</code>, and so on.), the query must specify the properties for each object type. For example, we cannot use the following query:</pre><pre class="source-code">query {  schoolItems {    __typename    id    name   }}</pre><p class="list-inset">The preceding query will cause an error, as follows:</p><pre class="source-code">{  "errors": [    {      "message": "A union type cannot declare a field directly. Use inline fragments or fragments instead.",      "locations": [        {          "line": 2,          "column": 15        }      ],      "path": [        "schoolItems"      ],      "extensions": {        "type": "SchoolItem",        "specifiedBy": "http://spec.graphql.org/October2021/   #sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types"      }    }  ]}</pre></li> </ol>
<p>Please note that<a id="_idIndexMarker1320"/> the <code>SchoolItem</code> union type is not a base type of the <code>Equipment</code> and <code>Furniture</code> object types. If you want to query the common<a id="_idTextAnchor525"/> properties of the object types, you can use the interface type instead of the union type.</p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor526"/>Filtering, sorting, and pagination</h1>
<p>In this section, we will learn how to<a id="_idIndexMarker1321"/> implement filtering, sorting, and pagination in HotChocolate. These features are very important for a real-world application. We will use the <code>Student</code> object as an example to demonstrate how to implement these features. The <code>Student</code> class is defined as follows:</p>
<pre class="source-code">
public class Student{
    public Guid Id { get; set; }
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string? Phone { get; set; }
    public string Grade { get; set; } = string.Empty;
    public DateOnly? DateOfBirth { get; set; }
    public Guid GroupId { get; set; }
    public Group Group { get; set; } = default!;
    public List&lt;Course&gt; Courses { get; set; } = new();
    public List&lt;StudentCourse&gt; StudentCourses { get; set; } = new();
}</pre>
<p>To use<a id="_idIndexMarker1322"/> filtering, sorting, and pagination, we need to install the <code>HotChocolate.Data</code> NuGet package. If you already installed the <code>HotChocolate.Data.EntityFramework</code> package following the previous sections, you do not need to install the <code>HotChocolate.Data</code> package again. The <code>HotChocolate.Data</code> package is a dependency of the <code>HotChocolate.Data.EntityFramework</code> package. If not, you can install the <code>HotChocolate.Data</code> package u<a id="_idTextAnchor527"/>sing the following command:</p>
<pre class="console">
dotnet add package HotChocolate.Data</pre> <p>Let’s begin with filtering!</p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor528"/>Filtering</h2>
<p>HotChocolate <a id="_idIndexMarker1323"/>supports filtering on the object type. A question is how we translate the GraphQL filter to the SQL-native queries. If the resolver exposes an <code>IQueryable</code> interface, HotChocolate can translate the GraphQL filter to SQL-native queries automatically. But we can also implement the filtering logic in the resolver manually. In this section, we will explore how to use filtering in HotChocolate.</p>
<p>To enable filtering on the <code>Student</code> object type, follow these steps:</p>
<ol>
<li>First, we need to register the <code>Filtering</code> middleware in the <code>Program.cs</code> file, as follows:<pre class="source-code">
builder.Services    .AddGraphQLServer()    // Omitted for brevity    .AddFiltering()    .AddMutationType&lt;Mutation&gt;();</pre></li> <li>Add a<a id="_idIndexMarker1324"/> query field in the <code>Query</code> class:<pre class="source-code">
public List&lt;Student&gt; Students { get; set; } = new();</pre></li> <li>Apply the filtering in the resolver of the <code>Students</code> field in the <code>QueryType</code>:<pre class="source-code">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseFiltering()    .Resolve(async context =&gt;    {        var dbContextFactory = context.Service&lt;IDbContextFactory&lt;AppDbContext&gt;&gt;();        var dbContext = await dbContextFactory.CreateDbContextAsync();        var students = dbContext.Students.AsQueryable();        return students;    });</pre><p class="list-inset">The preceding code uses the <code>UseFiltering()</code> method to enable filtering on the <code>Students</code> field. Then, we use the <code>AsQueryable()</code> method to expose the <code>IQueryable</code> interface. This allows HotChocolate to translate the GraphQL filter to SQL-native queries automatically.</p></li> <li>Run the<a id="_idIndexMarker1325"/> application and check the generated schema. You will find the <code>students</code> query has a <code>StudentFilterInput</code> filter, as shown here:<pre class="source-code">
students(where: StudentFilterInput): [Student!]!
input StudentFilterInput {  and: [StudentFilterInput!]  or: [StudentFilterInput!]  id: UuidOperationFilterInput  firstName: StringOperationFilterInput  lastName: StringOperationFilterInput  email: StringOperationFilterInput  phone: StringOperationFilterInput  grade: StringOperationFilterInput  dateOfBirth: DateOperationFilterInput}</pre><p class="list-inset">HotChocolate automatically inspects the <code>Student</code> object type and generates the filter input type. The <code>StudentFilterInput</code> filter includes all the properties of the <code>Student</code> object type by default.</pre></li> <li>Next, we can filter the <code>students</code> query, as follows:<pre class="source-code">
query {  students(where: { firstName: { eq: "John" } }) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}
{  "data": {    "students": [      {        "id": "00000000-0000-0000-0000-000000000901",        "firstName": "John",        "lastName": "Doe",        "email": "",        "phone": null,        "grade": "",        "dateOfBirth": "2000-01-01"      }    ]  }}</pre><p class="list-inset">You can find <a id="_idIndexMarker1327"/>the generated SQL query in the logs, as follows:</pre><pre class="source-code">info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (36ms) [Parameters=[@__p_0='?' (Size = 32)], CommandType='Text',    CommandTimeout='30']      SELECT [s].[Id], [s].[DateOfBirth], [s].[Email], [s].[FirstName], [s].[Grade], [s].[GroupId], [s].   [LastName], [s].[Phone]      FROM [Students] AS [s]      WHERE [s].[FirstName] = @__p_0</pre><p class="list-inset">The preceding SQL query uses the <code>WHERE</code> clause to filter the <code>Student</code> objects, which means the filtering is done in the database.</p></li> <li>The filtering<a id="_idIndexMarker1328"/> can be defined in the variable as well. For example, we can use the following query to filter the <code>Student</code> objects:<pre class="source-code">
query ($where: StudentFilterInput) {  students(where: $where) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}
{  "where": {    "firstName": {      "eq": "John"    }  }}</pre><p class="list-inset">The result is the same as the previous query. You can also try other operators to filter the <code>Student</code> objects. For example, the following variable uses the <code>in</code> operator to filter the <code>Student</code> objects:</pre><pre class="source-code">{  "where": {    "firstName": {      "in": ["John", "Jane"]    }  }}</pre><p class="list-inset">The<a id="_idIndexMarker1329"/> following variable uses the <code>gt</code> operator to filter the students who were born after <code>2001-01-01</code>:</p><pre class="source-code">{  "where": {    "dateOfBirth": {      "gt": "2001-01-01"    }  }}</pre></li> </ol>
<p>The generated filter input type contains all the properties of the object type. Sometimes, we do not need to filter all the properties. For example, we may want to allow filtering on a few properties only. In this case, we can create a custom filter input type and specify the properties we want to filter. Follow these steps to create a custom filter input type:</p>
<ol>
<li>Create a <code>Filters</code> folder in the <code>GraphQL</code> folder. Then, add a new class named <code>StudentFilterType</code>, as follows:<pre class="source-code">
public class StudentFilterType : FilterInputType&lt;Student&gt;{    protected override void Configure(IFilterInputTypeDescriptor&lt;Student&gt; descriptor)    {        descriptor.BindFieldsExplicitly();        descriptor.Field(t =&gt; t.Id);        descriptor.Field(t =&gt; t.GroupId);        descriptor.Field(t =&gt; t.FirstName);        descriptor.Field(t =&gt; t.LastName);        descriptor.Field(t =&gt; t.DateOfBirth);    }}</pre></li> <li>Then, we<a id="_idIndexMarker1330"/> need to specify the filter input type in the resolver. Update the resolver for the <code>students</code> query, as follows:<pre class="source-code">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseFiltering&lt;StudentFilterType&gt;()    // Omitted for brevity</pre></li> <li>Check the generated schema. You will find <code>StudentFilterInput</code> only contains the fields we specified in <code>StudentFilterType</code>, as shown here:<pre class="source-code">
input StudentFilterInput {  and: [StudentFilterInput!]  or: [StudentFilterInput!]  id: UuidOperationFilterInput  groupId: UuidOperationFilterInput  firstName: StringOperationFilterInput  lastName: StringOperationFilterInput  dateOfBirth: DateOperationFilterInput}</pre></li> <li>If the <a id="_idIndexMarker1331"/>model has many properties but we only want to ignore a few properties, we can use the <code>Ignore()</code> method to ignore the properties we do not want to filter. For example, we can update <code>StudentFilterType</code> as follows:<pre class="source-code">
override protected void Configure(IFilterInputTypeDescriptor&lt;Student&gt; descriptor){    descriptor.BindFieldsImplicitly();    descriptor.Ignore(t =&gt; t.Group);    descriptor.Ignore(t =&gt; t.Courses);}
public class StudentStringOperationFilterInputType : StringOperationFilterInputType{    protected override void Configure(IFilterInputTypeDescriptor descriptor)    {        descriptor.Operation(DefaultFilterOperations.Equals).Type&lt;StringType&gt;();        descriptor.Operation(DefaultFilterOperations.Contains).Type&lt;StringType&gt;();    }}</pre><p class="list-inset">The <a id="_idIndexMarker1332"/>preceding code defines a custom <code>StudentStringOperationFilterInputType</code> filter. The <code>StudentStringOperationFilterInputType</code> filter only includes the <code>eq</code> and <code>contains</code> operations. Then, we can use the <code>StudentStringOperationFilterInputType</code> filter in <code>StudentFilterType</code>, as follows:</pre><pre class="source-code">override protected void Configure(IFilterInputTypeDescriptor&lt;Student&gt; descriptor){    // Omitted for brevity    descriptor.Field(t =&gt; t.FirstName).Type&lt;StudentStringOperationFilterInputType&gt;();    descriptor.Field(t =&gt; t.LastName).Type&lt;StudentStringOperationFilterInputType&gt;();}</pre><p class="list-inset">Now, the <code>StudentFilterInput</code> filter only includes the <code>eq</code> and <code>contains</code> operations for the <code>FirstName</code> and <code>LastName</code> properties.</p></li> <li>The filter supports <code>and</code> and <code>or</code> operations. You can find an <code>and</code> and <code>or</code> property in the <code>StudentFilterInput</code> filter. These two fields are used to combine multiple filters. The <code>and</code> field means the filter must match all the conditions. The <code>or</code> field means the filter must match at least one condition. For example, we<a id="_idIndexMarker1333"/> can use the following query to filter the <code>Student</code> objects whose first name is John and who were born after 2001-01-01 using the <code>and</code> operation:<pre class="source-code">
query {  students(where: { and: [{ firstName: { eq: "John" } }, { dateOfBirth: { gt: "2001-01-01" } }] }) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}
query ($where: StudentFilterInput) {  students(where: $filter) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}</pre><p class="list-inset">The variables <a id="_idIndexMarker1334"/>are defined as follows:</pre><pre class="source-code">{  "where": {    "or": [      {        "firstName": {          "eq": "John"        }      },      {        "lastName": {          "eq": "Doe"        }      }    ]  }}</pre></li> </ol>
<p>In the preceding examples, we expose the <code>IQueryable</code> interface in the resolver, so HotChocolate can translate the GraphQL filter to SQL-native queries automatically. However, sometimes, we cannot expose the <code>IQueryable</code> interface in the resolver. In this case, we need to implement the filtering logic in the resolver manually. The code would be more complex. Let<a id="_idIndexMarker1335"/> us see how to implement the filtering logic in the resolver manually:</p>
<ol>
<li>The methods to retrieve the list of the <code>Student</code> type by the group ID are defined in the <code>IStudentService</code> interface, as follows:<pre class="source-code">
public interface IStudentService{    // Omitted for brevity    Task&lt;List&lt;Student&gt;&gt; GetStudentsByGroupIdAsync(Guid groupId);    Task&lt;List&lt;Student&gt;&gt; GetStudentsByGroupIdsAsync(List&lt;Guid&gt; groupIds);}</pre><p class="list-inset">We have two methods for <code>eq</code> and <code>in</code> operations. The <code>GetStudentsByGroupIdAsync()</code> method retrieves the list of <code>Student</code> objects by the group ID. The <code>GetStudentsByGroupIdsAsync()</code> method retrieves the list of <code>Student</code> objects by the list of group IDs. These two methods return the list of <code>Student</code> objects instead of the <code>IQueryable</code> interface. So, we need to implement the filtering logic in the resolver manually.</p></li> <li>Define a customized filter for the <code>Student</code> type as follows:<pre class="source-code">
public class CustomStudentFilterType : FilterInputType&lt;Student&gt;{    protected override void Configure(IFilterInputTypeDescriptor&lt;Student&gt; descriptor)    {        descriptor.BindFieldsExplicitly();        descriptor.Name("CustomStudentFilterInput");        descriptor.AllowAnd(false).AllowOr(false);        descriptor.Field(t =&gt; t.GroupId).Type&lt;CustomStudentGuidOperationFilterInputType&gt;();    }}public class CustomStudentGuidOperationFilterInputType : UuidOperationFilterInputType{    protected override void Configure(IFilterInputTypeDescriptor descriptor)    {        descriptor.Name("CustomStudentGuidOperationFilterInput");        descriptor.Operation(DefaultFilterOperations.Equals).Type&lt;IdType&gt;();        descriptor.Operation(DefaultFilterOperations.In).Type&lt;ListType&lt;IdType&gt;&gt;();    }}</pre><p class="list-inset">In the preceding code, we<a id="_idIndexMarker1336"/> define a custom filter input type named <code>CustomStudentFilterInput</code>. The <code>CustomStudentFilterInput</code> filter only includes the <code>GroupId</code> property. To make the filter more simple, we disable the <code>and</code> and <code>or</code> operations. Then, we define a custom filter input type named <code>CustomStudentGuidOperationFilterInput</code>. The <code>CustomStudentGuidOperationFilterInput</code> filter only includes the <code>eq</code> and <code>in</code> operations. Note that we need to specify the names of the filter input types. Otherwise, HotChocolate will report name conflicts because we already have a <code>StudentFilterInput</code> filter.</p></li> <li>Add a <a id="_idIndexMarker1337"/>new query type in the <code>Query</code> class:<pre class="source-code">
public List&lt;Student&gt; StudentsWithCustomFilter { get; set; } = new();</pre></li> <li>Configure the resolver and manually filter the data in the <code>QueryType</code> class, as follows:<pre class="source-code">
descriptor.Field(x =&gt; x.StudentsWithCustomFilter)    .Description("This is the list of students in the school.")    .UseFiltering&lt;CustomStudentFilterType&gt;()    .Resolve(async context =&gt;    {        var service = context.Service&lt;IStudentService&gt;();        // The following code uses the custom filter.        var filter = context.GetFilterContext()?.ToDictionary();        if (filter != null &amp;&amp; filter.ContainsKey("groupId"))        {            var groupFilter = filter["groupId"]! as Dictionary&lt;string, object&gt;;            if (groupFilter != null &amp;&amp; groupFilter.ContainsKey("eq"))            {                if (!Guid.TryParse(groupFilter["eq"].ToString(), out var groupId))                {                    throw new ArgumentException("Invalid group id", nameof(groupId));                }                var students = await service.GetStudentsByGroupIdAsync(groupId);                return students;            }            if (groupFilter != null &amp;&amp; groupFilter.ContainsKey("in"))            {                if (groupFilter["in"] is not IEnumerable&lt;string&gt; groupIds)                {                    throw new ArgumentException("Invalid group ids", nameof(groupIds));                }                groupIds = groupIds.ToList();                if (groupIds.Any())                {                    var students =                        await service.GetStudentsByGroupIdsAsync(groupIds                            .Select(x =&gt; Guid.Parse(x.ToString())).ToList());                    return students;                }                return new List&lt;Student&gt;();            }        }        var allStudents = await service.GetStudentsAsync();        return allStudents;    });</pre><p class="list-inset">The<a id="_idIndexMarker1338"/> preceding code is a bit complex. We need to get the filter from the <code>context</code> object. Then, we check whether the filter contains the <code>groupId</code> property. If the filter contains the <code>groupId</code> property, we check whether the <code>eq</code> or <code>in</code> operation is specified. If the <code>eq</code> operation is specified, we retrieve the list of <code>Student</code> objects by the group ID. If the <code>in</code> operation is specified, we retrieve the list of <code>Student</code> objects by the list of group IDs. If the <code>eq</code> or <code>in</code> operation is not specified, we retrieve all the <code>Student</code> objects.</p></li> <li>Run the application and check the generated schema. You will find the <code>studentsWithCustomFilter</code> query has a <code>CustomStudentFilterInput</code> filter, as shown here:<pre class="source-code">
input CustomStudentFilterInput {  groupId: CustomStudentGuidOperationFilterInput}input CustomStudentGuidOperationFilterInput {  and: [CustomStudentGuidOperationFilterInput!]  or: [CustomStudentGuidOperationFilterInput!]  eq: ID  in: [ID]}
query ($where: CustomStudentFilterInput) {  studentsWithCustomFilter(where: $where) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}</pre><p class="list-inset">To filter the <code>Student</code> objects by <code>groupId</code>, we can define the following variable:</pre><pre class="source-code">{  "where": {    "groupId": {      "eq": "00000000-0000-0000-0000-000000000201"    }  }}</pre><p class="list-inset">To filter the <code>Student</code> objects by the list of group IDs, we can define the following variable:</p><pre class="source-code">{  "where": {    "groupId": {      "in": ["00000000-0000-0000-0000-000000000201", "00000000-0000-0000-0000-000000000202"]    }  }}</pre></li> </ol>
<p>As the filtering<a id="_idIndexMarker1340"/> variables may vary in different cases, the logic to filter the data may be different. It is recommended to use the <code>IQueryable</code> int<a id="_idTextAnchor529"/>erface if possible, so that HotChocolate can translate the GraphQL filter to SQL-native queries automatically.</p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor530"/>Sorting</h2>
<p>In this section, we will learn how to <a id="_idIndexMarker1341"/>use sorting in HotChocolate. The sorting is similar to filtering. We can use the <code>UseSorting()</code> method to enable sorting on the object type. If we use the <code>IQueryable</code> interface in the resolver, HotChocolate can translate the GraphQL sorting to SQL-native queries automatically. Otherwise, we need to implement the sorting logic in the resolver manually.</p>
<p>To enable<a id="_idIndexMarker1342"/> sorting on the <code>Student</code> object type, the <code>HotChocolate.Data</code> package is required. Follow the step just before the <em class="italic">Filtering</em> section to install the <code>HotChocolate.Data</code> package if you have not installed it yet. Then, follow these <a id="_idIndexMarker1343"/>steps to enable sorting on the <code>Student</code> object type:</p>
<ol>
<li>Register the <code>Sorting</code> middleware in the <code>Program.cs</code> file, as follows:<pre class="source-code">
builder.Services    .AddGraphQLServer()    // Omitted for brevity    .AddSorting()    .AddMutationType&lt;Mutation&gt;();</pre></li> <li>Update the resolver for the <code>students</code> query:<pre class="source-code">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting()    // Omitted for brevity</pre><p class="list-inset">Note that <code>UseSorting()</code> must be placed after <code>UseFiltering</code>.</p></li> <li>Then, run the application and check the generated schema. You will find the <code>students</code> query has an <code>orderBy</code> argument, as shown here:<pre class="source-code">
students(where: StudentFilterInput, order: [StudentSortInput!]): [Student!]!
input StudentSortInput {  id: SortEnumType  firstName: SortEnumType  lastName: SortEnumType  email: SortEnumType  phone: SortEnumType  grade: SortEnumType  dateOfBirth: SortEnumType  groupId: SortEnumType  group: GroupSortInput}</pre><p class="list-inset">The <code>StudentSortInput</code> type includes all the properties of the <code>Student</code> object<a id="_idIndexMarker1344"/> type. The <code>SortEnumType</code> type is an enum type, as follows:</pre><pre class="source-code">enum SortEnumType {  ASC  DESC}</pre><p class="list-inset">The <code>SortDirection</code> type includes two values: <code>ASC</code> and <code>DESC</code>. The <code>ASC</code> value means the sorting is ascending. The <code>DESC</code> value means the sorting is descending.</p></li> <li>Next, we can query the <code>Student</code> type with sorting. The following query will sort the results by first name:<pre class="source-code">
query ($order: [StudentSortInput!]) {  students(order: $order) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}
{  "order": [    {      "firstName": "ASC"    }  ]}</pre><p class="list-inset">The<a id="_idIndexMarker1345"/> sorting variable supports multiple properties. For example, the following query variable will sort the results by first name and last name:</pre><pre class="source-code">{  "order": [     {        "firstName": "ASC"     },     {        "lastName": "ASC"     }  ]}
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (3ms) [Parameters=[], CommandType='Text', CommandTimeout='30']      SELECT [s].[Id], [s].[DateOfBirth], [s].[Email], [s].[FirstName], [s].[Grade], [s].[GroupId], [s].   [LastName], [s].[Phone]      FROM [Students] AS [s]      ORDER BY [s].[FirstName], [s].[LastName]</pre><p class="list-inset">The preceding SQL query uses the <code>ORDER BY</code> clause to sort the <code>Student</code> objects, which means the sorting is done in the database.</pre></li> </ol>
<p>Similar to filtering, the <a id="_idIndexMarker1346"/>default sorting includes all the properties of the object type. If we want to sort on specific properties only, we can create a custom sort input type and specify the properties we want to sort. Follow these steps to create a custom sort input type:</p>
<ol>
<li>Create a folder named <code>Sorts</code> in the <code>GraphQL</code> folder. Add a new class named <code>StudentSortType</code>, as follows:<pre class="source-code">
public class StudentSortType : SortInputType&lt;Student&gt;{    protected override void Configure(ISortInputTypeDescriptor&lt;Student&gt; descriptor)    {        descriptor.BindFieldsExplicitly();        descriptor.Field(x =&gt; x.FirstName);        descriptor.Field(x =&gt; x.LastName);        descriptor.Field(x =&gt; x.DateOfBirth);    }}</pre><p class="list-inset">The preceding code defines a custom sort input type, which only includes the <code>FirstName</code>, <code>LastName</code>, and <code>DateOfBirth</code> properties.</p><p class="list-inset">Similar to <a id="_idIndexMarker1347"/>the filter input type, you can explicitly specify the properties you want to sort, or you can ignore the properties you do not want to sort.</p></li> <li>Update the resolver to apply the custom sort input type:<pre class="source-code">
descriptor.Field(x =&gt; x.Students)    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity</pre></li> <li>Run the application and check the schema. You will see that <code>StudentSortInput</code> now has three properties only:<pre class="source-code">
input StudentSortInput {  firstName: SortEnumType  lastName: SortE<a id="_idTextAnchor531"/>numType  dateOfBirth: SortEnumType}</pre></li> </ol>
<p>The query is similar to the previous example, so we will not repeat it here.</p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor532"/>Pagination</h2>
<p>Pagination is a common feature in web API development. In this section, we will learn how to use<a id="_idIndexMarker1348"/> pagination in HotChocolate.</p>
<p>Similar to filtering and sorting, we need to install the <code>HotChocolate.Data</code> package to use pagination. HotChocolate supports two types of pagination:</p>
<ul>
<li><strong class="bold">Cursor-based pagination</strong>: This <a id="_idIndexMarker1349"/>is the default pagination in HotChocolate. It uses a cursor to indicate the current position in the list. The cursor is usually an ID or a timestamp, which is opaque to the client.</li>
<li><code>skip</code> and <code>take</code> arguments<a id="_idIndexMarker1350"/> to paginate the list.</li>
</ul>
<p>Let’s first use <a id="_idIndexMarker1351"/>cursor-based pagination to paginate the <code>Student</code> objects. As we introduced before, if we use the <code>IQueryable</code> interface<a id="_idIndexMarker1352"/> in the resolver, HotChocolate can translate the GraphQL pagination to SQL-native queries automatically. Follow the next steps to use cursor-based pagination for the <code>students</code> query:</p>
<ol>
<li>Update the resolver for the <code>students</code> query:<pre class="source-code">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UsePaging()    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity</pre><p class="list-inset">Note that <code>UsePaging()</code> must be placed before <code>UseFiltering()</code> and <code>UseSorting()</code>.</p></li> <li>Run the application and check the generated schema. You will find that the <code>students</code> query now is the <code>StudentsConnection</code> type:<pre class="source-code">
students(  first: Int  after: String  last: Int  before: String  where: StudentFilterInput  order: [StudentSortInput!]): StudentsConnection
type StudentsConnection {  pageInfo: PageInfo!  edges: [StudentsEdge!]  nodes: [Student!]}</pre><p class="list-inset">In GraphQL, the <a id="_idIndexMarker1353"/>connection type is a <a id="_idIndexMarker1354"/>standard way to paginate the list. The <code>StudentsConnection</code> type includes three fields: <code>pageInfo</code>, <code>edges</code>, and <code>nodes</code>. The <code>nodes</code> field is a list of the <code>Student</code> objects. The <code>edges</code> and <code>pageInfo</code> fields are defined in the <code>StudentsEdge</code> and <code>PageInfo</code> types as follows:</pre><pre class="source-code">type StudentsEdge {  cursor: String!  node: Student!}type PageInfo {  hasNextPage: Boolean!  hasPreviousPage: Boolean!  startCursor: String  endCursor: String}</pre></li> <li>Next, we can<a id="_idIndexMarker1355"/> query the paginated <code>Student</code> objects as follows:<pre class="source-code">
query {  students {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    pageInfo {      hasNextPage      hasPreviousPage    }  }}
{  "data": {    "students": {      "edges": [        {          "cursor": "MA==",          "node": {            "id": "00000000-0000-0000-0000-000000000901",            "firstName": "John",            "dateOfBirth": "2000-01-01"          }        },        ...        {          "cursor": "OQ==",          "node": {            "id": "00000000-0000-0000-0000-000000000910",            "firstName": "Jack",            "dateOfBirth": "2000-01-10"          }        }      ],      "pageInfo": {        "hasNextPage": true,        "hasPreviousPage": false      }    }  }}</pre><p class="list-inset">The result contains a <code>cursor</code> field for each <code>Student</code> object. The <code>cursor</code> field is an opaque string, which is used to indicate the current position in the list. The <code>pageInfo</code> field indicates whether<a id="_idIndexMarker1357"/> there are more pages. In this case, the <code>hasNextPage</code> field is <code>true</code>, which means there are more pages.</pre></li> <li>To query<a id="_idIndexMarker1358"/> the next page, we need to specify the <code>after</code> parameter:<pre class="source-code">
query {  students(after: "OQ==") {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    pageInfo {      hasNextPage      hasPreviousPage    }  }}
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (11ms) [Parameters=[@__p_0='?' (DbType = Int32), @__p_1='?' (DbType = Int32)],    CommandType='Text', CommandTimeout='30']      SELECT [s].[Id], [s].[DateOfBirth], [s].[Email], [s].[FirstName], [s].[Grade], [s].[GroupId], [s].   [LastName], [s].[Phone]      FROM [Students] AS [s]      ORDER BY (SELECT 1)      OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY</pre><p class="list-inset">The <a id="_idIndexMarker1359"/>preceding SQL query uses the <code>OFFSET</code> and <code>FETCH</code> clauses to paginate the <code>Student</code> objects, which means the <a id="_idIndexMarker1360"/>pagination is handled in the database.</pre></li> <li>To query the previous page, we need to specify the <code>before</code> parameter, as in this example:<pre class="source-code">
query {  students(before: "MA==") {     edges {        cursor        node {          id          firstName          dateOfBirth        }     }     pageInfo {        hasNextPage        hasPreviousPage     }  }}</pre></li> <li>We can <a id="_idIndexMarker1361"/>specify the options for pagination in the <code>UsePaging()</code> method. For example, we can specify the default page size and <a id="_idIndexMarker1362"/>include the total count in the <code>UsePaging()</code> method, as follows:<pre class="source-code">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UsePaging(options: new PagingOptions()    {        MaxPageSize = 20,        DefaultPageSize = 5,        IncludeTotalCount = true    })    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity
query {  students {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    totalCount    pageInfo {      hasNextPage      hasPreviousPage    }  }}</pre><p class="list-inset">You can <a id="_idIndexMarker1363"/>see the <code>totalCount</code> field in the response. The default page size is <code>5</code>.</pre></li> <li>We can use <a id="_idIndexMarker1364"/>pagination with filtering and sorting. The following query will filter the <code>Student</code> objects by first name and sort the results by first name and then by last name:<pre class="source-code">
query ($where: StudentFilterInput, $order: [StudentSortInput!]) {  students(where: $where, order: $order) {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    totalCount    pageInfo {      hasNextPage      hasPreviousPage    }  }}
{   "where":{      "dateOfBirth":{         "gt":"2001-01-01"      }   },   "order":[      {         "firstName":"ASC"      },      {         "lastName":"ASC"      }   ]}</pre><p class="list-inset">After <a id="_idIndexMarker1367"/>querying the first page, we can query the next page, as follows:</pre><pre class="source-code">query ($where: StudentFilterInput, $order: [StudentSortInput!]) {  students(where: $where, order: $order, after: "NA==") {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    totalCount    pageInfo {      hasNextPage      hasPreviousPage    }  }}</pre><p class="list-inset">You can also <a id="_idIndexMarker1368"/>define the <code>after</code> parameter in the query variable, as follows:</p><pre class="source-code">{   "where":{      "dateOfBirth":{         "gt":"2001-01-01"      }   },   "order":[      {         "firstName":"ASC"      },      {         "lastName":"ASC"      }   ],   "after":"NA=="}</pre></li> </ol>
<p>The query<a id="_idIndexMarker1369"/> language of GraphQL is very flexible. We <a id="_idIndexMarker1370"/>cannot list all the possible queries here. You can try different queries by yourself.</p>
<p>HotChocolate supports <a id="_idIndexMarker1371"/>offset-based pagination as well. To <a id="_idIndexMarker1372"/>use offset-based pagination, we need to use the <code>UseOffsetPaging()</code> method instead of the <code>UsePaging()</code> method. Follow these steps to use offset-based pagination:</p>
<ol>
<li>Update the resolver for the <code>students</code> query:<pre class="source-code">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseOffsetPaging()    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity</pre><p class="list-inset">The preceding code uses the <code>UseOffsetPaging()</code> method to enable offset-based pagination instead of cursor-based pagination.</p></li> <li>Run the<a id="_idIndexMarker1373"/> application and check the <a id="_idIndexMarker1374"/>generated schema. You will find the <code>students</code> query is now the <code>StudentsCollectionSegment</code> type:<pre class="source-code">
students(  skip: Int  take: Int  where: StudentFilterInput  order: [StudentSortInput!]): StudentsCollectionSegmenttype StudentsCollectionSegment {  pageInfo: CollectionSegmentInfo!  items: [Student!]}type CollectionSegmentInfo {  hasNextPage: Boolean!  hasPreviousPage: Boolean!}</pre><p class="list-inset">You should be familiar with the <code>skip</code> and <code>take</code> arguments. The <code>skip</code> argument is used to skip the first <code>n</code> items. The <code>take</code> argument is used to take the first <code>n</code> items. We already used these two methods in LINQ to implement the pagination.</p></li> <li>Next, we <a id="_idIndexMarker1375"/>can query the paginated <code>Student</code> objects as follows:<pre class="source-code">
 query {   students {     items {       id       firstName       dateOfBirth     }     pageInfo {       hasNextPage       hasPreviousPage     }   } }</pre></li> <li>To <a id="_idIndexMarker1376"/>query the next page, we need to specify the <code>skip</code> and <code>take</code> parameters, as follows:<pre class="source-code">
query {  students(skip: 5, take: 5) {    items {      id      firstName      dateOfBirth    }    pageInfo {      hasNextPage      hasPreviousPage    }  }}</pre></li> <li>You <a id="_idIndexMarker1377"/>can define the <code>skip</code> and <code>take</code> parameters in the query variable as follows:<pre class="source-code">
{  "skip": 5,  "take": 5}</pre></li> <li>We can<a id="_idIndexMarker1378"/> specify the pagination options in the <code>UseOffsetPaging</code> method:<pre class="source-code">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseOffsetPaging(options: new PagingOptions()    {        MaxPageSize = 20,        DefaultPageSize = 5,        IncludeTotalCount = true    })    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity</pre><p class="list-inset">You can include the <code>totalCount</code> field in the response now.</p></li> <li>We can use <a id="_idIndexMarker1379"/>pagination with filtering and sorting. The following query will filter the <code>Student</code> objects by first name and sort the results by first name and then by last name, and then fetch the second page:<pre class="source-code">
query ($where: StudentFilterInput, $order: [StudentSortInput!], $skip: Int!, $take: Int!) {     students(where: $where, order: $order, skip: $skip, take: $take) {       items {         id         firstName         dateOfBirth       }       totalCount       pageInfo {         hasNextPage         hasPreviousPage       }     }   }
{   "where":{      "dateOfBirth":{         "gt":"2001-01-01"      }   },   "order":[      {         "firstName":"ASC"      },      {         "lastName":"ASC"      }   ],   "skip":5,   "take":5}</pre><p class="list-inset">The <a id="_idIndexMarker1381"/>generated SQL query is shown<a id="_idIndexMarker1382"/> here:</pre><pre class="source-code">info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (2ms) [Parameters=[@__p_0='?' (DbType = Date), @__p_1='?' (DbType = Int32),    @__p_2='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']      SELECT [s].[Id], [s].[DateOfBirth], [s].[Email], [s].[FirstName], [s].[Grade], [s].[GroupId], [s].   [LastName], [s].[Phone]      FROM [Students] AS [s]      WHERE [s].[DateOfBirth] &gt; @__p_0      ORDER BY [s].[First<a id="_idTextAnchor533"/>Name], [s].[LastName]      OFFSET @__p_1 ROWS FETCH NEXT @__p_2 ROWS ONLY</pre></li> </ol>
<p>The preceding <a id="_idIndexMarker1383"/>SQL query <a id="_idIndexMarker1384"/>shows that the pagination is handled in the database.</p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor534"/>Visualizing the GraphQL schema</h1>
<p>When the<a id="_idIndexMarker1385"/> GraphQL API becomes more complex, it is difficult to understand the schema. We can use <code>GraphQL Voyager</code> to visualize the GraphQL schema. <code>GraphQL Voyager</code> is an open-source project that can visualize the GraphQL schema in an interactive graph. It is a frontend application that can be integrated with the GraphQL API. To use it in our ASP.NET Core application, we can use the <code>GraphQL.Server.Ui.Voyager</code> package. This package is part of the GraphQL.NET project.</p>
<p>Follow these steps<a id="_idIndexMarker1386"/> to use GraphQL Voyager in our application:</p>
<ol>
<li>Install the <code>GraphQL.Server.Ui.Voyager</code> package using the following command:<pre class="source-code">
<code>Program.cs</code> file:<pre class="source-code">
app.MapGraphQLVoyager();</pre><p class="list-inset">The preceding code adds a middleware that maps the Voyager UI to the default URL <code>ui/voyager</code>. If you want to specify a different URL, you can pass the URL as a parameter, as in this example:</p><pre class="source-code">app.MapGraphQLVoyager("/voyager");</pre></li> <li>Run the application and navigate to the <code>ui/voyager</code> URL. You will see the following page:</li>
</ol>
<div><div><img alt="Figure 12.5 – The GraphQL Voyager UI" src="img/B18971_12_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Overview of the GraphQL Voyager UI</p>
<p>Visualizing<a id="_idIndexMarker1387"/> the <a id="_idIndexMarker1388"/>GraphQL schema can be beneficial for your team. Doing so allows you to share the schema with your team members, making it easier to collaborate and stay on the same page.</p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor535"/>Summary</h1>
<p>In this chapter, we explored how to use HotChocolate and Entity Framework Core to create a GraphQL API. We discussed how to define object types, queries, and mutations, as well as how to use dependency injection to inject the <code>DbContext</code> instance and services into the resolver. We also introduced the data loader, which can reduce the number of queries to the database. Additionally, we discussed interface and union types, which are useful for defining polymorphic types. Finally, we explored how to use filtering, sorting, and pagination in HotChocolate.</p>
<p>In the next chapter, we will discuss SignalR, which is a real-time communication library in ASP.NET Core.</p>
<h1 id="_idParaDest-279"><a id="_idTextAnchor536"/>Further reading</h1>
<p>It is important to note that GraphQL is a comprehensive query language and there are many features that we were unable to cover in this chapter. For example, GraphQL supports subscriptions, which enable real-time communication with the GraphQL API. To learn more about HotChocolate and GraphQL, please refer to the following resources:</p>
<ul>
<li><a href="https://graphql.org/learn/">https://graphql.org/learn/</a></li>
<li><a href="https://chillicream.com/docs/hotchocolate/">https://chillicream.com/docs/hotchocolate/</a></li>
</ul>
<p>In a microservice architecture, we can use Apollo Federation to create a GraphQL gateway. Apollo Federation can combine multiple GraphQL APIs into a single GraphQL API. We will not cover Apollo Federation here as it is out of the scope of this book. To learn more about Apollo Federation, please refer to the following resources:</p>
<ul>
<li><a href="https://www.apollographql.com/">https://www.apollographql.com/</a></li>
<li><a href="https://github.com/apollographql">https://github.com/apollographql</a></li>
</ul>
</div>
</body></html>