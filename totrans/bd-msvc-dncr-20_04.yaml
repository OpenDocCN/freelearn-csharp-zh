- en: Testing Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quality assurance, or testing, is a great way to assess a system, program,
    or an application with different aspects. Sometimes, a system requires testing
    to identify erroneous code, on other occasions we may need it to assess our system''s
    business compliance. Testing can vary from system to system and can be considerably
    different depending on the architectural style of the application. Everything
    depends on how we are strategizing our testing approach or plan. For example,
    testing a monolith .NET application is different to testing SOA or microservices.
    In this chapter, we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to test microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing pyramid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of microservice tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing microservices can be a challenging job, as it is different from how
    we test applications built using the traditional architectural style. Testing
    a .NET monolithic application is a bit easier than testing a microservice, which
    provides implementation independence and short delivery cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand it in the context of our .NET monolithic application, where
    we did not utilize continuous integration and deployment. It becomes more complex
    when testing is combined with continuous integration and deployment. For microservices,
    we are required to understand the tests for every service and how these tests
    differ from each other. Also, note that automated testing does not mean that we
    will not perform any manual testing at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few things that make microservice testing a complex and challenging
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices might have multiple services that work together or individually
    for an enterprise system, so they can be complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices are meant to target multiple clients; hence, they involve more
    complex use cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component/service of the microservice architectural style is isolated and
    independent, so it is a bit complex to test them as they need to be tested individually
    and as a complete system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There might be independent teams working on separate components/services that
    might be required to interact with each other. Therefore, tests should cover not
    only internal services but also external services. This makes the job of testing
    microservices more challenging and complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component/service in a microservice is designed to work independently,
    but they might have to access common/shared data where each service is responsible
    for modifying its own database. So, testing microservices is going to be more
    complex as services need to access data using API calls to other services, which
    further adds dependencies to other services. This type of testing will have to
    be handled using mock tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we discussed how testing a microservice is a complex
    and challenging job. In this section, we will discuss some points that will indicate
    how conducting various tests could help us overcome these challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: A unit test framework, such as Microsoft Unit Testing Framework, provides a
    facility to test individual operations of independent components. To ensure that
    all the tests pass and that a new functionality or change does not break anything
    (if any functionality breaks down, then the related unit test would fail), these
    tests can be run on every compilation of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make sure that responses are consistent with the expectations of the clients
    or consumers, consumer-driven contract testing can be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services use data from an external party or from other services, and they can
    be tested by setting up the endpoint of the services that are responsible for
    handling the data. Then we can use a mocking framework or library such as `moq` to
    mock these endpoints during the integration process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing strategies (testing approach)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the *Prerequisites* section of *Chapter 1, An Introduction to
    Microservices*, deployment and QA requirements can become more demanding. The
    only way to effectively handle this scenario would be through preemptive planning.
    I have always favored the inclusion of the QA team during the early requirement
    gathering and design phase. In the case of microservices, it becomes a necessity
    to have a close collaboration between the architecture group and the QA group.
    Not only will the QA team's input be helpful, but they will be able to draw up
    a strategy to test the microservices effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Test strategies are merely a map or outlined plan that describes the complete
    approach of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Different systems require different testing approaches. It is not possible to
    implement a pure testing approach to a system that is developed using a newer
    approach rather than the earlier developed system. Testing strategies should be
    clear to everyone so that the created tests can help non-technical members of
    the team (such as stakeholders) understand how the system is working. Such tests
    can be automated, simply testing the business flow, or they could be manual tests,
    which can be simply performed by a user working on the User Acceptance Testing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing strategies or approaches have the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Proactive: This is a kind of early approach and tries to fix defects before
    the build is created from the initial test designs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reactive: In this approach, testing is started once coding is completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The testing pyramid is a strategy or a way to define what you should test in
    microservices. In other words, we can say it helps us define the testing scope
    of microservices. The concept of the testing pyramid was originated by Mike Cohn ([http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid](http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid))
    in 2009\. There are various flavors of the testing pyramid; different authors
    have described this by indicating how they had placed or prioritized their testing
    scope. The following image depicts the same concept that was defined by Mike Cohn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7179b98-8b5e-4876-b699-9b7481169763.png)'
  prefs: []
  type: TYPE_IMG
- en: The** Testing pyramid** showcases how a well-designed test strategy is structured.
    When we look closely at it, we can easily see how we should follow the testing
    approach for microservices (note that the testing pyramid is not specific to microservices).
    Let's start from the bottom of this pyramid. We can see that the testing scope
    is limited to the use of **Unit tests**. As soon as we move to the top, our testing
    scope is expanded into a broader scope where we can perform complete system testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s talk about these layers in detail (bottom-to-top approach):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These are tests that test small functionalities of an application
    based on the microservice architectural style'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service tests**: These are tests that test an independent service or a service
    that communicates with another/external service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System tests**: These are tests that help in testing an entire system with
    an aspect of the user interface. These are end-to-end tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One interesting point in this concept is that the top-layered tests, that is,
    system tests, are slow and expensive to write and maintain. On the other hand,
    the bottom-layered tests, that is, unit tests, are comparatively fast and less
    expensive.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will discuss these tests in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Types of microservice tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed test approaches or testing strategies.
    These strategies decide how we will proceed with the testing of the system. In
    this section, we will discuss various types of microservice testing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit tests are tests that typically test a single function call to ensure that
    the smallest piece of the program is tested. So these tests are meant to verify
    specific functionality without considering other components:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing will be more complex when components are broken down into small, independent
    pieces that are supposed to be tested independently. Here, testing strategies
    come in handy and ensure that the best quality assurance of a system will be performed.
    It adds more power when it comes with the **Test-Driven Development** (**TDD**)
    approach. We will discuss this with the help of an example in *Unit tests* which
    is a sub-section of *Tests in Action*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn and practice TDD with the help of Katas at [https://github.com/garora/TDD-Katas](https://github.com/garora/TDD-Katas)
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests can be of any size; there is no definite size for a unit test. Generally,
    these tests are written at the class level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller unit tests are good for testing every possible functionality of a complex
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component (service) testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Component or service testing is a method where we bypass the UI and directly
    test the API (in our case, the ASP.NET Core Web API). Using this test, we confirm
    that an individual service does not have any code bugs and that it is working
    fine functionality-wise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing a service does not mean it is an independent service. This service
    might be interacting with an external service. In such a scenario, we should not
    call the actual service but use the mock and stub approach. The reason for this
    is our motto: to test code and make sure it is bug-free. In our case, we will
    use the `moq` framework for mocking our services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things worth noting for component or service testing:'
  prefs: []
  type: TYPE_NORMAL
- en: As we need to verify the functionality of the services, these kinds of tests
    should be small and fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the help of mocking, we don't need to deal with the actual database; therefore,
    test execution time is less or nominally higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of these tests is broader than unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In unit testing, we test a single unit of code. In component or service testing,
    we test mock services depending on an external or third-party component. But integration
    testing in microservices can be a bit challenging, as in this type of testing
    we test components that work together. Service calls here should be made that
    integrate with external services. In this test strategy, we make sure that the
    system is working together correctly and the behavior of services is as expected.
    In our case, we have various microservices and some of them depend upon external
    services.
  prefs: []
  type: TYPE_NORMAL
- en: For example, StockService depends upon OrderService in a way that a particular
    number of items is reduced from the stock as soon as the customer successfully
    orders that specific item. In this scenario, when we test StockService, we should
    mock OrderService. Our motto should be to test StockService and not communicate
    with OrderService. We do not test the database of any service directly.
  prefs: []
  type: TYPE_NORMAL
- en: Contract testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contract testing is an approach where each service call independently verifies
    the response. If any service is dependent then dependencies are stubbed. This
    way, the service functions without interacting with any other service. This is
    an integration test that allows us to check the contract of external services.
    Here we come to a concept called the consumer-driven contract (we will discuss
    this in detail in the following section).
  prefs: []
  type: TYPE_NORMAL
- en: For example, CustomerService allows new customers to register with the FlixOne
    Store. We do not store new customers' data in our database. We verify customer
    data before this to check for blacklisting or fraud user listing and so on. This
    process calls an external service that is maintained by another team or entirely
    by a third-party. Out tests will still pass if someone changes the contract of
    this external service because this change would not affect our test, as we stubbed
    the contract of this external service.
  prefs: []
  type: TYPE_NORMAL
- en: Consumer-driven contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In microservices, we have several services that are independent or services
    that require communication with each other. Apart from this, from a user's (here,
    the user is a developer, who is consuming the API being referred to) point of
    view, they know about the service and whether it has, or doesn't have, several
    clients/consumers/users. These clients can have the same or different needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consumer-driven contracts refer to a pattern that specifies and verifies all
    the interactions between clients/consumers and the API owner (application). So
    here, consumer-driven means that the client/consumer specifies what kind of interactions
    it is asking for with the defined format. On the other hand, the API owner (application
    services) must then agree to these contracts and ensure that they are not breaking
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfe6dbe5-454f-4ff7-ac5c-f5157537d6b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: Provider contract: This is merely a complete description of the service provided
    by the API owner (application). Swagger's documentation can be used for our REST
    API (web API).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumer contract: This is a description of how consumers/clients are going
    to utilize the provider contract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumer-driven contract: This is a description of how the API owner satisfies
    consumer/client contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a consumer-driven test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of microservices, it's a bit more challenging to implement a consumer-driven
    test than for a .NET monolithic application. This is because, in monolithic applications,
    we can directly use any unit test framework, such as MS tests or NUnit, but we
    can't do this directly in the microservice architecture. In microservices, we
    would need to mock not only method calls but also the services themselves, which
    get called via either HTTP or HTTPs.
  prefs: []
  type: TYPE_NORMAL
- en: To implement a consumer-driven test, there are tools available that will help.
    One famous open source tool for a .NET framework is *PactNe*t ([https://github.com/SEEK-Jobs/pact-net](https://github.com/SEEK-Jobs/pact-net))
    and another for .NET Core is *Pact.Net Core* ([https://github.com/garora/pact-net-core](https://github.com/garora/pact-net-core)).
    These are based on *Pact* ([https://docs.pact.io/](https://docs.pact.io/)) standards.
    We will see consumer-driven contract testing in action at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How Pact-net-core helps us achieve our goal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a consumer-driven test, our goal is to make sure that we are able to test
    all the services, internal components, and services that depend on or communicate
    with other/external services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pact-net-core is written in a way that guarantees the contracts would be met.
    Here are a few points on how it helps us to achieve our goal:'
  prefs: []
  type: TYPE_NORMAL
- en: The execution is very fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps identify failure causes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main thing is that Pact does not require a separate environment to manage
    automation test integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two steps for working with Pact:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining expectations: In the very first step, the consumer team has to define
    the contract. In the preceding image, Pact helps record the consumer contract,
    which will be verified when replayed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d0486369-1395-43de-9f84-335f3c705236.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Verifying expectations: As part of the next step, the contract is provided
    to the provider team and then the provider service is implemented to fulfill the
    same. In the following image, we are showing the replaying of a contract on the
    provider side to fulfill the defined contract:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/59651ba9-f277-4e4d-8e13-efbbe81d90aa.png)'
  prefs: []
  type: TYPE_IMG
- en: We have gone through consumer-driven contracts; they mitigate the challenges
    of microservice architectures with the help of an open source tool called Pact-net.
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is non-functional testing, and its main motto is not to verify the code
    or test the code's health. This is meant to ensure that the system is performing
    well, based on the various measures, namely scalability, reliability, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the different techniques or types of performance testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load testing: This is a process where we test the behavior of the system under
    various circumstances of a specific load. It also covers critical transactions,
    database load, application servers, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stress testing: This is an approach where the system goes under regress testing
    and finds the upper limit capacity of the system. It also determines how a system
    behaves in this critical situation, when the current load goes above the expected
    maximum load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Soak testing: This is also called *endurance testing*. In this test, the main
    purpose is to monitor memory utilization, memory leaks, or various factors that
    affect the system performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spike testing: This is an approach where we make sure that the system is able
    to sustain the workload. One of the best tasks to determine performance is by
    suddenly increasing the user load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end (UI/functional) testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: End-to-end, UI, or functional tests are those that are performed for the entire
    system, including the entire service and database. These tests increase the scope
    of testing. It is the highest level of testing, includes frontend integration,
    and tests the system as an end user would use it. This testing is similar to how
    an end user would work on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Sociable versus isolated unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sociable unit tests are those that contain concrete collaborators and cross
    boundaries. They are not solitary tests. Solitary tests are those that ensure
    that the methods of a class are tested. Sociable testing is not new. This word
    is explained in detail by Martin Fowler as a unit test ([https://martinfowler.com/bliki/UnitTest.html](https://martinfowler.com/bliki/UnitTest.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sociable tests: This is a test that lets us know the application is working
    as expected. This is the environment where other applications behave correctly,
    run smoothly, and produce the expected results. It also, somehow, tests the functioning
    of new functions/methods, including other software for the same environment. Sociable
    tests resemble system testing because these tests behave like system tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Isolated unit tests: As the name suggests, you can use these tests to perform
    unit testing in an isolated way by performing stubbing and mocking. We can perform
    unit testing with a concrete class using stubs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubs and mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stubs are returned, canned responses to calls made during the test; mocks are
    meant to set expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stubs: In a stubs object, we always get a valid stubbed response. The response
    doesn’t care what input you provide. In any circumstance, the output will be the
    same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mocks: In a mock object, we can test or validate methods that can be called
    on mocked objects. This is a fake object that validates whether a unit test has
    failed or passed. In other words, we can say that mock objects are just a replica
    of our actual object. In the following code, we use the `moq` framework to implement
    a mocked object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we mocked our `IProductRepository` repository
    and verified the mocked result.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will understand these terms in more detail, using
    more code examples from our FlixOne bookstore application.
  prefs: []
  type: TYPE_NORMAL
- en: Tests in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have discussed test strategies and various types of microservice
    tests. We''ve also discussed how to test and what to test. In this section, we
    will see tests in action; we will implement tests with the use of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 Update 3 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# 7.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: xUnit and MS tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The moq framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready for the test project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will test our microservice application: FlixOne bookstore. With the help
    of code examples, we will see how to perform unit tests, stubbing, and mocking.'
  prefs: []
  type: TYPE_NORMAL
- en: We created the FlixOne bookstore application in *Chapter 2, Implementing Microservices.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start writing tests, we should set up a test project in our existing
    application. There are a few simple steps we can take with this test project setup:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From Solution Explorer within Using Visual Studio, right-click on Solution
    and click New Project—refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c808f29-36e5-4506-87c3-163b0c2a098b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the Add New Project template select .NET Core and xUnit Test Project (.NET
    Core), and provide a meaningful name, for example, `FlixOne.BookStore.ProductService.UnitTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c418de5d-1b85-4093-b12b-255078d23952.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to project Properties, by right-clicking on the project name from Solution
    Explorer. Open the Build tab from the Properties page and click on Advance and
    select C# 7.0 as Language version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/75e04409-c014-4cf6-8c00-3e262122578e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our project structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29a503f2-4471-43c0-861c-740ffbff730d.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `ProductService`, let''s make sure our service returns product data without
    failure by testing it. Here we will use fake objects to do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new folder and name it `Fake` in the `FlixOne.BookStore.ProductService.UnitTests`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the `Fake` folder add the `ProductData.cs` class and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, we are creating fake data by creating two lists
    of `ProductViewModel` and `Product`.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Services` folder in the `FlixOne.BookStore.ProductService.UnitTests` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the `Services` folder add the `ProductTests.cs` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open NuGet Manager and then search for and add `moq`, refer to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad0eb9e9-68f1-4b04-95e1-0d6e1e177710.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code to the `ProductTests.cs` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, which is a unit test example, we are mocking
    our repository and testing the output of our WebAPI controller. This test is based
    on the *AAA* technique; it will be passed if you meet the mocked data during setup.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `ProductService`, let''s make sure that our service returns the product
    data without failure. Before we proceed, we have to add a new project and subsequent
    test classes, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right click on Solution and then Add Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Add New Project window, select XUnit Test Project (.NET Core) and
    provide a meaningful name, for example, `FlixOne.BookStore.ProductService.IntegrationTests`.
    Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eca9d769-bb9e-4baa-94b5-f18794704e74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the `appsettings.json` file and add the following to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Open the `Startup.cs` file of the  `FlixOne.BookStore.ProductService` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now make the `ConfigureServices` and `Configure` methods void. This is so we
    can override these methods in our `TestStartup.cs` class. These methods would
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Add a new folder called `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `TestStartup.cs` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open NuGet Manager. Search and add the Microsoft.AspNetCore.TestHost package.
    Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ed19dbd-6924-405e-b1db-d9e816767b36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code to `TestStartup.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `Services` folder, add a new `ProductTest.cs` class and add the following
    code to this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we are checking a simple test. We are trying
    to verify the response of a service by setting up a client with the use of `HttpClient`.
    The test will fail if the response goes empty.
  prefs: []
  type: TYPE_NORMAL
- en: Consumer-driven contract tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, *Contract testing*, we discussed things in detail.
    In this section, we will see how we can implement consumer-driven contract tests
    with the help of pact-net-core.
  prefs: []
  type: TYPE_NORMAL
- en: We will use our existing  `FlixOne.BookStore.ProductService` project, which
    contains all our APIs. Our `FlixOne.BookStore.ProductService` project contains
    provider tests that let you create a provider scenario, and our client project
    that actually consumes the services, makes a call, and tests the contract.
  prefs: []
  type: TYPE_NORMAL
- en: To get started you should install the NuGet package. Execute `Install-Package
    PactNet.Windows` using the package console.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per Pact specification (already discussed in a previous section, *Contract
    testing*), the client will create a contract called *consumer contract* (a `.json`
    file). We have written the following code to generate our contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are building a contract. In addition to that, we
    mocked our client tests. See the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code will create the consumer contract as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the consumer-driven contract is created, it should adhere to a provider,
    so we need to write the APIs accordingly (we are using our existing product API).
    The following is the code snippet for a provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have created a web API and a test to verify consumer-driven contracts and
    finally testing it from a client's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing microservices is a bit different from applications built on the traditional
    architectural style. In a .NET monolithic application, testing is a bit easier
    compared to microservices, and it provides implementation independence and short
    delivery cycles. Microservices face challenges while performing the testing. With
    the help of the testing pyramid concept, we can strategize our testing procedures.
    Referring to the testing pyramid, we can easily see that unit tests provide the
    facility to test a small function of a class and are less time-consuming. On the
    other hand, the top layer of the testing pyramid enters a large scope with system
    or end-to-end testing, and these tests are time-consuming and very expensive.
    Consumer-driven contracts are a very useful way to test microservices. Pact-net
    is an open source tool meant for this. Finally, we went through the actual test
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to deploy a microservice application. We
    will discuss continuation integration and continuation deployment in detail.
  prefs: []
  type: TYPE_NORMAL
