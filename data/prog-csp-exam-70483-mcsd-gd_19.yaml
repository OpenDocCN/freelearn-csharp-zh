- en: Mock Test 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟测试3
- en: In your application, you have implemented the `LogException(string message)`
    method to log exceptions. When an exception is thrown from your application, you
    want to log and rethrow the original exception. How do you achieve this?
  id: totrans-1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序中，您实现了`LogException(string message)`方法来记录异常。当您的应用程序抛出异常时，您想记录并重新抛出原始异常。您如何实现这一点？
- en: '`catch(Exception ex){LogException(ex.Message); throw;}`'
  id: totrans-2
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch(Exception ex){LogException(ex.Message); throw;}`'
- en: '`catch(Exception ex){LogException(ex.Message); throw ex;}`'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch(Exception ex){LogException(ex.Message); throw ex;}`'
- en: '`catch{LogException(ex.Message); throw new Exception();}`'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch{LogException(ex.Message); throw new Exception();}`'
- en: '`catch{LogException(ex.Message); rethrow;}`'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch{LogException(ex.Message); rethrow;}`'
- en: 'You have created an application where you have implemented custom exception
    types and have also implemented multiple log methods, as follows:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您创建了一个应用程序，在其中实现了自定义异常类型，并实现了多个日志方法，如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You have a method that can throw one of the preceding exceptions. You need
    to make sure that, when the exception is caught, a log exception message by the
    log method accepts the exception; when `CustomException2` is caught, a log message
    by the log method accepts `CustomException2`; and the same for `CustomException3`.
    How do you want to achieve this? Please specify the order of catch statements:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个可能会抛出上述任一异常的方法。您需要确保，当捕获到异常时，通过日志方法记录异常信息；当捕获到`CustomException2`时，日志方法接受`CustomException2`；对于`CustomException3`也是如此。您希望如何实现这一点？请指定`catch`语句的顺序：
- en: '`catch(CustomException1 ex){...}`'
  id: totrans-9
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch(CustomException1 ex){...}`'
- en: '`catch(CustomExceotion2 ex){...}`'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`catch(CustomExceotion2 ex){...}`'
- en: '`catch(CustomException3 ex){...}`'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`catch(CustomException3 ex){...}`'
- en: '`catch(Exception ex){...}`'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch(Exception ex){...}`'
- en: '`catch(CustomExceotion2 ex){...}`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`catch(CustomExceotion2 ex){...}`'
- en: '`catch(CustomException3 ex){...}`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`catch(CustomException3 ex){...}`'
- en: '`catch(Exception ex){...}`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch(Exception ex){...}`'
- en: '`catch(CustomExceotion1 ex){...}`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`catch(CustomExceotion1 ex){...}`'
- en: '`catch(CustomException3 ex){...}`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch(CustomException3 ex){...}`'
- en: '`catch(CustomExceotion2 ex){...}`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`catch(CustomExceotion2 ex){...}`'
- en: '`catch(Exception ex){...}`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`catch(Exception ex){...}`'
- en: Your application is running multiple tasks using a task factory. However, a
    customer has requested you to run a specific task when its parent task throws
    an exception. How do you achieve this?
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的应用程序正在使用任务工厂运行多个任务。然而，一位客户要求您在父任务抛出异常时运行特定任务。您如何实现这一点？
- en: '`task.when()`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task.when()`'
- en: '`task.whenany()`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task.whenany()`'
- en: '`task.continuewhenany()`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task.continuewhenany()`'
- en: None of the above
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Your application is running multiple worker threads. How do you make sure that
    your application waits for all the threads to complete their execution?
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的应用程序正在运行多个工作线程。您如何确保应用程序等待所有线程完成执行？
- en: '`Thread.Sleep()`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Thread.Sleep()`'
- en: '`Thread.WiatALL()`'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Thread.WaitAll()`'
- en: '`Thread.Join()`'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Thread.Join()`'
- en: None of the above
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Secret key encryption is also known as asymmetric encryption.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 秘密密钥加密也称为非对称加密。
- en: '`True`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`True`'
- en: '`` `False` ``'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`` `False` ``'
- en: In public-key encryption, anyone with the public key can process the message.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公钥加密中，任何拥有公钥的人都可以处理消息。
- en: '`True`'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`True`'
- en: '`False`'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`False`'
- en: When using `RSACryptoServiceProvider` in your sample application, how would
    you get your public and private keys?
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的示例应用程序中使用`RSACryptoServiceProvider`时，您如何获取您的公钥和私钥？
- en: '`RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();`'
- en: '`string publicKey = rsa.ToXmlString(false);`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`string publicKey = rsa.ToXmlString(false);`'
- en: '`string pricateKey = rsa.ToXmlString(true);`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`string pricateKey = rsa.ToXmlString(true);`'
- en: '`RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();`'
- en: '`string publicKey = rsa.ToXmlString(true);`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`string publicKey = rsa.ToXmlString(true);`'
- en: '`string pricateKey = rsa.ToXmlString(false);`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`string pricateKey = rsa.ToXmlString(false);`'
- en: '`RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();`'
- en: '`string publicKey = rsa.ToXmlString(public);`'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`string publicKey = rsa.ToXmlString(public);`'
- en: '`string pricateKey = rsa.ToXmlString(private);`'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`string pricateKey = rsa.ToXmlString(private);`'
- en: '`RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();`'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();`'
- en: '`string publicKey = rsa.ToXmlString("public");`'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`string publicKey = rsa.ToXmlString("public");`'
- en: '`string pricateKey = rsa.ToXmlString("private");`'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`string pricateKey = rsa.ToXmlString("private");`'
- en: What is the best way to authenticate a sender?
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最佳的验证发送者的方式是什么？
- en: Encrypt your message.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密您的消息。
- en: Sign your message.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 签署您的消息。
- en: Use digital signatures.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数字签名。
- en: All of the above.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有。
- en: When you apply the hash algorithm on a string, what will the output be?
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您对一个字符串应用哈希算法时，输出会是什么？
- en: The string gets encrypted.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串被加密。
- en: Each character gets hashed into a different binary string.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个字符都被哈希到一个不同的二进制字符串。
- en: The string gets hashed as a whole.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串被整体哈希。
- en: None of the above.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是。
- en: You are adding new features to an existing application for your customers. When
    you deploy them, you get an assembly manifest mismatch error. What is the best
    possible solution to resolve this issue?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在为您的客户向现有应用程序添加新功能。当您部署它们时，您得到一个程序集清单不匹配错误。解决此问题的最佳可能解决方案是什么？
- en: Update all major and minor assembly versions of the current and dependent assemblies,
    then rebuild and deploy.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新当前和依赖程序集的所有主要和次要版本，然后重新构建和部署。
- en: Check all assembly versions of the current and dependent assemblies and make
    sure the configurations or policies are updated to reflect the change in assembly
    versions, then rebuild and deploy.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前和依赖程序集的所有程序集版本，并确保配置或策略已更新以反映程序集版本的更改，然后重新构建和部署。
- en: Update the `machine.config` file to ignore such errors.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`machine.config`文件以忽略此类错误。
- en: Update `web.config` and set the custom error mode to `off`.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`web.config`并将自定义错误模式设置为`off`。
- en: You create a release package and deploy your application into a production environment.
    When users start using the application, they receive an error. You are unable
    to reproduce it in any lower-level environments, so you decide to debug your application
    in the production environment. However, the application never stops at the breakpoint.
    Why is this?
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您创建了一个发布包并将应用程序部署到生产环境。当用户开始使用应用程序时，他们收到一个错误。您无法在任何较低级别的环境中重现它，因此您决定在生产环境中调试您的应用程序。然而，应用程序从未在断点处停止。这是为什么？
- en: You don't have local admin permissions on the system.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在系统上没有本地管理员权限。
- en: Visual Studio's debugging module is not loaded.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio的调试模块未加载。
- en: The release version doesn't allow us to debug.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布版本不允许我们调试。
- en: All of the above.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有。
- en: You create an application and you want to monitor it while it is executing.
    So, you decide to implement tracing. How do you trace your application so that
    you can see your trace messages in the output window?
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您创建了一个应用程序，您想在它执行时监控它。因此，您决定实现跟踪。您如何跟踪您的应用程序，以便您可以在输出窗口中看到您的跟踪消息？
- en: Use `Console.WriteLine()`.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Console.WriteLine()`。
- en: Use `tracelistener` to add the output window and use `trace.write`.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tracelistener`添加输出窗口并使用`trace.write`。
- en: '`Debug.WriteLine()`.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Debug.WriteLine()`。'
- en: '`Output.WriteLine()`.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Output.WriteLine()`。'
- en: You are creating an application where you have an `if` statement and an `else`
    statement. In the `if` statement, you have two conditions. You want both of these
    conditions to be validated before executing the code block. How do you achieve
    this?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在创建一个应用程序，其中有一个`if`语句和一个`else`语句。在`if`语句中，您有两个条件。您想在执行代码块之前验证这两个条件。您如何实现这一点？
- en: Use the `&&` operator.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`&&`运算符。
- en: Use the `&` operator.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`&`运算符。
- en: Use the `|` operator.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`|`运算符。
- en: User the `||` operator.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`||`运算符。
- en: How do you return a default value into a variable when your expression returns
    a null value?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的表达式返回null值时，您如何将默认值返回到变量中？
- en: Use the `ternary` operator.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ternary`运算符。
- en: Use the `binary` operator.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`binary`运算符。
- en: Use the conditional `OR`.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用条件`OR`。
- en: Use the `null` coalescing operator.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`null`合并运算符。
- en: You have multiple versions of the same method in your code. Your customer has
    requested you to make sure that all dependent applications use a specific version
    of the method. How do you make sure that no one invokes any other methods which
    may cause other exceptions?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的代码中有多个相同方法的版本。您的客户要求您确保所有依赖的应用程序都使用该方法的特定版本。您如何确保没有人调用任何可能引起其他异常的其他方法？
- en: Change the access modifiers for all other methods.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改所有其他方法的访问修饰符。
- en: Throw an exception from these methods.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这些方法中抛出异常。
- en: Use the `Obsolete` attribute to let users know the correct method to use.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Obsolete`属性让用户知道正确的使用方法。
- en: All of the above.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有。
- en: You are creating a C# application where you need to output multiple lines with
    a line break between them. How do you achieve this?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在创建一个C#应用程序，您需要输出多行，每行之间有一个换行符。您如何实现这一点？
- en: '`var sb = new StringBuilder();sb.AppendLine(Line1); sb.AppendLine(Environment.NewLine);`'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var sb = new StringBuilder();sb.AppendLine(Line1); sb.AppendLine(Environment.NewLine);`'
- en: '`var sb = new StringBuilder();foreach(string line in strList){sb.AppendLine(Line1);
    sb.AppendLine(Environment.NewLine); }`'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var sb = new StringBuilder();foreach(string line in strList){sb.AppendLine(Line1);
    sb.AppendLine(Environment.NewLine); }`'
- en: '`var sb = new StringBuilder();sb.Append(Line1); sb.Append(''\t'');`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var sb = new StringBuilder();sb.Append(Line1); sb.Append(''\t'');`'
- en: All of the above
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆是
- en: How would you make sure a parent class method is not accessible in inherited
    classes? Which access modifier would you use?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确保父类方法在继承类中不可访问？你将使用哪种访问修饰符？
- en: Private
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有的
- en: Internal
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部
- en: Protected
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 受保护的
- en: Abstract
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Specify the code to load an assembly at runtime:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定在运行时加载程序集的代码：
- en: '`Assembly.Load()`'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assembly.Load()`'
- en: '`Assembly.Create("A1.dll");Assembly.Load();`'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assembly.Create("A1.dll");Assembly.Load();`'
- en: '`Assembly.Load("a.dll");`'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assembly.Load("a.dll");`'
- en: '`Assembly.GetType().Load();`'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assembly.GetType().Load();`'
- en: When you create a C# console application, which files do you see in the solution
    explorer?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你创建一个C#控制台应用程序时，你在解决方案资源管理器中看到哪些文件？
- en: Project, `App.Config`, `Program.cs`, Solution, Properties, and References
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目、`App.Config`、`Program.cs`、解决方案、属性和引用
- en: '`App.Config`, `Program.cs`'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App.Config`、`Program.cs`'
- en: Project, `App.Config`, `Program.cs`, Solution, Properties
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目、`App.Config`、`Program.cs`、解决方案、属性
- en: '`App.Config`, `Program.cs`, Properties'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App.Config`、`Program.cs`、属性'
- en: When you create a console application and change the `static Main(string[] args)`
    to `static main(string[] args)`, what will happen?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你创建一个控制台应用程序并将`static Main(string[] args)`更改为`static main(string[] args)`时，会发生什么？
- en: A compile-time error is raised.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会引发编译时错误。
- en: A runtime error is raised.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会引发运行时错误。
- en: Both **a** and **b**.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**a**和**b**都正确。'
- en: None of the above.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非。
- en: A class or a class member that is declared as internal can only be accessed
    by classes in the same assembly but not by outside assemblies.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明为内部（internal）的类或类成员只能被同一程序集中的类访问，而不能被外部程序集访问。
- en: 'True'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Consider the following statements. **Statement 1**: A value type maintains
    the address of the variable. **Statement 2**: Two reference type variables pointing
    at address 1 reflect the updated value.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下陈述。**陈述1**：值类型保持变量的地址。**陈述2**：指向地址1的两个引用类型变量反映了更新的值。
- en: Both are true.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个都是正确的。
- en: Statement 1 is true, statement 2 is false.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 陈述1是正确的，陈述2是错误的。
- en: Statement 1 is false, statement 2 is true.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 陈述1是错误的，陈述2是正确的。
- en: Both are false.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个都是错误的。
- en: While defining an interface, it is good practice to have access modifiers for
    the methods.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义接口时，为方法使用访问修饰符是一种良好的做法。
- en: 'True'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: How do you define an optional parameter?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何定义可选参数？
- en: '`void AddNumbers(int a=1, int b)`'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void AddNumbers(int a=1, int b)`'
- en: '`void AddNumbers(int a, int b optional)`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void AddNumbers(int a, int b optional)`'
- en: '`void AddNumbers(int a, int b=4)`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void AddNumbers(int a, int b=4)`'
- en: '`void Add numbers(int a, optional int b)`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void Add numbers(int a, optional int b)`'
- en: What is the keyword that you use in a program function where you are using a
    pointer declaration?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用指针声明的程序函数中，你使用的关键字是什么？
- en: Sealed
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密封的
- en: Safe
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全的
- en: Internal
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部
- en: Unsafe
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不安全的
- en: What syntax do we use to append text to a file?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用什么语法向文件追加文本？
- en: '`File.CreateText`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`File.CreateText`'
- en: '`FileInfo.Create`'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FileInfo.Create`'
- en: '`File.Create`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`File.Create`'
- en: '`File.AppendText`'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`File.AppendText`'
- en: Which collection type can be used to create a strongly typed, zero-based index
    to process objects in a FIFO manner?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种集合类型可以用来创建一个强类型、基于零的索引，以FIFO方式处理对象？
- en: '`Queue<T>`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Queue<T>`'
- en: '`List<T>`'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List<T>`'
- en: '`Array`'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Array`'
- en: '`Dictionary`'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dictionary`'
- en: You are creating an application that manages information. You define a save
    method in the class and you want to ensure that only this class and any inherited
    classes can invoke the method. You want to define the save method as a strongly
    typed method. How do you achieve this?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在创建一个管理信息的应用程序。你在类中定义了一个保存方法，并希望确保只有这个类及其继承类可以调用该方法。你希望将保存方法定义为强类型方法。你如何实现这一点？
- en: '`public static void Save<T>(T target) where T : new(), ParentClass {}`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static void Save<T>(T target) where T : new(), ParentClass {}`'
- en: '`public static void Save<T>(T target) where T : ParentClass,new() {}`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static void Save<T>(T target) where T : ParentClass,new() {}`'
- en: '`public static void Save<T>(T target) where T : ParentClass {}`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static void Save<T>(T target) where T : ParentClass {}`'
- en: '`public static void Save(ParentClass target) {}`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static void Save(ParentClass target) {}`'
- en: You are developing an assembly that will be used by multiple applications. You
    need to install it in GAC. Which actions would you perform to achieve this?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在开发一个将被多个应用程序使用的程序集。你需要将其安装到GAC中。你将执行哪些操作来实现这一点？
- en: Sign the assembly and use the Gacutil tool to install the assembly in GAC.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对程序集进行签名并使用Gacutil工具将程序集安装到GAC。
- en: Version assembly and use the Regsvr32 tool to install the assembly in GAC.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 版本化程序集并使用Regsvr32工具将程序集安装到GAC。
- en: Drag and drop to the Windows assembly folder.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖放到Windows程序集文件夹。
- en: All of the above.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆是。
- en: When two parties need to communicate using the asymmetric algorithm, which key
    do they need to share?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个实体需要使用非对称算法进行通信时，他们需要共享哪个密钥？
- en: Private key
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私钥
- en: Public key
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公钥
- en: Both
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者
- en: None
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无
