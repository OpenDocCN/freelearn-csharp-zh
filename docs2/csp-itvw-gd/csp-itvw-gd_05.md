# 3

# C# 编程基础

欢迎来到*第三章*，我们将深入探讨技术面试的核心，特别是关注 C# 编程的基础。C# 是一种广泛采用、稳健且灵活的语言，被用于各个领域，包括但不限于游戏开发、网络服务和企业级软件。

掌握像 C# 这样的编程语言的基本要素对于在技术面试中表现出色至关重要。在本章中，我们将向您介绍 C# 的关键原则，从基本概念、数据类型、变量和运算符开始，迅速过渡到控制结构和循环。我们的目标不仅是让您熟悉语法，还要确保您理解其背后的逻辑，使您能够编写有效且干净的代码。

此外，我们将深入探讨使用 C# 的**面向对象编程**（**OOP**）的基础。理解 OOP 允许你设计和管理复杂的应用程序，这是科技行业中非常受重视的技能。

到本章结束时，您将拥有 C# 编程的坚实基础。这些知识将使您能够自信地应对编码挑战，并在技术面试中展示您的解决问题的能力。本章旨在提供理论与实践的平衡，确保您能够有效地应用所学概念。

在本章中，我们将涵盖以下主要主题：

+   C# 的基本概念和原则

+   在 C# 中使用数据类型、变量和运算符

+   在 C# 中编写控制结构和循环

+   使用 C# 探索 OOP 的基础

# C# 的基本概念和原则

在本节中，我们旨在帮助您深化对 C# 基本原则的理解，使您能够自信地回答在技术面试中可能遇到的相关问题。本节设计为一个问答环节，我们将解决可能出现的面试问题，涵盖从 C# 语法基础到 C# 中 OOP 关键概念的各个主题。我们相信这种互动方法将有助于巩固您的知识，并有效地为实际面试场景做好准备。

让我们开始探索您可能会遇到的问题以及如何有效地回答它们。

## C# 语言代表什么，它旨在哪些平台和应用程序中使用？

C# 是由微软创建的编程语言，是 .NET 平台的一部分。使用 C#，可以开发各种应用程序，如桌面应用程序、网络应用程序、移动应用程序、游戏应用程序（通过 Unity）、云计算解决方案等。C# 由于 .NET Core 和 Xamarin 的支持，在各种平台上得到支持。

## 在 C# 项目背景下，.dll 和 .exe 文件之间的基本区别是什么？

在 C# 和 .NET 的上下文中，`.exe`（`.exe` 文件，程序开始执行。另一方面，`.dll`（**动态链接库**）文件是一个代码库，它没有直接的入口点，但可以被另一个程序或应用程序调用。它是不同项目之间代码重用的一种方式。

## C# 编写的程序的入口点是如何的？

C# 程序的入口点通常由 `Main()` 方法表示，该方法位于 `Program` 类中。此方法必须是静态的，并作为程序执行的起点。通常，其结构如下所示：

```cs
public class Program
{
    public static void Main(string[] args)
    {
        // program code
    }
}
```

`args` 参数包含一个字符串数组，该数组在程序启动时传递给程序。

## C# 中是如何进行内存管理的？

在 C# 中，由于垃圾回收器机制，内存管理是自动处理的。它自动识别程序不再使用的对象，并释放它们占用的内存。虽然垃圾回收器简化了内存管理，但开发人员需要仔细管理不受 .NET 垃圾回收器控制的非托管资源，例如数据库连接或文件流。如果开发人员不释放这些资源，它们将保持应用程序的生命周期，可能造成内存泄漏和系统压力。

## C# 中面向对象编程（OOP）的原则是什么？

面向对象编程基于四个主要原则：封装、继承、多态性和抽象。在 C# 中，这意味着以下内容：

+   **封装**允许将数据和方法捆绑成一个单元（类），并限制对某些组件的访问。

+   **继承**允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法。这促进了代码的重用，并在类之间建立了层次关系。

+   **多态性**是指单个函数或方法根据其输入或被调用的对象以不同方式工作的能力。在 C# 中，可以通过方法重写实现多态性，使用 **override** 关键字，以及通过使用 **new** 关键字隐藏基类中的方法来实现方法隐藏。

+   **抽象**允许开发人员隐藏复杂的实现，只显示对象的必要功能。这意味着用户只与必要的部分交互，内部工作被隐藏。在 C# 中，抽象类和接口是帮助实现抽象的工具。

这些原则有助于设计健壮和可扩展的应用程序，允许轻松维护和进一步开发。C# 提供了一组丰富的功能，以有效地实现并从这些原则中受益。

## C# 中是如何处理错误的？

在 C# 中，主要的错误处理机制基于 `try`、`catch`、`finally` 和 `throw` 构造的使用。当 `try` 块中的代码引发错误时，执行将跳转到相应的 `catch` 块，在那里处理异常。如果存在，`finally` 块通常在 `try/catch` 之后执行，无论是否发生异常。然而，有一些关键异常，如 `StackOverflowException` 或 `OutOfMemoryException`，可能导致程序崩溃，因此 `finally` 块将不会执行。

## 依赖注入原则的含义是什么，如何在 C# 中实现？

**依赖注入**（**DI**）是一种软件设计方法，它减少了系统组件之间的紧密耦合。依赖注入的核心是将依赖（服务、对象）传递给组件，而不是在组件内部创建它们。在 C# 和 .NET 中，依赖注入通常使用依赖容器来实现，例如 *Microsoft.Extensions.DependencyInjection*、*Ninject*、*Autofac* 等。

## C# 中的装箱和拆箱是什么，为什么它们可能成为问题？

`object` 类型或由该值类型实现的任何接口类型。`object` 类型将转换回相应的值类型。在 C# 中，装箱和拆箱的主要关注点是它们可能降低应用程序的性能。装箱需要堆内存分配和值类型复制，从而减慢操作，尤其是在大型数据集或高频场景中。如果管理不当，拆箱可能导致运行时错误，因为类型转换不正确，从而中断程序执行。此外，这些操作可能会增加垃圾回收器的负载，导致更频繁的收集周期，并负面影响应用程序的响应能力。

## Entity Framework 代表什么，它是如何应用的？

**Entity Framework**（**EF**）是由 Microsoft 为 .NET 生态系统开发的 **对象关系映射**（**ORM**）框架。它允许开发者使用对象模型而不是直接编写 SQL 代码来与数据库交互。这个工具简化了创建和管理数据模型、自动化数据库模式迁移以及编写使数据库交互更直观的查询的过程。

## C# 中线程和进程有什么区别？

在操作系统中，进程是一个具有自己内存空间的独立执行实体。线程是进程内的最小执行单元。每个进程可以有一个或多个线程。在 C# 中，可以使用 `System.Threading` 命名空间中的 `Thread` 类来管理线程。主要区别在于，单个进程内的线程可以共享相同的内存区域，而每个进程都有自己的独立内存上下文。

## 主要用于 C# 的开发环境有哪些，Visual Studio 有没有替代品？

C# 的主要 IDE 是微软的 Visual Studio。然而，也有一些替代品，例如 Visual Studio Code（一个支持 C# 扩展的轻量级代码编辑器）和 JetBrains Rider。每个环境都有其自身的优点和特性，选择取决于开发者的具体需求：

+   **Visual Studio**:

    +   *特性*: 综合型 IDE，具有用于大型项目和多语言支持的先进工具

    +   *用例*: 最适合企业级应用，提供一系列用于协作和复杂项目的工具

+   **Visual Studio Code**:

    +   *特性*: 轻量级、开源代码编辑器，拥有丰富的扩展生态系统，包括对 C# 的支持

    +   *用例*: 适用于个人开发者或小型团队，提供灵活且可扩展的环境，支持各种语言和框架

+   **JetBrains Rider**:

    +   *特性*: 跨平台 .NET IDE，具有强大的 .NET 开发工具和丰富的插件集

    +   *用例*: 适用于跨平台开发，提供一致的经验和高质量的代码分析和重构工具

## 你知道哪些编程模式，你在 C# 中实现了哪些？

编程模式是针对常见开发挑战的经过验证的解决方案。它们表明实现特定任务的优化方式。在 C# 中，我经常使用如 *Singleton*、*Factory*、*Observer*、*Strategy* 和 *Decorator* 等模式。

## 你能描述不同的软件测试方法和它们的主要区别吗？

存在几种测试类型，包括以下几种：

+   **单元测试**: 专注于单个代码片段，尤其是函数或方法

+   **集成测试**: 检查软件不同部分之间的交互

+   **系统测试**: 测试整个系统

主要区别在于访问级别和测试范围。

## 你是如何确定进行单元测试的最佳时间，与集成测试或系统测试相比？

单元测试最好在开发期间进行，当创建或修改特定组件或函数时。

集成测试应该在将几个组件组合在一起以验证它们正确交互之后应用。

系统测试应该在整个产品或其重要部分准备发布时应用。

## NuGet 是什么，它是如何用于向你的项目添加库的？

**NuGet** 是 .NET 平台的包管理器，允许开发者轻松地向项目中添加、更新和删除外部库和依赖项。要通过 NuGet 向项目中添加外部库，你需要在开发环境（例如 Visual Studio）中打开 NuGet 控制台或使用其图形界面，找到所需的包，并安装它。

在掌握了 C#的基本概念和原则之后，你已经朝着理解这个强大的编程语言迈出了重要的一步。但旅程还没有结束。你的下一步是深入研究在 C#中处理数据类型、变量和运算符。准备好继续了吗？现在是深入探索的时候了！

# 在 C#中处理数据类型、变量和运算符

当深入研究 C#时，掌握数据类型、变量和运算符是至关重要的——它们是您应用程序的骨架。在本节中，我们将探讨这些基础元素，为更高级的编码铺平道路。准备好巩固您的理解了吗？让我们深入探讨吧！

## C#中的基本原始数据类型是什么？值类型和引用类型之间的主要区别是什么？

在 C#中，有原始数据类型，如`int`、`float`、`double`、`char`、`bool`、`byte`等。值类型和引用类型之间的主要区别在于它们的存储方式和内存管理。值类型存储在栈上，并直接包含其值，而引用类型存储在堆上，并包含对内存中对象的引用。

## 在字符串的上下文中，字符串和 StringBuilder 之间的主要区别是什么？

C#中的`string`类型是不可变的，这意味着每次修改字符串时都会创建一个新的实例。另一方面，`StringBuilder`旨在高效地修改字符串，而无需创建多个新实例。

## 你如何初始化和交互一维和多维数组？什么是“string[][]”与“string[,]”的区别？

C#中的一维数组初始化如下：`int[] arr = new int[5];`至于多维数组，`string[,]`是一个二维数组，而`string[][]`是数组的数组，也称为*锯齿*数组。

## 位运算是什么？C#中的哪些运算符支持这些操作？

位运算允许对数值的各个位进行操作。C#中的主要位运算符是`&`（*AND*）、`|`（*OR*）、`^`（*XOR*）和`~`（*NOT*）。

## C#中的“可空”类型有什么作用，如何正确地使用它们？

C#中的`Nullable`类型允许表示值类型的缺失或未初始化的值。它们通常用于需要区分*零*值和值缺失的情况。要检查值的存在，可以使用`HasValue`属性，要检索值本身，则使用`Value`。

## 关于 C#中的运算符重载你知道些什么？为什么它可能很有用？

运算符重载允许为用户定义的数据类型（如类）定义运算符的操作。例如，这可以用于轻松操作复数、向量或其他数学结构。

## 在 C#中如何重载运算符，你能提供一个例子吗？

在 C#中，运算符重载允许你重新定义内置运算符对用户定义类型（如类和结构体）的工作方式。要重载运算符，你需要在你的类或结构体中定义一个静态方法，使用`operator`关键字后跟你要重载的运算符符号。该方法必须返回一个结果，并至少接受一个参数，该参数是你正在重载运算符的类型。

下面是一个重载自定义`Vector`类中`+`运算符的简单示例：

```cs
public class Vector
{
    public int X { get; set; }
    public int Y { get; set; }
    public Vector(int x, int y)
    {
        X = x;
        Y = y;
    }
    // Overload + operator
    public static Vector operator +(Vector v1, Vector v2)
    {
        return new Vector(v1.X + v2.X, v1.Y + v2.Y);
    }
}
// Usage:
Vector vector1 = new Vector(1, 2);
Vector vector2 = new Vector(2, 3);
Vector result = vector1 + vector2;  // This will call the overloaded + operator
```

## C#中的比较和关系运算符是如何工作的？

比较运算符（`==`, `!=`）和关系运算符（`<`, `>`, `<=`, `>=`）用于比较两个值。重要的是要记住，当比较引用类型时，`==`运算符检查引用相等性，而不是内容。

## C#中的逻辑运算符的目的是什么？它们是如何工作的？为什么要注意运算符优先级？

逻辑运算符，如`&&`（逻辑“与”），`||`（逻辑“或”），和`!`（逻辑否定），用于组合逻辑条件。了解运算符优先级很重要，因为它会影响运算的顺序。例如，表达式`A && B || C`将被解释为`(A && B) || C`，而不是`A && (B || C)`，这可能导致不同的结果。

## 在什么情况下以及为什么应该使用 C#中的“const”变量？它们与“readonly”有什么区别？

当你需要定义一个在整个程序生命周期中不改变的变量时，应该使用`const`变量。它们必须在编译时分配一个值。另一方面，`readonly`可以在类构造函数中初始化，并确保其值之后不能被更改。

## 在 C#中，哪种对象比较方法更好用，“==”还是“Equals()”，以及为什么？

对于值类型，`==`和`Equals()`通常以相同的方式工作，但对于引用类型，`==`检查引用相等性，而不是内容。`Equals()`可以被自定义类重写以确保基于内容的比较。一般来说，如果你想比较对象的内容，最好使用`Equals()`。

## 在 C#中将类型转换为“is”和“as”时，主要区别是什么？

`is`检查一个对象是否是特定类型的实例，并返回一个布尔值。`as`用于安全类型转换，如果转换不可行，将返回`null`，而不是抛出异常。

## C#中的显式类型转换和隐式类型转换是什么意思？

隐式类型转换在将可以存储较少信息的数据类型转换为可以存储更多信息的数据类型时自动发生（例如，从`int`到`double`）。显式类型转换（类型转换）在转换过程中有数据丢失风险时是必需的。

## C#中的“??”运算符的目的是什么？在哪些场景下应该使用它？

`??`运算符是一个空合并运算符，如果左操作数不是`null`，则返回左操作数；否则，返回右操作数。它对于设置可能为`null`的值的默认值非常有用。

## 元组是什么，它们在 C#中如何使用，与类相比它们有哪些优势？

C#中的元组是有序的各种类型的集合。它们用于表示数据集，而无需创建特定的类型。与类相比，元组通常更轻便，对于小型、临时数据集来说更加方便。

在本节中，我们深入探讨了 C#的核心组件——数据类型、变量和运算符，它们构成了任何 C#应用程序的骨架。我们探讨了值类型和引用类型之间的差异，并检查了字符串操作，以及各种数组的初始化和处理。我们还讨论了位运算符和逻辑运算符的作用，可空类型的用法，以及运算符重载的原则。我们还触及了对象比较方法、类型转换以及使用元组进行紧凑数据表示的优势等重要主题。有了这个坚实的基础，我们准备进入下一节，*在 C#中编写控制结构和循环*，以进一步提高我们的编程技能。

# 在 C#中编写控制结构和循环

控制结构和循环是任何程序的基本元素，允许开发者高效地管理代码执行的流程。在 C#语言中，有各种强大的工具用于此目的。在本节中，我们将深入研究各种控制结构，如条件语句和选择，以及使用不同类型的循环通过数据循环的关键概念。通过深入研究这些元素，你将获得编写高效和结构化代码的坚实基础。让我们开始吧！

## C#中有哪些主要的循环类型，以及如何为特定情况选择最佳的循环？

在 C#中，有几种循环类型可用：`for`、`foreach`、`while`和`do-while`。让我们逐一看看它们：

+   **for**: 当你事先知道迭代次数时，这是最常用的循环。

+   **foreach**: 此类循环非常适合在需要按顺序处理每个元素时遍历集合或数组。

+   **while**: 当指定的条件为真时，此循环会一直执行。当你事先不知道迭代次数时，它非常有用。

+   **do-while**: 此循环与**while**类似，但条件是在执行循环体之后检查的，确保循环体至少执行一次。

选择最佳循环取决于具体的情况。如果你需要遍历集合中的所有元素，`foreach` 将是最方便的。如果你知道迭代次数，`for` 将是最高效的。在不知道迭代次数的情况下，你可以使用 `while` 或 `do-while`，这取决于你是否希望循环体至少执行一次。

## 你如何在 C# 中使用 “if”，“else if”，和 “else” 操作符？在哪些情况下你会推荐使用它们？

`if`，`else if`，和 `else` 操作符用于条件代码执行。`if` 检查一个条件，如果它是 `true`，则执行其后的代码块。`else if` 允许你在前面的条件为 `false` 时检查额外的条件。`else` 在没有满足前面的条件时执行代码块。使用 `if` 检查单个主要条件，`else if` 检查额外条件，`else` 作为后备代码块执行。

## “for” 循环和 “foreach” 循环有什么区别？在哪些情况下使用每个更好？

`for` 循环用于你知道需要执行循环多少次的情况。`foreach` 循环设计用于遍历集合，如列表或数组。当你有一个特定的迭代次数时使用 `for`，当你需要遍历集合中的所有元素时使用 `foreach`。

## “switch” 操作符是什么，它与一系列的 “if-else” 操作符有何不同？

`switch` 操作符允许你将一个变量与多个值进行比较。它更紧凑，通常更方便用于检查单个变量的值。另一方面，`if-else` 序列提供了更多的灵活性，因为它可以检查不同的条件，而不仅仅是一个变量。

## “continue” 和 “break” 操作符在循环中做什么，它们在什么情况下可能有用？

`continue` 跳过当前循环迭代并继续下一个。`break` 提前退出循环。`continue` 在需要跳过某些循环迭代时很有用，而 `break` 在需要根据某些条件终止循环执行时很有用。

## 如何使用逻辑运算符在单个 “if” 语句中组合多个条件？

你可以使用逻辑运算符 `&&`（逻辑“与”）和 `||`（逻辑“或”）来组合多个条件，例如，`if (x > 5 && y < 10) {...}`。

## 与常规的 “while” 循环相比，“do-while” 循环有什么特殊性？

主要区别在于在 `do-while` 循环中，条件是在循环体执行之后检查的，确保循环体至少运行一次，无论条件如何。

## 嵌套循环是什么样的，为什么它可能有用？

嵌套循环是将一个循环放置在另一个循环内部。它通常用于处理二维数组或矩阵。以下是一个示例：

```cs
for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 3; j++)
    {
        Console.WriteLine($"i = {i}, j = {j}");
    }
}
```

## 你如何防止潜在的无限循环执行？

为了防止无限循环，确保循环终止条件会被满足是至关重要的。这可以通过在进入循环前检查条件、使用执行时间限制器或通过内部计数器和监控工具来实现。

## C#中的递归是什么，以及如何在使用递归方法时防止栈溢出？

递归是一种方法调用自身的技术。为了防止栈溢出，重要的是要有明确的基例来终止递归调用，并限制递归深度。

## 如何在 C#中优化循环以处理大量数据？

为了优化循环，你可以使用并行处理、采用高效的数据结构、减少循环内的操作数量，并在可能的情况下利用缓存。

## C#中的“yield return”是什么，何时可以使用它？

`yield return`允许你创建迭代器，而无需生成辅助集合。当你想要在遍历集合时懒加载值时，这非常有用。

## 如何使用“for”创建无限循环？

可以使用以下方式使用`for`创建无限循环：

```cs
for(;;)
{
// loop code
}
```

在这里，条件、初始化和增量都是缺失的，因此循环将无限运行。

在本节中，我们探讨了控制结构和循环，这是决定代码流程的基本工具。我们讨论了各种循环类型，如`for`、`foreach`、`while`和`do-while`，强调了根据任务选择合适的循环类型。我们还涵盖了`if`、`else if`和`else`条件运算符的用法和应用。我们比较了`switch`运算符与一系列`if-else`语句的效率，并探讨了`continue`和`break`运算符在循环中的作用。有了这个基础，我们现在准备深入更高级的主题。

# 探索使用 C#的 OOP 基础知识

在本节中，我们将关注使用 C#的 OOP 基础知识。随着我们进一步探索，我们将揭示 OOP 的核心原则，这是一种促进有组织和可重用代码的范式。通过 C#，我们将探索诸如类、对象、继承和多态等关键 OOP 概念，加深你的理解，并为你提供构建健壮和高效应用程序的技能。让我们开始这段启发性的旅程。

## C#是如何整合 OOP 原则的？

C#支持所有核心的面向对象编程（OOP）原则：*封装*、*继承*、*多态*和*抽象*。例如，C#中的类和接口允许实现继承和多态，而访问修饰符则有助于封装。

## C#中的封装是如何工作的？

在 C#中，封装通过`private`、`protected`和`public`等访问修饰符来确保。这些修饰符决定了类成员的可见性，允许隐藏实现细节，仅暴露必要的 API。

## C#中多态是如何实现的？

C#中的多态是通过使用`virtual`和`override`关键字在子类中覆盖方法的能力，以及通过允许不同类具有一致方法集的接口来实现的。

## C#中的继承包含哪些内容？

C#中的继承允许基于现有类创建一个新的类，继承其属性和行为。这是通过使用冒号`:`，后跟基类名称来实现的。

## C#中类与其实例之间的区别是什么？

一个类充当一个示意图或原型，它定义了对象的特征和功能。一个对象（或类的实例）是该类的一个特定表示，具有一组独特的属性值。

## 为什么在 C#中使用诸如“public”、“private”、“protected”和“internal”之类的访问修饰符？

这些修饰符决定了类成员的访问级别。`public`使成员对任何代码都可用；`private`仅限制对给定类的方法的访问；`protected`允许对给定类及其派生类进行访问，而`internal`使成员对同一程序集内的任何代码都可用。

## C#中的类能否同时从多个其他类继承？

不，C#不支持类的多重继承。然而，一个类可以实现多个接口。

## C#中方法重载和方法重写有何不同？

方法重载允许在一个类中拥有多个具有不同参数的单个方法版本。方法重写允许子类替换其基类提供的方法的实现。

## C#中接口和基类的主要区别是什么？

接口定义了一个合同（一组没有实现的方法），实现它的类必须遵守。基类包含可以继承和扩展的实现。一个类只能继承一个基类，但可以实现多个接口。

## 为什么组合有时被认为比继承更好？

组合提供了更大的灵活性，允许在运行时动态更改对象的行为，并减少了与类之间紧密耦合相关的问题风险。它还促进了*组合优于继承*的原则，即使用组合来提高代码的可重用性是一种更可取的方法。

## C#中的属性是什么，它们与字段有何不同？

属性是 C#中的一种特殊类成员，它代表了对数据的访问，并能够在读取或写入该数据时定义逻辑。它们允许您控制对内部字段的访问，并且可以包含额外的逻辑，例如验证。另一方面，字段是在类中定义的变量，用于存储数据。

## C#中抽象类和接口的主要区别是什么？

抽象类可以包含有和没有实现的方法。它们不能直接实例化。接口只包含没有实现的方法声明。一个类可以实现多个接口，但不能继承多个抽象类。

## 为什么封装字段对于 SOLID 原则很重要？

封装有助于保护对象的内部状态，使其对外部世界隐藏，这支持遵循 SOLID 原则的*开放/封闭原则*。它还有助于防止可能违反*单一责任原则*的不希望的状态变化。

## 在 C#的面向对象编程（OOP）中，代表者的角色是什么？

C#中的代表者是指向方法的对象。它们以类型安全的方式实现了函数指针的概念。代表者通常用于实现事件和回调。

## 构造函数是如何用于对象初始化的，它们与静态构造函数有何不同？

构造函数有助于在对象创建时初始化对象，设置必要的状态或执行任何其他所需的设置。静态构造函数用于初始化类的静态成员或执行仅对类而不是每个单个对象应发生一次的操作。

## 在 OOP 中，聚合和关联的含义是什么，它们在 C#中是如何实现的？

**聚合**和**关联**代表了在 OOP 范式中类之间两种不同的关系。关联表示两个类之间更广泛的关系，表明一个类包含另一个类。

让我展示一些它们是如何实现的示例：

+   关联是两个类之间的双向关系。在这里，我们演示了**图书馆**类和**书籍**类之间的一对多关联：

    ```cs
    public class Book
    ```

    ```cs
    {
    ```

    ```cs
        public string Title { get; set; }
    ```

    ```cs
    }
    ```

    ```cs
    public class Library
    ```

    ```cs
    {
    ```

    ```cs
        public List<Book> Books { get; set; }
    ```

    ```cs
        public Library()
    ```

    ```cs
        {
    ```

    ```cs
            Books = new List<Book>();
    ```

    ```cs
        }
    ```

    ```cs
    }
    ```

    在前面的代码中，`Library`类有一个`Book`对象的列表，说明了一对一的关联。

+   聚合表示一个类是另一个类的部分的关系。在这里，我们展示了**汽车**类和**引擎**类之间的聚合关系：

    ```cs
    public class Engine
    ```

    ```cs
    {
    ```

    ```cs
        public string Model { get; set; }
    ```

    ```cs
    }
    ```

    ```cs
    public class Car
    ```

    ```cs
    {
    ```

    ```cs
        public Engine CarEngine { get; set; }
    ```

    ```cs
        public Car(Engine engine)
    ```

    ```cs
        {
    ```

    ```cs
            CarEngine = engine;
    ```

    ```cs
        }
    ```

    ```cs
    }
    ```

    在这个例子中，`Car`类包含一个`Engine`对象，展示了聚合关系，其中`Engine`类代表`Car`类的一部分。

通过这些示例，我们可以看到如何在 C#中使用类属性和构造函数实现关联和聚合关系。

## 如果 C#没有直接支持，如何实现多重继承？

在 C#中，没有直接的多重继承支持。然而，可以通过接口实现多重继承。一个类可以实现来自不同来源的多个接口。

## “组合优于继承”的原则是什么意思，它在什么时候有用？

**组合**优于**继承**是一种软件设计方法，它鼓励使用组合（对象利用其他对象）而不是继承来实现代码重用。当类的行为需要动态变化或继承可能导致类之间不希望出现的刚性耦合时，这可能很有用。

## 为什么 C# 中的异常被认为是对象，以及你如何创建自己的异常类？

在 C# 中，异常被实现为继承自基类 `Exception` 的对象。这允许传递有关异常的附加信息，并创建自定义异常类型。要创建自己的异常类，只需从 `Exception` 类或其子类继承即可。

## 在 C# 继承的上下文中，“base” 关键字有什么作用？

`base` 关键字允许你在派生类中调用基类的成员。它最常用于派生类中调用基类的构造函数或访问在派生类中被覆盖的其他基类成员。

## 在 C# 中，“this” 关键字是如何使用的？

`this` 关键字指向类的当前实例。它通常用于指向当前对象的字段或方法，尤其是在方法参数名称与类字段名称重叠时。

我们在本章中完成了对 C# 和面向对象编程基础的探索之旅。在建立了坚实的基础后，你将准备好应对技术面试中最常见的 C# 编码场景。

# 摘要

在本章中，我们深入探讨了关键概念，研究了数据类型、变量和运算符，分析了控制结构和循环，并发现了面向对象编程的基础。然而，精通 C# 是一个持续的学习过程。

随着我们翻过这一页，我们将在下一章开始探索 C# 编程的更高级领域。*第四章*，*高级 C# 概念*，将揭示 C# 的高级特性，包括处理集合、LINQ、异常处理、调试、异步编程以及更多。

我们将揭开 C# 的复杂性，学习如何充分利用其功能来解决更复杂的问题并提高应用程序性能。从使用泛型类、方法和接口创建可重用代码，到深入多线程和垃圾回收，我们将为你提供应对更高层次编程挑战的准备。记住，每个概念都是一块垫脚石，引领你掌握 C# 编程的艺术。所以，系好安全带，准备开始你学习旅程中的下一章精彩内容！

# 额外阅读

+   *《C# 12 和 .NET 8 – 现代跨平台开发基础 - 第八版》，作者：马克·J·普赖斯*

    [C# 12 和 .NET 8 现代跨平台开发基础第八版](https://www.packtpub.com/product/c-12-and-net-8-modern-cross-platform-development-fundamentals-eighth-edition/9781837635870)

+   *《使用 C# 代码重构》*，作者：Matt Eland

    [使用 C# 代码重构](https://www.packtpub.com/product/refactoring-with-c/9781835089989)
