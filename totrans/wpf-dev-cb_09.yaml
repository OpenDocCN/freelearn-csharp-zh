- en: Using WCF Services
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WCF 服务
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a WCF service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 WCF 服务
- en: Self-hosting a WCF service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自托管 WCF 服务
- en: Hosting a WCF service in IIS Server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 IIS 服务器上托管 WCF 服务
- en: Integrating a WCF service in a WPF application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中集成 WCF 服务
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the modern world, enterprise applications are the key to consumer-centric
    enterprises. Users access one or multiple devices to connect to the external world.
    And to succeed at this, the business needs shared services, which can be consumed
    by all such devices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代世界，企业应用程序是面向消费者的企业的关键。用户通过一个或多个设备连接到外部世界。为了成功做到这一点，业务需要共享服务，这些服务可以被所有这样的设备消费。
- en: The **service-oriented architecture** (**SOA**) is a design principle that enterprises
    follow to outline well-defined services, using a common set of contracts. Each
    of these services can be individually modified independently of one another and
    consumed by the external world.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务的架构**（**SOA**）是企业遵循的设计原则，用于定义明确的服务，使用一组通用的合同。这些服务中的每一个都可以独立于其他服务进行修改，并由外部世界消费。'
- en: '**Windows Communication Foundation** (**WCF**) is a framework to build such
    service-oriented applications. Using WCF, you can send data/messages asynchronously
    from one endpoint to the other. You can host a service endpoint in IIS, or in
    an application directly. The messages passed via this service endpoint can be
    a single character or a word sent as XML, or a complex stream of binary data.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows Communication Foundation**（**WCF**）是一个用于构建面向服务应用程序的框架。使用 WCF，您可以从一个端点异步发送数据/消息到另一个端点。您可以在
    IIS 或直接在应用程序中托管服务端点。通过此服务端点传递的消息可以是作为 XML 发送的单一字符或单词，也可以是复杂的二进制数据流。'
- en: 'WCF has been widely accepted as a standard to create web services, which offers
    support to multiple protocols and endpoints. In WCF, there are three important
    things that you need to remember; these things are generally known as the **ABC
    of WCF**. The ABC of WCF endpoints defines the following elements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WCF 已被广泛接受为创建 Web 服务的标准，它支持多种协议和端点。在 WCF 中，有三个重要的事情需要您记住；这些事情通常被称为 WCF 的 **ABC**。WCF
    端点的 ABC 定义了以下元素：
- en: '**A** for **Address**, which specifies where the service resides. This generally
    follows the URL format as `schema://domain[:port]/path`, for example `http://www.kunal-chowdhury.com:8080/Services`,
    `https://www.kunal-chowdhury.com:8050/Services`, or `http://192.168.0.1/Services`.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A** 代表 **Address**，它指定服务所在的位置。这通常遵循 URL 格式，如 `schema://domain[:port]/path`，例如
    `http://www.kunal-chowdhury.com:8080/Services`、`https://www.kunal-chowdhury.com:8050/Services`
    或 `http://192.168.0.1/Services`。'
- en: '**B** stands for **Binding**, which is basically a group of elements that corresponds
    to the transport and protocol channels located in the channel stack, to define
    how the messages are handled in the service side and the client side.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B** 代表 **Binding**，这基本上是一组元素，对应于通道堆栈中位于传输和协议通道中的元素，用于定义在服务端和客户端如何处理消息。'
- en: '**C** stands for **Contract**, which is nothing but an agreement between the
    client and the server about the structure (data contract) and content (message
    contract) being passed through the channel.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C** 代表 **Contract**，这仅仅是客户端和服务器之间关于通过通道传递的结构（数据合同）和内容（消息合同）的协议。'
- en: In this chapter, we will learn how to create WCF services, host them, and integrate
    them into a WPF application to give a service call to the defined endpoint. As
    this book is not about WCF, we will just be discussing basic concepts to get you
    started with it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建 WCF 服务，托管它们，并将它们集成到 WPF 应用程序中，以便对定义的端点进行服务调用。由于本书不是关于 WCF 的，我们只会讨论基本概念，以帮助您入门。
- en: Please ensure that ASP.NET and WCF are correctly installed and registered. To
    confirm, open the **Visual Studio 2017 Installer**, and make sure that the ASP.NET
    and web development workload, as well as the Windows Communication Foundation
    components, are already installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保 ASP.NET 和 WCF 已正确安装并注册。为了确认，请打开 **Visual Studio 2017 安装程序**，并确保 ASP.NET
    和 Web 开发工作负载以及 Windows Communication Foundation 组件已经安装。
- en: 'If they''re not there already, select them, and modify the installation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们还没有被选中，请选择它们，并修改安装：
- en: '![](img/2b05231d-fff8-4ef4-b6ba-5d03a418548d.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b05231d-fff8-4ef4-b6ba-5d03a418548d.png)'
- en: Creating a WCF service
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 WCF 服务
- en: A WCF service is a secure service to process business transactions, which supplies
    current data to others, exposing a workflow implemented using **Windows Workflow
    Foundation** as a WCF service. It provides a single programming model to leverage
    the features to create a unified solution to all distributed technologies. That
    means you can write the service once and expose different endpoints to exchange
    messages using any format (default is SOAP) over any transport protocol, that
    is, HTTP, TCP, MSMQ, Named Pipes, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: WCF 服务是一个用于处理业务交易的安全服务，它向他人提供当前数据，通过将使用 **Windows Workflow Foundation** 实现的工作流作为
    WCF 服务公开。它提供了一个单一的编程模型，以利用功能创建一个针对所有分布式技术的统一解决方案。这意味着您可以编写一次服务，并通过任何格式（默认为 SOAP）在任意传输协议（即
    HTTP、TCP、MSMQ、命名管道等）上公开不同的端点以交换消息。
- en: '**SOAP** (**Simple Object Access Protocol**) is one of the preferred models,
    where communication between the server and the client happens by using XML-based
    data.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOAP**（**简单对象访问协议**）是首选模型之一，其中服务器和客户端之间的通信是通过基于 XML 的数据进行。'
- en: In this recipe, we will learn about **data contract**, **data member**, **service
    contract**, **operation contract**, you need to consider these when creating and
    connecting to WCF services. When a service reference is taken into an application
    project, the developer only needs to configure the service with a proper endpoint
    address. Let's start demonstrating it by creating a simple, basic WCF service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将了解 **数据合同**、**数据成员**、**服务合同**、**操作合同**，在创建和连接到 WCF 服务时需要考虑这些内容。当服务引用被引入应用程序项目时，开发者只需配置具有适当端点地址的服务。让我们通过创建一个简单的、基本的
    WCF 服务来演示这一点。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open Visual Studio IDE with administrative privileges. This
    is often useful while deploying the service in a server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，以管理员权限打开 Visual Studio IDE。在将服务部署到服务器时，这通常很有用。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a simple WCF service, which we will integrate
    into a WPF application later in this chapter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个简单的 WCF 服务，我们将在本章后面将其集成到 WPF 应用程序中：
- en: 'First, create a new project named `EmployeeService`. Use the WCF Service Application
    template while creating the project. You can find this under the WCF template
    category, as shown in the following screenshot:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `EmployeeService` 的新项目。在创建项目时使用 WCF 服务应用程序模板。您可以在 WCF 模板类别下找到它，如下面的截图所示：
- en: '![](img/136ba68d-a283-444a-a4ab-32be5ce99477.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/136ba68d-a283-444a-a4ab-32be5ce99477.png)'
- en: Visual Studio, by default, creates three service files (`IService1.cs`, `Service1.svc`,
    and `Service1.svc.cs`) inside the project. As we will create our own services
    from scratch, from Solution Explorer, let's delete all three of the files:![](img/f172caeb-eb8b-4688-87ad-20e8af578300.png)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 默认情况下，在项目内部创建了三个服务文件（`IService1.cs`、`Service1.svc` 和 `Service1.svc.cs`）。由于我们将从头开始创建自己的服务，从解决方案资源管理器中，让我们删除这三个文件：![图片](img/f172caeb-eb8b-4688-87ad-20e8af578300.png)
- en: 'Let''s create two folders inside the project node and name them `DataModels`
    and `Services`. This is optional, but it is a good idea to keep the code files
    organized:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目节点内部创建两个文件夹，并将它们命名为 `DataModels` 和 `Services`。这是可选的，但保持代码文件组织良好是一个好主意：
- en: '![](img/7241f331-65b7-452a-b314-3e194d4d0519.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7241f331-65b7-452a-b314-3e194d4d0519.png)'
- en: Now, right-click on the DataModels folder, and follow the context menu entry
    Add | Class... to create a new class file named `Employee`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击 DataModels 文件夹，并按照上下文菜单中的“添加 | 类...”选项创建一个名为 `Employee` 的新类文件。
- en: Inside the class implementation of the `Employee.cs` file, add a few public
    properties of type `string`, and name them `ID`, `FirstName`, `LastName`, and
    `Designation`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Employee.cs` 文件的类实现中，添加一些类型为 `string` 的公共属性，并分别命名为 `ID`、`FirstName`、`LastName`
    和 `Designation`。
- en: Set the attribute `[DataContract]` to the class level to specify that the type
    defines or implements a data contract and is serializable by a serializer, such
    as `System.Runtime.Serialization.DataContractSerializer`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性 `[DataContract]` 设置在类级别，以指定该类型定义或实现了数据合同，并且可以被序列化器（如 `System.Runtime.Serialization.DataContractSerializer`）序列化。
- en: Set the attribute `[DataMember]` to the properties that you want to be part
    of the data contract, and mark it to serializable by the `System.Runtime.Serialization.DataContractSerializer`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性 `[DataMember]` 设置在您希望成为数据合同一部分的属性上，并通过 `System.Runtime.Serialization.DataContractSerializer`
    标记为可序列化。
- en: 'You need to resolve the namespace `System.Runtime.Serialization`, in order
    to use the `DataContract` and `DataMember` attributes:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要解析命名空间 `System.Runtime.Serialization`，以便使用 `DataContract` 和 `DataMember`
    属性：
- en: '![](img/23cf7efd-0aed-4694-bff8-49ec52de8ffe.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23cf7efd-0aed-4694-bff8-49ec52de8ffe.png)'
- en: 'Here''s the complete code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是完整的代码：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, right-click on the Services folder, and follow the context menu entry Add
    | New Item... to create a new service definition.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击“服务”文件夹，并按照上下文菜单项“添加 | 新项...”创建一个新的服务定义。
- en: 'From the Add New Item dialog window, select the WCF Service as the template.
    Give it a name (in our case, it is `EmployeeService`), and click on the Add button,
    as shown in the following screenshot:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“添加新项”对话框中选择 WCF 服务作为模板。给它一个名称（在我们的例子中是 `EmployeeService`），然后点击添加按钮，如下面的截图所示：
- en: '![](img/e3591510-bcd2-45f1-963b-a4a6e9a3c881.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3591510-bcd2-45f1-963b-a4a6e9a3c881.png)'
- en: 'This will create three files under the `Services` folder: `IEmployeeService.cs`,
    `EmployeeService.svc`, and `EmployeeService.svc.cs`:![](img/cb63d9d2-ad5c-49e3-a0c7-7250736b0274.png)'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在 `Services` 文件夹下创建三个文件：`IEmployeeService.cs`、`EmployeeService.svc` 和 `EmployeeService.svc.cs`：![图片](img/cb63d9d2-ad5c-49e3-a0c7-7250736b0274.png)
- en: 'From Solution Explorer, navigate to the `IEmployeeService.cs` file, and add
    the following `using` namespace declarations:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器导航到 `IEmployeeService.cs` 文件，并添加以下 `using` 命名空间声明：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now replace the class definition with the following code snippet, which will
    have three operation contracts `GetEmployeeByID`, `GetEmployees`, and `InsertEmployee`.
    Mark the interface as `[ServiceContract]` and the methods as `[OperationContract]`.
    Here''s the code snippet for reference:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将类定义替换为以下代码片段，它将包含三个操作合约 `GetEmployeeByID`、`GetEmployees` 和 `InsertEmployee`。将接口标记为
    `[ServiceContract]`，并将方法标记为 `[OperationContract]`。以下是代码片段供参考：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, from Solution Explorer, navigate to the `EmployeeService.svc.cs` file,
    and create a `static` member variable of type `List<Employee>`. Let''s name it
    `m_employees`, which will be used as a static data source of our demo application:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从解决方案资源管理器导航到 `EmployeeService.svc.cs` 文件，并创建一个类型为 `List<Employee>` 的 `static`
    成员变量。让我们称它为 `m_employees`，它将用作我们演示应用程序的静态数据源：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s implement the interface `IEmployeeService`, as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现接口 `IEmployeeService`，如下所示：
- en: '![](img/63c88383-011d-42fc-b5ca-aee91e3082bf.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63c88383-011d-42fc-b5ca-aee91e3082bf.png)'
- en: 'Modify the method definitions to perform the operations as per the name/functionality.
    Let''s modify them, which will look like this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改方法定义以执行按名称/功能进行的操作。让我们修改它们，它们将看起来像这样：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That''s it! Your WCF service named `EmployeeService` is now ready to host,
    so that applications can consume it. To check whether the service can run properly,
    build the project and then right-click on the `EmployeeService.svc` file, from
    Solution Explorer, and click on `View in Browser (Browser_Name)`, which is View
    in Browser (Firefox) in our case:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！您的 WCF 服务 `EmployeeService` 现已准备好托管，以便应用程序可以消费它。要检查服务是否可以正常运行，请构建项目，然后在解决方案资源管理器中右键单击
    `EmployeeService.svc` 文件，并点击“在浏览器中查看（浏览器名称）”，在我们的例子中是“在浏览器中查看（Firefox）”：
- en: '![](img/9813c78a-b358-41cb-807c-757633414345.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9813c78a-b358-41cb-807c-757633414345.png)'
- en: This will start the service and show you the message Service is hosted on the
    server.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将启动服务并显示消息“服务已在服务器上托管”。
- en: A point to note is that if you are running the service from Visual Studio, it
    will require administrative permission to open the specified port and host the
    service. In case you haven't provided the admin privileges yet, please restart
    Visual Studio using Run as administrator.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果您从 Visual Studio 运行服务，它将需要管理员权限来打开指定的端口并托管服务。如果您尚未提供管理员权限，请使用“以管理员身份运行”重启
    Visual Studio。
- en: 'Once the service has been hosted on `localhost`, this will load the SVC file
    in a browser window, and it will look like the following screenshot, which tells
    us that the service is up and running without any issues:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦服务已在 `localhost` 上托管，这将加载浏览器窗口中的 SVC 文件，它将看起来如下截图所示，这告诉我们服务正在正常运行且没有问题：
- en: '![](img/a1179d76-7154-4cba-a153-c305e3ed60a3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1179d76-7154-4cba-a153-c305e3ed60a3.png)'
- en: 'Each service provides a **Web Services Description Language** (**WSDL**) that
    defines the public interfaces including the metadata, which is similar to **interface
    definition language** (**IDA**). Click on the link to generate the WSDL of the
    service. In case your browser does not show the generated WSDL on the screen,
    copy the link, and run it inside the Internet Explorer, which will give you the
    following XML output:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个服务都提供了一个 **Web 服务描述语言（WSDL**），它定义了包括元数据在内的公共接口，类似于 **接口定义语言（IDA**）。点击链接以生成服务的
    WSDL。如果您的浏览器没有在屏幕上显示生成的 WSDL，请复制链接，并在 Internet Explorer 中运行它，这将给出以下 XML 输出：
- en: '![](img/2b261c14-bf04-4b98-800a-afe3915c0890.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b261c14-bf04-4b98-800a-afe3915c0890.png)'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this simple WCF service, we have used few attributes. Let's learn more about
    each one of them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的WCF服务中，我们使用了少量属性。让我们更深入地了解每一个。
- en: The DataContract attribute
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DataContract属性
- en: A data contract is a formal agreement between a client and a service that abstractly
    describes the data to be exchanged. In WCF, this is the most common way to serialize
    an object and make it ready to be available for passing between client and service.
    This is done by marking the class with the `[DataContract]` attribute.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数据契约是客户端和服务之间的一种正式协议，抽象地描述了要交换的数据。在WCF中，这是序列化对象并将其准备好在客户端和服务之间传递的最常见方式。这是通过使用`[DataContract]`属性标记类来实现的。
- en: 'It is worth mentioning that the serialization is not restricted to exactly
    match the class name and/or the property names in the class. You can simply use
    the `DataContract` and `DataMember` attributes to define their names in serialization.
    For example, consider the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，序列化并不局限于与类名和/或类中的属性名完全匹配。您只需简单地使用`DataContract`和`DataMember`属性来定义它们在序列化中的名称。例如，考虑以下代码片段：
- en: '`[DataContract (Name = "Employee")]`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`[DataContract (Name = "Employee")]`'
- en: '`public class EmployeeModel { ... }`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`public class EmployeeModel { ... }`'
- en: In the preceding code snippet, though the class name is `EmployeeModel`, the
    class will be exposed to serialization as `Employee` as the name mapping has been
    done using the `Name` property of the attribute.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，尽管类名为`EmployeeModel`，但由于使用了属性中的`Name`属性进行名称映射，该类将以`Employee`名称进行序列化。
- en: The DataMember attribute
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DataMember属性
- en: 'The `[DataMember]` attribute, on the other hand, specifies that the member
    is part of a data contract and is serializable by the `DataContractSerializer`.
    You can use the following properties while defining the data member attribute:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，`[DataMember]`属性指定成员是数据契约的一部分，并且可以通过`DataContractSerializer`进行序列化。在定义数据成员属性时，您可以使用以下属性：
- en: '`Name`: It defines the name of the data member'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`：它定义了数据成员的名称'
- en: '`Order`: It sets the order of serialization and deserialization of the member'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Order`：它设置成员的序列化和反序列化顺序'
- en: '`TypeId`: It sets a unique identifier for this attribute in the derived class'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeId`：它为派生类中的此属性设置一个唯一的标识符'
- en: '`IsRequired`: This property gets or sets a value that instructs the serialization
    that the member must be present during deserializing'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsRequired`：此属性获取或设置一个值，指示在反序列化期间成员必须存在'
- en: '`EmitDefaultValue`: When defined, this property value is specified whether
    to serialize the default value of the data member'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmitDefaultValue`：当定义时，此属性值指定是否序列化数据成员的默认值'
- en: You should apply the `[DataMember]` attribute in conjunction with the `[DataContract]`
    attribute to identify the members of a type that are part of the data contract.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将`[DataMember]`属性与`[DataContract]`属性一起应用，以标识类型中属于数据契约的成员。
- en: The ServiceContract attribute
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ServiceContract属性
- en: 'The `[ServiceContract]` attribute is used to define an interface that provides
    the service. A service should have at least one service contract, decorated by
    the `[ServiceContract]` attribute. The following properties can be used with the
    `ServiceContractAttribute`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ServiceContract]`属性用于定义提供服务的接口。一个服务应该至少有一个由`[ServiceContract]`属性装饰的服务契约。以下属性可以与`ServiceContractAttribute`一起使用：'
- en: '`ConfigurationName`: It specifies the name of the service element in the configuration
    file.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigurationName`：它指定了配置文件中服务元素的名称。'
- en: '`Name`: This specifies the name of the contract in the WSDL element.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`：这指定了WSDL元素中契约的名称。'
- en: '`Namespace`: This specifies the namespace of the contract in the WSDL element.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Namespace`：这指定了WSDL元素中契约的命名空间。'
- en: '`SessionMode`: This specifies whether the contract requires a binding that
    supports sessions. It can have either of the following three values: `Allowed`
    (specifies that the contract supports the session), `NotAllowed` (specifies that
    the contract does not support the session), and `Required` (specifies that the
    contract does not require the session).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SessionMode`：这指定了契约是否需要支持会话的绑定。它可以有以下三个值之一：`Allowed`（指定契约支持会话）、`NotAllowed`（指定契约不支持会话）和`Required`（指定契约不需要会话）。'
- en: '`CallbackContract`: This property specifies the return contract in a duplex
    conversation.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallbackContract`：此属性指定双工会话中的返回契约。'
- en: '`ProtectionLevel`: This specifies the message-level security that an operation
    requires during runtime. It can be one of three types: `None` (only simple authentication),
    `Sign` (`Sign` data to help ensure data integrity), and `EncryptAndSign` (`Encrypt`
    and `Sign` data to ensure integrity and confidentiality of transmitted data).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProtectionLevel`：这指定了操作在运行时所需的消息级安全。它可以有三种类型：`None`（仅简单身份验证）、`Sign`（签名数据以帮助确保数据完整性）和
    `EncryptAndSign`（加密并签名数据以确保传输数据的完整性和机密性）。'
- en: '`HasProtectionLevel`: This indicates whether the `ProtectionLevel` property
    has been explicitly set.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HasProtectionLevel`：这表示是否已显式设置 `ProtectionLevel` 属性。'
- en: The OperationContract attribute
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OperationContract 属性
- en: 'The `[OperationContract]` attribute is used to define the methods of the service
    contract. This is placed on the methods that you want to include as part of the
    service contract. The following properties can be used to control the structure
    of the operation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`[OperationContract]` 属性用于定义服务合同的方法。它放置在您希望包含在服务合同中的方法上。以下属性可以用来控制操作的架构：'
- en: '`Action`: This property specifies the action that uniquely identifies the operation.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action`：此属性指定了唯一标识操作的动作用户。'
- en: '`ReplyAction`: This specifies the action of the reply message of the operation.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplyAction`：这指定了操作回复消息的动作。'
- en: '`AsyncPattern`: This indicates that the operation can be called asynchronously.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncPattern`：这表示操作可以异步调用。'
- en: '`ProtectionLevel`: This specifies the message-level security that an operation
    requires during runtime. It can be one of three types—`None` (only simple authentication),
    `Sign` (sign data to help ensure data integrity), and `EncryptAndSign` (encrypt
    and sign data to ensure integrity and confidentiality of transmitted data).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProtectionLevel`：这指定了操作在运行时所需的消息级安全。它可以有三种类型之一——`None`（仅简单身份验证）、`Sign`（签名数据以帮助确保数据完整性）和
    `EncryptAndSign`（加密并签名数据以确保传输数据的完整性和机密性）。'
- en: '`HasProtectionLevel`: This indicates whether the `ProtectionLevel` property
    has been explicitly set.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HasProtectionLevel`：这表示是否已显式设置 `ProtectionLevel` 属性。'
- en: '`IsOneWay`: This property indicates that the operation consists of a single
    input message and has no associated output message.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsOneWay`：此属性指示操作由一个输入消息组成，没有关联的输出消息。'
- en: '`IsInitiating`: This specifies whether this operation can be the initial operation
    in a session.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsInitiating`：这指定了此操作是否可以是会话中的初始操作。'
- en: '`IsTerminating`: This specifies whether WCF will attempt to terminate the current
    session after the operation completes.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsTerminating`：这指定了在操作完成后，WCF 是否尝试终止当前会话。'
- en: Self-hosting a WCF service
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自托管 WCF 服务
- en: To use a WCF service, you need to host it in a runtime environment, so that
    the service host can listen for requests from clients, direct those requests to
    the service, and send responses back to the client. Using the host, you can start
    and stop the service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 WCF 服务，您需要在一个运行时环境中托管它，这样服务宿主就可以监听来自客户端的请求，将请求直接导向服务，并将响应发送回客户端。使用宿主，您可以启动和停止服务。
- en: If you want to self-host a service, you must create an instance of the `System.ServiceModel.ServiceHost`
    class and configure it with endpoints. This can be done in code or in a configuration
    file. Once the host is ready, any client can access the service by the URL specified.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自托管一个服务，您必须创建 `System.ServiceModel.ServiceHost` 类的一个实例，并使用端点进行配置。这可以通过代码或配置文件完成。一旦宿主准备就绪，任何客户端都可以通过指定的
    URL 访问服务。
- en: Self-hosting can be done in any managed application, such as a console application,
    a Windows service, a Windows Forms application, or a **Windows Presentation Foundation**
    (**WPF**) application. In this recipe, we will learn how to self-host a WCF service
    in a console application and execute it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自托管可以在任何托管应用程序中完成，例如控制台应用程序、Windows 服务、Windows 窗体应用程序或 **Windows Presentation
    Foundation**（**WPF**）应用程序。在本菜谱中，我们将学习如何在控制台应用程序中自托管 WCF 服务并执行它。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, let's launch Visual Studio with administrative privileges. Now,
    open the project `CH09.EmployeeService`, which we created in the previous recipe.
    Ensure that the project builds successfully, and that the service launches properly
    in the browser. Mark down the service URL for reference, which we will be using
    later in this recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们以管理员权限启动 Visual Studio。现在，打开我们之前在上一道菜谱中创建的项目 `CH09.EmployeeService`。确保项目构建成功，并且服务在浏览器中正确启动。记下服务
    URL 以供参考，我们将在本菜谱的后续部分使用它。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s follow these steps to create a self-hosted console application:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建一个自托管的控制台应用程序：
- en: First, add a new project of type Console Application, inside the solution, and
    name it `CH09.SelfHostingDemo`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在解决方案内添加一个类型为控制台应用程序的新项目，并将其命名为`CH09.SelfHostingDemo`。
- en: 'Now, right-click on the References node, and add the project reference of the
    service (`CH09.EmployeeService`):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击“引用”节点，并添加服务的项目引用（`CH09.EmployeeService`）：
- en: '![](img/ae00c43b-79bb-419f-aba6-93ed95a2077f.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae00c43b-79bb-419f-aba6-93ed95a2077f.png)'
- en: Also add the assembly reference of `System.ServiceModel` into the console application
    project.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需将`System.ServiceModel`的程序集引用添加到控制台应用程序项目中。
- en: From Solution Explorer, navigate to the `Program.cs` file.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“解决方案资源管理器”导航到`Program.cs`文件。
- en: 'Add the following `using` namespaces inside the class file:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类文件内添加以下`using`命名空间：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we need to define the service URL so that we can access it from the host.
    Create a static member variable inside the `Program.cs` class file, as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要定义服务URL，以便我们可以从宿主访问它。在`Program.cs`类文件中创建一个静态成员变量，如下所示：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Program` class contains a static `Main` method. Replace the definition
    with the following code block:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Program`类包含一个静态的`Main`方法。将定义替换为以下代码块：'
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Build the solution, and run the console application. You will see the following
    output in the console output window:![](img/eb4a7010-2170-43d6-ad0e-d267f1a98199.png)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建解决方案，并运行控制台应用程序。您将在控制台输出窗口中看到以下输出![图片](img/eb4a7010-2170-43d6-ad0e-d267f1a98199.png)
- en: The service is now hosted through the host process. Press the *Enter* key to
    stop the service.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务现在通过宿主进程进行托管。按*Enter*键停止服务。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To host the service, the host application uses the `ServiceHost` class from
    the `System.ServiceModel` namespace. It gets instantiated based on the type of
    service that you have implemented. In the preceding example, the `ServiceHost`
    class creates an object of `EmployeeService.Services.EmployeeService` and removes
    it from memory whenever the service completes execution.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要托管服务，宿主应用程序使用`System.ServiceModel`命名空间中的`ServiceHost`类。它根据您实现的服务类型进行实例化。在上面的示例中，`ServiceHost`类创建了一个`EmployeeService.Services.EmployeeService`的对象，并在服务完成执行时将其从内存中移除。
- en: If you check the `ServiceHost` object in the **QuickWatch Window**, you will
    notice that the object exposes several properties. The `BaseAddress` property
    defines the URL of the service, which maintains a runtime socket listener that
    listens to the port for the created service for any incoming requests. Once it
    receives any request, it parses the whole message passed to it and calls the service
    object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在**快速查看窗口**中检查`ServiceHost`对象，您会注意到该对象公开了几个属性。`BaseAddress`属性定义了服务的URL，它维护一个运行时套接字监听器，监听为创建的服务打开的端口。一旦它收到任何请求，它就会解析传递给它的整个消息并调用服务对象。
- en: 'Here''s a screenshot of the QuickWatch Window, showing the number of properties
    exposed by the `ServiceHost` object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张快速查看窗口的截图，显示了`ServiceHost`对象公开的属性数量：
- en: '![](img/80d8cdb1-8a4c-45bd-b26c-0977d799e827.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80d8cdb1-8a4c-45bd-b26c-0977d799e827.png)'
- en: The `serviceHost.AddServiceEndpoint` adds a service endpoint to the hosted service
    with a specified contract, binding, and endpoint address. You can use any binding
    type based on your requirement, but here we have used `BasicHttpBinding` to create
    the service endpoint.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`serviceHost.AddServiceEndpoint`方法向托管服务添加一个具有指定契约、绑定和端点地址的服务端点。您可以根据需求使用任何绑定类型，但在这里我们使用了`BasicHttpBinding`来创建服务端点。'
- en: In case of `BasicHttpBinding`, SOAP messages are transferred. The SOAP message
    contains a well-defined envelop with a header and body of the message inside it.
    When a client calls the service, the `ServiceHost` class parses the message and
    calls the service by creating the context.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BasicHttpBinding`的情况下，传输SOAP消息。SOAP消息包含一个定义良好的封装，其中包含消息的头部和体。当客户端调用服务时，`ServiceHost`类解析消息并通过创建上下文来调用服务。
- en: 'To see the endpoints used by the `ServiceHost` object, expand the `Description`
    property in the QuickWatch Window and navigate to `Endpoints`. Expand the first
    endpoint of the service and check the `Address`, `Binding`, `Contract` ("ABC")
    properties of it. This will look as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`ServiceHost`对象使用的端点，请在快速查看窗口中展开`Description`属性，并导航到`Endpoints`。展开服务的第一个端点，并检查其`Address`、`Binding`、`Contract`（"ABC"）属性。它看起来如下所示：
- en: '![](img/d867da9d-5923-41cd-bf38-c01c8882bafd.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d867da9d-5923-41cd-bf38-c01c8882bafd.png)'
- en: You can see that the `Address` points to the `BaseAdress` of the service, the
    `Binding` denotes the `BasicHttpBinding` that we created, and the `Contract` exposes
    service `Name`, `ConfigurationName`, `ContractType`, `SessionMode`, `ProtectionLevel`,
    `HasProtectionLevel`, and other properties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`Address` 指向服务的 `BaseAddress`，`Binding` 表示我们创建的 `BasicHttpBinding`，而 `Contract`
    揭示了服务的 `Name`、`ConfigurationName`、`ContractType`、`SessionMode`、`ProtectionLevel`、`HasProtectionLevel`
    以及其他属性。
- en: When you are ready, the `serviceHost.Open()` method starts the service. It causes
    the communication object to transition from the created state to the opened state.
    When you are done, calling the `serviceHost.Close()` method stops the service.
    This causes the communication object to transition from its current state to the
    closed state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，`serviceHost.Open()` 方法启动服务。它使通信对象从创建状态转换为打开状态。当你完成时，调用 `serviceHost.Close()`
    方法停止服务。这将使通信对象从其当前状态转换为关闭状态。
- en: 'In case you want your service object to be reused, you can add a `ServiceBehavior`
    attribute to the service class, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使服务对象可重用，你可以在服务类中添加一个 `ServiceBehavior` 属性，如下所示：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you apply this attribute, it specifies the internal execution behavior
    of the service contract implementation. The specified `InstanceContextMode` can
    be one of three types:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用此属性时，它指定了服务合同实现的内部执行行为。指定的 `InstanceContextMode` 可以是三种类型之一：
- en: '**PerSession**: A new `System.ServiceModel.InstanceContext` object is created
    for each session.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PerSession**: 每个会话都会创建一个新的 `System.ServiceModel.InstanceContext` 对象。'
- en: '**PerCall**: A new `System.ServiceModel.InstanceContext` object is created
    prior to and recycled subsequent to each call. If the channel does not create
    a session, this value behaves as `PerCall`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PerCall**: 在每个调用之前创建一个新的 `System.ServiceModel.InstanceContext` 对象，并在调用之后回收。如果通道没有创建会话，此值的行为类似于
    `PerCall`。'
- en: '**Single**: Only one `System.ServiceModel.InstanceContext` object is used for
    all incoming calls and is not recycled subsequent to the calls. If a `service`
    object does not exist, a new one will be created.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Single**: 只使用一个 `System.ServiceModel.InstanceContext` 对象来处理所有传入的调用，并且在调用之后不会回收。如果不存在
    `service` 对象，将创建一个新的。'
- en: There's more...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you don''t have administrative rights on your system, the application will
    crash with `System.ServiceModel.AddressAccessDeniedException`, saying that the
    HTTP could not register the URL. The error log will look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有系统管理员权限，应用程序将因 `System.ServiceModel.AddressAccessDeniedException` 而崩溃，表示
    HTTP 无法注册 URL。错误日志将如下所示：
- en: '![](img/6fad9ef9-32d3-467a-aa69-0113308ecbb3.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fad9ef9-32d3-467a-aa69-0113308ecbb3.png)'
- en: If you encounter this error, run the application under admin privileges. If
    you are running the application directly from Visual Studio, relaunch Visual Studio
    with admin privileges. To do so, right-click on the Visual Studio icon and click
    on Run as administrator.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到此错误，以管理员权限运行应用程序。如果你直接从 Visual Studio 运行应用程序，请以管理员权限重新启动 Visual Studio。为此，右键单击
    Visual Studio 图标并单击“以管理员身份运行”。
- en: Hosting a WCF service in an IIS server
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 IIS 服务器中托管 WCF 服务
- en: Another way to host a WCF service is in an **IIS** (**Internet Information Services**).
    It requires a physical file with a `.svc` extension to host the service properly.
    Unlike the previous recipe, you won't need to write any code to create the instance
    of `ServiceHost`. IIS automatically creates it for you while hosting the service.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种托管 WCF 服务的方式是在 **IIS**（**互联网信息服务**）中。它需要一个具有 `.svc` 扩展名的物理文件来正确托管服务。与之前的配方不同，你不需要编写任何代码来创建
    `ServiceHost` 实例。IIS 在托管服务时会自动为你创建它。
- en: In this recipe, we will learn how to publish an already created service to host
    inside the IIS server of Windows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何将已创建的服务发布到 Windows 的 IIS 服务器中托管。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, launch the Visual Studio IDE with administrative rights. To
    do so, right-click on the icon and click Run as administrator. Now open the existing
    project `CH09.EmployeeService`, which we have created earlier. Alternatively,
    you can also open the solution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，以管理员权限启动 Visual Studio IDE。为此，右键单击图标并单击“以管理员身份运行”。现在打开我们之前创建的现有项目 `CH09.EmployeeService`。或者，你也可以打开解决方案。
- en: To proceed further, we assume that you are familiar with IIS and understand
    how to use the IIS management tool to create and manage IIS applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步操作，我们假设你已经熟悉 IIS 并了解如何使用 IIS 管理工具创建和管理 IIS 应用程序。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s follow these steps to host our service in an IIS server:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤在 IIS 服务器中托管我们的服务：
- en: 'First, you need to check whether the **IIS** (**Internet Information Services**)
    is already installed on the system, where you are going to host the service. To
    check this, open the Control Panel and navigate to Turn Windows features on or
    off, as shown in the following screenshot:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要检查您打算托管服务的系统上是否已经安装了**IIS**（**互联网信息服务**）。为此，打开控制面板，导航到“启用或关闭Windows功能”，如下面的截图所示：
- en: '![](img/e2fb6da1-0573-4f91-84b2-fd3506c2d978.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2fb6da1-0573-4f91-84b2-fd3506c2d978.png)'
- en: From the Windows Features dialog, which pops up on the screen, make sure that
    the Internet Information Services feature is checked. If not, check it, and click
    OK. This will install the IIS server on that system.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从屏幕上弹出的“Windows功能”对话框中，确保已选中“互联网信息服务”功能。如果没有，请选中它，然后点击“确定”。这将在该系统上安装IIS服务器。
- en: 'Now, click on Start (![](img/1e167e22-1ea5-4da5-942c-1aeaac7192bc.png)), type
    `inetmgr`, and click the Internet Information Services (IIS) Manager app shortcut
    to launch it. Make sure that the Default Web Site is up and running. In the next
    steps, we will be deploying our service on this website:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**开始**(![](img/1e167e22-1ea5-4da5-942c-1aeaac7192bc.png))，输入`inetmgr`，然后点击“互联网信息服务（IIS）管理器”应用程序快捷方式来启动它。请确保默认网站正在运行。在接下来的步骤中，我们将在这个网站上部署我们的服务：
- en: '![](img/78545579-f1a9-41ce-b429-693f46e6bfce.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78545579-f1a9-41ce-b429-693f46e6bfce.png)'
- en: Once the IIS is installed (in case it was not already) and the Default Web Site
    in IIS is up and running, navigate back to Visual Studio.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦IIS安装完成（如果尚未安装）并且IIS中的默认网站正在运行，导航回Visual Studio。
- en: 'From the Solution Explorer, right-click on the service project (`CH09.EmployeeService`)
    node, and click Publish:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“解决方案资源管理器”中，右键单击服务项目（`CH09.EmployeeService`）节点，然后点击**发布**：
- en: '![](img/b564bb0d-4ba0-40cb-9edb-3414fdb72888.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b564bb0d-4ba0-40cb-9edb-3414fdb72888.png)'
- en: 'This will open the publishing wizard inside Visual Studio. Navigate to the
    Publish tab, select publishing template as IIS, FTP, etc, and click the Publish
    button, demonstrated as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在Visual Studio内部打开发布向导。导航到“发布”选项卡，选择发布模板为IIS、FTP等，然后点击**发布**按钮，如下所示：
- en: '![](img/8cfb2202-4f2c-48c6-9fa5-6d16300ac591.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cfb2202-4f2c-48c6-9fa5-6d16300ac591.png)'
- en: 'This will open the Publish dialog. Make sure that the Connection tab is selected:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开发布对话框。请确保已选中**连接**选项卡：
- en: 1\. Select Web Deploy as the publishing method type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 选择**Web Deploy**作为发布方法类型。
- en: 2\. Enter the name of the server. In our case, as we are deploying it to the
    same system, it will be `localhost`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 输入服务器的名称。在我们的例子中，因为我们是在同一系统上部署，所以它将是`localhost`。
- en: 3\. Enter the name of the site where we are going to deploy our service. In
    our case, it is `Default Web Site`. To deploy it in a specific web app inside
    the website, enter the name of the web app after the site name. For example, to
    deploy in the `MyApp` web application inside the `Default Web Site`, the site
    name here will be `Default Web Site/MyApp`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 输入我们打算部署服务的网站名称。在我们的例子中，它是`Default Web Site`。如果我们想在网站内的特定Web应用中部署，请在网站名称后输入Web应用的名称。例如，要在`Default
    Web Site`内的`MyApp` Web应用中部署，这里的网站名称将是`Default Web Site/MyApp`。
- en: 4\. Enter the User name and Password of your web server, where you are going
    to deploy it. In our case, as it is `localhost`, we will not need to enter any
    credentials. Those two fields will be by default disabled.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 输入您将要部署的Web服务器的用户名和密码。在我们的例子中，因为它是在`localhost`上，我们不需要输入任何凭据。这两个字段将默认禁用。
- en: 5\. Click on Validate Connection to confirm about the publishing details that
    you entered. On success, you will see a green tick mark beside the Validate Connection
    button.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 点击**验证连接**以确认您输入的发布详情。如果成功，您将在“验证连接”按钮旁边看到一个绿色的勾号。
- en: Once done, click on Next to proceed to the Settings page:![](img/e055c838-79ac-4968-ae2a-44fef73028da.png)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击**下一步**以进入设置页面:![](img/e055c838-79ac-4968-ae2a-44fef73028da.png)
- en: Inside the Settings page, select Release as the Configuration. Optionally, select
    File Publish Options based on your requirement.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“设置”页面内，选择“发布”作为配置。根据需要，可选地选择“文件发布选项”。
- en: Once you are done, click Save to start the publishing:![](img/9e546c87-6f91-46fb-b310-3aecb9761ce0.png)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击**保存**以开始发布:![](img/9e546c87-6f91-46fb-b310-3aecb9761ce0.png)
- en: Once the Visual Studio IDE builds the solution and completes the deployment
    to the selected website, navigate back to the Internet Information Services (IIS)
    Manager application (`inetmgr`).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Visual Studio IDE构建了解决方案并完成了到所选网站的部署，导航回“互联网信息服务（IIS）管理器”应用程序（`inetmgr`）。
- en: 'Refresh the Default Web Site node, which will now list two folders, named bin
    and Services. Click on the Services folder, and switch to Content View. This will
    list the `EmployeeService.svc` file, which is present inside it. Here''s a screenshot
    of this:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新默认网站节点，现在将列出两个文件夹，分别命名为 bin 和 Services。单击 Services 文件夹，切换到内容视图。这将列出 `EmployeeService.svc`
    文件，它位于其中。以下是这个截图：
- en: '![](img/deee5118-56df-4cbd-a5b6-10cc2ad57297.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/deee5118-56df-4cbd-a5b6-10cc2ad57297.png)'
- en: As shown in the preceding screenshot, right-click on the `EmployeeService.svc`
    file, and then click Browse from the context menu entry. Alternatively, you can
    click on the Browse link present at the right-side Actions pane.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前一个截图所示，右键单击 `EmployeeService.svc` 文件，然后从上下文菜单中单击浏览。或者，您也可以单击右侧操作窗格中的浏览链接。
- en: 'This will open the service URL in the browser window as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在浏览器窗口中打开服务 URL，如下所示：
- en: '![](img/f1270073-7a3b-4ad7-894d-dd35b14ccd70.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1270073-7a3b-4ad7-894d-dd35b14ccd70.png)'
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: IIS hosting is integrated with ASP.NET and uses the features such as process
    recycling, process health monitoring, message-based activation, and more. IIS
    also offers integrated manageability, which makes it an enterprise-grade server.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: IIS 托管与 ASP.NET 集成，并使用进程回收、进程健康监控、基于消息的激活等功能。IIS 还提供集成管理性，使其成为企业级服务器。
- en: 'To host a service in IIS, the IIS needs to be configured properly. For hosting
    in IIS, no additional code needs to be written. The WCF services hosted in IIS
    are represented as `.svc` files inside the IIS application. A `.svc` file contains
    a WCF-specific processing directive, that is, an `@ServiceHost`, which creates
    the service host and allows the hosting structure of the WCF service to activate
    in response to incoming messages:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 IIS 中托管服务，IIS 需要正确配置。对于 IIS 托管，不需要编写额外的代码。在 IIS 中托管的 WCF 服务在 IIS 应用程序中以 `.svc`
    文件的形式表示。`.svc` 文件包含一个 WCF 特定的处理指令，即 `@ServiceHost`，它创建服务宿主并允许 WCF 服务的托管结构在接收到传入消息时激活：
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The value of the `Service` attribute is the fully qualified CLR type name (in
    our case, it's `CH09.EmployeeService.Services.EmployeeService`) of the service
    implementation. The `CodeBehind` attribute defines the relative path of the code
    behind the file of the `.svc`, which is `EmployeeService.svc.cs` in our example.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Service` 属性的值是服务实现的完全限定 CLR 类型名（在我们的例子中，它是 `CH09.EmployeeService.Services.EmployeeService`）。`CodeBehind`
    属性定义了 `.svc` 文件背后的代码的相对路径，在我们的例子中是 `EmployeeService.svc.cs`。'
- en: When you deploy a service, the precompiled `.dll` file gets deployed in the
    application's `bin` directory and updates only when a latest version of the class
    library gets deployed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署一个服务时，预编译的 `.dll` 文件被部署在应用程序的 `bin` 目录中，并且只有当类库的最新版本被部署时才会更新。
- en: The uncompiled source file gets deployed in the application's `App_Code` directory.
    When the application gets the first request, these uncompiled source files dynamically
    load into the memory. Any changes to these deployed source files causes the entire
    application to be recycled. A fresh recompilation happens automatically when a
    new request happens to the application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 未编译的源文件被部署在应用程序的 `App_Code` 目录中。当应用程序收到第一个请求时，这些未编译的源文件会动态加载到内存中。对已部署源文件的任何更改都会导致整个应用程序被回收。当应用程序收到新的请求时，会自动进行新鲜的重编译。
- en: Integrating a WCF service in a WPF application
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中集成 WCF 服务
- en: Once you create a WCF service, you probably would like to integrate it into
    a client application. But before that, you will have to create a WCF client proxy,
    so that you can communicate with the service through the WCF client proxy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个 WCF 服务，您可能希望将其集成到客户端应用程序中。但在那之前，您将不得不创建一个 WCF 客户端代理，这样您就可以通过 WCF 客户端代理与该服务进行通信。
- en: In this recipe, we will learn how to create the proxy client and give a call
    to the service to pass messages between the service and the client.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建代理客户端，并通过服务与客户端之间传递消息。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before going into the steps to integrate the service, we need to create a client
    application. Open your Visual Studio IDE, and create a new WPF project. Name it
    `CH09.ClientDemo`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入集成服务的步骤之前，我们需要创建一个客户端应用程序。打开您的 Visual Studio IDE，创建一个新的 WPF 项目。将其命名为 `CH09.ClientDemo`。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create the service proxy and integrate the service call
    in the client application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建服务代理并在客户端应用程序中集成服务调用：
- en: 'Right-click on the project node (`CH09.ClientDemo`), and follow the context
    menu path Add | Service Reference..., which will open the Add Service Reference
    dialog on the screen:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目节点（`CH09.ClientDemo`），然后按照上下文菜单路径添加 | 服务引用...，这将打开屏幕上的添加服务引用对话框：
- en: '![](img/749d3780-5c3e-4816-83ad-bb5f8e3af136.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/749d3780-5c3e-4816-83ad-bb5f8e3af136.png)'
- en: 'In the Add Service Reference dialog, enter the service URL (`http://localhost:59795/Services/EmployeeService.svc`)
    inside the Address field and click on the Go button:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加服务引用对话框中，在地址字段中输入服务URL（`http://localhost:59795/Services/EmployeeService.svc`），然后单击Go按钮：
- en: '![](img/43695922-6890-4c20-bb4e-905339b097db.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43695922-6890-4c20-bb4e-905339b097db.png)'
- en: This will resolve the service address and show the details about it.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将解析服务地址并显示其详细信息。
- en: 'As shown in the following screenshot, enter `EmployeeServiceReference` as the
    Namespace for the service proxy and click OK:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，将`EmployeeServiceReference`作为服务代理的命名空间输入，然后单击确定：
- en: '![](img/496125a6-c623-4986-942a-aa49440dbfcc.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/496125a6-c623-4986-942a-aa49440dbfcc.png)'
- en: This will create the service proxy as Connected Services under the project:![](img/ead9084e-c956-4066-b86b-c8d6ac0fa148.png)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在项目下创建服务代理作为已连接的服务：![图片](img/ead9084e-c956-4066-b86b-c8d6ac0fa148.png)
- en: Build the project to make sure that there are no compilation issues.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以确保没有编译问题。
- en: Once the build gets succeeded, navigate to the `MainWindow.xaml.cs` file.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦构建成功，导航到`MainWindow.xaml.cs`文件。
- en: 'Create a dependency property of type `ObservableCollection<Employee>`, and
    name it as `Employees`. The property implementation will look as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为`ObservableCollection<Employee>`的依赖属性，并将其命名为`Employees`。属性实现如下：
- en: '[PRE10]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, resolve the reference of the `Employee` class, which will add `CH09.ClientDemo.EmployeeServiceReference`
    as the `using` namespace:![](img/1099f510-f417-4755-83a8-364efd49cd34.png)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，解析`Employee`类的引用，这将添加`CH09.ClientDemo.EmployeeServiceReference`作为`using`命名空间：![图片](img/1099f510-f417-4755-83a8-364efd49cd34.png)
- en: 'Make sure the following `using` namespaces are added to the class file:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在类文件中添加以下`using`命名空间：
- en: '[PRE11]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the class, create the following static instance of the proxy client,
    so that we can call the service APIs:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部，创建以下代理客户端的静态实例，以便我们可以调用服务API：
- en: '[PRE12]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, add the following two methods inside the class, and make sure that the
    methods are marked as `async`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在类内部添加以下两个方法，并确保将方法标记为`async`：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From Solution Explorer, navigate to the `MainWindow.xaml` file.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，导航到`MainWindow.xaml`文件。
- en: Give a name to the `Window` instance by adding the `x:Name="window"` attribute.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`x:Name="window"`属性为`Window`实例命名。
- en: 'Split the default `Grid` into two rows, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的`Grid`分为两行，如下所示：
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the first row of the `Grid` panel, add a `DataGrid`, and create a data binding
    between the `ItemsSource` property and the `Employees` collection. This will populate
    the `DataGrid` with the values from the `Employees` collection.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Grid`面板的第一行中添加一个`DataGrid`，并在`ItemsSource`属性和`Employees`集合之间创建数据绑定。这将使用`Employees`集合中的值填充`DataGrid`。
- en: 'Set `AutoGenerateColumns="False"`, `CanUserAddRows="False"`, and `CanUserDeleteRows="False"`,
    as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`AutoGenerateColumns="False"`、`CanUserAddRows="False"`和`CanUserDeleteRows="False"`，如下所示：
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we have already asked the `DataGrid` not to generate the columns automatically,
    we need to manually create them, based on the need. In this demonstration, we
    will only display the `ID`, `Name`, and `Designation` columns in the `DataGrid`.
    Let''s add the following columns, among which, the Name column will have a multi-binding
    with the `FirstName` and `LastName` properties of the `Employee` class to display
    the full name of the employee. Here''s the code for your reference:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经要求`DataGrid`不要自动生成列，因此我们需要根据需要手动创建它们。在这个演示中，我们将在`DataGrid`中仅显示`ID`、`Name`和`Designation`列。让我们添加以下列，其中，名称列将与`Employee`类的`FirstName`和`LastName`属性进行多绑定，以显示员工的完整姓名。以下是供您参考的代码：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the second row of the `Grid` panel, let''s add a horizontal `StackPanel`
    with two buttons in it. Label them as Refresh and Add. Also, expose the `Click`
    event of both the two buttons:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Grid`面板的第二行中，让我们添加一个包含两个按钮的水平`StackPanel`。将它们标记为刷新和添加。同时，公开两个按钮的`Click`事件：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the code behind the file of the `MainWindow.xaml` (that is, in `MainWindow.xaml.cs`),
    write the `Click` event implementation for both the two buttons. The `OnRefreshClicked`
    event will call the `RefreshListAsync()` method to fetch the employees list. The
    `OnAddClicked` event will call the `AddNewEmployeeAsync()` method to give a call
    to the service to insert a new employee record, and then call the `RefreshListAsync()`
    method to fetch the current employee list from the service:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml`文件的代码背后（即`MainWindow.xaml.cs`），为两个按钮编写`Click`事件实现。`OnRefreshClicked`事件将调用`RefreshListAsync()`方法以获取员工列表。`OnAddClicked`事件将调用`AddNewEmployeeAsync()`方法以调用服务插入新的员工记录，然后调用`RefreshListAsync()`方法从服务获取当前的员工列表：
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's build the project and run the application. Make sure that the service
    is already running and accessible.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建项目并运行应用程序。确保服务已经运行并且可访问。
- en: You will see the following application UI on the screen:![](img/8309d3cc-a058-42c3-b677-a00a0eac3d3b.png)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在屏幕上看到以下应用程序UI：![图片](img/8309d3cc-a058-42c3-b677-a00a0eac3d3b.png)
- en: Click the Add button. This will create a new employee record and pass it to
    the service to store in the database, which is the static `m_employees` instance
    in our case.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加按钮。这将创建一个新的员工记录并将其传递给服务以存储在数据库中，在我们的案例中是静态的`m_employees`实例。
- en: After inserting the record, it will again give a call to the service to fetch
    the newly inserted details and populate the `DataGrid` in the UI. Clicking the
    Add button multiple times will add the number of records and fill the `DataGrid`
    accordingly:![](img/ce168531-a457-445d-b279-c681600ade72.png)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插入记录后，它将再次调用服务以获取新插入的详细信息并填充UI中的`DataGrid`。点击添加按钮多次将增加记录数量并相应地填充`DataGrid`：![图片](img/ce168531-a457-445d-b279-c681600ade72.png)
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The WCF client proxy can be generated manually by using the `SVCUtil.exe` (**Service
    Model Metadata Utility Tool**). It is a command-line tool for generating the code
    from the service metadata. The following command can be used to generate the proxy
    code: `svcutil.exe <Service URL>`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: WCF客户端代理可以通过使用`SVCUtil.exe`（**服务模型元数据工具**）手动生成。这是一个用于从服务元数据生成代码的命令行工具。以下命令可以用来生成代理代码：`svcutil.exe
    <Service URL>`。
- en: 'If you want to create the proxy client for the service that we created earlier,
    you can enter the following command in a console window:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为我们之前创建的服务创建代理客户端，你可以在控制台窗口中输入以下命令：
- en: '[PRE19]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Alternatively, you can also generate the client proxy from Visual Studio. As
    demonstrated previously, the Add Service Reference feature generates the proxy
    code automatically. Once you click the Go button after inserting the service address,
    the dialog displays a list of services available at the address specified. It
    starts generating the code when you click the OK button.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以从Visual Studio生成客户端代理。如前所述，添加服务引用功能会自动生成代理代码。一旦你点击插入服务地址后的“Go”按钮，对话框将显示指定地址上可用的服务列表。当你点击“OK”按钮时，它开始生成代码。
- en: 'In our case, the **Service Model Metadata Utility Tool** and the Add Service
    Reference dialog of Visual Studio (you can use either of them) generates the following
    WCF client class (`EmployeeServiceClient`) for our service, which inherits from
    the generic `System.ServiceModel.ClientBase<TChannel>` class and implements the
    `CH09.ClientDemo.EmployeeServiceReference.IEmployeeService` interface:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，**服务模型元数据工具**和Visual Studio的添加服务引用对话框（你可以使用其中的任何一个）为我们生成以下WCF客户端类（`EmployeeServiceClient`），它继承自泛型`System.ServiceModel.ClientBase<TChannel>`类并实现了`CH09.ClientDemo.EmployeeServiceReference.IEmployeeService`接口：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the service proxy gets created, you can create the instance of the service
    client and call the methods of the service. In our example, we created the following
    service client instance and marked it as `static`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建服务代理，你就可以创建服务客户端的实例并调用服务的方法。在我们的例子中，我们创建了以下服务客户端实例并将其标记为`static`：
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The client consists of two API method types for each operation contract that
    the service has exposed. One of them is a synchronous method, whereas the other
    is asynchronous. For example, you could see `GetEmployees()` and `GetEmployeesAsync()`
    methods, as listed in the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端对于服务公开的每个操作合约都有两种API方法类型。其中一个是同步方法，而另一个是异步方法。例如，你可以看到`GetEmployees()`和`GetEmployeesAsync()`方法，如以下截图所示：
- en: '![](img/8f1aa35b-55f0-4bfe-8c21-0f8c7181091d.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f1aa35b-55f0-4bfe-8c21-0f8c7181091d.png)'
- en: When you want to call the service in a synchronous way, call the `GetEmployees()`
    method. In case you want to operate in asynchronous mode, call the `GetEmployeesAsync()`
    method. Similarly, to get the employee details by ID, you can select between `GetEmployeeByID`
    and `GetEmployeeByIDAsync`, based on synchronous and asynchronous modes. It is
    a similar case for other service methods.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想以同步方式调用服务时，请调用`GetEmployees()`方法。如果您想以异步模式操作，请调用`GetEmployeesAsync()`方法。同样，根据同步和异步模式，您可以通过选择`GetEmployeeByID`和`GetEmployeeByIDAsync`来根据ID获取员工详细信息。其他服务方法的情况也类似。
- en: There's more...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A WCF service client may throw one or more exceptions, which you must handle
    in your code. Some of the most common exceptions are:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: WCF服务客户端可能会抛出一个或多个异常，您必须在您的代码中处理这些异常。其中一些最常见的异常包括：
- en: '`SocketException`: This may occur when an existing connection was forcibly
    closed by the remote host'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocketException`：当远程主机强制关闭现有连接时可能会发生此异常'
- en: '`CommunicationException`: This may occur when the underlying connection was
    unexpectedly closed'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommunicationException`：当底层连接意外关闭时可能会发生此异常'
- en: '`CommunicationObjectAbortedException`: This may occur when the socket connection
    was aborted due to an error processing your message, a timeout while processing
    the request, or an underlying network issue'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommunicationObjectAbortedException`：当由于处理您的消息时出现错误、处理请求时超时或底层网络问题而导致套接字连接被中止时可能会发生此异常'
