<html><head></head><body>
		<div><h1 id="_idParaDest-179" class="chapter-number"><a id="_idTextAnchor187"/>10</h1>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor188"/>Consuming REST Services</h1>
			<p>Up until now, when we needed data, we faked it by using hardcoded objects. In a real-world program, however, you will get most of your data from local databases (as discussed in <a href="B19723_08.xhtml#_idTextAnchor144"><em class="italic">Chapter 8</em></a>), or you will interact with a service in the cloud through an API. You can interact using one of several architectures, of which the most popular for .NET MAUI is, arguably, <strong class="bold">Representational State </strong><strong class="bold">Transfer</strong> (<strong class="bold">REST</strong>).</p>
			<p>REST is a pattern that describes how classes interact across the internet. The key to REST is that it is stateless – that is, a sustained connection between the client and the API is not needed.</p>
			<p>The Forget Me Not architecture is designed to use a REST service and database, which will manage membership, authentication, and persistence of user data. In this chapter, we will look at the following:</p>
			<ul>
				<li>Using REST services</li>
				<li>The Forget Me Not API architecture</li>
				<li>API domain objects</li>
				<li><strong class="bold">Data Transfer </strong><strong class="bold">Objects</strong> (<strong class="bold">DTOs</strong>)</li>
				<li>The API Client class</li>
				<li>Using the API</li>
			</ul>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor189"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need Visual Studio. If you are going to enter the code as you follow along, you’ll want the branch for the previous chapter.</p>
			<p>The source code for the finished project for this chapter can be found at <a href="https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/REST">https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/REST</a>.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor190"/>Using REST Services</h1>
			<p>Until now, all the work<a id="_idIndexMarker417"/> we’ve been doing has been local to a device (a phone, Windows, or Mac). The design of Forget Me Not entails the use of a service in the cloud that will manage all our data – invitations to a program, registration, authentication, data persistence, and so on.</p>
			<p>A client interacts with a server<a id="_idIndexMarker418"/> through a <strong class="bold">REST API</strong> (also called a RESTful API).</p>
			<p>An <code>ForgetMeNot.API</code>.</p>
			<p class="callout-heading">Knowing more about REST</p>
			<p class="callout">For our purposes, that is really all you need to know about REST, but if you are curious, you can find out more at <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">https://en.wikipedia.org/wiki/Representational_state_transfer</a>.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor191"/>The Forget Me Not API architecture</h1>
			<p>When we looked at getting a user’s preferences in <a href="B19723_08.xhtml#_idTextAnchor144"><em class="italic">Chapter 8</em></a>, we used the Preference Service. That service, until now, used a method to return hardcoded values. That, of course, was a temporary <a id="_idIndexMarker420"/>expedient so that we could focus on one thing at a time. We are ready now to interact with the online API.</p>
			<p class="callout-heading">Where’s the service?</p>
			<p class="callout">I have created an online web service on Azure at <a href="https://forgetmenotapi20230113114628.azurewebsites.net/">https://forgetmenotapi20230113114628.azurewebsites.net/</a>.</p>
			<p class="callout">It is my goal to keep this up and running so that you can implement the client and get meaningful results, but given that there may be maintenance costs, by the time you read this, the service may no longer be in place. If that is true, you can still get 95% of what you need by reading the API code and using hardcoded data, as we’ve been doing up until now.</p>
			<p class="callout">Also, note that just going to the URL won’t get you anywhere. It is when we combine that base URL with the specific task-based additions that the magic happens. You can test whether the API is still available by creating an account or signing into one. If that works, then the rest of the API should work as well.</p>
			<p>To facilitate our REST interactions<a id="_idIndexMarker421"/> with the API, we will use the extremely popular open source <code>RestSharp</code> library (<a href="https://restsharp.dev/">https://restsharp.dev/</a>). It will do all the heavy lifting for us. (We’ll be using the <code>class</code> library template.)</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor192"/>Creating the projects</h2>
			<p>To get started, we’ll need three<a id="_idIndexMarker422"/> new projects. Right-click on <strong class="bold">Solution</strong> and choose <strong class="bold">Add New Project</strong>. The three projects are named:</p>
			<ul>
				<li><code>ForgetMeNot.API.Domain</code> (API domain objects)</li>
				<li><code>ForgetMeNot.API.Dto</code> (DTOs)</li>
				<li><code>ForgetMeNot.ApiClient</code> (a wrapper for the API)</li>
			</ul>
			<p><code>Api.Doman</code> and <code>API.Dto</code> are both class libraries. <code>APIClient</code> is a <code>webapi</code>.</p>
			<p>We’ll look at each of these in turn, filling in all the details.</p>
			<p>Because we’ll be using the API database, we can remove the local SQLite database. To do so, comment out or remove the <code>Constants</code> file and the entire <code>ForgetMeNotDemoDatabase.cs</code> file.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor193"/>Fleshing out the models</h2>
			<p>Before we <a id="_idIndexMarker423"/>create classes that correspond to the items in our model classes, we need to flesh them out.</p>
			<p>Let’s start with the <code>Preference</code> class in the <code>Model</code> directory. We had added an <code>Id</code> property for SQLite; we won’t need that anymore, so we can remove it. Remove it from <code>PreferencesTests.AfterCallingInitPreferencesIsNotEmpty()</code> as well.</p>
			<p>The design spec says that a user can invite a friend to be a buddy. We’ll need to add a model to describe the invitation:</p>
			<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
namespace ForgetMeNotDemo.Model;
[ObservableObject]
public partial class Invitation
{
  [ObservableProperty] private string buddyCode;
  [ObservableProperty] private int buddyId;
}</pre>
			<p>Similarly, we need to <a id="_idIndexMarker424"/>keep track of <em class="italic">occasions</em>, such as birthdays and anniversaries, so that we remember to use Forget Me Not to buy a present:</p>
			<pre class="source-code">
[ObservableObject]
public partial class Occasion
{
  [ObservableProperty] private string name;
  [ObservableProperty] private DateTime date;
  [ObservableProperty] private int numDaysToNotify;
}</pre>
			<p>We’ll need a couple more <code>Model</code> classes, such as <code>User</code> and its derived class, <code>Buddy</code>. The owner of the app is a user, as are all their buddies. Here is the <code>User </code><code>Model</code> class:</p>
			<pre class="source-code">
[ObservableObject]
public partial class User
{
  [ObservableProperty] private string name;
  [ObservableProperty] private string id;    [1]
  [ObservableProperty] private List&lt;Buddy&gt; buddies; [2]
  [ObservableProperty] private List&lt;Invitation&gt;
    invitations; [3]
  [ObservableProperty] private List&lt;Preference&gt;
    preferences; [4]</pre>
			<p><code>[1]</code> We’ve migrated the ID up here to the base class. We won’t need it for the (now non-existent) local <a id="_idIndexMarker425"/>database, but we will need the ID on the server. It is a <a id="_idIndexMarker426"/>string because the server will create a <strong class="bold">Globally Unique </strong><strong class="bold">ID</strong> (<strong class="bold">GUID</strong>).</p>
			<p><code>[2]</code> Each user can have any number of <code>Buddies</code>.</p>
			<p><code>[3]</code> Each user can send out any number of invitations.</p>
			<p><code>[4]</code> Each user will have a list of <code>Preference</code> objects.</p>
			<p class="callout-heading">Commented-out code</p>
			<p class="callout">Note that the <code>invitations</code> property is commented out in the code present in the GitHub repository. Please uncomment it.</p>
			<p>The <code>Buddy</code> class builds<a id="_idIndexMarker427"/> on this:</p>
			<pre class="source-code">
public partial class Buddy : User
{
  [ObservableProperty] private string emailAddress;
  [ObservableProperty] private string? phoneNumber;
  [ObservableProperty] private string? mailingAddressLine1;
  [ObservableProperty] private string? mailingAddressLine2;
  [ObservableProperty] private string? website;
  [ObservableProperty] private string? twitter;
  [ObservableProperty] private string? facebook;
  [ObservableProperty] private string? instagram;
  [ObservableProperty] private string? linkedIn;
  [ObservableProperty] private string? venmoName;
  [ObservableProperty] private InvitationStatus status;
  [ObservableProperty] private List&lt;OccasionModel&gt;
    occasions;
  [ObservableProperty] private DateTime buddySince;
}</pre>
			<p class="callout-heading">Commented-out code</p>
			<p class="callout">For now, do not uncomment <code>InvitationStatus</code> or <code>OccasionModel</code>.</p>
			<p>We store a lot of information about each buddy, including how long they’ve been our buddy, shared occasions, and the status of the invitation we sent to the <code>Buddy</code> class.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor194"/>Examining the API domain objects</h1>
			<p>The API domain objects are a<a id="_idIndexMarker428"/> superset of the <code>client model</code> classes. This is because there is data that the API will need that will not be visible on the client side. Right-click on <strong class="bold">ForgetMeNot.API.Domain</strong> and create the following classes:</p>
			<ul>
				<li><code>InvitationStatus</code></li>
				<li><code>Invite</code></li>
				<li><code>Occasion</code></li>
				<li><code>Related</code></li>
				<li><code>Roles</code></li>
				<li><code>User</code></li>
				<li><code>UserPreference</code></li>
			</ul>
			<p>Let’s walk through them, starting with <code>User</code> (note that this uses <code>UserPreference</code>, defined in the following code, so do not build until you have both classes):</p>
			<pre class="source-code">
public class User
{
    public Guid Id { get; set; }
    public string FullName { get; set; }
    public string Email { get; set; }
    public string HashedPassword { get; set; }
    public bool IsEmailConfirmed { get; set; }
    public string Role { get; set; }
    public List&lt;UserPreference&gt; Preferences { get; set; }
}</pre>
			<p>As you can see, on the server, each <code>User</code> instance has a unique ID. Most of the other properties are the same as on the client, although they may not have the same identifier (for example, <code>FullName</code> rather than <code>Name</code>). This is not a problem, as we’ll do the mapping when we get the objects <a id="_idIndexMarker429"/>from the server.</p>
			<p>There are a few new fields, however – for example, <code>IsEmailConfirmed</code>, <code>HashedPassword</code>, and <code>Role</code>. These are used by the server for authentication.</p>
			<p>Let’s create the <code>Roles</code> file. It is a static class with the two roles we’ll support:</p>
			<pre class="source-code">
public static class Roles
{
    public static string Admin = "admin";
    public static string User = "user";
}</pre>
			<p>Next, we’ll turn our attention to the <code>UserPreference</code> class. This corresponds to the <code>Preference</code> class in our client’s <code>Model</code> folder:</p>
			<pre class="source-code">
public class UserPreference
{
    public string PreferencePrompt { get; set; }
    public string PreferenceValue { get; set; }
}</pre>
			<p>Note that the API is, in some ways, independent of the client. We’re calling the class by a different name, and we’re not using the code generators.</p>
			<p>Next, we need classes to represent <code>Invitation</code> and <code>Occasion</code>. Let’s start with <code>Invitation</code>:</p>
			<pre class="source-code">
public class Invite
{
    public Invite()
    {
        Id = Guid.NewGuid();
    }
    public Guid Id { get; set; }
    public User CreatedByUser { get; set; }
    public User? AcceptedByUser { get; set; }
    public InvitationStatus Status { get; set; }
    public DateTime CreationDate { get; set; }
    public DateTime? EndDate { get; set; }
    public string InvitedUserName { get; set; }
    public string InvitedUserCustomMessage { get; set; }
}</pre>
			<p>This class has a property of the <code>InvitationStatus</code> type. Create a file for that as well. This is just<a id="_idIndexMarker430"/> an enumeration:</p>
			<pre class="source-code">
public enum InvitationStatus
 {
     Waiting,
     Expired,
     Accepted,
     Rejected
 }</pre>
			<p>Here’s the <code>Occasion</code> class:</p>
			<pre class="source-code">
public class Occasion
{
    public Occasion()
    {
        Id = Guid.NewGuid();
    }
    public Guid Id { get; set; }
    public User? ForUser { get; set; }
    public string? OccasionName { get; set; }
    public DateTime Date { get; set; }
    public int NumDaysToNotify { get; set; }
}</pre>
			<p>The purpose of <code>NumDaysToNotify</code> is to allow a user to designate how many days in advance of an occasion they want to be notified (that functionality is left as an exercise for you!).</p>
			<p>Finally, we add a class whose job is to tie a user to all their <code>Occasions</code> and buddies. Note that we <a id="_idIndexMarker431"/>use <code>User</code> for <code>Buddy</code>, as the base class has all the information we need:</p>
			<pre class="source-code">
public class Related
{
    public Related()
    {
        Occasions = new List&lt;Occasion&gt;();
        Users = new List&lt;User&gt;();
    }
    public Guid Id { get; set; }
    public string RelatedDescription { get; set; }
    public List&lt;User&gt; Users { get; set; }
    public List&lt;Occasion&gt; Occasions { get; set; }
    public DateTime Since { get; set; }
}</pre>
			<p>That’s it for that project. There are no methods; it really is just a set of server-based model objects.</p>
			<p>Once we have the <a id="_idIndexMarker432"/>models, we need to determine how to transfer this data to and from the server. For that, we need DTOs.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor195"/>Reviewing DTOs</h1>
			<p>The <code>ForgetMeNot.Api.Dto</code> project will, as you might have guessed, hold DTOs. These will correspond to the <a id="_idIndexMarker433"/>model objects but are designed to be passed back and forth between the server and the client.</p>
			<p class="callout-heading">Project reference</p>
			<p class="callout">You will need to add a project reference from <code>ForgetMeNot.Api.Dto</code> to <code>ForgetMeNot.Api.Domain</code>.</p>
			<p>Let’s start with <code>BuddyDto.cs</code>:</p>
			<pre class="source-code">
using ForgetMeNot.Api.Domain;
namespace ForgetMeNot.Api.Dto
{
    public class BuddyDto
    {
        public BuddyDto()
        {
        }
        public BuddyDto(User user)
        {
            UserId = user.Id;
            FullName = user.FullName;
            Email = user.Email;
            Preferences = new List&lt;UserPreference&gt;();
            if (user.Preferences?.Any(p =&gt;
                p.PreferenceValue != null) ?? false)
            {
                Preferences = user.Preferences.Where(p =&gt;
                    p.PreferenceValue != null).ToList();
            }
            Occasions = new List&lt;OccasionDto&gt;();
        }
        public Guid UserId { get; set; }
        public string FullName { get; set; }
        public string Email { get; set; }
        public List&lt;UserPreference&gt; Preferences { get; set; }
        public List&lt;OccasionDto&gt; Occasions { get; set; }
    }
}</pre>
			<p>Note that the<a id="_idIndexMarker434"/> constructor for <code>Buddy</code> takes <code>User</code>. As noted earlier, the <code>Buddy</code> class derives from <code>User</code>, and by passing <code>User</code> into the constructor, we can set <code>Buddy</code>’s <code>User</code> properties.</p>
			<p>Note that we are also using a list of <code>OccasionDto</code> objects. These are in the <code>ForgetMeNot.Api.Dto</code> project.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor196"/>Other DTO files</h2>
			<p>The other key files in <code>ForgetMeNot.Api.Dto</code> are not tied to model classes but, rather, are data that is <a id="_idIndexMarker435"/>exchanged between client and server to facilitate managing the account – for example, <code>AccountCreateRequest</code>:</p>
			<pre class="source-code">
public class AccountCreateRequest
{
    public string FullName { get; set; }
    public string Email { get; set; }
    public string PlainPassword { get; set; }
}</pre>
			<p>This is all that needs to be sent to the server when creating an account. There is a DTO to request an update to a user record that just contains <code>Id</code>, <code>FullName</code>, and <code>Email</code>. One important DTO is <code>UserResponse</code>, which contains information that corresponds to the <code>User </code><code>Domain</code> object:</p>
			<pre class="source-code">
public class UserResponse
{
  public Guid Id { get; set; }
  public string FullName { get; set; }
  public string Email { get; set; }
  public bool IsEmailConfirmed { get; set; }
  public string Role { get; set; }
  public List&lt;UserPreference&gt; Preferences { get; set; }
  public UserResponse()
  {
  }
  public UserResponse(User user)
  {
    Id = user.Id;
    FullName = user.FullName;
    Email = user.Email;
    Role = user.Role;
    IsEmailConfirmed = user.IsEmailConfirmed;
    Preferences = user.Preferences;
  }
}</pre>
			<p>You pass in a <code>User</code> object and <code>UserResponse</code> turns it into a DTO.</p>
			<p>Similarly, you can <a id="_idIndexMarker436"/>pass a <code>User</code> object into <code>ProfileResponse</code> and get back a <code>ProfileResponse</code> DTO:</p>
			<pre class="source-code">
public class ProfileResponse
{
  public Guid Id { get; set; }
  public string FullName { get; set; }
  public string Email { get; set; }
  public bool IsEmailConfirmed { get; set; }
  public string Role { get; set; }
  public List&lt;UserPreference&gt; Preferences { get; set; }
  public ProfileResponse(User user)
  {
    Id = user.Id;
    FullName = user.FullName;
    Email = user.Email;
    Role = user.Role;
    IsEmailConfirmed = user.IsEmailConfirmed;
    Preferences = user.Preferences;
  }
}</pre>
			<p>The final piece in the<a id="_idIndexMarker437"/> puzzle is to wrap the API in a client-side class to facilitate interactions with data in the cloud.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor197"/>Understanding ForgetMeNot.APIClient</h1>
			<p>The third API project, <code>ForgetMeNot.APIClient</code>, has only one class in it – <code>Client.cs</code>. This is the wrapper <a id="_idIndexMarker438"/>of the REST service that the client (<code>ForgetMeNotDemo</code>) will interact with.</p>
			<p>We start with four member variables:</p>
			<pre class="source-code">
public class Client
{
    RestClient client; [1]
    string baseUrl;   [2]
    string username;   [3]
    string password;</pre>
			<p><code>[1]</code> As noted earlier, <code>RestClient</code> is the library we are using to manage the REST interactions (obtained through NuGet, as discussed earlier).</p>
			<p><code>[2]</code> <code>baseURL</code> is the prefix<a id="_idIndexMarker439"/> for all the API calls and was created when we moved the API to Azure. As noted earlier, it is available at <a href="https://forgetmenotapi20230113114628.azurewebsites.net/">https://forgetmenotapi20230113114628.azurewebsites.net/</a>.</p>
			<p><code>[3]</code> <code>username</code> and <code>password</code> are used by the client to access the user’s record.</p>
			<p>The constructor to <code>Client</code> takes <code>baseUrl</code>, assigns it to the field, and then calls <code>SetClient()</code>:</p>
			<pre class="source-code">
public Client(string baseUrl)
{
    this.baseUrl = baseUrl;
    SetClient();
}
void SetClient()
{
    var options = new RestClientOptions(baseUrl)  [1]
    {
        ThrowOnAnyError = false,
        MaxTimeout = 10000
    };
    client = new RestClient(options); [2]
}</pre>
			<p><code>[1]</code> The options we want for this REST client create a robust interface; we won’t throw an exception on any error and we won’t time out for 10 seconds.</p>
			<p><code>[2]</code> With the options set, we can create a new <code>RestClient</code>, which is defined in <code>RestSharp</code>.</p>
			<p>The rest of the file is divided into <a id="_idIndexMarker440"/>sections for important behavior by the client, beginning with the code needed to authenticate the user.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor198"/>Authentication</h2>
			<p>We set a <code>IsAuthenticated</code> property, which is <a id="_idIndexMarker441"/>set to whether or not <code>client.Authenticator</code> is <code>null</code>.</p>
			<p>We then have a <code>Login</code> method that takes a <code>LoginRequest</code> object, sets <code>username</code> and <code>password</code>, and calls <code>Authenticate</code>:</p>
			<pre class="source-code">
public async Task Login(LoginRequest request)
{
    username = request.Username;
    password = request.Password;
    await Authenticate();
}</pre>
			<p class="callout-heading">Project reference</p>
			<p class="callout">You will need a reference to the DTO project.</p>
			<p><code>LoginRequest</code> is defined in the DTO project and simply has two string properties, <code>Username</code> and <code>Password</code> (refer to the following code block).</p>
			<p>The <code>Authenticate</code> method<a id="_idIndexMarker442"/> uses <code>RestSharp</code>’s OAuth authentication – that is, again, the heavy lifting is done by <code>RestSharp</code>:</p>
			<pre class="source-code">
async Task Authenticate()
{
    var request = new RestRequest("auth/gettoken");
    request.AddBody(new { username, password });
    var accessToken = await client.PostAsync&lt;string&gt;
        (request);
    client.Authenticator = new OAuth2Authorization
        RequestHeaderAuthenticator(accessToken, "Bearer");
}</pre>
			<p>Fortunately, you don’t need to understand how to make this work; you just pass in the username and password and <code>RestSharp</code> takes care of the rest of it for you.</p>
			<p class="callout-heading">Client versus client</p>
			<p class="callout">Remember that even though you are in the <code>Client</code> class, the <code>client</code> field is the <code>RestSharp</code> object.</p>
			<p>We have a helper method to get the current API version:</p>
			<pre class="source-code">
public Task&lt;string?&gt; Version()
{
    var request = new RestRequest("util/version");
    return client.GetAsync&lt;string?&gt;(request);
}</pre>
			<p>And that takes us to the<a id="_idIndexMarker443"/> profile section of the file, where we can get and update the <code>profile</code> object.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor199"/>Profile</h2>
			<p>There are two methods<a id="_idIndexMarker444"/> needed for the profile. The first gets the profile:</p>
			<pre class="source-code">
public Task&lt;ProfileResponse?&gt; GetProfile()
{
    var request = new RestRequest("profile/me");
    return client.GetAsync&lt;ProfileResponse?&gt;(request);
}</pre>
			<p>This uses the <code>ProfileResponse</code> DTO we examined earlier. The second method in this section is used to update the profile:</p>
			<pre class="source-code">
public Task UpdateProfile(ProfileUpdateRequest
    profileUpdateRequest)
{
    var request = new RestRequest("profile/me");
    request.AddBody(profileUpdateRequest);
    return client.PutAsync(request);
}</pre>
			<p>This code uses the <code>ProfileUpdateRequest</code> object defined in <code>ForgetMeNot.Api.Dto</code>.</p>
			<p>Again, all the interesting work here is being done by <code>RestSharp</code>. As you can see, the client is really just a <a id="_idIndexMarker445"/>wrapper around the <code>RestSharp</code> methods.</p>
			<p>Let’s reinforce this by looking at a couple more methods that are used to manage the <code>Buddy</code> object.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor200"/>The Buddy region</h2>
			<p>This region consists of the <a id="_idIndexMarker446"/>methods we need to interact with buddies, <code>GetBuddy</code> and <code>CreateInvitation</code>. <code>GetBuddy</code> returns a list of <code>BuddyDto</code> objects:</p>
			<pre class="source-code">
public Task&lt;List&lt;BuddyDto&gt;?&gt; GetBuddy()
{
    var request = new RestRequest("buddy");
    return client.GetAsync&lt;List&lt;BuddyDto&gt;?&gt;(request);
}</pre>
			<p><code>CreateInvitation</code> returns <code>Guid</code>, which is the <code>Id</code> attribute of the resulting <code>Invitation</code> object:</p>
			<pre class="source-code">
public Task&lt;Guid?&gt; CreateInvitation(InviteCreateRequest
  inviteCreateRequest)
{
    var request = new RestRequest("buddy/invite");
    request.AddBody(inviteCreateRequest);
    return client.PostAsync&lt;Guid?&gt;(request);
}</pre>
			<p>This code uses <code>InviteCreateRequest</code>, which is defined in <code>ForgetMeNot.Api.Dto</code>.</p>
			<p>Finally, we have a method to get all the users – that is, all this user’s buddies:</p>
			<pre class="source-code">
public Task&lt;List&lt;UserResponse&gt;?&gt; GetUserList()
{
    var request = new RestRequest("user");
    return client.GetAsync&lt;List&lt;UserResponse&gt;?&gt;(request);
}</pre>
			<p>What we get back is a list of <code>UserResponse</code> DTO objects that we saw earlier.</p>
			<p>Now that we’ve examined<a id="_idIndexMarker447"/> all the projects provided by the server, we are ready to have <code>ForgetMeNotDemo</code> interact with the API to get, store, and retrieve data.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor201"/>Using the API</h1>
			<p>With the <code>Client</code> class and its supporting <code>DTO</code> and <code>API</code> domain classes in place, we’re ready to interact with the API to <a id="_idIndexMarker448"/>create accounts and log in, as well as store and retrieve our preferences.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor202"/>Creating the account</h2>
			<p>The first thing a new user will do is create an account. To make this work, we need to bring the user to the <code>CreateAccount.xaml</code>, where they can fill in their name, email, and password. To implement this, we have to make some substantial changes to the <strong class="bold">Login</strong> and <strong class="bold">Create </strong><strong class="bold">Account</strong> pages.</p>
			<p>Let’s begin by pointing the application to start with login. Modify the <code>App.xaml.cs</code> <code>App</code> method to look like this:</p>
			<pre class="source-code">
public App(LoginViewModel loginViewModel) [1]
{
  InitializeComponent();
  MainPage = new LoginPage(loginViewModel); [2]
}</pre>
			<p><code>[1]</code> Have the IoC container pass in an instance of <code>LoginViewModel</code>.</p>
			<p><code>[2]</code> Set <code>MainPage</code> (the entry point to the program) to <code>LoginPage</code>.</p>
			<p>The job of the <strong class="bold">Login</strong> page will <a id="_idIndexMarker450"/>now be to either allow the user to log in or take them to the <strong class="bold">Create </strong><strong class="bold">Account</strong> page.</p>
			<p>Be sure to add routing for <code>CreateAccount</code> in <code>AppShell.xaml.cs</code>:</p>
			<pre class="source-code">
Routing.RegisterRoute("createaccount",
  typeof(CreateAccountPage));</pre>
			<p>Next, let’s modify the <strong class="bold">Login</strong> page.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor203"/>Modifying the Login page</h2>
			<p>Now that we’re going to turn<a id="_idIndexMarker451"/> management of authentication over to the server, we need a different <code>LoginPage.xaml.cs</code> and replace it with this simple version:</p>
			<pre class="source-code">
using CommunityToolkit.Maui.Core.Views;
using ForgetMeNotDemo.ViewModel;
namespace ForgetMeNotDemo.View;
public partial class LoginPage : ContentPage
{
  public LoginPage(LoginViewModel viewModel)
  {
    BindingContext = viewModel;
    InitializeComponent();
  }
}</pre>
			<p><code>LoginViewModel</code> is passed in from <code>App</code>, as shown in the preceding code.</p>
			<p>Now, let’s modify <code>LoginPage</code> to focus on<a id="_idIndexMarker452"/> either logging a user in or redirecting them to create a new account.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor204"/>Updating LoginPage</h2>
			<p>We’re going to make some <a id="_idIndexMarker453"/>significant changes to <code>LoginPage</code>. To avoid confusion, delete all you have there and replace it with this:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage
    x:Class="ForgetMeNot.View.LoginPage"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:iOsSpecific="clr-namespace:Microsoft.Maui
      .Controls.PlatformConfiguration.iOSSpecific;
        assembly=Microsoft.Maui.Controls"
    Title="Login"
    iOsSpecific:Page.UseSafeArea="True"
    Shell.NavBarIsVisible="False"
    Shell.PresentationMode="ModalAnimated"&gt;
    &lt;ContentPage.Resources&gt;
        &lt;ResourceDictionary&gt;
            &lt;Style x:Key="Prompt" TargetType="Label"&gt;   [1]
              &lt;Setter Property="TextColor" Value="Black" /&gt;
              &lt;Setter Property="FontSize" Value="Medium" /&gt;
              &lt;Setter Property="FontAttributes"
                  Value="Bold" /&gt;
                &lt;Setter Property="HorizontalTextAlignment"
                  Value="Center" /&gt;
                &lt;Setter Property="VerticalTextAlignment"
                  Value="Center" /&gt;
                &lt;Setter Property="VerticalOptions"
                  Value="Center" /&gt;
                &lt;Setter Property="HorizontalOptions"
                  Value="End" /&gt;
            &lt;/Style&gt;
            &lt;Style x:Key="LoginButton" TargetType="Button"&gt;
              &lt;Setter Property="BackgroundColor"
                Value="LightGray" /&gt;
              &lt;Setter Property="Margin" Value="0,20,0,0" /&gt;
              &lt;Setter Property="TextColor" Value="Black" /&gt;
             &lt;Setter Property="WidthRequest" Value="125" /&gt;
            &lt;/Style&gt;
        &lt;/ResourceDictionary&gt;
    &lt;/ContentPage.Resources&gt;</pre>
			<p>With the styles in place, we’re<a id="_idIndexMarker454"/> ready to create the <code>Labels</code> and <code>Entry</code> controls to get a user’s name and password:</p>
			<pre class="source-code">
&lt;VerticalStackLayout&gt;
        &lt;Grid
            ColumnDefinitions="*,*,*"
            RowDefinitions="Auto,Auto,Auto,Auto"
            RowSpacing="10"&gt;
            &lt;Label
                Grid.Row="0"
                Grid.Column="0"
                Style="{StaticResource Prompt}"
                Text="User name" /&gt;
            &lt;Entry
                Grid.Row="0"
                Grid.Column="1"
                Grid.ColumnSpan="2"
                Placeholder="User name"
                Text="{Binding LoginName}"
                WidthRequest="150" /&gt;
            &lt;Label
                Grid.Row="1"
                Grid.Column="0"
                HorizontalOptions="End"
                Style="{StaticResource Prompt}"
                Text="Password" /&gt;
            &lt;Entry
                Grid.Row="1"
                Grid.Column="1"
                Grid.ColumnSpan="2"
                IsPassword="True"
                Placeholder="Password"
                Text="{Binding Password}"
                WidthRequest="150" /&gt;
            &lt;Button
                Grid.Row="2"
                Grid.Column="0"
                Command="{Binding DoLoginCommand}"
                Style="{StaticResource LoginButton}"
                Text="Submit" /&gt;  [2]</pre>
			<p>Once a user has filled in the<a id="_idIndexMarker455"/> fields (or is unable to do so because they’ve forgotten their password), we will offer them the following choices:</p>
			<pre class="source-code">
             &lt;Button
                Grid.Row="2"
                Grid.Column="1"
                Command="{Binding DoCreateAccountCommand}"
                Style="{StaticResource LoginButton}"
                Text="Create Account" /&gt; [3]
            &lt;Button
                Grid.Row="2"
                Grid.Column="2"
                BackgroundColor="LightGray"
                Command="{Binding ForgotPasswordCommand}"
                Style="{StaticResource LoginButton}"
                Text="Forgot Password" /&gt; [4]
        &lt;/Grid&gt;
        &lt;ActivityIndicator  [6]
            x:Name="activityIndicator"
            HeightRequest="50"
            IsRunning="{Binding ShowActivityIndicator}"
            Color="Blue" /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre>
			<p><code>[1]</code> I’ve expanded the two <a id="_idIndexMarker456"/>styles a bit to minimize the styling in the controls.</p>
			<p><code>[2]</code> Click <code>ViewModel</code> a little later).</p>
			<p><code>[3]</code> Click <code>CreateAccount</code> page.</p>
			<p><code>[4]</code> Forgot password is (as they say) left as an exercise for you.</p>
			<p>With this new API-oriented <code>LoginViewModel</code>.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor205"/>The AccountService class</h2>
			<p>Before updating <code>LoginViewModel</code>, we’ll need <a id="_idIndexMarker457"/>to create the <code>AccountService</code> class and its associated interface:</p>
			<pre class="source-code">
using ForgetMeNot.Api.Dto;
using ForgetMeNot.ApiClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace ForgetMeNotDemo.Services
{
  public class AccountService : IAccountService
  {
    readonly Client apiClient;
    public AccountService(Client apiClient)
    {
      this.apiClient = apiClient;
    }
    public async Task CreateAccount(AccountCreateRequest
      accountCreateRequest)
    {
      await apiClient.CreateAccount(accountCreateRequest);
    }
    public async Task GetNewPassword()
    {
    }
    public async Task Login(LoginRequest request)
    {
      await apiClient.Login(request);
    }
    public bool IsLoggedIn()
    {
      return apiClient.IsAuthenticated;
    }
  }
}</pre>
			<p>This class is used in the creation <a id="_idIndexMarker458"/>and authentication of the account. With this in place, we are ready to update <code>LoginViewModel</code>.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor206"/>Updating LoginViewModel</h2>
			<p><code>LoginViewModel</code> must be updated to meet the<a id="_idIndexMarker459"/> new requirements of the updated <code>LoginPage</code> class. Once again, delete all that you have and replace it with this:</p>
			<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ForgetMeNot.API.Dto;
using ForgetMeNotDemo.Services;
using ForgetMeNotDemo;
namespace ForgetMeNotDemo.ViewModel
{
  [ObservableObject]
  public partial class LoginViewModel
  {
    private AccountService;           [1]
    [ObservableProperty] private string loginName;
    [ObservableProperty] private string password;
    [ObservableProperty] private bool showActivityIndicator
      = false;</pre>
			<p>The constructor is <a id="_idIndexMarker460"/>passed by <code>AccountService</code> by way of the <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) container and holds <a id="_idIndexMarker461"/>onto that service for its other methods:</p>
			<pre class="source-code">
    public LoginViewModel(AccountService accountService)
      [2]
    {
      this.accountService = accountService;
    }
    [RelayCommand]
    public async Task DoLogin()
    {
      try
      {
        LoginRequest loginRequest = new LoginRequest [3]
        {
          Username = LoginName,
          Password = Password
        };</pre>
			<p>We’ll set <code>ActivityIndicator</code> to display<a id="_idIndexMarker462"/> while we ask the API to log a user in:</p>
			<pre class="source-code">
        ShowActivityIndicator = true;
        await accountService.Login(loginRequest); [4]
        ShowActivityIndicator = false;
        if (accountService.IsLoggedIn()) [5]
        {
          Application.Current.MainPage = new AppShell();
          await Shell.Current.GoToAsync("mainpage");
        }
        else [6]
        {
          await Application.Current.MainPage.DisplayAlert
            ("Login failure",
              "Your username and password do not match our
                records", "Ok");
        }
      }
      catch (Exception exception)
      {
        await Application.Current.MainPage.DisplayAlert
          ("Authorization failure",
            "Your username and password do not match our
              records", "Ok");
        Console.WriteLine(exception);
      }</pre>
			<p>Implementing the logic to<a id="_idIndexMarker463"/> manage a forgotten password is left as an exercise for you:</p>
			<pre class="source-code">
    }
    [RelayCommand]
    public async Task ForgotPassword()
    {
[7]
    }</pre>
			<p>We delegate to the server the responsibility for creating new accounts:</p>
			<pre class="source-code">
    [RelayCommand]
    public async Task DoCreateAccount() [8]
    {
      try
      {
        Application.Current.MainPage = new AppShell();
        await Shell.Current.GoToAsync($"createaccount");
      }
      catch (Exception e)
      {
        Console.WriteLine(e);
      }
    }
  }
}</pre>
			<p><code>[1]</code> We create the <code>AccountService</code> field, which will mediate between <code>ViewModel</code> and the <code>Client</code> class.</p>
			<p><code>[2]</code> The IoC passes in the <code>AccountService</code> we need, which we will assign to the <code>AccountService</code> member <a id="_idIndexMarker464"/>we just created.</p>
			<p><code>[3]</code> We bundle up the username and password into a <code>LoginRequest</code> object. We get this class from <code>ForgetMeNot.API.DTO</code>:</p>
			<pre class="source-code">
public class LoginRequest
{
    public string Username { get; set; }
    public string Password { get; set; }
}</pre>
			<p><code>[4]</code> We turn <code>ActivityIndicator</code> on, pass <code>LoginRequest</code> to the API, and then, when we get a response, turn <code>ActivityIndicator</code> off. We’ll look at what <code>AccountService</code> is actually doing in the next step.</p>
			<p><code>[5]</code> We ask <code>AccountService</code> whether the login was successful. If it was (the happy path), we reset <code>MainPage</code> (away from <code>LoginPage</code>) and navigate there.</p>
			<p><code>[6]</code> If login fails (the sad path), we inform the user that we are unable to log them in and give them another chance to do so.</p>
			<p><code>[7]</code> This book will not<a id="_idIndexMarker465"/> implement the code to reset a password.</p>
			<p><code>AccountService</code> was responsible for the login. Let’s look at that next.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor207"/>Using AccountService to log in</h2>
			<p>For security purposes, we want a server to be responsible for authenticating a user based on an email address and <a id="_idIndexMarker466"/>password:</p>
			<pre class="source-code">
public async Task Login(LoginRequest request) [1]
{
  await apiClient.Login(request);
}
public bool IsLoggedIn() [2]
{
  return apiClient.IsAuthenticated;
}</pre>
			<p>Among other methods in <code>AccountService</code> (which we will return to shortly) are the following two methods:</p>
			<p><code>[1]</code> Login simply delegates to <code>apiClient</code> the responsibility to handle the <em class="italic">login</em> through the <em class="italic">API</em>, passing in <code>LoginRequest</code>, which contains the username and password.</p>
			<p><code>[2]</code> Similarly, the <code>IsLoggedIn</code> Boolean method uses <code>apiClient</code> to see whether the current user is <em class="italic">authenticated</em>.</p>
			<p>A second option exists for a user, which is to tap on the <code>CreateAccountPage</code>.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor208"/>Setting up the Create Account page</h2>
			<p>The <strong class="bold">Create Account</strong> page prompts a user for a username and a password, as well as their email. To keep things simple, in this <a id="_idIndexMarker467"/>example, we only ask for the password once, but we do implement validation:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage
    x:Class="ForgetMeNotDemo.View.CreateAccountPage"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:behaviors="http://schemas.microsoft.com/dotnet/
      2022/maui/toolkit"
    Title="CreateAccount"&gt;
    &lt;VerticalStackLayout&gt;
        &lt;Entry
            HorizontalOptions="FillAndExpand"
            Keyboard="Text"
            Placeholder="Enter Name"
            Text="{Binding Name}"&gt;
            &lt;Entry.Behaviors&gt;
                &lt;behaviors:UserStoppedTypingBehavior
      <a id="_idTextAnchor209"/>          Command="{Binding  ValidateNameCommand}"
                StoppedTypingTimeThreshold="500" /&gt;  [1]
            &lt;/Entry.Behaviors&gt;
        &lt;/Entry&gt;</pre>
			<p><code>[1]</code> We use the Community Toolkit’s <code>StoppedTypingBehavior</code> to detect when a user has finished entering a field. We set <code>StoppedTypingTimeThreshold</code> to <code>500</code> – that is, half a second. This indicates that once the user has not entered anything for half a second, we assume <a id="_idIndexMarker468"/>they are done and kick in the validation. Note that the command is set to <code>ValidateNameCommand</code>. This is handled in <code>ViewModel</code> (as shown later) but returns a Boolean, which indicates whether or not the user has entered a valid name:</p>
			<pre class="source-code">
        &lt;Label
            FontSize="13"
            IsVisible="{Binding ShowNameErrorMessage}"
              [1]
            Text="{Binding NameErrorMessage}"
            TextColor="Red" /&gt;
        &lt;Entry
            HorizontalOptions="FillAndExpand"
            Keyboard="Email"
            Placeholder="Enter Email"
            Text="{Binding Email}"&gt;
            &lt;Entry.Behaviors&gt;
                &lt;behaviors:UserStoppedTypingBehavior
                  Command="{Binding ValidateEmailCommand}"
                    StoppedTypingTimeThreshold="500" /&gt;
                      [2]
            &lt;/Entry.Behaviors&gt;
        &lt;/Entry&gt;</pre>
			<p><code>[1]</code> Only show the label if the name validation fails.</p>
			<p><code>[2]</code> Now, do the same for email as<a id="_idIndexMarker469"/> you did for the name, calling <code>ValidateEmailCommand</code> when the user stops typing:</p>
			<pre class="source-code">
        &lt;Label
            FontSize="13"
            IsVisible="{Binding ShowEmailErrorMessage}"
            Text="{Binding EmailErrorMessage}"
            TextColor="Red" /&gt;
        &lt;Entry
            HorizontalOptions="FillAndExpand"
            IsPassword="True"   [1]
            Keyboard="Default"
            Placeholder="Enter Password"
            Text="{Binding Password}"&gt;
            &lt;Entry.Behaviors&gt;
                &lt;behaviors:UserStoppedTypingBehavior
                Command="{Binding ValidatePasswordCommand}"
                  StoppedTypingTimeThreshold="500" /&gt;
            &lt;/Entry.Behaviors&gt;
        &lt;/Entry&gt;
        &lt;Label
            FontSize="13"
            IsVisible="{Binding ShowPasswordErrorMessage}"
            Text="{Binding PasswordErrorMessage}"
            TextColor="Red" /&gt;
        &lt;Button
            Margin="0,30,0,0"
            BackgroundColor="LightGray"
            Command="{Binding SignUpCommand}" [2]
            CornerRadius="5"
            HorizontalOptions="Center"
            IsEnabled="{Binding EnableButton}"
            Text="Sign up"
            TextColor="Black"
            TextTransform="None"
            WidthRequest="100" /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre>
			<p><code>[1]</code> The <code>IsPassword</code> property of the entry is set to <code>true</code>, and the password will be displayed as a series of asterisks <a id="_idIndexMarker470"/>as a user enters a character.</p>
			<p><code>[2]</code> Once the fields are valid, the <code>Signup</code> command.</p>
			<p>All of the supporting commands and validation are in <code>CreateAccountViewModel</code>.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor210"/>Setting up CreateAccountViewModel</h2>
			<p>The first thing we see in this file are<a id="_idIndexMarker471"/> all the properties:</p>
			<pre class="source-code">
[ObservableProperty] accountService;
[ObservableProperty] private string name;
[ObservableProperty] private string email;
[ObservableProperty] private string password;
[ObservableProperty] private string nameErrorMessage;
[ObservableProperty] private string emailErrorMessage;
[ObservableProperty] private string passwordErrorMessage;
[ObservableProperty] private bool showNameErrorMessage;
[ObservableProperty] private bool showEmailErrorMessage;
[ObservableProperty] private bool showPasswordErrorMessage;
[ObservableProperty] private bool enableButton;
[ObservableProperty] private bool isValidName;
[ObservableProperty] private bool isValidEmail;
[ObservableProperty] private bool isValidPassword;</pre>
			<p>Note that there are properties for the error messages along with the prompts. There is also a Boolean<a id="_idIndexMarker472"/> property, <code>EnableButton</code>, which defaults to <code>false</code> (if you don’t set a Boolean, it defaults to <code>false</code>).</p>
			<p>The constructor takes <code>AccountService</code>, passed in by the IoC (this was registered in <code>MauiProgram.cs</code>). Update the Client constructor to take a string serving as <code>baseUrl</code>:</p>
			<pre class="source-code">
var apiClient = new Client("https://forgetmenotapi
  20230113114628.azurewebsites.net/");
builder.Services.AddSingleton(apiClient);
builder.Services.AddTransient&lt;AccountService&gt;();</pre>
			<p>We’ll turn to the <code>CreateAccountViewModel</code> class:</p>
			<pre class="source-code">
public CreateAccountViewModel(AccountService
  accountService)
{
  this.accountService = accountService;
}</pre>
			<p>Let’s examine a <code>Validation</code> method.</p>
			<p>The business requirement is<a id="_idIndexMarker473"/> that a valid name has at least two characters. The code to validate is a simple <code>if</code> statement, as follows:</p>
			<pre class="source-code">
[RelayCommand]
public Task ValidateName()
{
  if (!string.IsNullOrEmpty(Name) &amp;&amp; Name.Length &gt;= 2)
  {
    IsValidName = true;
    ShowNameErrorMessage = false;
    EnableButton = IsValidName &amp;&amp; IsValidEmail &amp;&amp;
      IsValidPassword; [1]
  }
  else
  {
    NameErrorMessage = "*Please enter a name with at least
      two characters";
    IsValidName = false;
    ShowNameErrorMessage = true;  [2]
    EnableButton = IsValidName &amp;&amp; IsValidEmail &amp;&amp;
      IsValidPassword;
  }
  return Task.CompletedTask;
}</pre>
			<p><code>[1]</code> The <code>EnableButton</code> property (which is used to determine whether the <code>true</code> when the name, email, and password are all valid.</p>
			<p><code>[2]</code> If the name is not valid, the <code>ShowNameErrorMessage</code> property is set to <code>true</code>, and the error message is displayed.</p>
			<p>In the next chapter, we’ll look at the support that .NET MAUI provides for a more elegant validation approach.</p>
			<p>The most important command in this file is the one that responds to <code>SignUpCommand</code>.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor211"/>Handling the SignUp command</h2>
			<p>The <code>SignUp</code> method checks to <a id="_idIndexMarker475"/>ensure that the fields are<a id="_idIndexMarker476"/> valid (by making sure <code>EnableButton</code> is true) and then creates an <code>AccountCreateRequest</code> object, which is defined in <code>ForgetMeNot.Api.Dto</code>:</p>
			<pre class="source-code">
public class AccountCreateRequest
{
    public string FullName { get; set; }
    public string Email { get; set; }
    public string PlainPassword { get; set; }
}</pre>
			<p>It passes that object to the <code>CreateAccount</code> method on <code>accountService</code>. Let’s look at the entire<a id="_idIndexMarker477"/> method in <code>ForgetMeNot.Api.Dto AccountCreateRequest</code>:</p>
			<pre class="source-code">
[RelayCommand]
async Task SignUp()
{
  if (EnableButton)
  {
    AccountCreateRequest = new() [1]
    {
      Email = this.Email,
      FullName = Name,
      PlainPassword = Password
    };
    try
    {
      await accountService.CreateAccount
        (accountCreateRequest); [2]
      await Application.Current.MainPage.DisplayAlert(
        "Sign up  completed",
          "Your user has been created successfully", "Ok");
            [3]
      await Shell.Current.GoToAsync(".."); [4]
    }
    catch (Exception e)
    {
      await Application.Current.MainPage.DisplayAlert("Sign
        up failed",
          "We were not able to create an account with that
            user name", "Ok");
    }
  }
}</pre>
			<p><code>[1]</code> Start by creating <code>AccountCreateRequest</code> object, as explained earlier.</p>
			<p><code>[2]</code> Call <code>CreateAccount</code> on the<a id="_idIndexMarker478"/> service. We’ll look at that method in just a moment.</p>
			<p><code>[3]</code> If everything works, show a dialog box (or, as we did earlier, a toast).</p>
			<p><code>[4]</code> Once a user account has been <a id="_idIndexMarker479"/>created, go back a page to the <strong class="bold">Login</strong> page.</p>
			<p>All that the <code>CreateAccount</code> method in <code>AccountService</code> does is pass along the <code>AccountCreateRequest</code> object to the <code>apiClient</code> <code>CreateAccount</code> method.</p>
			<p>The mechanisms described here are correct as far as they go, but they do not include the invitation response that the final app should have (a user invites a buddy who then creates an account).</p>
			<p>Let’s not forget that we originally created <code>LoginCS</code> as a way to mimic the XAML in C#. You’ll need to fix up <code>LoginCS</code> to match the naming conventions in the XAML file or comment it out altogether, as we are not using it.</p>
			<p>It’s time to run the program and make sure everything we did works. However, sometimes, you will get unexplained build errors when you make this many changes.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor212"/>What to do if it won’t build</h2>
			<p>Assuming you’ve checked all your code, it is correct, and you are getting weird build errors (such as <code>InitializeComponents not found</code>), it may be time to clean everything out. To do so, close Visual<a id="_idIndexMarker480"/> Studio and navigate to the folder where your files are. Delete the <code>bin</code> and <code>obj</code> directories within each project, as shown in <em class="italic">Figure 10</em><em class="italic">.1</em>.</p>
			<div><div><img src="img/Figure_10.1_B19723.jpg" alt="Figure 10.1 – Deleting the bin and obj directories&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Deleting the bin and obj directories</p>
			<p>Follow these steps:</p>
			<ol>
				<li>Restart Visual Studio and immediately select <strong class="bold">Build</strong> | <strong class="bold">Clean Solution</strong> from the menu. Finally, select <strong class="bold">Build</strong> | <strong class="bold">Rebuild Solution</strong>, which forces a complete rebuild rather than <a id="_idIndexMarker481"/>an incremental build. Give your project a moment or two to settle down and run it.</li>
			</ol>
			<p>You should be brought directly to the <strong class="bold">Login</strong> page, as shown in the following figure:</p>
			<div><div><img src="img/Figure_10.2_B19723.jpg" alt="Figure 10.2 – The Login page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The Login page</p>
			<ol>
				<li value="2">Next, click on <code>Placeholder</code> property of the <code>Entry</code> control.</li>
			</ol>
			<div><div><img src="img/Figure_10.3_B19723.jpg" alt="Figure 10.3 – The CreateAccount page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – The CreateAccount page</p>
			<ol>
				<li value="3">Fill in the fields <a id="_idIndexMarker482"/>and click <strong class="bold">Sign up</strong>. Your account will be created on the server, and a dialog box will appear to let you know it worked, as shown in <em class="italic">Figure 10</em><em class="italic">.4</em>.</li>
			</ol>
			<div><div><img src="img/Figure_10.4_B19723.jpg" alt="Figure 10.4 – A successful sign-up&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – A successful sign-up</p>
			<p>If you try to log in, you<a id="_idIndexMarker483"/> will get an <code>unauthorized</code> message. The problem is that the system does not want the username; it wants the user’s email.</p>
			<p class="callout-heading">Unauthorized</p>
			<p class="callout">You will, of course, get an unauthorized message with any bad username or invalid password.</p>
			<p>Let’s fix <code>LoginPage.xaml</code> and log in, as shown in <em class="italic">Figure 10</em><em class="italic">.5</em>.</p>
			<div><div><img src="img/Figure_10.5_B19723.jpg" alt="Figure 10.5 – Logging in with our new account&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Logging in with our new account</p>
			<p>When the login is<a id="_idIndexMarker484"/> authenticated, you are taken directly to the home page.</p>
			<p>It is important to note and revel in the fact that the account creation and the authentication both take place in the cloud via the API.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor213"/>Summary</h1>
			<p>In this chapter, we reviewed how to interact with an API. We gained insight into the internals of that interaction by examining the API domain and DTO projects, and we saw how the <code>APIClient</code> class wraps all the API calls to make life easier and more intuitive on the client side.</p>
			<p>This is a reasonably advanced topic, and in the next chapter, we will dive into even more advanced topics to move you from being a novice .NET MAUI programmer to an expert.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor214"/>Quiz</h1>
			<ol>
				<li value="1">What is a DTO?</li>
				<li>Why don’t we need a local SQLite database?</li>
				<li>What does the API Client class do?</li>
				<li>Where does account creation occur?</li>
				<li>Where does authentication occur?</li>
			</ol>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor215"/>You try it</h1>
			<p>Implement the <em class="italic">Forgot Password</em> client-side code.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>